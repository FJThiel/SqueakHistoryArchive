'From Squeak2.6 of 11 October 1999 [latest update: #1723] on 23 December 1999 at 3:24:28 pm'!"Change Set:		SqEnvtFixes2Date:			16 December 1999Author:			Dan IngallsRemoves the need for backdoor access to environments via doesNotUnderstand:, and removes that mechanism as well.Extends the compatibility hack presently supporting Legacy code of the form	Smalltalk at: aSymbolto support Legacy code of the form	Smalltalk at: aSymbol ifAbsent: aBlock	(Thanks to Andrew Greenberg).Removes dashes from intra-package category names in packageBrowser.Environments now know their own name.ReorganizeEverything now moves existing pools into sub-environements if appropriate.	It now begins with a saveAs to avoid interference with normal work.	It also records all edits in a separate change set, and makes a new one at the end.SharedPool names are printed properly if pool is in a sub-environment.Superclass name in class def is printed with proper scoping.Can now add and remove classes in subEnvironments.	Requires a prefix to the superclass if it is not a Kernel class but this will soon be fixed."!SystemDictionary subclass: #Environment	instanceVariableNames: 'envtName outerEnvt '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!!Browser methodsFor: 'class functions' stamp: 'di 12/23/1999 11:53'!defineClass: defString notifying: aController 	"The receiver's textual content is a request to define a new class. The 	source code is defString. If any errors occur in compilation, notify 	aController."	| oldClass class newClassName defTokens keywdIx envt |	oldClass _ self selectedClassOrMetaClass.	defTokens _ defString findTokens: Character separators.	keywdIx _ defTokens indexOf: 'category:'.	envt _ Smalltalk environmentForCategory: ((defTokens at: keywdIx+1) copyWithout: $').	keywdIx _ defTokens findFirst: [:x | x endsWith: 'ubclass:'].	newClassName _ (defTokens at: keywdIx+1) copyWithout: $#.	((oldClass isNil or: [oldClass name asString ~= newClassName])		and: [envt includesKeyOrAbove: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	"ar 8/29/1999: Use oldClass superclass for defining oldClass	since oldClass superclass knows the definerClass of oldClass."	oldClass ifNotNil:[oldClass _ oldClass superclass].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: 			[self changed: #classList.			self classListIndex: 				(self classList indexOf: 					((class isKindOf: Metaclass)						ifTrue: [class soleInstance name]						ifFalse: [class name])).			self clearUserEditFlag; editClass.			^true]		ifFalse: [^false]! !!ClassBuilder methodsFor: 'class definition' stamp: 'di 12/23/1999 15:23'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force |	environ _ env.	instVars _ Scanner new scanFieldNames: instVarString.	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass _ env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: newSuper 		type: type 		instanceVariables: instVars		from: oldClass		unsafe: unsafe.	newClass == nil ifTrue:[^nil]. "Some error"	newClass == oldClass ifFalse:[newClass setName: className].	"Install the class variables and pool dictionaries... "	force _ (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	organization _ environ ifNotNil:[environ organization].	organization classify: newClass name under: category asSymbol.	newClass environment: environ.	"... recompile ..."	newClass _ self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		environ at: newClass name put: newClass.		Smalltalk flushClassNameCache.	].	"... and fix eventual references to obsolete globals."	oldClass _ nil. "So we have no references to the old class anymore"	self fixGlobalReferences.	self doneCompiling: newClass.	^newClass! !!ClassDescription methodsFor: 'printing' stamp: 'di 12/19/1999 14:37'!sharedPoolsString	"Answer a string of my shared pool names separated by spaces."	| aStream |	aStream _ WriteStream on: (String new: 100).	self sharedPools do: [:x | aStream nextPutAll: (self environment keyAtIdentityValue: x ifAbsent: ['private']); space].	^ aStream contents! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 12/19/1999 21:24'!definition	"Answer a String that defines the receiver."	| aStream path |	aStream _ WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'nil']		ifFalse: [path _ ''.				self environment scopeFor: superclass name from: nil						envtAndPathIfFound: [:envt :remotePath | path _ remotePath].				aStream nextPutAll: path , superclass name].	aStream nextPutAll: self kindOfSubclass.	self name storeOn: aStream.	aStream cr; tab; nextPutAll: 'instanceVariableNames: '.	aStream store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: '.	aStream store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: '.	aStream store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: '.	(SystemOrganization categoryOfElement: self name) asString storeOn: aStream.	^aStream contents! !!Class methodsFor: 'initialize-release' stamp: 'di 12/20/1999 12:37'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self environment removeClassFromSystem: self.	self obsolete! !!Class methodsFor: 'organization' stamp: 'di 12/23/1999 11:42'!environment: anEnvironment	environment _ anEnvironment! !!PackageBrowser methodsFor: 'system category list' stamp: 'di 12/20/1999 20:16'!selectedSystemCategoryName	"Answer the name of the selected system category or nil."	systemCategoryListIndex = 0		ifTrue: [^nil].	packageListIndex = 0		ifTrue: [^ self systemCategoryList at: systemCategoryListIndex].	^ self package , '-' , (self systemCategoryList at: systemCategoryListIndex)! !!PackageBrowser methodsFor: 'system category list' stamp: 'di 12/16/1999 16:14'!systemCategoryList	"Answer the sequenceable collection containing the class categories that 	the receiver accesses."	| prefix |	packageListIndex = 0 ifTrue: [^ systemOrganizer categories].	prefix := self package, '-'.	^ Array streamContents:		[:strm |		systemOrganizer categories do: 			[ :cat | (cat beginsWith: prefix) ifTrue:				[strm nextPut: (cat copyFrom: prefix size + 1 to: cat size)]]]! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/21/1999 12:00'!atOrAbove: key ifAbsent: absentBlock	"Compatibility with environment protocol."	^ self at: key ifAbsent: absentBlock! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/21/1999 12:00'!includesKeyOrAbove: key	"Compatibility with environment protocol."	self atOrAbove: key ifAbsent: [^ false].	^ true! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/19/1999 21:17'!scopeFor: varName from: lower envtAndPathIfFound: envtAndPathBlock	"Null compatibility with partitioning into environments."	(self includesKey: varName)		ifTrue: [^ envtAndPathBlock value: self value: String new]		ifFalse: [^ nil]! !!Environment methodsFor: 'instance creation' stamp: 'di 12/18/1999 15:12'!makeSubEnvironmentNamed: name	"Make a new environment (with its own class) of the given name.	Install it under that name in this environment, and point its outerEnvt link here as well."	| envtClass envt |	envtClass _ self class subclass: (name , 'Environment') asSymbol				instanceVariableNames: '' classVariableNames: ''				poolDictionaries: '' category: 'System-Environments'.	envt _ envtClass new setName: name inOuterEnvt: self.	envtClass addSharedPool: envt.  "add it to its own compilation context for exports"	^ envt! !!Environment methodsFor: 'instance creation' stamp: 'di 12/18/1999 15:26'!setName: name inOuterEnvt: outer	outerEnvt _ outer.	envtName _ name asSymbol.	outerEnvt ifNotNil:		[outerEnvt at: envtName put: self].  "install me in parent by name"! !!Environment methodsFor: 'dictionary access' stamp: 'acg 12/11/1999 02:15'!at: key ifAbsent: aBlock	"Compatibility hack for starting up Environments"	^ self atOrBelow: key ifAbsent: aBlock! !!Environment methodsFor: 'dictionary access' stamp: 'di 12/21/1999 13:03'!environmentForCategory: catString	"Smalltalk environmentForCategory:'Morphic'"	"Accepts a category name which may be a symbol or a string,	and which may have trailing parts of the form '-zort'.	Returns the environment object of that name."	| catName envt |	catName _ (catString copyUpTo: $-) asSymbol.	(Smalltalk kernelCategories includes: catName)		ifTrue: [^ Smalltalk].	envt _ Smalltalk at: catName ifAbsent:		[(self confirm: 'Use of the category name' , catName , 'implies the need to create a new system category.Is this what you wish to do?')			ifFalse: [self error: 'dismiss me'].		Smalltalk makeSubEnvironmentNamed: catName].	(envt isKindOf: Environment) ifFalse:		[self error: catName , ' cannot be used as an environment name.'].	^ envt! !!Environment methodsFor: 'dictionary access' stamp: 'di 12/19/1999 16:54'!scopeFor: varName from: lower envtAndPathIfFound: envtAndPathBlock	"Look up varName here or in any sub-environments, and also in any sub-environments of the outer environment.  If found, evaluate pathBlock with a string giving the path for the access, and return the environment in which the variable was found.  Return nil if the variable is not found.	lower ~= nil prevents revisiting lower parts of the tree in outer traversal."	| envt |	"Might be right here -- null path."	(self includesKey: varName) ifTrue:		[^ envtAndPathBlock value: self value: String new].	"Might be in a sub-environment -- append envt name to downward path."	self associationsDo:		[:assn |		(((envt _ assn value) isKindOf: Environment)			and: [envt ~~ self and: [envt ~~ lower]]) ifTrue:				[envt scopeFor: varName from: nil envtAndPathIfFound:						[:subEnvt :subPath |						^ envtAndPathBlock value: subEnvt value: assn key , ' ' , subPath]]].	"If not found, traverse outer environment."	outerEnvt ifNil: [^ nil].	subEnvt _ outerEnvt scopeFor: varName from: self envtAndPathIfFound:						[:subEnvt :subPath |						^ envtAndPathBlock value: subEnvt value: subPath].! !!Environment methodsFor: 'system conversion' stamp: 'di 12/23/1999 12:29'!rewriteIndirectRefs   "Smalltalk rewriteIndirectRefs"	"For all classes, identify all methods with references to globals outside their direct access path.	For each of these, call another method to rewrite the source with proper references."	| cm lits envtForVar envt foundOne allClasses n |	envtForVar _ Dictionary new.  "Dict of varName -> envt name"	Smalltalk associationsDo:		[:assn | (((envt _ assn value) isKindOf: Environment) and: [envt size < 500])			ifTrue: [envt associationsDo:						[:a | envtForVar at: a key put: assn key]]].	"Allow compiler to compile refs to globals out of the direct reference path"	Preferences enable: #lenientScopeForGlobals.	allClasses _ OrderedCollection new.	Smalltalk allClassesAnywhereDo: [:cls | allClasses addLast: cls].	'Updating indirect global references in source code...'		displayProgressAt: Sensor cursorPoint		from: 0 to: allClasses size		during:		[:bar | n _ 0.		allClasses do:			[:cls | bar value: (n_ n+1).			{ cls. cls class } do:				[:cl | cl selectors do:					[:sel | cm _ cl compiledMethodAt: sel.					lits _ cm literals.					foundOne _ false.					lits do:						[:lit | lit class == Association ifTrue:							[(lit value == cl or: [cl scopeHas: lit key ifTrue: [:ignored]])								ifFalse: [foundOne _ true]]].					foundOne ifTrue:						[self rewriteSourceForSelector: sel inClass: cl using: envtForVar]]].			]].	Preferences disable: #lenientScopeForGlobals.! !!Environment methodsFor: 'system conversion' stamp: 'di 12/16/1999 14:58'!rewriteSourceForSelector: selector inClass: aClass using: envtForVar	"Rewrite the source code for the method in question so that all global references out of the direct access path are converted to indirect global references.  This is done by parsing the source with a lenient parser able to find variables in any environment.  Then the parse tree is consulted for the source code ranges of each reference that needs to be rewritten and the pattern to which it should be rewritten.  Note that assignments, which will take the form	envt setValueOf: #GlobalName to: ...may generate spurious message due to agglutination of keywords with the value expression."	| code methodNode edits varName envtName envt |	code _ aClass sourceCodeAt: selector.	methodNode _ Compiler new parse: code in: aClass notifying: nil.	edits _ OrderedCollection new.	methodNode encoder globalSourceRanges do:		[:tuple |   "{ varName. srcRange. store }"		(aClass scopeHas: (varName _ tuple first asSymbol) ifTrue: [:ignored]) ifFalse:			["This is a remote global.  Add it as reference to be edited."			edits addLast: { varName. tuple at: 2. tuple at: 3 }]].	"Sort the edits by source position."	edits _ edits asSortedCollection: [:a :b | a second first < b second first].	edits reverseDo:		[:edit | varName _ edit first.		(envtName _ envtForVar at: varName ifAbsent: [nil]) ifNotNil:			["If varName is not already exported, define an export method"			envt _ self at: envtName.			(envt class includesSelector: varName) ifFalse:				[envt class compile: (self exportMethodFor: varName)						 classified: 'exports'].			"Replace each access out of scope with a proper remote reference"			code _ code copyReplaceFrom: edit second first						to: edit second last						with: envtName , ' ' , varName]].	aClass compile: code classified: (aClass organization categoryOfElement: selector)! !!Environment methodsFor: 'system conversion' stamp: 'di 12/23/1999 11:46'!transferBindingsNamedIn: nameList from: otherEnvt	| cls |	nameList do:		[:name |		cls _ otherEnvt at: name.		self add: (otherEnvt associationAt: name).		cls environment: self.		otherEnvt removeKey: name].! !!Environment methodsFor: 'printing' stamp: 'di 12/18/1999 15:19'!name	^ envtName ifNil: ['Environment ' , self hash printString]! !!Environment methodsFor: 'printing' stamp: 'di 12/18/1999 15:18'!printOn: aStream	aStream nextPutAll: 'An Environment'.	envtName ifNotNil: [aStream nextPutAll: ' named ' , envtName]! !!Environment methodsFor: 'fileIn/out' stamp: 'di 12/18/1999 15:19'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <my name>.seg."| is roots |is _ ImageSegment new.is segmentName: self name.roots _ (self select: [:global | global class class == Metaclass]) values asOrderedCollection.roots copy do: [:cls | roots add: cls class].roots add: self.is copyFromRootsLocalFileFor: roots sizeHint: 0.is state = #tooBig ifTrue: [^ false].is extract.is state = #active ifFalse: [^ false].is writeToFile: is segmentName.^ true! !!Environment class methodsFor: 'system conversion' stamp: 'di 12/23/1999 12:43'!reorganizeEverything	"Environment reorganizeEverything."	| bigCat envt pool s |	PopUpMenu notify: 'You are about to be asked to do a SaveAs...Give it a name like EnvtTest so that this experimental imagedoes not overwrite your normal one.'.	Smalltalk saveAs.	Smalltalk newChanges: (ChangeSet new initialize name: 'Reorganization').	"Recreate the Smalltalk dictionary as the top-level Environment."	Smalltalk _ SmalltalkEnvironment newFrom: Smalltalk.	Smalltalk setName: #Smalltalk inOuterEnvt: nil.	"Don't hang onto old copy of Smalltalk ."	Smalltalk recreateSpecialObjectsArray.	"Store values for environment and category in each class."	Smalltalk allClassesDo:		[:c | c environment: nil. "Flush any old values"].	"Run through all categories making up new sub-environments"	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			["Not a kernel category ..."			envt _ Smalltalk at: bigCat						ifAbsent: ["... make up a new environment if necessary ..."									Smalltalk makeSubEnvironmentNamed: bigCat].			"... and install the member classes in that category"			envt transferBindingsNamedIn: (SystemOrganization listAtCategoryNamed: cat)									from: Smalltalk].		].	"Move all shared pools that are only referred to in sub environments"	Smalltalk associationsDo:		[:assn | ((pool _ assn value) isMemberOf: Dictionary) ifTrue:			[s _ IdentitySet new.			Smalltalk allClassesAnywhereDo:				[:c | c sharedPools do:					[:p | p == pool ifTrue:						[s add: c environment]]].			(s size = 1 and: [(envt _ s someElement) ~~ Smalltalk]) ifTrue:				[envt declare: assn key from: Smalltalk]]].	Smalltalk rewriteIndirectRefs.	Smalltalk newChanges: (ChangeSet new initialize name: 'PostReorganization').	ChangeSorter gatherChangeSets.	Preferences enable: #browserShowsPackagePane.! !Class removeSelector: #category!Class removeSelector: #environment:category:!Environment removeSelector: #basicName!Environment removeSelector: #doesNotUnderstand:!Environment removeSelector: #setOuterEnvt:!