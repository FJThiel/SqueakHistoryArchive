'From Squeak2.9alpha of 12 June 2000 [latest update: #3106] on 1 December 2000 at 3:19:01 pm'!"Change Set:		CorrectionTweakDate:			1 December 2000Author:			Dan IngallsA minor rework of Squeak's symbol corrector.  It eliminates the old two-tier correction, trying hard from the start, and showing you up to 10 alternatives.By employing a different early filter on the candidates, it now accomplishes the full correction in the same time as the old simple correction."!!Parser methodsFor: 'error correction' stamp: 'di 12/1/2000 14:39'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ Symbol possibleSelectorsFor: proposedKeyword.	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	((proposedKeyword last ~~ $:) and: [correctSelector last == $:]) ifTrue: [		^ abortAction value].	^ correctSelector.! !!String methodsFor: 'private' stamp: 'di 12/1/2000 14:55'!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."	| choices scoreMin results score maxChoices |	scoreMin _ self size // 2 min: 3.	maxChoices _ 10.	oldCollection isNil		ifTrue: [ choices _ SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifFalse: [ choices _ oldCollection ].	wordBlock isNil		ifTrue:			[ results _ OrderedCollection new.			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]		ifFalse:			[ wordBlock value: [ :word |				(score _ self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= maxChoices) ifTrue: [ scoreMin _ (choices at: maxChoices) value] ] ].			results _ choices ].	^ results! !!String methodsFor: 'system primitives' stamp: 'di 12/1/2000 13:53'!numArgs	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector.  Note that currently this will answer -1 for anything begining with an uppercase letter even though the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."	| firstChar numColons excess ch |	self size = 0 ifTrue: [^ -1].	firstChar _ self at: 1.	(firstChar isLetter or: [firstChar = $:]) ifTrue:		[firstChar isUppercase ifTrue: [ ^ -1 ].		numColons _ 0. 		1 to: self size do:			[:i | ch _ self at: i.			ch = $: ifTrue: [numColons _ numColons + 1]					ifFalse: [(ch isLetter or: [ch isDigit]) ifFalse: [^ -1]]].		numColons = 0 ifTrue: [^ 0].		firstChar = $:			ifTrue: [excess _ 2 "Has an initial keyword, as #:if:then:else:"]			ifFalse: [excess _ 0].		self last = $:			ifTrue: [^ numColons - excess]			ifFalse: [^ numColons - excess - 1 "Has a final keywords as #nextPut::andCR"]].	firstChar isSpecial ifTrue:		[self size = 1 ifTrue: [^ 1].		2 to: self size do: [:i | (self at: i) isSpecial ifFalse: [^ -1]].		^ 1].	^ -1.! !!Symbol class methodsFor: 'private' stamp: 'di 12/1/2000 15:09'!possibleSelectorsFor: misspelled	"Answer an ordered collection of possible corrections	for the misspelled selector in order of likelyhood"	| numArgs candidates lookupString best binary short long |	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs _ lookupString numArgs.	numArgs < 0 ifTrue: [^ OrderedCollection new: 0].	short _ lookupString size - (lookupString size // 4 max: 3) max: 2.	long _ lookupString size + (lookupString size // 4 max: 3).	"First assemble candidates for detailed scoring"	candidates _ OrderedCollection new.	SymbolTable do:		[:s | ((s size between: short and: long) and: [s numArgs = numArgs])			ifTrue: [candidates add: s]].	"Then further prune these by correctAgainst:"	best _ lookupString correctAgainst: candidates.	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [		binary _ misspelled, ':'.		"try for missing colon"		Symbol hasInterned: binary ifTrue: [:him | best addFirst: him]].	^ best! !Symbol class removeSelector: #morePossibleSelectorsFor:!Parser removeSelector: #correctSelector:wordIntervals:exprInterval:ifAbort:fullSearch:!