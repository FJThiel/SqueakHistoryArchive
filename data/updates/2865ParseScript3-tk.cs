'From Squeak2.9alpha of 16 June 2000 [latest update: #2912] on 29 October 2000 at 12:25:28 am'!"Change Set:		ParseScript3-tkDate:			28 October 2000Author:			Ted KaehlerOutline in light brown any tile that can be picked up or grabbed.  Outline in green the places where a tile held in the hand may be dropped.  Executing 	Preferences enable: #noTileColorwill suppress tile colors and suppress borders on all but a few kinds of tiles.  This gives a sparse look to a script."!MessageNode subclass: #MessagePartNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Bob-Syntax'!!BlockNode methodsFor: 'tiles' stamp: 'tk 10/26/2000 16:41'!asMorphicSyntaxIn: parent	| len shown row column ww |	(column _ parent addColumn: #block on: self) inset: 4; minBorderWidth: 1.		"level _ 1 max: levelOrZero."	self addCommentToMorph: column.	len _ shown _ statements size.	column explanation: 'A block of ',len printString,' Smalltalk statements',(		arguments size = 0 ifTrue: [''] ifFalse: [' and ',arguments size printString,' arguments']	).		"(levelOrZero = 0 and: [statements last isReturnSelf]) ifTrue: [shown _ 1 max: shown - 1]."	arguments size = 0 ifFalse: [		row _ column addRow: #blockarg1 on: (BlockArgsNode new).		arguments do: [:arg | 			(arg asMorphicSyntaxIn: row) color: #blockarg2		].	].	ww _ (Preferences valueOfFlag: #noTileColor) ifTrue: [1] ifFalse: [0].	(statements copyFrom: 1 to: shown) do: [ :each | 		(each asMorphicSyntaxIn: column) borderWidth: ww.		each addCommentToMorph: column.	] separatedBy: [		column addMorphBack: (			AlignmentMorph newRow 				vResizing: #rigid; 				color: Color transparent;				extent: 2@2		).			].	^column! !!Inspector methodsFor: 'selecting' stamp: 'tk 10/27/2000 14:59'!selectedSlotName	^ self fieldList at: selectionIndex! !!MessageNode methodsFor: 'initialize-release' stamp: 'tk 10/26/2000 15:37'!selector: sel	selector _ sel! !!MessageNode methodsFor: 'equation translation' stamp: 'tk 10/27/2000 15:11'!arguments: list	arguments _ list! !!MessageNode methodsFor: 'tiles' stamp: 'tk 10/27/2000 15:14'!morphFromKeywords: key arguments: args on: parent indent: ignored	| keywords arg thisKey column row selType explanation receiverString getMenuBlock ww |	getMenuBlock _ [ :aClass | self buildMenuForClass: aClass andSelector: key].	receiver ifNotNil: [	"i.e. not a cascade"		receiver asMorphicSyntaxIn: parent.	].	parent getMenuBlock: getMenuBlock.	keywords _ key keywords.	selType _ precedence asPrecedenceName.	receiverString _ receiver ifNil: [		''	] ifNotNil: [		' sent to ',receiver explanation	].	args size = 0 ifTrue: [		row _ parent 			addTextRow: key getMenuBlock: getMenuBlock explanation: nil.		parent explanation: selType,' message #',keywords first,receiverString.		^ row parseNode: selector.	].	args size = 1 ifTrue: [		row _ parent 			addTextRow: keywords first  			getMenuBlock: getMenuBlock			explanation: selType,' selector'.		row parseNode: selector.		args first asMorphicSyntaxIn: parent.		parent explanation: selType,' message #', keywords first, ' with an argument ',					args first explanation, receiverString.		"(args first asMorphicSyntaxIn: parent)			explanation: selType,' message #',keywords first,' with an argument ',					args first explanation,receiverString."		^self	].		explanation _ 'A keyword message #',key,				' with ',keywords size printString,' arguments'.	column _ parent addColumn: #keyword1 on: self.	column explanation: explanation;  getMenuBlock: getMenuBlock.	ww _ (Preferences valueOfFlag: #noTileColor) ifTrue: [1] ifFalse: [0].	1 to: keywords size do: [:part |		arg _ args at: part.		thisKey _ keywords at: part.		(row _ column addRow: #keyword2 on: self)			borderWidth: ww;			parseNode: (self as: MessagePartNode);			borderColor: row stdBorderColor.		(row addTextRow: thisKey) parseNode: (KeyWordNode new).		arg asMorphicSyntaxIn: row.	].	explanation _ explanation,receiverString.	parent explanation: explanation.! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/25/2000 14:47'!acceptDroppingMorph: aMorph event: evt	| itNoun |	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks.  see wantsDroppedMorph:event:"	"We know it is acceptable.  Just a matter of which case"	itNoun _ aMorph isNoun.	(parseNode class == BlockNode) & itNoun ifTrue: [		 (aMorph parseNode class == TempVariableNode) 			ifTrue: ["If I am a BlockNode, and it is a TempVariableNode, add it into list"				^ (self addBlockArg: aMorph) ifFalse: [						self addToBlock: aMorph event: evt]]	"if already declared, start new line of code with it"			ifFalse: [^ self addToBlock: aMorph event: evt]].				"If I am a BlockNode and it is a noun add it as a new line"	(parseNode class == BlockNode) ifTrue: [		 (aMorph parseNode class == ReturnNode) ifTrue: [^ self addToBlock: aMorph event: evt]].	"Later add args and keywords.  later allow comments to be dropped"	"Can't put statement, literal, assignment, or cascade into left side of assignment"	(owner respondsTo: #parseNode) ifTrue: [		owner parseNode class == AssignmentNode ifTrue: [			(owner submorphIndexOf: self) = 1 ifTrue: [				(#(TempVariableNode VariableNode) includes: aMorph parseNode class name) ifFalse: [					^ self]]]].	owner replaceSubmorph: self by: aMorph.	"do the normal replacement"	aMorph setAllBorders.	aMorph owner layoutChanged.! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/25/2000 14:51'!addBlockArg: aMorph	| tempHolder tt var nn row |	"Add a temporary to a block or the method.  Return true if succeed"	self setAllBorders.	owner parseNode class == MethodNode ifTrue: [		^ (self addTempVar: aMorph)].	"Node for them is not insided the block"		"If exists, drop the temp in this block and let use extend it."	tt _ self firstSubmorph.	tempHolder _ tt firstSubmorph class == SyntaxMorph 				ifTrue: [tt parseNode class == BlockArgsNode 							ifTrue: [tt] ifFalse: [nil]]				ifFalse: [nil].	nn _ (aMorph allMorphs detect: [:rr | rr class == StringMorph]) contents.	"name"	tempHolder ifNil: ["make whole row"		row _ self addRow: #blockarg1 on: (BlockArgsNode new).		self addMorphFront: row.		aMorph parseNode name: nn key: nn code: nil.		var _ row addColumn: #tempVariable on: aMorph parseNode.		var inset: 1.		var addMorphBack: (StringMorph contents: nn).		^ true].	tempHolder ifNotNil: [		"If this variable is not present, add it"		tempHolder allMorphs do: [:rr | 					rr class == StringMorph ifTrue: [rr contents = nn ifTrue: [^ false]]].				"is present. caller adds the temp as a new line of code to be extended"		aMorph parseNode name: nn key: nn code: nil.		var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.		var inset: 1.		var addMorphBack: (StringMorph contents: nn).		^ true].! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 16:44'!addTextRow: aStringLikeItem	| row text ww |	ww _ (Preferences valueOfFlag: #noTileColor) ifTrue: [1] ifFalse: [0].	(row _ self class row: #text on: nil) borderWidth: ww.	text _ "NonEditableTextMorph" StringMorph contents: 		(aStringLikeItem copyWithout: Character cr).	row addMorph: text.	self addMorphBack: row.	^row! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 16:36'!addTextRow: aStringLikeItem getMenuBlock: aBlock explanation: aString	| row text ww |	ww _ (Preferences valueOfFlag: #noTileColor) ifTrue: [1] ifFalse: [0].	(row _ self class row: #text on: nil) borderWidth: ww.	text _ "NonEditableTextMorph" StringMorph new contents: aStringLikeItem.	row addMorph: text.	self addMorphBack: row.	row		getMenuBlock: aBlock;		explanation: aString.	^row! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/25/2000 14:51'!addToBlock: aMorph event: evt	"Insert a new line of code"	| whereDropped dropBefore |	self setAllBorders.	whereDropped _ "self pointFromWorld:" evt cursorPoint.	dropBefore _ self submorphs 		detect: [ :each | (each isKindOf: SyntaxMorph) and: 							[whereDropped y < each center y]] 		ifNone: [nil].	(aMorph parseNode class == ReturnNode) ifTrue: [dropBefore _ nil].		"Returns are always at the end. (Watch out for comments)"	dropBefore 		ifNil: [self addMorphBack: aMorph]		ifNotNil: [self addMorph: aMorph inFrontOf: dropBefore].	self addMorph: (			AlignmentMorph newRow 				vResizing: #rigid; 				color: Color transparent;				extent: 2@2)		behind: aMorph.	self layoutChanged.! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/25/2000 14:42'!cleanup! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 16:58'!handlesMouseOver: evt	"Am I a tile that could be picked up?"	^ true! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/25/2000 15:02'!handlesMouseOverDragging: evt	| tile |	(tile _ evt hand firstSubmorph) class == SyntaxMorph ifFalse: [^ false].	^ self wantsDroppedMorph: tile event: evt! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 19:57'!mouseEnter: evt	"Try to highlight the tiles we could pick up"	self borderColor: self class grabTargetColor.	self setAllBorders.! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 16:49'!mouseEnterDragging: evt	"Try to highlight places the hand's morph could land"	self borderColor: self class dropTargetColor.	self setAllBorders.! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 19:58'!mouseLeave: evt	| oo |	"Try to highlight tiles we could pick up"	self borderColor: self stdBorderColor.	oo _ owner.	[oo respondsTo: #parseNode] whileTrue: [		(oo handlesMouseOver: evt) ifTrue: [			oo borderColor: self class grabTargetColor.			^ oo setAllBorders].	"clear above me, not needed"		oo _ oo owner].! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 16:50'!mouseLeaveDragging: evt	| oo |	"Try to highlight places the hand's morph could land"	self borderColor: self stdBorderColor.	oo _ owner.	[oo respondsTo: #parseNode] whileTrue: [		(oo handlesMouseOverDragging: evt) ifTrue: [			oo borderColor: self class dropTargetColor.			^ oo setAllBorders].	"clear above me, not needed"		oo _ oo owner].! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 20:17'!setAllBorders	| oo |	"put it back after highlighting"	oo _ owner.	[oo respondsTo: #parseNode] whileTrue: [oo setBorder.  oo _ oo owner].! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 15:16'!setBorder	"put it back after highlighting"	self borderColor: self stdBorderColor.! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 15:26'!stdBorderColor	"several choices of how to do the border"	(Preferences valueOfFlag: #noTileColor) 		ifTrue: [			parseNode class == MessagePartNode ifTrue: [^ color darker].			parseNode class == BlockArgsNode ifTrue: [^ color darker].			parseNode class == MethodTempsNode ifTrue: [^ color darker].			^ color]		ifFalse: [^ color darker]! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 15:59'!step	| ok |	"Open up a space for a tile to fall in a block"	super step."	ok _ parseNode class == BlockNode.	ok ifFalse: [^ self cleanup].	self world currentHand submorphs size = 0 ifTrue: [^ self cleanup]."! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 15:23'!column: aColor on: aParseNode	| c color |	color _ self translateColor: aColor.	(c _ self newColumn)		parseNode: aParseNode;		inset: self standardInset;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: color;		borderWidth: 1;		borderColor: c stdBorderColor;		centering: #topLeft.	^c! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 16:50'!dropTargetColor	^ Color green darker! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 10/27/2000 15:23'!grabTargetColor	^ Color r: 0.796 g: 0.564 b: 0.421     "Color paleOrange mixed: 0.5 with: Color brown"! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 15:23'!row: aColor on: aParseNode	| r color |	color _ self translateColor: aColor.	(r _ self newRow)		parseNode: aParseNode;		inset: self standardInset;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: color;		borderWidth: 1;		borderColor: r stdBorderColor;		centering: #center.	^r! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 10/26/2000 20:01'!translateColor: aColorOrSymbol	aColorOrSymbol == #comment  ifTrue: [^ Color blue lighter].	(Preferences valueOfFlag: #noTileColor) ifTrue: [^ Color paleOrange].	"override"	aColorOrSymbol == #assignment  ifTrue: [^ Color paleGreen].	aColorOrSymbol == #block  ifTrue: [^ Color lightBlue darker].	aColorOrSymbol == #keyword1  ifTrue: [^ Color paleBuff].	aColorOrSymbol == #keyword2  ifTrue: [^ Color paleBuff lighter].	aColorOrSymbol == #cascade  ifTrue: [^ Color paleYellow darker].	aColorOrSymbol == #cascade2  ifTrue: [^ Color paleOrange].	aColorOrSymbol == #literal  ifTrue: [^ Color paleMagenta].	aColorOrSymbol == #message  ifTrue: [^ Color paleYellow].	aColorOrSymbol == #method  ifTrue: [^ Color white].	aColorOrSymbol == #text  ifTrue: [^ Color transparent].	aColorOrSymbol == #error  ifTrue: [^ Color red].	aColorOrSymbol == #return  ifTrue: [^ Color lightGray].	aColorOrSymbol == #variable  ifTrue: [^ Color paleTan].	aColorOrSymbol == #brace  ifTrue: [^ Color paleOrange].	aColorOrSymbol == #tempVariable  ifTrue: [^ Color paleYellow mixed: 0.75 with: Color paleGreen		"Color yellow lighter lighter"].	aColorOrSymbol == #blockarg2  ifTrue: [			^ Color paleYellow mixed: 0.75 with: Color paleGreen].	"arg itself"	aColorOrSymbol == #blockarg1  ifTrue: [^ Color paleRed].	"container"		"yellow mixed: 0.5 with: Color white"	^aColorOrSymbol! !