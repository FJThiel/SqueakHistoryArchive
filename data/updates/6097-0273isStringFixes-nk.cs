'From Squeakland 3.8.5976 of 25 August 2004 [latest update: #267] on 30 August 2004 at 8:10:06 am'!"Change Set:		isStringFixes-nkDate:			30 August 2004Author:			Ned KonzChanges to the String hierarchy caused a number of tests of the form	isKindOf: Stringto be suspect or wrong. In some places, other kinds of Strings (MultiString or MultiSymbol) may now be encountered.This changeSet changes a number of callers of 'isKindOf: String' to use isString instead. This is also a bit faster (not that either is particularly slow):a := ''.Time millisecondsToRun: [ 1000000 timesRepeat: [ a isKindOf: String ]] => 253Time millisecondsToRun: [ 1000000 timesRepeat: [ a isString ]] => 143"!!ClassDescription methodsFor: 'organization' stamp: 'nk 8/30/2004 07:48'!category: cat 	"Categorize the receiver under the system category, cat, removing it from 	any previous categorization."	| oldCat |	oldCat := self category.	(cat isString)		ifTrue: [SystemOrganization classify: self name under: cat asSymbol]		ifFalse: [self errorCategoryName].	SystemChangeNotifier uniqueInstance class: self recategorizedFrom: oldCat to: cat asSymbol! !!Collection methodsFor: 'testing' stamp: 'nk 8/30/2004 07:49'!includesSubstringAnywhere: testString	"Answer whether the receiver includes, anywhere in its nested structure, a string that has testString as a substring"	self do:		[:element |			(element isString)				ifTrue:					[(element includesSubString: testString) ifTrue: [^ true]].			(element isCollection)				ifTrue:					[(element includesSubstringAnywhere: testString) ifTrue: [^ true]]].	^ false"#(first (second third) ((allSentMessages ('Elvis' includes:)))) includesSubstringAnywhere:  'lvi'"! !!FlashBoundaryShape methodsFor: 'disk i/o' stamp: 'nk 8/30/2004 07:49'!compress	(points isOctetString) ifFalse:[		points _ FlashCodec compress: self.		leftFills _ rightFills _ lineWidths _ lineFills _ fillStyles _ nil].! !!FlashBoundaryShape methodsFor: 'disk i/o' stamp: 'nk 8/30/2004 07:49'!decompress	| newShape |	(points isOctetString) ifTrue:[		newShape _ FlashCodec decompress: (ReadStream on: points).		points _ newShape points.		leftFills _ newShape leftFills.		rightFills _ newShape rightFills.		lineWidths _ newShape lineWidths.		lineFills _ newShape lineFills.		fillStyles _ newShape fillStyles].! !!HTTPLoader methodsFor: 'requests' stamp: 'nk 8/30/2004 07:50'!retrieveObjectsFor: aURL	"Load a remote image segment and extract the root objects.	Check if the remote file is a zip archive."	"'http://bradley.online.disney.com/games/subgame/squeak-test/assetInfo.extSeg' 		asUrl loadRemoteObjects" 	"'http://bradley.online.disney.com/games/subgame/squeak-test/assetInfo.zip' 		asUrl loadRemoteObjects" 	| stream info data | 	data _ self retrieveContentsFor: aURL.	(data isString)		ifTrue: [^self error: data]		ifFalse: [data _ data content].	(data beginsWith: 'error')		ifTrue: [^self error: data].	data _ data unzipped.	stream _ RWBinaryOrTextStream on: data.	stream reset.	info _ stream fileInObjectAndCode.	stream close.	^info originalRoots! !!HttpUrl methodsFor: 'downloading' stamp: 'nk 8/30/2004 07:50'!checkAuthorization: webDocument retry: retryBlock	"authorization failed if webDocument is a String"	| oldRealm i end encoded |	((webDocument isString)		and: [(webDocument beginsWith: 'HTTP/1.0 401')			or: [webDocument beginsWith: 'HTTP/1.1 401']])	ifFalse: [^self].	oldRealm _ realm.	i _ webDocument findString: 'realm="'.	i = 0 ifTrue: [^self].	end _ webDocument indexOf: $" startingAt: i.	realm _ webDocument copyFrom: i+7 to: end.	"realm _ (webDocument findTokens: '""') at: 2."	Passwords ifNil: [Passwords _ Dictionary new].	encoded _ Passwords at: realm ifAbsent: [nil].	(oldRealm ~= realm) & (encoded ~~ nil) 		ifTrue: [^ retryBlock value]		ifFalse: ["ask the user"			self askNamePassword ifTrue: [^ retryBlock value]]! !!HttpUrl methodsFor: 'downloading' stamp: 'nk 8/30/2004 07:50'!normalizeContents: webDocument	(webDocument isString) ifTrue: [		^MIMEDocument			contentType: 'text/plain'			content: 'error occured retrieving ', self toText, ': ', webDocument			url: (Url absoluteFromText: '')].	webDocument contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: webDocument content url: webDocument url ].	^webDocument! !!Object class methodsFor: 'instance creation' stamp: 'nk 8/30/2004 07:57'!readCarefullyFrom: textStringOrStream	"Create an object based on the contents of textStringOrStream.  Return an error instead of putting up a SyntaxError window."	| object |	(Compiler couldEvaluate: textStringOrStream)		ifFalse: [^ self error: 'expected String, Stream, or Text'].	object _ Compiler evaluate: textStringOrStream for: nil 				notifying: #error: "signal we want errors" logged: false.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!Object class methodsFor: 'instance creation' stamp: 'nk 8/30/2004 07:57'!readFrom: textStringOrStream	"Create an object based on the contents of textStringOrStream."	| object |	(Compiler couldEvaluate: textStringOrStream)		ifFalse: [^ self error: 'expected String, Stream, or Text'].	object _ Compiler evaluate: textStringOrStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'nk 8/30/2004 07:47'!nameForCode: aStringOrChar	| ch |	ch _ (aStringOrChar isString) ifTrue: [aStringOrChar first] ifFalse: [aStringOrChar].	ch == self codeBalloonOval ifTrue: [^'balloon oval'].	ch == self codeBalloonRect ifTrue: [^'balloon rectangle'].	ch == self codeClip ifTrue: [^'clip'].	ch == self codeExtentDepth ifTrue: [^'codeExtentDepth'].	ch == self codeFont ifTrue: [^'codeFont'].	ch == self codeTTCFont ifTrue: [^'codeTTCFont'].	ch == self codeForce ifTrue: [^'codeForce'].	ch == self codeImage ifTrue: [^'codeImage'].	ch == self codeLine ifTrue: [^'codeLine'].	ch == self codeOval ifTrue: [^'codeOval'].	ch == self codePoly ifTrue: [^'codePoly'].	ch == self codeRect ifTrue: [^'codeRect'].	ch == self codeReleaseCache ifTrue: [^'codeReleaseCache'].	ch == self codeStencil ifTrue: [^'codeStencil'].	ch == self codeText ifTrue: [^'codeText'].	ch == self codeTransform ifTrue: [^'codeTransform'].	ch == self codeInfiniteFill ifTrue: [^'codeInfiniteFill'].	ch == self codeShadowColor ifTrue: [^'shadowColor'].	^'????'! !!Compiler class methodsFor: 'accessing' stamp: 'nk 8/30/2004 07:56'!couldEvaluate: anObject	"Answer true if anObject can be passed to my various #evaluate: methods."	^anObject isString or: [ anObject isText or: [ anObject isStream ]]! !!HTTPClient class methodsFor: 'post/get' stamp: 'nk 8/30/2004 07:50'!httpGet: url	| document |	document _ self httpGetDocument: url.	^(document isString)		ifTrue: [			"strings indicate errors"			document]		ifFalse: [(RWBinaryOrTextStream with: document content) reset]! !!HTTPSocket class methodsFor: 'get the page' stamp: 'nk 8/30/2004 07:50'!httpGet: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| document |	document _ self httpGetDocument: url  args: args  accept: mimeType request: requestString.	(document isString) ifTrue: [		"strings indicate errors"		^ document ].	^ (RWBinaryOrTextStream with: document content) reset! !!HTTPSocket class methodsFor: 'get the page' stamp: 'nk 8/30/2004 07:50'!httpGetNoError: url args: args accept: mimeType	"Return the exact contents of a web file.  Do better error checking.  Asks for the given MIME type.  To fetch raw data, you can use the MIMI type 'application/octet-stream'.  If mimeType is nil, use 'text/html'.  The parsed header is saved. Use a proxy server if one has been registered.""Edited to remove a lineFeed from the source 4/4/99 - di"	| document data |	document _ self httpGetDocument: url  args: args  accept: mimeType.	(document isString) ifTrue: [		"strings indicate errors"		^ document ].	data _ document content.	(data beginsWith: '<HTML><HEAD>' , (String with: Character linefeed) , '<TITLE>4')		ifTrue: ["an error message  404 File not found"				^ data copyFrom: 21 to: data size-16].		^ (RWBinaryOrTextStream with: data) reset! !!HTTPSocket class methodsFor: 'get the page' stamp: 'nk 8/30/2004 07:50'!httpPost: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| document |	document _ self httpPostDocument: url  args: argsDict  accept: mimeType  request: ''.	(document isString) ifTrue: [ 		"strings indicate errors"		^document ].		^RWBinaryOrTextStream with: document content! !!PluginHTTPDownloadRequest methodsFor: 'accessing' stamp: 'nk 8/30/2004 07:58'!contentStream	semaphore wait.	fileStream		ifNotNil: [^ fileStream].	^ content		ifNotNil: [content isString				ifTrue: [self error: 'Error loading ' , self url printString]				ifFalse: [content contentStream]]! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'nk 8/30/2004 07:59'!withCaption: cap chooseFrom: labels 	"Simply put up a menu. Get the args in the right order with the caption 	first. labels may be either an array of items or a string with CRs in it. 	May use backslashes for returns."	^ (labels isString		ifTrue: [self labels: labels withCRs lines: nil]		ifFalse: [self labelArray: labels lines: nil])		startUpWithCaption: cap withCRs! !!Project methodsFor: 'accessing' stamp: 'nk 8/30/2004 08:00'!findProjectView: projectDescription	| pName dpName proj |	"In this world, find the morph that holds onto the project described by projectDescription.  projectDescription can be a project, or the name of a project.  The project may be represented by a DiskProxy.  The holder morph may be at any depth in the world.	Need to fix this if Projects have subclasses, or if a class other than ProjectViewMorph can officially hold onto a project.  (Buttons, links, etc)	If parent is an MVC world, return the ProjectController."	self flag: #bob.		"read the comment"	pName _ (projectDescription isString) 		ifTrue: [projectDescription]		ifFalse: [projectDescription name].	self isMorphic 		ifTrue: [world allMorphsDo: [:pvm |				pvm class == ProjectViewMorph ifTrue: [					(pvm project class == Project and: 						[pvm project name = pName]) ifTrue: [^ pvm].					pvm project class == DiskProxy ifTrue: [ 						dpName _ pvm project constructorArgs first.						dpName _ (dpName findTokens: '/') last.						dpName _ (Project parseProjectFileName: dpName unescapePercents) first.						dpName = pName ifTrue: [^ pvm]]]]]		ifFalse: [world scheduledControllers do: [:cont |				(cont isKindOf: ProjectController) ifTrue: [					((proj _ cont model) class == Project and: 						[proj name = pName]) ifTrue: [^ cont view].					proj class == DiskProxy ifTrue: [ 						dpName _ proj constructorArgs first.						dpName _ (dpName findTokens: '/') last.						dpName _ (Project parseProjectFileName: dpName unescapePercents) first.						dpName = pName ifTrue: [^ cont view]]]]			].	^ nil! !!ProjectLoading class methodsFor: 'as yet unclassified' stamp: 'nk 8/30/2004 08:00'!bestAccessToFileName: aFileName andDirectory: aDirectoryOrURL	| localDir schema dir |	((localDir _ Project squeakletDirectory) fileExists: aFileName)		ifTrue: [^{localDir readOnlyFileNamed: aFileName. localDir}].	(aDirectoryOrURL isString) 		ifTrue: [			schema := Url schemeNameForString: aDirectoryOrURL.			(schema isNil or: [schema = 'file'])				ifTrue: [					dir := schema						ifNil: [FileDirectory forFileName: (FileDirectory default fullNameFor: aDirectoryOrURL)]						ifNotNil: [FileDirectory on: ((FileUrl absoluteFromText: aDirectoryOrURL) pathForDirectory)]]				ifFalse: [^{(Project serverFileFromURL: aDirectoryOrURL) asStream. nil}]]		ifFalse: [dir := aDirectoryOrURL].	^{dir readOnlyFileNamed: aFileName. dir}! !!ServerDirectory methodsFor: 'up/download' stamp: 'nk 8/30/2004 08:00'!putFile: fileStream named: fileNameOnServer retry: aBool	"ar 11/24/1998 Do the usual putFile:named: operation but retry if some error occurs and aBool is set. Added due to having severe transmission problems on shell.webpage.com."	| resp |	self isTypeFile ifTrue: [		^ (FileDirectory on: urlObject pathForDirectory)			putFile: fileStream named: fileNameOnServer].	[[resp _ self putFile: fileStream named: fileNameOnServer] 		ifError:[:err :rcvr| resp _ '5xx ',err]. "Report as error"	aBool and:[((resp isString) and: [resp size > 0]) and:[resp first ~= $2]]] whileTrue:[		(self confirm:('Error storing ',fileNameOnServer,' on the server.\(',resp,',)\Retry operation?') withCRs) ifFalse:[^resp].	].	^resp! !!ServerDirectory methodsFor: 'server groups' stamp: 'nk 8/30/2004 08:00'!groupName	^group		ifNil: [self moniker]		ifNotNil: [			(group isString)				ifTrue: [group]				ifFalse: [group key]]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'nk 8/30/2004 08:01'!obsoleteMethodReferences	"Smalltalk obsoleteMethodReferences"	"Smalltalk browseObsoleteMethodReferences"	"Open a browser on all referenced behaviors that are obsolete"	| obsClasses obsRefs references |	references _ WriteStream on: Array new.	obsClasses _ self obsoleteBehaviors.	'Scanning for methods referencing obsolete classes' displayProgressAt: Sensor cursorPoint		from: 1 to: obsClasses size during:[:bar|	obsClasses keysAndValuesDo:[:index :each|		bar value: index.		obsRefs _ self pointersTo: each except: obsClasses.		obsRefs do:[:ref|			"Figure out if it may be a global"			((ref isVariableBinding) and:[ref key isString "or Symbol"]) ifTrue:[				(self pointersTo: ref) do:[:meth|					(meth isKindOf: CompiledMethod) ifTrue:[						meth methodReference ifNotNilDo:[:mref|							references nextPut: mref]]]]]].	].	^references contents! !!TileMorph methodsFor: 'initialization' stamp: 'nk 8/30/2004 08:02'!setLiteral: anObject	"Set the receiver's literal to be anObject.  Create a readout morph and add it to the receiver, deleting any existing one that may be there."	| m already |	already _ submorphs detect: [:aSubMorph  | aSubMorph isKindOf: UpdatingStringMorph] ifNone: [nil].	already ifNotNil: [already delete].	type _ #literal.	m _ UpdatingStringMorph contents: ' ' font: ScriptingSystem fontForTiles.	m target: self; getSelector: #literal; putSelector: #literal:.	(anObject isString or: [ anObject isText]) ifTrue: [m useStringFormat].	self addMorphBack: m.	self setLiteralInitially: anObject.! !!Utilities class methodsFor: 'common requests' stamp: 'nk 8/30/2004 08:02'!eval: aString	"Evaluate the string in a neutral context, and under certain circumstances print the 	result in the transcript"	| result |	result _ Compiler new evaluate: aString in: nil to: nil.	(result isNumber) | (result isString)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'common requests' stamp: 'nk 8/30/2004 08:02'!offerCommonRequests	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| reply result aMenu index normalItemCount strings |	Smalltalk isMorphic ifTrue: [^ self offerCommonRequestsInMorphic].	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].	strings _ CommonRequestStrings contents.	normalItemCount _ strings asString lineCount.	aMenu _ PopUpMenu labels: (strings asString, 'edit this menu') lines: (Array with: normalItemCount).	index _ aMenu startUp.	index == 0 ifTrue: [^ self].	reply _ aMenu labelString lineNumber: index.	reply size == 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editCommonRequestStrings].	result _ self evaluate: reply in: nil to: nil.	(result isNumber) | (result isString)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'graphical support' stamp: 'nk 8/30/2004 08:02'!showFormsDictAcrossTopOfScreen: formDict	"Display the given Dictionary of forms across the top of the screen, wrapping to subsequent lines if needed.  Beneath each, put the name of the associated key."	"Utilities showFormsDictAcrossTopOfScreen: HaloIcons"	| position maxHeight screenBox ceiling elem box h labelWidth keyString |	position _ 20.	maxHeight _ 0.	ceiling _ 0.	screenBox _ Display boundingBox.	formDict associationsDo:		[:assoc | (elem _ assoc value) displayAt: (position @ ceiling).			box _ elem boundingBox.			h _ box height.			keyString _ (assoc key isString) ifTrue: [assoc key] ifFalse: [assoc key printString].			keyString displayAt: (position @ (ceiling + h)).			labelWidth _ TextStyle default defaultFont widthOfString: keyString.			maxHeight _ maxHeight max: h.			position _ position + (box width max: labelWidth) + 5.			position > (screenBox right - 100) ifTrue:				[position _ 20.				ceiling _ ceiling + maxHeight + 15.				maxHeight _ 0]]! !!Utilities class methodsFor: 'recent method submissions' stamp: 'nk 8/30/2004 08:02'!dumpAnyOldStyleRecentSubmissions	"simplify conversion by purging those recent submissions which are still Strings"	RecentSubmissions _ self recentMethodSubmissions reject: [ :each |		each isString	].! !