'From Squeak 2.3 beta of Nov 25, 1998 on 14 December 1998 at 10:44:21 pm'!"Change Set:		AtCacheIndexFrom1Date:			14 December 1998Author:			Dan IngallsThis changeSet uses 1-relative field accessors for the atCache to eliminate a few instructions.It also uses code sharing in internalFindNewMethod."!!Interpreter methodsFor: 'message sending' stamp: 'di 12/14/1998 22:19'!internalFindNewMethod	"Find the compiled method to be run when the current messageSelector is sent to the class 'lkupClass', setting the values of 'newMethod' and 'primitiveIndex'."	| ok | 	self inline: true.	self sharedCodeNamed: 'commonLookup' inCase: 131.	ok _ self lookupInMethodCacheSel: messageSelector class: lkupClass.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self externalizeIPandSP.		self lookupMethodInClass: lkupClass.		self internalizeIPandSP.		primitiveIndex _ self primitiveIndexOf: newMethod.		self addToMethodCacheSel: messageSelector			class: lkupClass			method: newMethod			primIndex: primitiveIndex].! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/14/1998 15:10'!bytecodePrimAt	"BytecodePrimAt will only succeed if the receiver is in the atCache.	Otherwise it will fail so that the more general primitiveAt will put it in the	cache after validating that message lookup results in a primitive response."	| index rcvr result atIx |	index _ self internalStackTop.	rcvr _ self internalStackValue: 1.	successFlag _ (self isIntegerObject: rcvr) not and: [self isIntegerObject: index].	successFlag ifTrue:		[atIx _ rcvr bitAnd: AtCacheMask.  "Index into atCache = 4N, for N = 0 ... 7"		(atCache at: atIx+AtCacheOop) = rcvr		ifTrue:			[result _ self commonVariableInternal: rcvr at: (self integerValueOf: index)							cacheIndex: atIx.			successFlag ifTrue:				[self fetchNextBytecode.				^ self internalPop: 2 thenPush: result]]].	messageSelector _ self specialSelector: 16.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/14/1998 15:10'!bytecodePrimAtPut	"BytecodePrimAtPut will only succeed if the receiver is in the atCache.	Otherwise it will fail so that the more general primitiveAtPut will put it in the	cache after validating that message lookup results in a primitive response."	| index rcvr atIx value |	value _ self internalStackTop.	index _ self internalStackValue: 1.	rcvr _ self internalStackValue: 2.	successFlag _ (self isIntegerObject: rcvr) not and: [self isIntegerObject: index].	successFlag ifTrue:		[atIx _ (rcvr bitAnd: AtCacheMask) + AtPutBase.  "Index into atPutCache"		(atCache at: atIx+AtCacheOop) = rcvr		ifTrue:			[self commonVariable: rcvr at: (self integerValueOf: index)							put: value cacheIndex: atIx.			successFlag ifTrue:				[self fetchNextBytecode.				^ self internalPop: 3 thenPush: value]]].	messageSelector _ self specialSelector: 17.	argumentCount _ 2.	self normalSend! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/14/1998 15:09'!commonAt: stringy	"This code is called if the receiver responds primitively to at:.	If this is so, it will be installed in the atCache so that subsequent calls of at:	or next may be handled immediately in bytecode primitive routines."	| index rcvr atIx result |	index _ self stackTop.	rcvr _ self stackValue: 1.	(self isIntegerObject: index) & (self isIntegerObject: rcvr) not		ifFalse: [^ self primitiveFail].	"NOTE:  The at-cache, since it is specific to the non-super response to #at:.	Therefore we must determine that the message is #at: (not, eg, #basicAt:),	and that the send is not a super-send, before using the at-cache."	(messageSelector = (self specialSelector: 16)		and: [lkupClass = (self fetchClassOfNonInt: rcvr)])		ifTrue:		["OK -- look in the at-cache"		atIx _ rcvr bitAnd: AtCacheMask.  "Index into atCache = 4N, for N = 0 ... 7"		(atCache at: atIx+AtCacheOop) = rcvr ifFalse:			["Rcvr not in cache.  Install it..."			self install: rcvr inAtCache: atCache at: atIx string: stringy].		successFlag ifTrue: [result _ self commonVariable: rcvr									at: (self integerValueOf: index)									cacheIndex: atIx].		successFlag ifTrue: [^ self pop: 2 thenPush: result]].	"The slow but sure way..."	successFlag _ true.	result _ self stObject: rcvr at: (self integerValueOf: index).	successFlag ifTrue:		[stringy ifTrue: [result _ self characterForAscii: (self integerValueOf: result)].		^ self pop: 2 thenPush: result]! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/14/1998 15:10'!commonAtPut: stringy	"This code is called if the receiver responds primitively to at:Put:.	If this is so, it will be installed in the atPutCache so that subsequent calls of at:	or  next may be handled immediately in bytecode primitive routines."	| value index rcvr atIx |	value _ self stackTop.	index _ self stackValue: 1.	rcvr _ self stackValue: 2.	(self isIntegerObject: index) & (self isIntegerObject: rcvr) not		ifFalse: [^ self primitiveFail].	"NOTE:  The atPut-cache, since it is specific to the non-super response to #at:Put:.	Therefore we must determine that the message is #at:Put: (not, eg, #basicAt:Put:),	and that the send is not a super-send, before using the at-cache."	(messageSelector = (self specialSelector: 17)		and: [lkupClass = (self fetchClassOfNonInt: rcvr)])		ifTrue:		["OK -- look in the at-cache"		atIx _ (rcvr bitAnd: AtCacheMask) + AtPutBase.  "Index into atPutCache"		(atCache at: atIx+AtCacheOop) = rcvr ifFalse:			["Rcvr not in cache.  Install it..."			self install: rcvr inAtCache: atCache at: atIx string: stringy].		successFlag ifTrue: [self commonVariable: rcvr at: (self integerValueOf: index)									put: value cacheIndex: atIx].		successFlag ifTrue: [^ self pop: 3 thenPush: value]].	"The slow but sure way..."	successFlag _ true.	stringy ifTrue: [self stObject: rcvr at: (self integerValueOf: index)							put: (self asciiOfCharacter: value)]			ifFalse: [self stObject: rcvr at: (self integerValueOf: index)							put: value].	successFlag ifTrue: [^ self pop: 3 thenPush: value].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/14/1998 14:58'!primitiveNext	"PrimitiveNext will succeed only if the stream's array is in the atCache.	Otherwise failure will lead to proper message lookup of at: and	subsequent installation in the cache if appropriate."	| stream array index limit result atIx |	stream _ self stackTop.	((self isPointers: stream)		and: [(self lengthOf: stream) >= (StreamReadLimitIndex + 1)])		ifFalse: [^ self primitiveFail].	array _ self fetchPointer: StreamArrayIndex ofObject: stream.	index _ self fetchInteger: StreamIndexIndex ofObject: stream.	limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.	atIx _ array bitAnd: AtCacheMask.	(index < limit and: [(atCache at: atIx+AtCacheOop) = array])		ifFalse: [^ self primitiveFail].	"OK -- its not at end, and the array is in the cache"	index _ index + 1.	result _ self commonVariable: array at: index cacheIndex: atIx.	"Above may cause GC, so can't use stream, array etc. below it"	successFlag ifTrue:		[stream _ self stackTop.		self storeInteger: StreamIndexIndex ofObject: stream withValue: index.		^ self pop: 1 thenPush: result].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/14/1998 14:58'!primitiveNextPut	"PrimitiveNextPut will succeed only if the stream's array is in the atPutCache.	Otherwise failure will lead to proper message lookup of at:put: and	subsequent installation in the cache if appropriate."	| value stream index limit array atIx |	value _ self stackTop.	stream _ self stackValue: 1.	((self isPointers: stream)		and: [(self lengthOf: stream) >= (StreamReadLimitIndex + 1)])		ifFalse: [^ self primitiveFail].	array _ self fetchPointer: StreamArrayIndex ofObject: stream.	index _ self fetchInteger: StreamIndexIndex ofObject: stream.	limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.	atIx _ (array bitAnd: AtCacheMask) + AtPutBase.	(index < limit and: [(atCache at: atIx+AtCacheOop) = array])		ifFalse: [^ self primitiveFail].	"OK -- its not at end, and the array is in the cache"	index _ index + 1.	self commonVariable: array at: index put: value cacheIndex: atIx.	successFlag ifTrue:		[self storeInteger: StreamIndexIndex ofObject: stream withValue: index.		^ self pop: 2 thenPush: value].! !!Interpreter class methodsFor: 'initialization' stamp: 'di 12/14/1998 15:12'!initializeCaches 	| atCacheEntrySize |	MethodCacheEntries _ 512. 	MethodCacheSelector _ 1.	MethodCacheClass _ 2.	MethodCacheMethod _ 3.	MethodCachePrim _ 4.	MethodCacheEntrySize _ 4.  "Must be power of two for masking scheme."	MethodCacheMask _ (MethodCacheEntries - 1) * MethodCacheEntrySize.	MethodCacheSize _ MethodCacheEntries * MethodCacheEntrySize.	CacheProbeMax _ 3.	AtCacheEntries _ 8.  "Must be power of two"	AtCacheOop _ 1.	AtCacheSize _ 2.	AtCacheFmt _ 3.	AtCacheFixedFields _ 4.	atCacheEntrySize _ 4.  "Must be power of two for masking scheme."	AtCacheMask _ (AtCacheEntries-1) * atCacheEntrySize.	AtPutBase _ AtCacheEntries * atCacheEntrySize.	AtCacheTotalSize _ AtCacheEntries * atCacheEntrySize * 2.! !!TCaseStmtNode methodsFor: 'all' stamp: 'di 12/14/1998 22:22'!fixSharedCodeBlocksForCase: caseIndex in: caseParseTree	"Process 'sharedCode' directives in the given parse tree. The sharedCode directive allows code replicated in different arms of a case statement to be shared. The replicated code must be the final code of the case so that it ends with a break out of the case statement. The replicated code will be generated in exactly one arm of the case statement; other instances of the shared code will be replaced by branches to that single instance of the code."	"NOTE: I have made this work for the nested case (ie several shared entry points in the same case, but it does not really work for methods with arguments.  A mechanism coud be added that would add a preamble of the form,	innerSharedTemp = outerTemp;when they differed.  There should at least be a test here."	| copying oldStmts newStmts stmt codeBlockName |	caseParseTree  nodesDo: [ :node |		node isStmtList ifTrue: [			copying _ true.			oldStmts _ node statements asArray.			newStmts _ nil.  "becomes an OrderedCollection if sharedCode block is found"			1 to: oldStmts size do: [ :i |				copying ifTrue: [					stmt _ oldStmts at: i.					(stmt isSend and: [stmt selector = #sharedCodeNamed:inCase:]) ifTrue: [						newStmts == nil 							ifTrue: [newStmts _ (oldStmts copyFrom: 1 to: i - 1) asOrderedCollection]							ifFalse: [newStmts removeLast "preserve any prior shared entry points - di"].						codeBlockName _ stmt args first value.						(stmt args last value = caseIndex) ifTrue: [							newStmts add: 								(TLabeledCommentNode new setLabel: codeBlockName comment: '').						] ifFalse: [							newStmts add: (TGoToNode new setLabel: codeBlockName).							copying _ false.  "don't copy remaining statements"						].					] ifFalse: [						newStmts = nil ifFalse: [newStmts add: stmt].					].				] ifFalse: [	"ikp: this permits explicit returns before 'goto aSharedCodeLabel'"					stmt _ oldStmts at: i.					(stmt isLabel and: [stmt label ~= nil]) ifTrue: [newStmts add: stmt].				].			].			newStmts = nil ifFalse: [node setStatements: newStmts].		].	].! !"Postscript:Clear out any old entries in Undeclared."Undeclared removeUnreferencedKeys!