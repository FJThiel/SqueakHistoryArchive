AlignmentMorph subclass: #PhonemeRecognizerMorph	instanceVariableNames: 'soundInput statusLight levelMeter phonemeDisplay phonemeRecords silentPhoneme currentPhoneme '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Phoneme Recognizer'!!PhonemeRecognizerMorph commentStamp: 'jm 5/23/2000 07:05' prior: 0!I am experimental phoneme recognizer. My approach to phoneme recognition is fairly crude, but the goal is not full speech recognition, but merely a close enough approximation to drive the mouth of an animated character from speech input.How it works:The phoneme recognizer has a collection of phoneme examples that were recorded in advance. Each of these phomemes has a "features vector" that describes that phoneme. Currently, feature vectors are basically a simplified version of the frequency spectrum measuring the sound energy in about two dozen frequency bands up to around 4000 Hz. The exact parameters are described in the class initialization method of PhonemeRecord and can be tweaked.To do phoneme recognition, a short window of sound is analyzed via FFT, and its feature vector is extracted. This feature vector is then compared to the feature vectors of all phonemes in the example set. The phoneme that matches most closely is considered the currently sounding phoneme. This phoneme's name is presented in the PhonemeRecognizer display. On a reasonably fast machine, the current phoneme can be watched by a program and used to drive real-time mouth animation . This phoneme matching approach is similar to some of the earliest speech recognition work. However, current speech recognition software is generally driven by features derived from a linear predictive or vocal tract model of speech, rather than the raw spectrum data.How to Use ItThe first step is to plan how many different mouth positions will be used by the animation, and which phonemes map to which mouth positions. Traditional animators might draw four mouth positions for vowels and four to six for consonants.The person whose speech is to be recognized then records phoneme examples for the phonemes to be recognized. For animation, these phonems might consist of the vowel sounds "eh", "ee", "ah", "o", "u" and the consonants "n", "r", "s", "sh", "th", "z", "l", "r", "w", and "m". In some cases "f" and "v" might also be included. The consonants "b" and "p" are also significant in animation, since these sounds, like "m", bring the lips together. Unfortunately, "b" and "p" are tricky to recognize with the scheme used here because they are actually two things in quick succession: a momentary silence followed by the sound of the released breath. However, if the mouth position for silence is drawn with the mouth closed, then the animation of "b" and "p" will probably look okay.Each phoneme example is recorded by clicking the "add" button and speaking the phoneme into the microphone. Leading and trailing silence is automatically removed. The user is prompted for the phoneme name and a mouth position index. The name is just a mnemonic for the user. The index can be used to select a costume from a holder during animation. It is handy to list and number the mouth positions before recording the phoneme example set.A phoneme can be reviewed with the "play phoneme" menu command. If it contains noise, includes slides between several different sounds, or doesn't sound like a representative example of the phoneme, delete it and record it again. English contains a number of "diphthongs"--vowel sounds that are actually slides between two different vowel sounds, as in the words "boy" or "boat". It is best to record each component of a diphthong individually. You can also set the name and mouth position index for the "silence" phoneme, the phoneme that is reported whenever the input sound falls below a certain threshold. A graphical view of the features vector for a given phoneme can be generated by selecting "show phoneme features" from the menu. A phoneme set can be saved to a file and restored later.Once you have recorded your phoneme examples, you can try them by clicking the "run" button and speaking into the microphone. You should see the phoneme display update to report the current match. The "match sound file" menu command can be used to analyze an entire AIFF or a WAV sound file at once. The resulting phoneme stream is currently reported by opening an inspector on the phoneme list. There is one phoneme in this list for each 1/24th of a second window of sound in the sound file.To allow use of the phoneme recognizer in tile scripts, the "mouth position tile" menu command creates a tile that reports the current phonemes mouth position index. This can be used to set the cursor of a holder containing the set of mouth position drawings. A two-line tile script can thus drive the mouth of an animated character.!!PhonemeRecognizerMorph methodsFor: 'initialization' stamp: 'jm 5/18/2000 18:29'!initialize	| r |	super initialize.	borderWidth _ 2.	orientation _ #vertical.	soundInput _ SoundInputStream new samplingRate: 22050.	phonemeRecords _ OrderedCollection new.	silentPhoneme _ PhonemeRecord new initialize name: '...'.	currentPhoneme _ silentPhoneme.  "the PhonemeRecord of the current match"	self addTitle.	self addButtonRows.	self addLevelSlider.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeLevelMeter.	self addMorphBack: r.	self addPhonemeDisplay.	self extent: 10@10.  "make minimum size"! !!PhonemeRecognizerMorph methodsFor: 'accessing' stamp: 'jm 5/18/2000 18:28'!currentPhonemeMouthPosition	"Answer the mouth position index (a position integer) of the currently matching phoneme."	^ currentPhoneme mouthPosition! !!PhonemeRecognizerMorph methodsFor: 'accessing' stamp: 'jm 5/18/2000 18:27'!currentPhonemeName	"Answer the name of the currently matching phoneme."	^ currentPhoneme name! !!PhonemeRecognizerMorph methodsFor: 'accessing' stamp: 'jm 5/22/2000 17:32'!getMouthPosition	"Answer the mouth position index (a position integer) of the currently matching phoneme. Sent by tile scripts."	^ currentPhoneme mouthPosition! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/23/2000 06:06'!addPhoneme	"Record and add a new phoneme example to my phoneme set. Prompt the user for its name and mouth position."	| phoneme |	Utilities		informUser: 'Press and hold the mouse button while speaking the phoneme.'		during: [Sensor waitButton].	soundInput isRecording ifTrue: [self stop].	phoneme _ PhonemeRecord new initialize.	phoneme recordWithLevel: soundInput recordLevel.	phoneme samples size < 10000 ifTrue: [		^ self inform: 'Nothing recorded; check the record input source and adjust the level'].	self promptForDetailsOfPhoneme: phoneme.	phonemeRecords addLast: phoneme.! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/23/2000 05:52'!changePhonemeDetails	"Change the name and mouth position index of a phoneme specified by the user."	| phoneme |	phoneme _ self selectPhonemeFromMenu.	phoneme ifNotNil: [self promptForDetailsOfPhoneme: phoneme].! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/18/2000 18:20'!deletePhoneme	"Delete a phoneme specified by the user."	| phoneme |	phoneme _ self selectPhonemeFromMenu.	phoneme ifNotNil: [		phonemeRecords remove: phoneme ifAbsent: []].! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/23/2000 05:53'!invokeMenu	"Invoke the settings menu."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('add phoneme'				addPhoneme)		('play phoneme'				playPhoneme)		('show phoneme features'	showPhonemeFeatures)		('change phoneme name'	changePhonemeDetails)		('set phoneme for silence'	setSilentPhoneme)		('delete phoneme'			deletePhoneme)		-		('mouth position tile'		makeTile)		('match sound file'			matchSoundFile)		-		('save phonemes to file'		savePhonemes)		('read phoneme from file'	readPhonemes)).	aMenu invokeOn: self defaultSelection: nil.! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/22/2000 17:53'!makeTile	"Make a scripting tile to fetch the current phoneme's mouth position. Attach it to the hand, allowing the user to drop it directly into a tile script."	| tile argTile |	tile _ PhraseTileMorph new setSlotRefOperator: #mouthPosition type: #number.	argTile _ TileMorph new		setObjectRef: nil actualObject: self;		typeColor: (ScriptingSystem colorForType: #object).	argTile bePossessive.	tile firstSubmorph addMorph: argTile.	tile enforceTileColorPolicy.	self world firstHand attachMorph: tile.! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/23/2000 05:44'!matchSoundFile	"Process an AIFF or WAV sound file and generate a sequence of phoneme matches for that file in the Transcript. When done, open an inspector on the resulting collection of phonemes."	| fileName snd out fftSize samplesPerInterval startIndex buf p |	self inform: 'Sorry, sound file matching is not yet implemented'.	fileName _ Utilities		chooseFileWithSuffixFromList: #('.aif' '.aiff' '.wav')		withCaption: 'Sound file?'.	fileName = #none ifTrue: [^ self inform: 'No sound files.'].	('*aif*' match: fileName) ifTrue:		[snd _ SampledSound fromAIFFfileNamed: fileName].	('*wav' match: fileName) ifTrue:		[snd _ SampledSound fromWaveFileNamed: fileName].	out _ OrderedCollection new: 1000.	fftSize _ PhonemeRecord fftSize.	samplesPerInterval _ snd samplingRate / 24.0.	1 to: (snd samples size - fftSize) + 1 by: samplesPerInterval do: [:i |		startIndex _ i truncated.		buf _ snd samples copyFrom: startIndex to: startIndex + fftSize - 1.		out addLast: (p _			self findMatchFor: buf samplingRate: snd samplingRate).p name asParagraph display.(SampledSound samples: buf samplingRate: 11025) playAndWaitUntilDone.].	out asArray inspect.! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/18/2000 18:20'!playPhoneme	"Play a phoneme specified by the user."	| phoneme |	phoneme _ self selectPhonemeFromMenu.	phoneme ifNotNil: [phoneme play].! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/22/2000 17:40'!readPhonemes	"Read a previously saved phoneme set from a file."	| fname s newPhonemes |	fname _ Utilities		chooseFileWithSuffixFromList: #('.pho' '.phonemes')		withCaption: 'Phoneme file?'.	fname == nil ifTrue: [^ self].	fname ifNil: [^ self].	s _ FileStream oldFileNamed: fname.	newPhonemes _ s fileInObjectAndCode.	s close.	phonemeRecords _ newPhonemes.! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/22/2000 17:39'!savePhonemes	"Save the current phoneme set in a file."	| fname refStream |	fname _ FillInTheBlank request: 'Phoneme file name?'.	fname isEmpty ifTrue: [^ self].	((fname endsWith: '.pho') or: [fname endsWith: '.phonemes'])		ifFalse: [fname _ fname, '.phonemes'].	refStream _ SmartRefStream fileNamed: fname.	refStream nextPut: phonemeRecords.	refStream close.! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/23/2000 06:18'!setSilentPhoneme	"Prompt the user for the name and mouth position associated with silence."	self promptForDetailsOfPhoneme: silentPhoneme.	phonemeDisplay contents: currentPhoneme name.! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/22/2000 17:40'!showPhonemeFeatures	"Show a graph of the features array for the phoneme selected by the user."	| phoneme m |	phoneme _ self selectPhonemeFromMenu.	phoneme ifNotNil: [		m _ ImageMorph new image: phoneme featuresGraph.		self world firstHand attachMorph: m].! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/22/2000 17:37'!startRecognizing	"Start recognizing phonemes from the sound input."	self stopRecognizing.	soundInput bufferSize: (PhonemeRecord fftSize).	soundInput startRecording.! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'jm 5/18/2000 18:24'!stopRecognizing	"Stop listening."	soundInput stopRecording.	currentPhoneme _ silentPhoneme.! !!PhonemeRecognizerMorph methodsFor: 'stepping' stamp: 'jm 5/23/2000 05:42'!step	"Update the record light, level meter, and display."	| w buf p |	"update the record light and level meter"	soundInput isRecording		ifTrue: [statusLight color: Color yellow]		ifFalse: [statusLight color: Color gray].	w _ ((121 * soundInput meterLevel) // 100) max: 1.	levelMeter width ~= w ifTrue: [levelMeter width: w].	soundInput isRecording ifTrue: [		[soundInput bufferCount > 0] whileTrue: [			"skip to the most recent buffer"			buf _ soundInput nextBufferOrNil].		buf ifNotNil: [			p _ self findMatchFor: buf samplingRate: soundInput samplingRate.			phonemeDisplay contents: p name]].! !!PhonemeRecognizerMorph methodsFor: 'stepping' stamp: 'jm 5/23/2000 05:48'!stepTime	^ 30! !!PhonemeRecognizerMorph methodsFor: 'stepping' stamp: 'jm 5/10/2000 16:04'!stopStepping	"Turn off recording."	super stopStepping.	soundInput stopRecording.! !!PhonemeRecognizerMorph methodsFor: 'analysis' stamp: 'jm 5/22/2000 23:15'!findMatchFor: aSoundBuffer samplingRate: samplingRate	"Find the phoneme whose features most closesly match those of the given sound buffer."	| unknown bestMatch bestDistance d |	unknown _ PhonemeRecord new		samples: aSoundBuffer samplingRate: samplingRate.	unknown peakLevel > 1500		ifTrue: [			unknown computeFeatures.			bestMatch _ nil.			bestDistance _ SmallInteger maxVal.			phonemeRecords do: [:p |				d _ p featureDistanceFrom: unknown features to: p features.				d < bestDistance ifTrue: [					bestMatch _ p.					bestDistance _ d]]]		ifFalse: [bestMatch _ silentPhoneme].	currentPhoneme _ bestMatch.	^ currentPhoneme! !!PhonemeRecognizerMorph methodsFor: 'private' stamp: 'jm 5/22/2000 17:45'!addButtonRows	"Create and add my button row."	| r |	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: ((self buttonName: 'Menu' action: #invokeMenu)		actWhen: #buttonDown).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Add' action: #addPhoneme).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Run' action: #startRecognizing).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Stop' action: #stopRecognizing).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: self makeStatusLight.	self addMorphBack: r.! !!PhonemeRecognizerMorph methodsFor: 'private' stamp: 'jm 5/23/2000 05:49'!addLevelSlider	"Create and add a slider to set the sound input level. This level is used both when recognizing and adding phonemes."	| levelSlider r |	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: soundInput;		actionSelector: #recordLevel:;		adjustToValue: soundInput recordLevel.	r _ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.! !!PhonemeRecognizerMorph methodsFor: 'private' stamp: 'jm 5/22/2000 17:47'!addPhonemeDisplay	"Add a display to show the currently matching phoneme."	| font r |	font _ StrikeFont familyName: 'Helvetica' size: 36.	phonemeDisplay _ StringMorph contents: '...' font: font.	r _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #spaceFill;		vResizing: #rigid;		height: 20.	r addMorphBack: phonemeDisplay.	self addMorphBack: (Morph new extent: 5@8; color: Color transparent).  "spacer"	self addMorphBack: r.! !!PhonemeRecognizerMorph methodsFor: 'private' stamp: 'jm 5/23/2000 05:50'!addTitle	"Add a title."	| font title r |	font _ StrikeFont familyName: 'ComicBold' size: 20.	title _ StringMorph contents: 'Phoneme Recognizer' font: font.	r _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #spaceFill;		vResizing: #rigid;		height: 20.	r addMorphBack: title.	self addMorphBack: r.	self addMorphBack: (Morph new extent: 5@8; color: Color transparent).  "spacer"! !!PhonemeRecognizerMorph methodsFor: 'private' stamp: 'jm 5/22/2000 17:48'!buttonName: aString action: aSymbol	"Create a button of the given name to send myself the given unary message."	^ SimpleButtonMorph new		target: self;		label: aString;		actionSelector: aSymbol! !!PhonemeRecognizerMorph methodsFor: 'private' stamp: 'jm 5/22/2000 17:50'!makeLevelMeter	"Create a recording level meter."	| outerBox |	outerBox _ RectangleMorph new extent: 125@14; color: Color lightGray.	levelMeter _ Morph new extent: 2@10; color: Color yellow.	levelMeter position: outerBox topLeft + (2@2).	outerBox addMorph: levelMeter.	^ outerBox! !!PhonemeRecognizerMorph methodsFor: 'private' stamp: 'jm 5/22/2000 17:50'!makeStatusLight	"Create a status light to show when the recognizer is running."	| s |	statusLight _ RectangleMorph new extent: 24@19.	statusLight color: Color gray.	s _ StringMorph contents: 'On'.	s position: statusLight center - (s extent // 2).	statusLight addMorph: s.	^ statusLight! !!PhonemeRecognizerMorph methodsFor: 'private' stamp: 'jm 5/18/2000 19:36'!promptForDetailsOfPhoneme: phoneme	"Prompt the user for the name and mouth position of the given phoneme."	| response |	response _ FillInTheBlank		request: 'Phoneme name?'		initialAnswer: phoneme name.	response ifNotNil: [phoneme name: response].	response _ FillInTheBlank		request: 'Mouth Position Index?'		initialAnswer: phoneme mouthPosition printString.	response ifNotNil: [phoneme mouthPosition: response asNumber asInteger].! !!PhonemeRecognizerMorph methodsFor: 'private' stamp: 'jm 5/18/2000 20:31'!selectPhonemeFromMenu	"Answer the phone selected by the user from a menu of the current phoneme records. Answer nil if the user does not select any phoneme."	| aMenu |	phonemeRecords isEmpty ifTrue: [self inform: 'The phoneme database is empty.'. ^ nil].	aMenu _ CustomMenu new title: 'Phoneme to delete?'.	phonemeRecords do: [:phoneme |		aMenu add: phoneme name action: phoneme].	^ aMenu startUp! !Object subclass: #PhonemeRecord	instanceVariableNames: 'name mouthPosition samples samplingRate features '	classVariableNames: 'AverageFeatures CutoffFreq FFTSize FilterBandwidth HighFreqWeight '	poolDictionaries: ''	category: 'Speech-Phoneme Recognizer'!!PhonemeRecord commentStamp: 'jm 5/23/2000 05:37' prior: 0!I represent a single phoneme. I contain the phoneme's name and an integer that represents the mouth position associated with this phoneme. This integer can be used as an index to select the mouth shape for an animated character. I also contain a 'features vector' derived from an analysis of my sound; this 'features vector' is the basis of matching during phoneme recognition. I also retain the original sound from which the features were computed so that it can be re-analyzed to create a new feature vector when the analysis algorithm is changed.!!PhonemeRecord methodsFor: 'initialization' stamp: 'jm 5/19/2000 23:13'!initialize	name _ ''.	mouthPosition _ 1.	samples _ SoundBuffer new.	samplingRate _ 22050.	features _ nil.! !!PhonemeRecord methodsFor: 'access' stamp: 'jm 5/23/2000 06:13'!features	"Answer the features vector for this phoneme, an array of numbers used in the phoneme matching process. Compute the features if necessary."	features ifNil: [		AverageFeatures			ifTrue: [features _ self averageFeatures]			ifFalse: [features _ self featuresAtCenter]].	^ features! !!PhonemeRecord methodsFor: 'access' stamp: 'jm 5/23/2000 05:37'!features: anObject	features _ anObject.! !!PhonemeRecord methodsFor: 'access' stamp: 'jm 5/19/2000 23:11'!mouthPosition	"Answer the mouth position associated with this phoneme, a positive integer that can be used to index into a collection of frames for an animation."	^ mouthPosition! !!PhonemeRecord methodsFor: 'access' stamp: 'jm 5/17/2000 17:51'!mouthPosition: anInteger	mouthPosition _ anInteger.! !!PhonemeRecord methodsFor: 'access' stamp: 'jm 5/17/2000 17:55'!name	"Answer the name the user gave this phoneme."	^ name! !!PhonemeRecord methodsFor: 'access' stamp: 'jm 5/17/2000 16:42'!name: anObject	name _ anObject.! !!PhonemeRecord methodsFor: 'access' stamp: 'jm 5/17/2000 17:53'!samples	"Answer the SoundBuffer containing my sampled sound data."	^ samples! !!PhonemeRecord methodsFor: 'access' stamp: 'jm 5/19/2000 23:12'!samples: aSoundBuffer samplingRate: aNumber	"Set my samples and sampling rate, and clear my cached features vector."	samples _ aSoundBuffer.	samplingRate _ aNumber.	self clearFeatures.! !!PhonemeRecord methodsFor: 'access' stamp: 'jm 5/17/2000 17:55'!samplingRate	"Answer the sampling rate used to record my samples."	^ samplingRate! !!PhonemeRecord methodsFor: 'other' stamp: 'jm 5/23/2000 05:39'!featuresGraph	"Answer a Form containing a pictorial view of my features vector."	| labelForm graphHeight barWidth bottom f min max scale x h |	labelForm _ name asParagraph asForm.	graphHeight _ 100.	barWidth _ 5.	bottom _ graphHeight + 2.  "2 pixel border"	f _ Form		extent: (self features size * barWidth) @ (graphHeight + labelForm height + 5)		depth: 16.	f fillWhite: f boundingBox.	f border: f boundingBox width: 2.	min _ 1.0e30.	max _ -1.0e30.	features do: [:v |		v < min ifTrue: [min _ v].		v > max ifTrue: [max _ v]].	scale _ (graphHeight - 1) asFloat / (max - min).	x _ 2.	self features do: [:v |		h _ (scale * (v - min)) asInteger.		f fill: ((x@(bottom - h)) extent: barWidth@h) fillColor: (Color r: 0.581 g: 0.581 b: 0.0).		x _ x + barWidth].	f fillBlack: ((0@bottom) extent: (f width@1)).	labelForm displayOn: f		at: ((f width - labelForm width) // 2)@bottom		rule: Form paint.	^ f! !!PhonemeRecord methodsFor: 'other' stamp: 'jm 5/17/2000 17:58'!play	"Playback my samples."	(SampledSound samples: samples samplingRate: samplingRate) play.! !!PhonemeRecord methodsFor: 'other' stamp: 'jm 5/23/2000 06:05'!recordWithLevel: recordLevel	"Initialize my sound samples by recording a snippet of sound while the mouse is held down. Trim off leading and trailing silence, and normalize the level of the recording."	| recorder |	"record the sound"	recorder _ SoundRecorder new		samplingRate: samplingRate;		recordLevel: recordLevel;		clearRecordedSound.	Utilities		informUser: 'Recording a phoneme. Release the mouse button when done.'		during: [			recorder resumeRecording.			Sensor waitNoButton.			recorder stopRecording].	Utilities		informUser: 'Removing leading/trailing silence...'		during: [			samples _ recorder condensedSamples.			samples size > 0 ifTrue: [				samples _ self trimAndNormalize: samples]].	self clearFeatures.! !!PhonemeRecord methodsFor: 'other' stamp: 'jm 5/17/2000 20:42'!trimAndNormalize: aSoundBuffer	"Trim leading and trailing silence and normalize the sound level of the given samples."	| lastSampleIndex maxLevel v threshold startI endI adjust count result |	"skip the sound of the terminating mouse click..."	lastSampleIndex _ (aSoundBuffer monoSampleCount - (samplingRate // 10)) max: 1.	"find maximum level"	maxLevel _ 0.	1 to: lastSampleIndex do: [:i |		v _ aSoundBuffer at: i.		v < 0 ifTrue: [v _ 0 - v].		v > maxLevel ifTrue: [maxLevel _ v]].	"find indices of start and end"	threshold _ (0.1 * maxLevel) asInteger.	startI _ 1.	[(aSoundBuffer at: startI) < threshold]		whileTrue: [startI _ startI + 1].  "scan for starting point"	endI _ lastSampleIndex.	[(aSoundBuffer at: endI) < threshold]		whileTrue: [endI _ endI - 1].  "scan for ending point"	"extend range by a twentieth of a second on both ends"	startI _ (startI - (samplingRate // 20)) max: 1.	endI _ (endI + (samplingRate // 20)) min: aSoundBuffer monoSampleCount.	adjust _ (10000 * (30000 / maxLevel)) asInteger.  "fixed point constant for speed"	count _ (endI - startI) + 1.	result _ SoundBuffer newMonoSampleCount: (endI - startI) + 1.	1 to: count do: [:i |		v _ (adjust * (aSoundBuffer at: (startI + i - 1))) // 10000.		result at: i put: v].	^ result! !!PhonemeRecord methodsFor: 'feature analysis' stamp: 'jm 5/17/2000 19:50'!averageFeatures	"Compute the average features vector across my sound samples."	| startI endI featureVectors |	"skip the first and last bits"	startI _ (samplingRate // 5).	endI _ samples monoSampleCount - (samplingRate // 5).	endI - startI < FFTSize ifTrue: [^ self extractFeaturesAt: endI].	featureVectors _ (startI to: endI by: FFTSize)		collect: [:i | (self extractFeaturesAt: i)].	^ self prunedAverageFeatures: featureVectors! !!PhonemeRecord methodsFor: 'feature analysis' stamp: 'jm 5/17/2000 20:02'!clearFeatures	"Clear my features vector cache. This must be done when new sample data is recorded or when the analysis algorithm is changed."	features _ nil.! !!PhonemeRecord methodsFor: 'feature analysis' stamp: 'jm 5/18/2000 22:21'!computeFeatures	"Compute and record a features vector take from the start of my samples. This method is typically used to analyze a single buffer during recognition."	self features: (self extractFeaturesAt: 1).! !!PhonemeRecord methodsFor: 'feature analysis' stamp: 'jm 5/21/2000 09:28'!distanceToPhoneme: otherPhoneme	"Answer the distance in feature space between this phoneme and the given phoneme."	^ self featureDistanceFrom: self features to: otherPhoneme features! !!PhonemeRecord methodsFor: 'feature analysis' stamp: 'jm 5/18/2000 22:46'!extractFeaturesAt: startIndex	"Extract a features vector from the given point in my samples."	| spectrum cutoffIndex binSize s i avg unscaledFeatures total |	spectrum _ (FFT new: FFTSize)		transformDataFrom: samples		startingAt: (startIndex min: (samples monoSampleCount - FFTSize + 1)).	cutoffIndex _ ((CutoffFreq * spectrum size) / (samplingRate / 2)) rounded.	binSize _ ((FilterBandwidth * spectrum size) / (samplingRate / 2)) rounded.	s _ WriteStream on: (Array new: 50).	i _ 2. "skip first bin of FFT data, which just contains the D.C. component"	[i < cutoffIndex] whileTrue: [		avg _ (spectrum copyFrom: i to: i + binSize - 1) sum / binSize.		s nextPut: avg.		i _ i + binSize].	"final entry of feature vector sums all energy above the cutoff frequency"	s nextPut: HighFreqWeight *		((spectrum copyFrom: i to: spectrum size) sum / (spectrum size + 1 - i)).	unscaledFeatures _ s contents.	total _ unscaledFeatures sum.	^ unscaledFeatures collect: [:n | (1000.0 * n) // total].! !!PhonemeRecord methodsFor: 'feature analysis' stamp: 'jm 5/18/2000 23:01'!featureDistanceFrom: featuresVec1 to: featuresVec2	"Answer the distance between the given two feature vectors. The lower this value, the closer the phonemes match."	| sumOfSquares |	sumOfSquares _ 0.	1 to: featuresVec1 size do: [:i |		 sumOfSquares _ sumOfSquares +			((featuresVec1 at: i) - (featuresVec2 at: i)) squared].	^ sumOfSquares sqrt! !!PhonemeRecord methodsFor: 'feature analysis' stamp: 'jm 5/17/2000 19:54'!featuresAtCenter	"Answer the features vector computed from a single FFT window taken from the center of my samples."	^ self extractFeaturesAt: (samples monoSampleCount // 2)! !!PhonemeRecord methodsFor: 'feature analysis' stamp: 'jm 5/18/2000 22:33'!peakLevel	"Answer the absolute value of the peak sample value my buffer."	| maxVal v |	maxVal _ 0.	1 to: samples size do: [:i |		v _ samples at: i.		v < 0 ifTrue: [v _ 0 - v].		v > maxVal ifTrue: [maxVal _ v]].	^ maxVal! !!PhonemeRecord methodsFor: 'feature analysis' stamp: 'jm 5/21/2000 09:28'!phonemeDistanceTo: otherPhoneme	"Answer the distance in feature space between this phoneme and the given phoneme."	^ self featureDistanceFrom: self features to: otherPhoneme features! !!PhonemeRecord methodsFor: 'feature analysis' stamp: 'jm 5/18/2000 23:04'!prunedAverageFeatures: featureVectors	"Compute the average of the given collection of feature vectors, then discard the outliers and average the remainding feature vectors. The result is an average of the most typical feature vectors in the given collection."	| centroid sum vectorsWithErrors filtered |	"compute the average of all the feature vectors"	centroid _ (1 to: featureVectors first size) collect: [:i |		sum _ 0.		1 to: featureVectors size do: [:j | sum _ sum + ((featureVectors at: j) at: i)].		(sum asFloat / featureVectors size) rounded].	"sort vectors by their distance from the centroid"	vectorsWithErrors _ SortedCollection sortBlock: [:e1 :e2 | e1 last < e2 last].	featureVectors do: [:v |		vectorsWithErrors add: (Array with: v with: (self featureDistanceFrom: v to: centroid))].	"reject outlying feature vectors"	filtered _ (1 to: (0.8 * vectorsWithErrors size) rounded)		collect: [:i | (vectorsWithErrors at: i) first].	"answer the average of the remaining feature vectors"	^ (1 to: filtered first size) collect: [:i |		sum _ 0.		1 to: filtered size do: [:j | sum _ sum + ((filtered at: j) at: i)].		(sum asFloat / filtered size) rounded].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PhonemeRecord class	instanceVariableNames: ''!!PhonemeRecord class methodsFor: 'class initialization' stamp: 'jm 5/22/2000 17:36'!fftSize	"Answer the FFT size for frequency analysis. It must be a power of two."	^ FFTSize! !!PhonemeRecord class methodsFor: 'class initialization' stamp: 'jm 5/23/2000 06:15'!initialize	"Initialize the parameter used to extract phoneme features. After changing these parameters, execute 'PhonemeRecord initialize'. The features vectors of any existing phoneme records will be cleared and recomputed as needed."	"PhonemeRecord initialize"	FFTSize _ 512.			"size of FFT for analysis; this must be a power of two"	CutoffFreq _ 4000.		"boundary between fine and coarse ranges"	FilterBandwidth _ 160.	"bandwidth of each frequency band in the fine range"	HighFreqWeight _ 5.		"weighting of energy above the cutoff frequency"	AverageFeatures _ false.		"If AverageFeatures is true, then average features over the phoneme recording. Otherwise, extract features from the center of the recording."	"clear all cached feature vectors"	PhonemeRecord allInstancesDo: [:p | p clearFeatures].! !PhonemeRecord initialize!