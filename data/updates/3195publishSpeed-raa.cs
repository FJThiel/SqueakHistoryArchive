'From Squeak2.9alpha of 17 July 2000 [latest update: #3254] on 11 January 2001 at 4:45:04 pm'!"Change Set:		publishSpeedDate:			11 January 2001Author:			Bob Arning- a couple of small speed increases for project publishing- removed endless looping in #storeSegment"!!Object methodsFor: 'objects from disk' stamp: 'RAA 1/10/2001 14:02'!indexIfCompact	^0		"helps avoid a #respondsTo: in publishing"! !!IdentityDictionary methodsFor: 'private' stamp: 'RAA 1/10/2001 14:57'!fasterKeys	"This was taking some time in publishing and we didn't really need a Set"	| answer index |	answer _ Array new: self size.	index _ 0.	self keysDo: [:key | answer at: (index _ index + 1) put: key].	^ answer! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 1/10/2001 14:03'!copyFromRoots: aRootArray sizeHint: segSizeHint areUnique: areUnique	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  	[1] For exporting a project.  Objects were enumerated by ReferenceStream and aRootArray has them all.	[2] For exporting some classes.  See copyFromRootsForExport:. (Caller must hold Symbols, or they will not get registered in the target system.)	[3] For 'local segments'.  outPointers are kept in the image.	If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize rootSet uniqueRoots |	aRootArray ifNil: [self errorWrongState].	uniqueRoots _ areUnique 		ifTrue: [aRootArray]		ifFalse: [rootSet _ IdentitySet new: aRootArray size * 3.			uniqueRoots _ OrderedCollection new.			1 to: aRootArray size do: [:ii |	"Don't include any roots twice"				(rootSet includes: (aRootArray at: ii)) 					ifFalse: [						uniqueRoots addLast: (aRootArray at: ii).						rootSet add: (aRootArray at: ii)]					ifTrue: [userRootCnt ifNotNil: ["adjust the count"								ii <= userRootCnt ifTrue: [userRootCnt _ userRootCnt - 1]]]].			uniqueRoots].	arrayOfRoots _ uniqueRoots asArray.	rootSet _ uniqueRoots _ nil.	"be clean"	userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].	arrayOfRoots do: [:aRoot | 		aRoot indexIfCompact > 0 ifTrue: [			self error: 'Compact class ', aRoot name, ' cannot be a root'].		aRoot _ nil].	"clean up"	outPointers _ nil.	"may have used this instance before"	segSize _ segSizeHint > 0 ifTrue: [segSizeHint *3 //2] ifFalse: [50000].	["Guess a reasonable segment size"	segmentWordArray _ WordArrayForSegment new: segSize.	[outPointerArray _ Array new: segSize // 20] ifError: [		state _ #tooBig.  ^ self].	"Smalltalk garbageCollect."	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 1/11/2001 10:41'!rootsIncludingPlayers	"Return a new roots array with more objects.  (Caller should store into rootArray.) Player (non-systemDefined) gets its class and metaclass put into the Roots array.  Then ask for the segment again."| extras havePresenter players morphs env existing |userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].extras _ OrderedCollection new.arrayOfRoots do: [:root | 	(root isKindOf: Presenter) ifTrue: [havePresenter _ root].	(root isKindOf: PasteUpMorph) ifTrue: [			root isWorldMorph ifTrue: [havePresenter _ root presenter]].	(root isKindOf: Project) ifTrue: [havePresenter _ root world presenter]].havePresenter ifNotNil: [	havePresenter flushPlayerListCache.		"old and outside guys"	morphs _ IdentitySet new: 400.	havePresenter associatedMorph allMorphsAndBookPagesInto: morphs.	players _ (morphs select: [:m | m player ~~ nil] 				thenCollect: [:m | m player]) asArray.	players _ players select: [:ap | (arrayOfRoots includes: ap class) not		& (ap class isSystemDefined not)].	extras addAll: (players collect: [:each | each class]).	(env _ havePresenter world project environment) ifNil: [		extras addAll: (players collect: [:each | each class class])].	extras addAll: morphs.	"Make then ALL roots!!"	].existing _ arrayOfRoots asIdentitySet.extras _ extras reject: [ :each | existing includes: each].extras isEmpty ifTrue: [^ nil].	"no change"env 	ifNil: ["old pre-environment"		havePresenter _ players _ morphs _ nil.		^ arrayOfRoots, extras]	"will contain multiples of some, but reduced later"	ifNotNil: [		(env includesKey: #Object) ifTrue: [self error: 'only look in local env, not up chain'].			"If get error, use a message other than includesKey:"		extras do: [:cls | 			(env includesKey: cls name) ifFalse: [				env declare: cls name from: Smalltalk]].		havePresenter _ players _ morphs _ env _ nil.		^ arrayOfRoots, extras	"still need in roots in case outside pointers"		]! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 1/10/2001 14:05'!smartFillRoots: dummy	| refs known ours ww blockers |	"Put all traced objects into my arrayOfRoots.  Remove some that want to be in outPointers.  Return blockers, an IdentityDictionary of objects to replace in outPointers."	blockers _ dummy blockers.	known _ (refs _ dummy references) size.	refs fasterKeys do: [:obj | "copy keys to be OK with removing items"		(obj class == Symbol) ifTrue: [refs removeKey: obj.  known _ known-1].		(obj class == PasteUpMorph) ifTrue: [			obj isWorldMorph & (obj owner == nil) ifTrue: [				obj == dummy project world ifFalse: [					refs removeKey: obj.  known _ known-1.					blockers at: obj put: 						(StringMorph contents: 'The worldMorph of a different world')]]].					"Make a ProjectViewMorph here"		"obj class == Project ifTrue: [Transcript show: obj; cr]."		(blockers includesKey: obj) ifTrue: [			refs removeKey: obj ifAbsent: [known _ known+1].  known _ known-1].		].	ours _ dummy project world.	refs keysDo: [:obj |			obj isMorph ifTrue: [				ww _ obj world. 				(ww == ours) | (ww == nil) ifFalse: [					refs removeKey: obj.  known _ known-1.					blockers at: obj put: (StringMorph contents: 								obj printString, ' from another world')]]].	"keep original roots on the front of the list"	(dummy rootObject) do: [:rr | refs removeKey: rr ifAbsent: []].	^ dummy rootObject, refs fasterKeys asArray.! !