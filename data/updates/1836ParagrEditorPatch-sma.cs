'From Squeak2.7 of 5 January 2000 [latest update: #1789] on 5 February 2000 at 6:54:52 pm'!"Change Set:		ParagraphEditor-Patch-sma-thDate:			15 December 1999Author:			Stefan Mathias Aust (sma@3plus4.de)Written by Stefan Matthias Aust and tweaked by Torge Husfeldt so that closeTypeIn is called where needed.These are the new features:Added Crtl+Left and Crtl+Right to move cursor word by word.Added Shift+Crtl+Left and Shift+Crtl+Right to move and select by word.Added Shift+Pos1 and Shift+End to select regions.Added Shift+Del to delete words.Added Crtl+Space or Alt+Space to select as by double clicking.Fixed Alt+(, Alt+"" and Alt+' to do enclosements also on Windows.Fixed problem that Crtl+D (ascii=4) would overwrite End key or the other way round."!!ParagraphEditor reorganize!('initialize-release' changeParagraph: initialize resetState stateArray stateArrayPut:)('accessing' initialText replace:with:and: replaceSelectionWith: selection selectionAsStream selectionInterval setSearch: text userHasEdited zapSelectionWith:)('controlling' controlActivity controlInitialize controlTerminate isControlActive)('scrolling' computeMarkerRegion markerDelta scrollAmount scrollBar scrollBy: scrollRectangleHeight scrollToBottom scrollToTop scrollView: updateMarker viewDelta)('sensor access' processBlueButton processKeyboard processMouseButtons processRedButton processYellowButton)('displaying' display flash)('menu messages' accept again align browseIt browseItHere cancel changeAlignment changeEmphasis changeEmphasisOrAlignment changeStyle chooseAlignment clipboardText clipboardTextPut: compareToClipboard copySelection cut exchange experimentalCommand explain fileItIn find findAgain fit implementorsOfIt lineSelectAndEmptyCheck: methodNamesContainingIt methodSourceContainingIt methodStringsContainingit mvcRedisplay paste performMenuMessage: presentSpecialMenu prettyPrint prettyPrintWithColor referencesToIt selectedSelector selectedSymbol sendersOfIt setSearchString spawn spawnWorkspace specialMenuItems undo)('explain' explainAnySel: explainChar: explainClass: explainCtxt: explainDelimitor: explainGlobal: explainInst: explainMySel: explainNumber: explainPartSel: explainScan: explainTemp:)('editing keys' align: browseIt: browseItHere: cancel: changeEmphasis: changeLfToCr: compareToClipboard: copyHiddenInfo copySelection: cut: doIt: duplicate: enclose: exchange: exploreIt: implementorsOfIt: inOutdent:delta: indent: inspectIt: makeCapitalized: makeLowercase: makeUppercase: methodNamesContainingIt: methodStringsContainingIt: noop: offerFontMenu offerFontMenu: outdent: paste: pasteInitials: printIt: recognizer: referencesToIt: save: sendersOfIt: setEmphasis: shiftEnclose: spawnIt: swapChars: tempCommand: undo:)('nonediting/nontyping keys' comment cursorDown: cursorEnd: cursorHome: cursorLeft: cursorPageDown: cursorPageJump:down: cursorPageUp: cursorRight: cursorUp: selectCurrentTypeIn: selectWord: setSearchString:)('typing/selecting keys' argAdvance: backWord: backspace: changeStyle: crWithIndent: displayIfFalse: displayIfTrue: doAgainMany: doAgainOnce: find: findAgain: forwardDelete: normalCharacter: querySymbol: search: selectAll: simulatedBackspace)('typing support' backTo: closeTypeIn closeTypeIn: dispatchOnCharacter:with: dispatchOnEnterWith: doneTyping insertTypeAhead: openTypeIn readKeyboard recognizeCharacters recognizeCharactersWhileMouseIn: setEmphasisHere simulatedKeystroke: startOfTyping)('undoers' undoAgain:andReselect:typedKey: undoAndReselect:redoAndReselect: undoCutCopy: undoQuery:lastOffering: undoReplace)('undo support' isDoing isRedoing isUndoing noUndoer undoMessage:forRedo: undoer: undoer:with: undoer:with:with: undoer:with:with:with:)('current selection' deselect initializeSelection recomputeInterval recomputeSelection reverseSelection select selectAndScroll selectAndScrollToTop)('new selection' afterSelectionInsertAndSelect: computeIntervalFrom:to: correctFrom:to:with: insertAndSelect:at: nextTokenFrom:direction: notify:at:in: selectAt: selectFrom:to: selectInterval: selectInvisiblyFrom:to: selectLine selectPrecedingIdentifier selectWord)('private' againOnce: againOrSame: againOrSame:many: completeSymbol:lastOffering: exchangeWith: indent:fromStream:toStream: initializeYellowButtonMenu isDisjointFrom: nextWord: nullText previousWord:)('do-its' doIt evaluateSelection exploreIt inspectIt objectsReferencingIt printIt)('as yet unclassified' totalTextHeight visibleHeight)!!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:51'!comment	"All key actions that are neither editing nor typing actions have to	send closeTypeIn at first. See comment in openTypeIn closeTypeIn"! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:31'!cursorDown: characterStream "Private - Move cursor from position in current line to same position innext line. If next line too short, put at end. If shift key down,select."	| shift string right left start position textSize|	self closeTypeIn: characterStream.	shift := sensor leftShiftDown.	sensor keyboard.	string _ paragraph text string.	textSize _ string size.	left _ right _ stopBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	position _ stopBlock stringIndex - left.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue:[right _ right + 1].	right _ start _ right + 1.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue:[right _ right + 1].	shift		ifTrue: 			[			start + position > right				ifTrue: [self selectFrom: startBlock stringIndex to: right - 1]				ifFalse: [self selectFrom: startBlock stringIndex to: start +position - 1]			]		ifFalse: 			[			start + position > right				ifTrue: [self selectFrom: right to: right - 1]				ifFalse: [self selectFrom: start + position to: start + position -1]			].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/22/2000 17:42'!cursorEnd: characterStream "Private - Move cursor end of current line. If cursor already at end ofline, put cursor at end of text"	| string right stringSize |	self closeTypeIn: characterStream.	sensor keyboard.	string _ paragraph text string.	stringSize _ string size.	right _ stopBlock stringIndex.	[right <= stringSize and: [(string at: right) ~= Character cr]]		whileTrue: [right _ right + 1].	sensor commandKeyPressed ifTrue: [right _ stringSize + 1].	sensor leftShiftDown		ifTrue: [self selectFrom: startBlock stringIndex to: right - 1]		ifFalse: [self selectAt: right].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/22/2000 17:42'!cursorHome: characterStream "Private - Move cursor from position in current line to beginning ofcurrent line. If cursor already at beginning of line, put cursor atbeginning of text"	| string left |	self closeTypeIn: characterStream.	sensor keyboard.	string _ paragraph text string.	left _ startBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]]		whileTrue: [left _ left - 1].	sensor commandKeyPressed ifTrue: [left _ 1].	sensor leftShiftDown		ifTrue: [self selectFrom: left to: stopBlock stringIndex - 1]		ifFalse: [self selectAt: left].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:54'!cursorLeft: characterStream 	"Private - Move cursor left one character if nothing selected, otherwise 	move cursor to beginning of selection. If the shift key is down, start 	selecting or extending current selection. Don't allow cursor past 	beginning of text"	| shift left |	self closeTypeIn: characterStream.	shift _ sensor leftShiftDown.	left _ startBlock stringIndex - 1.	sensor controlKeyPressed ifTrue: [left _ self previousWord: left].	sensor keyboard.	shift		ifTrue: [startBlock stringIndex > 1			ifTrue: [self selectFrom: left to: stopBlock stringIndex - 1]]		ifFalse: [(startBlock stringIndex == stopBlock stringIndex and: [startBlock stringIndex > 1])			ifTrue: [self selectAt: left]			ifFalse: [self selectAt: startBlock stringIndex]].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!cursorPageJump: characterStream down: aBoolean"Private - Move cursor from position in current line to same position in the line on the next page up or down (direction is controlled by <aBoolean>. If next line too short, put at end. If shift key down, select.  This method is similar to #cursorDown:.  Haven't figured out how to intercept the shift key yet.See Utilities createPageTestWorkspace to create a test MVC workspace."	| string right left start position textSize currentLineNumber howManyLines visibleHeight totalHeight ratio deltaLines targetLine offsetAtTargetLine |	self closeTypeIn: characterStream.	sensor keyboard.  "Eat the key stroke."	string _ paragraph text string.	textSize _ string size.	left _ right _ stopBlock stringIndex.	"Calculate the position of the left edge."	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue: [left _ left - 1].	"Calculate the offset from the left edge where cursor is now."	position _ stopBlock stringIndex - left.	"Calculate the current line number."	currentLineNumber _ paragraph lineIndexOfCharacterIndex: stopBlock stringIndex.	howManyLines _ paragraph numberOfLines.	visibleHeight _ self visibleHeight.	totalHeight _ self totalTextHeight.	ratio _ visibleHeight / totalHeight.	deltaLines _ (ratio * howManyLines) rounded - 2.	targetLine _ aBoolean		ifTrue: [(currentLineNumber + deltaLines) min: howManyLines]		ifFalse: [(currentLineNumber - deltaLines) max: 1].	offsetAtTargetLine _ (paragraph lines at: targetLine) first.	"Calculate the position of the right edge of text of target line."	right _ offsetAtTargetLine.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue: [right _ right + 1].	start _ offsetAtTargetLine.	start + position > right			ifTrue: [self selectForTopFrom: right to: right - 1]			ifFalse: [self selectForTopFrom: start + position to: start + position - 1].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!cursorRight: characterStream 	"Private - Move cursor right one character if nothing selected, 	otherwise move cursor to end of selection. If the shift key is down, 	start selecting characters or extending already selected characters. 	Don't allow cursor past end of text"	| shift right |	self closeTypeIn: characterStream.	shift _ sensor leftShiftDown.	right _ stopBlock stringIndex + 1.	sensor controlKeyPressed ifTrue: [right _ self nextWord: right].	sensor keyboard.	shift		ifTrue: [self selectFrom: startBlock stringIndex to: right - 1]		ifFalse: [startBlock stringIndex == stopBlock stringIndex				ifTrue: [self selectAt: right]				ifFalse: [self selectAt: stopBlock stringIndex]].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!cursorUp: characterStream "Private - Move cursor from position in current line to same position inprior line. If prior line too short, put at end"	| shift string left position start |	self closeTypeIn: characterStream.	shift := sensor leftShiftDown.	sensor keyboard.	string _ paragraph text string.	left _ startBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	position _ startBlock stringIndex - left.	start _ left.	left _ left - 1.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	left < 1 ifTrue: [left _ 1].	start = 1 ifTrue: [position _ 0].	shift		ifTrue: 			[			(start - left < position and: [start > 1])				ifTrue: [self selectFrom: start - 1 to: stopBlock stringIndex - 1]				ifFalse: [self selectFrom: left + position to: stopBlock stringIndex- 1]			]		ifFalse: 			[			(start - left < position and: [start > 1])				ifTrue: [self selectFrom: start - 1 to: start - 2]				ifFalse: [self selectFrom: left + position to: left + position - 1]			].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!selectCurrentTypeIn: characterStream 	"Select what would be replaced by an undo (e.g., the last typeIn)."	| prior |	self closeTypeIn: characterStream.	prior _ otherInterval.	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectInterval: UndoInterval.	otherInterval _ prior.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'sma 12/15/1999 11:46'!selectWord: characterStream	sensor keyboard.	self closeTypeIn: characterStream.	self selectWord.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!setSearchString: characterStream	"Establish the current selection as the current search string."	| aString |	self closeTypeIn: characterStream.	sensor keyboard.	self lineSelectAndEmptyCheck: [^ true].	aString _  self selection string.	aString size == 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'sma 12/15/1999 12:20'!forwardDelete: characterStream	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex _ startBlock stringIndex.	startIndex > paragraph text size ifTrue:		[sensor keyboard.		^ false].	startIndex = stopBlock stringIndex ifFalse:		["there was a selection"		sensor keyboard.		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval deepCopy.	"umes _ UndoMessage deepCopy.	Set already by openTypeIn"	"usel _ UndoSelection deepCopy."	upara _ UndoParagraph deepCopy.	stopIndex := startIndex.	(sensor keyboard asciiValue = 127 and: [sensor leftShiftDown])		ifTrue: [stopIndex := (self nextWord: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!ParagraphEditor methodsFor: 'typing support' stamp: 'sma 12/15/1999 13:21'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys |	((honorCommandKeys _ Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue:				[self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse:				[self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue:			[^ self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	^ self perform: #normalCharacter: with: typeAheadStream! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:32'!nextWord: position	| string index |	string _ paragraph text string.	index _ position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index _ index + 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index _ index + 1].	^ index! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:33'!previousWord: position	| string index |	string _ paragraph text string.	index _ position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index _ index - 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index _ index - 1].	^ index + 1! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sma 12/15/1999 11:29'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"ParagraphEditor initialize"	| cmdMap cmds |	cmdMap _ Array new: 256 withAll: #noop:.  "use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #backspace:.			"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.			"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"cmd-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.			"space bar key"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	'0123456789-=' do: [ :char | cmdMap at: (char asciiValue + 1) put: #changeEmphasis: ].	'([{''"<' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose: ].	cmdMap at: ($, asciiValue + 1) put: #shiftEnclose:.	cmds _ #(		$a	selectAll:		$b	browseIt:		$c	copySelection:		$d	doIt:		$e	exchange:		$f	find:		$g	findAgain:		$h	setSearchString:		$i	inspectIt:		$j	doAgainOnce:		$k  offerFontMenu:		$l	cancel:		$m	implementorsOfIt:		$n	sendersOfIt:		$o	spawnIt:		$p	printIt:		$q	querySymbol:		$r	recognizer:		$s	save:		$t	tempCommand:		$u	align:		$v	paste:		$w	backWord:		$x	cut:		$y	swapChars:		$z	undo:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).	].	CmdActions _ cmdMap! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sma 12/15/1999 13:29'!initializeShiftCmdKeyShortcuts	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256 withAll: #noop:.  "use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.		"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.			"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.			"space bar key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["	'"''(' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose: ].	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$e	methodStringsContainingIt:		$f	displayIfFalse:		$j	doAgainMany:		$k	changeStyle:		$n	referencesToIt:		$r	indent:		$l	outdent:		$s	search:		$t	displayIfTrue:		$u	changeLfToCr:		$v	pasteInitials:		$w	methodNamesContainingIt:		$x	makeLowercase:		$y	makeUppercase:		$z	makeCapitalized:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).		"plain keys"		cmdMap at: ((cmds at: i) asciiValue - 32 + 1) put: (cmds at: i + 1).		"shifted keys"		cmdMap at: ((cmds at: i) asciiValue - 96 + 1) put: (cmds at: i + 1).		"ctrl keys"	].	ShiftCmdActions _ cmdMap! !"Postscript:"ParagraphEditor initializeCmdKeyShortcuts.ParagraphEditor initializeShiftCmdKeyShortcuts.!