'From Squeak2.6 of 11 October 1999 [latest update: #1606] on 17 November 1999 at 8:44:51 pm'!"Change Set:		wiwDate:			14 November 1999Author:			Bob Arning, Dan IngallsThe second release of the World-In-Window project...Flaps display only in the active world.World window starts stepping when activated.Any click outside stops stepping, then any click inside resumes.Halo bounds and brown drag now work right.Yet to fix...[ ]	Takes two clicks to get to outer menu (tho only 1 to activate another window).[ ]	Possible to lose cursor (exactly how?)"!PasteUpMorph subclass: #WiWPasteUpMorph	instanceVariableNames: 'parentWorld hostWindow '	classVariableNames: 'Debug '	poolDictionaries: ''	category: 'Morphic-WiW'!SystemWindow subclass: #WorldWindow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-WiW'!!Morph methodsFor: 'structure' stamp: 'di 8/4/1999 15:41'!rootAt: location	"Just return myself, unless I am a WorldWindow.	If so, then return the appropriate root in that world"	^ self! !!Morph methodsFor: 'geometry' stamp: 'di 11/17/1999 20:41'!setConstrainedPositionFrom: aPoint	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds."	| trialRect delta boundingMorph |	trialRect _ aPoint extent: self bounds extent.	boundingMorph _ self nearestOwnerThat:		[:o | (o isKindOf: DropShadowMorph) not].		" -- would be nice to just use topRendererOrSelf, but making			DropShadows respond to isRenderer makes them hard to select."	delta _ boundingMorph			ifNil:    [aPoint]			ifNotNil: [trialRect amountToTranslateWithin: boundingMorph constrainingBounds].	self position: aPoint + delta.	self layoutChanged  "So that, eg, surrounding text will readjust"! !!Morph methodsFor: 'WiW support' stamp: 'di 11/17/1999 20:40'!constrainingBounds	^ self bounds! !!Morph methodsFor: 'WiW support' stamp: 'RAA 11/14/1999 14:53'!globalWorldBounds	^self world globalWorldBounds! !!FlapTab methodsFor: 'positioning' stamp: 'RAA 11/14/1999 15:54'!fitOnScreen	| constrainer |	constrainer _ (owner ifNil: [self]) constrainingBounds.	self orientation == #vertical			ifTrue:				[self top: ((self top min: (constrainer bottom- self height)) max: 0)]			ifFalse:				[self left: ((self left min: (constrainer right - self width)) max: 0)]! !!FlapTab methodsFor: 'positioning' stamp: 'RAA 11/14/1999 15:55'!positionObject: anObject	"anObject could be myself or my referent"	| container |	container _ (self currentWorld) constrainingBounds.	"Could consider container _ referent pasteUpMorph, to allow flaps on things other than the world, but for the moment, let's skip it!!"	(edgeToAdhereTo == #left) ifTrue:		[^ anObject left: container left].	(edgeToAdhereTo == #right) ifTrue:		[^ anObject right: container right].	(edgeToAdhereTo == #top) ifTrue:		[^ anObject top: container top].	(edgeToAdhereTo == #bottom) ifTrue:		[^ anObject bottom: container bottom]! !!HaloMorph methodsFor: 'private' stamp: 'di 11/17/1999 20:41'!basicBox	^ (self bounds expandBy: self handleSize + 1)			intersect: (self world constrainingBounds insetBy: 8@8)! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 11/14/1999 15:22'!handleEvent: evt		eventSubscribers do: [:m | m handleEvent: evt]."--"	(evt anyButtonPressed and:	 [evt controlKeyPressed and:	 [lastEvent anyButtonPressed not]]) ifTrue:		[eventTransform _ MorphicTransform identity.		lastEvent _ evt.		^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]]."--"	lastEvent _ evt.	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	evt isMouse ifTrue: [		evt isMouseMove ifTrue: [^ self handleMouseMove: evt].		self world validateMouseEvent: evt.	"allow current world to bail out"		evt isMouseDown ifTrue: [ ^ self handleMouseDown: evt].		evt isMouseUp ifTrue: [^ self handleMouseUp: evt]	].	evt isKeystroke ifTrue: [		keyboardFocus ifNotNil: [keyboardFocus keyStroke: evt].		^ self].! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 8/4/1999 15:41'!argumentOrNil	"Answer the root of the front-most morph under the cursor. If the cursor is not over any morph, answer nil."	owner submorphsDo:		[:m | ((m fullContainsPoint: targetOffset) and: [m isLocked not]) ifTrue: [^ m rootAt: targetOffset]].	^ nil! !!MenuMorph methodsFor: 'control' stamp: 'RAA 11/14/1999 14:53'!popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta tryToPlace selectedOffset |	hand world startSteppingSubmorphsOf: self.	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | each == lastSelection]							ifNone: [self items first].	self fullBounds.  "ensure layout is current"	selectedOffset := selectedItem position - self position.	tryToPlace :=		[ :where :mustFit |		self position: where - selectedOffset.		delta _ self fullBoundsInWorld amountToTranslateWithin: hand globalWorldBounds.		(delta x = 0 or: [mustFit]) ifTrue:			[delta = (0@0) ifFalse: [self position: self position + delta].			sourceItem owner owner addMorphFront: self.			^ self]].	tryToPlace 		value: rightOrLeftPoint first value: false;		value: rightOrLeftPoint last  - (self width @ 0) value: false;		value: rightOrLeftPoint first value: true	! !!MenuMorph methodsFor: 'control' stamp: 'RAA 11/14/1999 14:53'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem i yOffset sub delta |	popUpOwner _ hand.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | each == lastSelection]				ifNone: [self items isEmpty						ifTrue: [^ self]						ifFalse: [self items first]].	"Note: items may not be laid out yet (I found them all to be at 0@0), 	so have to add up heights of items above the selected item."	i _ 0.	yOffset _ 0.	[(sub _ self submorphs at: (i _ i + 1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	self bounds right > hand globalWorldBounds right		ifTrue: [self position: self position - (self bounds width - 4 @ 0)].	delta _ self bounds amountToTranslateWithin: hand globalWorldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self; startSteppingSubmorphsOf: self.	hand newMouseFocus: selectedItem.	self changed! !!MenuMorph methodsFor: 'control' stamp: 'RAA 11/14/1999 14:53'!popUpAt: aPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta |	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self items detect:		 [:each | each == lastSelection] ifNone: [self items first].	self fullBounds.  "ensure layout is current"	self position: aPoint - (selectedItem position - self position).	sourceItem owner owner addMorphFront: self.	delta _ self fullBoundsInWorld amountToTranslateWithin: hand globalWorldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 11/17/1999 11:37'!modelWakeUp	"I am the model of a SystemWindow, that has just been activated"	owner == nil ifTrue: [^ self].  "Not in Morphic world"	(owner isKindOf: TransformMorph) ifTrue: [^ self viewBox: self fullBounds].	self viewBox = owner panelRect ifFalse:		[self viewBox: owner panelRect]! !!PasteUpMorph methodsFor: 'WiW support' stamp: 'RAA 11/14/1999 14:52'!globalWorldBounds	^self bounds! !!PasteUpMorph methodsFor: 'WiW support' stamp: 'RAA 11/14/1999 15:07'!validateMouseEvent: evt	! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 17:02'!becomeTheActiveWorld	| delta |	World == self ifTrue: [^ self].	self damageRecorder reset.	"since we may have moved, old data no longer valid"	hostWindow setStripeColorsFrom: Color green.	parentWorld _ World.	delta _ hostWindow panelRect origin negated.	submorphs do: [ :each | each privateFullMoveBy: delta ].	World _ self.	World assuredCanvas.	self viewBox: hostWindow panelRect.	self installFlaps.	self startSteppingSubmorphsOf: self! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 15:54'!constrainingBounds	^self bounds translateBy: self position negated! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 11:56'!doDeferredUpdating	"If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	DisableDeferredUpdates ifNil: [DisableDeferredUpdates _ false].	DisableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	self resetViewBox.	^ true! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 11:59'!drawSubmorphsOn: aCanvas	self == World ifFalse: [^super drawSubmorphsOn: aCanvas].	aCanvas 		translateBy: self position 		clippingTo: self innerBounds 		during: [ :clippedCanvas |			super drawSubmorphsOn: clippedCanvas		].! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 12:05'!extent: x	super extent: x.	self resetViewBox.! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 14:55'!globalWorldBounds	^self bounds translateBy: self position negated! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/13/1999 22:58'!hostWindow: x	hostWindow _ x.! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 16:34'!invalidRect: damageRect	self == World		ifTrue: [self damageRecorder ifNotNil:					[self damageRecorder recordInvalidRect: damageRect]]		ifFalse: [owner ifNotNil:					[owner invalidRect: (damageRect intersect: bounds)]]! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 15:57'!mouseDown: evt	World == self ifTrue: [^ super mouseDown: evt].	(self bounds containsPoint: evt cursorPoint) ifFalse: [^ self].	self becomeTheActiveWorld! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 12:01'!resetViewBox	| c |	(c _ self canvas) == nil ifTrue: [^self resetViewBoxForReal].	c form == Display ifFalse: [^self resetViewBoxForReal].	c origin = self viewBox origin ifFalse: [^self resetViewBoxForReal].	c clipRect extent = self viewBox extent ifFalse: [^self resetViewBoxForReal].			! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 14:30'!resetViewBoxForReal	self viewBox ifNil: [^self].	self canvas: (		(FormCanvas on: Display)			copyOffset: self viewBox origin 			clipRect: self viewBox	)! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 15:38'!restoreDisplay	self == World ifTrue:  "Else we're a morphic world-window in an mvc worldState and the restoreDisplay was, unusually, issued from the world's menu rather than from the mvc screen menu"		[DisplayScreen startUp.		self extent: Display extent.		"self viewBox: Display boundingBox."		self handsDo: [:h | h endDisplaySuppression].		self restoreFlapsDisplay].	self fullRepaintNeeded! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 16:37'!revertToParentWorld	| delta |	delta _ self canvas origin.	submorphs do: [ :each | each privateFullMoveBy: delta ].	self damageRecorder reset.	"Terminate local display"	World _ parentWorld.	World assuredCanvas.	World installFlaps.	owner changed.	hostWindow setStripeColorsFrom: Color red.! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 16:48'!runStepMethods	self == World ifFalse: [^ self].	super runStepMethods! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 17:25'!validateMouseEvent: evt	"any click outside returns us to our home world"	(self bounds containsPoint: (evt cursorPoint + self position)) ifFalse:		[self revertToParentWorld.		"redispatch that click in outer world"		World primaryHand handleEvent: (evt copy setCursorPoint: evt cursorPoint + self position)].! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 12:09'!viewBox: newViewBox	| vb |	self damageRecorder reset.	"since we may have moved, old data no longer valid"	((vb _ self viewBox) == nil or: [vb ~= newViewBox])		ifTrue: [self canvas: nil].	worldState viewBox: newViewBox.	bounds _ newViewBox.	self assuredCanvas.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self handsDo: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !!WiWPasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 11:04'!say: x	(Debug ifNil: [Debug _ OrderedCollection new])		add: x.	Debug size > 500 ifTrue: [Debug _ Debug copyFrom: 200 to: Debug size]! !!WiWPasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 11:04'!show	Debug inspect.	Debug _ OrderedCollection new.! !!WorldWindow commentStamp: '<historical>' prior: 0!This is the first release of the World-in-Window project. You can see what works by evaluating:	WorldWindow test1.WorldWindows have a red title bar when the world inside is inactive. This changes to green when the world becomes the active world. The world inside becomes activated by clicking in it and answering "yes". When you click outside this world, the parent world resumes control. While its world is inactive, the WorldWindow may be moved and resized like any other. I originally thought about making the world inside active whenever the WorldWindow was active, but this presented difficulties in moving and resizing.!!WorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 12:11'!extent: x	super extent: x.	model ifNil: [^self].	model extent: self panelRect extent.! !!WorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 11/13/1999 23:24'!fullBounds	^self bounds! !!WorldWindow methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 17:56'!mouseUp: evt	(self panelRect containsPoint: evt cursorPoint)		ifTrue: [model becomeTheActiveWorld]! !!WorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 11/11/1999 20:03'!openInWorld: aWorld	"This msg and its callees result in the window being activeOnlyOnTop"	self bounds: (RealEstateAgent initialFrameFor: self).	self firstSubmorph position: (self left + 1) @ (self top + self labelHeight).	aWorld addMorph: self.	self activate.	aWorld startSteppingSubmorphsOf: self! !!WorldWindow class methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 11:12'!test1	"WorldWindow test1."	| window world |	world _ WiWPasteUpMorph newWorldForProject: nil.	window _ (WorldWindow labelled: 'Inner World') model: world.	window addMorph: world.	world hostWindow: window.	window openInWorld! !!WorldWindow class methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 11:39'!test2	"WorldWindow test2."	| window world scrollPane |	world _ WiWPasteUpMorph newWorldForProject: nil.	window _ (WorldWindow labelled: 'Scrollable World') model: world.	window addMorph: (scrollPane _ TwoWayScrollPane new model: world)		frame: (0@0 extent: 1.0@1.0).	scrollPane scroller addMorph: world.	world hostWindow: window.	window openInWorld! !Morph removeSelector: #downwardBounds!WiWPasteUpMorph removeSelector: #position:!WiWPasteUpMorph removeSelector: #preemptsMouseDown:!WiWPasteUpMorph removeSelector: #downwardBounds!WiWPasteUpMorph removeSelector: #isWorldMorph!WiWPasteUpMorph removeSelector: #handlesMouseDown:!WorldWindow removeSelector: #justWentInactive:!WorldWindow removeSelector: #step!WorldWindow removeSelector: #activate!WorldWindow removeSelector: #stepTime!WorldWindow removeSelector: #handlesMouseDown:!WorldWindow removeSelector: #wantsSteps!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."!