'From Squeak3.8gamma of ''24 November 2004'' [latest update: #6643] on 12 April 2005 at 8:01:16 pm'!"Change Set:		WideNamesDate:			12 April 2005Author:			Andreas RaabFinally, change MultiString and MultiSymbol to WideString and WideSymbol."!!String commentStamp: '<historical>' prior: 0!A String is an indexed collection of Characters. Class String provides the abstract super class for ByteString (that represents an array of 8-bit Characters) and WideString (that represents an array of  32-bit characters).  In the similar manner of LargeInteger and SmallInteger, those subclasses are chosen accordingly for a string; namely as long as the system can figure out so, the String is used to represent the given string.Strings support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.Here are a few useful methods to look at...	String match:	String contractTo:String also inherits many useful methods from its hierarchy, such as	SequenceableCollection ,	SequenceableCollection copyReplaceAll:with:!]style[(55 376 188 13 2 18 72 24 2 44)f1,f2,f1,f1LString match:;,f1,f1LString contractTo:;,f1,f1LSequenceableCollection ,;,f1,f1LSequenceableCollection copyReplaceAll:with:;!Smalltalk renameClassNamed: #MultiString as: #WideString!Smalltalk renameClassNamed: #MultiStringTest as: #WideStringTest!Smalltalk renameClassNamed: #MultiSymbol as: #WideSymbol!!ByteArray methodsFor: 'accessing' stamp: 'ar 4/12/2005 17:35'!asWideString	^ WideString fromByteArray: self.! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ar 4/12/2005 17:34'!drawMultiText: command	| boundsEnc colorEnc  text bounds color fontIndexEnc fontIndex |	text := WideString fromByteArray: (command at: 2) asByteArray.	"text asByteArray printString displayAt: 800@0."	"self halt."	boundsEnc := command at: 3.	fontIndexEnc := command at: 4.	colorEnc := command at: 5.	bounds _ self class decodeRectangle: boundsEnc.	fontIndex := self class decodeInteger: fontIndexEnc.	color _ self class decodeColor: colorEnc.	self drawCommand: [ :c |		c drawString: text in: bounds font: (fonts at: fontIndex) color: color ]! !!CanvasEncoder methodsFor: 'drawing' stamp: 'ar 4/12/2005 19:53'!drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c	| fontIndex str |	fontIndex := self establishFont: (fontOrNil ifNil: [ TextStyle defaultFont ]).	str _ s asString.	str isWideString ifTrue: [		self sendCommand: {			String with: CanvasEncoder codeMultiText.			(str copyFrom: firstIndex to: lastIndex) asByteArray asString.			self class encodeRectangle: boundsRect.			self class encodeInteger: fontIndex.			self class encodeColor: c		}	] ifFalse: [		self sendCommand: {			String with: CanvasEncoder codeText.			s asString copyFrom: firstIndex to: lastIndex.			self class encodeRectangle: boundsRect.			self class encodeInteger: fontIndex.			self class encodeColor: c		}	].! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 4/12/2005 19:53'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].		startEncoding _  (sourceString at: startIndex) leadingChar.		selector _ (EncodedCharSet charsetAt: startEncoding) scanSelector.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stopConditions with: kernDelta).	].		^ stops at: EndOfRun! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ar 4/12/2005 17:37'!comeFullyUpOnReload: smartRefStream
	"fix up the objects in the segment that changed size.  An
object in the segment is the wrong size for the modern version of the
class.  Construct a fake class that is the old size.  Replace the
modern class with the old one in outPointers.  Load the segment.
Traverse the instances, making new instances by copying fields, and
running conversion messages.  Keep the new instances.  Bulk forward
become the old to the new.  Let go of the fake objects and classes.
	After the install (below), arrayOfRoots is filled in.
Globalize new classes.  Caller may want to do some special install on
certain objects in arrayOfRoots.
	May want to write the segment out to disk in its new form."

	| mapFakeClassesToReal ccFixups receiverClasses
rootsToUnhiberhate myProject existing |

	RecentlyRenamedClasses _ nil.		"in case old data
hanging around"
	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.
		"Dictionary of just the ones that change shape.
Substitute them in outPointers."
	ccFixups _ self remapCompactClasses: mapFakeClassesToReal
				refStrm: smartRefStream.
	ccFixups ifFalse: [^ self error: 'A class in the file is not
compatible'].
	endMarker _ segment nextObject. 	"for enumeration of objects"
	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	self fixCapitalizationOfSymbols.
	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.
		"Can't use install.  Not ready for rehashSets"
	mapFakeClassesToReal isEmpty ifFalse: [
		self reshapeClasses: mapFakeClassesToReal refStream:
smartRefStream
	].
	"When a Project is stored, arrayOfRoots has all objects in
the project, except those in outPointers"
	arrayOfRoots do: [:importedObject |
		(importedObject isKindOf: WideString) ifTrue: [
			importedObject mutateJISX0208StringToUnicode.
			importedObject class = WideSymbol ifTrue: [
				"self halt."
				Symbol hasInterned: 
importedObject asString ifTrue: [:multiSymbol |
					multiSymbol == importedObject
ifFalse: [
						importedObject
becomeForward: multiSymbol.
					].
				].
			].
		].
		(importedObject isKindOf: TTCFontSet) ifTrue: [
			existing _ TTCFontSet familyName:
importedObject familyName
						pointSize:
importedObject pointSize.	"supplies default"
			existing == importedObject ifFalse:
[importedObject becomeForward: existing].
		].
	].
	"Smalltalk garbageCollect.   MultiSymbol rehash.  These take
time and are not urgent, so don't to them.  In the normal case, no
bad MultiSymbols will be found."

	receiverClasses _ self restoreEndianness.		"rehash sets"
	smartRefStream checkFatalReshape: receiverClasses.

	"Classes in this segment."
	arrayOfRoots do: [:importedObject |
		importedObject class class == Metaclass ifTrue: [self
declare: importedObject]].
	arrayOfRoots do: [:importedObject |
		(importedObject isKindOf: CompiledMethod) ifTrue: [
			importedObject sourcePointer > 0 ifTrue:
[importedObject zapSourcePointer]].
		(importedObject isKindOf: Project) ifTrue: [
			myProject _ importedObject.
			importedObject ensureChangeSetNameUnique.
			Project addingProject: importedObject.
			importedObject restoreReferences.
			self dependentsRestore: importedObject.
			ScriptEditorMorph writingUniversalTiles:
				((importedObject projectPreferenceAt:
#universalTiles) ifNil: [false])]].

	rootsToUnhiberhate _ arrayOfRoots select: [:importedObject |
		importedObject respondsTo: #unhibernate
	"ScriptEditors and ViewerFlapTabs"
	].
	myProject ifNotNil: [
		myProject world setProperty: #thingsToUnhibernate
toValue: rootsToUnhiberhate
	].

	mapFakeClassesToReal isEmpty ifFalse: [
		mapFakeClassesToReal keys do: [:aFake |
			aFake indexIfCompact > 0 ifTrue: [aFake
becomeUncompact].
			aFake removeFromSystemUnlogged].
		SystemOrganization removeEmptyCategories].
	"^ self"
! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ar 4/12/2005 17:37'!fixCapitalizationOfSymbols	"MultiString>>capitalized was not implemented 
correctly. 	Fix eventual accessors and mutators here."	| sym ms |	1 to: outPointers size do:[:i|		sym := outPointers at: i.		(sym class == WideSymbol and:[sym size > 3]) ifTrue:[			((sym beginsWith: 'get')				and:[(sym at: 4) asInteger < 256				and:[(sym at: 4) isLowercase]]) ifTrue:[					ms _ sym asString.					ms at: 4 put: (ms at: 4) asUppercase.					ms _ ms asSymbol.					sym becomeForward: ms.			].			((sym beginsWith: 'set')				and:[(sym at: 4) asInteger < 256				and:[(sym at: 4) isLowercase				and:[sym last = $:				and:[(sym occurrencesOf: $:) = 1]]]]) ifTrue:[					ms _ sym asString.					ms at: 4 put: (ms at: 4) asUppercase.					ms _ ms asSymbol.					sym becomeForward: ms.				].			outPointers at: i put: sym.		].	].! !!JISX0208 class methodsFor: 'class methods' stamp: 'ar 4/12/2005 17:34'!stringFromKutenArray: anArray	| s |	s _ WideString new: anArray size.	1 to: anArray size do: [:i |		s at: i put: (self charAtKuten: (anArray at: i)).	].	^s.! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'ar 4/12/2005 19:53'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].		startEncoding _  (sourceString at: startIndex) leadingChar.		selector _ (EncodedCharSet charsetAt: startEncoding) scanSelector.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stopConditions with: kernDelta).	].		^ stops at: EndOfRun! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'ar 4/12/2005 17:34'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	"Set up margins"	leftMargin _ lineRectangle left.	leftSide ifTrue: [leftMargin _ leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX _ spaceX _ leftMargin.	firstDestX _ destX.	rightMargin _ lineRectangle right.	rightSide ifTrue: [rightMargin _ rightMargin - textStyle rightIndent].	lastIndex _ startIndex.	"scanning sets last index"	destY _ lineRectangle top.	lineHeight _ baseline _ 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	presentationLine _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	numOfComposition _ 0.	spaceCount _ 0.	self handleIndentation.	leftMargin _ destX.	line leftMargin: leftMargin.	presentationLine leftMargin: leftMargin.	presentation _ TextStream on: (Text fromString: (WideString new: text size)).	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading.						^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'ar 4/12/2005 17:34'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	destX _ spaceX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."	baseline _ textStyle baseline.	baselineY _ destY + baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	presentationLine _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	numOfComposition _ 0.	presentation _ TextStream on: (Text fromString: (WideString new: text size)).	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading.						^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!NewParagraph methodsFor: 'selection' stamp: 'ar 4/12/2005 19:53'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ ((text string isWideString) ifTrue: [		MultiCharacterBlockScanner new text: text textStyle: textStyle	] ifFalse: [CharacterBlockScanner new text: text textStyle: textStyle])		characterBlockAtPoint: aPoint index: nil		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'ar 4/12/2005 19:53'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line |	line _ lines at: (self lineIndexForCharacter: index).	^ ((text string isWideString) ifTrue: [		MultiCharacterBlockScanner new text: text textStyle: textStyle	] ifFalse: [		CharacterBlockScanner new text: text textStyle: textStyle	])		characterBlockAtPoint: nil index: ((index max: line first) min: text size+1)		in: line! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'ar 4/12/2005 17:34'!decodeString: string andRuns: runsRaw	| strm runLength runValues newString index |	strm _ ReadStream on: runsRaw from: 1 to: runsRaw size.	(strm peekFor: $( ) ifFalse: [^ nil].	runLength _ OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[runLength add: (Number readFrom: strm)].	runValues _ OrderedCollection new.	[strm atEnd not] whileTrue: 		[runValues add: (Number readFrom: strm).		strm next.].	newString _ WideString new: string size.	index _ 1.	runLength with: runValues do: [:length :leadingChar |		index to: index + length - 1 do: [:pos |			newString at: pos put: (Character leadingChar: leadingChar code: (string at: pos) charCode).		].		index _ index + length.	].	^ newString.! !!SmartRefStream methodsFor: 'conversion' stamp: 'ar 4/12/2005 17:38'!multiStringx0	^ WideString! !!SmartRefStream methodsFor: 'conversion' stamp: 'ar 4/12/2005 17:38'!multiSymbolx0	^ WideSymbol! !!SmartRefStream methodsFor: 'import image segment' stamp: 'ar 4/12/2005 18:06'!mapClass: newClass origName: originalName	"See if instances changed shape.  If so, make a fake class for the old shape and return it.  Remember the original class name."	| newName oldInstVars fakeClass |	newClass isMeta ifTrue: [^ newClass].	newName _ newClass name.	(steady includes: newClass) & (newName == originalName) ifTrue: [^ newClass].		"instances in the segment have the right shape"	oldInstVars _ structures at: originalName ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	"Allow mapping from old to new string names"	(newName == #ByteString and:[originalName == #String]) ifTrue:[^newClass].	(newName == #WideString and:[originalName == #MultiString]) ifTrue:[^newClass].	(newName == #WideSymbol and:[originalName == #MultiSymbol]) ifTrue:[^newClass].	fakeClass _ Object subclass: ('Fake37', originalName) asSymbol		instanceVariableNames: oldInstVars allButFirst		classVariableNames: ''		poolDictionaries: ''		category: 'Obsolete'.	ChangeSet current removeClassChanges: fakeClass name.	"reduce clutter"	^ fakeClass! !!String methodsFor: 'comparing' stamp: 'ar 4/12/2005 19:56'!hash	"#hash is implemented, because #= is implemented"	"ar 4/10/2005: I had to change this to use ByteString hash as initial 	hash in order to avoid having to rehash everything and yet compute	the same hash for ByteString and WideString."	^ self class stringHash: self initialHash: ByteString hash! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 17:36'!asWideString 	self isWideString		ifTrue:[^self]		ifFalse:[^WideString from: self]! !!String methodsFor: 'testing' stamp: 'ar 4/12/2005 19:52'!isWideString	"Answer whether the receiver is a WideString"	^false! !!ByteString methodsFor: 'accessing' stamp: 'ar 4/12/2005 17:33'!at: index put: aCharacter	"Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 64>	aCharacter isCharacter 		ifFalse:[^self errorImproperStore].	aCharacter isOctetCharacter ifFalse:[		"Convert to WideString"		self becomeForward: (WideString from: self).		^self at: index put: aCharacter.	].	index isInteger		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex]! !!ByteString methodsFor: 'accessing' stamp: 'ar 4/12/2005 17:33'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	replacement class == WideString ifTrue: [		self becomeForward: (WideString from: self).	]. 	super replaceFrom: start to: stop with: replacement startingAt: repStart.! !!String class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 17:34'!with: aCharacter	| newCollection |	aCharacter asInteger < 256		ifTrue:[newCollection _ ByteString new: 1]		ifFalse:[newCollection _ WideString new: 1].	newCollection at: 1 put: aCharacter.	^newCollection! !!ByteSymbol methodsFor: 'accessing' stamp: 'ar 4/12/2005 17:51'!species	"Answer the preferred class for reconstructing the receiver."	^ByteString! !!Symbol class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 17:37'!intern: aStringOrSymbol 	^(self lookup: aStringOrSymbol) ifNil:[		| aClass aSymbol |		aStringOrSymbol isSymbol ifTrue:[			aSymbol _ aStringOrSymbol.		] ifFalse:[			aClass := aStringOrSymbol isOctetString ifTrue:[ByteSymbol] ifFalse:[WideSymbol].			aSymbol := aClass new: aStringOrSymbol size.			aSymbol string: aStringOrSymbol.		].		NewSymbols add: aSymbol.		aSymbol].! !!Text methodsFor: 'converting' stamp: 'ar 4/12/2005 17:32'!asOctetStringText	string class == WideString ifTrue: [		^ self class string: string asOctetString runs: self runs copy.	].	^self.! !!WideString methodsFor: 'accessing' stamp: 'ar 4/12/2005 17:36'!replaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>	replacement class == String ifTrue: [		^ self replaceFrom: start to: stop with: (replacement asWideString) startingAt: repStart.	]. 	^ super replaceFrom: start to: stop with: replacement startingAt: repStart.! !!WideString methodsFor: 'testing' stamp: 'ar 4/12/2005 19:52'!isWideString	"Answer whether the receiver is a WideString"	^true! !!WideString class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 19:58'!fromPacked: aLong	"Convert from a longinteger to a String of length 4."	| s val |	s _ self new: 1.	val _ (((aLong digitAt: 4) << 24) bitOr:((aLong digitAt: 3) << 16))				bitOr: (((aLong digitAt: 2) << 8) bitOr: (aLong digitAt: 1)).	s basicAt: 1 put: val.	^ s."WideString fromPacked: 'TEXT' asPacked"! !!WideString class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 20:00'!from: aString 	| newString |	(aString isMemberOf: self)		ifTrue: [^ aString copy].	newString _ self new: aString size.	1 to: aString size do: [:index | newString basicAt: index put: (aString basicAt: index)].	^ newString! !!WideStringTest methodsFor: 'testing - converting' stamp: 'ar 4/12/2005 17:36'!testAsInteger	self assert: '1796exportFixes-tkMX' asWideString asInteger = 1796.	self assert: 'donald' asWideString asInteger isNil.	self assert: 'abc234def567' asWideString asInteger = 234.	self assert: '-94' asWideString asInteger = -94.	self assert: 'foo-bar-92' asWideString asInteger = -92.	self assert: '1796exportFixes-tkMX' asWideString asSignedInteger = 1796.	self assert: 'donald' asWideString asSignedInteger isNil.	self assert: 'abc234def567' asWideString asSignedInteger = 234.	self assert: '-94' asWideString asSignedInteger = -94.	self assert: 'foo-bar-92' asWideString asSignedInteger = -92.	self assert: '1796exportFixes-tkMX' asWideString asUnsignedInteger = 1796.	self assert: 'donald' asWideString asUnsignedInteger isNil.	self assert: 'abc234def567' asWideString asUnsignedInteger = 234.	self assert: '-94' asWideString asUnsignedInteger = 94.	self assert: 'foo-bar-92' asWideString asUnsignedInteger = 92! !!WideSymbol methodsFor: 'accessing' stamp: 'ar 4/12/2005 17:34'!species	"Answer the preferred class for reconstructing the receiver."	^WideString! !!WideSymbol methodsFor: 'testing' stamp: 'ar 4/12/2005 19:52'!isWideString	"Answer whether the receiver is a WideString"	^true! !!WriteStream methodsFor: 'accessing' stamp: 'ar 4/12/2005 17:34'!nextPut: anObject 	"Primitive. Insert the argument at the next position in the Stream	represented by the receiver. Fail if the collection of this stream is not an	Array or a String. Fail if the stream is positioned at its end, or if the	position is out of bounds in the collection. Fail if the argument is not	of the right type for the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 66>	((collection class == ByteString) and: [		anObject isCharacter and:[anObject isOctetCharacter not]]) ifTrue: [			collection _ (WideString from: collection).			^self nextPut: anObject.	].	position >= writeLimit		ifTrue: [^ self pastEndPut: anObject]		ifFalse: 			[position _ position + 1.			^collection at: position put: anObject]! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'ar 4/12/2005 17:34'!next: anInteger 	| multiString |	"self halt."	self isBinary ifTrue: [^ (super next: anInteger) asByteArray].	multiString _ WideString new: anInteger.	1 to: anInteger do: [:index |		| character |		(character _ self next) ifNotNil: [			multiString at: index put: character		] ifNil: [			multiString _ multiString copyFrom: 1 to: index - 1.			^ multiString		]	].	^ multiString.! !WideSymbol removeSelector: #isMultiByteString!WideString removeSelector: #isMultiByteString!Text removeSelector: #asMultiStringText!Symbol removeSelector: #species!String removeSelector: #asMultiString!String removeSelector: #isMultiByteString!ByteArray removeSelector: #asMultiString!