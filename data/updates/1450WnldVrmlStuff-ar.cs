'From Squeak 2.5 of August 6, 1999 on 16 September 1999 at 2:55:48 pm'!"Change Set:		WnldVrmlStuff-arDate:			16 September 1999Author:			Andreas RaabModifications of Wonderland for inclusion of the VRML 97 parser."!VRMLEnumerator subclass: #VRMLWonderlandBuilder	instanceVariableNames: 'myWonderland scene attributes baseActor currentActor defaultCamera progress '	classVariableNames: ''	poolDictionaries: ''	category: 'VRML-Definition'!!FileList methodsFor: 'file list menu' stamp: 'ar 9/16/1999 14:48'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix = 'form') | (suffix = '*') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports'						 'open image as background').		selectors addAll: #(openImageInWindow importImage openAsBackground)].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = 'sp') | (suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile.		labels add: 'load as project'.		selectors add: #openProjectFromFile].	(suffix = 'bo') | (suffix = '*') ifTrue:[		labels add: 'load as book'.		selectors add: #openBookFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'browse code' 'remove line feeds' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges browseFile removeLinefeeds putUpdate)].	(suffix = 'swf') | (suffix = '*') ifTrue:[		labels add:'open as Flash'.		selectors add: #openAsFlash].	(suffix = 'ttf') | (suffix = '*') ifTrue:[		labels add: 'open true type font'.		selectors add: #openAsTTF].	(suffix = 'gz') | (suffix = '*') ifTrue:[		labels addAll: #('view decompressed' 'decompress to file').		selectors addAll: #(viewGZipContents saveGZipContents)].	(suffix = '3ds') | (suffix = '*') ifTrue:[		labels add: 'Open 3DS file'.		selectors add: #open3DSFile].	(suffix = 'tape') | (suffix = '*') ifTrue:		[labels add: 'open for playback'.		selectors add: #openTapeFromFile].	(suffix = 'wrl') | (suffix = '*') ifTrue:		[labels add: 'open in Wonderland'.		selectors add: #openVRMLFile].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	^ Array with: labels with: lines with: selectors! !!FileList methodsFor: 'file list menu' stamp: 'ar 9/16/1999 14:48'!openVRMLFile	| scene |	scene _ Wonderland new.	scene makeActorFromVRML: self fullName.! !!VRMLWonderlandBuilder commentStamp: '<historical>' prior: 0!This class builds a Wonderland representation from a given scene.!!VRMLWonderlandBuilder methodsFor: 'initialize' stamp: 'ar 9/14/1999 23:33'!initializeFor: aWonderland	myWonderland _ aWonderland.	defaultCamera _ aWonderland getDefaultCamera.! !!VRMLWonderlandBuilder methodsFor: 'initialize' stamp: 'ar 8/18/1999 19:46'!on: aVRMLScene	scene _ aVRMLScene! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/14/1999 23:57'!baseActor	^baseActor! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/14/1999 23:57'!baseActor: aWonderlandActor	baseActor _ aWonderlandActor.	self currentActor: baseActor.! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/15/1999 16:29'!buildActors	"Using the given VRML scene build a set of actors for Wonderland"	attributes _ Dictionary new.	Utilities informUserDuring:[:bar| 		progress _ bar.		scene doWith: self].! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/14/1999 19:39'!buildActorsFor: aWonderland	"Using the given VRML scene build a set of actors for Wonderland"	self initializeFor: aWonderland.	self buildActors.! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 8/26/1999 12:28'!createActorFor: aMesh	^self createActorFor: aMesh suffix:''! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/15/1999 18:54'!createActorFor: aMesh name: aString suffix: suffix	| actor |	actor _ myWonderland createSimpleActor: aMesh 					named: aString, suffix					parent: currentActor.	"actor setMaterial: (attributes at: #currentMaterial ifAbsent:[nil])."	^actor! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/9/1999 12:29'!createActorFor: aMesh suffix: aString	^self createActorFor: aMesh			name: (attributes at: #currentName ifAbsent:['unnamed'])			suffix: aString! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/14/1999 19:43'!currentActor	^currentActor! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/14/1999 19:43'!currentActor: aWonderlandActor	currentActor _ aWonderlandActor! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 8/19/1999 13:20'!doAppearance: node	| attr |	attr _ node attributeNamed: 'material'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	attr _ node attributeNamed: 'texture'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	attr _ node attributeNamed: 'textureTransform'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 8/18/1999 20:26'!doCoordinate: node	| attr points |	attr _ node attributeNamed: 'point'.	(attr notNil and:[attr value notNil]) 		ifTrue:[points _ self mfVec3fFrom: attr value].	points == nil		ifTrue:[attributes removeKey: #currentPoints]		ifFalse:[attributes at: #currentPoints put: points].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/15/1999 16:23'!doDirectionalLight: node	| ambientIntensity intensity color on material light dir |	ambientIntensity _ (node attributeNamed:'ambientIntensity') value.	intensity _ (node attributeNamed: 'intensity') value.	color _ (node attributeNamed: 'color') value.	dir _ self positionFrom: (node attributeNamed:'direction') value.	on _ (node attributeNamed:'on') value.	material _ B3DMaterialColor new.	material ambientPart: (color * ambientIntensity).	material diffusePart: (color * intensity).	light _ myWonderland makeLight: (Wonderland wonderlandConstants at: 'directional').	light lightColor: material.	light setDirection: dir.	currentActor ifNotNil:[light reparentTo: currentActor].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/15/1999 16:22'!doImageTexture: node	| attr texFileName tex |	"Create a new texture."	attributes at: #currentTexture put: nil.	attr _ node attributeNamed: 'url'.	(attr notNil and:[attr value notNil]) 		ifTrue:[			texFileName _ (FileDirectory on: (FileDirectory dirPathFor: scene fileURL)) fullNameFor: attr value first.			(FileDirectory default fileExists: texFileName)				ifTrue:[tex _ myWonderland makeTextureFrom: texFileName].			attributes at: #currentTexture put: tex].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/15/1999 18:53'!doIndexedFaceSet: node	| attr faces points mesh |	attributes at: #currentPoints put: nil.	attr _ node attributeNamed: 'coord'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	points _ attributes at: #currentPoints.	points ifNil:[^self].	attr _ node attributeNamed: 'coordIndex'.	(attr notNil and:[attr value notNil]) 		ifTrue:[faces _ self facesFrom: attr value for: points].	faces ifNil:[^self].	mesh _ B3DSimpleMesh withAll: faces.	self assignIndexedNormals: node in: mesh.	self assignIndexedTexCoords: node in: mesh.	self assignIndexedColors: node in: mesh.	mesh _ mesh asIndexedTriangleMesh.	"Try to recycle the actors"	(currentActor == nil or:[currentActor hasMesh])		ifTrue:[self createActorFor: mesh]		ifFalse:[currentActor setMesh: mesh].	currentActor setMaterial: (attributes at: #currentMaterial ifAbsent:[nil]).	currentActor setTexturePointer: (attributes at: #currentTexture ifAbsent:[nil]).! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 8/19/1999 15:50'!doMaterial: node	| ambientIntensity diffuseColor emissiveColor shininess specularColor material |	ambientIntensity _ (node attributeNamed: 'ambientIntensity') value.	diffuseColor _ (node attributeNamed: 'diffuseColor') value.	emissiveColor _ (node attributeNamed:'emissiveColor') value.	shininess _ (node attributeNamed: 'shininess') value.	specularColor _ (node attributeNamed: 'specularColor') value.	"transparency _ (node attributeNamed:'transparency') value."	material _ B3DMaterial new.	material ambientPart: (diffuseColor * ambientIntensity).	material diffusePart: diffuseColor.	material specularPart: specularColor.	material emission: emissiveColor.	material shininess: shininess.	attributes at: #currentMaterial put: material.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/14/1999 21:07'!doNormal: node	| attr points |	attr _ node attributeNamed: 'vector'.	(attr notNil and:[attr value notNil]) 		ifTrue:[points _ self mfVec3fFrom: attr value].	points == nil		ifTrue:[attributes removeKey: #currentNormals]		ifFalse:[attributes at: #currentNormals put: points].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/14/1999 23:12'!doShape: node	| attr |	attributes at: #currentTexture put: nil.	attr _ node attributeNamed: 'appearance'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	attr _ node attributeNamed: 'geometry'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/14/1999 19:15'!doTextureCoordinate: node	| attr points |	attr _ node attributeNamed: 'point'.	(attr notNil and:[attr value notNil]) 		ifTrue:[points _ self mfVec2fFrom: attr value].	points == nil		ifTrue:[attributes removeKey: #currentTexCoords]		ifFalse:[attributes at: #currentTexCoords put: points].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/15/1999 16:20'!doTransform: node	| attr c r s sr t xform oldActor |	attr _ node attributeNamed: 'center'.	attr notNil ifTrue:[c _ self positionFrom: attr value].	attr _ node attributeNamed: 'rotation'.	attr notNil ifTrue:[r _ self rotationFrom: attr value].	attr _ node attributeNamed: 'scale'.	attr notNil ifTrue:[s _ self scaleFrom: attr value].	attr _ node attributeNamed: 'scaleOrientation'.	attr notNil ifTrue:[sr _ self rotationFrom: attr value].	attr _ node attributeNamed: 'translation'.	attr notNil ifTrue:[t _ self positionFrom: attr value].	xform _ B3DMatrix4x4 identity.	xform translation: t+c.	xform _ xform composedWithLocal: r asMatrix4x4.	xform _ xform composedWithLocal: sr asMatrix4x4.	xform _ xform composedWithLocal: (B3DMatrix4x4 identity scaling: s).	xform _ xform composedWithLocal: sr negated asMatrix4x4.	xform _ xform composedWithLocal: (B3DMatrix4x4 identity translation: c negated).	oldActor _ currentActor.	currentActor _ self createActorFor: nil.	currentActor setComposite: xform.	super doTransform: node.	currentActor _ oldActor.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/15/1999 16:21'!doViewpoint: node	| attr pos r fov name m camera |	attr _ node attributeNamed: 'position'.	attr notNil ifTrue:[pos _ self positionFrom: attr value].	attr _ node attributeNamed: 'orientation'.	attr notNil ifTrue:[r _ self rotationFrom: attr value].	attr _ node attributeNamed: 'fieldOfView'.	attr notNil ifTrue:[fov _ attr value radiansToDegrees].	attr _ node attributeNamed: 'description'.	attr notNil ifTrue:[name _ attr value].	m _ B3DMatrix4x4 identity.	m _ m composedWithGlobal: (r asMatrix4x4).	m _ m composedWithGlobal: (B3DMatrix4x4 withOffset: pos).	(currentActor == baseActor and:[defaultCamera ~~ nil]) ifTrue:[		camera _ defaultCamera.		defaultCamera _ nil.	] ifFalse:[		camera _ myWonderland makeCameraNamed: (name ifNil:['camera']) parent: currentActor.	].	camera setComposite: m.	camera setFieldOfView: fov.! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 9/14/1999 23:02'!assignIndexedColors: node in: mesh	| attr colors colorIndex faces vertices |	attributes at: #currentColors put: nil.	attr _ node attributeNamed: 'color'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	colors _ attributes at: #currentColors.	colors == nil ifTrue:[^self].	attr _ node attributeNamed: 'colorIndex'.	(attr notNil and:[attr value notNil]) 		ifFalse:[^self].	colorIndex _ ReadStream on: attr value.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[colorIndex next = -1] whileTrue.		colorIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) color: (colors at: colorIndex next + 1).		].	].! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 9/14/1999 23:02'!assignIndexedNormals: node in: mesh	| attr normals nrmlIndex faces vertices |	attributes at: #currentNormals put: nil.	attr _ node attributeNamed: 'normal'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	normals _ attributes at: #currentNormals.	normals == nil ifTrue:[^self].	attr _ node attributeNamed: 'normalIndex'.	(attr notNil and:[attr value notNil]) 		ifFalse:[^self].	nrmlIndex _ ReadStream on: attr value.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[nrmlIndex next = -1] whileTrue.		nrmlIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) normal: (normals at: nrmlIndex next + 1).		].	].! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 9/14/1999 23:08'!assignIndexedTexCoords: node in: mesh	| attr faces vertices texCoords texIndex |	attributes at: #currentTexCoords put: nil.	attr _ node attributeNamed: 'texCoord'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	texCoords _ attributes at: #currentTexCoords.	texCoords == nil ifTrue:[^self].	attr _ node attributeNamed: 'texCoordIndex'.	(attr notNil and:[attr value notNil]) 		ifFalse:[^self].	texIndex _ ReadStream on: attr value.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[texIndex next = -1] whileTrue.		texIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) texCoord: (texCoords at: texIndex next + 1).		].	].! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 9/14/1999 23:04'!facesFrom: anArray for: vertices	"Create and return a set of faces from the given index array"	| faces vtx |	vtx _ WriteStream on: (Array new: 4).	faces _ WriteStream on: (Array new: anArray size // 4).	anArray do:[:idx|		idx = -1 ifTrue:[			vtx position > 2 				ifTrue:[faces nextPut: (B3DSimpleMeshFace withAll: vtx contents)].			vtx reset.		] ifFalse:[			vtx nextPut: (B3DSimpleMeshVertex new position: (vertices at: idx+1)).		].	].	^faces contents! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 8/19/1999 13:11'!indexedFacesFrom: anArray	"Create and return a set of faces from the given index array"	| faces index idx0 idx1 idx2 |	faces _ WriteStream on: (B3DIndexedTriangleArray new: anArray size // 4).	index _ 0.	[index < anArray size] whileTrue:[		idx0 _ anArray at: (index _ index + 1).		idx1 _ anArray at: (index _ index + 1).		[idx2 _ anArray at: (index _ index + 1).		faces nextPut: (B3DIndexedTriangle with: idx0+1 with: idx1+1 with: idx2+1).		idx1 _ idx2.		index < anArray size			ifTrue:[idx2 _ anArray at: (index_index+1)]			ifFalse:[idx2 _ -1].		idx2 = -1] whileFalse.	].	^faces contents! !!VRMLWonderlandBuilder methodsFor: 'enumerating' stamp: 'ar 9/15/1999 16:29'!doNamedNode: node	| lastName |	progress value:'Creating ', node name,' ...'.	lastName _ attributes at: #currentName ifAbsent:[nil].	attributes at: #currentName put: node name.	super doNamedNode: node.	lastName		ifNil:[attributes removeKey: #currentName]		ifNotNil:[attributes at: #currentName put: lastName].! !!VRMLWonderlandBuilder methodsFor: 'converting' stamp: 'ar 9/15/1999 16:16'!mfVec2fFrom: anArray	"Convert the given array into a B3DVector2Array"	| pts |	pts _ WriteStream on: (B3DTexture2Array new: anArray size).	anArray do:[:spec|		pts nextPut: (B3DVector2 u: (spec at: 1) v: (spec at: 2)).	].	^pts contents! !!VRMLWonderlandBuilder methodsFor: 'converting' stamp: 'ar 9/15/1999 17:33'!mfVec3fFrom: anArray	"Convert the given array into a B3DVector3Array"	| pts |	pts _ WriteStream on: (B3DVector3Array new: anArray size).	anArray do:[:spec|		pts nextPut: (B3DVector3 x: (spec at: 1) y: (spec at: 2) z: 0.0 - (spec at: 3)).	].	^pts contents! !!VRMLWonderlandBuilder methodsFor: 'converting' stamp: 'ar 9/15/1999 17:33'!positionFrom: attr	"Fix up coord systems"	^B3DVector3 x: (attr at: 1) y: (attr at: 2) z: 0.0 - (attr at: 3).! !!VRMLWonderlandBuilder methodsFor: 'converting' stamp: 'ar 9/15/1999 18:20'!rotationFrom: attr	"Fix up coord systems"	^B3DRotation radiansAngle: (attr at: 4) negated axis: 			(B3DVector3 x: (attr at: 1) y: (attr at: 2) z: (attr at: 3))! !!VRMLWonderlandBuilder methodsFor: 'converting' stamp: 'ar 9/15/1999 18:05'!scaleFrom: attr	"Fix up coord systems"	^B3DVector3 x: (attr at: 1) y: (attr at: 2) z: (attr at: 3).! !!VRMLWonderlandBuilder class methodsFor: 'instance creation' stamp: 'ar 8/18/1999 19:46'!on: aVRMLScene	^self new on: aVRMLScene! !!Wonderland methodsFor: 'creating' stamp: 'ar 9/14/1999 19:43'!makeActorFrom3DS: filename	"Creates a new actor using the specification from the given file"	| parent name baseActor newActor actorClass scene globals hierarchy meshSize materials material textureName cameras newCamera |	myUndoStack closeStack.	scene _ ThreeDSParser parseFileNamed: filename.	scene ifNil:[^nil].	globals _ scene at: #globals.	materials _ globals at: #materials ifAbsent:[Dictionary new].	"The remaining objects are the actual named meshes,"	scene removeKey: #globals.	hierarchy _ self createHierarchyFrom3DS: globals.	baseActor _ self makeBaseActorFrom: filename.	"Now create the actors"	scene associationsDo:[:assoc|		name _ assoc key.		actorClass _ WonderlandActor newUniqueClassInstVars: '' classInstVars: ''.		newActor _ actorClass createFor: self.		actorClassList addLast: actorClass.		newActor setName: (self fixNameFrom: name).		"newActor setTexture: texture."		newActor setMesh: (B3DSTriangleMesh from3DS: assoc value).		material _ materials at: (assoc value at: #triList) last ifAbsent:[nil].		(material isKindOf: Association) ifTrue:[			"Note: In this case the name of the texture is the key"			textureName _ material key.			material _ material value].		newActor setMaterial: material.		"newActor setComposite: matrix."		assoc value: newActor.	].	"Create hierarchy"	scene associationsDo:[:assoc|		name _ assoc key.		newActor _ assoc value.		newActor setName: (self uniqueNameFrom: name).		parent _ hierarchy at: name ifAbsent:[nil].		parent == nil ifFalse:[parent _ scene at: parent ifAbsent:[nil]].		parent == nil ifTrue:[parent _ baseActor].		newActor reparentTo: parent.		newActor becomePart.	].	"Create the cameras"	cameras _ globals at: #cameras.	cameras associationsDo:[:assoc|		name _ assoc key.		newCamera _ WonderlandCamera createFor: self.		newCamera setName: (self fixNameFrom: name).		newCamera copySettingsFrom: assoc value.		newCamera reparentTo: baseActor.		newCamera becomePart.	].	meshSize _ baseActor getBoundingBox extent length.	meshSize > 100.0 ifTrue:[		(self inform:'This actor is huge!!You should rescale it to a reasonable size.')].	meshSize < 0.01 ifTrue:[		self inform:'This actor is tiny!!You should rescale it to a reasonable size.'].			myUndoStack openStack.	"Ensure that the new actor's name is unique"	myNamespace at: baseActor getName put: baseActor.	scriptEditor updateActorBrowser.	"Add an undo item to undo the creation of this object"	myUndoStack push: (UndoAction new: [ baseActor removeFromScene.											myNamespace removeKey: baseActor getName ifAbsent: [].											scriptEditor updateActorBrowser.  ] ).	^ baseActor.! !!Wonderland methodsFor: 'creating' stamp: 'ar 9/14/1999 23:58'!makeActorFromVRML: filename	"Creates a new actor using the specification from the given file"	| baseActor parserClass builderClass scene |	parserClass _ Smalltalk at: #VRMLNodeParser ifAbsent:[		self reportErrorToUser:'No VRML parser found'.		^self].	builderClass _ Smalltalk at: #VRMLWonderlandBuilder ifAbsent:[		self reportErrorToUser:'No VRML to Alice converter found'.		^self].	myUndoStack closeStack.	baseActor _ self makeBaseActorFrom: filename.	parserClass == nil		ifFalse:[scene _ parserClass parseFileNamed: filename].	(builderClass == nil or:[scene == nil])		ifFalse:[(builderClass on: scene) 					baseActor: baseActor;					buildActorsFor: self].	myUndoStack openStack.	"Ensure that the new actor's name is unique"	myNamespace at: baseActor getName put: baseActor.	scriptEditor updateActorBrowser.	"Add an undo item to undo the creation of this object"	myUndoStack push: (UndoAction new: [ baseActor removeFromScene.											myNamespace removeKey: baseActor getName ifAbsent: [].											scriptEditor updateActorBrowser.  ] ).	^ baseActor.! !!Wonderland methodsFor: 'creating' stamp: 'ar 9/14/1999 19:40'!makeBaseActorFrom: filename	| protoClass actorClass baseActor name |	"First see if we need to create a prototype class for this model"	protoClass _ self protoClassFor: filename.	"Base actor creation"	actorClass _ protoClass newUniqueClassInstVars: '' classInstVars: ''.	baseActor _ actorClass createFor: self.	actorClassList addLast: actorClass.	name _ FileDirectory localNameFor: filename.	(name findString: FileDirectory dot) = 0 ifFalse:[		name _ name copyFrom: 1 to: (name findString: FileDirectory dot)-1].	baseActor setName: (self uniqueNameFrom: name).	^baseActor! !!Wonderland methodsFor: 'creating' stamp: 'ar 9/14/1999 23:40'!makeCamera	"Add a new camera to the Wonderland"	^self makeCameraNamed:'camera'! !!Wonderland methodsFor: 'creating' stamp: 'ar 9/14/1999 23:40'!makeCameraNamed: aString	"Add a new camera to the Wonderland"	| newClass newCamera name windowName |	newClass _ WonderlandCamera newUniqueClassInstVars: '' classInstVars: ''.	newCamera _ newClass createFor: self.	actorClassList addLast: newClass.	name _ self uniqueNameFrom: aString.	newCamera setName: name.	myNamespace at: name put: newCamera.	windowName _ self uniqueNameFrom: aString,'Window'.	myNamespace at: windowName put: (newCamera getMorph).	cameraList addLast: newCamera.	scriptEditor updateActorBrowser.	"Add an undo action to remove this camera"	myUndoStack push: (UndoAction new: [  cameraList remove: newCamera.											newCamera removeFromScene.											myNamespace removeKey: name ifAbsent: [].											myNamespace removeKey: windowName.											newCamera release.											scriptEditor updateActorBrowser ]).	^ newCamera.! !!Wonderland methodsFor: 'creating' stamp: 'ar 9/14/1999 23:41'!makeCameraNamed: aString parent: parentActor	"Add a new camera to the Wonderland"	| newCamera |	newCamera _ self makeCameraNamed: aString.	parentActor == nil ifFalse:[		newCamera reparentTo: parentActor.		newCamera becomePart].	^newCamera! !!Wonderland methodsFor: 'creating' stamp: 'ar 8/19/1999 16:23'!makeLight: lightType	"Create a light of the specified type and add it to the Wonderland"	^self makeLight: lightType named: nil! !!Wonderland methodsFor: 'creating' stamp: 'ar 8/19/1999 16:23'!makeLight: lightType named: aString	"Create a light of the specified type and add it to the Wonderland"	| newClass theLight name |	"Make sure the user gave us a type of light"	[ WonderlandVerifier VerifyLight: lightType ]		ifError: [ :msg :rcvr |			self reportErrorToUser:				'Squeak could not determine the type of light to create because ', msg.			^ nil ].	"The user gave us a valid type type, so proceed"	(lightType = ambient)		ifTrue: [ newClass _ WonderlandAmbientLight newUniqueClassInstVars: ''									classInstVars: ''.					theLight _ newClass createFor: self. ]		ifFalse: [ (lightType = positional)			ifTrue: [ newClass _ WonderlandPositionalLight newUniqueClassInstVars: ''										classInstVars: ''.					theLight _ newClass createFor: self. ]			ifFalse: [ (lightType = directional)				ifTrue: [ newClass _ WonderlandDirectionalLight newUniqueClassInstVars: ''										classInstVars: ''.						theLight _ newClass createFor: self. ]				ifFalse: [ newClass _ WonderlandSpotLight newUniqueClassInstVars: ''										classInstVars: ''.						theLight _ newClass createFor: self. ]					]				].	actorClassList addLast: newClass.	name _ self uniqueNameFrom: (aString ifNil:['light']).	theLight setName: name.	myNamespace at: name put: theLight.	scriptEditor updateActorBrowser.	lightList addLast: theLight.	^ theLight.! !!Wonderland methodsFor: 'creating' stamp: 'ar 9/14/1999 20:02'!makeTextureFrom: filename	"Create a texture from the given file name"	^self makeTextureFrom: filename flipping: false! !!Wonderland methodsFor: 'creating' stamp: 'ar 9/14/1999 20:01'!makeTextureFrom: filename flipping: aBool	"Create a texture from the given file name and flip it in y if requested"	| tex |	filename == nil ifTrue:[^nil].	^self getSharedTextureDict at: filename ifAbsentPut:[		tex _ (Form fromBMPFileNamed: filename) asTexture.		aBool ifTrue:[tex flipVertically].		tex wrap: true.		tex interpolate: true.		tex envMode: 0.	].! !!Wonderland class methodsFor: 'accessing' stamp: 'ar 8/19/1999 16:20'!wonderlandConstants	^WonderlandConstants! !!WonderlandActor methodsFor: 'set property' stamp: 'ar 9/14/1999 20:02'!setTexture: textureFile	"Sets the object's texture"	(myWonderland getUndoStack) push: (UndoTextureChange for: self from: myTexture).	myTexture _ myWonderland makeTextureFrom: textureFile flipping: true.	myChildren do: [:child | (child isPart) ifTrue: [ child setTexturePointer: myTexture ] ].! !!WonderlandActor methodsFor: 'private' stamp: 'ar 8/20/1999 00:56'!getMesh	^myMesh! !!WonderlandActor methodsFor: 'private' stamp: 'ar 8/19/1999 11:40'!hasMesh	^myMesh notNil! !!WonderlandLightSource methodsFor: 'shading' stamp: 'ar 8/20/1999 00:57'!shadeVertexBuffer: vb with: aMaterial into: colorArray	"This is the generic shading function similar to the primitive.	Subclasses may implement optimized versions but should evaluate	exactly to the same value as in here if they are to be converted into	B3DPrimitiveLights."	| color vtxArray ambientColor vtx direction distance scale cosAngle diffusePart specularPart specDir specularFactor |	self flag: #b3dPrimitive.	vtxArray _ vb vertexArray.	(self hasAmbientPart and:[vb trackAmbientColor not])		ifTrue:[ambientColor _ aMaterial ambientPart * lightColor ambientPart].	(self hasDiffusePart and:[vb trackDiffuseColor not])		ifTrue:[diffusePart _ aMaterial diffusePart].	(self hasSpecularPart and:[vb trackSpecularColor not])		ifTrue:[specularPart _ aMaterial specularPart].	1 to: vb vertexCount do:[:i|		vtx _ vtxArray at: i.		color _ colorArray at: i.		"Compute the direction and distance of light source from vertex"		direction _ self computeDirectionTo: vtx.		distance _ direction length.		(distance = 0.0 or:[distance = 1.0]) ifFalse:[direction /= distance negated].		"Compute the attenuation for the given distance"		self isAttenuated			ifTrue:[scale _ self computeAttenuationFor: distance]			ifFalse:[scale _ 1.0].		"Compute spot light factor"		self hasSpot			ifTrue:[scale _ scale * (self computeSpotFactor: direction)].		"Compute ambient part"		self hasAmbientPart ifTrue:[			vb trackAmbientColor 				ifTrue:[ambientColor _ vtx b3dColor * lightColor ambientPart].			color += (ambientColor * scale).		].		"Compute the diffuse part of the light"		self hasDiffusePart ifTrue:[			"Compute angle from light->vertex to vertex normal"			cosAngle _ vtx normal dot: direction.			"For one-sided lighting negate cosAngle if necessary"			(vb twoSidedLighting not and:[cosAngle < 0.0]) 				ifTrue:[cosAngle _ 0.0 - cosAngle].			"For two-sided lighting check if cosAngle > 0.0 meaning that it is a front face"			cosAngle > 0.0 ifTrue:[				vb trackDiffuseColor ifTrue:[diffusePart _ vtx b3dColor].				color += (diffusePart * lightColor diffusePart * (cosAngle * scale)).			].		].		"Compute specular part of the light"		(self hasSpecularPart and:[aMaterial shininess > 0.0]) ifTrue:[			vb useLocalViewer 				ifTrue:[specDir _ direction - vtx position safelyNormalized]				ifFalse:[specDir _ direction - (0@0@1.0)].			cosAngle _ vtx normal dot: specDir.			cosAngle > 0.0 ifTrue:[				"Normalize the angle"				cosAngle _ cosAngle / specDir length.				"cosAngle should be somewhere between 0 and 1.				If not, then the vertex normal was not normalized"				cosAngle > 1.0 ifTrue:[					specularFactor _ cosAngle raisedTo: aMaterial shininess.				] ifFalse:[					self flag: #TODO. "Use table lookup later"					specularFactor _ cosAngle raisedTo: aMaterial shininess.				].				color += (specularPart * lightColor specularPart * specularFactor).			].		].		self flag: #TODO. "Check specular part"		colorArray at: i put: color.	].! !!WonderlandDirectionalLight methodsFor: 'private' stamp: 'ar 8/19/1999 16:26'!setDirection: dir	direction _ dir.! !!WonderlandPositionalLight methodsFor: 'shading' stamp: 'ar 8/19/1999 16:44'!computeDirectionTo: aB3DPrimitiveVertex	"Compute the lights direction to the given vertex"	^ aB3DPrimitiveVertex  position - (self getPositionVector).! !