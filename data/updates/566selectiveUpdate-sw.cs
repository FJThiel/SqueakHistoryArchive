'From Squeak 2.3 beta of Nov 25, 1998 on 13 January 1999 at 10:17:31 am'!"Change Set:		selectiveUpdate-swDate:			13 January 1999Author:			Scott WallaceProvides a mechanism for selectively updating only through a given update number.To update only up through update #828, for example, evaluate   Utilities updateFromServerThroughUpdateNumber: 828"!!String methodsFor: 'converting' stamp: 'sw 1/10/1999 01:46'!integerAtBeginning	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"	| firstNonDigit |	firstNonDigit _ (self findFirst: [:m | m isDigit not]).	^ firstNonDigit > 1		ifTrue:			[(self copyFrom: 1  to: (firstNonDigit - 1)) asNumber]		ifFalse:			[nil]"'234Whoopie' integerAtBeginning'wimpy' integerAtBeginning'  89Ten ' integerAtBeginning'78 92' integerAtBeginning"! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 1/11/1999 13:35'!newUpdatesOn: serverList throughNumber: aNumber	"Return a list of fully formed URLs of update files we do not yet have.  Go to the listed servers and look at the file 'updates.list' for the names of the last N update files.  We look backwards for the first one we have, and make the list from there.  tk 9/10/97	No updates numbered higher than aNumber (if it is not nil) are returned " 	| existing doc list out ff raw char maxNumber itsNumber |	maxNumber _ aNumber ifNil: [99999].	out _ OrderedCollection new.	existing _ ChangeSorter allChangeSetNames.	existing _ existing collect: [:cngSet | cngSet copyReplaceAll: '/' with: '_'].			"Replace slashes with underbars"	serverList do: [:server |		doc _ HTTPSocket httpGet: server,'updates.list' accept: 'application/octet-stream'.		"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue:			[raw _ doc reset; contents.	"one file name per line"			list _ self extractThisVersion: raw.			list reverseDo: [:fileName |				ff _ (fileName findTokens: '/') last.	"allow subdirectories"				(existing includes: ff sansPeriodSuffix)					ifFalse:						[itsNumber _ ff integerAtBeginning. 						(itsNumber == nil or: [itsNumber <= maxNumber])							ifTrue:								[out addFirst: server, fileName]]					ifTrue: [^ out]].			((out size > 0) or: [char _ doc reset; skipSeparators; next.				(char == $*) | (char == $#)]) ifTrue:					[^ out "we have our list"]].	"else got error msg instead of file"		"Server was down, try next one"].	PopUpMenu notify: 'All code update servers seem to be unavailable'.	^ out! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 1/10/1999 02:02'!readServerUpdatesSaveLocally: saveLocally updateImage: updateImage	^ self readServerUpdatesThrough: nil saveLocally: saveLocally updateImage: updateImage! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 1/10/1999 02:21'!readServerUpdatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.A file on the server called updates.list has the names of the last N update files.  We look backwards for the first one we do not have, and start there""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""Utilities readServerUpdatesThrough: 828 saveLocally: false updateImage: true""Utilities readServerUpdatesThrough: 828 saveLocally: true updateImage: true"	| doc urls failed loaded str |	Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"	Cursor wait showWhile: [(Smalltalk includesKey: #EToySystem)		ifTrue: [ScriptingSystem guessDOLProxy].	urls _ self newUpdatesOn: 		(Utilities serverUrls collect: [:url | url, 'updates/']) throughNumber: maxNumber.	loaded _ 0.	failed _ nil.	urls do: [:this |		failed ifNil:			[doc _ HTTPSocket httpGet: this accept: 'application/octet-stream'.			doc class == String				ifTrue: [failed _ this]	"an error loading"				ifFalse:					[doc reset; text.					doc peek asciiValue = 4	"pure object file"						ifTrue: [failed _ this]	"Must be fileIn, not pure object file"						ifFalse:							["(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."								"HTML source code not supported here yet"							updateImage ifTrue:									[ChangeSorter newChangesFromStream: doc									named: (this findTokens: '/') last].							saveLocally ifTrue:								[self saveUpdate: doc onFile: (this findTokens: '/') last].	"if wanted"							loaded _ loaded + 1]]]]].	str _ loaded printString ,' new update files processed.'.	failed ifNotNil: [str _ str, '\Could not load ' withCRs, (urls size - loaded) printString ,' update files.',						'\Starting with "' withCRs, failed, '".'].	self inform: str.! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 1/10/1999 01:59'!updateFromServerThroughUpdateNumber: aNumber	"Update the image by loading all pending updates from the server.  Also save local copies of the update files if the #updateSavesFile preference is set to true"	self readServerUpdatesThrough: aNumber saveLocally: Preferences updateSavesFile updateImage: true! !Utilities class removeSelector: #newUpdatesOn:!