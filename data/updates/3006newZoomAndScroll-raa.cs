'From Squeak2.9alpha of 17 July 2000 [latest update: #3055] on 1 December 2000 at 8:13 am'!"Change Set:		newZoomAndScrollDate:			20 November 2000Author:			Bob ArningnewZoomAndScrollfifth version:- preset Alan's preferred scale factors for pan and zoom- try to keep center of image centered as we zoomfourth version:- an effort is made to keep the view full of content- two sliders are added to experiment with scale factors for pan/tilt and zoom- we were already doing this: Also, looking ahead into the future a little, each page in the bookmorph will have its own zoom, pan and tilt settings ....third version:- do not rely on continuous mouse moves- adjust things dropped into inner pasteup so that none extend over left or top edgesecond version:- added scripting commands to StoryboardBookMorph for getting and setting scale, offsetX and offsetY (of the current page).first version:- made contents of the zoomer a true playfield in a transformation so multiple morphs are possible-----third version:- zooming/scrolling controls now in a separate area below the page- Balloon interpolating mode now the defaultsecond version:- ZoomAndScrollMorph becomes a PasteUpMorph so it can be in a book- StoryboardBookMorph is a book that uses ZoomAndScrollMorph as its pageszooming and scolling for Alan- get a ZoomAndScrollMorph from the new morph/demo menu- drop any morph in it- drag mouse horizontally to pan- drag mouse vertically to zoom- shift-drag vertically to move up/down- change the instance variable <usingBalloon> to true to use Balloon"!BookMorph subclass: #StoryboardBookMorph	instanceVariableNames: 'alansSliders panAndTiltFactor zoomFactor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Books'!!StoryboardBookMorph commentStamp: 'RAA 12/1/2000 07:51' prior: 0!A BookMorph variant whose pages are instances of ZoomAndScrollMorph. I have a control area where the user may pan, tilt and zoom over the image shown in the page.- drag up and down to zoom in and out- drag left and right to pan- shift-drag up and down to tilt.!TransformationMorph subclass: #TransformationB2Morph	instanceVariableNames: 'worldBoundsToShow useRegularWarpBlt '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!TransformationB2Morph commentStamp: 'RAA 12/1/2000 07:53' prior: 0!A transformation which:- is content to let someone else decide my bounds (I do not try to minimally enclose my submorphs)- can use bi-linear interpolation!PasteUpMorph subclass: #ZoomAndScrollMorph	instanceVariableNames: 'sourceRectangle mouseDownPoint usingBalloon cachedImage image mouseMovePoint panAndTiltFactor zoomFactor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!ZoomAndScrollMorph commentStamp: 'RAA 12/1/2000 07:55' prior: 0!I am the outer part of a transformed view of another pasteup. I know how to translate requests to pan, tilt and zoom into appropriate changes to the transformation!!BookMorph methodsFor: 'navigation' stamp: 'RAA 11/20/2000 12:44'!goToPageMorph: newPage transitionSpec: transitionSpec	| pageIndex aWorld oldPageIndex ascending tSpec readIn |	pages isEmpty ifTrue: [^ self].	self setProperty: #searchContainer toValue: nil.	"forget previous search"	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	pageIndex _ pages identityIndexOf: newPage ifAbsent: [^ self "abort"].	readIn _ newPage isInMemory not.	oldPageIndex _ pages identityIndexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageIndex == nil) or: [newPage == currentPage])			ifTrue: [nil]			ifFalse: [oldPageIndex < pageIndex].	tSpec _ transitionSpec ifNil:  "If transition not specified by requestor..."		[newPage valueOfProperty: #transitionSpec  " ... then consult new page"			ifAbsent: [self transitionSpecFor: self  " ... otherwise this is the default"]].	self flag: #arNote. "Probably unnecessary"	(aWorld _ self world) ifNotNil:		[self primaryHand releaseKeyboardFocus].	currentPage ifNotNil: [currentPage updateCachedThumbnail].	self currentPage ~~ nil		ifTrue:		[(((pages at: pageIndex) owner isKindOf: TransitionMorph)			and: [(pages at: pageIndex) isInWorld])			ifTrue: [^ self  "In the process of a prior pageTurn"].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		ascending ifNotNil:			["Show appropriate page transition and start new page when done"			currentPage stopStepping.			(pages at: pageIndex) position: currentPage position.			^ (TransitionMorph					effect: tSpec second					direction: tSpec third					inverse: (ascending or: [transitionSpec notNil]) not)				showTransitionFrom: currentPage				to: (pages at: pageIndex)				in: self				whenStart: [self playPageFlipSound: tSpec first]				whenDone:					[currentPage delete; fullReleaseCachedState.					self insertPageMorphInCorrectSpot: (pages at: pageIndex).					self adjustCurrentPageForFullScreen.					self snapToEdgeIfAppropriate.					aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].					self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].					(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld].					readIn ifTrue: [currentPage updateThumbnailUrlInBook: self url.						currentPage sqkPage computeThumbnail].	"just store it"					]].		"No transition, but at least decommission current page"		currentPage delete; fullReleaseCachedState].	self insertPageMorphInCorrectSpot: (pages at: pageIndex).	self adjustCurrentPageForFullScreen.	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld].	readIn ifTrue: [currentPage updateThumbnailUrl.		currentPage sqkPage computeThumbnail].	"just store it"! !!BookMorph methodsFor: 'navigation' stamp: 'RAA 11/20/2000 12:43'!insertPageMorphInCorrectSpot: aPageMorph	self addMorphBack: (currentPage _ aPageMorph).! !!Canvas methodsFor: 'Nebraska/embeddedWorlds' stamp: 'RAA 11/21/2000 16:14'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"an attempt to use #displayInterpolatedOn: instead of WarpBlt."	| patchRect subCanvas |	self flag: #bob.		"added to Canvas in hopes it will work for Nebraska"	(aDisplayTransform isPureTranslation) ifTrue: [		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to aClipRect"	patchRect _ (aDisplayTransform globalBoundsToLocal: aClipRect) rounded.	patchRect area = 0 ifTrue: [^self]. 	"oh, well!!"	"Render the submorphs visible in the clipping rectangle, as patchForm"	subCanvas _ FormCanvas extent: patchRect extent depth: self depth.	self isShadowDrawing ifTrue: [		subCanvas shadowColor: self shadowColor	].	subCanvas 		translateBy: patchRect topLeft negated rounded		during: [ :offsetCanvas | aBlock value: offsetCanvas].	subCanvas form 		displayInterpolatedIn: (aClipRect translateBy: self origin) truncated		on: self form.! !!Form methodsFor: 'displaying' stamp: 'RAA 11/21/2000 18:28'!displayInterpolatedIn: aRectangle on: aForm	"Display the receiver on aForm, using interpolation if necessary.		Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine adjustedR |	self extent = aRectangle extent ifTrue:[^self displayOn: aForm at: aRectangle origin].	Smalltalk at: #B3DRenderEngine 		ifPresent:[:engineClass| engine _ (engineClass defaultForPlatformOn: aForm)].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aRectangle;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	"Otherwise use the 3D engine for our purposes"	"there seems to be a slight bug in B3D which the following adjusts for"	adjustedR _ (aRectangle withRight: aRectangle right + 1) translateBy: 0@1.	engine viewport: adjustedR.	engine material: (B3DMaterial new emission: Color white).	engine texture: self.	engine render: (B3DIndexedQuadMesh new plainTextureRect).	engine finish.! !!Player methodsFor: 'slot getters/setters' stamp: 'RAA 11/22/2000 08:43'!getOffsetX	^ self costume offsetX! !!Player methodsFor: 'slot getters/setters' stamp: 'RAA 11/22/2000 08:43'!getOffsetY	^ self costume offsetY! !!Player methodsFor: 'slot getters/setters' stamp: 'RAA 11/22/2000 08:35'!getScale	^ self costume scale! !!Player methodsFor: 'slot getters/setters' stamp: 'RAA 11/22/2000 08:44'!setOffsetX: aNumber	^ self costume offsetX: aNumber! !!Player methodsFor: 'slot getters/setters' stamp: 'RAA 11/22/2000 08:56'!setOffsetY: aNumber	^ self costume offsetY: aNumber! !!Player methodsFor: 'slot getters/setters' stamp: 'RAA 11/22/2000 08:35'!setScale: aNumber	^ self costume scale: aNumber! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:37'!changeTiltFactor: x	currentPage changeTiltFactor: x.	panAndTiltFactor _ x.! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:37'!changeZoomFactor: x	currentPage changeZoomFactor: x.	zoomFactor _ x.! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:38'!getTiltFactor	^panAndTiltFactor ifNil: [panAndTiltFactor _ 0.5].! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:38'!getZoomFactor	^zoomFactor ifNil: [zoomFactor _ 0.5]! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 08:02'!initialize	newPagePrototype _ ZoomAndScrollMorph new extent: Display extent // 3.	super initialize.	self addMorphBack: (		BorderedMorph new			color: Color lightBlue;			extent: 40@40;			vResizing: #rigid;			hResizing: #spaceFill;			borderWidth: 4;			borderColor: Color transparent;			on: #mouseDown send: #zoomerMouseDown: to: self;			on: #mouseMove send: #zoomerMouseMove: to: self;			on: #mouseUp send: #zoomerMouseUp: to: self;			setBalloonText: 'Drag in here to zoom, tilt and pan the page above'	).	alansSliders _ {		{#changeTiltFactor: . #getTiltFactor . 'Pan and tilt sensitivity'}.		{#changeZoomFactor: . #getZoomFactor . 'Zoom sensitivity'}.	} collect: [ :sData |		{			SimpleSliderMorph new				extent: 150@10;				color: Color orange;				sliderColor: Color gray;				target: self; 				actionSelector: sData first;				setBalloonText: sData third;				adjustToValue: (self perform: sData second).			sData second		}	].	alansSliders do: [ :each | self addMorphBack: each first]! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:39'!insertPageMorphInCorrectSpot: aPageMorph	self addMorph: (currentPage _ aPageMorph) behind: submorphs second.	self changeTiltFactor: self getTiltFactor.	self changeZoomFactor: self getZoomFactor.! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:41'!offsetX	^currentPage offsetX! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:41'!offsetX: aNumber	currentPage offsetX: aNumber! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:41'!offsetY	^currentPage offsetY! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:41'!offsetY: aNumber	currentPage offsetY: aNumber! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:35'!scale	^currentPage scale! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:26'!scale: aValue	currentPage scale: aValue! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/20/2000 12:52'!zoomerMouseDown: evt	currentPage zoomerMouseDown: evt! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/20/2000 12:52'!zoomerMouseMove: evt	currentPage zoomerMouseMove: evt! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 15:33'!zoomerMouseUp: evt	currentPage zoomerMouseUp: evt! !!StoryboardBookMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:46'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((#'storyboard'			(	(slot scale 'the scale of the current page' number readWrite player getScale player setScale:)	(slot offsetX 'the X offset of the current page' number readWrite player getOffsetX player setOffsetX:)	(slot offsetY 'the Y offset of the current page' number readWrite player getOffsetY player setOffsetY:)			)	))! !!TransformationB2Morph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 08:12'!adjustAfter: changeBlock 	"same as super, but without reference position stuff"	changeBlock value.	self chooseSmoothing.	self layoutChanged.	owner ifNotNil: [owner invalidRect: bounds]! !!TransformationB2Morph methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/2000 13:32'!computeBounds	"the transform bounds must remain under the control of the owner in this case"! !!TransformationB2Morph methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/2000 16:13'!drawSubmorphsOn: aCanvas	| r1 fullG r2 |	(self innerBounds intersects: aCanvas clipRect) ifFalse: [^self].	useRegularWarpBlt == true ifTrue: [		^aCanvas 			transformBy: transform			clippingTo: ((self innerBounds intersect: aCanvas clipRect) expandBy: 1) rounded			during: [:myCanvas |				submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]			]			smoothing: smoothing	].	r1 _ self innerBounds intersect: aCanvas clipRect.	r1 area = 0 ifTrue: [^self].	fullG _ (transform localBoundsToGlobal: self firstSubmorph fullBounds) rounded.	r2 _ r1 intersect: fullG.	r2 area = 0 ifTrue: [^self]."Q7 at: 1 put: {r2 area. r1 area}."	aCanvas 		transform2By: transform		"#transformBy: for pure WarpBlt"		clippingTo: ((r2 expandBy: 1) rounded intersect: self innerBounds rounded)		during: [:myCanvas |			submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]		]		smoothing: smoothing! !!TransformationB2Morph methodsFor: 'as yet unclassified' stamp: 'RAA 11/20/2000 18:17'!extent: aPoint	| newExtent |	newExtent _ aPoint truncated.	bounds extent = newExtent ifTrue: [^self].	bounds _ bounds topLeft extent: newExtent.	"self recomputeExtent."! !!TransformationB2Morph methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/2000 12:44'!useRegularWarpBlt: aBoolean	useRegularWarpBlt _ aBoolean! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:25'!changeOffsetBy: aPoint	| transform trialOffset innerPasteup keepWidth keepHeight |	transform _ self firstSubmorph.	keepWidth _ transform width "// 4".	keepHeight _ transform height "// 4".	innerPasteup _ transform firstSubmorph.	trialOffset _ transform offset + aPoint.	trialOffset _ 		(trialOffset x 			min: (innerPasteup width * transform scale) - keepWidth 			max: keepWidth - transform width) @ 		(trialOffset y 			min: (innerPasteup height * transform scale) - keepHeight 			max: keepHeight - transform height).	transform offset: trialOffset.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:12'!changeTiltFactor: x	panAndTiltFactor _ x! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:13'!changeZoomFactor: x	zoomFactor _ x! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/2000 16:05'!extent: extentPoint	bounds extent = extentPoint ifFalse: [		cachedImage _ nil.		self changed.		bounds _ bounds topLeft extent: extentPoint.		self layoutChanged.		self changed.	].	self firstSubmorph bounds: self innerBounds.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:15'!getTiltFactor	^panAndTiltFactor ifNil: [panAndTiltFactor _ 0.5].	! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:16'!getZoomFactor	^zoomFactor ifNil: [zoomFactor _ 0.5].	! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 22:49'!panImageBy: pixels	self changeOffsetBy: (pixels * self getTiltFactor * 0.1) @ 0.	"steps _ (pixels abs / 6) exp rounded * pixels sign.""==Alan's preferred factorspan = 0.0425531914893617zoom = 0.099290780141844==="! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 08:12'!scaleImageBy: pixels	| scalePerPixel steps transform factor innerPasteup min1 min2 newScale oldScale scaleR half |	(steps _ (pixels * self getZoomFactor * 0.2) rounded) = 0 ifTrue: [^self].	transform _ self firstSubmorph.	scalePerPixel _ 1.01.	factor _ scalePerPixel raisedTo: steps abs.	steps > 0 ifTrue: [		factor _ 1.0 / factor.	].	newScale _ (oldScale _ transform scale) * factor min: 10.0 max: 0.1.	transform _ self firstSubmorph.	innerPasteup _ transform firstSubmorph.	min1 _ transform width / innerPasteup width asFloat.	min2 _ transform height / innerPasteup height asFloat.	newScale _ (newScale max: min1) max: min2.	transform scale: newScale.	scaleR _ newScale / oldScale.	half _ transform extent // 2.	self changeOffsetBy: scaleR * (transform offset + half) - half - transform offset."==Alan's preferred factorspan = 0.0425531914893617zoom = 0.099290780141844==="! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/29/2000 16:57'!step	| innerPasteUp overlap delta |	innerPasteUp _ self firstSubmorph firstSubmorph.	overlap _ (innerPasteUp submorphs 		inject: 0@0 		into: [ :min :each | min min: each position]) rounded.	overlap = (0@0) ifFalse: [		innerPasteUp submorphs do: [ :each | each position: each position - overlap].		innerPasteUp layoutChanged.	].	mouseMovePoint ifNil: [^self].	delta _ mouseMovePoint - mouseDownPoint.	Sensor shiftPressed ifTrue: [		self tiltImageBy: delta y.	] ifFalse: [		self scaleImageBy: delta y.	].	self panImageBy: delta x.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 08:04'!stepTime	^10		"ms"! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 22:50'!tiltImageBy: pixels	self changeOffsetBy: 0 @ (pixels * self getTiltFactor * 0.1)"	steps _ (pixels abs / 6) exp rounded * pixels sign.""==Alan's preferred factorspan = 0.0425531914893617zoom = 0.099290780141844==="! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/20/2000 12:50'!zoomerMouseDown: evt	mouseDownPoint _ evt cursorPoint.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 15:31'!zoomerMouseMove: evt	mouseMovePoint _ evt cursorPoint.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/2000 15:32'!zoomerMouseUp: evt	mouseMovePoint _ mouseDownPoint _ nil.! !!ZoomAndScrollMorph methodsFor: 'initialization' stamp: 'RAA 11/30/2000 16:45'!createInteriorTransform	| innerPasteUp tm |	innerPasteUp _ PasteUpMorph new.	innerPasteUp 		borderWidth: 0;		minHeight: 100;		minWidth: 100;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		position: 0@0;		extent: 100@100.	tm _ TransformationB2Morph new.	tm setProperty: #rotationCenter toValue: 0@0.	tm useRegularWarpBlt: usingBalloon not.	self addMorph: tm.	tm addMorph: innerPasteUp.	tm beSticky.	innerPasteUp beSticky.	tm		scale: 1.0;		offset: 0@0.	! !!ZoomAndScrollMorph methodsFor: 'initialization' stamp: 'RAA 11/21/2000 16:05'!initialize	usingBalloon _ true.	super initialize.	color _ Color lightGray.	borderColor _ Color red.	self createInteriorTransform.! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 11/22/2000 08:39'!offsetX	| transform |	transform _ self firstSubmorph.	^transform offset x! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 11/22/2000 08:40'!offsetX: aNumber	| transform |	transform _ self firstSubmorph.	transform offset: aNumber @ transform offset y! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 11/22/2000 08:56'!offsetY	| transform |	transform _ self firstSubmorph.	^transform offset y! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 11/22/2000 08:39'!offsetY: aNumber	| transform |	transform _ self firstSubmorph.	transform offset: transform offset x @ aNumber! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 11/22/2000 08:36'!scale	| transform |	transform _ self firstSubmorph.	^transform scale! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 11/22/2000 08:28'!scale: aValue	| transform |	transform _ self firstSubmorph.	transform scale: aValue.! !!ZoomAndScrollMorph methodsFor: 'drag and drop' stamp: 'RAA 11/21/2000 12:37'!acceptDroppingMorph: morphToDrop event: evt	^morphToDrop rejectDropMorphEvent: evt.		"put it back where it came from"! !!ZoomAndScrollMorph methodsFor: 'drag and drop' stamp: 'RAA 11/22/2000 15:40'!wantsDroppedMorph: aMorph event: evt	"we don't, really, but it avoids problem of outer pasteup rejecting a drop for inner pasteup"	^true! !!ZoomAndScrollMorph reorganize!('as yet unclassified' changeOffsetBy: changeTiltFactor: changeZoomFactor: extent: getTiltFactor getZoomFactor panImageBy: scaleImageBy: step stepTime tiltImageBy: zoomerMouseDown: zoomerMouseMove: zoomerMouseUp:)('initialization' createInteriorTransform initialize)('scripting' offsetX offsetX: offsetY offsetY: scale scale:)('drag and drop' acceptDroppingMorph:event: wantsDroppedMorph:event:)!