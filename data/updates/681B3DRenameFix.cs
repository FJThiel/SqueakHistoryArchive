'From Squeak 2.3 of January 14, 1999 on 17 February 1999 at 7:43:03 pm'!"Change Set:		B3DRenameFixDate:			17 February 1999Author:			Andreas RaabRenames a couple of inst vars in the B3DShaderPlugin due to possible clashes with system definitions on the Mac."!B3DEnginePlugin subclass: #B3DShaderPlugin	instanceVariableNames: 'litVertex primLight primMaterial l2vDirection l2vDistance l2vSpecDir lightFlags vbFlags lightScale vtxInColor vtxOutColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Plugins'!!B3DShaderPlugin methodsFor: 'primitives' stamp: 'ar 2/17/1999 19:40'!b3dShadeVertexBuffer	"Primitive. Shade all the vertices in the vertex buffer using the given array of primitive light sources. Return true on success."	| lightArray vtxCount vtxArray lightCount |	self export: true.	self inline: false.	self var: #vtxArray declareC:'float *vtxArray'.	vbFlags _ interpreterProxy stackIntegerValue: 0.	primMaterial _ self stackMaterialValue: 1.	lightArray _ self stackLightArrayValue: 2.	vtxCount _ interpreterProxy stackIntegerValue: 3.	vtxArray _ self stackPrimitiveVertexArray: 4 ofSize: vtxCount.	(vtxArray = nil or:[primMaterial = nil or:[interpreterProxy failed]])		ifTrue:[^interpreterProxy primitiveFail].	"Setup"	litVertex _ vtxArray.	lightCount _ interpreterProxy slotSizeOf: lightArray.	"Go over all vertices"	1 to: vtxCount do:[:i|		"Load the primitive vertex"		self loadPrimitiveVertex.		"Load initial color (e.g., emissive part of vertex and/or material)"		(vbFlags anyMask: VBTrackEmission) ifTrue:[			"Load color from vertex"			vtxOutColor at: 0 put: (vtxInColor at: 0) + (primMaterial at: EmissionRed).			vtxOutColor at: 1 put: (vtxInColor at: 1) + (primMaterial at: EmissionGreen).			vtxOutColor at: 2 put: (vtxInColor at: 2) + (primMaterial at: EmissionBlue).			vtxOutColor at: 3 put: (vtxInColor at: 3) + (primMaterial at: EmissionAlpha).		] ifFalse:[			vtxOutColor at: 0 put: (primMaterial at: EmissionRed).			vtxOutColor at: 1 put: (primMaterial at: EmissionGreen).			vtxOutColor at: 2 put: (primMaterial at: EmissionBlue).			vtxOutColor at: 3 put: (primMaterial at: EmissionAlpha).		].		"For each enabled light source"		0 to: lightCount-1 do:[:j|			"Fetch the light source"			primLight _ self fetchLightSource: j ofObject: lightArray.			"Setup values"			self loadPrimitiveLightSource.			"Compute the color from the light source"			self shadeVertex.		].		"Store the computed color back"		self storePrimitiveVertex.		"And step on to the next vertex"		litVertex _ litVertex + PrimVertexSize.	].	"Clean up stack"	interpreterProxy pop: 6. "Pop args+rcvr"	interpreterProxy pushBool: true.! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/17/1999 19:40'!addPart: lightPart from: materialPart trackFlag: vbTrackFlag scale: scale	"Add the given light part to the output color, scaled by the given scale factor.	If the given flag is set in vbFlags then load the part from the primitive vertex"	| rPart gPart bPart aPart |	self var: #lightPart declareC:'float *lightPart'.	self var: #materialPart declareC:'float *materialPart'.	self var: #scale declareC:'double scale'.	self var: #rPart declareC:'double rPart'.	self var: #gPart declareC:'double gPart'.	self var: #bPart declareC:'double bPart'.	self var: #aPart declareC:'double aPart'.	self inline: true.	(vbFlags anyMask: vbTrackFlag) ifTrue:[		rPart _ (vtxInColor at: 0) * (lightPart at: 0) * scale.		gPart _ (vtxInColor at: 1) * (lightPart at: 1) * scale.		bPart _ (vtxInColor at: 2) * (lightPart at: 2) * scale.		aPart _ (vtxInColor at: 3) * (lightPart at: 3) * scale.	] ifFalse:[		"Note: This should be pre-computed."		rPart _ (materialPart at: 0) * (lightPart at: 0) * scale.		gPart _ (materialPart at: 1) * (lightPart at: 1) * scale.		bPart _ (materialPart at: 2) * (lightPart at: 2) * scale.		aPart _ (materialPart at: 3) * (lightPart at: 3) * scale.	].	vtxOutColor at: 0 put: (vtxOutColor at: 0) + rPart.	vtxOutColor at: 1 put: (vtxOutColor at: 1) + gPart.	vtxOutColor at: 2 put: (vtxOutColor at: 2) + bPart.	vtxOutColor at: 3 put: (vtxOutColor at: 3) + aPart.! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/17/1999 19:39'!computeAttenuation	"Compute the attenuation for the current light and vertex"	lightScale _ 1.0.	(lightFlags anyMask: FlagAttenuated) ifTrue:[		lightScale _ 1.0 / ((primLight at: PrimLightAttenuationConstant) + 			(l2vDistance * ((primLight at: PrimLightAttenuationLinear) + 				(l2vDistance * (primLight at: PrimLightAttenuationSquared)))))].! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/17/1999 19:37'!computeDirection	"Compute the direction for the current light and vertex"	| scale |	self inline: true.	self var: #scale declareC:'double scale'.	(lightFlags anyMask: FlagPositional) ifTrue:[		"Must compute the direction for this vertex"		l2vDirection at: 0 put: (litVertex at: PrimVtxPositionX) - (primLight at: PrimLightPositionX).		l2vDirection at: 1 put: (litVertex at: PrimVtxPositionY) - (primLight at: PrimLightPositionY).		l2vDirection at: 2 put: (litVertex at: PrimVtxPositionZ) - (primLight at: PrimLightPositionZ).		l2vDistance _ self dotProductOf: l2vDirection with: l2vDirection.		(l2vDistance = 0.0 or:[l2vDistance = 1.0]) 			ifFalse:[	l2vDistance _ l2vDistance sqrt.					scale _ -1.0/l2vDistance].		l2vDirection at: 0 put: (l2vDirection at: 0) * scale.		l2vDirection at: 1 put: (l2vDirection at: 1) * scale.		l2vDirection at: 2 put: (l2vDirection at: 2) * scale.	] ifFalse:[		(lightFlags anyMask: FlagDirectional) ifTrue:[			l2vDirection at: 0 put: (primLight at: PrimLightDirectionX).			l2vDirection at: 1 put: (primLight at: PrimLightDirectionY).			l2vDirection at: 2 put: (primLight at: PrimLightDirectionZ).		].	].! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/17/1999 19:38'!computeSpecularDirection	"Computes		l2vSpecDir _ l2vSpecDir - vtx position safelyNormalized.	"	| scale |	self var: #scale declareC:'double scale'.	scale _ self inverseLengthOf: litVertex + PrimVtxPosition.	l2vSpecDir at: 0 put: (l2vSpecDir at: 0) - ((litVertex at: PrimVtxPositionX) * scale).	l2vSpecDir at: 1 put: (l2vSpecDir at: 1) - ((litVertex at: PrimVtxPositionY) * scale).	l2vSpecDir at: 2 put: (l2vSpecDir at: 2) - ((litVertex at: PrimVtxPositionZ) * scale).! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/17/1999 19:37'!computeSpotFactor	"Compute the spot factor for a spot light"	| cosAngle minCos deltaCos |	self returnTypeC:'double'.	self var: #cosAngle declareC:'double cosAngle'.	self var: #minCos declareC:'double minCos'.	self var: #deltaCos declareC:'double deltaCos'.	"Compute cos angle between direction of the spot light and direction to vertex"	cosAngle _ self dotProductOf: primLight + PrimLightDirection with: l2vDirection.	cosAngle _ 0.0 - cosAngle.	minCos _ primLight at: SpotLightMinCos.	cosAngle < minCos ifTrue:[^0.0].	deltaCos _ primLight at: SpotLightDeltaCos.	deltaCos <= 0.00001 ifTrue:[		"No delta -- a sharp boundary between on and off.		Since off has already been determined above, we are on"		^1.0].	"Scale the angle to 0/1 range"	cosAngle _ (cosAngle - minCos) / deltaCos.	^cosAngle raisedTo: (primLight at: SpotLightExponent)! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 2/17/1999 19:39'!shadeVertex	| cosAngle specularFactor |	self var: #cosAngle declareC:'double cosAngle'.	self var: #specularFactor declareC:'double specularFactor'.	self computeDirection.	self computeAttenuation.	(lightFlags anyMask: FlagHasSpot) ifTrue:[		lightScale _ lightScale * self computeSpotFactor.	].	"Compute ambient and diffuse part only if lightScale is non-zero."	(lightScale > 0.001) ifTrue:[		"Compute the ambient part"		(lightFlags anyMask: FlagAmbientPart) ifTrue:[			self addPart: (primLight + AmbientPart) 				from: primMaterial + AmbientPart 				trackFlag: VBTrackAmbient 				scale: lightScale.		].		"Compute the diffuse part"		(lightFlags anyMask: FlagDiffusePart) ifTrue:[			"Compute angle from light->vertex to vertex normal"			cosAngle _ self dotProductOf: (litVertex + PrimVtxNormal) with: l2vDirection.			"For one-sided lighting negate cosAngle if necessary"			((vbFlags bitAnd: VBTwoSidedLighting) = 0 and:[cosAngle < 0.0])				ifTrue:[cosAngle _ 0.0 - cosAngle].			"For two-sided lighting check if cosAngle > 0.0 meaning that it is a front face"			cosAngle > 0.0 ifTrue:[				self addPart: primLight + DiffusePart 					from: primMaterial + DiffusePart 					trackFlag: VBTrackDiffuse 					scale: lightScale * cosAngle.			].		].	]. "lightScale > 0.001"	"Compute the specular part"	((lightFlags anyMask: FlagSpecularPart) and:[		(primMaterial at: MaterialShininess) > 0.0]) ifTrue:[		"Compute specular part"		l2vSpecDir at: 0 put: (l2vDirection at: 0).		l2vSpecDir at: 1 put: (l2vDirection at: 1).		l2vSpecDir at: 2 put: (l2vDirection at: 2).		(vbFlags anyMask: VBUseLocalViewer) 			ifTrue:[self computeSpecularDirection]			ifFalse:[l2vSpecDir at: 2 put: (l2vSpecDir at: 2) - 1.0].		cosAngle _ self dotProductOf: (litVertex + PrimVtxNormal) with: l2vSpecDir.		cosAngle > 0.0 ifTrue:[			"Normalize the angle"			cosAngle _ cosAngle * (self inverseLengthOf: l2vSpecDir).			"cosAngle should be somewhere between 0 and 1.			If not, then the vertex normal was not normalized"			cosAngle > 1.0 ifTrue:[				specularFactor _ cosAngle raisedTo: (primMaterial at: MaterialShininess).			] ifFalse:[				cosAngle = 0.0 					ifTrue:[specularFactor _ 1.0]					ifFalse:[specularFactor _ cosAngle raisedTo: (primMaterial at: MaterialShininess)].			].			self addPart: primLight + SpecularPart 				from: primMaterial + SpecularPart 				trackFlag: VBTrackSpecular 				scale: specularFactor.		].	].! !!B3DShaderPlugin methodsFor: 'other' stamp: 'ar 2/17/1999 19:35'!loadPrimitiveLightSource	self inline: true.	lightFlags _ (self cCoerce: primLight to: 'int*') at: PrimLightFlags.! !!B3DShaderPlugin methodsFor: 'other' stamp: 'ar 2/17/1999 19:40'!loadPrimitiveVertex	"Load the necessary values from the current primitive vertex"	| rgba |	self inline: true.	rgba _ (self cCoerce: litVertex to:'int*') at: PrimVtxColor32.	vtxInColor at: 2 put: (rgba bitAnd: 255) * (1.0 / 255.0).	rgba _ rgba >> 8.	vtxInColor at: 1 put: (rgba bitAnd: 255) * (1.0 / 255.0).	rgba _ rgba >> 8.	vtxInColor at: 0 put: (rgba bitAnd: 255) * (1.0 / 255.0).	rgba _ rgba >> 8.	vtxInColor at: 3 put: (rgba bitAnd: 255) * (1.0 / 255.0).! !!B3DShaderPlugin methodsFor: 'other' stamp: 'ar 2/17/1999 19:41'!storePrimitiveVertex	"Store the computed output color back into the current primitive vertex.	Clamp the r,g,b,a part to be in the range 0-255."	| r g b a |	self inline: true.	r _ ((vtxOutColor at: 0) * 255) asInteger.	r _ (r min: 255) max: 0.	g _ ((vtxOutColor at: 1) * 255) asInteger.	g _ (g min: 255) max: 0.	b _ ((vtxOutColor at: 2) * 255) asInteger.	b _ (b min: 255) max: 0.	a _ ((vtxOutColor at: 3) * 255) asInteger.	a _ (a min: 255) max: 0.	"The following is equal to b + (g << 8) + (r << 16) + (a << 24)"	(self cCoerce: litVertex to:'int*') 		at: PrimVtxColor32 put: b + (g + (r + (a << 8) << 8) << 8). ! !"Postscript:Clean up Undeclared after the rename has been done."Undeclared removeUnreferencedKeys.!