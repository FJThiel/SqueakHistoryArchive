'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:05:47 am'!"Change Set:		Balloon-8-TrueTypeDate:			2 November 1998Author:			Andreas RaabThe change set includes a TrueType font reader that generates a geometric description of the glyphs in a TrueType file."!Object subclass: #TTContourConstruction	instanceVariableNames: 'points '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Support'!Object subclass: #TTFontDescription	instanceVariableNames: 'glyphTable glyphs kernPairs copyright familyName fullName subfamilyName uniqueName versionName postscriptName trademark bounds unitsPerEm ascender descender lineGap '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Fonts'!Object subclass: #TTFontReader	instanceVariableNames: 'charMap glyphs nGlyphs kernPairs infoBar fontDescription '	classVariableNames: 'WinToMacTable '	poolDictionaries: ''	category: 'TrueType-Support'!Object subclass: #TTFontTableDirEntry	instanceVariableNames: 'tag fontData offset length checkSum '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Support'!Object subclass: #TTGlyph	instanceVariableNames: 'bounds contours advanceWidth leftSideBearing rightSideBearing glyphIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Fonts'!TTGlyph subclass: #TTCompositeGlyph	instanceVariableNames: 'glyphs '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Fonts'!Object subclass: #TTKernPair	instanceVariableNames: 'left right value mask '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Fonts'!Object subclass: #TTPoint	instanceVariableNames: 'x y type '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Support'!BorderedMorph subclass: #TTSampleFontMorph	instanceVariableNames: 'font transform smoothing '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Support'!TTSampleFontMorph subclass: #TTSampleStringMorph	instanceVariableNames: 'string ttBounds '	classVariableNames: ''	poolDictionaries: ''	category: 'TrueType-Support'!!ByteArray methodsFor: 'accessing' stamp: 'ar 11/1/1998 20:55'!byteAt: index	^self at: index! !!ByteArray methodsFor: 'accessing' stamp: 'ar 11/1/1998 20:55'!byteAt: index put: value	^self at: index put: value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:44'!longAt: index bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 w h |	aBool ifTrue:[		b0 _ self at: index.		b1 _ self at: index+1.		b2 _ self at: index+2.		w _ self at: index+3.	] ifFalse:[		w _ self at: index.		b2 _ self at: index+1.		b1 _ self at: index+2.		b0 _ self at: index+3.	].	"Minimize LargeInteger arithmetic"	h _ ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.	b2 = 0 ifFalse:[w _ (b2 bitShift: 8) + w].	h = 0 ifFalse:[w _ (h bitShift: 16) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:47'!longAt: index put: value bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 _ value bitShift: -24.	b0 _ (b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80).	b1 _ (value bitShift: -16) bitAnd: 255.	b2 _ (value bitShift: -8) bitAnd: 255.	b3 _ value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:57'!shortAt: index bigEndian: aBool	"Return a 16 bit integer quantity starting from the given byte index"	| uShort |	uShort _ self unsignedShortAt: index bigEndian: aBool.	^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/3/1998 14:20'!shortAt: index put: value bigEndian: aBool	"Store a 16 bit integer quantity starting from the given byte index"	self unsignedShortAt: index put: (value bitAnd: 16r7FFF) - (value bitAnd: -16r8000) bigEndian: aBool.	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index bigEndian: aBool	"Return a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 w |	aBool ifTrue:[		b0 _ self at: index.		b1 _ self at: index+1.		b2 _ self at: index+2.		w _ self at: index+3.	] ifFalse:[		w _ self at: index.		b2 _ self at: index+1.		b1 _ self at: index+2.		b0 _ self at: index+3.	].	"Minimize LargeInteger arithmetic"	b2 = 0 ifFalse:[w _ (b2 bitShift: 8) + w].	b1 = 0 ifFalse:[w _ (b1 bitShift: 16) + w].	b0 = 0 ifFalse:[w _ (b0 bitShift: 24) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index put: value bigEndian: aBool	"Store a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 _ value bitShift: -24.	b1 _ (value bitShift: -16) bitAnd: 255.	b2 _ (value bitShift: -8) bitAnd: 255.	b3 _ value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:51'!unsignedShortAt: index bigEndian: aBool	"Return a 16 bit unsigned integer quantity starting from the given byte index"	^aBool 		ifTrue:[((self at: index) bitShift: 8) + (self at: index+1)]		ifFalse:[((self at: index+1) bitShift: 8) + (self at: index)].! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:53'!unsignedShortAt: index put: value bigEndian: aBool	"Store a 16 bit unsigned integer quantity starting from the given byte index"	aBool ifTrue:[		self at: index put: (value bitShift: -8).		self at: index+1 put: (value bitAnd: 255).	] ifFalse:[		self at: index+1 put: (value bitShift: -8).		self at: index put: (value bitAnd: 255).	].	^value! !!ByteArray methodsFor: 'converting' stamp: 'ar 11/2/1998 00:51'!asByteArray	^self! !!FileList methodsFor: 'file list menu' stamp: 'ar 11/14/1998 23:46'!openAsTTF	(TTFontReader parseFileNamed: self fullName) asMorph open! !!TTContourConstruction commentStamp: '<historical>' prior: 0!This class represents a temporary contour structure during the construction of a TTGlyph from a TrueType file.Instance variables:	points	<Array of: TTPoint>	The points defining this contour!!TTContourConstruction methodsFor: 'accessing'!points	^points! !!TTContourConstruction methodsFor: 'accessing' stamp: 'ar 11/1/1998 22:34'!points: anArray	points _ anArray asArray.! !!TTContourConstruction methodsFor: 'accessing'!segments	| segments |	segments _ OrderedCollection new.	self segmentsDo:[:seg| segments add: seg].	^segments! !!TTContourConstruction methodsFor: 'enumerating' stamp: 'ar 11/3/1998 14:42'!segmentsDo: aBlock	"Evaluate aBlock with the segments of the receiver. This may either be straight line	segments or quadratic bezier curves. The decision is made upon the type flags	in TTPoint as follows:	a) 	To subsequent #OnCurve points define a straight segment	b) 	A #OnCurve point followed by a #OffCurve point followed 		by a #TT_ONCURVE point defines a quadratic bezier segment	c)	Two subsequent #OffCurve points have an implicitely defined 		#OnCurve point at half the distance between them"	| last next mid index |	last _ points first.	"The first point is _always_ on the curve"	(last type == #OnCurve) ifFalse:[		Transcript cr; show:'Bad starting point OffCurve'.		last type: #OnCurve].	index _ 2.	[index <= points size] whileTrue:[		mid _ points at: index.		mid type == #OnCurve ifTrue:[			"Straight segment"			aBlock value: (LineSegment from: last asPoint to: mid asPoint).			last _ mid.		] ifFalse:["Quadratic bezier"			"Read ahead if the next point is on curve"			next _ (index < points size) ifTrue:[points at: (index+1)] ifFalse:[points first].			next type == #OnCurve ifTrue:[				"We'll continue after the end point"				index _ index + 1.			] ifFalse:[ "Calculate center"				next _ (next asPoint + mid asPoint) // 2].			aBlock value:(Bezier2Segment from: last asPoint via: mid asPoint to: next asPoint).			last _ next].		index _ index + 1].	(index = (points size + 1)) ifTrue:[		aBlock value:(LineSegment from: points last asPoint to: points first asPoint)]! !!TTContourConstruction methodsFor: 'converting' stamp: 'ar 11/14/1998 21:17'!asCompressedPoints	"Return the receiver compressed into a PointArray.	All lines will be converted into bezier segments with	the control point set to the start point"	| out minPt maxPt fullRange |	minPt _ -16r7FFF asPoint.	maxPt _ 16r8000 asPoint.	"Check if we need full 32bit range"	fullRange _ points contains:[:any| any asPoint < minPt or:[any asPoint > maxPt]].	fullRange ifTrue:[		out _ WriteStream on: (PointArray new: points size).	] ifFalse:[		out _ WriteStream on: (ShortPointArray new: points size).	].	self segmentsDo:[:segment|		out nextPut: segment start.		segment isBezier2Segment 			ifTrue:[out nextPut: segment via]			ifFalse:[out nextPut: segment start].		out nextPut: segment end.	].	^out contents! !!TTContourConstruction methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut:$(;		print: points size;		"space;		print: self type;"		nextPut:$)! !!TTContourConstruction class methodsFor: 'instance creation'!on: points	^self new points: points! !!TTFontDescription reorganize!('accessing' at: at:put:)('properties' ascender bounds descender lineGap unitsPerEm)('information' copyright familyName fullName postscriptName subfamilyName trademark uniqueName versionName)('converting' asMorph)('private-initialization' flipAroundY setAscender:descender:lineGap: setBounds:unitsPerEm: setGlyphs:mapping: setKernPairs: setStrings:)!!TTFontDescription methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:08'!at: aCharOrInteger	^glyphTable at: aCharOrInteger asInteger+1! !!TTFontDescription methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:08'!at: index put: value	^self shouldNotImplement! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!ascender	^ascender! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!bounds	^bounds! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!descender	^descender! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:48'!lineGap	^lineGap! !!TTFontDescription methodsFor: 'properties' stamp: 'ar 11/14/1998 23:49'!unitsPerEm	^unitsPerEm! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!copyright	^copyright! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!familyName	^familyName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!fullName	^fullName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!postscriptName	^postscriptName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!subfamilyName	^subfamilyName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!trademark	^trademark! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:48'!uniqueName	^uniqueName! !!TTFontDescription methodsFor: 'information' stamp: 'ar 11/14/1998 23:49'!versionName	^versionName! !!TTFontDescription methodsFor: 'converting' stamp: 'ar 11/14/1998 23:47'!asMorph	^TTSampleFontMorph font: self! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/14/1998 20:20'!flipAroundY	bounds _ (bounds origin x @ bounds corner y negated) corner:				(bounds corner x @ bounds origin y negated).	glyphs do:[:glyph| glyph flipAroundY]! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:27'!setAscender: asc descender: desc lineGap: lgap	ascender _ asc.	descender _ desc.	lineGap _ lgap! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:28'!setBounds: aRect unitsPerEm: aNumber	bounds _ aRect.	unitsPerEm _ aNumber.! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:27'!setGlyphs: glyphArray mapping: mappingTable	glyphs _ glyphArray.	glyphTable _ mappingTable.! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:48'!setKernPairs: array	kernPairs _ array! !!TTFontDescription methodsFor: 'private-initialization' stamp: 'ar 11/2/1998 00:46'!setStrings: anArray	copyright _ anArray at: 1.	familyName _ anArray at: 2.	subfamilyName _ anArray at: 3.	uniqueName _ anArray at: 4.	fullName _ anArray at: 5.	versionName _ anArray at: 6.	postscriptName _ anArray at: 7.	trademark _ anArray at: 8.! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'ar 11/2/1998 00:25'!glyphs: glyphArray mapping: glyphTable bounds: aRectangle	^self new setGlyphs: glyphArray mapping: glyphTable bounds: aRectangle! !!TTFontReader reorganize!('public' readFrom:)('processing' processCharMap: processCharacterMappingTable: processCompositeGlyph:contours:from: processFontHeaderTable: processGlyphDataTable:offsets: processHorizontalHeaderTable: processHorizontalMetricsTable:length: processIndexToLocationTable:format: processKerningTable: processMaximumProfileTable: processNamingTable: processSimpleGlyph:contours:from:)('displaying' displayKerningString:on:at:withSize: displayString:on:at:withSize:)('private' display getGlyphFlagsFrom:size: getTableDirEntry:from: open readGlyphXCoords:glyph:nContours:flags:endPoints: readGlyphYCoords:glyph:nContours:flags:endPoints: warn:)!!TTFontReader methodsFor: 'public' stamp: 'ar 11/2/1998 23:51'!readFrom: aStream	| fontData headerEntry maxProfileEntry nameEntry indexLocEntry charMapEntry glyphEntry horzHeaderEntry horzMetricsEntry kerningEntry glyphOffset cmap numHMetrics indexToLocFormat |	"Read the raw font byte data"	(aStream respondsTo: #binary) ifTrue:[aStream binary].	fontData _ aStream contents asByteArray.	fontDescription _ TTFontDescription new.	"Search the tables required to build the font"	(headerEntry _ self getTableDirEntry: 'head' from: fontData) == nil ifTrue:[		^self error:'This font does not have a header table'].	(maxProfileEntry _ self getTableDirEntry: 'maxp' from: fontData) == nil ifTrue:[		^self error:'This font does not have a maximum profile table'].	(nameEntry _ self getTableDirEntry: 'name' from: fontData) == nil ifTrue:[		^self error:'This font does not have a name table'].	(indexLocEntry _ self getTableDirEntry: 'loca' from: fontData) == nil ifTrue:[		^self error:'This font does not have a relocation table'].	(charMapEntry _ self getTableDirEntry: 'cmap' from: fontData) == nil ifTrue:[		^self error:'This font does not have a character map table'].	(glyphEntry _ self getTableDirEntry: 'glyf' from: fontData) == nil ifTrue:[		^self error:'This font does not have a glyph table'].	(horzHeaderEntry _ self getTableDirEntry: 'hhea' from: fontData) == nil ifTrue:[		^self error:'This font does not have a horizontal header table'].	(horzMetricsEntry _ self getTableDirEntry: 'hmtx' from: fontData) == nil ifTrue:[		^self error:'This font does not have a horizontal metrics table'].	(kerningEntry _ self getTableDirEntry: 'kern' from: fontData) == nil ifTrue:[		Transcript cr; show:'This font does not have a kerning table';endEntry].	"Process the data"	indexToLocFormat _ self processFontHeaderTable: headerEntry.	self processMaximumProfileTable: maxProfileEntry.	self processNamingTable: nameEntry.	glyphOffset _ self processIndexToLocationTable: indexLocEntry format: indexToLocFormat.	cmap _ self processCharacterMappingTable: charMapEntry.	(cmap == nil or:[cmap value == nil])		ifTrue:[^self error:'This font has no suitable character mappings'].	self processGlyphDataTable: glyphEntry offsets: glyphOffset.	numHMetrics _ self processHorizontalHeaderTable: horzHeaderEntry.	self processHorizontalMetricsTable: horzMetricsEntry length: numHMetrics.	kerningEntry isNil 		ifTrue:[kernPairs _ #()]		ifFalse:[self processKerningTable: kerningEntry].	charMap _ self processCharMap: cmap.	fontDescription setGlyphs: glyphs mapping: charMap.	fontDescription setKernPairs: kernPairs.	^fontDescription! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:21'!processCharMap: assoc	"Process the given character map"	| charTable glyph cmap |	cmap _ assoc value.	charTable _ Array new: 256.	charTable atAllPut: glyphs first. "Initialize with default glyph"	assoc key = 1 ifTrue:["Mac encoded table"		1 to: 256 do:[:i| 			glyph _ glyphs at: (cmap at: 6+i)+1.			charTable at: i put: glyph]].	assoc key = 3 ifTrue:["Win encoded table"		1 to: 256 do:[:i| 			glyph _ glyphs at: (cmap at: 6+i)+1.			charTable at: (WinToMacTable at: i) put: glyph]].	^charTable! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 23:48'!processCharacterMappingTable: entry	"Read the font's character to glyph index mapping table.	If an appropriate mapping can be found then return an association	with the format identifier and the contents of the table"	| copy initialOffset nSubTables pID sID offset cmapFmt tableLength cmap assoc |	initialOffset _ entry offset.	entry skip: 2. "Skip table version"	nSubTables _ entry nextUShort.	1 to: nSubTables do:[:i|		pID _ entry nextUShort.		sID _ entry nextUShort.		offset _ entry nextULong.		"Check if this is either a Macintosh encoded table		or a Windows encoded table"		(pID = 1 or:[pID = 3]) ifTrue:[			"Go to the beginning of the table"			copy _ entry copy.			copy offset: initialOffset + offset.			cmapFmt _ copy nextUShort.			tableLength _ copy nextUShort.			"We can only read cmaps of type 0 (e.g., byte encoded tables)"			(cmapFmt = 0 "or:[cmapFmt = 4]") ifTrue:[				cmap _ Array new: tableLength.				copy nextBytes: tableLength into: cmap startingAt: initialOffset + offset].			pID = 1 ifTrue:[^pID -> cmap]. "Prefer Macintosh encoding over everything else"			assoc _ pID -> cmap. "Keep it in case we don't find a Mac encoded table"		].	].	^assoc! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/15/1998 01:00'!processCompositeGlyph: glyph contours: nContours from: entry	"Read a composite glyph from the font data. The glyph passed into this method contains some state variables that must be copied into the resulting composite glyph."	| flags glyphIndex hasInstr cGlyph ofsX ofsY iLen a11 a12 a21 a22 m |	cGlyph _ TTCompositeGlyph new.	a11 _ a22 _ 16r4000.	"1.0 in F2Dot14"	a21 _ a12 _ 0.		"0.0 in F2Dot14"	"Copy state"	cGlyph bounds: glyph bounds; glyphIndex: glyph glyphIndex.	hasInstr _ false.	[ flags _ entry nextUShort.	glyphIndex _ entry nextUShort + 1.	(flags bitAnd: 1) = 1 ifTrue:[		ofsX _ entry nextShort.		ofsY _ entry nextShort.	] ifFalse:[		(ofsX _ entry nextByte) > 127 ifTrue:[ofsX _ ofsX - 256].		(ofsY _ entry nextByte) > 127 ifTrue:[ofsY _ ofsY - 256]].	((flags bitAnd: 2) = 2) ifFalse:[self halt].	(flags bitAnd: 8) = 8 ifTrue:[		a11 _ a22 _ entry nextShort].	(flags bitAnd: 64) = 64 ifTrue:[		a11 _ entry nextShort.		a22 _ entry nextShort].	(flags bitAnd: 128) = 128 ifTrue:[		"2x2 transformation"		a11 _ entry nextShort.		a21 _ entry nextShort.		a12 _ entry nextShort.		a22 _ entry nextShort].	m _ MatrixTransform2x3 new.	"Convert entries from F2Dot14 to float"	m a11: (a11 asFloat / 16r4000).	m a12: (a12 asFloat / 16r4000).	m a21: (a21 asFloat / 16r4000).	m a22: (a22 asFloat / 16r4000).	m a13: ofsX.	m a23: ofsY.	cGlyph addGlyph: (glyphs at: glyphIndex) transformation: m.	hasInstr _ hasInstr or:[ (flags bitAnd: 256) = 256].	"Continue as long as the MORE_COMPONENTS bit is set"	(flags bitAnd: 32) = 32] whileTrue.	hasInstr ifTrue:[		iLen _ entry nextUShort.		entry skip: iLen].	^cGlyph! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:42'!processFontHeaderTable: entry"Value				Data Type    DescriptionunitsPerEm			USHORT      Granularity of the font's em square.xMax				USHORT      Maximum X-coordinate for the entire font.xMin				USHORT      Minimum X-coordinate for the entire font.yMax				USHORT      Maximum Y-coordinate for the entire font.yMin				USHORT      Minimum Y-coordinate for the entire font.indexToLocFormat	SHORT       Used when processing the Index To Loc Table."	| origin corner units indexToLocFormat |	entry skip: 4. "Skip table version number"	entry skip: 4. "Skip font revision number"	entry skip: 4. "Skip check sum adjustment"	entry skip: 4. "Skip magic number"	entry skip: 2. "Skip flags"	units _ entry nextUShort.	entry skip: 8. "Skip creation date"	entry skip: 8. "Skip modification date"	"Get min/max values of all glyphs"	origin _ entry nextShort @ entry nextShort.	corner _ entry nextShort @ entry nextShort.	entry skip: 2. "Skip mac style"	entry skip: 2. "Skip lowest rec PPEM"	entry skip: 2. "Skip font direction hint"	indexToLocFormat _ entry nextShort.	fontDescription setBounds: (origin corner: corner) unitsPerEm: units.	^indexToLocFormat! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/3/1998 14:43'!processGlyphDataTable: entry offsets: offsetArray	"Read the actual glyph data from the font.	offsetArray contains the start offsets in the data for each glyph."	| initialOffset glyph nextOffset glyphLength glyphOffset nContours origin corner |	initialOffset _ entry offset.	glyphs _ Array new: nGlyphs.	1 to: nGlyphs do:[:i | 		glyphs at: i put: (TTGlyph new glyphIndex: i-1)].	'Reading glyph data' 		displayProgressAt: Sensor cursorPoint		from: 1 to: nGlyphs during:[:bar|	1 to: nGlyphs do:[:glyphIndex |		bar value: glyphIndex.		glyph _ glyphs at: glyphIndex.		glyphOffset _ offsetArray at: glyphIndex.		nextOffset _ offsetArray at: glyphIndex+1.		glyphLength _ nextOffset - glyphOffset.		glyphLength = 0 ifFalse:[			entry offset: initialOffset + glyphOffset.			nContours _ entry nextShort.			origin _ entry nextShort @ entry nextShort.			corner _ entry nextShort @ entry nextShort.			glyph bounds: (origin corner: corner).			nContours >= 0 ifTrue:[				self processSimpleGlyph: glyph contours: nContours from: entry			] ifFalse:[				glyph _ self processCompositeGlyph: glyph contours: nContours from: entry.				glyphs at: glyphIndex put: glyph]]]	].! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:40'!processHorizontalHeaderTable: entry"ascender           SHORT          Typographic ascent.descender          SHORT          Typographic descent.lineGap            SHORT          Typographic lineGap.numberOfHMetrics   USHORT         Number hMetric entries in the HTMX                                               Table; may be smaller than the total                                             number of glyphs."	| asc desc lGap numHMetrics |	entry skip: 4. "Skip table version"	asc _ entry nextShort.	desc _ entry nextShort.	lGap _ entry nextShort.	entry skip: 2. "Skip advanceWidthMax"	entry skip: 2. "Skip minLeftSideBearing"	entry skip: 2. "Skip minRightSideBearing"	entry skip: 2. "Skip xMaxExtent"	entry skip: 2. "Skip caretSlopeRise"	entry skip: 2. "Skip caretSlopeRun"	entry skip: 10. "Skip 5 reserved shorts"	entry skip: 2. "Skip metricDataFormat"	numHMetrics _ entry nextUShort.	fontDescription setAscender: asc descender: desc lineGap: lGap.	^numHMetrics! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:40'!processHorizontalMetricsTable: entry length: numHMetrics	"Extract the advance width, left side bearing, and right	side bearing for each glyph from the Horizontal Metrics Table."	|  index lastAW glyph |	index _ 1.	[index <= numHMetrics] whileTrue:[		glyph _ glyphs at: index.		glyph advanceWidth: entry nextUShort.		glyph leftSideBearing: entry nextShort.		glyph updateRightSideBearing.		index _ index + 1].	index = (nGlyphs +1) ifTrue:[^true].	lastAW _ (glyphs at: index-1) advanceWidth.	[index <= nGlyphs] whileTrue:[		glyph _ glyphs at: index.		glyph advanceWidth: lastAW.		glyph leftSideBearing: entry nextShort.		glyph updateRightSideBearing.		index _ index + 1].! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:43'!processIndexToLocationTable: entry format: indexToLocFormat"glyphOffset    ULONG[numGlyphs]   An array that contains each glyph's                                 offset into the Glyph Data Table."	| glyphOffset offset|	glyphOffset _ Array new: nGlyphs+1.	1 to: nGlyphs+1 do:[:i|		(indexToLocFormat = 0) ifTrue:[ "Format0: offset/2 is stored"			offset _ entry nextUShort * 2.		] ifFalse:["Format1: store actual offset"			offset _ entry nextULong].		glyphOffset at: i put: offset].	^glyphOffset! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/1/1998 23:21'!processKerningTable: entry	"Extract the kerning information for pairs of glyphs."	| covLow covHigh nKernPairs kp |	entry skip: 2. "Skip table version"	entry skip: 2. "Skip number of sub tables -- we're using the first one only"	entry skip: 2. "Skip current subtable number"	entry skip: 2. "Skip length of subtable"	covHigh _ entry nextByte.	covLow _ entry nextByte.	"Make sure the format is right (kerning table and format type 0)"	((covLow bitAnd: 2) = 2 or:[ covHigh ~= 0]) ifTrue:[^false].	nKernPairs _ entry nextUShort.	entry skip: 2. "Skip search range"	entry skip: 2. "Skip entry selector"	entry skip: 2. "Skip range shift"	kernPairs _ Array new: nKernPairs.	1 to: nKernPairs do:[:i|		kp _ TTKernPair new.		kp left: entry nextUShort.		kp right: entry nextUShort.		kp value: entry nextShort.		kernPairs at: i put: kp].	^true! !!TTFontReader methodsFor: 'processing'!processMaximumProfileTable: entry"numGlyphs         USHORT      The number of glyphs in the font."	entry skip: 4. "Skip Table version number"	nGlyphs _ entry nextUShort.! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/2/1998 00:38'!processNamingTable: entry"copyright         CHARPTR     The font's copyright notice.familyName        CHARPTR     The font's family name.subfamilyName     CHARPTR     The font's subfamily name.uniqueName        CHARPTR     A unique identifier for this font.fullName          CHARPTR     The font's full name (a combination of                                          familyName and subfamilyName).versionName       CHARPTR     The font's version string."	| nRecords initialOffset storageOffset pID sID lID nID length offset multiBytes string strings |	strings _ Array new: 8.	strings atAllPut:''.	initialOffset _ entry offset.	entry skip: 2. "Skip format selector"	"Get the number of name records"	nRecords _ entry nextUShort.	"Offset from the beginning of this table"	storageOffset _ entry nextUShort + initialOffset.	1 to: nRecords do:[:i|		pID _ entry nextUShort.		sID _ entry nextUShort.		lID _ entry nextUShort.		nID _ entry nextUShort.		length _ entry nextUShort.		offset _ entry nextUShort.		"Read only Macintosh or Microsoft strings"		(pID = 1 or:[pID = 3 and:[sID = 1]]) ifTrue:[			"MS uses Unicode all others single byte"			multiBytes _ pID = 3.			string _ entry stringAt: storageOffset + offset length: length multiByte: multiBytes.			"Put the name at the right location.			Note: We prefer Macintosh strings about everything else."			nID < strings size ifTrue:[				(pID = 1 or:[(strings at: nID+1) = ''])					ifTrue:[strings at: nID+1 put: string].			].		].	].	fontDescription setStrings: strings.! !!TTFontReader methodsFor: 'processing' stamp: 'ar 11/1/1998 22:18'!processSimpleGlyph: glyph contours: nContours from: entry	| endPts  nPts iLength flags |	endPts _ Array new: nContours.	1 to: nContours do:[:i| endPts at: i put: entry nextUShort].	glyph initializeContours: nContours with: endPts.	nPts _ endPts last + 1.	iLength _ entry nextUShort. "instruction length"	entry skip: iLength.	flags _ self getGlyphFlagsFrom: entry size: nPts.	self readGlyphXCoords: entry glyph: glyph nContours: nContours flags: flags endPoints: endPts.	self readGlyphYCoords: entry glyph: glyph nContours: nContours flags: flags endPoints: endPts.	glyph buildContours.! !!TTFontReader methodsFor: 'displaying' stamp: 'ar 11/1/1998 21:04'!displayKerningString: aString on: aGraphicsContext at: aPoint withSize: scale	| glyph start last kp mask char |	start _ aPoint.	last _ nil.	1 to: aString size do:[:i|		char _ aString at: i.		glyph _ charMap at: char.		last = nil ifFalse:[			mask _ TTKernPair maskFor: last glyphIndex with: glyph glyphIndex.			kp _ kernPairs detect:[:any| any mask = mask] ifNone:[nil].			kp isNil ifFalse:[start x: start x + (kp value * scale x)]].		glyph displayCharOn: aGraphicsContext at: start withSize: scale.		start x: start x + (glyph advanceWidth * scale x).		last _ glyph	].! !!TTFontReader methodsFor: 'displaying'!displayString: aString on: aGraphicsContext at: aPoint withSize: scale	| glyph start char |	start _ aPoint.	1 to: aString size do:[:i|		char _ aString at: i.		glyph _ charMap at: char.		glyph displayCharOn: aGraphicsContext at: start withSize: scale.		start x: start x + (glyph advanceWidth * scale x).	].! !!TTFontReader methodsFor: 'private'!display	| gc delay |	gc _ ScheduledControllers activeController view graphicsContext.	delay _ Delay forMilliseconds: 100.	glyphs do:[:g| 		gc clear.		g displayOn: gc.		delay wait].! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:33'!getGlyphFlagsFrom: entry size: nPts	"Read in the flags for this glyph.  The outer loop gathers the flags that	are actually contained in the table.  If the repeat bit is set in a flag	then the next byte is read from the table; this is the number of times	to repeat the last flag.  The inner loop does this, incrementing the	outer loops index each time."	| flags index repCount flagBits |	flags _ ByteArray new: nPts.	index _ 1.	[index <= nPts] whileTrue:[		flagBits _ entry nextByte.		flags at: index put: flagBits.		(flagBits bitAnd: 8) = 8 ifTrue:[			repCount _ entry nextByte.			repCount timesRepeat:[				index _ index + 1.				flags at: index put: flagBits]].		index _ index + 1].	^flags! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:33'!getTableDirEntry: tagString from: fontData	"Find the table named tagString in fontData and return a table directory entry for it."	| nTables pos currentTag tag |	nTables _ fontData shortAt: 5 bigEndian: true.	tag _ ByteArray new: 4.	1 to: 4 do:[:i| tag byteAt: i put: (tagString at: i) asInteger].	tag _ tag longAt: 1 bigEndian: true.	pos _ 13.	1 to: nTables do:[:i|		currentTag _ fontData longAt: pos bigEndian: true.		currentTag = tag ifTrue:[^TTFontTableDirEntry on: fontData at: pos].		pos _ pos+16].	^nil! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/1/1998 19:59'!open	"^(ScheduledWindow new)		component: (TTFontView model: self);		openWithExtent: 400@400."! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:36'!readGlyphXCoords:entry glyph: glyph nContours: nContours flags: flags endPoints: endPts	"Read the x coordinates for the given glyph from the font file."	| startPoint endPoint flagBits xValue contour ttPoint |	startPoint _ 1.	1 to: nContours do:[:i|		contour _ glyph contours at: i.		"Get the end point"		endPoint _ (endPts at: i) + 1.		"Store number of points"		startPoint to: endPoint do:[:j|			ttPoint _ contour points at: (j - startPoint + 1).			flagBits _ flags at: j.			"If bit zero in the flag is set then this point is an on-curve			point, if not, then it is an off-curve point."			(flagBits bitAnd: 1) = 1 				ifTrue:[ ttPoint type: #OnCurve]				ifFalse:[ttPoint type: #OffCurve].			"First we check to see if bit one is set.  This would indicate that			the corresponding coordinate data in the table is 1 byte long.			If the bit is not set, then the coordinate data is 2 bytes long."			(flagBits bitAnd: 2) = 2 ifTrue:[ "one byte"				xValue _ entry nextByte.				xValue _ (flagBits bitAnd: 16)=16 ifTrue:[xValue] ifFalse:[xValue negated].				ttPoint x: xValue.			] ifFalse:[ "two byte"				"If bit four is set, then this coordinate is the same as the				last one, so the relative offset (of zero) is stored.  If bit				is not set, then read in two bytes and store it as a signed value."				(flagBits bitAnd: 16) = 16 ifTrue:[ ttPoint x: 0 ]				ifFalse:[					xValue _ entry nextShort.					ttPoint x: xValue]]].		startPoint _ endPoint + 1]! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/2/1998 01:37'!readGlyphYCoords:entry glyph: glyph nContours: nContours flags: flags endPoints: endPts	"Read the y coordinates for the given glyph from the font file."	| startPoint endPoint flagBits yValue contour ttPoint |	startPoint _ 1.	1 to: nContours do:[:i|		contour _ glyph contours at: i.		"Get the end point"		endPoint _ (endPts at: i) + 1.		"Store number of points"		startPoint to: endPoint do:[:j|			ttPoint _ contour points at: (j - startPoint + 1).			flagBits _ flags at: j.			"Check if this value one or two byte encoded"			(flagBits bitAnd: 4) = 4 ifTrue:[ "one byte"				yValue _ entry nextByte.				yValue _ (flagBits bitAnd: 32)=32 ifTrue:[yValue] ifFalse:[yValue negated].				ttPoint y: yValue.			] ifFalse:[ "two byte"				(flagBits bitAnd: 32) = 32 ifTrue:[ ttPoint y: 0 ]				ifFalse:[					yValue _ entry nextShort.					ttPoint y: yValue]]].		startPoint _ endPoint + 1]! !!TTFontReader methodsFor: 'private' stamp: 'ar 11/1/1998 21:01'!warn: aString	Transcript cr; show: aString; endEntry.! !!TTFontReader class methodsFor: 'class initialization' stamp: 'ar 11/2/1998 00:16'!initialize	"TTFontReader initialize"	WinToMacTable _ 		#(	0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 			16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 			32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 			48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 			64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 			80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 			96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 			112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 			173 176 226 196 227 201 160 224 246 228 178 220 206 179 182 183 			184 212 213 210 211 165 208 209 247 170 185 221 207 186 189 217 			202 193 162 163 219 180 195 164 172 169 187 199 194 197 168 248 			161 177 198 215 171 181 166 225 252 218 188 200 222 223 240 192 			203 231 229 204 128 129 174 130 233 131 230 232 237 234 235 236 			245 132 241 238 239 205 133 249 175 244 242 243 134 250 251 167 			136 135 137 139 138 140 190 141 143 142 144 145 147 146 148 149 			253 150 152 151 153 155 154 214 191 157 156 158 159 254 255 216) collect:[:i| i+1].! !!TTFontReader class methodsFor: 'examples'!exampleString: aString	"TTFont exampleString:'Warum?'"	self default 		displayString: aString		on: ScheduledControllers activeController view graphicsContext		at: 100@300		withSize: (0.1 @ -0.1).	self default 		displayKerningString: aString		on: ScheduledControllers activeController view graphicsContext		at: 100@500		withSize: (0.1 @ -0.1).! !!TTFontReader class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 23:43'!parseFileNamed: aString	"TTFontReader parseFileNamed:'c:\windows\arial.ttf'"	"TTFontReader parseFileNamed:'c:\windows\times.ttf'"	| contents |	contents _ (FileStream readOnlyFileNamed: aString) binary contentsOfEntireFile.	^self readFrom: (ReadStream on: contents)! !!TTFontReader class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 00:53'!readFrom: aStream	^self new readFrom: aStream! !!TTFontTableDirEntry reorganize!('initialize-release' on:at:)('accessing' nextByte nextBytes:into:startingAt: nextLong nextShort nextULong nextUShort offset offset: skip: stringAt:length:multiByte:)!!TTFontTableDirEntry methodsFor: 'initialize-release'!on: fd at: index	fontData _ fd.	tag _ fontData longAt: index bigEndian: true.	checkSum _ fontData longAt: index+4 bigEndian: true.	offset _ (fontData longAt: index+8 bigEndian: true) + 1.	length _ fontData longAt: index+12 bigEndian: true.! !!TTFontTableDirEntry methodsFor: 'accessing'!nextByte	| value |	value _ fontData byteAt: offset.	offset _ offset + 1.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextBytes: numBytes into: array startingAt: byteOffset	1 to: numBytes do:[:i|		array at: i put: (fontData byteAt: byteOffset + i - 1)].! !!TTFontTableDirEntry methodsFor: 'accessing'!nextLong	| value |	value _ fontData longAt: offset bigEndian: true.	offset _ offset + 4.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextShort	| value |	value _ fontData shortAt: offset bigEndian: true.	offset _ offset + 2.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextULong	| value |	value _ fontData unsignedLongAt: offset bigEndian: true.	offset _ offset + 4.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!nextUShort	| value |	value _ fontData unsignedShortAt: offset bigEndian: true.	offset _ offset + 2.	^value! !!TTFontTableDirEntry methodsFor: 'accessing'!offset	^offset! !!TTFontTableDirEntry methodsFor: 'accessing'!offset: newOffset	offset _ newOffset! !!TTFontTableDirEntry methodsFor: 'accessing'!skip: n	"Skip n bytes"	offset _ offset + n.! !!TTFontTableDirEntry methodsFor: 'accessing' stamp: 'ar 11/1/1998 23:37'!stringAt: stringOffset length: byteLength multiByte: aBoolean	| string index stringLength |	aBoolean ifFalse:[		stringLength _ byteLength.		string _ String new: stringLength.		index _ stringOffset.		1 to: stringLength do:[:i|			string at: i put: (Character value: (fontData byteAt: index + i - 1))].		^string	] ifTrue:[		stringLength _ byteLength // 2.		string _ String new: stringLength.		index _ stringOffset.		1 to: stringLength do:[:i|			string at: i put: (Character value: (fontData byteAt: index + 1)).			index _ index + 2].		^string]! !!TTFontTableDirEntry class methodsFor: 'instance creation'!on: fontData at: index	^self new on: fontData at: index! !!TTGlyph commentStamp: '<historical>' prior: 0!This class represents a glyph of a TrueType font.Instance variables:	bounds			<Rectangle>	The receiver's bounds	contours		<Array of: PointArray> The compressed contours in the receiver	advanceWidth	<Integer>	advance width of the glyph	leftSideBearing	<Integer>	left side bearing	rightSideBearing <Integer>	right side bearing	glyphIndex 		<Integer>	the original index of the glyph (used for kerning)!!TTGlyph reorganize!('initialize-release' initialize)('accessing' advanceWidth advanceWidth: bounds bounds: contours contours: glyphIndex glyphIndex: glyphsAndTransformationsDo: leftSideBearing leftSideBearing: rightSideBearing rightSideBearing:)('testing' isComposite)('printing' printOn:)('private-initialization' buildContours initializeContours:with: updateRightSideBearing)('private' display flipAroundY)!!TTGlyph methodsFor: 'initialize-release' stamp: 'ar 11/1/1998 22:25'!initialize	bounds _ 0@0 corner: 0@0.	contours _ #().	advanceWidth _ 0.	leftSideBearing _ 0.	rightSideBearing _ 0.! !!TTGlyph methodsFor: 'accessing'!advanceWidth	^advanceWidth! !!TTGlyph methodsFor: 'accessing'!advanceWidth: aNumber	advanceWidth _ aNumber.! !!TTGlyph methodsFor: 'accessing' stamp: 'ar 11/1/1998 22:25'!bounds	^bounds! !!TTGlyph methodsFor: 'accessing' stamp: 'ar 11/1/1998 22:25'!bounds: aRectangle	bounds _ aRectangle! !!TTGlyph methodsFor: 'accessing'!contours	^contours! !!TTGlyph methodsFor: 'accessing'!contours: aCollection	contours _ aCollection asArray.! !!TTGlyph methodsFor: 'accessing'!glyphIndex	^glyphIndex! !!TTGlyph methodsFor: 'accessing'!glyphIndex: anInteger	glyphIndex _ anInteger! !!TTGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:26'!glyphsAndTransformationsDo: aBlock	aBlock value: self value: MatrixTransform2x3 identity! !!TTGlyph methodsFor: 'accessing'!leftSideBearing	^leftSideBearing! !!TTGlyph methodsFor: 'accessing'!leftSideBearing: aNumber	leftSideBearing _ aNumber.! !!TTGlyph methodsFor: 'accessing'!rightSideBearing	^rightSideBearing! !!TTGlyph methodsFor: 'accessing'!rightSideBearing: aNumber	rightSideBearing _ aNumber.! !!TTGlyph methodsFor: 'testing'!isComposite	^false! !!TTGlyph methodsFor: 'printing' stamp: 'ar 11/1/1998 22:03'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut:$(;		print: contours size;		nextPut:$).! !!TTGlyph methodsFor: 'private-initialization' stamp: 'ar 11/1/1998 22:18'!buildContours	"Build the contours in the receiver glyph.	The contour is constructed by converting the points	form each contour into an absolute value and then	compressing the contours into PointArrays."	| tx ty points |	tx _ ty _ 0.	contours _ contours collect:[:contour|		points _ contour points.		points do:[:pt|			pt x: (tx _ tx + pt x).			pt y: (ty _ ty + pt y)].		contour asCompressedPoints].! !!TTGlyph methodsFor: 'private-initialization' stamp: 'ar 11/1/1998 22:42'!initializeContours: numContours with: endPoints	"Initialize the contours for creation of the glyph."	| startPt pts endPt |	contours _ Array new: numContours.	startPt _ -1.	1 to: numContours do:[:i|		endPt _ endPoints at: i.		pts _ Array new: endPt - startPt.		1 to: pts size do:[:j| pts at: j put: TTPoint new].		contours at: i put: (TTContourConstruction on: pts).		startPt _ endPt].! !!TTGlyph methodsFor: 'private-initialization' stamp: 'ar 11/1/1998 22:27'!updateRightSideBearing	"Update the right side bearing value"	"@@: Is the following really correct?!!?!!"	rightSideBearing _ advanceWidth - leftSideBearing - bounds corner x + bounds origin x! !!TTGlyph methodsFor: 'private' stamp: 'ar 11/2/1998 01:41'!display	| canvas |	canvas _ FormCanvas on: Display.	self contours do:[:ptArray|		1 to: ptArray size by: 3 do:[:i|			canvas line: (ptArray at: i) // 10					to: (ptArray at: i+2) // 10					width: 1 color: Color black.		].	].! !!TTGlyph methodsFor: 'private' stamp: 'ar 11/14/1998 20:22'!flipAroundY	bounds _ (bounds origin x @ bounds corner y negated) corner:				(bounds corner x @ bounds origin y negated).	contours _ self contours collect:[:contour| contour collect:[:pt| pt x @ pt y negated]].! !!TTCompositeGlyph methodsFor: 'initialize' stamp: 'ar 11/2/1998 01:20'!initialize	glyphs _ #().! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:21'!addGlyph: aGlyph transformation: aMatrix	glyphs _ glyphs copyWith: (aMatrix -> aGlyph)! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:43'!contours	^contours ifNil:[contours _ self computeContours]! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:20'!glyphs	^glyphs collect:[:assoc| assoc value].! !!TTCompositeGlyph methodsFor: 'accessing' stamp: 'ar 11/2/1998 01:28'!glyphsAndTransformationsDo: aBlock	glyphs do:[:assoc|		aBlock value: assoc value value: assoc key.	].! !!TTCompositeGlyph methodsFor: 'testing'!isComposite	^true! !!TTCompositeGlyph methodsFor: 'private' stamp: 'ar 11/2/1998 01:43'!computeContours	| out |	out _ WriteStream on: (Array new: glyphs size * 4).	self glyphsAndTransformationsDo:[:glyph :transform|		glyph contours do:[:ptArray|			out nextPut: (transform localPointsToGlobal: ptArray).		].	].	^out contents! !!TTCompositeGlyph methodsFor: 'private' stamp: 'ar 11/14/1998 20:27'!flipAroundY	bounds _ (bounds origin x @ bounds corner y negated) corner:				(bounds corner x @ bounds origin y negated).	contours _ nil.! !!TTGlyph class methodsFor: 'instance creation'!new	^super new initialize! !!TTCompositeGlyph class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 01:20'!new	^super new initialize! !!TTKernPair methodsFor: 'accessing'!left	^left! !!TTKernPair methodsFor: 'accessing'!left: aNumber	left _ aNumber! !!TTKernPair methodsFor: 'accessing' stamp: 'ar 11/1/1998 20:08'!mask	^mask ifNil:[mask _ self class maskFor: left with: right]! !!TTKernPair methodsFor: 'accessing'!right	^right! !!TTKernPair methodsFor: 'accessing'!right: aNumber	right _ aNumber! !!TTKernPair methodsFor: 'accessing'!value	^value! !!TTKernPair methodsFor: 'accessing'!value: aNumber	value _ aNumber! !!TTKernPair class methodsFor: 'accessing'!maskFor: left with: right	^(left bitShift: 12) + right! !!TTPoint methodsFor: 'accessing'!type	^type! !!TTPoint methodsFor: 'accessing'!type: aSymbol	type _ aSymbol! !!TTPoint methodsFor: 'accessing'!x	^x! !!TTPoint methodsFor: 'accessing'!x: aNumber	x _ aNumber! !!TTPoint methodsFor: 'accessing'!y	^y! !!TTPoint methodsFor: 'accessing'!y: aNumber	y _ aNumber! !!TTPoint methodsFor: 'printing'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut:$(;		print: x;		nextPut:$@;		print: y;		nextPut:$|;		print: type;		nextPut:$)! !!TTPoint methodsFor: 'converting'!asPoint	^x@y! !!TTSampleFontMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 01:26'!initialize	super initialize.	borderWidth _ 1.	borderColor _ Color black.	color _ Color black.	smoothing _ 4.	self extent: 300@300.! !!TTSampleFontMorph methodsFor: 'initialize' stamp: 'ar 11/14/1998 23:50'!open	Smalltalk isMorphic 		ifTrue:[self openInWorld]		ifFalse:[self openInMVC]! !!TTSampleFontMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 03:16'!openInWorld	Smalltalk isMorphic ifFalse:[^self openInMVC].	World primaryHand attachMorph: self! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 00:32'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: box center color: Color magenta on: #mouseDown send: #createSample to: self.! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:39'!balloonHelpTextForHandle: aHandle	aHandle eventHandler firstMouseSelector == #createSample		ifTrue:[^'Create a sample string'].	^super balloonHelpTextForHandle: aHandle! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:52'!doesBevels	^false! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 00:31'!font: aTTFontDescription	| morph |	font _ aTTFontDescription.	morph _ (TTSampleStringMorph font: font).	morph extent: morph extent * 2.	morph color: Color magenta.	self addMorphCentered: morph.	morph position: morph position x @ (self bounds bottom + 10).	self privateFullMoveBy: self fullBounds origin negated.! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 22:42'!newTransformationMorph	^MatrixTransformMorph new! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:52'!smoothing	^smoothing ifNil:[1]! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:52'!smoothing: aNumber	smoothing _ aNumber! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 22:53'!transform	^transform ifNil:[self computeTransform].! !!TTSampleFontMorph methodsFor: 'geometry' stamp: 'ar 11/14/1998 22:53'!extent: extentPoint	super extent: extentPoint.	transform _ nil.! !!TTSampleFontMorph methodsFor: 'geometry' stamp: 'ar 11/14/1998 22:53'!position: pos	super position: pos.	transform _ nil.! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'ar 11/14/1998 23:12'!areasRemainingToFill: aRectangle	^ Array with: aRectangle! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 00:55'!drawCharactersOn: aCanvas	| glyph origin r offset cy m |	0 to: 255 do:[:i|		glyph _ font at: i.		origin _ font bounds extent * ((i \\ 16) @ (i // 16)).		r _ origin extent: font bounds extent.		offset _ r center - glyph bounds center.		cy _ glyph bounds center y.		m _ MatrixTransform2x3 withOffset: 0@cy.		m _ m composedWithLocal: (MatrixTransform2x3 withScale: 1@-1).		m _ m composedWithLocal: (MatrixTransform2x3 withOffset: 0@cy negated).		m _ m composedWithGlobal: (MatrixTransform2x3 withOffset: offset).		aCanvas transformBy: m while:[:canvas|			canvas drawGeneralBezierShape: glyph contours					color: color					borderWidth: 1					borderColor: Color black.		].	].! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 22:46'!drawOn: aCanvas	| origin extent offset |	(font isNil) 		ifTrue:[^aCanvas frameRectangle: bounds color: Color black].	origin _ self position asIntegerPoint.	extent _ self extent asIntegerPoint.	0 to: 16 do:[:i|		offset _ (extent x * i // 16) @ (extent y * i // 16).		aCanvas line: origin x @ (origin y + offset y) 				to: (origin x + extent x) @ (origin y + offset y)				width: borderWidth color: borderColor.		aCanvas line: (origin x + offset x) @ origin y 				to: (origin x + offset x) @ (origin y + extent y)				width: borderWidth color: borderColor.	].	aCanvas asBalloonCanvas transformBy: self transform while:[:balloonCanvas|		balloonCanvas aaLevel: self smoothing.		self drawCharactersOn: balloonCanvas.	].! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self smoothing = 1 		ifTrue:[aCustomMenu add: 'turn on smoothing' action: #smoothingOn].	self smoothing = 2 		ifTrue:[aCustomMenu add: 'more smoothing' action: #smoothingMore].	self smoothing = 4 		ifTrue:[aCustomMenu add: 'turn off smoothing' action: #smoothingOff].! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 23:46'!createSample	self world primaryHand attachMorph: (TTSampleStringMorph font: font)! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!smoothingMore	smoothing _ 4.	self changed! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!smoothingOff	smoothing _ 1.	self changed! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'ar 11/14/1998 22:54'!smoothingOn	smoothing _ 2.	self changed! !!TTSampleFontMorph methodsFor: 'private' stamp: 'ar 11/15/1998 01:06'!changed	self invalidRect: (self fullBounds insetBy: -1@-1)! !!TTSampleFontMorph methodsFor: 'private' stamp: 'ar 11/15/1998 22:48'!computeTransform	| fullExtent scale |	fullExtent _ font bounds extent * 16.	scale _ self extent asFloatPoint / fullExtent asFloatPoint.	transform _ MatrixTransform2x3 withScale: scale.	transform _ transform composedWithGlobal: (MatrixTransform2x3 withOffset: self position).	^transform! !!TTSampleFontMorph methodsFor: 'private' stamp: 'ar 11/14/1998 22:55'!privateMoveBy: delta	super privateMoveBy: delta.	transform _ nil.! !!TTSampleFontMorph class methodsFor: 'instance creation' stamp: 'ar 11/14/1998 23:06'!font: aTTFontDescription	^self new font: aTTFontDescription! !!TTSampleStringMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 01:27'!initialize	super initialize.	borderWidth _ 0.	borderColor _ Color black.	color _ {Color magenta. Color yellow. Color orange. Color lightGray} atRandom.	smoothing _ 4.! !!TTSampleStringMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 00:30'!initializeString	| xStart char glyph |	(font isNil or:[string isNil]) ifTrue:[^self].	xStart _ 0.	ttBounds _ 0@0 corner: 0@0.	1 to: string size do:[:i|		char _ string at: i.		glyph _ (font at: char).		ttBounds _ ttBounds merge: (glyph bounds translateBy: xStart@0).		xStart _ xStart + glyph advanceWidth.	].	self extent: ttBounds extent // 40.	borderWidth _ ttBounds height // 40.! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:44'!addOptionalHandlesTo: aHalo box: box! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 00:10'!font: aTTFontDescription	font _ aTTFontDescription.	self string: aTTFontDescription fullName.! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:53'!string: aString	string _ aString.	self initializeString.! !!TTSampleStringMorph methodsFor: 'drawing' stamp: 'ar 11/14/1998 22:12'!drawOn: aCanvas	| xStart glyph |	(font isNil or:[string isNil or:[string isEmpty]]) 		ifTrue:[^aCanvas frameRectangle: bounds color: Color black].	xStart _ 0.	aCanvas asBalloonCanvas transformBy: self transform while:[:balloonCanvas|		balloonCanvas aaLevel: self smoothing.		string do:[:char|			glyph _ font at: char.			balloonCanvas transformBy: (MatrixTransform2x3 withOffset: xStart@0) 				while:[:subCanvas| subCanvas drawGeneralBezierShape: glyph contours					color: color borderWidth: borderWidth borderColor: borderColor].			xStart _ xStart + glyph advanceWidth.		].	].! !!TTSampleStringMorph methodsFor: 'private' stamp: 'ar 11/14/1998 22:04'!computeTransform	| cy |	cy _ bounds origin y + bounds corner y * 0.5.	transform _ MatrixTransform2x3 			transformFromLocal: (ttBounds insetBy: borderWidth negated)			toGlobal: bounds.	transform _ transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0@cy negated).	transform _ transform composedWithGlobal:(MatrixTransform2x3 withScale: 1.0@-1.0).	transform _ transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0@cy).	^transform! !TTFontReader initialize!