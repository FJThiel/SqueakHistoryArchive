'From Squeak 2.1 of June 30, 1998 on 22 August 1998 at 11:06:14 pm'!"Change Set:		auxTweaks-swDate:			22 August 1998Author:			Scott WallaceA potpourri of tweaks:* Gives better information in the 'printStrings' of EventHandlers and MorphExtensions.* Removes HolderMorph from the system (this was done earlier, theoretically, the class having been completely supplanted by PasteUpMorph, but somehow the change didn't take)* Removes a variety of unsent methods.* Incorporates Dan's updated class comments for LargePositiveInteger and SmallInteger* Omits several classes from the new-morph menu.* Adds Utilities.instanceComparisonsBetween:and:, providing differential information about instance counts between two #printSpaceAnalysis executions.* In several places, call the #startStepping variant that doesn't do that initial 'one to get started'."!!Object methodsFor: 'comparing' stamp: 'sw 8/20/1998 12:34'!identityHashPrintString	"'fred' identityHashPrintString"	^ '(', self identityHash printString, ')'! !!Object methodsFor: 'macpal' stamp: 'sw 6/16/1998 15:07'!instanceVariableValues	"Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class"	| c |	c _ OrderedCollection new.	self class superclass instSize + 1 to: self class instSize do:		[:i | c add: (self instVarAt: i)].	^ c! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/22/1998 21:12'!removeAllMemoryOfChangesToClassNamed: className	"Remove all memory of changes associated with this class"	classChanges removeKey: className ifAbsent: [].	methodChanges removeKey: className ifAbsent: [].	classRemoves remove: className ifAbsent: [].! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 8/22/1998 21:12'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeAllMemoryOfChangesToClassNamed: currentClassName.		currentClassName _ nil.		currentSelector _ nil.		self showChangeSet: myChangeSet].! !!EventHandler methodsFor: 'access' stamp: 'sw 8/22/1998 19:29'!printOn: aStream	| aVal |	super printOn: aStream.	#(mouseDownSelector  mouseStillDownSelector mouseUpSelector  mouseEnterSelector  mouseLeaveSelector  mouseEnterLadenSelector  mouseLeaveLadenSelector  keyStrokeSelector) do:		[:aName | (aVal _ self instVarNamed: aName) ~~ nil ifTrue:			[aStream nextPutAll: ' ', aName, '=', aVal]]! !!LargePositiveInteger commentStamp: 'sw 8/22/1998 23:06' prior: 0!I represent positive integers of more than 30 bits (ie, >= 1073741824).  These values are beyond the range of SmallInteger, and are encoded here as an array of 8-bit digits.  Care must be taken, when new values are computed, that any result that COULD BE a SmallInteger IS a SmallInteger (see normalize).Note that the bit manipulation primitives, bitAnd:, bitShift:, etc., = and ~= run without failure (and therefore fast) if the value fits in 32 bits.  This is a great help to the simulator.!!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/21/1998 16:31'!arrangeToStartSteppingIn: aWorld	"Start getting sent the 'step' message in aWorld.  Like startSteppingIn:, but without the initial one to get started'"	aWorld startStepping: self.	self changed! !!MorphExtension methodsFor: 'other' stamp: 'sw 8/20/1998 12:35'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ', self identityHashPrintString.	locked == true ifTrue: [aStream nextPutAll: ' [locked] '].	visible == true ifTrue: [aStream nextPutAll: ' [visible] '].	sticky == true ifTrue: [aStream nextPutAll: ' [sticky] '].	balloonText ifNotNil: [aStream nextPutAll: ' [balloonText] '].	balloonTextSelector ifNotNil: [aStream nextPutAll: ' [balloonTextSelector: ', balloonTextSelector printString, '] '].	externalName ifNotNil: [aStream nextPutAll: ' [externalName = ', externalName, ' ] '].	isPartsDonor == true ifTrue: [aStream nextPutAll: ' [isPartsDonor] '].	player ifNotNil: [aStream nextPutAll: ' [player = ', player printString, '] '].	eventHandler ifNotNil: [aStream nextPutAll: ' [eventHandler = ', eventHandler printString, '] '].	otherProperties size > 0 ifTrue: [aStream nextPutAll: ' [other = ', otherProperties keys asArray printString, ']']! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 8/10/1998 07:05'!initialize	| f |	super initialize.	color _ Color lightGray.  "background color"	f _ Form extent: 60@80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 8/10/1998 07:05'!smaller	self form: (self form copy: (0@0 extent: self form extent // 2))! !!PartsBinMorph class reorganize!('all' includeInNewMorphMenu)!!PartsBinMorph class methodsFor: 'all' stamp: 'sw 8/19/1998 15:18'!includeInNewMorphMenu	"Not to be instantiated from the menu. The PartsBinMorph is misleadingly named, and is extremely special-purpose"	^ false! !!PartsViewer class methodsFor: 'all' stamp: 'sw 8/19/1998 17:55'!includeInNewMorphMenu	^ false! !!SmallInteger commentStamp: 'sw 8/22/1998 23:06' prior: 0!My instances are 30-bit numbers, stored in twos complement form. The allowable range is approximately +- 1 billion (see SmallInteger minVal, maxVal).!!TransformationMorph methodsFor: 'accessing' stamp: 'sw 8/20/1998 13:44'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' on ', submorphs first printString! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 7/22/1998 17:12'!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict _ Dictionary new.	report _ ReadWriteStream on: ''.	f _ FileStream oldFileNamed: fileName1.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f _ FileStream oldFileNamed: fileName2.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[className _ items first.			newInstCount _ items third asNumber.			newSpace _ items fourth asNumber.			oldPair _ instCountDict at: className ifAbsent: [nil].			oldInstCount _ oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace _ oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!WorldMorph methodsFor: 'stepping' stamp: 'sw 8/21/1998 16:32'!startSteppingSubmorphsOf: aMorph	"Ensure that all submorphs of the given morph that want to be stepped are added to the step list.   Typically used after adding a morph to the world."	aMorph allMorphsDo: [:m |		m wantsSteps ifTrue: [m arrangeToStartSteppingIn: self]]! !GraphMorph removeSelector: #parts!JoystickMorph removeSelector: #parts!Object class removeSelector: #instanceOfUniqueClassWithInstanceVariableNames:!PasteUpMorph removeSelector: #newPlayerInstance!ScriptEditorMorph removeSelector: #goScript!Smalltalk removeClassNamed: #HolderMorph!