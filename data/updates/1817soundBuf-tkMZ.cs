'From Squeak2.7 of 5 January 2000 [latest update: #1812] on 5 February 2000 at 10:31:23 pm'!"Change Set:		soundBuf-tkMZDate:			4 February 2000Author:			Ted KaehlerAllow SoundBuffer instances to be filed out by SmartRefStreams and ImageSegments and be read on opposite endian machines.Also, Bob Arning's fix to the 'explain' feature in ChangeSorters.  Thanks, Bob!!  And thanks to Randy Schwartz for discovering the problem."!!ChangeSorter methodsFor: 'message list' stamp: 'tk 2/3/2000 20:08'!selectedMessage	"Answer a copy of the source code for the selected message selector."	^ contents ifNil: [''] ifNotNil: [contents copy]! !!DataStream methodsFor: 'write and read' stamp: 'tk 2/3/2000 21:16'!next	"Answer the next object in the stream."	| type selector anObject isARefType pos internalObject |	type _ byteStream next.	type ifNil: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType _ self noteCurrentReference: type.	selector _ #(readNil readTrue readFalse readInteger			readStringOld readSymbol readByteArray			readArray readInstance readReference readBitmap			readClass readUser readFloat readRectangle readShortInst 			readString readWordArray readWordArrayForSegment 			readWordLike) at: type.	selector == 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"			byteStream close. 			self error: 'file is more recent than this system'. ^ nil].	anObject _ self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	isARefType ifTrue: [self beginReference: anObject].		"After reading the externalObject, internalize it.		 #readReference is a special case. Either:		   (1) We actually have to read the object, recursively calling			   next, which internalizes the object.		   (2) We just read a reference to an object already read and			   thus already interalized.		 Either way, we must not re-internalize the object here."	selector == #readReference ifTrue: [^ anObject].	internalObject _ anObject comeFullyUpOnReload: self.	^ self maybeBeginReference: internalObject! !!DataStream methodsFor: 'write and read' stamp: 'tk 2/3/2000 21:15'!nextPut: anObject	"Write anObject to the receiver stream. Answer anObject."	| typeID selector objectToStore |	typeID _ self typeIDFor: anObject.	(self tryToPutReference: anObject typeID: typeID)		ifTrue: [^ anObject].	objectToStore _ (self objectIfBlocked: anObject) objectForDataStream: self.	objectToStore == anObject ifFalse: [typeID _ self typeIDFor: objectToStore].	byteStream nextPut: typeID.	selector _ #(writeNil: writeTrue: writeFalse: writeInteger: 		writeStringOld: writeSymbol: writeByteArray:		writeArray: writeInstance: errorWriteReference: writeBitmap:		writeClass: writeUser: writeFloat: writeRectangle: == "dummy 16" 		writeString: writeBitmap: writeBitmap: writeWordLike:) at: typeID.	self perform: selector with: objectToStore.	^ anObject"NOTE: If anObject is a reference type (one that we write cross-references to) but its externalized form (result of objectForDataStream:) isn't (e.g. CompiledMethod and ViewState), then we should remember its externalized form but not add to 'references'. Putting that object again should just put its external form again. That's more compact and avoids seeks when reading. But we just do the simple thing here, allowing backward-references for non-reference types like nil. So objectAt: has to compensate. Objects that externalize nicely won't contain the likes of ViewStates, so this shouldn't hurt much.	 writeReference: -> errorWriteReference:."! !!DataStream methodsFor: 'write and read' stamp: 'tk 2/3/2000 21:11'!readWordLike	| refPosn aSymbol newClass anObject |	"Can be used by any class that is bits and not bytes (WordArray, Bitmap, SoundBuffer, etc)."	refPosn _ self getCurrentReference.	aSymbol _ self next.	newClass _ Smalltalk at: aSymbol asSymbol.	anObject _ newClass newFromStream: byteStream.	"Size is number of long words."	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!DataStream methodsFor: 'write and read' stamp: 'tk 2/5/2000 21:53'!writeWordLike: aWordArray	"Note that we put the class name before the size."	self nextPut: aWordArray class name.	aWordArray writeOn: byteStream	"Note that this calls (byteStream nextPutAll: aBitmap) which knows enough to put 4-byte quantities on the stream!!  Reader must know that size is in long words or double-bytes."! !!DataStream class methodsFor: 'as yet unclassified' stamp: 'tk 2/3/2000 20:56'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes _ OrderedCollection new.	t _ TypeMap _ Dictionary new: 80. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: String put: 5.   refTypes add: 1.	t at: Symbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.		"CompiledMethod is handled by Object (type 9)"	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances of any class, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.	t at: String put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"	t at: WordArray put: 18.  refTypes add: 1.	"bitmap-like"	t at: WordArrayForSegment put: 19.  refTypes add: 1.		"bitmap-like"	t at: SoundBuffer put: 20.  refTypes add: 1.		"And all other word arrays"	"t at:  put: 21.  refTypes add: 0."	ReferenceStream refTypes: refTypes.		"save it"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 2/5/2000 16:10'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots.	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal fakes goods bads perfect ccFixups real insts receiverClasses |	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal 				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is not compatible'].	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		fakes _ mapFakeClassesToReal keys.		goods _ OrderedCollection new.		bads _ OrderedCollection new.		fakes do: [:aFakeClass | 			real _ mapFakeClassesToReal at: aFakeClass.			(real indexIfCompact > 0) "and there is a fake class"				ifFalse: ["normal case"					aFakeClass allInstancesDo: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]				ifTrue: ["instances have the wrong class.  Fix them before anyone notices."					insts _ OrderedCollection new.					self allObjectsDo: [:obj | obj class == real ifTrue: [insts add: obj]].					insts do: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]].		bads size > 0 ifTrue: [			bads asArray elementsForwardIdentityTo: goods asArray]].	receiverClasses _ self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:aRoot | 		(aRoot isKindOf: Project) ifTrue: [			Project allInstancesDo: [:pp | pp ~~ aRoot ifTrue: [				pp name = aRoot name ifTrue: [					aRoot projectChangeSet name: ChangeSet defaultName]]]].		aRoot class class == Metaclass ifTrue: [			self declare: aRoot]].	mapFakeClassesToReal isEmpty ifFalse: [		fakes do: [:aFake | 			aFake indexIfCompact > 0 ifTrue: [aFake becomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 2/5/2000 21:20'!restoreEndianness	"Fix endianness (byte order) of any objects not already fixed.	I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks.  Return them.  Caller will check if they have been reshaped."	| object sets receiverClasses inSeg reorder |	object _ segment.	sets _ OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses _ IdentitySet new.	reorder _ (Smalltalk endianness) ~~ 		((segment first bitShift: -24) asCharacter == $d ifTrue: [#big] ifFalse: [#little]).	inSeg _ true.	[object _ object nextObject.  "all the way to the end of memory to catch remade objects"		object == endMarker ifTrue: [inSeg _ false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: Set) ifTrue: [sets add: object].			object class == BlockContext ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				object class == MethodContext ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				(reorder and: [(object class == SoundBuffer) & inSeg]) ifTrue: [object swapHalves]]. 		object == 0] whileFalse.	sets do: [:each | each rehash].	"our purpose"	^ receiverClasses	"our secondary job"! !!Parser methodsFor: 'public access' stamp: 'tk 2/4/2000 18:39'!parseArgsAndTemps: aString notifying: req 	"Parse the argument, aString, notifying req if an error occurs. Otherwise, 	answer a two-element Array containing Arrays of strings (the argument 	names and temporary variable names)."	aString == nil ifTrue: [^#()].	doitFlag _ false.		"Don't really know if a doit or not!!"	^self		initPattern: aString		notifying: req		return: [:pattern | (pattern at: 2) , self temporaries]! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 2/3/2000 21:21'!isAReferenceType: typeID	"Return true iff typeID is one of the classes that can be written as a reference to an instance elsewhere in the stream."	"too bad we can't put Booleans in an Array literal"	^ (RefTypes at: typeID) == 1		"NOTE: If you get a bounds error here, the file probably has bad bits in it.  The most common cause is a file unpacking program that puts linefeeds after carriage returns."! !!SoundBuffer methodsFor: 'objects from disk' stamp: 'tk 2/3/2000 20:32'!restoreEndianness	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."	| hack blt |	Smalltalk endianness == #little ifTrue: [		"The implementation is a hack, but fast for large ranges"		hack _ Form new hackBits: self.		blt _ (BitBlt toForm: hack) sourceForm: hack.		blt combinationRule: Form reverse.  "XOR"		blt sourceY: 0; destY: 0; height: self size; width: 1.		blt sourceX: 0; destX: 1; copyBits.  "Exchange bytes 0 and 1"		blt sourceX: 1; destX: 0; copyBits.		blt sourceX: 0; destX: 1; copyBits.		blt sourceX: 2; destX: 3; copyBits.  "Exchange bytes 2 and 3"		blt sourceX: 3; destX: 2; copyBits.		blt sourceX: 2; destX: 3; copyBits].! !!SoundBuffer methodsFor: 'objects from disk' stamp: 'tk 2/5/2000 16:15'!swapHalves		"A normal switch in endianness (byte order in words) reverses the order of 4 bytes.  That is not correct for SoundBuffers, which use 2-bytes units.  If a normal switch has be done, this method corrects it further by swapping the two halves of the long word."	| hack blt |	"The implementation is a hack, but fast for large ranges"	hack _ Form new hackBits: self.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: 0; destY: 0; height: self size; width: 2.	blt sourceX: 0; destX: 2; copyBits.  "Exchange bytes 0&1 with 2&3"	blt sourceX: 2; destX: 0; copyBits.	blt sourceX: 0; destX: 2; copyBits.! !!SoundBuffer methodsFor: 'objects from disk' stamp: 'tk 2/5/2000 21:52'!writeOn: aStream 	| reversed convertToBytes |	"Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed).  Always store in Big Endian (Mac) byte order.  Do the writing at BitBlt speeds."	convertToBytes _ aStream originalContents "collection" class isBytes.	(aStream isKindOf: FileStream) ifTrue: [convertToBytes _ false].	"knows how"	aStream nextInt32Put: self size.	Smalltalk endianness == #big 		ifTrue: ["no change"			convertToBytes ifTrue: [self do: [:vv | aStream nextNumber: 4 put: vv]]					"Later define (aStream nextPutWordsAll:) that uses BitBlt to 					 put words on a non-file byteStream quickly" 				ifFalse: [aStream nextPutAll: self]]	"files use this"		ifFalse: [			reversed _ self clone.			reversed restoreEndianness.	"swap an extra time to get to big endian format"			convertToBytes ifTrue: [reversed do: [:vv | aStream nextNumber: 4 put: vv]]				ifFalse: [aStream nextPutAll: reversed]]! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'tk 2/5/2000 22:00'!newFromStream: s	| len |	len _ s nextInt32.	^ s nextWordsInto: (self new: len)! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'tk 2/5/2000 21:43'!nextPutAll: aString	"Write all the characters of the given string to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	self primWrite: fileID from: aString startingAt: 1 count: aString basicSize.	^ aString! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'tk 2/5/2000 21:58'!nextWordsInto: aBitmap	"Note: The file primitives automatically adjust for word based objects."	self next: aBitmap basicSize into: aBitmap startingAt: 1.	aBitmap restoreEndianness.	^ aBitmap! !DataStream initialize!SoundBuffer removeSelector: #newFromStream:!