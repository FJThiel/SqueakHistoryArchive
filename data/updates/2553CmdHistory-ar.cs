'From Squeak2.9alpha of 12 June 2000 [latest update: #2550] on 31 August 2000 at 11:27:34 pm'!"Change Set:		CmdHistory-arDate:			31 August 2000Author:			Andreas RaabFixes the command history from a global singular object to a property of the current world. Enables project swapping to work again, disables undo-ing operations in other project etc."!Object subclass: #CommandHistory	instanceVariableNames: 'lastCommand history excursions '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Undo'!Object subclass: #WorldState	instanceVariableNames: 'hands activeHand viewBox canvas damageRecorder stepList lastStepTime lastCycleTime commandHistory '	classVariableNames: 'CanSurrenderToOS DeferredUIMessages DisableDeferredUpdates LastCycleTime MinCycleLapse '	poolDictionaries: ''	category: 'Morphic-Worlds'!!WorldState methodsFor: 'object fileIn' stamp: 'ar 9/1/2000 06:28'!converthavcdsll0: varDict havcdsllc0: smartRefStrm	"These variables are automatically stored into the new instance #('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' 'lastCycleTime').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('commandHistory')  If a non-nil value is needed, please assign it."! !!CommandHistory methodsFor: 'initialize' stamp: 'ar 8/31/2000 22:50'!initialize	lastCommand _ nil.	history _ OrderedCollection new.	excursions _ OrderedCollection new.! !!CommandHistory methodsFor: 'menu' stamp: 'ar 8/31/2000 22:41'!nextCommandToUndo	| anIndex |	lastCommand ifNil: [^ nil].	lastCommand phase == #done ifTrue: [^ lastCommand].	(lastCommand phase == #undone and:		[(anIndex _ history indexOf: lastCommand) > 1])		ifTrue: [^ history at: anIndex - 1]		ifFalse: [^ nil]! !!CommandHistory methodsFor: 'menu' stamp: 'ar 8/31/2000 22:39'!redoEnabled	"Answer whether the redo command is currently available"	^ self nextCommand notNil! !!CommandHistory methodsFor: 'menu' stamp: 'ar 8/31/2000 22:39'!redoMenuWording	"Answer the wording to be used in a menu offering the current Redo command"	| nextCommand |	((nextCommand _ self nextCommand) == nil or: [Preferences useUndo not]) ifTrue:  [^ 'can''t redo'].	^ String streamContents:		[:aStream | 			aStream nextPutAll: 'redo "'.			aStream nextPutAll: (nextCommand cmdWording truncateTo: 12).			aStream nextPut: $".			lastCommand phase == #done ifFalse:				[aStream nextPutAll: ' (z)']]! !!CommandHistory methodsFor: 'menu' stamp: 'ar 8/31/2000 22:40'!undoEnabled	"Answer whether there is an undoable command at the ready"	^ lastCommand notNil! !!CommandHistory methodsFor: 'menu' stamp: 'ar 8/31/2000 22:40'!undoMenuWording	"Answer the wording to be used in an 'undo' menu item"	((lastCommand == nil or: [Preferences useUndo not]) or:		[Preferences infiniteUndo not and: [lastCommand phase == #undone]]) ifTrue: [^ 'can''t undo'].	^ String streamContents:		[:aStream | 			aStream nextPutAll: 'undo "'.			aStream nextPutAll: (self nextCommandToUndo cmdWording truncateTo: 12).			aStream nextPut: $".			lastCommand phase == #done ifTrue:				[aStream nextPutAll: ' (z)']]! !!CommandHistory methodsFor: 'menu' stamp: 'ar 8/31/2000 22:40'!undoOrRedoMenuWording	"Answer the wording to be used in a menu item offering undo/redo"	| pre |	lastCommand ifNil: [^ 'can''t undo'].	pre _ lastCommand phase == #done		ifTrue:		['undo']		ifFalse:		['redo'].	^ ((pre, ' ', lastCommand cmdWording) truncateTo: 30), ' (z)'! !!CommandHistory methodsFor: 'command history' stamp: 'ar 8/31/2000 22:44'!historyIndexOfLastCommand	"Answer which position of the CommandHistory list is occupied by the LastCommand"	^ history indexOf: lastCommand ifAbsent: [0]! !!CommandHistory methodsFor: 'command history' stamp: 'ar 8/31/2000 22:45'!lastCommand	"Answer the last command done or undone"	^ lastCommand! !!CommandHistory methodsFor: 'command history' stamp: 'ar 8/31/2000 22:45'!nextCommand	"Answer the command object that would be sent the #redoCommand message if the user were to request Redo, or nil if none"	| anIndex |	lastCommand ifNil: [^ nil].	lastCommand phase == #undone ifTrue: [^ lastCommand].	anIndex _ history indexOf: lastCommand ifAbsent: [^ nil].	^ anIndex = history size ifTrue: [nil] ifFalse: [history at: (anIndex + 1)]! !!CommandHistory methodsFor: 'command history' stamp: 'ar 8/31/2000 22:45'!resetCommandHistory	"Clear out the command history so that it remembers only the last command done or undone"	history _ OrderedCollection with: lastCommand.! !!CommandHistory methodsFor: 'called by programmer' stamp: 'ar 8/31/2000 22:46'!cantUndo	"Called by client to indicate that the prior undoable command is no longer undoable"	lastCommand _ nil.	history _ OrderedCollection new.! !!CommandHistory methodsFor: 'called by programmer' stamp: 'ar 8/31/2000 22:47'!promoteToCurrent: aCommand	"Very unusual and speculative and unfinished!!.  Not currently reachable.  For the real thing, we presumably march forward or backward from the current command pointer to the target command in an orderly fashion, doing or undoing each command in turn."	| itsIndex |	Preferences useUndo ifFalse: [^ self].	itsIndex _ history indexOf: aCommand ifAbsent: [nil].	itsIndex ifNotNil:		[history remove: aCommand ifAbsent: []].	history add: (lastCommand _ aCommand).	itsIndex < history size ifTrue:		[excursions add: (history copyFrom: (itsIndex to: history size))].	history _ (history copyFrom: 1 to: itsIndex) copyWith: aCommand.	lastCommand _ aCommand.	aCommand doCommand.	lastCommand phase: #done.! !!CommandHistory methodsFor: 'called by programmer' stamp: 'ar 8/31/2000 23:16'!rememberCommand: aCommand	"Make the supplied command be the 'LastCommand', and mark it 'done'"	| currentCommandIndex |	Preferences useUndo ifFalse: [^ self].  "Command initialize"	Preferences infiniteUndo ifTrue:		[currentCommandIndex _ history indexOf: lastCommand.		((currentCommandIndex < history size) and: [Preferences preserveCommandExcursions]) ifTrue:			[excursions add: (history copyFrom: (currentCommandIndex to: history size))].		history _ (history copyFrom: 1 to: currentCommandIndex) copyWith: aCommand].	lastCommand _ aCommand.	lastCommand phase: #done.! !!CommandHistory methodsFor: 'called from the ui' stamp: 'ar 8/31/2000 22:49'!commandToUndo	"Undo the last command, i.e. move backward in the recent-commands tape, if possible."	| anIndex |	lastCommand ifNil: [^ nil].	lastCommand phase == #done ifTrue: [^ lastCommand].	(lastCommand phase == #undone and:		[(anIndex _ history indexOf: lastCommand) > 1])		ifTrue: [^ history at: anIndex - 1]		ifFalse: [^ nil]! !!CommandHistory methodsFor: 'called from the ui' stamp: 'ar 8/31/2000 22:49'!redoNextCommand	"If there is a way to 'redo' (move FORWARD) in the undo/redo history tape, do it."	| anIndex |	lastCommand ifNil: [^ self beep].	lastCommand phase == #undone		ifFalse:			[anIndex _ history indexOf: lastCommand.			(anIndex < history size)				ifTrue:					[lastCommand _ history at: anIndex + 1]				ifFalse:					[^ self beep]].	lastCommand redoCommand.	lastCommand phase: #done! !!CommandHistory methodsFor: 'called from the ui' stamp: 'ar 8/31/2000 22:49'!undoLastCommand	"Undo the last command, i.e. move backward in the recent-commands tape, if possible."	| aPhase anIndex |	lastCommand ifNil: [^ self beep].	(aPhase _ lastCommand phase) == #done		ifFalse:			[aPhase == #undone				ifTrue:					[anIndex _ history indexOf: lastCommand.					anIndex > 1 ifTrue:						[lastCommand _ history at: anIndex - 1]]].	lastCommand undoCommand.	lastCommand phase: #undone	"Command undoLastCommand"! !!CommandHistory methodsFor: 'called from the ui' stamp: 'ar 8/31/2000 22:49'!undoOrRedoCommand	"This gives a feature comparable to standard Mac undo/redo.  If the undo/redo action taken was a simple do or a redo, then undo it.  But if the last undo/redo action taken was an undo, then redo it."	"Command undoOrRedoCommand"	| aPhase |	lastCommand ifNil: [^ self beep].	(aPhase _ lastCommand phase) == #done		ifTrue:			[lastCommand undoCommand.			lastCommand phase: #undone]		ifFalse:			[aPhase == #undone				ifTrue:					[lastCommand redoCommand.					lastCommand phase: #done]]! !!CommandHistory methodsFor: 'called from the ui' stamp: 'ar 8/31/2000 22:49'!undoTo	"Incomplete.  Allow the user to choose a point somewhere in the undo/redo tape, and undo his way to there.   Applicable only if infiniteUndo is set.  Not yet functional."	| anIndex commandList aMenu reply |	(anIndex _ self historyIndexOfLastCommand) ifNil: [^ self beep].	commandList _ history		copyFrom:	((anIndex - 10) max: 1)		to:			((anIndex + 10) min: history size).	aMenu _ SelectionMenu labels:  (commandList collect: [:cmd | cmd cmdWording]) selections: commandList.	reply _ aMenu startUpWithCaption: 'undo or redo to...'.	reply ifNotNil: [self halt: 'now for the rest...!!']	"Command undoTo"! !!CommandHistory class methodsFor: 'instance creation' stamp: 'ar 8/31/2000 22:50'!new	^super new initialize! !!Command class methodsFor: 'dog simple ui' stamp: 'ar 8/31/2000 23:13'!redoEnabled	| w |	^(w _ self currentWorld) == nil ifTrue:[false] ifFalse:[w commandHistory redoEnabled]! !!Command class methodsFor: 'dog simple ui' stamp: 'ar 8/31/2000 23:13'!redoNextCommand	| w |	^(w _ self currentWorld) == nil ifFalse:[w commandHistory redoNextCommand]! !!Command class methodsFor: 'dog simple ui' stamp: 'ar 8/31/2000 23:13'!undoEnabled	| w |	^(w _ self currentWorld) == nil ifTrue:[false] ifFalse:[w commandHistory undoEnabled]! !!Command class methodsFor: 'dog simple ui' stamp: 'ar 8/31/2000 23:14'!undoLastCommand	| w |	^(w _ self currentWorld) == nil ifFalse:[w commandHistory undoLastCommand]! !!Command class methodsFor: 'dog simple ui' stamp: 'ar 8/31/2000 23:06'!undoRedoButtons	"Answer a morph that offers undo and redo buttons"	| aButton wrapper |	"self currentHand attachMorph: Command undoRedoButtons"	wrapper _ AlignmentMorph newColumn.	wrapper color: Color veryVeryLightGray lighter;		borderWidth: 0;		inset: 0;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap.	#((CrudeUndo undoLastCommand 'undo last command done' undoEnabled CrudeUndoDisabled CrudeUndoDisabled) 	(CrudeRedo redoNextCommand 'redo last undone command' redoEnabled CrudeRedoDisabled CrudeRedoDisabled)) do:		[:tuple |			wrapper addTransparentSpacerOfSize: (8@0).			aButton _ UpdatingThreePhaseButtonMorph new.			aButton				onImage: (ScriptingSystem formAtKey: tuple first);				offImage: (ScriptingSystem formAtKey: tuple fifth);				pressedImage: (ScriptingSystem formAtKey: tuple sixth);				getSelector: tuple fourth;				color: Color transparent; 				target: self;				actionSelector: tuple second;				setNameTo: tuple second;				setBalloonText: tuple third;				extent: aButton onImage extent.			wrapper addMorphBack: aButton.			wrapper addTransparentSpacerOfSize: (8@0)].	^ wrapper! !!Form methodsFor: 'displaying' stamp: 'ar 8/31/2000 22:59'!setAsBackground	"Set this form as a background image."	| world newColor cmd |	Smalltalk isMorphic 		ifTrue:			[world _ self currentWorld.			newColor _ InfiniteForm with: self.			cmd _ Command new cmdWording: 'set background to a picture';				undoTarget: world selector: #color: argument: world color;				redoTarget: world selector: #color: argument: newColor.			world rememberCommand: cmd.			world color: newColor]		ifFalse:			[ScheduledControllers screenController model form: self.			Display restoreAfter: []]! !!Morph methodsFor: 'undo' stamp: 'ar 8/31/2000 23:15'!commandHistory	"Return the command history for the receiver"	| w |	(w _ self world) ifNotNil:[^w commandHistory].	(w _ self currentWorld) ifNotNil:[^w commandHistory].	^CommandHistory new. "won't really record anything but prevent breaking things"! !!Morph methodsFor: 'undo' stamp: 'ar 8/31/2000 23:17'!rememberCommand: aCommand	"Remember the given command for undo"	Preferences useUndo ifFalse: [^ self]. "get out quickly"	^self commandHistory rememberCommand: aCommand! !!BorderedMorph methodsFor: 'menu' stamp: 'ar 8/31/2000 22:59'!changeBorderWidth: evt	| handle origin aHand cmd newWidth |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	cmd _ Command new cmdWording: 'border change';			undoTarget: self selector: #borderWidth: argument: self borderWidth.	handle _ HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			newWidth _ (newPoint - origin) r asInteger // 5.			self borderWidth: newWidth]		lastPointDo:			[:newPoint | self addHalo.			cmd redoTarget: self selector: #borderWidth: argument: newWidth.			self rememberCommand: cmd].	aHand attachMorph: handle.	handle startStepping! !!ColorPickerMorph methodsFor: 'other' stamp: 'ar 8/31/2000 23:00'!delete	"The moment of departure has come.  If the receiver has an affiliated command, finalize it and have the system remember it.  In any case, delete the receiver"	(self valueOfProperty: #commandInProgress) doIfNotNil:		[:cmd | selectedColor ~= originalColor ifTrue:			[cmd redoTarget: target selector: selector arguments: (self argumentsWith: selectedColor).			self rememberCommand: cmd]].	super delete! !!HaloMorph methodsFor: 'private' stamp: 'ar 8/31/2000 23:00'!endInteraction	"Clean up after a user interaction with the a halo control"	| m |	(target isInWorld not or: [owner == nil]) ifTrue: [^ self].	[target isFlexMorph and: [target hasNoScaleOrRotation]]		whileTrue:			[m _ target firstSubmorph.			target removeFlexShell.			target _ m].	self isInWorld ifTrue:		["make sure handles show in front, even if flex shell added"		self comeToFront.		self addHandles].	(self valueOfProperty: #commandInProgress) doIfNotNil:		[:cmd | self rememberCommand: cmd.		self removeProperty: #commandInProgress] ! !!HandMorph methodsFor: 'event handling' stamp: 'ar 8/31/2000 23:03'!unfocusedKeystroke: evt	"A keystroke has come through when no object claimed the keyboard focus.  See if there's something we can do with it"	|  aChar isCmd aWorld |	aChar _ evt keyCharacter.	(aChar == Character tab) ifTrue:		[((aWorld _ self world) hasProperty: #tabAmongFields)			ifTrue:				[^ aWorld tabHitWithEvent: evt]].	isCmd _ evt commandKeyPressed and: [Preferences cmdKeysInText].	isCmd ifTrue:		[(aChar == $b) ifTrue: [^ Browser openBrowser].          "for example"		(aChar == $z) ifTrue: [^ self commandHistory undoOrRedoCommand]]! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 8/31/2000 23:00'!dropMorphsEvent: evt 	"Drop all the morphs this hand is currently holding in response to the 	given event."	"Details: All submorphs of the front-most composite morph under the 	hand are given an opportunity to accept the dropping morph. If none 	of these accepts it, or if there is no morph under the hand, then the 	morph drops into the world."	| newOwner morphToDrop localPt grabbedMorph pos worldUnderCursor |	worldUnderCursor _ self worldUnderCursor.	worldUnderCursor		ifNil: [^ self].	self changed.	self		submorphsReverseDo: [:m | 			"drop in reverse order to maintain back-to-front ordering"			addedFlexAtGrab == true				ifTrue: [pos _ m firstSubmorph position.					grabbedMorph _ m removeFlexShell.					self privateRemoveMorph: grabbedMorph.					grabbedMorph position: pos					"undo offset from removeFlexShell"]				ifFalse: [grabbedMorph _ m].			newOwner _ self dropTargetFor: grabbedMorph event: evt.			newOwner				ifNil: ["Drop not allowed"					self rejectDropMorph: grabbedMorph event: evt.					addedFlexAtGrab == true						ifTrue: [self privateRemoveMorph: m.							addedFlexAtGrab _ false].					^ self].			"Transcript show: newOwner printString; cr."			morphToDrop _ newOwner morphToDropFrom: grabbedMorph.			morphToDrop == grabbedMorph				ifFalse: [submorphs size == 1						ifTrue: [self privateRemoveMorph: m.							m privateOwner: nil.							addedFlexAtGrab _ false]].			"the above says: the thing to drop is not what I was carrying; 			silently vaporize what I was carrying lest it cause trouble 			later; keep the owner/submorph relationship invariant, but 			don't go through the standard delete protocol"			localPt _ newOwner globalPointToLocal: self position.			addedFlexAtGrab == true				ifTrue: [morphToDrop position: (localPt + (morphToDrop position								- (m transform globalPointToLocal: self position))) rounded.					self privateRemoveMorph: m.					addedFlexAtGrab _ false]				ifFalse: [morphToDrop position:							(newOwner gridPoint:								(newOwner globalPointToLocal: morphToDrop position) rounded)].			newOwner acceptDroppingMorph: morphToDrop event: evt.			morphToDrop justDroppedInto: newOwner event: evt.			morphToDrop owner = self				ifTrue: [self world addMorphFront: m]].	currentCommand ifNotNil:		[self rememberCommand: currentCommand.		currentCommand _ nil].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!HandMorph methodsFor: 'world menu' stamp: 'ar 8/31/2000 23:03'!addUndoItemsTo: aWorldMenu	"Add undo-related items to the given menu.  Will add zero, one or two items, depending on the settings of the #useUndo and #infiniteUndo preferences"	Preferences useUndo ifFalse: [^ self].	Preferences infiniteUndo		ifFalse:			[aWorldMenu addUpdating: #undoOrRedoMenuWording target: self commandHistory action: #undoOrRedoCommand]		ifTrue:			[aWorldMenu addUpdating: #undoMenuWording target: self commandHistory  action: #undoLastCommand.			aWorldMenu addUpdating: #redoMenuWording target: self commandHistory action: #redoNextCommand.			self flag: #deferred.  "The following feature to be unblocked in due course"			"aWorldMenu add: 'undo to...' target: self commandHistory action: #undoTo"].	aWorldMenu addLine! !!PasteUpMorph methodsFor: 'undo' stamp: 'ar 8/31/2000 23:16'!commandHistory	"Return the command history for the receiver"	^self isWorldMorph		ifTrue:[worldState commandHistory]		ifFalse:[super commandHistory]! !!WorldState methodsFor: 'undo support' stamp: 'ar 8/31/2000 22:57'!commandHistory	^commandHistory ifNil:[commandHistory _ CommandHistory new]! !UndefinedObject removeSelector: #rememberCommand:!PasteUpMorph removeSelector: #rememberCommand:!Command class removeSelector: #cantUndo!Command class removeSelector: #commandToUndo!Command class removeSelector: #historyIndexOfLastCommand!Command class removeSelector: #initialize!Command class removeSelector: #lastCommand!Command class removeSelector: #nextCommand!Command class removeSelector: #nextCommandToUndo!Command class removeSelector: #promoteToCurrent:!Command class removeSelector: #redoMenuWording!Command class removeSelector: #rememberCommand:!Command class removeSelector: #resetCommandHistory!Command class removeSelector: #undoMenuWording!Command class removeSelector: #undoOrRedoCommand!Command class removeSelector: #undoOrRedoMenuWording!Command class removeSelector: #undoTo!Command removeSelector: #remember!Object subclass: #Command	instanceVariableNames: 'phase cmdWording undoTarget undoSelector undoArguments redoTarget redoSelector redoArguments parameters '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Undo'!