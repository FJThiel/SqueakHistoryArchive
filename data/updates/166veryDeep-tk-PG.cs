'From Squeak 2.1 of June 30, 1998 on 4 August 1998 at 1:42:42 pm'!!PasteUpMorph methodsFor: 'misc' stamp: 'tk 8/3/1998 17:52'!releaseCachedState	presenter ifNotNil: [presenter flushViewerCache].	super releaseCachedState! !!SmartRefStream commentStamp: 'tk 8/4/1998 13:42' prior: 0!Ordinary ReferenceStreams assume that the layout of instance variables in an object on the disk is the same as the layout of that class in memory now.  And it assumes that the class has the same name as before.  SmartRefStream allows one to bring in objects whose instance variables or class name have changed.  1/13/97 tk>>>>See SmartRefStream.aComment for an example.<<<< The basic principal is that object conversion to a new version needs to be done after the fact.  SmartRefStream records the names of the instance variables of all outgoing classes.  Adjustments are done later when the file is read in.* Allows incoming object to have fewer instance variables than the current class.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure description, which is big.  * Writes triplets of (version, class structure array, object) on the file.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.		Note that aDictionary has (old inst var name -> value) * Prompts the user to write (or file in) a conversion method when needed.* Allows a change of instance vars in a superclass to be handled by just one conversion method.  Figures out what to do to the subclasses.* Allows mixing cole for filing in, and raw objects.  The file can start out in the normal fileOut format.  Definitions of new classes on the front and an object are at the end.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, #marked if internal call.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.UniClasses are classes for the instance specific behavior of just one instance.  Subclasses of Player are an example.  When a UniClass is read in, and a class of the same name already exists, the incoming one is renamed.  ObjectScanner converts the filed in code.Values in instance variables of UniClasses are stored in the array that tells the class structure.  It is the fourth of the four top level objects.  #(version (class-structure) the-object ((#Player25 scripts slotInfo costumeDictionary) (#Player26 scripts slotInfo costumeDictionary))).Future:* Someday will prompt for a new version number when there are new inst vars with same initials, and tells how to make conversion work when some files have already been written.* There should be a separate subclass for doing veryDeepCopy (in memory).  Currently, any object that has objectToStoreOnDataStream return an object other than self does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.!!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/4/1998 13:01'!veryDeepCopy: anObject	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream and storeDataOn:"	| dummy refs class new uniClasses uc old |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"  		"Note that dummy is a ReferenceStream.  instVarInfo: will not be called."	dummy nextPut: anObject.	"Do the traverse of the tree"	uniClasses _ Dictionary new.	"UniClass -> new UniClass"	renamed _ Dictionary new.	refs _ dummy references.	"all the objects"	"For each object, make a simple copy, then replace all fields with new copy from dict"	refs keysDo: [:each | 		class _ each class.		class == Metaclass ifTrue: ["object is a metaclass" self error: 'can''t copy a class'].		class isMeta 			ifTrue: ["a class" self error: 'can''t copy a class']			ifFalse: ["an instance" class isSystemDefined 				ifFalse: [uc _ uniClasses at: class ifAbsent: [nil].					uc ifNil: [uniClasses at: class put: (uc _ each copyUniClass)]]]].	uniClasses do: [:uniCls | 		dummy nextPut: uniCls scripts].	"more objects to veryDeepCopy"	refs associationsDo: [:assoc | 		(uniClasses includesKey: assoc key class)			ifFalse: [(#(Form Color StrikeFont) includes: assoc key class name)				ifFalse: [assoc key class == DiskProxy					ifFalse: [assoc value: assoc key clone]					ifTrue: [assoc value: nil "assoc key comeFullyUpOnReload"]]						"a DiskProxy will never be looked up -- its not in any field.						Old value of field is used."				ifTrue: [assoc value: assoc key]]		"Don't copy Forms, Colors"			ifTrue: [old _ assoc key.				assoc value: (new _ (uc _ uniClasses at: assoc key class) new).				1 to: uc instSize do: [:ii | new instVarAt: ii put: (old instVarAt: ii)]]].		"Watch out for classes that do extra things in copy but not in shallowCopy"	self veryDeepRectify: refs.	"rehashes Sets and Dictionaries"	self veryDeepClassVars: refs.		ScannedObject _ refs.	"debug"	^ refs at: anObject! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'tk 8/3/1998 15:56'!viewerBook	^ pages detect: [:p | (p isKindOf: ViewerBook)] ifNone: [nil]! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'tk 8/3/1998 22:30'!releaseCachedState	| vv |	(vv _ self viewerBook) ifNotNil: [		(self currentPage ~~ vv) ifTrue: [vv removeEverything]].	super releaseCachedState! !