'From Squeak2.8alpha of 19 January 2000 [latest update: #2299] on 7 June 2000 at 7:46:15 pm'!"Change Set:		JMM-Socket ChangesDate:			5 June 2000Author:			John M McIntoshA number of changes were made to NetNameResolver and Socket when I was creating the Macintosh Open Transport plugin. These changes range from adding some accessors to get at instance variables to a fundamental change in semaphore signalling logic.We now have three semaphores: one for open/close/listen, one for reading, one for writing. Existing applications and existing C code are unaffected by this change since I attempted to make this change backwards compatible. However this change makes mult-threaded applications safer to write since you now can have seperate processes in a application that have the responsiblity for listening, reading, and writing to a socket. Implementation of this feature depends on the underlying VM implementation. As of June 5th 2000 it is fully supported on the Macintosh. Beware you can of course write a Squeak application that will not behave correctly on an older VM. Use the accessor primitiveOnlySupportsOneSemaphore to find out if the C code supports one or three semaphores and make a decision about continuing.Additional support for UDP was added, now you can set the host for an outgoing UDP datagrams, and on reading a UDP datagram get information about who it came from, this support of course relies on the underlying VM implementation. Although this feature was support somewhat in the in the previous implementation we now tie host information to the datagram which ensures race conditions or high volume UDP traffic from multiple locations does not affect who we think we are talking to.Support for setting and getting Socket, TCP/IP, and UDP options was added.  You should be able to set or get information about socket options for all of the common options and most of the uncommon ones. Again support relies on the underlying VM implementation.Lastly some cleanup of the test examples and new examples were added, but for testing purposes you should use the SUnit test suite that I created to run tests when making socket C code changes or changes to the Classes"!Object subclass: #Socket	instanceVariableNames: 'semaphore socketHandle writeSemaphore primitiveOnlySupportsOneSemaphore readSemaphore '	classVariableNames: 'Connected DeadServer InvalidSocket OtherEndClosed Registry TCPSocketType ThisEndClosed UDPSocketType Unconnected WaitingForConnection '	poolDictionaries: ''	category: 'Network-Kernel'!Socket allSubInstancesDo: [:s | s instVarNamed: 'primitiveOnlySupportsOneSemaphore' put: true]!!Socket commentStamp: '<historical>' prior: 0!A Socket represents a network connection point. Current sockets are designed to support the TCP/IP and UDP protocolsSubclasses of socket provide support for network protocols such as POP, NNTP, HTTP, and FTP. Sockets also allow you to implement your own custom services and may be used to support Remote Procedure Call or Remote Method Invocation some day.JMM June 2nd 2000 Macintosh UDP support was added if you run open transport.!]style[(196 4 6 3 228)f1,f1LHTTPSocket Comment;,f1,f1LFTPSocket Comment;,f1!!NetNameResolver class methodsFor: 'lookups' stamp: 'JMM 5/3/2000 17:35'!addressForName: hostName timeout: secs	"Look up the given host name and return its address. Return nil if the address is not found in the given number of seconds."	"NetNameResolver addressForName: 'create.ucsb.edu' timeout: 30"	"NetNameResolver addressForName: '100000jobs.de' timeout: 30"	"NetNameResolver addressForName: '1.7.6.4' timeout: 30"	"NetNameResolver addressForName: '' timeout: 30 (This seems to return nil?)"	| deadline ready success result |	"check if this is a valid numeric host address (e.g. 1.2.3.4)"	result _ self addressFromString: hostName.	result isNil ifFalse: [^result].	"Look up a host name, including ones that start with a digit (e.g. 100000jobs.de or squeak.org)"	deadline _ Time millisecondClockValue + (secs * 1000).	ready _ self waitForResolverReadyUntil: deadline.	ready ifFalse: [^ nil].	self primStartLookupOfName: hostName.	success _ self waitForCompletionUntil: deadline.	success		ifTrue: [^ self primNameLookupResult]		ifFalse: [^ nil].! !!NetNameResolver class methodsFor: 'lookups' stamp: 'JMM 5/3/2000 11:25'!resolverError	^self primNameResolverError! !!NetNameResolver class methodsFor: 'lookups' stamp: 'JMM 5/3/2000 11:25'!resolverStatus	^self primNameResolverStatus! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'JMM 5/3/2000 11:35'!initializeNetworkIfFail: errorBlock	"Initialize the network drivers and record the semaphore to be used by the resolver. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails."	"NetNameResolver initializeNetworkIfFail: [self error: 'network initialization failed']"	| semaIndex result |	self resolverStatus = ResolverUninitialized		ifFalse: [			LastContact _ Time totalSeconds.  HaveNetwork _ true.			^ self].  "network is already initialized"	LastContact _ Time totalSeconds.  HaveNetwork _ false.	"in case abort"	ResolverSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: ResolverSemaphore.	Utilities informUser:'Initializing the network drivers; this maytake up to 30 seconds and can''t be interrupted'		during: [result _ self primInitializeNetwork: semaIndex].	Smalltalk isMorphic ifTrue: [World displayWorld].  "take the informer down"	"result is nil if network initialization failed, self if it succeeds"	result ifNil: [errorBlock value]		ifNotNil: [HaveNetwork _ true].! !!NetNameResolver class methodsFor: 'private' stamp: 'JMM 5/3/2000 13:57'!readDecimalByteFrom: aStream	"Read a positive, decimal integer from the given stream. Stop when a non-digit or end-of-stream is encountered. Return nil if stream is not positioned at a decimal digit or if the integer value read exceeds 255.JMM - 000503 fixed didn't work correctly"	| digitSeen value digit |	digitSeen _ false.	value _ 0.	[aStream atEnd] whileFalse: 		[digit _ aStream next digitValue.		(digit < 0 or: [digit > 9]) ifTrue: [			aStream skip: -1.			(digitSeen not or: [value > 255]) ifTrue: [^ nil].			^ value].		digitSeen _ true.		value _ (value * 10) + digit].	(digitSeen not or: [value > 255]) ifTrue: [^ nil].	^ value! !!NetNameResolver class methodsFor: 'private' stamp: 'JMM 5/3/2000 11:35'!waitForCompletionUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is ready, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status _ self resolverStatus.	[(status = ResolverBusy) and:	 [Time millisecondClockValue < deadline]]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self resolverStatus].	status = ResolverReady		ifTrue: [^ true]		ifFalse: [			status = ResolverBusy ifTrue: [self primAbortLookup].			^ false].! !!NetNameResolver class methodsFor: 'private' stamp: 'JMM 5/3/2000 11:36'!waitForResolverReadyUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is not busy, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status _ self resolverStatus.	status = ResolverUninitialized ifTrue: [^ false].	[(status = ResolverBusy) and:	 [Time millisecondClockValue < deadline]]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self resolverStatus].	^ status ~= ResolverBusy! !!Socket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 22:47'!acceptFrom: aSocket	"Initialize a new socket handle from an accept call"	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore _ false.	semaphore _ Semaphore new.	readSemaphore _ Semaphore new.	writeSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	readSemaIndex _ Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex _ Smalltalk registerExternalObject: writeSemaphore.	socketHandle _ self primAcceptFrom: aSocket socketHandle						receiveBufferSize: 8000						sendBufSize: 8000						semaIndex: semaIndex						readSemaIndex: readSemaIndex						writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore _ writeSemaphore _ semaphore _ nil	] ifFalse:[self register].! !!Socket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 22:54'!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil ifFalse: 		[self isValid ifTrue: [self primSocketDestroy: socketHandle].		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		socketHandle _ nil.		readSemaphore _ writeSemaphore _ semaphore _ nil.		self unregister].! !!Socket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 23:04'!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore _ false.	semaphore _ Semaphore new.	readSemaphore _ Semaphore new.	writeSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	readSemaIndex _ Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex _ Smalltalk registerExternalObject: writeSemaphore.	socketHandle _		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore _ writeSemaphore _ semaphore _ nil	] ifFalse:[self register].! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/10/2000 14:37'!localAddress	self waitForConnectionUntil: Socket standardDeadline.	self isConnected ifFalse: [^ByteArray new: 4].	^ self primSocketLocalAddress: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/10/2000 14:31'!localPort	self waitForConnectionUntil: Socket standardDeadline.	self isConnected ifFalse: [^0 ].	^ self primSocketLocalPort: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'JMM 6/5/2000 10:12'!primitiveOnlySupportsOneSemaphore	^primitiveOnlySupportsOneSemaphore! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/22/2000 22:49'!readSemaphore	primitiveOnlySupportsOneSemaphore ifTrue: [^semaphore].	^readSemaphore! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/9/2000 15:32'!semaphore	^semaphore! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/22/2000 22:49'!writeSemaphore	primitiveOnlySupportsOneSemaphore ifTrue: [^semaphore].	^writeSemaphore! !!Socket methodsFor: 'queries' stamp: 'JMM 5/5/2000 12:15'!isOtherEndClosed	"Return true if this socket had the other end closed."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == OtherEndClosed! !!Socket methodsFor: 'queries' stamp: 'JMM 5/5/2000 12:17'!isThisEndClosed	"Return true if this socket had the this end closed."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == ThisEndClosed! !!Socket methodsFor: 'queries' stamp: 'JMM 5/8/2000 23:24'!socketError	^self primSocketError: socketHandle! !!Socket methodsFor: 'sending-receiving' stamp: 'JMM 6/3/2000 21:48'!getData	"Get some data"	| buf bytesRead |	(self waitForDataUntil: Socket standardDeadline) ifFalse: [self error: 'getData timeout'].	buf _ String new: 4000.	bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'waiting' stamp: 'JMM 5/22/2000 22:04'!waitForDataUntil: deadline	"Wait up until the given deadline for data to arrive. Return true if data arrives by the deadline, false if not."	| dataArrived |	[self isConnected & 	 (dataArrived _ self primSocketReceiveDataAvailable: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			self readSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ dataArrived! !!Socket methodsFor: 'waiting' stamp: 'JMM 5/17/2000 14:52'!waitForDisconnectionUntil: deadline	"Wait up until the given deadline for the the connection to be broken. Return true if it is broken by the deadline, false if not."	"Note: The client should know the the connect is really going to be closed (e.g., because he has called 'close' to send a close request to the other end) before calling this method.JMM 00/5/17 note that other end can close which will terminate wait"	| extraBytes status |	extraBytes _ 0.	status _ self primSocketConnectionStatus: socketHandle.	[((status = Connected) or: [(status = ThisEndClosed)]) and:	 [Time millisecondClockValue < deadline]] whileTrue: [		self dataAvailable			ifTrue: [extraBytes _ extraBytes + self discardReceivedData].		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		status _ self primSocketConnectionStatus: socketHandle].	extraBytes > 0		ifTrue: [self inform: 'Discarded ', extraBytes printString, ' bytes while closing connection.'].	^ status ~= Connected! !!Socket methodsFor: 'waiting' stamp: 'JMM 5/22/2000 22:05'!waitForSendDoneUntil: deadline	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone |	[self isConnected & (sendDone _ self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			self writeSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ sendDone! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/22/2000 22:55'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"Create and return a new socket handle based on accepting the connection from the given listening socket"	<primitive: 'primitiveSocketAccept3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore _ true.	^self primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex ! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 21:48'!primSocket: socketID getOption: aString 	"Get some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP_NODELAY, SO_KEEPALIVE are valid options for example	returns an array containing the error code and the option value"	<primitive: 'primitiveSocketGetOptions' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/24/2000 17:19'!primSocket: socketID receiveUDPDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. 	Return an Array containing the amount read, the host address byte array, the host port, and the more flag"	<primitive: 'primitiveSocketReceiveUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 00:08'!primSocket: socketID sendUDPData: aStringOrByteArray toHost: hostAddress  port: portNumber startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive:  'primitiveSocketSendUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 20:12'!primSocket: socketID setOption: aString value: aStringValue	"Set some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP_NODELAY, SO_KEEPALIVE are valid options for example	returns an array containing the error code and the negotiated value"	<primitive: 'primitiveSocketSetOptions' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 6/3/2000 21:53'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex	"Return a new socket handle for a socket of the given type and buffer sizes. Return nil if socket creation fails.	The netType parameter is platform dependent and can be used to encode both the protocol type (IP, Xerox XNS, etc.) and/or the physical network interface to use if this host is connected to multiple networks. A zero netType means to use IP protocols and the primary (or only) network interface.	The socketType parameter specifies:		0	reliable stream socket (TCP if the protocol is IP)		1	unreliable datagram socket (UDP if the protocol is IP)	The buffer size parameters allow performance to be tuned to the application. For example, a larger receive buffer should be used when the application expects to be receiving large amounts of data, especially from a host that is far away. These values are considered requests only; the underlying implementation will ensure that the buffer sizes actually used are within allowable bounds. Note that memory may be limited, so an application that keeps many sockets open should use smaller buffer sizes. Note the macintosh implementation ignores this buffer size. Also see setOption to get/set socket buffer sizes which allows you to set/get the current buffer sizes for reading and writing. 	If semaIndex is > 0, it is taken to be the index of a Semaphore in the external objects array to be associated with this socket. This semaphore will be signalled when the socket status changes, such as when data arrives or a send completes. All processes waiting on the semaphore will be awoken for each such event; each process must then query the socket state to figure out if the conditions they are waiting for have been met. For example, a process waiting to send some data can see if the last send has completed."	<primitive: 209>	^ nil  "socket creation failed"! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/22/2000 22:48'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"See comment in primSocketCreateNetwork: with one semaIndex. However you should know that some implementations	ignore the buffer size and this interface supports three semaphores,  one for open/close/listen and the other two for	reading and writing"	<primitive: 'primitiveSocketCreate3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore _ true.	^ self primSocketCreateNetwork: netType			type: socketType			receiveBufferSize: rcvBufSize			sendBufSize: sendBufSize			semaIndex: semaIndex! !!Socket methodsFor: 'finalization' stamp: 'JMM 5/22/2000 22:52'!finalize	self primSocketDestroyGently: socketHandle.	Smalltalk unregisterExternalObject: semaphore.	Smalltalk unregisterExternalObject: readSemaphore.	Smalltalk unregisterExternalObject: writeSemaphore.! !!Socket methodsFor: 'datagrams' stamp: 'JMM 6/7/2000 14:58'!receiveDataInto: aStringOrByteArray fromHost: hostAddress port: portNumber	| datagram |	"Receive a UDP packet from the given hostAddress/portNumber, storing the data in the given buffer, and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	primitiveOnlySupportsOneSemaphore ifTrue:		[self setPeer: hostAddress port: portNumber.		^self receiveDataInto: aStringOrByteArray].	[true] whileTrue: 		[datagram _ self receiveUDPDataInto: aStringOrByteArray.		((datagram at: 2) = hostAddress and: [(datagram at: 3) = portNumber]) 			ifTrue: [^datagram at: 1]			ifFalse: [^0]]! !!Socket methodsFor: 'datagrams' stamp: 'JMM 6/3/2000 21:54'!receiveUDPDataInto: aStringOrByteArray	"Receive UDP data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data. What is returned is an array, the first element is the bytes read, the second the sending bytearray address, the third the senders port, the fourth, true if more of the datagram awaits reading"	^ self primSocket: socketHandle		receiveUDPDataInto: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size! !!Socket methodsFor: 'datagrams' stamp: 'JMM 5/25/2000 00:05'!sendData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	primitiveOnlySupportsOneSemaphore ifTrue:		[self setPeer: hostAddress port: portNumber.		^self sendData: aStringOrByteArray].	^self sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber! !!Socket methodsFor: 'datagrams' stamp: 'JMM 5/25/2000 00:07'!sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	| bytesToSend bytesSent count |	bytesToSend _ aStringOrByteArray size.	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneUntil: (Socket deadlineSecs: 20))			ifFalse: [self error: 'send data timeout; data not sent'].		count _ self primSocket: socketHandle			sendUDPData: aStringOrByteArray			toHost: hostAddress			port: portNumber			startIndex: bytesSent + 1			count: bytesToSend - bytesSent.		bytesSent _ bytesSent + count].	^ bytesSent! !!Socket methodsFor: 'other' stamp: 'JMM 6/3/2000 19:39'!getOption: aName 	"Get options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is an status number (0 ok, -1 read only option)	element two is the resulting of the requested option"	(socketHandle == nil or: [self isValid not])		ifTrue: [self error: 'Socket status must valid before getting an option'].	^self primSocket: socketHandle getOption: aName"| foo options |Socket initializeNetwork.foo _ Socket newTCP.foo connectTo: (NetNameResolver addressFromString: '192.168.1.1') port: 80.foo waitForConnectionUntil: (Socket standardDeadline).options _ {'SO_DEBUG'. 'SO_REUSEADDR'. 'SO_REUSEPORT'. 'SO_DONTROUTE'.'SO_BROADCAST'. 'SO_SNDBUF'. 'SO_RCVBUF'. 'SO_KEEPALIVE'.'SO_OOBINLINE'. 'SO_PRIORITY'. 'SO_LINGER'. 'SO_RCVLOWAT'.'SO_SNDLOWAT'. 'IP_TTL'. 'IP_HDRINCL'. 'IP_RCVOPTS'.'IP_RCVDSTADDR'. 'IP_MULTICAST_IF'. 'IP_MULTICAST_TTL'.'IP_MULTICAST_LOOP'. 'UDP_CHECKSUM'. 'TCP_MAXSEG'.'TCP_NODELAY'. 'TCP_ABORT_THRESHOLD'. 'TCP_CONN_NOTIFY_THRESHOLD'. 'TCP_CONN_ABORT_THRESHOLD'. 'TCP_NOTIFY_THRESHOLD'.'TCP_URGENT_PTR_TYPE'}.1 to: options size do: [:i | | fum |	fum _foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr].foo _ Socket newUDP.foo setPeer: (NetNameResolver addressFromString: '192.168.1.9') port: 7.foo waitForConnectionUntil: (Socket standardDeadline).1 to: options size do: [:i | | fum |	fum _foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr]."! !!Socket methodsFor: 'other' stamp: 'JMM 6/3/2000 19:39'!setOption: aName value: aValue 	| value |	"setup options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is the error number	element two is the resulting of the negotiated value.	See getOption for list of keys"	(socketHandle == nil or: [self isValid not])		ifTrue: [self error: 'Socket status must valid before setting an option'].	value _ aValue asString.	aValue == true ifTrue: [value _ '1'].	aValue == false ifTrue: [value _ '0'].	^ self primSocket: socketHandle setOption: aName value: value! !!Socket class methodsFor: 'tests' stamp: 'JMM 5/19/2000 22:13'!loopbackTest	"Send data from one socket to another on the local machine. Tests most of the socket primitives."	"100 timesRepeat: [Socket loopbackTest]"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived t extraBytes packetsSent packetsRead |	Transcript cr; show: 'starting loopback test'; cr.	Transcript show: '---------- Connecting ----------'; cr.	Socket initializeNetwork.	sock1 _ Socket new.	sock2 _ Socket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	bytesToSend _ 5000000.	sendBuf _ String new: 5000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	packetsSent _ packetsRead _ bytesSent _ bytesReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (sock1 sendSomeData: sendBuf)].			sock2 dataAvailable ifTrue: [				packetsRead _ packetsRead + 1.				bytesReceived _ bytesReceived +					(sock2 receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend) and: [bytesReceived = bytesSent]]].		Transcript show: 'closing connection'; cr.	sock1 waitForSendDoneUntil: self standardDeadline.	sock1 close.	sock2 waitForDisconnectionUntil: self standardDeadline.	extraBytes _ sock2 discardReceivedData.	extraBytes > 0 ifTrue: [		Transcript show: ' *** received ', extraBytes size printString, ' extra bytes ***'; cr.	].	sock2 close.	sock1 waitForDisconnectionUntil: self standardDeadline.	(sock1 isUnconnectedOrInvalid) ifFalse: [self error: 'sock1 not closed'].	(sock2 isUnconnectedOrInvalid) ifFalse: [self error: 'sock2 not closed'].	Transcript show: '---------- Connection Closed ----------'; cr.	sock1 destroy.	sock2 destroy.	Transcript show: 'loopback test done; time = ', t printString; cr.	Transcript show: ((bytesToSend asFloat / t) roundTo: 0.01) printString, ' 1000Bytes/sec'; cr.	Transcript endEntry.! !!Socket class methodsFor: 'tests' stamp: 'JMM 5/22/2000 23:06'!sendTest	"Send data to the 'discard' socket of the given host. Tests the speed of one-way data transfers across the network to the given host. Note that many host hosts do not run a discard server."	"Socket sendTest"	| sock bytesToSend sendBuf bytesSent t serverName serverAddr |	Transcript cr; show: 'starting send test'; cr.	Socket initializeNetwork.	serverName _ FillInTheBlank		request: 'What is the destination server?'		initialAnswer: 'create.ucsb.edu'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', serverName].	sock _ Socket new.	Transcript show: '---------- Connecting ----------'; cr.	sock connectTo: serverAddr port: 9.	sock waitForConnectionUntil: self standardDeadline.	(sock isConnected) ifFalse: [		sock destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection established; sending data'; cr.	bytesToSend _ 1000000.	sendBuf _ String new: 64*1024 withAll: $x.	bytesSent _ 0.	t _ Time millisecondsToRun: [		[bytesSent < bytesToSend] whileTrue: [			sock sendDone ifTrue: [				bytesSent _ bytesSent + (sock sendSomeData: sendBuf)]]].	sock waitForSendDoneUntil: self standardDeadline.	sock destroy.	Transcript show: '---------- Connection Closed ----------'; cr.	Transcript show: 'send test done; time = ', t printString; cr.	Transcript show: ((bytesToSend asFloat / t) roundTo: 0.01) printString, ' 1000Bytes/sec'; cr.	Transcript endEntry.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/19/2000 21:38'!clientServerTestUDP	"Socket clientServerTestUDP"	"Performa 6400/200, Linux-PPC 2.1.24:		client/server UDP test done; time = 2820		2500 packets, 10000000 bytes sent (3546 kBytes/sec)		2500 packets, 10000000 bytes received (3546 kBytes/sec)		4000 bytes/packet, 886 packets/sec, 0 packets dropped"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t |	Transcript show: 'starting client/server UDP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	Transcript show: 'creating endpoints'; cr.	sock1 _ Socket newUDP.	"the sender"	sock2 _ Socket newUDP.	"the recipient"	sock2 setPort: 54321.	sock1 setPeer: (NetNameResolver localHostAddress) port: (sock2 port).	Transcript show: 'endpoints created'; cr.	bytesToSend _ 10000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (sock1 sendData: sendBuf)].			sock2 dataAvailable ifTrue: [				packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived +					(sock2 receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)].		sock1 waitForSendDoneUntil: self standardDeadline.		bytesReceived _ bytesReceived + sock2 discardReceivedData].	Transcript show: 'closing endpoints'; cr.	sock1 close.	sock2 close.	sock1 destroy.	sock2 destroy.	Transcript show: 'client/server UDP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: (bytesSent // packetsSent) printString, ' bytes/packet, ',						(packetsReceived * 1000 // t) printString, ' packets/sec, ',						(packetsSent - packetsReceived) printString, ' packets dropped'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/28/2000 23:18'!clientServerTestUDP2	"Socket clientServerTestUDP2"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t datagramInfo |	Transcript show: 'starting client/server UDP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	Transcript show: 'creating endpoints'; cr.	sock1 _ Socket newUDP.	"the sender"	sock2 _ Socket newUDP.	"the recipient"	sock2 setPort: 54321.	Transcript show: 'endpoints created'; cr.	bytesToSend _ 100000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 2000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (sock1 sendData: sendBuf toHost: (NetNameResolver localHostAddress) port: (sock2 port))].				sock2 dataAvailable ifTrue: [				packetsReceived _ packetsReceived + 1.				datagramInfo _ sock2 receiveUDPDataInto: receiveBuf.				bytesReceived _ bytesReceived + (datagramInfo at: 1)].			done _ (bytesSent >= bytesToSend)].		sock1 waitForSendDoneUntil: self standardDeadline.		bytesReceived _ bytesReceived + sock2 discardReceivedData].	Transcript show: 'closing endpoints'; cr.	sock1 close.	sock2 close.	sock1 destroy.	sock2 destroy.	Transcript show: 'client/server UDP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: (bytesSent // packetsSent) printString, ' bytes/packet, ',						(packetsReceived * 1000 // t) printString, ' packets/sec, ',						(packetsSent - packetsReceived) printString, ' packets dropped'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/19/2000 21:41'!remoteTestClientTCP	"FIRST start up another image, and execute: Socket remoteTestServerTCP.	THEN come back to this image and execute:"			"Socket remoteTestClientTCP"	"Performa 6400/200, Linux-PPC 2.1.24, both images on same CPU:		remoteClient TCP test done; time = 5680		250 packets, 1000000 bytes sent (176 kBytes/sec)		60 packets, 1000000 bytes received (176 kBytes/sec)"	| socket bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t serverName |	Transcript show: 'starting client/server TCP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newTCP.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	socket connectTo: (NetNameResolver addressFromString: serverName) port: 54321.	socket waitForConnectionUntil: Socket standardDeadline.	Transcript show: 'client endpoint created'; cr.	bytesToSend _ 1000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse:			[(socket sendDone and: [bytesSent < bytesToSend]) ifTrue:				[packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (socket sendData: sendBuf)].			socket dataAvailable ifTrue:				[packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)].		[bytesReceived < bytesToSend] whileTrue:			[socket dataAvailable ifTrue:				[packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)]]].	socket closeAndDestroy.	Transcript show: 'remoteClient TCP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' bytes/sec)'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/19/2000 22:08'!remoteTestClientTCPOpenClose1000	"Socket remoteTestClientTCPOpenClose1000"	| number t1 socket serverName |	Transcript show: 'starting client/server TCP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	number _ 1000.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	t1 _ Time millisecondsToRun: 		[number timesRepeat: 		[socket _ Socket newTCP.		socket connectTo: (NetNameResolver addressFromString: serverName) port: 54321.		socket waitForConnectionUntil: Socket standardDeadline.		socket closeAndDestroy]].	Transcript cr;show: 'connects/close per second ', ((number/t1*1000.0) printString); cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/21/2000 14:13'!remoteTestClientTCPOpenClosePutGet	"Socket remoteTestClientTCPOpenClosePutGet"	| checkLength number bytesExpected sendBuf receiveBuf t1 socket bytesReceived serverName | 	Transcript show: 'starting client/server TCP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	number _ 1000.		bytesExpected _ 20000.	sendBuf _ String new: 80 withAll: $x.	receiveBuf _ String new: 50000.	t1 _ Time millisecondsToRun: 		[number timesRepeat: 		[socket _ Socket newTCP.		socket connectTo: (NetNameResolver addressFromString: serverName) port: 54321.		socket waitForConnectionUntil: Socket standardDeadline.		socket sendData: sendBuf.		socket waitForSendDoneUntil: (Socket deadlineSecs: 5).		socket waitForDataUntil: (Socket deadlineSecs: 5).		bytesReceived _ 0.		[bytesReceived < bytesExpected] whileTrue:			[checkLength _ socket receiveDataInto: receiveBuf.			bytesReceived _ bytesReceived + checkLength].		socket closeAndDestroy]].	Transcript cr;show: 'connects/get/put/close per second ', ((number/t1*1000.0) printString); cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/23/2000 14:38'!remoteTestClientUDP	"FIRST start up another image, and execute: Socket remoteTestServerUDP.	THEN come back to this image and execute:"			"Socket remoteTestClientUDP"	"Performa 6400/200, Linux-PPC 2.1.24:		remoteClient UDP test done; time = 4580		2500 packets, 10000000 bytes sent (2183 kBytes/sec)		180 packets, 720000 bytes received (157 kBytes/sec)		4000 bytes/packet, 39 packets/sec, 2320 packets dropped"	| socket bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t serverName |	Transcript show: 'starting client/server UDP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	socket _ Socket newUDP.	socket setPeer: (NetNameResolver addressFromString: serverName) port: 54321.	Transcript show: 'client endpoint created'; cr.	bytesToSend _ 10000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 4000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse:			[(socket sendDone and: [bytesSent < bytesToSend]) ifTrue:				[packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (socket sendData: sendBuf)].			socket dataAvailable ifTrue:				[packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)].	[socket waitForDataUntil: (Socket deadlineSecs: 1).	socket dataAvailable] whileTrue:		[packetsReceived _ packetsReceived + 1.		bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)]].	socket closeAndDestroy.	Transcript show: 'remoteClient UDP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' bytes/sec)'; cr.	Transcript show: (bytesSent // packetsSent) printString, ' bytes/packet, ',						(packetsReceived * 1000 // t) printString, ' packets/sec, ',						(packetsSent - packetsReceived) printString, ' packets dropped'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/23/2000 12:04'!remoteTestServerTCP	"See remoteTestClientTCP for instructions on running this method."	"Socket remoteTestServerTCP"	| socket buffer n |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newTCP.	socket listenOn: 54321.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 4000.	socket waitForConnectionUntil: self standardDeadline.	[socket isConnected] whileTrue: [		socket dataAvailable ifTrue:			[n _ socket	receiveDataInto: buffer.			socket sendData: buffer count: n]].	socket closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/19/2000 22:12'!remoteTestServerTCPOpenClose1000	"The version of #remoteTestServerTCPOpenClose1000 using the BSD style accept() mechanism."	"Socket remoteTestServerTCPOpenClose1000"	| socket server |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	server _ Socket newTCP.	server listenOn: 54321 backlogSize: 20.	server isValid ifFalse:[self error:'Accept() is not supported'].	Transcript show: 'server endpoint created -- run client test in other image'; cr.	1000 timesRepeat: 		[socket _ server waitForAcceptUntil: (Socket deadlineSecs: 300).		socket closeAndDestroy].	server closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/19/2000 22:12'!remoteTestServerTCPOpenClosePutGet		"The version of #remoteTestServerTCPOpenClosePutGet using the BSD style accept() mechanism."	"Socket remoteTestServerTCPOpenClosePutGet"	| socket server bytesIWantToSend bytesExpected receiveBuf sendBuf checkLength |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	server _ Socket newTCP.	server listenOn: 54321 backlogSize: 20.	server isValid ifFalse:[self error:'Accept() is not supported'].	Transcript show: 'server endpoint created -- run client test in other image'; cr.	bytesIWantToSend _ 20000.	bytesExpected _ 80.	receiveBuf _ String new: 40000.	sendBuf _ String new: bytesIWantToSend withAll: $x.	1000 timesRepeat: 		[socket _ server waitForAcceptUntil: (Socket deadlineSecs: 300).		socket waitForDataUntil: (Socket deadlineSecs: 5).		checkLength _ socket receiveDataInto: receiveBuf.		(checkLength ~= bytesExpected) ifTrue: [self halt].		socket sendData: sendBuf.		socket waitForSendDoneUntil: (Socket deadlineSecs: 5).				socket closeAndDestroy].	server closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/23/2000 12:09'!remoteTestServerTCPUsingAccept	"The version of #remoteTestServer using the BSD style accept() mechanism."	"Socket remoteTestServerTCPUsingAccept"	| socket buffer n server |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	server _ Socket newTCP.	server listenOn: 54321 backlogSize: 4.	server isValid ifFalse:[self error:'Accept() is not supported'].	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 40000.	10 timesRepeat: 		[socket _ server waitForAcceptUntil: (self deadlineSecs: 300).		[socket isConnected] whileTrue: [ 			socket dataAvailable ifTrue:				[n _ socket	receiveDataInto: buffer.				socket sendData: buffer count: n]]].	socket closeAndDestroy.	server closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/23/2000 12:25'!remoteTestServerUDP	"See remoteTestClientUDP for instructions on running this method."	"Socket remoteTestServerUDP"	| socket buffer n |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newUDP.	socket setPort: 54321.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 4000.	[true] whileTrue: [		socket dataAvailable ifTrue:			[n _ socket	receiveDataInto: buffer.				socket sendData: buffer count: n]].! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/24/2000 21:55'!remoteTestServerUDP2	"See remoteTestClientUDP for instructions on running this method."	"Socket remoteTestServerUDP2"	| socket buffer datagramInfo |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newUDP.	socket setPort: 54321.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 65000.	[true] whileTrue: [		socket dataAvailable ifTrue:			[datagramInfo _ socket receiveUDPDataInto: buffer. 			Transcript show: datagramInfo printString;cr.				socket sendData: buffer count: (datagramInfo at: 1)]].! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/17/2000 19:54'!remoteTestSinkTCP	"See sendTest for instructions on running this method."	"Socket remoteTestSinkTCP"	| socket buffer n |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newTCP.	socket listenOn: 9.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 64000.	socket waitForConnectionUntil: self standardDeadline.	[socket isConnected] whileTrue: [		socket dataAvailable ifTrue:			[n _ socket	receiveDataInto: buffer]].	socket closeAndDestroy.	Transcript cr; show: 'sink endpoint destroyed'; cr.! !Object subclass: #Socket	instanceVariableNames: 'semaphore socketHandle readSemaphore writeSemaphore primitiveOnlySupportsOneSemaphore '	classVariableNames: 'Connected DeadServer InvalidSocket OtherEndClosed Registry TCPSocketType ThisEndClosed UDPSocketType Unconnected WaitingForConnection '	poolDictionaries: ''	category: 'Network-Kernel'!