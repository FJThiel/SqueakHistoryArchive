'From Squeak 2.3 of January 14, 1999 on 8 March 1999 at 10:42:33 pm'!"Change Set:		miscCleanups-swDate:			8 March 1999Author:			Scott WallaceA potpourri of fixes, enhancements, and bulletproofings, including...DropShadowMorph now correctly declares itself to be a renderer, so that generic methods like topRendererOrSelf and renderedMorph will work correctly.ChangeSorter now reports class-organization changes and class-renames (never did before.)Reset the suppressDrawing flag to false in HandMorph initForEvents -- fixes obscure bug that could make objects disappear when dragged, if an interrupt had earlier occurred while an object was being dragged over the trashcan.Fixes bug in multi-select logic in mvc changelist browsers (reported by Craig Latta 3/1/99)Fixed bug in ColorPickerMorph.target: for the case where the target did not respond to #color.Fixes up a several places where Sensor cursorPoint was being called, making instead calls that take into account the currently active hand, if any -- to increase the likelihood of code running properly when being replayed via the event recorder.HandMorph.fullDrawOn: bulletproofed against casees that actually can arise where cacheCanvis is nonNil but cachedCanvasHasHoles is nil, which led to a very awkward failure.PluggableListMorph no longer fails when the current selection index is out of range.ChangeSet's checkForSlips produces grammatically-correct msgs now.ScreenController.restoreDisplay passes control on to the WorldMorph version of the same method in the case of a morphic project -- serves to get various parameters correct after a screen resize, etc.Reverse the policy of marking the class as having been reorganized (in the current change set) onh a change-method-category.  Makes it two easy for one person's fileout to clobber another's changed organization.Project-choice menu now marks current one.The ancient #scriptingControl property and its attendant mechanisms are now eliminated."!!Object methodsFor: 'macpal' stamp: 'sw 3/5/1999 18:59'!currentHand	"Return a usable HandMorph -- the one associated with the object's current environment.  This method will always return a hand, even if it has to conjure one up as a last resort.  If a particular hand is actually handling events at the moment (such as a remote hand or a ghost hand), it will be returned."	| w |	^ (w _ self currentWorld) activeHand ifNil: [w hands first]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 3/8/1999 12:07'!lookForSlips	| slips nameLine msg |	nameLine _ '"', self name, '"'.	(slips _ self checkForSlips) size == 0 ifTrue:		[^ self inform: 'No slips detected in change set', nameLine].	msg _ slips size == 1		ifTrue:			[ 'One method in change set', nameLine, 'has a halt, reference to the Transcript,and/or some other ''slip'' in it.Would you like to browse it? ?']		ifFalse:			[ slips size printString,' methods in change set', nameLine, 'have halts or references to theTranscript or other ''slips'' in them.Would you like to browse them?'].	(self confirm: msg)		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!Morph methodsFor: 'structure' stamp: 'sw 3/3/1999 13:08'!presenter	^ owner ifNotNil: [owner presenter] ifNil: [self currentWorld presenter]! !!Morph methodsFor: 'event handling' stamp: 'sw 3/8/1999 00:17'!cursorPoint	^ self currentHand lastEvent cursorPoint! !!Morph methodsFor: 'menus' stamp: 'sw 3/4/1999 15:24'!addDropShadow	| ds hadHalo |	(hadHalo _ self hasHalo) ifTrue: [self halo delete].	self owner replaceSubmorph: self by: (ds _ DropShadowMorph new).	ds addMorph: self.	hadHalo ifTrue: [ds addHalo]! !!BookMorph methodsFor: 'sorting' stamp: 'sw 3/5/1999 17:38'!morphsForPageSorter	| i thumbnails |	'Assembling thumbnail images...'		displayProgressAt: self cursorPoint		from: 0 to: pages size		during:			[:bar | i _ 0.			thumbnails _ pages collect:				[:p | bar value: (i_ i+1).				pages size > 40 					ifTrue: [p smallThumbnailForPageSorter inBook: self]					ifFalse: [p thumbnailForPageSorter inBook: self]]].	^ thumbnails! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'sw 3/8/1999 14:28'!target: anObject	target _ anObject.	(target respondsTo: #color)		ifTrue: [selectedColor _ target color]		ifFalse: [selectedColor _ Color white].! !!DropShadowMorph methodsFor: 'geometry' stamp: 'sw 3/4/1999 16:10'!isRenderer	^ true! !!HandMorph methodsFor: 'initialization' stamp: 'sw 3/7/1999 17:51'!initForEvents	eventSubscribers _ Set new.	mouseDownMorph _ nil.	lastEvent _ MorphicEvent new.	eventTransform _ MorphicTransform identity.	self resetClickState.	mouseOverTimes ifNotNil: [mouseOverTimes _ Dictionary new].	suppressDrawing _ false! !!HandMorph methodsFor: 'drawing' stamp: 'sw 3/8/1999 22:37'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds shadowCanvas |	self suppressDisplay ifTrue: [^ self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue:		[cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvasDepth: aCanvas depth.	(cacheCanvas == nil or: [aCanvas depth = 1]) ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	cachedCanvasHasHoles == true "bulletproofing against nil value, which can happen"		ifTrue: ["Have to draw the real shadow of the form"				shadowCanvas image: cacheCanvas form at: subBnds origin]		ifFalse: ["Much faster if only have to shade the edge of a solid rectangle"				(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do:					[:r | shadowCanvas fillRectangle: r color: Color black]].	"draw morphs in front of the shadow using the cached Form"	aCanvas image: cacheCanvas form at: subBnds origin.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 3/6/1999 00:04'!presenter	"Normally only the world will have a presenter, but the architecture supports individual localized presenters as well"	^ presenter ifNil: [super presenter]! !!PluggableListControllerOfMany methodsFor: 'as yet unclassified' stamp: 'sw 3/1/1999 20:44'!redButtonActivity	| selection firstHit turningOn lastSelection pt scrollFlag |	model okToChange ifFalse: [^ self].		"Don't change selection if model refuses to unlock"	firstHit _ true.	scrollFlag _ false.	lastSelection _ 0.	[sensor redButtonPressed] whileTrue: 		[selection _ view findSelection: (pt _ sensor cursorPoint).		selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"			[pt y < view insetDisplayBox top ifTrue:				[self scrollView: view list lineGrid.				scrollFlag _ true.				selection _ view firstShown].			pt y > view insetDisplayBox bottom ifTrue:				[self scrollView: view list lineGrid negated.				scrollFlag _ true.				selection _ view lastShown]].		(selection == nil or: [selection = lastSelection]) ifFalse: 			[firstHit ifTrue:				[firstHit _ false.				turningOn _ (model listSelectionAt: selection) not].			view selection: selection.			(model listSelectionAt: selection) == turningOn ifFalse:				[view displaySelectionBox.				model listSelectionAt: selection put: turningOn].			lastSelection _ selection]].	scrollFlag ifTrue: [self moveMarker]! !!PluggableListMorph methodsFor: 'initialization' stamp: 'sw 3/8/1999 17:21'!list: listOfStrings	| morphList handler h loc index |	scroller removeAllMorphs.	list _ listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	morphList _ list collect: [:item | StringMorph contents: item font: font].	"Sensitize first morph and copy handler to all the rest"	morphList first on: #mouseDown send: #mouseDown:onItem: to: self.	handler _ morphList first eventHandler.	morphList do: [:m | m eventHandler: handler].	"Lay items out vertically and install them in the scroller"	h _ morphList first height "self listItemHeight".	loc _ 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc _ loc + (0@h)].	scroller addAllMorphs: morphList.	index _ self getCurrentSelectionIndex.	self selectedMorph: ((index = 0 or: [index > morphList size]) ifTrue: [nil] ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0.! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 3/2/1999 14:09'!standardPartsWindow	| aPartsWindow aWorld |	aPartsWindow _ ScriptingSystem newStandardPartsBin wrappedInPartsWindowWithTitle: 'Standard Parts'.	aWorld _ (associatedMorph == nil or: [associatedMorph isInWorld not])		ifTrue:		[self currentWorld]		ifFalse:		[associatedMorph world].	aWorld addMorph: aPartsWindow.  "So that closeEditing won't bomb"	aPartsWindow closeEditing.  "a bit redundant but gets the last details right"	^ aPartsWindow! !!Presenter methodsFor: 'misc' stamp: 'sw 3/3/1999 12:38'!morph: aMorph droppedIntoPasteUpMorph: aPasteUpMorph	aPasteUpMorph automaticViewing ifTrue:		[((aMorph isKindOf: PaintInvokingMorph) and: [aMorph isPartsDonor])	"Ugly yes, but we don't want automatic viewing if we're going to trigger painting"			ifFalse: 				[aPasteUpMorph standardPalette viewMorph: aMorph]]! !!Presenter methodsFor: 'misc' stamp: 'sw 3/3/1999 01:15'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' (', self asOop printString, ')'! !!Project class methodsFor: 'utilities' stamp: 'sw 3/6/1999 22:54'!buildJumpToMenu: menu	"Make the supplied menu offer a list of potential projects, consisting of:		*	The previous-project chain		*	The next project, if any		*	The parent project, if any		*	All projects, alphabetically"	| prev listed i next  toAdd |	listed _ OrderedCollection with: CurrentProject.	i _ 0.	prev _ CurrentProject previousProject.	[(prev ~~ nil and: [(listed includes: prev) not])] whileTrue:		[i _ i + 1.		listed add: prev.		self addItem: prev name , ' (back ' , i printString , ')'					toMenu: menu selection: ('%back' , i printString) project: prev.				prev _ prev previousProject].	(((next _ CurrentProject nextProject) ~~ nil) and: [(listed includes: next) not]) ifTrue:		[self addItem: (next name, ' (forward 1)') toMenu: menu selection: next name project: next]. 	(i > 0 or: [next ~~ nil]) ifTrue: [menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: 		[self addItem: CurrentProject parent name , ' (parent)' toMenu: menu selection: #parent project: CurrentProject parent.		menu addLine].	"Finally all the projects, in alphabetical order"	Project allNamesAndProjects do:		[:aPair | 			toAdd _ aPair last == CurrentProject				ifTrue:					[aPair first, ' (current)']				ifFalse:					[aPair first].			self addItem: toAdd toMenu: menu selection: aPair first project: aPair last].	^ menu! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 3/6/1999 22:42'!restoreDisplay 	"Clear the screen to gray and then redisplay all the scheduled views."	World ifNotNil: [^ World restoreDisplay].	Display extent = DisplayScreen actualScreenSize ifFalse:		[DisplayScreen startUp.		ScheduledControllers unCacheWindows].	ScheduledControllers restore! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 3/7/1999 00:53'!goButton	| aButton |	aButton _  ThreePhaseButtonMorph new.	aButton image:  (ScriptingSystem formAtKey: 'GoPicOn');			offImage: (ScriptingSystem formAtKey: 'GoPic');			pressedImage: (ScriptingSystem formAtKey: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: aButton);			actWhen: #buttonUp;			target: self;			setNameTo: 'Go Button';			setBalloonText:'Resume running all paused scripts'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 3/7/1999 00:53'!stepButton	| aButton |	self flag: #deferred.  "ambiguity about recipients"	aButton _ ThreePhaseButtonMorph new.		aButton			image:  (ScriptingSystem formAtKey: 'StepPicOn');			offImage: (ScriptingSystem formAtKey: 'StepPic');			pressedImage:  (ScriptingSystem formAtKey: 'StepPicOn');			arguments: (Array with: nil with: aButton);		 	actionSelector: #stepStillDown:with:; 			target: self;			setNameTo: 'Step Button'; 			actWhen: #whilePressed;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every paused script exactly once.  Keep the mouse button down over "Step" and everything will keep running until you release it'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 3/7/1999 00:53'!stopButton	"Answer a new button that can serve as a stop button"	| aButton |	aButton _ ThreePhaseButtonMorph new.	aButton		image:  (ScriptingSystem formAtKey: 'StopPic');		offImage: (ScriptingSystem formAtKey: 'StopPic');		pressedImage:  (ScriptingSystem formAtKey: 'StopPicOn').		aButton actionSelector: #stopUp:with:; 		arguments: (Array with: nil with: aButton);		actWhen: #buttonUp;		target: self;		setNameTo: 'Stop Button'; 		setBalloonText: 'Pause all ticking scripts.'.	^ aButton! !!StringHolder methodsFor: 'method category' stamp: 'sw 3/6/1999 12:05'!changeCategory	"Present a menu of the categories of messages for the current class, and let the user choose a new category for the current message"	| aClass aSelector |	(aClass _ self selectedClassOrMetaClass) ifNotNil:		[(aSelector _ self selectedMessageName) ifNotNil:			[(aClass organization letUserReclassify: aSelector) ifTrue:				["Smalltalk changes reorganizeClass: aClass."				"Decided on further review that the above, when present, could cause more                    unexpected harm than good"				self methodCategoryChanged]]]! !!ChangeSorter methodsFor: 'code pane' stamp: 'sw 3/8/1999 20:06'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ contents _ myChangeSet preambleString ifNil: ['']].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents _ 'Added then removed (see versions)'].			class ifNil: [^ contents _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents _ 'Method was added, but cannot be found!!'].			contents _ class sourceCodeAt: sel.			Preferences browseWithPrettyPrint ifTrue:				[contents _ class compilerClass new					format: contents in: class notifying: nil].			^ contents _ contents asText makeSelectorBoldIn: class]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do: [:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was added or changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				"each = #add ifTrue: [strm nextPutAll: 'Entire class was added.'; cr].					...this last a disused branch... #add not produced by change-mgt system any more,"]].			^ contents _ strm contents].! !PasteUpMorph removeSelector: #removeScriptingControls!Presenter removeSelector: #grabScreenAreaButton!