'From Squeak3.1alpha of 28 February 2001 [latest update: #3879] on 26 March 2001 at 12:45:50 pm'!"Change Set:		leanerListsHangover-swDate:			26 March 2001Author:			Scott WallaceRemoves a debugging artifact left by update 3862LeanerLists that resulted in a line of debugging information being written to the screen whenever you dragged within a PluggableListMorphOfMany, such as in the list pane of a changeList.  This kind of debugging code (in this case it was the line 'aMorph printString displayAt: 0@100') is not detected by the 'check for slips' mechanism.To allow use of this style of debugging to be trappable by the check-for-slips mechanism, this update also adds a method Object.printDirectlyToDisplay, and adds that to the list of things checked by the check-for-slips.  Thus, intead of 'aMorph printString displayAt: 0@100', one can now write 'aMorph printDirectlyToDisplay' to achieve the same effect, and such calls will be detected when you 'check for slips' in a change sorter.There is obviously scope for a more sophisticated print-directly-to-display mechanism that keeps track of where the last such call printed, and moves down a line, etc." !!Object methodsFor: 'converting' stamp: 'sw 3/26/2001 12:12'!printDirectlyToDisplay	"For debugging: write the receiver's printString directly to the display at (0, 100); senders of this are detected by the check-for-slips mechanism."	self asString displayAt: 0@100"StringMorph someInstance printDirectlyToDisplay"! !!CompiledMethod methodsFor: 'testing' stamp: 'sw 3/26/2001 12:45'!hasReportableSlip	"Answer whether the receiver contains anything that should be brought to the attention of the author when filing out.   Customize the lists here to suit your preferences.  If slips do not get reported in spite of your best efforts here, make certain that the Preference 'checkForSlips' is set to true."	| assoc | 	#(doOnlyOnce: halt halt: hottest printDirectlyToDisplay personal urgent) do:		[:aLit | (self hasLiteral: aLit) ifTrue: [^ true]].	#(Transcript AA BB CC DD EE) do:		[:aSymbol | (assoc _ (Smalltalk associationAt: aSymbol ifAbsent: [nil])) ifNotNil:			[(self hasLiteral: assoc) ifTrue: [^ true]]].	^ false! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'sw 3/26/2001 12:04'!mouseMove: event	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| index oldIndex oldVal aMorph |	event position y < self top		ifTrue:			[scrollBar scrollUp: 1.			aMorph _ self itemFromPoint: scroller topLeft + (1@1)]		ifFalse:			[event position y > self bottom				ifTrue:					[scrollBar scrollDown: 1.					aMorph _ self itemFromPoint: scroller bottomLeft + (1@-1)]				ifFalse:					[aMorph _ self itemFromPoint: event position]].	aMorph ifNil: [^ super mouseDown: event].	model okToChange ifFalse: [^ self].  "No change if model is locked"	index _ scroller submorphs indexOf: aMorph.	index = 0 ifTrue: [^ self  "minimize chance of selecting with a pane border drag"].	"Set meaning for subsequent dragging of selection"	oldIndex _ self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal _ model listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff		ifTrue: [self setSelectedMorph: aMorph]		ifFalse: [self setSelectedMorph: nil].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [model listSelectionAt: oldIndex put: oldVal].	model listSelectionAt: index put: dragOnOrOff.	aMorph changed! !