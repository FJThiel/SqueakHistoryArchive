'From Squeak 2.4c of May 10, 1999 on 2 September 1999 at 8:10:42 am'!Model subclass: #TelnetMachine	instanceVariableNames: 'hostname port socket outputBuffer processingCommand commandChar lastInputChar displayLines cursorX cursorY foregroundColor displayMode commandParams requestedRemoteEcho remoteEchoAgreed '	classVariableNames: 'CSSpecialChars DOChar DONTChar IAC OPTEcho WILLChar WONTChar '	poolDictionaries: ''	category: 'NetTools-Telnet'!!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 9/2/1999 08:06'!escape	"Answer the ASCII ESC character"	^self value: 27! !!TelnetMachine commentStamp: '<historical>' prior: 0!The beginnings of a telnet terminal, for telnetting to other hosts. NOTE - it should separate out the VT100 code to a separate class some time....!!TelnetMachine methodsFor: 'screen management' stamp: 'ls 9/16/1998 06:40'!addBoringStringInNormalMode: aString	"add a string with no special characters, and assuming we are already in #normal mode"	|line inPos space amt |aString do: [ :c | self displayChar: c ].true ifTrue: [ ^self ].	line _ displayLines at: cursorY.	inPos _ 1.	[ inPos <= aString size ] whileTrue: [		"copy a line's worth"		space _ 80 - cursorX + 1.		amt _ space min: (aString size - inPos + 1).		line replaceFrom: cursorX to: cursorX+amt-1 with: aString startingAt: inPos.		line addAttribute: (TextColor color: foregroundColor) from: cursorX to: cursorX+amt-1.		inPos _ inPos + amt.		"update cursor"		cursorX _ cursorX + amt.		self possiblyWrapCursor.	].! !!TelnetMachine methodsFor: 'screen management' stamp: 'ls 9/16/1998 06:41'!displayChar: c	| line |	displayMode = #sawEscape ifTrue: [ 		^self displayCharSawEscape: c ].	displayMode = #gatheringParameters ifTrue: [		^self displayCharGatheringParameters: c ].	c = Character escape ifTrue: [		displayMode _ #sawEscape.		^self ].	c = Character cr ifTrue: [		"go back to the beginning of the line"		cursorX _ 1.		^self ].	c = Character lf ifTrue: [		"go to the next line"		cursorY _ cursorY + 1.		cursorY > 25 ifTrue: [			self scrollScreenBack: 1.			cursorY _ 25 ].		^self ].	c = Character tab ifTrue: [		"move to the next tab stop"		cursorX _ cursorX + 8 // 8 * 8.		self possiblyWrapCursor.		^self ].	"default: display the character"	line _ displayLines at: cursorY.	line at: cursorX put: c.	line addAttribute: (TextColor color: foregroundColor) from: cursorX to: cursorX.			cursorX _ cursorX + 1.	self possiblyWrapCursor.! !!TelnetMachine methodsFor: 'screen management' stamp: 'ls 9/16/1998 05:04'!displayCharGatheringParameters: c	"display a character from the mode #gatheringParameters"	| colorName |	c isDigit  ifTrue: [		"add a digit to the last parameter"		commandParams at: commandParams size put:			(commandParams last * 10 + c digitValue).		^self ].	c = $; ifTrue: [		"end of a parameter; begin another one"		commandParams add: 0.		^self ].	c = $m ifTrue: [		"change display modes"		displayMode _ #normal.		commandParams do: [ :p |			p = 0 ifTrue: [				"reset"				foregroundColor _ Color white ].			(p >= 30 and: [ p <= 37 ]) ifTrue: [				"change color"				colorName _ #(gray red green yellow blue blue cyan white) at: (p - 29).				foregroundColor _ Color perform: colorName. ] ].		^self ].	"unrecognized character"	displayMode _ #normal.	^self displayChar: c! !!TelnetMachine methodsFor: 'screen management' stamp: 'ls 9/16/1998 02:30'!displayCharSawEscape: c	"display a character from the mode #sawEscape"	c = $[ ifTrue: [		commandParams _ OrderedCollection with: 0.		displayMode _ #gatheringParameters.		^self ].		displayMode _ #normal.	^self displayChar: c! !!TelnetMachine methodsFor: 'screen management' stamp: 'ls 9/16/1998 06:46'!displayString: aString	"add aString to the display"	|pos specialIdx |	pos _ 1. 	"pos steps through aString"	[ pos <= aString size ] whileTrue: [		displayMode = #normal ifTrue: [			"try to display a whole hunk of text at once"			specialIdx _ aString indexOfAnyOf: CSSpecialChars startingAt: pos ifAbsent: [ aString size + 1 ].			specialIdx > pos ifTrue: [				self addBoringStringInNormalMode: (aString copyFrom: pos to: specialIdx-1).				pos _ specialIdx. ] ].			pos <= aString size ifTrue: [				"either a special has been seen, or we're in a special mode"				self displayChar: (aString at: pos).				pos _ pos + 1. ].	].! !!TelnetMachine methodsFor: 'screen management' stamp: 'ls 9/16/1998 06:39'!possiblyWrapCursor	"if the cursor has gone past the right margin, then wrap"	cursorX > 80 ifTrue: [		cursorX _ 1.		cursorY _ cursorY + 1.		cursorY > 25 ifTrue: [			cursorY _ 25.			self scrollScreenBack: 1 ].	].! !!TelnetMachine methodsFor: 'screen management' stamp: 'ls 9/16/1998 02:10'!scrollScreenBack: numLines	"scrolls the screen up by the number of lines.  The cursor isn't moved"	numLines timesRepeat: [ displayLines removeFirst ].	numLines timesRepeat: [		displayLines addLast: (Text new: 80 withAll: Character space) ].! !!TelnetMachine methodsFor: 'sending data' stamp: 'ls 9/26/1998 10:24'!processTyping: aString	"process aString as if it were typed"	outputBuffer nextPutAll: aString asString.	remoteEchoAgreed ifFalse: [ self displayString: aString asString ].	^true! !!TelnetMachine methodsFor: 'sending data' stamp: 'ls 9/2/1999 08:09'!sendLine: aString	"send a line, along with a newline"	self processTyping: aString, String crlf.	^true! !!TelnetMachine methodsFor: 'access' stamp: 'ls 9/16/1998 02:12'!displayBuffer	"the 'screen' of the terminal"	^Text streamContents: [ :s |		displayLines do: [ :line |			s nextPutAll: line.			s cr. ] ]! !!TelnetMachine methodsFor: 'access' stamp: 'ls 9/16/1998 06:36'!displayBufferSelection	"where the selection should be in the display buffer.  It should be where the cursor is"	| pos |	pos _ cursorY * 81 + cursorX - 82.	^pos+1 to: pos! !!TelnetMachine methodsFor: 'access' stamp: 'ls 9/11/1998 04:41'!isConnected	"answer whether we are connected to a remote host"	^socket ~~ nil and: [ socket isValid and: [ socket isConnected ] ]! !!TelnetMachine methodsFor: 'access' stamp: 'ls 9/11/1998 04:46'!port: anInteger	"set which port to connect to"	port _ anInteger! !!TelnetMachine methodsFor: 'access' stamp: 'ls 9/11/1998 04:40'!remoteHost: aString	"set which host to connect to"	hostname _ aString! !!TelnetMachine methodsFor: 'IO' stamp: 'ls 9/26/1998 10:25'!connect	"connect to the name host"	| addr |	self isConnected ifTrue: [ self disconnect ].	Socket initializeNetwork.	addr _ NetNameResolver addressForName: hostname.	addr ifNil: [ self error: 'could not find address for ', hostname ].	socket _ Socket new.		socket connectTo: addr port: port.	(socket waitForConnectionUntil: Socket standardDeadline) ifFalse: [		self error: 'connection failed' ].		requestedRemoteEcho _ true.	self do: OPTEcho.! !!TelnetMachine methodsFor: 'IO' stamp: 'ls 9/11/1998 05:57'!disconnect	self isConnected ifTrue: [		Transcript show: 'disconnecting from ', hostname.		socket disconnect ].! !!TelnetMachine methodsFor: 'IO' stamp: 'ls 9/16/1998 05:20'!processIO	"should be called periodically--this actually sends and recieves some bytes over the network"	| amountSent |	self isConnected ifFalse: [ ^ self ].	outputBuffer _ outputBuffer contents.	"convert to String for convenience in the loop.  still not as optimal as it could be...."	[outputBuffer size > 0 and: [ socket sendDone ]] whileTrue: [ 		"do some output"		amountSent _ socket sendSomeData: outputBuffer.		outputBuffer _ outputBuffer copyFrom: amountSent+1 to: outputBuffer size. ].	outputBuffer _ WriteStream on: outputBuffer.	"do some input"	[socket dataAvailable] whileTrue: [		self processInput: socket getData ].! !!TelnetMachine methodsFor: 'IO' stamp: 'ls 9/11/1998 05:01'!release	self isConnected ifTrue:[ self disconnect ]! !!TelnetMachine methodsFor: 'IO' stamp: 'ls 9/11/1998 05:03'!step	self processIO! !!TelnetMachine methodsFor: 'IO' stamp: 'ls 9/2/1999 08:08'!wantsSteps	^true! !!TelnetMachine methodsFor: 'menu' stamp: 'ls 9/11/1998 04:58'!menu: aMenu shifted: shiftState	aMenu labels: 'set host nameset portconnectdisconnect' lines: #() selections: #(setHostName setPort connect disconnect).	^aMenu! !!TelnetMachine methodsFor: 'menu' stamp: 'ls 9/11/1998 05:02'!perform: aSelector orSendTo: anObject	^self perform: aSelector! !!TelnetMachine methodsFor: 'menu' stamp: 'ls 9/11/1998 05:15'!setHostName	| newHostname |	newHostname _ FillInTheBlank request: 'host to connect to' initialAnswer: hostname.	newHostname size > 0 ifTrue: [ hostname _ newHostname ].! !!TelnetMachine methodsFor: 'menu' stamp: 'ls 9/11/1998 05:15'!setPort	| portString |	portString _ port printString.	portString _ FillInTheBlank request: 'port to connect on' initialAnswer: portString.	portString _ portString withBlanksTrimmed.	portString isEmpty ifFalse: [ port _ portString asNumber asInteger ].! !!TelnetMachine methodsFor: 'private' stamp: 'ls 9/26/1998 10:17'!do: optionNo	"request that the remote side does optionNo"	self sendChar: IAC.	self sendChar: DOChar.	self sendChar: optionNo asCharacter! !!TelnetMachine methodsFor: 'private' stamp: 'ls 9/26/1998 10:17'!dont: optionNo	"demand that the remote side doesn't do optionNo"	self sendChar: IAC.	self sendChar: DONTChar.	self sendChar: optionNo asCharacter! !!TelnetMachine methodsFor: 'private' stamp: 'ls 9/2/1999 08:08'!initialize	outputBuffer _ WriteStream on: String new.	port _ 23.	processingCommand _ false.	displayLines _ (1 to: 25) asOrderedCollection collect: [ :i |		Text new: 80 withAll: Character space ].	cursorX _ 1.	cursorY _ 1.	foregroundColor _ Color white.	displayMode _ #normal.	requestedRemoteEcho _ false.	remoteEchoAgreed _ false.	hostname _ ''.! !!TelnetMachine methodsFor: 'private' stamp: 'ls 9/26/1998 10:20'!processDo: optionChar	"we don't do anything"	self wont: optionChar! !!TelnetMachine methodsFor: 'private' stamp: 'ls 9/26/1998 10:20'!processDont: char	"okay, fine by us, we won't do it..."! !!TelnetMachine methodsFor: 'private' stamp: 'ls 9/26/1998 10:19'!processInput: aString	"process input from the network"	| newDisplayText |	(processingCommand not and: [(aString indexOf: IAC) = 0]) ifTrue: [		"no commands here--display the whole string"		self displayString: aString.		self changed: #displayBuffer.		^self ].	Transcript show: 'slow.'; cr.	newDisplayText _ WriteStream on: String new.	aString do: [ :c |		processingCommand ifTrue: [			"an IAC has been seen"			commandChar				ifNil: [ 					"c is the command character.  act immediately if c=IAC, otherwise save it and wait fro the next character"					commandChar _ c.  					(commandChar = IAC) ifTrue: [ self displayChar: IAC. processingCommand _ false ] ]				ifNotNil: [					commandChar == DOChar ifTrue: [ self processDo: c. ].					commandChar == DONTChar ifTrue: [ self processDont: c ].					commandChar == WILLChar ifTrue: [ self processWill: c ].					commandChar == WONTChar ifTrue: [ self processWont: c ].					processingCommand _ false.  ] ]		ifFalse: [			"normal mode"			c = IAC ifTrue: [ processingCommand _ true.  commandChar _ nil ] ifFalse: [			  newDisplayText nextPut: c ] ] ].	self displayString: newDisplayText contents.	self changed: #displayBuffer! !!TelnetMachine methodsFor: 'private' stamp: 'ls 9/26/1998 10:23'!processWill: optionChar	optionChar == OPTEcho ifTrue: [		requestedRemoteEcho ifTrue: [			remoteEchoAgreed _ true ]		ifFalse: [			"they are offering remote echo, though we haven't asked.  Answer: oh yes."			self do: OPTEcho.			requestedRemoteEcho _ true.			remoteEchoAgreed _ true. ].	^self  ].		"they've requested an unknown option.  reject it"	self dont: optionChar.! !!TelnetMachine methodsFor: 'private' stamp: 'ls 9/26/1998 10:27'!processWont: optionChar	optionChar == OPTEcho ifTrue: [		remoteEchoAgreed _ false.		requestedRemoteEcho _ false.	^self  ].	! !!TelnetMachine methodsFor: 'private' stamp: 'ls 9/26/1998 10:26'!sendChar: char	"queue a character for sending over the network"	outputBuffer nextPut: char! !!TelnetMachine methodsFor: 'private' stamp: 'ls 9/26/1998 09:56'!will: optionNo	"request that we do optionNo"	self sendChar: IAC.	self sendChar: WILLChar.	self sendChar: optionNo asCharacter! !!TelnetMachine methodsFor: 'private' stamp: 'ls 9/26/1998 09:57'!wont: optionNo	"demand that we won't do optionNo"	self sendChar: IAC.	self sendChar: WONTChar.	self sendChar: optionNo asCharacter! !!TelnetMachine class methodsFor: 'user interface' stamp: 'ls 9/25/1998 21:00'!open	"TelnetMachine open"	| machine win displayMorph inputMorph |	Smalltalk isMorphic ifFalse: [ ^self notYetImplemented ].		machine _ self new.	win _ SystemWindow labelled: 'telnet'.	win model: machine.	displayMorph _ PluggableTextMorph on: machine text: #displayBuffer accept: nil readSelection: #displayBufferSelection menu: #menu:shifted:.		displayMorph color: Color black.	inputMorph _ PluggableTextMorph on: machine text: nil accept: #sendLine:.	inputMorph acceptOnCR: true.	win addMorph: displayMorph frame: (0@0 extent: 1@0.9).	win addMorph: inputMorph frame: (0@0.9 extent: 1@0.1).	displayMorph color: Color black.	win openInWorld.! !!TelnetMachine class methodsFor: 'instance creation' stamp: 'ls 9/11/1998 04:47'!new	^super new initialize! !!TelnetMachine class methodsFor: 'initialization' stamp: 'ls 9/26/1998 10:18'!initialize	"TelnetMachine initialize"	WILLChar _ 251 asCharacter.	WONTChar _ 252 asCharacter.	DOChar _ 253 asCharacter.	DONTChar _ 254 asCharacter.	IAC _ 255 asCharacter.	OPTEcho _ 1 asCharacter.	"set of characters that need special processing"	CSSpecialChars _ CharacterSet 		with: Character escape 		with: Character cr		with: Character lf		with: Character tab.	! !TelnetMachine initialize!