'From Squeak 2.3 of January 14, 1999 on 3 February 1999 at 8:51:05 am'!"Change Set:		XBMReadWriter2Date:			3 February 1999Author:			William CatteyDefines a reader for X-Bitmap files.Also includes Lex Spoon's interface for file: and ftp: accesses."!ImageReadWriter subclass: #XBMReadWriter	instanceVariableNames: 'width height '	classVariableNames: 'Flipbits '	poolDictionaries: ''	category: 'Graphics-Files'!!MIMEDocument class methodsFor: 'content-types' stamp: 'ls 2/1/1999 08:55'!guessTypeFromName: url	"guesses a content type from the url"	| extension |	extension _ url asString.	(extension includes: $.) ifFalse: [ ^self defaultContentType].	extension _ (extension findTokens: '.') last asLowercase.	extension = 'html' ifTrue: [ ^'text/html' ].	extension = 'htm' ifTrue:[ ^'text/html' ].	extension = 'txt' ifTrue: [ ^'text/plain' ].	extension = 'gif' ifTrue: [ ^'image/gif' ].	extension = 'jpg' ifTrue: [ ^'image/jpeg' ].	extension = 'jpeg' ifTrue: [ ^'image/jpeg' ].	extension = 'xbm' ifTrue: [ ^'image/x-xbitmap' ].	extension = 'mid' ifTrue: [ ^'audio/midi' ].	^ self defaultContentType! !!XBMReadWriter methodsFor: 'private' stamp: 'wdc 2/2/1999 15:20'!parseByteValue	"skip over separators and return next bytevalue parsed as a C language number:		0ddd is an octal digit.		0xddd is a hex digit.		ddd is decimal."	| source mybase |	stream skipSeparators.	source _ ReadWriteStream on: String new.	[stream atEnd or: [ stream peek isSeparator ]]		whileFalse: [source nextPut: self next asUppercase].	mybase _ 10. "Base 10 default"	source reset.	(source peek = $0) ifTrue: [		mybase _ 8. "Octal or Hex, say its Octal unless overridden."		source next.		(source peek = $X) ifTrue: [			mybase _ 16. "Ah.  It's Hex."			source next.			]		].	^ Integer readFrom: source base: mybase! !!XBMReadWriter methodsFor: 'private' stamp: 'di 2/1/1999 08:23'!readHeader	"Set width and height, and position stream at start of bytes"	| number setwidth setheight fieldName |	setwidth _ setheight _ false.		[((stream atEnd) or: [setwidth and: [setheight]])]		whileFalse: [	  	stream skipSeparators.		(stream nextMatchAll: '#define ') ifFalse: [^ false].		(stream skipTo: $_) ifFalse: [^ false].		fieldName _ String streamContents:			[:source |			[(stream atEnd) or: [ stream peek isSeparator ]]				whileFalse: [ source nextPut: stream next]].	  	(fieldName = 'width') ifTrue: [			stream skipSeparators.			number _ Integer readFrom: stream.			(number > 0) ifTrue: [setwidth _true].	  		width _ number.].		(fieldName = 'height') ifTrue: [			stream skipSeparators.			number _ Integer readFrom: stream.			(number > 0) ifTrue: [setheight _ true].			height _ number.			].		].	(setwidth & setheight) ifFalse: [^ false].	^ stream skipTo: ${! !!XBMReadWriter methodsFor: 'accessing' stamp: 'wdc 2/1/1999 07:15'!nextImage	"Read in the next xbm image from the stream."	| form long incount chunks byteWidth pad fourway outcount total |	stream reset.	stream ascii.	self readHeader.	form _ ColorForm extent: width@height depth: 1.	incount _ 0.	outcount _1.	chunks _ Array new: 4.	byteWidth _ width + 7 // 8.	total _ byteWidth * height.	byteWidth > 4		ifTrue: [ pad _ byteWidth \\ 4]		ifFalse: [ pad _ 4 - byteWidth ].	fourway _ 0.	[(incount = total)] whileFalse: [		incount _ incount + 1.		fourway _ fourway + 1.		chunks at: fourway put: (Flipbits at: ((self parseByteValue) +1)).		(pad > 0 and: [(incount \\ byteWidth) = 0]) ifTrue: [			1 to: pad do:				[:q |	  			fourway _ fourway + 1.				chunks at: fourway put: 0]		].		fourway = 4 ifTrue: [			long _ Integer				byte1: (chunks at: 4)				byte2: (chunks at: 3)				byte3: (chunks at: 2)				byte4: (chunks at: 1).			(form bits) at: outcount put: long.			fourway _ 0.			outcount _ outcount + 1].		].	 ^ form ! !!XBMReadWriter methodsFor: 'accessing' stamp: 'wdc 2/1/1999 06:20'!understandsImageFormat	"Test to see if the image stream format is understood by this decoder.	This should be implemented in each subclass of ImageReadWriter so that	a proper decoder can be selected without ImageReadWriter having to know about all possible image file types."	| first |	first _ (stream next: 7) asString.	^ (first = '#define')! !!XBMReadWriter class methodsFor: 'class initialization' stamp: 'wdc 2/2/1999 15:28'!initialize	"XBMReadWriter initialize"	| flippedByte |	Flipbits _ (0 to: 255) collect:     [:n |  "Compute the bit-reversal of the 8-bit value, n"     flippedByte _ 0.     0 to: 7 do:          [:i |          flippedByte _ flippedByte bitOr: ((n >> i bitAnd: 1) << (7-i))].         flippedByte]! !XBMReadWriter initialize!