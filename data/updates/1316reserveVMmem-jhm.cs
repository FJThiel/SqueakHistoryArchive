'From Squeak 2.4c of May 10, 1999 on 10 July 1999 at 8:35:57 am'!"Change Set:		reserveVMmem-jhmDate:			10 July 1999Author:			John Maloney and Andrew C. GreenbergAdds a VM parameter that allows you to specify an additional amountof memory to be reserved for use by the VM for things like plugins,file and socket buffers, etc. (This is especially useful on the Macintosh.)The memory request is recorded in the image header when the image issaved and is honored when the image is restarted.Many thanks to Andrew C. Greenberg for the original version of thisfacility."!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP localHomeContext messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache atCache lkupClass reclaimableContextCount nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals compilerInitialized compilerHooks extraVMMemory '	classVariableNames: 'ActiveProcessIndex AtCacheEntries AtCacheFixedFields AtCacheFmt AtCacheMask AtCacheOop AtCacheSize AtCacheTotalSize AtPutBase BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex CompilerHooksSize DirBadPath DirEntryFound DirNoMoreEntries ExcessSignalsIndex FirstLinkIndex HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageLookupClassIndex MessageSelectorIndex MethodArrayIndex MethodCacheClass MethodCacheEntries MethodCacheEntrySize MethodCacheMask MethodCacheMethod MethodCachePrim MethodCacheSelector MethodCacheSize MethodIndex MyListIndex NextLinkIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!Interpreter methodsFor: 'other primitives' stamp: 'jm 7/10/1999 07:35'!primitiveVMParameter	"Behaviour depends on argument count:		0 args:	return an Array of VM parameter values;		1 arg:	return the indicated VM parameter;		2 args:	set the VM indicated parameter.	VM parameters are numbered as follows:		1	end of old-space (0-based, read-only)		2	end of young-space (read-only)		3	end of memory (read-only)		4	allocationCount (read-only)		5	allocations between GCs (read-write)		6	survivor count tenuring threshold (read-write)		7	full GCs since startup (read-only)		8	total milliseconds in full GCs since startup (read-only)		9	incremental GCs since startup (read-only)		10	total milliseconds in incremental GCs since startup (read-only)		11	tenures of surving objects since startup (read-only)		12-20 specific to the translating VM		21	root table size (read-only)		22	root table overflows since startup (read-only)		23	bytes of extra memory to reserve for VM buffers, plugins, etc.	Note: Thanks to Ian Piumarta for this primitive."	| mem paramsArraySize result arg index |	mem _ self cCoerce: memory to: 'int'.	argumentCount = 0 ifTrue: [		paramsArraySize _ 23.		result _ self instantiateClass: (self splObj: ClassArray) indexableSize: paramsArraySize.		0 to: paramsArraySize - 1 do:			[:i | self storeWord: i ofObject: result withValue: (self integerObjectOf: 0)].		self storeWord: 0	ofObject: result withValue: (self integerObjectOf: youngStart - mem).		self storeWord: 1		ofObject: result withValue: (self integerObjectOf: freeBlock - mem).		self storeWord: 2	ofObject: result withValue: (self integerObjectOf: endOfMemory - mem).		self storeWord: 3	ofObject: result withValue: (self integerObjectOf: allocationCount).		self storeWord: 4	ofObject: result withValue: (self integerObjectOf: allocationsBetweenGCs).		self storeWord: 5	ofObject: result withValue: (self integerObjectOf: tenuringThreshold).		self storeWord: 6	ofObject: result withValue: (self integerObjectOf: statFullGCs).		self storeWord: 7	ofObject: result withValue: (self integerObjectOf: statFullGCMSecs).		self storeWord: 8	ofObject: result withValue: (self integerObjectOf: statIncrGCs).		self storeWord: 9	ofObject: result withValue: (self integerObjectOf: statIncrGCMSecs).		self storeWord: 10	ofObject: result withValue: (self integerObjectOf: statTenures).		self storeWord: 20	ofObject: result withValue: (self integerObjectOf: rootTableCount).		self storeWord: 21	ofObject: result withValue: (self integerObjectOf: statRootTableOverflows).		self storeWord: 22	ofObject: result withValue: (self integerObjectOf: extraVMMemory).		self pop: 1 thenPush: result.		^nil].	arg _ self stackTop.	(self isIntegerObject: arg) ifFalse: [^self primitiveFail].	arg _ self integerValueOf: arg.	argumentCount = 1 ifTrue: [	 "read VM parameter"		(arg < 1 or: [arg > 23]) ifTrue: [^self primitiveFail].		arg = 1		ifTrue: [result _ youngStart - mem].		arg = 2		ifTrue: [result _ freeBlock - mem].		arg = 3		ifTrue: [result _ endOfMemory - mem].		arg = 4		ifTrue: [result _ allocationCount].		arg = 5		ifTrue: [result _ allocationsBetweenGCs].		arg = 6		ifTrue: [result _ tenuringThreshold].		arg = 7		ifTrue: [result _ statFullGCs].		arg = 8		ifTrue: [result _ statFullGCMSecs].		arg = 9		ifTrue: [result _ statIncrGCs].		arg = 10		ifTrue: [result _ statIncrGCMSecs].		arg = 11		ifTrue: [result _ statTenures].		((arg >= 12) and: [arg <= 20]) ifTrue: [result _ 0].		arg = 21		ifTrue: [result _ rootTableCount].		arg = 22		ifTrue: [result _ statRootTableOverflows].		arg = 23		ifTrue: [result _ extraVMMemory].		self pop: 2 thenPush: (self integerObjectOf: result).		^nil].	"write a VM parameter"	argumentCount = 2 ifFalse: [^self primitiveFail].	index _ self stackValue: 1.	(self isIntegerObject: index) ifFalse: [^self primitiveFail].	index _ self integerValueOf: index.	index <= 0 ifTrue: [^self primitiveFail].	successFlag _ false.	index = 5 ifTrue: [		result _ allocationsBetweenGCs.		allocationsBetweenGCs _ arg.		successFlag _ true].	index = 6 ifTrue: [		result _ tenuringThreshold.		tenuringThreshold _ arg.		successFlag _ true].	index = 23 ifTrue: [		result _ extraVMMemory.		extraVMMemory _ arg.		successFlag _ true].	successFlag ifTrue: [		self pop: 3 thenPush: (self integerObjectOf: result).  "return old value"		^ nil].	self primitiveFail.  "attempting to write a read-only parameter"! !!Interpreter methodsFor: 'image save/restore' stamp: 'jm 7/10/1999 07:50'!readImageFromFile: f HeapSize: desiredHeapSize	"Read an image from the given file stream, allocating the given amount of memory to its object heap. Fail if the image has an unknown format or requires more than the given amount of memory."	"Details: This method detects when the image was stored on a machine with the opposite byte ordering from this machine and swaps the bytes automatically. Furthermore, it allows the header information to start 512 bytes into the file, since some file transfer programs for the Macintosh apparently prepend a Mac-specific header of this size. Note that this same 512 bytes of prefix area could also be used to store an exec command on Unix systems, allowing one to launch Smalltalk by invoking the image name as a command."	"This code is based on C code by Ian Piumarta and Smalltalk code by Tim Rowledge. Many thanks to both of you!!!!"	| swapBytes headerStart headerSize dataSize oldBaseAddr minimumMemory memStart bytesRead bytesToShift heapSize |	self var: #f declareC: 'sqImageFile f'.	swapBytes _ self checkImageVersionFrom: f.	headerStart _ (self sqImageFilePosition: f) - 4.  "record header start position"	headerSize			_ self getLongFromFile: f swap: swapBytes.	dataSize				_ self getLongFromFile: f swap: swapBytes.	oldBaseAddr			_ self getLongFromFile: f swap: swapBytes.	specialObjectsOop	_ self getLongFromFile: f swap: swapBytes.	lastHash			_ self getLongFromFile: f swap: swapBytes.	savedWindowSize	_ self getLongFromFile: f swap: swapBytes.	fullScreenFlag		_ self getLongFromFile: f swap: swapBytes.	extraVMMemory		_ self getLongFromFile: f swap: swapBytes.	lastHash = 0 ifTrue: [		"lastHash wasn't stored (e.g. by the cloner); use 999 as the seed"		lastHash _ 999].	"compare memory requirements with availability".	minimumMemory _ dataSize + 100000.  "need at least 100K of breathing room"	heapSize _ desiredHeapSize - extraVMMemory.		"decrease Squeak object heap to leave extra memory for the VM"	heapSize < minimumMemory		ifTrue: [self error: 'Insufficient memory for this image'].	"allocate a contiguous block of memory for the Squeak heap"	memory _ self cCode: '(unsigned char *) sqAllocateMemory(minimumMemory, heapSize)'.	memory = nil		ifTrue: [self error: 'Failed to allocate memory for the heap'].	memStart _ self startOfMemory.	memoryLimit _ (memStart + heapSize) - 24.  "decrease memoryLimit a tad for safety"	endOfMemory _ memStart + dataSize.	"position file after the header"	self sqImageFile: f Seek: headerStart + headerSize.	"read in the image in bulk, then swap the bytes if necessary"	bytesRead _ self cCode: 'sqImageFileRead(memory, sizeof(unsigned char), dataSize, f)'.	bytesRead ~= dataSize		ifTrue: [self error: 'Read failed or premature end of image file'].	swapBytes ifTrue: [self reverseBytesInImage].	"compute difference between old and new memory base addresses"	bytesToShift _ memStart - oldBaseAddr.	self initializeInterpreter: bytesToShift.  "adjusts all oops to new location"	^ dataSize! !!Interpreter methodsFor: 'image save/restore' stamp: 'jm 7/10/1999 07:55'!writeImageFile: imageBytes	| headerStart headerSize f bytesWritten |	self var: #f declareC: 'sqImageFile f'.	"local constants"	headerStart _ 0.  "change to 512 to leave room for a Unix exec string"	headerSize _ 64.  "header size in bytes; do not change!!"	f _ self cCode: 'sqImageFileOpen(imageName, "wb")'.	f = nil ifTrue: [		"could not open the image file for writing"		self success: false.		^ nil].	self cCode: '/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */'.	"position file to start of header"	self sqImageFile: f Seek: headerStart.	self putLong: (self imageFormatVersion) toFile: f.	self putLong: headerSize toFile: f.	self putLong: imageBytes toFile: f.	self putLong: (self startOfMemory) toFile: f.	self putLong: specialObjectsOop toFile: f.	self putLong: lastHash toFile: f.	self putLong: (self ioScreenSize) toFile: f.	self putLong: fullScreenFlag toFile: f.	self putLong: extraVMMemory toFile: f.	1 to: 7 do: [:i | self putLong: 0 toFile: f].  "fill remaining header words with zeros"	successFlag ifFalse: [		"file write or seek failure"		self cCode: 'sqImageFileClose(f)'.		^ nil].	"position file after the header"	self sqImageFile: f Seek: headerStart + headerSize.	"write the image data"	bytesWritten _ self cCode: 'sqImageFileWrite(memory, sizeof(unsigned char), imageBytes, f)'.	self success: bytesWritten = imageBytes.	self cCode: 'sqImageFileClose(f)'.	"set Mac file type and creator; this is a noop on other platforms"	self cCode: 'dir_SetMacFileTypeAndCreator(imageName, strlen(imageName), "STim", "FAST")'.! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 7/10/1999 08:10'!extraVMMemory	"Answer the current setting of the 'extraVMMemory' VM parameter. See the comment in extraVMMemory: for details."	^ Smalltalk vmParameterAt: 23! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 7/10/1999 08:26'!extraVMMemory: extraBytesToReserve	"Request that the given amount of extra memory be reserved for use by the virtual machine to leave extra C heap space available for things like plugins, network and file buffers, and so on. This request is stored when the image is saved and honored when the image is next started up. Answer the previous value of this parameter."	extraBytesToReserve < 0		ifTrue: [self error: 'VM memory reservation must be non-negative'].	^ Smalltalk vmParameterAt: 23 put: extraBytesToReserve! !