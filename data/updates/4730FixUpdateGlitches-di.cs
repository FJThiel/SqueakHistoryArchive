'From Squeak3.3alpha of 11 January 2002 [latest update: #4726] on 30 January 2002 at 9:40:12 pm'!"Change Set:		FixUpdateInteractionsDate:			30 January 2002Author:			Dan IngallsIn merging the various submissions from harvesters, I omitted several useful tweaks and reviewed decisions.  This update attempts to set them straight, with apologies to Scott Wallace for my oversights.In particular,InitLeftMargin supplants CharacterBlockScannerFix (simpler, more general)ShrinkWrapObjectsTool withdrawn intil we can find a way to avoid jerkiness.Retracted 4705 and 4707.Improved wording of Brace explanation in 4714."!!CharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 12/16/2001 18:14'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop done stopCondition |	line _ textLine.	rightMargin _ line rightMargin.	lastIndex _ line first.	self setStopConditions.		"also sets font"	characterIndex _ index.  " == nil means scanning for point"	characterPoint _ aPoint.	(characterPoint == nil or: [characterPoint y > line bottom])		ifTrue: [characterPoint _ line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex ~~ nil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	destX _ leftMargin _ line leftMarginForAlignment: alignment.	destY _ line top.	runLength _ text runLengthFor: line first.	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex  "scanning for index"]		ifFalse:	[lineStop _ line last  "scanning for point"].	runStopIndex _ lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0.	done  _ false.	[done] whileFalse:		[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth == nil			ifTrue: [font widthOf: (text at: lastIndex)]			ifFalse: [specialWidth]).		(self perform: stopCondition) ifTrue:			[characterIndex == nil				ifTrue: ["Result for characterBlockAtPoint: "						^ (CharacterBlock new stringIndex: lastIndex							text: text topLeft: characterPoint + (font descentKern @ 0)							extent: lastCharacterExtent - (font baseKern @ 0))									textLine: line]				ifFalse: ["Result for characterBlockForIndex: "						^ (CharacterBlock new stringIndex: characterIndex							text: text topLeft: characterPoint + ((font descentKern) - kern @ 0)							extent: lastCharacterExtent)									textLine: line]]]! !!ObjectsTool methodsFor: 'initialization' stamp: 'sw 8/11/2001 20:14'!initializeToStandAlone	"Initialize the receiver so that it can live as a stand-alone morph"	| aPane aBin aColor |	self basicInitialize.	self layoutInset: 6. 	self listCentering: #topLeft.	self cellPositioning: #topLeft.	self wrapCentering: #center.	self useRoundedCorners.	self listDirection: #topToBottom.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	aPane _ self paneForTabs: self modeTabs.	aPane addMorphFront: self dismissButton.	aPane addMorphBack: self helpButton.	aPane color: (aColor _ aPane color) darker.	aPane listSpacing: #equal.	aPane cellInset: 10 @ 10.	aPane listCentering: #center; height: 38.	aPane wrapDirection: nil.	self addMorphFront: aPane.	self addMorphBack: Morph new.  "Place holder for a tabs or text pane"	aBin _ PartsBin newPartsBinWithOrientation: #leftToRight from: #().	aBin listDirection: #leftToRight.	aBin wrapDirection: #topToBottom.	aBin hResizing: #spaceFill; vResizing: #spaceFill.	aBin extent: (self currentWorld width) @ 250.	aBin color: aColor lighter lighter.	aBin setNameTo: 'parts'.	aBin dropEnabled: false.	self addMorphBack: aBin.	self submorphs last width: 350; hResizing: #rigid.	self color: (Color r: 0.0 g: 0.839 b: 0.226).	self setProperty: #initialWidth toValue: 268.	self setNameTo: 'Objects'.	self showCategories.! !!ObjectsTool methodsFor: 'alphabetic' stamp: 'sw 8/12/2001 16:35'!installQuads: quads fromButton: aButton	"Install items in the bottom pane that correspond to the given set of quads, as triggered from the given button"	| aPartsBin sortedQuads |	aPartsBin _ self findDeeplyA: PartsBin.	aPartsBin removeAllMorphs.	sortedQuads _ quads asSortedCollection:		[:a :b | a third < b third].	aPartsBin listDirection: #leftToRight quadList: sortedQuads.	aPartsBin width: self innerBounds width.	aButton ifNotNil: [self tabsPane highlightOnlySubmorph: aButton]! !!ParagraphEditor methodsFor: 'explain' stamp: 'di 1/30/2002 21:09'!explainChar: string	"Does string start with a special character?"	| char |	char _ string at: 1.	char = $. ifTrue: [^'"Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float)."'].	char = $' ifTrue: [^'"The characters between two single quotes are made into an instance of class String"'].	char = $" ifTrue: [^'"Double quotes enclose a comment.  Smalltalk ignores everything between double quotes."'].	char = $# ifTrue: [^'"The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants."'].	(char = $( or: [char = $)]) ifTrue: [^'"Expressions enclosed in parenthesis are evaluated first"'].	(char = $[ or: [char = $]]) ifTrue: [^'"The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockContext and is usually passed as an argument."'].	(char = ${ or: [char = $}]) ifTrue: [^ '"A sequence of expressions separated by periods, when enclosed in curly braces, are evaluated to yield the elements of a new Array"'].	(char = $< or: [char = $>]) ifTrue: [^'"<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails."'].	char = $^ ifTrue: [^'"Uparrow means return from this method.  The value returned is the expression following the ^"'].	char = $| ifTrue: [^'"Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code."'].	char = $_ ifTrue: [^'"Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it."'].	char = $; ifTrue: [^'"Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon."'].	char = $: ifTrue: [^'"A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withCRs, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon)."'].	char = $$ ifTrue: [^'"The single character following a dollar sign is made into an instance of class Character"'].	char = $- ifTrue: [^'"A minus sign in front of a number means a negative number."'].	char = $e ifTrue: [^'"An e in the middle of a number means that the exponent follows."'].	char = $r ifTrue: [^'"An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base."'].	char = Character space ifTrue: [^'"the space Character"'].	char = Character tab ifTrue: [^'"the tab Character"'].	char = Character cr ifTrue: [^'"the carriage return Character"'].	^nil! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'sw 9/28/1999 20:42'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addLabelItemsTo: aCustomMenu hand: aHandMorph.	(target isKindOf: BookMorph)		ifTrue:			[aCustomMenu add: 'set page sound' action: #setPageSound:.			aCustomMenu add: 'set page visual' action: #setPageVisual:]		ifFalse:			[aCustomMenu add: 'change action selector' action: #setActionSelector.			aCustomMenu add: 'change arguments' action: #setArguments.			aCustomMenu add: 'change when to act' action: #setActWhen.			((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue:				[aCustomMenu add: 'set target' action: #setTarget:]].! !SimpleButtonMorph removeSelector: #addButtonCustomMenuItems:hand:!Interval removeSelector: #extent!Smalltalk removeClassNamed: #DoitButtonMorph!Smalltalk removeClassNamed: #IntervalTestCase!