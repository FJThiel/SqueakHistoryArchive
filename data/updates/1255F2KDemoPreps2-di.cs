'From Squeak 2.4c of May 10, 1999 on 21 June 1999 at 8:41:42 am'!"Change Set:		F2KDemoPreps2Date:			20 June 1999Author:			Dan IngallsPatches TransformMorph so that Piano keyboards work right at any warp.Adds ability to change time signature and enable display of measure lines in PianoRollFixed a bug with slow backward scroling of the PianoRoll.If you click near a note in the score to play all notes at that time, the sound now lingers as you hold, AND it changes if you drag horizontally.Defines KeyboardMorphForInput with duration rest and backspace controls for entering simple melodies.Makes simple note hits in the score last as long as the mouse is pressed.  Similarly while selecting.Autoscrolling is supported for both play along with the cursor, and melody selection.Defines KeyboardMorphForInput with duration rest and backspace controls for entering simple melodies.Makes simple note hits in the score last as long as the mouse is pressed.  Similarly while selecting.Autoscrolling is supported for both play along with the cursor, and melody selection.Adds a primitive facility for keying notes into a score.Makes deletions select the prior note.Adds dotted, triplet, etc duration modifiers to PianoKeyboardForInput.Fills staff lines in the absence of notes covering the range.Appending or deleting notes induces autoscrolling.Setting a new duration resets the duration modifier (dotted, etc).New 'paste...' command is like paste, but it will transpose the entire selection to bve pasted up or down by any interval up to an octave."!PianoKeyboardMorph subclass: #KeyboardMorphForInput	instanceVariableNames: 'pianoRoll duration durationModifier articulation buildingChord insertMode prevSelection startOfNextNote '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!Morph subclass: #PianoRollNoteMorph	instanceVariableNames: 'trackIndex indexInTrack hitLoc editMode selected notePlaying '	classVariableNames: 'SoundPlaying '	poolDictionaries: ''	category: 'Music-Scores'!RectangleMorph subclass: #PianoRollScoreMorph	instanceVariableNames: 'scorePlayer score colorForTrack lowestNote leftEdgeTime timeScale indexInTrack lastUpdateTick lastMutedState cursor selection timeSignature beatsPerMeasure notePerBeat showMeasureLines showBeatLines soundsPlaying soundsPlayingMorph '	classVariableNames: 'NotePasteBuffer '	poolDictionaries: ''	category: 'Music-Scores'!!MIDIScore commentStamp: 'di 6/20/1999 18:42' prior: 0!A MIDIScore is a container for a number of MIDI tracks as well as an ambient track for such things as sounds, book page triggers and other related events.!!MIDIScore reorganize!('initialization' initialize)('accessing' durationInTicks tempoMap tempoMap: ticksPerQuarterNote ticksPerQuarterNote: trackInfo trackInfo: tracks tracks:)('ambient track' addAmbientEvent: ambientEventAfter:ticks: ambientTrack removeAmbientEventWithMorph:)('playing' otherPlayersDo: pauseFrom: resetFrom: resumeFrom:)('editing' appendEvent:fullDuration:at: cutSelection: eventForTrack:after:ticks: gridToNextQuarterNote: gridToQuarterNote: gridTrack:toQuarter:at: insertEvents:at: jitterStartAndEndTimesBy:)!!MIDIScore methodsFor: 'editing' stamp: 'di 6/20/1999 00:08'!appendEvent: noteEvent fullDuration: fullDuration at: selection	"It is assumed that the noteEvent already has the proper time"	| track noteLoc |	track _ tracks at: selection first.	noteLoc _ selection third + 1.	noteEvent midiKey = -1		ifTrue: [noteLoc _ noteLoc - 1]		ifFalse: ["If not a rest..."				track _ track copyReplaceFrom: noteLoc to: noteLoc - 1								with: (Array with: noteEvent)].	track size >= (noteLoc + 1) ifTrue:		["Adjust times of following events"		noteLoc + 1 to: track size do:			[:i | (track at: i) adjustTimeBy: fullDuration]].	tracks at: selection first put: track! !!PianoKeyboardMorph reorganize!('simple keyboard' buildKeyboard initialize mouseDownEvent:noteMorph:pitch: mouseUpEvent:noteMorph:pitch: soundPrototype:)!!PianoKeyboardMorph methodsFor: 'simple keyboard' stamp: 'di 6/17/1999 21:39'!buildKeyboard	| wtWid bkWid noteR octavePt nWhite nBlack |	wtWid _ 8. bkWid _ 5.	self extent: 10@10.	1 to: nOctaves+1 do:		[:i | i <= nOctaves ifTrue: [nWhite _ 7.  nBlack _ 5]						ifFalse: [nWhite _ 1.  nBlack _ 0 "High C"].		octavePt _ self innerBounds topLeft + ((7*wtWid*(i-1)-1)@-1).		1 to: nWhite do:			[:j | 			noteR _ octavePt + (j-1*wtWid@0) extent: (wtWid+1)@36.			self addMorph: ((RectangleMorph newBounds: noteR color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(1 3 5 6 8 10 12) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)].		1 to: nBlack do:			[:j |			noteR _ octavePt + ((#(6 15 29 38 47) at: j)@1) extent: bkWid@21.			self addMorph: ((Morph newBounds: noteR color: blackKeyColor)				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(2 4 7 9 11) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)]].	self extent: (self fullBounds extent + borderWidth - 1)! !!PianoKeyboardMorph methodsFor: 'simple keyboard' stamp: 'di 6/21/1999 08:40'!initialize	super initialize.	color _ Color veryLightGray.	whiteKeyColor _ Color gray: 0.95.	blackKeyColor _ Color black.	playingKeyColor _ Color red.	nOctaves _ 6.	self buildKeyboard.	soundPrototype _ FMSound brass1 duration: 9.9! !!KeyboardMorphForInput commentStamp: 'di 6/20/1999 18:44' prior: 0!This class adds state and controls to the basic PianoKeyboardMorph so that notes of reliable duration can be keyed into a score without the need for a real keyboard.To try this out, execute...	| n score | n _ 3.	score _ (MIDIScore new tracks: ((1 to: n) collect: [:i | Array new]);		trackInfo: ((1 to: n) collect: [:i | 'Instrument' , i printString]);		tempoMap: nil; ticksPerQuarterNote: 96).	ScorePlayerMorph openOn: score title: 'empty score'Then open a pianoRoll and, from that, open a keyboard.  The rule is that the keyboard will append after the current selection.  If the current selection is muted or nil, then input will go to the end of the first non-muted track.!!KeyboardMorphForInput reorganize!('initialization' addRecordingControls initialize pianoRoll:)('note controls' articulation:onOff: backspaceNote buildChord: deleteNotes durMod:onOff: duration:onOff: emitRest fullDuration noteDuration velocity)('events' mouseDownEvent:noteMorph:pitch: mouseUpEvent:noteMorph:pitch: soundForEvent:inTrack:)!!KeyboardMorphForInput methodsFor: 'initialization' stamp: 'di 6/20/1999 12:57'!addRecordingControls	| button switch playRow durRow articRow modRow |	button _ SimpleButtonMorph new target: self;		borderColor: #raised; borderWidth: 2; color: color.	switch _ SimpleSwitchMorph new target: self;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); borderWidth: 2;		setSwitchState: false.	"Add chord, rest and delete buttons"	playRow _ AlignmentMorph newRow.	playRow color: color; borderWidth: 0; inset: 0.	playRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	playRow addMorphBack: (switch fullCopy label: 'chord'; actionSelector: #buildChord:).	playRow addMorphBack: (button fullCopy label: '          rest          '; actionSelector: #emitRest).	playRow addMorphBack: (button fullCopy label: 'del'; actionSelector: #deleteNotes).	self addMorph: playRow.	playRow align: playRow bounds topCenter			with: self bounds bottomCenter.	"Add note duration buttons"	durRow _ AlignmentMorph newRow.	durRow color: color; borderWidth: 0; inset: 0.	durRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	durRow addMorphBack: (switch fullCopy label: 'whole';				actionSelector: #duration:onOff:; arguments: #(1)).	durRow addMorphBack: (switch fullCopy label: 'half';				actionSelector: #duration:onOff:; arguments: #(2)).	durRow addMorphBack: (switch fullCopy label: 'quarter';				actionSelector: #duration:onOff:; arguments: #(4)).	durRow addMorphBack: (switch fullCopy label: 'eighth';				actionSelector: #duration:onOff:; arguments: #(8)).	durRow addMorphBack: (switch fullCopy label: 'sixteenth';				actionSelector: #duration:onOff:; arguments: #(16)).	self addMorph: durRow.	durRow align: durRow bounds topCenter			with: playRow bounds bottomCenter.	"Add note duration modifier buttons"	modRow _ AlignmentMorph newRow.	modRow color: color; borderWidth: 0; inset: 0.	modRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	modRow addMorphBack: (switch fullCopy label: 'dotted';				actionSelector: #durMod:onOff:; arguments: #(dotted)).	modRow addMorphBack: (switch fullCopy label: 'normal';				actionSelector: #durMod:onOff:; arguments: #(normal)).	modRow addMorphBack: (switch fullCopy label: 'triplets';				actionSelector: #durMod:onOff:; arguments: #(triplets)).	modRow addMorphBack: (switch fullCopy label: 'quints';				actionSelector: #durMod:onOff:; arguments: #(quints)).	self addMorph: modRow.	modRow align: modRow bounds topCenter			with: durRow bounds bottomCenter.	"Add articulation buttons"	articRow _ AlignmentMorph newRow.	articRow color: color; borderWidth: 0; inset: 0.	articRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	articRow addMorphBack: (switch fullCopy label: 'legato';				actionSelector: #articulation:onOff:; arguments: #(legato)).	articRow addMorphBack: (switch fullCopy label: 'normal';				actionSelector: #articulation:onOff:; arguments: #(normal)).	articRow addMorphBack: (switch fullCopy label: 'staccato';				actionSelector: #articulation:onOff:; arguments: #(staccato)).	self addMorph: articRow.	articRow align: articRow bounds topCenter			with: modRow bounds bottomCenter.	self bounds: (self fullBounds expandBy: (0@0 extent: 0@borderWidth))! !!KeyboardMorphForInput methodsFor: 'initialization' stamp: 'di 6/20/1999 12:54'!initialize	super initialize.	buildingChord _ false.	self addRecordingControls.	self duration: 4 onOff: true.	self durMod: #normal onOff: true.	self articulation: #normal onOff: true.	insertMode _ false! !!KeyboardMorphForInput methodsFor: 'initialization' stamp: 'di 6/18/1999 15:52'!pianoRoll: prMorph	pianoRoll _ prMorph! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/19/1999 23:37'!articulation: artic onOff: ignored    "artic = eg, #legato, #normal, #staccato."	"Set the articulation of notes to be emitted when a key is pressed."	self allMorphsDo:		[:m | ((m isMemberOf: SimpleSwitchMorph)				and: [m actionSelector == #articulation:onOff:])				ifTrue: [m setSwitchState: m arguments first == artic]].	articulation _ artic! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 00:20'!backspaceNote	self deleteNotes! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/18/1999 15:50'!buildChord: onOff! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 00:20'!deleteNotes	pianoRoll deleteSelection! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 12:55'!durMod: durMod onOff: ignored    "durMod = eg, #dotted, #normal, #triplets, #quints"	"Set the duration of notes to be emitted when a key is pressed."	self allMorphsDo:		[:m | ((m isMemberOf: SimpleSwitchMorph)				and: [m actionSelector == #durMod:onOff:])				ifTrue: [m setSwitchState: m arguments first = durMod]].	durationModifier _ durMod! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 18:31'!duration: denom onOff: ignored    "denom = eg, 1, 2, 4, 8, 16"	"Set the duration of notes to be emitted when a key is pressed."	self allMorphsDo:		[:m | ((m isMemberOf: SimpleSwitchMorph)				and: [m actionSelector == #duration:onOff:])				ifTrue: [m setSwitchState: m arguments first = denom]].	duration _ denom.	self durMod: #normal onOff: true! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 00:01'!emitRest	| sel noteEvent |	"All this selection logic should be shared with mouseDown..."	(sel _ pianoRoll selection) ifNil: [^ self].	insertMode ifTrue:		[sel _ pianoRoll selectionForInsertion.		insertMode _ false].	sel = prevSelection ifFalse:		["This is a new selection -- need to determine start time"		sel third = 0			ifTrue: [startOfNextNote _ 0]			ifFalse: [startOfNextNote _ ((pianoRoll score tracks at: sel first)										at: sel third) endTime.					startOfNextNote _ startOfNextNote + self fullDuration - 1										truncateTo: self fullDuration]].	noteEvent _ NoteEvent new time: startOfNextNote; duration: self noteDuration;			key: -1 "my flag for rest" velocity: self velocity channel: 1.	pianoRoll appendEvent: noteEvent fullDuration: self fullDuration.	soundPlaying ifNotNil: [soundPlaying stopGracefully].	prevSelection _ pianoRoll selection.	startOfNextNote _ startOfNextNote + self fullDuration.! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 13:03'!fullDuration	| num denom |	num _ denom _ 1.	durationModifier == #dotted ifTrue: [num _ 3.  denom _ 2].	durationModifier == #triplets ifTrue: [num _ 2.  denom _ 3].	durationModifier == #quints ifTrue: [num _ 2.  denom _ 5].	^ pianoRoll score ticksPerQuarterNote * 4 * num // duration // denom! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 00:27'!noteDuration	articulation == #staccato ifTrue: [^ (self fullDuration * 0.65) asInteger].	articulation == #normal ifTrue: [^ (self fullDuration * 0.8) asInteger].	articulation == #legato ifTrue: [^ (self fullDuration * 0.95) asInteger].! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/19/1999 23:13'!velocity	^ 80  "Later put a slider on the keyboard control"! !!KeyboardMorphForInput methodsFor: 'events' stamp: 'di 6/19/1999 23:52'!mouseDownEvent: event noteMorph: keyMorph pitch: midiKey	| sel noteEvent |	event hand hasSubmorphs ifTrue: [^ self  "no response if drag something over me"].	keyMorph color: playingKeyColor.	(sel _ pianoRoll selection) ifNil: [^ self].	insertMode ifTrue:		[sel _ pianoRoll selectionForInsertion.		insertMode _ false].	sel = prevSelection ifFalse:		["This is a new selection -- need to determine start time"		sel third = 0			ifTrue: [startOfNextNote _ 0]			ifFalse: [startOfNextNote _ ((pianoRoll score tracks at: sel first)										at: sel third) endTime.					startOfNextNote _ startOfNextNote + self fullDuration - 1										truncateTo: self fullDuration]].	noteEvent _ NoteEvent new time: startOfNextNote; duration: self noteDuration;			key: midiKey + 23 velocity: self velocity channel: 1.	pianoRoll appendEvent: noteEvent fullDuration: self fullDuration.	soundPlaying ifNotNil: [soundPlaying stopGracefully].	(soundPlaying _ self soundForEvent: noteEvent inTrack: sel first) play.	prevSelection _ pianoRoll selection.	startOfNextNote _ startOfNextNote + self fullDuration.! !!KeyboardMorphForInput methodsFor: 'events' stamp: 'di 6/20/1999 15:28'!mouseUpEvent: event noteMorph: noteMorph pitch: pitch	noteMorph color: ((#(0 1 3 5 6 8 10) includes: pitch\\12)					ifTrue: [whiteKeyColor]					ifFalse: [blackKeyColor]).! !!KeyboardMorphForInput methodsFor: 'events' stamp: 'di 6/20/1999 15:53'!soundForEvent: noteEvent inTrack: trackIndex	| sound player |	player _ pianoRoll scorePlayer.	sound _ MixedSound new.	sound add: ((player instrumentForTrack: trackIndex)					soundForMidiKey: noteEvent midiKey					dur: noteEvent duration / (pianoRoll scorePlayer ticksForMSecs: 1000)					loudness: (noteEvent velocity asFloat / 127.0))			pan: (player panForTrack: trackIndex)			volume: player overallVolume *						(player volumeForTrack: trackIndex).	^ sound! !!PianoRollNoteMorph commentStamp: '<historical>' prior: 0!A PianoRollNoteMorph is drawn as a simple mroph, but it carries the necessary state to locate its source sound event via its owner (a PianorRollScoreMorph) and the score therein.  Simple editing of pitch and time placement is provided here.!!PianoRollNoteMorph reorganize!('initialization' trackIndex:indexInTrack:)('accessing' indexInTrack trackIndex)('drawing' drawOn:)('geometry' fullBounds)('event handling' handlesMouseDown: mouseDown: mouseMove: mouseUp:)('note playing' noteInScore noteOfDuration: playSound playSound: soundOfDuration:)('menu' invokeNoteMenu:)('selecting' deselect select selectFrom: selectNotes: selected)('editing' editPitch: gridToNextQuarter gridToPrevQuarter)!!PianoRollNoteMorph methodsFor: 'event handling' stamp: 'di 6/19/1999 10:26'!mouseDown: evt	hitLoc _ evt cursorPoint.	editMode _ nil.	owner submorphsDo:		[:m | (m isKindOf: PianoRollNoteMorph) ifTrue: [m deselect]].	selected _ true.	self changed.	owner selection: (Array with: trackIndex with: indexInTrack with: indexInTrack).	self playSound! !!PianoRollNoteMorph methodsFor: 'event handling' stamp: 'di 6/20/1999 12:37'!mouseMove: evt	| delta offsetEvt |	editMode == nil ifTrue:		["First movement determines edit mode"		((delta _ evt cursorPoint - hitLoc) dist: 0@0) <= 2 ifTrue:			[^ self  "No significant movement yet."].		delta x abs > delta y abs			ifTrue: [delta x > 0  "Horizontal drag"						ifTrue: [editMode _ #selectNotes]						ifFalse: [self playSound: nil.								offsetEvt _ evt copy setCursorPoint: evt cursorPoint + (20@0).								self invokeNoteMenu: offsetEvt]]			ifFalse: [editMode _ #editPitch  "Vertical drag"]].	editMode == #editPitch ifTrue: [self editPitch: evt].	editMode == #selectNotes ifTrue: [self selectNotes: evt].! !!PianoRollNoteMorph methodsFor: 'event handling' stamp: 'di 6/19/1999 08:29'!mouseUp: evt	self playSound: nil! !!PianoRollNoteMorph methodsFor: 'note playing' stamp: 'di 6/19/1999 08:19'!playSound	"This STARTS a single long sound.  It must be stopped by playing another or nil."	^ self playSound: (self soundOfDuration: 999.0)! !!PianoRollNoteMorph methodsFor: 'note playing' stamp: 'di 6/19/1999 08:13'!playSound: aSoundOrNil	SoundPlaying ifNotNil: [SoundPlaying stopGracefully].	SoundPlaying _ aSoundOrNil.	SoundPlaying ifNotNil: [SoundPlaying play].! !!PianoRollNoteMorph methodsFor: 'note playing' stamp: 'di 6/19/1999 08:03'!soundOfDuration: duration	| sound |	sound _ MixedSound new.	sound add: (self noteOfDuration: duration)		pan: (owner scorePlayer panForTrack: trackIndex)		volume: owner scorePlayer overallVolume *				(owner scorePlayer volumeForTrack: trackIndex).	^ sound! !!PianoRollNoteMorph methodsFor: 'menu' stamp: 'di 6/20/1999 13:22'!invokeNoteMenu: evt	"Invoke the note's edit menu."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addList:		#(('grid to next quarter'		gridToNextQuarter)		('grid to prev quarter'		gridToPrevQuarter)).	evt hand invokeMenu: menu event: evt.! !!PianoRollNoteMorph methodsFor: 'selecting' stamp: 'di 6/19/1999 10:24'!selectNotes: evt	| lastMorph oldEnd saveOwner |	saveOwner _ owner.	(owner autoScrollForX: evt cursorPoint x) ifTrue:		["If scroll talkes place I will be deleted and my x-pos will become invalid."		owner _ saveOwner.		bounds _ bounds withLeft: (owner xForTime: self noteInScore time)].	oldEnd _ owner selection last.	(owner notesInRect: (evt cursorPoint x @ owner top corner: owner bottomRight))		do: [:m | m trackIndex = trackIndex ifTrue: [m deselect]].	self select.  lastMorph _ self.	(owner notesInRect: (self left @ owner top corner: evt cursorPoint x @ owner bottom))		do: [:m | m trackIndex = trackIndex ifTrue: [m select.  lastMorph _ m]].	owner selection: (Array with: trackIndex with: indexInTrack with: lastMorph indexInTrack).	lastMorph indexInTrack ~= oldEnd ifTrue:		["Play last note as selection grows or shrinks"		owner ifNotNil: [lastMorph playSound]]! !!PianoRollNoteMorph methodsFor: 'selecting' stamp: 'di 6/20/1999 11:44'!selected	^ selected! !!PianoRollNoteMorph methodsFor: 'editing' stamp: 'di 6/19/1999 08:14'!editPitch: evt	| mk note |	mk _ owner midiKeyForY: evt cursorPoint y.	note _ (owner score tracks at: trackIndex) at: indexInTrack.	note midiKey = mk ifTrue: [^ self].	note midiKey: mk.	self playSound: (self soundOfDuration: 999.0).	self position: self position x @ ((owner yForMidiKey: mk) - 1)! !!PianoRollScoreMorph commentStamp: '<historical>' prior: 0!A PianoRollScoreMorph displays a score such as a MIDIScore, and will scroll through it tracking the porgress of a ScorePlayerMorph (from which it is usually spawned).timeScale is in pixels per score tick.Currently the ambient track (for synchronizing thumbnails, eg) is treated specially here and in the score.  This should be cleaned up by adding a trackType or something like it in the score.!!PianoRollScoreMorph reorganize!('initialization' initialize on: updateLowestNote)('accessing' beatsPerMeasure: notePerBeat: score scorePlayer selection selection: timeSignature:over:)('drawing' canvasForSubmorphs: drawMeasureLinesOn: drawOn: drawStaffOn: isBlackKey: rebuildFromScore)('geometry' contractTime expandTime extent: fullBounds layoutChanged midiKeyForY: timeForX: xForTime: yForMidiKey:)('submorphs-add/remove' addNotes privateRemoveMorph:)('event handling' handlesMouseDown: mouseDown: mouseMove: mouseUp:)('dropping/grabbing' acceptDroppingMorph:event:)('menu' addCustomMenuItems:hand: addKeyboard beatLinesOnOff invokeScoreMenu: measureLinesOnOff)('editing' appendEvent:fullDuration: copySelection cutSelection deleteSelection insertSelection insertTransposed)('scrolling' autoScrollForX: goToTime: moveCursorToTime: notesInRect:)('stepping' step stepTime)!!PianoRollScoreMorph methodsFor: 'initialization' stamp: 'di 6/20/1999 16:20'!initialize	super initialize.	borderWidth _ 1.	color _ Color white.	self extent: 400@300.	showMeasureLines _ true.	showBeatLines _ false.	self timeSignature: 4 over: 4.! !!PianoRollScoreMorph methodsFor: 'initialization' stamp: 'di 6/20/1999 00:53'!on: aScorePlayer	scorePlayer _ aScorePlayer.	score _ aScorePlayer score.	colorForTrack _ Color wheel: score tracks size.	leftEdgeTime _ 0.	timeScale _ 0.1.	indexInTrack _ Array new: score tracks size withAll: 1.	lastUpdateTick _ -1.	self updateLowestNote! !!PianoRollScoreMorph methodsFor: 'initialization' stamp: 'di 6/20/1999 12:25'!updateLowestNote	"find the actual lowest note in the score"	| n |	lowestNote _ 128 - (self innerBounds height // 3).	score tracks do: [:track |		1 to: track size do: [:i |			n _ track at: i.			(n isNoteEvent and: [n midiKey < lowestNote])				ifTrue: [lowestNote _ n midiKey - 4]]].! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 6/20/1999 16:25'!beatsPerMeasure: n	^ self timeSignature: n over: notePerBeat! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 6/20/1999 16:25'!notePerBeat: n	^ self timeSignature: beatsPerMeasure over: n! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 6/20/1999 01:00'!selection	"Returns an array of 3 elements:		trackIndex		indexInTrack of first note		indexInTrack of last note"	| trackIndex track |	selection ifNil:  "If no selection, return last event of 1st non-muted track (or nil)"		[trackIndex _ (1 to: score tracks size)			detect: [:i | (scorePlayer mutedForTrack: i) not] ifNone: [^ nil].		track _ score tracks at: trackIndex.		^ Array with: trackIndex with: track size with: track size].	(scorePlayer mutedForTrack: selection first)		ifTrue: [selection _ nil.  ^ self selection].	^ selection! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 6/20/1999 20:48'!timeSignature: num over: denom	beatsPerMeasure _ num.	notePerBeat _ denom.  "a number like 2, 4, 8"	self changed! !!PianoRollScoreMorph methodsFor: 'drawing' stamp: 'di 6/20/1999 16:35'!drawMeasureLinesOn: aCanvas	| ticksPerMeas x measureLineColor inner |	showBeatLines ifNil: [showBeatLines _ false].	showMeasureLines ifNil: [showMeasureLines _ true].	notePerBeat ifNil: [self timeSignature: 4 over: 4].	showBeatLines ifTrue:		[measureLineColor _ Color gray: 0.8.		ticksPerMeas _ score ticksPerQuarterNote.		inner _ self innerBounds.		(leftEdgeTime + ticksPerMeas truncateTo: ticksPerMeas)			to: ((self timeForX: self right - borderWidth) truncateTo: ticksPerMeas)			by: ticksPerMeas			do: [:tickTime | x _ self xForTime: tickTime.				aCanvas fillRectangle: (x @ inner top extent: 1 @ inner height)						color: measureLineColor]].	showMeasureLines ifTrue:		[measureLineColor _ Color gray: 0.7.		ticksPerMeas _ beatsPerMeasure*score ticksPerQuarterNote*4//notePerBeat.		inner _ self innerBounds.		(leftEdgeTime + ticksPerMeas truncateTo: ticksPerMeas)			to: ((self timeForX: self right - borderWidth) truncateTo: ticksPerMeas)			by: ticksPerMeas			do: [:tickTime | x _ self xForTime: tickTime.				aCanvas fillRectangle: (x @ inner top extent: 1 @ inner height)						color: measureLineColor]].! !!PianoRollScoreMorph methodsFor: 'drawing' stamp: 'di 6/20/1999 12:24'!drawStaffOn: aCanvas	| blackKeyColor l r topEdge y |	self drawMeasureLinesOn: aCanvas.	blackKeyColor _ Color gray: 0.5.	l _ self left + borderWidth.	r _ self right - borderWidth.	topEdge _ self top + borderWidth + 3.	lowestNote to: 127 do: [:k |		y _ self yForMidiKey: k.		y <= topEdge ifTrue: [^ self].  "over the top!!"		(self isBlackKey: k) ifTrue: [			aCanvas				fillRectangle: (l@y corner: r@(y + 1))				color: blackKeyColor]].! !!PianoRollScoreMorph methodsFor: 'drawing' stamp: 'di 6/20/1999 12:23'!rebuildFromScore	"Rebuild my submorphs from the score. This method should be invoked after changing the time scale, the color or visibility of a track, the extent of this morph, etc."	score ifNil: [^ self].	self addNotes.! !!PianoRollScoreMorph methodsFor: 'geometry' stamp: 'di 6/20/1999 15:25'!extent: aPoint	"Force rebuild when re-sized."	super extent: aPoint. 	score ifNotNil: [self updateLowestNote].	self rebuildFromScore.! !!PianoRollScoreMorph methodsFor: 'event handling' stamp: 'di 6/19/1999 09:02'!mouseDown: evt	| noteMorphs chordRect sound |	(self notesInRect: ((evt cursorPoint extent: 1@0) expandBy: 2@30)) isEmpty		ifTrue: ["If not near a note, then put up score edit menu"				^ self invokeScoreMenu: evt].	"Clicked near (but not on) a note, so play all notes at the cursor time"	noteMorphs _ self notesInRect: ((evt cursorPoint extent: 1@0) expandBy: 0@self height).	chordRect _ (self innerBounds withLeft: evt cursorPoint x) withWidth: 1.	soundsPlayingMorph _ Morph newBounds: chordRect color: Color green.	self addMorphBack: soundsPlayingMorph.		soundsPlaying _ IdentityDictionary new.	noteMorphs do:		[:m | sound _ m soundOfDuration: 999.0.		soundsPlaying at: m put: sound.		sound play].! !!PianoRollScoreMorph methodsFor: 'event handling' stamp: 'di 6/19/1999 09:02'!mouseMove: evt	| noteMorphs chordRect sound |	soundsPlaying ifNil: [^ self].	self autoScrollForX: evt cursorPoint x.	"Play all notes at the cursor time"	noteMorphs _ self notesInRect: ((evt cursorPoint extent: 1@0) expandBy: 0@self height).	chordRect _ (self innerBounds withLeft: evt cursorPoint x) withWidth: 1.	soundsPlayingMorph delete.	soundsPlayingMorph _ Morph newBounds: chordRect color: Color green.	self addMorphBack: soundsPlayingMorph.		noteMorphs do:		[:m |  "Add any new sounds"		(soundsPlaying includesKey: m)			ifFalse: [sound _ m soundOfDuration: 999.0.					soundsPlaying at: m put: sound.					sound play]].	soundsPlaying keys do:		[:m |  "Remove any sounds no longer in selection."		(noteMorphs includes: m)			ifFalse: [(soundsPlaying at: m) stopGracefully.					soundsPlaying removeKey: m]].! !!PianoRollScoreMorph methodsFor: 'event handling' stamp: 'di 6/18/1999 08:37'!mouseUp: evt	soundsPlayingMorph ifNotNil: [soundsPlayingMorph delete].	soundsPlaying ifNotNil: [soundsPlaying do: [:s | s stopGracefully]].	soundsPlayingMorph _ soundsPlaying _ nil! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'di 6/18/1999 15:55'!addKeyboard	(KeyboardMorphForInput new pianoRoll: self) openInWorld! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'di 6/18/1999 16:04'!beatLinesOnOff	showBeatLines _ showBeatLines not.	self changed! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'di 6/20/1999 23:34'!invokeScoreMenu: evt	"Invoke the score's edit menu."	| menu subMenu |	menu _ MenuMorph new defaultTarget: self.	menu addList:		#(('cut'		cutSelection)		('copy'		copySelection)		('paste'		insertSelection)		('paste...'	insertTransposed)).	menu addLine.	menu addList:		#(('legato'		selectionBeLegato)		('staccato'		selectionBeStaccato)		('normal'		selectionBeNormal)).	menu addLine.	menu addList:		#(('expand time'		expandTime)		('contract time'		contractTime)).	menu addLine.	subMenu _ MenuMorph new defaultTarget: self.		(2 to: 12) do: [:i | subMenu add: i printString selector: #beatsPerMeasure: argument: i].		menu add: 'time   ', beatsPerMeasure printString subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.		#(2 4 8) do: [:i | subMenu add: i printString selector: #notePerBeat: argument: i].		menu add: 'sig     ', notePerBeat printString subMenu: subMenu.	menu addLine.	showMeasureLines		ifTrue: [menu add: 'hide measure lines' action: #measureLinesOnOff]		ifFalse: [menu add: 'show measure lines' action: #measureLinesOnOff].	showBeatLines		ifTrue: [menu add: 'hide beat lines' action: #beatLinesOnOff]		ifFalse: [menu add: 'show beat lines' action: #beatLinesOnOff].	menu addLine.	menu add: 'add keyboard' action: #addKeyboard.	evt hand invokeMenu: menu event: evt.! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'di 6/17/1999 22:10'!measureLinesOnOff	showMeasureLines _ showMeasureLines not.	self changed! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'di 6/20/1999 23:16'!appendEvent: noteEvent fullDuration: fullDuration 	| sel x |	score appendEvent: noteEvent fullDuration: fullDuration at: (sel _ self selection).	noteEvent midiKey = -1 ifFalse:  "Unless it is a rest..."		["Advance the selection to the note just entered"		selection _ Array with: sel first with: sel third + 1 with: sel third + 1].	"This is all horribly inefficient..."	scorePlayer updateDuration.	(x _ self xForTime: noteEvent endTime) > (self right - 30) ifTrue:		[self autoScrollForX: x + (30 + self width // 4)].	self updateLowestNote.	self rebuildFromScore! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'di 6/20/1999 00:25'!cutSelection	selection == nil ifTrue: [^ self].	self copySelection.	self deleteSelection! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'di 6/20/1999 23:15'!deleteSelection	| selMorphs priorEvent x |	(selection == nil or: [selection second = 0]) ifTrue: [^ self].	score cutSelection: selection.	selection second > 1		ifTrue: [selection at: 2 put: selection second - 1.				selection at: 3 put: selection second.				priorEvent _ (score tracks at: selection first) at: selection second.				(x _ self xForTime: priorEvent time) < (self left + 30) ifTrue:					[self autoScrollForX: x - (30 + self width // 4)]]		ifFalse: [selection _ nil].	scorePlayer updateDuration.	self rebuildFromScore.	selMorphs _ self submorphsSatisfying:						[:m | (m isKindOf: PianoRollNoteMorph) and: [m selected]].	selMorphs isEmpty ifFalse: [(selMorphs last noteOfDuration: 0.3) play]! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'di 6/20/1999 00:47'!insertSelection	selection == nil ifTrue: [^ self].	score insertEvents: NotePasteBuffer at: self selection.	scorePlayer updateDuration.	self rebuildFromScore! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'di 6/20/1999 23:37'!insertTransposed	| delta transposedNotes |	(delta _ (SelectionMenu selections: ((12 to: -12 by: -1) collect: [:i | i printString]))			startUpWithCaption: 'offset...') ifNil: [^ self].	transposedNotes _ NotePasteBuffer collect: [:note | note copy midiKey: note midiKey + delta].	selection == nil ifTrue: [^ self].	score insertEvents: transposedNotes at: self selection.	scorePlayer updateDuration.	self rebuildFromScore! !!PianoRollScoreMorph methodsFor: 'scrolling' stamp: 'di 6/19/1999 10:56'!autoScrollForX: x	"Scroll by the amount x lies outside of my innerBounds.  Return true if this happens."	| d ticks |	((d _ x - self innerBounds right) > 0		or: [(d _ x - self innerBounds left) < 0])		ifTrue: [ticks _ (self timeForX: self bounds center x + d+1)						min: score durationInTicks max: 0.				self moveCursorToTime: ticks.				scorePlayer ticksSinceStart: ticks.				^ true].	^ false! !!PianoRollScoreMorph methodsFor: 'scrolling' stamp: 'di 6/19/1999 09:30'!goToTime: scoreTime	| track trackSize index newLeftEdgeTime |	newLeftEdgeTime _ scoreTime asInteger.	newLeftEdgeTime < leftEdgeTime		ifTrue: [indexInTrack _ Array new: score tracks size+1 withAll: 1].	leftEdgeTime _ newLeftEdgeTime.	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		index _ indexInTrack at: trackIndex.		trackSize _ track size.		[(index < trackSize) and:		 [(track at: index) endTime < leftEdgeTime]]			whileTrue: [index _ index + 1].		indexInTrack at: trackIndex put: index].	self addNotes.! !!PianoRollScoreMorph methodsFor: 'scrolling' stamp: 'di 6/19/1999 09:29'!moveCursorToTime: scoreTime	| cursorOffset desiredCursorHeight |	scorePlayer isPlaying		ifTrue:			[cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger.			(cursorOffset < 0				or: [cursorOffset > (self width-20)])				ifTrue:				[self goToTime: scoreTime - (20/timeScale).				cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger]]		ifFalse:			[self goToTime: scoreTime - (self width//2 / timeScale).			cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger].	cursor position: (self left + borderWidth + cursorOffset)@(self top + borderWidth).	desiredCursorHeight _ self height.	cursor height ~= desiredCursorHeight ifTrue: [cursor extent: 1@desiredCursorHeight].! !!ScorePlayer methodsFor: 'initialization' stamp: 'di 6/20/1999 00:46'!updateDuration	durationInTicks _ score durationInTicks.! !!ScorePlayer methodsFor: 'accessing' stamp: 'di 6/20/1999 00:42'!positionInScore	^ self ticksSinceStart asFloat / (self durationInTicks max: 1)! !!ScorePlayer methodsFor: 'accessing' stamp: 'di 6/19/1999 10:45'!ticksSinceStart: newTicks	"Adjust ticks to folow, eg, piano roll autoscrolling"	self isPlaying ifFalse: [ticksSinceStart _ newTicks]! !!ScorePlayerMorph commentStamp: '<historical>' prior: 0!A ScorePlayerMorph mediates between a score such as a MIDIScore, a PianoRollScoreMorph, and the actual SoundPlayer synthesizer.It provides control over volume, tempo, instrumentation, and location in the score.!!ScorePlayerMorph reorganize!('initialization' closeMIDIPort initialize onScorePlayer:title: openMIDIFile openMIDIPort)('accessing' scorePlayer)('layout' makeControls makeMIDIController: makePianoRoll makeRow panAndVolControlsFor: rateControl scrollControl trackControlsFor: trackNumAndMuteButtonFor: volumeControl)('controls' atTrack:from:selectInstrument: rewind setLogRate:)('menu' instrumentChoicesForTrack: invokeMenu updateInstrumentsFromLibrary)('stepping' step)!!ScorePlayerMorph methodsFor: 'layout' stamp: 'di 6/19/1999 20:59'!rateControl	| rateSlider middleLine r |	rateSlider _ SimpleSliderMorph new		color: color;		extent: 180@2;		target: self;		actionSelector: #setLogRate:;		minVal: -1.0;		maxVal: 1.0;		adjustToValue: 0.0.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(rateSlider height - 4);		position: rateSlider center x@(rateSlider top + 2).	rateSlider addMorphBack: middleLine.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'slow ').	r addMorphBack: rateSlider.	r addMorphBack: (StringMorph contents: ' fast').	^ r! !!ScorePlayerMorph methodsFor: 'layout' stamp: 'di 6/19/1999 20:59'!volumeControl	| volumeSlider r |	volumeSlider _ SimpleSliderMorph new		color: color;		extent: 80@2;		target: scorePlayer;		actionSelector: #overallVolume:;		adjustToValue: scorePlayer overallVolume.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'soft  ').	r addMorphBack: volumeSlider.	r addMorphBack: (StringMorph contents: ' loud').	^ r! !!TransformMorph methodsFor: 'drawing' stamp: 'di 6/17/1999 21:35'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds, and to translate, rotate and scale as appropriate."	| sourceQuad warp innerRect patchRect subCanvas offsetCanvas start |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	transform isPureTranslation ifTrue:		[^ super fullDrawOn: aCanvas].	self drawOn: aCanvas.	self hasSubmorphs ifFalse: [^ self].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ self innerBounds.	patchRect _ transform globalBoundsToLocal:					((aCanvas clipRect expandBy: 2) intersect: innerRect).	sourceQuad _ (transform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.	warp cellSize: smoothing.  "installs a colormap if smoothing > 1"	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (aCanvas depth = 1 and: [aCanvas shadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		i=1	ifTrue: [subCanvas setShadowDrawing; stipple: Color black.					warp combinationRule: Form erase]			ifFalse: [aCanvas shadowDrawing ifTrue:					[subCanvas setShadowDrawing; stipple: aCanvas stipple].					warp combinationRule: Form paint].		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		submorphs reverseDo: [:m | m fullDrawOn: offsetCanvas].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!TransformMorph methodsFor: 'change reporting' stamp: 'di 6/17/1999 21:35'!invalidRect: damageRect	"Translate damage reports from submorphs by the scrollOffset."	owner ifNil: [^ self].	^ owner invalidRect: (((transform localBoundsToGlobal: damageRect) intersect: bounds) expandBy: 1)! !PianoKeyboardMorph removeSelector: #articulation:onOff:!PianoKeyboardMorph removeSelector: #duration:onOff:!PianoKeyboardMorph removeSelector: #addRecordingControls!PianoKeyboardMorph removeSelector: #duration:!PianoKeyboardMorph removeSelector: #backSpaceNote!PianoKeyboardMorph removeSelector: #emitRest!PianoKeyboardMorph removeSelector: #buildChord:!PianoRollNoteMorph removeSelector: #addNoteOfDuration:to:!PianoRollNoteMorph removeSelector: #playNoteOfDuration:!PianoRollNoteMorph removeSelector: #containsPoint:!PianoRollScoreMorph removeSelector: #insertTransposed:!PianoRollScoreMorph removeSelector: #showMeasureLinesOn:!PianoRollScoreMorph removeSelector: #appendEvent:!PianoRollScoreMorph removeSelector: #setTimeSig!