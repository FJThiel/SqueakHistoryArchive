'From Squeak 2.0 BETA of May 8, 1998 on 19 May 1998 at 12:41:57 pm'!!ChangeSorter methodsFor: 'class list' stamp: 'tk 5/19/1998 12:41'!currentClassName: aString	currentClassName _ aString.	currentSelector _ nil.	"fix by wod"	self changed: #currentClassName.	self changed: #messageList.	self setContents.	self changed: #contents.! !!ChangeSorter methodsFor: 'message list' stamp: 'tk 5/18/1998 10:23'!removeMessage	"Remove the selected msg from the system.  Real work done by the parent, a ChangeSorter"	| confirmation sel |	self okToChange ifFalse: [^ self].	currentSelector ifNotNil: [		confirmation _ self selectedClassOrMetaClass 			confirmRemovalOf: (sel _ self selectedMessageName).		confirmation == 3 ifTrue: [^ self].		myChangeSet removeSelectorChanges: sel 			class: self selectedClassOrMetaClass.		self selectedClassOrMetaClass removeSelector: sel.		self update.	"	self changed: #messageList.		self setContents.		self changed: #contents.	"		confirmation == 2 ifTrue:			[Smalltalk browseAllCallsOn: sel]]! !!ChangeSorter methodsFor: 'code pane' stamp: 'tk 5/18/1998 11:43'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Create an error if the category of the selected message is unknown. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	(class _ self selectedClassOrMetaClass) ifNil: [^ false].	oldSelector _ self selectedMessageName.	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector ifNil: [^ false].	(self messageList includes: selector)		ifTrue: [self currentSelector: selector]		ifFalse: [self currentSelector: oldSelector].	self update.	^ true! !!ChangeSorter methodsFor: 'code pane' stamp: 'tk 5/18/1998 14:40'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ contents _ ''].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents _ 'Added then removed (see versions)'].			class ifNil: [^ contents _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents _ 'Method was added, but cannot be found!!'].			^ contents _ (class sourceMethodAt: sel) copy]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do: [:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Entire class was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr]].			^ contents _ strm contents].! !!ClassOrganizer methodsFor: 'compiler access' stamp: 'tk 5/18/1998 11:32'!classify: element under: heading 	"Store the argument, element, in the category named heading."	| catName catIndex elemIndex realHeading |	((heading = NullCategory) or: [heading == nil])		ifTrue: [realHeading _ Default]		ifFalse: [realHeading _ heading asSymbol].	(catName _ self categoryOfElement: element) = realHeading		ifTrue: [^self].  "done if already under that category"	catName ~~ nil ifTrue: 		[realHeading = Default			ifTrue: [^self].	"return if exists and realHeading is default"		self removeElement: element].	"remove if in another category"	(categoryArray indexOf: realHeading) = 0 ifTrue: [self addCategory: realHeading].	"add realHeading if not there already"	catIndex _ categoryArray indexOf: realHeading.	elemIndex _ 		catIndex > 1			ifTrue: [categoryStops at: catIndex - 1]			ifFalse: [0].	[(elemIndex _ elemIndex + 1) <= (categoryStops at: catIndex) 		and: [element >= (elementArray at: elemIndex)]] whileTrue.	"elemIndex is now the index for inserting the element. Do the insertion before it."	elementArray _ elementArray copyReplaceFrom: elemIndex to: elemIndex-1						with: (Array with: element).	"add one to stops for this and later categories"	catIndex to: categoryArray size do: 		[:i | categoryStops at: i put: (categoryStops at: i) + 1].	(self listAtCategoryNamed: Default) size = 0 ifTrue: [self removeCategory: Default]! !!SwikiAction methodsFor: 'save and restore' stamp: 'tk 5/14/1998 18:24'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct the url map."	| map page folder dir rep templateFolder |	map _ URLmap new.	self map: map.	self name: nameOfSwiki.	templateFolder _ self class == SwikiAction ifTrue: ['swiki'] ifFalse: ['pswiki'].	self source: templateFolder,(ServerAction pathSeparator).	map action: self.	map pages: (Dictionary new).	map directory: nameOfSwiki. "This is where the pages are."	folder _ (ServerAction serverDirectory), nameOfSwiki.	dir _ FileDirectory on: folder.	dir fileNames do: [:fName |		rep _ fName detect: [:char | char isDigit not] ifNone: [$3].		rep isDigit ifTrue: ["all are digits"			page _ self class pageClass new.			page fromFileNamed: folder,(ServerAction pathSeparator),fName action: self.			map at: page name put: page]].	PWS link: nameOfSwiki to: self.! !!PSwikiAction methodsFor: 'all' stamp: 'tk 5/14/1998 18:32'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct the url map."	super restore: nameOfSwiki.	authorizer _ Authorizer new.	authorizer realm: name.! !!SwikiAction class methodsFor: 'initialization' stamp: 'tk 5/14/1998 18:22'!pageClass	"The class of my pages"	^ SwikiPage! !!PSwikiAction class methodsFor: 'initialization' stamp: 'tk 5/14/1998 18:22'!pageClass	"The class of my pages"	^ PSwikiPage! !