'From Squeak3.1alpha of 28 February 2001 [latest update: #4207] on 20 July 2001 at 2:02:17 pm'!"Change Set:		GCMsgTallyStats-arDate:			18 July 2001Author:			Andreas RaabThe change set improves reports provided by the message tally to include changes in memory usage as well as GC statistics for the profiled block. This is valuable information if the profiled block does heavy allocations in which case a large percentage of time can be spent in GC related places."!Magnitude subclass: #MessageTally	instanceVariableNames: 'class method tally receivers senders time gcStats '	classVariableNames: 'ObservedProcess Timer '	poolDictionaries: ''	category: 'Tools-Debugger'!!Integer methodsFor: 'printing' stamp: 'ar 7/18/2001 22:09'!asStringWithCommasSigned	"123456789 asStringWithCommasSigned"	"-123456789 asStringWithCommasSigned"	| digits |	digits _ self abs printString.	^ String streamContents:		[:strm | 		self sign = -1 ifTrue: [strm nextPut: $-] ifFalse:[strm nextPut: $+].		1 to: digits size do: 			[:i | strm nextPut: (digits at: i).			(i < digits size and: [(i - digits size) \\ 3 = 0])				ifTrue: [strm nextPut: $,]]]! !!MessageTally methodsFor: 'initialize-release' stamp: 'ar 7/18/2001 22:27'!spyEvery: millisecs on: aBlock 	"Create a spy and spy on the given block at the specified rate."	| myDelay value startTime time0 |	(aBlock isMemberOf: BlockContext)		ifFalse: [self error: 'spy needs a block here'].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	ObservedProcess _ Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats _ Smalltalk getVMParameters.	Timer :=		[[true] whileTrue: 			[startTime := Time millisecondClockValue.			myDelay wait.			self tally: ObservedProcess suspendedContext				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor userInterruptPriority.		"activate the probe and evaluate the block"	Timer resume.	value := aBlock value.	"Collect gc statistics"	Smalltalk getVMParameters keysAndValuesDo:		[:idx :gcVal| gcStats at: idx put: (gcVal - gcStats at: idx)].		"cancel the probe and return the value"	Timer terminate.	time := Time millisecondClockValue - time0.	^value! !!MessageTally methodsFor: 'initialize-release' stamp: 'ar 7/18/2001 22:27'!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration 	"Create a spy and spy on the given process at the specified rate."	| myDelay time0 endTime sem |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	ObservedProcess _ aProcess.	myDelay _ Delay forMilliseconds: millisecs.	time0 _ Time millisecondClockValue.	endTime _ time0 + msecDuration.	sem _ Semaphore new.	gcStats _ Smalltalk getVMParameters.	Timer _ [[| startTime | 			startTime _ Time millisecondClockValue.			myDelay wait.			self tally: ObservedProcess suspendedContext by: Time millisecondClockValue - startTime // millisecs.			startTime < endTime] whileTrue.			sem signal]				forkAt: (ObservedProcess priority + 1 min: Processor highestPriority).	"activate the probe and wait for it to finish"	sem wait.	"Collect gc statistics"	Smalltalk getVMParameters keysAndValuesDo:		[:idx :gcVal| gcStats at: idx put: (gcVal - gcStats at: idx)].	time _ Time millisecondClockValue - time0! !!MessageTally methodsFor: 'reporting' stamp: 'ar 7/18/2001 21:53'!report: strm cutoff: threshold 	tally = 0		ifTrue: [strm nextPutAll: ' - no tallies obtained']		ifFalse: 			[strm nextPutAll: ' - '; print: tally; nextPutAll: ' tallies, ', time printString, ' msec.'; cr; cr.			self fullPrintOn: strm tallyExact: false orThreshold: threshold].	self reportGCStatsOn: strm.! !!MessageTally methodsFor: 'reporting' stamp: 'ar 7/18/2001 22:12'!reportGCStatsOn: str	| oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime rootOverflows |	upTime _ time.	oldSpaceEnd			_ gcStats at: 1.	youngSpaceEnd		_ gcStats at: 2.	memoryEnd			_ gcStats at: 3.	fullGCs				_ gcStats at: 7.	fullGCTime			_ gcStats at: 8.	incrGCs				_ gcStats at: 9.	incrGCTime			_ gcStats at: 10.	tenureCount			_ gcStats at: 11.	rootOverflows		_ gcStats at: 22.	str cr.	str	nextPutAll: '**Memory**'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str cr.	str	nextPutAll: '**GCs**'; cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	incrGCs = 0 ifFalse:		[str nextPutAll:', avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.	str	nextPutAll: '	root table	';		nextPutAll: rootOverflows asStringWithCommas; nextPutAll:' overflows'.	str cr.! !