'From Squeak2.9alpha of 17 July 2000 [latest update: #2949] on 5 November 2000 at 11:40:15 am'!"Change Set:		pngFixesDate:			4 November 2000Author:			Bob Arning, Eric Arseneau- speed improvements (quite radical for large images)- bug fixes- new features (transparency and background)Not all modes have gotten the full treatment. If you have a url for a PNG image that seems slow to decode, send it to me and I will see about speeding it up.If you are interested in seeing how processing various test suites, see the class method #test1. In particular, from the menu for the BookMorph it produces, select 'sort pages'"!ImageReadWriter subclass: #PNGReadWriter	instanceVariableNames: 'chunk form width height depth bitsPerChannel colorType interlaceMethod bitsPerPixel bytesPerScanline thisScanline prevScanline rowSize palette globalDataChunk transparentPixelValue unknownChunks '	classVariableNames: 'BPP BlockHeight BlockWidth IDAT IEND IHDR PLTE '	poolDictionaries: ''	category: 'Graphics-Files'!!InflateStream methodsFor: 'accessing' stamp: 'RAA 11/5/2000 11:12'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for simplicity"	| newArray |	"try to do it the fast way"	position + anInteger < readLimit ifTrue: [		newArray _ collection copyFrom: position + 1 to: position + anInteger.		position _ position + anInteger.		^newArray	].	"oh, well..."	newArray _ collection species new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].	^newArray! !!PNGReadWriter methodsFor: 'accessing' stamp: 'RAA 11/5/2000 11:25'!nextImage	globalDataChunk _ nil.	transparentPixelValue _ nil.	unknownChunks _ Set new.	stream reset.	(stream respondsTo: #binary) ifTrue: [ stream binary] .	stream skip: 8.	[stream atEnd] whileFalse: [		self processNextChunk.	].	chunk _ globalDataChunk.	chunk ifNotNil: [self processIDATChunk].	unknownChunks isEmpty ifFalse: [		"Transcript show: ' ',unknownChunks asSortedCollection asArray printString."	].	^ form! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/4/2000 12:03'!processBackgroundChunk	| val red green blue max |	"Transcript show: '  BACKGROUND: ',chunk printString."	colorType = 3 ifTrue: [		form fillColor: (palette at: chunk first).		^self	].	max _ (2 raisedTo: bitsPerChannel) - 1.	(colorType = 0 or: [colorType = 4]) ifTrue: [		val _ chunk unsignedShortAt: 1 bigEndian: true.		form fillColor: (Color gray: val / max).		^self	].	(colorType = 2 or: [colorType = 6]) ifTrue: [		red _ chunk unsignedShortAt: 1 bigEndian: true.		green _ chunk unsignedShortAt: 3 bigEndian: true.		blue _ chunk unsignedShortAt: 5 bigEndian: true.		form fillColor: (Color r: red/max g: green/max b: blue/max).		^self	]."self halt.""====The bKGD chunk specifies a default background color to present the image against. Note that viewers are not bound to honor this chunk; a viewer can choose to use a different background. For color type 3 (indexed color), the bKGD chunk contains:    Palette index:  1 byteThe value is the palette index of the color to be used as background. For color types 0 and 4 (grayscale, with or without alpha), bKGD contains:    Gray:  2 bytes, range 0 .. (2^bitdepth)-1(For consistency, 2 bytes are used regardless of the image bit depth.) The value is the gray level to be used as background. For color types 2 and 6 (truecolor, with or without alpha), bKGD contains:    Red:   2 bytes, range 0 .. (2^bitdepth)-1   Green: 2 bytes, range 0 .. (2^bitdepth)-1   Blue:  2 bytes, range 0 .. (2^bitdepth)-1(For consistency, 2 bytes per sample are used regardless of the image bit depth.) This is the RGB color to be used as background. When present, the bKGD chunk must precede the first IDAT chunk, and must follow the PLTE chunk, if any. ==="! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/4/2000 17:00'!processIDATChunk	interlaceMethod = 0		ifTrue: [ self processNonInterlaced ]		ifFalse: [ self processInterlaced ]! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/4/2000 16:57'!processInterlaced	| z filter bytesPerPass startingCol colIncrement rowIncrementstartingRow cx sc |	startingCol _ #(0 4 0 2 0 1 0 ).	colIncrement _ #(8 8 4 4 2 2 1 ).	rowIncrement _ #(8 8 8 4 4 2 2 ).	startingRow _ #(0 0 4 0 2 0 1 ).	z _ ZLibReadStream				on: chunk				from: 1				to: chunk size.	1 to: 7 do: [:pass |		(self doPass: pass)			ifTrue:				[cx _ colIncrement at: pass.				sc _ startingCol at: pass.				bytesPerPass _ width - sc + cx - 1 // cx * bitsPerPixel + 7 // 8.				prevScanline _ ByteArray new: bytesPerPass.				(startingRow at: pass)					to: height - 1					by: (rowIncrement at: pass)					do:						[:y |						filter _ z next.						(filter isNil or: [(filter between: 0 and: 4) not])							ifTrue: [^ self].						thisScanline _ z next: bytesPerPass.						self filterScanline: filter count: bytesPerPass.						self							copyPixels: y							at: sc							by: cx.						prevScanline							replaceFrom: 1							to: bytesPerPass							with: thisScanline							startingAt: 1]]]! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/4/2000 11:43'!processNextChunk	| length asciiType |	length _ self nextLong.	asciiType _ (self next: 4) asString.	chunk _ self next: length.	"crc _" self nextLong. "TODO - validate crc"	asciiType = 'IEND' ifTrue: [^self	"*should* be the last chunk"].	asciiType = 'sBIT' ifTrue: [^self	"could indicate unusual sample depth in original"].	asciiType = 'gAMA' ifTrue: [^self 	"indicates gamma correction value"].	asciiType = 'bKGD' ifTrue: [^self processBackgroundChunk].	asciiType = 'pHYs' ifTrue: [^self processPhysicalPixelChunk].	asciiType = 'tRNS' ifTrue: [^self processTransparencyChunk].	asciiType = 'IHDR' ifTrue: [^self processIHDRChunk].	asciiType = 'PLTE' ifTrue: [^self processPLTEChunk].	asciiType = 'IDAT' ifTrue: [		"---since the compressed data can span multiple		chunks, stitch them all together first. later,		if memory is an issue, we need to figure out how		to do this on the fly---"		globalDataChunk _ globalDataChunk ifNil: [chunk] ifNotNil:			[globalDataChunk,chunk].		^self	].	unknownChunks add: asciiType.! !!PNGReadWriter methodsFor: 'chunks' stamp: 'eat 9/12/2000 14:25'!processNonInterlaced	| z filter temp |	z _ ZLibReadStream on: chunk from: 1 to: chunk size.	prevScanline _ ByteArray new: bytesPerScanline.	thisScanline := ByteArray new: bytesPerScanline.	0 to: height-1 do: [ :y |		filter _ z next.		(filter isNil or: [(filter between: 0 and: 4) not])			ifTrue: [^ self].		thisScanline _ z next: bytesPerScanline into: thisScanline startingAt: 1.		self filterScanline: filter count: bytesPerScanline.		self copyPixels: y.			"This is fatser than copying the bytes from one to the other, but not by much mind you"		temp := prevScanline.		prevScanline := thisScanline.		thisScanline := temp.		]! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/4/2000 11:13'!processPLTEChunk	| colorCount i |	colorCount _ chunk size // 3. "TODO - validate colorCount against depth"	palette _ Array new: colorCount.	0 to: colorCount-1 do: [ :index |		i _ index * 3 + 1.		palette at: index+1 put:			(Color r: (chunk at: i)/255 g: (chunk at: i+1)/255 b: (chunk at: i+2)/255)		].	(form isKindOf: ColorForm) ifTrue: [		form colors: palette	] ifFalse: [		self flag: #bob.		"palette for true color image!!!!"	].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/5/2000 11:24'!processPhysicalPixelChunk	"Transcript show: '  PHYSICAL: ',chunk printString."! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/4/2000 16:22'!processTransparencyChunk	| red green blue |	"Transcript show: '  TRANSPARENCY ',chunk printString."	colorType = 0 ifTrue: [		transparentPixelValue _ chunk unsignedShortAt: 1 bigEndian: true.		^self	].	colorType = 2 ifTrue: [		red _ chunk at: 2.		green _ chunk at: 2.		blue _ chunk at: 2.		transparentPixelValue _ 16rFF00 + red << 8 + green << 8 + blue.		^self	].	colorType = 3 ifTrue: [		chunk withIndexDo: [ :alpha :index |			palette at: index put: ((palette at: index) alpha: alpha/255)		].		^self	].! !!PNGReadWriter methodsFor: 'filtering' stamp: 'eat 9/11/2000 19:57'!filterPaeth: count	"Select one of (the pixel to the left, the pixel above and thepixel to above left) to	predict the value of this pixel"	| delta |	delta _ bitsPerPixel // 8 max: 1.	1 to: delta do: [ :i |		thisScanline at: i put:			(((thisScanline at: i) + (prevScanline at: i)) bitAnd: 255)].	delta+1 to: count do: [ :i |		thisScanline			at: i			put: (((thisScanline at: i) + (self				paethPredictLeft: (thisScanline at: i-delta)				above: (prevScanline at: i)				aboveLeft: (prevScanline at: i-delta)))					bitAnd: 255)]! !!PNGReadWriter methodsFor: 'filtering' stamp: 'eat 9/11/2000 20:08'!filterScanline: filterType count: count	self		perform: (			#(filterNone: filterHorizontal: filterVertical: filterAverage: filterPaeth:)				at: filterType+1)		with: count.! !!PNGReadWriter methodsFor: 'filtering' stamp: 'eat 9/11/2000 20:05'!paethPredictLeft: a above: b aboveLeft: c	"Predicts the value of a pixel based on nearby pixels, based onPaeth (GG II, 1991)"	| pa pb pc |	pa _ b > c ifTrue: [b - c] ifFalse: [c - b].	pb _ a > c ifTrue: [a - c] ifFalse: [c - a].	pc _ a + b - c - c.	pc < 0 ifTrue: [		pc := pc * -1].	((pa <= pb) and: [pa <= pc]) ifTrue: [^ a].	(pb <= pc) ifTrue: [^ b].	^ c! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:08'!copyPixels: y at: startX by: incX	"Handle interlaced pixels of supported colorTypes"	| s |	s _ #(copyPixelsGray:at:by: nil copyPixelsRGB:at:by: copyPixelsIndexed:at:by:		  copyPixelsGrayAlpha:at:by: nil copyPixelsRGBA:at:by:) at: colorType+1.	self perform: s asSymbol with: y with: startX with: incX! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:12'!copyPixelsGray: y 	"Handle non-interlaced grayscale color mode (colorType = 0)"	| blitter pixPerByte mask shifts pixelNumber rawByte pixel transparentIndex |	blitter _ BitBlt current bitPokerToForm: form.	transparentIndex _ form colors size.	bitsPerChannel = 16		ifTrue: [0				to: width - 1				do: [:x | blitter pixelAt: x @ y put: 255							- (thisScanline at: x << 1 + 1)].			^ self]		ifFalse: [bitsPerChannel = 8				ifTrue: [1						to: width						do: [:x | blitter								pixelAt: x - 1 @ y								put: (thisScanline at: x)].					^ self].			bitsPerChannel = 1				ifTrue: [pixPerByte _ 8.					mask _ 1.					shifts _ #(7 6 5 4 3 2 1 0 )].			bitsPerChannel = 2				ifTrue: [pixPerByte _ 4.					mask _ 3.					shifts _ #(6 4 2 0 )].			bitsPerChannel = 4				ifTrue: [pixPerByte _ 2.					mask _ 15.					shifts _ #(4 0 )].			pixelNumber _ 0.			0 to: width - 1 do: [:x | 				rawByte _ thisScanline at: pixelNumber // pixPerByte + 1.				pixel _ rawByte							>> (shifts at: pixelNumber \\ pixPerByte + 1) bitAnd: mask.				pixel = transparentPixelValue ifTrue: [pixel _ transparentIndex].				blitter pixelAt: x @ y put: pixel.				pixelNumber _ pixelNumber + 1			]		]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:09'!copyPixelsGray: y at: startX by: incX	"Handle interlaced grayscale color mode (colorType = 0)"	| b offset bits w pixel mask blitter pixelNumber pixPerByte rawByteshifts |	bitsPerChannel = 16		ifTrue: [			b _ BitBlt current bitPokerToForm: form.			startX to: width-1 by: incX do: [ :x |				b pixelAt: x@y put: 255 - (thisScanline at: (x//incX<<1)+1).				].			^ self			].	offset _ y*rowSize+1.	bits _ form bits.	bitsPerChannel = 8 ifTrue: [		startX to: width-1 by: incX do: [ :x |			w _ offset + (x>>2).			b _ 3- (x \\ 4) * 8.			pixel _ (thisScanline at: x // incX + 1)<<b.			mask _ (255<<b) bitInvert32.			bits at: w put: (((bits at: w) bitAnd: mask) bitOr: pixel)		].		^ self	].	bitsPerChannel = 1 ifTrue: [		pixPerByte _ 8.		mask _ 1.		shifts _ #(7 6 5 4 3 2 1 0).	].	bitsPerChannel = 2 ifTrue: [		pixPerByte _ 4.		mask _ 3.		shifts _ #(6 4 2 0).	].	bitsPerChannel = 4 ifTrue: [		pixPerByte _ 2.		mask _ 15.		shifts _ #(4 0).	].	blitter _ BitBlt current bitPokerToForm: form.	pixelNumber _ 0.	startX to: width-1 by: incX do: [ :x |		rawByte _ thisScanline at: (pixelNumber // pixPerByte) + 1.		pixel _ (rawByte >> (shifts at: (pixelNumber \\ pixPerByte) + 1)) bitAnd: mask.		blitter pixelAt: (x@y) put: pixel.		pixelNumber _ pixelNumber + 1.	].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:09'!copyPixelsGrayAlpha: y	"Handle non-interlaced grayscale with alpha color mode (colorType = 4)"	| i pixel gray b |	b _ BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			0 to: width-1 do: [ :x |				i _ (x << 1) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+1)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			0 to: width-1 do: [ :x |				i _ (x << 2) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+2)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:09'!copyPixelsGrayAlpha: y at: startX by: incX	"Handle interlaced grayscale with alpha color mode (colorType = 4)"	| i pixel gray b |	b _ BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			startX to: width-1 by: incX do: [ :x |				i _ (x // incX << 1) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+1)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			startX to: width-1 by: incX do: [ :x |				i _ (x // incX << 2) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+2)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:10'!copyPixelsIndexed: y	"Handle non-interlaced indexed color mode (colorType = 3)"	| blitter pixPerByte mask shifts pixelNumber rawByte pixel |	blitter _ BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue:			[1 to: width do: [:x | blitter pixelAt: x - 1 @ y put: (thisScanline at: x)].			^ self].	bitsPerChannel = 1		ifTrue:			[pixPerByte _ 8.			mask _ 1.			shifts _ #(7 6 5 4 3 2 1 0 )].	bitsPerChannel = 2		ifTrue:			[pixPerByte _ 4.			mask _ 3.			shifts _ #(6 4 2 0 )].	bitsPerChannel = 4		ifTrue:			[pixPerByte _ 2.			mask _ 15.			shifts _ #(4 0 )].	pixelNumber _ 0.	0 to: width - 1 do:		[:x |		rawByte _ thisScanline at: pixelNumber // pixPerByte + 1.		pixel _ rawByte >> (shifts at: pixelNumber \\ pixPerByte + 1) bitAnd: mask.		blitter pixelAt: x @ y put: pixel.		pixelNumber _ pixelNumber + 1]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:23'!copyPixelsIndexed: y at: startX by: incX	"Handle interlaced indexed color mode (colorType = 3)"	| offset b bits w pixel mask pixPerByte shifts blitter pixelNumber rawByte |	offset _ y*rowSize+1.	bits _ form bits.	bitsPerChannel = 8		ifTrue: [			startX to: width-1 by: incX do: [ :x |				w _ offset + (x>>2).				b _ 3 - (x \\ 4) * 8.				pixel _ (thisScanline at: x // incX + 1)<<b.				mask _ (255<<b) bitInvert32.				bits at: w put: (((bits at: w) bitAnd: mask) bitOr: pixel)].			^ self ].	bitsPerChannel = 1 ifTrue: [		pixPerByte _ 8.		mask _ 1.		shifts _ #(7 6 5 4 3 2 1 0).	].	bitsPerChannel = 2 ifTrue: [		pixPerByte _ 4.		mask _ 3.		shifts _ #(6 4 2 0).	].	bitsPerChannel = 4 ifTrue: [		pixPerByte _ 2.		mask _ 15.		shifts _ #(4 0).	].	blitter _ BitBlt current bitPokerToForm: form.	pixelNumber _ 0.	startX to: width-1 by: incX do: [ :x |		rawByte _ thisScanline at: (pixelNumber // pixPerByte) + 1.		pixel _ (rawByte >> (shifts at: (pixelNumber \\ pixPerByte) + 1)) bitAnd: mask.		blitter pixelAt: (x@y) put: pixel.		pixelNumber _ pixelNumber + 1.	].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 17:51'!copyPixelsRGB: y	"Handle non-interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits |	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	bitsPerChannel = 8 ifTrue: [		i := 1.		0 to: width-1 do: [ :x |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			(transparentPixelValue isNil or: [transparentPixelValue ~= pixel]) ifTrue: [				tempBits at: x+1 put: pixel.			].			i _ i + 3.		]	] ifFalse: [		i := 1.		0 to: width-1 do: [ :x |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			(transparentPixelValue isNil or: [transparentPixelValue ~= pixel]) ifTrue: [				tempBits at: x+1 put: pixel.			].			i _ i + 6.		]	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/5/2000 11:16'!copyPixelsRGB: y at: startX by: incX	"Handle interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits xx loopsToDo |	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	loopsToDo _ width - startX + incX - 1 // incX.	bitsPerChannel = 8 ifTrue: [		i _ (startX // incX * 3) + 1.		xx _ startX+1.		1 to: loopsToDo do: [ :j |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: xx put: pixel.			i _ i + 3.			xx _ xx + incX.		]	] ifFalse: [		i _ (startX // incX * 6) + 1.		xx _ startX+1.		1 to: loopsToDo do: [ :j |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: xx put: pixel.			i _ i + 6.			xx _ xx + incX.		].	].	transparentPixelValue ifNotNil: [		startX to: width-1 by: incX do: [ :x |			(tempBits at: x+1) = transparentPixelValue ifTrue: [				tempBits at: x+1 put: 0.			].		].	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:20'!copyPixelsRGBA: y	"Handle non-interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits |	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	bitsPerChannel = 8 ifTrue: [		i := -3.		0 to: width-1 do: [ :x |			i := i + 4.			pixel at: 4 put: (thisScanline at: i+3);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x+1 put: pixel.		]	] ifFalse: [		i := -7.		0 to: width-1 do: [ :x |			i := i + 8.			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel.		]	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 18:14'!copyPixelsRGBA: y at: startX by: incX	"Handle interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits |	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	bitsPerChannel = 8 ifTrue: [		i _ (startX // incX << 2) + 1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+3);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x+1 put: pixel.			i _ i + 4.		]	] ifFalse: [		i _ (startX // incX << 3) +1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel.			i _ i + 8.		].	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!PNGReadWriter methodsFor: 'miscellaneous' stamp: 'RAA 11/4/2000 12:07'!grayColorsFor: d	"return a color table for a gray image"	palette _ Array new: 1<<d.	d = 1 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: Color white.		^ palette,{Color transparent}		].	d = 2 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: (Color gray: 0.3333).		palette at: 3 put: (Color gray: 0.6667).		palette at: 4 put: Color white.		^ palette,{Color transparent}.		].	d = 4 ifTrue: [		0 to: 15 do: [ :g |			palette at: g+1 put: (Color gray: (g/15) asFloat) ].		^ palette,{Color transparent}		].	d = 8 ifTrue: [		0 to: 255 do: [ :g |			palette at: g+1 put: (Color gray: (g/255) asFloat) ].		^ palette		"??transparent??"		].! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'RAA 11/4/2000 10:51'!initialize	"	PNGReadWriter initialize	"	BPP _ {	#(1 2 4 8 16).			#(0 0 0 0 0).			#(0 0 0 24 48).			#(1 2 4 8 0).			#(0 0 0 16 32).			#(0 0 0 0 0).			#(0 0 0 32 64).			#(0 0 0 0 0) }.	BlockHeight _ #(8 8 4 4 2 2 1).	BlockWidth _ #(8 4 4 2 2 1 1)! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'RAA 11/5/2000 11:19'!test1"PNGReadWriter test1"	| answer data t error d0 d1 f fileInfo forms book newPage |	book _ BookMorph new.	book setProperty: #transitionSpec toValue: {'silence'. #none. #none}.	answer _ WriteStream on: String new.	forms _ OrderedCollection new.	d0 _ FileDirectory default.	d1 _ d0 directoryNamed: 'PngSuite Folder'.	fileInfo _ {		d0. {'pngs-img-ie5mac.png'}.		d1. d1 fileNames.	}.	"fileInfo _ {		d1. {'PP0N2C16.PNG'. 'PP0N6A08.PNG'. 'X00N0G01.PNG'. 'XCRN0G04.PNG'. 'XLFN0G04.PNG'}.	}."	fileInfo pairsDo: [ :dir :fileNames |		fileNames do: [ :each |			Transcript cr; show: each.			data _ (dir fileNamed: each) contentsOfEntireFile.			error _ ''.			t _ [					f _ [						self formFromStream: (RWBinaryOrTextStream with: data)					] ifError: [ :a :b |						error _ a printString,'  ',b printString.						(StringMorph contents: error) color: Color red; imageForm					].				] timeToRun.			newPage _ book insertPageLabel: each morphs: {f asMorph}.			newPage color: Color lightYellow.			newPage extent: (newPage submorphs inject: 10@10 into: [ :ex :m |				m left: 10.				ex max: m width @ m bottom			]) + (20@20).			forms add: {each. f}.			answer nextPutAll: each,'  ',data size printString,' = ',t printString,' ms',error; cr.		].	].	StringHolder new contents: answer contents; openLabel: 'png test'.	[forms explore].	book openInWorld.! !PNGReadWriter initialize!ImageReadWriter subclass: #PNGReadWriter	instanceVariableNames: 'chunk form width height depth bitsPerChannel colorType interlaceMethod bitsPerPixel bytesPerScanline thisScanline prevScanline rowSize globalDataChunk unknownChunks palette transparentPixelValue '	classVariableNames: 'BPP BlockHeight BlockWidth '	poolDictionaries: ''	category: 'Graphics-Files'!