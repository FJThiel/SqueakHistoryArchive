'From Squeak2.9alpha of 13 June 2000 [latest update: #2915] on 12 November 2000 at 11:38:02 am'!"Change Set:		229NaughtyCode-lsDate:			23 October 2000Author:			Lex SpoonHand-written parsers tend to accept more input than they should. Happily, my hand-written parser has different errors than Squeak's.  :)Here's a few fixes for out-of-scope accesses to block variables, and accidentally using ''super'' as a message."!!ClassBuilder methodsFor: 'private' stamp: 'ls 10/23/2000 14:10'!fixGlobalReferences	"Fix all the references to globals which are now outdated.	Care must be taken that we do not accidentally 'fix' dangerous stuff."	| oldClasses newClasses condition any |	classMap == nil ifTrue:[^self].	(self retryWithGC: [condition _ classMap anySatisfy: [:any0 | any _ any0. any0 _ nil. any notNil and:[anyisObsolete]]. any_nil. condition]		until:[:obsRef| obsRef = false])		ifFalse:[^self]. "GC cleaned up the remaining refs"	"Collect the old and the new refs"	oldClasses _ OrderedCollection new.	newClasses _ OrderedCollection new.	classMap keysAndValuesDo:[:new :old|		old == nil ifFalse:[			newClasses add: new.			oldClasses add: old]].	oldClasses isEmpty ifTrue:[^self]. "GC cleaned up the rest"	"Now fix all the known dangerous pointers to old classes by creating	copies of those still needed. Dangerous pointers should come only	from obsolete subclasses (where the superclass must be preserved)."	self fixObsoleteReferencesTo: oldClasses.	"After this has been done fix the remaining references"	progress == nil ifFalse:[progress value: 'Fixing references toglobals'].	"Forward all old refs to the new ones"	(oldClasses asArray) elementsForwardIdentityTo: (newClasses asArray).	"Done"! !!Environment methodsFor: 'dictionary access' stamp: 'ls 10/23/2000 14:12'!scopeFor: varName from: prior envtAndPathIfFound: envtAndPathBlock	"Look up varName here or in any sub-environments, and also in any sub-environments of the outer environment.  If found, evaluate pathBlock with a string giving the path for the access, and return the environment in which the variable was found.  Return nil if the variable is not found.	Call from outside with prior == nil.	prior ~= nil prevents revisiting prior parts of the tree."	| envt |	"Might be right here -- null path."	(self includesKey: varName) ifTrue:		[^ envtAndPathBlock value: self value: String new].	"Might be in a sub-environment -- append envt name to downward path."	self associationsDo:		[:assn |		(((envt _ assn value) isKindOf: Environment)			and: [envt ~~ self and: [envt ~~ prior]]) ifTrue:				[envt scopeFor: varName from: self envtAndPathIfFound:						[:subEnvt :subPath |						^ envtAndPathBlock value: subEnvt value: assn key , ' ' , subPath]]].	"If not found, traverse outer environment."	outerEnvt ifNil: [^ nil].	outerEnvt == prior ifTrue: [^ nil].	outerEnvt scopeFor: varName from: self envtAndPathIfFound:						[:subEnvt :subPath |						^ envtAndPathBlock value: subEnvt value: subPath].! !!EventSensor methodsFor: 'private' stamp: 'ls 10/23/2000 14:14'!primSetInterruptKey: anInteger	"Primitive. Register the given keycode as the user interrupt key. The low byte of the keycode is the ISO character and its next four bits are the Smalltalk modifer bits <cmd><opt><ctrl><shift>."	interruptKey _ anInteger.	"backward compatibility: use the old primitive which is obsolete now"	super primSetInterruptKey: anInteger! !