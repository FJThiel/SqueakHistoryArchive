'From Squeak2.9alpha of 16 June 2000 [latest update: #3031] on 22 November 2000 at 1:47:07 pm'!!CategoryViewer methodsFor: 'entries' stamp: 'tk 11/16/2000 15:39'!phraseForSlot: slotSpec	"Return a PhraseTileMorph representing a variable belonging to the player"	"The slot spec if a tuple with the following structure:		1	#slot		2	slot name		3	balloon help		4	slot type		5	#readOnly,# readWrite, or #writeOnly		6	getter receiver indicator		7	getter selector		8	setter receiver indicator		9	setter selector	NB:	all are symbols except #3, which is a string"	| r anArrow slotName getterButton ut cover inner |	r _ ViewerRow newRow		color: self color;		beSticky;		elementSymbol: (slotName _ slotSpec second);		wrapCentering: #center;		cellPositioning: #leftCenter.	r addMorphBack: (self slotHeaderFor: slotName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self infoButtonFor: slotName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	ut _ scriptedPlayer costume world valueOfProperty: #universalTiles ifAbsent: [false].	ut ifTrue: [inner _ self newTilesFor: scriptedPlayer getter: slotSpec.			cover _ (Morph new) color: Color transparent.			cover extent: inner fullBounds extent.			(getterButton _ cover copy) addMorph: cover; addMorphBack: inner.			cover on: #mouseDown send: #newMakeGetter:from:forPart:					to: self withValue: slotSpec]		ifFalse: [r addMorphBack: self tileForSelf bePossessive.			r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"			getterButton _ self getterButtonFor: slotName type: slotSpec fourth].	r addMorphBack: getterButton.	getterButton setBalloonText: slotSpec third.	(slotName == #isOverColor)		ifTrue:			[self addIsOverColorDetailTo: r]		ifFalse:			[(slotSpec fifth == #readOnly) ifFalse:				[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"				anArrow _ ut 					ifTrue: [self arrowSetterButton: #newMakeSetter:from:forPart:								args: slotSpec]					ifFalse: [self arrowSetterButton: #makeSetter:from:forPart:								args: (Array with: slotName with: slotSpec fourth)].				r addMorphBack: anArrow.				].			r addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"			(#(colorSees playerSeeingColor copy) includes: slotName) ifFalse:		 		[r addMorphBack: (self readoutFor: slotName type: slotSpec fourth readOnly: slotSpec fifth getSelector: slotSpec seventh putSelector: slotSpec ninth)]].	anArrow ifNotNil: [anArrow step].	^ r! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 11/16/2000 14:52'!newTilesFor: aPlayer command: aSpec	| ms messageNodeMorph argTile argArray sel |	"Return universal tiles for a command.  Record who self is."	sel _ aSpec second.	aSpec size > 3 		ifTrue: [argTile _ aPlayer tileForArgType: aSpec fourth inViewer: nil.				argArray _ Array with: (aSpec fourth == #player 					ifTrue: [argTile actualObject]					ifFalse: [argTile literal]).	"default value for each type"				sel == #colorSees ifTrue: [sel _ #color:sees:.  							argArray _ argArray, argArray].	"two colors"				sel == #isOverColor ifTrue: [sel _ #seesColor:]]		ifFalse: [argArray _ #()].	ms _ MessageSend receiver: aPlayer selector: sel arguments: argArray.	messageNodeMorph _ ms asTilesIn: aPlayer class.	^ messageNodeMorph setProperty: #whoIsSelf toValue: aPlayer. ! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 11/16/2000 15:04'!newTilesFor: aPlayer getter: aSpec	| ms messageNodeMorph argTile argArray |	"Return universal tiles for a getter on this property.  Record who self is."	ms _ MessageSend receiver: aPlayer selector: aSpec seventh arguments: #().	aSpec second == #colorSees ifTrue: [		ms selector: #color:sees:.		argTile _ aPlayer tileForArgType: #color inViewer: nil.		argArray _ Array with: argTile colorSwatch color with: argTile colorSwatch color copy. 		ms arguments: argArray].	aSpec second == #isOverColor ifTrue: [		ms selector: #seesColor:.		argTile _ aPlayer tileForArgType: #color inViewer: nil.		ms arguments: (Array with: argTile colorSwatch color)].	messageNodeMorph _ ms asTilesIn: aPlayer class.	^ messageNodeMorph setProperty: #whoIsSelf toValue: aPlayer. ! !!MessageSend methodsFor: 'tiles' stamp: 'tk 11/16/2000 20:51'!stringFor: anObject	"Return a string suitable for compiling.  Literal or reference from global ref dictionary.  self is always named via the ref dictionary."	anObject isLiteral ifTrue: [^ anObject printString].	anObject class == Color ifTrue: [^ anObject printString].	anObject class superclass == Boolean ifTrue: [^ anObject printString].	anObject class == BlockContext ifTrue: [^ '[''do nothing'']'].	"default block"		"Real blocks need to construct tiles in a different way"	^ anObject uniqueNameForReference! !!Player methodsFor: 'slots-user' stamp: 'tk 11/21/2000 16:25'!addSpecialSetter: selector	| instVar code |	"For the special setters, fooIncreaseBy:, fooDecreaseBy:, fooMultiplyBy:, add a method that does them." 	self assureUniClass.	instVar _ (selector allButLast: 11) asLowercase.  "all three are 11 long!!"	(self respondsTo: ('set', instVar capitalized, ':') asSymbol) ifFalse: [^ false].	code _ String streamContents: [:strm |		strm nextPutAll: selector, ' amount'; crtab.		strm nextPutAll: 'self set', instVar capitalized, ': (self get', instVar capitalized; space.		(selector endsWith: 'IncreaseBy:') ifTrue: [strm nextPut: $+].		(selector endsWith: 'DecreaseBy:') ifTrue: [strm nextPut: $-].		(selector endsWith: 'MultiplyBy:') ifTrue: [strm nextPut: $*].		strm nextPutAll: ' amount)'].	self class compileUnlogged: code		classified: 'access' notifying: nil.	^ true! !!Player methodsFor: 'slots-user' stamp: 'tk 11/21/2000 16:17'!doesNotUnderstand: aMessage 	 | ours |"See it the message is a special setter that has not been defined.  Define it and try again."	ours _ false.	(aMessage selector endsWith: 'IncreaseBy:') ifTrue: [ours _ true].	(aMessage selector endsWith: 'DecreaseBy:') ifTrue: [ours _ true].	(aMessage selector endsWith: 'MultiplyBy:') ifTrue: [ours _ true].	ours ifFalse: [^ super doesNotUnderstand: aMessage].	(self addSpecialSetter: aMessage selector) ifFalse: ["not our inst var"		^ super doesNotUnderstand: aMessage].	^ aMessage sentTo: self! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'tk 11/16/2000 20:43'!addYesNoToHand	| ms messageNodeMorph |	(self world valueOfProperty: #universalTiles ifAbsent: [false])		ifTrue: [ms _ MessageSend receiver: true selector: #ifTrue:ifFalse: 						arguments: {['do nothing']. ['do nothing']}.			messageNodeMorph _ ms asTilesIn: playerScripted class.			"messageNodeMorph setProperty: #whoIsSelf toValue: playerScripted."			self primaryHand attachMorph: messageNodeMorph]		ifFalse: [self primaryHand attachMorph: CompoundTileMorph new].! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 1/1/1904 00:33'!selector	"Find the SyntaxMorph that is a selectorNode within in me.  My parseNode is a MessageNode."	^ submorphs detect: [:mm | 			(mm isSyntaxMorph and: [mm nodeClassIs: SelectorNode])] 		ifNone: [nil].! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 11/17/2000 11:50'!try	| rec |	"Evaluate me once"	(parseNode class == MessageNode) | (parseNode class == LiteralNode) ifFalse: [^ self].	"(self firstSubmorph) parseNode class == VariableNode ifFalse: [^ self]."	rec _ self valueOfProperty: #whoIsSelf ifAbsent: [true]. 	"often is aPlayer"	^ Compiler evaluate: self decompile				for: rec				logged: false.	"should do something to the player"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/19/2000 23:47'!changeSound: upDown	| ind arg st soundChoices index it current |	"move in the list of sounds.  Adjust arg tile after me"	ind _ owner submorphs indexOf: self.	arg _ owner submorphs atWrap: ind+1.	arg isSyntaxMorph ifFalse: [^ self].	st _ arg findA: StringMorph.	soundChoices _ #('silence').  "default, if no SampledSound class"	Smalltalk at: #SampledSound ifPresent:		[:sampledSound | soundChoices _ sampledSound soundNames].	current _ st contents copyFrom: 2 to: st contents size-1.	"remove string quotes"	index _ soundChoices indexOf: current.	index > 0 ifTrue:		[st contents: (it _ soundChoices atWrap: index + upDown) printString.		self playSoundNamed: it].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/17/2000 15:01'!colorPatch	"Return a color patch button that lets the user choose a color and modifies the code"	| msg cc patch ss |		(self nodeClassIs: KeyWordNode) ifTrue: [		msg _ self firstOwnerSuchThat: [:oo | 			(oo isSyntaxMorph and: [oo nodeClassIs: MessageNode]) 				ifTrue: [ss _ oo submorphs select: [:mm | mm isSyntaxMorph].					ss size > 1 ifTrue: [ss second printString = 'r:g:b:']							ifFalse: [false]]				ifFalse: [false]]].	"Later test for SelectorNode with a standard color name"	(self nodeClassIs: VariableNode) ifTrue: [		self printString = 'Color' ifTrue: [			owner isSyntaxMorph ifTrue: [msg _ owner]]].	msg ifNil: [^ nil].	(cc _ msg try) class == Color ifFalse: [^ nil].	patch _ RectangleMorph new color: cc; borderWidth: 1.	patch on: #mouseDown send: #chooseColor to: msg.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/21/2000 16:45'!event: evt arrow: arrowMorph upDown: delta		| st aList index now want instVar |	st _ self findA: StringMorph.	(self nodeClassIs: LiteralNode) ifTrue: [ "+/- 1"		st contents: (self decompile asNumber + delta) printString.		^ self acceptIfInScriptor.	"maybe set parseNode's key"].	(self nodeClassIs: VariableNode) ifTrue: [ "true/false"		st contents: (self decompile asString = 'true') not printString.		^ self acceptIfInScriptor.	"maybe set parseNode's key"].	(self nodeClassIs: SelectorNode) ifTrue: [		aList _ #(+ - * / // \\ min: max:).		index _ aList indexOf: self decompile asString.		index  > 0 ifTrue: [			self setBalloonText: 				(ScriptingSystem helpStringForOperator: (aList atWrap: index + delta)).			st contents: (aList atWrap: index + 1).			^ self acceptIfInScriptor].		aList _ #(= ~= > >= isDivisibleBy: < <=).		index _ aList indexOf: self decompile asString.		index  > 0 ifTrue: [			self setBalloonText: 				(ScriptingSystem helpStringForOperator: (aList atWrap: index + delta)).			st contents: (aList atWrap: index + 1).			^ self acceptIfInScriptor].		"rec or arg type = #number 				ifFalse: [^ st contents: (#(= ~=) atWrap: index + delta)]."		'beep:' = self decompile asString ifTrue: ["replace sound arg"			self changeSound: delta.			^ self acceptIfInScriptor].		].	(self nodeClassIs: SelectorNode) ifTrue: ["kinds of assignment"		((now _ self decompile asString) beginsWith: 'set') ifTrue: ["a setX: 3"			want _ 1+delta.  instVar _ (now allButFirst: 3) allButLast].		(now endsWith: 'IncreaseBy:') ifTrue: ["a xIncreaseBy: 3      a setX: (a getX +3)."			want _ 2+delta.  instVar _ now allButLast: 11].		(now endsWith: 'DecreaseBy:') ifTrue: ["a xDecreaseBy: 3      a setX: (a getX -3)."			want _ 3+delta.  instVar _ now allButLast: 11].		(now endsWith: 'MultiplyBy:') ifTrue: ["a xMultiplyBy: 3      a setX: (a getX *3)."			want _ 4+delta.  instVar _ now allButLast: 11].		want ifNil: [^ self].		instVar _ instVar asLowercase.		want _ #(1 2 3 4) atWrap: want.		want = 1 ifTrue: [st contents: 'set', instVar capitalized, ':'].	"setter method is present"		want = 2 ifTrue: [st contents: instVar, 'IncreaseBy:'].			"notUnderstood will create the method if needed"		want = 3 ifTrue: [st contents: instVar, 'DecreaseBy:'].			"notUnderstood will create the method if needed"		want = 4 ifTrue: [st contents: instVar, 'MultiplyBy:'].			"notUnderstood will create the method if needed"				^ self acceptIfInScriptor].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/22/2000 13:43'!extend	| messageNodeMorph first |	"replace this arg with a new message like (arg + 1)."	"Later do evaluation of self to see what type and offer right selector"	messageNodeMorph _ (MessageSend receiver: 1 selector: #+ arguments: #(1))								asTilesIn: Player.	owner replaceSubmorph: self by: messageNodeMorph.	first _ messageNodeMorph submorphs detect: [:mm | mm isSyntaxMorph].	messageNodeMorph replaceSubmorph: first by: self.	self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/17/2000 15:25'!extendArrow	"Return the extend arrow button.  It replaces the argument with a new message.	I am a number or getter messageNode."	| patch ok sel ss |		ok _ false.	(self nodeClassIs: LiteralNode) ifTrue: [		[self decompile asString asNumber] ifError: [:msg :rcvr | ^ nil].		ok _ true].	(self nodeClassIs: MessageNode) ifTrue: [		ss _ submorphs select: [:mm | mm isSyntaxMorph].		ss size > 1 ifTrue: [			(ss second nodeClassIs: SelectorNode) ifTrue: [				((sel _ ss second decompile asString) beginsWith: 'get') ifTrue: [					ok _ (sel atWrap: 4) isUppercase ]]]].	"a getter -- hope it is a number"	ok ifFalse: [^ nil].	patch _ (ImageMorph new image: (TileMorph classPool at: #SuffixPicture)).	patch on: #mouseDown send: #extend to: self.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/17/2000 15:32'!offerPopUp	"Put up a halo to allow user to change Literals (Integer, true), Selector (beep: sound, +,-,*,//,\\, r:g:b:, setX: incX: decX: for any X,), Variable (Color),    not AssignmentNode (_ inc dec), 	Extend arrows on each literal, variable, and message, (block that is by itself).	Retract arrows on each literal or variable, or message or block that is an argument.	Any literal can be changed by Shift-clicking and typing."	| panel any upDown retract extend colorPatch edge |	(self hasProperty: #myPopup) ifTrue: [^ self].  "already has one"	any _ false.	(upDown _ self upDownArrows) ifNotNil: [any _ true].	(retract _ self retractArrow) ifNotNil: [any _ true].	(extend _ self extendArrow) ifNotNil: [any _ true].	(colorPatch _ self colorPatch) ifNotNil: [any _ true].	any ifFalse: [^ self].	panel _ RectangleMorph new color: Color transparent; borderWidth: 0.	upDown ifNotNil: [		panel addMorphBack: upDown first.		upDown first align: upDown first topLeft with: panel topLeft.		panel addMorphBack: upDown second.		upDown second align: upDown second topLeft with: upDown first bottomLeft].	colorPatch ifNotNil: [		panel addMorphBack: colorPatch.		colorPatch align: colorPatch topLeft 					with: panel topLeft].	retract ifNotNil: [		edge _ panel submorphs size = 0 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: retract.		retract align: retract topLeft with: (edge+2) @ (panel top + 3)].	extend ifNotNil: [		edge _ panel submorphs size = 0 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: extend.		extend align: extend topLeft with: (edge+2) @ (panel top + 3)].	panel on: #mouseLeave send: #maybeDeletePopup: to: self.	panel align: panel topLeft with: self topRight.	panel extent: panel submorphs last bottomRight - panel topLeft.	self setProperty: #myPopup toValue: panel.	self rootTile owner addMorphFront: panel.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/17/2000 11:20'!offerPopUp2	"Put up a halo to allow user to change Literals (Integer, true), Selector (beep: sound, +,-,*,//,\\, r:g:b:, setX: incX: decX: for any X,), Variable (Color),    not AssignmentNode (_ inc dec), 	Extend arrows on each literal, variable, and message, (block that is by itself).	Retract arrows on each literal or variable, or message or block that is an argument.	Any literal can be changed by Shift-clicking and typing."	| panel any upDown retract extend colorPatch edge |	(self hasProperty: #myPopup) ifTrue: [^ self].  "already has one"	any _ false.	(upDown _ self upDownArrows) ifNotNil: [any _ true].	(retract _ self retractArrow) ifNotNil: [any _ true].	(extend _ self extendArrow) ifNotNil: [any _ true].	(colorPatch _ self colorPatch) ifNotNil: [any _ true].	any ifFalse: [^ self].	panel _ RectangleMorph new color: Color transparent; borderWidth: 0.	upDown ifNotNil: [		panel addMorphBack: upDown first.		upDown first align: upDown first topLeft with: panel topRight.		panel addMorphBack: upDown second.		upDown second align: upDown second topLeft with: upDown first bottomLeft].	colorPatch ifNotNil: [		panel addMorphBack: colorPatch.		colorPatch align: colorPatch topLeft 					with: panel topRight].	retract ifNotNil: [		panel addMorphBack: retract.		edge _ panel submorphs size = 0 			ifTrue: [panel right] 			ifFalse: [panel submorphs last right].		retract align: retract topLeft with: (edge+2) @ (panel top + 3)].	extend ifNotNil: [		panel addMorphBack: extend.		edge _ panel submorphs size = 0 			ifTrue: [panel right] 			ifFalse: [panel submorphs last right].		extend align: extend topLeft with: (edge+2) @ (panel top + 3)].	panel on: #mouseLeave send: #maybeDeletePopup: to: self.	panel align: panel topLeft with: self topRight.	self setProperty: #myPopup toValue: panel.	self rootTile owner addMorphFront: panel.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/21/2000 16:46'!retract	| rec |	"replace this message with its receiver.  I am the message node."	rec _ submorphs detect: [:mm | mm isSyntaxMorph] ifNone: [^ nil].	(rec nodeClassIs: MessagePartNode) ifTrue: [^ nil].	self valueOfProperty: #myPopup ifPresentDo:		[:panel | panel delete. self removeProperty: #myPopup].	owner replaceSubmorph: self by: rec.	self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/17/2000 14:47'!retractArrow	"Return the retract arrow button.  It replaces the current message with its receiver.	I am in a MessageNode whose first subnode is not a MessagePartNode.  I did not encounter a block on the way up to it.  I am the last subnode in every owner up to it."	| msg patch oo prev ff |		oo _ self owner.  prev _ self.  msg _ nil.	[(msg == nil) & (oo ~~ nil) and: [oo isSyntaxMorph]] whileTrue: [		(oo nodeClassIs: BlockNode) ifTrue: [^ nil].	"bare object in a block"		oo lastSubmorph == prev ifFalse: [^ nil].		(oo nodeClassIs: MessageNode) ifTrue: [			ff _ oo submorphs detect: [:mm | mm isSyntaxMorph] ifNone: [^ nil].			(ff nodeClassIs: MessagePartNode) ifFalse: [msg _ oo]].		prev _ oo.  oo _ oo owner].	msg ifNil: [^ nil].	patch _ (ImageMorph new image: (TileMorph classPool at: #RetractPicture)).	patch on: #mouseDown send: #retract to: msg.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/22/2000 13:29'!upDownArrows	"Return an array of two up/down arrow buttons.  It replaces the selector or arg with a new one.	I am a number or boolean or a selector (beep:, +,-,*,//,\\, or setX: incX: decX: for any X."	| patch ok target sel |		target _ nil.	(self nodeClassIs: LiteralNode) ifTrue: [		[self decompile asNumber] ifError: [:msg :rcvr | ^ nil].		target _ self].	(self nodeClassIs: VariableNode) ifTrue: [		(self decompile asString = 'true') | (self decompile asString = 'false') ifTrue: [target _ self]].	(self nodeClassIs: SelectorNode) ifTrue: [		ok _ #('beep:' '+' '-' '*' '//' '\\') includes: (sel _ self decompile asString).		ok ifFalse: [ok _ (sel beginsWith: 'set') and: [(sel atWrap: 4) isUppercase]].		ok ifFalse: [sel size > 11 ifTrue: [			ok _ #('IncreaseBy:' 'DecreaseBy:' 'MultiplyBy:') includes: (sel last: 11)]].		ok ifTrue: [target _ self]].	target ifNil: [^ nil].	patch _ Array 		with: (ImageMorph new image: (TileMorph classPool at: #UpPicture))		with: (ImageMorph new image: (TileMorph classPool at: #DownPicture)).	patch first on: #mouseDown send: #event:arrow:upDown: to: target withValue: 1.	patch second on: #mouseDown send: #event:arrow:upDown: to: target withValue: -1.	^ patch! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 11/21/2000 16:35'!acceptIfInScriptor	| root |	"If I am in a ScriptEditorMorph, tell my root to accept the new changes."	(self ownerThatIsA: ScriptEditorMorph) ifNotNil: [		root _ self rootTile.		root ifNotNil: [root accept]]. ! !SyntaxMorph removeSelector: #doArrow:!SyntaxMorph removeSelector: #doUp!MessageSend removeSelector: #asTiles!