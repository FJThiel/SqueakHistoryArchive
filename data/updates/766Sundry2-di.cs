'From Squeak 2.3 of January 14, 1999 on 29 March 1999 at 5:12:05 pm'!"Change Set:		Sundry2Date:			29 March 1999Author:			Dan Ingalls[This is a re-release of an incomplete changeSet]A couple of changes to prevent gratuitous responses to inappropiate messages.	'abc' asNumber no longer responds with 0.	123 size no longer responds with 0.	nil size no longer responds with 0.All these are now errors.Attempts to use at:, or at:put: with non-indexable objects no longer complain about subscript bounds, but properly complain about indexability.Includes a couple of fixes for code that relied on the above improprieties."!!Object methodsFor: 'accessing' stamp: 'di 3/29/1999 11:39'!at: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue:		[self class isVariable			ifTrue: [self errorSubscriptBounds: index]			ifFalse: [self error: (self class name) , 's are not indexable']].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'di 3/29/1999 11:41'!at: index put: value 	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[self class isVariable			ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]]			ifFalse: [self error: (self class name) , 's are not indexable']].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'di 3/29/1999 13:10'!size	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 62>	self class isVariable ifFalse: [self errorNotIndexable].	^ 0! !!Object methodsFor: 'private' stamp: 'di 3/29/1999 12:39'!errorNotIndexable	"Create an error notification that the receiver is not indexable."	self error: (self class name) , 's are not indexable'! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 13:35'!fileOutPostscriptOn: stream 	"If the receiver has a postscript, put it out onto the stream.  "	| aString |	aString _ self postscriptString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 14:58'!fileOutPreambleOn: stream 	"If the receiver has a preamble, put it out onto the stream.  "	| aString |	aString _ self preambleString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!Color class methodsFor: 'other' stamp: 'di 3/29/1999 13:33'!maskingMap: depth	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero. Cache the most recently used map."	| sizeNeeded |	depth <= 8		ifTrue: [sizeNeeded _ 1 bitShift: depth]		ifFalse: [sizeNeeded _ 4096].	(MaskingMap == nil or: [MaskingMap size ~= sizeNeeded]) ifTrue:		[MaskingMap _ Bitmap new: sizeNeeded withAll: 16rFFFFFFFF.		MaskingMap at: 1 put: 0.  "transparent"].	^ MaskingMap! !!Integer class methodsFor: 'instance creation' stamp: 'di 2/9/1999 15:37'!readFrom: aStream base: base 	"Answer an instance of one of my concrete subclasses. Initial minus sign 	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not 	allowed--use Number readFrom: for that. Answer zero (not an error) if 	there are no digits."	| digit value neg startPos |	neg _ aStream peekFor: $-.	value _ 0.	startPos _ aStream position.	[aStream atEnd]		whileFalse: 			[digit _ aStream next digitValue.			(digit < 0 or: [digit >= base])				ifTrue: 					[aStream skip: -1.					aStream position = startPos ifTrue: [self error: 'At least one digit expected here'].					neg ifTrue: [^ value negated].					^ value]				ifFalse: [value _ value * base + digit]].	neg ifTrue: [^ value negated].	^ value! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 3/29/1999 11:28'!primitiveSize	| rcvr sz |	rcvr _ self stackTop.	(self isIntegerObject: rcvr) ifTrue: [^ self primitiveFail].  "Integers are not indexable"	(self formatOf: rcvr) < 2 ifTrue: [^ self primitiveFail].  "This is not an indexable object"	sz _ self stSizeOf: rcvr.	successFlag ifTrue:		[self pop: 1 thenPush: (self positive32BitIntegerFor: sz)]! !!Parser methodsFor: 'error handling' stamp: 'di 2/9/1999 15:43'!offEnd: aString 	"Notify a problem beyond 'here' (in lookAhead token). Don't be offEnded!!"	requestorOffset == nil		ifTrue: [^ self notify: aString at: mark]		ifFalse: [^ self notify: aString at: mark + requestorOffset]! !!Parser methodsFor: 'private' stamp: 'di 3/29/1999 13:10'!previousTokenSize	"Answer the size of the previous token. Bugfix for Strings."	| hereSize |	hereType == #number ifTrue: [^ mark - prevMark].	hereSize _ here ifNil: [0] ifNotNil: [here size].	hereType == #string ifTrue: [^ hereSize + 2].   "One for each single quote"	^ hereSize! !!SequenceableCollection methodsFor: 'comparing' stamp: 'di 3/29/1999 13:36'!= otherCollection	"Answer whether the species of the receiver is the same as	otherCollection's species, and the receiver's size is the same as	otherCollection's size, and each of the receiver's elements equal the	corresponding element of otherCollection."	| size |	self species == otherCollection species ifFalse: [^false].	(size _ self size) = otherCollection size ifFalse: [^false].	1 to: size do:		[:index |		(self at: index) = (otherCollection at: index) ifFalse: [^false]].	^true! !"Postscript:Initialize any hands with null remoteConnections."HandMorph allInstancesDo:	[:h | (h instVarNamed: 'remoteConnections') ifNil:		[h instVarNamed: 'remoteConnections' put: OrderedCollection new]].!