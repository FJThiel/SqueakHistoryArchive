'From Squeak2.9alpha of 12 June 2000 [latest update: #2778] on 2 October 2000 at 5:47:47 pm'!"Change Set:		ArrowTweaksDate:			2 October 2000Author:			Dan IngallsAdds a facility to control the appearance of arrowheads on morphic lines.  Both length and width of the arrowheads can be controlled, and two styles of arrowhead are now supported.Also, arrowheads now end strictly at the end vertices of their line.  This allows one to change line width or arrow size without having to reposition the line to meet an adjacent object.Finally a modicum of help is now provided during operation of the arrowhead control as well as the similar border width control."!!BorderedMorph methodsFor: 'menu' stamp: 'di 10/2/2000 17:21'!changeBorderWidth: evt	| handle origin aHand newWidth oldWidth |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	oldWidth _ borderWidth.	handle _ HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			newWidth _ (newPoint - origin) r asInteger // 5.			self borderWidth: newWidth]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo doIfNotNil: [:halo | halo addHandles].			self rememberCommand:				(Command new cmdWording: 'border change';					undoTarget: self selector: #borderWidth: argument: oldWidth;					redoTarget: self selector: #borderWidth: argument: newWidth)].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor farther fromthis point to increase border width.Click when done.'.	handle startStepping! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 10/2/2000 17:39'!drawBorderOn: aCanvas	"Display my border on the canvas."	"NOTE: Much of this code is also copied in drawDashedBorderOn: (should be factored)"	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i v d |	borderDashSpec ifNotNil:		[^ self drawDashedBorderOn: aCanvas].	(borderColor == nil or: [borderColor isColor and: [borderColor isTransparent]])		ifTrue: [^ self].	lineColor _ borderColor.	bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: 			[topLeftColor _ color lighter.			bottomRightColor _ color darker.			bevel _ true].	borderColor == #inset ifTrue: 			[topLeftColor _ owner colorForInsets darker.			bottomRightColor _ owner colorForInsets lighter.			bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth + 1 // 2.	brush _ nil.	self lineSegmentsDo: 			[:p1 :p2 | 			p1i _ p1 asIntegerPoint.			p2i _ p2 asIntegerPoint.			arrows == #none ifFalse:				["Shorten line ends so as not to interfere with tip of arrow."				((arrows == #back or: [arrows == #both]) and: [p1 = vertices first])					ifTrue: [v _ p1 - p2.							d _ Point r: v r - (self borderWidth*3) degrees: v degrees.							p1i _ (p2 + d) asIntegerPoint].				((arrows == #forward or: [arrows == #both]) and: [p2 = vertices last])					ifTrue: [v _ p2 - p1.							d _ Point r: v r - (self borderWidth*3) degrees: v degrees.							p2i _ (p1 + d) asIntegerPoint]].			(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"				((p1i min: p2i)					max: bigClipRect origin)					<= ((p1i max: p2i)							min: bigClipRect corner)])				ifTrue: 					[bevel						ifTrue: [(p1i quadrantOf: p2i)								> 2								ifTrue: [lineColor _ topLeftColor]								ifFalse: [lineColor _ bottomRightColor]].					(borderWidth > 3 and: [borderColor isColor])						ifTrue: 							[brush == nil ifTrue: [brush _ (ColorForm dotOfSize: borderWidth)											colors: (Array with: Color transparent with: borderColor)].							aCanvas								line: p1i								to: p2i								brushForm: brush]						ifFalse: [aCanvas								line: p1i								to: p2i								width: borderWidth								color: lineColor]]].! !!PolygonMorph methodsFor: 'menu' stamp: 'di 10/2/2000 12:32'!addCustomMenuItems: aMenu hand: aHandMorph	| lineName |	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addUpdating: #handlesShowingPhrase target: self action: #showOrHideHandles.	vertices size > 2 ifTrue:		[aMenu addUpdating: #openOrClosePhrase target: self action: #makeOpenOrClosed.		lineName _ closed ifTrue: ['outline'] ifFalse: ['line'].		self isCurve			ifTrue: [aMenu add: 'make segmented ', lineName action: #toggleSmoothing]			ifFalse: [aMenu add: 'make smooth ', lineName action: #toggleSmoothing]]. 	aMenu add: 'specify dashed line' action:  #specifyDashedLine.	self isOpen ifTrue:		[aMenu addLine.		aMenu addWithLabel: '---' enablement: [self isOpen and: [arrows ~~ #none]] action:  #makeNoArrows.		aMenu addWithLabel: '-->' enablement: [self isOpen and: [arrows ~~ #forward]] action:  #makeForwardArrow.		aMenu addWithLabel: '<--' enablement: [self isOpen and: [arrows ~~ #back]] action:  #makeBackArrow.		aMenu addWithLabel: '<->' enablement: [self isOpen and: [arrows ~~ #both]] action:  #makeBothArrows.		aMenu add: 'customize arrows' action: #customizeArrows:.		(self hasProperty: #arrowLength)			ifTrue: [aMenu add: 'standard arrows' action: #standardArrows]].! !!PolygonMorph methodsFor: 'menu' stamp: 'di 10/2/2000 17:38'!customizeArrows: evt	| handle origin aHand specPt |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	handle _ HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			specPt _ (newPoint - origin) // 5.0.			self setProperty: #arrowLength toValue: specPt x.			self setProperty: #arrowWidth toValue: specPt y abs.			self computeBounds]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo doIfNotNil: [:halo | halo addHandles].].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor left and rightto change arrow length and style.Move it up and down to change width.Click when done.'.	handle startStepping! !!PolygonMorph methodsFor: 'menu' stamp: 'di 10/2/2000 15:46'!standardArrows	self removeProperty: #arrowLength.	self removeProperty: #arrowWidth.	self computeBounds! !!PolygonMorph methodsFor: 'private' stamp: 'di 10/2/2000 16:35'!arrowBoundsAt: endPoint from: priorPoint 	"Answer a triangle oriented along the line from priorPoint to endPoint."	| d v angle arrowLength arrowWidth wingBase |	v _ endPoint - priorPoint.	angle _ v degrees.	d _ borderWidth max: 1.	arrowLength _ self valueOfProperty: #arrowLength ifAbsent: [5].	arrowWidth _ self valueOfProperty: #arrowWidth ifAbsent: [4].	wingBase _ endPoint + (Point r: d * arrowLength abs degrees: angle + 180.0).	arrowLength >= 0		ifTrue: [^ {	endPoint.					wingBase + (Point r: d * arrowWidth degrees: angle + 135.0).					wingBase + (Point r: d * arrowWidth degrees: angle - 135.0) }]		ifFalse: ["Negative length means concave base."				^ {	endPoint.					wingBase + (Point r: d * arrowWidth degrees: angle + 135.0).					wingBase.					wingBase + (Point r: d * arrowWidth degrees: angle - 135.0) }]! !!PolygonMorph methodsFor: 'dashes' stamp: 'di 10/2/2000 17:39'!drawDashedBorderOn: aCanvas 	"Display my border on the canvas.  NOTE: mostly copied from drawBorderOn:"	| lineColor bevel topLeftColor bottomRightColor bigClipRect p1i p2i segmentOffset v d |	(borderColor == nil		or: [borderColor isColor and: [borderColor isTransparent]])		ifTrue: [^ self].	lineColor _ borderColor.	bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: 			[topLeftColor _ color lighter.			bottomRightColor _ color darker.			bevel _ true].	borderColor == #inset ifTrue: 			[topLeftColor _ owner colorForInsets darker.			bottomRightColor _ owner colorForInsets lighter.			bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth + 1 // 2.	segmentOffset _ self borderDashOffset.	self lineSegmentsDo: 			[:p1 :p2 | 			p1i _ p1 asIntegerPoint.			p2i _ p2 asIntegerPoint.			arrows == #none ifFalse:				["Shorten line ends so as not to interfere with tip of arrow."				((arrows == #back or: [arrows == #both]) and: [p1 = vertices first])					ifTrue: [v _ p1 - p2.							d _ Point r: v r - (self borderWidth*3) degrees: v degrees.							p1i _ (p2 + d) asIntegerPoint].				((arrows == #forward or: [arrows == #both]) and: [p2 = vertices last])					ifTrue: [v _ p2 - p1.							d _ Point r: v r - (self borderWidth*3) degrees: v degrees.							p2i _ (p1 + d) asIntegerPoint]].			(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"				((p1i min: p2i)					max: bigClipRect origin)					<= ((p1i max: p2i)							min: bigClipRect corner)])				ifTrue: 					[bevel						ifTrue: [(p1i quadrantOf: p2i)								> 2								ifTrue: [lineColor _ topLeftColor]								ifFalse: [lineColor _ bottomRightColor]].					segmentOffset _						aCanvas line: p1i to: p2i width: borderWidth							color: lineColor							dashLength: borderDashSpec first							secondColor: borderDashSpec third							secondDashLength: borderDashSpec second							startingOffset: segmentOffset]]! !