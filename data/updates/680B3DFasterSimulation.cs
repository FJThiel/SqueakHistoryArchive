'From Squeak 2.3 of January 14, 1999 on 17 February 1999 at 4:35:40 pm'!B3DRenderEngine subclass: #B3DPrimitiveEngine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!Object subclass: #B3DScene	instanceVariableNames: 'box objects cameras lights materials defaultCamera clearColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Objects'!Morph subclass: #B3DSceneMorph	instanceVariableNames: 'scene '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Balloon-Demos'!B3DEnginePart subclass: #B3DVertexShader	instanceVariableNames: 'lights material materialStack '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!B3DVertexShader subclass: #B3DPrimitiveShader	instanceVariableNames: 'primitiveLights '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!B3DVertexTransformer subclass: #B3DPrimitiveTransformer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!B3DPrimitiveEngine subclass: #OSMesaRenderEngine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-OSMesa'!!B3DBox methodsFor: 'accessing' stamp: 'ar 2/17/1999 05:26'!boundingBox	^Rectangle origin: vertices first corner: vertices last! !!B3DCamera methodsFor: 'experimental' stamp: 'ar 2/17/1999 05:41'!changeDistanceBy: delta	position _ target + (position - target * delta)! !!B3DCamera methodsFor: 'experimental' stamp: 'ar 2/17/1999 16:05'!moveToFit: aScene	"Move the camera to fit the given scene. Experimental."	| distance center |	self setTargetFrom: aScene.	center _ (aScene boundingBox origin + aScene boundingBox corner) * 0.5.	distance _ (aScene boundingBox origin - center) length * 1.3.	distance _ distance / (target - position) length.	"self inform:'Distance ', distance printString."	self changeDistanceBy: distance.! !!B3DEnginePart class methodsFor: 'testing' stamp: 'ar 2/17/1999 04:39'!isAvailableFor: anOutputMedium	"Return true if this part of the engine is available for the given output medium"	^self isAvailable! !!B3DMatrix4x4 methodsFor: 'private' stamp: 'ar 2/17/1999 04:23'!privateTransformMatrix: m1 with: m2 into: m3	"Perform a 4x4 matrix multiplication		m2 * m1 = m3	being equal to first transforming points by m2 and then by m1.	Note that m1 may be identical to m3.	NOTE: The primitive implementation does NOT return m3 - and so don't we!!"	| c1 c2 c3 c4 |	m2 == m3 ifTrue:[^self error:'Argument and result matrix identical'].	c1 _ ((m1 a11 * m2 a11) + (m1 a12 * m2 a21) + 				(m1 a13 * m2 a31) + (m1 a14 * m2 a41)).	c2 _ ((m1 a11 * m2 a12) + (m1 a12 * m2 a22) + 				(m1 a13 * m2 a32) + (m1 a14 * m2 a42)).	c3 _ ((m1 a11 * m2 a13) + (m1 a12 * m2 a23) + 				(m1 a13 * m2 a33) + (m1 a14 * m2 a43)).	c4 _ ((m1 a11 * m2 a14) + (m1 a12 * m2 a24) + 				(m1 a13 * m2 a34) + (m1 a14 * m2 a44)).	m3 a11: c1; a12: c2; a13: c3; a14: c4.	c1 _ ((m1 a21 * m2 a11) + (m1 a22 * m2 a21) + 				(m1 a23 * m2 a31) + (m1 a24 * m2 a41)).	c2 _ ((m1 a21 * m2 a12) + (m1 a22 * m2 a22) + 				(m1 a23 * m2 a32) + (m1 a24 * m2 a42)).	c3 _ ((m1 a21 * m2 a13) + (m1 a22 * m2 a23) + 				(m1 a23 * m2 a33) + (m1 a24 * m2 a43)).	c4 _ ((m1 a21 * m2 a14) + (m1 a22 * m2 a24) + 				(m1 a23 * m2 a34) + (m1 a24 * m2 a44)).	m3 a21: c1; a22: c2; a23: c3; a24: c4.	c1 _ ((m1 a31 * m2 a11) + (m1 a32 * m2 a21) + 				(m1 a33 * m2 a31) + (m1 a34 * m2 a41)).	c2 _ ((m1 a31 * m2 a12) + (m1 a32 * m2 a22) + 				(m1 a33 * m2 a32) + (m1 a34 * m2 a42)).	c3 _ ((m1 a31 * m2 a13) + (m1 a32 * m2 a23) + 				(m1 a33 * m2 a33) + (m1 a34 * m2 a43)).	c4 _ ((m1 a31 * m2 a14) + (m1 a32 * m2 a24) + 				(m1 a33 * m2 a34) + (m1 a34 * m2 a44)).	m3 a31: c1; a32: c2; a33: c3; a34: c4.	c1 _ ((m1 a41 * m2 a11) + (m1 a42 * m2 a21) + 				(m1 a43 * m2 a31) + (m1 a44 * m2 a41)).	c2 _ ((m1 a41 * m2 a12) + (m1 a42 * m2 a22) + 				(m1 a43 * m2 a32) + (m1 a44 * m2 a42)).	c3 _ ((m1 a41 * m2 a13) + (m1 a42 * m2 a23) + 				(m1 a43 * m2 a33) + (m1 a44 * m2 a43)).	c4 _ ((m1 a41 * m2 a14) + (m1 a42 * m2 a24) + 				(m1 a43 * m2 a34) + (m1 a44 * m2 a44)).	m3 a41: c1; a42: c2; a43: c3; a44: c4.! !!B3DPrimitiveEngine commentStamp: 'ar 2/17/1999 04:25' prior: 0!I am a basic render engine with some primitive level support for transformation, lighting and (once it is done) clipping.!!B3DRenderEngine class methodsFor: 'instance creation' stamp: 'ar 2/17/1999 04:41'!defaultForPlatformOn: aForm	"Return the render engine that is most appropriate for the current host platform.	If aForm is nil, then the engine may render directly onto the host window.	For now, we only have the choice between OSMesa (preferred),	a primitive accellerated and the fully simulated version"	(OSMesaRenderEngine isAvailableFor: aForm) ifTrue:[^OSMesaRenderEngine].	(B3DPrimitiveEngine isAvailableFor: aForm) ifTrue:[^B3DPrimitiveEngine].	^B3DRenderEngine! !!B3DPrimitiveEngine class methodsFor: 'accessing' stamp: 'ar 2/17/1999 04:24'!shader	"Return the shader to use with this engine"	^B3DPrimitiveShader! !!B3DPrimitiveEngine class methodsFor: 'accessing' stamp: 'ar 2/17/1999 04:24'!transformer	"Return the transformer to use with this engine"	^B3DPrimitiveTransformer! !!B3DSTriangleMesh methodsFor: 'private' stamp: 'ar 2/17/1999 15:59'!computeFunkyVertexNormals	"Compute the vertex normals for the receiver.	Don't split the faces so we'll get some funky lighting effects."	vtxNormals _ super computeVertexNormals! !!B3DSTriangleMesh methodsFor: 'private' stamp: 'ar 2/17/1999 15:57'!computeVertexNormals	"Compute the vertex normals for the receiver.	Note: This is a multi pass process here - we may have to split up vertices"	| set dict |	set _ self detectNonSmoothVertices.	set isEmpty ifFalse:[		"Collect the dictionary of vertices to split"		dict _ self collectSplitVertices: set.		"And actually split them"		self splitVerticesFrom: dict.	].	"Now do the actual computation"	^super computeVertexNormals! !!B3DScene methodsFor: 'initialize' stamp: 'ar 2/17/1999 16:02'!from3DS: aDictionary	| globals constants ambient texture funkyNormals r1 |	"Remove the globals from the scene - the remaining objects are name->sceneObject"	globals _ aDictionary at: #globals.	constants _ globals at: #constants ifAbsent:[Dictionary new].	aDictionary removeKey: #globals.	"Collect the scene objects and assign the names"	objects _ OrderedCollection new.	aDictionary associationsDo:[:assoc| objects add: (assoc value name: assoc key)].	"Fetch the cameras and set a default camera"	cameras _ globals at: #cameras.	cameras isEmpty ifFalse:[defaultCamera _ cameras at: cameras keys asSortedCollection first].	"Fetch the lights"	lights _ globals at: #lights.	"Add the ambient light if possible.	Note: The name $AMBIENT$ is used in the keyframe section of the 3DS file."	ambient _ constants at: 'ambientColor' ifAbsent:[nil].	ambient ifNotNil:[lights at: '$AMBIENT$' put: (B3DAmbientLight color: ambient)].	"Fetch the background color"	clearColor _ constants at: 'backgroundColor' ifAbsent:[Color white].	"Fetch the materials and replace names in sceneObjects by actual materials"	materials _ globals at: #materials.	"Compute the per vertex normals"	funkyNormals _ self confirm:'Do you want funky normals instead of accurate normals?(It will give the model a somewhat strange, but interesting look)'.	'Computing vertex normals' displayProgressAt: Sensor cursorPoint		from: 0 to: objects size during:[:bar|			objects doWithIndex:[:obj :index|				bar value: index.				obj material ifNotNil:[obj material: (materials at: obj material ifAbsent:[nil])].				funkyNormals 					ifTrue:[obj geometry computeFunkyVertexNormals]					ifFalse:[obj geometry vertexNormals]]].	(self confirm:'Do you want to use a texture with the model?') ifTrue:[		Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 128@128.				Sensor waitNoButton].		texture _ B3DTexture fromDisplay: r1.		texture wrap: true.		texture interpolate: false.		texture envMode: 0].	objects do:[:obj|		obj texture ifNotNil:[			obj texture: texture]].! !!B3DScene methodsFor: 'initialize' stamp: 'ar 2/17/1999 05:09'!initialize	objects _ OrderedCollection new.	cameras _ OrderedCollection new.	lights _ OrderedCollection new.	materials _OrderedCollection new.! !!B3DScene methodsFor: 'accessing' stamp: 'ar 2/17/1999 04:44'!clearColor	^clearColor! !!B3DScene methodsFor: 'accessing' stamp: 'ar 2/17/1999 04:44'!clearColor: aColor	clearColor _ aColor! !!B3DScene methodsFor: 'accessing' stamp: 'ar 2/17/1999 05:08'!defaultCamera: aCamera	defaultCamera _ aCamera.! !!B3DScene methodsFor: 'accessing' stamp: 'ar 2/17/1999 05:14'!objects	^objects! !!B3DScene methodsFor: 'accessing' stamp: 'ar 2/17/1999 05:14'!objects: aCollection	objects _ aCollection! !!B3DScene methodsFor: 'displaying' stamp: 'ar 2/17/1999 04:44'!render	| b3d |	b3d _ (B3DRenderEngine defaultForPlatformOn: Display) new.	b3d viewport: (0@0 extent: 600@600).	clearColor ifNotNil:[b3d clearViewport: clearColor].	b3d clearDepthBuffer.	"b3d addLight: (B3DAmbientLight color: Color white)."	self renderOn: b3d.	b3d finish.	b3d destroy.! !!B3DScene class methodsFor: 'instance creation' stamp: 'ar 2/17/1999 05:14'!new	^super new initialize! !!B3DSceneMorph methodsFor: 'drawing' stamp: 'ar 2/17/1999 05:05'!drawOn: aCanvas	aCanvas asBalloonCanvas render: self.! !!B3DSceneMorph methodsFor: 'drawing' stamp: 'ar 2/17/1999 05:34'!renderOn: aRenderer	aRenderer viewport: (self bounds insetBy: 1@1).	aRenderer clearDepthBuffer.	aRenderer loadIdentity.	scene renderOn: aRenderer.! !!B3DSceneMorph methodsFor: 'initialize' stamp: 'ar 2/17/1999 05:27'!createDefaultScene	| sceneObj camera |	sceneObj _ B3DSceneObject named: 'Sample Cube'.	sceneObj geometry: (B3DBox from: (-0.7@-0.7@-0.7) to: (0.7@0.7@0.7)).	camera _ B3DCamera new.	camera position: 0@0@-1.5.	self extent: 100@100.	scene _ B3DScene new.	scene defaultCamera: camera.	scene objects add: sceneObj.! !!B3DSceneMorph methodsFor: 'initialize' stamp: 'ar 2/17/1999 05:24'!initialize	super initialize.	self createDefaultScene.! !!B3DSceneMorph methodsFor: 'accessing' stamp: 'ar 2/17/1999 05:34'!scene	^scene! !!B3DSceneMorph methodsFor: 'accessing' stamp: 'ar 2/17/1999 05:34'!scene: aScene	scene _ aScene! !!B3DSceneMorph methodsFor: 'stepping' stamp: 'ar 2/17/1999 05:31'!step	scene defaultCamera rotateBy: 15.	self changed.! !!B3DSceneMorph methodsFor: 'stepping' stamp: 'ar 2/17/1999 05:31'!stepTime	^1! !!B3DSceneMorph methodsFor: 'stepping' stamp: 'ar 2/17/1999 05:30'!wantsSteps	^true! !!B3DShaderPlugin methodsFor: 'primitives' stamp: 'ar 2/17/1999 04:31'!b3dShadeVertexBuffer	"Primitive. Shade all the vertices in the vertex buffer using the given array of primitive light sources. Return true on success."	| lightArray vtxCount vtxArray lightCount |	self export: true.	self inline: false.	self var: #vtxArray declareC:'float *vtxArray'.	vbFlags _ interpreterProxy stackIntegerValue: 0.	pMaterial _ self stackMaterialValue: 1.	lightArray _ self stackLightArrayValue: 2.	vtxCount _ interpreterProxy stackIntegerValue: 3.	vtxArray _ self stackPrimitiveVertexArray: 4 ofSize: vtxCount.	(vtxArray = nil or:[pMaterial = nil or:[interpreterProxy failed]])		ifTrue:[^interpreterProxy primitiveFail].	"Setup"	litVertex _ vtxArray.	lightCount _ interpreterProxy slotSizeOf: lightArray.	"Go over all vertices"	1 to: vtxCount do:[:i|		"Load the primitive vertex"		self loadPrimitiveVertex.		"Load initial color (e.g., emissive part of vertex and/or material)"		(vbFlags anyMask: VBTrackEmission) ifTrue:[			"Load color from vertex"			pOutColor at: 0 put: (pInColor at: 0) + (pMaterial at: EmissionRed).			pOutColor at: 1 put: (pInColor at: 1) + (pMaterial at: EmissionGreen).			pOutColor at: 2 put: (pInColor at: 2) + (pMaterial at: EmissionBlue).			pOutColor at: 3 put: (pInColor at: 3) + (pMaterial at: EmissionAlpha).		] ifFalse:[			pOutColor at: 0 put: (pMaterial at: EmissionRed).			pOutColor at: 1 put: (pMaterial at: EmissionGreen).			pOutColor at: 2 put: (pMaterial at: EmissionBlue).			pOutColor at: 3 put: (pMaterial at: EmissionAlpha).		].		"For each enabled light source"		0 to: lightCount-1 do:[:j|			"Fetch the light source"			pLight _ self fetchLightSource: j ofObject: lightArray.			"Setup values"			self loadPrimitiveLightSource.			"Compute the color from the light source"			self shadeVertex.		].		"Store the computed color back"		self storePrimitiveVertex.		"And step on to the next vertex"		litVertex _ litVertex + PrimVertexSize.	].	"Clean up stack"	interpreterProxy pop: 6. "Pop args+rcvr"	interpreterProxy pushBool: true.! !!B3DShaderPlugin methodsFor: 'primitives' stamp: 'ar 2/17/1999 04:32'!b3dShaderVersion	"Return the current shader version."	self export: true.	self inline: false.	interpreterProxy pop: 1.	interpreterProxy pushInteger: 1.	"Version 1"! !!B3DTransformerPlugin methodsFor: 'primitives' stamp: 'ar 2/17/1999 04:31'!b3dTransformerVersion	"Return the current version of the transformer"	self export: true.	self inline: false.	interpreterProxy pop: 1.	interpreterProxy pushInteger: 1.	"Version 1"! !!B3DVertexBufferPlugin methodsFor: 'primitives' stamp: 'ar 2/17/1999 04:30'!b3dLoadVertexBuffer	"Primitive. Load the data into the given vertex buffer.	NOTE: dstStart is a zero-based index."	| defaultVtx defaultNormal defaultTexCoords defaultColor count texPtr colorPtr normalPtr vtxPtr dstStart dstPtr pVtx |	self export: true.	self inline: false.	self var: #defaultVtx declareC:'int *defaultVtx'.	self var: #defaultNormal declareC:'int *defaultNormal'.	self var: #defaultTexCoords declareC:'int *defaultTexCoords'.	self var: #defaultColor declareC:'int *defaultColor'.	self var: #texPtr declareC:'int *texPtr'.	self var: #colorPtr declareC:'int *colorPtr'.	self var: #normalPtr declareC:'int *normalPtr'.	self var: #vtxPtr declareC:'int *vtxPtr'.	self var: #dstPtr declareC:'int *dstPtr'.	self var: #pVtx declareC:'int *pVtx'.	defaultVtx _ self stackPrimitiveVertex: 0.	count _ interpreterProxy stackIntegerValue: 1.	texPtr _ self vbLoadArray: (interpreterProxy stackObjectValue: 2) 				size: 2*count.	colorPtr _ self vbLoadArray: (interpreterProxy stackObjectValue: 3) 				size: count.	normalPtr _ self vbLoadArray: (interpreterProxy stackObjectValue: 4) 				size: 3*count.	vtxPtr _ self vbLoadArray: (interpreterProxy stackObjectValue: 5) 				size: 3*count.	dstStart _ interpreterProxy stackIntegerValue: 6.	dstPtr _ self stackPrimitiveVertexArray: 7 ofSize: dstStart + count.	"Check for all problems above"	(dstPtr = nil or:[defaultVtx == nil or:[interpreterProxy failed]]) 		ifTrue:[^interpreterProxy primitiveFail].	"Install default values"	normalPtr = nil		ifTrue:[defaultNormal _ defaultVtx + PrimVtxNormal]		ifFalse:[defaultNormal _ normalPtr].	texPtr = nil		ifTrue:[defaultTexCoords _ defaultVtx + PrimVtxTexCoords]		ifFalse:[defaultTexCoords _ texPtr].	colorPtr = nil		ifTrue:[defaultColor _ defaultVtx + PrimVtxColor32]		ifFalse:[defaultColor _ colorPtr].	"Do the actual stuff"	pVtx _ dstPtr + (dstStart * PrimVertexSize).	0 to: count-1 do:[:i|		pVtx at: PrimVtxPositionX put: (vtxPtr at: 0).		pVtx at: PrimVtxPositionY put: (vtxPtr at: 1).		pVtx at: PrimVtxPositionZ put: (vtxPtr at: 2).		pVtx at: PrimVtxNormalX put: (defaultNormal at: 0).		pVtx at: PrimVtxNormalY put: (defaultNormal at: 1).		pVtx at: PrimVtxNormalZ put: (defaultNormal at: 2).		pVtx at: PrimVtxColor32 put: (defaultColor at: 0).		pVtx at: PrimVtxTexCoordU put: (defaultTexCoords at: 0).		pVtx at: PrimVtxTexCoordV put: (defaultTexCoords at: 1).		"And go to the next vertex"		pVtx _ pVtx + PrimVertexSize.		vtxPtr _ vtxPtr + 3.		normalPtr = nil ifFalse:[defaultNormal _ defaultNormal + 3].		colorPtr = nil ifFalse:[defaultColor _ defaultColor + 1].		texPtr = nil ifFalse:[defaultTexCoords _ defaultTexCoords + 2].	].	"Clean up stack"	interpreterProxy pop: 8. "Pop args+rcvr"	interpreterProxy pushInteger: count.! !!B3DVertexShader methodsFor: 'initialize' stamp: 'ar 2/17/1999 04:17'!initialize	super initialize.	lights _ OrderedCollection new.	material _ B3DMaterial new.	materialStack _ OrderedCollection new: 10.! !!B3DVertexShader methodsFor: 'shading' stamp: 'ar 2/17/1999 04:12'!processVertexBuffer: vb	| colors emissionPart |	colors _ B3DColor4Array new: vb vertexCount.	"Load initial colors (e.g., emission part)"	vb trackEmissionColor ifFalse:[		emissionPart _ material emission.		1 to: vb vertexCount do:[:i| colors at: i put: emissionPart].	] ifTrue:[		1 to: vb vertexCount do:[:i| colors at: i put: (vb primitiveVertexAt: i) b3dColor].	].	lights do:[:light|		light key shadeVertexBuffer: vb with: material into: colors.	].	colors clampAllFrom: 0.0 to: 1.0.	vb vertexArray upTo: vb vertexCount doWithIndex:[:vtx :i| vtx color: (colors at: i)].! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 2/17/1999 04:14'!addLight: aLightSource	lights add: aLightSource.	^lights size! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 2/17/1999 04:16'!removeLight: lightIndex	"Remove the light with the given index"	(lightIndex < 1 or:[lightIndex > lights size]) ifTrue:[^nil].	lights at: lightIndex put: nil. "So we don't change the indexes"! !!B3DPrimitiveShader commentStamp: 'ar 2/17/1999 04:26' prior: 0!I am a shader that uses primitive level support.NOTE: Currently, primitive and non-primitive lights cannot be mixed.!!B3DPrimitiveShader methodsFor: 'initialize' stamp: 'ar 2/17/1999 04:17'!initialize	super initialize.	primitiveLights _ #().! !!B3DPrimitiveShader methodsFor: 'accessing' stamp: 'ar 2/17/1999 04:14'!addLight: aLightSource	"NOTE: This does not work if primitive/non-primitive lights are mixed!!"	| primLight |	self flag: #b3dBug. "See above"	primLight _ aLightSource asPrimitiveLight.	primLight ifNotNil:[primitiveLights _ primitiveLights copyWith: primLight].	^super addLight: aLightSource! !!B3DPrimitiveShader methodsFor: 'accessing' stamp: 'ar 2/17/1999 04:17'!removeLight: lightIndex	| pLight |	super removeLight: lightIndex.	self flag: #b3dBug. 	"There should be a better way then doing this."	primitiveLights _ #().	lights do:[:light| 		light ifNotNil:[pLight _ light asPrimitiveLight].		pLight ifNotNil:[primitiveLights _ primitiveLights copyWith: pLight]].! !!B3DPrimitiveShader methodsFor: 'shading' stamp: 'ar 2/17/1999 04:10'!primShadeVB: vertexArray count: vtxCount lights: lightArray material: aMaterial vbFlags: vbFlags	"Primitive. Shade all the vertices in the vertex buffer using the given array of primitive light sources. Return true on success, false otherwise."	<primitive: 'b3dShadeVertexBuffer' module:'Squeak3D'>	self flag: #b3dDebug. self primitiveFailed.	^false! !!B3DPrimitiveShader methodsFor: 'shading' stamp: 'ar 2/17/1999 04:11'!processVertexBuffer: vb	"Do the primitive operation"	(self primShadeVB: vb vertexArray 				count: vb vertexCount 				lights: primitiveLights 				material: material 				vbFlags: vb flags) ifTrue:[^self].	"Run simulation instead"	super processVertexBuffer: vb.! !!B3DPrimitiveShader class methodsFor: 'accessing' stamp: 'ar 2/17/1999 04:09'!version	"Return the version of this shader"	<primitive:'b3dShaderVersion' module:'Squeak3D'>	^0! !!B3DPrimitiveShader class methodsFor: 'testing' stamp: 'ar 2/17/1999 04:08'!isAvailable	^self version > 0! !!B3DVertexTransformer methodsFor: 'private-transforming' stamp: 'ar 2/17/1999 04:19'!privateTransformMatrix: m1 with: m2 into: m3	"Perform a 4x4 matrix multiplication		m2 * m1 = m3	being equal to first transforming points by m2 and then by m1.	Note that m1 may be identical to m3."	| c1 c2 c3 c4 |	m2 == m3 ifTrue:[^self error:'Argument and result matrix identical'].	c1 _ ((m1 a11 * m2 a11) + (m1 a12 * m2 a21) + 				(m1 a13 * m2 a31) + (m1 a14 * m2 a41)).	c2 _ ((m1 a11 * m2 a12) + (m1 a12 * m2 a22) + 				(m1 a13 * m2 a32) + (m1 a14 * m2 a42)).	c3 _ ((m1 a11 * m2 a13) + (m1 a12 * m2 a23) + 				(m1 a13 * m2 a33) + (m1 a14 * m2 a43)).	c4 _ ((m1 a11 * m2 a14) + (m1 a12 * m2 a24) + 				(m1 a13 * m2 a34) + (m1 a14 * m2 a44)).	m3 a11: c1; a12: c2; a13: c3; a14: c4.	c1 _ ((m1 a21 * m2 a11) + (m1 a22 * m2 a21) + 				(m1 a23 * m2 a31) + (m1 a24 * m2 a41)).	c2 _ ((m1 a21 * m2 a12) + (m1 a22 * m2 a22) + 				(m1 a23 * m2 a32) + (m1 a24 * m2 a42)).	c3 _ ((m1 a21 * m2 a13) + (m1 a22 * m2 a23) + 				(m1 a23 * m2 a33) + (m1 a24 * m2 a43)).	c4 _ ((m1 a21 * m2 a14) + (m1 a22 * m2 a24) + 				(m1 a23 * m2 a34) + (m1 a24 * m2 a44)).	m3 a21: c1; a22: c2; a23: c3; a24: c4.	c1 _ ((m1 a31 * m2 a11) + (m1 a32 * m2 a21) + 				(m1 a33 * m2 a31) + (m1 a34 * m2 a41)).	c2 _ ((m1 a31 * m2 a12) + (m1 a32 * m2 a22) + 				(m1 a33 * m2 a32) + (m1 a34 * m2 a42)).	c3 _ ((m1 a31 * m2 a13) + (m1 a32 * m2 a23) + 				(m1 a33 * m2 a33) + (m1 a34 * m2 a43)).	c4 _ ((m1 a31 * m2 a14) + (m1 a32 * m2 a24) + 				(m1 a33 * m2 a34) + (m1 a34 * m2 a44)).	m3 a31: c1; a32: c2; a33: c3; a34: c4.	c1 _ ((m1 a41 * m2 a11) + (m1 a42 * m2 a21) + 				(m1 a43 * m2 a31) + (m1 a44 * m2 a41)).	c2 _ ((m1 a41 * m2 a12) + (m1 a42 * m2 a22) + 				(m1 a43 * m2 a32) + (m1 a44 * m2 a42)).	c3 _ ((m1 a41 * m2 a13) + (m1 a42 * m2 a23) + 				(m1 a43 * m2 a33) + (m1 a44 * m2 a43)).	c4 _ ((m1 a41 * m2 a14) + (m1 a42 * m2 a24) + 				(m1 a43 * m2 a34) + (m1 a44 * m2 a44)).	m3 a41: c1; a42: c2; a43: c3; a44: c4.! !!B3DVertexTransformer methodsFor: 'private-transforming' stamp: 'ar 2/17/1999 04:20'!privateTransformPrimitiveNormal: primitiveVertex byMatrix: aMatrix rescale: scaleNeeded	| x y z rx ry rz dot |	x _ primitiveVertex normalX.	y _ primitiveVertex normalY.	z _ primitiveVertex normalZ.	rx := (x * aMatrix a11) + (y * aMatrix a12) + (z * aMatrix a13).	ry := (x * aMatrix a21) + (y * aMatrix a22) + (z * aMatrix a23).	rz := (x * aMatrix a31) + (y * aMatrix a32) + (z * aMatrix a33).	scaleNeeded ifTrue:[		dot _ (rx * rx) + (ry * ry) + (rz * rz).		dot < 1.0e-20 ifTrue:[			rx _ ry _ rz _ 0.0.		] ifFalse:[			dot = 1.0 ifFalse:[				dot _ 1.0 / dot sqrt.				rx _ rx * dot.				ry _ ry * dot.				rz _ rz * dot.			].		].	].	primitiveVertex normalX: rx.	primitiveVertex normalY: ry.	primitiveVertex normalZ: rz.! !!B3DVertexTransformer methodsFor: 'private-transforming' stamp: 'ar 2/17/1999 04:20'!privateTransformPrimitiveVertex: primitiveVertex byModelView: aMatrix	| x y z rx ry rz rw oneOverW |	x _ primitiveVertex positionX.	y _ primitiveVertex positionY.	z _ primitiveVertex positionZ.	rx := (x * aMatrix a11) + (y * aMatrix a12) + (z * aMatrix a13) + aMatrix a14.	ry := (x * aMatrix a21) + (y * aMatrix a22) + (z * aMatrix a23) + aMatrix a24.	rz := (x * aMatrix a31) + (y * aMatrix a32) + (z * aMatrix a33) + aMatrix a34.	rw := (x * aMatrix a41) + (y * aMatrix a42) + (z * aMatrix a43) + aMatrix a44.	rw = 1.0 ifTrue:[		primitiveVertex positionX: rx.		primitiveVertex positionY: ry.		primitiveVertex positionZ: rz.	] ifFalse:[		rw = 0.0 			ifTrue:[oneOverW _ 0.0]			ifFalse:[oneOverW _ 1.0 / rw].		primitiveVertex positionX: rx * oneOverW.		primitiveVertex positionY: ry * oneOverW.		primitiveVertex positionZ: rz * oneOverW.	].! !!B3DVertexTransformer methodsFor: 'private-transforming' stamp: 'ar 2/17/1999 04:21'!privateTransformPrimitiveVertex: primitiveVertex byProjection: aMatrix	| x y z rx ry rz rw |	x _ primitiveVertex positionX.	y _ primitiveVertex positionY.	z _ primitiveVertex positionZ.	rx := (x * aMatrix a11) + (y * aMatrix a12) + (z * aMatrix a13) + aMatrix a14.	ry := (x * aMatrix a21) + (y * aMatrix a22) + (z * aMatrix a23) + aMatrix a24.	rz := (x * aMatrix a31) + (y * aMatrix a32) + (z * aMatrix a33) + aMatrix a34.	rw := (x * aMatrix a41) + (y * aMatrix a42) + (z * aMatrix a43) + aMatrix a44.	primitiveVertex rasterPosX: rx.	primitiveVertex rasterPosY: ry.	primitiveVertex rasterPosZ: rz.	primitiveVertex rasterPosW: rw.! !!B3DVertexTransformer methodsFor: 'private-transforming' stamp: 'ar 2/17/1999 04:22'!privateTransformVB: vertexArray count: vertexCount modelViewMatrix: modelViewMatrix projectionMatrix: projectionMatrix flags: flags	| noW |	(modelViewMatrix a41 = 0.0 and:[		modelViewMatrix a42 = 0.0 and:[			modelViewMatrix a43 = 0.0 and:[				modelViewMatrix a44 = 1.0]]]) ifTrue:[noW _ true].	noW ifTrue:[		vertexArray upTo: vertexCount do:[:primitiveVertex|			self privateTransformPrimitiveVertex: primitiveVertex				byModelViewWithoutW: modelViewMatrix.			self privateTransformPrimitiveVertex: primitiveVertex				byProjection: projectionMatrix.			(flags anyMask: VBVtxHasNormals)				ifTrue:[self privateTransformPrimitiveNormal: primitiveVertex							byMatrix: modelViewMatrix							rescale: true].		].	] ifFalse:[		vertexArray upTo: vertexCount do:[:primitiveVertex|			self privateTransformPrimitiveVertex: primitiveVertex				byModelView: modelViewMatrix.			self privateTransformPrimitiveVertex: primitiveVertex				byProjection: projectionMatrix.			(flags anyMask: VBVtxHasNormals)				ifTrue:[self privateTransformPrimitiveNormal: primitiveVertex							byMatrix: modelViewMatrix							rescale: true].		].	].! !!B3DPrimitiveTransformer commentStamp: 'ar 2/17/1999 04:26' prior: 0!I am a vertex transformer that uses some primitive level support.!!B3DPrimitiveTransformer methodsFor: 'private-transforming' stamp: 'ar 2/17/1999 04:19'!privateTransformMatrix: m1 with: m2 into: m3	"Use the primitive operation"	<primitive: 'b3dTransformMatrixWithInto' module:'Squeak3D'>	^super privateTransformMatrix: m1 with: m2 into: m3! !!B3DPrimitiveTransformer methodsFor: 'private-transforming' stamp: 'ar 2/17/1999 04:20'!privateTransformPrimitiveNormal: primitiveVertex byMatrix: aMatrix rescale: scaleNeeded	"Use the primitive operation"	<primitive: 'b3dTransformPrimitiveNormal' module:'Squeak3D'>	^super privateTransformPrimitiveNormal: primitiveVertex byMatrix: aMatrix rescale: scaleNeeded! !!B3DPrimitiveTransformer methodsFor: 'private-transforming' stamp: 'ar 2/17/1999 04:20'!privateTransformPrimitiveVertex: primitiveVertex byModelView: aMatrix	"Use the primitive operation"	<primitive: 'b3dTransformPrimitivePosition' module:'Squeak3D'>	^super privateTransformPrimitiveVertex: primitiveVertex byModelView: aMatrix! !!B3DPrimitiveTransformer methodsFor: 'private-transforming' stamp: 'ar 2/17/1999 04:21'!privateTransformPrimitiveVertex: primitiveVertex byProjection: aMatrix	"Use the primitive operation"	<primitive: 'b3dTransformPrimitiveRasterPosition' module:'Squeak3D'>	^super privateTransformPrimitiveVertex: primitiveVertex byProjection: aMatrix! !!B3DPrimitiveTransformer methodsFor: 'private-transforming' stamp: 'ar 2/17/1999 04:21'!privateTransformVB: vertexArray count: vertexCount modelViewMatrix: modelViewMatrix projectionMatrix: projectionMatrix flags: flags	"Use the primitive operation"	<primitive: 'b3dTransformVertexBuffer' module:'Squeak3D'>	^super privateTransformVB: vertexArray count: vertexCount modelViewMatrix: modelViewMatrix projectionMatrix: projectionMatrix flags: flags! !!B3DPrimitiveTransformer class methodsFor: 'accessing' stamp: 'ar 2/17/1999 04:29'!version	"Return the version of this transformer"	<primitive:'b3dTransformerVersion' module:'Squeak3D'>	^0! !!B3DPrimitiveTransformer class methodsFor: 'testing' stamp: 'ar 2/17/1999 04:22'!isAvailable	^self version > 0! !!FileList methodsFor: 'file list menu' stamp: 'ar 2/17/1999 05:55'!open3DSFile	"Open a MoviePlayerMorph on the given file (must be in .3ds format)."	| scene |	scene _ (ThreeDSParser parseFileNamed: self fullName).	Smalltalk isMorphic ifTrue:[		(OSMesaRasterizer isAvailableFor: Display) ifFalse:[			(self confirm:'WARNING: YOU HAVE NO REAL SUPPORT FOR 3D!!Opening this guy in Morphic will EXTREMELY time consuming.Are you sure you want to do this?!!(NO is probably the right answer :-)') ifFalse:[^scene inspect]].		scene defaultCamera moveToFit: scene.		(B3DSceneMorph new scene: scene) openInWorld.	] ifFalse:[scene inspect].! !B3DMorph removeSelector: #asB3DScene!B3DNullRasterizer class removeSelector: #isAvailableFor:!B3DVertexClipper class removeSelector: #isAvailableFor:!B3DVertexShader removeSelector: #primShadeVB:count:lights:material:vbFlags:!B3DVertexShader class removeSelector: #isAvailableFor:!B3DVertexTransformer class removeSelector: #isAvailableFor:!