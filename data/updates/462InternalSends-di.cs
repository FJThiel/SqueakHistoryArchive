'From Squeak 2.3 beta of Nov 25, 1998 on 5 December 1998 at 1:13:34 pm'!"Change Set:		InternalSendsDate:			4 December 1998Author:			Dan IngallsThis set of changes allows message activation to take place in the inner interpreter, using IP and SP as registers.NOTE: These changes were developed together with several others and so may not work in isolation."!!Interpreter methodsFor: 'contexts' stamp: 'di 12/3/1998 15:55'!internalNewActiveContext: aContext	"The only difference between this method and newActiveContext: is that this method uses internal context registers."	self inline: true.	self internalStoreContextRegisters: activeContext.	(aContext < youngStart) ifTrue: [ self beRootIfOld: aContext ].	activeContext _ aContext.	self internalFetchContextRegisters: aContext.! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/3/1998 22:57'!internalStoreContextRegisters: activeCntx	"The only difference between this method and fetchContextRegisters: is that this method stores from the local IP and SP."	"InstructionPointer is a pointer variable equal to	method oop + ip + BaseHeaderSize		-1 for 0-based addressing of fetchByte		-1 because it gets incremented BEFORE fetching currentByte"	self inline: true.	self storeWord: InstructionPointerIndex ofObject: activeCntx		withValue: (self integerObjectOf: 			(localIP asInteger + 2 - (method + BaseHeaderSize))).	self storeWord: StackPointerIndex		  ofObject: activeCntx		withValue: (self integerObjectOf:			(((localSP asInteger - (activeCntx + BaseHeaderSize)) >> 2) - TempFrameStart + 1)).! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/3/1998 15:51'!newActiveContext: aContext	"Note: internalNewActiveContext: should track changes to this method."	self storeContextRegisters: activeContext.	(aContext < youngStart) ifTrue: [ self beRootIfOld: aContext ].	activeContext _ aContext.	self fetchContextRegisters: aContext.! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/3/1998 13:39'!storeContextRegisters: activeCntx	"Note: internalStoreContextRegisters: should track changes to this method."	"InstructionPointer is a pointer variable equal to	method oop + ip + BaseHeaderSize		-1 for 0-based addressing of fetchByte		-1 because it gets incremented BEFORE fetching currentByte"	self inline: true.	self storeWord: InstructionPointerIndex ofObject: activeCntx		withValue: (self integerObjectOf: 			(instructionPointer - method - (BaseHeaderSize - 2))).	self storeWord: StackPointerIndex		  ofObject: activeCntx		withValue: (self integerObjectOf:			(self stackPointerIndex - TempFrameStart + 1)).! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/4/1998 00:49'!activateNewMethod	| newContext methodHeader initialIP tempCount nilOop |	methodHeader _ self headerOf: newMethod.	newContext _ self allocateOrRecycleContext.	initialIP _		((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _		(methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	0 to: argumentCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self stackValue: argumentCount-i)].	"clear remaining temps to nil in case it has been recycled"	nilOop _ nilObj.	argumentCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: nilOop].	self pop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self newActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/3/1998 23:30'!executeNewMethod	self inline: true.	primitiveIndex > 0		ifTrue: [self primitiveResponse ifTrue: [^ nil]].	"if not primitive, or primitive failed, activate the method"	self activateNewMethod.	"check for possible interrupts at each real send"	self quickCheckForInterrupts.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/3/1998 23:41'!findNewMethodInClass: class	"Find the compiled method to be run when the current messageSelector is sent to the given class, setting the values of 'newMethod' and 'primitiveIndex'."	| ok |	self inline: false.	ok _ self lookupInMethodCacheSel: messageSelector class: class.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self lookupMethodInClass: class.		primitiveIndex _ self primitiveIndexOf: newMethod.		self addToMethodCacheSel: messageSelector			class: class			method: newMethod			primIndex: primitiveIndex.	].! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/4/1998 00:53'!internalActivateNewMethod	| newContext methodHeader initialIP tempCount nilOop |	self inline: true.	methodHeader _ self headerOf: newMethod.	newContext _ self internalAllocateOrRecycleContext.	initialIP _		((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _		(methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	0 to: argumentCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self internalStackValue: argumentCount-i)].	"clear remaining temps to nil in case it has been recycled"	nilOop _ nilObj.	argumentCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: nilOop].	self internalPop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self internalNewActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/4/1998 03:15'!internalExecuteNewMethod	self inline: true.	primitiveIndex > 0		ifTrue: [(primitiveIndex > 255 and: [primitiveIndex < 520])				ifTrue: ["Internal return instvars"						primitiveIndex >= 264						ifTrue:						[^ self internalPop: 1 thenPush:								(self fetchPointer: primitiveIndex-264										ofObject: self internalStackTop)]						ifFalse:						["Internal return constants"						primitiveIndex = 256 ifTrue: [^ nil "^ self"].						primitiveIndex = 257 ifTrue: [^ self internalPop: 1 thenPush: trueObj].						primitiveIndex = 258 ifTrue: [^ self internalPop: 1 thenPush: falseObj].						primitiveIndex = 259 ifTrue: [^ self internalPop: 1 thenPush: nilObj].						^ self internalPop: 1 thenPush: (self integerObjectOf: primitiveIndex-261)]]				ifFalse: 	[self externalizeIPandSP.						self primitiveResponse ifTrue: [self internalizeIPandSP. ^ nil].						self internalizeIPandSP]].	"if not primitive, or primitive failed, activate the method"	self internalActivateNewMethod.	"check for possible interrupts at each real send"	self internalQuickCheckForInterrupts.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/3/1998 23:31'!internalFindNewMethodInClass: class	"Find the compiled method to be run when the current messageSelector is sent to the given class, setting the values of 'newMethod' and 'primitiveIndex'."	| ok |	self inline: true.	ok _ self lookupInMethodCacheSel: messageSelector class: class.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self externalizeIPandSP.		self lookupMethodInClass: class.		self internalizeIPandSP.		primitiveIndex _ self primitiveIndexOf: newMethod.		self addToMethodCacheSel: messageSelector			class: class			method: newMethod			primIndex: primitiveIndex.	].! !!Interpreter methodsFor: 'message sending' stamp: 'jm 9/24/97 22:52'!lookupMethodInClass: class	| currentClass dictionary found rclass |	currentClass _ class.	[currentClass ~= nilObj]		whileTrue:		[dictionary _ self fetchPointer: MessageDictionaryIndex ofObject: currentClass.		found _ self lookupMethodInDictionary: dictionary.		found ifTrue: [^ currentClass].		currentClass _ self superclassOf: currentClass].	messageSelector = (self splObj: SelectorDoesNotUnderstand) ifTrue:		[self error: 'Recursive not understood error encountered'].	self pushRemappableOop: class.	self createActualMessage.  "may cause GC!!"	rclass _ self popRemappableOop.	messageSelector _ self splObj: SelectorDoesNotUnderstand.	^ self lookupMethodInClass: rclass! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/3/1998 23:37'!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| rcvrClass |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: 131.	rcvrClass _ self fetchClassOf: (self internalStackValue: argumentCount).	self internalFindNewMethodInClass: rcvrClass.	self internalExecuteNewMethod.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/3/1998 23:35'!sendSelectorToClass: classPointer	"Note: Requires that instructionPointer and stackPointer be externalized."	self inline: true.	self internalFindNewMethodInClass: classPointer.	self internalExecuteNewMethod.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/3/1998 23:38'!superclassSend	"Send a message to self, starting lookup with the superclass of the class containing the currently executing method."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| superClass |	self inline: true.	self sharedCodeNamed: 'commonSupersend' inCase: 133.	superClass _ self superclassOf: (self methodClassOf: method).	self internalFindNewMethodInClass: superClass.	self internalExecuteNewMethod.! !!Interpreter methodsFor: 'send bytecodes' stamp: 'di 12/3/1998 12:52'!sendLiteralSelectorBytecode	"Can use any of the first 16 literals for the selector and pass up to 2 arguments."	messageSelector _ self literal: (currentBytecode bitAnd: 16rF).	argumentCount _ ((currentBytecode >> 4) bitAnd: 3) - 1.	self normalSend."Note - if you ever want to try inlining these, the following will produce the code to paste into interp.c -- I found it actually slowed things down (cache size effect?).String streamContents:	[:s | 208 to: 255 do:		[:i | s tab; tab; nextPutAll: 'case ', i printString, ':'; cr.		s tab; tab; tab; nextPutAll: 'messageSelector = longAt(((char *) method) + 4 + ';			print: ((i bitAnd: 15) + 1) << 2; nextPutAll: ');'; cr.		s tab; tab; tab; nextPutAll: 'argumentCount = ';			print: (i >> 4 bitAnd: 3) - 1; nextPutAll: ';'; cr.		s tab; tab; tab; nextPutAll: 'goto commonSend;'; cr.		s tab; tab; tab; nextPutAll: 'break;'; cr; cr]]"! !!Interpreter methodsFor: 'return bytecodes' stamp: 'di 12/4/1998 01:02'!returnValue: resultObj to: returnContext	"Note: Assumed to be inlined into the dispatch loop."	| nilOop thisCntx contextOfCaller |	self inline: true.	self sharedCodeNamed: 'commonReturn' inCase: 120.	nilOop _ nilObj. "keep in a register"	thisCntx _ activeContext.	"make sure we can return to the given context"	((returnContext = nilOop) or:	 [(self fetchPointer: InstructionPointerIndex ofObject: returnContext) = nilOop]) ifTrue: [		"error: sender's instruction pointer or context is nil; cannot return"		self internalPush: activeContext.		self internalPush: resultObj.		messageSelector _ self splObj: SelectorCannotReturn.		argumentCount _ 1.		^ self normalSend	].	[thisCntx = returnContext] whileFalse: [		"climb up stack to returnContext"		contextOfCaller _ self fetchPointer: SenderIndex ofObject: thisCntx.		"zap exited contexts so any future attempted use will be caught"		self storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.		self storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.		reclaimableContextCount > 0 ifTrue: [			"try to recycle this context"			reclaimableContextCount _ reclaimableContextCount - 1.			self recycleContextIfPossible: thisCntx.		].		thisCntx _ contextOfCaller.	].	activeContext _ thisCntx.	(thisCntx < youngStart) ifTrue: [ self beRootIfOld: thisCntx ].	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"	self internalPush: resultObj.	"self internalQuickCheckForInterrupts."! !!Interpreter methodsFor: 'primitive support' stamp: 'di 12/5/1998 12:09'!primitiveResponse	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| startTime |	successFlag _ true.	nextWakeupTick = 0 ifTrue:		[self dispatchOn: primitiveIndex in: PrimitiveTable.		^ successFlag].	startTime _ self ioLowResMSecs.	self dispatchOn: primitiveIndex in: PrimitiveTable.	self ioLowResMSecs ~= startTime ifTrue:		["primitive ran for more than a tick; check for possible timer interrupts"		((self ioMSecs bitAnd: 16r1FFFFFFF) >= nextWakeupTick) ifTrue: [			successFlag				ifTrue: ["process the interrupt now"						self checkForInterrupts]				ifFalse: ["process the interrupt in primtive failure code"						interruptCheckCounter _ 0]]].	^ successFlag! !!Interpreter methodsFor: 'control primitives' stamp: 'di 12/3/1998 23:41'!primitivePerform	| performSelector newReceiver selectorIndex |	performSelector _ messageSelector.	messageSelector _ self stackValue: argumentCount - 1.	newReceiver _ self stackValue: argumentCount.	"NOTE: the following lookup may fail and be converted to #doesNotUnderstand:,		so we must adjust argument count now, so that would work."	argumentCount _ argumentCount - 1.	self findNewMethodInClass: (self fetchClassOf: newReceiver).	self success: (self argumentCountOf: newMethod) = argumentCount.	successFlag		ifTrue: [selectorIndex _ self stackPointerIndex - argumentCount.				self transfer: argumentCount					fromIndex: selectorIndex + 1					ofObject: activeContext					toIndex: selectorIndex					ofObject: activeContext.				self pop: 1.				self executeNewMethod.  "Recursive xeq affects successFlag"				successFlag _ true]		ifFalse: [argumentCount _ argumentCount + 1.				messageSelector _ performSelector]! !!Interpreter methodsFor: 'control primitives' stamp: 'di 12/3/1998 23:59'!primitivePerformWithArgs	| thisReceiver performSelector argumentArray arraySize index cntxSize |	argumentArray _ self popStack.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ self fetchWordLengthOf: activeContext.	self success: (self stackPointerIndex + arraySize) < cntxSize.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	successFlag		ifTrue: [performSelector _ messageSelector.				messageSelector _ self popStack.				thisReceiver _ self stackTop.				argumentCount _ arraySize.				index _ 1.				[index <= argumentCount]					whileTrue:					[self push: (self fetchPointer: index - 1 ofObject: argumentArray).					index _ index + 1].				self findNewMethodInClass: (self fetchClassOf: thisReceiver).				self success: (self argumentCountOf: newMethod) = argumentCount.				successFlag					ifTrue: [self executeNewMethod.  "Recursive xeq affects successFlag"							successFlag _ true]					ifFalse: [self pop: argumentCount.							self push: messageSelector.							self push: argumentArray.							argumentCount _ 2.							messageSelector _ performSelector]]	ifFalse: [self unPop: 1]! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 12/3/1998 15:29'!findNewMethodInClass: class"	| cName |	traceOn ifTrue:		[cName _ (self sizeBitsOf: class) = 16r20			ifTrue: ['class ' , (self nameOfClass: (self fetchPointer: 6 ofObject: class))]			ifFalse: [(self nameOfClass: class)].		self cr; print: cName , '>>' , (self stringOf: messageSelector)].""(self stringOf: messageSelector) = 'doesNotUnderstand:' ifTrue: [self halt]."	sendCount _ sendCount + 1."	(sendCount > 1000 and: [sendCount\\10 = 0]) ifTrue:		[Transcript print: sendCount; space.		self validate].""	(sendCount > 100150) ifTrue:		[self qvalidate.		messageQueue == nil ifTrue: [messageQueue _ OrderedCollection new].		messageQueue addLast: (self stringOf: messageSelector)]."	super findNewMethodInClass: class.! !Interpreter removeSelector: #failSpecialPrim:!