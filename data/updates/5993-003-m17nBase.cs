Object subclass: #EncodedCharSet	instanceVariableNames: ''	classVariableNames: 'EncodedCharSets '	poolDictionaries: ''	category: 'Multilingual-Encodings'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EncodedCharSet class	instanceVariableNames: 'CompoundTextSequence '!!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 8/5/2003 16:55'!canBeGlobalVarInitial: char	| leadingChar |	leadingChar _ char leadingChar.	leadingChar = 0 ifTrue: [^ self isUppercase: char].	^ self isLetter: char.! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 8/5/2003 17:18'!canBeNonGlobalVarInitial: char	| leadingChar |	leadingChar _ char leadingChar.	leadingChar = 0 ifTrue: [^ self isLowercase: char].	^ self isLetter: char.! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 10/14/2003 16:27'!charFromUnicode: unicode	| table index |	unicode < 256 ifTrue: [^ Character value: unicode].	table _ self ucsTable.	index _ table indexOf: unicode.	index = 0 ifTrue: [		^ nil.	].	^ MultiCharacter leadingChar: self leadingChar code: index - 1.! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 12/1/2003 19:29'!digitValue: char	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 	otherwise. This is used to parse literal numbers of radix 2-36."	| value |	value _ char charCode.	value <= $9 asciiValue 		ifTrue: [^value - $0 asciiValue].	value >= $A asciiValue 		ifTrue: [value <= $Z asciiValue ifTrue: [^value - $A asciiValue + 10]].	^ -1! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 12/27/2002 05:48'!encodedCharSets	^ EncodedCharSets! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 8/18/2003 18:40'!initialize"	self initialize"	self allSubclassesDo: [:each | each initialize].	EncodedCharSets _ Array new: 256.	EncodedCharSets at: 1 put: Latin1.	EncodedCharSets at: 2 put: JISX0208.	EncodedCharSets at: 3 put: GB2312.	EncodedCharSets at: 4 put: KSX1001.	EncodedCharSets at: 5 put: JISX0208.	EncodedCharSets at: 6 put: UnicodeJapanese.	EncodedCharSets at: 7 put: UnicodeSimplifiedChinese.	EncodedCharSets at: 8 put: UnicodeKorean.	EncodedCharSets at: 9 put: GB2312.	EncodedCharSets at: 10 put: UnicodeTraditionalChinese.	EncodedCharSets at: 11 put: UnicodeVietnamese.	EncodedCharSets at: 13 put: KSX1001.	EncodedCharSets at: 18 put: UnicodeLatinExtendedAB.	EncodedCharSets at: 19 put: UnicodeIPA.	EncodedCharSets at: 20 put: UnicodeSpacingModifiers.	EncodedCharSets at: 21 put: UnicodeCombiningDiacritical.	EncodedCharSets at: 22 put: UnicodeGreek.	EncodedCharSets at: 23 put: UnicodeCyrillic.	EncodedCharSets at: 24 put: UnicodeArmenian.	EncodedCharSets at: 25 put: UnicodeHebrew.	EncodedCharSets at: 26 put: UnicodeArabic.	EncodedCharSets at: 27 put: UnicodeSyriac.	EncodedCharSets at: 28 put: UnicodeThaana.	EncodedCharSets at: 29 put: UnicodeDevanagari.	EncodedCharSets at: 30 put: UnicodeBengali.	EncodedCharSets at: 31 put: UnicodeGurmukhi.	EncodedCharSets at: 32 put: UnicodeGujarati.	EncodedCharSets at: 33 put: UnicodeOriya.	EncodedCharSets at: 34 put: UnicodeTamil.	EncodedCharSets at: 35 put: UnicodeTelugu.	EncodedCharSets at: 36 put: UnicodeKannada.	EncodedCharSets at: 37 put: UnicodeMalayalam.	EncodedCharSets at: 38 put: UnicodeSinhala.	EncodedCharSets at: 39 put: UnicodeThai.	EncodedCharSets at: 40 put: UnicodeLao.	EncodedCharSets at: 41 put: UnicodeTibetan.	EncodedCharSets at: 42 put: UnicodeMyanmar.	EncodedCharSets at: 43 put: UnicodeGeorgian.	EncodedCharSets at: 44 put: UnicodeEthiopic.	EncodedCharSets at: 45 put: UnicodeCherokee.	EncodedCharSets at: 46 put: UnicodeCanadianAboriginal.	EncodedCharSets at: 47 put: UnicodeOgham.	EncodedCharSets at: 48 put: UnicodeRunic.	EncodedCharSets at: 49 put: UnicodeTagalog.	EncodedCharSets at: 50 put: UnicodeHanunoo.	EncodedCharSets at: 51 put: UnicodeBuhid.	EncodedCharSets at: 52 put: UnicodeTagbanwa.	EncodedCharSets at: 53 put: UnicodeKhmer.	EncodedCharSets at: 54 put: UnicodeMongolian.	EncodedCharSets at: 55 put: UnicodeLatinExtendedAdditional.	EncodedCharSets at: 56 put: UnicodeGreekExtended.	EncodedCharSets at: 57 put: UnicodeGeneralPunctuation.	EncodedCharSets at: 58 put: UnicodeSuperAndSubscript.	EncodedCharSets at: 59 put: UnicodeCurrencySymbols.	EncodedCharSets at: 60 put: UnicodeCombiningDiacriticalForSymbols.	EncodedCharSets at: 61 put: UnicodeLetterlikeSymbols.	EncodedCharSets at: 62 put: UnicodeNumberForms.	EncodedCharSets at: 63 put: UnicodeArrows.	EncodedCharSets at: 64 put: UnicodeMathOperators.	EncodedCharSets at: 65 put: UnicodeMiscTechnical.	EncodedCharSets at: 66 put: UnicodeControlPictures.	EncodedCharSets at: 67 put: UnicodeOCRs.	EncodedCharSets at: 68 put: UnicodeEnclosedAlnums.	EncodedCharSets at: 69 put: UnicodeBoxDrawing.	EncodedCharSets at: 70 put: UnicodeBlockElements.	EncodedCharSets at: 71 put: UnicodeGeometricShapes.	EncodedCharSets at: 72 put: UnicodeMiscSymbols.	EncodedCharSets at: 73 put: UnicodeDingbats.	EncodedCharSets at: 74 put: UnicodeMiscMathSymbolsA.	EncodedCharSets at: 75 put: UnicodeSupplementalArrowsA.	EncodedCharSets at: 76 put: UnicodeBraille.	EncodedCharSets at: 77 put: UnicodeSupplementalArrowsB.	EncodedCharSets at: 78 put: UnicodeMiscMathSymbolsB.	EncodedCharSets at: 79 put: UnicodeSupplementalMathOperators.	EncodedCharSets at: 80 put: UnicodeYiSyllables.	EncodedCharSets at: 81 put: UnicodeYiRadicals.	EncodedCharSets at: 82 put: UnicodeAlphabeticPresentations.	EncodedCharSets at: 83 put: UnicodeArabicPresentationsA.	EncodedCharSets at: 84 put: UnicodeCombiningHalfMarks.	EncodedCharSets at: 85 put: UnicodeArabicPresentationsB.	EncodedCharSets at: 86 put: UnicodeOldItalic.	EncodedCharSets at: 87 put: UnicodeGothic.	EncodedCharSets at: 88 put: UnicodeDeseret.	EncodedCharSets at: 89 put: UnicodeByzantineMusicals.	EncodedCharSets at: 90 put: UnicodeMusicalSymbols.	EncodedCharSets at: 91 put: UnicodeMathAlnumSymbols.	EncodedCharSets at: 92 put: UnicodeTags.	EncodedCharSets at: 256 put: Unicode! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 8/5/2003 16:44'!isDigit: char	"Answer whether the receiver is a digit."	| value |	value _ char asciiValue.	^ value >= 48 and: [value <= 57].! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 8/5/2003 16:40'!isLetter: char	"Answer whether the receiver is a letter."	| value |	value _ char asciiValue.	^ (8r141 <= value and: [value <= 8r172]) or: [8r101 <= value and: [value <= 8r132]].! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 8/5/2003 16:40'!isLowercase: char	"Answer whether the receiver is a lowercase letter.	(The old implementation answered whether the receiver is not an uppercase letter.)"	| value |	value _ char asciiValue.	^ 8r141 <= value and: [value <= 8r172].! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 8/5/2003 16:44'!isUppercase: char	"Answer whether the receiver is an uppercase letter.	(The old implementation answered whether the receiver is not a lowercase letter.)"	| value |	value _ char asciiValue.	^ 8r101 <= value and: [value <= 8r132].! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 11/10/2002 10:55'!languageClass	^ Smalltalk primaryLanguage.! !!EncodedCharSet class methodsFor: 'as yet unclassified' stamp: 'yo 9/2/2002 16:32'!charSetSize	self subclassResponsibility.! !!EncodedCharSet class methodsFor: 'as yet unclassified' stamp: 'yo 9/4/2002 22:57'!charsetAt: encoding	^ EncodedCharSets at: encoding + 1 ifAbsent: [EncodedCharSets at: 1].! !!EncodedCharSet class methodsFor: 'as yet unclassified' stamp: 'yo 9/2/2002 16:32'!compoundTextFinalChar	self subclassResponsibility.! !!EncodedCharSet class methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 20:31'!compoundTextSequence	self subclassResponsibility.! !!EncodedCharSet class methodsFor: 'as yet unclassified' stamp: 'yo 9/2/2002 16:32'!leadingChar	self subclassResponsibility.! !!EncodedCharSet class methodsFor: 'as yet unclassified' stamp: 'yo 11/4/2002 14:43'!nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state	self subclassResponsibility.! !!EncodedCharSet class methodsFor: 'as yet unclassified' stamp: 'yo 9/4/2002 22:51'!printingDirection	self subclassResponsibility.! !!EncodedCharSet class methodsFor: 'as yet unclassified' stamp: 'yo 10/7/2002 17:00'!scanSelector	self subclassResponsibility."	^ #basicScanCharactersFrom:to:in:rightX:stopConditions:kern:"! !!EncodedCharSet class methodsFor: 'as yet unclassified' stamp: 'yo 10/14/2003 10:19'!ucsTable	^ UCSTable latin1Table.! !!EncodedCharSet class methodsFor: 'accessing - displaying' stamp: 'yo 12/18/2002 12:34'!isBreakableAt: index in: text	self subclassResponsibility.! !EncodedCharSet subclass: #GB2312	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encodings'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GB2312 class	instanceVariableNames: ''!!GB2312 class methodsFor: 'class methods' stamp: 'yo 8/6/2003 05:30'!isLetter: char	| value leading |	leading _ char leadingChar.	value _ char charCode.	leading = 0 ifTrue: [^ super isLetter: char].	value _ value // 94 + 1.	^ 1 <= value and: [value < 84].! !!GB2312 class methodsFor: 'class methods' stamp: 'yo 8/4/2003 10:14'!languageClass	^ SimplifiedChinese.! !!GB2312 class methodsFor: 'as yet unclassified' stamp: 'yo 10/22/2002 19:50'!charSetSize	^ 94 * 94.! !!GB2312 class methodsFor: 'as yet unclassified' stamp: 'yo 10/22/2002 19:50'!compoundTextSequence	^ CompoundTextSequence! !!GB2312 class methodsFor: 'as yet unclassified' stamp: 'yo 10/22/2002 19:50'!initialize"	GB2312 initialize"	CompoundTextSequence _ String				streamContents: 					[:stream | 					stream nextPut: Character escape.					stream nextPut: $$.					stream nextPut: $(.					stream nextPut: $A].! !!GB2312 class methodsFor: 'as yet unclassified' stamp: 'yo 10/22/2002 19:51'!leadingChar	^ 2.! !!GB2312 class methodsFor: 'accessing - encoding' stamp: 'yo 11/24/2002 17:03'!nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state	| c1 c2 |	state charSize: 2.	(state g0Leading ~= self leadingChar) ifTrue: [		state g0Leading: self leadingChar.		state g0Size: 2.		aStream basicNextPutAll: CompoundTextSequence.	].	c1 _ ascii // 94 + 16r21.	c2 _ ascii \\ 94 + 16r21.	^ aStream basicNextPut: (Character value: c1); basicNextPut: (Character value: c2).! !!GB2312 class methodsFor: 'accessing - encoding' stamp: 'yo 10/14/2003 10:19'!ucsTable	^ UCSTable gb2312Table.! !!GB2312 class methodsFor: 'accessing - displaying' stamp: 'yo 11/23/2002 23:15'!scanSelector	^ #scanMultiCharactersFrom:to:in:rightX:stopConditions:kern:! !EncodedCharSet subclass: #JISX0208	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encodings'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JISX0208 class	instanceVariableNames: ''!!JISX0208 class methodsFor: 'as yet unclassified' stamp: 'yo 9/2/2002 16:47'!charSetSize	^ 94 * 94.! !!JISX0208 class methodsFor: 'as yet unclassified' stamp: 'yo 9/2/2002 16:49'!compoundTextSequence	^ CompoundTextSequence.! !!JISX0208 class methodsFor: 'as yet unclassified' stamp: 'yo 9/2/2002 16:49'!initialize"	self initialize"	CompoundTextSequence _ String streamContents: [:s |		s nextPut: (Character value: 27).		s nextPut: $$.		s nextPut: $B	].! !!JISX0208 class methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2003 05:30'!isLetter: char	| value leading |	leading _ char leadingChar.	value _ char charCode.	leading = 0 ifTrue: [^ super isLetter: char].	value _ value // 94 + 1.	^ 1 <= value and: [value < 84].! !!JISX0208 class methodsFor: 'as yet unclassified' stamp: 'yo 9/2/2002 17:38'!leadingChar	^ 1.! !!JISX0208 class methodsFor: 'as yet unclassified' stamp: 'yo 9/4/2002 22:52'!printingDirection	^ #right.! !!JISX0208 class methodsFor: 'accessing - displaying' stamp: 'yo 3/13/2003 11:57'!scanSelector	^ #scanJapaneseCharactersFrom:to:in:rightX:stopConditions:kern:! !!JISX0208 class methodsFor: 'accessing - encoding' stamp: 'yo 3/18/2003 11:11'!isBreakableAt: index in: text	| prev |	index = 1 ifTrue: [^ false].	prev _ text at: index - 1.	prev leadingChar ~= 1 ifTrue: [^ true].	^ false! !!JISX0208 class methodsFor: 'accessing - encoding' stamp: 'yo 11/24/2002 17:03'!nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state	| c1 c2 |	state charSize: 2.	(state g0Leading ~= self leadingChar) ifTrue: [		state g0Leading: self leadingChar.		state g0Size: 2.		aStream basicNextPutAll: CompoundTextSequence.	].	c1 _ ascii // 94 + 16r21.	c2 _ ascii \\ 94 + 16r21.	^ aStream basicNextPut: (Character value: c1); basicNextPut: (Character value: c2).! !!JISX0208 class methodsFor: 'accessing - encoding' stamp: 'yo 10/14/2003 10:19'!ucsTable	^ UCSTable jisx0208Table.! !!JISX0208 class methodsFor: 'class methods' stamp: 'yo 11/10/2002 09:24'!charAtKuten: anInteger	| a b |	a _ anInteger \\ 100.	b _ anInteger // 100.	(a > 94) | (b > 94) ifTrue: [		self error: 'character code is not valid'.	].	^ MultiCharacter leadingChar: self leadingChar code: ((b - 1) * 94) + a - 1.! !!JISX0208 class methodsFor: 'class methods' stamp: 'yo 11/10/2002 10:45'!languageClass	^ Japanese.! !!JISX0208 class methodsFor: 'class methods' stamp: 'yo 11/10/2002 09:09'!stringFromKutenArray: anArray	| s |	s _ MultiString new: anArray size.	1 to: anArray size do: [:i |		s at: i put: (self charAtKuten: (anArray at: i)).	].	^s.! !EncodedCharSet subclass: #KSX1001	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encodings'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!KSX1001 class	instanceVariableNames: ''!!KSX1001 class methodsFor: 'class methods' stamp: 'yo 8/6/2003 05:30'!isLetter: char	| value leading |	leading _ char leadingChar.	value _ char charCode.	leading = 0 ifTrue: [^ super isLetter: char].	value _ value // 94 + 1.	^ 1 <= value and: [value < 84].! !!KSX1001 class methodsFor: 'class methods' stamp: 'yo 11/10/2002 10:46'!languageClass	^ Korean.! !!KSX1001 class methodsFor: 'as yet unclassified' stamp: 'yo 10/22/2002 19:47'!charSetSize	^ 94 * 94.! !!KSX1001 class methodsFor: 'as yet unclassified' stamp: 'yo 10/22/2002 19:47'!compoundTextSequence	^ CompoundTextSequence.! !!KSX1001 class methodsFor: 'as yet unclassified' stamp: 'yo 10/22/2002 19:49'!initialize"	KSX1001 initialize"	CompoundTextSequence _ String				streamContents: 					[:stream | 					stream nextPut: Character escape.					stream nextPut: $$.					stream nextPut: $(.					stream nextPut: $C]! !!KSX1001 class methodsFor: 'as yet unclassified' stamp: 'yo 10/22/2002 19:49'!leadingChar	^ 3.! !!KSX1001 class methodsFor: 'accessing - encoding' stamp: 'yo 11/24/2002 17:03'!nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state	| c1 c2 |	state charSize: 2.	(state g0Leading ~= self leadingChar) ifTrue: [		state g0Leading: self leadingChar.		state g0Size: 2.		aStream basicNextPutAll: CompoundTextSequence.	].	c1 _ ascii // 94 + 16r21.	c2 _ ascii \\ 94 + 16r21.	^ aStream basicNextPut: (Character value: c1); basicNextPut: (Character value: c2).! !!KSX1001 class methodsFor: 'accessing - encoding' stamp: 'yo 11/24/2002 22:38'!scanSelector	^ #scanMultiCharactersFrom:to:in:rightX:stopConditions:kern:! !!KSX1001 class methodsFor: 'accessing - encoding' stamp: 'yo 10/14/2003 10:19'!ucsTable	^ UCSTable ksx1001Table.! !EncodedCharSet subclass: #Latin1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encodings'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Latin1 class	instanceVariableNames: 'RightHalfSequence '!!Latin1 class methodsFor: 'class initialization' stamp: 'yo 8/18/2003 17:41'!initialize"	self initialize"	CompoundTextSequence _ String streamContents: [:s |		s nextPut: (Character value: 27).		s nextPut: $(.		s nextPut: $B.	].	RightHalfSequence _ String streamContents: [:s |		s nextPut: (Character value: 27).		s nextPut: $-.		s nextPut: $A.	].! !!Latin1 class methodsFor: 'class methods' stamp: 'yo 8/18/2003 18:09'!charSetSize	^ 256.	"^ 94 + 96"! !!Latin1 class methodsFor: 'class methods' stamp: 'yo 8/18/2003 17:46'!emitSequenceToResetStateIfNeededOn: aStream forState: state	(state g0Leading ~= 0) ifTrue: [		state charSize: 1.		state g0Leading: 0.		state g0Size: 1.		aStream basicNextPutAll: CompoundTextSequence.	].	"Actually, G1 state should go back to ISO-8859-1, too."! !!Latin1 class methodsFor: 'class methods' stamp: 'yo 8/18/2003 17:32'!leadingChar	^ 0.! !!Latin1 class methodsFor: 'class methods' stamp: 'yo 8/18/2003 17:41'!nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state	(ascii <= 16r7F and: [state g0Leading ~= 0]) ifTrue: [		state charSize: 1.		state g0Leading: 0.		state g0Size: 1.		aStream basicNextPutAll: CompoundTextSequence.		aStream basicNextPut: (Character value: ascii).		^ self.	].	((16r80 <= ascii and: [ascii <= 16rFF]) and: [state g1Leading ~= 0]) ifTrue: [		^ self nextPutRightHalfValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state.	].	aStream basicNextPut: (Character value: ascii).	^ self.! !!Latin1 class methodsFor: 'displaying' stamp: 'yo 8/18/2003 17:32'!isBreakableAt: index in: text	| char |	char _ text at: index.	char = Character space ifTrue: [^ true].	char = Character cr ifTrue: [^ true].	^ false.! !!Latin1 class methodsFor: 'displaying' stamp: 'yo 8/18/2003 17:32'!printingDirection	^ #right.! !!Latin1 class methodsFor: 'displaying' stamp: 'yo 8/18/2003 17:32'!scanSelector	^ #scanMultiCharactersFrom:to:in:rightX:stopConditions:kern:! !!Latin1 class methodsFor: 'private' stamp: 'yo 8/18/2003 17:41'!nextPutRightHalfValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state	state charSize: 1.	state g1Leading: 0.	state g1Size: 1.	aStream basicNextPutAll: RightHalfSequence.	aStream basicNextPut: (Character value: ascii).! !EncodedCharSet subclass: #Unicode	instanceVariableNames: ''	classVariableNames: 'DecimalProperty GeneralCategory '	poolDictionaries: ''	category: 'Multilingual-Encodings'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Unicode class	instanceVariableNames: ''!!Unicode class methodsFor: 'subencodings' stamp: 'yo 12/27/2002 05:53'!addLeadingCharMethods"	self addLeadingCharMethods"	| index |	Unicode subclasses do: [:s |		index _ EncodedCharSet encodedCharSets indexOf: s.		index = 0 ifTrue: [self error: 'inconsistent'].		s class compile: ('leadingChar\\	^ ', (index - 1) printString, '.\') withCRs classified: 'accessing - encoding'.	].! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 8/4/2003 10:26'!defaultKanjiClass	| lang |	lang _ Smalltalk primaryLanguage name.	(#(Japanese. Korean. TraditionalChinese. SimplifiedChinese) includes: lang name) ifTrue: [		^ lang.	].	^ Japanese.! !!Unicode class methodsFor: 'class methods' stamp: 'yo 12/1/2003 19:26'!digitValue: char	| value |	value _ char charCode.	value > (DecimalProperty size - 1) ifTrue: [^ false].	^ (DecimalProperty at: value+1)! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 8/5/2003 19:33'!isCJK: code	^ ((((16r2E80 <= code and: [code <= 16rA4CF])		or: [16rF900 <= code and: [code <= 16rFAFF]])			or: [16rFE30 <= code and: [code <= 16rFE4F]])				or: [16rFF00 <= code and: [code <= 16rFFEF]])					or: [16r20000 <= code and: [code <= 16r2FA1F]].! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 12/26/2002 19:57'!leadingCharFor0: unicode	unicode < 16r780 ifTrue: [		unicode < 16r100 ifTrue: [^ 0].		unicode <= 16r24F ifTrue: [^ UnicodeLatinExtendedAB leadingChar].		unicode <= 16r2AF ifTrue: [^ UnicodeIPA leadingChar].		unicode <= 16r2FF ifTrue: [^ UnicodeSpacingModifiers leadingChar].		unicode <= 16r36F ifTrue: [^ UnicodeCombiningDiacritical leadingChar].		unicode <= 16r3FF ifTrue: [^ UnicodeGreek leadingChar].		unicode <= 16r52F ifTrue: [^ UnicodeCyrillic leadingChar].		unicode <= 16r58F ifTrue: [^ UnicodeArmenian leadingChar].		unicode <= 16r5FF ifTrue: [^ UnicodeHebrew leadingChar].		unicode <= 16r6FF ifTrue: [^ UnicodeArabic leadingChar].		unicode <= 16r74F ifTrue: [^ UnicodeSyriac leadingChar].		^ Unicode leadingChar	].	^ self restOfleadingCharFor0: unicode.! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 12/26/2002 18:15'!leadingCharFor10: unicode	unicode >= 16rAC00 ifTrue: [		^ UnicodeKorean leadingChar	].	unicode <= 16rA48F ifTrue: [^ UnicodeYiSyllables leadingChar].	unicode <= 16rA4CF ifTrue: [^ UnicodeYiRadicals leadingChar].	^ Unicode leadingChar! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 12/26/2002 18:20'!leadingCharFor13: unicode	unicode <= 16rD7AF ifTrue: [		^ UnicodeKorean leadingChar	].	^ Unicode leadingChar.! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 12/26/2002 18:29'!leadingCharFor15: unicode	unicode <= 16rFB4F ifTrue: [^ UnicodeAlphabeticPresentations leadingChar].	unicode <= 16rFDFF ifTrue: [^ UnicodeArabicPresentationsA leadingChar].	unicode <= 16rFE0F ifTrue: [^ Unicode leadingChar].	unicode <= 16rFE2F ifTrue: [^ UnicodeCombiningHalfMarks leadingChar].	unicode <= 16rFE4F ifTrue: [^ Unicode leadingChar].	unicode <= 16rFE6F ifTrue: [^ Unicode leadingChar].	unicode <= 16rFEFF ifTrue: [^ UnicodeArabicPresentationsB leadingChar].	^ Unicode leadingChar.! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 12/26/2002 14:10'!leadingCharFor1: unicode	unicode < 16r1700 ifTrue: [		unicode <= 16r109F ifTrue: [^ UnicodeMyanmar leadingChar].		unicode <= 16r10FF ifTrue: [^ UnicodeGeorgian leadingChar].		unicode <= 16r11FF ifTrue: [^ Unicode leadingChar].		unicode <= 16r137F ifTrue: [^ UnicodeEthiopic leadingChar].		unicode <= 16r13FF ifTrue: [^ UnicodeCherokee leadingChar].		unicode <= 16r167F ifTrue: [^ UnicodeCanadianAboriginal leadingChar].		unicode <= 16r169F ifTrue: [^ UnicodeOgham leadingChar].		unicode <= 16r16FF ifTrue: [^ UnicodeRunic leadingChar].		^ Unicode leadingChar	].	unicode <= 16r171F ifTrue: [^ UnicodeTagalog leadingChar].	unicode <= 16r173F ifTrue: [^ UnicodeHanunoo leadingChar].	unicode <= 16r175F ifTrue: [^ UnicodeBuhid leadingChar].	unicode <= 16r177F ifTrue: [^ UnicodeTagbanwa leadingChar].	unicode <= 16r17FF ifTrue: [^ UnicodeKhmer leadingChar].	unicode <= 16r18AF ifTrue: [^ UnicodeMongolian leadingChar].	unicode <= 16r1EFF ifTrue: [^ UnicodeLatinExtendedAdditional leadingChar].	unicode <= 16r1FFF ifTrue: [^ UnicodeGreekExtended leadingChar].	^ Unicode leadingChar! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 8/4/2003 11:50'!leadingCharFor2: unicode	unicode < 16r2600 ifTrue: [		unicode <= 16r206F ifTrue: [^ UnicodeGeneralPunctuation leadingChar].		unicode <= 16r209F ifTrue: [^ UnicodeSuperAndSubscript leadingChar].		unicode <= 16r20CF ifTrue: [^ UnicodeCurrencySymbols leadingChar].		unicode <= 16r20FF ifTrue: [^ UnicodeCombiningDiacriticalForSymbols leadingChar].		unicode <= 16r214F ifTrue: [^ UnicodeLetterlikeSymbols leadingChar].		unicode <= 16r218F ifTrue: [^ UnicodeNumberForms leadingChar].		unicode <= 16r21FF ifTrue: [^ UnicodeArrows leadingChar].		unicode <= 16r22FF ifTrue: [^ UnicodeMathOperators leadingChar].		unicode <= 16r23FF ifTrue: [^ UnicodeMiscTechnical leadingChar].		unicode <= 16r243F ifTrue: [^ UnicodeControlPictures leadingChar].		unicode <= 16r245F ifTrue: [^ UnicodeOCRs leadingChar].		unicode <= 16r24FF ifTrue: [^ UnicodeEnclosedAlnums leadingChar].		unicode <= 16r257F ifTrue: [^ UnicodeBoxDrawing leadingChar].		unicode <= 16r259F ifTrue: [^ UnicodeBlockElements leadingChar].		unicode <= 16r25FF ifTrue: [^ UnicodeGeometricShapes leadingChar].		^ Unicode leadingChar	].	unicode <= 16r26FF ifTrue: [^ UnicodeMiscSymbols leadingChar].	unicode <= 16r27BF ifTrue: [^ UnicodeDingbats leadingChar].	unicode <= 16r27EF ifTrue: [^ UnicodeMiscMathSymbolsA leadingChar].	unicode <= 16r27FF ifTrue: [^ UnicodeSupplementalArrowsA leadingChar].	unicode <= 16r28FF ifTrue: [^ UnicodeBraille leadingChar].	unicode <= 16r297F ifTrue: [^ UnicodeSupplementalArrowsB leadingChar].	unicode <= 16r29FF ifTrue: [^ UnicodeMiscMathSymbolsB leadingChar].	unicode <= 16r2AFF ifTrue: [^ UnicodeSupplementalMathOperators leadingChar].	^ Unicode leadingChar! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 8/5/2003 19:40'!leadingCharFor: unicode kanjiClass: kanjiClass	| code4096 |	code4096 _ unicode // 4096.	code4096 = 0 ifTrue: [^ self leadingCharFor0: unicode].	code4096 = 1 ifTrue: [^ self leadingCharFor1: unicode].	code4096 = 2 ifTrue: [		unicode >= 16r2E80 ifTrue: [			^ self leadingCharForKanjiClass: kanjiClass		].		^ self leadingCharFor2: unicode	].	code4096 = 3 ifTrue: [^ self leadingCharForKanjiClass: kanjiClass].	code4096 = 4 ifTrue: [^ self leadingCharForKanjiClass: kanjiClass].	code4096 = 5 ifTrue: [^ self leadingCharForKanjiClass: kanjiClass].	code4096 = 6 ifTrue: [^ self leadingCharForKanjiClass: kanjiClass].	code4096 = 7 ifTrue: [^ self leadingCharForKanjiClass: kanjiClass].	code4096 = 8 ifTrue: [^ self leadingCharForKanjiClass: kanjiClass].	code4096 = 9 ifTrue: [^ self leadingCharForKanjiClass: kanjiClass].	code4096 = 10 ifTrue: [^ self leadingCharFor10: unicode].	code4096 = 11 ifTrue: [^ UnicodeKorean leadingChar].	code4096 = 12 ifTrue: [^ UnicodeKorean leadingChar].	code4096 = 13 ifTrue: [^ self leadingCharFor13: unicode].	code4096 = 14 ifTrue: [^ Unicode leadingChar].	code4096 = 15 ifTrue: [		unicode <= 16rF8FF ifTrue: [^ Unicode leadingChar].		unicode <= 16rFAFF ifTrue: [^ self leadingCharForKanjiClass: kanjiClass].		unicode <= 16rFB4F ifTrue: [^ UnicodeAlphabeticPresentations leadingChar].		unicode <= 16rFDFF ifTrue: [^ UnicodeArabicPresentationsA leadingChar].		unicode <= 16rFE0F ifTrue: [^ Unicode leadingChar].		unicode <= 16rFE2F ifTrue: [^ UnicodeCombiningHalfMarks leadingChar].		unicode <= 16rFE4F ifTrue: [^ Unicode leadingChar].		unicode <= 16rFE6F ifTrue: [^ Unicode leadingChar].		unicode <= 16rFEFF ifTrue: [^ UnicodeArabicPresentationsB leadingChar].		unicode <= 16rFFEF ifTrue: [^ self leadingCharForKanjiClass: kanjiClass].		^ Unicode leadingChar.	].	(16r10300 <= unicode and: [unicode <= 16r1032F]) ifTrue:[^ UnicodeOldItalic leadingChar].	unicode <= 16r1034F ifTrue: [^ UnicodeGothic leadingChar].	(16r10400 <= unicode and: [unicode <= 16r1044F]) ifTrue: [^ UnicodeDeseret leadingChar].	unicode <= 16r1CFFF ifTrue: [^ Unicode leadingChar].	unicode <= 16r1D0FF ifTrue: [^ UnicodeByzantineMusicals leadingChar].	unicode <= 16r1D3FF ifTrue: [^ Unicode leadingChar].	unicode <= 16r1D7FF ifTrue: [^ UnicodeMathAlnumSymbols leadingChar].	(16r20000 <= unicode and: [unicode <= 16r2FA1F]) ifTrue: [^ self leadingCharForKanjiClass: kanjiClass].	^ Unicode leadingChar.! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 8/4/2003 10:15'!leadingCharForKanjiClass: kanjiClass	kanjiClass = Japanese ifTrue: [^ UnicodeJapanese leadingChar].	kanjiClass = Korean ifTrue: [^ UnicodeKorean leadingChar].	kanjiClass = SimplifiedChinese ifTrue: [^ UnicodeSimplifiedChinese leadingChar]."	kanjiClass = Taiwanese ifTrue: [^ UnicodeTraditionalChinese leadingChar].""	kanjiClass = Vietnamese ifTrue: [^ UnicodeVietnamese leadingChar]."	^ Unicode leadingChar.! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 12/26/2002 17:33'!newForCode: unicode kanjiClass: kanjiClass	| leadingChar |	leadingChar _ self leadingCharFor: unicode kanjiClass: kanjiClass.	^ MultiCharacter leadingChar: leadingChar code: unicode.! !!Unicode class methodsFor: 'subencodings' stamp: 'yo 12/26/2002 13:46'!restOfleadingCharFor0: unicode	unicode <= 16r7BF ifTrue: [^ UnicodeThaana leadingChar].	unicode < 16r900 ifTrue: [^ Unicode leadingChar].	unicode <= 16r97F ifTrue: [^ UnicodeDevanagari leadingChar].	unicode <= 16r9FF ifTrue: [^ UnicodeBengali leadingChar].	unicode <= 16rA7F ifTrue: [^ UnicodeGurmukhi leadingChar].	unicode <= 16rAFF ifTrue: [^ UnicodeGujarati leadingChar].	unicode <= 16rB7F ifTrue: [^ UnicodeOriya leadingChar].	unicode <= 16rBFF ifTrue: [^ UnicodeTamil leadingChar].	unicode <= 16rC7F ifTrue: [^ UnicodeTelugu leadingChar].	unicode <= 16rCFF ifTrue: [^ UnicodeKannada leadingChar].	unicode <= 16rD7F ifTrue: [^ UnicodeMalayalam leadingChar].	unicode <= 16rDFF ifTrue: [^ UnicodeSinhala leadingChar].	unicode <= 16rE7F ifTrue: [^ UnicodeThai leadingChar].	unicode <= 16rEFF ifTrue: [^ UnicodeLao leadingChar].	unicode <= 16rFFF ifTrue: [^ UnicodeTibetan leadingChar].	^ Unicode leadingChar.! !!Unicode class methodsFor: 'accessing - encoding' stamp: 'yo 12/24/2002 07:48'!charSetSize	^ 16r110000.! !!Unicode class methodsFor: 'accessing - encoding' stamp: 'yo 12/24/2002 07:49'!compoundTextFinalChar	self shouldNotImplement.! !!Unicode class methodsFor: 'accessing - encoding' stamp: 'yo 12/24/2002 08:03'!compoundTextSequence	self subclassResponsibility.! !!Unicode class methodsFor: 'accessing - encoding' stamp: 'yo 8/4/2003 11:50'!leadingChar	^ 255.! !!Unicode class methodsFor: 'accessing - encoding' stamp: 'yo 12/24/2002 08:03'!nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state	self subclassResponsibility.! !!Unicode class methodsFor: 'accessing - encoding' stamp: 'yo 12/24/2002 08:04'!ucsTable	^ UCSTable latin1Table.! !!Unicode class methodsFor: 'accessing - displaying' stamp: 'yo 12/24/2002 08:05'!isBreakableAt: index in: text	self subclassResponsibility.! !!Unicode class methodsFor: 'accessing - displaying' stamp: 'yo 12/24/2002 08:05'!printingDirection	self subclassResponsibility.! !!Unicode class methodsFor: 'accessing - displaying' stamp: 'yo 1/2/2003 14:25'!scanSelector	^ #scanMultiCharactersCombiningFrom:to:in:rightX:stopConditions:kern:.	"^ #scanMultiCharactersFrom:to:in:rightX:stopConditions:kern:."! !!Unicode class methodsFor: 'class methods' stamp: 'yo 12/30/2002 13:35'!charFromUnicode: uniCode	^ MultiCharacter leadingChar: self leadingChar code: uniCode! !!Unicode class methodsFor: 'class methods' stamp: 'yo 8/5/2003 16:12'!generalCategoryComment"Lu Letter, Uppercase Ll Letter, Lowercase Lt Letter, Titlecase Lm Letter, Modifier Lo Letter, Other Mn Mark, Non-Spacing Mc Mark, Spacing Combining Me Mark, Enclosing Nd Number, Decimal Nl Number, Letter No Number, Other Pc Punctuation, Connector Pd Punctuation, Dash Ps Punctuation, Open Pe Punctuation, Close Pi Punctuation, Initial quote (may behave like Ps or Pe depending on usage) Pf Punctuation, Final quote (may behave like Ps or Pe depending on usage) Po Punctuation, Other Sm Symbol, Math Sc Symbol, Currency Sk Symbol, Modifier So Symbol, Other Zs Separator, Space Zl Separator, Line Zp Separator, Paragraph Cc Other, Control Cf Other, Format Cs Other, Surrogate Co Other, Private Use Cn Other, Not Assigned (no characters in the file have this property) "! !!Unicode class methodsFor: 'class methods' stamp: 'yo 12/1/2003 18:24'!isDigit: char	| value |	value _ char charCode.	value > (GeneralCategory size - 1) ifTrue: [^ false].	^ (GeneralCategory at: value+1) = 'Nd'.! !!Unicode class methodsFor: 'class methods' stamp: 'yo 12/1/2003 18:25'!isLetter: char	| value result |	value _ char charCode.	value > (GeneralCategory size - 1) ifTrue: [^ false].	result _ GeneralCategory at: value+1.	^ result first = $L.! !!Unicode class methodsFor: 'class methods' stamp: 'yo 12/1/2003 18:25'!isLowercase: char	| value |	value _ char charCode.	value > (GeneralCategory size - 1) ifTrue: [^ false].	^ (GeneralCategory at: value+1) = 'Ll'.! !!Unicode class methodsFor: 'class methods' stamp: 'yo 12/1/2003 18:25'!isUppercase: char	| value |	value _ char charCode.	value > (GeneralCategory size - 1) ifTrue: [^ false].	^ (GeneralCategory at: value+1) = 'Lu'.! !!Unicode class methodsFor: 'class methods' stamp: 'yo 12/1/2003 18:25'!isUppercase: char	| value |	value _ char charCode.	value > (GeneralCategory size - 1) ifTrue: [^ false].	^ (GeneralCategory at: value+1) = 'Lu'.! !!Unicode class methodsFor: 'class methods' stamp: 'yo 1/15/2004 17:23'!parseUnicodeDataFrom: stream"	self halt.	self parseUnicodeDataFile"	| line fieldEnd point fieldStart toNumber generalCategory decimalProperty |	toNumber _ [:quad | ('16r', quad) asNumber].	GeneralCategory _ SparseLargeTable new: 16rE0080 chunkSize: 1024 arrayClass: Array base: 1 defaultValue:  'Cn'.	DecimalProperty _ SparseLargeTable new: 16rE0080 chunkSize: 32 arrayClass: Array base: 1 defaultValue: -1.	16r3400 to: 16r4DB5 do: [:i | GeneralCategory at: i+1 put: 'Lo'].	16r4E00 to: 16r9FA5 do: [:i | GeneralCategory at: i+1 put: 'Lo'].	16rAC00 to: 16rD7FF do: [:i | GeneralCategory at: i+1 put: 'Lo'].	[(line _ stream upTo: Character cr) size > 0] whileTrue: [		fieldEnd _ line indexOf: $; startingAt: 1.		point _ toNumber value: (line copyFrom: 1 to: fieldEnd - 1).		point > 16rE007F ifTrue: [			GeneralCategory zapDefaultOnlyEntries.			DecimalProperty zapDefaultOnlyEntries.			^ self].		2 to: 3 do: [:i |			fieldStart _ fieldEnd + 1.			fieldEnd _ line indexOf: $; startingAt: fieldStart.		].		generalCategory _ line copyFrom: fieldStart to: fieldEnd - 1.		GeneralCategory at: point+1 put: generalCategory.		generalCategory = 'Nd' ifTrue: [			4 to: 7 do: [:i |				fieldStart _ fieldEnd + 1.				fieldEnd _ line indexOf: $; startingAt: fieldStart.			].			decimalProperty _  line copyFrom: fieldStart to: fieldEnd - 1.			DecimalProperty at: point+1 put: decimalProperty asNumber.		].	].	GeneralCategory zapDefaultOnlyEntries.	DecimalProperty zapDefaultOnlyEntries.! !!Unicode class methodsFor: 'class methods' stamp: 'yo 12/29/2002 00:44'!value: code	(self isCJK: code) ifFalse: [		^ MultiCharacter leadingChar: (self leadingCharFor: code kanjiClass: nil) code: code	].	^ MultiCharacter leadingChar: (self leadingCharFor: code kanjiClass: self defaultKanjiClass) code: code! !!Unicode class methodsFor: 'class methods' stamp: 'yo 12/29/2002 00:44'!value: code kanjiClass: kanjiClass	^ MultiCharacter leadingChar: (self leadingCharFor: code kanjiClass: kanjiClass) code: code.! !!Unicode class methodsFor: 'sub encodings' stamp: 'yo 12/23/2002 13:04'!blocks320Comment"# Blocks-3.2.0.txt# Correlated with Unicode 3.2# Start Code..End Code; Block Name0000..007F; Basic Latin0080..00FF; Latin-1 Supplement0100..017F; Latin Extended-A0180..024F; Latin Extended-B0250..02AF; IPA Extensions02B0..02FF; Spacing Modifier Letters0300..036F; Combining Diacritical Marks0370..03FF; Greek and Coptic0400..04FF; Cyrillic0500..052F; Cyrillic Supplementary0530..058F; Armenian0590..05FF; Hebrew0600..06FF; Arabic0700..074F; Syriac0780..07BF; Thaana0900..097F; Devanagari0980..09FF; Bengali0A00..0A7F; Gurmukhi0A80..0AFF; Gujarati0B00..0B7F; Oriya0B80..0BFF; Tamil0C00..0C7F; Telugu0C80..0CFF; Kannada0D00..0D7F; Malayalam0D80..0DFF; Sinhala0E00..0E7F; Thai0E80..0EFF; Lao0F00..0FFF; Tibetan1000..109F; Myanmar10A0..10FF; Georgian1100..11FF; Hangul Jamo1200..137F; Ethiopic13A0..13FF; Cherokee1400..167F; Unified Canadian Aboriginal Syllabics1680..169F; Ogham16A0..16FF; Runic1700..171F; Tagalog1720..173F; Hanunoo1740..175F; Buhid1760..177F; Tagbanwa1780..17FF; Khmer1800..18AF; Mongolian1E00..1EFF; Latin Extended Additional1F00..1FFF; Greek Extended2000..206F; General Punctuation2070..209F; Superscripts and Subscripts20A0..20CF; Currency Symbols20D0..20FF; Combining Diacritical Marks for Symbols2100..214F; Letterlike Symbols2150..218F; Number Forms2190..21FF; Arrows2200..22FF; Mathematical Operators2300..23FF; Miscellaneous Technical2400..243F; Control Pictures2440..245F; Optical Character Recognition2460..24FF; Enclosed Alphanumerics2500..257F; Box Drawing2580..259F; Block Elements25A0..25FF; Geometric Shapes2600..26FF; Miscellaneous Symbols2700..27BF; Dingbats27C0..27EF; Miscellaneous Mathematical Symbols-A27F0..27FF; Supplemental Arrows-A2800..28FF; Braille Patterns2900..297F; Supplemental Arrows-B2980..29FF; Miscellaneous Mathematical Symbols-B2A00..2AFF; Supplemental Mathematical Operators2E80..2EFF; CJK Radicals Supplement2F00..2FDF; Kangxi Radicals2FF0..2FFF; Ideographic Description Characters3000..303F; CJK Symbols and Punctuation3040..309F; Hiragana30A0..30FF; Katakana3100..312F; Bopomofo3130..318F; Hangul Compatibility Jamo3190..319F; Kanbun31A0..31BF; Bopomofo Extended31F0..31FF; Katakana Phonetic Extensions3200..32FF; Enclosed CJK Letters and Months3300..33FF; CJK Compatibility3400..4DBF; CJK Unified Ideographs Extension A4E00..9FFF; CJK Unified IdeographsA000..A48F; Yi SyllablesA490..A4CF; Yi RadicalsAC00..D7AF; Hangul SyllablesD800..DB7F; High SurrogatesDB80..DBFF; High Private Use SurrogatesDC00..DFFF; Low SurrogatesE000..F8FF; Private Use AreaF900..FAFF; CJK Compatibility IdeographsFB00..FB4F; Alphabetic Presentation FormsFB50..FDFF; Arabic Presentation Forms-AFE00..FE0F; Variation SelectorsFE20..FE2F; Combining Half MarksFE30..FE4F; CJK Compatibility FormsFE50..FE6F; Small Form VariantsFE70..FEFF; Arabic Presentation Forms-BFF00..FFEF; Halfwidth and Fullwidth FormsFFF0..FFFF; Specials10300..1032F; Old Italic10330..1034F; Gothic10400..1044F; Deseret1D000..1D0FF; Byzantine Musical Symbols1D100..1D1FF; Musical Symbols1D400..1D7FF; Mathematical Alphanumeric Symbols20000..2A6DF; CJK Unified Ideographs Extension B2F800..2FA1F; CJK Compatibility Ideographs SupplementE0000..E007F; TagsF0000..FFFFF; Supplementary Private Use Area-A100000..10FFFF; Supplementary Private Use Area-B"! !EncodedCharSet initialize!GB2312 initialize!JISX0208 initialize!KSX1001 initialize!Latin1 initialize!Object subclass: #LanguageEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Languages'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LanguageEnvironment class	instanceVariableNames: 'inputInterpreter clipboardInterpreter defaultSystemConverter '!!LanguageEnvironment class methodsFor: 'language methods' stamp: 'yo 8/14/2003 15:39'!beCurrentNaturalLanguage! !!LanguageEnvironment class methodsFor: 'language methods' stamp: 'yo 8/11/2003 21:23'!flapTabTextFor: aString	^ aString asTranslatedWording.! !!LanguageEnvironment class methodsFor: 'language methods' stamp: 'yo 8/11/2003 21:25'!flapTabTextFor: aString in: aFlapTab	^ aString asTranslatedWording.! !!LanguageEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 17:49'!charsetClass	^ Latin1.! !!LanguageEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/13/2003 14:43'!defaultClipboardInterpreter	clipboardInterpreter ifNil: [self setClipboardInterpreterClass].	^ clipboardInterpreter new.! !!LanguageEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 10/24/2002 11:56'!defaultEncodingName	self subclassResponsibility! !!LanguageEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/13/2003 21:47'!defaultInputInterpreter	| platformName osVersion |	platformName _ Smalltalk platformName.	osVersion _ Smalltalk getSystemAttribute: 1002.	^ MacRomanInputInterpreter new.! !!LanguageEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 15:06'!defaultSystemConverter	defaultSystemConverter ifNil: [self setDefaultSystemConverterClass].	^ defaultSystemConverter new.! !!LanguageEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/13/2003 15:50'!initialize"	self initialize"	Smalltalk addToStartUpList: self.! !!LanguageEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 15:24'!setClipboardInterpreterClass	clipboardInterpreter _ MacRomanClipboardInterpreter.! !!LanguageEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 14:40'!setDefaultSystemConverterClass	| encodingName cl |	encodingName _ self defaultEncodingName.	encodingName ifNil: [^ defaultSystemConverter _ MacRomanTextConverter].	cl _ TextConverter defaultConverterClassForEncoding: encodingName.	cl ifNotNil: [^ defaultSystemConverter _ cl].	^ defaultSystemConverter _ MacRomanTextConverter.! !!LanguageEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/13/2003 15:43'!setInputInterpreterClass	inputInterpreter _ NoInputInterpreter.! !!LanguageEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 13:55'!startUp	clipboardInterpreter _ nil.	inputInterpreter _ nil.	defaultSystemConverter _ nil.	Clipboard clearInterpreters.	HandMorph startUp.! !LanguageEnvironment subclass: #EnglishEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Languages'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EnglishEnvironment class	instanceVariableNames: ''!!EnglishEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 10/24/2002 13:41'!defaultEncodingName	| platformName osVersion |	platformName _ Smalltalk platformName.	osVersion _ Smalltalk getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) ifTrue: [^ 'utf-8' copy].	(#('Win32' 'Mac OS' 'ZaurusOS') includes: platformName) ifTrue: [^ 'iso8859-1' copy].	(#('unix') includes: platformName) ifTrue: [^ 'iso8859-1' copy].	^ nil! !LanguageEnvironment subclass: #GermanEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Languages'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GermanEnvironment class	instanceVariableNames: ''!!GermanEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 17:49'!charsetClass	^ Latin1.! !!GermanEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 18:30'!defaultEncodingName	| platformName osVersion |	platformName _ Smalltalk platformName.	osVersion _ Smalltalk getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) ifTrue: [^ 'utf-8' copy].	(#('Win32' 'Mac OS' 'ZaurusOS') includes: platformName) ifTrue: [^ 'iso8859-1' copy].	(#('unix') includes: platformName) ifTrue: [^ 'iso8859-1' copy].	^ nil! !LanguageEnvironment subclass: #SpanishEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Languages'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SpanishEnvironment class	instanceVariableNames: ''!!SpanishEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 17:49'!charsetClass	^ Latin1.! !!SpanishEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 18:28'!defaultEncodingName	| platformName osVersion |	platformName _ Smalltalk platformName.	osVersion _ Smalltalk getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) ifTrue: [^ 'utf-8' copy].	(#('Win32' 'Mac OS' 'ZaurusOS') includes: platformName) ifTrue: [^ 'iso8859-1' copy].	(#('unix') includes: platformName) ifTrue: [^ 'iso8859-1' copy].	^ nil! !!Character methodsFor: 'accessing' stamp: 'yo 12/29/2002 10:14'!leadingChar	^ (value bitAnd: (16r3FC00000)) bitShift: -22.! !!Character methodsFor: 'converting' stamp: 'yo 8/18/2003 17:02'!squeakToIso	| asciiValue |	value < 128 ifTrue: [^ self].	value > 255 ifTrue: [^ self].	asciiValue _ #(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216 129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248 191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156 150 151 147 148 145 146 247 179 255 159 185 164 139 155 188 189 135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212 190 210 218 219 217 208 136 152 175 215 221 222 184 240 253 254 ) at: self asciiValue - 127.	^ Character value: asciiValue.! !!Character methodsFor: 'testing' stamp: 'yo 8/5/2003 16:43'!isUppercase	^ (EncodedCharSet charsetAt: self leadingChar) isUppercase: self.! !!Character methodsFor: 'testing' stamp: 'yo 8/27/2002 15:18'!isOctetCharacter	^ value < 256.! !!Character methodsFor: 'testing' stamp: 'yo 8/5/2003 16:57'!canBeGlobalVarInitial	^ (EncodedCharSet charsetAt: self leadingChar) canBeGlobalVarInitial: self.! !!Character methodsFor: 'testing' stamp: 'yo 8/5/2003 16:43'!isLetter	^ (EncodedCharSet charsetAt: self leadingChar) isLetter: self.! !!Character methodsFor: 'testing' stamp: 'yo 8/28/2002 13:42'!isCharacter	^ true.! !!Character methodsFor: 'converting' stamp: 'yo 12/30/2002 11:36'!asUnicode	^ value! !!Character methodsFor: 'converting' stamp: 'yo 8/18/2003 19:25'!isoToSqueak 	"Convert receiver from iso8895-1 (actually CP1252) to mac encoding.	Does not do lf/cr conversion!!	To make the round-trip conversion possible, each undefined code point is mapped to a unique value.	For each c in Character, c squeakToIso isoToSqueak = c, and c isoToSqueak squeakToIso = c is true.  Also, for each array literals in squeakToIso and isoToSqueak, self size = self asSet size is true.  Finally, the table is compabie with the 'keymap' table in the Windows VM."	value < 128 ifTrue: [^ self].	value > 255 ifTrue: [^ self].	^ Character value: (#(		173 176 226 196 227 201 160 224 246 228 178 220 206 179 182 183	"80-8F"		184 212 213 210 211 165 208 209 247 170 185 221 207 186 189 217	"90-9F"		202 193 162 163 219 180 195 164 172 169 187 199 194 197 168 248	"A0-AF"		161 177 198 215 171 181 166 225 252 218 188 200 222 223 240 192 	"B0-BF"		203 231 229 204 128 129 174 130 233 131 230 232 237 234 235 236 	"C0-CF"		245 132 241 238 239 205 133 249 175 244 242 243 134 250 251 167	"D0-DF"		136 135 137 139 138 140 190 141 143 142 144 145 147 146 148 149	"E0-EF"		253 150 152 151 153 155 154 214 191 157 156 158 159 254 255 216	"F0-FF"	) at: value - 127)! !!Character methodsFor: 'testing' stamp: 'yo 12/30/2002 16:14'!isUnicodeCJK	^ self isUnicode and: [Unicode isCJK: self charCode].! !!Character methodsFor: 'accessing' stamp: 'yo 12/29/2002 10:11'!charCode	^ (value bitAnd: 16r3FFFFF).! !!Character methodsFor: 'testing' stamp: 'yo 12/30/2002 15:55'!isUnicode	^ false.! !!Character methodsFor: 'comparing' stamp: 'yo 8/27/2002 15:16'!= aCharacter 	"Primitive. Answer true if the receiver and the argument are the same	object (have the same object pointer) and false otherwise. Optional. See	Object documentation whatIsAPrimitive."	"<primitive: 110>"	^ self == aCharacter		or: [aCharacter class == MultiCharacter				and: [aCharacter asciiValue = self asciiValue]].! !!Character methodsFor: 'accessing' stamp: 'yo 12/1/2003 19:30'!digitValue	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 	otherwise. This is used to parse literal numbers of radix 2-36."	^ (EncodedCharSet charsetAt: self leadingChar) digitValue: self.! !!Character methodsFor: 'testing' stamp: 'yo 8/5/2003 16:43'!isDigit	^ (EncodedCharSet charsetAt: self leadingChar) isDigit: self.! !!Character methodsFor: 'testing' stamp: 'yo 8/5/2003 16:58'!canBeNonGlobalVarInitial	^ (EncodedCharSet charsetAt: self leadingChar) canBeNonGlobalVarInitial: self.! !!Character methodsFor: 'testing' stamp: 'yo 8/5/2003 16:43'!isLowercase	^ (EncodedCharSet charsetAt: self leadingChar) isLowercase: self.! !!Character methodsFor: 'converting' stamp: 'yo 8/11/2003 21:18'!basicSqueakToIso	| asciiValue |	value < 128 ifTrue: [^ self].	value > 255 ifTrue: [^ self].	asciiValue _ #(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216 129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248 191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156 150 151 147 148 145 146 247 179 253 159 185 164 139 155 188 189 135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212 190 210 218 219 217 208 136 152 175 215 221 222 184 240 254 255 256 ) at: self asciiValue - 127.	^ Character value: asciiValue.! !!Character class methodsFor: 'instance creation' stamp: 'yo 8/27/2002 15:15'!value: anInteger 	"Answer the Character whose value is anInteger."	anInteger > 255 ifTrue: [^ MultiCharacter value: anInteger].	^ CharacterTable at: anInteger + 1.! !!Symbol class methodsFor: 'private' stamp: 'yo 8/30/2002 14:50'!hasInterned: aString ifTrue: symBlock 	"Answer with false if aString hasnt been interned (into a Symbol),  	otherwise supply the symbol to symBlock and return true."	| symbol |	((aString isKindOf: MultiString)			and: [aString isOctetString not])		ifTrue: [^ MultiSymbol hasInterned: aString ifTrue: symBlock].	^ (symbol _ self lookup: aString)		ifNil: [false]		ifNotNil: [symBlock value: symbol.			true]! !!Symbol class methodsFor: 'instance creation' stamp: 'yo 8/30/2002 14:52'!intern: aStringOrSymbol 	(aStringOrSymbol class == MultiString			and: [aStringOrSymbol isOctetString not])		ifTrue: [^ MultiSymbol intern: aStringOrSymbol].	^ (self lookup: aStringOrSymbol)		ifNil: [NewSymbols				add: ((aStringOrSymbol isKindOf: Symbol)						ifTrue: [aStringOrSymbol]						ifFalse: [(self new: aStringOrSymbol size)								string: aStringOrSymbol])].! !!String methodsFor: 'converting' stamp: 'yo 8/28/2002 16:53'!asMultiString 	^ MultiString from: self.! !!String methodsFor: 'converting' stamp: 'yo 6/4/2003 05:31'!convertFromWithConverter: converter	| readStream writeStream c |	readStream _ self readStream.	writeStream _ String new writeStream.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		c _ converter nextFromStream: readStream.		c ifNotNil: [writeStream nextPut: c] ifNil: [^ writeStream contents]	].	^ writeStream contents! !!String methodsFor: 'converting' stamp: 'yo 11/11/2002 12:20'!convertFromCompoundText	| readStream writeStream converter |	readStream _ self readStream.	writeStream _ String new writeStream.	converter _ CompoundTextConverter new.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		writeStream nextPut: (converter nextFromStream: readStream)].	^ writeStream contents! !!String methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:30'!caseSensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."	| m |	aString isOctetString ifTrue: [		^ (self compare: self with: aString asOctetString collated: CaseSensitiveOrder) <= 2	].	m _ self asMultiString.	^ (m compare: m with: aString collated: CaseSensitiveOrder) <= 2! !!String methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:30'!compare: aString 	"Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	The collation sequence is ascii with case differences ignored.	To get the effect of a <= b, but ignoring case, use (a compare: b) <= 2."	^ self compare: self with: aString collated: CaseInsensitiveOrder! !!String methodsFor: 'private' stamp: 'yo 8/28/2002 16:54'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	replacement class == MultiString ifTrue: [		self becomeForward: (MultiString from: self).	]. 	super replaceFrom: start to: stop with: replacement startingAt: repStart.! !!String methodsFor: 'converting' stamp: 'yo 8/28/2002 16:52'!asOctetString	^ self.! !!String methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:30'!caseInsensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case insensitive."	| m |	aString isOctetString ifTrue: [		^ (self compare: self with: aString asOctetString collated: CaseInsensitiveOrder) <= 2	].	m _ self asMultiString.	^ (m compare: m with: aString collated: CaseInsensitiveOrder) <= 2! !!String methodsFor: 'testing' stamp: 'yo 8/28/2002 15:19'!isOctetString	^ true.! !!String methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:30'!>= aString 	"Answer whether the receiver sorts after or equal to aString.	The collation order is simple ascii (with case differences)."	| m |	aString isOctetString ifTrue: [		^ (self compare: self with: aString asOctetString collated: AsciiOrder) >= 2	].	m _ self asMultiString.	^ (m compare: m with: aString collated: nil) >= 2! !!String methodsFor: 'converting' stamp: 'sw 8/3/2002 04:32'!asSignedInteger	"Answer the Integer created by interpreting the receiver as the string representation of an integer, possibly with a leading minus sign.  Answer nil if no digits, else find the first digit and then all consecutive digits after that"	| startPosition tail endPosition |	startPosition _ self findFirst: [:ch | ch isDigit or: [ch == $-]].	startPosition == 0 ifTrue: [^ nil].	tail _ self copyFrom: startPosition to: self size.	endPosition _ tail findFirst: [:ch | ch isDigit not and: [ch ~~ $-]].	endPosition == 0 ifTrue: [endPosition _ tail size + 1].	^ Number readFromString: (tail copyFrom: 1 to: endPosition - 1)"'znak -58 to wit' asSignedInteger"! !!String methodsFor: 'converting' stamp: 'yo 10/24/2002 14:08'!convertToSystemString	^ self! !!String methodsFor: 'converting' stamp: 'yo 9/26/2003 11:51'!convertFromSystemString	| readStream writeStream converter |	readStream _ self readStream.	writeStream _ String new writeStream.	converter _ Smalltalk systemLanguage defaultSystemConverter.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		writeStream nextPut: (converter nextFromStream: readStream)].	^ writeStream contents! !!String methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:29'!< aString 	"Answer whether the receiver sorts before aString.	The collation order is simple ascii (with case differences)."	| m |	aString isOctetString ifTrue: [		^ (self compare: self with: aString asOctetString collated: AsciiOrder) = 1	].	m _ self asMultiString.	^ (m compare: m with: aString collated: nil) = 1! !!String methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:31'!sameAs: aString 	"Answer whether the receiver sorts equal to aString. The 	collation sequence is ascii with case differences ignored."	| m |	aString isOctetString ifTrue: [		^ (self compare: self with: aString asOctetString collated: CaseInsensitiveOrder) = 2	].	m _ self asMultiString.	^ (m compare: m with: aString collated: CaseInsensitiveOrder) = 2! !!String methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:29'!<= aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is simple ascii (with case differences)."	| m |	aString isOctetString ifTrue: [		^ (self compare: self with: aString asOctetString collated: AsciiOrder) <= 2	].	m _ self asMultiString.	^ (m compare: m with: aString collated: nil) <= 2! !!String methodsFor: 'converting' stamp: 'yo 5/22/2003 14:06'!convertToWithConverter: converter	^ self.! !!String methodsFor: 'accessing' stamp: 'yo 8/26/2002 20:33'!at: index 	"Primitive. Answer the Character stored in the field of the receiver	indexed by the argument. Fail if the index argument is not an Integer or	is out of bounds. Essential. See Object documentation whatIsAPrimitive."	<primitive: 63>	^ Character value: (super at: index)! !!String methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:29'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."	(aString class == String or: [aString class == Symbol]) ifFalse: [		aString class == MultiString ifTrue: [^ aString = self].		aString isText ifTrue: [^ self = aString string].		^ false	].	^ (self compare: self with: aString collated: AsciiOrder) = 2.! !!String methodsFor: 'converting' stamp: 'yo 11/4/2002 22:21'!asTranslatedWording	| vocabulary wording |	vocabulary _ Vocabulary eToyVocabulary.	wording _ vocabulary translatedWordingFor: self asSymbol.	(wording isNil or: [wording = 'none']) ifTrue: [^ self].	^ wording! !!String methodsFor: 'accessing' stamp: 'yo 8/28/2002 16:42'!at: index put: aCharacter	"Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 64>	(aCharacter isMemberOf: Character) ifTrue: [			index isInteger			ifTrue: [self errorSubscriptBounds: index]			ifFalse: [self errorNonIntegerIndex]	] ifFalse: [		(aCharacter isMemberOf: MultiCharacter) 			ifTrue: [				self becomeForward: (MultiString from: self).				self at: index put: aCharacter.			] ifFalse: [					self error: 'Strings only store Characters'			]	].! !!String methodsFor: 'testing' stamp: 'yo 7/29/2003 14:09'!includesUnifiedCharacter	^ false.! !!String methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:30'!> aString 	"Answer whether the receiver sorts after aString.	The collation order is simple ascii (with case differences)."	| m |	aString isOctetString ifTrue: [		^ (self compare: self with: aString asOctetString collated: AsciiOrder) = 3	].	m _ self asMultiString.	^ (m compare: m with: aString collated: nil) = 3! !!String class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 14:51'!correspondingSymbolClass	^ Symbol! !!String class methodsFor: 'instance creation' stamp: 'yo 10/23/2002 23:43'!fromByteArray: aByteArray	^ aByteArray asString! !!MultiCharacter methodsFor: 'converting' stamp: 'yo 11/30/2003 16:09'!asUnicode	| table charset v |	charset _ EncodedCharSet charsetAt: self leadingChar.	(charset isKindOf: Unicode class) ifTrue: [^ self charCode].	table _ charset ucsTable.	table isNil ifTrue: [^ 16rFFFD].	v _ table at: self charCode + 1.	v = -1 ifTrue: [^ 16rFFFD].	^ v.! !!MultiCharacter methodsFor: 'as yet unclassified' stamp: 'yo 8/5/2003 13:33'!hex	^ value hex.! !!MultiCharacter methodsFor: 'as yet unclassified' stamp: 'yo 8/26/2002 11:11'!squeakToIso 	^ self! !!MultiCharacter methodsFor: 'as yet unclassified' stamp: 'yo 8/26/2002 11:10'!isoToSqueak	^ self.! !!MultiCharacter methodsFor: 'as yet unclassified' stamp: 'yo 8/26/2002 11:12'!hash	"Hash is reimplemented because = is implemented."	^ value! !!MultiCharacter methodsFor: 'testing' stamp: 'yo 12/30/2002 15:56'!isUnicode	^ (EncodedCharSet charsetAt: self leadingChar) isKindOf: Unicode class.! !!MultiCharacter methodsFor: 'as yet unclassified' stamp: 'yo 8/26/2002 11:08'!asCharacter	^ self isOctetCharacter		ifTrue: [Character value: self asciiValue]		ifFalse: [self]! !!MultiCharacter methodsFor: 'comparing' stamp: 'yo 9/2/2002 16:51'!= other	^(other isCharacter) and: [self asciiValue = other asciiValue].! !!MultiCharacter methodsFor: 'as yet unclassified' stamp: 'yo 8/26/2002 11:10'!asString	^MultiString with: self.! !!MultiCharacter methodsFor: 'as yet unclassified' stamp: 'yo 8/26/2002 11:11'!value: anInteger	value _ anInteger.! !!MultiCharacter class methodsFor: 'as yet unclassified' stamp: 'yo 12/30/2002 11:01'!leadingChar: leadChar code: code	code >= 16r400000 ifTrue: [		self error: 'code is out of range'.	].	leadChar >= 256 ifTrue: [		self error: 'lead is out of range'.	].	^self value: (leadChar bitShift: 22) + code.! !!MultiCharacter class methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:45'!from: aCharacter	^ self value: aCharacter asciiValue.! !!MultiCharacter class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 16:39'!value: anInteger	anInteger < 256		ifTrue: [^ Character value: anInteger].	^ self basicNew value: anInteger.! !!MultiCharacter class methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:44'!allCharacters	self shouldNotImplement.! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/27/2002 11:20'!unparenthetically	"If the receiver starts with (..( and ends with matching )..), strip them"	| curr |	curr _ self.	[((curr first = $() and: [curr last = $)])] whileTrue:		[curr _ curr copyFrom: 2 to: (curr size - 1)].	^ curr"'((fred the bear))' unparenthetically"		! !!AbstractString methodsFor: 'private' stamp: 'yo 8/28/2002 15:22'!stringhash	^ self hash.! !!AbstractString methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:32'!sameAs: aString 	"Answer whether the receiver sorts equal to aString. The 	collation sequence is ascii with case differences ignored."	self subclassResponsibility.! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/26/2002 20:31'!asUnHtml	"Strip out all Html stuff (commands in angle brackets <>) and convertthe characters &<> back to their real value.  Leave actual cr and tab asthey were in text."	| in out char rest did |	in _ ReadStream on: self.	out _ WriteStream on: (String new: self size).	[in atEnd] whileFalse:		[in peek = $<			ifTrue: [in unCommand] 	"Absorb <...><...>"			ifFalse: [(char _ in next) = $&						ifTrue: [rest _ in upTo: $;.								did _ out position.								rest = 'lt' ifTrue: [out nextPut: $<].								rest = 'gt' ifTrue: [out nextPut: $>].								rest = 'amp' ifTrue: [out nextPut: $&].								did = out position ifTrue: [									self error: 'new HTML char encoding'.									"Please add it to this code"]]						ifFalse: [out nextPut: char]].		].	^ out contents! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/26/2002 23:06'!asHex	| stream |	stream _ WriteStream on: (String new: self size * 4).	self do: [ :ch | stream nextPutAll: ch hex ].	^stream contents! !!AbstractString methodsFor: 'converting' stamp: 'yo 11/8/2002 11:33'!asTranslatedWording	self subclassResponsibility! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/4/2003 14:37'!asCharacter	"Answer the receiver's first character, or '*' if none.  Idiosyncratic, provisional."	^ self size > 0 ifTrue: [self first] ifFalse: [$*]! !!AbstractString methodsFor: 'testing' stamp: 'yo 12/29/2002 10:30'!isUnicodeString	^ false.! !!AbstractString methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:32'!>= aString 	"Answer whether the receiver sorts after or equal to aString.	The collation order is simple ascii (with case differences)."	self subclassResponsibility.! !!AbstractString methodsFor: 'comparing' stamp: 'yo 8/28/2002 14:43'!hash	"#hash is implemented, because #= is implemented"	^ self class stringHash: self initialHash: self species hash! !!AbstractString methodsFor: 'accessing' stamp: 'yo 8/26/2002 22:26'!at: index 	^ super at: index.! !!AbstractString methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:31'!<= aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is simple ascii (with case differences)."	self subclassResponsibility.! !!AbstractString methodsFor: 'Camp Smalltalk' stamp: 'yo 8/26/2002 20:31'!sunitSubStrings        ^self substrings! !!AbstractString methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:32'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."	self subclassResponsibility.! !!AbstractString methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:22'!byteAt: index put: value	^ super at: index put: value.! !!AbstractString methodsFor: 'converting' stamp: 'yo 10/22/2002 17:38'!asDefaultDecodedString	^ self! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/28/2002 16:58'!encodeForHTTP	"change dangerous characters to their %XX form, for use in HTTP  	transactions"	| encodedStream |	encodedStream _ WriteStream on: String new.	self do: [:character | character isSafeForHTTP			ifTrue: [encodedStream nextPut: character]			ifFalse: [character == Character space					ifTrue: [encodedStream nextPut: $+]					ifFalse: 						[encodedStream nextPut: $%.						encodedStream nextPut: (character asciiValue // 16) asHexDigit.						encodedStream nextPut: (character asciiValue \\ 16) asHexDigit]]].	^ encodedStream contents.! !!AbstractString methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:32'!caseInsensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case insensitive."	self subclassResponsibility.! !!AbstractString methodsFor: 'Camp Smalltalk' stamp: 'yo 8/26/2002 20:31'!sunitAsSymbol        ^self asSymbol! !!AbstractString methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:34'!lineCount	"Answer the number of lines represented by the receiver, where every cr adds one line.  5/10/96 sw"	| cr count |	cr _ Character cr.	count _ 1  min: self size..	1 to: self size do:		[:i | (self at: i) = cr ifTrue: [count _ count + 1]].	^ count"'FredtheBear' lineCount"! !!AbstractString methodsFor: 'comparing' stamp: 'yo 8/27/2002 14:15'!charactersExactlyMatching: aString	"Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."	| count |	count _ self size min: aString size.	1 to: count do: [:i | 		(self at: i) = (aString at: i) ifFalse: [			^ i - 1]].	^ count! !!AbstractString methodsFor: 'private' stamp: 'yo 8/26/2002 22:53'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/28/2002 14:52'!findSelector	"Dan's code for hunting down selectors with keyword parts; while this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it."	| sel possibleParens level n |	sel _ self withBlanksTrimmed.	(sel includes: $:) ifTrue:		[sel _ sel copyReplaceAll: ':' with: ': '.	"for the style (aa max:bb) with no space"		possibleParens _ sel findTokens: Character separators.		sel _ self class streamContents:			[:s | level _ 0.			possibleParens do:				[:token |				(level = 0 and: [token endsWith: ':'])					ifTrue: [s nextPutAll: token]					ifFalse: [(n _ token occurrencesOf: $( ) > 0 ifTrue: [level _ level + n].							(n _ token occurrencesOf: $[ ) > 0 ifTrue: [level _ level + n].							(n _ token occurrencesOf: $] ) > 0 ifTrue: [level _ level - n].							(n _ token occurrencesOf: $) ) > 0 ifTrue: [level _ level - n]]]]].	sel isEmpty ifTrue: [^ nil].	self class correspondingSymbolClass hasInterned: sel ifTrue:		[:aSymbol | ^ aSymbol].	^ nil! !!AbstractString methodsFor: 'accessing' stamp: 'yo 8/28/2002 16:45'!indexOf: aCharacter	aCharacter isCharacter ifFalse: [^ 0].	^ self class		indexOfAscii: aCharacter asciiValue		inString: self		startingAt: 1.! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/26/2002 20:31'!withFirstCharacterDownshifted	"Answer an object like the receiver but with first character downshifted if necesary"	"'MElViN' withFirstCharacterDownshifted"	"#Will withFirstCharacterDownshifted"	| answer |	answer _ self isString				ifTrue: ["don't change receiver"					self copy]				ifFalse: [self asString].	answer at: 1 put: (answer at: 1) asLowercase.	^ self isString		ifTrue: [answer]		ifFalse: [answer as: self class]! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/28/2002 15:13'!translateWith: table	"translate the characters in the string by the given table, in place"	^ self translateFrom: 1 to: self size table: table! !!AbstractString methodsFor: 'testing' stamp: 'yo 8/28/2002 15:19'!isOctetString	self subclassResponsibility.! !!AbstractString methodsFor: 'accessing' stamp: 'yo 8/28/2002 14:28'!skipAnySubStr: delimiters startingAt: start 	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."	| any this ind ii |	ii _ start-1.	[(ii _ ii + 1) <= self size] whileTrue: [ "look for char that does not match"		any _ false.		delimiters do: [:delim |			delim isCharacter 				ifTrue: [(self at: ii) == delim ifTrue: [any _ true]]				ifFalse: ["a substring"					delim size > (self size - ii + 1) ifFalse: "Here's where the one-off error was."						[ind _ 0.						this _ true.						delim do: [:dd | 							dd == (self at: ii+ind) ifFalse: [this _ false].							ind _ ind + 1].						this ifTrue: [ii _ ii + delim size - 1.  any _ true]]							ifTrue: [any _ false] "if the delim is too big, it can't match"]].		any ifFalse: [^ ii]].	^ self size + 1! !!AbstractString methodsFor: 'Camp Smalltalk' stamp: 'yo 8/26/2002 20:31'!sunitMatch: aString        ^self match: aString! !!AbstractString methodsFor: 'testing' stamp: 'yo 7/29/2003 14:09'!includesUnifiedCharacter	self subclassResponsibility.! !!AbstractString methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:32'!compare: aString 	"Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	The collation sequence is ascii with case differences ignored.	To get the effect of a <= b, but ignoring case, use (a compare: b) <= 2."	self subclassResponsibility.! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/28/2002 16:51'!asOctetString	self subclassResponsibility.! !!AbstractString methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:21'!byteAt: index	^ super at: index.! !!AbstractString methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:31'!< aString 	"Answer whether the receiver sorts before aString.	The collation order is simple ascii (with case differences)."	self subclassResponsibility.! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/27/2002 11:13'!splitInteger	"Answer an array that is a splitting of self into a string and an integer.	'43Sam' ==> #(43 'Sam').  'Try90' ==> #('Try' 90)	BUT NOTE: 'Sam' ==> #('Sam' 0), and '90' ==> #('' 90)  ie, (<string> <integer>)."	| pos |	(pos _ self findFirst: [:d | d isDigit not]) = 0 ifTrue: [^ Array with: '' with: self asNumber].	self first isDigit ifTrue: [		^ Array with: (self copyFrom: 1 to: pos - 1) asNumber 				with: (self copyFrom: pos to: self size)].	(pos _ self findFirst: [:d | d isDigit]) = 0 ifTrue: [^ Array with: self with: 0].	^ Array with: (self copyFrom: 1 to: pos - 1)			with: (self copyFrom: pos to: self size) asNumber! !!AbstractString methodsFor: 'filter streaming' stamp: 'yo 8/26/2002 22:31'!byteEncode:aStream	^aStream writeString: self.! !!AbstractString methodsFor: 'filter streaming' stamp: 'yo 8/26/2002 22:31'!putOn:aStream	^aStream nextPutAll: self.! !!AbstractString methodsFor: 'accessing' stamp: 'yo 12/17/2002 16:56'!leadingCharRunLengthAt: index	| leadingChar |	leadingChar _ (self at: index) leadingChar.	index to: self size do: [:i |		(self at: i) leadingChar ~= leadingChar ifTrue: [^ i - index].	].	^ self size - index + 1.! !!AbstractString methodsFor: 'accessing' stamp: 'yo 8/26/2002 22:27'!at: index put: aCharacter 	super at: index put: Character asciiValue.! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/28/2002 15:14'!translateFrom: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	self class translate: self from: start to: stop table: table! !!AbstractString methodsFor: 'accessing' stamp: 'yo 8/26/2002 20:31'!byteSize	^self size! !!AbstractString methodsFor: 'system primitives' stamp: 'yo 11/5/2002 15:32'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	self subclassResponsibility.! !!AbstractString methodsFor: 'printing' stamp: 'yo 8/26/2002 22:58'!storeOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream nextPut: $'.	1 to: self size do:		[:i |		aStream nextPut: (x _ self at: i).		x = $' ifTrue: [aStream nextPut: x]].	aStream nextPut: $'! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/27/2002 14:38'!asFourCode	| result |	self size = 4 ifFalse: [^self error: 'must be exactly four characters'].	result _ self inject: 0 into: [:val :each | 256 * val + each asciiValue].	(result bitAnd: 16r80000000) = 0 		ifFalse: [self error: 'cannot resolve fourcode'].	(result bitAnd: 16r40000000) = 0 ifFalse: [^result - 16r80000000].	^ result! !!AbstractString methodsFor: 'testing' stamp: 'yo 8/4/2003 12:26'!isAsciiString	| c |	c _ self detect: [:each | each asciiValue > 127] ifNone: [nil].	^ c isNil.! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/27/2002 14:06'!withoutLeadingDigits	"Answer the portion of the receiver that follows any leading series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstNonDigit |	firstNonDigit _ (self findFirst: [:m | m isDigit not and: [m ~= $ ]]).	^ firstNonDigit > 0		ifTrue:			[self copyFrom: firstNonDigit  to: self size]		ifFalse:			['']"'234Whoopie' withoutLeadingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/27/2002 14:06'!withoutTrailingDigits	"Answer the portion of the receiver that precedes any trailing series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstDigit |	firstDigit _ (self findFirst: [:m | m isDigit or: [m = $ ]]).	^ firstDigit > 0		ifTrue:			[self copyFrom: 1 to: firstDigit-1]		ifFalse:			[self]"'Whoopie234' withoutTrailingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!AbstractString methodsFor: 'paragraph support' stamp: 'yo 8/26/2002 22:19'!indentationIfBlank: aBlock	"Answer the number of leading tabs in the receiver.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value."	| reader leadingTabs lastSeparator cr tab ch |	cr _ Character cr.	tab _ Character tab.	reader _ ReadStream on: self.	leadingTabs _ 0.	[reader atEnd not and: [(ch _ reader next) = tab]]		whileTrue: [leadingTabs _ leadingTabs + 1].	lastSeparator _ leadingTabs + 1.	[reader atEnd not and: [ch isSeparator and: [ch ~= cr]]]		whileTrue: [lastSeparator _ lastSeparator + 1. ch _ reader next].	lastSeparator = self size | (ch = cr)		ifTrue: [^aBlock value: leadingTabs].	^ leadingTabs.! !!AbstractString methodsFor: 'user interface' stamp: 'yo 8/26/2002 22:20'!asExplorerString	^ self asString! !!AbstractString methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:32'!caseSensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."	self subclassResponsibility.! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/27/2002 14:39'!asPacked	"Convert to a longinteger that describes the string"	^ self inject: 0 into: [ :pack :next | pack _ pack * 256 + next asInteger ].! !!AbstractString methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:34'!lineNumber: anIndex	"Answer a string containing the characters in the given line number.  5/10/96 sw"	| crString pos finalPos |	crString _ String with: Character cr.	pos _ 0.	1 to: anIndex - 1 do:		[:i | pos _ self findString: crString startingAt: pos + 1.			pos = 0 ifTrue: [^ nil]].	finalPos _ self findString: crString startingAt: pos + 1.	finalPos = 0 ifTrue: [finalPos _ self size + 1].	^ self copyFrom: pos + 1 to: finalPos - 1"'FredtheBear' lineNumber: 3"! !!AbstractString methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:33'!lineCorrespondingToIndex: anIndex	"Answer a string containing the line at the given character position.  1/15/96 sw:  Inefficient first stab at this"	| cr aChar answer |	cr _ Character cr.	answer _ ''.	1 to: self size do:		[:i | 			aChar _ self at: i.			aChar = cr				ifTrue:					[i > anIndex						ifTrue:							[^ answer]						ifFalse:							[answer _ '']]				ifFalse:					[answer _ answer copyWith: aChar]].	^ answer! !!AbstractString methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:32'!> aString 	"Answer whether the receiver sorts after aString.	The collation order is simple ascii (with case differences)."	self subclassResponsibility.! !!AbstractString methodsFor: 'printing' stamp: 'yo 8/26/2002 22:57'!encodeDoublingQuoteOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream print: $'.	1 to: self size do:		[:i |		aStream print: (x _ self at: i).		x = $' ifTrue: [aStream print: x]].	aStream print: $'! !!AbstractString methodsFor: 'converting' stamp: 'yo 8/28/2002 14:53'!asSymbol	"Answer the unique Symbol whose characters are the characters of the 	string."	^ self class correspondingSymbolClass intern: self.! !!AbstractString methodsFor: 'accessing' stamp: 'yo 10/15/2003 15:32'!findLastOccuranceOfString: subString startingAt: start 	"Answer the index of the last occurance of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	| last now |	last _ self findSubstring: subString in: self startingAt: start matchTable: CaseSensitiveOrder.	last = 0 ifTrue: [^ 0].	[last > 0] whileTrue: [		now _ last.		last _ self findSubstring: subString in: self startingAt: last + subString size matchTable: CaseSensitiveOrder.	].	^ now.! !!AbstractString class methodsFor: 'initialization' stamp: 'yo 8/28/2002 13:31'!initialize   "self initialize"	| order |	AsciiOrder _ (0 to: 255) as: ByteArray.	CaseInsensitiveOrder _ AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue + 1				put: (CaseInsensitiveOrder at: c asUppercase asciiValue +1)].	"Case-sensitive compare sorts space, digits, letters, all the rest..."	CaseSensitiveOrder _ ByteArray new: 256 withAll: 255.	order _ -1.	' 0123456789' do:  "0..10"		[:c | CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	($a to: $z) do:     "11-64"		[:c | CaseSensitiveOrder at: c asUppercase asciiValue + 1 put: (order _ order+1).		CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	1 to: CaseSensitiveOrder size do:		[:i | (CaseSensitiveOrder at: i) = 255 ifTrue:			[CaseSensitiveOrder at: i put: (order _ order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	"a table for translating to lower case"	LowercasingTable _ String withAll: (Character allCharacters collect: [:c | c asLowercase]).	"a table for translating to upper case"	UppercasingTable _ String withAll: (Character allCharacters collect: [:c | c asUppercase]).	"a table for testing tokenish (for fast numArgs)"	Tokenish _ String withAll: (Character allCharacters collect:									[:c | c tokenish ifTrue: [c] ifFalse: [$~]]).	"CR and LF--characters that terminate a line"	CSLineEnders _ CharacterSet empty.	CSLineEnders add: Character cr.	CSLineEnders add: Character lf. 	"separators and non-separators"	CSSeparators _ CharacterSet separators.	CSNonSeparators _ CSSeparators complement.! !!AbstractString class methodsFor: 'primitives' stamp: 'yo 8/28/2002 13:32'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	self subclassResponsibility.! !!AbstractString class methodsFor: 'initialization' stamp: 'yo 8/11/2003 21:11'!initializeHtmlEntities	"self initializeHtmlEntities"	HtmlEntities _ (Dictionary new: 128)		at: 'amp'	put: $&;		at: 'lt'		put: $<;		at: 'gt'		put: $>;		at: 'quot'	put: $";		at: 'euro'	put: Character euro;		yourself.	#('nbsp' 'iexcl' 'cent' 'pound' 'curren' 'yen' 'brvbar' 'sect' 'uml' 'copy' 'ordf' 'laquo' 'not' 'shy' 'reg' 'hibar' 'deg' 'plusmn' 'sup2' 'sup3' 'acute' 'micro' 'para' 'middot' 'cedil' 'sup1' 'ordm' 'raquo' 'frac14' 'frac12' 'frac34' 'iquest' 'Agrave' 'Aacute' 'Acirc' 'Atilde' 'Auml' 'Aring' 'AElig' 'Ccedil' 'Egrave' 'Eacute' 'Ecirc' 'Euml' 'Igrave' 'Iacute' 'Icirc' 'Iuml' 'ETH' 'Ntilde' 'Ograve' 'Oacute' 'Ocirc' 'Otilde' 'Ouml' 'times' 'Oslash' 'Ugrave' 'Uacute' 'Ucirc' 'Uuml' 'Yacute' 'THORN' 'szlig' 'agrave' 'aacute' 'acirc' 'atilde' 'auml' 'aring' 'aelig' 'ccedil' 'egrave' 'eacute' 'ecirc' 'euml' 'igrave' 'iacute' 'icirc' 'iuml' 'eth' 'ntilde' 'ograve' 'oacute' 'ocirc' 'otilde' 'ouml' 'divide' 'oslash' 'ugrave' 'uacute' 'ucirc' 'uuml' 'yacute' 'thorn' 'yuml' ) withIndexDo: [:each :index | HtmlEntities at: each put: (index + 159) asCharacter]! !!AbstractString class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:27'!readFrom: inStream	"Answer an instance of me that is determined by reading the stream, 	inStream. Embedded double quotes become the quote Character."	| outStream char done |	outStream _ WriteStream on: (self new: 16).	"go to first quote"	inStream skipTo: $'.	done _ false.	[done or: [inStream atEnd]]		whileFalse: 			[char _ inStream next.			char = $'				ifTrue: 					[char _ inStream next.					char = $'						ifTrue: [outStream nextPut: char]						ifFalse: [done _ true]]				ifFalse: [outStream nextPut: char]].	^outStream contents! !!AbstractString class methodsFor: 'primitives' stamp: 'yo 8/28/2002 13:32'!translate: aString from: start  to: stop  table: table	self subclassResponsibility.! !!AbstractString class methodsFor: 'primitives' stamp: 'yo 8/28/2002 13:06'!indexOfAscii: anInteger inString: aString startingAt: start	self subclassResponsibility.! !!AbstractString class methodsFor: 'primitives' stamp: 'yo 8/28/2002 13:32'!stringHash: aString initialHash: speciesHash	self subclassResponsibility.! !!AbstractString class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:29'!value: anInteger	^ self with: (Character value: anInteger).! !!AbstractString class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 14:50'!correspondingSymbolClass	^ self subclassResponsibility.! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:15'!asSymbol 	"Refer to the comment in String|asMultiSymbol."! !!MultiSymbol methodsFor: 'private' stamp: 'yo 11/3/2002 13:22'!species	^ MultiString! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 11/3/2002 13:21'!sunitAsClass        ^ SUnitNameResolver classNamed: self.! !!MultiSymbol methodsFor: 'testing' stamp: 'yo 11/3/2002 13:22'!isSymbol	^ true.! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:17'!isPvtSelector	"Answer whether the receiver is a private message selector, that is,	begins with 'pvt' followed by an uppercase letter, e.g. pvtStringhash."	^ (self beginsWith: 'pvt') and: [self size >= 4 and: [(self at: 4) isUppercase]].! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:15'!at: anInteger put: anObject 	"You cannot modify the receiver."	self errorNoModification! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:17'!isUnary	"Answer whether the receiver is an unary message selector."	^ self precedence == 1.! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:15'!byteEncode:aStream	^ aStream writeSymbol: self.! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:14'!asMultiSymbol 	"Refer to the comment in String|asMultiSymbol."! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:16'!isInfix	"Answer whether the receiver is an infix message selector."	^ self precedence == 2! !!MultiSymbol methodsFor: 'private' stamp: 'yo 11/3/2002 13:21'!string: aString	1 to: aString size do: [:j | super at: j put: (aString at: j)].	^ self! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:18'!storeOn: aStream 	aStream nextPut: $#.	(Scanner isLiteralMultiSymbol: self)		ifTrue: [aStream nextPutAll: self]		ifFalse: [super storeOn: aStream].! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 11/3/2002 13:23'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:15'!capitalized	^ self asString capitalized asMultiSymbol.! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:16'!isKeyword	"Answer whether the receiver is a message keyword."	^ self precedence == 3! !!MultiSymbol methodsFor: '-- all --' stamp: 'yo 8/30/2002 14:14'!= another	"Use == between two symbols..."	self == another ifTrue: [^ true].  "Was == "	another class == MultiSymbol ifTrue: [^ false].  "Was not == "	"Otherwise use string =..."	^ super = another.! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:16'!isOrientedFill	"Needs to be implemented here because symbols can occupy 'color' slots of morphs."	^ false! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:16'!errorNoModification	self error: 'symbols can not be modified.'! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:14'!asExplorerString	^ self printString.! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:15'!copy	"Answer with the receiver, because MultiSymbols are unique."! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:14'!asString 	"Refer to the comment in String|asString."	| newString |	newString _ String new: self size.	1 to: self size do: [:index | newString at: index put: (self at: index)].	^ newString! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:17'!shallowCopy	"Answer with the receiver, because MultiSymbols are unique."! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:17'!precedence	"Answer the receiver's precedence, assuming it is a valid Smalltalk	message selector or 0 otherwise.  The numbers are 1 for unary,	2 for binary and 3 for keyword selectors."	self size = 0 ifTrue: [^ 0].	self first isLetter ifFalse: [^ 2].	self last = $: ifTrue: [^ 3].	^ 1! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:16'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^ map newHashFor: self! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:17'!replaceFrom: start to: stop with: replacement startingAt: repStart	self errorNoModification! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:16'!flushCache	"Tell the interpreter to remove all entries with this symbol as a selector from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of the two selective flush methods needs to be used.	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."	<primitive: 119>! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:16'!isLiteral	"Answer whether the receiver is a valid Smalltalk literal."	^ true! !!MultiSymbol methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:15'!clone	"Answer with the receiver, because MultiSymbols are unique."! !!MultiSymbol class methodsFor: 'instance creation' stamp: 'yo 11/11/2002 23:43'!internLoadedSymbol: aStringOrMultiSymbol 	aStringOrMultiSymbol isOctetString		ifTrue: [^ Symbol intern: aStringOrMultiSymbol].	^ (self lookupForLoadedSymbol: aStringOrMultiSymbol)		ifNil: [NewMultiSymbols				add: ((aStringOrMultiSymbol isKindOf: MultiSymbol)						ifTrue: [aStringOrMultiSymbol]						ifFalse: [(self new: aStringOrMultiSymbol size)								string: aStringOrMultiSymbol])]! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:59'!shutDown: aboutToQuit	MultiSymbolTable addAll: NewMultiSymbols.	NewMultiSymbols _ WeakSet new.! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:55'!allMultiSymbolTablesDo: aBlock after: aMultiSymbol	NewMultiSymbols do: aBlock after: aMultiSymbol.	MultiSymbolTable do: aBlock after: aMultiSymbol.! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:56'!compactMultiSymbolTable	"Reduce the size of the symbol table so that it holds all existing symbols + 25% (changed from 1000 since sets like to have 25% free and the extra space would grow back in a hurry)"	| oldSize |	Smalltalk garbageCollect.	oldSize _ MultiSymbolTable array size.	MultiSymbolTable growTo: MultiSymbolTable size * 4 // 3 + 100.	^oldSize printString,'  ',(oldSize - MultiSymbolTable array size) printString, ' slot(s) reclaimed'! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:57'!newFromStream: stream 	| length multiString |	self isPointers | self isWords not		ifTrue: [^ super newFromStream: stream].	stream next = 128		ifTrue: [^ self error: 'not implemented'].	stream skip: -1.	length _ stream nextInt32.	multiString _ stream				nextWordsInto: (MultiString basicNew: length).	^ multiString asSymbol! !!MultiSymbol class methodsFor: 'private' stamp: 'yo 11/11/2002 23:22'!hasInternedALoadedSymbol: aString ifTrue: symBlock 	"Answer with false if aString hasnt been interned (into a MultiSymbol), 	otherwise supply the symbol to symBlock and return true."	| symbol |	^(symbol _ self lookupForLoadedSymbol: aString)		ifNil: [false]		ifNotNil: [symBlock value: symbol. true]! !!MultiSymbol class methodsFor: 'instance creation' stamp: 'yo 11/11/2002 23:13'!lookupForLoadedSymbol: aStringOrMultiSymbol	^(MultiSymbolTable likeLoadedSymbol: aStringOrMultiSymbol) ifNil: [		NewMultiSymbols likeLoadedSymbol: aStringOrMultiSymbol	].! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:54'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList _ OrderedCollection new.	(size _ aString size) = 0 ifTrue: [^ selectorList].	aString size = 1 ifTrue: [		ascii _ aString first asciiValue.		ascii < 128 ifTrue: [selectorList add: (OneCharacterMultiSymbols at: ascii+1)]	].	aString first isLetter ifFalse: [		aString size = 2 ifTrue: 			[MultiSymbol hasInterned: aString ifTrue:				[:s | selectorList add: s]].		^ selectorList	].	selectorList _ selectorList copyFrom: 2 to: selectorList size.	self allMultiSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findSubstring: aString in: each startingAt: 1 				matchTable: CaseInsensitiveOrder) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."MultiSymbol selectorsContaining: 'scon'"! !!MultiSymbol class methodsFor: 'instance creation' stamp: 'yo 11/4/2002 23:16'!intern: aStringOrMultiSymbol 	aStringOrMultiSymbol isOctetString		ifTrue: [^ Symbol intern: aStringOrMultiSymbol].	^ (self lookup: aStringOrMultiSymbol)		ifNil: [NewMultiSymbols				add: ((aStringOrMultiSymbol isKindOf: MultiSymbol)						ifTrue: [aStringOrMultiSymbol]						ifFalse: [(self new: aStringOrMultiSymbol size)								string: aStringOrMultiSymbol])]! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:57'!internCharacter: aCharacter	OneCharacterMultiSymbols ifNil: [^self intern: aCharacter asString].	^ OneCharacterMultiSymbols at: aCharacter asciiValue + 1! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:57'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	^ (aCollection as: MultiString) asMultiSymbol"	MultiSymbol newFrom: {$P. $e. $n}	{$P. $e. $n} as: MultiSymbol"! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:56'!compareTiming"MultiSymbol compareTiming"	| answer t selectorList implementorLists flattenedList md |	answer _ WriteStream on: String new.	Smalltalk timeStamp: answer.	answer cr; cr.	answer nextPutAll: MethodDictionary instanceCount printString,' method dictionaries'; cr; cr.	answer nextPutAll: (		MethodDictionary allInstances inject: 0 into: [ :sum :each | sum + each size]) printString,		' method dictionary entries'; cr; cr.	md _ MethodDictionary allInstances.	t _ [100 timesRepeat: [md do: [ :each | each includesKey: #majorShrink]]] timeToRun.	answer nextPutAll: t printString,		' ms to check all method dictionaries for #majorShrink 1000 times'; cr; cr.	selectorList _ MultiSymbol selectorsContaining: 'help'.	t _ [		3 timesRepeat: [selectorList collect: [:each | Smalltalk allImplementorsOf: each]]	] timeToRun.	answer nextPutAll: t printString,' ms to do #allImplementorsOf: for ',		selectorList size printString,' selectors like *help* 3 times'; cr; cr.	t _ [		3 timesRepeat: [			selectorList do: [:eachSel | md do: [ :eachMd | eachMd includesKey: eachSel]]		]	] timeToRun.	answer nextPutAll: t printString,' ms to do #includesKey: for ',		md size printString,' methodDicts for ',		selectorList size printString,' selectors like *help* 3 times'; cr; cr.	#('help' 'majorShrink') do: [ :substr |		answer nextPutAll: (MultiSymbol selectorsContaining: substr) size printString,				' selectors containing "',substr,'"'; cr.		t _ [			3 timesRepeat: [				selectorList _ MultiSymbol selectorsContaining: substr.			].		] timeToRun.		answer nextPutAll: t printString,' ms to find MultiSymbols containing *',substr,'* 3 times'; cr.		t _ [			3 timesRepeat: [				selectorList _ MultiSymbol selectorsContaining: substr.				implementorLists _ selectorList collect: [:each | Smalltalk allImplementorsOf: each].				flattenedList _ SortedCollection new.				implementorLists do: [:each | flattenedList addAll: each].			].		] timeToRun.		answer nextPutAll: t printString,' ms to find implementors of *',substr,'* 3 times'; cr; cr.	].	StringHolder new contents: answer contents; openLabel: 'timing'.! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:58'!readFrom: strm  "MultiSymbol readFromString: '#abc'"	strm peek = $# ifFalse: [self error: 'MultiSymbols must be introduced by #'].	^ (Scanner new scan: strm) advance  "Just do what the code scanner does"! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:58'!rehash		"MultiSymbol rehash"	"Rebuild the hash table, reclaiming unreferenced MultiSymbols."	MultiSymbolTable _ WeakSet withAll: self allInstances.	NewMultiSymbols _ WeakSet new.! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:56'!initialize	"MultiSymbol initialize"	MultiSymbol rehash.	OneCharacterMultiSymbols _ nil.	OneCharacterMultiSymbols _ (1 to: 256) collect: [ :i | (i - 1) asCharacter asSymbol].	Smalltalk addToShutDownList: self.! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:55'!thatStarts: leadingCharacters skipping: skipSym	"Answer a selector symbol that starts with leadingCharacters.	MultiSymbols beginning with a lower-case letter handled directly here.	Ignore case after first char.	If skipSym is not nil, it is a previous answer; start searching after it.	If no symbols are found, answer nil.	Used by Alt-q (Command-q) routines"	| size firstMatch key |	size _ leadingCharacters size.	size = 0 ifTrue: [^skipSym ifNil: [#''] ifNotNil: [nil]].	firstMatch _ leadingCharacters at: 1.	size > 1 ifTrue: [key _ leadingCharacters copyFrom: 2 to: size].	self allMultiSymbolTablesDo: [:each |			each size >= size ifTrue:				[					((each at: 1) == firstMatch and:						[key == nil or:							[(each findString: key startingAt: 2 caseSensitive: false) = 2]])								ifTrue: [^each]				]		] after: skipSym.	^nil"MultiSymbol thatStarts: 'sf' skipping: nil""MultiSymbol thatStarts: 'sf' skipping: #sfpGetFile:with:with:with:with:with:with:with:with:""MultiSymbol thatStarts: 'candidate' skipping: nil"! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:58'!possibleSelectorsFor: misspelled 	"Answer an ordered collection of possible corrections	for the misspelled selector in order of likelyhood"	| numArgs candidates lookupString best binary short long first ss |	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs _ lookupString numArgs.	(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollection new: 0].	first _ lookupString first.	short _ lookupString size - (lookupString size // 4 max: 3) max: 2.	long _ lookupString size + (lookupString size // 4 max: 3).	"First assemble candidates for detailed scoring"	candidates _ OrderedCollection new.	self allMultiSymbolTablesDo: [:s | (((ss _ s size) >= short	"not too short"			and: [ss <= long			"not too long"					or: [(s at: 1) = first]])	"well, any length OK if starts w/same letter"			and: [s numArgs = numArgs])	"and numArgs is the same"			ifTrue: [candidates add: s]].	"Then further prune these by correctAgainst:"	best _ lookupString correctAgainst: candidates.	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [		binary _ misspelled, ':'.		"try for missing colon"		MultiSymbol hasInterned: binary ifTrue: [:him | best addFirst: him]].	^ best! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:57'!lookup: aStringOrMultiSymbol	^(MultiSymbolTable like: aStringOrMultiSymbol) ifNil: [		NewMultiSymbols like: aStringOrMultiSymbol	].! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:58'!hasInterned: aString ifTrue: symBlock 	"Answer with false if aString hasnt been interned (into a MultiSymbol), 	otherwise supply the symbol to symBlock and return true."	| symbol |	^(symbol _ self lookup: aString)		ifNil: [false]		ifNotNil: [symBlock value: symbol. true]! !!MultiSymbol class methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 14:55'!allMultiSymbolTablesDo: aBlock	NewMultiSymbols do: aBlock.	MultiSymbolTable do: aBlock.! !!MultiString methodsFor: 'accessing' stamp: 'yo 10/31/2002 22:32'!wordAt: index	^ (self basicAt: index).! !!MultiString methodsFor: 'encoding' stamp: 'yo 7/29/2003 22:45'!writeLeadingCharRunsOn: stream	| runLength runValues runStart leadingChar |	self isEmpty ifTrue: [^ self].	runLength _ OrderedCollection new.	runValues _ OrderedCollection new.	runStart _ 1.	leadingChar _ (self at: runStart) leadingChar.	2 to: self size do: [:index |		(self at: index) leadingChar = leadingChar ifFalse: [			runValues add: leadingChar.			runLength add: (index - runStart).			leadingChar _ (self at: index) leadingChar.			runStart _ index.		].	].	runValues add: (self last) leadingChar.	runLength add: self size + 1 -  runStart.	stream nextPut: $(.	runLength do: [:rr | rr printOn: stream. stream space].	stream skip: -1; nextPut: $).	runValues do: [:vv | vv printOn: stream. stream nextPut: $,].	stream skip: -1.! !!MultiString methodsFor: 'converting' stamp: 'yo 11/4/2002 21:06'!asTranslatedWording	^ self! !!MultiString methodsFor: 'accessing' stamp: 'yo 11/4/2002 12:05'!findString: key startingAt: start caseSensitive: caseSensitive	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."	^ caseSensitive ifTrue: [		self			findMultiSubstring: key asMultiString			in: self			startingAt: start			matchTable: nil.	] ifFalse: [		self			findMultiSubstring: key asLowercase asMultiString			in: self asLowercase			startingAt: start			matchTable: nil.	].! !!MultiString methodsFor: 'converting' stamp: 'yo 8/27/2002 10:44'!asUnHtml	self flag: #toBeImplemented.! !!MultiString methodsFor: 'accessing' stamp: 'yo 8/28/2002 14:21'!indexOf: aCharacter	^ MultiString indexOfAscii: aCharacter asciiValue inMultiString: self startingAt: 1! !!MultiString methodsFor: 'comparing' stamp: 'yo 8/28/2002 14:39'!caseSensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."	^ (self multiStringCompare: self with: aString collated: nil) <= 2! !!MultiString methodsFor: 'system primitives' stamp: 'yo 11/4/2002 12:06'!findSubstring: key in: body startingAt: start matchTable: matchTable	^ self findMultiSubstring: key asMultiString in: body asMultiString startingAt: start matchTable: matchTable.! !!MultiString methodsFor: 'testing' stamp: 'yo 7/29/2003 14:10'!includesUnifiedCharacter	^ self isUnicodeStringWithCJK! !!MultiString methodsFor: 'comparing' stamp: 'yo 8/28/2002 14:36'!= aString 	aString isString ifFalse: [^ false].	^ (self multiStringCompare: self with: (MultiString from: aString) collated: nil) = 2.! !!MultiString methodsFor: 'accessing' stamp: 'yo 11/3/2002 13:20'!wordAt: index put: anInteger	self basicAt: index put: anInteger.! !!MultiString methodsFor: 'converting' stamp: 'yo 10/31/2002 22:30'!translateFrom: start to: stop table: table	"translate the characters in the string by the given table, in place"	self flag: #whatToDoWithThis.	super translateFrom: start to: stop table: table.! !!MultiString methodsFor: 'private' stamp: 'yo 8/28/2002 16:56'!replaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>	replacement class == String ifTrue: [		^ self replaceFrom: start to: stop with: (replacement asMultiString) startingAt: repStart.	]. 	^ super replaceFrom: start to: stop with: replacement startingAt: repStart.! !!MultiString methodsFor: 'converting' stamp: 'yo 8/27/2002 10:47'!encodeForHTTP	self flag: #toBeImplemented.! !!MultiString methodsFor: 'private' stamp: 'yo 8/18/2003 11:02'!mutateJISX0208StringToUnicode	| c |	1 to: self size do: [:i |		c _ self at: i.		(c leadingChar = JISX0208 leadingChar or: [			c leadingChar = (JISX0208 leadingChar bitShift: 2)]) ifTrue: [			self basicAt: i put: (MultiCharacter leadingChar: UnicodeJapanese leadingChar code: (c asUnicode)) asciiValue.		]	].! !!MultiString methodsFor: 'converting' stamp: 'yo 8/27/2002 10:45'!capitalized	self flag: #toBeImplemented.! !!MultiString methodsFor: 'converting' stamp: 'yo 10/31/2002 22:30'!substrings	"Answer an array of the substrings that compose the receiver."	^self findBetweenSubStrs: (MultiString from: Character separators).! !!MultiString methodsFor: 'system primitives' stamp: 'yo 8/28/2002 14:35'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	^ self multiStringCompare: string1 with: string2 collated: order.! !!MultiString methodsFor: 'converting' stamp: 'yo 8/30/2002 16:44'!asMultiString 	^ self! !!MultiString methodsFor: 'converting' stamp: 'yo 8/28/2002 15:17'!asByteArray	"Convert to a ByteArray with the ascii values of the string."	| b |	b _ ByteArray new: self size * 4.	1 to: self size * 4 do: [:i |		b at: i put: (self byteAt: i).	].	^ b.! !!MultiString methodsFor: 'accessing' stamp: 'yo 11/3/2002 13:19'!byteAt: index put: aByte	| d r w |	d _ (index + 3) // 4.	r _ (index - 1) \\ 4 + 1.	w _ (self wordAt: d) bitAnd: ((16rFF<<((4 - r)*8)) bitInvert32).	w _ w + (aByte<<((4 - r)*8)).	self basicAt: d put: w.	^ aByte.! !!MultiString methodsFor: 'internet' stamp: 'yo 8/26/2002 22:39'!decodeQuotedPrintable	"Assume receiver is in MIME 'quoted-printable' encoding, and decode it."	self flag: #toBeImplemented.! !!MultiString methodsFor: 'encoding' stamp: 'yo 10/23/2002 23:32'!putInteger32: anInteger at: location	| integer |	integer _ anInteger.	integer < 0 ifTrue: [integer :=  1073741824 - integer. ].	self basicAt: location+3 put: (integer \\ 256).	self basicAt: location+2 put: (integer bitShift: -8) \\ 256.	self basicAt: location+1 put: (integer bitShift: -16) \\ 256.	self basicAt: location put: (integer bitShift: -24) \\ 256.! !!MultiString methodsFor: 'converting' stamp: 'yo 8/28/2002 14:47'!asPacked	self inject: 0 into: [:pack :next | pack _ pack * 16r100000000 + next asInteger].! !!MultiString methodsFor: 'encoding' stamp: 'yo 10/23/2002 23:32'!getInteger32: location	| integer |	integer := 		((self basicAt: location) bitShift: 24) +		((self basicAt: location+1) bitShift: 16) +		((self basicAt: location+2) bitShift: 8) +		(self basicAt: location+3).	integer > 1073741824 ifTrue: [^ 1073741824 - integer ].	^ integer.! !!MultiString methodsFor: 'system primitives' stamp: 'yo 12/27/2002 04:34'!findMultiSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index c1 c2 |	self var: #key declareC: 'unsigned int *key'.	self var: #body declareC: 'unsigned int *body'.	self var: #matchTable declareC: 'unsigned char *matchTable'.	self var: #c1 declareC: 'unsigned int c1'.	self var: #c2 declareC: 'unsigned int c2'.	matchTable == nil ifTrue: [		key size = 0 ifTrue: [^ 0].		start to: body size - key size + 1 do:			[:startIndex |			index _ 1.				[(body at: startIndex+index-1)					= (key at: index)]					whileTrue:					[index = key size ifTrue: [^ startIndex].					index _ index+1]].		^ 0	].	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index _ 1.		[c1 _ body at: startIndex+index-1.		c2 _ key at: index.		((c1 leadingChar = 0) ifTrue: [(matchTable at: c1 asciiValue + 1)]						ifFalse: [c1 asciiValue + 1])			= ((c2 leadingChar = 0) ifTrue: [(matchTable at: c2 asciiValue + 1)]								ifFalse: [c2 asciiValue + 1])]			whileTrue:				[index = key size ifTrue: [^ startIndex].				index _ index+1]].	^ 0! !!MultiString methodsFor: 'system primitives' stamp: 'yo 11/5/2002 15:14'!multiStringCompare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	self var: #string1 declareC: 'unsigned int *string1'.	self var: #string2 declareC: 'unsigned int *string2'.	self var: #order declareC: 'unsigned char *order'.	order == nil ifTrue: [		len1 _ string1 size.		len2 _ string2 size.		1 to: (len1 min: len2) do:			[:i |			c1 _ string1 basicAt: i.			c2 _ string2 basicAt: i.			c1 = c2 ifFalse: 				[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].		len1 = len2 ifTrue: [^ 2].		len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].	].	len1 _ string1 size.	len2 _ string2 size.	1 to: (len1 min: len2) do:		[:i |		c1 _ string1 basicAt: i.		c2 _ string2 basicAt: i.		c1 < 256 ifTrue: [c1 _ order at: c1 + 1].		c2 < 256 ifTrue: [c2 _ order at: c2 + 1].		c1 = c2 ifFalse: 			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!MultiString methodsFor: 'accessing' stamp: 'yo 8/28/2002 14:23'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	ans _ MultiString indexOfAscii: aCharacter asciiValue inMultiString: self  startingAt: start.	ans = 0		ifTrue: [^ aBlock value]		ifFalse: [^ ans]! !!MultiString methodsFor: 'accessing' stamp: 'yo 8/28/2002 13:42'!at: index put: aCharacter 	aCharacter isCharacter ifFalse: [		self error: 'MultiStrings only store (descendents of) Characters'.	].	self basicAt: index put: aCharacter asciiValue.! !!MultiString methodsFor: 'comparing' stamp: 'yo 11/12/2002 10:59'!caseInsensitiveLessOrEqual: aString 	^ (self multiStringCompare: self with: aString asMultiString collated: CaseInsensitiveOrder) <= 2.! !!MultiString methodsFor: 'accessing' stamp: 'yo 8/28/2002 13:40'!at: index 	^ MultiCharacter value: (self basicAt: index).! !!MultiString methodsFor: 'converting' stamp: 'yo 10/24/2002 14:09'!asFileName	| string |	string _ self isOctetString				ifTrue: [self]				ifFalse: [self convertToSystemString].	^ FileDirectory checkName: string fixErrors: true! !!MultiString methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:22'!< aString 	^ (self multiStringCompare: self with: aString asMultiString collated: nil) = 1.! !!MultiString methodsFor: 'accessing' stamp: 'yo 8/28/2002 13:46'!findAnySubStr: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."	| min ind |	min _ self size + 1.	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"		delim isCharacter			ifTrue: [ind _ self indexOfSubCollection: (MultiString with: delim) 						startingAt: start ifAbsent: [min]]			ifFalse: [ind _ self indexOfSubCollection: (MultiString from: delim) 						startingAt: start ifAbsent: [min]].			min _ min min: ind].	^ min.! !!MultiString methodsFor: 'testing' stamp: 'yo 12/30/2002 15:57'!isUnicodeString	self do: [:c |		c isUnicode ifTrue: [			^ true		].	].	^ false.! !!MultiString methodsFor: 'converting' stamp: 'yo 8/27/2002 14:04'!unzipped	self flag: #toBeImplemented.! !!MultiString methodsFor: 'comparing' stamp: 'yo 8/28/2002 14:35'!<= aString	^ (self multiStringCompare: self with: aString collated: nil) <= 2.! !!MultiString methodsFor: 'accessing' stamp: 'yo 8/28/2002 14:22'!indexOf: aCharacter startingAt: start	^ MultiString indexOfAscii: aCharacter asciiValue inMultiString: self startingAt: start.! !!MultiString methodsFor: 'testing' stamp: 'yo 8/28/2002 22:43'!isOctetString	1 to: self size do: [:pos |		(self basicAt: pos) >= 256 ifTrue: [^ false].	].	^ true.! !!MultiString methodsFor: 'internet' stamp: 'yo 8/26/2002 22:47'!unescapePercents	self flag: #toBeImplemented.! !!MultiString methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:22'!byteSize	^ self size * 4.! !!MultiString methodsFor: 'comparing' stamp: 'yo 8/28/2002 14:37'!> aString	^ (self multiStringCompare: self with: aString collated: nil) = 3.! !!MultiString methodsFor: 'accessing' stamp: 'yo 10/31/2002 22:29'!byteAt: index	| d r |	d _ (index + 3) // 4.	r _ (index - 1) \\ 4 + 1.	^ (self wordAt: d) digitAt: ((4 - r) + 1).! !!MultiString methodsFor: 'comparing' stamp: 'yo 8/28/2002 14:37'!>= aString	^ (self multiStringCompare: self with: aString collated: nil) >= 2.! !!MultiString methodsFor: 'converting' stamp: 'yo 8/26/2002 23:08'!asHtml	self flag: #toBeImplemented.! !!MultiString methodsFor: 'converting' stamp: 'yo 8/28/2002 15:18'!asOctetString	| n |	self isOctetString ifFalse: [		self error: 'I have non-single byte character(s)'.	].	n _ String new: self size.	1 to: self size do: [:i |		n basicAt: i put: (self basicAt: i).	].	^ n.! !!MultiString methodsFor: 'converting' stamp: 'yo 7/28/2003 14:20'!convertToWithConverter: converter	| readStream writeStream |	readStream _ self readStream.	writeStream _ String new writeStream.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		converter nextPut: readStream next toStream: writeStream	].	converter emitSequenceToResetStateIfNeededOn: writeStream.	^ writeStream contents.! !!MultiString methodsFor: 'converting' stamp: 'yo 9/26/2003 11:51'!convertToSystemString	| readStream writeStream converter |	readStream _ self readStream.	writeStream _ String new writeStream.	converter _ Smalltalk systemLanguage defaultSystemConverter.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		converter nextPut: readStream next toStream: writeStream	].	converter emitSequenceToResetStateIfNeededOn: writeStream.	^ writeStream contents.! !!MultiString methodsFor: 'comparing' stamp: 'yo 8/28/2002 14:41'!crc16	"Compute a 16 bit cyclic redundancy check."	| crc |	crc := 0.	1 to: self size * 4 do: [:i |		crc := (crc bitShift: -8) bitXor: (		 #(	16r0000	16rC0C1	16rC181	16r0140	16rC301	16r03C0	16r0280	16rC241			16rC601	16r06C0	16r0780	16rC741	16r0500	16rC5C1	16rC481	16r0440			16rCC01	16r0CC0	16r0D80	16rCD41	16r0F00	16rCFC1	16rCE81	16r0E40			16r0A00	16rCAC1	16rCB81	16r0B40	16rC901	16r09C0	16r0880	16rC841			16rD801	16r18C0	16r1980	16rD941	16r1B00	16rDBC1	16rDA81	16r1A40			16r1E00	16rDEC1	16rDF81	16r1F40	16rDD01	16r1DC0	16r1C80	16rDC41			16r1400	16rD4C1	16rD581	16r1540	16rD701	16r17C0	16r1680	16rD641			16rD201	16r12C0	16r1380	16rD341	16r1100	16rD1C1	16rD081	16r1040			16rF001	16r30C0	16r3180	16rF141	16r3300	16rF3C1	16rF281	16r3240			16r3600	16rF6C1	16rF781	16r3740	16rF501	16r35C0	16r3480	16rF441			16r3C00	16rFCC1	16rFD81	16r3D40	16rFF01	16r3FC0	16r3E80	16rFE41			16rFA01	16r3AC0	16r3B80	16rFB41	16r3900	16rF9C1	16rF881	16r3840			16r2800	16rE8C1	16rE981	16r2940	16rEB01	16r2BC0	16r2A80	16rEA41			16rEE01	16r2EC0	16r2F80	16rEF41	16r2D00	16rEDC1	16rEC81	16r2C40			16rE401	16r24C0	16r2580	16rE541	16r2700	16rE7C1	16rE681	16r2640			16r2200	16rE2C1	16rE381	16r2340	16rE101	16r21C0	16r2080	16rE041			16rA001	16r60C0	16r6180	16rA141	16r6300	16rA3C1	16rA281	16r6240			16r6600	16rA6C1	16rA781	16r6740	16rA501	16r65C0	16r6480	16rA441			16r6C00	16rACC1	16rAD81	16r6D40	16rAF01	16r6FC0	16r6E80	16rAE41			16rAA01	16r6AC0	16r6B80	16rAB41	16r6900	16rA9C1	16rA881	16r6840			16r7800	16rB8C1	16rB981	16r7940	16rBB01	16r7BC0	16r7A80	16rBA41			16rBE01	16r7EC0	16r7F80	16rBF41	16r7D00	16rBDC1	16rBC81	16r7C40			16rB401	16r74C0	16r7580	16rB541	16r7700	16rB7C1	16rB681	16r7640			16r7200	16rB2C1	16rB381	16r7340	16rB101	16r71C0	16r7080	16rB041			16r5000	16r90C1	16r9181	16r5140	16r9301	16r53C0	16r5280	16r9241			16r9601	16r56C0	16r5780	16r9741	16r5500	16r95C1	16r9481	16r5440			16r9C01	16r5CC0	16r5D80	16r9D41	16r5F00	16r9FC1	16r9E81	16r5E40			16r5A00	16r9AC1	16r9B81	16r5B40	16r9901	16r59C0	16r5880	16r9841			16r8801	16r48C0	16r4980	16r8941	16r4B00	16r8BC1	16r8A81	16r4A40			16r4E00	16r8EC1	16r8F81	16r4F40	16r8D01	16r4DC0	16r4C80	16r8C41			16r4400	16r84C1	16r8581	16r4540	16r8701	16r47C0	16r4680	16r8641			16r8201	16r42C0	16r4380	16r8341	16r4100	16r81C1	16r8081	16r4040)			 at: ((crc bitXor: (self byteAt: i)) bitAnd: 16rFF) + 1) ].	^crc.! !!MultiString methodsFor: 'comparing' stamp: 'yo 11/5/2002 15:14'!sameAs: aString 	"Answer whether the receiver sorts equal to aString. The 	collation sequence is ascii with case differences ignored."	^ (self multiStringCompare: self with: aString asMultiString collated: CaseInsensitiveOrder) = 2.! !!MultiString methodsFor: 'accessing' stamp: 'yo 8/28/2002 14:24'!indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock	"returns the index of the first character in the given set, starting from start"	| ans |	ans _ MultiString findFirstInMultiString: self  inSet: aCharacterSet byteArrayMap startingAt: start.	ans = 0		ifTrue: [^ aBlock value]		ifFalse: [^ ans]! !!MultiString methodsFor: 'testing' stamp: 'yo 12/30/2002 16:15'!isUnicodeStringWithCJK	self do: [:c |		c isUnicodeCJK ifTrue: [			^ true		].	].	^ false.! !!MultiString methodsFor: 'accessing' stamp: 'yo 8/28/2002 14:20'!findTokens: delimiters	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."	| tokens keyStart keyStop separators |	tokens _ OrderedCollection new.	separators _ delimiters isCharacter		ifTrue: [Array with: delimiters]		ifFalse: [delimiters].	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipDelimiters: separators startingAt: keyStop.		keyStop _ self findDelimiters: separators startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!MultiString methodsFor: 'converting' stamp: 'yo 8/30/2002 14:09'!asMultiSymbol	^ self asSymbol.! !!MultiString methodsFor: 'comparing' stamp: 'yo 8/28/2002 14:38'!beginsWith: prefix	"Answer whether the receiver begins with the given prefix string."	self size < prefix size ifTrue: [^ false].	^ (self findMultiSubstring: (MultiString from: prefix) in: self startingAt: 1			matchTable: nil) = 1! !!MultiString methodsFor: 'converting' stamp: 'yo 8/28/2002 14:46'!asFourCode	| result |	self size = 1 ifFalse: [^self error: 'must be exactly four octets'].	result _ self basicAt: 1.	(result bitAnd: 16r80000000) = 0 		ifFalse: [self error: 'cannot resolve fourcode'].	(result bitAnd: 16r40000000) = 0 ifFalse: [^result - 16r80000000].	^ result! !!MultiString methodsFor: 'comparing' stamp: 'yo 10/31/2002 22:31'!compare: aString 	"Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after."	^ self multiStringCompare: self with: aString collated: nil! !!MultiString class methodsFor: 'enumeration' stamp: 'yo 8/12/2003 17:14'!allMultiStringMethods  	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| list adder num i |	list _ Set new.	adder _ [ :mrClass :mrSel |		list add: (			MethodReference new				setStandardClass: mrClass				methodSymbol: mrSel		)	].	num _ CompiledMethod allInstances size.	i _ 0.	'processing...' displayProgressAt: Sensor cursorPoint from: 0 to: num during: [:bar |		SystemNavigation new allBehaviorsDo: [ :class |			class selectors do: [:s |				bar value: (i _ i + 1).								((class sourceCodeAt: s) asString isOctetString) ifFalse: [					adder value: class value: s.				]			]		]	].	^ list.! !!MultiString class methodsFor: 'primitives' stamp: 'yo 8/28/2002 15:10'!translate: aString from: start  to: stop  table: table	^ self translateMultiString: aString from: start  to: stop  table: table.! !!MultiString class methodsFor: 'primitives' stamp: 'yo 8/28/2002 13:07'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	^ self findFirstInMultiString: aString inSet: inclusionMap startingAt: start.! !!MultiString class methodsFor: 'enumeration' stamp: 'yo 8/27/2003 07:01'!allMethodsWithEncodingTag: encodingTag	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| list adder num i |	list _ Set new.	adder _ [ :mrClass :mrSel |		list add: (			MethodReference new				setStandardClass: mrClass				methodSymbol: mrSel		)	].	num _ CompiledMethod allInstances size.	i _ 0.	'processing...' displayProgressAt: Sensor cursorPoint from: 0 to: num during: [:bar |		SystemNavigation new allBehaviorsDo: [ :class |			class selectors do: [:s |				bar value: (i _ i + 1).								(self string: (class sourceCodeAt: s) asString hasEncoding: encodingTag) ifTrue: [					adder value: class value: s.				]			]		]	].	^ list.! !!MultiString class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:30'!value: anInteger	^ self with: (MultiCharacter value: anInteger).! !!MultiString class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 14:51'!correspondingSymbolClass	^ MultiSymbol! !!MultiString class methodsFor: 'primitives' stamp: 'yo 8/28/2002 13:16'!multiStringHash: aString initialHash: speciesHash	| stringSize hash low |	self var: #aHash declareC: 'int speciesHash'.	self var: #aString declareC: 'unsigned int *aString'.	stringSize _ aString size.	hash _ speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash _ hash + (aString at: pos) asciiValue.		"Begin hashMultiply"		low _ hash bitAnd: 16383.		hash _ (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash.! !!MultiString class methodsFor: 'enumeration' stamp: 'yo 8/5/2003 14:20'!string: str hasEncoding: encoding	str do: [:each | each leadingChar = encoding ifTrue: [^ true]].	^ false.! !!MultiString class methodsFor: 'instance creation' stamp: 'yo 8/30/2002 17:00'!fromISO2022JPString: string 	| tempFileName stream contents |	tempFileName _ Time millisecondClockValue printString , '.txt'.	FileDirectory default deleteFileNamed: tempFileName ifAbsent: [].	stream _ StandardFileStream fileNamed: tempFileName.	[stream nextPutAll: string]		ensure: [stream close].	stream _ FileStream fileNamed: tempFileName.	contents _ stream contentsOfEntireFile.	FileDirectory default deleteFileNamed: tempFileName ifAbsent: [].	^ contents! !!MultiString class methodsFor: 'primitives' stamp: 'yo 11/7/2002 14:18'!stringHash: aString initialHash: speciesHash	aString isOctetString ifTrue: [^ aString asOctetString hash].	^ self multiStringHash: aString initialHash: speciesHash.! !!MultiString class methodsFor: 'instance creation' stamp: 'yo 8/30/2002 16:57'!from: aString 	| multiString |	(aString isMemberOf: self)		ifTrue: [^ aString copy].	multiString _ self new: aString size.	1 to: aString size do: [:index | multiString basicAt: index put: (aString basicAt: index)].	^ multiString! !!MultiString class methodsFor: 'primitives' stamp: 'yo 8/28/2002 13:00'!findFirstInMultiString: aString  inSet: inclusionMap  startingAt: start	| i stringSize ascii more |		self var: #aString declareC: 'unsigned int *aString'.	self var: #inclusionMap declareC: 'char *inclusionMap'.	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize _ aString size.	more _ true.	i _ start - 1.	[more and: [i + 1 <= stringSize]] whileTrue: [		i _ i + 1.		ascii _ (aString at: i) asciiValue.		more _ ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i + 1 > stringSize ifTrue: [^ 0].	^ i.! !!MultiString class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:39'!fromString: aString 	"Answer an instance of me that is a copy of the argument, aString."	| inst |	(aString isMemberOf: self) ifTrue: [		^ aString copy.	].	inst _ self new: aString size.	1 to: aString size do: [:pos |		inst basicAt: pos put: (aString basicAt: pos).	].	^ inst.! !!MultiString class methodsFor: 'instance creation' stamp: 'yo 10/23/2002 23:33'!fromByteArray: aByteArray 	| inst |	aByteArray size \\ 4 = 0 ifFalse: [^ String fromByteArray: aByteArray ].	inst _ self new: aByteArray size // 4.	4 to: aByteArray size by: 4 do: [:i |		inst basicAt: i // 4			put: ((aByteArray at: i - 3) << 24) + 				((aByteArray at: i - 2) << 16) +				 ((aByteArray at: i - 1) << 8) +				(aByteArray at: i)	].	^ inst! !!MultiString class methodsFor: 'primitives' stamp: 'yo 8/28/2002 13:06'!indexOfAscii: anInteger inString: aString startingAt: start	^ self indexOfAscii: anInteger inMultiString: aString startingAt: start.! !!MultiString class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:25'!fromPacked: aLong	"Convert from a longinteger to a String of length 4."	| s val |	s _ self new: 1.	val _ ((aLong digitAt: 4) << 24) |			((aLong digitAt: 3) << 16) |			((aLong digitAt: 2) << 8) |			(aLong digitAt: 1).	s basicAt: 1 put: val.	^ s."MultiString fromPacked: 'TEXT' asPacked"! !!MultiString class methodsFor: 'plugin generation' stamp: 'yo 8/26/2002 20:42'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asCharPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isBytes')! !!MultiString class methodsFor: 'plugin generation' stamp: 'yo 8/26/2002 20:42'!ccgDeclareCForVar: aSymbolOrString	^'char *', aSymbolOrString! !!MultiString class methodsFor: 'enumeration' stamp: 'yo 8/27/2003 07:00'!allNonAsciiMethods  	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| list adder num i |	list _ Set new.	adder _ [ :mrClass :mrSel |		list add: (			MethodReference new				setStandardClass: mrClass				methodSymbol: mrSel		)	].	num _ CompiledMethod allInstances size.	i _ 0.	'processing...' displayProgressAt: Sensor cursorPoint from: 0 to: num during: [:bar |		SystemNavigation new allBehaviorsDo: [ :class |			class selectors do: [:s |				bar value: (i _ i + 1).								((class sourceCodeAt: s) asString isAsciiString) ifFalse: [					adder value: class value: s.				]			]		]	].	^ list.! !!MultiString class methodsFor: 'primitives' stamp: 'yo 11/4/2002 22:58'!translateMultiString: aString from: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	| char |	self var: #table  declareC: 'unsigned char *table'.	self var: #aString  declareC: 'unsigned int *aString'.	start to: stop do: [:i |		char _ aString basicAt: i.		char < 256 ifTrue: [			aString basicAt: i put: (table at: char+1) asciiValue		].	].! !!MultiString class methodsFor: 'primitives' stamp: 'yo 8/28/2002 13:05'!indexOfAscii: anInteger inMultiString: aString startingAt: start	| stringSize |	self var: #aCharacter declareC: 'int anInteger'.	self var: #aString declareC: 'unsigned int *aString'.	stringSize _ aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !!AbstractString methodsFor: 'internet' stamp: 'yo 11/23/2003 20:35'!decodeMimeHeader	"See RFC 2047, MIME Part Three: Message Header Extension for Non-ASCII  	Text. Text containing non-ASCII characters is encoded by the sequence  	=?character-set?encoding?encoded-text?=  	Encoding is Q (quoted printable) or B (Base64), handled by  	Base64MimeConverter / RFC2047MimeConverter.	Thanks to Yokokawa-san, it works in m17n package.  Try the following:	'=?ISO-2022-JP?B?U1dJS0lQT1AvGyRCPUJDKyVpJXMlQRsoQi8=?= =?ISO-2022-JP?B?GyRCJVElRiUjJSobKEIoUGF0aW8p?=' decodeMimeHeader."	| input output temp charset decoder encodedStream encoding pos |	input _ ReadStream on: self.	output _ WriteStream on: String new.	[output		nextPutAll: (input upTo: $=).	"ASCII Text"	input atEnd]		whileFalse: [(temp _ input next) = $?				ifTrue: [charset _ input upTo: $?.					encoding _ (input upTo: $?) asUppercase.					temp _ input upTo: $?.					input next.					"Skip final ="					encodedStream _ MultiByteBinaryOrTextStream on: String new encoding: charset.					decoder _ encoding = 'B'								ifTrue: [Base64MimeConverter new]								ifFalse: [RFC2047MimeConverter new].					decoder						mimeStream: (ReadStream on: temp);						 dataStream: encodedStream;						 mimeDecode.					output nextPutAll: encodedStream reset contents.					pos _ input position.					input skipSeparators.					"Delete spaces if followed by ="					input peek = $=						ifFalse: [input position: pos]]				ifFalse: [output nextPut: $=;						 nextPut: temp]].	^ output contents! !AbstractString initialize!MultiSymbol initialize!Unicode subclass: #UnicodeAlphabeticPresentations	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeAlphabeticPresentations class	instanceVariableNames: ''!!UnicodeAlphabeticPresentations class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 81.! !Unicode subclass: #UnicodeArabic	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeArabic class	instanceVariableNames: ''!!UnicodeArabic class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 25.! !Unicode subclass: #UnicodeArabicPresentationsA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeArabicPresentationsA class	instanceVariableNames: ''!!UnicodeArabicPresentationsA class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 82.! !Unicode subclass: #UnicodeArabicPresentationsB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeArabicPresentationsB class	instanceVariableNames: ''!!UnicodeArabicPresentationsB class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 84.! !Unicode subclass: #UnicodeArmenian	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeArmenian class	instanceVariableNames: ''!!UnicodeArmenian class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 23.! !Unicode subclass: #UnicodeArrows	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeArrows class	instanceVariableNames: ''!!UnicodeArrows class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 62.! !Unicode subclass: #UnicodeBengali	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeBengali class	instanceVariableNames: ''!!UnicodeBengali class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 29.! !Unicode subclass: #UnicodeBlockElements	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeBlockElements class	instanceVariableNames: ''!!UnicodeBlockElements class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 69.! !Unicode subclass: #UnicodeBoxDrawing	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeBoxDrawing class	instanceVariableNames: ''!!UnicodeBoxDrawing class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 68.! !Unicode subclass: #UnicodeBraille	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeBraille class	instanceVariableNames: ''!!UnicodeBraille class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 75.! !Unicode subclass: #UnicodeBuhid	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeBuhid class	instanceVariableNames: ''!!UnicodeBuhid class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 50.! !Unicode subclass: #UnicodeByzantineMusicals	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeByzantineMusicals class	instanceVariableNames: ''!!UnicodeByzantineMusicals class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 88.! !Unicode subclass: #UnicodeCanadianAboriginal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeCanadianAboriginal class	instanceVariableNames: ''!!UnicodeCanadianAboriginal class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 45.! !Unicode subclass: #UnicodeCherokee	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeCherokee class	instanceVariableNames: ''!!UnicodeCherokee class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 44.! !Unicode subclass: #UnicodeCombiningDiacritical	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeCombiningDiacritical class	instanceVariableNames: ''!!UnicodeCombiningDiacritical class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 20.! !Unicode subclass: #UnicodeCombiningDiacriticalForSymbols	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeCombiningDiacriticalForSymbols class	instanceVariableNames: ''!!UnicodeCombiningDiacriticalForSymbols class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 59.! !Unicode subclass: #UnicodeCombiningHalfMarks	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeCombiningHalfMarks class	instanceVariableNames: ''!!UnicodeCombiningHalfMarks class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 83.! !Unicode subclass: #UnicodeControlPictures	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeControlPictures class	instanceVariableNames: ''!!UnicodeControlPictures class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 65.! !Unicode subclass: #UnicodeCurrencySymbols	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeCurrencySymbols class	instanceVariableNames: ''!!UnicodeCurrencySymbols class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 58.! !Unicode subclass: #UnicodeCyrillic	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeCyrillic class	instanceVariableNames: ''!!UnicodeCyrillic class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 22.! !Unicode subclass: #UnicodeDeseret	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeDeseret class	instanceVariableNames: ''!!UnicodeDeseret class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 87.! !Unicode subclass: #UnicodeDevanagari	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeDevanagari class	instanceVariableNames: ''!!UnicodeDevanagari class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 28.! !Unicode subclass: #UnicodeDingbats	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeDingbats class	instanceVariableNames: ''!!UnicodeDingbats class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 72.! !Unicode subclass: #UnicodeEnclosedAlnums	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeEnclosedAlnums class	instanceVariableNames: ''!!UnicodeEnclosedAlnums class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 67.! !Unicode subclass: #UnicodeEthiopic	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeEthiopic class	instanceVariableNames: ''!!UnicodeEthiopic class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 43.! !Unicode subclass: #UnicodeGeneralPunctuation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeGeneralPunctuation class	instanceVariableNames: ''!!UnicodeGeneralPunctuation class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 56.! !Unicode subclass: #UnicodeGeometricShapes	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeGeometricShapes class	instanceVariableNames: ''!!UnicodeGeometricShapes class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 70.! !Unicode subclass: #UnicodeGeorgian	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeGeorgian class	instanceVariableNames: ''!!UnicodeGeorgian class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 42.! !Unicode subclass: #UnicodeGothic	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeGothic class	instanceVariableNames: ''!!UnicodeGothic class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 86.! !Unicode subclass: #UnicodeGreek	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeGreek class	instanceVariableNames: ''!!UnicodeGreek class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 21.! !Unicode subclass: #UnicodeGreekExtended	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeGreekExtended class	instanceVariableNames: ''!!UnicodeGreekExtended class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 55.! !Unicode subclass: #UnicodeGujarati	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeGujarati class	instanceVariableNames: ''!!UnicodeGujarati class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 31.! !Unicode subclass: #UnicodeGurmukhi	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeGurmukhi class	instanceVariableNames: ''!!UnicodeGurmukhi class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 30.! !Unicode subclass: #UnicodeHanunoo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeHanunoo class	instanceVariableNames: ''!!UnicodeHanunoo class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 49.! !Unicode subclass: #UnicodeHebrew	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeHebrew class	instanceVariableNames: ''!!UnicodeHebrew class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 24.! !Unicode subclass: #UnicodeIPA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeIPA class	instanceVariableNames: ''!!UnicodeIPA class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 18.! !Unicode subclass: #UnicodeJapanese	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeJapanese class	instanceVariableNames: ''!!UnicodeJapanese class methodsFor: 'accessing - encoding' stamp: 'yo 7/29/2003 15:45'!fromJISX0208String: aString	^ aString collect: [:each | MultiCharacter leadingChar: UnicodeJapanese leadingChar code: (each asUnicode)].! !!UnicodeJapanese class methodsFor: 'accessing - encoding' stamp: 'yo 10/4/2003 16:04'!isBreakableAt: index in: text	| char |	char _ text at: index.	char = Character space ifTrue: [^ true].	char = Character cr ifTrue: [^ true].	^ false.! !!UnicodeJapanese class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 5.! !!UnicodeJapanese class methodsFor: 'accessing - encoding' stamp: 'yo 8/4/2003 10:28'!scanSelector	^ #scanJapaneseCharactersFrom:to:in:rightX:stopConditions:kern:! !Unicode subclass: #UnicodeKannada	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeKannada class	instanceVariableNames: ''!!UnicodeKannada class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 35.! !Unicode subclass: #UnicodeKhmer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeKhmer class	instanceVariableNames: ''!!UnicodeKhmer class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 52.! !Unicode subclass: #UnicodeKorean	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeKorean class	instanceVariableNames: ''!!UnicodeKorean class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 7.! !Unicode subclass: #UnicodeLao	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeLao class	instanceVariableNames: ''!!UnicodeLao class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 39.! !Unicode subclass: #UnicodeLatinExtendedAB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeLatinExtendedAB class	instanceVariableNames: ''!!UnicodeLatinExtendedAB class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 17.! !Unicode subclass: #UnicodeLatinExtendedAdditional	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeLatinExtendedAdditional class	instanceVariableNames: ''!!UnicodeLatinExtendedAdditional class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 54.! !Unicode subclass: #UnicodeLetterlikeSymbols	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeLetterlikeSymbols class	instanceVariableNames: ''!!UnicodeLetterlikeSymbols class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 60.! !Unicode subclass: #UnicodeMalayalam	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeMalayalam class	instanceVariableNames: ''!!UnicodeMalayalam class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 36.! !Unicode subclass: #UnicodeMathAlnumSymbols	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeMathAlnumSymbols class	instanceVariableNames: ''!!UnicodeMathAlnumSymbols class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 90.! !Unicode subclass: #UnicodeMathOperators	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeMathOperators class	instanceVariableNames: ''!!UnicodeMathOperators class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 63.! !Unicode subclass: #UnicodeMiscMathSymbolsA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeMiscMathSymbolsA class	instanceVariableNames: ''!!UnicodeMiscMathSymbolsA class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 73.! !Unicode subclass: #UnicodeMiscMathSymbolsB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeMiscMathSymbolsB class	instanceVariableNames: ''!!UnicodeMiscMathSymbolsB class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 77.! !Unicode subclass: #UnicodeMiscSymbols	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeMiscSymbols class	instanceVariableNames: ''!!UnicodeMiscSymbols class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 71.! !Unicode subclass: #UnicodeMiscTechnical	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeMiscTechnical class	instanceVariableNames: ''!!UnicodeMiscTechnical class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 64.! !Unicode subclass: #UnicodeMongolian	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeMongolian class	instanceVariableNames: ''!!UnicodeMongolian class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 53.! !Unicode subclass: #UnicodeMusicalSymbols	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeMusicalSymbols class	instanceVariableNames: ''!!UnicodeMusicalSymbols class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 89.! !Unicode subclass: #UnicodeMyanmar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeMyanmar class	instanceVariableNames: ''!!UnicodeMyanmar class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 41.! !Unicode subclass: #UnicodeNumberForms	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeNumberForms class	instanceVariableNames: ''!!UnicodeNumberForms class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 61.! !Unicode subclass: #UnicodeOCRs	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeOCRs class	instanceVariableNames: ''!!UnicodeOCRs class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 66.! !Unicode subclass: #UnicodeOgham	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeOgham class	instanceVariableNames: ''!!UnicodeOgham class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 46.! !Unicode subclass: #UnicodeOldItalic	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeOldItalic class	instanceVariableNames: ''!!UnicodeOldItalic class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 85.! !Unicode subclass: #UnicodeOriya	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeOriya class	instanceVariableNames: ''!!UnicodeOriya class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 32.! !Unicode subclass: #UnicodeRunic	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeRunic class	instanceVariableNames: ''!!UnicodeRunic class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 47.! !Unicode subclass: #UnicodeSimplifiedChinese	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeSimplifiedChinese class	instanceVariableNames: ''!!UnicodeSimplifiedChinese class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 6.! !Unicode subclass: #UnicodeSinhala	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeSinhala class	instanceVariableNames: ''!!UnicodeSinhala class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 37.! !Unicode subclass: #UnicodeSpacingModifiers	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeSpacingModifiers class	instanceVariableNames: ''!!UnicodeSpacingModifiers class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 19.! !Unicode subclass: #UnicodeSuperAndSubscript	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeSuperAndSubscript class	instanceVariableNames: ''!!UnicodeSuperAndSubscript class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 57.! !Unicode subclass: #UnicodeSupplementalArrowsA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeSupplementalArrowsA class	instanceVariableNames: ''!!UnicodeSupplementalArrowsA class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 74.! !Unicode subclass: #UnicodeSupplementalArrowsB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeSupplementalArrowsB class	instanceVariableNames: ''!!UnicodeSupplementalArrowsB class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 76.! !Unicode subclass: #UnicodeSupplementalMathOperators	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeSupplementalMathOperators class	instanceVariableNames: ''!!UnicodeSupplementalMathOperators class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 78.! !Unicode subclass: #UnicodeSyriac	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeSyriac class	instanceVariableNames: ''!!UnicodeSyriac class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 26.! !Unicode subclass: #UnicodeTagalog	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeTagalog class	instanceVariableNames: ''!!UnicodeTagalog class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 48.! !Unicode subclass: #UnicodeTagbanwa	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeTagbanwa class	instanceVariableNames: ''!!UnicodeTagbanwa class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 51.! !Unicode subclass: #UnicodeTags	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeTags class	instanceVariableNames: ''!!UnicodeTags class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 91.! !Unicode subclass: #UnicodeTamil	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeTamil class	instanceVariableNames: ''!!UnicodeTamil class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 33.! !Unicode subclass: #UnicodeTelugu	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeTelugu class	instanceVariableNames: ''!!UnicodeTelugu class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 34.! !Unicode subclass: #UnicodeThaana	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeThaana class	instanceVariableNames: ''!!UnicodeThaana class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 27.! !Unicode subclass: #UnicodeThai	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeThai class	instanceVariableNames: ''!!UnicodeThai class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 38.! !Unicode subclass: #UnicodeTibetan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeTibetan class	instanceVariableNames: ''!!UnicodeTibetan class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 40.! !Unicode subclass: #UnicodeTraditionalChinese	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeTraditionalChinese class	instanceVariableNames: ''!!UnicodeTraditionalChinese class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 9.! !Unicode subclass: #UnicodeVietnamese	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeVietnamese class	instanceVariableNames: ''!!UnicodeVietnamese class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 10.! !Unicode subclass: #UnicodeYiRadicals	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeYiRadicals class	instanceVariableNames: ''!!UnicodeYiRadicals class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 80.! !Unicode subclass: #UnicodeYiSyllables	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Encoding-Unicode'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnicodeYiSyllables class	instanceVariableNames: ''!!UnicodeYiSyllables class methodsFor: 'accessing - encoding' stamp: 'yo 12/27/2002 05:55'!leadingChar	^ 79.! !Object subclass: #ClipboardInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 19:03'!fromSystemClipboard: aString	self subclassResponsibility.! !!ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 19:03'!toSystemClipboard: aString	self subclassResponsibility.! !Object subclass: #CompoundTextConverterState	instanceVariableNames: 'g0Size g1Size g0Leading g1Leading charSize streamPosition '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 8/23/2002 21:30'!charSize	^ charSize! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 20:41'!charSize: s	charSize _ s.! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 8/23/2002 21:29'!g0Leading	^ g0Leading! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 20:41'!g0Leading: l	g0Leading _ l.! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 8/23/2002 21:29'!g0Size	^ g0Size! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 20:41'!g0Size: s	g0Size _ s.! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 8/23/2002 14:37'!g0Size: g0 g1Size: g1 g0Leading: g0l g1Leading: g1l charSize: cSize streamPosition: pos	g0Size _ g0.	g1Size _ g1.	g0Leading _ g0l.	g1Leading _ g1l.	charSize _ cSize.	streamPosition _ pos.! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 8/23/2002 21:30'!g1Leading	^ g1Leading! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 20:41'!g1Leading: l	g1Leading _ l.! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 8/23/2002 21:29'!g1Size	^ g1Size! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 20:41'!g1Size: s	g1Size _ s.! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 11/4/2002 12:31'!printOn: aStream	aStream nextPut: $(;		nextPutAll: g0Size printString; space;		nextPutAll: g1Size printString; space;		nextPutAll: g0Leading printString; space;		nextPutAll: g1Leading printString; space;		nextPutAll: charSize printString; space;		nextPutAll: streamPosition printString.	aStream nextPut: $).! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 8/23/2002 21:30'!streamPosition	^ streamPosition! !!CompoundTextConverterState methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 20:40'!streamPosition: pos	streamPosition _ pos.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CompoundTextConverterState class	instanceVariableNames: ''!!CompoundTextConverterState class methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2002 17:04'!g0Size: g0 g1Size: g1 g0Leading: g0l g1Leading: g1l charSize: cSize streamPosition: pos	^ (self new)		g0Size: g0		g1Size: g1		g0Leading: g0l		g1Leading: g1l		charSize: cSize		streamPosition: pos	; yourself.! !Object subclass: #KeyboardInputInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'EventSensorConstants '	category: 'Multilingual-TextConversion'!!KeyboardInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 7/25/2003 17:26'!initialize! !!KeyboardInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 7/25/2003 13:53'!nextCharFrom: sensor firstEvt: evtBuf	self subclassResponsibility.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!KeyboardInputInterpreter class	instanceVariableNames: ''!!KeyboardInputInterpreter class methodsFor: 'as yet unclassified' stamp: 'yo 7/25/2003 16:24'!new	^ (self basicNew) initialize; yourself.! !ClipboardInterpreter subclass: #MacRomanClipboardInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!MacRomanClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 15:22'!fromSystemClipboard: aString	^ aString squeakToIso.! !!MacRomanClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 15:23'!toSystemClipboard: aString	| result |	aString isOctetString ifTrue: [^ aString asOctetString isoToSqueak].	result _ WriteStream on: (String new: aString size).	aString do: [:each | each value < 256 ifTrue: [result nextPut: each isoToSqueak]].	^ result contents.! !KeyboardInputInterpreter subclass: #MacRomanInputInterpreter	instanceVariableNames: 'converter '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!MacRomanInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 21:19'!nextCharFrom: sensor firstEvt: evtBuf	| keyValue |	keyValue := evtBuf third.	^ keyValue asCharacter squeakToIso.! !ClipboardInterpreter subclass: #MacShiftJISClipboardInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!MacShiftJISClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'tetha 8/16/2003 00:21'!fromSystemClipboard: aString	^ aString convertFromSystemString! !!MacShiftJISClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'tetha 8/16/2003 00:24'!toSystemClipboard: text	| string |	"self halt."	string _ text asString.	string isAsciiString ifTrue: [^ string asOctetString].	string isOctetString ifTrue: [^ string "hmm"].	^ string convertToSystemString .! !KeyboardInputInterpreter subclass: #MacUnicodeInputInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!MacUnicodeInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 9/26/2003 11:51'!nextCharFrom: sensor firstEvt: evtBuf	| keyValue |	keyValue := evtBuf third.	keyValue < 256 ifTrue: [^ Character value: keyValue].	^ Smalltalk systemLanguage charsetClass charFromUnicode: keyValue.! !ReadWriteStream subclass: #MultiByteBinaryOrTextStream	instanceVariableNames: 'isBinary converter '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:16'!asBinaryOrTextStream	^ self! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:16'!ascii	isBinary _ false! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:01'!basicNext	^ super next ! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:20'!basicNext: anInteger.	^ super next: anInteger.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicNext: n into: aString	^ super next: n into: aString.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicNextInto: aString	^ super nextInto: aString.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicNextPut: char	^ super nextPut: char.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicNextPutAll: aString	^ super nextPutAll: aString.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicPeek	^ super peek! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicPosition	^ super position.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicPosition: pos	^ super position: pos.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:16'!binary	isBinary _ true! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:26'!contents	^ self upToEnd.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 8/7/2003 09:03'!converter	converter ifNil: [converter _ UTF8TextConverter new].	^ converter! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 8/7/2003 09:12'!converter: aConverter	converter _ aConverter.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:31'!fileInObjectAndCode	"This file may contain:1) a fileIn of code  2) just an object in SmartReferenceStream format 3) both code and an object.	File it in and return the object.  Note that self must be a FileStream or RWBinaryOrTextStream.  Maybe ReadWriteStream incorporate RWBinaryOrTextStream?"	| refStream object |	self text.	self peek asciiValue = 4		ifTrue: [  "pure object file"			self binary.			refStream _ SmartRefStream on: self.			object _ refStream nextAndClose]		ifFalse: [  "objects mixed with a fileIn"			self fileIn.  "reads code and objects, then closes the file"			self binary.			object _ SmartRefStream scannedObject].	"set by side effect of one of the chunks"	SmartRefStream scannedObject: nil.  "clear scannedObject"	^ object! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:25'!isBinary	^ isBinary! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:39'!next	| n |	n _ self converter nextFromStream: self.	n ifNil: [^ nil].	isBinary and: [n isCharacter ifTrue: [^ n asciiValue]].	^ n.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/12/2002 04:28'!next: anInteger 	| multiString |	"self halt."	self isBinary ifTrue: [^ (super next: anInteger) asByteArray].	multiString _ MultiString new: anInteger.	1 to: anInteger do: [:index |		| character |		(character _ self next) ifNotNil: [			multiString at: index put: character		] ifNil: [			multiString _ multiString copyFrom: 1 to: index - 1.			^ multiString		]	].	^ multiString.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:24'!nextDelimited: terminator	| out ch |	out _ WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	self next = terminator ifFalse: [		"absorb initial terminator"		self position: (self position - converter currentCharSize)	].	[(ch _ self next) == nil] whileFalse: [		(ch = terminator) ifTrue: [			self peek = terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:24'!nextMatchAll: aColl    | save |    save _ converter saveStateOf: self.    aColl do: [:each |       (self next) = each ifFalse: [            converter restoreStateOf: self with: save.            ^ false.		].	].    ^ true.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/14/2002 13:54'!nextPut: aCharacter	aCharacter isInteger ifTrue: [^ super nextPut: aCharacter asCharacter].	^ self converter nextPut: aCharacter toStream: self! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:24'!nextPutAll: aCollection	self isBinary ifTrue: [		^ super nextPutAll: aCollection.	].	aCollection do: [:e | self nextPut: e].! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/14/2002 13:54'!padToEndWith: aChar	"We don't have pages, so we are at the end, and don't need to pad."! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:25'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next |	self atEnd ifTrue: [^ nil].	next _ self next.	self position: self position - converter currentCharSize.	^ next.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:25'!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state _ converter saveStateOf: self.	(next _ self next) == nil ifTrue: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 8/7/2003 09:13'!reset	super reset.	isBinary ifNil: [isBinary _ false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection _ collection asString.		isBinary _ true].	converter ifNil: [converter _ UTF8TextConverter new].! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/14/2002 13:49'!setFileTypeToObject	"do nothing.  We don't have a file type"! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:17'!skipSeparators	[self atEnd] whileFalse: [		self basicNext isSeparator ifFalse: [			^ self position: self position - 1]]! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:24'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast"	| peek |	[self atEnd] whileFalse: [		(peek _ self next) isSeparator ifFalse: [			self position: self position - converter currentCharSize.			^ peek.		].	].! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:33'!text	isBinary _ false! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:24'!upTo: delim 	| out ch |	out _ WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	[(ch _ self next) isNil] whileFalse: [		(ch = delim) ifTrue: [			^ out contents  "terminator is not doubled; we're done!!"		].		out nextPut: ch.	].	^ out contents.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:17'!upToEnd	| newStream element newCollection |	newCollection _ self isBinary				ifTrue: [ByteArray new: 100]				ifFalse: [String new: 100].	newStream _ WriteStream on: newCollection.	[(element _ self next) notNil]		whileTrue: [newStream nextPut: element].	^ newStream contents! !!MultiByteBinaryOrTextStream class methodsFor: 'instance creation' stamp: 'ykoubo 9/28/2003 19:59'!on: aCollection encoding: encodingName 	| aTextConverter |	encodingName isNil		ifTrue: [aTextConverter _ TextConverter default]		ifFalse: [aTextConverter _ TextConverter newForEncoding: encodingName].	^ (self on: aCollection)		converter: aTextConverter! !!MultiByteBinaryOrTextStream class methodsFor: 'instance creation' stamp: 'yo 11/23/2003 20:32'!with: aCollection encoding: encodingName 	| aTextConverter |	encodingName isNil		ifTrue: [aTextConverter _ TextConverter default]		ifFalse: [aTextConverter _ TextConverter newForEncoding: encodingName].	^ (self with: aCollection)		converter: aTextConverter! !StandardFileStream subclass: #MultiByteFileStream	instanceVariableNames: 'converter '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:06'!accepts: aSymbol 	^ converter accepts: aSymbol.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 16:34'!basicNext	^ super basicNext ! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:06'!basicNext: anInteger.	^ super next: anInteger.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:07'!basicNext: n into: aString	^ super next: n into: aString.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:07'!basicNextInto: aString	^ super nextInto: aString.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:07'!basicNextPut: char	^ super nextPut: char.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:07'!basicNextPutAll: aString	^ super nextPutAll: aString.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:07'!basicPeek	^ super peek! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:08'!basicPosition	^ super position.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:08'!basicPosition: pos	^ super position: pos.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:08'!basicReadInto: byteArray startingAt: startIndex count: count	^ super readInto: byteArray startingAt: startIndex count: count.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:08'!basicSetToEnd	^ super setToEnd.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:08'!basicSkip: n	^ super skip: n.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:08'!basicUpTo: delim	^ super upTo: delim.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:09'!basicVerbatim: aString	^ super verbatim: aString.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 15:11'!converter	converter ifNil: [converter _ TextConverter defaultSystemConverter].	^ converter! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:09'!converter: aConverter	converter _ aConverter.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2003 11:56'!fileInEncodingName: aString	self converter: (TextConverter newForEncoding: aString).	super fileIn.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:09'!filterFor: aFileStream	| rw |	name _ aFileStream name.	rw _ aFileStream isReadOnly not.	aFileStream close.	self open: name forWrite: rw.	^self.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 16:35'!next	^ self converter nextFromStream: self! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:11'!next: anInteger 	| multiString |	self isBinary ifTrue: [^ super next: anInteger].	multiString _ MultiString new: anInteger.	1 to: anInteger do: [:index |		| character |		(character _ self next) ifNotNil: [			multiString at: index put: character		] ifNil: [			multiString _ multiString copyFrom: 1 to: index - 1.			^ multiString		]	].	^ multiString.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:12'!nextDelimited: terminator	| out ch |	out _ WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	self next = terminator ifFalse: [		"absorb initial terminator"		self position: (self position - converter currentCharSize)	].	[(ch _ self next) == nil] whileFalse: [		(ch = terminator) ifTrue: [			self peek = terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:13'!nextMatchAll: aColl    | save |    save _ converter saveStateOf: self.    aColl do: [:each |       (self next) = each ifFalse: [            converter restoreStateOf: self with: save.            ^ false.		].	].    ^ true.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 12/30/2002 10:53'!nextPut: aCharacter	| leadingChar |	aCharacter isInteger ifTrue: [^ super nextPut: aCharacter].	leadingChar _ aCharacter leadingChar.	"((EncodedCharSet charsetAt: leadingChar) isKindOf: Unicode class) ifTrue: [^ self]."	^ self converter nextPut: aCharacter toStream: self! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 5/23/2003 09:40'!nextPutAll: aCollection	(self isBinary or: [aCollection class == ByteArray]) ifTrue: [		^ super nextPutAll: aCollection.	].	aCollection do: [:e | self nextPut: e].! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/13/2003 11:53'!open: fileName forWrite: writeMode	| result |	result _ super open: fileName forWrite: writeMode.	result ifNotNil: [		converter ifNil: [			self localName = (FileDirectory localNameFor: Smalltalk sourcesName) ifTrue: [				converter _ MacRomanTextConverter new			] ifFalse: [				converter _ UTF8TextConverter new.			].		].	].	^result.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:14'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next |	self atEnd ifTrue: [^ nil].	next _ self next.	self position: self position - converter currentCharSize.	^ next.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:15'!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state _ converter saveStateOf: self.	(next _ self next) == nil ifTrue: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/13/2003 13:51'!reset	super reset.	converter ifNil: [		converter _ UTF8TextConverter new.	].! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 16:37'!skipSeparators	[self atEnd] whileFalse: [		self basicNext isSeparator ifFalse: [			^ self position: self position - 1]]"	[self atEnd] whileFalse: [		self next isSeparator ifFalse: [			^ self position: self position - converter currentCharSize.		].	]."! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:16'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast"	| peek |	[self atEnd] whileFalse: [		(peek _ self next) isSeparator ifFalse: [			self position: self position - converter currentCharSize.			^ peek.		].	].! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:17'!upTo: delim 	| out ch |	out _ WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	[(ch _ self next) isNil] whileFalse: [		(ch = delim) ifTrue: [			^ out contents  "terminator is not doubled; we're done!!"		].		out nextPut: ch.	].	^ out contents.! !!MultiByteFileStream methodsFor: 'as yet unclassified' stamp: 'yo 8/30/2002 16:39'!upToEnd	| newStream element |	collection _ self isBinary				ifTrue: [ByteArray new: 100]				ifFalse: [String new: 100].	newStream _ WriteStream on: collection.	[(element _ self next) notNil]		whileTrue: [newStream nextPut: element].	^ newStream contents! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MultiByteFileStream class	instanceVariableNames: ''!!MultiByteFileStream class methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 11:43'!newFrom: aFileStream	| rw n |	n _ aFileStream name.	rw _ aFileStream isReadOnly not.	aFileStream close.	^self new open: n forWrite: rw.! !ClipboardInterpreter subclass: #NoConversionClipboardInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!NoConversionClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 19:03'!fromSystemClipboard: aString	^ aString.! !!NoConversionClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 21:06'!toSystemClipboard: aString	| result |	aString isOctetString ifTrue: [^ aString asOctetString].	result _ WriteStream on: (String new: aString size).	aString do: [:each | each value < 256 ifTrue: [result nextPut: each]].	^ result contents.! !KeyboardInputInterpreter subclass: #NoInputInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!NoInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 7/25/2003 14:59'!nextCharFrom: sensor firstEvt: evtBuf	| keyValue |	keyValue := evtBuf third.	^ keyValue asCharacter.! !Object subclass: #TextConverter	instanceVariableNames: 'acceptingEncodings '	classVariableNames: ''	poolDictionaries: 'EventSensorConstants '	category: 'Multilingual-TextConversion'!!TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2002 15:27'!accepts: aSymbol	self subclassResponsibility.! !!TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2002 15:27'!currentCharSize	self subclassResponsibility.! !!TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 7/29/2003 15:51'!emitSequenceToResetStateIfNeededOn: aStream! !!TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2002 15:27'!errorMalformedInput	self error: 'malformed input'.! !!TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2002 15:27'!nextFromStream: aStream	self subclassResponsibility.! !!TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2002 15:27'!nextPut: aCharacter toStream: aStream	self subclassResponsibility.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextConverter class	instanceVariableNames: ''!!TextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 7/25/2003 14:08'!defaultConverterClassForEncoding: encodingName	"TextConverter defaultConverterClassForEncoding: 'shift-jis'"	^ self allSubclasses		detect: [:class | class encodingNames includes: encodingName]		ifNone: []! !!TextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 9/26/2003 11:51'!defaultSystemConverter	^ Smalltalk systemLanguage defaultSystemConverter! !!TextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2002 15:28'!encodingNames 	^ #() copy.! !!TextConverter class methodsFor: 'instance creation' stamp: 'yo 8/6/2003 11:54'!newForEncoding: aString 	| class encoding |	encoding _ aString asLowercase.	class _ self allSubclasses				detect: [:each | each encodingNames includes: encoding]				ifNone: [].	class isNil		ifTrue: [^ nil].	^ class new! !!TextConverter class methodsFor: 'utilities' stamp: 'mu 8/22/2003 01:29'!allEncodingStates	"TextConverter allEncodingStates"	| encodingStates |	encodingStates _ Set new.	self allSubclasses		do: [:each | 			| names | 			names _ each encodingNames.			names notEmpty				ifTrue: [encodingStates add: names first asSymbol]].	^encodingStates! !TextConverter subclass: #CompoundTextConverter	instanceVariableNames: 'state '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!CompoundTextConverter methodsFor: 'conversion' stamp: 'yo 8/18/2003 17:50'!emitSequenceToResetStateIfNeededOn: aStream	Latin1 emitSequenceToResetStateIfNeededOn: aStream forState: state.! !!CompoundTextConverter methodsFor: 'conversion' stamp: 'yo 8/13/2003 11:34'!nextFromStream: aStream 	| character character2 size leadingChar offset result |	aStream isBinary ifTrue: [^ aStream basicNext].	character _ aStream basicNext.	character ifNil: [^ nil].	character == Character escape ifTrue: [		self parseShiftSeqFromStream: aStream.		character _ aStream basicNext.		character ifNil: [^ nil]].	character asciiValue < 128 ifTrue: [		size _ state g0Size.		leadingChar _ state g0Leading.		offset _ 16r21.	] ifFalse: [		size _state g1Size.		leadingChar _ state g1Leading.		offset _ 16rA1.	].	size = 1 ifTrue: [		leadingChar = 0			ifTrue: [^ character]			ifFalse: [^ MultiCharacter leadingChar: leadingChar code: character asciiValue]	].	size = 2 ifTrue: [		character2 _ aStream basicNext.		character2 ifNil: [self errorMalformedInput].		character _ character asciiValue - offset.		character2 _ character2 asciiValue - offset.		result _ MultiCharacter leadingChar: leadingChar code: character * 94 + character2.		^ self toUnicode: result	].	self error: 'unsupported encoding'.! !!CompoundTextConverter methodsFor: 'conversion' stamp: 'yo 8/18/2003 17:52'!nextPut: aCharacter toStream: aStream	| ascii leadingChar |	aStream isBinary ifTrue: [		aCharacter class == Character ifTrue: [			^ aStream basicNextPut: aCharacter.		].		aCharacter class == MultiCharacter ifTrue: [			"this shouldn't happen?"			^ aStream nextInt32Put: aCharacter value.		].	].	aCharacter isUnicode ifTrue: [		ascii _ (JISX0208 charFromUnicode: aCharacter asUnicode) charCode.		leadingChar _ JISX0208 leadingChar.	] ifFalse: [		ascii _ aCharacter charCode.		leadingChar _ aCharacter leadingChar.	].	self nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForLeadingChar: leadingChar.! !!CompoundTextConverter methodsFor: 'private' stamp: 'yo 11/4/2002 14:36'!nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForLeadingChar: leadingChar	| charset |	charset _ EncodedCharSet charsetAt: leadingChar.	charset ifNotNil: [		charset nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state.	] ifNil: [		"..."	].! !!CompoundTextConverter methodsFor: 'private' stamp: 'yo 11/4/2002 14:47'!parseShiftSeqFromStream: aStream	| c set target id |	c _ aStream basicNext.	c = $$ ifTrue: [		set _ #multibyte.		c _ aStream basicNext.		c = $( ifTrue: [target _ 1].		c = $) ifTrue: [target _ 2].		target ifNil: [target _ 1. id _ c]			ifNotNil: [id _ aStream basicNext].	] ifFalse: [		c = $( ifTrue: [target _ 1. set _ #nintyfour].		c = $) ifTrue: [target _ 2. set _ #nintyfour].		c = $- ifTrue: [target _ 2. set _ #nintysix].		"target = nil ifTrue: [self errorMalformedInput]."		id _ aStream basicNext.	].	(set = #multibyte and: [id = $B]) ifTrue: [		state charSize: 2.		target = 1 ifTrue: [			state g0Size: 2.			state g0Leading: 1.		] ifFalse: [			state g1Size: 2.			state g1Leading: 1.		].		^ self	].	(set = #nintyfour and: [id = $B or: [id = $J]]) ifTrue: [		state charSize: 1.		state g0Size: 1.		state g0Leading: 0.		^ self	].	(set = #nintysix and: [id = $A]) ifTrue: [		state charSize: 1.		state g1Size: 1.		state g1Leading: 0.		^ self	].	"self errorUnsupported."! !!CompoundTextConverter methodsFor: 'private' stamp: 'yo 11/4/2002 12:33'!restoreStateOf: aStream with: aConverterState	state _ aConverterState copy.	aStream position: state streamPosition.! !!CompoundTextConverter methodsFor: 'private' stamp: 'yo 11/4/2002 13:52'!saveStateOf: aStream	| inst |	inst _  state clone.	inst streamPosition: aStream position.	^ inst.! !!CompoundTextConverter methodsFor: 'private' stamp: 'yo 8/4/2003 12:02'!toUnicode: aChar	^ MultiCharacter leadingChar: UnicodeJapanese leadingChar code: aChar asUnicode.! !!CompoundTextConverter methodsFor: 'accessing' stamp: 'yo 8/23/2002 22:39'!accepts: aSymbol	^ acceptingEncodings includes: aSymbol.! !!CompoundTextConverter methodsFor: 'accessing' stamp: 'yo 9/16/2002 21:41'!currentCharSize	^ state charSize.! !!CompoundTextConverter methodsFor: 'initialize-release' stamp: 'yo 8/13/2003 11:45'!initialize	state _ CompoundTextConverterState 		g0Size: 1 g1Size: 1 g0Leading: 0 g1Leading: 0 charSize: 1 streamPosition: 0.	acceptingEncodings _ #(ascii iso88591 jisx0208 gb2312 ksc5601 ksx1001 ) copy.! !!CompoundTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2002 16:47'!errorMalformedInput	^ self error: 'malformed input'.! !!CompoundTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2002 16:48'!errorUnsupported	^ self error: 'unsupported encoding'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CompoundTextConverter class	instanceVariableNames: ''!!CompoundTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 10/24/2002 14:16'!encodingNames	^ #('iso-2022-jp' 'x-ctext') copy! !!CompoundTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 22:56'!new	^ (super new) initialize; yourself.! !TextConverter subclass: #EUCTextConverter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!EUCTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 10:09'!leadingChar	^ self subclassResponsibility! !!EUCTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 10/4/2003 15:59'!nextFromStream: aStream	| character1 character2 offset value1 value2 nonUnicodeChar |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 _ aStream basicNext.	character1 isNil ifTrue: [^ nil].	character1 asciiValue <= 127 ifTrue: [^ character1].	character2 _ aStream basicNext.	character2 = nil ifTrue: [self errorMalformedInput].	offset _ 16rA1.	value1 _ character1 asciiValue - offset.	value2 _ character2 asciiValue - offset.	nonUnicodeChar _ MultiCharacter leadingChar: self leadingChar code: value1 * 94 + value2.	^ self unicodeClass value: nonUnicodeChar asUnicode.! !!EUCTextConverter methodsFor: 'as yet unclassified' stamp: 'Tsutomu Hiroshima 11/7/2003 19:55'!nextPut: aCharacter toStream: aStream 	| value leadingChar nonUnicodeChar value1 value2 |	aStream isBinary ifTrue: [		aCharacter class == Character ifTrue: [			aStream basicNextPut: aCharacter.			^ aStream		].		aCharacter class == MultiCharacter ifTrue: [			aStream nextInt32Put: aCharacter value.			^ aStream		]	].	value _ aCharacter charCode.	leadingChar _ aCharacter leadingChar.	(leadingChar = 0 and: [value < 128]) ifTrue: [		aStream basicNextPut: (Character value: value).		^ aStream	].		nonUnicodeChar _ self nonUnicodeClass charFromUnicode: value.	nonUnicodeChar ifNotNil: [		value _ nonUnicodeChar charCode.		value1 _ value // 94 + 161.		value2 _ value \\ 94 + 161.		aStream basicNextPut: (Character value: value1).		aStream basicNextPut: (Character value: value2).		^ aStream	]! !!EUCTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 10/4/2003 15:48'!nonUnicodeClass	^ (EncodedCharSet charsetAt: self leadingChar).! !!EUCTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 10/4/2003 15:37'!unicodeClass	self subclassResponsibility! !EUCTextConverter subclass: #CNGBTextConverter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!CNGBTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 14:42'!leadingChar	^ GB2312 leadingChar! !!CNGBTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 10/4/2003 15:38'!unicodeClass	^ UnicodeTraditionalChinese.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CNGBTextConverter class	instanceVariableNames: ''!!CNGBTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 14:42'!encodingNames 	^ #('gb2312' ) copy! !!CNGBTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 14:42'!example1	"CNGBTextConverter example1"	| fileStream |	fileStream _ FileStream newFileNamed: 'test.gb'.	fileStream converter: CNGBTextConverter new.	fileStream nextPut: (MultiCharacter value: 33559461).	fileStream nextPut: (MultiCharacter value: 33556777).	fileStream close! !!CNGBTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 14:43'!example2	"CNGBTextConverter example2"	| writeStream fileStream |	writeStream _ WriteStream on: String new.	fileStream _ FileStream fileNamed: 'test.gb'.	fileStream converter: CNGBTextConverter new.	[fileStream atEnd] whileFalse: [writeStream nextPut: fileStream next].	fileStream close.	^ writeStream contents! !EUCTextConverter subclass: #EUCJPTextConverter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!EUCJPTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 10:09'!leadingChar	^ JISX0208 leadingChar! !!EUCJPTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 10/4/2003 16:00'!unicodeClass	^ UnicodeJapanese.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EUCJPTextConverter class	instanceVariableNames: ''!!EUCJPTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 10:11'!encodingNames 	^ #('euc-jp' ) copy! !EUCTextConverter subclass: #EUCKRTextConverter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!EUCKRTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 15:19'!leadingChar	^ KSX1001 leadingChar! !!EUCKRTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 10/4/2003 16:00'!unicodeClass	^ UnicodeKorean.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EUCKRTextConverter class	instanceVariableNames: ''!!EUCKRTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 3/31/2003 11:36'!encodingNames 	^ #('ks-c-5601-1987' 'euc-kr' ) copy! !!EUCKRTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 15:19'!example1	"EUCKRTextConverter example1"	| fileStream |	fileStream _ FileStream newFileNamed: 'test.kr'.	fileStream converter: EUCKRTextConverter new.	fileStream nextPut: (MultiCharacter value: 50335081).	fileStream nextPut: (MultiCharacter value: 50334733).	fileStream close! !!EUCKRTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 15:19'!example2	"EUCKRTextConverter example2"	| writeStream fileStream |	writeStream _ WriteStream on: String new.	fileStream _ FileStream fileNamed: 'test.kr'.	fileStream converter: EUCKRTextConverter new.	[fileStream atEnd] whileFalse: [writeStream nextPut: fileStream next].	fileStream close.	^ writeStream contents! !TextConverter subclass: #MacRomanTextConverter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!MacRomanTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/5/2003 22:20'!currentCharSize	^ 1.! !!MacRomanTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/4/2003 12:33'!leadingChar	^ 0.! !!MacRomanTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 21:19'!nextFromStream: aStream 	| character1 |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 _ aStream basicNext.	character1 isNil ifTrue: [^ nil].	^ character1 squeakToIso.! !!MacRomanTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 21:17'!nextPut: aCharacter toStream: aStream 	aStream isBinary ifTrue: [		aCharacter class == Character ifTrue: [			aStream basicNextPut: aCharacter isoToSqueak.			^ aStream.		].		aCharacter class == MultiCharacter ifTrue: [			aStream nextInt32Put: aCharacter value.			^ aStream.		].	].	aStream basicNextPut: aCharacter isoToSqueak.! !!MacRomanTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/5/2003 22:15'!restoreStateOf: aStream with: aConverterState	aStream position: aConverterState.! !!MacRomanTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/5/2003 22:15'!saveStateOf: aStream	^ aStream position.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MacRomanTextConverter class	instanceVariableNames: ''!!MacRomanTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 8/4/2003 12:33'!encodingNames 	^ #('mac-roman' ) copy! !TextConverter subclass: #ShiftJISTextConverter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!ShiftJISTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 15:28'!leadingChar	^ JISX0208 leadingChar! !!ShiftJISTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/13/2003 11:33'!nextFromStream: aStream 	| character1 character2 value1 value2 char1Value result |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 _ aStream basicNext.	character1 isNil ifTrue: [^ nil].	char1Value _ character1 asciiValue.	((char1Value > 127 and: [char1Value < 160])		or: [char1Value > 223 and: [char1Value < 253]]) ifFalse: [^ character1].	character2 _ aStream basicNext.	character2 = nil ifTrue: [self errorMalformedInput].	value1 _ character1 asciiValue.	character1 asciiValue >= 224 ifTrue: [value1 _ value1 - 64].	value1 _ value1 - 129 bitShift: 1.	value2 _ character2 asciiValue.	character2 asciiValue >= 128 ifTrue: [value2 _ value2 - 1].	character2 asciiValue >= 158 ifTrue: [		value1 _ value1 + 1.		value2 _ value2 - 158	] ifFalse: [value2 _ value2 - 64].	result _ MultiCharacter leadingChar: self leadingChar code: value1 * 94 + value2.	^ self toUnicode: result! !!ShiftJISTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 19:24'!nextPut: aCharacter toStream: aStream 	| value leadingChar aChar |	aStream isBinary ifTrue: [		aCharacter class == Character ifTrue: [			aStream basicNextPut: aCharacter.			^ aStream.		].		aCharacter class == MultiCharacter ifTrue: [			aStream nextInt32Put: aCharacter value.			^ aStream.		].	].	aCharacter isUnicode ifFalse: [			aChar _ aCharacter.		value _ aCharacter charCode.	] ifTrue: [		aChar _ JISX0208 charFromUnicode: aCharacter charCode.		aChar ifNil: [^ aStream].		value _ aChar charCode.	].	leadingChar _ aChar leadingChar.	leadingChar = 0 ifTrue: [		aStream basicNextPut: (Character value: value).		^ aStream.	].	leadingChar == self leadingChar ifTrue: [		| upper lower | 		upper _ value // 94 + 33.		lower _ value \\ 94 + 33.		upper \\ 2 == 1 ifTrue: [			upper _ upper + 1 / 2 + 112.			lower _ lower + 31		] ifFalse: [			upper _ upper / 2 + 112.			lower _ lower + 125		].		upper >= 160 ifTrue: [upper _ upper + 64].		lower >= 127 ifTrue: [lower _ lower + 1].		aStream basicNextPut: (Character value: upper).		aStream basicNextPut: (Character value: lower).		^ aStream	].! !!ShiftJISTextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/4/2003 10:42'!toUnicode: aChar	^ MultiCharacter leadingChar: UnicodeJapanese leadingChar code: aChar asUnicode.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShiftJISTextConverter class	instanceVariableNames: ''!!ShiftJISTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 3/31/2003 11:36'!encodingNames 	^ #('shift-jis' ) copy! !!ShiftJISTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 15:33'!example1	"ShiftJISTextConverter example1"	| fileStream |	fileStream _ FileStream newFileNamed: 'test.sjis'.	fileStream converter: ShiftJISTextConverter new.	fileStream nextPut: (MultiCharacter value: 16780785).	fileStream nextPut: (MultiCharacter value: 16781223).	fileStream close! !!ShiftJISTextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 10/23/2002 15:33'!example2	"ShiftJISTextConverter example2"	| writeStream fileStream |	writeStream _ WriteStream on: String new.	fileStream _ FileStream fileNamed: 'test.sjis'.	fileStream converter: ShiftJISTextConverter new.	[fileStream atEnd] whileFalse: [writeStream nextPut: fileStream next].	fileStream close.	^ writeStream contents! !TextConverter subclass: #UTF8TextConverter	instanceVariableNames: 'currentCharSize forceToEncodingTag '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!UTF8TextConverter methodsFor: 'conversion' stamp: 'yo 8/13/2003 10:56'!nextFromStream: aStream	| character1 value1 character2 value2 unicode character3 value3 codesets char character4 value4 |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 _ aStream basicNext.	character1 isNil ifTrue: [^ nil].	value1 _ character1 asciiValue.	value1 <= 127 ifTrue: [		"1-byte character"		currentCharSize _ 1.		^ character1	].	(value1 bitAnd: 16rE0) = 192 ifTrue: [		"2-byte character"		character2 _ aStream basicNext.		character2 = nil ifTrue: [^ self errorMalformedInput].		value2 _ character2 asciiValue.		currentCharSize _ 2.		^ Unicode value: ((value1 bitAnd: 31) bitShift: 6) + (value2 bitAnd: 63).	].	(value1 bitAnd: 16rF0) = 224 ifTrue: [		"3-byte character"		character2 _ aStream basicNext.		character2 = nil ifTrue: [^ self errorMalformedInput].		value2 _ character2 asciiValue.		character3 _ aStream basicNext.		character3 = nil ifTrue: [^ self errorMalformedInput].		value3 _ character3 asciiValue.		unicode _ ((value1 bitAnd: 15) bitShift: 12) + ((value2 bitAnd: 63) bitShift: 6)				+ (value3 bitAnd: 63).		currentCharSize _ 3.	].	(value1 bitAnd: 16rF8) = 240 ifTrue: [		"4-byte character"		character2 _ aStream basicNext.		character2 = nil ifTrue: [^ self errorMalformedInput].		value2 _ character2 asciiValue.		character3 _ aStream basicNext.		character3 = nil ifTrue: [^ self errorMalformedInput].		value3 _ character3 asciiValue.		character4 _ aStream basicNext.		character4 = nil ifTrue: [^ self errorMalformedInput].		value4 _ character4 asciiValue.		currentCharSize _ 4.		unicode _ ((value1 bitAnd: 16r7) bitShift: 18) +					((value2 bitAnd: 63) bitShift: 12) + 					((value3 bitAnd: 63) bitShift: 6) +					(value4 bitAnd: 63).	].	unicode isNil ifTrue: [^ MultiCharacter value: 16777323].	Smalltalk primaryLanguage = #Japanese ifTrue: [		codesets _ Array with: UnicodeJapanese with: UnicodeKorean with: UnicodeSimplifiedChinese with: UnicodeTraditionalChinese.	].	Smalltalk primaryLanguage = #Korean ifTrue: [		codesets _ Array with: UnicodeKorean with: UnicodeJapanese with: UnicodeSimplifiedChinese with: UnicodeTraditionalChinese.	].	Smalltalk primaryLanguage = #SimplifiedChinese ifTrue: [		codesets _ Array with: UnicodeSimplifiedChinese with: UnicodeTraditionalChinese with: UnicodeKorean with: UnicodeJapanese.	].	Smalltalk primaryLanguage = #UnicodeTraditionalChinese ifTrue: [		codesets _ Array with: UnicodeTraditionalChinese with: UnicodeSimplifiedChinese with: UnicodeKorean with: UnicodeJapanese.	].	codesets isNil		ifTrue: [^Unicode value: unicode].	codesets do: [:cs |		char _ cs charFromUnicode: unicode.		char ifNotNil: [^ char].	].	^ nil.! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'yo 7/30/2003 11:14'!nextPut: aCharacter toStream: aStream 	| leadingChar nBytes mask shift ucs2code |	aStream isBinary ifTrue: [		aCharacter class == Character ifTrue: [			aStream basicNextPut: aCharacter.			^ aStream.		].		aCharacter class = MultiCharacter ifTrue: [			aStream nextInt32Put: aCharacter value.			^ aStream.		].	].	leadingChar _ aCharacter leadingChar.	(leadingChar = 0 and: [aCharacter asciiValue < 128]) ifTrue: [		aStream basicNextPut: (Character value: aCharacter asciiValue).		^ aStream.	].	"leadingChar > 3 ifTrue: [^ aStream]."	ucs2code _ aCharacter asUnicode.	ucs2code ifNil: [^ aStream].	nBytes _ ucs2code highBit + 3 // 5.	mask _ #(128 192 224 240 248 252 254 255) at: nBytes.	shift _ nBytes - 1 * -6.	aStream basicNextPut: (Character value: (ucs2code bitShift: shift) + mask).	2 to: nBytes do: [:i | 		shift _ shift + 6.		aStream basicNextPut: (Character value: ((ucs2code bitShift: shift) bitAnd: 63) + 128).	].	^ aStream.! !!UTF8TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2002 16:17'!leadingChar	^ self shouldNotImplement! !!UTF8TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/4/2003 17:13'!restoreStateOf: aStream with: aConverterState	aStream position: aConverterState.! !!UTF8TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 8/4/2003 17:12'!saveStateOf: aStream	^ aStream position.! !!UTF8TextConverter methodsFor: 'accessing' stamp: 'yo 12/30/2002 14:00'!currentCharSize	^ currentCharSize.! !!UTF8TextConverter methodsFor: 'accessing' stamp: 'yo 8/4/2003 15:34'!forceToEncodingTag	^ forceToEncodingTag.! !!UTF8TextConverter methodsFor: 'accessing' stamp: 'yo 8/4/2003 15:31'!forceToEncodingTag: encodingTagOrNil	forceToEncodingTag _ encodingTagOrNil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UTF8TextConverter class	instanceVariableNames: ''!!UTF8TextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2003 11:54'!encodingNames	^ #('utf-8') copy.! !!UTF8TextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2002 16:29'!example1	"UTF8TextConverter example1"	| fileStream |	fileStream _ FileStream newFileNamed: 'test.utf8'.	fileStream converter: UTF8TextConverter new.	fileStream nextPut: (MultiCharacter value: 16780785).	fileStream nextPut: (MultiCharacter value: 16781223).	fileStream nextPut: (MultiCharacter value: 50335081).	fileStream nextPut: (MultiCharacter value: 50334733).	fileStream nextPut: (MultiCharacter value: 33559461).	fileStream nextPut: (MultiCharacter value: 33556777).	fileStream close.! !!UTF8TextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2002 16:29'!example2	"UTF8TextConverter example2"	| writeStream fileStream |	writeStream _ WriteStream on: String new.	fileStream _ FileStream fileNamed: 'test.utf8'.	fileStream converter: UTF8TextConverter new.	[fileStream atEnd]		whileFalse: [writeStream nextPut: fileStream next].	fileStream close.	^ writeStream contents.! !ClipboardInterpreter subclass: #WinShiftJISClipboardInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!WinShiftJISClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 19:09'!fromSystemClipboard: aString	^ aString squeakToIso convertFromSystemString! !!WinShiftJISClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 21:17'!toSystemClipboard: text	| string |	"self halt."	string _ text asString.	string isAsciiString ifTrue: [^ string asOctetString].	string isOctetString ifTrue: [^ string "hmm"].	^ string convertToSystemString isoToSqueak.! !KeyboardInputInterpreter subclass: #WinShiftJISInputInterpreter	instanceVariableNames: 'converter '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!WinShiftJISInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/13/2003 13:45'!initialize	converter _ ShiftJISTextConverter new.! !!WinShiftJISInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 22:30'!nextCharFrom: sensor firstEvt: evtBuf	| firstCharacter secondCharacter peekEvent char1Value keyValue pressType type stream multiCharacter |	keyValue := evtBuf third.	pressType := evtBuf fourth.	pressType = EventKeyDown ifTrue: [type := #keyDown].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [type := #keystroke].	char1Value _ (Character value: keyValue) squeakToIso asciiValue.	((char1Value > 127 and: [char1Value < 160])		or: [char1Value > 223 and: [char1Value < 253]]) ifFalse: [			^ keyValue asCharacter.		].	peekEvent _ sensor peekEvent.	"peekEvent printString displayAt: 0@0."	(peekEvent notNil and: [(peekEvent at: 4) = EventKeyDown])		ifTrue: [sensor nextEvent.			peekEvent _ sensor peekEvent].	(type = #keystroke			and: [peekEvent notNil					and: [(peekEvent at: 1)								= EventTypeKeyboard							and: [(peekEvent at: 4)									= EventKeyChar]]])		ifTrue: [			firstCharacter _ char1Value asCharacter.			secondCharacter _ (peekEvent at: 3) asCharacter squeakToIso.			stream _ ReadStream on: (String with: firstCharacter with: secondCharacter).			multiCharacter _ converter nextFromStream: stream.			multiCharacter isOctetCharacter ifFalse: [				sensor nextEvent.			].			^ multiCharacter.		].	^ keyValue asCharacter.! !KeyboardInputInterpreter subclass: #MacShiftJISInputInterpreter	instanceVariableNames: 'converter '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!MacShiftJISInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/13/2003 13:45'!initialize	converter _ ShiftJISTextConverter new.! !!MacShiftJISInputInterpreter methodsFor: 'as yet unclassified' stamp: 'sumim 8/29/2003 15:25'!nextCharFrom: sensor firstEvt: evtBuf	| firstChar secondChar peekEvent keyValue type stream multiChar |	keyValue _ evtBuf third.	evtBuf fourth = EventKeyChar ifTrue: [type _ #keystroke].	peekEvent _ sensor peekEvent.	(peekEvent notNil and: [peekEvent fourth = EventKeyDown]) ifTrue: [		sensor nextEvent.		peekEvent _ sensor peekEvent].	(type == #keystroke	and: [peekEvent notNil 	and: [peekEvent first = EventTypeKeyboard	and: [peekEvent fourth = EventKeyChar]]]) ifTrue: [		firstChar _ keyValue asCharacter.		secondChar _ (peekEvent third) asCharacter.		stream _ ReadStream on: (String with: firstChar with: secondChar).		multiChar _ converter nextFromStream: stream.		multiChar isOctetCharacter ifFalse: [sensor nextEvent].		^ multiChar].	^ keyValue asCharacter! !ClipboardInterpreter subclass: #UnixEUCJPClipboardInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!KeyboardInputInterpreter subclass: #UnixEUCJPInputInterpreter	instanceVariableNames: 'converter '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!UnixEUCJPClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'Tsutomu Hiroshima 11/7/2003 15:57'!fromSystemClipboard: aString	^ aString convertFromSystemString! !!UnixEUCJPClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'Tsutomu Hiroshima 11/7/2003 15:57'!toSystemClipboard: text	| string |	"self halt."	string _ text asString.	string isAsciiString ifTrue: [^ string asOctetString].	string isOctetString ifTrue: [^ string "hmm"].	^ string convertToSystemString .! !!UnixEUCJPInputInterpreter methodsFor: 'as yet unclassified' stamp: 'Tsutomu Hiroshima 11/7/2003 15:11'!initialize	converter _ EUCJPTextConverter new.! !!UnixEUCJPInputInterpreter methodsFor: 'as yet unclassified' stamp: 'Tsutomu Hiroshima 11/7/2003 20:25'!nextCharFrom: sensor firstEvt: evtBuf	| firstChar secondChar peekEvent keyValue type stream multiChar |	keyValue _ evtBuf third.	evtBuf fourth = EventKeyChar ifTrue: [type _ #keystroke].	peekEvent _ sensor peekEvent.	(peekEvent notNil and: [peekEvent fourth = EventKeyDown]) ifTrue: [		sensor nextEvent.		peekEvent _ sensor peekEvent].	(type == #keystroke	and: [peekEvent notNil 	and: [peekEvent first = EventTypeKeyboard	and: [peekEvent fourth = EventKeyChar]]]) ifTrue: [		firstChar _ keyValue asCharacter.		secondChar _ (peekEvent third) asCharacter.		stream _ ReadStream on: (String with: firstChar with: secondChar).		multiChar _ converter nextFromStream: stream.		multiChar isOctetCharacter ifFalse: [sensor nextEvent].		^ multiChar].	^ keyValue asCharacter! !"Postscript:""LanguageEnvironment initialize".Smalltalk closeSourceFiles.Smalltalk garbageCollect.Smalltalk openSourceFiles.!