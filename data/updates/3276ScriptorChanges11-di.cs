'From Squeak2.9alpha of 12 June 2000 [latest update: #3340] on 31 January 2001 at 11:38:11 am'!"Change Set:		ScriptorChanges11Date:			29 January 2001Author:			Dan IngallsIntroduces two new optional properties in TwoWayScrollPanes:	#hideUnneededScrollbars - suppresses scrollBar display if full content is visible.	#maxAutoFitSize - causes entire pane to track conent size, up to this limit.Patches calls on #showSourceInScriptor to reset alignment resizing to #shrinkWrap, thus enabling new-tile ScriptEditors to grow and shrink with their content, as did the old tiles.Above two changes cause ScriptEditors with new tiles to grow and shrink properly with their content.Reinstates old green drop zones for insertion in tile scriptors.Several tweaks to drop zones for consistent appearance and behavior in new tile scriptors.The border width of TowWayScrollers has been set to 0 in scriptors.	Bug: if it is 1, the border only shows on two sides."!ComponentLikeModel subclass: #TwoWayScrollPane	instanceVariableNames: 'getMenuSelector getMenuTitleSelector xScrollBar yScrollBar scroller '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!Debugger methodsFor: 'code pane' stamp: 'di 1/31/2001 10:15'!toggleSyntaxMorph	syntaxMorph ifNil:		[syntaxMorph _ self createSyntaxMorph inAScrollPane.		syntaxMorph color: Color paleOrange].	standardTextMorph visible ifTrue: [		standardTextMorph owner replacePane: standardTextMorph with: syntaxMorph.		syntaxMorph scroller firstSubmorph update: #contentsSelection.	] ifFalse: [		syntaxMorph owner replacePane: syntaxMorph with: standardTextMorph.	].! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'di 1/31/2001 11:37'!useNewTiles	| ww |	"At the next request for textual script, use new tiles instead.  Make that request."	ww _ self bestGuessOfCurrentWorld.	(ww valueOfProperty: #universalTiles ifAbsent: [false]) ifFalse: [		ww setProperty: #universalTiles toValue: true.	 		"for all scriptors and viewers in this world"		"force viewers to be recreated"		ww flapTabs do: [:ff | (ff isMemberOf: ViewerFlapTab) ifTrue: [							ff referent delete.  ff delete]].		Utilities clobberFlapTabList].	Preferences enable: #capitalizedReferences.	self showSourceInScriptor.   "**This does way more than necess, AND kills the shrinkWrap..."	self hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		cellPositioning: #topLeft.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'di 1/31/2001 10:13'!useNewTilesNow	| mp source aSelector aClass tree syn widget |	"First make it show source with a method pane, then substitute tiles!!"	(mp _ self findA: MethodMorph) ifNil: [^ self].	"code pane must be present"	aSelector _ mp model selectedMessageName.	aClass _ mp model selectedClassOrMetaClass.	source _ aClass sourceCodeAt: aSelector.    	tree _ Compiler new 		parse: source 		in: aClass 		notifying: nil.	(syn _ tree asMorphicSyntaxUsing: SyntaxMorph)		parsedInClass: aClass.	widget _ syn inAScrollPane.	widget color: Color transparent;		setProperty: #hideUnneededScrollbars toValue: true;		setProperty: #maxAutoFitSize toValue: 300@200.	mp delete.	self addMorphBack: widget.	widget extent: (self width - 10 @ 150).! !!SyntaxMorph methodsFor: 'initialization' stamp: 'di 1/31/2001 10:12'!inAScrollPane	| widget |	widget _ TwoWayScrollPane new.	widget extent: 10@10;		borderWidth: 0.	widget scroller addMorph: self.	widget setScrollDeltas.	^widget! !!SyntaxMorph methodsFor: 'initialization' stamp: 'di 1/31/2001 10:14'!openInWindow	| window widget sel |	sel _ ''.	self firstSubmorph allMorphs do: [:rr | 			(rr isKindOf: StringMorph) ifTrue: [sel _ sel, rr contents]].	window _ (SystemWindow labelled: 'Tiles for ', self parsedInClass printString, '>>',sel).	widget _ self inAScrollPane.	widget color: Color paleOrange.	window		addMorph: widget		frame: (0@0 extent: 1.0@1.0).	window openInWorldExtent: (		self extent + (20@40) min: (Display boundingBox extent * 0.8) rounded	)! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 1/29/2001 16:14'!mouseEnterDragging: evt	"Highlight this level as a potential drop target""Transcript cr; print: self; show: ' enterDragging'."	evt hand hasSubmorphs ifFalse: [^ self].  "Don't react to empty hand"	self unhighlightOwner.	self highlightForDrop: evt.	self isBlockNode ifTrue:		[(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m isBlockNode]])			ifNotNilDo: [:m | "Suspend outer block."						m stopStepping; removeDropZones].		self startStepping]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 1/29/2001 16:13'!mouseLeaveDragging: evt"Transcript cr; print: self; show: ' leaveDragging'."	self isBlockNode ifTrue:		[self stopStepping; removeDropZones.		(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m isBlockNode]])			ifNotNilDo: [:m | "Activate outer block."						m startStepping]].	"Move drop highlight back out a level"	self unhighlight.	(owner ~~ nil and: [owner isSyntaxMorph])		ifTrue: [owner highlightForDrop: evt].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 1/30/2001 09:31'!step	self isBlockNode ifTrue: [self trackDropZones].	super step! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 1/30/2001 11:22'!wantsSteps	"Only step this morph if we explicitly send startStepping"	^ false! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'di 1/29/2001 16:32'!acceptDroppingMorph: aMorph event: evt	| itNoun old |	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks.  see wantsDroppedMorph:event:"	"We know it is acceptable.  Just a matter of which case"	itNoun _ aMorph isNoun.	self withAllOwnersDo:		[:m | (m isSyntaxMorph and: [m isBlockNode])			ifTrue: [m stopStepping; removeDropZones]].	self isBlockNode & itNoun		ifTrue:			[(aMorph nodeClassIs: TempVariableNode) ifTrue:				["If I am a BlockNode, and it is a TempVariableNode, add it into list"				^ (self addBlockArg: aMorph) ifFalse:					["if already declared, start new line of code with it"					self addToBlock: aMorph event: evt]]			ifFalse:			[^ self addToBlock: aMorph event: evt]].	"If I am a BlockNode and it is a noun add it as a new line"	self isBlockNode ifTrue: [		 (aMorph nodeClassIs: ReturnNode) ifTrue: [^ self addToBlock: aMorph event: evt]].	"Later add args and keywords.  later allow comments to be dropped"	"Can't put statement, literal, assignment, or cascade into left side of assignment"	(owner isSyntaxMorph) ifTrue:		[(owner nodeClassIs: AssignmentNode) ifTrue:			[(owner submorphIndexOf: self) = 1 ifTrue:				[((aMorph nodeClassIs: TempVariableNode)				or: [aMorph nodeClassIs: VariableNode])  ifFalse: [ ^ self]]]].	aMorph deselect.	(old _ owner) replaceSubmorph: self by: aMorph.	"do the normal replacement"	old cleanupAfterItDroppedOnMe.	"now owned by no one"! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'di 1/29/2001 16:23'!cleanupAfterItDroppedOnMe	"A tile just dropped into me.  Clean up"	self layoutChanged.  "** Isn't this already implied by the addMorph: ?"	"Auto-accept on drop if in a scriptor"	self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'di 1/31/2001 09:56'!morphToDropInPasteUp: aPasteUp	"If property #beScript is true, create a scriptor around me."	| actualObject itsSelector aScriptor adjustment handy tw blk |	self flag: #noteToTed.  "I changed PhraseTileMorph's version of this method to eliminate the flagshipInstance annoyance, and the below needs to be changed accordingly -- look at my method and notice diffs.  Besides eliminating the flagshipInstance test, one needs to be sure that the thing dropped is adjusted to reflect which instance of the uniclass is at hand.  sw 1/19/2001 02:30"	(self valueOfProperty: #beScript ifAbsent: [false]) ifFalse: [^ self].	self removeProperty: #beScript.	(actualObject _ self actualObject) ifNil: [^ self].	actualObject assureUniClass.	itsSelector _ self userScriptSelector.	aScriptor _ itsSelector isEmptyOrNil		ifFalse:			[adjustment _ 0@0.			actualObject scriptEditorFor: itsSelector]		ifTrue:			["It's a system-defined selector; construct an anonymous scriptor around it"			adjustment _ 60 @ 20.			actualObject newScriptorAround: self].	handy _ aPasteUp primaryHand.	aScriptor ifNotNil: [		aScriptor position: handy position - adjustment.		aPasteUp addMorphFront: aScriptor.	"do this early so can find World"		(tw _ aScriptor findA: TwoWayScrollPane) ifNil: [			aScriptor useNewTiles.			itsSelector ifNil: ["blank script"				tw _ aScriptor findA: TwoWayScrollPane.				blk _ tw scroller firstSubmorph "MethodNode" lastSubmorph "BlockNode".				blk addMorphFront: self.				"self position: self topLeft + (7@14)"]]].	aScriptor showSourceInScriptor.  "**This destroys most of the work done before**"	aScriptor hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		cellPositioning: #topLeft.	(aScriptor isKindOf: ScriptEditorMorph) ifTrue:		[aScriptor playerScripted expungeEmptyUnRenamedScripts].	^ aScriptor ifNil: [self]! !!SyntaxMorph methodsFor: 'insertion drop zones' stamp: 'di 1/29/2001 16:11'!hideCaret	"For backward compat -- remove when there are no senders"	self removeDropZones! !!SyntaxMorph methodsFor: 'insertion drop zones' stamp: 'di 1/30/2001 21:00'!removeDropZones	"Remove the insertion drop-zone morphs."	self submorphsDo:		[:mm | (mm isMemberOf: BorderedMorph) ifTrue: [mm delete]].! !!SyntaxMorph methodsFor: 'insertion drop zones' stamp: 'di 1/31/2001 09:14'!trackDropZones	| hand i localPt insertion insHt ii prevBot nxtHt d c1 c2 ht2 spacer1 spacer2 wid ht1 |	hand _ self primaryHand.	(hand lastEvent redButtonPressed & hand hasSubmorphs		and: [(self hasOwner: hand) not]) ifFalse: [^ self].	insertion _ hand firstSubmorph renderedMorph.	insertion isNoun ifFalse: [^ self].	localPt _ self globalPointToLocal: hand position.	insHt _ insertion height.  "**just use standard line height here"	self removeDropZones.  "Maybe first check if in right place, then just tweak heights."	i _ (ii _ self indexOfMorphAbove: localPt) min: submorphs size-1.	prevBot _ i <= 0 ifTrue: [(self innerBounds) top]					ifFalse: [(self submorphs at: i) bottom].	nxtHt _ (submorphs isEmpty		ifTrue: [insertion]		ifFalse: [self submorphs at: i+1]) height.	d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]			ifFalse: [0 max: (localPt y - prevBot min: nxtHt)].	"Top and bottom spacer heights cause continuous motion..."	c1 _ Color yellow lighter.  c2 _ Color transparent.	ht2 _ d*insHt//nxtHt.  ht1 _ insHt - ht2.	wid _ 100 min: owner width - 10.	(spacer1 _ BorderedMorph newBounds: (0@0 extent: wid@ht1)					color: (ht1 > (insHt//2) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer1 color.	self privateAddMorph: spacer1 atIndex: (i+1 max: 1).	(spacer2 _ BorderedMorph newBounds: (0@0 extent: wid@ht2)					color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer2 color.	self privateAddMorph: spacer2 atIndex: (i+3 min: submorphs size+1).	self fullBounds.  "Force layout prior to testing for cursor containment"	"Maintain the drop target highlight -- highlight spacer if hand is in it."	{spacer1. spacer2} do:		[:spacer | (spacer containsPoint: localPt) ifTrue:			[spacer borderColor: self dropColor.			self borderColor = self dropColor				ifTrue: [self borderColor: self stdBorderColor]]].	"If no submorph (incl spacers) highlighted, then re-highlight the block."	((self wantsDroppedMorph: insertion event: hand lastEvent) and:		[(self submorphs anySatisfy: [:m | m containsPoint: localPt]) not])		ifTrue: [self borderColor: self dropColor]! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 1/31/2001 10:39'!translateColor: aColorOrSymbol	aColorOrSymbol == #comment  ifTrue: [^ Color blue lighter].	aColorOrSymbol == #block  ifTrue: [^ Color transparent].	aColorOrSymbol == #text  ifTrue: [^ Color transparent].	aColorOrSymbol isColor  ifTrue: [^ aColorOrSymbol].	self noTileColor ifTrue: [^ Color transparent].	"override"	aColorOrSymbol == #assignment  ifTrue: [^ Color paleGreen].	aColorOrSymbol == #keyword1  ifTrue: [^ Color paleBuff].	"binary"	aColorOrSymbol == #keyword2  ifTrue: [^ Color paleBuff lighter].	"multipart" 	aColorOrSymbol == #cascade  ifTrue: [^ Color paleYellow darker].	"has receiver"	aColorOrSymbol == #cascade2  ifTrue: [^ Color paleOrange].	"one send in the cascade"	aColorOrSymbol == #literal  ifTrue: [^ Color paleMagenta].	aColorOrSymbol == #message  ifTrue: [^ Color paleYellow].	aColorOrSymbol == #method  ifTrue: [^ Color white].	aColorOrSymbol == #error  ifTrue: [^ Color red].	aColorOrSymbol == #return  ifTrue: [^ Color lightGray].	aColorOrSymbol == #variable  ifTrue: [^ Color paleTan].	aColorOrSymbol == #brace  ifTrue: [^ Color paleOrange].	aColorOrSymbol == #tempVariable  ifTrue: [^ Color paleYellow mixed: 0.75 with: Color paleGreen		"Color yellow lighter lighter"].	aColorOrSymbol == #blockarg2  ifTrue: [			^ Color paleYellow mixed: 0.75 with: Color paleGreen].	"arg itself"	aColorOrSymbol == #blockarg1  ifTrue: [^ Color paleRed].	"container"		"yellow mixed: 0.5 with: Color white"	^aColorOrSymbol! !!TransformMorph methodsFor: 'geometry' stamp: 'di 1/30/2001 22:40'!contentBounds	self hasSubmorphs ifTrue:		[^ (transform localBoundsToGlobal: self submorphBounds) truncated].	^ self fullBounds! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'di 1/31/2001 09:59'!fitContentsUpTo: maxFitSize	"Implements the autoFit feature:  If the #maxAutoFitSize property is set, then change my size to track any changes in the extent of my contents up to the max extent.  Above that extent, use scrollbars.  Typically one uses the #hideUnneededScrollbars property as well."	"Adjust my size to fit my contents reasonably snugly"	self extent: (scroller contentBounds extent				+ (yScrollBar width@xScrollBar height)				+ (borderWidth*2) min: maxFitSize)				 ! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'di 1/29/2001 14:18'!resizeScroller	| inner |	"used to handle left vs right scrollbar"	inner _ self innerBounds.	scroller bounds: (inner topLeft + (yScrollBar width@0) corner: (inner bottomRight - (0@xScrollBar height)))! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'di 1/28/2001 21:37'!setScrollDeltas	| range scrollDelta totalRange innerBounds |	totalRange _ self totalScrollRange ifNil: [^ self].	range _ self leftoverScrollRange.	innerBounds _ self innerBounds.	scrollDelta _ 10 @ 10.	self hideOrShowScrollBar: xScrollBar forRange: totalRange x - (innerBounds width - yScrollBar width).	range x = 0		ifTrue: [xScrollBar scrollDelta: 0.02 pageDelta: 0.2.				xScrollBar interval: 1.0]		ifFalse: [xScrollBar scrollDelta: (scrollDelta x / range x) asFloat						pageDelta: (innerBounds width - scrollDelta x / range x) asFloat.				xScrollBar interval: (innerBounds width - scrollDelta x / totalRange x) asFloat].	self hideOrShowScrollBar: yScrollBar forRange: totalRange y - (innerBounds height - xScrollBar height).	range y = 0		ifTrue: [yScrollBar scrollDelta: 0.02 pageDelta: 0.2.				xScrollBar interval: 1.0]		ifFalse: [yScrollBar scrollDelta: (scrollDelta y / range y) asFloat						pageDelta: (innerBounds height - scrollDelta y / range y) asFloat.				yScrollBar interval: (innerBounds height - scrollDelta y / totalRange y) asFloat]! !!TwoWayScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 1/23/2001 07:36'!hideOrShowScrollBar: scrollBar forRange: range	(self hasProperty: #hideUnneededScrollbars) ifFalse: [^ self].	(submorphs includes: scrollBar)		ifTrue: [range <= 0 ifTrue: [scrollBar model: nil; delete]]		ifFalse: [range > 0 ifTrue: [scrollBar model: self.  self addMorph: scrollBar]]! !!TwoWayScrollPane methodsFor: 'as yet unclassified' stamp: 'di 1/29/2001 10:44'!layoutChanged	self valueOfProperty: #maxAutoFitSize ifPresentDo:		[:maxFitSize |		self fitContentsUpTo: maxFitSize.		^ super layoutChanged].	scroller ifNotNil: [self setScrollDeltas].	^ super layoutChanged! !!UniclassScript methodsFor: 'script editor' stamp: 'di 1/31/2001 10:56'!instantiatedScriptEditor	"Return the current script editor, creating it if necessary"	| aPlayer |	(currentScriptEditor == nil or: [currentScriptEditor == #textuallyCoded]) ifTrue:		[aPlayer _ playerClass someInstance.		currentScriptEditor _ ScriptEditorMorph new				setMorph: aPlayer costume				scriptName: selector.		self isTextuallyCoded ifTrue:			[currentScriptEditor showSourceInScriptor].		defaultStatus == #ticking ifTrue:			[aPlayer costume arrangeToStartStepping]].		^ currentScriptEditor! !SyntaxMorph removeSelector: #addCaretFront:!SyntaxMorph removeSelector: #insertionIndexForCaret:!SyntaxMorph removeSelector: #mouseEnterDragging:inCaret:!SyntaxMorph removeSelector: #mouseLeaveDragging:inCaret:!SyntaxMorph removeSelector: #removeCaret:!SyntaxMorph removeSelector: #removeSpaces!SyntaxMorph removeSelector: #showCaretAt:!SyntaxMorph removeSelector: #startStepping!SyntaxMorph removeSelector: #trackCaret!!SyntaxMorph reorganize!('initialization' aJunkMethod:event: inAScrollPane openInWindow)('accessing' actualObject color: externalName getCurrentValue parseNode parseNode: parsedInClass parsedInClass: rename: selector userScriptSelector userScriptSelector:)('node types' findA: isBlockNode isCascadePart isMethodNode isNoun isSyntaxMorph nodeClassIs: rootTile)('event handling' cursorBaseOffset handlesKeyboard: handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: keyStroke: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseUp: step stepTime wantsSteps)('dropping/grabbing' acceptDroppingMorph:event: cleanupAfterItDroppedOnMe justDroppedInto:event: morphToDropInPasteUp: wantsDroppedMorph:event:)('drawing' drawOn:)('highlighting' borderColor: dropColor grabColor highlightForDrop: highlightForGrab: stdBorderColor unhighlight unhighlightOwner)('selection' currentSelectionDo: deselect isSelectable select setSelection: wantsKeyboardFocusFor:)('insertion drop zones' hideCaret removeDropZones trackDropZones)('layout' addBlockArg: addColumn:on: addRow:on: addString: addTempVar: addTextRow: addToBlock:event: addToken:type:on: foldMessage foldMessageOneArg try unfoldMessage)('printing' printOn: printOn:indent: structure)('pop ups' changeSound: colorPatch deletePopup event:arrow:upDown: extend extendArrow offerPopUp retract retractArrow upDownArrows)('menus' accept acceptIfInScriptor acceptIgnoring: decompile getMenuBlock showCode showMenu:)('debugging' balloonText debugger debugger: hostContext update:)('tests' cascadeTest changed test testForNode:andDo: toDo)('copying')!