'From Squeak2.9alpha of 13 June 2000 [latest update: #3013] on 15 November 2000 at 2:17:13 pm'!"Change Set:		LayoutPropertiesDate:			15 November 2000Author:			Andreas RaabGroups the prominent layout properties together so that they're no longer spread out in the other properties."!Object subclass: #LayoutProperties	instanceVariableNames: 'hResizing vResizing disableLayout '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!!LayoutProperties commentStamp: '<historical>' prior: 0!This class provides a compact bit encoding for the most commonly used layout properties.!LayoutPolicy subclass: #TableLayout	instanceVariableNames: 'properties '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!LayoutProperties subclass: #TableLayoutProperties	instanceVariableNames: 'cellInset cellPositioning cellSpacing layoutInset listCentering listDirection listSpacing reverseTableCells rubberBandCells wrapCentering wrapDirection minCellSize maxCellSize '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!!LayoutProperties methodsFor: 'initialize' stamp: 'ar 11/14/2000 17:53'!initialize	hResizing _ vResizing _ #rigid.	disableLayout _ false.! !!LayoutProperties methodsFor: 'initialize' stamp: 'ar 11/14/2000 17:56'!initializeFrom: defaultProvider	"Initialize the receiver from a default provider"	self hResizing: defaultProvider hResizing.	self vResizing: defaultProvider vResizing.	self disableTableLayout: defaultProvider disableTableLayout.! !!LayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:51'!disableTableLayout	^disableLayout! !!LayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:51'!disableTableLayout: aBool	disableLayout _ aBool! !!LayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:51'!hResizing	^hResizing! !!LayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:51'!hResizing: aSymbol	hResizing _ aSymbol! !!LayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:51'!vResizing	^vResizing! !!LayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:52'!vResizing: aSymbol	vResizing _ aSymbol! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/13/2000 19:53'!cellInset	"Default"	^0! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/14/2000 17:50'!cellPositioning	^#center! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/13/2000 19:55'!cellSpacing	"Default"	^#none! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/14/2000 16:38'!layoutInset	^0! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/13/2000 19:58'!listCentering	"Default"	^#topLeft! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/13/2000 19:59'!listDirection	"Default"	^#topToBottom! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/13/2000 19:59'!listSpacing	"Default"	^#none! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/13/2000 20:00'!maxCellSize	^SmallInteger maxVal! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/13/2000 20:00'!minCellSize	^0! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/13/2000 20:00'!reverseTableCells	^false! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/13/2000 20:01'!rubberBandCells	^false! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/13/2000 20:02'!wrapCentering	^#topLeft! !!LayoutProperties methodsFor: 'table defaults' stamp: 'ar 11/13/2000 20:02'!wrapDirection	^#none! !!LayoutProperties methodsFor: 'testing' stamp: 'ar 11/13/2000 18:34'!includesTableProperties	^false! !!LayoutProperties methodsFor: 'converting' stamp: 'ar 11/14/2000 17:52'!asTableLayoutProperties	^(TableLayoutProperties new)		hResizing: self hResizing;		vResizing: self vResizing;		disableTableLayout: self disableTableLayout;		yourself! !!LayoutProperties class methodsFor: 'instance creation' stamp: 'ar 11/13/2000 18:16'!new	^super new initialize! !!Morph methodsFor: 'property extension' stamp: 'ar 11/13/2000 19:27'!resetExtension	"Reset the extension slot if it is not needed"	extension ifNil:[^false]. "not removed"	extension isDefault ifTrue:[		extension _ nil.		^true].	^false! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:08'!changeCellInset: evt	| handle |	handle _ HandleMorph new forEachPointDo:[:newPoint |		self cellInset: (newPoint - evt cursorPoint) asIntegerPoint // 5].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 18:54'!changeClipLayoutCells	self invalidRect: self fullBounds.	self clipLayoutCells: self clipLayoutCells not.	self invalidRect: self fullBounds.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:09'!changeLayoutInset: evt	| handle |	handle _ HandleMorph new forEachPointDo:[:newPoint |		self layoutInset: (newPoint - evt cursorPoint) asIntegerPoint // 5].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:10'!changeListDirection: aSymbol	| listDir wrapDir |	self listDirection: aSymbol.	(self wrapDirection == #none) ifTrue:[^self].	"otherwise automatically keep a valid table layout"	listDir _ self listDirection.	wrapDir _ self wrapDirection.	(listDir == #leftToRight or:[listDir == #rightToLeft]) ifTrue:[		wrapDir == #leftToRight ifTrue:[^self wrapDirection: #topToBottom].		wrapDir == #rightToLeft ifTrue:[^self wrapDirection: #bottomToTop].	] ifFalse:[		wrapDir == #topToBottom ifTrue:[^self wrapDirection: #leftToRight].		wrapDir == #bottomToTop ifTrue:[^self wrapDirection: #rightToLeft].	].! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:10'!changeMaxCellSize: evt	| handle |	handle _ HandleMorph new forEachPointDo:[:newPoint |		self maxCellSize: (newPoint - evt cursorPoint) asIntegerPoint].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:10'!changeMinCellSize: evt	| handle |	handle _ HandleMorph new forEachPointDo:[:newPoint |		self minCellSize: (newPoint - evt cursorPoint) asIntegerPoint].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:10'!changeReverseCells	self reverseTableCells: self reverseTableCells not.! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:10'!changeRubberBandCells	self rubberBandCells: self rubberBandCells not.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:56'!assureLayoutProperties	| props |	props _ self layoutProperties.	props == self ifTrue:[props _ nil].	props ifNil:[		props _ LayoutProperties new initializeFrom: self.		self layoutProperties: props].	^props! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:57'!assureTableProperties	| props |	props _ self layoutProperties.	props == self ifTrue:[props _ nil].	props ifNil:[		props _ TableLayoutProperties new initializeFrom: self.		self layoutProperties: props].	props includesTableProperties 		ifFalse:[self layoutProperties: (props _ props asTableLayoutProperties)].	^props! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:54'!cellInset	"Layout specific. This property specifies an extra inset for each cell in the layout."	| props |	props _ self layoutProperties.	^props ifNil:[0] ifNotNil:[props cellInset].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:54'!cellInset: aNumber	"Layout specific. This property specifies an extra inset for each cell in the layout."	self assureTableProperties cellInset: aNumber.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:54'!cellPositioning	"Layout specific. This property describes how the receiver should be layed out in its owner when the bounds of the cell assigned to the receiver do not exactly match its bounds. Possible values are:		#topLeft, #topRight, #bottomLeft, #bottomRight, #topCenter, #leftCenter, #rightCenter, #bottomCenter, #center 	which align the receiver's bounds with the cell at the given point."	| props |	props _ self layoutProperties.	^props ifNil:[#center] ifNotNil:[props cellPositioning].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:39'!cellPositioning: aSymbol	"Layout specific. This property describes how the receiver should be layed out in its owner when the bounds of the cell assigned to the receiver do not exactly match its bounds. Possible values are:		#topLeft, #topRight, #bottomLeft, #bottomRight, #topCenter, #leftCenter, #rightCenter, #bottomCenter, #center 	which align the receiver's bounds with the cell at the given point."	self assureTableProperties cellPositioning: aSymbol.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:55'!cellSpacing	"Layout specific. This property describes how the cell size for each element in a list should be computed.		#globalRect - globally equal rectangular cells		#globalSquare - globally equal square cells		#localRect - locally (e.g., per row/column) equal rectangular cells		#localSquare - locally (e.g., per row/column) equal square cells		#none - cells are sized based on available row/column constraints	"	| props |	props _ self layoutProperties.	^props ifNil:[#none] ifNotNil:[props cellSpacing].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:56'!cellSpacing: aSymbol	"Layout specific. This property describes how the cell size for each element in a list should be computed.		#globalRect - globally equal rectangular cells		#globalSquare - globally equal square cells		#localRect - locally (e.g., per row/column) equal rectangular cells		#localSquare - locally (e.g., per row/column) equal square cells		#none - cells are sized based on available row/column constraints	"	self assureTableProperties cellSpacing: aSymbol.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:56'!disableTableLayout	"Layout specific. Disable laying out the receiver in table layout"	| props |	props _ self layoutProperties.	^props ifNil:[false] ifNotNil:[props disableTableLayout].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:06'!disableTableLayout: aBool	"Layout specific. Disable laying out the receiver in table layout"	self assureLayoutProperties disableTableLayout: aBool.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:57'!hResizing	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	| props |	props _ self layoutProperties.	^props ifNil:[#rigid] ifNotNil:[props hResizing].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:06'!hResizing: aSymbol	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	self assureLayoutProperties hResizing: aSymbol.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:19'!layoutFrame	"Layout specific. Return the layout frame describing where the receiver should appear in a proportional layout"	extension == nil ifTrue:[^nil].	^extension layoutFrame! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:20'!layoutFrame: aLayoutFrame	"Layout specific. Return the layout frame describing where the receiver should appear in a proportional layout"	self layoutFrame == aLayoutFrame ifTrue:[^self].	self assureExtension layoutFrame: aLayoutFrame.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 16:38'!layoutInset	"Return the extra inset for layouts"	| props |	props _ self layoutProperties.	^props ifNil:[0] ifNotNil:[props layoutInset].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 16:38'!layoutInset: aNumber	"Return the extra inset for layouts"	self assureTableProperties layoutInset: aNumber.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:19'!layoutPolicy	"Layout specific. Return the layout policy describing how children of the receiver should appear."	extension == nil ifTrue:[^nil]. "shortcut for speed"	^extension layoutPolicy! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:21'!layoutPolicy: aLayoutPolicy	"Layout specific. Return the layout policy describing how children of the receiver should appear."	self layoutPolicy == aLayoutPolicy ifTrue:[^self].	self assureExtension layoutPolicy: aLayoutPolicy.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:19'!layoutProperties	"Return the current layout properties associated with the receiver"	extension == nil ifTrue:[^nil].	^extension layoutProperties! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:21'!layoutProperties: newProperties	"Return the current layout properties associated with the receiver"	self layoutProperties == newProperties ifTrue:[^self].	self assureExtension layoutProperties: newProperties.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:58'!listCentering	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of primary direction		#bottomRight - center at end of primary direction		#center - center in the middle of primary direction		#justified - insert extra space inbetween rows/columns	"	| props |	props _ self layoutProperties.	^props ifNil:[#topLeft] ifNotNil:[props listCentering].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:05'!listCentering: aSymbol	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of primary direction		#bottomRight - center at end of primary direction		#center - center in the middle of primary direction		#justified - insert extra space inbetween rows/columns	"	self assureTableProperties listCentering: aSymbol.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:59'!listDirection	"Layout specific. This property describes the direction in which a list-like layout should be applied. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop	indicating the direction in which any layout should take place"	| props |	props _ self layoutProperties.	^props ifNil:[#topToBottom] ifNotNil:[props listDirection].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:04'!listDirection: aSymbol	"Layout specific. This property describes the direction in which a list-like layout should be applied. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop	indicating the direction in which any layout should take place"	self assureTableProperties listDirection: aSymbol.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:59'!listSpacing	"Layout specific. This property describes how the heights for different rows in a table layout should be handled.		#equal - all rows have the same height		#none - all rows may have different heights	"	| props |	props _ self layoutProperties.	^props ifNil:[#none] ifNotNil:[props listSpacing].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:04'!listSpacing: aSymbol	"Layout specific. This property describes how the heights for different rows in a table layout should be handled.		#equal - all rows have the same height		#none - all rows may have different heights	"	self assureTableProperties listSpacing: aSymbol.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:59'!maxCellSize	"Layout specific. This property specifies the maximum size of a table cell."	| props |	props _ self layoutProperties.	^props ifNil:[SmallInteger maxVal] ifNotNil:[props maxCellSize].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:04'!maxCellSize: aPoint	"Layout specific. This property specifies the maximum size of a table cell."	self assureTableProperties maxCellSize: aPoint.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:00'!minCellSize	"Layout specific. This property specifies the minimal size of a table cell."	| props |	props _ self layoutProperties.	^props ifNil:[0] ifNotNil:[props minCellSize].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:04'!minCellSize: aPoint	"Layout specific. This property specifies the minimal size of a table cell."	self assureTableProperties minCellSize: aPoint.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:01'!reverseTableCells	"Layout specific. This property describes if the cells should be treated in reverse order of submorphs."	| props |	props _ self layoutProperties.	^props ifNil:[false] ifNotNil:[props reverseTableCells].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:04'!reverseTableCells: aBool	"Layout specific. This property describes if the cells should be treated in reverse order of submorphs."	self assureTableProperties reverseTableCells: aBool.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:01'!rubberBandCells	"Layout specific. This property describes if a parent that is #shrinkWrapped around its children should ignore any #spaceFill children. E.g., when #rubberBandCells is true, the compound layout will always stay at the smallest available size, even though some child may be able to grow."	| props |	props _ self layoutProperties.	^props ifNil:[false] ifNotNil:[props rubberBandCells].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:04'!rubberBandCells: aBool	"Layout specific. This property describes if a parent that is #shrinkWrapped around its children should ignore any #spaceFill children. E.g., when #rubberBandCells is true, the compound layout will always stay at the smallest available size, even though some child may be able to grow."	self assureTableProperties rubberBandCells: aBool.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/15/2000 14:16'!spaceFillWeight: aNumber	"Layout specific. This property describes the relative weight that should be given to the receiver when extra space is distributed between different #spaceFill cells."	aNumber = 1		ifTrue:[self removeProperty: #spaceFillWeight]		ifFalse:[self setProperty: #spaceFillWeight toValue: aNumber].	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:02'!vResizing	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	| props |	props _ self layoutProperties.	^props ifNil:[#rigid] ifNotNil:[props vResizing].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:03'!vResizing: aSymbol	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	self assureLayoutProperties vResizing: aSymbol.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:02'!wrapCentering	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of secondary direction		#bottomRight - center at end of secondary direction		#center - center in the middle of secondary direction		#justified - insert extra space inbetween rows/columns	"	| props |	props _ self layoutProperties.	^props ifNil:[#topLeft] ifNotNil:[props wrapCentering].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:03'!wrapCentering: aSymbol	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of secondary direction		#bottomRight - center at end of secondary direction		#center - center in the middle of secondary direction		#justified - insert extra space inbetween rows/columns	"	self assureTableProperties wrapCentering: aSymbol.	self layoutChanged.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:03'!wrapDirection	"Layout specific. This property describes the direction along which a list-like layout should be wrapped. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop		#none	indicating in which direction wrapping should occur. This direction must be orthogonal to the list direction, that is if listDirection is #leftToRight or #rightToLeft then wrapDirection must be #topToBottom or #bottomToTop and vice versa."	| props |	props _ self layoutProperties.	^props ifNil:[#none] ifNotNil:[props wrapDirection].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:03'!wrapDirection: aSymbol	"Layout specific. This property describes the direction along which a list-like layout should be wrapped. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop		#none	indicating in which direction wrapping should occur. This direction must be orthogonal to the list direction, that is if listDirection is #leftToRight or #rightToLeft then wrapDirection must be #topToBottom or #bottomToTop and vice versa."	self assureTableProperties wrapDirection: aSymbol.	self layoutChanged.! !!MenuItemMorph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:58'!hResizing	"Default to #spaceFill"	| props |	props _ self layoutProperties.	^props ifNil:[#spaceFill] ifNotNil:[props hResizing].! !!MenuItemMorph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:59'!vResizing	"Default to #shrinkWrap"	| props |	props _ self layoutProperties.	^props ifNil:[#shrinkWrap] ifNotNil:[props vResizing].! !!MorphExtension methodsFor: 'other' stamp: 'ar 11/13/2000 19:08'!isDefault	"Return true if the receiver is a default and can be omitted"	locked == true ifTrue:[^false].	visible == false ifTrue:[^false].	sticky == true ifTrue:[^false].	balloonText == nil ifFalse:[^false].	balloonTextSelector == nil ifFalse:[^false].	externalName == nil ifFalse:[^false].	isPartsDonor == true ifTrue:[^false].	actorState == nil ifFalse:[^false].	player == nil ifFalse:[^false].	eventHandler == nil ifFalse:[^false].	otherProperties == nil ifFalse:[otherProperties size > 0 ifTrue:[^false]].	^true! !!MorphExtension methodsFor: 'other' stamp: 'ar 11/13/2000 13:18'!sortedPropertyNames	| props |	props _ WriteStream on: (Array new: 10).	locked == true ifTrue:[props nextPut: #locked].	visible == false ifTrue:[props nextPut: #visible].	sticky == true ifTrue:[props nextPut: #sticky].	balloonText == nil ifFalse:[props nextPut: #balloonText].	balloonTextSelector == nil ifFalse:[props nextPut: #balloonTextSelector].	externalName == nil ifFalse:[props nextPut: #externalName].	isPartsDonor == true ifTrue:[props nextPut: #isPartsDonor].	actorState == nil ifFalse:[props nextPut: #actorState].	player == nil ifFalse:[props nextPut: #player].	eventHandler == nil ifFalse:[props nextPut: #eventHandler].	otherProperties == nil ifFalse:[		otherProperties associationsDo:[:a| props nextPut: a key]].	^props contents sort:[:s1 :s2| s1 <= s2].! !!MorphExtension methodsFor: 'layout properties' stamp: 'ar 11/14/2000 17:17'!layoutFrame	^self valueOfProperty: #layoutFrame ifAbsent:[nil]! !!MorphExtension methodsFor: 'layout properties' stamp: 'ar 11/14/2000 17:17'!layoutFrame: aLayoutFrame	aLayoutFrame == nil		ifTrue:[self removeProperty: #layoutFrame]		ifFalse:[self setProperty: #layoutFrame toValue: aLayoutFrame].! !!MorphExtension methodsFor: 'layout properties' stamp: 'ar 11/14/2000 17:17'!layoutPolicy	^self valueOfProperty: #layoutPolicy ifAbsent:[nil]! !!MorphExtension methodsFor: 'layout properties' stamp: 'ar 11/14/2000 17:18'!layoutPolicy: aLayoutPolicy	aLayoutPolicy == nil		ifTrue:[self removeProperty: #layoutPolicy]		ifFalse:[self setProperty: #layoutPolicy toValue: aLayoutPolicy].! !!MorphExtension methodsFor: 'layout properties' stamp: 'ar 11/14/2000 17:18'!layoutProperties	^self valueOfProperty: #layoutProperties ifAbsent:[nil]! !!MorphExtension methodsFor: 'layout properties' stamp: 'ar 11/14/2000 17:18'!layoutProperties: newProperties	"Return the current layout properties associated with the receiver"	newProperties == nil		ifTrue:[self removeProperty: #layoutProperties]		ifFalse:[self setProperty: #layoutProperties toValue: newProperties].! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/13/2000 18:24'!computeCellArrangement: cellHolder in: newBounds horizontal: aBool target: aMorph	"Compute number of cells we can put in each row/column. The returned array contains a list of all the cells we can put into the row/column at each level.	Note: The arrangement is so that the 'x' value of each cell advances along the list direction and the 'y' value along the wrap direction. The returned arrangement has an extra cell at the start describing the width and height of the row."	| cells wrap spacing output maxExtent n sum index max cell first last w cellMax maxCell hFill vFill inset |	maxCell _ cellHolder key.	cells _ cellHolder value.	properties wrapDirection == #none 		ifTrue:[wrap _ SmallInteger maxVal]		ifFalse:[wrap _ aBool ifTrue:[newBounds width] ifFalse:[newBounds height].				wrap < maxCell x ifTrue:[wrap _ maxCell x]].	spacing _ properties cellSpacing.	(spacing == #globalRect or:[spacing = #globalSquare]) ifTrue:[		"Globally equal spacing is a very special case here, so get out fast and easy"		^self computeGlobalCellArrangement: cells 			in: newBounds horizontal: aBool 			wrap: wrap spacing: spacing].	output _ (WriteStream on: Array new).	inset _ properties cellInset asPoint.	aBool ifFalse:[inset _ inset transposed].	first _ last _ nil.	maxExtent _ 0@0.	sum _ 0.	index _ 1.	n _ 0.	hFill _ vFill _ false.	[index <= cells size] whileTrue:[		w _ sum.		cell _ cells at: index.		cellMax _ maxExtent max: cell cellSize. "e.g., minSize"		(spacing == #localRect or:[spacing == #localSquare]) ifTrue:[			"Recompute entire size of current row"			spacing == #localSquare 				ifTrue:[max _ cellMax x max: cellMax y]				ifFalse:[max _ cellMax x].			sum _ (n + 1) * max.		] ifFalse:[			sum _ sum + (cell cellSize x).		].		((sum + (n * inset x)) > wrap and:[first notNil]) ifTrue:[			"It doesn't fit and we're not starting a new line"			(spacing == #localSquare or:[spacing == #localRect]) ifTrue:[				spacing == #localSquare 					ifTrue:[maxExtent _ (maxExtent x max: maxExtent y) asPoint].				first do:[:c| c cellSize: maxExtent]].			w _ w + ((n - 1) * inset x).			"redistribute extra space"			first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].			last _ LayoutCell new.			last cellSize: w @ (maxExtent y).			last hSpaceFill: hFill.			last vSpaceFill: vFill.			last nextCell: first.			output position = 0 ifFalse:[last addExtraSpace: 0@inset y].			output nextPut: last.			first _ nil.			maxExtent _ 0@0.			sum _ 0.			n _ 0.			hFill _ vFill _ false.		] ifFalse:[			"It did fit; use next item from input"			first ifNil:[first _ last _ cell] ifNotNil:[last nextCell: cell. last _ cell].			index _ index+1.			n _ n + 1.			maxExtent _ cellMax.			hFill _ hFill or:[cell hSpaceFill].			vFill _ vFill or:[cell vSpaceFill].		].	].	first ifNotNil:[		last _ LayoutCell new.		sum _ sum + ((n - 1) * inset x).		first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].		last cellSize: sum @ maxExtent y.		last hSpaceFill: hFill.		last vSpaceFill: vFill.		last nextCell: first.		output position = 0 ifFalse:[last addExtraSpace: 0@inset y].		output nextPut: last].	output _ output contents.	properties listSpacing == #equal ifTrue:[		"Make all the heights equal"		max _ output inject: 0 into:[:size :c| size max: c cellSize y].		output do:[:c| c cellSize: c cellSize x @ max].	].	^output! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/13/2000 18:24'!computeCellSizes: aMorph in: newBounds horizontal: aBool	"Step 1: Compute the minimum extent for all the children of aMorph"	| cells cell size block maxCell minSize maxSize |	cells _ WriteStream on: (Array new: aMorph submorphCount).	minSize _ properties minCellSize asPoint.	maxSize _ properties maxCellSize asPoint.	aBool ifTrue:[		minSize _ minSize transposed.		maxSize _ maxSize transposed].	maxCell _ 0@0.	block _ [:m|		m disableTableLayout ifFalse:[			size _ m minExtent.			cell _ LayoutCell new target: m.			aBool ifTrue:[				cell hSpaceFill: m hResizing == #spaceFill.				cell vSpaceFill: m vResizing == #spaceFill.			] ifFalse:[				cell hSpaceFill: m vResizing == #spaceFill.				cell vSpaceFill: m hResizing == #spaceFill.				size _ size transposed.			].			size _ (size min: maxSize) max: minSize.			cell cellSize: size.			maxCell _ maxCell max: size.			cells nextPut: cell]].	properties reverseTableCells		ifTrue:[aMorph submorphsReverseDo: block]		ifFalse:[aMorph submorphsDo: block].	^maxCell -> cells contents! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/13/2000 18:24'!computeExtraSpacing: arrangement in: newBounds horizontal: aBool target: aMorph	"Compute the required extra spacing for laying out the cells"	| extent extra centering n extraPerCell cell last hFill vFill max amount allow |	"match newBounds extent with arrangement's orientation"	extent _ newBounds extent.	aBool ifFalse:[extent _ extent transposed].	"figure out if we have any horizontal or vertical space fillers"	hFill _ vFill _ false.	max _ 0@0.	arrangement do:[:c|		max _ (max x max: c cellSize x) @ (max y + c cellSize y).		max _ max max: c cellSize.		hFill _ hFill or:[c hSpaceFill].		vFill _ vFill or:[c vSpaceFill]].	"Take client's shrink wrap constraints into account.	Note: these are only honored when there are no #spaceFill children,	or when #rubberBandCells is set."	allow _ properties rubberBandCells not.	aMorph hResizing == #shrinkWrap ifTrue:[		aBool 			ifTrue:[allow & hFill ifFalse:[extent _ max x @ (max y max: extent y)]]			ifFalse:[allow & vFill ifFalse:[extent _ (max x max: extent x) @ max y]]].	aMorph vResizing == #shrinkWrap ifTrue:[		aBool 			ifFalse:[allow & hFill ifFalse:[extent _ max x @ (max y max: extent y)]]			ifTrue:[allow & vFill ifFalse:[extent _ (max x max: extent x) @ max y]]].	"Now compute the extra v space"	extra _ extent y - (arrangement inject: 0 into:[:sum :c| sum + c cellSize y]).	extra > 0 ifTrue:[		"Check if we have any #spaceFillers"		vFill ifTrue:[ "use only #spaceFillers"			n _ arrangement inject: 0 into:[:sum :c| 				c vSpaceFill ifTrue:[sum + 1] ifFalse:[sum]].			n isZero ifFalse:[extraPerCell _ extra asFloat / n asFloat].			extra _ last _ 0.			arrangement do:[:c|				c vSpaceFill ifTrue:[					extra _ (last _ extra) + extraPerCell.					amount _ 0 @ (extra truncated - last truncated).					c do:[:cc| cc cellSize: cc cellSize + amount]]].		] ifFalse:[ "no #spaceFillers; distribute regularly"			centering _ properties wrapCentering.			"centering == #topLeft ifTrue:[]." "add all extra space to the last cell; e.g., do nothing"			centering == #bottomRight "add all extra space to the first cell"				ifTrue:[arrangement first addExtraSpace: 0@extra].			centering == #center "add 1/2 extra space to the first and last cell"				ifTrue:[arrangement first addExtraSpace: 0@ (extra // 2)].			centering == #justified "add extra space equally distributed to each cell"				ifTrue:[	n _ (arrangement size - 1) max: 1.						extraPerCell _ extra asFloat / n asFloat.						extra _ last _ 0.						arrangement do:[:c|							c addExtraSpace: 0@(extra truncated - last truncated).							extra _ (last _ extra) + extraPerCell]].		].	].	"Now compute the extra space for the primary direction"	centering _ properties listCentering.	1 to: arrangement size do:[:i|		cell _ (arrangement at: i).		extra _ extent x - cell cellSize x.		extra > 0 ifTrue:[			"Check if we have any #spaceFillers"			cell hSpaceFill ifTrue:[ "use only #spaceFillers"				cell _ cell nextCell.				n _ cell inject: 0 into:[:sum :c| 					c hSpaceFill ifTrue:[sum + c target spaceFillWeight] ifFalse:[sum]].				n isZero ifFalse:[extraPerCell _ extra asFloat / n asFloat].				extra _ last _ 0.				cell do:[:c|					c hSpaceFill ifTrue:[						extra _ (last _ extra) + (extraPerCell * c target spaceFillWeight).						amount _ extra truncated - last truncated.						c cellSize: c cellSize + (amount@0)]].			] ifFalse:[ "no #spaceFiller; distribute regularly"				cell _ cell nextCell.				"centering == #topLeft ifTrue:[]" "add all extra space to the last cell; e.g., do nothing"				centering == #bottomRight "add all extra space to the first cell"					ifTrue:[cell addExtraSpace: extra @ 0].				centering == #center "add 1/2 extra space to the first and last cell"					ifTrue:[cell addExtraSpace: (extra // 2) @ 0].				centering == #justified "add extra space equally distributed to each cell"					ifTrue:[	n _ (cell size - 1) max: 1.							extraPerCell _ extra asFloat / n asFloat.							extra _ last _ 0.							cell do:[:c|								c addExtraSpace: (extra truncated - last truncated) @ 0.								extra _ (last _ extra) + extraPerCell]].			].		].	].! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/13/2000 19:42'!layout: aMorph in: box	"Compute the layout for the given morph based on the new bounds"	| cells arrangement horizontal newBounds |	aMorph hasSubmorphs ifFalse:[^self].	properties _ aMorph assureTableProperties.	newBounds _ box origin asIntegerPoint corner: (box corner asIntegerPoint).	(properties wrapDirection == #none and:[properties cellSpacing == #none]) ifTrue:[		"get into the fast lane"		properties listCentering == #justified ifFalse:["can't deal with that"			properties listDirection == #leftToRight 				ifTrue:[^self layoutLeftToRight: aMorph in: newBounds].			properties listDirection == #topToBottom				ifTrue:[^self layoutTopToBottom: aMorph in: newBounds].		].	].	(properties listDirection == #topToBottom or:[properties listDirection == #bottomToTop])		ifTrue:[	horizontal _ false]		ifFalse:[	horizontal _ true].	"Step 1: Compute the minimum extent for all the children of aMorph"	cells _ self computeCellSizes: aMorph 				in: (0@0 corner: newBounds extent) 				horizontal: horizontal.	"Step 2: Compute the arrangement of the cells for each row and column"	arrangement _ self computeCellArrangement: cells 						in: newBounds 						horizontal: horizontal 						target: aMorph.	"Step 3: Compute the extra spacing for each cell"	self computeExtraSpacing: arrangement 		in: newBounds 		horizontal: horizontal 		target: aMorph.	"Step 4: Place the children within the cells accordingly"	self placeCells: arrangement 		in: newBounds 		horizontal: horizontal 		target: aMorph.! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/13/2000 19:42'!minExtentOf: aMorph in: box	"Return the minimal size aMorph's children would require given the new bounds"	| cells arrangement horizontal newBounds minX minY minExtent dir |	aMorph hasSubmorphs ifFalse:[^0@0].	properties _ aMorph assureTableProperties.	(properties wrapDirection == #none and:[properties cellSpacing == #none]) ifTrue:[		"Get into the fast lane"		dir _ properties listDirection.		(dir == #leftToRight or:[dir == #rightToLeft])			ifTrue:[^self minExtentHorizontal: aMorph].		(dir == #topToBottom or:[dir == #bottomToTop])			ifTrue:[^self minExtentVertical: aMorph].	].	newBounds _ box origin asIntegerPoint corner: (box corner asIntegerPoint).	(properties listDirection == #topToBottom or:[properties listDirection == #bottomToTop])		ifTrue:[	horizontal _ false]		ifFalse:[	horizontal _ true].	"Step 1: Compute the minimum extent for all the children of aMorph"	cells _ self computeCellSizes: aMorph 				in: (0@0 corner: newBounds extent) 				horizontal: horizontal.	"Step 2: Compute the arrangement of the cells for each row and column"	arrangement _ self computeCellArrangement: cells 						in: newBounds 						horizontal: horizontal						target: aMorph.	"Step 3: Extract the minimum size out of the arrangement"	minX _ minY _ 0.	arrangement do:[:cell|		minX _ minX max: cell cellSize x + cell extraSpace x.		minY _ minY + cell cellSize y + cell extraSpace y].	horizontal 		ifTrue:[minExtent _ minX@minY]		ifFalse:[minExtent _ minY@minX].	^minExtent! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/13/2000 18:25'!placeCells: arrangement in: newBounds horizontal: aBool target: aMorph	"Place the morphs within the cells accordingly"	| xDir yDir anchor yDist place cell xDist cellRect corner inset |	inset _ properties cellInset.	(inset isNumber and:[inset isZero]) ifTrue:[inset _ nil].	aBool ifTrue:["horizontal layout"		properties listDirection == #rightToLeft ifTrue:[			xDir _ -1@0.			properties wrapDirection == #bottomToTop 				ifTrue:[yDir _ 0@-1. anchor _ newBounds bottomRight]				ifFalse:[yDir _ 0@1. anchor _ newBounds topRight].		] ifFalse:[			xDir _ 1@0.			properties wrapDirection == #bottomToTop				ifTrue:[yDir _ 0@-1. anchor _ newBounds bottomLeft]				ifFalse:[yDir _ 0@1. anchor _ newBounds topLeft]].	] ifFalse:["vertical layout"		properties listDirection == #bottomToTop ifTrue:[			xDir _ 0@-1.			properties wrapDirection == #rightToLeft				ifTrue:[yDir _ -1@0. anchor _ newBounds bottomRight]				ifFalse:[yDir _ 1@0. anchor _ newBounds bottomLeft]		] ifFalse:[			xDir _ 0@1.			properties wrapDirection == #rightToLeft				ifTrue:[yDir _ -1@0. anchor _ newBounds topRight]				ifFalse:[yDir _ 1@0. anchor _ newBounds topLeft]].	].	1 to: arrangement size do:[:i|		cell _ arrangement at: i.		cell extraSpace ifNotNil:[anchor _ anchor + (cell extraSpace y * yDir)].		yDist _ cell cellSize y * yDir. "secondary advance direction"		place _ anchor.		cell _ cell nextCell.		[cell == nil] whileFalse:[			cell extraSpace ifNotNil:[place _ place + (cell extraSpace x * xDir)].			xDist _ cell cellSize x * xDir. "primary advance direction"			corner _ place + xDist + yDist.			cellRect _ Rectangle origin: (place min: corner) corner: (place max: corner).			inset ifNotNil:[cellRect _ cellRect insetBy: inset].			cell target layoutInBounds: cellRect.			place _ place + xDist.			cell _ cell nextCell].		anchor _ anchor + yDist.	].! !!TableLayout methodsFor: 'utilities' stamp: 'ar 11/13/2000 18:26'!indexForInserting: aPoint inList: morphList horizontal: aBool target: aMorph	| box cmp1 cmp2 cmp3 noWrap |	properties _ aMorph layoutProperties.	noWrap _ properties wrapDirection == #none.	aBool ifTrue:["horizontal"		properties listDirection == #rightToLeft			ifTrue:[cmp1 _ [:rect| aPoint x > rect left]]			ifFalse:[cmp1 _ [:rect| aPoint x < rect right]].		properties wrapDirection == #bottomToTop 			ifTrue:[cmp2 _ [:rect| aPoint y > rect top].					cmp3 _ [:rect| aPoint y > rect bottom]]			ifFalse:[cmp2 _ [:rect| aPoint y < rect bottom].					cmp3 _ [:rect| aPoint y < rect top]].	] ifFalse:["vertical"		properties listDirection == #bottomToTop 			ifTrue:[cmp1 _ [:rect| aPoint y > rect top]]			ifFalse:[cmp1 _ [:rect| aPoint y < rect bottom]].		properties wrapDirection == #rightToLeft			ifTrue:[cmp2 _ [:rect| aPoint x > rect left].					cmp3 _ [:rect| aPoint x > rect right]]			ifFalse:[cmp2 _ [:rect| aPoint x < rect right].					cmp3 _ [:rect| aPoint x < rect left]].	].	morphList keysAndValuesDo:[:index :m|		self flag: #arNote. "it is not quite clear if we can really use #fullBounds here..."		box _ m fullBounds.		noWrap ifTrue:[			"Only in one direction"			(cmp1 value: box) ifTrue:[^index]		] ifFalse:[			"Check for inserting before current row"			(cmp3 value: box) ifTrue:[^index].			"Check for inserting before current cell"			((cmp1 value: box) and:[cmp2 value: box]) ifTrue:[^index]]].	^morphList size + 1! !!TableLayout methodsFor: 'optimized' stamp: 'ar 11/14/2000 17:10'!layoutLeftToRight: aMorph in: newBounds	"An optimized left-to-right list layout"	| inset n size extent width height block sum vFill posX posY extra centering extraPerCell last amount minX minY maxX maxY sizeX sizeY first cell props |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint x.	extent _ newBounds extent.	n _ 0. vFill _ false. sum _ 0.	width _ height _ 0.	first _ last _ nil.	block _ [:m|		props _ m layoutProperties ifNil:[m].		props disableTableLayout ifFalse:[			n _ n + 1.			cell _ LayoutCell new target: m.			(props hResizing == #spaceFill) ifTrue:[				cell hSpaceFill: true.				extra _ m spaceFillWeight.				cell extraSpace: extra.				sum _ sum + extra.			] ifFalse:[cell hSpaceFill: false].			(props vResizing == #spaceFill) ifTrue:[vFill _ true].			size _ m minExtent.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			cell cellSize: sizeX.			last ifNil:[first _ cell] ifNotNil:[last nextCell: cell].			last _ cell.			width _ width + sizeX.			sizeY > height ifTrue:[height _ sizeY].		].	].	properties reverseTableCells		ifTrue:[aMorph submorphsReverseDo: block]		ifFalse:[aMorph submorphsDo: block].	n > 1 ifTrue:[width _ width + (n-1 * inset)].	(properties hResizing == #shrinkWrap and:[properties rubberBandCells or:[sum isZero]])		ifTrue:[extent _ width @ (extent y max: height)].	(properties vResizing == #shrinkWrap and:[properties rubberBandCells or:[vFill not]])		ifTrue:[extent _ (extent x max: width) @ height].	posX _ newBounds left.	posY _ newBounds top.	"Compute extra vertical space"	extra _ extent y - height.	extra < 0 ifTrue:[extra _ 0].	extra > 0 ifTrue:[		vFill ifTrue:[			height _ extent y.		] ifFalse:[			centering _ properties wrapCentering.			centering == #bottomRight ifTrue:[posY _ posY + extra].			centering == #center ifTrue:[posY _ posY + (extra // 2)]		].	].	"Compute extra horizontal space"	extra _ extent x - width.	extra < 0 ifTrue:[extra _ 0].	extraPerCell _ 0.	extra > 0 ifTrue:[		sum isZero ifTrue:["extra space but no #spaceFillers"			centering _ properties listCentering.			centering == #bottomRight ifTrue:[posX _ posX + extra].			centering == #center ifTrue:[posX _ posX + (extra // 2)].		] ifFalse:[extraPerCell _ extra asFloat / sum asFloat].	].	n _ 0.	extra _ last _ 0.	cell _ first.	[cell == nil] whileFalse:[		n _ n + 1.		width _ cell cellSize.		(extraPerCell > 0 and:[cell hSpaceFill]) ifTrue:[			extra _ (last _ extra) + (extraPerCell * cell extraSpace).			amount _ extra truncated - last truncated.			width _ width + amount.		].		cell target layoutInBounds: (posX @ posY extent: width @ height).		posX _ posX + width + inset.		cell _ cell nextCell.	].! !!TableLayout methodsFor: 'optimized' stamp: 'ar 11/14/2000 17:12'!layoutTopToBottom: aMorph in: newBounds	"An optimized top-to-bottom list layout"	| inset n size extent width height block sum vFill posX posY extra centering extraPerCell last amount minX minY maxX maxY sizeX sizeY first cell props |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint y.	extent _ newBounds extent.	n _ 0. vFill _ false. sum _ 0.	width _ height _ 0.	first _ last _ nil.	block _ [:m|		props _ m layoutProperties ifNil:[m].		props disableTableLayout ifFalse:[			n _ n + 1.			cell _ LayoutCell new target: m.			(props vResizing == #spaceFill) ifTrue:[				cell vSpaceFill: true.				extra _ m spaceFillWeight.				cell extraSpace: extra.				sum _ sum + extra.			] ifFalse:[cell vSpaceFill: false].			(props hResizing == #spaceFill) ifTrue:[vFill _ true].			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			cell cellSize: sizeY.			first ifNil:[first _ cell] ifNotNil:[last nextCell: cell].			last _ cell.			height _ height + sizeY.			sizeX > width ifTrue:[width _ sizeX].		].	].	properties reverseTableCells		ifTrue:[aMorph submorphsReverseDo: block]		ifFalse:[aMorph submorphsDo: block].	n > 1 ifTrue:[height _ height + (n-1 * inset)].	(properties vResizing == #shrinkWrap and:[properties rubberBandCells or:[sum isZero]])		ifTrue:[extent _ (extent x max: width) @ height].	(properties hResizing == #shrinkWrap and:[properties rubberBandCells or:[vFill not]])		ifTrue:[extent _ width @ (extent y max: height)].	posX _ newBounds left.	posY _ newBounds top.	"Compute extra horizontal space"	extra _ extent x - width.	extra < 0 ifTrue:[extra _ 0].	extra > 0 ifTrue:[		vFill ifTrue:[			width _ extent x.		] ifFalse:[			centering _ properties wrapCentering.			centering == #bottomRight ifTrue:[posX _ posX + extra].			centering == #center ifTrue:[posX _ posX + (extra // 2)]		].	].	"Compute extra vertical space"	extra _ extent y - height.	extra < 0 ifTrue:[extra _ 0].	extraPerCell _ 0.	extra > 0 ifTrue:[		sum isZero ifTrue:["extra space but no #spaceFillers"			centering _ properties listCentering.			centering == #bottomRight ifTrue:[posY _ posY + extra].			centering == #center ifTrue:[posY _ posY + (extra // 2)].		] ifFalse:[extraPerCell _ extra asFloat / sum asFloat].	].	n _ 0.	extra _ last _ 0.	cell _ first.	[cell == nil] whileFalse:[		n _ n + 1.		height _ cell cellSize.		(extraPerCell > 0 and:[cell vSpaceFill]) ifTrue:[			extra _ (last _ extra) + (extraPerCell * cell extraSpace).			amount _ extra truncated - last truncated.			height _ height + amount.		].		cell target layoutInBounds: (posX @ posY extent: width @ height).		posY _ posY + height + inset.		cell _ cell nextCell.	].! !!TableLayout methodsFor: 'optimized' stamp: 'ar 11/13/2000 18:27'!minExtentHorizontal: aMorph	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint.	n _ 0.	width _ height _ 0.	aMorph submorphsDo:[:m|		m disableTableLayout ifFalse:[			n _ n + 1.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			width _ width + sizeX.			sizeY > height ifTrue:[height _ sizeY].		].	].	n > 1 ifTrue:[width _ width + (n-1 * inset x)].	^width @ height! !!TableLayout methodsFor: 'optimized' stamp: 'ar 11/13/2000 18:27'!minExtentVertical: aMorph	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint.	n _ 0.	width _ height _ 0.	aMorph submorphsDo:[:m|		m disableTableLayout ifFalse:[			n _ n + 1.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			height _ height + sizeY.			sizeX > width ifTrue:[width _ sizeX].		].	].	n > 1 ifTrue:[height _ height + (n-1 * inset y)].	^width @ height! !!TableLayoutProperties methodsFor: 'initialize' stamp: 'ar 11/14/2000 17:45'!initialize	super initialize.	cellSpacing _ listSpacing _ wrapDirection _ #none.	cellPositioning _ #center.	listCentering _ wrapCentering _ #topLeft.	listDirection _ #topToBottom.	reverseTableCells _ rubberBandCells _ false.	layoutInset _ cellInset _ minCellSize _ 0.	maxCellSize _ 1073741823. "SmallInteger maxVal"! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:45'!cellInset	^cellInset! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/13/2000 17:57'!cellInset: aNumber	cellInset _ aNumber! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:49'!cellPositioning	^cellPositioning! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:49'!cellPositioning: aSymbol	cellPositioning _ aSymbol! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:46'!cellSpacing	^cellSpacing! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:46'!cellSpacing: aSymbol	cellSpacing _ aSymbol.! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 16:37'!layoutInset	^layoutInset! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 16:37'!layoutInset: aNumber	layoutInset _ aNumber! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:46'!listCentering	^listCentering! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:46'!listCentering: aSymbol	listCentering _ aSymbol! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:46'!listDirection	^listDirection! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:46'!listDirection: aSymbol	listDirection _ aSymbol.! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:47'!listSpacing	^listSpacing! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:47'!listSpacing: aSymbol	listSpacing _ aSymbol! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:47'!maxCellSize	^maxCellSize! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/13/2000 17:58'!maxCellSize: aNumber	maxCellSize _ aNumber.! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:47'!minCellSize	^minCellSize! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/13/2000 17:57'!minCellSize: aNumber	minCellSize _ aNumber.! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:47'!reverseTableCells	^reverseTableCells! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:47'!reverseTableCells: aBool	reverseTableCells _ aBool! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:47'!rubberBandCells	^rubberBandCells! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:48'!rubberBandCells: aBool	rubberBandCells _ aBool.! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:48'!wrapCentering	^wrapCentering! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:48'!wrapCentering: aSymbol	wrapCentering _ aSymbol! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:48'!wrapDirection	^wrapDirection! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:48'!wrapDirection: aSymbol	wrapDirection _ aSymbol! !!TableLayoutProperties methodsFor: 'testing' stamp: 'ar 11/13/2000 18:34'!includesTableProperties	^true! !!LayoutProperties reorganize!('initialize' initialize initializeFrom:)('accessing' disableTableLayout disableTableLayout: hResizing hResizing: vResizing vResizing:)('table defaults' cellInset cellPositioning cellSpacing layoutInset listCentering listDirection listSpacing maxCellSize minCellSize reverseTableCells rubberBandCells wrapCentering wrapDirection)('testing' includesTableProperties)('converting' asTableLayoutProperties)!"Postscript:Convert the old extensions into proper layout objects."| props set map removed ext other |props _ #(layoutInset cellPositioning disableTableLayout hResizing vResizing cellInset cellSpacing listCentering listDirection listSpacing maxCellSize minCellSize reverseTableCells rubberBandCells wrapCentering wrapDirection).set _ IdentitySet new: 100.set addAll: props.map _ IdentityDictionary new: 100.props do:[:p| map at: p put: (p copyWith: $:) asSymbol].removed _ 0.Smalltalk allObjectsDo:[:o|	o isMorph ifTrue:[		ext _ o extension.		(ext notNil and:[(other _ ext otherProperties) notNil]) ifTrue:[			"remap the properties"			other keys do:[:key|				(props includes: key) ifTrue:[					o perform: (map at: key) with: (other at: key).					other removeKey: key ifAbsent:[]]].			other rehash.		].		"Finally check if the extension is useful"		o resetExtension ifTrue:[removed _ removed + 1].	].].!