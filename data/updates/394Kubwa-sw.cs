'From Squeak 2.2 of Sept 23, 1998 on 9 November 1998 at 6:53:21 pm'!"Change Set:		KubwaDate:			9 November 1998Author:			Scott WallaceMajor changes to Parts Bins, Scripting Spaces, and Viewers, and a large number of lesser changes all over the map."!PasteUpMorph subclass: #IndexTabs	instanceVariableNames: 'highlightColor regularColor basicHeight basicWidth '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Palettes'!AlignmentMorph subclass: #PhraseWrapperMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Object subclass: #Preferences	instanceVariableNames: ''	classVariableNames: 'DesktopColor FlagDictionary HelpDictionary Parameters '	poolDictionaries: ''	category: 'System-Support'!Model subclass: #ScriptingDomain	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Object subclass: #SlotInformation	instanceVariableNames: 'type documentation '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Object subclass: #StandardScriptingSystem	instanceVariableNames: ''	classVariableNames: 'CustomPartsBin FormDictionary HelpStrings PartsBin ScriptHelp StandardPartsBin StandardScriptInfo StandardSlotInfo SystemSlotDictionary TypeColorDictionary '	poolDictionaries: ''	category: 'Morphic-Scripting'!SystemWindow subclass: #PartsWindow	instanceVariableNames: 'book prevButton nextButton menuButton openForEditing '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!SystemWindow subclass: #PreDebugWindow	instanceVariableNames: 'proceedButton debugButton '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!TileMorph subclass: #UndescribedTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!UpdatingStringMorph subclass: #UpdatingStringMorphWithArgument	instanceVariableNames: 'argumentTarget argumentGetSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!AlignmentMorph subclass: #Viewer	instanceVariableNames: 'scriptedPlayer '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Viewer subclass: #CategoryViewer	instanceVariableNames: 'prevButton nextButton newButton clearButton namePane '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Viewer subclass: #StandardViewer	instanceVariableNames: 'firstPanel '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!AlignmentMorph subclass: #ViewerEntry	instanceVariableNames: 'helpPane editingPane '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!AlignmentMorph subclass: #ViewerRow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!!Object methodsFor: 'printing' stamp: 'sw 5/2/1998 13:55'!stringForReadout	^ self stringRepresentation! !!Object methodsFor: 'message handling' stamp: 'sw 10/30/1998 18:27'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ otherTarget perform: selector! !!Object methodsFor: 'user interface' stamp: 'sw 10/5/1998 14:39'!addModelMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph 	"The receiver serves as the model for aMorph; a menu is being constructed for the morph, and here the receiver is able to add its own items"! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'sw 10/24/1998 22:22'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer a new instance of me, containing only the 6 arguments as elements."	| newCollection |	newCollection _ self new: 6.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	newCollection at: 6 put: sixthObject.	^ newCollection! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 10/27/1998 13:53'!lookForSlips	| slips |	slips _ self checkForSlips.	slips size == 0 ifTrue:		[^ self inform: 'No slips detected in thecurrent change set.'].	(self confirm:'Some methods in the current change sethave halts or references to the Transcriptor other ''slips'' in them.Would you like to browse them?')		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!ClockMorph class methodsFor: 'all' stamp: 'sw 10/16/1998 15:36'!authoringPrototype	^ super authoringPrototype contents: Time now printString! !!Color class methodsFor: 'instance creation' stamp: 'sw 11/9/1998 19:25'!colorFrom: parm	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol, else just return the thing"	(parm isKindOf: Color) ifTrue: [^ parm].	(parm isKindOf: Symbol) ifTrue: [^ self perform: parm].	^ parm! !!Morph methodsFor: 'accessing' stamp: 'sw 11/9/1998 18:44'!balloonText	"NB: subclasses may override such that they programatically construct the text, for economy's sake, such as model phrases in a Viewer"	| val |	extension == nil ifTrue: [^ nil].	(val _  extension balloonText) ifNotNil: [^ val].	(val _ extension balloonTextSelector) ifNotNil:		[^ (ScriptingSystem helpStringFor: val) withNoLineLongerThan: Preferences maxBalloonHelpLineLength].	^ nil! !!Morph methodsFor: 'drawing' stamp: 'sw 10/22/1998 20:28'!fullDrawOn: aCanvas	| canvasForSubmorphs |	self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:		[^ self].	(aCanvas isVisible: bounds) ifTrue:		[self drawOn: aCanvas].	canvasForSubmorphs _ self canvasForSubmorphs: aCanvas.	submorphs reverseDo:  "Display submorphs back to front"		[:m | m fullDrawOn: canvasForSubmorphs].  ! !!Morph methodsFor: 'drawing' stamp: 'sw 10/30/1998 18:27'!hide	owner ifNil: [^ self].	self visible ifTrue: [self visible: false.  self changed]! !!Morph methodsFor: 'drawing' stamp: 'sw 10/22/1998 20:29'!show	"Make sure this morph is on-stage."	self visible ifFalse: [self visible: true.  self changed]! !!Morph methodsFor: 'drawing' stamp: 'sw 10/19/1998 22:21'!visible	extension ifNil: [^ true].	^ extension visible! !!Morph methodsFor: 'drawing' stamp: 'sw 10/20/1998 00:28'!visible: aBoolean	extension ifNil: [aBoolean ifTrue: [^ self]].	self visible == aBoolean ifTrue: [^ self].	self assuredExtension visible: aBoolean.	self changed! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 10/23/1998 12:00'!addTransparentSpacerOfSize: aPoint	self addMorphBack: (self transparentSpacerOfSize: aPoint)! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 10/23/1998 12:01'!beTransparent	self color: Color transparent! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 10/23/1998 11:50'!transparentSpacerOfSize: aPoint	^ (Morph new extent: aPoint) color: Color transparent! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 10/30/1998 16:22'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	| aWindow |	self isPartsDonor: false.	(aWindow _ aMorph ownerThatIsA: SystemWindow) ifNotNil:		[aWindow isActive ifFalse:			[aWindow activate]].	self isInWorld ifTrue:		[self world startSteppingSubmorphsOf: self]  	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."! !!Morph methodsFor: 'naming' stamp: 'sw 10/30/1998 14:46'!externalName	^ self knownName ifNil: [self innocuousName]! !!Morph methodsFor: 'naming' stamp: 'sw 10/30/1998 14:47'!renameTo: aName	| aPresenter putInViewer aPasteUp |	self setNameTo: aName.	(aPresenter _ self presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: self player.		putInViewer ifTrue: [aPresenter viewMorph: self]].	(aPasteUp _ self topPasteUp) ifNotNil:		[aPasteUp allTileScriptingElements do:			[:m | m bringUpToDate]]! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 10/8/1998 17:18'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	self isPartsDonor ifTrue: [^ false].	self player ifNotNil: [^ true].	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 11/9/1998 18:32'!setBalloonText: stringOrText	extension == nil ifTrue: [self assureExtension].	extension balloonText: (stringOrText withNoLineLongerThan: Preferences maxBalloonHelpLineLength)! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 11/9/1998 18:29'!setBalloonText: stringOrText maxLineLength: aLength	extension == nil ifTrue: [self assureExtension].	extension balloonText: (stringOrText withNoLineLongerThan: aLength)! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 11/9/1998 18:39'!showBalloon: msgString	"Pop up a balloon containing the given string, first removing any existing BalloonMorphs in the world."	| w balloon worldBounds |	w _ self world.	w ifNil: [^ self].	balloon _ BalloonMorph string: msgString for: self corner: #bottomRight.	w submorphsDo: [:m |  "delete any existing balloons"		(m isKindOf: BalloonMorph) ifTrue: [m delete]].	balloon lock.  "So that if the translation below makes it overlap the receiver, it won't interfere with the rootMorphsAt: logic and hence cause flashing.  Without this, flashing happens, believe me!!"	w addMorphFront: balloon.	((worldBounds _ w bounds) containsRect: balloon bounds) ifFalse:		[balloon bounds: (balloon bounds translatedToBeWithin: worldBounds)].	self setProperty: #balloon toValue: balloon.! !!Morph methodsFor: 'player' stamp: 'sw 10/21/1998 09:30'!assuredPlayer	"Answer the receiver's player, creating a new one if none currently exists"	| aPlayer |	(aPlayer _ self player) ifNil:		[self externalName.  "a default may be given if not named yet"		self player: (aPlayer _ self newPlayerInstance).  			"Different morphs may demand different player types"		aPlayer costume: self.		self presenter ifNotNil: [self presenter flushPlayerListCache]].	^ aPlayer! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/22/1998 20:28'!currentPlayerDo: aBlock	"If the receiver is a viewer/scriptor associated with a current Player object, evaluate the given block against that object"! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/30/1998 16:07'!embeddedInMorphicWindowLabeled: labelString	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: self frame: (0@0 extent: 1@1).	^ window! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/21/1998 09:51'!enforceTileColorPolicy	| aPresenter |	(aPresenter _ self presenter) ifNotNil: [^ aPresenter harmonizeTileColorPolicyFor: self].	self makeAllTilesGreen "fallback - ack current preference"! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/21/1998 15:54'!isAViewer	^ false! !!Morph methodsFor: 'property extension' stamp: 'sw 10/20/1998 00:27'!assureExtension	extension == nil ifTrue: [extension _ MorphExtension new initialize].	^ extension! !!Morph methodsFor: 'property extension' stamp: 'sw 10/20/1998 00:28'!assuredExtension	extension == nil ifTrue: [extension _ MorphExtension new initialize].	^ extension! !!Morph methodsFor: 'debug and other' stamp: 'sw 10/21/1998 09:29'!addDebuggingItemsTo: aMenu hand: aHandMorph	aMenu add: 'debug...' subMenu:  (self debuggingMenuFor: aHandMorph)! !!Morph methodsFor: 'debug and other' stamp: 'sw 10/21/1998 09:29'!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ MenuMorph new defaultTarget: aHandMorph.	aMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	World ifNil:		[aMenu add: 'inspect morph (in MVC)' action: #inspectArgument.		aMenu add: 'inspect morph' action: #inspectArgumentInMorphic]		ifNotNil:		[aMenu add: 'inspect morph' action: #inspectArgumentInMorphic].	aMenu add: 'browse morph class' action: #browseMorphClass.	self player ifNotNil:		[aMenu add: 'inspect player' action: #inspectPlayer.		World ifNil: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic].		aMenu add: 'browse player class' action: #browsePlayerClass].	aMenu add: 'make own subclass' action: #subclassMorph.	aMenu add: 'internal name' action: #nameMorph.	aMenu add: 'save morph in file' action: #saveOnFile.	aMenu addLine.	aMenu add: 'call #tempCommand' action: #callTempCommand.	aMenu add: 'define #tempCommand' action: #defineTempCommand.	aMenu addLine.	aMenu defaultTarget: self.	aMenu add: 'edit balloon help' action: #editBalloonHelpText.	^ aMenu! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/2/1998 15:54'!defineTempCommand	"To use this, comment out what's below here, and substitute your own code.You will then be able to invoke it from the standard debugging menus.  If invoked from the world menu, you'll always get it invoked on behalf of the world, but if invoked from an individual morph's meta-menu, it will be invoked on behalf of that individual morph.Note that you can indeed reimplement tempCommand in an individual morph's class if you wish"	Browser openMessageBrowserForClass: Morph		selector: #tempCommand editString: nil! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/5/1998 20:31'!inspectOwnerChain	self ownerChain inspectWithLabel: 'Owner chain for ', self printString! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/5/1998 20:28'!ownerChain	"Answer a list of objects representing the receiver and all of its owners.   The first element is the receiver, and the last one is typically the world in which the receiver resides"	| c next |	c _ OrderedCollection with: self.	next _ self.	[(next _ next owner) ~~ nil] whileTrue: [c add: next].	^ c asArray! !!Morph methodsFor: 'debug and other' stamp: 'sw 11/2/1998 15:51'!tempCommand	"Generic backstop.  If you care to, you can comment out what's below here, and substitute your own code, though the intention of design of the feature is that you leave this method as it is, and instead reimplement tempCommand in the class of whatever individual morph you care to.  In any case, once you have your own #tempCommand in place, you will then be able to invoke it from the standard debugging menus."	self inform: 'Before calling tempCommand, youshould first give it a definition.  Todo this, choose "define tempCommand"from the debug menu.'! !!AlignmentMorph methodsFor: 'initialization' stamp: 'sw 10/24/1998 14:25'!addUpDownArrowsFor: aMorph	"Add a column of up and down arrows that serve to send upArrowHit and downArrowHit to aMorph when they're pressed/held down"	| holder downArrow upArrow |	holder _ Morph new extent: 16 @ 16; beTransparent.	downArrow _ ImageMorph new image: (ScriptingSystem formAtKey: 'DownArrow').	upArrow _ ImageMorph new image: (ScriptingSystem formAtKey: 'UpArrow').	upArrow position: holder bounds topLeft + (2@2).	downArrow align: downArrow bottomLeft				with: holder topLeft + (0 @ TileMorph defaultH) + (2@-2).	holder addMorph: upArrow.	holder addMorph: downArrow.	self addMorphBack: holder.	upArrow on: #mouseStillDown send: #upArrowHit to: aMorph.	downArrow on: #mouseStillDown send: #downArrowHit to: aMorph.! !!AlignmentMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/23/1998 14:18'!rootForGrabOf: aMorph	| root |	openToDragNDrop ifFalse: [^ super rootForGrabOf: aMorph].	root _ aMorph.	[root == self] whileFalse:		[root owner = self ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!BookMorph methodsFor: 'accessing' stamp: 'sw 10/16/1998 22:39'!currentPage	(submorphs includes: currentPage) ifFalse: [currentPage _ nil].	^ currentPage! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 10/26/1998 16:04'!insertPageColored: aColor	| sz newPage bw bc |	currentPage == nil		ifTrue:			[sz _ pageSize.			bw _ 0.			bc _ Color blue muchLighter]		ifFalse:			[sz _ currentPage extent.			bw _ currentPage borderWidth.			bc _ currentPage borderColor].	newPagePrototype		ifNil:			[newPage _ PasteUpMorph new extent: sz; color: aColor.			newPage borderWidth: bw; borderColor: bc]		ifNotNil: [Cursor wait showWhile: 				[newPage _ newPagePrototype veryDeepCopy]].	newPage setNameTo: 'page'.	newPage resizeToFit: false.	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage.! !!BookMorph methodsFor: 'navigation' stamp: 'sw 10/19/1998 23:51'!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending newPage |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	oldPageNumber _ pages indexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue:				[nil]			ifFalse:				[oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	self currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		currentPage releaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	self snapToEdgeIfAppropriate.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["Nil at init time, for example" aWorld displayWorld].! !!BookMorph methodsFor: 'navigation' stamp: 'sw 10/26/1998 15:41'!goto: aPlayer	self goToPageMorph: aPlayer costume! !!BookMorph methodsFor: 'menu' stamp: 'sw 10/21/1998 23:09'!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	subMenu add: 'Establish Custom Parts Bin' action: #saveAsCustomPartsBin.	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'Book...' subMenu: subMenu! !!BookMorph methodsFor: 'other' stamp: 'sw 10/1/1998 13:40'!resizePagesTo: anExtent	pages do:		[:aPage | aPage extent: anExtent]! !!BookMorph methodsFor: 'other' stamp: 'sw 10/9/1998 08:00'!wrappedInPartsWindowWithTitle: aTitle	| aWindow |	aWindow _ (PartsWindow labelled: aTitle) model: MorphicModel new.	aWindow book: self.	aWindow extent: self extent.	^ aWindow! !!ClockMorph methodsFor: 'all' stamp: 'sw 10/8/1998 17:21'!initialize	super initialize.	self contents: Time now printString! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 14:57'!changesDo	"Build the changes menu for the world."	self changesMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/27/1998 13:49'!changesMenu	"Build the changes menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Change management') defaultTarget: self.	menu addStayUpItem.	menu add: 'file out changes' target: ScreenController new action: #fileOutChanges.	menu add: 'create new change set...' target: ChangeSorter action: #newChangeSet.	menu add: 'browse changed methods' action: #browseChangedMessages.	menu add: 'check for slips' target: Smalltalk changes action: #lookForSlips.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'browse recent submissions' action: #openRecentChanges.	menu add: 'recent change log' action: #openChangesLog.	menu addLine.	menu add: 'save world as morph file' action: #saveWorldInFile.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:15'!debugDo	"Build the scripting menu for the world."	self debugMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:15'!debugMenu	"Build the scripting menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Debugging...') defaultTarget: self.	menu addStayUpItem.	menu add: 'inspect world' target: owner action: #inspect.	menu add: 'inspect model' action: #inspectWorldModel.	menu add: 'start MessageTally' action: #startMessageTally.	menu addLine.	menu add: 'call #tempCommand' action: #callTempCommand.	menu add: 'define #tempCommand' action: #defineTempCommand.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 14:56'!helpDo	"Build and show the help menu for the world."	self helpMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/27/1998 14:51'!helpMenu	"Build the help menu for the world."	| menu screenCtrl |	screenCtrl _ ScreenController new.	menu _ (MenuMorph entitled: 'General help') defaultTarget: self.	menu addStayUpItem.	menu add: 'edit preferences...' target: Preferences action: #openPreferencesInspector.	menu add: 'command-key help' target: Utilities action: #openCommandKeyHelp.	menu add: 'world menu help' target: self action: #worldMenuHelp.	menu add: 'font size summary' target: Utilities action: #fontSizeSummary.	menu add: 'useful expressions' target: Utilities action: #openStandardWorkspace.	menu add: 'view image imports' target: Smalltalk action: #viewImageImports.	menu addLine.	menu add: 'full screen on' target: screenCtrl action: #fullScreenOn.	menu add: 'full screen off' target: screenCtrl action: #fullScreenOff.	menu add: 'set display depth...' action: #setDisplayDepth.	menu add: 'set desktop color...' action: #changeBackgroundColor.	menu add: 'use texture background' target: self world action: #setStandardTexture.	gridOn		ifTrue: [menu add: 'turn gridding off' action: #setGridding]		ifFalse: [menu add: 'turn gridding on' action: #setGridding].	menu add: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])		target: screenCtrl action: #soundOnOrOff.	menu addLine.	menu add: 'update code from server' action: #absorbUpdatesFromServer.	menu add: 'about this system' target: screenCtrl action: #aboutThisSystem.	menu add: 'set author initials...' target: screenCtrl action: #setAuthorInitials.	menu add: 'vm statistics' target: screenCtrl action: #vmStatistics.	menu add: 'space left' target: screenCtrl action: #garbageCollect.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:16'!openMenu	"Build the open window menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Open a new window') defaultTarget: self.	menu addStayUpItem.	menu add: 'browser' action: #openBrowser.	menu add: 'workspace' action: #openWorkspace.	menu add: 'file list' action: #openFileList.	menu add: 'transcript' target: Transcript action: #open.	menu add: 'selector finder' target: ScreenController new action: #openSelectorBrowser.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'email reader' action: #openEmail.	menu add: 'web browser' action: #openWebBrowser.	menu add: 'IRC chat' action: #openIRC.	menu addLine.	menu add: 'project (mvc)' action: #openMVCProject.	menu add: 'project (morphic)' action: #openMorphicProject.	menu add: 'project (construction)' action: #openConstructionProject.	menu add: 'project link...' action: #projectThumbnail.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:16'!openWindow	self openMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:17'!remoteDo	self remoteMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:17'!remoteMenu	"Build the Telemorphic menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Telemorphic') defaultTarget: self.	menu addStayUpItem.	menu add: 'local host address' action: #reportLocalAddress.	menu add: 'connect remote user' action: #connectRemoteUser.	menu add: 'disconnect remote user' action: #disconnectRemoteUser.	menu add: 'disconnect all remote users' action: #disconnectAllRemoteUsers.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/27/1998 13:39'!scriptingDo	self scriptingMenu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 11/6/1998 10:48'!scriptingMenu	"Build the scripting menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Authoring Tools') defaultTarget: self.	menu addStayUpItem.	menu add: 'standard parts bin' target: self presenter action: #createStandardPartsBin.	menu balloonTextForLastItem: 'A bin of standard parts, from which you can drag out useful morphs.'.	menu add: 'custom parts bin' target: self presenter action: #launchCustomPartsBin.	menu balloonTextForLastItem: 'A customized bin of parts.  To define what the custom parts bin is, edit any existing parts bin and tell it to be saved as the custom parts bin.'.	menu add: 'new scripting area' target: self action: #detachableScriptingSpace.	menu balloonTextForLastItem: 'A window set up for simple scripting.'.	menu add: 'control panel' target: self presenter action: #createControlPanel.	menu balloonTextForLastItem: 'A little panel that lets you choose whether or not things like the showing of balloon help should be enabled or disabled.'.	menu addLine.	menu add: 'unlock locked objects' action: #unlockWorldContents.	menu balloonTextForLastItem: 'If any items on the world desktop are currently locked, unlock them.'.	menu add: 'unhide hidden objects' action: #showHiders.	menu balloonTextForLastItem: 'If any items on the world desktop are currently hidden, make them visible.'.	menu add: 'round up stray objects' action: #roundUpStrayObjects.	menu balloonTextForLastItem: 'If any items on the desktop are currently off-screen (because their coordinates are outside the bounds of the desktop), bring them back within view.'.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/26/1998 15:18'!windowsDo	"Build the windows menu for the world."	self windowsMenu popUpAt: self position forHand: self! !!HandMorph methodsFor: 'world menu' stamp: 'sw 11/6/1998 11:24'!windowsMenu	"Build the windows menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Window management') defaultTarget: self.	menu addStayUpItem.	menu add: 'find window' action: #findWindow.	menu add: 'find changed browsers...' action: #findDirtyBrowsers.	menu add: 'find changed windows...' action: #findDirtyWindows.	menu addLine.	menu add: 'collapse all windows' action: #collapseAll.	menu add: 'expand all windows' action: #expandAll.	menu add: 'close unchanged windows' action: #closeUnchangedWindows.	menu add: 'delete all non-windows' action: #deleteNonWindows.	menu addLine.	menu add: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows'])		target: ScreenController new action: #changeWindowPolicy.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sw 10/27/1998 14:53'!worldMenuHelp	| aList aMenu cnts explanation |	"HandMorph new worldMenuHelp"	aList _ OrderedCollection new.	#(helpMenu changesMenu openMenu debugMenu remoteMenu scriptingMenu windowsMenu) 		with:	#('help' 'changes' 'open' 'debug' 'remote' 'authoring tools' 'windows')do:		[:sel :title | aMenu _ self perform: sel.			aMenu items do:				[:it | ((cnts _ it contents) = 'keep this menu up')					ifFalse: [aList add: (cnts, ' - ', title)]]].	aList _ aList asSortedCollection: [:a :b | a asLowercase < b asLowercase].	explanation _ ReadWriteStream on: ''.	aList do:		[:anItem | explanation nextPutAll: anItem; cr].	(StringHolder new contents: explanation contents)		openLabel: 'Where in the world menu is...'! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/18/1998 08:44'!defineTempCommand	argument		ifNotNil:			[argument defineTempCommand]		ifNil:			[self world defineTempCommand]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 11/6/1998 11:27'!deleteNonWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(SelectionMenu confirm:'Do you really want to close all objectsthat are not in windows?')		ifFalse: [^ self].	self world submorphs copy do:		[:m | (m isKindOf: SystemWindow) ifFalse: [m delete]]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 10/9/1998 08:38'!detachableScriptingSpace	ScriptingSystem newScriptingSpace openInWorld: self world! !!MenuLineMorph methodsFor: 'drawing' stamp: 'sw 11/3/1998 11:35'!drawOn: aCanvas	aCanvas		fillRectangle: (bounds topLeft corner: bounds rightCenter)		color: Preferences menuLineUpperColor.	aCanvas		fillRectangle: (bounds leftCenter corner: bounds bottomRight)		color: Preferences menuLineLowerColor! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/3/1998 11:25'!initialize	super initialize.	self setDefaultParameters.	orientation _ #vertical.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	defaultTarget _ nil.	lastSelection _ nil.	stayUp _ false.	originalEvent _ nil.	popUpOwner _ nil.! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/3/1998 11:19'!setDefaultParameters	self setColor: Preferences menuColor borderWidth: Preferences menuBorderWidth borderColor: Preferences menuBorderColor.	inset _ 3! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/3/1998 11:23'!setTitleParametersFor: aMenuTitle	aMenuTitle setColor: Preferences menuTitleColor borderWidth: Preferences menuTitleBorderWidth borderColor: Preferences menuTitleBorderColor! !!MenuMorph methodsFor: 'construction' stamp: 'sw 10/9/1998 16:00'!addTitle: aString	"Add a title line at the top of this menu."	| title |	title _ AlignmentMorph new.	self setTitleParametersFor: title.	title vResizing: #shrinkWrap.	title orientation: #vertical.	title centering: #center.	(aString asString findTokens: String cr) do:		[:line | title addMorphBack: (StringMorph new contents: line)].	self addMorphFront: title.! !!MenuMorph methodsFor: 'construction' stamp: 'sw 11/5/1998 21:13'!balloonTextForLastItem: balloonText	submorphs last setBalloonText: balloonText! !!MorphExtension methodsFor: 'other' stamp: 'sw 10/20/1998 00:00'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ', self identityHashPrintString.	locked == true ifTrue: [aStream nextPutAll: ' [locked] '].	visible == false ifTrue: [aStream nextPutAll: '[not visible] '].	sticky == true ifTrue: [aStream nextPutAll: ' [sticky] '].	balloonText ifNotNil: [aStream nextPutAll: ' [balloonText] '].	balloonTextSelector ifNotNil: [aStream nextPutAll: ' [balloonTextSelector: ', balloonTextSelector printString, '] '].	externalName ifNotNil: [aStream nextPutAll: ' [externalName = ', externalName, ' ] '].	isPartsDonor == true ifTrue: [aStream nextPutAll: ' [isPartsDonor] '].	player ifNotNil: [aStream nextPutAll: ' [player = ', player printString, '] '].	eventHandler ifNotNil: [aStream nextPutAll: ' [eventHandler = ', eventHandler printString, '] '].	otherProperties size > 0 ifTrue: [aStream nextPutAll: ' [other = ', otherProperties keys asArray printString, ']']! !!MorphicModel methodsFor: 'menu' stamp: 'sw 10/5/1998 14:55'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	model ifNotNil: [model addModelMenuItemsTo: aCustomMenu forMorph: self hand: aHandMorph].	self isOpen ifTrue: [aCustomMenu add: 'close editing' action: #closeToEdits]			ifFalse: [aCustomMenu add: 'open editing' action: #openToEdits].! !!NewHandleMorph methodsFor: 'all' stamp: 'sw 11/5/1998 10:24'!initialize	waitingForClickInside _ true.	super initialize.	Preferences noviceMode ifTrue: [self setBalloonText: 'stretch']! !!PaintBoxMorph class methodsFor: 'all' stamp: 'sw 10/19/1998 23:17'!flushPrototype	"Later we will be a subclass of Model, and it will have a general version of this"	Prototype _ self new! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 11/2/1998 15:50'!tempCommand: characterStream 	"Experimental.  Triggered by Cmd-t; put trial cmd-key commands here to see how they work, before hanging them on their own cmd accelerators."	Sensor keyboard.	self experimentalCommand.	^ true	"sensor keyboard.	self spawnWorkspace.	^ true"! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 10/21/1998 09:39'!aRowForPart: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Return a row representing the given part of my target morph."	| r anArrow |	r _ AlignmentMorph newRow		color: self color;		centering: #center;		inset: 1.	r addMorphBack: (self infoButtonFor: partName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: self tileForSelf bePossessive.	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self getterButtonFor: partName type: partType).	readOnly ifFalse:		[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"		r addMorphBack: (anArrow _ self arrowSetterButtonFor: partName type: partType)].	r addMorphBack: (AlignmentMorph new color: self color).  "flexible spacer"	(#(colorSees isOverColor) includes: partName) ifFalse: 		[r addMorphBack: (self readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector)].	anArrow ifNotNil: [anArrow step].	^ r! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 11/7/1998 22:36'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new		target: self morph;		getSelector: (Utilities getterSelectorFor: partName);		borderWidth: 1;		extent:  30@22.		putSelector == #unused ifFalse: [readout putSelector: (Utilities setterSelectorFor: partName)]].	readout ifNil: [readout _ self morph updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 10/21/1998 09:39'!setPlayer: aPlayer	scriptedPlayer _ aPlayer.	self removeAllMorphs.	self addMorphBack: self rowBeforeParts.	self addTilesForPlayerParts.	self enforceTileColorPolicy. "prematurely here to avoid momentarily flashing wrong policyh"	self addTransparentSpacerOfSize: 1 @ 8.	self addMorphBack: self rowBeforeScripts.	self addMorphBack: self commandTilesPartsBin.	self beRepelling.	self enforceTileColorPolicy.	self isInWorld ifTrue: [self world startSteppingSubmorphsOf: self].	self layoutChanged.! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 10/21/1998 16:44'!makeGetter: evt from: aMorph forPart: args	| m selfTile selector aType firstArg |	(aType _ args last) == #unknown ifTrue: [^ self beep].	(#(colorSees isOverColor) includes: (firstArg _ args first))		ifFalse:			[m _ PhraseTileMorph new setSlotRefOperator: args first asSymbol type: aType]		ifTrue:			[(firstArg == #colorSees) ifTrue: [m _ self colorSeesPhrase].			(firstArg == #isOverColor) ifTrue: [m _ self seesColorPhrase]].	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	selector _ m submorphs at: 2.	(aType == #number) ifTrue:		[selector addSuffixArrow].	selector updateLiteralLabel.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 11/9/1998 18:27'!makeSetter: evt from: aMorph forPart: args	| argType m argTile selfTile |	argType _ args last.	m _ PhraseTileMorph new setAssignmentRoot: args first asSymbol		type: #command		rcvrType: #player		argType: argType.	argTile _ scriptedPlayer tileForArgType: argType.	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!PartsViewer methodsFor: 'misc' stamp: 'sw 10/21/1998 09:54'!coloredTilesEnabled	self flag: #isThisEverCalled.	^ self presenter coloredTilesEnabled! !!PartsViewer methodsFor: 'misc' stamp: 'sw 10/21/1998 15:55'!isAViewer	^ true! !!PartsViewer methodsFor: 'misc' stamp: 'sw 10/15/1998 15:22'!presenter	^ super presenter ifNil:		[scriptedPlayer costume presenter]! !!PartsViewer methodsFor: 'private' stamp: 'sw 11/9/1998 18:27'!commandTiles	"Return a list of tiles for my scriptedPlayer's commands."	| resultType cmd m argType argTile selfTile aRow names bank  |	names _ scriptedPlayer class namedTileScriptSelectors.	bank _ self scriptsBank.	^ (scriptedPlayer typedCommandsForBank: bank) collect: [:entry |		aRow _ PartsBinMorph newRow borderWidth: 0;			color: self color.		resultType _ (entry at: 1).		cmd _ (entry at: 2).		entry size = 2			ifTrue:				[m _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player.				(names includes: cmd) ifTrue: [m userScriptSelector: cmd]]			ifFalse: 				[argType _ entry at: 3.				m _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player					argType: argType.				argTile _ scriptedPlayer tileForArgType: argType.				argTile position: m lastSubmorph position.				m lastSubmorph addMorph: argTile.				m markAsPartsDonor].		selfTile _ self tileForSelf.		selfTile position: m firstSubmorph position.		m firstSubmorph addMorph: selfTile.			aRow addMorph: (ScriptingSystem tryButtonFor: m).		aRow addMorphBack: (Morph new extent: 4@2; color: self color).		aRow addMorphBack: m.		aRow beSticky; openToDragNDrop: false.		aRow]	"	m addMorphFront: (Morph new color: self color; extent: 2@10). "! !!PartsViewer methodsFor: 'private' stamp: 'sw 10/22/1998 00:13'!commandTilesPartsBin	| bin |	bin _ PhraseWrapperMorph new		color: self color;		borderWidth: 0;		orientation: #vertical.	bin addMorphBack:		(Morph new color: self color; extent: 1@1).  "placeholder for parts bin label"	bin addAllMorphs: self commandTiles.	^ bin! !!PartsViewer methodsFor: 'private' stamp: 'sw 10/23/1998 14:12'!infoButtonFor: aSlotName	| aButton isUserSlot |	isUserSlot _ scriptedPlayer slotInfo includesKey: aSlotName asSymbol.	aButton _ SimpleButtonMorph new.	aButton target: scriptedPlayer;		actionSelector: #infoFor:;		arguments: (Array with: aSlotName);		label: '¤' font: (StrikeFont familyName: #ComicBold size: 16);		color: Color transparent;		borderWidth: 0;		actWhen: #buttonDown.	aButton balloonTextSelector: (isUserSlot		ifFalse:	[aSlotName]		ifTrue:	[#userSlot]).	^ aButton! !!PartsViewer methodsFor: 'private' stamp: 'sw 10/15/1998 17:23'!rowBeforeParts	| r nail aButton aTextMorph aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	r addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Hit the X to remove this Viewer'.	r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousPartsBank; label: '<' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'Show previous bank of parts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextPartsBank; label: '>' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Show next bank of parts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	aTextMorph step.	r  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousCostume; label: '<' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to previous costume'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextCostume; label: '>' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to next costume'.	r addTransparentSpacerOfSize: 10@5.	nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	r addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.		^ r! !!PartsViewer methodsFor: 'type coercion' stamp: 'sw 11/9/1998 18:26'!booleanPhraseForRetrieverOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel _ (retrieverType == #number)		ifTrue:		[#<]		ifFalse:		[#=].	outerPhrase _ PhraseTileMorph new setOperator: rel type: #boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase _  PhraseTileMorph new setOperator: retrieverOp type: retrieverType rcvrType: #player.	getterPhrase submorphs last setSlotRefOperator: (Utilities inherentSelectorForGetter: retrieverOp).	receiverTile _ (self tileForPlayer: aPlayer) bePossessive.	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile _ aPlayer tileForArgType: retrieverType.	retrieverType == #number ifTrue: [finalTile addArrows].	outerPhrase submorphs last addMorph: finalTile.	^ outerPhrase! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/15/1998 18:27'!morphToDropFrom: aMorph	| itsSelector aScriptor adjustment anEditor actualObject aUserScript ownersChoice aNail representee |	owner ifNotNil:		[(ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self)			ifNotNil:	[^ ownersChoice]].	self alwaysShowThumbnail ifTrue:		[aNail _ aMorph representativeNoTallerThan: self maxHeightToAvoidThumbnailing thumbnailHeight: self heightForThumbnails.		aNail == aMorph ifFalse:			[aNail position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (aNail extent / aMorph extent)) rounded)].		^ aNail].	((aMorph isKindOf: MorphThumbnail) and: [(representee _ aMorph morphRepresented) owner == nil])		ifTrue:			[representee position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (representee extent / aMorph extent)) rounded).			^ representee].	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	aMorph isCommand ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	actualObject assureUniClass.	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject anonymousScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject anonymousScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 11/6/1998 10:27'!addPlayfieldMenuItems: menu hand: aHandMorph	| subMenu prefix hasPalette |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'navigate to...' action: #navigateTo.	subMenu add: 'round up strays' action: #roundUpStrays.	subMenu addLine.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	prefix _ (self hasProperty: #automaticPhraseExpansion) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'phrase expansion') action: #toggleAutomaticPhraseExpansion.	prefix _ (self hasProperty: #alwaysShowThumbnail) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'showing thumbnails') action: #toggleAlwaysShowThumbnail.	(self hasProperty: #alwaysShowThumbnail) ifTrue:		[subMenu add: 'set thumbnail height...' action: #setThumbnailHeight].	(hasPalette _ self standardPalette ~~ nil) ifTrue:		[prefix _ self automaticViewing ifTrue: ['stop '] ifFalse: ['start '].		subMenu add: (prefix, 'automatic viewing') action: #toggleAutomaticViewing].	subMenu addLine.	hasPalette ifTrue: [subMenu add: 'clear palette area' action: #clearPaletteArea].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	presenter ifNil:		[subMenu add: 'make detachable' action: #impartPrivatePresenter].	subMenu addLine.	subMenu add: 'use standard texture' action: #setStandardTexture.	subMenu add: 'make graph paper...' action: #makeGraphPaper.	subMenu addTitle: 'Playfield options'.	menu add: 'playfield options...' subMenu: subMenu.! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 9/28/1998 13:15'!automaticViewing: aBoolean	self setProperty: #automaticViewing toValue: aBoolean! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/8/1998 16:46'!setPartsBinStatusTo: aBoolean	"Not entirely happy with the openToDragNDrop not being directly manipulable etc, but still living with it for now."	isPartsBin _ aBoolean.	openToDragNDrop _ isPartsBin not.	isPartsBin		ifTrue:			[submorphs do:				[:m | m isPartsDonor: true.					m stopStepping.					m suspendEventHandler]]		ifFalse:			[submorphs do:				[:m | m isPartsDonor: false.					m restoreSuspendedEventHandler].			self world ifNotNil: [self world startSteppingSubmorphsOf: self]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 9/30/1998 17:24'!toggleIsPartsBin	"Not entirely happy with the openToDragNDrop not being directly manipulable etc, but still living with it for now."	self setPartsBinStatusTo: self isPartsBin not! !!IndexTabs methodsFor: 'initialization' stamp: 'sw 10/15/1998 17:12'!initialize	super initialize.	padding _ 10.	basicHeight _ 14.	basicWidth _ 200.	color _ Color transparent.	fillColor2 _ color.	borderWidth _ 0! !!IndexTabs methodsFor: 'layout' stamp: 'sw 10/15/1998 17:12'!basicWidth	basicWidth ifNil: [basicWidth _ 200].	^ basicWidth! !!IndexTabs methodsFor: 'layout' stamp: 'sw 10/15/1998 17:12'!basicWidth: w	basicWidth _ w! !!IndexTabs methodsFor: 'layout' stamp: 'sw 10/15/1998 17:12'!laySubpartsOutInOneRow	| aPosition |	aPosition _ self topLeft.	submorphs do:		[:aMorph |			aMorph position: (aPosition + (padding @ 0)).			aPosition _ aMorph topRight].	self extent: (((aPosition x - self left) max: self basicWidth) @ self basicHeight)! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:00'!brightenTiles	brightenedOnEnter _ true.	self allMorphsDo: [:m |		(m isKindOf: TileMorph) ifTrue:			[m color: (ScriptingSystem brightColorFor: m color)]]! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:00'!isCommand	"Answer whether the receiver is a true line of phrase-command.  If not, it is a fragment that will not be able to serve as a line of script on its own"	| rcvrTile pad |	pad _ submorphs first.	(((pad isKindOf: TilePadMorph) ifTrue:		[(submorphs second isKindOf: AssignmentTileMorph) ifTrue: [^ true].		(rcvrTile _ pad submorphs first) isKindOf: TileMorph]) and: [rcvrTile isPossessive]) ifTrue: [^ false].	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/21/1998 09:41'!rowOfRightTypeFor: aLayoutMorph forActor: aPlayer	| aPartsViewer aPhrase |	aLayoutMorph demandsBoolean ifTrue:		[self isBoolean ifTrue: [^ self].		aPartsViewer _ PartsViewer new invisiblySetPlayer: aPlayer.		aPhrase _ aPartsViewer booleanPhraseFromPhrase: self.		^ aPhrase].	^ self! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:01'!setAssignmentRoot: opSymbol type: opType rcvrType: rcvrType argType: argType	resultType _ opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	self addMorphBack: ((AssignmentTileMorph new setRoot: opSymbol asString dataType: argType) typeColor: color).	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 11/9/1998 18:46'!setOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	resultType _ opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	self addMorphBack: ((TileMorph new setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: argType)]! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:01'!setSlotRefOperator: opSymbol type: opType	resultType _ opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: #player).	self addMorphBack: ((TileMorph new setSlotRefOperator: opSymbol asString) typeColor: color)! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 11/9/1998 18:48'!unbrightenTiles	brightenedOnEnter ifFalse: [^ self].	brightenedOnEnter _ false.	self allMorphsDo: [:m |		(m isKindOf: TileMorph) ifTrue:			[m color: (ScriptingSystem unbrightColorFor: m color)]]! !!PhraseWrapperMorph commentStamp: 'sw 11/9/1998 18:53' prior: 0!An alignment morph designed for use in scripting Viewers; it wraps a set of phrases in a category viewer, and repels attempts to drop phrases upon it.!!PhraseWrapperMorph methodsFor: 'extraction support' stamp: 'sw 8/12/97 14:16'!isPartsBin	^ true! !!PhraseWrapperMorph methodsFor: 'extraction support' stamp: 'sw 5/6/1998 18:13'!repelsMorph: aMorph event: ev	^ (aMorph isKindOf: PhraseTileMorph) or: [aMorph hasProperty: #newAnonymousScript]! !!PhraseWrapperMorph class methodsFor: 'all' stamp: 'sw 11/9/1998 16:16'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:56'!firstPage	self sendMessageToCostume: #firstPage! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:56'!goto: aPlayer	self sendMessageToCostume: #goto: with: aPlayer! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:56'!lastPage	self sendMessageToCostume: #lastPage! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:55'!nextPage	self sendMessageToCostume: #nextPage! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/26/1998 15:55'!previousPage	self sendMessageToCostume: #previousPage! !!Player methodsFor: 'costume' stamp: 'sw 10/24/1998 21:57'!forgetOtherCostumes	costumes _ nil.	self updateAllViewers! !!Player methodsFor: 'costume' stamp: 'sw 10/24/1998 23:18'!hasCostumeOfClass: aClass	(costume class == aClass) ifTrue: [^ true].	costumes ifNotNil:		[costumes do:			[:aCostume | (aCostume class  == aClass)				ifTrue:					[^ true]]].	^ false! !!Player methodsFor: 'costume' stamp: 'sw 10/24/1998 21:48'!newCostume	| aMenu reply |	aMenu _ SelectionMenu selections: self availableCostumeNames.	(reply _ aMenu startUpWithCaption: 'choose a costume') ifNil: [^ self].	self wearCostumeOfName: reply.	self updateAllViewers! !!Player methodsFor: 'costume' stamp: 'sw 10/26/1998 15:55'!sendMessageToCostume: aSelector	| aCostume |	(aCostume _ self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 10/26/1998 15:54'!sendMessageToCostume: aSelector with: arg	| aCostume |	(aCostume _ self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector with: arg].	^ nil! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/5/1998 19:57'!categories	| aList |	aList _ #('basic' ) asOrderedCollection.	self slotNames size > 0 ifTrue:		[aList add: 'instance variables'].	self class scripts size > 0 ifTrue:		[aList add: 'scripts'].	(self hasCostumeOfClass: JoystickMorph)		ifTrue:	[aList add: 'joystick'].	(self hasCostumeOfClass: BookMorph)		ifTrue:	[aList add: 'book navigation'].	(self hasCostumeOfClass: PasteUpMorph)		ifTrue:	[aList addAll: #('pen trails' 'card/stack')].	aList addAll: #('tests' 'color & border' 'geometry' 'motion' 'pen use' 'miscellaneous' ).	Preferences showPlayerSource ifTrue:		[aList addAll: Player organization categories].	aList removeAllFoundIn: #('card/stack commands' 'object fileIn').	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/7/1998 22:31'!commandPhraseFor: commandSpec inViewer: aViewer	"Too lazy at the moment to do this cleanly"	| entry aRow resultType cmd m names argType argTile selfTile |	entry _ (commandSpec copy asOrderedCollection removeFirst; yourself) asArray.	names _ self class namedTileScriptSelectors.	aRow _ ViewerRow newRow borderWidth: 0; color: aViewer color.	resultType _ (entry at: 1).	cmd _ (entry at: 2).	entry size = 2		ifTrue:			[m _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player.			(names includes: cmd) ifTrue: [m userScriptSelector: cmd]]		ifFalse: 			[argType _ entry at: 3.			m _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player				argType: argType.			argTile _ self tileForArgType: argType inViewer: aViewer.			argTile position: m lastSubmorph position.			m lastSubmorph addMorph: argTile].	m markAsPartsDonor.	selfTile _ aViewer tileForSelf.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	aRow addMorph: (ScriptingSystem tryButtonFor: m).	aRow addMorphBack: (Morph new extent: 4@2; beTransparent).	aRow addMorphBack: m.	aRow beSticky; openToDragNDrop: false.	aRow addDetailButton.	^ aRow! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/30/1998 18:33'!phraseSpecFor: aPair	"Expand aPair, whose first element is either #slot or #script, into an array appropriate for mapping into a phrase tile"	| info prefix |	info _ (prefix _ aPair first) == #slot		ifTrue:			[ScriptingSystem slotInfoFor: aPair second]		ifFalse:			[ScriptingSystem scriptInfoFor: aPair second].	^ (Array with: prefix), info! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/21/1998 15:27'!slotPhraseFor: aSpec inViewer: aViewer	^ aViewer phraseForSlot: aSpec second type: aSpec third readOnly: aSpec fourth == #readOnly getSelector: aSpec fifth putSelector: aSpec sixth! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/29/1998 16:29'!tileForArgType: typeSymbol	| aColor |	typeSymbol == #player ifTrue:		[^ self tileForPlayer:  self presenter standardPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/5/1998 19:59'!tileForArgType: typeSymbol inViewer: aViewer	| aColor aPlayer |	typeSymbol == #player ifTrue:		[aPlayer _ self presenter			ifNotNil:				[self presenter standardPlayer]			ifNil:  "It happens, if costume is not currently in a world"				[self].		^ aViewer tileForPlayer:  aPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/29/1998 15:51'!tilePhraseSpecsForPlayerCategory: aCategory	"Expand aPair, whose first element is either #slot or #script, into an array appropriate for mapping into a phrase tile"	| aList specList toks prefix |	aList _ (Player organization listAtCategoryNamed: aCategory asSymbol) collect:		[:aSelector |			prefix _ #(script).			specList _ ScriptingSystem scriptInfoFor: aSelector.			specList ifNil:				[specList _ OrderedCollection with: #command.				toks _ aSelector keywords.				toks do:					[:aTok |						specList add: aTok.						(aTok endsWith: ':') ifTrue: [specList add: #object]]].			prefix, specList].	^ aList select: [:spec | spec size < 5]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/22/1998 20:41'!tilePhrasesForCategory: aCategory inViewer: aViewer	"Return an array of phrases, each in one of the following two formats:		(slot		heading		number				readWrite	getHeading		setHeading:)		(script		command 	wearCostumeOf: 	player)"	^ (self tilePhrasesSpecsForCategory: aCategory) collect:		[:aSpec |			aSpec first == #slot				ifTrue:					[self slotPhraseFor: aSpec inViewer: aViewer]				ifFalse:					[self commandPhraseFor: aSpec inViewer: aViewer]]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/3/1998 12:10'!tilePhrasesSpecsForCategory: aCategory	"Return an array of slot and script names and info for use in a viewer on the receiver.  These can be of two flavors - script and slot.		(slot		heading		number				readWrite	getHeading		setHeading:)		(script		command 	wearCostumeOf: 	player)"	| aList nameString |	(aCategory = 'instance variables') ifTrue:		[^ self slotNames collect: [:aName |		nameString _ aName asString capitalized.		Array			with:	#slot			with: 	aName 								"name"			with: 	(self typeForSlot: aName asSymbol)	"type"			with:	#readWrite							"r/w"			with:	('get', nameString) asSymbol		"get selector"			with:	('set', nameString, ':') asSymbol]].	"set selector"	(aCategory = 'scripts') ifTrue:		[^ self tileScriptCommands].	(aCategory = 'basic') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (slot colorUnder) (script forward:) (script turn:) (script beep:))].	(aCategory = 'tests') ifTrue:		[aList _ #((slot isOverColor) (slot isUnderMouse) (slot colorSees) )].	(aCategory = 'color & border') ifTrue:		[aList _ #((slot color) (slot colorUnder) (slot borderColor) (slot borderWidth))].	(aCategory = 'geometry') ifTrue:		[aList _ #((slot left) (slot right) (slot top) (slot bottom) (slot width) (slot height) (slot x) (slot y) (slot heading))].	(aCategory = 'miscellaneous') ifTrue:		[aList _ #((script show) (script hide) (script wearCostumeOf:) (script startScript:) (script stopScript:) (script pauseScript:))]. 	(aCategory = 'motion') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (script forward:) (script moveToward:) (script turn:) (script bounce:) (script wrap) (script goToRightOf:))].	(aCategory = 'pen trails') ifTrue:		[aList _ #((script liftAllPens) (script lowerAllPens) (script clearTurtleTrails))].	(aCategory = 'pen use') ifTrue:		[aList _ #((slot penColor) (slot penSize) (slot penDown))].	(aCategory = 'card/stack') ifTrue:		[aList _ #((script goToNextCard) (script goToPreviousCard) (script deleteCard) (script newCard))].	(aCategory = 'joystick') ifTrue:		[aList _ #((slot amount) (slot angle) (slot leftRight) (slot upDown))].	(aCategory = 'book navigation') ifTrue:		[aList _ #((script nextPage) (script previousPage) (script firstPage) (script lastPage) (script goto:))].	aList ifNil:		[^ (Player organization categories includes: aCategory)			ifTrue:				[self tilePhraseSpecsForPlayerCategory: aCategory]			ifFalse:				[self error: 'faulty category: ', aCategory.				Array new]].	^ aList collect: [:aPair | self phraseSpecFor: aPair]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/6/1998 10:43'!typeForSlot: aSlotName	(self slotInfo includesKey: aSlotName) ifTrue: [^ (self slotInfoAt: aSlotName) type].	^ ScriptingSystem typeForSystemSlotNamed: aSlotName! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 10/24/1998 23:15'!getAmount	^ self getValueFromCostume: #amount! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 01:15'!getLeft	^ self costume left! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:33'!addInstanceVariable	| itsName initialValue typeChosen suggestedNames usedNames initialAnswer setterSelector |	suggestedNames _ #('cargo' 'speed' 'weight' 'mzee' 'friml' 'verp' 'znak').	usedNames _ self class instVarNames.	initialAnswer _ suggestedNames detect: [:aName |  (usedNames includes: aName) not] ifNone:		[Utilities keyLike: 'var1'  satisfying: [:aKey | (usedNames includes: aKey) not]].	itsName _ FillInTheBlank request: 'name for new inst var: ' initialAnswer: initialAnswer. 	itsName size == 0 ifTrue: [^ self].	(Utilities isLegalInstVarName: itsName) ifFalse: [^ self inform: 'sorry, illegal name, try again.'].	itsName _ itsName asSymbol.	(self class allInstVarNames includes: itsName) ifTrue: [^ self inform: 'that name is already used.'].		self assureUniClass.	typeChosen _ self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: (SlotInformation new type: typeChosen).	initialValue _ self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileAccessorsFor: itsName.	setterSelector _ Utilities setterSelectorFor: itsName.	(self class allInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewers! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:36'!addSlotNamedLike: suggestedName withValue: aValue	| otherNames numericSuffix nameToUse  stem itsInfo |	stem _ suggestedName first asLowercase asString , suggestedName allButFirst.	stem _ stem stemAndNumericSuffix first.	nameToUse _ stem.	otherNames _ self class allInstVarNames.	numericSuffix _ 1.	[otherNames includes: nameToUse]		whileTrue: [numericSuffix _ numericSuffix + 1. (nameToUse _ stem, numericSuffix printString)].	self class addInstVarName: nameToUse.	self instVarAt: self class instSize put: aValue.  "Assumes added as last field"	self compileAccessorsFor: nameToUse.	itsInfo _ SlotInformation new type: aValue basicType.	self slotInfo at: nameToUse asSymbol put: itsInfo.	^ nameToUse! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:41'!chooseSlotTypeFor: slotName	| typeChoices typeChosen |	typeChoices _ #(number player boolean color point string costume).	typeChosen _ (SelectionMenu selections: typeChoices lines: #()) startUpWithCaption: 'Choose the TYPEfor ', slotName.	(typeChosen size == 0) ifTrue: [^ self].	(self typeForSlot: slotName) = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName)).		anInst updateAllViewers]! !!Player methodsFor: 'slots-user' stamp: 'sw 11/6/1998 10:40'!slotInfoAt: slotName	| info |	info _ self slotInfo at: slotName ifAbsent: [nil].	info ifNil:		[self slotInfo at: slotName put: (info _ SlotInformation new)].	(info isKindOf: Symbol) "bkward compat"		ifTrue:			[self slotInfo at: slotName put: (info _ SlotInformation new type: info)].	^ info! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 11/5/1998 10:33'!sourceCodeFor: sel	^ self class sourceCodeAt: sel ifAbsent: 		[Player sourceCodeAt: sel ifAbsent: ['this space for rent']]	! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 10/24/1998 22:31'!tileScriptCommands	"Return a list of typed-command arrays of the form:		#script <result type> <command> <argType>"	^  self class namedTileScriptSelectors asSortedArray collect:			[:sel | Array with: #script with: #command with: sel]! !!Player methodsFor: 'misc' stamp: 'sw 11/5/1998 15:48'!noteDeletionOf: aMorph fromWorld: aWorld	"aMorph, while pointing to me as its costumee, has been deleted"	"This may be too aggressive because deletion of a morph may not really mean deletion of its associated player -- in light of hoped-for multiple viewing"	| viewers scriptors |	viewers _ OrderedCollection new.	scriptors _ OrderedCollection new.	aWorld allMorphs do:		[:m | m isAViewer ifTrue: [viewers add: m].			((m isKindOf: ScriptEditorMorph) and: [m myMorph == aMorph])				ifTrue: [scriptors add: m]].	viewers do: [:v |  v noteDeletionOf: aMorph].	scriptors do: [:s | s privateDelete] ! !!Player methodsFor: 'misc' stamp: 'sw 10/26/1998 15:45'!seesColor: aColor	costume isInWorld ifFalse: [^ false].	^ costume touchesColor: aColor! !!Player methodsFor: 'misc' stamp: 'sw 10/27/1998 14:00'!thumbnailMenuEvt: anEvent forMorph: aMorph	"The mouse went down in the thumbnail of a Viewer for the receiver"	| aMenu aWorld aViewer |	aWorld _ aMorph world.	aViewer _ aMorph ownerThatIsA: Viewer.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'set new costume...' action: #newCostume.	(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume]])		ifTrue:			[aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes].	aMenu addLine.	aMenu add: 'add a new instance variable' target: self action: #addInstanceVariable.	aMenu add: 'add an empty new script' target: aViewer action: #newEmptyScript.	aMenu addLine.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	aMenu add: 'reveal me' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab me' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu popUpAt: aWorld primaryHand position event: aWorld primaryHand lastEvent"	aMenu add: 'switch costume...' target: self selector: #chooseCostumeIn: argument: aWorld.""	aMenu add: 'get info...' action: #getInfo.  "! !!Player methodsFor: 'misc' stamp: 'sw 10/29/1998 16:05'!tileReferringToSelf	| aTile |	aTile _ TileMorph new		setObjectRef: nil "disused parm" actualObject: self;		typeColor: (ScriptingSystem colorForType: #player).	self costume presenter harmonizeTileColorPolicyFor: aTile.	^ aTile! !!Player methodsFor: 'misc' stamp: 'sw 10/27/1998 14:22'!updateAllViewers	"The receiver's structure has changed, so viewers on it need to be reconstituted."	| aPresenter viewers all |	(aPresenter _ self costume presenter) ifNil: [^ self].	all _ self costume world allMorphs.	viewers _ all select:		[:m | (m isKindOf: PartsViewer)  and: [m scriptedPlayer == self]].	viewers do: [:m | aPresenter updatePartsViewer: m].	viewers _ all select:		[:m | (m isKindOf: StandardViewer) and: [m scriptedPlayer == self]].	viewers do: [:m | aPresenter updateViewer: m]! !!PreDebugWindow class methodsFor: 'all' stamp: 'sw 11/4/1998 09:20'!includeInNewMorphMenu	^ false! !!Preferences class methodsFor: 'initialization' stamp: 'sw 11/5/1998 20:59'!chooseInitialSettings	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	#(	(allowSysWindowEmbedding			false)		(browseWithPrettyPrint				false)		(cmdDotEnabled						true)		(confirmFirstUseOfStyle				true)		(disableSounds						false)		(fastDragWindowForMorphic			false)		(ignoreStyleIfOnlyBold				true)		(logDebuggerStackToFile				true)		(noviceMode							false)		(reverseWindowStagger				true)		(showDebugHaloHandle				true)		(showScriptSource					false)		(showTimeStampsInMenuTitles		false)		(suppressCheckForSlips				false)		(suppressUpdateServerPrompt		false)		(thoroughSenders					true)		(unlimitedPaintArea					false)		(updateSavesFile						false)		(warnIfNoChangesFile				true)		(warnIfNoSourcesFile				true))	do:		[:aPair |			aPair last == #true				ifTrue:					[self enable: aPair first]				ifFalse:					[self disable: aPair first]]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 11/8/1998 18:01'!initializeHelpMessages	"Preferences initializeHelpMessages"  	HelpDictionary _ Dictionary new.	#((allowSysWindowEmbedding'Determines whether, in Morphic, SystemWindows should automatically be droppable into willing receptors')(browseWithPrettyPrint'If true, browsers will automatically format their contents')(cautionBeforeClosing 'If true, Morphic windows seen in an mvc project will put up a warning before allowing themselves to be dismissed')(cmdDotEnabled'If true, cmd-dot brings up a debugger;if false, the cmd-dot interrupt is disabled')(confirmFirstUseOfStyle'If true, the first attempt to submit a method with non-standard style will bring up a confirmation dialog')(disableSounds'If true, all sound playing is disabled')	(editPlayerScriptsInPlace 'If true, textual player scripts are edited in place in Scriptors (still imperfectly implemented)')(eToyScheme'If true, new scripting spaces place the Playfield to the left and the the palette to the right of the window; if false, the opposite is true.')(fastDragWindowForMorphic'If true, morphic window drag will be done by dragging an outline of the window.')(ignoreStyleIfOnlyBold'If true, then any method submission in which the only style change is for bolding will be treated as a method with no style specifications')(logDebuggerStackToFile'If true, whenever you fall into a debugger a summary of its stack will be written to a file named''SqueakDebug.log''')(noviceMode 'If true, certain novice-mode accommodations are made.')(reverseWindowStagger'If true, a reverse-stagger strategy  is used for determining where newly launched windows will be placed; if false, a direct- stagger strategy is used.')(showDebugHaloHandle 'If true, a special debugging halo handle is displayed at the right of the halo; if false, no such handle is shown.')(showPlayerSource'If true, then all Player methods with fewer than 2 arguments are included in Viewers, whether or not they are intended for end-user use.  This can be dangerous')(showScriptSource'If true, then the actual Smalltalk source code for methods is shown in the detail panes for scripts in a viewer; if false, then a help message for scripts is shown instead.')(showTimeStampsInMenuTitles'If true, then the author''s timestamp is displayed as the menu title of any message list; if false, no author''s timestamps are shown')(suppressCheckForSlips 'If false, then whenever you file out a change set, it is checked for ''slips'' and if any are found, you are so informed and given a chance to open a browser on them')(suppressUpdateServerPrompt'If true, the prompt for server choice when updating code from the server is suppressed.  Set this to true to leave the server choice unchanged from update to update.')(thoroughSenders'If true, then ''senders'' browsers will dive inside structured literals in their search')(uniformWindowColors'If true, then all standard windows are given the same color rather than their customized window-type-specific colors')(unlimitedPaintArea'If true, the painting area for a new drawing will not be limited in size; if false, a reasonablelimit will be applied, in an attempt to hold down memory and time price.')(updateRemoveSequenceNum'If true, then remove the leading sequence number from the filename before automatically saving a local copy of any update loaded.')(updateSavesFile'If true, then when an update is loaded from the server, a copy of it will automatically be saved on a local file as well.')(useNewViewers'If true, then the new kinds of viewers introduced in Squeak 2.3 are used; if false, then the old style, from earlier releases, are still used.  Old viewers will hopefully soon be removed from the system.')(warnIfNoChangesFile'If true, then you will be warned, whenever you start up, if no changes filecan be found')(warnIfNoSourcesFile 'If true, then you will be warned, whenever you start up, if no sources file can be found')) do:		[:pair | HelpDictionary at: pair first put: 			(pair first, ':', pair last)]! !!Preferences class methodsFor: 'parameters' stamp: 'sw 10/5/1998 15:04'!defaultPaintingExtent	"Answer the preferred size for the onion-skin paint area when launching a new painting within a paste-up morph.  Feel free to change the parameters to suit your configuration."	^ 400 @ 300! !!Preferences class methodsFor: 'parameters' stamp: 'sw 11/5/1998 19:50'!initializeParameters	"Preferences initializeParameters"	Parameters _ IdentityDictionary new.	self restoreDefaultMenuParameters.	Parameters at: #maxBalloonHelpLineLength put: 28! !!Preferences class methodsFor: 'parameters' stamp: 'sw 11/5/1998 16:49'!maxBalloonHelpLineLength	^ Parameters at: #maxBalloonHelpLineLength! !!Preferences class methodsFor: 'parameters' stamp: 'sw 10/27/1998 13:57'!viewerEditingPaneHeight	^ 42! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 11/5/1998 19:55'!openPreferencesControlPanel	"Preferences openPreferencesControlPanel"	| aPanel aWindow aRow wrapper but aList odd aColor w width1 width2 spacer |	Smalltalk verifyMorphicAvailability ifFalse: [^ self beep].	aPanel _ AlignmentMorph newColumn.	aPanel beSticky.	aList _ OrderedCollection new.	FlagDictionary associationsDo: [:assoc | aList add: (Array				with: assoc key				with: assoc value				with: (self helpMessageForPreference: assoc key))].	odd _ false.	width1 _ 172.	spacer _ 4.	width2 _ 14.	(aList asSortedCollection: [:a :b | a first < b first])		do: 			[:triplet | 			aPanel addMorphBack: (aRow _ AlignmentMorph newRow).			aRow color: (aColor _ odd							ifTrue: [Color green muchLighter]							ifFalse: [Color red veryMuchLighter]).			odd _ odd not.			aRow addMorph: (wrapper _ Morph new color: aColor).			wrapper setBalloonText: triplet third.			wrapper extent: width1 @ 15.			wrapper addMorph: (StringMorph new contents: triplet first).			aRow addMorphBack: (Morph new color: aColor; extent: (spacer @ 15)).			aRow addMorphBack: (wrapper _ Morph new color: aColor).			wrapper extent: width2 @ 15.			wrapper addMorphBack: (but _ UpdatingBooleanStringMorph new contents: triplet second printString).			but getSelector: triplet first;			 putSelector: #setPreference:toValue:;			 target: self].	Smalltalk isMorphic		ifTrue:			[aWindow _ SystemWindow new model: self.			aWindow addMorph: aPanel frame: (0 @ 0 extent: 1 @ 1).			aWindow setLabel: 'Preferences'.			aWindow openInWorld]		ifFalse:			[w _ WorldMorph new addMorph: aPanel.			w startSteppingSubmorphsOf: aPanel.			MorphWorldView openOn: w				label: 'Preferences'				extent: w fullBounds extent]! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:15'!menuBorderColor	^ Parameters at: #menuBorderColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:16'!menuBorderWidth	^ Parameters at: #menuBorderWidth! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:15'!menuColor	^ Parameters at: #menuColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:37'!menuLineLowerColor	^ Parameters at: #menuLineLowerColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:36'!menuLineUpperColor	^ Parameters at: #menuLineUpperColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:16'!menuTitleBorderColor	^ Parameters at: #menuTitleBorderColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:16'!menuTitleBorderWidth	^ Parameters at: #menuTitleBorderWidth! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:15'!menuTitleColor	^ Parameters at: #menuTitleColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:33'!restoreDefaultMenuParameters	"Preferences restoreDefaultMenuParameters"	"Restore the four color choices of the original implementors of MorphicMenus"	Parameters at: #menuColor put: (Color r: 0.8 g: 0.8 b: 0.8).	Parameters at: #menuBorderColor put: #raised.	Parameters at: #menuBorderWidth put: 2.	Parameters at: #menuTitleColor put: (Color r: 0.5 g: 1 b: 0.75).	Parameters at: #menuTitleBorderColor put: #inset.	Parameters at: #menuTitleBorderWidth put: 1.	Parameters at: #menuLineUpperColor put: (Color r: 0.667 g: 0.667 b: 0.667).	Parameters at: #menuLineLowerColor put: (Color r: 0.833 g: 0.833 b: 0.833).! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:38'!setAltMenuChoices	"Preferences setAltMenuChoices"	Parameters at: #menuTitleColor put: (Color r: 0.4 g: 0.8 b: 0.9).	Parameters at: #menuColor put: (Color r: 0.97 g: 0.97 b: 0.97).	Parameters at: #menuTitleBorderColor put: Color blue muchLighter.	Parameters at: #menuBorderColor put: Color blue lighter.	Parameters at: #menuLineUpperColor put: Color blue lighter.	Parameters at: #menuLineLowerColor put: (Color r: 0.97 g: 0.97 b: 0.97)! !!Presenter methodsFor: 'button creation' stamp: 'sw 11/9/1998 13:45'!addStopStepGoButtonsTo: aPasteUpMorph	| controls |	controls _ ScriptingSystem scriptControlButtons.	controls setToAdhereToEdge: #bottomLeft.	aPasteUpMorph addMorphBack: controls! !!Presenter methodsFor: 'button creation' stamp: 'sw 11/5/1998 16:53'!flushButton	"for debugging only"	| aButton |	aButton _ EllipseMorph new extent: 41@25.	aButton addMorphCentered: (StringMorph new contents: 'Flush') lock;			color: (Color r: 0.548 g: 0.935 b: 0.935);			on: #mouseUp send: #flushUp:with: to: self;			setNameTo: 'Flush';			setProperty: #scriptingControl toValue: true;			setBalloonText: 'Don''t worry, you can *never* go down the drain. Clears out the Viewer and flushes the viewer cache';			beRepelling.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 11/5/1998 16:53'!goButton	goButton == nil  ifTrue:		[goButton _ ThreePhaseButtonMorph new.		goButton image:  (ScriptingSystem formAtKey: 'GoPicOn');			offImage: (ScriptingSystem formAtKey: 'GoPic');			pressedImage: (ScriptingSystem formAtKey: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: goButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Go Button';			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottom;			setBalloonText:'Resume running all paused scripts'].	goButton isInWorld ifFalse:		[associatedMorph addMorph: (goButton beRepelling position: (self stepButton topRight + (1@0)))].	^ goButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 10/16/1998 09:18'!newControlsButton	|  aButton aForm |	aButton _ ThreePhaseButtonMorph new.	aButton image:  (aForm _ ScriptingSystem formAtKey: 'Controls');		offImage: aForm; pressedImage:  aForm.	aButton actionSelector: #createControlPanel; 		arguments: Array new;		actWhen: #buttonDown; target: self;		setNameTo: 'Make Controls';		beRepelling;		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Drag from here to get a Control panel'.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 11/5/1998 16:53'!newPaintingButton	| aButton |	aButton _ ThreePhaseButtonMorph new.	aButton image:  (ScriptingSystem formAtKey: 'PaintBrush');		offImage: (ScriptingSystem formAtKey: 'PaintBrush'); pressedImage:  (ScriptingSystem formAtKey: 'PaintBrush').	aButton actionSelector: #dragAndDropToMakeNewDrawing; 		arguments: Array new;		actWhen: #buttonDown; target: self;		setNameTo: 'New Painting';		beRepelling;		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Drag a paintbrush into any playfield to start drawing a new player there.'.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 10/16/1998 09:19'!newPartsBinButton	|  aButton aForm |	aButton _ ThreePhaseButtonMorph new.	aButton image:  (aForm _ ScriptingSystem formAtKey: 'PartsBin');		offImage: aForm; pressedImage:  aForm.	aButton actionSelector: #createStandardPartsBin; 		arguments: Array new;		actWhen: #buttonDown; target: self;		setNameTo: 'Make Parts Bin';		beRepelling;		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Drag from here to create a new Parts Bin'.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 11/5/1998 16:53'!stepButton	| aPosition |	stepButton ifNil:		[stepButton _ ThreePhaseButtonMorph new.		stepButton image:  (ScriptingSystem formAtKey: 'StepPicOn');			offImage: (ScriptingSystem formAtKey: 'StepPic'); pressedImage:  (ScriptingSystem formAtKey: 'StepPicOn');				arguments: (Array with: nil with: stepButton);			setNameTo: 'Step Button'; 			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottom;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every paused script exactly once.  Keep the mouse button down over "Step" and everything will keep running until you release it'].	stepButton isInWorld ifFalse:		[aPosition _ associatedMorph			positionNear:				(self stopButton topRight + (1@0))			 forExtent:				stepButton extent			adjustmentSuggestion:				(0 @ (stepButton height negated)).		associatedMorph addMorph: (stepButton beRepelling position: aPosition)].	^ stepButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 10/16/1998 09:20'!stopButton	|  aPosition anExtent |	stopButton ifNil:		[stopButton _ ThreePhaseButtonMorph new.		stopButton image:  (ScriptingSystem formAtKey: 'StopPic');			offImage: (ScriptingSystem formAtKey: 'StopPic'); pressedImage:  (ScriptingSystem formAtKey: 'StopPicOn').		stopButton actionSelector: #stopUp:with:; 			arguments: (Array with: nil with: stopButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Stop Button'; 			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottomLeft;			setBalloonText:'Pause all ticking scripts.'].	stopButton isInWorld ifFalse:		[anExtent _ stopButton extent.		aPosition _ (associatedMorph left + 128) @ (associatedMorph bottom - 30).		aPosition _ associatedMorph positionNear: aPosition forExtent:  anExtent adjustmentSuggestion: (0 @ (anExtent y negated)).		associatedMorph addMorph: (stopButton beRepelling position: aPosition)].		^ stopButton! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/8/1998 17:27'!classNamesForStandardPartsBin	^	#(			(RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph PaintInvokingMorph  StringMorph)		( RecordingControlsMorph PianoKeyboardMorph))! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/22/1998 13:35'!controlPanel	|  aPanel itsWorld |	(itsWorld _ associatedMorph world) ifNotNil:		[(aPanel _ itsWorld allMorphs detect:		[:aMorph | ((aMorph isKindOf: PasteUpMorph) and: [aMorph hasProperty: #controlPanel])]				ifNone: [nil]) notNil			ifTrue:				[^ aPanel]].	aPanel _ PasteUpMorph new extent:  128 @ 48.	aPanel color: Color white; padding: 9; borderWidth: 1; borderColor: Color blue.	aPanel addAllMorphs: self toggleButtons. 	aPanel laySubpartsOutInOneRow.	aPanel setProperty: #controlPanel toValue: true; setNameTo: 'Control Panel'.	^ aPanel ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/16/1998 18:47'!createStandardPartsBin	associatedMorph primaryHand attachMorph: self standardPartsWindow activate! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 11/9/1998 13:08'!customPagesForPartsBin	| aPage aWindow anotherPage pu |	aPage _ self newPageForStandardPartsBin.	aPage addMorphBack: BookMorph authoringPrototype.	aPage addMorphBack: Morph new previousPageButton markAsPartsDonor.	aPage addMorphBack: Morph new nextPageButton markAsPartsDonor.	#(TabbedPalette BasicButton JoystickMorph ClockMorph) do:		[:aName | aPage addMorphBack: (Smalltalk at: aName) authoringPrototype].	aWindow _ Browser new openAsMorphEditing: nil.	aWindow setLabel: 'System Browser'.	aPage addMorphBack: aWindow.	aWindow _ Workspace new embeddedInMorphicWindowLabeled: 'Workspace'.	aPage addMorphBack: aWindow.	aPage addMorphBack: FileList openAsMorph.	aPage replaceTallSubmorphsByThumbnails.	aPage fixLayout.	anotherPage _ self newPageForStandardPartsBin.	anotherPage addMorphBack: ScriptingSystem newScriptingSpace.	anotherPage addMorphBack: ScriptingSystem scriptControlButtons.	anotherPage addMorphBack: TrashCanMorph new.	anotherPage addMorphBack: PasteUpMorph authoringPrototype.	anotherPage addMorphBack: ((pu _ PasteUpMorph newSticky) embeddedInMorphicWindowLabeled: 'assembly window').	pu color: (Color r: 0.839 g: 1.0 b: 0.935).	anotherPage replaceTallSubmorphsByThumbnails.	anotherPage fixLayout.	^ Array with: aPage with: anotherPage! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/23/1998 15:30'!launchCustomPartsBin	associatedMorph primaryHand attachMorph: ScriptingSystem customPartsBin ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/16/1998 11:27'!newPageForStandardPartsBin	| aPage |	aPage _ PasteUpMorph new.	aPage color: Color white; padding: 6.	aPage autoLineLayout: true.	aPage isPartsBin: true; openToDragNDrop: false.	aPage setProperty: #alwaysShowThumbnail toValue: true.	^ aPage! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/8/1998 15:16'!newStandardPartsBinTitled: aTitle includeControls: includeControls	| aBook aPage aSize |	aSize _ 360 @ 190.	aBook _ BookMorph new color: Color blue veryMuchLighter.	aBook borderWidth: 0.	aBook removeEverything.	aBook openToDragNDrop: false.	includeControls ifTrue:		[aBook addMorphBack: (aBook makeMinimalControlsWithColor: Color transparent title: aTitle)].	self classNamesForStandardPartsBin do:		[:aList |			aPage _ self newPageForStandardPartsBin.			aList do:				[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].			aPage replaceTallSubmorphsByThumbnails.			aPage fixLayout.			aBook insertPage: aPage pageSize: aSize].	self customPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	self tilesPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	aBook goToPage: 1.	^ aBook! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/21/1998 23:13'!standardPartsWindow	| aPartsWindow |	aPartsWindow _ ScriptingSystem newStandardPartsBin wrappedInPartsWindowWithTitle: 'Standard Parts'.	associatedMorph world addMorph: aPartsWindow.	aPartsWindow closeEditing.  "a bit redundant but gets the last details right"	^ aPartsWindow! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/21/1998 09:44'!tilesPagesForPartsBin	| aPage bools aTile aPhrase |	aPage _ self newPageForStandardPartsBin padding: 30.	bools _ self booleanTiles.	aPage addMorphBack: bools first markAsPartsDonor.	aPage addMorphBack: bools last markAsPartsDonor.	aPage addMorphBack: self arithmeticTiles first markAsPartsDonor.	aPage addMorphBack: RandomNumberTile new markAsPartsDonor.	#(('(Sensor anyButtonPressed)' 'button down?')	('(Sensor noButtonPressed)' 'button up?')	"('(Sensor keyboardPressed)' 'key hit?')   sucker doesn't work for some reason") do:		[:pair |			aPhrase _ SystemQueryPhrase new.			aTile _ BooleanTile new.			aTile setExpression: pair first label: pair second.			aPhrase addMorph: aTile.			aPage addMorphBack: aPhrase].	self harmonizeTileColorPolicyFor: aPage.	aPage fixLayout.	aPage replaceTallSubmorphsByThumbnails.	^ OrderedCollection with: aPage  "room to grow"! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 10/16/1998 09:17'!createStandardPlayer	| aMorph |	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	standardPlayer _ aMorph assuredPlayer renameTo: 'dot'.	aMorph setBalloonText: '...'.	self positionStandardPlayer.	^ standardPlayer! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 10/30/1998 15:36'!goUp: evt with: aMorph	self startRunningScripts! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 10/30/1998 18:33'!balloonHelpEnabled	"Because the Hand logic wants to get the balloon-help state from the World rather than from any more local morph, this option always gets referred directly to the world -- perforce non-uniform with the other toggles"	^ associatedMorph world ifNotNil: [associatedMorph world balloonHelpEnabled] ifNil: [true]! !!Presenter methodsFor: 'tile support' stamp: 'sw 11/9/1998 18:48'!constantTile: anObject	(anObject isKindOf: Color) ifTrue:		[^ ColorTileMorph new typeColor: (ScriptingSystem colorForType: #color)].	^ anObject newTileMorphRepresentative		typeColor: (ScriptingSystem colorForType: (self typeForConstant: anObject))! !!Presenter methodsFor: 'tile support' stamp: 'sw 10/29/1998 16:06'!valueTiles	| tiles |	tiles _ OrderedCollection new.	tiles add: (5 newTileMorphRepresentative typeColor: (ScriptingSystem colorForType: #number)).	tiles add: ((4 @ 9) newTileMorphRepresentative typeColor: (ScriptingSystem colorForType: #point)).	tiles add: (ColorTileMorph new typeColor: (ScriptingSystem colorForType: #color)).	tiles add: (TileMorph new typeColor: (ScriptingSystem colorForType: #number);			setExpression: '(180 atRandom)'			label: 'random').	tiles add: RandomNumberTile new.	^ tiles! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/22/1998 20:36'!nascentPartsViewer	"EToyPlayer creates one that is sticky, here it's movable"	^ Preferences useNewViewers		ifTrue:			[StandardViewer new]		ifFalse:			[PartsViewer new]! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/27/1998 14:53'!updatePartsViewer: aPartsViewer	| aPlayer aPosition aNewPartsViewer oldOwner wasSticky |	aPlayer _ aPartsViewer scriptedPlayer.	aPosition _ aPartsViewer position.	wasSticky _ aPartsViewer isSticky.	aNewPartsViewer _ aPartsViewer species new visible: false.	wasSticky ifTrue: [aNewPartsViewer beSticky].	oldOwner _ aPartsViewer owner.	aPartsViewer delete.	oldOwner ifNotNil: [oldOwner addMorphBack: aNewPartsViewer].	aNewPartsViewer obtainBankInfoFrom: aPartsViewer.	aNewPartsViewer setPlayer: aPlayer.	aNewPartsViewer position: aPosition.	self harmonizeTileColorPolicyFor: aNewPartsViewer.	aNewPartsViewer visible: true.	aNewPartsViewer layoutChanged! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/27/1998 21:14'!updateViewer: aViewer	| aPlayer aPosition newViewer oldOwner wasSticky |	aPlayer _ aViewer scriptedPlayer.	aPosition _ aViewer position.	wasSticky _ aViewer isSticky.	newViewer _ aViewer species new visible: false.	newViewer initializeFor: aPlayer.	wasSticky ifTrue: [newViewer beSticky].	oldOwner _ aViewer owner.	aViewer delete.	oldOwner ifNotNil: [oldOwner addMorphBack: newViewer].	newViewer obtainBankInfoFrom: aViewer.	newViewer position: aPosition.	self harmonizeTileColorPolicyFor: newViewer.	newViewer visible: true.	newViewer world startSteppingSubmorphsOf: newViewer.	newViewer layoutChanged! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/21/1998 09:44'!viewMorph: aMorph	| aPlayer aViewer aPalette |	Sensor leftShiftDown ifFalse:		[(aPalette _ aMorph standardPalette) ifNotNil:			[^ aPalette viewMorph: aMorph]].	aPlayer _ aMorph assuredPlayer.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	aViewer setPlayer: aPlayer.	self harmonizeTileColorPolicyFor: aViewer.	aMorph primaryHand attachMorph: (aViewer visible: true)! !!Presenter methodsFor: 'misc' stamp: 'sw 10/30/1998 14:48'!harmonizeTileColorPolicyFor: aMorph	self coloredTilesEnabled		ifTrue:			[aMorph makeAllTilesColored]		ifFalse:			[aMorph makeAllTilesGreen]! !!Presenter methodsFor: 'misc' stamp: 'sw 10/21/1998 09:47'!harmonizeTilesWithColorSetting	self harmonizeTileColorPolicyFor: self world! !!Presenter methodsFor: 'misc' stamp: 'sw 10/16/1998 18:34'!morph: aMorph droppedIntoPasteUpMorph: aPasteUpMorph	((aMorph isKindOf: PaintInvokingMorph) and: [aMorph isPartsDonor])		ifTrue: "Ugly, I know, but we don't want automatic viewing if we're going to trigger painting"			[^ self].	aPasteUpMorph automaticViewing ifTrue: [aPasteUpMorph standardPalette viewMorph: aMorph]! !!Presenter methodsFor: 'misc' stamp: 'sw 11/5/1998 16:54'!toggleButtons	| aButton  aList |	aList _ #(	('Balloons'	'BalloonsOn'		'BalloonsOff' 	toggleShowBalloons	balloonHelpEnabled)	('Sounds'	'SoundOn'		'SoundOff'  		toggleSoundsEnabled	soundsEnabled)	('Fence'		'FenceOn'		'FenceOff'  		toggleFence			fenceEnabled)) with:	#('Balloon Help: If green, then when the cursor pauses over an object that has balloon help, that help balloon is shown''Sounds: If green, sounds will be  heard when appropriate; if red, sounds are suppressed.''Fence: If green, an invisible "fence" keeps your objects from straying outside their containers when their scripts move them.')	collect:			[:q :helpString |			aButton _ ToggleButtonMorph new setNameTo: q first.			aButton onImage: (ScriptingSystem formAtKey: q second);				offImage: (ScriptingSystem formAtKey: q third);				pressedImage: nil;				actionSelector: q fourth;				stateSelector: q last;				actWhen: #buttonDown;				target: self;				setInitialState;  "Obtains it from target"				setBalloonText: helpString;				extent: (ScriptingSystem formAtKey: q second) extent.			aButton].	^ aList! !!Project methodsFor: 'initialization' stamp: 'sw 11/5/1998 21:28'!backgroundColorForMorphicProject	^ Color r: 0.935 g: 1.0 b: 0.355! !!Project methodsFor: 'initialization' stamp: 'sw 11/5/1998 21:28'!backgroundColorForMvcProject	^ Color r: 1.0 g: 1.0 b: 0.065! !!Project methodsFor: 'initialization' stamp: 'sw 11/5/1998 21:28'!defaultBackgroundColor	^ (world isKindOf: WorldMorph) ifTrue: [self backgroundColorForMorphicProject] ifFalse: [self backgroundColorForMvcProject]! !!ProjectViewMorph methodsFor: 'all' stamp: 'sw 11/5/1998 14:45'!drawOn: aCanvas	(project ~~ nil and: [project thumbnail ~~ lastProjectThumbnail]) ifTrue:			["scale thumbnail to fit my bounds"			(WarpBlt toForm: image)				sourceForm: project thumbnail;				cellSize: 2;  "installs a colormap"				combinationRule: Form over;				copyQuad: (project thumbnail boundingBox) innerCorners				toRect: (0@0 extent: image extent).			lastProjectThumbnail _ project thumbnail.			image borderWidth: 1].	project ifNotNil: [project thumbnail ifNil: [image fill: (0@0 extent: image extent) rule: Form over fillColor: project defaultBackgroundColor]].	super drawOn: aCanvas.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 11/5/1998 21:41'!durableOpenMenu 	| colorPattern |	colorPattern _ #(blue lightGreen lightYellow lightMagenta  lightOrange lightCyan lightBlue lightBlue) asOrderedCollection.	colorPattern add: Project someInstance backgroundColorForMvcProject.	colorPattern add: Project someInstance backgroundColorForMorphicProject.	colorPattern add: #orange.	Utilities windowFromMenu: self openMenu target: self title: 'Openers'		colorPattern: colorPattern! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 11/5/1998 16:17'!fileOutChanges	"File out changes to a file whose name is a function of the current date and time."	Smalltalk changes fileOut.	Transcript cr; show: 'Changes filed out ', Date dateAndTimeNow printString! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 10/27/1998 14:27'!lookForSlips	Smalltalk changes lookForSlips! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 10/27/1998 14:27'!changesMenu	"Answer a menu for changes-related items"	^ SelectionMenu labelList:		#(	'keep this menu up'			'file out changes'			'create new change set...'			'browse changed methods'			'check for slips'			'simple change sorter'			'dual change sorter'			'browse recent submissions'			'recent change log'			)		lines: #(1 5 7)		selections: #(durableChangesMenufileOutChanges newChangeSet browseChangedMessages lookForSlipsopenSimpleChangeSorter openChangeManagerbrowseRecentSubmissions browseRecentLog )"ScreenController new changesMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 10/9/1998 08:05'!openMenu	^ SelectionMenu labelList:		#(	'keep this menu up'			'browser'			'workspace'			'file list'			'transcript'			'selector finder'			'simple change sorter'			'dual change sorter'			'project (mvc)'			'project (morphic)'			'project (construction)'			)		lines: #(1 8)		selections: #(durableOpenMenuopenBrowser openWorkspace openFileList openTranscript openSelectorBrowser openSimpleChangeSorter openChangeManager"openMorphicWorld openMorphicConstructionWorld"openProject  openMorphicProject  openConstructionProject )"ScreenController  new openMenu startUp"! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 11/3/1998 17:20'!myMorph	"Answer the morph that serves as the costume of my associated player.  If for some reason I have no associated player, answer nil"	| aPlayer |	^ (aPlayer _ self playerScripted) ifNotNil: [aPlayer costume]! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/21/1998 09:41'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add tiles and program fragments just by dropping them on this morph." 	| i slideMorph p1 p2 |		self prepareToUndoDropOf: aMorph.		"Find where it will go, and prepare to animate the move..."	i _ self rowInsertionIndexFor: aMorph fullBounds center.	slideMorph _ aMorph imageForm offset: 0@0.	p1 _ aMorph screenRectangle topLeft.	aMorph delete.	self stopStepping.	self world displayWorld.  "Clear old image prior to animation"	(aMorph isKindOf: PhraseTileMorph) ifTrue: [aMorph unbrightenTiles].	aMorph tileRows do: [:tileList |		self insertTileRow: (Array with:				(tileList first rowOfRightTypeFor: owner forActor: aMorph associatedPlayer))			after: i.		i _ i + 1].	self removeSpaces.	self enforceTileColorPolicy.	self layoutChanged.	"Now animate the move, before next Morphic update.		NOTE: This probably should use ZoomMorph instead"	p2 _ (self submorphs atPin: (i-1 max: firstTileRow)) screenRectangle topLeft.	slideMorph slideFrom: p1 to: p2 nSteps: 5 delay: 50 andStay: true.	self playSoundNamed: 'scritch'.	self topEditor install  "Keep me for editing, a copy goes into lastAcceptedScript"! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/29/1998 16:06'!step	| hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii |	hand _ self primaryHand.	(hand lastEvent redButtonPressed)		ifTrue:		[hand submorphCount > 0 ifTrue:			[insertion _ hand firstSubmorph.			insHt _ insertion height.			self removeSpaces.			i _ (ii _ self indexOfMorphAbove: insertion fullBounds topLeft)					min: submorphs size-1.			prevBot _ i <= 0 ifTrue: [(self innerBounds) top]					ifFalse: [(self submorphs at: i) bottom].			nxtHt _ (submorphs isEmpty					ifTrue: [insertion]					ifFalse: [self submorphs at: i+1]) height.			d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]					ifFalse: [0 max: (insertion top - prevBot min: nxtHt)].			"Top and bottom spacer heights cause continuous motion..."			c1 _ Color green.  c2 _ Color transparent.			ht2 _ d*insHt//nxtHt.			space1 _ Morph newBounds: (0@0 extent: 30@(insHt-ht2))					color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space1 atIndex: (i+1 max: 1).			space2 _ Morph newBounds: (0@0 extent: 30@ht2)					color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1)]]		ifFalse:		[self stopStepping.		self removeSpaces.		self allMorphsDo: [:m |			(m isKindOf: TileMorph) ifTrue: [				m color: (ScriptingSystem unbrightColorFor: m color)]]]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 11/9/1998 18:37'!buttonRowForEditor	| r aString aButtonMorph buttonFont aStatusMorph aStatus |	buttonFont _ ScriptingSystem fontForScriptorButtons.	r _ AlignmentMorph newRow color: Color transparent; inset: 0.	r addMorphFront:		(SimpleButtonMorph new			label: '!!' font: (StrikeFont familyName: #ComicBold size: 16);			target: self;			color: Color yellow;			actWhen: #whilePressed;			actionSelector: #tryMe;			balloonTextSelector: #tryMe).	r addTransparentSpacerOfSize: 6@10.	aString _ playerScripted externalName, ' ', self scriptTitle.	r addMorphBack:		(aButtonMorph _ SimpleButtonMorph new label: aString font: buttonFont; target: self; setNameTo: 'title').	aButtonMorph actWhen: #buttonDown; actionSelector: #offerScriptorMenu.	aButtonMorph borderColor: (Color fromRgbTriplet: #(0.065 0.258 1.0)).	aButtonMorph color: (self isAnonymous ifTrue: [Color blue muchLighter] ifFalse: [ScriptingSystem uniformTileInteriorColor]).	aButtonMorph balloonTextSelector: #offerScriptorMenu.	r addTransparentSpacerOfSize: 6@10.	aStatus _ self scriptInstantiation status.	r addMorphBack:			(aStatusMorph _ SimpleButtonMorph new label: aStatus font: buttonFont;				setNameTo: 'trigger';				target: self;				actWhen: #buttonDown;				actionSelector: #chooseTrigger;				setBalloonText: (ScriptingSystem helpStringFor: #chooseTrigger) maxLineLength: 65;				balloonTextSelector: #chooseTrigger).	r addTransparentSpacerOfSize: 10@10.	r addMorphBack:		((SimpleButtonMorph new label: '¥' font: buttonFont)			target: self;			color: Color veryLightGray;			actWhen: #buttonDown;			actionSelector: #addYesNoToHand;			balloonTextSelector: #addYesNoToHand).	r addTransparentSpacerOfSize: 12@10.	self addDismissButtonTo: r.	self updateStatusMorph: aStatusMorph.	^ r! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 10/22/1998 11:25'!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	| aMenu reply standardStati aScriptInstantiation |	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging opening closing "keyStroke").	aScriptInstantiation _ self scriptInstantiation.	aMenu _ SelectionMenu labelList:  #(		'normal'		" -- run when called"				'paused' 		"ready to run all the time"		'ticking'		"run all the time"		'mouseDown'	"run when mouse goes down on me"		'mouseStillDown'	"while mouse still down"		'mouseUp'		"when mouse comes back up"		'mouseEnter'	"when mouse enters my bounds, button up"		'mouseLeave'	"when mouse exits my bounds, button up"		'mouseEnterDragging'	"when mouse enters my bounds, button down"		'mouseLeaveDragging'	"when mouse exits my bounds, button down"		'opening'	"when I am being opened"		'closing'	"when I am being closed"	"	'keyStroke'	run when user hits a key"		)		lines: #(1 3 6 10 "12")		selections: standardStati.	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply ifNotNil: 		[aScriptInstantiation status: reply.  "Gets event handlers fixed up"		reply == #ticking ifTrue: [playerScripted costume arrangeToStartStepping].		self updateStatus]! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'sw 11/2/1998 14:23'!addTextualScript: aBrowser	"Put a message browser right into the header alignment morph"	| window aMorph codePane |	submorphs last class == PluggableTextMorph ifTrue: [^ self].	window _ self.	aMorph _ PluggableListMorph on: aBrowser list: #messageListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageListMenu:shifted:.	aMorph bounds: (window topLeft extent: 200@12).	"will get moved"	window addMorphBack: aMorph.	aMorph borderWidth: 1;		color: (Color colorFrom: aBrowser defaultBackgroundColor).	codePane _ PluggableTextMorph on: aBrowser text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	"editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true]."	codePane bounds: (window topLeft extent: 200@120).	"will get moved"	window addMorphBack: codePane.	codePane borderWidth: 1; retractableOrNot; "make it stay"		color: (Color perform: aBrowser defaultBackgroundColor)."	self addMorph: aMorph.	aMorph borderWidth: 1;		color: (Color perform: aBrowser defaultBackgroundColor);		bounds: "! !!ScriptingDomain methodsFor: 'all' stamp: 'sw 10/5/1998 14:47'!addModelMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph 	super addModelMenuItemsTo: aCustomMenu forMorph: self hand: aHandMorph.  "nominally nothing"	aCustomMenu add: 'take out of window' action: #takeOutOfWindow	! !!ScriptingDomain methodsFor: 'all' stamp: 'sw 9/30/1998 13:00'!initialExtent	^ 640 @ 480! !!ScrollPane methodsFor: 'menu' stamp: 'sw 11/5/1998 14:14'!retractable: aBoolean	retractableScrollBar == aBoolean ifFalse: [self retractableOrNot "toggles it"]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 11/2/1998 17:49'!yellowButtonActivity	"Called when the shifted-menu's 'more' item is chosen"	| menu event |	(menu _ self getMenu: false) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		event _ self primaryHand lastEvent.		menu popUpAt: event cursorPoint event: event]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 10/21/1998 15:27'!sixth	"Answer the sixth element of the receiver. Create an error notification if 	the receiver contains fewer than five elements."	^ self at: 6 ifAbsent: [self error: 'element not found']! !!SimpleButtonMorph methodsFor: 'events' stamp: 'sw 10/22/1998 20:37'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue: [oldColor ifNotNil: [self color: (oldColor mixed: 1/2 with: Color white)].				(actWhen == #whilePressed and: [evt anyButtonPressed])					 ifTrue: [self doButtonAction]]		ifFalse: [oldColor ifNotNil: [self color: oldColor]].! !!SlotInformation commentStamp: 'sw 11/9/1998 18:53' prior: 0!Holds information about user-defined instance variables in Players.!!SlotInformation methodsFor: 'all' stamp: 'sw 11/9/1998 14:09'!documentation	documentation ifNil: [documentation _ 'This is an instance variable defined by you.  Please edit this into your own meaningful documentation.'].	^ documentation! !!SlotInformation methodsFor: 'all' stamp: 'sw 11/6/1998 10:33'!documentation: d	documentation _ d! !!SlotInformation methodsFor: 'all' stamp: 'sw 11/6/1998 10:31'!type	type ifNil: [type _ #number].	^ type! !!SlotInformation methodsFor: 'all' stamp: 'sw 11/6/1998 10:31'!type: aType	type _ aType! !!StandardScriptingSystem reorganize!('font & color choices' colorBehindTiles fontForNameEditingInScriptor fontForScriptorButtons fontForTiles frozenPlayfieldBorderColor runningPlayfieldBorderColor statusColorSymbolFor: uniformTileInteriorColor)('form dictionary' formAtKey: inspectFormDictionary patchInNewStandardPlayerForm readFormsFromFileNamed: saveForm:atKey: saveFormsToFileNamed: squeakyMouseForm)('help dictionary' helpStringFor: initializeHelpStrings initializeScriptHelp initializeSystemSlotDictionary scriptHelp: scriptHelpFor: scriptHelpOrNilFor:)('utilities' cleanupsForRelease guessDOLProxy newScriptingSpace prepareForExternalReleaseNamed: reclaimSpace serverUrls spaceReclaimed standardEventStati stripGraphicsForExternalRelease tryButtonFor: typeForSystemSlotNamed: wordingForAssignmentSuffix: wordingForOperator:)('parts bin' customPartsBin initializeCustomPartsBin newStandardPartsBin resetStandardPartsBin setCustomPartsBinFrom:)('universal slots & scripts' initStandardScriptInfo initStandardSlotInfo scriptInfoFor: slotInfoFor:)('script-control' goButton goUp:with: mouseUpBalk: scriptControlButtons stepButton stepDown:with: stepStillDown:with: stepUp:with: stopButton stopUp:with:)('tile colors' brightColorFor: colorForType: colorFudge initializeTypeColors unbrightColorFor:)!!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/21/1998 11:31'!formAtKey: aKey	"ScriptingSystem saveForm: (TileMorph downPicture) atKey: 'downArrow'"	^ FormDictionary at: aKey ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/16/1998 09:21'!inspectFormDictionary	"ScriptingSystem inspectFormDictionary"	FormDictionary inspectFormsWithLabel: 'Standard Graphics'! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/16/1998 09:21'!patchInNewStandardPlayerForm	"ScriptingSystem patchInNewStandardPlayerForm"	FormDictionary at: 'standardPlayer' put:		(Form extent: 3@3	depth: 16 fromArray: #( 17969 0 1177634353 1177616384 17969 0) offset: 0@0)! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/21/1998 11:29'!saveForm: aForm atKey: aKey	FormDictionary at: aKey put: aForm! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 10/24/1998 14:12'!squeakyMouseForm	^ self formAtKey: 'squeakyMouse'"	ScriptingSystem saveForm: (Form	extent: 30@29	depth: 16	fromArray: #( 1811114995 1878286257 2012637171 1811180532 1811180533 1811179508 1811180532 1811179508 1744006133 1878289396 1811180533 1878289396 1744007156 1674736630 1744006132 1811114995 1811181556 1744006131 1811246068 1811180532 1811179508 1811180532 1744071668 1811113972 1811180532 1811180532 1811179507 1878288338 1945529332 1744071668 1743941620 1811112945 1811179506 1811114995 1744006131 1744006130 1744005106 1811048434 1811113969 1743939570 1811179506 1743939571 1676833782 1676765171 1811047410 1744006131 1811048435 1811116020 1811180531 1743939571 1811048435 1743939570 1743939570 1743939570 1743940594 1744005106 1811181556 1811180532 1676766196 1743939570 1878420468 1676963830 1189896082 1811245044 1744137204 1744070644 1811179508 1811113971 1743939571 1811179508 1811246070 1811309524 1811302093 1811310580 1811246068 1674867703 1744049472 1120606594 1118465013 1744137205 1811179508 1811180532 1744071667 1744006132 1811112947 1811247095 1605584589 358761132 289435638 1676830707 1741975543 1462778473 1811312631 702891724 1811310548 1945528308 1811178450 1945528307 1878288372 1878353875 1878421494 1051471335 1809213397 1118524175 1811246068 1945659348 1185698607 1878486005 1672694510 1118531574 1607626741 1878420467 1811180533 1743942645 1744072693 1811301035 1185770487 1878486006 1324239597 1811180533 1811116019 1120623438 1878352818 1945462739 704868339 1878289395 1811049459 1878221808 1878223859 1743876083 1811162563 1945463796 1811181556 1464746666 1811116018 1809019893 1120551562 1945464821 1741844468 1466842760 1878289395 1811048434 1811050483 1811050483 1878223859 1049188174 1741910004 1811181556 1256998634 1811114994 1878289396 1466840647 1744007156 1744006131 1676877216 1743940596 1878222835 1743938545 1878351792 1676833781 358641652 1743940596 1811050484 845566798 1811113970 1811114995 1811163652 1811112913 1878420468 1878282028 1811179506 1607560178 1878289395 1676900342 1878351825 1466853330 1811113971 1811116019 635659217 1811179506 1811245045 1676942754 1744137206 1744201717 1676962806 1676962805 1811310581 1676896245 1744199635 1811376117 1744072695 1744005109 1811244019 499279861 1811310581 1811244020 1811293668 1399943159 1605528567 1744136181 982063522 986342388 1744070645 1744189066 430063308 1744071669 1744070644 1744067504 566519797 1744136181 1744137205 1743999854 912813044 1811311606 1742162607 4195488 283139922 1945531382 1253113857 144710948 1601400791 1811246069 1811167879 1464821747 1744136180 1674799094 1811178482 843473875 1811311606 1878533542 2106790 2080066222 1876193270 696845376 627472380 1185772536 1878355957 1743990309 1744007157 1676898294 1744006132 1811114996 1743941620 1811180533 1809204941 4194368 4217681 1878290421 1252982848 4194336 1670540278 1739811795 1878353906 1744006131 1811179506 1744007157 1744005106 1945462771 1811182582 1811311574 1393641133 1462856629 2012638196 1876382449 1112301394 1742041045 1945596917 1676833781 1811113970 1811179507 1811180532 1672705014 1674735606 1672697648 1945725943 1878551479 1809215479 1811312629 1809216504 1809215479 1809215478 1462853490 1878487029 1744007158 1744005075 1811239726 704979363 495004132 700789287 562372997 631646663 1739998892 4194400 1116497846 698688932 562375109 770124262 633609569 495070758 1257010166 562315916 1809279958 2012894002 1047280171 980237901 910966381 1668677696 4194400 6314867 1047281260 908804749 910968495 1393719290 1809279959 1185750370 1809214455 1878469062 423836236 1532188466 1601592148 1462986647 1672937568 4194368 6319062 1603622706 1601525554 1601522417 1047336194 770206679 1878487031 1878409899 977955830 1809145716 1118586509 980105834 980045584 1811372914 980104778 1605526483 1395605131 910769804 1118651052 1534358520 1809136234 1118596053 1532059506 1878485973 1326456163 1945660374 1742106615 1811311607 1945725942 1742107641 1744072693 1811311605 1744203767 1878551543 564478604 1878553591 1603428242 1811048433 1811049459 1051290611 1744006131 1811049459 1878156273 1743874034 1744007156 1743874033 1811048434 1811113970 1743939571 1743933228 1603301363 1743875059 1811049458 1945461745 1811181556 1811113971 1811049458 1811048434 1811116020 1878287346 1878223857 1743940594 1744006130 1744007157 1945395153 1945400309 1811048434 1743810547 1676765170 1878353906 1811113970 1743874032 1810983921 1743874033 1811113971 1676765169 1743874034 1743940593 1743939569 1811047409 1676765168 1743940595 1810981872 1945397235 1607560179 1743941620 1810982897 1810983921 1811048433 1744007155 1743875059 1811048434 1743875058 1743939568 1676832754 1811116019 1811114994 1811244019 1676962805 1677029367 1811244020 1744005106 1743940594 1811246068 1744070645 1676961781 1744004084 1676897269 1811180533 1878353908 1744004083 1744070645)	offset: 0@0) atKey: 'squeakyMouse'"! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 13:50'!initializeHelpStrings	"ScriptingSystem initializeHelpStrings"	HelpStrings _ IdentityDictionary new.	#((heading		number		'Which direction the object is facing.  0 is straight up') (x				number		'The x coordinate, measured from the left of the container')(y				number'The y-coordinate, measured upward from the bottom of the container')(colorUnder		color'The color under the center of the object')(penDown		boolean'Whether the object''s pen is down (true) or up (false)')(penColor		color'The color of the object''s pen')(penSize			number'The size of the object''s pen')(colorSees		boolean'Whether a given color in the object is over another given color')(isOverColor		boolean'Whether any part of this object is directly over the specified color')(isUnderMouse	boolean'Whether any part of this object is beneath the current mouse-cursor position')(scaleFactor		number'The amount by which the object is scaled')(width			number'The distance between the left and right edges of the object')(height			number'The distance between the top and bottom edges of the object')(isOverColor		color'Whether any part of the object is over a given color')(color			color'The object''s interior color')(borderWidth	number'The width of the object''s border')(borderColor		color'The color of the object''s border')(cursor			number'The index of the chosen element')(valueAtCursor	player'The chosen element')(leftRight		number'The horizontal displacement')(upDown		number'The vertical displacement')(angle			number'The angular displacement')(amount		number'The amount of displacement')(mouseX		number'The x coordinate of the mouse pointer')(mouseY		number'The y coordinate of the mouse pointer')(left		number'My left edge, measured from the left edge of the World')(right		number'My right edge, measured from the left edge of the world')(top		number'My top edge, measured downward from the top edge of the world')(bottom		number'My bottom edge, measured downward from the top edge of the world')(tryMe			command'Click here to run this script once; hold button down to run repeatedly.')(try			command'Run this command once.')(dismiss			command'Click here to dismiss me')(addYesNoToHand	command'Press here to tear off a  TEST/YES/NO unit which you can drop into your script')(chooseTrigger	command'when this script should be run	normal -- run when called	paused -- ready to run all the time	ticking -- run all the time	mouseDown -- run when mouse goes down on me	mouseStillDown -- while mouse still down	mouseUp -- when mouse comes back up	mouseEnter -- when mouse enters my bounds, button up	mouseLeave -- when mouse exits my bounds, button up	mouseEnterDragging -- when mouse enters my bounds, button down	mouseLeaveDragging -- when mouse exits my bounds, button down	opening -- when I am being opened	closing -- when I am being closed'	"	'keyStroke -- run when user hits a key' "		)(offerScriptorMenu	command'Press here to get a menu of options for this Scriptor')(objectNameInHalo  control'Object''s name -- To change: click here; backspace over old name, type in new name; hit ENTER')(userSlot		control'This is an instance variable defined by you.  Click here to change its type')		) do: [:triplet | HelpStrings at: triplet first put: triplet third]! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 14:53'!initializeScriptHelp" | helpDict |	helpDict _ IdentityDictionary new.	#(	(aTest 'testing one two three') 	(acceptScript:for: 'submit the contents of the given script editor as the code defining the given selector')	(actorState 'return the ActorState object for the receiver, creating it if necessary')	(addInstanceVariable 'start the interaction for adding a new instance variable to the receiver')	(addPlayerMenuItemsTo:hand: 'add player-specific menu items to the given menu, on behalf of the given hand.  At present, these are only commands relating to the turtle')	(addSlotNamedLike:withValue: 'add a slot with a unique name derived from the first parameter, giving it the second parameter as its initial value')	(allScriptEditors 'answer a list off the extant ScriptEditors for the receiver')	(anonymousScriptEditorFor: 'answer a new ScriptEditor object to serve as the place for scripting an anonymous (unnamed, unsaved) script for the receiver')	(assignDecrGetter:setter:amt: 'evaluate the decrement variant of assignment')	(assignGetter:setter:amt: 'evaluate the vanilla variant of assignment')	(assignIncrGetter:setter:amt: 'evalute the increment version of assignment')	(assignMultGetter:setter:amt: 'evaluate the multiplicative version of assignment')	(assureEventHandlerRepresentsStatus 'make certain that the event handler associated with my current costume is set up to conform to my current script-status')	(assureExternalName 'if I do not currently have an external name assigned, get one now')	(assureUniClass 'make certain that I am a member a uniclass (i.e. a unique Player subclass); if I am not, create one now and become me into an instance of it')	(availableCostumeNames 'answer a list of strings representing the names of all costumes currently available for me')	(availableCostumesForArrows 'answer a list of actual, instantiated costumes for me, which can be cycled through as the user hits a next-costume or previous-costume button in a viewer')	(beep: 'make the requested sound')	(bounce: 'if I have just run into a boundary, bounce off of it, making the stated sound')	(clearTurtleTrails 'erase all the pen trails within me')	(deleteCard 'delete the current card')	(firstPage 'make the first page of this book be the current one')	(forward: 'move forward by the specified amount')	(goto: 'make the given page be seen as my current page')	(goToNextCard 'make the next card within me be the currently-visible one')	(goToPreviousCard 'make the previous card within me be the currently-visible one')	(goToRightOf: 'move me until I lie directly to the right of the other object.')	(hide 'make me be invisible')	(initiatePainting 'let the user start painting a new object with me')	(lastPage 'make the last page of this book be the current one')	(liftAllPens 'lift the pens of all the objects within me')	(lowerAllPens 'lower the pens of all the objects within me')	(moveToward: 'move toward another object')	(newCard 'create a new card and make it my currently-visible one')	(nextPage 'go to the next page following the current one')	(pauseScript: 'make the specified script become paused')	(previousPage 'go to the page preceding the current one.')	(show 'make me be visible (if I was formerly hidden')	(startScript: 'make the specified script start ticking')	(stopScript: 'make the specified script stop running')	(turn: 'turn by the specified amount')	(wearCostumeOf: 'wear a costume resembling that of another player')	(wrap 'if I have just run into a boundary, reappear at the corresponding point on the opposite side')	 		) do: [:pair | helpDict at: pair first put: pair second].	ScriptingSystem scriptHelp: helpDict"	| aDoIt |	aDoIt _ StandardScriptingSystem firstCommentAt: #initializeScriptHelp.	Compiler evaluate: aDoIt"ScriptingSystem initializeScriptHelp""(     basicType beNotZero:   categories changeScript:toStatus: changeVariableType checkCostume choosePenColor: choosePenSize chooseSlotTypeFor: chooseUserSlot color color:sees: colorUnder commandPhraseFor:inViewer: compileAccessorsFor: compileInstVarAccessorsFor: convertdc0:dcc0: copyStateFrom: copyUniClass costume costume: costumeRespondingTo: costumeSlotNamesAndTypesForBank: costumes costumesDo: createNewCard defaultLabelForInspector defaultPenColor defaultPenSize  dummy externalName  forgetOtherCostumes  getAmount getAngle getBorderColor getBorderWidth getBottom getColor getColorUnder getCursor getHeading getHeadingUnrounded getHeight getInfo getIsUnderMouse getLeft getLeftRight getMouseX getMouseY getName getPenColor getPenDown getPenSize getRight getRotationStyle getScaleFactor getSpeed getTop getUpDown getValueAtCursor getValueFromCostume: getWidth getX getY     grabPlayerIn: hasCostumeOfClass: hasScriptInvoking:ofPlayer: hasScriptReferencing:ofPlayer: headDown headLeft headRight headUp  infoFor: initialTypeForSlotNamed: initialValueForSlotOfType: initializeCostumesFrom: initiatePainting instantiatedUserScriptsDo: isFlagshipForClass justClonedFrom: knownSketchCostumeWithSameFormAs: lastEvent   liftPen  lowerPen makeBounceSound: maxPartsBankNumber maxScriptsBankNumber   newCostume  noteDeletionOf:fromWorld: okayToDestroyScriptNamed: okayToRemoveSlotNamed: owningPlayer  penColor: personalSlotNamesAndTypesForBank: phraseSpecFor: presenter  printOn: rawCostume: rememberCostume: removeSlotNamed: renameSlot: renameTo: renderedCostume: renderedCostumeRespondsTo: revealPlayerIn: revertToUnscriptedPlayerIfAppropriate runAllClosingScripts runAllOpeningScripts runAllTickingScripts scriptEditorFor: scriptEvaluatorFor:phrase: scriptInstantiationForSelector: scriptPerformer seesColor: sendMessageToCostume: sendMessageToCostume:with: setBorderColor: setBorderWidth: setBottom: setColor: setCostume: setCostumeSlot:toValue: setCursor: setHeading: setHeight: setLeft: setName: setPenColor: setPenDown: setPenSize: setRight: setRotationStyle: setScaleFactor: setTop: setValueAtCursor: setWidth: setX: setY:  slotInfo slotNames slotNamesAndTypesForViewerBank: slotPhraseFor:inViewer: standardCommandsForBank: standardSlotsForBank: standardWorldSlotsForBank: startRunning startRunningScripts  step stopProgramatically stopRunning  tearOffFancyWatcherFor: tearOffTileForSelf tearOffWatcherFor: thumbnailMenuEvt:forMorph: tileForArgType: tileForArgType:inViewer: tilePhraseSpecsForPlayerCategory: tilePhrasesForCategory:inViewer: tilePhrasesSpecsForCategory: tileReferringToSelf tileScriptCommands tileScriptCommandsForBank:  typeForSlot: typedCommandsForBank: unusedScriptName updateAllViewers valueOfType:from:  wearCostumeOfClass: wearCostumeOfName: wearSketchCostumeResembling: width  "! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/6/1998 17:24'!scriptHelp: aDictionary	ScriptHelp _ aDictionary.	Transcript cr; show: 'script help loaded; ', aDictionary size printString, ' entries.'! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 14:28'!scriptHelpFor: aSelector	| help |	help _ self scriptHelpOrNilFor: aSelector.	help ifNotNil: [^ help].	^ HelpStrings at: aSelector ifAbsent: ['sorry, no description yet provided for ', aSelector]! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 11/9/1998 14:27'!scriptHelpOrNilFor: aSelector	^ ScriptHelp at: aSelector ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 11/8/1998 18:02'!newScriptingSpace	"Answer a complete scripting space"	| aTemplate  palette aPlayfield aWindow |	aWindow _ (SystemWindow labelled: 'scripting area') model: ScriptingDomain new.	aWindow extent: 640 @ 480.	aTemplate _ PasteUpMorph new setNameTo: 'etoy'.	aTemplate extent: 638 @ 470.	aWindow addMorph: aTemplate frame: (0@0 corner: 1@1).	aTemplate setStandardTexture.	aTemplate impartPrivatePresenter; setProperty: #automaticPhraseExpansion toValue: true; beSticky.	palette _ TabbedPalette new pageSize: 200@320.	palette beSticky.	aTemplate addMorph: palette.	palette addMenuTab.	palette addPartsTab.	palette addControlsTab.	palette addScrapsTab.	"palette addViewerTab."	aPlayfield _ PasteUpMorph new setNameTo: 'playfield'.	(Preferences valueOfFlag: #eToyScheme)  "Not widely advertised"		ifFalse:				[aPlayfield setToAdhereToEdge: #topRight.			palette setToAdhereToEdge: #topLeft]		ifTrue:			[aPlayfield setToAdhereToEdge: #topLeft.			palette setToAdhereToEdge: #topRight].	aTemplate addMorph: aPlayfield.	aPlayfield extent: 340@300; position: aTemplate topRight - (400@0).	aPlayfield beSticky.	aPlayfield automaticViewing: true.	aPlayfield wantsMouseOverHalos: true.	aTemplate presenter standardPlayfield: aPlayfield.		^ aWindow! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 10/16/1998 09:22'!stripGraphicsForExternalRelease	"ScriptingSystem stripGraphicsForExternalRelease"	|  replacement |	replacement _ FormDictionary at: 'Gets'.	#('BadgeMiniPic' 'BadgePic' 'Broom' 'CedarPic' 'CollagePic' 'CoverMain' 'CoverSpiral' 'CoverTexture' 'Fred' 'ImagiPic' 'KayaPic' 'StudioPic')		do:			[:aKey | FormDictionary at: aKey put: replacement]! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/23/1998 15:34'!customPartsBin	CustomPartsBin ifNil: [self initializeCustomPartsBin].	^ CustomPartsBin veryDeepCopy! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/23/1998 15:28'!initializeCustomPartsBin	"ScriptingSystem initializeCustomPartsBin"	CustomPartsBin _ Presenter new standardPartsWindow! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/21/1998 23:14'!newStandardPartsBin	"StandardPartsBin _ nil"	StandardPartsBin ifNil:		[StandardPartsBin _ Presenter new newStandardPartsBinTitled: 'objects' includeControls: false].	^ StandardPartsBin fullCopy! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/27/1998 13:35'!resetStandardPartsBin	"ScriptingSystem resetStandardPartsBin"	StandardPartsBin _ nil! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 10/21/1998 23:08'!setCustomPartsBinFrom: aMorph	CustomPartsBin _ aMorph! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 10/26/1998 15:41'!initStandardScriptInfo	"ScriptingSystem initStandardScriptInfo"	StandardScriptInfo _ Dictionary new.	#(	(command beep: sound)		(command stopScript: string)		(command pauseScript: string)		(command startScript: string)		(command initiatePainting)		(command forward: number)		(command turn: number)		(command wearCostumeOf: player)		(command moveToward: player)		(command beep: sound)		(command show)		(command hide)		(command bounce: sound)		(command wrap)		(command goToRightOf: player)		(command stopScript: string)		(command pauseScript: string)		(command startScript: string)		(command liftAllPens)		(command lowerAllPens)		(command clearTurtleTrails)		(command goToNextCard)		(command goToPreviousCard)		(command newCard)		(command deleteCard)		(command initiatePainting)		(command nextPage)		(command previousPage)		(command firstPage)		(command lastPage)		(command goto: player ))	do:		[:anArray | StandardScriptInfo at: anArray second put: anArray]! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 10/22/1998 20:52'!initStandardSlotInfo	"ScriptingSystem initStandardSlotInfo"	StandardSlotInfo _ Dictionary new.	#((color			color		readWrite	getColor				setColor:)	(borderWidth 	number		readWrite	getBorderWidth	setBorderWidth:)	(borderColor		color		readWrite	getBorderColor	setBorderColor:)		(leftRight	number		readOnly	getLeftRight				unused)		(upDown	number		readOnly	getUpDown				unused)		(angle		number		readOnly	getAngle				unused)		(amount	number		readOnly	getAmount				unused)		(mouseX			number		readOnly	getMouseX			unused)		(mouseY		number		readOnly	getMouseY			unused)		(rotationStyle	rotationStyle									readWrite	getRotationStyle		setRotationStyle:)		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused)		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:)		(isOverColor	boolean		readOnly	dummy				unused)		(colorSees	boolean		readOnly	dummy				unused)		(isUnderMouse					boolean		readOnly	getIsUnderMouse		unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:))	do:		[:anArray | StandardSlotInfo at: anArray first put: anArray]! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 10/22/1998 20:51'!scriptInfoFor: aSlotName	^ StandardScriptInfo at: aSlotName ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 10/22/1998 20:53'!slotInfoFor: aSlotName	^ StandardSlotInfo at: aSlotName ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 11/5/1998 16:54'!goButton	| aButton |	aButton _  ThreePhaseButtonMorph new.	aButton image:  (ScriptingSystem formAtKey: 'GoPicOn');			offImage: (ScriptingSystem formAtKey: 'GoPic');			pressedImage: (ScriptingSystem formAtKey: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: aButton);			actWhen: #buttonUp;			target: self;			setNameTo: 'Go Button';			setProperty: #scriptingControl toValue: true;			setBalloonText:'Resume running all paused scripts'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:31'!goUp: evt with: aMorph	aMorph presenter startRunningScripts! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:59'!mouseUpBalk: evt! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 16:09'!scriptControlButtons	"World primaryHand attachMorph: ScriptingSystem scriptControlButtons"	| wrapper |	wrapper _ AlignmentMorph newRow setNameTo: 'script controls'.	wrapper vResizing: #shrinkWrap.	wrapper addMorph: self stopButton.	wrapper addMorphBack: self stepButton.	wrapper addMorphBack: self goButton.	wrapper beTransparent.	^ wrapper! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 11/5/1998 16:55'!stepButton	| aButton |	aButton _ ThreePhaseButtonMorph new.		aButton			image:  (ScriptingSystem formAtKey: 'StepPicOn');			offImage: (ScriptingSystem formAtKey: 'StepPic');			pressedImage:  (ScriptingSystem formAtKey: 'StepPicOn');			arguments: (Array with: nil with: aButton);			setNameTo: 'Step Button'; 			setProperty: #scriptingControl toValue: true;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every paused script exactly once.  Keep the mouse button down over "Step" and everything will keep running until you release it'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:33'!stepDown: evt with: aMorph	aMorph presenter stopRunningScripts! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:35'!stepStillDown: dummy with: theButton	theButton presenter stepStillDown: dummy with: theButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:35'!stepUp: evt with: aMorph	aMorph presenter stepUp: evt with: aMorph! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:50'!stopButton	"Answer a new button that can serve as a stop button"	| aButton |	aButton _ ThreePhaseButtonMorph new.	aButton		image:  (ScriptingSystem formAtKey: 'StopPic');		offImage: (ScriptingSystem formAtKey: 'StopPic');		pressedImage:  (ScriptingSystem formAtKey: 'StopPicOn').		aButton actionSelector: #stopUp:with:; 		arguments: (Array with: nil with: aButton);		actWhen: #buttonUp;		target: self;		setNameTo: 'Stop Button'; 		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Pause all ticking scripts.'.	^ aButton! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 10/30/1998 15:32'!stopUp: dummy with: theButton	| aPresenter |	(aPresenter _ theButton presenter) flushPlayerListCache.  "catch guys not in cache but who're running"	aPresenter stopRunningScripts! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:30'!brightColorFor: aColor	TypeColorDictionary do: [:pair |		(pair at: 1) = aColor ifTrue: [^ (pair at: 2)]].	^ aColor! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 15:58'!colorForType: typeSymbol	^ (TypeColorDictionary		at: typeSymbol asSymbol		ifAbsent: [^ Color magenta]) at: 1! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:18'!colorFudge	^ 0.4! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:49'!initializeTypeColors	"ScriptingSystem initializeTypeColors"	TypeColorDictionary _ IdentityDictionary new.	#(		(command		(0.065 0.258 1.0)		(0.065 0.258 1.0))	(number		(0.8 0.4 0.2)			(1.0	0.6 0.2))	(boolean		(0.94 1.0 0.06)		(0.94 1.0 0.06))  		"some kind of yellowish"	(player			(1.0  0 0.065)		(1.0  0 0.065)) 	(color			(1.0  0 0.065)		(0.806 1.0 0.806))  	"some damn dark red"	(sound			(1.0 0.06 0.84)		(1.0 0.06 0.84))   	"a kind of magenta"	(object			(1.0 0.26 0.98)		(1.0 0.26 0.98))   		(rotationStyle	(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(string			(0.0 0.0 1.0)			(0.0 0.0 1.0))      "not in use"	(group			(0.0 0.0 1.0)			(0.0 0.0 1.0))		 "not in use"	(costume		(0.806 1.0 0.806)	(0.806 1.0 0.806))		 "not in use")			do:		[:t | TypeColorDictionary at: t first put:			(Array 	with: 	((Color fromRgbTriplet: t second) mixed: self colorFudge with: ScriptingSystem uniformTileInteriorColor)					with:	(Color fromRgbTriplet: t third))]! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/29/1998 16:01'!unbrightColorFor: aColor	TypeColorDictionary do: [:pair |		(pair at: 2) = aColor ifTrue: [^ (pair at: 1)]].	^ aColor! !!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 10/22/1998 10:32'!initialize	"StandardScriptingSystem initialize"	"Sometimes this method is vacuously changed just to get it in a changeset so that its invocation will occur as part of an update"	Smalltalk at: #ScriptingSystem put: (self new initializeSystemSlotDictionary; initializeHelpStrings; yourself).	ScriptingSystem initStandardSlotInfo! !!EToySystem class methodsFor: 'development support' stamp: 'sw 10/16/1998 09:31'!stripMethodsForExternalRelease	"EToySystem stripMethodsForExternalRelease"	Utilities stripMethods: self methodsToStripForExternalRelease messageCode: '2.3External'! !!EToySystem class methodsFor: 'external release' stamp: 'sw 10/16/1998 09:30'!methodsToStripForExternalRelease	"Answer a list of triplets #(className, class/instance, methodName) of methods to be stripped in an external release."	^ #(		(EToySystem			class		serverUrls)		(EToySystem			class		prepareRelease)			(EToySystem			class		previewEToysOn:)		)! !!String methodsFor: 'converting' stamp: 'sw 11/5/1998 19:47'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	| listOfLines currentLast currentStart resultString putativeLast putativeLine crPosition |	listOfLines _ OrderedCollection new.	currentLast _ 0.	[currentLast < self size] whileTrue:		[currentStart _ currentLast + 1.		putativeLast _ (currentStart + aNumber - 1) min: self size.		putativeLine _ self copyFrom: currentStart to: putativeLast.		(crPosition _ putativeLine indexOf: Character cr) > 0 ifTrue:			[putativeLast _ currentStart + crPosition - 1.			putativeLine _ self copyFrom: currentStart to: putativeLast].		currentLast _ putativeLast == self size			ifTrue:				[putativeLast]			ifFalse:				[currentStart + putativeLine lastSpacePosition - 1].		currentLast <= currentStart ifTrue:			["line has NO spaces; baleout!!"			currentLast _ putativeLast].		listOfLines add: (self copyFrom: currentStart to: currentLast) withBlanksTrimmed].	listOfLines size > 0 ifFalse: [^ ''].	resultString _ listOfLines first.	2 to: listOfLines size do:		[:i | resultString _ resultString, String cr, (listOfLines at: i)].	^ resultString"#(5 7 20) collect:	[:i | 'Fred the bear went down to the brook to read his book in silence' withNoLineLongerThan: i]"! !!String methodsFor: 'testing' stamp: 'sw 11/5/1998 17:41'!lastSpacePosition	"Answer the character position of the final space or other separator character in the receiver, and 0 if none"	self size to: 1 by: -1 do:		[:i | ((self at: i) isSeparator) ifTrue: [^ i]].	^ 0"'fred the bear' lastSpacePosition'ziggie' lastSpacePosition'elvis ' lastSpacePosition'wimpy  ' lastSpacePosition'' lastSpacePosition"! !!StringButtonMorph methodsFor: 'events' stamp: 'sw 10/23/1998 15:57'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue:			[self color: (oldColor mixed: 1/2 with: Color white).			actWhen == #whilePressed ifTrue: [self doButtonAction]]		ifFalse: [self color: oldColor].! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 10/16/1998 11:36'!embeddedInMorphicWindowLabeled: labelString	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 10/16/1998 11:37'!openAsMorphLabel: labelString 	"Workspace new openAsMorphLabel: 'Workspace'"	(self embeddedInMorphicWindowLabeled: labelString) openInWorld! !!Browser methodsFor: 'initialize-release' stamp: 'sw 11/2/1998 13:32'!buildMorphicSwitches	| instanceSwitch commentSwitch classSwitch row |	instanceSwitch _ PluggableButtonMorph		on: self		getState: #instanceMessagesIndicated		action: #indicateInstanceMessages.	instanceSwitch		label: 'instance';		askBeforeChanging: true.	commentSwitch _ PluggableButtonMorph		on: self		getState: #classCommentIndicated		action: #editComment.	commentSwitch		label: '?' asText allBold asParagraph;		askBeforeChanging: true;		setBalloonText: 'class comment'.	classSwitch _ PluggableButtonMorph		on: self		getState: #classMessagesIndicated		action: #indicateClassMessages.	classSwitch		label: 'class';		askBeforeChanging: true.	row _ AlignmentMorph newRow		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 0;		borderColor: Color transparent;		addMorphBack: instanceSwitch;		addMorphBack: commentSwitch;		addMorphBack: classSwitch.	^ row! !!Debugger methodsFor: 'initialize' stamp: 'sw 10/15/1998 12:59'!buildMorphicNotifierLabelled: label message: messageString	| notifyPane window |	window _ (PreDebugWindow labelled: label) model: self.	notifyPane _ PluggableTextMorph on: self text: nil accept: nil		readSelection: nil menu: #debugProceedMenu:.	notifyPane editString: messageString;		askBeforeDiscardingEdits: false.	window addMorph: notifyPane frame: (0@0 corner: 1@1).	^ window openInWorldExtent: 350@116! !!SystemWindow methodsFor: 'initialization' stamp: 'sw 11/5/1998 10:26'!initialize	| aFont |	super initialize.	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	paneRects _ Array new.	borderColor _ #raised.	borderWidth _ 1.	color _ Color black.	aFont _ Preferences fontForScriptorButtons.	stripes _ Array with: (RectangleMorph newBounds: bounds)  "see extent:"				with: (RectangleMorph newBounds: bounds).	self addMorph: (stripes first borderWidth: 1).	self addMorph: (stripes second borderWidth: 2).	self addMorph: (label _ StringMorph new contents: labelString;			font: ((TextStyle default fontAt: 2) emphasized: 1)).	self addMorph: (closeBox _ SimpleButtonMorph new borderWidth: 0;			label: 'X' font: aFont; color: Color transparent;			actionSelector: #delete; target: self; extent: 16@16).	self addMorph: (collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 16@16).	Preferences noviceMode ifTrue:		[closeBox setBalloonText: 'close window'.		collapseBox 	setBalloonText: 'collapse/expand window'].	self on: #mouseEnter send: #spawnReframeHandle: to: self.	self on: #mouseLeave send: #spawnReframeHandle: to: self.	label on: #mouseDown send: #relabel to: self.	self extent: 300@200! !!SystemWindow methodsFor: 'geometry' stamp: 'sw 11/2/1998 14:23'!extent: newExtent	| inner labelRect paneColor |	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	paneColor _ Color colorFrom: model defaultBackgroundColor.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: paneColor.	closeBox align: closeBox topLeft with: inner topLeft + (4@0).	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: inner topCenter.	self setBoundsOfPaneMorphs.	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].! !!SystemWindow methodsFor: 'panes' stamp: 'sw 11/2/1998 14:23'!addMorph: aMorph frame: relFrame	| panelRect |	self addMorph: aMorph.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	paneRects _ paneRects copyReplaceFrom: 1 to: 0 with: (Array with: relFrame).	panelRect _ self panelRect.	aMorph borderWidth: 1;		color: (Color colorFrom: model defaultBackgroundColor);		bounds: ((relFrame scaleBy: panelRect extent) translateBy: panelRect topLeft) truncated.! !!SystemWindow methodsFor: 'panes' stamp: 'sw 11/2/1998 14:23'!paneColor	^ Color colorFrom: model defaultBackgroundColor! !!SystemWindow methodsFor: 'menu' stamp: 'sw 10/5/1998 14:56'!takeOutOfWindow	"Take the receiver's pane morph out the window and place it, naked, where once the window was"	| aMorph |	paneMorphs size == 1 ifFalse: [^ self beep].	aMorph _ paneMorphs first.	owner addMorphFront: aMorph.	self delete! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/9/1998 16:41'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'parts window controls...' action: #invokePartsWindowMenu! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/7/1998 21:48'!adjustBookControls	| inner |	prevButton ifNil: [^ self].	prevButton align: prevButton topLeft with: (inner _ self innerBounds) topLeft + (20@0).	nextButton align: nextButton topRight with: inner topRight - (20@0).	menuButton align: menuButton topLeft with: inner topLeft + (40@5).! !!PartsWindow methodsFor: 'all' stamp: 'sw 10/1/1998 10:10'!book: aBook	book _ aBook.	self addMorph: aBook frame: (0@0 extent: 1@1).	book beSticky.	book hResizing: #none; vResizing: #none.	nextButton target: aBook.	prevButton target: aBook! !!PartsWindow methodsFor: 'all' stamp: 'sw 9/30/1998 17:30'!closeEditing	openForEditing _ false.	self color: Color white.	book pages do:		[:aPage | aPage setPartsBinStatusTo: true]! !!PartsWindow methodsFor: 'all' stamp: 'sw 10/8/1998 13:44'!extent: newExtent	super extent: (newExtent max: 100 @ 50).	self adjustBookControls! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/7/1998 21:56'!initialize	| aFont aForm |	super initialize.	color _ Color white.	openForEditing _ false.	aFont _ Preferences fontForScriptorButtons.	self addMorph: (prevButton _ SimpleButtonMorph new borderWidth: 0;			label: '<' font: aFont; color: Color transparent;			setBalloonText: 'previous page';			actionSelector: #previousPage; target: self; extent: 16@16).	self addMorph: (nextButton _ SimpleButtonMorph new borderWidth: 0;			label: '>' font: aFont; color: Color transparent;			setBalloonText: 'next page';			actionSelector: #nextPage; target: self; extent: 16@16).	menuButton _ ThreePhaseButtonMorph new onImage: (aForm _ ScriptingSystem formAtKey: 'OfferToUnlock'); offImage: (ScriptingSystem formAtKey: 'OfferToLock'); pressedImage: (ScriptingSystem formAtKey: 'OfferToLock'); extent: aForm extent; state: #on.	menuButton target: self; actionSelector: #toggleStatus; actWhen: #buttonUp.	menuButton setBalloonText: 'open for editing'.	self addMorph: menuButton."	self addMorph: (menuButton _ SimpleButtonMorph new borderWidth: 0;			label: '¥' font: aFont; color: Color transparent;			actWhen: #buttonDown;			actionSelector: #invokePartsWindowMenu; target: self; extent: 16@16)."	self adjustBookControls! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/9/1998 17:35'!invokePartsWindowMenu	| aMenu sel |	aMenu _ MVCMenuMorph new.	openForEditing		ifTrue:			[aMenu add: 'resume being a parts bin' action:	#toggleStatus]		ifFalse:			[aMenu add: 'open for editing'			action:	#toggleStatus].	aMenu add: 'sort pages'	action: #sortPages.	aMenu add: 'save as Custom Parts Bin' action: #saveAsCustomPartsBin.	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel].! !!PartsWindow methodsFor: 'all' stamp: 'sw 9/30/1998 17:30'!openEditing	openForEditing _ true.	self color: Color green.	book pages do:		[:aPage | aPage setPartsBinStatusTo: false]! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/9/1998 17:37'!saveAsCustomPartsBin	| aBin |	self closeEditing.	aBin _ self veryDeepCopy.	ScriptingSystem setCustomPartsBinFrom: aBin.	self inform: 'Okay; from now on, when you request''custom parts bin'' from the ''authoring tools...''menu, you will obtain a copy of this parts bin'! !!PartsWindow methodsFor: 'all' stamp: 'sw 10/8/1998 13:57'!setBoundsOfPaneMorphs	| panelRect bookBorder bookExtent |	panelRect _ self panelRect.	book ifNotNil:		[book bounds: ((panelRect origin + (bookBorder _ book borderWidth asPoint)) 			extent: (bookExtent _ panelRect extent - (2 * bookBorder))).		book resizePagesTo: (bookExtent - (7 @ 7))]! !!PartsWindow methodsFor: 'all' stamp: 'sw 9/30/1998 17:12'!sortPages	book sortPages! !!PartsWindow methodsFor: 'all' stamp: 'sw 11/7/1998 21:56'!toggleStatus	openForEditing _ openForEditing not.	openForEditing		ifTrue:			[self openEditing.			menuButton state: #off.			menuButton setBalloonText: 'resume being a parts bin']		ifFalse:			[self closeEditing.			menuButton state: #on.			menuButton setBalloonText: 'open for editing']! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 11/4/1998 14:23'!adjustBookControls	| inner |	proceedButton ifNil: [^ self].	proceedButton align: proceedButton topLeft with: (inner _ self innerBounds) topLeft + (20@-4).	debugButton align: debugButton topRight with: inner topRight - (16@4).! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 10/15/1998 13:00'!debug	model debug! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 11/4/1998 09:50'!extent: newExtent	super extent: (newExtent max: 100 @ 50).	self adjustBookControls! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 11/4/1998 14:15'!initialize	| aFont proceedLabel debugLabel |	super initialize.	labelString size > 45 ifTrue: [^ self].   "No proceed/debug buttons if label too long"	labelString size > 25		ifTrue:			[proceedLabel _ 'p'.			debugLabel _ 'd']		ifFalse:			[proceedLabel _ 'proceed'.			debugLabel _ 'debug'].	aFont _ Preferences fontForScriptorButtons.	self addMorph: (proceedButton _ SimpleButtonMorph new borderWidth: 0;			label: proceedLabel font: aFont; color: Color transparent;			actionSelector: #proceed; target: self).	proceedButton setBalloonText: 'continue execution'.	self addMorph: (debugButton _ SimpleButtonMorph new borderWidth: 0;			label: debugLabel font: aFont; color: Color transparent;			actionSelector: #debug; target: self).	debugButton setBalloonText: 'bring up a debugger'.	proceedButton submorphs first color: Color blue.	debugButton submorphs first color: Color red.	self adjustBookControls! !!PreDebugWindow methodsFor: 'all' stamp: 'sw 10/15/1998 13:00'!proceed	model proceed! !!TabbedPalette reorganize!('initialization' addTabForBook: addTabForBook:withBalloonText: addTabNamed:color:atIndex: defaultPageSize initialize newTabs: setInitialState)('parts ^ controls tabs' addControlsTab addPartsTab)('scraps tab' addScrapsTab addToTrash: hasScrapsTab scrapsBook)('viewer tab' addViewerTab hasViewerTab oldViewMorph: selectViewerTab viewMorph: viewerBook viewerTab)('palette menu' addBookMenuItemsTo:hand: addMenuTab addScriptableTab addScriptableTabWithTitle: hasMenuTab showPaletteMenu)('misc menu items' becomeStandardPalette recolorTabs showNoPalette sortTabs:)('user-interface' repelsMorph:event: selectTab: selectTabNamed: selectTabOfBook: tabMorphs wantsDroppedMorph:event:)('miscellaneous' currentPalette releaseCachedState showPageTurningFeedbackFromOrigin:ascending: succeededInRevealing: tabsMorph)!!TabbedPalette methodsFor: 'initialization' stamp: 'sw 10/29/1998 17:35'!addTabForBook: aBook withBalloonText: text	| aTab |	aTab _ tabsMorph addTabForBook: aBook.	pages add: aBook.	currentPage ifNil: [currentPage _ aBook].	text ifNotNil: [aTab setBalloonText: text].	^ aTab! !!TabbedPalette methodsFor: 'parts ^ controls tabs' stamp: 'sw 10/29/1998 17:37'!addControlsTab	| controlWrapper controlPage |	controlPage _ AlignmentMorph newColumn beSticky color: Color white.	controlWrapper _ AlignmentMorph newRow beSticky vResizing: #spaceFill; color: Color white.	controlWrapper centering: #center.	controlWrapper addMorphBack: AlignmentMorph newColumn beTransparent.	controlWrapper addMorphBack: self presenter controlPanel beSticky.	controlWrapper addMorphBack: AlignmentMorph newColumn beTransparent.	controlPage addMorphBack: controlWrapper.	controlPage addMorphBack: (Morph new beTransparent extent: (1 @ 10)).	controlPage addMorphBack: RecordingControlsMorph newSticky.	controlPage setNameTo: 'Controls'.	self addTabForBook: controlPage  withBalloonText:'recording controls, andcontrols to turn sound,balloon help, etc., on and off'! !!TabbedPalette methodsFor: 'parts ^ controls tabs' stamp: 'sw 10/29/1998 17:39'!addPartsTab	| partsBook aPage |	partsBook _ BookMorph new pageSize: pageSize; setNameTo: 'Supplies'.	partsBook removeEverything.	aPage _ self presenter newPageForStandardPartsBin.	aPage extent: pageSize.	#(PaintInvokingMorph RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph   StringMorph) do:		[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].	aPage replaceTallSubmorphsByThumbnails.	aPage fixLayout.	partsBook insertPage: aPage pageSize: pageSize.	self addTabForBook: partsBook withBalloonText: 'parts bin'! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 11/7/1998 22:49'!addScrapsTab	| scrapsBook |	scrapsBook _ BookMorph new pageSize: pageSize; setNameTo: 'Scraps'.	scrapsBook removeEverything; showPageControls; insertPage.	scrapsBook currentPage addMorph: (SketchMorph new form: ScriptingSystem squeakyMouseForm).	scrapsBook setProperty: #scraps toValue: true.	self addTabForBook: scrapsBook  withBalloonText: 'a storage place for anything; also, objects dragged into the trash can will be found here.'.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 11/7/1998 22:53'!addViewerTab	| viewerBook |	"A now disused branch, though it may be invoked in some grandfathered palettes"	viewerBook _ ViewerBook new removeEverything setNameTo: 'view'.	self addTabForBook: viewerBook.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/30/1998 18:35'!oldViewMorph: aMorph	"View the morph using the old type of viewer."	| aPlayer currentViewer viewerBook |	self hasViewerTab ifFalse:		[self addViewerTab].	self visible: false.	aPlayer _ aMorph assuredPlayer.	viewerBook _ self viewerBook.  "Just to make this code easier to read"	(currentViewer _ viewerBook currentPage)		ifNil:			[currentViewer _ viewerBook setPlayer: aPlayer]		ifNotNil:			[currentViewer scriptedPlayer == aPlayer				ifFalse:					[currentViewer setPlayer: aPlayer]				ifTrue:					[currentViewer isInWorld ifFalse: [self halt]]].	"currentViewer makeAllTilesGreen. "  "yecch; overkill"	 "This stuff is generally still weird and objectionable, but since the PartsViewer path is being abandoned, to hell with it. "	self presenter flushPlayerListCache.  "A precaution in case aMorph is no longer in world, owing to palette sharing.  This is not very attractive"	self selectViewerTab.	self snapToEdgeIfAppropriate.	self visible: true.	currentViewer visible: true"	self layoutChanged.	self ownerChanged.	self world displayWorld"! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/15/1998 12:45'!selectViewerTab	| viewerTab |	(viewerTab _ self viewerTab) ifNil: [^ self beep].	^ self selectTab: viewerTab! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/25/1998 22:37'!viewMorph: aMorph	"The receiver is expected to have a viewer tab; select it, and target it to aMorph"	| aPlayer aViewer |	Preferences useNewViewers ifFalse: [^ self oldViewMorph: aMorph].	((currentPage isKindOf: Viewer) and: [currentPage scriptedPlayer == aMorph player])		ifTrue:			[^ self].	self visible: false.	aPlayer _ aMorph assuredPlayer.	aViewer _  StandardViewer new initializeFor: aPlayer.	self showNoPalette.	currentPage ifNotNil: [currentPage delete].	self addMorphBack: (currentPage _ aViewer).	self snapToEdgeIfAppropriate..	self world startSteppingSubmorphsOf: aViewer.	self visible: true! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 10/15/1998 12:44'!viewerTab	^ tabsMorph submorphs detect: [:m | m morphToInstall isKindOf: ViewerBook] ifNone: [nil]! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 11/7/1998 22:50'!addMenuTab	| aTab |	aTab _ self tabsMorph addActionTabWithTitle: '<>'.	aTab target: self; actionSelector: #showPaletteMenu;		setProperty: #tabsMenu toValue: true;		setBalloonText: 'menu';		actWhen: #buttonDown! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 11/7/1998 22:53'!showPaletteMenu	| aMenu evt |	evt _ self primaryHand lastEvent.	aMenu _ MenuMorph new defaultTarget: self.	self currentPalette ifNotNil:		[aMenu add:  'clear' action: #showNoPalette.		aMenu addLine].	aMenu add:  'sort tabs' action: #sortTabs:.	aMenu add:  'choose new colors for tabs' action: #recolorTabs.	(self presenter standardPaletteIsAlready: self) ifFalse:		[aMenu add:  'make me the Standard palette' action: #becomeStandardPalette].	aMenu addLine.	self hasScrapsTab ifFalse:	[aMenu add:  'add "scraps" tab' action: #addScrapsTab].	aMenu add: 'add a tab for me to script' action: #addScriptableTab.	aMenu addTitle: 'Palette'.	aMenu popUpAt: self cursorPoint event: evt! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 10/15/1998 15:51'!showNoPalette	| aMenuTab |	currentPage ifNotNil: [currentPage delete].	currentPage _ nil.	(aMenuTab _ tabsMorph submorphWithProperty: #tabsMenu) ifNotNil:		[tabsMorph highlightTab: aMenuTab].	"self snapToEdgeIfAppropriate"! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 10/19/1998 23:53'!selectTab: aTab	| currentPalette |	(currentPage notNil and: [(currentPage hasProperty: #placeHolder) not]) ifTrue:		[self currentPalette currentPlayerDo:			[:aPlayer | aPlayer runAllClosingScripts]].	tabsMorph selectTab: aTab.	self goToPageMorph: aTab morphToInstall.	(currentPalette _ self currentPalette) ifNotNil:		[currentPalette layoutChanged.		currentPalette currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts]].	self snapToEdgeIfAppropriate.! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 10/19/1998 23:50'!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	self visible ifFalse: [^ self].	(PageFlipSoundOn and: [oldOrigin ~~ nil])		ifTrue:			[Display fadeImageHorFine: currentPage imageForm at: oldOrigin]! !!TabbedPalette class methodsFor: 'all' stamp: 'sw 10/16/1998 11:30'!authoringPrototype	| aTabbedPalette aBook aTab |	aTabbedPalette _ self new markAsPartsDonor.	aTabbedPalette pageSize: 200 @ 300.	aTabbedPalette tabsMorph highlightColor: Color red regularColor: Color blue.	aTabbedPalette addMenuTab.	aBook _ BookMorph new setNameTo: 'one'; pageSize: aTabbedPalette pageSize.	aBook color: Color blue muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: (SketchMorph new form: ScriptingSystem squeakyMouseForm).	aTab _ aTabbedPalette addTabForBook: aBook.	aBook _ BookMorph new setNameTo: 'two'; pageSize: aTabbedPalette pageSize.	aBook color: Color red muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: CurveMorph authoringPrototype.	aTabbedPalette addTabForBook: aBook.	aTabbedPalette selectTab: aTab.	aTabbedPalette beSticky.	^ aTabbedPalette! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'sw 10/18/1998 10:17'!tempCommand: characterStream 	"Experimental.  Triggered by Cmd-t; put trial cmd-key commands here to see how they work, before hanging them on their own cmd accelerators."	Sensor keyboard.	morph tempCommand.	^ true! !!TextMorphForEditView methodsFor: 'debugging' stamp: 'sw 11/2/1998 15:51'!tempCommand	"Smalltalk browseAllImplementorsOf: #tempCommand"	"Place your definition for tempCommand for this class here"! !!TileMorph methodsFor: 'accessing' stamp: 'sw 11/6/1998 11:02'!associatedPlayer	^ actualObject! !!TileMorph methodsFor: 'accessing' stamp: 'sw 10/21/1998 15:55'!playerBearingCode	"Answer the actual Player object who will be the 'self' when the receiver is being asked to generate code"	| anEditor |	(anEditor _ self topEditor) ifNotNil: [^ anEditor playerScripted].	^ (self nearestOwnerThat: [:m | m isAViewer]) scriptedPlayer! !!TileMorph methodsFor: 'accessing' stamp: 'sw 11/9/1998 14:18'!slotName	"Caution: the slotName is not in use!!"	^ slotName! !!TileMorph methodsFor: 'arrows' stamp: 'sw 10/21/1998 09:45'!showSuffixChoices	| plus phrase pad outer num |	(phrase _ self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	(type == #literal) & (literal isNumber) ifTrue: ["Tile is a constant number"		phrase lastSubmorph == owner "pad"			ifTrue: ["we are adding the first time (at end of our phrase)"				plus _ self presenter phraseForReceiver: literal 						op: #+ arg: 1 resultType: #number.				owner acceptDroppingMorph: plus event: self primaryHand lastEvent.				num _ plus firstSubmorph firstSubmorph.				num deleteSuffixArrow]].	type == #operator ifTrue: ["Tile is accessor of an expression"		phrase resultType == #number ifTrue:			[outer _ phrase ownerThatIsA: PhraseTileMorph.			pad _ self ownerThatIsA: TilePadMorph.			outer ifNotNil:				[outer lastSubmorph == pad ifTrue: [ "first time"					plus _ self presenter phraseForReceiver: 1 							op: #+ arg: 1 resultType: #number.					pad acceptDroppingMorph: plus event: self primaryHand lastEvent.					(plus firstSubmorph) removeAllMorphs.					(plus firstSubmorph) addMorph: phrase.	"car's heading"					self deleteSuffixArrow]]]].	phrase presenter harmonizeTileColorPolicyFor: (phrase topEditor ifNil: [phrase])! !!ColorTileMorph methodsFor: 'other' stamp: 'sw 10/25/1998 00:25'!colorSwatch	^ colorSwatch! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 10/29/1998 16:06'!initialize	| m1 m2 |	super initialize.	self typeColor: (ScriptingSystem colorForType: #number).	self addArrows.	m1 _ StringMorph contents: 'random' font: ScriptingSystem fontForTiles.	self addMorph: m1.	m2 _ StringMorph contents: '180' font: ScriptingSystem fontForTiles.	m2 position: m1 topRight.	self addMorphBack: m2.	literal _ 180.	self updateLiteralLabel! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:07'!mouseEnter: evt	"Show drag/drop feedback."	| h m |	h _ evt hand.	h submorphCount ~= 1 ifTrue: [^ self].	m _ h firstSubmorph.	(self canAccept: m) ifTrue:		[self color: (ScriptingSystem brightColorForType: type).		self submorphsDo: [:subM |			(subM isKindOf: TileMorph) ifTrue:				[subM color: (ScriptingSystem brightColorFor: subM color)]]].! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:08'!mouseLeave: evt	"Clear drag/drop feedback."	color ~= (ScriptingSystem colorForType: type) ifTrue:		[self color: (ScriptingSystem colorForType: type).		self submorphsDo: [:subM |			(subM isKindOf: TileMorph) ifTrue:				[subM color: (ScriptingSystem unbrightColorFor: subM color)]]].! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:08'!rootForGrabOf: aMorph	"Allow submorph to be extracted."	| root |true ifTrue: [^ super rootForGrabOf: aMorph].	self inPartsBin ifTrue: [^ super rootForGrabOf: aMorph].	root _ aMorph.	[root = self] whileFalse:		[root owner = self ifTrue:			[root color: (ScriptingSystem colorForType: root resultType).			^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/29/1998 16:08'!setType: aSymbol	type _ aSymbol.	self color: (ScriptingSystem colorForType: type).	self extent: (TileMorph defaultW)@(TileMorph defaultH).! !!TrashCanMorph methodsFor: 'initialization' stamp: 'sw 11/5/1998 16:55'!initialize	super initialize.	self image: TrashPicOn;		offImage: TrashPic;		pressedImage: TrashPicOn.	self setNameTo: 'Trash'.	self setProperty: #scriptingControl toValue: true.	self setBalloonText:'To remove an object, drop it on this trash can.'.! !!TrashCanMorph methodsFor: 'event handling' stamp: 'sw 10/30/1998 15:57'!handlesMouseDown: evt	^ self inPartsBin not! !!UndefinedObject methodsFor: 'printing' stamp: 'sw 10/29/1998 16:34'!newTileMorphRepresentative	^ UndescribedTile new! !!UndescribedTile methodsFor: 'all' stamp: 'sw 10/29/1998 16:45'!initialize	super initialize.	self extent: (20 @ 22)! !!UpdatingRectangleMorph methodsFor: 'display' stamp: 'sw 10/24/1998 21:23'!drawOn: aCanvas 	"Copied down from BorderedMorph, with the substitution that the color inst var of the receiver here might well be something like #raised or some other symbol, which the frameAndFillRectangle... methods barf on."	| insetColor colorToFill |	colorToFill _ (color isKindOf: Color) ifTrue: [color] ifFalse: [Color gray].	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self].	borderColor == #raised ifTrue:		[^ aCanvas frameAndFillRectangle: bounds			fillColor: colorToFill			borderWidth: borderWidth			topLeftColor: colorToFill lighter			bottomRightColor: colorToFill darker].	borderColor == #inset ifTrue:		[insetColor _ owner colorForInsets.		^ aCanvas frameAndFillRectangle: bounds			fillColor: colorToFill			borderWidth: borderWidth			topLeftColor: insetColor darker			bottomRightColor: insetColor lighter].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: colorToFill		borderWidth: borderWidth		borderColor: borderColor.! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 10/25/1998 00:53'!acceptValueFromTarget: v	lastValue _ v.	format = #string ifTrue: [^ v].	(format = #default and: [v isNumber]) ifTrue:		[v isInteger ifTrue: [^ v asInteger printString].		(v isKindOf: Float) ifTrue: [^ (v roundTo: self floatPrecision) printString]].	^ v printString! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 10/25/1998 00:56'!readFromTarget	| v |	((target == nil) or: [getSelector == nil]) ifTrue: [^ contents].	v _ target scriptPerformer perform: getSelector.	^ self acceptValueFromTarget: v! !!UpdatingStringMorphWithArgument methodsFor: 'as yet unclassified' stamp: 'sw 10/25/1998 00:57'!readFromTarget	| v |	argumentTarget ifNil: [^ super readFromTarget].	v _ target perform: getSelector with: (argumentTarget perform: argumentGetSelector).	^ self acceptValueFromTarget: v! !!UpdatingStringMorphWithArgument methodsFor: 'all' stamp: 'sw 10/25/1998 00:20'!argumentTarget: t argumentGetSelector: s	argumentTarget _ t.	argumentGetSelector _ s! !!Utilities class methodsFor: 'common requests' stamp: 'sw 10/15/1998 15:14'!closeAllDebuggers	"Utilities closeAllDebuggers"	Smalltalk isMorphic	ifTrue:		[(SystemWindow allSubInstances select: [:w | w model isKindOf: Debugger])			do: [:w | w delete]]	ifFalse:		[(StandardSystemController allInstances select: [:w | w model isKindOf: Debugger])			do: [:w | w closeAndUnscheduleNoTerminate]]! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 11/2/1998 14:27'!windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList title: aTitle	| aWorld colorList  pos delta aButton  rightmost widthToUse |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aWorld _ WorldMorph new.	colorList _  (1 to: labelList size) collect:		[:ind | Color colorFrom: (colorPattern at: (ind \\ colorPattern size + 1))].				pos _ 4 @ 6.	delta _ 0 @ 30.	rightmost _ 0.	1 to: labelList size do:		[:index |			aButton _ SimpleButtonMorph new.			aButton label: (labelList at: index); 				color: (colorList at: index); 				target: (targetList at: index);				actionSelector: (selectionList at: index);				position: pos.			rightmost _ rightmost max: aButton right.			pos _ pos + delta.			aWorld addMorphBack: aButton].	widthToUse _ rightmost + 10.	aWorld submorphs do:		[:m | m position: (((widthToUse - m width) // 2) @ m position y)].	aWorld setProperty: #initialExtent toValue: (widthToUse @ (aButton bottom + 10)).	aWorld openWithTitle: aTitle cautionOnClose: false! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:34'!backgroundColor	Display depth <= 2 ifTrue: [^ Color white].	insideColor ifNotNil: [^ Color colorFrom: insideColor].	^ superView == nil		ifFalse: [superView backgroundColor]		ifTrue:	[Color white]! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:35'!foregroundColor	borderColor ifNotNil: [^ Color colorFrom: borderColor].	^ superView == nil		ifFalse: [superView foregroundColor]		ifTrue:	[Color black]! !!Viewer methodsFor: 'all' stamp: 'sw 10/29/1998 16:08'!colorSeesPhrase	| outerPhrase |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #color.	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs at: 2) delete.	"operator"	outerPhrase addMorphBack: ColorSeerTile new.	(outerPhrase submorphs at: 2) goBehind.		"Make it third"	outerPhrase submorphs last addMorph: (ColorTileMorph new typeColor: 		(ScriptingSystem colorForType: #color)).	^ outerPhrase! !!Viewer methodsFor: 'all' stamp: 'sw 10/22/1998 12:25'!controlButtonColor	^ Color blue muchLighter! !!Viewer methodsFor: 'all' stamp: 'sw 10/21/1998 15:55'!isAViewer	^ true! !!Viewer methodsFor: 'all' stamp: 'sw 10/22/1998 12:28'!newEmptyScript	| aMorph |	self scriptedPlayer assureUniClass.	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'newScript').	aMorph setProperty: #newAnonymousScript toValue: true.	aMorph setProperty: #player toValue: self scriptedPlayer.	self primaryHand attachMorph: aMorph! !!Viewer methodsFor: 'all' stamp: 'sw 10/27/1998 14:19'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updateViewer: self! !!Viewer methodsFor: 'all' stamp: 'sw 11/5/1998 15:48'!noteDeletionOf: aMorph	| pal |	aMorph player == scriptedPlayer ifTrue:		[(pal _ self standardPalette)			ifNotNil: [pal showNoPalette]			ifNil:	[self delete]]   "Viewer on a discarded player"! !!Viewer methodsFor: 'all' stamp: 'sw 10/22/1998 20:32'!obtainBankInfoFrom: anotherViewer	"Grandfathered in from old archictecture.   Probably dubious"! !!Viewer methodsFor: 'all' stamp: 'sw 10/27/1998 14:19'!previousCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[aList size]		ifNotNil:	[anIndex - 1].	newIndex < 1 ifTrue: [newIndex _ aList size].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updateViewer: self! !!Viewer methodsFor: 'all' stamp: 'sw 10/21/1998 15:56'!scriptedPlayer	^ scriptedPlayer! !!Viewer methodsFor: 'all' stamp: 'sw 10/20/1998 13:20'!scriptedPlayer: aPlayer	scriptedPlayer _ aPlayer! !!Viewer methodsFor: 'all' stamp: 'sw 10/29/1998 16:09'!seesColorPhrase	| outerPhrase seesColorTile |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #color.	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs at: 2) delete.	"operator"	seesColorTile _ TileMorph new setOperator: #seesColor:.	outerPhrase addMorphBack: seesColorTile.	(outerPhrase submorphs at: 2) goBehind.		"Make it third""	selfTile _ self tileForSelf bePossessive.	Done by caller.	selfTile position: 1.	outerPhrase firstSubmorph addMorph: selfTile."	outerPhrase submorphs last addMorph: (ColorTileMorph new typeColor: 		(ScriptingSystem colorForType: #color)).	^ outerPhrase! !!Viewer methodsFor: 'all' stamp: 'sw 10/23/1998 09:10'!setPlayer: aPlayer	"bridging to old interface"	self initializeFor: aPlayer! !!CategoryViewer commentStamp: 'sw 11/9/1998 18:53' prior: 0!A viewer on an object.  Consists of three panes:   Header pane -- category-name, arrows for moving among categories, etc.   List pane -- contents are a list of subparts in the chosen category.   Editing pane -- optional, a detail pane with info relating to the selected element of the list pane.!!CategoryViewer methodsFor: 'initialization' stamp: 'sw 10/24/1998 23:10'!initializeFor: aPlayer	^ self initializeFor: aPlayer categoryChoice: 'basic'! !!CategoryViewer methodsFor: 'initialization' stamp: 'sw 10/25/1998 22:28'!initializeFor: aPlayer categoryChoice: aChoice	self orientation: #vertical;		hResizing: #spaceFill;		vResizing: #spaceFill;		borderWidth: 1;		beSticky.	self color: Color green muchLighter muchLighter.	scriptedPlayer _ aPlayer.	self addHeaderMorph.	self categoryChoice: aChoice! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 11/9/1998 16:15'!categoryChoice: aCategory	| bin |	namePane contents: aCategory; color: Color black.	bin _ PhraseWrapperMorph new		borderWidth: 0;		orientation: #vertical.	bin addAllMorphs:		((scriptedPlayer tilePhrasesForCategory: aCategory inViewer: self) collect:			[:aViewerRow | self viewerEntryFor: aViewerRow]).	bin enforceTileColorPolicy.	submorphs size < 2		ifTrue:			[self addMorphBack: bin]		ifFalse:			[self replaceSubmorph: self listPane by: bin].	self world ifNotNil: [self world startSteppingSubmorphsOf: self]! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 11/3/1998 13:22'!chooseCategory	"The mouse went down on the receiver; pop up a list of category choices"	| aList aMenu reply aLinePosition lineList |	aList _ scriptedPlayer categories.	aLinePosition _ aList indexOf: 'miscellaneous' ifAbsent: [nil].	lineList _ aLinePosition ifNil: [#()] ifNotNil: [Array with: aLinePosition].	aMenu _ CustomMenu labels: aList lines: lineList selections: aList.	reply _ aMenu startUpWithCaption: 'category'.	reply ifNil: [^ self].	self categoryChoice: reply! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/21/1998 14:09'!currentCategory	^ namePane contents! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/24/1998 14:24'!downArrowHit	self previousCategory! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/21/1998 16:28'!nextCategory	| aList anIndex newIndex |	aList _ scriptedPlayer categories.	anIndex _ aList indexOf: self currentCategory ifAbsent: [0].	newIndex _ anIndex = aList size		ifTrue:		[1]		ifFalse:		[anIndex + 1].	self categoryChoice: (aList at: newIndex)! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/21/1998 16:31'!previousCategory	| aList anIndex newIndex |	aList _ scriptedPlayer categories.	anIndex _ aList indexOf: self currentCategory ifAbsent: [aList size + 1].	newIndex _ anIndex = 1		ifTrue:		[aList size]		ifFalse:		[anIndex - 1].	self categoryChoice: (aList at: newIndex)! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/24/1998 14:25'!upArrowHit	self nextCategory! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 11/5/1998 09:09'!viewerEntryFor: aViewerRow	| anEntry |	anEntry _ ViewerEntry newColumn.	anEntry addMorphBack: aViewerRow.	^ anEntry! !!CategoryViewer methodsFor: 'editing pane' stamp: 'sw 10/30/1998 18:16'!contents: c notifying: k	"later, spruce this up so that it can accept input such as new method source"	self beep.	^ false! !!CategoryViewer methodsFor: 'header pane' stamp: 'sw 11/5/1998 20:21'!addHeaderMorph	| header aFont aButton wrpr |	header _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	header addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Delete this Viewer'.	header addTransparentSpacerOfSize: 5@5.	header addUpDownArrowsFor: self.	header beSticky.	self addMorph: header.	(wrpr _ header submorphs last) submorphs second setBalloonText: 'previous category'.		wrpr submorphs first  setBalloonText: 'next category'.		namePane _ (StringButtonMorph contents: '-----' "font: ScriptingSystem fontForScriptorButtons") color: Color black.	namePane target: self; arguments: Array new; actionSelector: #chooseCategory.	namePane actWhen: #buttonDown.	namePane align: namePane topLeft with: (bounds topLeft + (50 @ 0)).	namePane setBalloonText: 'category'.	header addMorphBack: namePane.	self categoryChoice: 'basic'! !!CategoryViewer methodsFor: 'header pane' stamp: 'sw 10/27/1998 14:19'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updateViewer: self! !!CategoryViewer methodsFor: 'list pane' stamp: 'sw 10/23/1998 13:50'!listPane	^ submorphs second! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 10/30/1998 18:23'!addIsOverColorDetailTo: aRow	| clrTile readout aTile |	aRow addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer".	aRow addMorphBack: (clrTile _ Color blue newTileMorphRepresentative).	aRow addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"	readout _ UpdatingStringMorphWithArgument new			target: scriptedPlayer; getSelector: #seesColor:; growable: false; putSelector: nil;			argumentTarget: clrTile colorSwatch argumentGetSelector: #color.	readout useDefaultFormat.	aTile _ StringReadoutTile new typeColor: Color lightGray lighter.	aTile addMorphBack: readout.	aRow addMorphBack: aTile.	aTile setLiteralTo: (scriptedPlayer seesColor: clrTile colorSwatch color) printString width: 30! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 11/9/1998 14:14'!infoButtonFor: aSlotName	| aButton isUserSlot |	isUserSlot _ scriptedPlayer slotInfo includesKey: aSlotName asSymbol.	aButton _ SimpleButtonMorph new.	aButton target: scriptedPlayer;		actionSelector: #infoFor:;		arguments: (Array with: aSlotName);		label: '¥' font: (StrikeFont familyName: #ComicBold size: 16);		color: Color transparent;		borderWidth: 0;		actWhen: #buttonDown.	aButton setBalloonText: 'menu'.	"aButton balloonTextSelector: (isUserSlot		ifFalse:	[aSlotName]		ifTrue:	[#userSlot])."	^ aButton! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 11/7/1998 22:31'!phraseForSlot: slotName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Return a PhraseTileMorph representing the slot in the viewer"	| r anArrow |	r _ ViewerRow newRow		color: self color;		beSticky;		centering: #center.	r addDetailButton.	r addMorphBack: (self infoButtonFor: slotName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: self tileForSelf bePossessive.	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self getterButtonFor: slotName type: partType).	(slotName == #isOverColor)		ifTrue:			[self addIsOverColorDetailTo: r]		ifFalse:			[readOnly ifFalse:				[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"				r addMorphBack: (anArrow _ self arrowSetterButtonFor: slotName type: partType)].			r addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"			(#(colorSees) includes: slotName) ifFalse:		 		[r addMorphBack: (self readoutFor: slotName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector)]].	anArrow ifNotNil: [anArrow step].	^ r! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 11/7/1998 22:37'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new		target: scriptedPlayer costume;		getSelector: (Utilities getterSelectorFor: partName);		borderWidth: 1;		extent:  22@22.		putSelector == #unused ifFalse: [readout putSelector: (Utilities setterSelectorFor: partName)]].	readout ifNil: [readout _ scriptedPlayer costume updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/29/1998 15:59'!arrowSetterButtonFor: partName type: partType	| m |	m _ RectangleMorph new		color: (ScriptingSystem colorForType: #command);		extent: 24@TileMorph defaultH;		borderWidth: 1.	m addMorphCentered: (ImageMorph new image: (ScriptingSystem formAtKey: 'Gets')).	m on: #mouseDown send: #makeSetter:from:forPart:		to: self		withValue: (Array with: partName with: partType).	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/29/1998 15:59'!getterButtonFor: partName type: partType	| m |	m _ TileMorph new setOperator: partName.	m typeColor: (ScriptingSystem colorForType: partType).	m on: #mouseDown send: #makeGetter:from:forPart:		to: self		withValue: (Array with: partName with: partType).	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/21/1998 16:44'!makeGetter: evt from: aMorph forPart: args	| m selfTile selector aType firstArg |	(aType _ args last) == #unknown ifTrue: [^ self beep].	(#(colorSees isOverColor) includes: (firstArg _ args first))		ifFalse:			[m _ PhraseTileMorph new setSlotRefOperator: args first asSymbol type: aType]		ifTrue:			[(firstArg == #colorSees) ifTrue: [m _ self colorSeesPhrase].			(firstArg == #isOverColor) ifTrue: [m _ self seesColorPhrase]].	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	selector _ m submorphs at: 2.	(aType == #number) ifTrue:		[selector addSuffixArrow].	selector updateLiteralLabel.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 10/29/1998 16:04'!makeSetter: evt from: aMorph forPart: args	| argType m argTile selfTile |	argType _ args last.	m _ PhraseTileMorph new setAssignmentRoot: args first asSymbol		type: #command		rcvrType: #player		argType: argType.	argTile _ scriptedPlayer tileForArgType: argType inViewer: self.	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/30/1998 18:15'!contentsSelection	"Not well understood why this needs to be here!!"	^ 1 to: 0! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/24/1998 23:41'!obtainBankInfoFrom: aViewer	self categoryChoice: aViewer currentCategory! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/29/1998 15:59'!tileForPlayer: aPlayer	"Return a tile representing aPlayer"	^ TileMorph new		setObjectRef: nil "disused parm" actualObject: aPlayer;		typeColor: (ScriptingSystem colorForType: #player)! !!CategoryViewer methodsFor: 'support' stamp: 'sw 10/21/1998 14:55'!tileForSelf	"Return a tile representing the target morph itself."	^ self tileForPlayer: scriptedPlayer! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/23/1998 21:54'!addCategoryViewer		| aCategory |	aCategory _ self categoryNotCurrentlyViewing.	self addCategoryViewerFor: aCategory! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/27/1998 21:19'!addCategoryViewerFor: aStartingCategory	| aViewer |	self addMorphBack: (aViewer _ CategoryViewer new initializeFor: scriptedPlayer categoryChoice: aStartingCategory).	self world ifNotNil: [self world startSteppingSubmorphsOf: aViewer]! !!StandardViewer methodsFor: 'all' stamp: 'sw 11/5/1998 16:11'!addHeaderMorph	| header aFont aButton aTextMorph nail wrpr costs |	header _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	header addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #dismiss;			setBalloonText: 'Delete'.	header addTransparentSpacerOfSize: 4@1.	header addMorphBack: (aButton _ SimpleButtonMorph new label: '+' font: aFont).	aButton target: self; beTransparent;			actionSelector: #addCategoryViewer;			setBalloonText: 'click here to addanother viewer'.	header addTransparentSpacerOfSize: 4@1.	(((costs _ scriptedPlayer costumes) size > 1) or: [costs size == 1 and: [costs first ~~ scriptedPlayer costume]]) ifTrue:		[header addUpDownArrowsFor: self.		(wrpr _ header submorphs last) submorphs second setBalloonText: 'switch to previous costume'.			wrpr submorphs first  setBalloonText: 'switch to next costume'].		nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	header addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.		header addTransparentSpacerOfSize: 5@5."	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'S' font: (aFont _ StrikeFont familyName: #ComicBold size: 16);  color: Color transparent; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		header addMorphBack: aButton.	header addTransparentSpacerOfSize: 8@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'I' font: aFont;  color: Color transparent; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 5@5."	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	aTextMorph step.	header  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		header beSticky.	self addMorph: header! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/30/1998 18:38'!categoryMorphs	^ self submorphsSatisfying: [:m | m isKindOf: CategoryViewer]! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/24/1998 23:11'!categoryNotCurrentlyViewing	| aList |	aList _ scriptedPlayer categories asOrderedCollection.	self categoryMorphs do:		[:m | aList remove: m currentCategory ifAbsent: []].	^ aList size > 0		ifTrue:			[aList first]		ifFalse:			['basic']! !!StandardViewer methodsFor: 'all' stamp: 'sw 11/5/1998 16:15'!dismiss	"User hit the dismiss button."	(owner isKindOf: TabbedPalette)		ifTrue:			[^ owner showNoPalette].	self delete! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/24/1998 14:34'!downArrowHit	self nextCostume! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/27/1998 09:24'!initializeFor: aPlayer	scriptedPlayer _ aPlayer.	self orientation: #vertical;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		borderWidth: 1.	self addHeaderMorph.	self addCategoryViewerFor: 'basic'.	self addCategoryViewerFor: 'tests'! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/30/1998 18:37'!obtainBankInfoFrom: anotherViewer	anotherViewer categoryMorphs with: self categoryMorphs do:		[:old :new | new obtainBankInfoFrom: old]! !!StandardViewer methodsFor: 'all' stamp: 'sw 10/24/1998 14:33'!upArrowHit	self previousCostume! !!ViewerBook methodsFor: 'all' stamp: 'sw 10/19/1998 23:21'!setPlayer: aPlayer	| aPartsViewer |	"caution: returns an object not yet visible"	"currentPage ifNotNil: [currentPage partsViewer scriptedPlayer == aPlayer ifTrue: [^ self]]."	self flag: #deferred.  "deploy viewer cache soon"	aPlayer costume pasteUpMorph "temporarily, so it can get initialized!!" addMorph:		(aPartsViewer _ PartsViewer newSticky visible: false).		aPartsViewer setPlayer: aPlayer.	self removeAllMorphs.	self newPages: (OrderedCollection with: aPartsViewer) currentIndex: 1.	currentPage _ aPartsViewer.	^ aPartsViewer! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 13:54'!addHelpPane	helpPane ifNotNil: [^ self].	helpPane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	helpPane extent: ((self width - 4) @ (Preferences viewerEditingPaneHeight)).	helpPane retractable: true; scrollBarOnLeft: false.	self addMorphBack: helpPane! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 13:57'!codePaneMenu: aMenu shifted: shifted	^ aMenu 		labels: 'menueventuallywillbeuseful'		lines: #(1)		selections: #(beep flash beep flash beep)! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 14:26'!contents	| aType  newText sel info |	(info _ self userSlotInformation) ifNotNil:		[^ info documentation].	(aType _ self entryType) == #slot ifTrue: "system-defined slot"		[^ ScriptingSystem helpStringFor: self slotName].	aType == #script ifTrue:		[sel _ self phraseTileMorph submorphs second operatorOrExpression.		newText _ (Preferences showScriptSource or: [self playerBearingCode class tileScriptNames includes: sel])			ifTrue:				[self playerBearingCode sourceCodeFor: sel]			ifFalse:				[ScriptingSystem scriptHelpFor: sel]].	^ newText ifNil: ['?????']! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/6/1998 11:14'!contents: c notifying: k	"later, spruce this up so that it can accept input such as new method source"	| info |	(info _ self userSlotInformation)		ifNotNil:			[info documentation: c.			^ true].	self beep.	^ false! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 09:31'!contentsSelection	"Not well understood why this needs to be here!!"	^ 1 to: 0! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 21:04'!detailButtonPressed	helpPane		ifNotNil:			[helpPane delete.			helpPane _ nil]		ifNil:			[self addHelpPane]! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 10:09'!entryType	^ self viewerRow entryType! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 16:14'!initialize	super initialize.	color _ Color r: 1.0 g: 0.91 b: 1.0.	inset _ 0! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/6/1998 11:34'!phraseTileMorph	"Answer the phraseTileMorph within the receiver"	^ self entryType == #script		ifTrue:			[self viewerRow submorphs fourth]		ifFalse:			[self error: 'slot rows do not contain a phrase tile morph']! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 10:10'!playerBearingCode	^ self viewerRow playerBearingCode! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 20:56'!rootForGrabOf: aMorph	^ aMorph == self		ifTrue: [nil]		ifFalse:	[super rootForGrabOf: aMorph]! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 14:18'!slotName	"Assuming the receiver represents a slot, return its name"	^  self viewerRow submorphs sixth operatorOrExpression! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/9/1998 14:18'!userSlotInformation	"If the receiver represents a user-defined slot, then return its info; if not, retun nil"	| aSlotName info |	(self entryType == #slot)		ifFalse:			[^ nil].	aSlotName _ self slotName.	^ ((info _ self playerBearingCode slotInfo) includesKey: aSlotName)		ifTrue:			[info at: aSlotName]		ifFalse:			[nil]! !!ViewerEntry methodsFor: 'all' stamp: 'sw 11/5/1998 10:09'!viewerRow	"Answer the ViewerRow object, that contains the controls and the phraseTile"	^ submorphs first! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/9/1998 13:36'!addDetailButton	| aButton |	aButton _ SimpleButtonMorph new		target: self;		actionSelector: #detail;		beTransparent;		setBalloonText: 'detail';		label: '¦'.	self addMorphFront: aButton! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/5/1998 09:16'!detail	owner detailButtonPressed! !!ViewerRow methodsFor: 'all' stamp: 'sw 10/27/1998 21:27'!entryType	"systemSlot userSlot systemScript userScript, eventually?!!"	| keyElement |	keyElement _ submorphs second submorphs first contents.	keyElement = '!!' ifTrue: [^ #script].	keyElement = '¥' ifTrue: [^ #slot].	^ #unknown! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/7/1998 22:31'!initialize	super initialize.	inset _ 1! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/5/1998 10:17'!playerBearingCode	^ submorphs fourth associatedPlayer! !!ViewerRow methodsFor: 'all' stamp: 'sw 11/9/1998 15:57'!rootForGrabOf: aMorph	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ nil].	^ aMorph fullCopy isPartsDonor: false! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 10/16/1998 18:49'!configureForConstruction	| aPanel aCan |	self addMorph: (self presenter standardPartsWindow position: 10@10).	presenter standardPlayer.	aPanel _ presenter controlPanel.	self addMorph: aPanel.	self positionControlPanel: aPanel.	aCan _ self presenter addTrashCan.	aCan position: (Display boundingBox bottomRight - aCan extent).  "This oddity necessary to avoid the trashcan's showing up at top-left until an ownerChanged is sent to it; the problem is that addTrashCan: is called too early otherwise."! !!WorldMorph class methodsFor: 'all' stamp: 'sw 10/16/1998 18:51'!openWithStandardPartsBinShowing	"WorldMorph openWithStandardPartsBinShowing"	| aWorld anExtent aPanel aWindow |	anExtent _  700 @ 500.	aWorld _ self new setProperty: #initialExtent toValue: anExtent.	aWorld extent: anExtent.	aWorld presenter addTrashCan.	aPanel _ aWorld presenter controlPanel.	aWorld addMorph: aPanel.	aWorld positionControlPanel: aPanel.	aWorld addMorph: (aWindow _ aWorld presenter standardPartsWindow position: 10@10).	aWindow activate.	MorphWorldView openOn: aWorld label: 'Construction' extent: anExtent! !Morph removeSelector: #standardHolder!BookMorph removeSelector: #saveAsMyPartsBin!HandMorph removeSelector: #flushViewerCache!PasteUpMorph removeSelector: #releaseCachedState!PhraseTileMorph removeSelector: #inPartsBin!Player removeSelector: #standardHolder!Presenter removeSelector: #removeFromViewerCache:!Presenter removeSelector: #cacheViewer:forPlayer:!Presenter removeSelector: #viewerCache!Presenter removeSelector: #launchMyPartsBin!Presenter removeSelector: #flushViewerCache!Presenter removeSelector: #partsBinFor:!Presenter removeSelector: #standardHolder!Presenter removeSelector: #newStandardPartsBin!Presenter removeSelector: #partsBinFor:color:!Presenter removeSelector: #standardHolder:!StandardScriptingSystem removeSelector: #setPartsBinFrom:!StandardScriptingSystem removeSelector: #formDictionary!StandardScriptingSystem removeSelector: #initializePartsBin!StandardScriptingSystem removeSelector: #partsBin!StandardScriptingSystem initialize!EToySystem class removeSelector: #loadImages4!EToySystem class removeSelector: #shrinkPics!EToySystem class removeSelector: #openEToyWorkspace!EToySystem class removeSelector: #prepareForExternalReleaseNamed:!EToySystem class removeSelector: #stripGraphicsForExternalRelease!EToySystem class removeSelector: #loadImages2!EToySystem class removeSelector: #setFirstVersion!EToySystem class removeSelector: #shrinkPics2!EToySystem class removeSelector: #loadPurpleWalt!EToySystem class removeSelector: #eToyDoItStrings!EToySystem class removeSelector: #loadImages3!EToySystem class removeSelector: #stuff!EToySystem class removeSelector: #readCedarAndKayaPics!EToySystem class removeSelector: #loadImages!EToySystem class removeSelector: #loadImages5!EToySystem class removeSelector: #readCollagePic!WorldMorph removeSelector: #standardHolder!"Postscript:"ScriptingSystem saveForm: TileMorph downPicture atKey: 'DownArrow'.ScriptingSystem saveForm: TileMorph upPicture atKey: 'UpArrow'.ScriptingSystem initStandardScriptInfo.ScriptingSystem initStandardSlotInfo.ScriptingSystem initializeHelpStrings.Preferences disable: #showPlayerSource.Preferences disable: #showScriptSource.Preferences enable: #useNewViewers.ScriptingSystem resetStandardPartsBin.ScriptingSystem initializeTypeColors.	ScriptingSystem saveForm: (Form	extent: 30@29	depth: 16	fromArray: #( 1811114995 1878286257 2012637171 1811180532 1811180533 1811179508 1811180532 1811179508 1744006133 1878289396 1811180533 1878289396 1744007156 1674736630 1744006132 1811114995 1811181556 1744006131 1811246068 1811180532 1811179508 1811180532 1744071668 1811113972 1811180532 1811180532 1811179507 1878288338 1945529332 1744071668 1743941620 1811112945 1811179506 1811114995 1744006131 1744006130 1744005106 1811048434 1811113969 1743939570 1811179506 1743939571 1676833782 1676765171 1811047410 1744006131 1811048435 1811116020 1811180531 1743939571 1811048435 1743939570 1743939570 1743939570 1743940594 1744005106 1811181556 1811180532 1676766196 1743939570 1878420468 1676963830 1189896082 1811245044 1744137204 1744070644 1811179508 1811113971 1743939571 1811179508 1811246070 1811309524 1811302093 1811310580 1811246068 1674867703 1744049472 1120606594 1118465013 1744137205 1811179508 1811180532 1744071667 1744006132 1811112947 1811247095 1605584589 358761132 289435638 1676830707 1741975543 1462778473 1811312631 702891724 1811310548 1945528308 1811178450 1945528307 1878288372 1878353875 1878421494 1051471335 1809213397 1118524175 1811246068 1945659348 1185698607 1878486005 1672694510 1118531574 1607626741 1878420467 1811180533 1743942645 1744072693 1811301035 1185770487 1878486006 1324239597 1811180533 1811116019 1120623438 1878352818 1945462739 704868339 1878289395 1811049459 1878221808 1878223859 1743876083 1811162563 1945463796 1811181556 1464746666 1811116018 1809019893 1120551562 1945464821 1741844468 1466842760 1878289395 1811048434 1811050483 1811050483 1878223859 1049188174 1741910004 1811181556 1256998634 1811114994 1878289396 1466840647 1744007156 1744006131 1676877216 1743940596 1878222835 1743938545 1878351792 1676833781 358641652 1743940596 1811050484 845566798 1811113970 1811114995 1811163652 1811112913 1878420468 1878282028 1811179506 1607560178 1878289395 1676900342 1878351825 1466853330 1811113971 1811116019 635659217 1811179506 1811245045 1676942754 1744137206 1744201717 1676962806 1676962805 1811310581 1676896245 1744199635 1811376117 1744072695 1744005109 1811244019 499279861 1811310581 1811244020 1811293668 1399943159 1605528567 1744136181 982063522 986342388 1744070645 1744189066 430063308 1744071669 1744070644 1744067504 566519797 1744136181 1744137205 1743999854 912813044 1811311606 1742162607 4195488 283139922 1945531382 1253113857 144710948 1601400791 1811246069 1811167879 1464821747 1744136180 1674799094 1811178482 843473875 1811311606 1878533542 2106790 2080066222 1876193270 696845376 627472380 1185772536 1878355957 1743990309 1744007157 1676898294 1744006132 1811114996 1743941620 1811180533 1809204941 4194368 4217681 1878290421 1252982848 4194336 1670540278 1739811795 1878353906 1744006131 1811179506 1744007157 1744005106 1945462771 1811182582 1811311574 1393641133 1462856629 2012638196 1876382449 1112301394 1742041045 1945596917 1676833781 1811113970 1811179507 1811180532 1672705014 1674735606 1672697648 1945725943 1878551479 1809215479 1811312629 1809216504 1809215479 1809215478 1462853490 1878487029 1744007158 1744005075 1811239726 704979363 495004132 700789287 562372997 631646663 1739998892 4194400 1116497846 698688932 562375109 770124262 633609569 495070758 1257010166 562315916 1809279958 2012894002 1047280171 980237901 910966381 1668677696 4194400 6314867 1047281260 908804749 910968495 1393719290 1809279959 1185750370 1809214455 1878469062 423836236 1532188466 1601592148 1462986647 1672937568 4194368 6319062 1603622706 1601525554 1601522417 1047336194 770206679 1878487031 1878409899 977955830 1809145716 1118586509 980105834 980045584 1811372914 980104778 1605526483 1395605131 910769804 1118651052 1534358520 1809136234 1118596053 1532059506 1878485973 1326456163 1945660374 1742106615 1811311607 1945725942 1742107641 1744072693 1811311605 1744203767 1878551543 564478604 1878553591 1603428242 1811048433 1811049459 1051290611 1744006131 1811049459 1878156273 1743874034 1744007156 1743874033 1811048434 1811113970 1743939571 1743933228 1603301363 1743875059 1811049458 1945461745 1811181556 1811113971 1811049458 1811048434 1811116020 1878287346 1878223857 1743940594 1744006130 1744007157 1945395153 1945400309 1811048434 1743810547 1676765170 1878353906 1811113970 1743874032 1810983921 1743874033 1811113971 1676765169 1743874034 1743940593 1743939569 1811047409 1676765168 1743940595 1810981872 1945397235 1607560179 1743941620 1810982897 1810983921 1811048433 1744007155 1743875059 1811048434 1743875058 1743939568 1676832754 1811116019 1811114994 1811244019 1676962805 1677029367 1811244020 1744005106 1743940594 1811246068 1744070645 1676961781 1744004084 1676897269 1811180533 1878353908 1744004083 1744070645)	offset: 0@0) atKey: 'squeakyMouse'.ScriptingSystem saveForm: (Form extent: 7@7 depth: 16	fromArray: #( 0 1879273475 1879244800 0 28675 1879273475 1879273475 0 1879273475 1879273475 1879273475 1879244800 1879273475 1879273475 1879273475 1879244800 1879273475 1879273475 1879273475 1879244800 28675 1879273475 1879273475 0 0 1879273475 1879244800 0)	offset: 0@0) atKey: 'OfferToLock'.ScriptingSystem saveForm: (Form extent: 7@7 depth: 16	fromArray: #( 0 58852226 58851328 0 898 58852226 58852226 0 58852226 58852226 58852226 58851328 58852226 58852226 58852226 58851328 58852226 58852226 58852226 58851328 898 58852226 58852226 0 0 58852226 58851328 0)	offset: 0@0) atKey: 'OfferToUnlock'.ScriptingSystem initializeHelpStrings.Preferences initializeParameters.Preferences setAltMenuChoices.ScriptingSystem initializeScriptHelp.ScriptingSystem newStandardPartsBin.!