'From Squeak 2.3 of January 14, 1999 on 22 March 1999 at 12:04:42 pm'!"Change Set:		DebuggerFixDate:			22 March 1999Author:			Dan IngallsMade a new class MessageAsTempNode to clarify the situation where a message node masquerades as a temporary variable in order to provide access to temporary variables when executing do-its in the debugger.Included in this class the new protocol required for variable scoping thus restoring the ability to execute blocks in the context of a debugger."!MessageNode subclass: #MessageAsTempNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!AssignmentNode methodsFor: 'initialize-release' stamp: 'di 3/22/1999 12:00'!variable: aVariable value: expression from: encoder	(aVariable isMemberOf: MessageAsTempNode)		ifTrue: ["Case of remote temp vars"				^ aVariable store: expression from: encoder].	variable _ aVariable.	value _ expression! !!Encoder methodsFor: 'initialize-release' stamp: 'di 3/22/1999 09:32'!init: aClass context: aContext notifying: req	| node n homeNode indexNode |	requestor _ req.	class _ aClass.	nTemps _ 0.	supered _ false.	self initScopeAndLiteralTables.	n _ -1.	class allInstVarNames do: 		[:variable | 		node _ VariableNode new					name: variable					index: (n _ n + 1)					type: LdInstType.		scopeTable at: variable put: node].	aContext == nil		ifFalse: 			[homeNode _ self bindTemp: 'homeContext'.			"first temp = aContext passed as arg"			n _ 0.			aContext tempNames do: 				[:variable | 				indexNode _ self encodeLiteral: (n _ n + 1).				node _ MessageAsTempNode new							receiver: homeNode							selector: #tempAt:							arguments: (Array with: indexNode)							precedence: 3							from: self.				scopeTable at: variable put: node]].	sourceRanges _ Dictionary new: 32! !!MessageAsTempNode commentStamp: 'di 3/22/1999 09:26' prior: 0!This node represents accesses to temporary variables for do-its in the debugger.  Since they execute in another context, they must send a message to the original context to access the value of the temporary variable in that context.!!MessageAsTempNode reorganize!('access to remote temps' asStorableNode: emitStorePop:on: isTemp nowHasDef nowHasRef scope scope: sizeForStorePop: store:from:)!!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:38'!asStorableNode: encoder	"This node is a message masquerading as a temporary variable.	It currently has the form {homeContext tempAt: offset}.	We need to generate code for {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack.	This, in turn will get turned into {homeContext tempAt: offset put: expr}	at runtime if nobody disturbs storeAt:inTempFrame: in Object (not clean)"	^ MessageAsTempNode new		receiver: nil  "suppress code generation for reciever already on stack"		selector: #storeAt:inTempFrame:		arguments: (arguments copyWith: receiver)		precedence: precedence		from: encoder! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!emitStorePop: stack on: codeStream	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^ self emitForEffect: stack on: codeStream! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:35'!isTemp	"Masquerading for debugger access to temps."	^ true! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!nowHasDef	"For compatibility with temp scope protocol"! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!nowHasRef	"For compatibility with temp scope protocol"! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!scope	"For compatibility with temp scope protocol"	^ -1! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!scope: ignored	"For compatibility with temp scope protocol"! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!sizeForStorePop: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^ self sizeForEffect: encoder! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:40'!store: expr from: encoder 	"ctxt tempAt: n -> ctxt tempAt: n put: expr (see Assignment).	For assigning into temps of a context being debugged."	selector key ~= #tempAt: 		ifTrue: [^self error: 'cant transform this message'].	^ MessageAsTempNode new		receiver: receiver		selector: #tempAt:put:		arguments: (arguments copyWith: expr)		precedence: precedence		from: encoder! !!SortedCollection methodsFor: 'enumerating' stamp: 'di 3/22/1999 11:59'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into an OrderedCollection. Answer the new collection. 	Override the superclass in order to produce an OrderedCollection instead	of a SortedCollection."	| newCollection | 	newCollection _ OrderedCollection new.	self do: [:each | newCollection addLast: (aBlock value: each)].	^newCollection! !MessageNode removeSelector: #asStorableNode:!MessageNode removeSelector: #emitStorePop:on:!MessageNode removeSelector: #isTemp!MessageNode removeSelector: #store:from:!MessageNode removeSelector: #sizeForStorePop:!