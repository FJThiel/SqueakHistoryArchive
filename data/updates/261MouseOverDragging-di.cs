'From Squeak 2.2beta of Sept 11, 1998 on 14 September 1998 at 3:34:44 pm'!"Change Set:		MouseOverDragging-diDate:			14 September 1998Author:			Dan IngallsRetroactively converts all the dragOver and mouseOverLaden terminology to mouseOverDragging, mouseEnterDragging and mouseLeaveDragging.Also includes code from Scott Wallace for integrating with end-user scripting.Also makes a silent version of ClassDescription renameInstVar:to:"!!ClassDescription methodsFor: 'instance variables' stamp: 'di 9/14/1998 08:40'!renameInstVar: oldName to: newName	(self confirm: 'WARNING: Renaming of instance variablesis subject to substitution ambiguities.Do you still wish to attempt it?') ifFalse: [self halt].	"...In other words, this does a dumb text search-and-replace,	which might improperly alter, eg, a literal string.  As long as	the oldName is unique, everything should work jes' fine. - di"	^ self renameSilentlyInstVar: oldName to: newName! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 9/14/1998 15:30'!renameSilentlyInstVar: oldName to: newName	| i oldCode newCode parser header body sels |	(i _ instanceVariables indexOf: oldName) = 0 ifTrue:		[self error: oldName , ' is not defined in ', self name].	self allSuperclasses , self withAllSubclasses asOrderedCollection do:		[:cls | (cls instVarNames includes: newName) ifTrue:			[self error: newName , ' is already used in ', cls name]].	instanceVariables replaceFrom: i to: i with: (Array with: newName).	self withAllSubclasses do:		[:cls | sels _ cls selectors.		sels removeAllFoundIn: #(DoIt DoItIn:).		sels do:			[:sel |			oldCode _ cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser _ cls parserClass new) parseSelector: oldCode.			header _ oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body _ header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode _ header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].			cls isMeta ifFalse:				[oldCode _ cls comment.				newCode _ oldCode copyReplaceTokens: oldName with: newName.				newCode ~= oldCode ifTrue:					[cls comment: newCode]]]! !!EventHandler methodsFor: 'initialization' stamp: 'di 9/14/1998 08:35'!forgetDispatchesTo: aSelector	"aSelector is no longer implemented by my corresponding Player, so don't call it any more"	mouseDownSelector == aSelector		ifTrue: [mouseDownRecipient _ mouseDownSelector _ nil].	mouseStillDownSelector == aSelector		ifTrue: [mouseStillDownRecipient _ mouseStillDownSelector _ nil].	mouseUpSelector == aSelector		ifTrue: [mouseUpRecipient _ mouseUpSelector _ nil].	mouseEnterSelector == aSelector		ifTrue: [mouseEnterRecipient _ mouseEnterSelector _ nil].	mouseLeaveSelector == aSelector		ifTrue: [mouseLeaveRecipient _ mouseLeaveSelector _ nil].	mouseEnterLadenSelector == aSelector		ifTrue: [mouseEnterLadenRecipient _ mouseEnterLadenSelector _ nil].	mouseLeaveLadenSelector == aSelector		ifTrue: [mouseLeaveLadenRecipient _ mouseLeaveLadenSelector _ nil].	keyStrokeSelector == aSelector		ifTrue: [keyStrokeRecipient _ keyStrokeSelector _ nil].! !!EventHandler methodsFor: 'initialization' stamp: 'di 9/14/1998 08:34'!on: eventName send: selector to: recipient	eventName = #mouseDown ifTrue:		[mouseDownRecipient _ recipient.  mouseDownSelector _ selector. ^ self].	eventName = #mouseStillDown ifTrue:		[mouseStillDownRecipient _ recipient.  mouseStillDownSelector _ selector. ^ self].	eventName = #mouseUp ifTrue:		[mouseUpRecipient _ recipient.  mouseUpSelector _ selector. ^ self].	eventName = #mouseEnter ifTrue:		[mouseEnterRecipient _ recipient.  mouseEnterSelector _ selector. ^ self].	eventName = #mouseLeave ifTrue:		[mouseLeaveRecipient _ recipient.  mouseLeaveSelector _ selector. ^ self].	eventName = #mouseEnterDragging ifTrue:		[mouseEnterLadenRecipient _ recipient.  mouseEnterLadenSelector _ selector. ^ self].	eventName = #mouseLeaveDragging ifTrue:		[mouseLeaveLadenRecipient _ recipient.  mouseLeaveLadenSelector _ selector. ^ self].	eventName = #keyStroke ifTrue:		[keyStrokeRecipient _ recipient.  keyStrokeSelector _ selector. ^ self].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!EventHandler methodsFor: 'testing' stamp: 'di 9/14/1998 08:30'!handlesMouseOverDragging: evt	mouseEnterLadenRecipient ifNotNil: [^ true].	mouseLeaveLadenRecipient ifNotNil: [^ true].	^ false! !!EventHandler methodsFor: 'events' stamp: 'di 9/14/1998 08:30'!mouseEnterDragging: event fromMorph: sourceMorph	^ self send: mouseEnterLadenSelector to: mouseEnterLadenRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'di 9/14/1998 08:30'!mouseLeaveDragging: event fromMorph: sourceMorph	^ self send: mouseLeaveLadenSelector to: mouseLeaveLadenRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:30'!firstMouseSelector	"Answer the selector corresponding to the first mouse-handling selector fielded.  Created in support of providing balloon-help for halo handles, triggered by the selector handled"	mouseDownSelector ifNotNil: [^ mouseDownSelector].	mouseStillDownSelector ifNotNil: [^ mouseStillDownSelector].	mouseUpSelector ifNotNil: [^ mouseUpSelector].	mouseEnterSelector ifNotNil: [^ mouseEnterSelector].	mouseLeaveSelector ifNotNil: [^ mouseLeaveSelector].	mouseEnterLadenSelector ifNotNil: [^ mouseEnterLadenSelector].	mouseLeaveLadenSelector ifNotNil: [^ mouseLeaveLadenSelector].	^ nil! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:30'!messageList	"Return a list of 'Class selector' for each message I can send.  tk9/13/97"	| list |	list _ SortedCollection new.	mouseDownRecipient ifNotNil:		[list add: (mouseDownRecipient class classThatUnderstands:					mouseDownSelector) name , ' ', mouseDownSelector].	mouseStillDownRecipient ifNotNil:		[list add: (mouseStillDownRecipient class classThatUnderstands:					mouseStillDownSelector) name , ' ', mouseStillDownSelector].	mouseUpRecipient ifNotNil:		[list add: (mouseUpRecipient class classThatUnderstands:					mouseUpSelector) name , ' ', mouseUpSelector].	mouseEnterRecipient ifNotNil:		[list add: (mouseEnterRecipient class classThatUnderstands:					mouseEnterSelector) name , ' ', mouseEnterSelector].	mouseLeaveRecipient ifNotNil:		[list add: (mouseLeaveRecipient class classThatUnderstands:					mouseLeaveSelector) name , ' ', mouseLeaveSelector].	mouseEnterLadenRecipient ifNotNil:		[list add: (mouseEnterLadenRecipient class classThatUnderstands:					mouseEnterLadenSelector) name , ' ', mouseEnterLadenSelector].	mouseLeaveLadenRecipient ifNotNil:		[list add: (mouseLeaveLadenRecipient class classThatUnderstands:					mouseLeaveLadenSelector) name , ' ', mouseLeaveLadenSelector].	keyStrokeRecipient ifNotNil:		[list add: (keyStrokeRecipient class classThatUnderstands:					keyStrokeSelector) name , ' ', keyStrokeSelector].	^ list! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:32'!mouseDownSelector	^ mouseDownSelector! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:32'!mouseUpSelector	^ mouseUpSelector! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:30'!printOn: aStream	| aVal |	super printOn: aStream.	#('mouseDownSelector' 'mouseStillDownSelector mouseUpSelector' 'mouseEnterSelector' 'mouseLeaveSelector' 'mouseEnterLadenSelector' 'mouseLeaveLadenSelector' 'keyStrokeSelector') do:		[:aName | (aVal _ self instVarNamed: aName) ~~ nil ifTrue:			[aStream nextPutAll: '; ', aName, '=', aVal]]! !!EventHandler methodsFor: 'object fileIn' stamp: 'di 9/14/1998 08:30'!convertmmmmmmmmmmkkv0: varDict mmmmmmmmmmmmmmkkv0: smartRefStrm	"These variables are automatically stored into the new instance ('mouseDownRecipient' 'mouseDownSelector' 'mouseStillDownRecipient' 'mouseStillDownSelector' 'mouseUpRecipient' 'mouseUpSelector' 'mouseEnterRecipient' 'mouseEnterSelector' 'mouseLeaveRecipient' 'mouseLeaveSelector' 'keyStrokeRecipient' 'keyStrokeSelector' 'valueParameter' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('mouseEnterLadenRecipient' 'mouseEnterLadenSelector' 'mouseLeaveLadenRecipient' 'mouseLeaveLadenSelector' ) and deal with the information in ()"! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:31'!handlesMouseOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?  The default response is false, except if you have added sensitivity to mouseEnter: or mouseLeave:, using the on:send:to: mechanism." 	self eventHandler ifNotNil: [^ self eventHandler handlesMouseOver: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:31'!handlesMouseOverDragging: evt	"Return true if I want to receive mouseEnterDragging: and mouseLeaveDragging: when the hand drags something over me (button up or button down), or when the mouse button is down but there is no mouseDown recipient.  The default response is false, except if you have added sensitivity to mouseEnterLaden: or mouseLeaveLaden:, using the on:send:to: mechanism."	"NOTE:  If the hand state matters in these cases, it may be tested by constructs such as		event anyButtonPressed		event hand hasSubmorphs"	self eventHandler ifNotNil: [^ self eventHandler handlesMouseOverDragging: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:33'!mouseEnterDragging: evt	"Handle a mouseEnterDragging event, meaning the mouse just entered my bounds with a button pressed or laden with submorphs.  The default response is to let my eventHandler, if any, handle it, or else to do nothing."	self eventHandler ifNotNil:		[^ self eventHandler mouseEnterDragging: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:38'!mouseLeaveDragging: evt	"Handle a mouseLeaveLaden event, meaning the mouse just left my bounds with a button pressed or laden with submorphs. The default response is to let my eventHandler, if any, handle it; else to do nothing."	self eventHandler ifNotNil:		[self eventHandler mouseLeaveDragging: evt fromMorph: self]! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:50'!handlesMouseOverDragging: evt	^ true! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/14/1998 08:48'!handleDragOver: evt	| mList allMouseOvers leftMorphs enteredMorphs |	owner ifNil: [^ self].  "this hand is not in a world"	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	"Make a list of all potential drag-overs..."	allMouseOvers _ mList select:		[:m | m handlesMouseOverDragging: (evt transformedBy: (m transformFrom: self))].	leftMorphs _ dragOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (dragOverMorphs includes: m) not].	"Notify and remove any morphs that have just been left..."	leftMorphs do: [:m |		dragOverMorphs remove: m.		m mouseLeaveDragging: (evt transformedBy: (m transformFrom: self))].	"Add any new mouse-overs and send mouseEnter:"	enteredMorphs do: [:m |		dragOverMorphs add: m.		mouseOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		m mouseEnterDragging: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/14/1998 08:18'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: (Sensor cursorPoint - owner viewBox topLeft)]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				mouseDownMorph _ m.				eventTransform _ m transformFrom: self.				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				"ensure that at least one mouseMove: is reported for each mouse transaction:"				m mouseMove: (localEvt copy setType: #mouseMove).				(m handlesMouseOverDragging: localEvt) ifTrue:					["If m also handles dragOver, enter it in the list"					dragOverMorphs add: m.					mouseOverMorphs remove: m ifAbsent: []]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: []]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/14/1998 08:47'!handleMouseUp: evt	"Dispatch a mouseUp event."	| oldFocus |	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	"drop morphs being carried, if any"	self hasSubmorphs ifTrue: [self dropMorphsEvent: evt].	mouseDownMorph = nil ifTrue: [^ self].	oldFocus := mouseDownMorph.	"make sure that focus becomes nil."	mouseDownMorph _ nil.  "mouse focus transaction ends when mouse goes up"	oldFocus mouseUp: (self transformEvent: evt).	dragOverMorphs copy do: [:m |		dragOverMorphs remove: m.		m mouseLeaveDragging: (evt transformedBy: (m transformFrom: self))].! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:57'!handlesMouseOverDragging: evt	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:16'!buildKeyboard	| wtWid bkWid noteR octavePt nWhite nBlack |	wtWid _ 8. bkWid _ 5.	self extent: 10@10.	1 to: nOctaves+1 do:		[:i | i <= nOctaves ifTrue: [nWhite _ 7.  nBlack _ 5]						ifFalse: [nWhite _ 1.  nBlack _ 0 "High C"].		octavePt _ self innerBounds topLeft + ((7*wtWid*(i-1)-1)@-1).		1 to: nWhite do:			[:j | 			noteR _ octavePt + (j-1*wtWid@0) extent: (wtWid+1)@36.			self addMorph: ((RectangleMorph newBounds: noteR color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(1 3 5 6 8 10 12) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)].		1 to: nBlack do:			[:j |			noteR _ octavePt + ((#(6 15 29 38 47) at: j)@0) extent: bkWid@22.			self addMorph: ((Morph newBounds: noteR color: blackKeyColor)				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(2 4 7 9 11) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)]].	self extent: (self fullBounds extent + borderWidth - 1)! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ true! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 9/14/1998 14:47'!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	| aMenu reply standardStati aScriptInstantiation |	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging opening closing "keyStroke").	aScriptInstantiation _ self scriptInstantiation.	aMenu _ SelectionMenu labelList:  #(		'normal -- run when called'		'paused -- ready to run all the time'		'ticking -- run all the time'		'mouseDown -- run when mouse goes down on me'		'mouseStillDown -- while mouse still down'		'mouseUp -- when mouse comes back up'		'mouseEnter -- when mouse enters my bounds, button up'		'mouseLeave -- when mouse exits my bounds, button up'		'mouseEnterDragging -- when mouse enters my bounds, button down'		'mouseLeaveDragging -- when mouse exits my bounds, button down'		'opening -- when I am being opened'		'closing -- when I am being closed'	"	'keyStroke -- run when user hits a key' "		)		lines: #(1 3 6 10 "12")		selections: standardStati.	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply ifNotNil: 		[aScriptInstantiation status: reply.  "Gets event handlers fixed up"		reply == #ticking ifTrue: [playerScripted costume arrangeToStartStepping].		self updateStatus]! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 5/7/1998 22:06'!status: newStatus	| stati actualMorph |	actualMorph _ player costume renderedMorph.	((stati _ ScriptingSystem standardEventStati) includes: status)		ifTrue:			[actualMorph on: status send: nil to: nil].  			"remove old link in event handler"	(stati includes: newStatus)		ifTrue:			[actualMorph on: newStatus send: selector to: player].  "establish new link in evt handler"	status _ newStatus! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 9/14/1998 14:41'!statusColorSymbolFor: statusSymbol	#(	(normal					green)		(ticking					blue)		(paused					red)		(mouseDown				yellow)		(mouseStillDown			lightYellow)		(mouseUp				lightBlue)		(mouseEnter				lightBrown)		(mouseLeave			lightRed)		(mouseEnterDragging	lightGray)		(mouseLeaveDragging	darkGray)		(keyStroke				lightGreen)) do:			[:pair | statusSymbol == pair first ifTrue: [^ pair second]].		^ #blue! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 9/14/1998 14:39'!standardEventStati	^ #(mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging keyStroke)! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^true! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ true! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 08:08'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !EventHandler removeSelector: #mouseLeaveLaden:fromMorph:!EventHandler removeSelector: #handlesDragOver:!EventHandler removeSelector: #mouseEnterLaden:fromMorph:!Morph removeSelector: #mouseEnterLaden:!Morph removeSelector: #mouseLeaveLaden:!Morph removeSelector: #handlesDragOver:!"Postscript:Rename the variables of EventHandler..."EventHandler renameSilentlyInstVar: 'mouseEnterLadenRecipient' to: 'mouseEnterDraggingRecipient'.EventHandler renameSilentlyInstVar: 'mouseEnterLadenSelector' to: 'mouseEnterDraggingSelector'.EventHandler renameSilentlyInstVar: 'mouseLeaveLadenRecipient' to: 'mouseLeaveDraggingRecipient'.EventHandler renameSilentlyInstVar: 'mouseLeaveLadenSelector' to: 'mouseLeaveDraggingSelector'.!