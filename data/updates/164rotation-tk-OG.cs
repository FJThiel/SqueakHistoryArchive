'From Squeak 2.1 of June 30, 1998 on 2 August 1998 at 2:42:30 pm'!!Morph methodsFor: 'accessing' stamp: 'tk 7/31/1998 13:47'!forwardDirection	"Default implementation."	^ 0.0! !!Morph methodsFor: 'drawing' stamp: 'tk 8/2/1998 14:33'!doesOwnRotation	"Some morphs don't want to TransformMorph to rotate their images, but we do"	^ false! !!HandMorph methodsFor: 'from EToyHand' stamp: 'tk 8/2/1998 12:40'!makeNewDrawingInBounds: rect pasteUpMorph: aPasteUpMorph	| w newSketch newPlayer sketchEditor p aPaintBox |	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new costumee: (newPlayer _ Player newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: aPasteUpMorph.	sketchEditor		afterNewPicDo: [:aForm :aRect |			newSketch form: aForm.			newSketch position: aRect origin.			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch setupAngle: sketchEditor forwardDirection.			newSketch privateOwner: aPasteUpMorph.  "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			aPasteUpMorph addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			self presenter drawingJustCompleted: newSketch]		 ifNoBits:			[(aPaintBox _ self world paintBox) ifNotNil:				[aPaintBox delete].			p _ aPasteUpMorph standardPalette.			p ifNotNil: [p showNoPalette]]! !!MovieMorph methodsFor: 'menu' stamp: 'di 8/1/1998 10:03'!setRotationCenter	| frame p |	frame _ self currentFrame.	frame ifNil: [^ self].	self rotationDegrees: 0.0.   "must set rotation center with no rotation"	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld transform: p.	Sensor waitNoButton.	frame rotationCenter: p - frame bounds origin.	self setFrame: currentFrameIndex.! !!Player methodsFor: 'slots-standard-get/set' stamp: 'tk 7/31/1998 13:47'!getHeadingUnrounded 	^ costume forwardDirection asSmallAngleDegrees! !!SketchEditorMorph commentStamp: 'tk 8/2/1998 14:42' prior: 0!Inst vars (converting to morphic events)hostView -- SketchMorph we are working on.stampForm -- Stamp is stored here.canvasRectangle -- later use boundspalette -- the PaintBox interface Morphdirty -- not usedcurrentColor ticksToDwell rotationCenter registrationPoint newPicBlock -- do this after paintingaction -- selector of painting actionpaintingForm -- our copycomposite -- now paintArea origin.  world relative.  stop using it.dimForm -- SketchMorph of the dimmed background.  Opaque.  		installed behind the editor morph.buff brush -- 1-bit Form of the brush, paintingFormPen formCanvas -- Aim it at paintingForm to allow it to draw ovals, rectangles, lines, etc.picToComp dimToComp compToDisplay -- used to composite -- obsoletepicToBuff brushToBuff buffToBuff buffToPic rotationButton scaleButton -- submorphs, handles to do these actions.strokeOrigin -- During Pickup, origin of rect. cumRot cumMag -- cumulative for multiple operations from same originalundoBuffer lastEvent currentNib -- 1 bit deep form.For now, we do not carry the SketchMorph's registration point, rotation center, or ticksToDwell.New -- using transform morphs to rotate the finished player.  How get it rotated back and the rotationDegrees to be right?  We cancel out rotationDegrees, so how remember it?Registration point convention:  In a GraphicFrame, reg point is relative to this image's origin.During painting, it is relative to canvasRectangle origin, and thus us absolute within the canvas.  To convert back, subract newBox origin.Be sure to convert back and forth correctly.  In deliverPainting. initializeFromFrame:inView: !!SketchEditorMorph methodsFor: 'initialization' stamp: 'tk 7/30/1998 17:20'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph	| w aPaintBox aPal  aPosition |	(w _ aPasteUpMorph world) addMorphFront: self.	aPaintBox _ w paintBox.	(aPal _ aPasteUpMorph standardPalette)		ifNotNil:			[aPal showNoPalette.			aPosition _ aPal topRight + (aPaintBox width negated @ 0 "aPal tabsMorph height")]		ifNil:			[aPosition _ aPaintBox position].	hostView _ aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	canvasRectangle _ bounds translateBy: w viewBox origin.	aPaintBox position: aPosition.	palette _  aPaintBox.	palette position: aPosition.	w addMorphFront: aPaintBox.  "bring to front"	paintingForm _ Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	self addRotationScaleHandles.	aSketchMorph ifNotNil:		[aSketchMorph rotationDegrees: 0.		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter]! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 8/2/1998 13:39'!addRotationScaleHandles	"Rotation and scaling handles"	| fwdButton pt toggle |	rotationButton _ SketchMorph new form: (palette rotationTabForm).	rotationButton position: bounds topCenter - (6@0).	rotationButton on: #mouseDown send: #rotateScalePrep to: self.	rotationButton on: #mouseStillDown send: #rotateBy: to: self.	rotationButton on: #mouseUp send: #rotateDone: to: self.	rotationButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	rotationButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: rotationButton.	rotationButton setBalloonText: 'Drag me sideways to\rotate yourpicture.' withCRs.	scaleButton _ SketchMorph new form: (palette scaleTabForm).	scaleButton position: bounds rightCenter - ((scaleButton width)@6).	scaleButton on: #mouseDown send: #rotateScalePrep to: self.	scaleButton on: #mouseStillDown send: #scaleBy: to: self.	scaleButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	scaleButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: scaleButton.	scaleButton setBalloonText: 'Drag me up and down to change\the sizeof your picture.' withCRs.	fwdButton _ PolygonMorph new.	pt _ "rotationButton topRight" bounds topCenter.	fwdButton borderWidth: 2; makeOpen; makeBackArrow; borderColor:(Color r: 0 g: 0.8 b: 0).	fwdButton removeHandles; setVertices: (Array with: pt+(0@7) with:pt+(0@22)).	fwdButton on: #mouseStillDown send: #forward:direction: to: self.	fwdButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	fwdButton on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdButton toValue: fwdButton.	self addMorph: fwdButton.	fwdButton setBalloonText: 'Drag me around to point\in the directionI go forward.' withCRs.	toggle _ EllipseMorph		newBounds: (Rectangle center: fwdButton vertices last +(-4@4) extent: 8@8)		color: Color gray.	toggle on: #mouseUp send: #toggleDirType:in: to: self.	toggle on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	toggle on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdToggle toValue: toggle.	fwdButton addMorph: toggle.	toggle setBalloonText: 'When your object turns,\how should itspicture change?\It can rotate, face left or right,\face up or down, or notchange.' withCRs.	self setProperty: #rotationStyle toValue: hostView rotationStyle.	self forward: hostView setupAngle direction: fwdButton.	"Set to its current value"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 7/30/1998 16:21'!dimTheWindow	"Do not call twice!!  Installs a morph with the background behindme.  6/12/97 12:29 tk"	| dim map notTrans |	"create a dim version of the stuff on the screen"	"dim _ Form fromDisplay: canvasRectangle."	dim _ owner imageFormForRectangle: self bounds.	dim fill: dim boundingBox		rule: (dim depth < 16 ifTrue: [Form and] ifFalse: [Form under])		fillColor: (Color pixelScreenForDepth: dim depth).	map _ (Color cachedColormapFrom: dim depth to: dim depth) copy.	map _ map collect: [:c |		c = 0 ifTrue: [Color white pixelValueForDepth: dim depth]ifFalse: [c]].	notTrans _ BitBlt toForm: dim.	notTrans colorMap: map; sourceForm: dim; combinationRule: Form over;		destRect: dim boundingBox; sourceOrigin: 0@0; copyBits.	dimForm _ SketchMorph new form: dim.	dimForm position: self position.	owner privateAddMorph: dimForm atIndex: (owner submorphs indexOf:self)+1.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/30/1998 17:30'!forward: evt direction: button	"Move the forward direction arrow of this painting.  When the usersays forward:, the object moves in the direction of the arrow.  evt may bean Event (from the user moving the arrow), or an initial number ofdegrees."	| center dir ww ff |	center _ bounds center "+ (rotationButton width - 6 @ 0)".	evt isNumber ifTrue: [dir _ Point r: 100 degrees: evt - 90.0"convert to 0 on X axis"]		ifFalse: [dir _ evt cursorPoint - center].	ww _ (bounds height min: bounds width)//2 - 7.	button setVertices: (Array		with: (center + (Point r: ww degrees: dir degrees))		with: (center + (Point r: ww-15 degrees: dir degrees))).	(ff _ self valueOfProperty: #fwdToggle) position:		(center + (Point r: ww-7 degrees: dir degrees + 6.5)) - (ffextent // 2).	self showDirType.! !!SketchMorph commentStamp: 'tk 8/2/1998 14:42' prior: 0!The morph that results when the user draws a color bitmap using the PaintBox (SketchEditorMorph and PaintBoxMorph).  forwardDirection is the angle at which the object will go forward.  When the rotationStyle is not #normal, then forwardDirection is any angle, while the rotation is highly restricted.  If flexed, this is remembered by the Transform morph.  For non-normal rotationStyle, it is rotationDegrees.setupAngle (a property) is where the user put the green arrow to indicate which direction on the picture is forward.  When #normal, draw the morph initially at (0.0 - setupAngle).  The enclosing TransformationMorph then rotates it to the true angle. rotationDegrees  In a #normal object, rotationDegrees is constant an equal to setupAngle.	For non-normal, it is the direction the object is going.When repainting, set it back to its original state. The green arrow is set to setupAngle, and the sketch is shown as drawn originally (rotationDegrees = 0). rotationStyle = normal (turns), leftRight, upDown, fixed.  When leftRight upDown or fixed, bit map has severe restrictions.!!SketchMorph reorganize!('initialization' initialize)('accessing' form form: forwardDirection forwardDirection: framesToDwell framesToDwell: maxScaleFactor newScaleFactor:previousScaleFactor: referencePosition referencePosition: rotatedForm rotationCenter rotationCenter: rotationDegrees rotationDegrees: rotationDegrees:scalePoint: rotationStyle rotationStyle: scalePoint scalePoint: setupAngle setupAngle:)('drawing' doesOwnRotation drawOn: generateRotatedForm)('geometry' containsPoint: extent:)('menu' addCustomMenuItems:hand: editDrawing editDrawingIn:forBackground: erasePixelsOfColor: insertIntoMovie: recolorPixelsOfColor: setRotationCenter setRotationStyle)('change reporting' layoutChanged)('other' addOptionalHandlesTo:box: colorSettable colorUnder releaseCachedState replaceSelfWithMovie wearCostume:)('object fileIn' convertbosfceorrrfro0:bosfceorrrsfro0:)('pen support' clearExtent:fillColor: penOnMyForm revealPenStrokes)!!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:11'!forwardDirection	"Return my forward direction.  If #normal I am not flexed."	^ rotationStyle == #normal 		ifTrue: [0.0]		ifFalse: [rotationDegrees]	"fwd dir kept here when leftRight, upDown, none"! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:52'!forwardDirection: degrees	"Set the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	(0.0 - degrees) abs <= 0.0001		ifTrue: [self removeProperty: #forwardDirection]		ifFalse: [self setProperty: #forwardDirection toValue: degrees].! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 11:54'!setupAngle	"Return the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	^ (self valueOfProperty: #setupAngle) ifNil: [0.0]! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:53'!setupAngle: degrees	"Set the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	(0.0 - degrees) abs <= 0.0001		ifTrue: [self removeProperty: #setupAngle]		ifFalse: [self setProperty: #setupAngle toValue: degrees].! !!SketchMorph methodsFor: 'drawing' stamp: 'tk 8/2/1998 14:35'!doesOwnRotation	"When not #normal, don't let to TransformMorph to rotate my image"	^ rotationStyle ~~ #normal! !!SketchMorph methodsFor: 'drawing' stamp: 'tk 8/2/1998 12:05'!generateRotatedForm	"Compute my rotatedForm and offsetWhenRotated."	| adjustedAngle smoothPix pair |	(rotationStyle = #normal)		ifTrue: [adjustedAngle _ 0.0 - self setupAngle]			"let TransformationMorph do directional image turn, we subtract green arrow angle"		ifFalse: [adjustedAngle _ 0.0].	"leftRight, upDown, none"	((adjustedAngle = 0.0) and: [0.0@0.0 = scalePoint])		ifTrue: [			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: ["do the actual rotation!!"			((scalePoint x < 1.0) or: [scalePoint y < 1.0])				ifTrue: [smoothPix _ 2]				ifFalse: [smoothPix _ 1].			pair _ WarpBlt				rotate: originalForm				degrees: adjustedAngle negated				center: rotationCenter				scaleBy: self scalePoint				smoothing: smoothPix.			rotatedForm _ pair first.			offsetWhenRotated _ pair last].	((rotationStyle = #leftRight) and: [rotationDegrees < 0.0]) ifTrue: [		"headed left; use flipped"		rotatedForm _ rotatedForm flipBy: #horizontal centerAt: 0@0.		offsetWhenRotated _ offsetWhenRotated + 			(((2 * (rotationCenter x - (originalForm width // 2)))@0) * scalePoint).		^ self].	((rotationStyle = #upDown) and: [(rotationDegrees > 90.0) or: 		[rotationDegrees < -90.0]]) ifTrue: [			"headed down; use flipped"			rotatedForm _ rotatedForm flipBy: #vertical centerAt: 0@0.			offsetWhenRotated _ offsetWhenRotated + 				((0@(2 * (rotationCenter y - (originalForm height // 2)))) * scalePoint).			^ self].! !!SketchMorph methodsFor: 'menu' stamp: 'tk 7/6/1998 15:31'!editDrawing	self flag: #deferred.  "Don't allow this if the user is already in paint mode, because it creates a very strange situation."	"costumee ifNotNil: [self forwardDirection: costumee direction]."  "how say this?"	self editDrawingIn: self pasteUpMorph forBackground: false! !!SketchMorph methodsFor: 'menu' stamp: 'tk 8/2/1998 12:06'!editDrawingIn: aPasteUpMorph forBackground: forBackground	| w oldRotation bnds sketchEditor |	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	w displayWorld.	oldRotation _ rotationDegrees.	forBackground		ifTrue: [bnds _ aPasteUpMorph boundsInWorld]		ifFalse: [			bnds _ self boundsInWorld.			bnds _ (aPasteUpMorph paintingBoundsAround: bnds center) merge: bnds].	sketchEditor _ SketchEditorMorph new.	forBackground ifTrue: [sketchEditor setProperty: #background toValue: true].	w addMorphFront: sketchEditor.	sketchEditor initializeFor: self inBounds: bnds pasteUpMorph: aPasteUpMorph.		"self rotationDegrees: 0.  inside the init"	self rotationDegrees: oldRotation.  "restore old rotation so that cancel leaves it right"	sketchEditor		afterNewPicDo: [:aForm :aRect |			self form: aForm.			self topRendererOrSelf position: aRect origin.			self rotationStyle: sketchEditor rotationStyle.			self setupAngle: sketchEditor forwardDirection.			self rotationDegrees: sketchEditor forwardDirection.			aPasteUpMorph playfield ifNotNil: "Show the right viewer"				[self presenter drawingJustCompleted: self].			forBackground ifTrue: [self goBehind]]  "shouldn't be necessary"		ifNoBits: ["If no bits drawn.  Must keep old pic.  Can't have no picture"			aPasteUpMorph standardPalette ifNotNil:				[aPasteUpMorph standardPalette viewMorph: self]]! !!SketchMorph methodsFor: 'menu' stamp: 'di 8/1/1998 10:02'!setRotationCenter	| oldRotation p oldScale |	oldRotation _ rotationDegrees.	oldScale _ scalePoint.	scalePoint _ 1.0@1.0.	self rotationDegrees: 0.0.	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld transform: p.	Sensor waitNoButton.	self rotationCenter: p - bounds origin.	scalePoint _ oldScale.	self rotationDegrees: oldRotation.! !!SketchMorph methodsFor: 'change reporting' stamp: 'tk 7/6/1998 14:26'!layoutChanged	"Update rotatedForm and offsetWhenRotated and compute new bounds."	| unrotatedOrigin |	self changed.	unrotatedOrigin _ bounds origin - offsetWhenRotated.	(rotationStyle == #none and: [scalePoint = (1.0@1.0)])		ifTrue: [			"zero rotation and scale; use original Form.			All normal rotation handled by TransformMorph.rotationDegrees:"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: [self generateRotatedForm].	"changes offsetWhenRotated"	bounds _ (unrotatedOrigin + offsetWhenRotated) extent: rotatedForm extent.	super layoutChanged.	self changed.! !!TransformationMorph methodsFor: 'accessing' stamp: 'tk 7/31/1998 12:35'!forwardDirection	"Same as rotationDegrees"| m |^ (((m _ self renderedMorph) isKindOf: SketchMorph) and: [m rotationStyle ~~ #normal]) 			ifTrue: [m rotationDegrees]			ifFalse: [self angle radiansToDegrees negated]! !!TransformationMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 14:37'!rotationDegrees: degrees	| m |	self adjustAfter:		[(m _ self renderedMorph) doesOwnRotation			ifTrue: ["is SketchMorph and rotationStyle is not #normal"				m rotationDegrees: degrees.				"self angle: 0.0 or not flexed"]			ifFalse: [self angle: degrees degreesToRadians negated]]	"usual case"! !!TransformationMorph methodsFor: 'private' stamp: 'tk 7/6/1998 13:31'!adjustAfter: changeBlock	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| oldRefPos |	oldRefPos _ transform invert: self renderedMorph referencePosition.	changeBlock value.	(self scale < 1.0 or: [self angle ~= (self angle roundTo: Float pi / 2.0)])		ifTrue: [smoothing _ 2]		ifFalse: [smoothing _ 1].	self layoutChanged.	self position: self position + (oldRefPos - 			(transform invert: self renderedMorph referencePosition)).! !