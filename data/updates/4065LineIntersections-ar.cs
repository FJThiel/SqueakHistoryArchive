'From Squeak3.1alpha of 28 February 2001 [latest update: #4064] on 24 May 2001 at 1:54:01 pm'!"Change Set:		LineIntersections-arDate:			24 May 2001Author:			Andreas RaabProvides a tool for computing all intersections of a set of (integer) line segments."!Object subclass: #LineIntersectionEvent	instanceVariableNames: 'position type segment crossedEdge '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Tools-Intersection'!!LineIntersectionEvent commentStamp: '<historical>' prior: 0!I represent an event that occurs during the computation of line segment intersections.Instance variables:	position		<Point>	The position of where this event occurs	type		<Symbol>	The type of the event	edge		<LineIntersectionSegment>	The edge associated with this event.	crossedEdge	<LineIntersectionSegment>	The crossing edge of a #cross event.!Object subclass: #LineIntersections	instanceVariableNames: 'segments activeEdges events intersections lastIntersections '	classVariableNames: 'Debug '	poolDictionaries: ''	category: 'Graphics-Tools-Intersection'!!LineIntersections commentStamp: '<historical>' prior: 0!This class computes all intersections of a set of line segments. The input segments must be integer coordinates. The intersections returned will be accurate, meaning that fractional points describing the intersections will be reported. It is up to the client to convert these fractional points if required.!LineSegment subclass: #LineIntersectionSegment	instanceVariableNames: 'referentEdge '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Tools-Intersection'!!LineIntersectionSegment commentStamp: '<historical>' prior: 0!I represent a line segment used during the computation of intersections.Instance variables:	referentEdge	<LineSegment>	The line segment this segment originated from.!!Heap class methodsFor: 'instance creation' stamp: 'ar 5/23/2001 17:22'!withAll: aCollection sortBlock: sortBlock	"Create a new heap with all the elements from aCollection"	^(self basicNew)		setCollection: aCollection asArray copy tally: aCollection size;		sortBlock: sortBlock;		yourself! !!LineIntersectionEvent methodsFor: 'initialize-release' stamp: 'ar 5/23/2001 21:58'!type: aSymbol position: aPoint segment: aSegment	type _ aSymbol.	position _ aPoint.	segment _ aSegment.! !!LineIntersectionEvent methodsFor: 'accessing' stamp: 'ar 5/23/2001 18:55'!crossedEdge	^crossedEdge! !!LineIntersectionEvent methodsFor: 'accessing' stamp: 'ar 5/23/2001 18:55'!crossedEdge: aSegment	crossedEdge _ aSegment! !!LineIntersectionEvent methodsFor: 'accessing' stamp: 'ar 5/23/2001 19:21'!edge	^segment! !!LineIntersectionEvent methodsFor: 'accessing' stamp: 'ar 5/23/2001 21:58'!position	^position! !!LineIntersectionEvent methodsFor: 'accessing' stamp: 'ar 5/23/2001 18:22'!priority	"Return the priority for this event"	type == #start ifTrue:[^3]. "first insert new segments"	type == #cross ifTrue:[^2]. "then process intersections"	type == #end ifTrue:[^1]. "then remove edges"	^self error:'Unknown type'! !!LineIntersectionEvent methodsFor: 'accessing' stamp: 'ar 5/23/2001 18:11'!segment	^segment! !!LineIntersectionEvent methodsFor: 'accessing' stamp: 'ar 5/23/2001 18:11'!type	^type! !!LineIntersectionEvent methodsFor: 'sorting' stamp: 'ar 5/23/2001 20:28'!sortsBefore: anEvent	(self position x = anEvent position x and:[self position y = anEvent position y])		ifFalse:[^self position sortsBefore: anEvent position].	^self priority > anEvent priority! !!LineIntersectionEvent class methodsFor: 'instance creation' stamp: 'ar 5/23/2001 18:10'!type: aSymbol position: aPoint segment: aSegment	^self new type: aSymbol position: aPoint segment: aSegment! !!LineIntersections methodsFor: 'computing' stamp: 'ar 5/23/2001 22:22'!computeIntersectionAt: leftIndex belowOrRightOf: aPoint	| leftEdge rightEdge pt evt |	leftIndex < 1 ifTrue:[^self].	leftIndex >= activeEdges size ifTrue:[^self].	leftEdge _ activeEdges at: leftIndex.	rightEdge _ activeEdges at: leftIndex+1.	Debug == true ifTrue:[		self debugDrawLine: leftEdge with: rightEdge color: Color yellow.		self debugDrawLine: leftEdge with: rightEdge color: Color blue.		self debugDrawLine: leftEdge with: rightEdge color: Color yellow.		self debugDrawLine: leftEdge with: rightEdge color: Color blue.	].	pt _ self intersectFrom: leftEdge start to: leftEdge end with: rightEdge start to: rightEdge end.	pt ifNil:[^self].	pt y < aPoint y ifTrue:[^self].	(pt y = aPoint y and:[pt x <= aPoint x]) ifTrue:[^self].	Debug == true ifTrue:[self debugDrawPoint: pt].	evt _ LineIntersectionEvent type: #cross position: pt segment: leftEdge.	evt crossedEdge: rightEdge.	events add: evt.! !!LineIntersections methodsFor: 'computing' stamp: 'ar 5/23/2001 20:24'!computeIntersectionsOf: anArrayOfLineSegments	segments _ anArrayOfLineSegments.	self initializeEvents.	self processEvents.	^intersections contents! !!LineIntersections methodsFor: 'computing' stamp: 'ar 5/23/2001 22:22'!crossEdgeEvent: evt	| evtPoint edge index other |	lastIntersections 		ifNil:[lastIntersections _ Array with: evt]		ifNotNil:[			(lastIntersections anySatisfy:				[:old| old edge == evt edge and:[old crossedEdge == evt crossedEdge]]) ifTrue:[^self].			lastIntersections _ lastIntersections copyWith: evt].	evtPoint _ evt position.	edge _ evt edge.	self recordIntersection: edge with: evt crossedEdge at: evtPoint.	Debug == true ifTrue:[		self debugDrawLine: edge with: evt crossedEdge color: Color red.		self debugDrawLine: edge with: evt crossedEdge color: Color blue.		self debugDrawLine: edge with: evt crossedEdge color: Color red.		self debugDrawLine: edge with: evt crossedEdge color: Color blue].	index _ self firstIndexForInserting: evtPoint.	[other _ activeEdges at: index.	other == edge] whileFalse:[index _ index + 1].	"Swap edges at index"	"self assert:[(activeEdges at: index+1) == evt crossedEdge]."	other _ activeEdges at: index+1.	activeEdges at: index+1 put: edge.	activeEdges at: index put: other.	"And compute new intersections"	self computeIntersectionAt: index-1 belowOrRightOf: evtPoint.	self computeIntersectionAt: index+1 belowOrRightOf: evtPoint.! !!LineIntersections methodsFor: 'computing' stamp: 'ar 5/23/2001 22:23'!endEdgeEvent: evt	| evtPoint edge index other |	evtPoint _ evt position.	edge _ evt edge.	Debug == true ifTrue:[self debugDrawLine: edge color: Color green].	index _ self firstIndexForInserting: evtPoint.	[other _ activeEdges at: index.	other == edge] whileFalse:[index _ index + 1].	"Remove edge at index"	activeEdges removeAt: index.	self computeIntersectionAt: index-1 belowOrRightOf: evtPoint.! !!LineIntersections methodsFor: 'computing' stamp: 'ar 5/23/2001 19:00'!initializeEvents	"Initialize the events for all given line segments"	| mySeg pt1 pt2 |	events _ WriteStream on: (Array new: segments size * 2).	segments do:[:seg|		pt1 _ seg start asPoint.		pt2 _ seg end asPoint.		(pt1 sortsBefore: pt2) 			ifTrue:[mySeg _ LineIntersectionSegment from: pt1 to: pt2]			ifFalse:[mySeg _ LineIntersectionSegment from: pt2 to: pt1].		mySeg referentEdge: seg.		events nextPut: (LineIntersectionEvent type: #start position: mySeg start segment: mySeg).		events nextPut: (LineIntersectionEvent type: #end position: mySeg end segment: mySeg).	].	events _ Heap withAll: events contents sortBlock: [:ev1 :ev2| ev1 sortsBefore: ev2].! !!LineIntersections methodsFor: 'computing' stamp: 'ar 5/23/2001 22:19'!processEvents	| evt |	intersections _ WriteStream on: (Array new: segments size).	activeEdges _ OrderedCollection new.	[events isEmpty] whileFalse:[		evt _ events removeFirst.		evt type == #start ifTrue:[self startEdgeEvent: evt].		evt type == #end ifTrue:[self endEdgeEvent: evt].		evt type == #cross 			ifTrue:[self crossEdgeEvent: evt]			ifFalse:[lastIntersections _ nil].	].! !!LineIntersections methodsFor: 'computing' stamp: 'ar 5/23/2001 20:26'!recordIntersection: edge with: other at: evtPoint	intersections nextPut:		(Array with: evtPoint				with: edge referentEdge				with: other referentEdge).! !!LineIntersections methodsFor: 'computing' stamp: 'ar 5/23/2001 22:23'!startEdgeEvent: evt	| idx edge evtPoint index keepChecking other side |	edge _ evt segment.	Debug == true ifTrue:[self debugDrawLine: edge color: Color blue].	evtPoint _ evt position.	"Find left-most insertion point"	idx _ self firstIndexForInserting: evtPoint.	index _ idx.	keepChecking _ true.	"Check all edges containing the same insertion point"	[idx <= activeEdges size		ifTrue:[	other _ activeEdges at: idx.				side _ other sideOfPoint: evtPoint]		ifFalse:[side _ -1].	side = 0] whileTrue:[		idx _ idx + 1.		self recordIntersection: edge with: other at: evtPoint.		"Check edges as long as we haven't found the insertion index"		keepChecking ifTrue:[			(self isLeft: other direction comparedTo: edge direction)				ifTrue:[index _ index + 1]				ifFalse:[keepChecking _ false]].	].	activeEdges add: edge afterIndex: index-1.	self computeIntersectionAt: index-1 belowOrRightOf: evtPoint.	self computeIntersectionAt: index belowOrRightOf: evtPoint.! !!LineIntersections methodsFor: 'private' stamp: 'ar 5/23/2001 18:31'!firstIndexForInserting: aPoint	| index |	index _ self indexForInserting: aPoint.	[index > 1 and:[((activeEdges at: index-1) sideOfPoint: aPoint) = 0]]		whileTrue:[index _ index-1].	^index! !!LineIntersections methodsFor: 'private' stamp: 'ar 5/23/2001 19:19'!indexForInserting: aPoint	"Return the appropriate index for inserting the given x value"	| index low high side |	low _ 1.	high _ activeEdges size.	[index _ (high + low) bitShift: -1.	low > high] whileFalse:[		side _ (activeEdges at: index) sideOfPoint: aPoint.		side = 0 ifTrue:[^index].		side > 0			ifTrue:[high _ index - 1]			ifFalse:[low _ index + 1]].	^low! !!LineIntersections methodsFor: 'private' stamp: 'ar 5/23/2001 20:32'!intersectFrom: pt1Start to: pt1End with: pt2Start to: pt2End	| det deltaPt alpha beta pt1Dir pt2Dir |	pt1Dir _ pt1End - pt1Start.	pt2Dir _ pt2End - pt2Start.	det _ (pt1Dir x * pt2Dir y) - (pt1Dir y * pt2Dir x).	deltaPt _ pt2Start - pt1Start.	alpha _ (deltaPt x * pt2Dir y) - (deltaPt y * pt2Dir x).	beta _ (deltaPt x * pt1Dir y) - (deltaPt y * pt1Dir x).	det = 0 ifTrue:[^nil]. "no intersection"	alpha * det < 0 ifTrue:[^nil].	beta * det < 0 ifTrue:[^nil].	det > 0 		ifTrue:[(alpha > det or:[beta > det]) ifTrue:[^nil]]		ifFalse:[(alpha < det or:[beta < det]) ifTrue:[^nil]].	"And compute intersection"	^pt1Start + (alpha * pt1Dir / (det@det))! !!LineIntersections methodsFor: 'private' stamp: 'ar 5/23/2001 19:26'!isLeft: dir1 comparedTo: dir2	"Return true if dir1 is left of dir2"	| det |	det _ ((dir1 x * dir2 y) - (dir2 x * dir1 y)).	"det = 0 ifTrue:[self error:'line on line']."	^det <= 0! !!LineIntersections methodsFor: 'debug' stamp: 'ar 5/23/2001 20:15'!debugDrawLine: line color: aColor	Display getCanvas		line: (line start * self debugScale)		to: (line end * self debugScale)		width: 3		color: aColor.	self debugWait.! !!LineIntersections methodsFor: 'debug' stamp: 'ar 5/23/2001 20:15'!debugDrawLine: line1 with: line2 color: aColor	Display getCanvas		line: (line1 start * self debugScale)		to: (line1 end * self debugScale)		width: 3		color: aColor.	Display getCanvas		line: (line2 start * self debugScale)		to: (line2 end * self debugScale)		width: 3		color: aColor.	self debugWait.! !!LineIntersections methodsFor: 'debug' stamp: 'ar 5/23/2001 20:15'!debugDrawPoint: pt	Display getCanvas		fillRectangle: (pt * self debugScale - 3 extent: 6@6) truncated color: Color red.	self debugWait.! !!LineIntersections methodsFor: 'debug' stamp: 'ar 5/23/2001 22:07'!debugScale	^1! !!LineIntersections methodsFor: 'debug' stamp: 'ar 5/23/2001 22:21'!debugWait	(Delay forMilliseconds: 100) wait.! !!LineIntersections class methodsFor: 'instance creation' stamp: 'ar 5/23/2001 17:16'!of: anArrayOfLineSegments	^self new computeIntersectionsOf: anArrayOfLineSegments! !!LineIntersections class methodsFor: 'debug' stamp: 'ar 5/23/2001 22:33'!debugMode	^Debug == true! !!LineIntersections class methodsFor: 'debug' stamp: 'ar 5/23/2001 22:34'!debugMode: aBool	"LineIntersections debugMode: true"	"LineIntersections debugMode: false"	Debug _ aBool.! !!LineIntersections class methodsFor: 'example' stamp: 'ar 5/23/2001 22:33'!exampleLines: n	"LineIntersections exampleLines: 100"	| segments rnd canvas intersections pt p1 p2 |	rnd _ Random new.	segments _ (1 to: n) collect:[:i|		p1 _ (rnd next @ rnd next * 500) asIntegerPoint.		[p2 _ (rnd next @ rnd next * 200 - 100) asIntegerPoint.		p2 isZero] whileTrue.		LineSegment from: p1 to: p1 + p2].	canvas _ Display getCanvas.	canvas fillRectangle: (0@0 extent: 600@600) color: Color white.	segments do:[:seg|		canvas line: seg start to: seg end width: 1 color: Color black.	].	intersections _ LineIntersections of: segments.	intersections do:[:array|		pt _ array at: 1.		canvas fillRectangle: (pt asIntegerPoint - 2 extent: 5@5) color: Color red].	Display restoreAfter:[].! !!LineSegment methodsFor: 'accessing' stamp: 'ar 5/23/2001 19:11'!direction	^end - start! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 5/23/2001 18:27'!sideOfPoint: aPoint	"Return the side of the receiver this point is on. The method returns		-1: if aPoint is left		 0: if aPoint is on		+1: if a point is right	of the receiver."	| dx dy px py |	dx _ end x - start x.	dy _ end y - start y.	px _ aPoint x - start x.	py _ aPoint y - start y.	^((dx * py) - (px * dy)) sign"	(LineSegment from: 0@0 to: 100@0) sideOfPoint: 50@-50.	(LineSegment from: 0@0 to: 100@0) sideOfPoint: 50@50.	(LineSegment from: 0@0 to: 100@0) sideOfPoint: 50@0."! !!LineIntersectionSegment methodsFor: 'accessing' stamp: 'ar 5/23/2001 18:09'!referentEdge	^referentEdge! !!LineIntersectionSegment methodsFor: 'accessing' stamp: 'ar 5/23/2001 18:09'!referentEdge: anEdge	referentEdge _ anEdge! !!Point methodsFor: 'point functions' stamp: 'ar 5/23/2001 21:29'!squaredDistanceTo: aPoint	"Answer the distance between aPoint and the receiver."	| delta |	delta _ aPoint - self.	^delta dotProduct: delta! !