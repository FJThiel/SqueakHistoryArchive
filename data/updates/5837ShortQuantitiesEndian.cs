'From Squeak3.7alpha of 11 September 2003 [latest update: #5816] on 18 March 2004 at 8:55:36 am'!"Change Set:		ShortQuantitiesEndianDate:			17 March 2004Author:			Yoshiki OhshimaLater fixes by:	Ned KonzRestoring the endianness of 16-bit quantity array object are wrong from a place to another.  This fixes the ones I noticed.With this patch, you can:		* save and restore the Squeaky Mouse.	* save and restore TTFontDescriptions across the platforms.7 Mar (Ned Konz): fixes to make ShortIntegerArray and ShortPointArray work too:* moved restoreEndianness up to ShortIntegerArray* added bytesPerElement to ShortIntegerArray17 March (Ned Konz):	more fixes to ShortIntegerArray hierarchy"!!ArrayedCollection methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 15:22'!byteSize	^self basicSize * self bytesPerBasicElement! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 16:28'!bytesPerBasicElement	"Answer the number of bytes that each of my basic elements requires.	In other words:		self basicSize * self bytesPerBasicElement	should equal the space required on disk by my variable sized representation."	^self class isBytes ifTrue: [ 1 ] ifFalse: [ 4 ]! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 18:51'!bytesPerElement	^self class isBytes ifTrue: [ 1 ] ifFalse: [ 4 ].! !!MatrixTransform2x3 methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 16:06'!byteSize	^self basicSize * self bytesPerBasicElement! !!MatrixTransform2x3 methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 15:04'!bytesPerBasicElement	"Answer the number of bytes that each of my basic elements requires.	In other words:		self basicSize * self bytesPerBasicElement	should equal the space required on disk by my variable sized representation."	^4! !!MatrixTransform2x3 methodsFor: 'objects from disk' stamp: 'yo 3/6/2004 12:57'!bytesPerElement	^ 4.! !!MatrixTransform2x3 methodsFor: 'objects from disk' stamp: 'yo 3/6/2004 15:33'!restoreEndianness	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."	| w b1 b2 b3 b4 |	SmalltalkImage current  isLittleEndian ifTrue: [		1 to: self basicSize do: [:i |			w _ self basicAt: i.			b1 _ w digitAt: 1.			b2 _ w digitAt: 2.			b3 _ w digitAt: 3.			b4 _ w digitAt: 4.			w _ (b1 << 24) + (b2 << 16) + (b3 << 8) + b4.			self basicAt: i put: w.		]	].! !!PositionableStream methodsFor: 'accessing' stamp: 'nk 3/18/2004 08:52'!nextWordsInto: aBitmap 	"Fill the word based buffer from my collection. 	Stored on stream as Big Endian. Optimized for speed. 	Read in BigEndian, then restoreEndianness."	| blt pos source byteSize |	collection class isBytes		ifFalse: [^ self next: aBitmap size into: aBitmap startingAt: 1].	byteSize := aBitmap byteSize.	"is the test on collection basicSize \\ 4 necessary?"	((self position bitAnd: 3) = 0 and: [ (collection basicSize bitAnd: 3) = 0])		ifTrue: [source := collection.			pos := self position.			self skip: byteSize]		ifFalse: ["forced to copy it into a buffer"			source := self next: byteSize.			pos := 0].	"Now use BitBlt to copy the bytes to the bitmap."	blt := (BitBlt current				toForm: (Form new hackBits: aBitmap))				sourceForm: (Form new hackBits: source).	blt combinationRule: Form over. "store"	blt sourceX: 0;		 sourceY: pos // 4;		 height: byteSize // 4;		 width: 4.	blt destX: 0;		 destY: 0.	blt copyBits.	"And do whatever the bitmap needs to do to convert from big-endian order."	aBitmap restoreEndianness.	^ aBitmap 	"May be WordArray, ColorArray, etc"! !!ShortIntegerArray methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 16:11'!bytesPerBasicElement	^4! !!ShortIntegerArray methodsFor: 'objects from disk' stamp: 'nk 3/7/2004 13:54'!bytesPerElement	^2! !!ShortIntegerArray methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 18:41'!restoreEndianness	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."	| hack blt |	SmalltalkImage current  isLittleEndian ifTrue: [		"The implementation is a hack, but fast for large ranges"		hack _ Form new hackBits: self.		blt _ (BitBlt toForm: hack) sourceForm: hack.		blt combinationRule: Form reverse.  "XOR"		blt sourceY: 0; destY: 0; height: hack height; width: 1.		blt sourceX: 0; destX: 1; copyBits.  "Exchange bytes 0 and 1"		blt sourceX: 1; destX: 0; copyBits.		blt sourceX: 0; destX: 1; copyBits.		blt sourceX: 2; destX: 3; copyBits.  "Exchange bytes 2 and 3"		blt sourceX: 3; destX: 2; copyBits.		blt sourceX: 2; destX: 3; copyBits	].! !!ShortIntegerArray methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 18:55'!writeOn: aStream 	aStream nextInt32Put: self basicSize.	1 to: self basicSize do: [ :i | | w |		w _ self basicAt: i.		SmalltalkImage current  isLittleEndian			ifFalse: [ aStream nextNumber: 4 put:  w ]			ifTrue: [ aStream				nextPut: (w digitAt: 2);				nextPut: (w digitAt: 1);				nextPut: (w digitAt: 4);				nextPut: (w digitAt: 3) ]].! !!ShortPointArray methodsFor: 'accessing' stamp: 'yo 3/6/2004 12:56'!bytesPerElement	^ 4.	! !!ShortRunArray methodsFor: 'accessing' stamp: 'yo 3/6/2004 14:19'!bytesPerElement	^ 4! !!ShortRunArray methodsFor: 'objects from disk' stamp: 'yo 3/6/2004 15:10'!restoreEndianness	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."	| w b1 b2 b3 b4 |	SmalltalkImage current  isLittleEndian ifTrue: [		1 to: self basicSize do: [:i |			w _ self basicAt: i.			b1 _ w digitAt: 1.			b2 _ w digitAt: 2.			b3 _ w digitAt: 3.			b4 _ w digitAt: 4.			w _ (b1 << 24) + (b2 << 16) + (b3 << 8) + b4.			self basicAt: i put: w.		]	].! !StandardFileStream removeSelector: #nextWordsPutAll:!!MatrixTransform2x3 reorganize!('*connectors-initialize')('*morphic-Postscript Canvases' encodePostscriptOn:)('*nebraska-Morphic-Remote' encodeForRemoteCanvas)('accessing' at: at:put: inverseTransformation offset offset:)('comparing' = hash)('composing' composedWithLocal: composedWithLocal:into:)('converting' asMatrixTransform2x3)('element access' a11 a11: a12 a12: a13 a13: a21 a21: a22 a22: a23 a23:)('initialize' setIdentiy)('objects from disk' byteSize bytesPerBasicElement bytesPerElement restoreEndianness writeOn:)('printing' printOn:)('testing' isIdentity isMatrixTransform2x3 isPureTranslation)('transforming points' globalPointToLocal: invertPoint: localPointToGlobal: transformDirection: transformPoint:)('transforming rects' globalBounds:toLocal: globalBoundsToLocal: localBounds:toGlobal: localBoundsToGlobal:)('private' setAngle: setOffset: setScale:)!ArrayedCollection removeSelector: #basicByteSize!