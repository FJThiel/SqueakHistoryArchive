'From Squeak2.7alpha of 9 November 1999 [latest update: #1617] on 23 November 1999 at 11:46:20 am'!"Change Set:		wiwRAA1120Date:			20 November 1999Author:			Bob Arningchanges noted in email"!PasteUpMorph subclass: #WiWPasteUpMorph	instanceVariableNames: 'parentWorld hostWindow pendingEvent '	classVariableNames: 'Debug '	poolDictionaries: ''	category: 'Morphic-WiW'!!ContextPart methodsFor: 'debugger access' stamp: 'RAA 11/21/1999 14:43'!longStack	"Answer a String showing the top ten contexts on my sender chain."	^ String streamContents:		[:strm |		(self stackOfSize: 55)			do: [:item | strm print: item; cr]]! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 11/21/1999 15:45'!processEvents	"Process user input events from the local input devices."	| griddedPoint evt currentExtent |	griddedPoint _ Sensor cursorPoint "- owner viewBox topLeft".	gridOn ifTrue: [griddedPoint _ griddedPoint grid: grid].	evt _ MorphicEvent new		setMousePoint: griddedPoint		buttons: Sensor primMouseButtons		lastEvent: lastEvent		hand: self.	remoteConnections size > 0 ifTrue: [		currentExtent _ self worldBounds extent.		lastWorldExtent ~= currentExtent ifTrue: [			self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).			lastWorldExtent _ currentExtent].		self transmitEvent: evt].	self handleEvent: evt.	[Sensor keyboardPressed] whileTrue: [		evt _ MorphicEvent new			setKeyValue: Sensor keyboard asciiValue			mousePoint: griddedPoint			buttons: Sensor primMouseButtons			hand: self.		remoteConnections size > 0 ifTrue: [self transmitEvent: evt].		self handleEvent: evt].! !!HandMorph methodsFor: 'world menu' stamp: 'RAA 11/20/1999 08:52'!openMenu"temporary support of WorldWindow (easy open)"	"Build the open window menu for the world."	| menu |	menu _ (MenuMorph entitled: 'open...') defaultTarget: self.	menu addStayUpItem.	menu add: 'browser' action: #openBrowser.	menu add: 'method finder' action: #openSelectorBrowser.	menu add: 'workspace' action: #openWorkspace.	menu add: 'file list' action: #openFileList.	menu add: 'file...' action: #openFileDirectly.	menu add: 'transcript' action: #openTranscript.	menu add: 'WorldInWindow' action: #openWorldInWindow.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'email reader' action: #openEmail.	menu add: 'web browser' action: #openWebBrowser.	menu add: 'IRC chat' action: #openIRC.	menu addLine.	(Preferences allowMVCprojects and: [Smalltalk includesKey: #StandardSystemView])		ifTrue: [menu add: 'project (mvc)' action: #openMVCProject].	menu add: 'project (morphic)' action: #openMorphicProject.	menu add: 'project (construction)' action: #openConstructionProject.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'RAA 11/20/1999 08:52'!openWorldInWindow		WorldWindow test1! !!MenuMorph methodsFor: 'control' stamp: 'RAA 11/23/1999 11:37'!popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta tryToPlace selectedOffset |	self flag: #na.		"removing WiW change no longer needed"	hand world startSteppingSubmorphsOf: self.	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | each == lastSelection]							ifNone: [self items first].	self fullBounds.  "ensure layout is current"	selectedOffset := selectedItem position - self position.	tryToPlace :=		[ :where :mustFit |		self position: where - selectedOffset.		delta _ self fullBoundsInWorld amountToTranslateWithin: hand worldBounds.		(delta x = 0 or: [mustFit]) ifTrue:			[delta = (0@0) ifFalse: [self position: self position + delta].			sourceItem owner owner addMorphFront: self.			^ self]].	tryToPlace 		value: rightOrLeftPoint first value: false;		value: rightOrLeftPoint last  - (self width @ 0) value: false;		value: rightOrLeftPoint first value: true	! !!MenuMorph methodsFor: 'control' stamp: 'RAA 11/23/1999 11:38'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem i yOffset sub delta |	self flag: #na.		"removing WiW change no longer needed"	popUpOwner _ hand.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | each == lastSelection]				ifNone: [self items isEmpty						ifTrue: [^ self]						ifFalse: [self items first]].	"Note: items may not be laid out yet (I found them all to be at 0@0), 	so have to add up heights of items above the selected item."	i _ 0.	yOffset _ 0.	[(sub _ self submorphs at: (i _ i + 1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	self bounds right > hand worldBounds right		ifTrue: [self position: self position - (self bounds width - 4 @ 0)].	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self; startSteppingSubmorphsOf: self.	hand newMouseFocus: selectedItem.	self changed! !!MenuMorph methodsFor: 'control' stamp: 'RAA 11/23/1999 11:38'!popUpAt: aPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta |	self flag: #na.		"removing WiW change no longer needed"	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self items detect:		 [:each | each == lastSelection] ifNone: [self items first].	self fullBounds.  "ensure layout is current"	self position: aPoint - (selectedItem position - self position).	sourceItem owner owner addMorphFront: self.	delta _ self fullBoundsInWorld amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 11/23/1999 11:11'!displayWorld	"Update this world's display."	| deferredUpdateMode updateNeeded worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	updateNeeded _ self damageRecorder updateIsNeeded.	updateNeeded ifFalse: [		self handsDo: [:h |			(h hasChanged and: [h needsToBeDrawn])				ifTrue: [updateNeeded _ true]]].	updateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdating.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawInvalidAreasOn: self canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: self canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: self canvas].  "draw hands onto world canvas"	false ifTrue: [  "*make this true to flash damaged areas for testing*"		self flashRects: allDamage color: Color black].	self canvas flush.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [allDamage do: [:r | Display forceToScreen: (r "translateBy: self viewBox origin")]]		ifFalse: [self canvas showAt: self viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: self canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 11/23/1999 11:29'!drawInvalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect |	rectList _ self damageRecorder invalidRectsFullBounds: ("0@0 extent:" self viewBox "extent").	self damageRecorder reset.	n _ self submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	rectList do: [:r |		true		ifTrue:			["Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:				[mm _ submorphs at: i.				((mm fullBounds intersects: r) and: [mm visible]) ifTrue:					[morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]].				i _ i+1].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:				[c _ aCanvas copyClipRect: rectToFill.				c fillColor: color.				turtleTrailsForm ifNotNil: [c image: turtleTrailsForm at: 0@0]].			[morphs isEmpty] whileFalse:				[(rect _ rects removeLast) == rectToFill ifFalse:					[c _ aCanvas copyClipRect: (rectToFill _ rect)].				morphs removeLast fullDrawOn: c].			morphs reset.  rects reset]		ifFalse: [c _ aCanvas copyClipRect: r.				c fillColor: color.				turtleTrailsForm ifNotNil: [c image: turtleTrailsForm at: 0@0].				submorphs reverseDo: [:m | m fullDrawOn: c]]		].	^ rectList! !!PasteUpMorph methodsFor: 'WiW support' stamp: 'RAA 11/20/1999 09:53'!restartWorldCycleWithEvent: evt	"redispatch that click in outer world not yet for main world"	"pendingEvent _ evt."	Project current spawnNewProcessAndTerminateOld: true! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:49'!initialFrameFor: aView initialExtent: initialExtent	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen."	| allOrigins screenRight screenBottom putativeOrigin putativeFrame allowedArea staggerOrigin otherFrames |	Preferences reverseWindowStagger ifTrue:		[^ self strictlyStaggeredInitialFrameFor: aView initialExtent: initialExtent].	allowedArea _ self maximumUsableArea.	screenRight _ allowedArea right.	screenBottom _ allowedArea bottom.	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: World satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	allOrigins _ otherFrames collect: [:f | f origin].	self standardPositions do:  "First see if one of the standard positions is free"		[:aPosition | (allOrigins includes: aPosition)			ifFalse:				[^ (aPosition extent: initialExtent) squishedWithin: allowedArea]].	staggerOrigin _ self standardPositions first.  "Fallback: try offsetting from top left"	putativeOrigin _ staggerOrigin.	[putativeOrigin _ putativeOrigin + StaggerOffset.	putativeFrame _ putativeOrigin extent: initialExtent.	(putativeFrame bottom < screenBottom) and:					[putativeFrame right < screenRight]]				whileTrue:					[(allOrigins includes: putativeOrigin)						ifFalse:							[^ (putativeOrigin extent: initialExtent) squishedWithin: allowedArea]].	^ (self scrollBarSetback @ self screenTopSetback extent: initialExtent) squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:49'!maximumUsableArea	| allowedArea |	allowedArea _ Display usableArea.	Smalltalk isMorphic ifTrue: [allowedArea _ allowedArea intersect: World viewBox].	^allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:49'!standardPositions	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  "	| anArea aList  midX midY |	anArea _ self maximumUsableArea.	midX _ self scrollBarSetback +   ((anArea width - self scrollBarSetback)  // 2).	midY _ self screenTopSetback + ((anArea height - self screenTopSetback) // 2).	aList _ OrderedCollection with: (self scrollBarSetback @ self screenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ self screenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (self scrollBarSetback @ (midY+self screenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+self screenTopSetback))]].	^ aList! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:55'!standardWindowExtent	"Answer the standard default extent for new windows.  "	| effectiveExtent width strips height grid allowedArea maxLevel |	effectiveExtent _ self maximumUsableArea extent					- (self scrollBarSetback @ self screenTopSetback).	Preferences reverseWindowStagger ifTrue:		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"		allowedArea _ self maximumUsableArea insetBy: (			self scrollBarSetback @ self screenTopSetback extent: 0@0		).		"Number to be staggered at each corner (less on small screens)"		maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].		"Amount by which to stagger (less on small screens)"		grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: StandardSize "600@400"].	width _ (strips _ self windowColumnsDesired) > 1		ifTrue:			[effectiveExtent x // strips]		ifFalse:			[(3 * effectiveExtent x) // 4].	height _ (strips _ self windowRowsDesired) > 1		ifTrue:			[effectiveExtent y // strips]		ifFalse:			[(3 * effectiveExtent y) //4].	^ width @ height"RealEstateAgent standardWindowExtent"! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:53'!strictlyStaggeredInitialFrameFor: aStandardSystemView	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	"	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea _ self maximumUsableArea insetBy: (		self scrollBarSetback @ self screenTopSetback extent: 0@0	).	"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((aStandardSystemView initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: World satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			otherFrames do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (self scrollBarSetback @ self screenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:53'!strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	"	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea _ self maximumUsableArea insetBy: (		self scrollBarSetback @ self screenTopSetback extent: 0@0	).	"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: World satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			otherFrames do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (self scrollBarSetback @ self screenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:54'!windowColumnsDesired	"Answer how many separate vertical columns of windows are wanted.  5/22/96 sw"	^ Preferences reverseWindowStagger		ifTrue:			[1]		ifFalse:			[(self maximumUsableArea width > 640)				ifTrue:					[2]				ifFalse:					[1]]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:54'!windowRowsDesired	"Answer how many separate horizontal rows of windows are wanted.  5/22/96 sw"	^ Preferences reverseWindowStagger		ifTrue:			[1]		ifFalse:			[(self maximumUsableArea height > 480)				ifTrue:					[2]				ifFalse:					[1]]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'RAA 11/21/1999 23:25'!doFastWindowReframe: ptName	| newBounds |	"For fast display, only higlight the rectangle during loop"	newBounds _ self bounds newRectFrom: [:f | 		f 			withSideOrCorner: ptName			setToPoint: (self pointFromWorld: Sensor cursorPoint)			minExtent: 100@80	].	self bounds: newBounds! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'RAA 11/21/1999 23:25'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) ifTrue:  [^ self].	((self world ifNil: [^ self]) firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[^ self  "Prevent multiple handles"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ self bounds withSideOrCorner: ptName setToPoint: localPt minExtent: 100@80.			self fastFramingOn 			ifTrue:				[self doFastWindowReframe: ptName]			ifFalse:				[self bounds: newBounds.				(Preferences roundedWindowCorners					and: [#(bottom right bottomRight) includes: ptName])					ifTrue:					["Complete kluge: causes rounded corners to get painted correctly,					in spite of not working with top-down displayWorld."					ptName = #bottom ifFalse:						[self invalidRect: (self bounds topRight - (6@0) extent: 7@7)].					ptName = #right ifFalse:						[self invalidRect: (self bounds bottomLeft - (0@6) extent: 7@7)].					self invalidRect: (self bounds bottomRight - (6@6) extent: 7@7)]]]		lastPointDo:			[:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'events' stamp: 'RAA 11/21/1999 22:59'!doFastFrameDrag	| offset newBounds |	offset _ self position - Sensor cursorPoint.	newBounds _ self bounds newRectFrom: [:f | 		Sensor cursorPoint + offset extent: self extent	].	^ self position: newBounds topLeft! !!SystemWindow methodsFor: 'events' stamp: 'RAA 11/21/1999 22:58'!mouseDown: evt	| cp |	TopWindow == self ifFalse: [self activate].	(Sensor redButtonPressed "If mouse is really still down after activate"		and: [self labelRect containsPoint: evt cursorPoint]) ifTrue: [		self fastFramingOn 			ifTrue: [^ self doFastFrameDrag]			ifFalse: [^ evt hand grabMorph: self topRendererOrSelf]	].	model windowActiveOnFirstClick ifTrue:		["Normally window keeps control of first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseDown: evt]]]! !!SystemWindow methodsFor: 'drawing' stamp: 'RAA 11/23/1999 11:39'!makeMeVisible 	self flag: #na.		"removing WiW change no longer needed"	((self world bounds insetBy: (0@0 corner: self labelHeight asPoint))		containsPoint: self position) ifTrue: [^ self "OK -- at least my top left is visible"].	"window not on screen (probably due to reframe) -- move it now"	self isCollapsed		ifTrue: [self position: (RealEstateAgent assignCollapsePointFor: self)]		ifFalse: [self position: (RealEstateAgent initialFrameFor: self initialExtent: self extent) topLeft].! !!SystemWindow methodsFor: 'menu' stamp: 'RAA 11/21/1999 23:02'!buildWindowMenu	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'change title...' action: #relabel.	aMenu addLine.	aMenu add: 'send to back' action: #sendToBack.	aMenu add: 'make next-to-topmost' action: #makeSecondTopmost.	aMenu addLine.	self mustNotClose		ifFalse:			[aMenu add: 'make unclosable' action: #makeUnclosable]		ifTrue:			[aMenu add: 'make closable' action: #makeClosable].	aMenu add: 'full screen' action: #fullScreen.	self isCollapsed ifFalse: [aMenu add: 'window color...' action: #setWindowColor].	^aMenu! !!SystemWindow methodsFor: 'menu' stamp: 'RAA 11/21/1999 23:01'!offerWindowMenu	| aMenu |	aMenu _ self buildWindowMenu.	model ifNotNil:		[model addModelItemsToWindowMenu: aMenu].	aMenu popUpAt: self cursorPoint event: self currentEvent! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/23/1999 09:26'!becomeTheActiveWorldWith: evt	World == self ifTrue: [^ self].	self damageRecorder reset.	"since we may have moved, old data no longer valid"	hostWindow setStripeColorsFrom: Color green.	World _ self.	self canvas: nil.	"safer to start from scratch"	self viewBox: hostWindow panelRect.	self installFlaps.	self startSteppingSubmorphsOf: self.	self changed.	pendingEvent _ nil.	self primaryHand handleEvent: (evt setHand: self primaryHand).! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/23/1999 09:01'!doOneCycle	pendingEvent ifNotNil: [		self primaryHand handleEvent: (pendingEvent setHand: self primaryHand).		pendingEvent _ nil.	].	^super doOneCycle.! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/22/1999 09:51'!hostWindow: x	hostWindow _ x.	self canvas: nil.	"safer to start from scratch"	self viewBox: hostWindow panelRect.! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/20/1999 15:11'!initialize	super initialize.	parentWorld _ World.! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/23/1999 09:12'!mouseDown: evt	World == self ifTrue: [^ super mouseDown: evt].	(self bounds containsPoint: evt cursorPoint) ifFalse: [^ self].	self becomeTheActiveWorldWith: evt.! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/23/1999 11:11'!resetViewBox	| c |	(c _ self canvas) == nil ifTrue: [^self resetViewBoxForReal].	c form == Display ifFalse: [^self resetViewBoxForReal].	c origin = (0@0) ifFalse: [^self resetViewBoxForReal].	c clipRect extent = (self viewBox intersect: parentWorld viewBox) extent ifFalse: [^self resetViewBoxForReal].			! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/23/1999 11:35'!resetViewBoxForReal	| newClip |	self viewBox ifNil: [^self].	newClip _ self viewBox intersect: parentWorld viewBox.	self canvas: (		(FormCanvas on: Display)			copyOffset:  0@0			clipRect: newClip	)! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/23/1999 09:06'!restartWorldCycleWithEvent: evt	"redispatch that click in outer world"	pendingEvent _ evt.	Project current spawnNewProcessAndTerminateOld: true! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/23/1999 11:45'!revertToParentWorldWithEvent: evt	self damageRecorder reset.	"Terminate local display"	World _ parentWorld.	World assuredCanvas.	World installFlaps.	owner changed.	hostWindow setStripeColorsFrom: Color red.	"Dan, I put this back in so we don't try to finish the current cycle with the old world's hand"	World restartWorldCycleWithEvent: evt.! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 23:07'!validateMouseEvent: evt	"any click outside returns us to our home world"	(self bounds containsPoint: (evt cursorPoint "+ self viewBox topLeft")) ifFalse: [		self revertToParentWorldWithEvent: evt.	].! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 23:08'!viewBox: newViewBox	| vb |	self damageRecorder reset.	"since we may have moved, old data no longer valid"	((vb _ self viewBox) == nil or: [vb ~= newViewBox])		ifTrue: [self canvas: nil].	worldState viewBox: newViewBox.	bounds _ newViewBox.	self assuredCanvas.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self handsDo: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !!WiWPasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 11/20/1999 08:05'!say: x	(Debug ifNil: [Debug _ OrderedCollection new])		add: x asString,''.	Debug size > 500 ifTrue: [Debug _ Debug copyFrom: 200 to: Debug size]! !!WorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 23:05'!buildWindowMenu	| aMenu |	aMenu _ super buildWindowMenu.	{640@480. 800@600. 832@624. 1024@768} do: [ :each |		aMenu 			add: each x printString,' x ',each y printString 			target: self 			selector: #extent: 			argument: each + (0@self labelHeight).	].	^aMenu! !!WorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 11/23/1999 09:27'!mouseUp: evt	(self panelRect containsPoint: evt cursorPoint)		ifTrue: [model becomeTheActiveWorldWith: evt]! !Morph removeSelector: #globalWorldBounds!PasteUpMorph removeSelector: #globalWorldBounds!WiWPasteUpMorph removeSelector: #globalWorldBounds!WiWPasteUpMorph removeSelector: #drawSubmorphsOn:!WiWPasteUpMorph removeSelector: #becomeTheActiveWorld!WiWPasteUpMorph removeSelector: #revertToParentWorld!