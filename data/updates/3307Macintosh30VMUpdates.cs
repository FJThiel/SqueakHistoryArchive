'From Squeak2.9alpha of 13 June 2000 [latest update: #3299] on 2 February 2001 at 12:57:02 am'!!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/1/2001 23:39'!macAsyncFilePrimsFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "AsynchFilePlugin.h"#include <devices.h>#if !!TARGET_API_MAC_CARBON#define DisposeIOCompletionUPP(userUPP) DisposeRoutineDescriptor(userUPP)#endif/* initialize/shutdown */int asyncFileInit() { return true; }int asyncFileShutdown() {} /* End of adjustments for pluginized VM *//*  Experimental support for asynchronous file reading and writing.  When a read or write operation is initiated, control is returned to Squeak  immediately. A semaphore is signaled when the operation completes, at which  time the client can find out how many bytes were actually read or written  and copy the results of the read operation from the file buffer into a Squeak  buffer. Only one operation may be in progress on a given file at a given time,  but operations on different files may be done in parallel.  The semaphore is signalled once for each transfer operation that is successfully  started, even if that operation later fails. Write operations always write  their entire buffer if they succeed, but read operations may transfer less than  their buffer size if they are started less than a buffer''s size from the end  of the file.    The state of a file is kept in the following structure, which is stored directly  in a Squeak ByteArray object:    typedef struct {	  int				sessionID;	  AsyncFileState	*state;    } AsyncFile;  The session ID is used to detect stale files--files that were open  when the image was saved. The state pointer of such files is meaningless.  Async file handles use the same session ID as ordinary file handles.  Note: These primitives are experimental!! They need not be implemented on  every platform, and they may be withdrawn or replaced in a future release.*/#include <Errors.h>#include <Files.h>#include <Strings.h>/* Async file handle (defined in header file):*/typedef struct {	ParamBlockRec pb;  /* must be first */	long	refNum;	int		writable;	int		semaIndex;	int		status;	int		bytesTransferred;	int		bufferSize;	char 	*bufferPtr;} AsyncFileState;/*** Status Values ***/#define IDLE			0#define LAST_OP_FAILED	1#define BUSY			2/*** Imported Variables ***/extern int successFlag;extern int thisSession;/*** Local Vaiables ***/IOCompletionUPP asyncFileCompletionProc = nil;/*** Exported Functions ***/int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** Local Functions ***/int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount);pascal void asyncFileCompletionRoutine(AsyncFileState *state);int asyncFileInitPB(AsyncFileState *state, int fPosition);int asyncFileValid(AsyncFile *f);int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount) {  /* Allocate a new buffer of the given size if necessary. If the current buffer	 is already allocated and of the desired size, do nothing. */	if ((state->bufferPtr !!= nil) && (state->bufferSize == byteCount)) {		return;  /* buffer is already allocated and of the desired size */	}	/* free old buffer, if any */	if (state->bufferPtr !!= nil) {		DisposePtr(state->bufferPtr);		state->bufferSize = 0;		state->bufferPtr = nil;	}	/* allocate new buffer */	state->bufferPtr = NewPtr(byteCount);	if (state->bufferPtr == nil) {		state->bufferSize = 0;		return success(false);  /* could not allocate a buffer of size count */	}	state->bufferSize = byteCount;}pascal void asyncFileCompletionRoutine(AsyncFileState *state) {  /* Called when an I/O request completes. Decides what to do based on the given state.	 Note that the first part of the state record is the I/O parameter block. */	OSErr err;	err = state->pb.ioParam.ioResult;	if ((err !!= noErr) && (err !!= eofErr)) {		/* Note: eofErr indicates that fewer than the count bytes were transfered when		   reading because the end-of-file was encountered first; it isn''t a real error. */		state->status = LAST_OP_FAILED;		state->bytesTransferred = 0;		signalSemaphoreWithIndex(state->semaIndex);		return;	}	state->bytesTransferred = state->pb.ioParam.ioActCount;	state->status = IDLE;	signalSemaphoreWithIndex(state->semaIndex);}int asyncFileInitPB(AsyncFileState *state, int fPosition) {	memset(&state->pb, 0, sizeof(ParamBlockRec));	state->pb.ioParam.ioCompletion = asyncFileCompletionProc;	state->pb.ioParam.ioRefNum = state->refNum;	state->pb.ioParam.ioBuffer = state->bufferPtr;	state->pb.ioParam.ioReqCount = state->bufferSize;	state->pb.ioParam.ioPosMode = fsFromStart;	state->pb.ioParam.ioPosOffset = (fPosition < 0) ? 0 : fPosition;	state->status = BUSY;	state->bytesTransferred = 0;}int asyncFileValid(AsyncFile *f) {	return (		(f !!= NULL) &&		(f->sessionID == thisSession) &&		(f->state !!= NULL) &&		(((AsyncFileState *) f->state)->refNum !!= 0));}/*** Exported Functions ***/int asyncFileClose(AsyncFile *f) {  /* Close the given asynchronous file. */	AsyncFileState *state;	short int volRefNum;	OSErr err;	if (!!asyncFileValid(f)) return;  /* already closed */	state = f->state;	err = GetVRefNum(state->refNum, &volRefNum);	success(err == noErr);	err = FSClose(state->refNum);	success(err == noErr);	if (successFlag) err = FlushVol(NULL, volRefNum);	success(err == noErr);    if (asyncFileCompletionProc !!= nil)        DisposeIOCompletionUPP(asyncFileCompletionProc);  	asyncFileCompletionProc = nil;	if (state->bufferPtr !!= nil) DisposePtr(state->bufferPtr);	DisposePtr((void *) f->state);	f->state = nil;	f->sessionID = 0;}int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex) {  /* Opens the given file using the supplied AsyncFile structure to record	 its state. Fails with no side effects if f is already open. Files are	 always opened in binary mode. */	int i;	Str255 cFileName;	short int fileRefNum;	AsyncFileState *state;	OSErr err;	/* don''t open an already open file */	if (asyncFileValid(f)) return success(false);	/* build complete routine descriptor, if necessary */	if (asyncFileCompletionProc == nil) {#if TARGET_API_MAC_CARBON		asyncFileCompletionProc = NewIOCompletionUPP((pascal void (*) (union ParamBlockRec *) )asyncFileCompletionRoutine);#else		asyncFileCompletionProc = NewIOCompletionProc((pascal void (*) (union ParamBlockRec *) )asyncFileCompletionRoutine);#endif	}	/* copy the file name into a null-terminated C string */	if (fileNameSize > 255) return success(false);		sqFilenameFromString(cFileName, fileNamePtr, fileNameSize);	if (!!plugInAllowAccessToFilePath((char *) cFileName, fileNameSize)) {		return success(false);	}	CopyCStringToPascal((const char *)cFileName,cFileName);	f->sessionID = 0;	if (writeFlag) {		/* first try to open an existing file read/write: */		err = HOpenDF(0,0,cFileName, fsRdWrPerm, &fileRefNum); 		if (err !!= noErr) {			/* file does not exist; must create it. */			err = HCreate(0, 0, cFileName,''R*ch'',''TEXT''); 			if (err !!= noErr) return success(false);			err = HOpenDF(0,0,cFileName,fsRdWrPerm, &fileRefNum);			if (err !!= noErr) return success(false);		}	} else {		/* open the file read-only  */		err = HOpenDF(0,0,cFileName, fsRdPerm, &fileRefNum); 		if (err !!= noErr) return success(false);	}	f->state = (AsyncFileState *) NewPtr(sizeof(AsyncFileState));	/* allocate state record */	if (f->state == nil) {		FSClose(fileRefNum);		return success(false);	}	f->sessionID = thisSession;	state = (AsyncFileState *) f->state;	state->refNum = fileRefNum;	state->writable = writeFlag;	state->semaIndex = semaIndex;	state->status = IDLE;	state->bytesTransferred = 0;	state->bufferSize = 0;	state->bufferPtr = nil;}int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize) {  /* Copy up to bufferSize bytes from the buffer of the last read operation	 into the given Squeak buffer, and return the number of bytes copied.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed	Note that a read operation may read fewer bytes than requested if, for	example, there are fewer than the requested number of bytes between the	starting file position of the read operation and the end-of-file. */	AsyncFileState *state;	int bytesRead;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	/* copy the file buffer into the squeak buffer */	bytesRead = (bufferSize < state->bytesTransferred) ? bufferSize : state->bytesTransferred;	memcpy((char *) bufferPtr, state->bufferPtr, bytesRead);	return bytesRead;}int asyncFileReadStart(AsyncFile *f, int fPosition, int count) {  /* Start an asynchronous operation to read count bytes from the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileReadResult() to	 find out if the operation succeeded and to get the data that was read. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, count);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	asyncFileInitPB(state, fPosition);	err = PBReadAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}int asyncFileRecordSize() {	return sizeof(AsyncFile);}int asyncFileWriteResult(AsyncFile *f) {  /* Return the number of bytes copied by the last write operation.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed */	AsyncFileState *state;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	return state->bytesTransferred;}int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize) {  /* Start an asynchronous operation to write bufferSize bytes to the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileWriteResult() to	 find out if the operation succeeded and how many bytes were actually written. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	if (!!state->writable) return success(false);	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, bufferSize);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	/* copy the squeak buffer into the file buffer */	memcpy(state->bufferPtr, (char *) bufferPtr, bufferSize);	asyncFileInitPB(state, fPosition);	err = PBWriteAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/2/2001 00:56'!macDirectoryFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "FilePlugin.h"/* End of adjustments for pluginized VM */#include <Files.h>#include <Strings.h>/***	The interface to the directory primitive is path based.	That is, the client supplies a Squeak string describing	the path to the directory on every call. To avoid traversing	this path on every call, a cache is maintained of the last	path seen, along with the Mac volume and folder reference	numbers corresponding to that path.***//*** Constants ***/#define ENTRY_FOUND     0#define NO_MORE_ENTRIES 1#define BAD_PATH        2#define DELIMITOR '':''#define MAX_PATH 2000/*** Variables ***/char lastPath[MAX_PATH + 1];int  lastPathValid = false;int  lastRefNum = 0;int  lastVolNum = 0;/*** Functions ***/int convertToSqueakTime(int macTime);int equalsLastPath(char *pathString, int pathStringLength);int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr);int lookupVolume(char *volName, int *refNumPtr);int recordPath(char *pathString, int pathStringLength, int refNum, int volNum);int convertToSqueakTime(int macTime) {	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */	return macTime + (3 * 365 * 24 * 60 * 60);}int dir_Create(char *pathString, int pathStringLength) {	/* Create a new directory with the given path. By default, this	   directory is created in the current directory. Use	   a full path name such as "MyDisk:Working:New Folder" to	   create folders elsewhere. */	Str255 name;	HParamBlockRec pb;	int i;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return false;	}	for (i = 0; i < pathStringLength; i++) {		name[i] = pathString[i];	}	name[i] = 0; /* string terminator */	CopyCStringToPascal((const char *) name,name);	pb.fileParam.ioNamePtr = name;	pb.fileParam.ioVRefNum = 0;	pb.fileParam.ioDirID = 0;	return PBDirCreateSync(&pb) == noErr;}int dir_Delete(char *pathString, int pathStringLength) {	/* Delete the existing directory with the given path. */	int okay, refNum, volNum, i;	HParamBlockRec pb;	Str255 name;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return false;	}	for (i = 0; i < pathStringLength; i++) {		name[i] = pathString[i];	}	name[i] = 0; /* string terminator */	okay = lookupPath(pathString, pathStringLength, &refNum, &volNum);	if (!!okay) {		return false;	}	CopyCStringToPascal((const char *) name,name);	pb.fileParam.ioNamePtr = name;	pb.fileParam.ioVRefNum = volNum;	pb.fileParam.ioDirID = refNum;	return PBHDeleteSync(&pb) == noErr;}int dir_Delimitor(void) {	return DELIMITOR;}int dir_Lookup(char *pathString, int pathStringLength, int index,  /* outputs: */  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile) {	/* Lookup the index-th entry of the directory with the given path, starting	   at the root of the file system. Set the name, name length, creation date,	   creation time, directory flag, and file size (if the entry is a file).	   Return:	0 	if a entry is found at the given index	   			1	if the directory has fewer than index entries	   			2	if the given path has bad syntax or does not reach a directory	*/	int okay, newRefNum, newVolNum;	HVolumeParam volumeParams;	CInfoPBRec dirParams;	/* default return values */	*name             = 0;	*nameLength       = 0;	*creationDate     = 0;	*modificationDate = 0;	*isDirectory      = false;	*sizeIfFile       = 0;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return NO_MORE_ENTRIES;	}	if ((pathStringLength == 0)) {		/* get volume info */		volumeParams.ioNamePtr = (unsigned char *) name;		volumeParams.ioVRefNum = 0;		volumeParams.ioVolIndex = index;		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);			*isDirectory      = true;			*sizeIfFile       = 0;			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	} else {		/* get file or directory info */		if (!!equalsLastPath(pathString, pathStringLength)) {			/* lookup and cache the refNum for this path */			okay = lookupPath(pathString, pathStringLength, &newRefNum, &newVolNum);			if (okay) {				recordPath(pathString, pathStringLength, newRefNum, newVolNum);			} else {				return BAD_PATH;			}		}		dirParams.hFileInfo.ioNamePtr = (unsigned char *) name;		dirParams.hFileInfo.ioFVersNum = 0;		dirParams.hFileInfo.ioFDirIndex = index;		if (lastRefNum < 0) {			dirParams.hFileInfo.ioVRefNum = lastRefNum;			dirParams.hFileInfo.ioDirID = 0;		} else {			dirParams.hFileInfo.ioVRefNum = lastVolNum;			dirParams.hFileInfo.ioDirID = lastRefNum;		}		okay = PBGetCatInfoSync(&dirParams) == noErr;		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);			if ((dirParams.hFileInfo.ioFlAttrib & 16) !!= 0) {				*isDirectory  = true;				*sizeIfFile   = 0;			} else {				*isDirectory  = false;				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;			}			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	}}dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Set the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */	Str255 name;	FInfo finderInfo;	int i;	/* copy file name into a Pascal string */	if (filenameSize > 255) return false;	name[0] = filenameSize;	for (i = 1; i <= filenameSize; i++) {		name[i] = filename[i - 1];	}	if (HGetFInfo(0,0,name,  &finderInfo) !!= noErr) return false;	finderInfo.fdType = *((int *) fType);	finderInfo.fdCreator = *((int *) fCreator);	if (HSetFInfo(0,0,name,  &finderInfo) !!= noErr) return false;	return true;}dir_GetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Get the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */	Str255 name;	FInfo finderInfo;	int i;	/* copy file name into a Pascal string */	if (filenameSize > 255) return false;	name[0] = filenameSize;	for (i = 1; i <= filenameSize; i++) {		name[i] = filename[i - 1];	}	if (HGetFInfo(0,0,name,  &finderInfo) !!= noErr) return false;	*((int *) fType) = finderInfo.fdType;	*((int *) fCreator) = finderInfo.fdCreator;	return true;}int equalsLastPath(char *pathString, int pathStringLength) {	/* Return true if the lastPath cache is valid and the	   given Squeak string equals it. */	int i, ch;	if (!!lastPathValid ||		(pathStringLength > MAX_PATH)) {			return false;	}	for (i = 0; i < pathStringLength; i++) {		ch = lastPath[i];		if ((ch == 0) || (ch !!= pathString[i])) return false;	}	return lastPath[i] == 0;}/*Note:The previous version of lookupPath checks each folder in the pathhierarchy.  Given a parent folder id of 0, the Carbon version wantsto look in the default directory rather than the root level.  So, ratherthan fix it up, I chose to rewrite the function, first looking for thevolume, then the directory (they are the system calls offered anyway).The function only needs to return false for failure otherwise the volumeand folder id numbers - not details of a full examination of the path.Karl Goiser 14/01/01*/int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr) {	/* Resolve the given path and return the resulting folder or volume	   reference number in *refNumPtr. Return false if the path is bad. */	Str255		tempName;	CInfoPBRec	pb;	OSErr		err;    FSSpec		volumeSpec;    long        i;	// Set up for failure...		*refNumPtr = 0;		*volNumPtr = 0;// --------------// Find the volume reference number:	/* copy file name into a Pascal string */	if (pathStringLength > 255) return false;		tempName[0] = pathStringLength;	for (i = 1; i <= pathStringLength; i++)		tempName[i] = pathString[i - 1];	err = FSMakeFSSpec (0, 0, tempName, &volumeSpec);	if (err == -43) {	    err = lookupVolume(pathString, refNumPtr);	    return err;	}		if (err !!= noErr) {	    return false;	}// --------------// Find the directory id:	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioNamePtr = tempName;	pb.hFileInfo.ioVRefNum = 0;	pb.hFileInfo.ioDirID = 0;	pb.hFileInfo.ioACUser = 0; /* ioACUser used to be filler2 */	pb.hFileInfo.ioCompletion = nil;	pb.hFileInfo.ioFVersNum = 0;	err = PBGetCatInfoSync(&pb);	if (err !!= noErr) return false;	*refNumPtr = pb.hFileInfo.ioDirID;	*volNumPtr = volumeSpec.vRefNum;	return true;}int lookupVolume(char *volName, int *refNumPtr) {	/* Look up the volume with the given name and set *refNumPtr	   to the reference number of the resulting volume.	   Return true if this succeeds. */	int okay;	HVolumeParam volumeParams;	Str255 tempVolName;	CopyCStringToPascal((const char *)volName,tempVolName);	volumeParams.ioNamePtr = (StringPtr) tempVolName;	volumeParams.ioVRefNum = 0;	volumeParams.ioVolIndex = -1;	okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;	if (okay) {		*refNumPtr = volumeParams.ioVRefNum;		return true;	}	return false;}int recordPath(char *pathString, int pathStringLength, int refNum, int volNum) {	/* Copy the given Squeak string into the lastPath cache. */	int i;	if (pathStringLength > MAX_PATH) {		lastPath[0] = 0; /* set to empty string */		lastPathValid = false;		lastRefNum = 0;		lastVolNum = 0;		return;	}	for (i = 0; i < pathStringLength; i++) {		lastPath[i] = pathString[i];	}	lastPath[i] = 0; /* string terminator */	lastPathValid = true;	lastRefNum = refNum;	lastVolNum = volNum;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/1/2001 23:41'!macDragDropFile	^ '/*  Jan 24th 2001	Drag and drop support for Squeak 	John M McIntosh of Corporate Smalltalk Consulting Ltd	johnmci@smalltalkconsulting.com 	http://www.smalltalkconsulting.com 	In Jan of 2001 under contract to Disney		Dragging is only for objects into Squeak, not from Squeak outwards.		    V1.0 Jan 24th 2001, JMMSome of this code comes from	Author:		John Montbriand				Some techniques borrowed from Pete Gontier''s original FinderDragPro.	Copyright: 	Copyright: © 1999 by Apple Computer, Inc.				all rights reserved.		Disclaimer:	You may incorporate this sample code into your applications without				restriction, though the sample code has been provided "AS IS" and the				responsibility for its operation is 100% yours.  However, what you are				not permitted to do is to redistribute the source as "DSC Sample Code"				after having made changes. If you''re going to re-distribute the source,				we require that you make it clear in the source that the code was				descended from Apple Sample Code, but that you''ve made changes.		Change History (most recent first):	9/9/99 by John Montbriand	*//*    need get filetype/creator    need DropPlugin_shutdownModule & dropShutdown    */#include "sq.h"#include <drag.h>#include <macwindows.h>#include <gestalt.h>#include <quickdraw.h>#include "sqVirtualMachine.h"#include "FilePlugin.h"#include "DropPlugin.h"#if TARGET_API_MAC_CARBON#else    inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}  #endif	/* promise flavor types */	enum {	kPromisedFlavor = ''fssP'',		/* default promise */	kPromisedFlavorFindFile = ''rWm1'' /* Find File promise -- special case */}; Boolean gHasDragManager = false;                    /* true if the Drag Manager is installed */ Boolean gCanTranslucentDrag = false;                /* true if translucent dragging is available */ DragReceiveHandlerUPP gMainReceiveHandler = NULL;   /* receive handler for the main dialog */ DragTrackingHandlerUPP gMainTrackingHandler = NULL; /* tracking handler for the main dialog */ WindowPtr   gWindowPtr; UInt16 gNumDropFiles=0; HFSFlavor *dropFiles;#define DOCUMENT_NAME_SIZE 300char tempName[DOCUMENT_NAME_SIZE + 1];  	/* these routines are used both in the receive handler and inside of the		tracking handler.  The following variables are shared between MyDragTrackingHandler		and MyDragReceiveHandler.  */		 Boolean gApprovedDrag = false;   /* set to true if the drag is approved */ Boolean gInIconBox = false;      /* set true if the drag is inside our drop box */extern struct VirtualMachine *interpreterProxy;extern WindowPtr getSTWindow(void); pascal OSErr MyDragTrackingHandler(DragTrackingMessage message, WindowPtr theWindow, void *refCon, DragReference theDragRef); pascal OSErr MyDragReceiveHandler(WindowPtr theWindow, void *refcon, DragReference theDragRef);extern int (*instantiateClassindexableSize)(int classPointer, int size);extern int classByteArray(void);extern int fileRecordSize(void);extern int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);extern SQFile * fileValueOf(int objectPointer);extern int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType);extern int MouseModifierState(EventRecord *theEvent);extern void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short VolumeNumber,long directoryID);// Startup logicint dropInit(void){    long response;    long fn;    Boolean  installedReceiver=false, installedTracker=false;    OSErr err;        /* check for the drag manager & translucent feature??? */    	if (gMainReceiveHandler !!= NULL) return 1;		if (Gestalt(gestaltDragMgrAttr, &response) !!= noErr) return 0;		gHasDragManager = (((1 << gestaltDragMgrPresent)) !!= 0);	gCanTranslucentDrag = (((1 << gestaltDragMgrHasImageSupport)) !!= 0);    if (!!(gHasDragManager && gCanTranslucentDrag)) return 0;		gWindowPtr = getSTWindow();	gMainTrackingHandler = NewDragTrackingHandlerUPP(MyDragTrackingHandler);	if (gMainTrackingHandler == NULL) return 0;	gMainReceiveHandler = NewDragReceiveHandlerUPP(MyDragReceiveHandler);	if (gMainReceiveHandler == NULL) return 0;		/* install the drag handlers, don''t forget to dispose of them later */			err = InstallTrackingHandler(gMainTrackingHandler, gWindowPtr, NULL);	if (err !!= noErr) { 	    err = memFullErr; 	    goto bail;     }	installedTracker = true;	err = InstallReceiveHandler(gMainReceiveHandler, gWindowPtr, NULL);		if (err !!= noErr) { 	    err = memFullErr; 	    goto bail; 	}	installedReceiver = true;	return 1;	bail:     if (installedReceiver)		RemoveReceiveHandler(gMainReceiveHandler, gWindowPtr);	if (installedTracker)		RemoveTrackingHandler(gMainTrackingHandler, gWindowPtr);		gMainTrackingHandler = NULL;     gMainReceiveHandler = NULL;    	return 0;}	// Shutdown logicint dropShutdown() {    if (gMainReceiveHandler !!= NULL)		RemoveReceiveHandler(gMainReceiveHandler, gWindowPtr);	if (gMainTrackingHandler !!= NULL)		RemoveTrackingHandler(gMainTrackingHandler, gWindowPtr);	if (gNumDropFiles !!= 0 ) {	    DisposePtr((char *) dropFiles);	    gNumDropFiles = 0;	}		gMainTrackingHandler = NULL;     gMainReceiveHandler = NULL;}//Primitive to get file namechar *dropRequestFileName(int dropIndex) {    char	shortName[256];      if(dropIndex < 1 || dropIndex > gNumDropFiles)         return NULL;    CopyPascalStringToC(dropFiles[dropIndex-1].fileSpec.name,shortName);    StoreFullPathForLocalNameInto(shortName,         tempName,         DOCUMENT_NAME_SIZE,        dropFiles[dropIndex-1].fileSpec.vRefNum,        dropFiles[dropIndex-1].fileSpec.parID);  return tempName;}//Primitive to get file stream handle.int dropRequestFileHandle(int dropIndex) {    int fileHandle;    int   size,classPointer;    char *dropName = dropRequestFileName(dropIndex);        if(!!dropName)        return interpreterProxy->nilObject();    size = fileRecordSize();    classPointer = interpreterProxy->classByteArray();    fileHandle = interpreterProxy->instantiateClassindexableSize(classPointer, size);    sqFileOpen(fileValueOf(fileHandle),(int)dropName, strlen(dropName), 0);      return fileHandle;}/* RECEIVING DRAGS ------------------------------------------------ *//* ApproveDragReference is called by the drag tracking handler to determine	if the contents of the drag can be handled by our receive handler.	Note that if a flavor can''t be found, it''s not really an	error; it only means the flavor wasn''t there and we should	not accept the drag. Therefore, we translate ''badDragFlavorErr''	into a ''false'' value for ''*approved''. */	static pascal OSErr ApproveDragReference(DragReference theDragRef, Boolean *approved) {	OSErr err;	DragAttributes dragAttrs;	FlavorFlags flavorFlags;	ItemReference theItem;				/* we cannot drag to our own window */	if ((err = GetDragAttributes(theDragRef, &dragAttrs)) !!= noErr) 	    goto bail;	    	if ((dragAttrs & kDragInsideSenderWindow) !!= 0) { 	    err = userCanceledErr; 	    goto bail;     }			/* gather information about the drag & a reference to item one. */	if ((err = GetDragItemReferenceNumber(theDragRef, 1, &theItem)) !!= noErr) 	    goto bail;				/* check for flavorTypeHFS */	err = GetFlavorFlags(theDragRef, theItem, flavorTypeHFS, &flavorFlags);	if (err == noErr) {		*approved = true;		return noErr;	} else if (err !!= badDragFlavorErr)		goto bail;				/* check for flavorTypePromiseHFS */	err = GetFlavorFlags(theDragRef, theItem, flavorTypePromiseHFS, &flavorFlags);	if (err == noErr) {		*approved = true;		return noErr;	} else if (err !!= badDragFlavorErr)		goto bail;				/* none of our flavors were found */	*approved = false;	return noErr;	bail:		/* an error occured, clean up.  set result to false. */	*approved = false;	return err;}/* MyDragTrackingHandler is called for tracking the mouse while a drag is passing over our	window.  if the drag is approved, then the drop box will be hilitied appropriately	as the mouse passes over it.  */	static pascal OSErr MyDragTrackingHandler(DragTrackingMessage message, WindowPtr theWindow, void *refCon, DragReference theDragRef) {		/* we''re drawing into the image well if we hilite... */    Rect  bounds;	EventRecord		theEvent;	switch (message) {			case kDragTrackingEnterWindow:			{					Point mouse;								gApprovedDrag = false;				if (theWindow == gWindowPtr) {					if (ApproveDragReference(theDragRef, &gApprovedDrag) !!= noErr) break;					if ( !! gApprovedDrag ) break;					SetPortWindowPort(theWindow);					GetMouse(&mouse);					GetPortBounds(GetWindowPort(gWindowPtr),&bounds);					if (PtInRect(mouse, &bounds)) {  // if we''re in the box, hilite... 						gInIconBox = true;					                    	    /* queue up an event */                        WaitNextEvent(0, &theEvent,0,null);                    	recordDragDropEvent(&theEvent, MouseModifierState(&theEvent),gNumDropFiles,DragEnter);					} 				}			}			break;		case kDragTrackingInWindow:			if (gApprovedDrag) {                WaitNextEvent(0, &theEvent,0,null);            	recordDragDropEvent(&theEvent, MouseModifierState(&theEvent),gNumDropFiles,DragMove);			}			break;		case kDragTrackingLeaveWindow:			if (gApprovedDrag && gInIconBox) {            	    /* queue up an event */                WaitNextEvent(0, &theEvent,0,null);            	recordDragDropEvent(&theEvent, MouseModifierState(&theEvent),gNumDropFiles,DragLeave);			}			gApprovedDrag = gInIconBox = false;			break;	}	return noErr; // there''s no point in confusing Drag Manager or its caller}/* MyDragReceiveHandler is the receive handler for the main window.  It is called	when a file or folder (or a promised file or folder) is dropped into the drop	box in the main window.  Here, if the drag reference has been approved in the	track drag call, we handle three different cases:		1. standard hfs flavors,		2. promised flavors provided by find file, mmmm This may be a pre sherlock issue		3. promised flavors provided by other applications.	     */     static pascal OSErr MyDragReceiveHandler(WindowPtr theWindow, void *refcon, DragReference theDragRef) {	ItemReference   theItem;	PromiseHFSFlavor targetPromise;	Size            theSize;	OSErr           err;	EventRecord		theEvent;	long            i,countActualItems;	FInfo 			finderInfo;	HFSFlavor		targetHFSFlavor;			/* validate the drag.  Recall the receive handler will only be called after		the tracking handler has received a kDragTrackingInWindow event.  As a result,		the gApprovedDrag and gInIconBox will be defined when we arrive here.  Hence,		there is no need to spend extra time validating the drag at this point. */			if ( !! (gApprovedDrag && gInIconBox) )  	    return userCanceledErr; 	if (gNumDropFiles !!=0 ) 	    DisposePtr((char *) dropFiles);	    	if ((err = CountDragItems(theDragRef, &gNumDropFiles)) !!= noErr) 	    return paramErr;		dropFiles = (HFSFlavor *) NewPtr(sizeof(HFSFlavor)*gNumDropFiles);		if (dropFiles == null) 	    return userCanceledErr;	    WaitNextEvent(0, &theEvent,0,null);    countActualItems = 0;    		    for(i=1;i<=gNumDropFiles;i++) {		/* get the first item reference */    	if ((err = GetDragItemReferenceNumber(theDragRef, i, &theItem)) !!= noErr)     	    continue;    		/* try to get a  HFSFlavor*/    	theSize = sizeof(HFSFlavor);    	err = GetFlavorData(theDragRef, theItem, flavorTypeHFS, &targetHFSFlavor, &theSize, 0);    	if (err == noErr) {    		if (dropFiles[countActualItems].fileCreator == ''MACS'' && (    				dropFiles[countActualItems].fileType == ''fold'' ||    				dropFiles[countActualItems].fileType == ''disk''))     				continue;    		dropFiles[countActualItems] = targetHFSFlavor;    		countActualItems++;    		continue;    	} else if (err !!= badDragFlavorErr)     	        continue;     	    		/* try to get a  promised HFSFlavor*/    	theSize = sizeof(PromiseHFSFlavor);    	err = GetFlavorData(theDragRef, theItem, flavorTypePromiseHFS, &targetPromise, &theSize, 0);    	if (err !!= noErr)     		continue;    	    		/* check for a drop from find file */    	if (targetPromise.promisedFlavor == kPromisedFlavorFindFile) {    	    			/* from find file, no need to set the file location... */    		theSize = sizeof(FSSpec);    		err = GetFlavorData(theDragRef, theItem, targetPromise.promisedFlavor, &dropFiles[countActualItems].fileSpec, &theSize, 0);    		if (err !!= noErr)     			continue;    		HGetFInfo(dropFiles[countActualItems].fileSpec.vRefNum,dropFiles[countActualItems].fileSpec.parID,dropFiles[countActualItems].fileSpec.name,  &finderInfo);	    		/* queue up an event */	        dropFiles[countActualItems].fileType = finderInfo.fdType;	        dropFiles[countActualItems].fileCreator = finderInfo.fdCreator;	        dropFiles[countActualItems].fdFlags =  finderInfo.fdFlags;    		countActualItems++;    	} else {    		err = badDragFlavorErr;    		return err;    	}    }    	gNumDropFiles = countActualItems;    if (gNumDropFiles == 0) {    	DisposePtr((char *) dropFiles);    	return noErr;    }		    /* queue up an event */	recordDragDropEvent(&theEvent, MouseModifierState(&theEvent),gNumDropFiles,DragDrop);	return noErr;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/1/2001 23:43'!macNetworkFile	^ '#include <ConditionalMacros.h>#if TARGET_CPU_PPC#include <OpenTransport.h>#include <OpenTptInternet.h>#include <OpenTptClient.h>#include <stropts.h>#include <Gestalt.h>#include <TextUtils.h>#include <files.h>#if !!TARGET_API_MAC_CARBON    #ifndef NewOTNotifyUPP    	typedef struct OTConfiguration* OTConfigurationRef;    	#define OTNotifyUPP OTNotifyProcPtr     	#define NewOTNotifyUPP(userRoutine) userRoutine    	#define DisposeOTNotifyUPP(userRoutine)    #endif#endif#include "sq.h"#include "SocketPlugin.h"//#define OTSERVER/*  May 1st 2000	An Open Transport 2.0 version of source code for TCP/IP & UDP support	Some of this the code was descended from Apple sample source written by: Eric Okholm	However getting it to work was done by	John M Mcintosh of Corporate Smalltalk Consulting Ltd	johnmci@smalltalkconsulting.com 	http://www.smalltalkconsulting.com 	In May of 2000 under contract to Disney		Some of the original source code was written by John Maloney of Disney thoughout the 1990''s		The basic intent was to make the code fully interrupt driven	No limits.... Well maybe we throttle read buffers to some parcel of memory to prevent us	from using all the memory on the box. Sends depend on lowerlayer buffering/flow control.	Testing from a 500Mhz PowerBook showed we could saturate a 100MB ethernet when sending data oneway.		UDP and TCP/IP are all supported.	Note for TCP we turn on two options IP_REUSEADDR, and IP_KEEPALIVE.	We do NOT handle T_EXDATA  data		V1.0 May 18th 2000, JMM (TCP/IP and UDP)	V1.1 May 19th 2000, JMM Cleanup	V1.2 may 20th 2000, JMM UDP free buffer cleanup, relook at resolver terminate to fix crash	V1.3 may 23rd 2000, JMM fix T_UDERR crash	V1.3.1 may 24th 2000, JMM UDP work	V1.3.2 may 25th 2000, JMM socket options work	V1.3.3 may 27th 2000, JMM rewrote resolver	V1.3.4 Jun 7th 2000, JMM some integration	V1.3.5 Jun 9th 2000, JMM Dan Ingalls found some interesting bugs with a T_GODATA on T_CONNECT.	V1.3.6 Jun 10th 2000, JMM fix a fatal but in close/close pattern I made on the 9th.	V1.3.7 Aug 1st 2000, JMM Some carbon work, reviewed open non-existent port logic fix so unavailable port causes immediate failure	V1.3.8 Aug 29th 2000, JMM Fix problem with recusion on make me an EP.	v1.3.9 Sept 28th 2000, JMM Problem with accept somewhere (so harden code)	v1.3.10 Oct 4th 2000, JMM Issue with destory and free buffers, and disconnect on read with buffer restriction	v1.3.11 Nov 11th 2000, JMM extra buffer for server version	v1.3.12 Jan 2001, Karl Goiser Carbon changes		Notes beware semaphore''s lurk for socket support. Three semaphores lives in Smalltalk, waiting for	connect/disconnect/listen, sending data, and receiving data. When to tap the semaphore is based on	inferences driven from the smalltalk code. We really need a call to tell us intent.		waitForDisconnectUntil:	    via closeAndDestroy: after primSocketCloseConnection:	    	waitForDataUntil:	    Usually before primitiveSocketReceiveDataBufCount: after checking SocketReceiveDataAvailable	    	waitForSendDoneUntil:	    via sendData: or sendSomeData:startIndex;count: before calls to primitiveSocketSendDataBufCount	    	waitForConnectionUntil:	    via waitForAcceptUntil and many places afer doing primitiveSocketConnectToPort*/								/*** Socket Type Constants ***/#define TCPSocketType 0#define UDPSocketType 1#define TCPListenerSocketType 2   //These are special to enable the right options for listening. Not Exposed to Smalltalk#define UDPListenerSocketType 3   //Very special not really linked to an EP structure.  Not Exposed to Smalltalk/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3#define RESOLVER_NAMETOADDR     4#define RESOLVER_ADDRTONAME     5/*** TCP Socket Status Constants ***/#define InvalidSocket           -1#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4	// Overall program statesenum{	kProgramRunning		= 1,	kProgramDone		= 2};	// Bit numbers in EPInfo stateFlags fieldsenum{	kOpenInProgressBit				= 0,  	kUnConnected    				= 1,	kWaitingForConnection           = 2,	kConnected                      = 3,	kSendIsBlocked                  = 4,    kOtherEndClosed                 = 5,    kThisEndClosed                  = 6,	kPassconBit                     = 7};	// Bit numbers in EPInfo stateFlags2 fieldsenum{	kFlushDisconnectInProgressBit	= 0,	kMakeEPIdle                     = 1,	kEPIsBroken                     = 2,	kReadFlowControl                = 3,	kPassconNeeded                  = 4,	kTapSemaphore                   = 5,	kTapSemaphoreReadData           = 6,	kTapSemaphoreWriteData          = 7};	// Bit numbers in EPInfo stateFlags3 fieldsenum{    kKeepAliveOptionNeeded          = 0,    kSleepKilledMe                  = 1,    kWaitingForBind                 = 2}; enum{	kOTVersion111				= 0x01110000,	kOTVersion112				= 0x01120000,	kOTVersion113				= 0x01130000,	kOTVersion130				= 0x01300000};const kTCPKeepAliveInMinutes		= 10;		// 10 minutes  keep alive#ifdef OTSERVERconst kReadBuffersToAllocate	    = 256;		// Memory Allocation issue how big, this means 256x mtu size * 4 But for 68K we do 1/2 size#elseconst kReadBuffersToAllocate	    = 50;		// Memory Allocation issue how big, this means 50x mtu size * 4 But for 68K we do 1/2 size#endif	// Endpoint Info Structurestruct EPInfo{	EndpointRef		erf;				//	actual endpoint	OTLink			link;				//	link into an OT LIFO (atomic)	OTLink          globalLink;         //  link that follows all allocated EPs    SInt32          outstandingSends;   //  number of sends outstanding    OTList          readBuffers;        //  Read buffers    SInt32          bytesPendingToRead; //  bytes outstanding to read	SInt32			semaIndex;			//	semaphore index	SInt32          readSemaIndex;      //  read semaphore	SInt32          writeSemaIndex;     //  write semaphore	SInt32          UDPMaximumSize;     //  max size if a UDP endpoint	SInt32			lastError;          //  last error code	UInt8			stateFlags;			//	various status fields	UInt8			stateFlags2;		//	various status fields	UInt8			stateFlags3;		//	various status fields	UInt8           socketType;         //  type of socket, tcp, udp, or tcp/udp listener	InetAddress     localAddress;       //  local address at bind time (ignored used call to get current)	InetAddress     remoteAddress;      //  remote address at connect (ignored used call to get current)	Boolean         UDPMoreFlag;        //  UDP more of datagram flag set    };typedef struct EPInfo EPInfo;struct ReadBuffer                       // Structure to contain read data.{	OTLink			fNext;				//	link into an OT FIFO 	UInt32          readBufferSize;	UInt32			readBufferOriginalSize;  	char *          readBufferData;	char *          readBufferPtr;      //Sliding pointer used to partial read buffer.    InetAddress     UDPAddress;         //UDP address	Boolean         UDPMoreFlag;        //UDP more of datagram flag set};typedef struct ReadBuffer ReadBuffer;struct TKeepAliveOpt                    {	UInt32		len;	OTXTILevel	level;	OTXTIName	name;	UInt32		status;	UInt32		tcpKeepAliveOn;	UInt32		tcpKeepAliveTimer;};typedef struct TKeepAliveOpt TKeepAliveOpt;struct TLingerOpt                    {	UInt32		len;	OTXTILevel	level;	OTXTIName	name;	UInt32		status;	UInt32		tcpLingerOn;	UInt32		tcpLingerTimer;};typedef struct TLingerOpt TLingerOpt;/*** Variables ***/extern struct VirtualMachine *interpreterProxy;EPInfo*				gDNSResolver;               //Our resolverSInt32				gDNSResolverStatus 			= RESOLVER_UNINITIALIZED;SInt32				gDNSResolverError			= noErr;SInt32			    gDNSResolverSemaIndex;      //This gets changed at startup time.InetHostInfo		gDNSHostInfo;InetDomainName 		gDNSAddrStr;                //Length of domain names? Old code was 512, but specs say 256.InetHost			gDNSAddr;SInt32              gDNSLookupType;OTConfigurationRef	gCfgMastertcp				= NULL;OTConfigurationRef	gCfgMasterudp				= NULL;OTConfigurationRef	gCfgMasterListener			= NULL;OTLIFO				gFreeReadBuffersLIFO;    	//  Buffers that are free to read intoOTLIFO*				gFreeReadBuffers			= &gFreeReadBuffersLIFO;SInt32				gFreeReadBuffersCounter		= 0;SInt32				gSocketsAllocated			= 0;UInt32				gmtuSize 					= 1024; //This gets changed at startup time.SInt32				gthisNetSession 			= 0;    //This gets changed at startup time.SInt32				gMaxConnections				= 0;    //This gets changed at startup time.UInt32				gOTVersion;                         //Gets set to OT version, to help us with special cases.SInt32				gProgramState				= 0;    //This gets changed at startup time.OTClientContextPtr     gClientContext;OTLIFO				gIdleEPLIFO[3];OTLIFO*				gIdleEPs[3];SInt32              gIdleEPCounter[3];OTLIFO				gBrokenEPLIFO;OTLIFO*				gBrokenEPs					= &gBrokenEPLIFO;OTLIFO				gAllEPLIFO;OTLIFO*				gAllEPs					    = &gAllEPLIFO;OTNotifyUPP DNSNotifierUPP,NotifierSocketUPP,NotifierSocketUDPUPP,NotifierSocketListenerUPP;/*** Private TCP Socket Functions ***//*** Private Resolver Functions ***/static void 		ResolverInitialize();static void		    ResolverTerminate(void);static void 		ResolverStart ();/*** Other Private Functions ***/void               CFMTerminate (void);static Boolean	   DestroyAllOpenSockets(void);static Boolean	   SocketValid(SocketPtr s);static Boolean     PortNumberValid(InetPort port) ;static SInt32      unmapStatus(EPInfo *);static void        Recycle();static void        makeEPIdle(EPInfo *epi);static void        purgeReadBuffers(EPInfo *epi);static void        makeEPBrokenThenIdle(EPInfo* epi,OTResult error);static void        makeEPBroken(EPInfo* epi,OTResult error);static EPInfo*     getOrMakeMeAnEP(UInt8 aSocketType,short counter);static Boolean     makeMeAnEP(UInt8 aSocketType);static void        attemptToCloseAndDeleteThisEP (EPInfo *epi);static void		   makeEPUnconnected(EPInfo* epi);static void        SetEPLastError(EPInfo* epi,OTResult error);static void        TapAllInterestedSemaphores(EPInfo *epi);int 				socketInit(void);int 				socketShutdown(void);static pascal void  DNSNotifier(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocket(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocketUDP(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocketListener(void* context, OTEventCode event, OTResult result, void* cookie);static SInt32       internalSocketCreate(SocketPtr s, SInt32 netType, SInt32  socketType, SInt32 recvBufSize, SInt32 sendBufSize, SInt32 semaIndex, SInt32 readSemaIndex, SInt32 writeSemaIndex, UInt8 aExtraSocketHint);static Boolean		EPOpen(EPInfo* epi);static Boolean 		EPClose(EPInfo*);static void         DoListenAccept(EPInfo* acceptor,EPInfo* theServer);static void         DoConnect(EPInfo* epi,InetHost addr, InetPort port);static void         DoBind(EPInfo* epi,InetHost addr, InetPort port,UInt8 aExtraSocketHint, OTQLen queueDepth );static UInt32       ReadData(EPInfo* epi, char* specialBuffer, UInt32 specialBufferSize);static OTResult     SendData(EPInfo* epi, char* buffer, UInt32 size);static OSStatus     doAbortConnection(EPInfo* epi);static void         NoCopyReceiveWalkingBufferChain(EPInfo *epi,OTBufferInfo *bufferInfo);static UInt32       readBytes(EPInfo* epi,char *buf,UInt32 adjustedBufSize);static UInt32       readBytesUDP(EPInfo* epi,InetAddress *fromAddress, int *moreFlag, char *buf,UInt32 adjustedBufSize);static SInt32	    lookupOptionName(EPInfo *epi, Boolean trueIfGet, char *aString, UInt32 value, SInt32 *result);static OTResult     SetFourByteOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetOneByteOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetKeepAliveOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetLingerOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);// Some diagnostic routinesvoid JMMLogMessage(Str255 input);void JMMLogMessageAndNumber(Str255 msg,long number);void JMMWriteLog();/*** Network Functions ***/int socketInit() {	//	//Don''t actually do any network work until we are newworked initialized	//This prevents kicking off internet dialup connections until needed	//	return true;}int socketShutdown() {	CFMTerminate();	return true;}int sqNetworkInit(int resolverSemaIndex) {	//	//  Initialize the network and return 0 if successful	//  Loads Open transport, allocates memory for read buffers and various other tasks	//		SInt32              i;	OSStatus            err = noErr;	InetInterfaceInfo   interfaceInformation;	UInt8               aSocketType;    ReadBuffer          *readBufferObject;    long				check68KorPPC;	    	if (gthisNetSession !!= 0) return 0;  /* noop if network is already initialized */	#if TARGET_API_MAC_CARBON	err = InitOpenTransportInContext (kInitOTForExtensionMask, &gClientContext);#else	err = InitOpenTransport(); #endif	if (err) return -1;			err = Gestalt(gestaltOpenTptVersions, (long*) &gOTVersion);		if (err || (gOTVersion < kOTVersion112))	{		// Please install Open Transport 1.1.2 or later		// This might change to 1.3 since tech notes talked about 		// previous versions having problems with acksend logic.		//		return -111;	}		err = Gestalt(gestaltSysArchitecture, (long*) &check68KorPPC);	gProgramState = kProgramRunning;    //     //Setup the head of the idle queues    //    	for (i=0;i<3;i++) {	    gIdleEPs[i] = &gIdleEPLIFO[i];	    gIdleEPs[i]->fHead	   = NULL;	    gIdleEPCounter[i]      = 0;	}	gBrokenEPs->fHead 		= NULL;	gFreeReadBuffers->fHead = NULL;	gAllEPs->fHead          = NULL;			gMaxConnections			= 24; // Build 8 of each of listeners, tcp, udp.	    DNSNotifierUPP = NewOTNotifyUPP(DNSNotifier);    NotifierSocketUPP = NewOTNotifyUPP(NotifierSocket);    NotifierSocketUDPUPP = NewOTNotifyUPP(NotifierSocketUDP);    NotifierSocketListenerUPP = NewOTNotifyUPP(NotifierSocketListener);	#if TARGET_API_MAC_CARBON	gDNSResolver = (EPInfo*) OTAllocMemInContext(sizeof(EPInfo), gClientContext);#else	gDNSResolver = (EPInfo*) OTAllocMem(sizeof(EPInfo));#endif	if (gDNSResolver == NULL) return -1;			gDNSResolverSemaIndex = resolverSemaIndex;	ResolverInitialize();		/* Get MTU and default selected host address */		OTInetGetInterfaceInfo (&interfaceInformation,kDefaultInetInterface);    gmtuSize = interfaceInformation.fIfMTU;    		//	//	Open endpoints 	//	gCfgMastertcp = OTCreateConfiguration(kTCPName);	if (gCfgMastertcp == NULL) return -3;		gCfgMasterudp = OTCreateConfiguration(kUDPName);	if (gCfgMasterudp == NULL) return -4;		gCfgMasterListener = OTCreateConfiguration("tilisten, tcp"); //Note use of special tilisten logic	if (gCfgMasterListener == NULL) return -5;		//	//Build all our EPs, lots of work happens lower down asyncronously	//	aSocketType = TCPSocketType;	for (i = 0; i < gMaxConnections; i++)	{		makeMeAnEP(aSocketType);		aSocketType = ++aSocketType > 2 ? TCPSocketType : aSocketType;	} 	#ifdef OTSERVER	for (i = 0; i < 256; i++)	{		makeMeAnEP(TCPSocketType);	} #endif	//	//Build storage objects for read buffers	//How much memory to allocate still is a mystery	//    for (i=0;i<kReadBuffersToAllocate ;i++) { #if TARGET_API_MAC_CARBON        readBufferObject = OTAllocMemInContext(sizeof(ReadBuffer), gClientContext);#else        readBufferObject = OTAllocMem(sizeof(ReadBuffer));#endif        if (readBufferObject == nil) {       	    interpreterProxy->success(false);            return -25;        }                 OTMemzero(readBufferObject,sizeof(ReadBuffer));        if (gestalt68k == check68KorPPC)         	readBufferObject->readBufferOriginalSize = (gmtuSize > 0) ? gmtuSize*2 : 1024;        else        	readBufferObject->readBufferOriginalSize = (gmtuSize > 0) ? gmtuSize*4 : 1024;        #if TARGET_API_MAC_CARBON       readBufferObject->readBufferData = readBufferObject->readBufferPtr = OTAllocMemInContext(readBufferObject->readBufferOriginalSize, gClientContext);#else       readBufferObject->readBufferData = readBufferObject->readBufferPtr = OTAllocMem(readBufferObject->readBufferOriginalSize);#endif        if ( readBufferObject->readBufferData == nil) {       	    interpreterProxy->success(false);            return -25;        }        OTLIFOEnqueue(gFreeReadBuffers, &readBufferObject->fNext);		gFreeReadBuffersCounter++;    }	/* Success!! Create a session ID that is unlikely to be	   repeated. Zero is never used for a valid session number.	*/	gthisNetSession = clock() + time(NULL);	if (gthisNetSession == 0) gthisNetSession = 1;  /* don''t use 0 */		return 0;}void CFMTerminate (void)    /* termination either via a CFM or Squeak call*/{     sqNetworkShutdown();}void sqNetworkShutdown(void) {	/* shut down the network */    	if (gthisNetSession == 0) return;  /* noop if network is already shut down */	gthisNetSession = 0;	gProgramState = kProgramDone;	DestroyAllOpenSockets();#if TARGET_API_MAC_CARBON	CloseOpenTransportInContext(gClientContext); #else	CloseOpenTransport(); #endif}/*** Resolver Functions ***/static void	ResolverInitialize() {	OSStatus err;		//	//	Prepare to open internet services	//  to invoke DNR services	//		OTMemzero(gDNSResolver, sizeof(EPInfo));	#if TARGET_API_MAC_CARBON    gDNSResolver->erf = OTOpenInternetServicesInContext(kDefaultInternetServicesPath, 0, &err, gClientContext);#else    gDNSResolver->erf = OTOpenInternetServices(kDefaultInternetServicesPath, 0, &err);#endif    gDNSResolver->semaIndex = gDNSResolverSemaIndex;		if (err !!= kOTNoError) {		gDNSResolverStatus = RESOLVER_ERROR;		gDNSResolverError = err;		return;	}	gDNSResolverStatus = RESOLVER_SUCCESS;	gDNSResolverError = kOTNoError;    err =  OTSetAsynchronous(gDNSResolver->erf);    err =  OTSetNonBlocking(gDNSResolver->erf);    err =  OTInstallNotifier(gDNSResolver->erf, DNSNotifierUPP, gDNSResolver);}static void ResolverStart () {	OSStatus err;	//	// Invoke DNR service Async, this meants the DNSNotifier will handle the actual 	// lookup and work, flags like the gDNSResolverStatus are used to indicate back	// to Squeak when the work is done	//	if (gDNSResolver->erf == NULL) //Sleep fix, other endpoints are more explicit about this issue. 	    ResolverInitialize();	    	gDNSResolverStatus  = RESOLVER_BUSY;	switch (gDNSLookupType) {		case RESOLVER_NAMETOADDR: {		    err = OTInetStringToAddress((InetSvcRef)gDNSResolver->erf, gDNSAddrStr, &gDNSHostInfo);			break;		}		case RESOLVER_ADDRTONAME: {			err = OTInetAddressToName((InetSvcRef)gDNSResolver->erf, gDNSAddr, gDNSAddrStr);			break;		}    }	if (err !!= kOTNoError)  {		gDNSResolverStatus = RESOLVER_ERROR;		gDNSResolverError = err;	}}void ResolverTerminate(void) {    //JMM if the resolver is opening what happens? 	gDNSResolverStatus = RESOLVER_UNINITIALIZED;   	if (gDNSResolver->erf == NULL) return;	EPClose(gDNSResolver);	OTMemzero(gDNSResolver, sizeof(EPInfo));}void sqResolverAbort(void) {	//	// Abort this running resolver request	//	if (gDNSResolverStatus == RESOLVER_BUSY) {		ResolverTerminate();		ResolverInitialize();	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	//	// copy the name found by the last address lookup into the given string 	//		OTMemcpy(nameForAddress, gDNSAddrStr, (UInt32) nameSize);	}int sqResolverAddrLookupResultSize(void) {	//	// return the length of the looked up name	//	return (long) strlen(gDNSAddrStr);}int sqResolverError(void) {	//	// Return OT error number	//	return gDNSResolverError; }int sqResolverLocalAddress(void) {    //    // Watch out for dynamic changing of this information, so don''t cache    //	InetInterfaceInfo interfaceInformation;	OTInetGetInterfaceInfo (&interfaceInformation,kDefaultInetInterface);	gDNSResolverStatus = RESOLVER_SUCCESS;	gDNSResolverError  = noErr;	return (long) interfaceInformation.fAddress;}int sqResolverNameLookupResult(void) {	//	// Return address from last lookup	//    	return (int) gDNSAddr;}void sqResolverStartAddrLookup(int address) {	//	// start process to lookup name from address	//    	if (gDNSResolverStatus == RESOLVER_BUSY) return;	gDNSAddr            = (InetHost) address;    gDNSLookupType      = RESOLVER_ADDRTONAME;	ResolverStart();}void sqResolverStartNameLookup(char *hostName, int nameSize) {	//	// start process to lookup address from name	//    	UInt32 len; 	if (gDNSResolverStatus == RESOLVER_BUSY) return;	len = (UInt32) ((nameSize <= kMaxHostNameLen) ? nameSize : kMaxHostNameLen);  //Old limit was 500  but that appeared to be wrong	OTMemcpy(gDNSAddrStr, hostName, len);	gDNSAddrStr[len]    = ''\0'';    gDNSLookupType      = RESOLVER_NAMETOADDR;	ResolverStart();	}int sqResolverStatus(void) {	//	// return resolver status, this is different from resolver error code	// status is the same among implementations, error is implementation dependent	//    	return gDNSResolverStatus;}//================================// Socket logic //void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {				//	//Old call from old image using new VM	//Just make new call	//	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  		 s,  netType,  socketType, recvBufSize,  sendBufSize,  semaIndex,  semaIndex,  semaIndex);}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex)	{     OSErr error;      netType; recvBufSize; sendBufSize;            //    //Create a socket given the supplied information    //We don''t bind the socket to a local port  until     //we do the connection. This of course could change?     //        error = internalSocketCreate( s, netType, socketType, recvBufSize,  sendBufSize, semaIndex, readSemaIndex, writeSemaIndex, (UInt8) socketType);    if (error !!= noErr) {		interpreterProxy->success(false);         return;       }}static SInt32 internalSocketCreate(  SocketPtr s, SInt32 netType, SInt32 socketType,  SInt32 recvBufSize, SInt32 sendBufSize, SInt32 semaIndex, SInt32 readSemaIndex, SInt32 writeSemaIndex, UInt8 aExtraSocketHint)	{  //  // Internal logic to open a socket for a connection or to listen  // Note how we ignore buffer sizes!!  //    EPInfo*     epi;    socketType; netType; recvBufSize; sendBufSize;        //    //Make the socket invalid and then get an idle EP    //Technically we only run out of EP when we run out of memory    //    	s->sessionID = 0;	if (gProgramState !!= kProgramRunning ) {			    interpreterProxy->success(false);        return -1;    }	epi = getOrMakeMeAnEP(aExtraSocketHint,0);	if (epi == NULL) {		interpreterProxy->success(false);		return -1;	}	epi->outstandingSends   = 0;	epi->bytesPendingToRead = 0;	epi->semaIndex          = semaIndex;	epi->readSemaIndex      = readSemaIndex;	epi->writeSemaIndex     = writeSemaIndex;	epi->stateFlags         = 0;	epi->stateFlags2        = 0;	epi->stateFlags3        = 0;	SetEPLastError(epi,noErr);	epi->socketType        = aExtraSocketHint;	OTInitInetAddress(&epi->remoteAddress, 0, 0);    OTInitInetAddress(&epi->localAddress, 0, 0);        if (aExtraSocketHint == UDPSocketType)        OTAtomicSetBit(&epi->stateFlags, kConnected); //udp is always connected     else        OTAtomicSetBit(&epi->stateFlags, kUnConnected);  	s->sessionID            = gthisNetSession;	s->socketType           = (aExtraSocketHint == UDPSocketType) ? UDPSocketType : TCPSocketType;	s->privateSocketPtr     = epi;	gSocketsAllocated++;	return 0;}void sqSocketListenOnPort(SocketPtr s, int port) {    //    //Listen on port for a connection, this is not the approved method    //sqSocketListenOnPortBacklogSize is the best way if you are a server    //However this works ok for UDP and kinda for onetime connections in TCP    //    EPInfo* epi;	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	epi = (EPInfo *) s->privateSocketPtr;	if (s->socketType == TCPSocketType) {		DoBind(epi,0,(InetPort) port,TCPListenerSocketType,1);		if (epi->localAddress.fPort !!= port) {//We die if we don''t get the port we want            sqSocketDestroy(s);    	    interpreterProxy->success(false);		}	} else {//udp		DoBind(epi,0,(InetPort) port,UDPListenerSocketType,1);	}}void	sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize) {    EPInfo* epi;	SInt32 sema,readSema,writeSema;	OSErr error;    //    //Listen on port for a connection, this is the best method if you are    //a server. Works in conjunction with accept. Shouldn''t drop connections    //OT''s special listener logic queues up the listen requestions    //	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	if (s->socketType == TCPSocketType) {		epi = (EPInfo *) s->privateSocketPtr;		sema = epi->semaIndex; readSema = epi->readSemaIndex; writeSema = epi->writeSemaIndex;	    makeEPIdle(epi); //Special case really need a listener EP, so put this EP back on the queue	    				 //This may seem odd but the epi is allocated before we know what type it is.	    				 //Would need to change Squeak to indicate type at creation!!		error = internalSocketCreate( s, 0, TCPSocketType, 0,  0, sema, readSema, writeSema, TCPListenerSocketType);		if (error !!= noErr) {            interpreterProxy->success(false);             return;   		}        epi = (EPInfo *) s->privateSocketPtr;		DoBind(epi,0,(InetPort) port,TCPListenerSocketType,(OTQLen) backlogSize);		if (epi->localAddress.fPort !!= port) {//The port we wanted must match, otherwise we die		    sqSocketDestroy(s);    	    interpreterProxy->success(false);		}	} else {//udp not allowed       	    interpreterProxy->success(false);	}}void	sqSocketAcceptFromRecvBytesSendBytesSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex){	//	//Old call from old image using new VM	//Just make new call	//	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			 s,  serverSocket,  recvBufSize,  sendBufSize,  semaIndex,  semaIndex,  semaIndex);		}void	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {	//	//Accept incoming request from a listener	//We take information from the listener, create a new socket	//and accept the incoming call	//	    EPInfo* epiSocket;    EPInfo* epiServerSocket;    Boolean	doLeave;    OSErr   error;    long	count=0;    	if (!!SocketValid(serverSocket)) return;	if (serverSocket->socketType == TCPSocketType) {            error = internalSocketCreate( s, 0, TCPSocketType, recvBufSize,  sendBufSize, semaIndex, readSemaIndex, writeSemaIndex, TCPSocketType);		    if (error !!= noErr) {        		interpreterProxy->success(false); 		        return;   		    }		    epiSocket = (EPInfo *) s->privateSocketPtr;    		DoBind(epiSocket,0,0,TCPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE    		while (count++ < 100 && (OTAtomicTestBit(&epiSocket->stateFlags3, kWaitingForBind) == true)) {#ifndef TARGET_API_MAC_CARBON			    SystemTask();#endif			    OTIdle();            }		    OTAtomicSetBit(&epiSocket->stateFlags2, kPassconNeeded);		    epiServerSocket = (EPInfo *) serverSocket->privateSocketPtr;			OTAtomicSetBit(&epiServerSocket->stateFlags, kWaitingForConnection);			OTAtomicSetBit(&epiServerSocket->stateFlags, kUnConnected);            OTAtomicClearBit(&epiServerSocket->stateFlags, kConnected);    	    OTAtomicSetBit(&epiServerSocket->stateFlags2, kTapSemaphore);        	        	doLeave = OTEnterNotifier(epiServerSocket->erf);        	DoListenAccept(epiSocket,epiServerSocket);        	if (doLeave)        		OTLeaveNotifier(epiServerSocket->erf);	} else { //udp		interpreterProxy->success(false); 	}}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {    //    //Connect this socket to the given host addr and port    //    EPInfo* epi;	OTResult	epState;	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	epi = (EPInfo *) s->privateSocketPtr;	if (s->socketType == TCPSocketType) {    	DoBind(epi,(InetHost) addr,(InetPort) port,TCPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE which drives T_CONNECT/DoConnect	} else {//udp		epState = OTGetEndpointState(epi->erf);		if (epState == T_UNBND) {//Bind to remote, our side gets wildcarded    	    DoBind(epi,(InetHost) addr,(InetPort) port,UDPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE which drives T_CONNECT/DoConnect    	} else {//Already bound to a port/interface on our side    	    OTInitInetAddress(&epi->remoteAddress, (InetPort) port, (InetHost) addr);    	}	}}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	//	// Send data really fast	// We create a copy of the data and give it to OT to play with	// We can get flow controlled lower down, if no flow control then we	// tap the semiphore since from squeaks viewpoint data is sent, otherwise when flow control is lifted the	// semaphore is tapped in the notification routine	//	OTResult res ;    EPInfo* epi;    Boolean doLeave;    char * buffer; 	UInt32 adjustedBufSize = bufSize > 65536 ? 65536 : (UInt32) bufSize; //? Not sure if we really need to do this limiting.   		if (!!SocketValid(s)) return -1;		epi = (EPInfo *) s->privateSocketPtr;		// If send is blocked wait for unblocking	if (OTAtomicTestBit(&epi->stateFlags, kSendIsBlocked)) {	    return 0;	}    if (epi->socketType == UDPSocketType) {        //UDP adjust the buffer size again        adjustedBufSize = (adjustedBufSize > epi->UDPMaximumSize) ?   epi->UDPMaximumSize : adjustedBufSize;     }#if TARGET_API_MAC_CARBON	buffer = OTAllocMemInContext(adjustedBufSize, gClientContext);#else	buffer = OTAllocMem(adjustedBufSize);#endif	if (buffer == nil) {		//Well maybe we back off and wait awhile? 		//If we run out of memory and stress the box, well death lurks.		adjustedBufSize = 256;#if TARGET_API_MAC_CARBON		buffer = OTAllocMemInContext(adjustedBufSize, gClientContext);#else		buffer = OTAllocMem(adjustedBufSize);#endif		if (buffer == nil) {		    interpreterProxy->success(false); //Death did lurk	        SetEPLastError(epi, -1);	        return -1;	    } 	}			OTMemcpy(buffer,(void*) buf,adjustedBufSize);    	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_GODATA    res = SendData(epi,buffer,adjustedBufSize);  	  	if (doLeave)		OTLeaveNotifier(epi->erf);		  	if (res < 0 ){	    SetEPLastError(epi, res);		interpreterProxy->success(false); //JMM just for testing	    return 0;	}	return res;}////New primitive for sending UDP data to a particular host/port//Avoids race conditions between binding and send in Smalltalk//int sqSockettoHostportSendDataBufCount(SocketPtr s, int address, int port, int buf, int bufSize) { sqSocketConnectToPort(s, address, port); return sqSocketSendDataBufCount(s, buf, bufSize);}////Abort the socket//void sqSocketAbortConnection(SocketPtr s) {    EPInfo* epi;   OSStatus err; 	if (!!SocketValid(s)) return;    if (s->socketType == UDPSocketType) {		interpreterProxy->success(false);         return;    }	epi = (EPInfo *) s->privateSocketPtr;	err = doAbortConnection(epi);}////Acutal abort logic//We need to flush the queues//Then do a disconnect//static OSStatus doAbortConnection(EPInfo* epi) {   SInt32		count = 0;   OSStatus     err = kOTNoError; 	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 ) {		//Do flush and wait for it to happen		//Should make sync?		//		if (epi->outstandingSends !!= 0) {		    err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);		    while (count++ < 100 && (epi->outstandingSends !!= 0 || OTAtomicTestBit(&epi->stateFlags, kUnConnected) == false)) {			    OTIdle();            }	    }        makeEPBroken(epi,0);	    err = OTSndDisconnect(epi->erf, NULL);	}	    	if (err !!= kOTNoError) 	    return err;	else        return epi->lastError;}////Socket close logic//void sqSocketCloseConnection(SocketPtr s) {    EPInfo* epi;    OSStatus err; 	OTResult	epState;	OTResult	lookResult;    	if (!!SocketValid(s)) return;	epi = (EPInfo *) s->privateSocketPtr;    if (s->socketType == UDPSocketType) {//Handle udp and return        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);        OTAtomicClearBit(&epi->stateFlags, kConnected);        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);        OTAtomicSetBit(&epi->stateFlags, kUnConnected);        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);		err = OTUnbind(epi->erf);		if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.		    makeEPBroken(epi,err);		}	    TapAllInterestedSemaphores(epi);	    return;    }    OTAtomicSetBit(&epi->stateFlags, kThisEndClosed);    OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);	// old code is sync and doesn''t trigger semaphore 		epState = OTGetEndpointState(epi->erf);	if (epState == T_UNINIT || epState == T_UNBND ) {        OTAtomicSetBit(&epi->stateFlags, kThisEndClosed);        OTAtomicClearBit(&epi->stateFlags, kConnected);        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed); 	    TapAllInterestedSemaphores(epi);	    return;	}	else	    err = OTSndOrderlyDisconnect(epi->erf);	    	if (err == kOTNoError) {        if (OTAtomicTestBit(&epi->stateFlags, kOtherEndClosed)) {	        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);	        OTAtomicClearBit(&epi->stateFlags, kConnected);	        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);	        OTAtomicSetBit(&epi->stateFlags, kUnConnected);	        if (epi->outstandingSends !!= 0)	            doAbortConnection(epi);			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.			    makeEPBroken(epi,err);			}    	    TapAllInterestedSemaphores(epi);        }	} else {// Could get kOTLookErr with T_DISCONNECT pending 		lookResult = OTLook(epi->erf); 		if (err == kOTLookErr && lookResult == T_DISCONNECT) {        	err = OTRcvDisconnect(epi->erf, NULL);	        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);	        OTAtomicClearBit(&epi->stateFlags, kConnected);	        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);	        OTAtomicSetBit(&epi->stateFlags, kUnConnected);	        if (epi->outstandingSends !!= 0)	            doAbortConnection(epi);			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.			    makeEPBroken(epi,err);			}    	    TapAllInterestedSemaphores(epi);        }        else {            SetEPLastError(epi,err);    		makeEPBroken(epi,err);            TapAllInterestedSemaphores(epi);       }	}}////Destroy the socket here we must ensure we cleanup and put the //socket back on the idle or broken EP queue//void sqSocketDestroy(SocketPtr s) {    OTResult err;    EPInfo* epi;	OTResult	epState;    JMMWriteLog(); //Diagnostics, turned off, must fiddle recompile to turn on.          if (!!SocketValid(s)) {    	return;     }	epi = (EPInfo *) s->privateSocketPtr;   OTAtomicSetBit(&epi->stateFlags2, kMakeEPIdle); 	epState = OTGetEndpointState(epi->erf);	if (epState == T_UNINIT || epState == T_UNBND ) {	    makeEPIdle(epi); //Unbound already so make him idle.	} else {	    if (s->socketType == UDPSocketType)			err = OTUnbind(epi->erf);	    else 		    err = doAbortConnection(epi);			if (err !!= kOTNoError) {//kOTLookErr with T_DATA, book says response is to zap EP.		    makeEPBrokenThenIdle(epi,err);		}	}	purgeReadBuffers(epi); //JMM Oct 4th 2000 (bug?)	s->sessionID = 0;	s->socketType = -1;	s->privateSocketPtr = nil;	gSocketsAllocated--; }////Check to see if bytes are available//int sqSocketReceiveDataAvailable(SocketPtr s)							{    EPInfo* epi;    static lastTickCount=0;	if (!!SocketValid(s)) return 0;    epi = (EPInfo *) s->privateSocketPtr;    if (epi->bytesPendingToRead > 0)         return 1;       if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) // New case if data pending but flow controlled then go get it        return 1;        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphoreReadData); //Note how we imply there will be interest in semaphore    return 0;}////Read data into the buffer supplied//int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {    EPInfo* epi; 	UInt32  bytesRead = 0;    Boolean doLeave;    	if (!!SocketValid(s)) return -1; 		epi = (EPInfo *) s->privateSocketPtr;         	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_DATA    bytesRead = readBytes(epi,(char *) buf,(UInt32) bufSize);    if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) {        if (bytesRead > 0)             ReadData(epi,NULL,0);         else            bytesRead = ReadData(epi,(char *) buf,(UInt32) bufSize); //special case attempt read into squeak buffer    }  	if (doLeave)		OTLeaveNotifier(epi->erf);   	return (int) bytesRead;}////New primitive to read UDP data and get data, host/port, and more flag//int sqSocketReceiveUDPDataBufCountaddressportmoreFlag(SocketPtr s, int buf, int bufSize,  int *address,  int *port, int *moreFlag) {    EPInfo* epi; 	UInt32 bytesRead = 0;    Boolean doLeave;    InetAddress fromAddress;        OTMemzero(&fromAddress,sizeof(InetAddress));    *address  = 0;    *port = 0;    *moreFlag = 0;    	if (!!SocketValid(s)) return -1;		epi = (EPInfo *) s->privateSocketPtr;         	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_DATA    bytesRead   = readBytesUDP(epi,&fromAddress, moreFlag, (char *) buf,(UInt32) bufSize);    *address    = fromAddress.fHost;    *port       = fromAddress.fPort;    if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) {         if (bytesRead > 0)             ReadData(epi,NULL,0);         else {            bytesRead = ReadData(epi,(char *) buf,(UInt32) bufSize);//special case attempt read into squeak buffer            *address    = epi->remoteAddress.fHost; //Also we happen to know the address just when into this area            *port       = epi->remoteAddress.fPort; //JMM more flag?            *moreFlag   = epi->UDPMoreFlag;        }    }  	if (doLeave)		OTLeaveNotifier(epi->erf);   	return (int) bytesRead;}int sqSocketLocalAddress(SocketPtr s) {    EPInfo* epi;    	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;    return (int) (epi->localAddress.fHost == 0) ? sqResolverLocalAddress() : epi->localAddress.fHost;}int sqSocketLocalPort(SocketPtr s) {    EPInfo* epi;    	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;		return epi->localAddress.fPort;}int sqSocketRemoteAddress(SocketPtr s) {    EPInfo*     epi;    TBind       remoteBind;    InetAddress remoteAddr;    SInt32        counter=0;    OSStatus    err;	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;	if (OTAtomicTestBit(&epi->stateFlags, kUnConnected) && 	    !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)) return 0;	    if (epi->socketType == UDPSocketType) {        return (int) epi->remoteAddress.fHost;    }        //It seems the only reliable way to get the address    //Is to make a call    //    OTMemzero(&remoteBind,sizeof(TBind));    OTMemzero(&remoteAddr,sizeof(InetAddress));    remoteBind.addr.buf = (UInt8 *) &remoteAddr;    remoteBind.addr.maxlen = sizeof(InetAddress);    err = OTGetProtAddress(epi->erf,0,&remoteBind);    while (counter++ < 10 && remoteAddr.fHost == 0) {        OTIdle();    }        if (err !!= kOTNoError)         return 0;    else        return (int) remoteAddr.fHost;}int sqSocketRemotePort(SocketPtr s) {    EPInfo* epi;    TBind       remoteBind;    InetAddress remoteAddr;    SInt32        counter=0;    OSStatus    err;	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;	if (OTAtomicTestBit(&epi->stateFlags, kUnConnected) && 	    !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)) return 0;	    if (epi->socketType == UDPSocketType) {        return epi->remoteAddress.fPort;    }        //It seems the only reliable way to get the port    //Is to make a call    //    OTMemzero(&remoteBind,sizeof(TBind));    OTMemzero(&remoteAddr,sizeof(InetAddress));    remoteBind.addr.buf = (UInt8 *) &remoteAddr;    remoteBind.addr.maxlen = sizeof(InetAddress);    err = OTGetProtAddress(epi->erf,0,&remoteBind);    while (counter++ < 10 && remoteAddr.fHost == 0) {        OTIdle();    }        if (err !!= kOTNoError)         return 0;    else        return remoteAddr.fPort;}int sqSocketSendDone(SocketPtr s) {    EPInfo* epi;	if (!!SocketValid(s)) return 1;	epi = (EPInfo *) s->privateSocketPtr;    if (OTAtomicTestBit(&epi->stateFlags, kSendIsBlocked)) {	    OTAtomicSetBit(&epi->stateFlags2, kTapSemaphoreWriteData); //Note the implied intent to use the semaphore        return 0;    }    else {        return 1;    }}int sqSocketError(SocketPtr s) {    EPInfo* epi;     	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;    if (OTAtomicTestBit(&epi->stateFlags, kUnConnected)  &&         !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)         && epi->lastError == 0)	    return kENOTCONNErr; // old code would return unconnectederror if unconnected	else	    return (epi->lastError);}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return InvalidSocket;	return unmapStatus((EPInfo *) s->privateSocketPtr);}static SInt32 unmapStatus(EPInfo *s) {    if (OTAtomicTestBit(&s->stateFlags3, kSleepKilledMe))         {return  InvalidSocket;        }    if (OTAtomicTestBit(&s->stateFlags, kThisEndClosed))         {return  ThisEndClosed;        }    if (OTAtomicTestBit(&s->stateFlags, kOtherEndClosed))         {return  OtherEndClosed;        }    if (OTAtomicTestBit(&s->stateFlags, kConnected))         { return  Connected;        }    if (OTAtomicTestBit(&s->stateFlags, kWaitingForConnection))         {return  WaitingForConnection;        }    if (OTAtomicTestBit(&s->stateFlags, kUnConnected))         {return  Unconnected;        }   return 0;}static Boolean SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == gthisNetSession) && 		(s->socketType == TCPSocketType || s->socketType == UDPSocketType) &&		(!!OTAtomicTestBit(&(((EPInfo *)s->privateSocketPtr)->stateFlags3), kSleepKilledMe)) )		    return true;	interpreterProxy->success(false);	return false;}static Boolean PortNumberValid(InetPort port) {	if (port <= 65535) {		return true;	}	interpreterProxy->success(false);	return false;}//Used to signal all semaphores when we''ve closed the socket//I guess the read/write/disconnect threads really want to know//static void TapAllInterestedSemaphores(EPInfo *epi) {    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);     if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreReadData)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->readSemaIndex);     if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex); 				}static Boolean DestroyAllOpenSockets(void) {	EPInfo      *epi;	OTLink*		link;    ReadBuffer *aBuffer;	//	//	Start closing connector endpoints.	//	While we could be rude and just close the endpoints, 	//	we try to be polite and wait for all outstanding connections	//	to finish before closing the endpoints.   The is a bit easier	//	on the server which won''t end up keeping around control blocks	//	for dead connections which it doesn''t know are dead.  Alternately,	//	we could just send a disconnect, but this seems cleaner.	//	(void)OTLIFOStealList(gBrokenEPs);	(void)OTLIFOStealList(gIdleEPs[0]);	(void)OTLIFOStealList(gIdleEPs[1]);	(void)OTLIFOStealList(gIdleEPs[2]);	    link = OTLIFODequeue(gAllEPs);    while (link !!= NULL) {        epi = OTGetLinkObject(link, EPInfo, globalLink);     	attemptToCloseAndDeleteThisEP(epi);        link = OTLIFODequeue(gAllEPs);    }	//	//	If the lists are empty now, then all endpoints have been successfully closed,	//	so the client is stopped now.  (Actually we hope that is the case)	//	    //    //Free up all the other resources    //    link = OTLIFODequeue(gFreeReadBuffers);    while (link !!= NULL) {    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);        OTFreeMem(aBuffer->readBufferData);        OTFreeMem(aBuffer);         link = OTLIFODequeue(gFreeReadBuffers);    }    ResolverTerminate();	OTFreeMem((char*)gDNSResolver);	gIdleEPs[0]->fHead		= NULL;	gIdleEPs[1]->fHead		= NULL;	gIdleEPs[2]->fHead		= NULL;	gBrokenEPs->fHead 		= NULL;	OTDestroyConfiguration(gCfgMastertcp);	OTDestroyConfiguration(gCfgMasterudp);	OTDestroyConfiguration(gCfgMasterListener);	DisposeOTNotifyUPP(DNSNotifierUPP);	DisposeOTNotifyUPP(NotifierSocketUPP);	DisposeOTNotifyUPP(NotifierSocketUDPUPP);	DisposeOTNotifyUPP(NotifierSocketListenerUPP);	return true;}////	DoBind////	This routine either binds to a wild card address and specfic port if //  we are doing a listen, otherwise we bind to a wild card address and //  wild card port if we are starting a connection to a remote host.//  J M M NOTE A more complex version could use port and addr//  Note we don''t bind to the local socket until here, we could when //  The socket is created, but that leads to odd issues.//static void DoBind(EPInfo* epi,InetHost addr, InetPort port,UInt8 aExtraSocketHint,OTQLen queueDepth ){	OSStatus 	err;	TBind 		bindReq, bindResult;	InetAddress	inAddr,bindAddr;		switch (aExtraSocketHint) {        case TCPSocketType: {            // for a connection        	//	Bind the endpoint to a wildcard address         	//	(assign us a port, we don''t care which one).        	//  NOTE A more complex version could use port and addr            OTInitInetAddress(&epi->remoteAddress, port, addr);            OTInitInetAddress(&epi->localAddress, 0, kOTAnyInetAddress);        	OTInitInetAddress(&inAddr, 0, 0);            break;        }        case UDPSocketType: {             // for a connection        	//	Bind the endpoint to earlier supplied information            OTInitInetAddress(&epi->remoteAddress, port, addr);        	OTInitInetAddress(&inAddr, 0, 0);            break;        }        case TCPListenerSocketType: {            // For a listen, bind wild card address, but supplied port.            // Note the passed in addr should be zero            // Note a more complex version could supply the address            OTInitInetAddress(&epi->remoteAddress, 0, kOTAnyInetAddress);            OTInitInetAddress(&epi->localAddress, port, addr);        	OTInitInetAddress(&inAddr,port, addr);            break;        }        case UDPListenerSocketType: {            // For a listen, bind wild card address, but supplied port.            // Note the passed in addr should be zero            // Note a more complex version could supply the address            OTInitInetAddress(&epi->remoteAddress, 0, kOTAnyInetAddress);            OTInitInetAddress(&epi->localAddress, port, addr);        	OTInitInetAddress(&inAddr,port, addr);            break;        }	} 	bindReq.addr.len    	= sizeof(InetAddress);	bindReq.addr.buf    	= (unsigned char*) &inAddr;	bindReq.qlen        	= queueDepth; //Note queue depth for listening 	bindResult.addr.maxlen	= sizeof(InetAddress); 	bindResult.addr.len   	= sizeof(InetAddress);	bindResult.addr.buf    	= (unsigned char*) &bindAddr;	epi->stateFlags     	= 0;	epi->stateFlags2   		= 0;	epi->stateFlags3    	= 0;	epi->bytesPendingToRead = 0;	SetEPLastError(epi,noErr);	if (aExtraSocketHint == TCPSocketType|| aExtraSocketHint == TCPListenerSocketType) {        OTAtomicSetBit(&epi->stateFlags, kUnConnected);        OTAtomicSetBit(&epi->stateFlags, kWaitingForConnection);        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);    }		OTAtomicSetBit(&epi->stateFlags3, kWaitingForBind);	err = OTBind(epi->erf, &bindReq, &bindResult); // resume at T_BINDCOMPLETE		// for bindReq on listen what is queueDepth now? 	// bindReq.qlen could have changed	// But... No why to feed this back to the client!!		if (err !!= kOTNoError) {    	SetEPLastError(epi,err);        makeEPUnconnected(epi);    	return;	}		OTMemcpy(&epi->localAddress,bindResult.addr.buf,sizeof(InetAddress)); //Pickup local address	return;}////	DoConnect////	This routine attempts establish a new connection to the given//	address and port.  //  Called via the notifier at interrupt time.//static void DoConnect(EPInfo* epi,InetHost addr, InetPort port){	OSStatus err;	TCall sndCall;	InetAddress inAddr;		//	Don''t want new connections if already shutting down.	if (gProgramState !!= kProgramRunning ) return;			OTInitInetAddress(&inAddr, port, addr);	OTMemzero(&sndCall, sizeof(TCall));	sndCall.addr.len 	= sizeof(InetAddress);					sndCall.addr.buf	= (unsigned char*) &inAddr;		err = OTConnect(epi->erf, &sndCall, NULL); //resume at T_CONNECT	if (err !!= kOTNoDataErr) {    	SetEPLastError(epi,err);        makeEPUnconnected(epi);		return;	}}////	DoListenAccept////	The handling of a T_LISTEN is greatly simplified by use//	of the tilisten module, which serializes inbound connections.//	This means that when doing an OTAccept we won''t get a kOTLookErr//	because another inbound connection arrived and created a T_LISTEN.//	Without the tilisten module, we have to use the "8 step //	listen/accept/disconnect method", which is documented elsewhere.//static void DoListenAccept(EPInfo* acceptor,EPInfo* theServer){	TCall		call;	InetAddress	caddr;	OTResult	lookResult;	OSStatus	err;				OTMemzero(&call, sizeof(TCall));	call.addr.maxlen = sizeof(InetAddress);	call.addr.buf = (unsigned char*) &caddr;			err = OTListen(theServer->erf, &call);	if (err !!= kOTNoError) {		//		//	Only two errors are expected at this point.		//	One would be a kOTNoDataErr, indicating the inbound connection		//	was unavailable, temporarily hidden by a higher priority streams		//	message, etc.   The more likely error is a kOTLookErr, 		//	which indicates a T_DISCONNECT on the OTLook()		//	happens when the call we were going to process disconnected.		//	In that case, go away and wait for the next T_LISTEN event.		//		if (err == kOTNoDataErr) return;					lookResult = OTLook(theServer->erf); 		if (err == kOTLookErr && lookResult == T_DISCONNECT)        	err = OTRcvDisconnect(theServer->erf, NULL);		else 		    SetEPLastError(theServer,lookResult);				//JMM Sept28th,2000 ? ok accept it, if we don''t does this cause blockage?		acceptor->remoteAddress = caddr;		err = OTAccept(theServer->erf, acceptor->erf, &call);		return;		}		acceptor->remoteAddress = caddr;		err = OTAccept(theServer->erf, acceptor->erf, &call);	//	//	Note an kOTIndOutErr can occur if we are listening on the EP and handling 	//  off to the same EP. Sorry use the listento:backlogqueue: logic instead    //	if (err !!= kOTNoError) {		//		//	Again, we have to be able to handle the connection being disconnected		//	while we were trying to accept it.		//		lookResult = OTLook(theServer->erf);		if (err == kOTLookErr && lookResult == T_DISCONNECT)         	err = OTRcvDisconnect(theServer->erf, NULL);		else 		    SetEPLastError(theServer,lookResult);	}}////	EPOpen:////	A front end to OTAsyncOpenEndpoint.//	A status bit is set so we know there is an open in progress.//	It is cleared when the notifier gets a T_OPENCOMPLETE where the context//	pointer is this EPInfo.  Until that happens, this EPInfo can''t be cleaned//	up and released.//static Boolean EPOpen(EPInfo* epi){	OSStatus err;		OTAtomicSetBit(&epi->stateFlags, kOpenInProgressBit);	SetEPLastError(epi,kOTNoError);    epi->UDPMaximumSize = 0; //Remember to figure out the max UDP size.    	switch (epi->socketType) {	    case TCPSocketType: {#if TARGET_API_MAC_CARBON		    err = OTAsyncOpenEndpointInContext(OTCloneConfiguration(gCfgMastertcp), 0, NULL, NotifierSocketUPP, epi, gClientContext); #else		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMastertcp), 0, NULL, NotifierSocketUPP, epi); #endif	        break;	    }	    case UDPSocketType: {	        TEndpointInfo endPointInformation;#if TARGET_API_MAC_CARBON		    err = OTAsyncOpenEndpointInContext(OTCloneConfiguration(gCfgMasterudp), 0, &endPointInformation, NotifierSocketUDPUPP, epi, gClientContext); #else		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMasterudp), 0, &endPointInformation, NotifierSocketUDPUPP, epi); #endif		    epi->UDPMaximumSize = (endPointInformation.tsdu == T_INFINITE) ? 64*1024 : endPointInformation.tsdu;	        break;	    }	    case TCPListenerSocketType: {#if TARGET_API_MAC_CARBON		    err = OTAsyncOpenEndpointInContext(OTCloneConfiguration(gCfgMasterListener), 0, NULL, NotifierSocketListenerUPP, epi, gClientContext); #else		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMasterListener), 0, NULL, NotifierSocketListenerUPP, epi); #endif	        break;	    }	}	if (err !!= kOTNoError) {		SetEPLastError(epi,err);		OTAtomicClearBit(&epi->stateFlags, kOpenInProgressBit);		return false;	}	return (epi->lastError == kOTNoError);}////	EPClose////	This routine is a front end to OTCloseProvider.   //	Centralizing closing of endpoints makes debugging and instrumentation easier.  //static Boolean EPClose(EPInfo* epi){	OSStatus err;		//	//	If an endpoint is still being opened, we can''t close it yet.	//	There is no way to cancel an OTAsyncOpenEndpoint, so we just	//	have to wait for the T_OPENCOMPLETE event at the notifier.	//	if ( OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit) )		return false;		    	//	//	If the OTAsyncOpenEndpoint failed, the endpoint ref will be NULL,	//	and we don''t need to close it now. Also can be NULL or should be NULL if sleeping happened.	//	if (epi->erf == NULL || OTAtomicClearBit(&epi->stateFlags3, kSleepKilledMe)) {	    epi->erf = NULL;		return true;	}			if (epi->outstandingSends == 0) {    	err = OTCloseProvider(epi->erf);    	epi->erf = NULL;    	return true;    }    	    //	//	If we get to this point, the endpoint did an OTSnd() with AckSends,	//	and the T_MEMORYRELEASED event hasn''t been returned yet.  In order	//	to make sure we get the event, we flush the stream and then do an	//	OTDisconnect().   This should get the memory freed so we can close	//	the endpoint safely.   Note, we set a flag so we don''t do this 	//	more than once on an endpoint.	//  J M M I''m not sure we''ll ever get here since a flush should have been done higher up	//	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )	{		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);		if (err !!= kOTNoError)			{} 	}	return false;}////	Recycle:////	This routine shouldn''t be necessary, but it is helpful to work around both//	problems in OpenTransport and bugs in this program.   Basicly, whenever an//	unexpected error occurs which shouldn''t be fatal to the program, the EPInfo//	is queued on the BrokenEP queue.  When recycle is called,//  it will attempt to close the associated endpoint and open//	a new one to replace it using the same EPInfo structure.   This process of//	closing an errant endpoint and opening a replacement is probably the most//	reliable way to make sure that this program and OpenTransport can recover//	from unexpected happenings in a clean manner.////  Mind you it can be invoked to cleanup UDP sockets that aren''t closed //  properly due to pending traffice on a busy port.//  Solution mentioned in books is to close the EP.//static void Recycle(){	OTLink* 	list = OTLIFOStealList(gBrokenEPs);	OTLink*		link;	EPInfo*		epi;	while ( (link = list) !!= NULL ) {		list = link->fNext;		epi = OTGetLinkObject(link, EPInfo, link);		if (!!EPClose(epi)) {			OTLIFOEnqueue(gBrokenEPs, &epi->link);			continue;		}		if (gProgramState == kProgramRunning)		    EPOpen(epi);		 else		    makeEPIdle(epi);	}}//// Make the EP idle, it either goes on an idle queue or gets broken.//static void    makeEPIdle(EPInfo *epi) {    purgeReadBuffers(epi);        if (OTAtomicClearBit(&epi->stateFlags2, kEPIsBroken)) {        OTLIFOEnqueue(gBrokenEPs, &epi->link);     } else {	    OTLIFOEnqueue(gIdleEPs[epi->socketType], &epi->link);    	    OTAtomicAdd32(1, &gIdleEPCounter[epi->socketType]);    }}static void attemptToCloseAndDeleteThisEP (EPInfo *epi) {    purgeReadBuffers(epi); 	if (!!EPClose(epi)) {		//	Can''t close this endpoint yet, so skip it.	} else 	    OTFreeMem((char*)epi);}static EPInfo* getOrMakeMeAnEP(UInt8 aSocketType,short counter) {	EPInfo      *epi;    OTLink		*link;    SInt32      i;        Recycle();  //Ensure broken EP get fixed up        if (counter > 25)         return nil;  // End recursion John 2000/8/29    if (gIdleEPCounter[aSocketType] < 5)   //Magic Number ensure we have at least 5 EP available.        makeMeAnEP(aSocketType);            link = OTLIFODequeue(gIdleEPs[aSocketType]);	if (link == NULL) {		for(i=0;i<10;i++) {OTIdle();};		return getOrMakeMeAnEP(aSocketType,counter+1); //Watch for recursive failure	}	   	OTAtomicAdd32(-1, &gIdleEPCounter[aSocketType]);	epi = OTGetLinkObject(link, EPInfo, link);		if (OTAtomicTestBit(&epi->stateFlags3, kSleepKilledMe)) {	//	//A broken epi on the idle stack, now the only way we can 	//get here (I think) is to have gone to sleep which breaks	//all the end points. To clean up we must now fix them	//So make it idle, of course it''s broken	//Then recursive call to get another one	//This continues until we get a good one	//  	    makeEPIdle(epi);	    return getOrMakeMeAnEP(aSocketType,counter);  //Not a recursion issue. 	}    return epi;}////This is where EP are actually made and opened//EP opening is async//static Boolean makeMeAnEP (UInt8 aSocketType) {	EPInfo      *epi;	#if TARGET_API_MAC_CARBON	epi = (EPInfo*) OTAllocMemInContext(sizeof(EPInfo), gClientContext);#else	epi = (EPInfo*) OTAllocMem(sizeof(EPInfo));#endif	if (epi == NULL) return false;   //Death lurks	OTMemzero(epi, sizeof(EPInfo));  //zero it out which makes all the pointers null    epi->socketType = aSocketType;    OTLIFOEnqueue(gAllEPs, &epi->globalLink);	return EPOpen(epi);}static void makeEPUnconnected(EPInfo *epi) {	OTAtomicClearBit(&epi->stateFlags, kWaitingForConnection);	OTAtomicSetBit(&epi->stateFlags, kUnConnected);    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) //tap to clear waitforconnection on error        interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);}static void makeEPConnected(EPInfo *epi) {	OTAtomicClearBit(&epi->stateFlags, kWaitingForConnection);	OTAtomicClearBit(&epi->stateFlags, kUnConnected);    OTAtomicSetBit(&epi->stateFlags, kConnected);    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) //tap to clear waitforconnection        interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);}static void makeEPBrokenThenIdle(EPInfo* epi,OTResult error) {    makeEPBroken(epi,error);    makeEPIdle(epi);}static void makeEPBroken(EPInfo* epi,OTResult error) {    SetEPLastError(epi,error);    OTAtomicSetBit(&epi->stateFlags2, kEPIsBroken);}static void SetEPLastError(EPInfo* epi,OTResult error) {    if (error < 0) {		JMMLogMessageAndNumber("\p NonZero Error For ",epi->semaIndex);		JMMLogMessageAndNumber("\p NonZero Error Is  ",error);    }    epi->lastError = error;}//	ReadData:////	This routine attempts to read all available data from an endpoint.//	it is not necessary for the program to handle//	getting back a T_DATA notification DURING an OTRcv() call, as would be//	the case if we read from outside the notifier.   We must read until we//	get a kOTNoDataErr in order to clear the T_DATA event so we will get//	another notification of T_DATA in the future.//  Note we use EnterNotifier to make this possible////	Note for the curious we attempted to use no-copy receives to get data.  This obligates//	the program to return the buffers to OT asap.  BUT we found we overran memory!!//  So we reverted to more expensive copies into buffers we have preallocated////  Perhaps a seperate routine for UDP would make sense?//  Note May 30/00 we added a special read when we exhaust the internal buffer pool//  But data is still pending we allow you to read into the squeak buffer directly//static UInt32 ReadData(EPInfo* epi,char *specialReadBuffer,UInt32 specialReadSize) {	OTResult  	res;	OTFlags	  	flags;	OTResult	epState,err;	OTLink		*link;    ReadBuffer 	*readBufferObject,simulatedReadBuffer;    InetAddress UDPdataFromAddress;	    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreReadData)) //tap to clear waitfordata Data Data Data        interpreterProxy->signalSemaphoreWithIndex(epi->readSemaIndex);            if (specialReadSize > 0) { //Special case drop into squeak buffer, make a simulated buffer object        OTMemzero(&simulatedReadBuffer,sizeof(ReadBuffer));        simulatedReadBuffer.readBufferData = specialReadBuffer;        simulatedReadBuffer.readBufferSize = simulatedReadBuffer.readBufferOriginalSize = specialReadSize;        readBufferObject = &simulatedReadBuffer;    } else {       link = OTLIFODequeue(gFreeReadBuffers);                	if (link == NULL) {           	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl);  //NO free buffers we are flow controled        	return;     	}		gFreeReadBuffersCounter--;    	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);        OTAtomicClearBit(&epi->stateFlags2, kReadFlowControl);      }        OTMemzero(&UDPdataFromAddress,sizeof(InetAddress));    	while (true) {        		readBufferObject->readBufferPtr = readBufferObject->readBufferData;		   	    if (epi->socketType == UDPSocketType) {   	        TUnitData 	UDPDataInBound;   	        OTFlags     flagMeaningMore;            OSStatus    error;                	    UDPDataInBound.addr.maxlen = sizeof(InetAddress);    	    UDPDataInBound.addr.len    = sizeof(InetAddress);    	    UDPDataInBound.addr.buf    = (UInt8*) &readBufferObject->UDPAddress;    	    UDPDataInBound.opt.maxlen  = 0;    	    UDPDataInBound.opt.len     = 0;    	    UDPDataInBound.opt.buf     = NULL;    	    UDPDataInBound.udata.maxlen = readBufferObject->readBufferOriginalSize;    	    UDPDataInBound.udata.len    = readBufferObject->readBufferOriginalSize;    	    UDPDataInBound.udata.buf    = (UInt8*)readBufferObject->readBufferData;	    	        error =  OTRcvUData(epi->erf, &UDPDataInBound, &flagMeaningMore);	        	        if (error !!= kOTNoError) {	            res = error;	        } else {	            if (UDPDataInBound.addr.len == 0) //Remember UDP address	                readBufferObject->UDPAddress = UDPdataFromAddress;	            else	                UDPdataFromAddress = readBufferObject->UDPAddress;	                	            epi->UDPMoreFlag = readBufferObject->UDPMoreFlag = (flagMeaningMore > 0) ? true: false;	            res = (SInt32) UDPDataInBound.udata.len; 	            OTMemcpy(&epi->remoteAddress,&readBufferObject->UDPAddress,sizeof(InetAddress));  	        }   	    } else {//A less complicated tcp read   	        res = OTRcv(epi->erf, readBufferObject->readBufferData, readBufferObject->readBufferOriginalSize, &flags);   	    }   	    		//		//	Note, check for 0 because can get a real 0 length receive		//	in some protocols (not in TCP), which is different from		//	getting back a kOTNoDataErr.		//		if (res >= 0) {            if (specialReadSize > 0)                 return (UInt32) res; //Note special case                            readBufferObject->readBufferSize = (UInt32) res;                        OTAddLast(&epi->readBuffers,&readBufferObject->fNext); //Put the buffer on the read queue        	OTAtomicAdd32(res, &epi->bytesPendingToRead);            link = OTLIFODequeue(gFreeReadBuffers);                            	if (link == NULL) {               	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl); //Our read flow control, OT will block lower down            	return;         	}			gFreeReadBuffersCounter--;        	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);   			continue; //Loop around and get more bytes if available		}		else {            if (specialReadSize == 0) {                OTLIFOEnqueue(gFreeReadBuffers, &readBufferObject->fNext); //Read above didn''t work so put it back on free queue				gFreeReadBuffersCounter++;			}		}				if (res == kOTNoDataErr) {			//			//	Since ReadData is only called from inside the notifier			//	we don''t have to worry about having missed a T_DATA 			//	during the OTRcv.			//  Note use of EnterNotifier logic			//			if (specialReadSize > 0)			    OTAtomicClearBit(&epi->stateFlags2, kReadFlowControl); 			return 0;		}		if (res == kOTLookErr) {			res = OTLook(epi->erf);			if (res == T_ORDREL || res == T_DISCONNECT) {				//	If we got the T_ORDREL, we won''t get any more inbound data.				//	We return and wait for the notifier to get the T_ORDREL notification.				//	Upon getting it, we will notice we still need to send data and do so.				//	The T_ORDREL has to be cleared before we can send. 				//				if (specialReadSize > 0 && res == T_DISCONNECT) {					//Special case? need to get disconnect 					err = OTRcvDisconnect(epi->erf, NULL);					makeEPUnconnected(epi);				}				return 0 ;			}			if (res == T_GODATA) {			    if (specialReadSize == 0) {    			    link = OTLIFODequeue(gFreeReadBuffers);                    	if (link == NULL) {                       	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl);                    	return 0 ;                 	}					gFreeReadBuffersCounter--;                	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);            	} else {            	    return 0;            	}			    continue; //OT Flow control lifted keep reading. JMM			}		} else {			epState = OTGetEndpointState(epi->erf);			if (res == kOTOutStateErr && epState == T_INREL) {				//				//	Occasionally this problem will happen due to what appears				//	to be an OpenTransport notifier reentrancy problem.   				//	What has occured is that a T_ORDREL event happened and 				//	was processed during ReadData().   This is proven by being				//	in the T_INREL state without having done a call to				//	OTRcvOrderlyDisconnect() here.   It appears to be a benign 				//	situation, so the way to handle it is to understand that no				//	more data is going to arrive and go ahead and being our response				//	to the client.				//				break;			}			if (res == kOTOutStateErr && (epState == T_UNBND || epState == T_IDLE ) && specialReadSize > 0) {				  interpreterProxy->success(false); //JMM Oct 4th 2000 special case fail if read on unbound				  return 0;			}		break; //Ok error so break out of loop		}	}    return 0;	}//// NOT USED HISTORICAL REASONS// /*static void NoCopyReceiveWalkingBufferChain(EPInfo *epi,OTBufferInfo *bufferInfo){   OSStatus     err;   OTBuffer     *thisBuffer;   UInt32       count;   ReadBuffer   *readBufferObject;           thisBuffer = bufferInfo->fBuffer;    err = noErr;    while (err == noErr && thisBuffer !!= nil) {        count = thisBuffer->fLen;    	OTAtomicAdd32(count, &epi->bytesPendingToRead);		readBufferObject = OTAllocMemInContext(sizeof(ReadBuffer), gClientContext);        if (readBufferObject == nil) {			SysBeep(5);            err = -1;            break;        }         OTMemzero(readBufferObject,sizeof(ReadBuffer));        readBufferObject->readBufferData = readBufferObject->readBufferPtr = OTAllocMemInContext(count, gClientContext);        if ( readBufferObject->readBufferData == nil) {			SysBeep(5);             err = -1;            break;        }         readBufferObject->readBufferOriginalSize = readBufferObject->readBufferSize = count;        OTMemcpy(readBufferObject->readBufferData,thisBuffer->fData,count);        OTAddLast(&epi->readBuffers,&readBufferObject->fNext);        thisBuffer = thisBuffer->fNext;    }   // Clean up.  We MUST release the OTBuffer chain to Open Transport    // so that it crelease the OTBuffer chain to Open Transport    // so that it can reuse it., OTReleaseBuffer does not tolerate   // the parameter being nil, so we check for that case first.    if (bufferInfo->fBuffer !!= nil) {      OTReleaseBuffer(bufferInfo->fBuffer);   }}*///// Read Bytes from the buffers// Called by Squeak to get the data//static UInt32  readBytes(EPInfo* epi,char *buf,UInt32 adjustedBufSize){    //    // Read bytes from buffers    // use recursion to fill buf to adjustedBufSize or     // til we have no buffers left    // By using enterNotifier higher up we avoid race on the readBuffers list    //        UInt32 		increment,bytesRead = 0;    ReadBuffer *aBuffer;        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    if (aBuffer == nil) return 0;        if (aBuffer->readBufferSize > adjustedBufSize) {        bytesRead = adjustedBufSize;    	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy((char *) buf,aBuffer->readBufferPtr,bytesRead);        aBuffer->readBufferPtr += bytesRead;        aBuffer->readBufferSize -= bytesRead;        OTAddFirst(&epi->readBuffers,&aBuffer->fNext);        return bytesRead;    }    else {        bytesRead = aBuffer->readBufferSize;       	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy(buf,aBuffer->readBufferPtr,bytesRead);        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);		gFreeReadBuffersCounter++;        increment = readBytes(epi,buf+bytesRead,adjustedBufSize-bytesRead);        bytesRead += increment;        return bytesRead;   }}static UInt32  readBytesUDP(EPInfo* epi,InetAddress *fromAddress, int * moreFlag, char *buf,UInt32 adjustedBufSize){    //    // Read bytes from buffers    // For UDP we just drop in the read buffer and address    // Don''t fill the entire buffer no recursion.    // By using enterNotifier higher up we avoid race on the readBuffers list    //        UInt32      bytesRead = 0;    ReadBuffer  *aBuffer;        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    if (aBuffer == nil) return 0;        if (aBuffer->readBufferSize > adjustedBufSize) {        bytesRead = adjustedBufSize;    	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy((char *) buf,aBuffer->readBufferPtr,bytesRead);        aBuffer->readBufferPtr += bytesRead;        aBuffer->readBufferSize -= bytesRead;        OTMemcpy(fromAddress,&aBuffer->UDPAddress,sizeof(InetAddress));        *moreFlag = aBuffer->UDPMoreFlag;        OTAddFirst(&epi->readBuffers,&aBuffer->fNext);        return bytesRead;    }    else {        bytesRead = aBuffer->readBufferSize;       	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy(buf,aBuffer->readBufferPtr,bytesRead);        OTMemcpy(fromAddress,&aBuffer->UDPAddress,sizeof(InetAddress));        *moreFlag = aBuffer->UDPMoreFlag;        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);		gFreeReadBuffersCounter++;        return bytesRead;   }}//Cleanup logic//static void purgeReadBuffers(EPInfo *epi) {    ReadBuffer *aBuffer;            //    //Put buffers for this epi back on the free queue    //    aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);        while (aBuffer !!= NULL) {        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);		gFreeReadBuffersCounter++;        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    }    epi->bytesPendingToRead = 0;}////	Send the Bytes (Really fast, we hope)//static SInt32 SendData(EPInfo* epi,char* buffer, UInt32 size){	OTResult res;	struct OTData *dataPtr;  	//	//	Make sure we record that we are starting a send so we don''t try to close	//	the endpoint before a T_MEMORYRELEASED event is returned.	//	OTAtomicAdd32(1, &epi->outstandingSends);		if (epi->socketType == UDPSocketType) {		TUnitData UDPDataOutBound;	    UDPDataOutBound.addr.maxlen  = sizeof(InetAddress);	    UDPDataOutBound.addr.len     = sizeof(InetAddress);	    UDPDataOutBound.addr.buf     = (UInt8*) &epi->remoteAddress;	    UDPDataOutBound.opt.maxlen   = 0;	    UDPDataOutBound.opt.len      = 0;	    UDPDataOutBound.opt.buf      = NULL;	    UDPDataOutBound.udata.maxlen = size;	    UDPDataOutBound.udata.len    = size;	    UDPDataOutBound.udata.buf    = (UInt8*)buffer;	            res =  OTSndUData(epi->erf,&UDPDataOutBound);         if (res == kOTNoError ) return (SInt32) size;                // Other Errors could be kOTFlowErr or kOTBadDataErr	}	else { //TCP Send    	//    	//	In OT 1.1.2 and previous versions, there is a bug with AckSends    	//	which occurs when the same buffer is sent more than once.   In an attempt    	//	to go fast and not allocate memory, TCP may write an IP and TCP header    	//	into the data buffer which is sent.   If the buffer is sent more than once    	//	without being refreshed, the data may be corrupted.   To work around this,    	//	send the data via an OTData structure, using the gather-write mechanism.    	//	The problem does not occur in this code path, and this will not hinder performance.    	//	The problem will be fixed in the next Open Transport release following 1.1.2.    	//    	//  Note the MAC OS 8.1 docs alude to a bug before 1.3 where acksends    	//  cause problems if a disconnect flows just right. Unsure if this    	//  will be an issue    	//    	    	if (gOTVersion < kOTVersion113) {#if TARGET_API_MAC_CARBON    		dataPtr = OTAllocMemInContext(sizeof(OTData), gClientContext);#else    		dataPtr = OTAllocMem(sizeof(OTData));#endif    		if (dataPtr == NULL) { //Death lurks I''m sure    		    OTAtomicAdd32(-1, &epi->outstandingSends);                OTFreeMem(buffer);                return 0;            }    		dataPtr->fNext = NULL;    		dataPtr->fData = buffer;    		dataPtr->fLen  = size;    		res = OTSnd(epi->erf, dataPtr, kNetbufDataIsOTData, 0);    		    		//Note in the notification routine we cleanup the allocated dataPtr AND buffer.    	}    	else    	{    		res = OTSnd(epi->erf, buffer, size, 0);    		    		//JMM how to handle kENOMEMErr no memory right now error    		//Book says to back off and wait but must do a timer or something    		//Right now we''ll fail the primitive higher up since the error code is bad    	}    }	if (res == size) return (SInt32) size;	if (res >= 0) {		//		//	Implied kOTFlowErr since not all data was accepted.		//  But maybe we aren''t blocked yet so keep sending		//		return res;	} else	{	// res < 0	 		OTAtomicAdd32(-1, &epi->outstandingSends);        OTFreeMem(buffer);        	    if ((epi->socketType !!= UDPSocketType) && (gOTVersion < kOTVersion113) )	       	OTFreeMem(dataPtr); 	   		if (res == kOTFlowErr) {		    //		    // Flow control back off and wait for T_GODATA		    //        	OTAtomicSetBit(&epi->stateFlags, kSendIsBlocked);			return 0;		}				if (res == kOTLookErr) {			res = OTLook(epi->erf);			if (res == T_ORDREL || res == T_GODATA || res == T_DISCONNECT)			{				//	Wait to get the T_ORDREL at the notifier and handle it there.				//	Then we will resume sending.				//  Same applies for other events				//                //JMM test?                	OTAtomicSetBit(&epi->stateFlags, kSendIsBlocked);				return 0;			} else 			    	return res; 		} else 		    return res;		}}////Set the options//int sqSocketSetOptionsoptionNameStartoptionNameSizeoptionValueStartoptionValueSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int optionValueT, int optionValueSize, int *result)	{    EPInfo*     epi;    OTResult    error;    char        optionName[80],optionValue[80];    SInt32      anInteger;    	*result = 0;	if (!!SocketValid(s)) return -1;    epi = (EPInfo *) s->privateSocketPtr;	OTMemcpy(optionName,(char *) optionNameT,optionNameSize);	optionName[optionNameSize] = 0x00;	    OTMemcpy(optionValue,(char *) optionValueT,optionValueSize);    optionValue[optionValueSize] = 0x00;    CopyCStringToPascal(optionValue,(unsigned char *) optionValue);    StringToNum((ConstStr255Param) optionValue,&anInteger);       	   error = lookupOptionName(epi, false, (char *) &optionName, anInteger,(long *) result);   return error;}////Get the options//int sqSocketGetOptionsoptionNameStartoptionNameSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int *result)	{    EPInfo*     epi;    OTResult    error;    char        optionName[80];   	*result = 0;	if (!!SocketValid(s)) return -1;    epi = (EPInfo *) s->privateSocketPtr;	OTMemcpy(optionName,(char *) optionNameT,optionNameSize);  //NEED to fiddle with error number JMM to say readonly notvalid etc.	optionName[optionNameSize] = 0x00;	     	   error = lookupOptionName(epi, true, (char *) &optionName, NULL,(long *)  result);   return error;}// A Number of routines to set/get options, first figureout the flags, then call the routine// To set or get the options. static SInt32	lookupOptionName(EPInfo *epi, Boolean trueIfGet, char *aString, UInt32 value, SInt32 *result) {	if (strcmp("TCP_MAXSEG",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_MAXSEG,value,result);};	if (strcmp("TCP_NODELAY",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_NODELAY,value,result);};	if (strcmp("TCP_ABORT_THRESHOLD",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_ABORT_THRESHOLD,value,result);};	if (strcmp("TCP_CONN_NOTIFY_THRESHOLD",aString)==0) {return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_CONN_NOTIFY_THRESHOLD,value,result);};	if (strcmp("TCP_CONN_ABORT_THRESHOLD",aString)==0) 	{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_CONN_ABORT_THRESHOLD,value,result);};	if (strcmp("TCP_NOTIFY_THRESHOLD",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_NOTIFY_THRESHOLD,value,result);};	if (strcmp("TCP_URGENT_PTR_TYPE",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_URGENT_PTR_TYPE,value,result);};	if (strcmp("UDP_CHECKSUM",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_UDP,UDP_CHECKSUM,value,result);};	if (strcmp("SO_DEBUG",aString)==0) 			    	{return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_DEBUG,value,result);};	if (strcmp("SO_REUSEADDR",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_REUSEADDR,value,result);;};	if (strcmp("SO_REUSEPORT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_REUSEADDR,value,result);};	if (strcmp("SO_DONTROUTE",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_DONTROUTE,value,result);};	if (strcmp("SO_BROADCAST",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_BROADCAST,value,result);};	if (strcmp("SO_SNDBUF",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_SNDBUF,value,result);};	if (strcmp("SO_RCVBUF",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_RCVBUF,value,result);};	if (strcmp("SO_KEEPALIVE",aString)==0) 			   {return SetKeepAliveOption(epi,trueIfGet,INET_TCP,TCP_KEEPALIVE,value,result);};	if (strcmp("SO_OOBINLINE",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_OOBINLINE,value,result);};	if (strcmp("SO_PRIORITY",aString)==0) 			     {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_TOS,value,result);};	if (strcmp("SO_LINGER",aString)==0) 			      {return SetLingerOption(epi,trueIfGet,XTI_GENERIC,XTI_LINGER,value,result);};	if (strcmp("SO_RCVLOWAT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_RCVLOWAT,value,result);};	if (strcmp("SO_SNDLOWAT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_SNDLOWAT,value,result);};			if (strcmp("IP_OPTIONS",aString)==0) 			    { }; //JMM What to do here?		if (strcmp("IP_TTL",aString)==0) 			         {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_TTL,value,result);};		if (strcmp("IP_HDRINCL",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_HDRINCL,value,result);}; //NOT SUPPORT FOR IP		if (strcmp("IP_RCVOPTS",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVOPTS,value,result);};		if (strcmp("IP_RCVDSTADDR",aString)==0) 			{return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVDSTADDR,value,result);};		if (strcmp("IP_MULTICAST_IF",aString)==0) 			{return SetFourByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_IF,value,result);};		if (strcmp("IP_MULTICAST_TTL",aString)==0) 			 {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_TTL,value,result);};		if (strcmp("IP_MULTICAST_LOOP",aString)==0) 	     {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_LOOP,value,result);};	/*	if (strcmp("IP_ADD_MEMBERSHIP",aString)==0) 	    { return SetJMMByteOption(epi,trueIfGet,INET_IP,IP_ADD_MEMBERSHIP,value,result);};		if (strcmp("IP_DROP_MEMBERSHIP",aString)==0) 	    { return SetJMMByteOption(epi,trueIfGet,INET_IP,IP_DROP_MEMBERSHIP,value,result);};		if (strcmp("IP_BROADCAST_IF",aString)==0) 	        {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_BROADCAST_IF,value,result);};		if (strcmp("IP_RCVIFADDR",aString)==0) 	            {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVIFADDR,value,result);};	*/    *result = 0;    return -1;}static OTResult SetFourByteOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   UInt8    optBuffer[kOTFourByteOptionSize];   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;      /* Set up the option buffer to specify the option and value to set. */   option->len  = kOTFourByteOptionSize;   option->level= level;   option->name = name;   option->status = 0;   option->value[0] = value;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(optBuffer);   request.opt.maxlen=sizeof(optBuffer);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(optBuffer);      if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}								    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = option->value[0];   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }                return (err);}static OTResult SetOneByteOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   UInt8    optBuffer[kOTFourByteOptionSize];   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;      /* Set up the option buffer to specify the option and value to set. */   option->len  = kOTOneByteOptionSize;   option->level= level;   option->name = name;   option->status = 0;   *(unsigned char *)option->value = value;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= kOTOneByteOptionSize;   request.opt.maxlen=sizeof(optBuffer);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(optBuffer);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = (UInt32) (*(unsigned char *)option->value);   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}static OTResult SetKeepAliveOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   TKeepAliveOpt  optBuffer;   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;         if (value == 0)       optBuffer.tcpKeepAliveOn = T_NO;   else        optBuffer.tcpKeepAliveOn = T_YES;           optBuffer.tcpKeepAliveTimer = value;				   /* Set up the option buffer to specify the option and value to set. */   option->len  = sizeof(TKeepAliveOpt);   option->level= level;   option->name = name;   option->status = 0;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(TKeepAliveOpt);   request.opt.maxlen=sizeof(TKeepAliveOpt);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(TKeepAliveOpt);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = optBuffer.tcpKeepAliveTimer;   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}		    static OTResult SetLingerOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   TLingerOpt  optBuffer;   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;         if (value == 0)       optBuffer.tcpLingerOn = T_NO;   else        optBuffer.tcpLingerOn = T_YES;           optBuffer.tcpLingerTimer = value;				   /* Set up the option buffer to specify the option and value to set. */   option->len  = sizeof(TKeepAliveOpt);   option->level= level;   option->name = name;   option->status = 0;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(TKeepAliveOpt);   request.opt.maxlen=sizeof(TKeepAliveOpt);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(TKeepAliveOpt);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = optBuffer.tcpLingerTimer;   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}////	Notifier:////	Most of the interesting networking code in this program for the resolver resides inside //	this notifier.   In order to run asynchronously and as fast as possible,//	things are done inside the notifier whenever possible.  Since almost//	everything is done inside the notifier, there was little need for specical//	synchronization code.////	Note: The only events which are expected from the DNR are T_DNRSTRINGTOADDRCOMPLETE,//	T_DNRADDRTONAMECOMPLETE, and of close sleep/reconfigure notifications.////static pascal void DNSNotifier(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	JMMLogMessageAndNumber("\p DNS Event  ",event);	JMMLogMessageAndNumber("\p DNS Result ",result);	JMMLogMessageAndNumber("\p Id ",epi->semaIndex);		//	//	Once the program is shutting down, most events would be uninteresting.	//	if (gProgramState !!= kProgramRunning)			return;			//	//	Within the notifier, all action is based on the event code.	//	In this notifier, fatal errors all break out of the switch to the bottom.	//	As long as everything goes as expected, the case returns rather than breaks.	//	switch (event)	{		//		//	T_DNRSTRINGTOADDRCOMPLETE:		//		//	This event occurs when the DNR has finished an attempt to translate		//	the server''s name into an IP address we can use to connect to.		//		case T_DNRSTRINGTOADDRCOMPLETE:		{			gDNSResolverError = result;			if (result !!= kOTNoError) {				gDNSResolverStatus = RESOLVER_ERROR;    			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);				return;			}			gDNSAddr = gDNSHostInfo.addrs[0];			gDNSResolverStatus = RESOLVER_SUCCESS;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			return;		}				//		//	T_DNRADDRTONAMECOMPLETE:		//		//	This event occurs when the DNR has finished an attempt to translate		//	the  an IP address into a server name.		//		case T_DNRADDRTONAMECOMPLETE:		{			gDNSResolverError = result;			if (result !!= kOTNoError) {				gDNSResolverStatus = RESOLVER_ERROR;    			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);				return;			}			gDNSResolverStatus = RESOLVER_SUCCESS;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			return;		}									//		//	kOTProviderWillClose:		//		//	This event occurs when the user changes TCP/IP in the control panel		//		case kOTProviderWillClose:		case kOTProviderIsClosed:		{			gDNSResolverError = kOTProviderWillClose;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			ResolverTerminate(); 			gDNSResolverStatus = RESOLVER_SUCCESS; //Cheat!! Keep Squeak happy later we fix the resolver EP.			return;		}				//		//	default:		//		//	There are events which we don''t handle, but we don''t expect to see		//	any of them.  In the production version of the program, we ignore the event and try to keep running.		//		default:		{			return;		}	}}////	Notifier for socket: Please note we have another notifier for sockets that do multiple listens//  And a different notifier for UDP sockets, however the intesting thing is that we can call/// This routine from othe other as a simple form of inheritence.////	Most of the interesting networking code in this program for socket support resides inside //	this notifier.   In order to run asynchronously and as fast as possible,//	things are done inside the notifier whenever possible.  Since almost//	everything is done inside the notifier, there was little need for specical//	synchronization code.////	IMPORTANT NOTE:  Normal events defined by XTI (T_LISTEN, T_CONNECT, etc)//	and OT completion events (T_OPENCOMPLETE, T_BINDCOMPLETE, etc.) are not//	reentrant.  That is, whenever our notifier is invoked with such an event,//	the notifier will not be called again by OT for another normal or completion//	event until we have returned out of the notifier - even if we make OT calls//	from inside the notifier.   This is a useful synchronization tool.//	However, there are two kinds of events which will cause the notifier to //	be reentered.   One is T_MEMORYRELEASED, which always happens instantly.//	The other are state change events like kOTProviderWillClose.//static pascal void NotifierSocket(void* context, OTEventCode event, OTResult result, void* cookie){	OSStatus err;	OTResult epState;	EPInfo* epi = (EPInfo*) context;		JMMLogMessageAndNumber("\p Event  ",event);	JMMLogMessageAndNumber("\p Result ",result);	JMMLogMessageAndNumber("\p Id ",epi->semaIndex);	//	//	Once the program is shutting down, most events would be uninteresting.	//	However, we still need T_OPENCOMPLETE and T_MEMORYRELEASED events since	//	we can''t call CloseOpenTransport until all OTAsyncOpenEndpoints and	//	OTSends with AckSends have completed.   So those specific events	//	are still accepted.	//	if (gProgramState !!= kProgramRunning) {		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED)) {			return;		}	}			//	//	Within the notifier, all action is based on the event code.	//	In this notifier, fatal errors all break out of the switch to the bottom.	//	As long as everything goes as expected, the case returns rather than breaks.	//	switch (event)	{		//		//	kStreamIoctlEvent:		//		//	This event is returned when an I_FLUSH ioctl has completed.		//	The flush was done in an attempt to get back all T_MEMORYRELEASED events		//	for outstanding OTSnd() calls with Ack Sends.   For good measure, we		//	send a disconnect now.   Errors are ignored at this point since it is		//	possible that the connection will already be gone, etc.		//		case kStreamIoctlEvent:		{			if (OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit) !!= 0) {			    OTAtomicClearBit(&epi->stateFlags2, kFlushDisconnectInProgressBit);				(void) OTSndDisconnect(epi->erf, NULL);			}			return;		}		//		//	T_ACCEPTCOMPLETE:		//		//	This event is received by the listener endpoint only when we open a port with a listen.   		//	The acceptor endpoint will get a T_PASSCON event instead.		//		case T_ACCEPTCOMPLETE:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {				makeEPUnconnected(epi);        		return;            }            makeEPConnected(epi);			return;		}		//		//	T_BINDCOMPLETE:		//		//	This event is returned when an endpoint has been bound to a wildcard addr.		//  Bind happens when we open a connection to a remote location.		//	No errors are expected.   		//		case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			OTAtomicClearBit(&epi->stateFlags3, kWaitingForBind);			if (result !!= kOTNoError) {            	makeEPUnconnected(epi);				return;			}			if (epi->remoteAddress.fHost !!= 0) 			    DoConnect(epi,epi->remoteAddress.fHost, epi->remoteAddress.fPort);			return;		}				//		//	T_CONNECT:		//		//	This event is returned when a connection is established to the server.		//	The program must call OTRcvConnect() to get the conenction information		//	and clear the T_CONNECT event from the stream.  Since OTRcvConnect()		//	returns immediately (rather than via a completion event to the notifier)		//	we can use local stack structures for parameters.		//		case T_CONNECT:		{			TCall call;						            SetEPLastError(epi,result);			if (result !!= kOTNoError) {				makeEPUnconnected(epi);  				return;			}						// Address of endpoint that has connection			// This could be different from original request			// Due to hand off to different EP say you connect to 			// port 80, but you end up on 49160						call.addr.maxlen = sizeof(InetAddress);			call.addr.buf = (unsigned char*) &epi->remoteAddress;  			call.opt.maxlen = 0;			call.opt.buf = NULL;			call.udata.maxlen = 0;			call.udata.buf = NULL;						err = OTRcvConnect(epi->erf, &call);			SetEPLastError(epi,err);			if (err !!= kOTNoError) {			    if (err == kOTLookErr) {			        OSStatus	lookStatus;			        lookStatus = OTLook(epi->erf);			        if (lookStatus == T_DISCONNECT) {               			err = OTRcvDisconnect(epi->erf, NULL);        	    		if (err !!= kOTNoError) {        		    		if (err == kOTNoDisconnectErr) {                    			err = OTRcvConnect(epi->erf, &call);                    			SetEPLastError(epi,err);                       			makeEPUnconnected(epi);       		    		        return;       		    		    }			            } else {                			err = OTRcvConnect(epi->erf, &call);                			SetEPLastError(epi,err);                   			makeEPUnconnected(epi);   		    		        return;			            }			        }			        if (lookStatus == T_GODATA) { // HUH            			err = OTRcvConnect(epi->erf, &call);            			SetEPLastError(epi,err);               			makeEPConnected(epi);	    		        return;			        }			    }                //JMM book says may return kOTNoDataErr (no connecton yet) or a kOTLookErr with T_DISCONNECT                // BUT we had got T_GODATA WHY?                 				makeEPUnconnected(epi);				return;			}						makeEPConnected(epi);			return;				// Wait for a T_DATA...		}				//		//	T_LISTEN:		//		case T_LISTEN:		{			DoListenAccept(epi,epi);			return;		}		//		//	T_DATA:		//		//	The main rule for processing T_DATA''s is to remember that once you have		//	a T_DATA, you won''t get another one until you have read to a kOTNoDataErr.		//	The advanced rule is to remember that you could get another T_DATA		//	during an OTRcv() which will eventually return kOTNoDataErr, presenting		//	the application with a synchronization issue to be most careful about.		//			//	In this application, since an OTRcv() calls are made from inside the notifier,		//	this particular synchronization issue doesn''t become a problem.		//		case T_DATA:		{			if (!!OTAtomicTestBit(&epi->stateFlags2, kPassconNeeded)) {			    ReadData(epi,NULL,0);			    return;			 }			 else {    			//    			//	Here we work around a small OpenTransport bug.    			//	It turns out, since this program does almost everything from inside the notifier,    			//	that during a T_UNBINDCOMPLETE we can put an EPInfo back into the idle list.    			//	If that notification is interrupted by a T_LISTEN at the notifier, we could    			//	end up starting a new connection on the endpoint before OT unwinds the stack    			//	out of the code which delivered the T_UNBINDCOMPLETE.   OT has some specific    			//	code to protect against a T_DATA arriving before the T_PASSCON, but in this    			//	case it gets confused and the events arrive out of order.   If we try to    			//	do an OTRcv() at this point we will get a kOTStateChangeErr because the endpoint    			//	is still locked by the earlier OTAccept call until the T_PASSCON is delivered    			//	to us.   This is fairly benign and can be worked around easily.  What we do    			//	is note that the T_PASSCON hasn''t arrived yet and defer the call to ReadData()    			//	until it does.    			//    			if ( OTAtomicSetBit(&epi->stateFlags, kPassconBit) !!= 0 )    			{    			    ReadData(epi,NULL,0);    			    return;    			}    		}		}							//		//	T_PASSCON:		//		//	This event happens on the accepting endpoint, not the listening endpoint.		//	At this point the connection is fully established and we can begin the		//	process of downloading data.  Note that due to a problem in OT it is 		//	possible for a T_DATA to beat a T_PASSCON to the notifier.  When this		//	happens we note it in the T_DATA case and then start processing the 		//	data here.  		//		case T_PASSCON:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {               	OTAtomicSetBit(&epi->stateFlags, kPassconBit);   				makeEPUnconnected(epi);				return;			}			   			makeEPConnected(epi);                		    if ( OTAtomicSetBit(&epi->stateFlags, kPassconBit) !!= 0 ){				//				//	A T_DATA previously beat the T_PASSCON to our notifier.				//	Here we help OT out by having deferred data processing until now.				//			    ReadData(epi,NULL,0);			}			return;		}		//		// T_MEMORYRELEASED		// lower level has finished with buffer						case T_MEMORYRELEASED:		{		    if (cookie == nil) return;			OTAtomicAdd32(-1, &epi->outstandingSends);				    	if (epi->socketType == UDPSocketType) {		        OTFreeMem(cookie);	    	} else {//tcp		    	if (gOTVersion < kOTVersion113) {		    		struct OTData *data=cookie;		    		OTFreeMem(data->fData);		    		OTFreeMem(data);		    	} else {		        	OTFreeMem(cookie);		        }	        }	        			    return;		}					//		//	T_DISCONNECT:		//		//	An inbound T_DISCONNECT event usually indicates that the other side of the		//	connection did an abortive disconnect (as opposed to an orderly release).		//	It also can be generated by the transport provider on the system (e.g. tcp)		//	when it decides that a connection is no longer in existance.		//		//	We receive the disconnect, but this program ignores the associated reason (NULL param).		//	It is possible to get back a kOTNoDisconnectErr from the OTRcvDisconnect call.		//	This can happen when either (1) the disconnect on the stream is hidden by a 		//	higher priority message, or (2) something has flushed or reset the disconnect		//	event in the meantime.   This is not fatal, and the appropriate thing to do is		//	to pretend the T_DISCONNECT event never happened.   Any other error is unexpected		//	and needs to be reported so we can fix it.  Next, unbind the endpoint so we can		//	reuse it for a new inbound connection.		//			//	It is possible to get an error on the unbind due to a bug in OT 1.1.1 and earlier.		//	The best thing to do for that is close the endpoint and open a new one to replace it.		//	We do this back in the main thread so we don''t have to deal with synchronization problems.		//		case T_DISCONNECT:		{			epState = OTGetEndpointState(epi->erf);			err = OTRcvDisconnect(epi->erf, NULL);						if (epState == T_OUTCON) { //01Aug2000 fix for bad port, will get disconnect on outgoing connection                makeEPUnconnected(epi);			}			if (err !!= kOTNoError) {				if (err == kOTNoDisconnectErr) return;			    makeEPBroken(epi,err);				return;			}			                ///                //Both sides now have closed                 //                        OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);						err = OTUnbind(epi->erf);    	    TapAllInterestedSemaphores(epi);			if (err !!= kOTNoError) {			    makeEPBroken(epi,err);			}			return;		}				//		//	T_GODATA:		//		//	This event is received when flow control is lifted.   We are under flow control		//	whenever OTSnd() returns a kOTFlowErr or accepted less bytes than we attempted		//	to send.  		//		//	Note, it is also possible to get a T_GODATA without having invoke flow control.		//	Be safe and prepare for this. 		//		case T_GODATA:		{            if (OTAtomicClearBit(&epi->stateFlags, kSendIsBlocked)) { 	           if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData))  	              interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex);            };			return;		}				//		//	T_OPENCOMPLETE:		//		//	This event occurs when an OTAsyncOpenEndpoint() completes.   Note that this event,		//	just like any other async call made from outside the notifier, can occur during		//	the call to OTAsyncOpenEndpoint().  That is, in the main thread the program did		//	the OTAsyncOpenEndpoint(), and the notifier is invoked before control is returned		//	to the line of code following the call to OTAsyncOpenEndpoint().   This is one		//	event we need to keep track of even if we are shutting down the program since there		//	is no way to cancel outstanding OTAsyncOpenEndpoint() calls.		//		case T_OPENCOMPLETE:		{			TOptMgmt 			optReq;			TOption             opt;			OTAtomicClearBit(&epi->stateFlags, kOpenInProgressBit);			if (result == kOTNoError)				epi->erf = (EndpointRef) cookie;			else {				makeEPBrokenThenIdle(epi,result);				return;			}			if (gProgramState !!= kProgramRunning) return;										//			//	Set to blocking mode so we don''t have to deal with kEAGAIN errors.			//	Async/blocking is the best mode to write an OpenTransport application in.			//			err = OTSetBlocking(epi->erf);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);				return;			}						//			//	Set to AckSends so OT doesn''t slow down to copy data sent out.			//	However, this requires special care when closing endpoints, so don''t use			//	AckSends unless you are prepared for this.   Never, ever, close an endpoint			//	when a send has been done but the T_MEMORYRELEASED event hasn''t been returned yet.			//			err = OTAckSends(epi->erf);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);				return;			}						//			//	Option Management			//			//	Turn on ip_reuseaddr so we don''t have port conflicts in general.			//	We use local stack structures here since the memory for the 			//	option request structure is free upon return.   If we were to request			//	the option return value, we would have to use static memory for it.			//			optReq.flags			= T_NEGOTIATE;			optReq.opt.len			= kOTFourByteOptionSize;			optReq.opt.buf			= (unsigned char *) &opt;						opt.len					= sizeof(TOption);			opt.level				= INET_IP;			opt.name				= IP_REUSEADDR;			opt.status				= 0;			opt.value[0]			= 1;			            if (epi->socketType == TCPSocketType)                 OTAtomicSetBit(&epi->stateFlags3, kKeepAliveOptionNeeded);                			err = OTOptionManagement(epi->erf, &optReq, NULL);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);			}						//			//	Code path resumes at T_OPTMGMTCOMPLETE			//						return;		}				//		//	T_OPTMGMTCOMPLETE:		//		//	An OTOptionManagement() call has completed.  These are used on all		//	endpoints to set IP_REUSEADDR.   It is also used for all endpoints		//	other than the listener to set TCP_KEEPALIVE which helps recover		//	server resources if the other side crashes or is unreachable.		//		case T_OPTMGMTCOMPLETE:		{			TOptMgmt 			optReq;			if (result !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,result);				return;			}			            if (OTAtomicClearBit(&epi->stateFlags3, kKeepAliveOptionNeeded)) {                                TKeepAliveOpt		opt;				//				//	Turn on TCP_KEEPALIVE so we can recover from connections which have				//	gone away which we don''t know about.  				//				optReq.flags			= T_NEGOTIATE;				optReq.opt.len			= sizeof(TKeepAliveOpt);				optReq.opt.buf			= (unsigned char *) &opt;								opt.len					= sizeof(TKeepAliveOpt);				opt.level				= INET_TCP;				opt.name				= TCP_KEEPALIVE;				opt.status				= 0;				opt.tcpKeepAliveOn		= 1;				opt.tcpKeepAliveTimer	= kTCPKeepAliveInMinutes;									err = OTOptionManagement(epi->erf, &optReq, NULL);				if (err !!= kOTNoError) {    			    makeEPBrokenThenIdle(epi,result);                }                return;            }						            makeEPIdle(epi);  //This is where more EP enter the queue of available EPs.            			return;			// now wait 		}		//		//	T_ORDREL:		//		//	This event occurs when an orderly release has been received on the stream.		//		case T_ORDREL:		{			err = OTRcvOrderlyDisconnect(epi->erf);						if (err !!= kOTNoError) {				//				//	It is possible for several reasons for the T_ORDREL to have disappeared,				//	or be temporarily hidden, when we attempt the OTRcvOrderlyDisconnect().				//	The best thing to do when this happens is pretend that the event never				//	occured.   We will get another notification of T_ORDREL if the event				//	becomes unhidden later.  Any other form of error is unexpected and 				//	is reported back so we can correct it.				//				if (err == kOTNoReleaseErr)					return;				//Can get OTLookErr with T_DISCONNECT    		   makeEPBroken(epi,err);			}				if (OTAtomicTestBit(&epi->stateFlags, kThisEndClosed)) {                                ///                //Both sides now have closed                //                                OTAtomicSetBit(&epi->stateFlags, kUnConnected);			    	        OTAtomicClearBit(&epi->stateFlags, kConnected);                OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			                OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);											epState = OTGetEndpointState(epi->erf);				if (epState !!= T_IDLE) {            	    TapAllInterestedSemaphores(epi);				    return;				}				err = OTUnbind(epi->erf);        	    TapAllInterestedSemaphores(epi);				if (err !!= kOTNoError) {				    makeEPBroken(epi,err);				}				    		    return;            } else {    			OTAtomicSetBit(&epi->stateFlags, kOtherEndClosed);			}						//			//	Sometimes our data sends get stopped with a kOTLookErr			//	because of a T_ORDREL from the other side (which doesn''t close			//	the connection, it just means they are done sending data).			//	If so, we still end up in the notifier with the T_ORDREL event,			//	but we won''t resume sending data unless we explictly check			//	here whether or not we need to do so.			//             //JMM Test this?             if (OTAtomicClearBit(&epi->stateFlags, kSendIsBlocked)) {  		    	if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData))                	interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex);            };			return;		}				//		//	T_UNBINDCOMPLETE:		//		//	This event occurs on completion of an OTUnbind().		//	The endpoint is ready for reuse on a new inbound connection.		//	Note that the OTLIFO structure has atomic queue and dequeue,		//	which can be helpful for synchronization protection.  		//		case T_UNBINDCOMPLETE:		{			if (result !!= kOTNoError) {				//				//	Unbind errors can occur as a result of a bug in OT 1.1.1 and earlier				//	versions.   The best recovery is to put the endpoint in the broken				//	list for recycling with a clean, new endpoint.				//  Since we only support 1.1.2 we don''t expect to run this code.				//			    makeEPBroken(epi,result);				return;			}			return;		}						//		//	T_DISCONNECTCOMPLETE:		//		//	This event occurs on completion of an OTSndDisconnect().		//	Called when we abort a socket		//		case T_DISCONNECTCOMPLETE: {			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) {			    makeEPBroken(epi,err);			}			purgeReadBuffers(epi);		            TapAllInterestedSemaphores(epi); 			if (OTAtomicTestBit(&epi->stateFlags2, kMakeEPIdle)) { //Make EP idle if marked as such only happens via destroy. 			    makeEPIdle(epi);			}			epi->stateFlags = 0;			epi->stateFlags2 = 0;			epi->stateFlags3 = 0;            SetEPLastError(epi,result);        	OTAtomicSetBit(&epi->stateFlags, kUnConnected);			return;		}				//		//Sleep sleep sleep all end points get trashed.		//		case kOTProviderWillClose: // reconfig stack disconnect and close		{		    makeEPBroken(epi,-12345678);            if(OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit)) return;            OTSetSynchronous(epi->erf);			        // set endpoint to sync	        	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )        		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);            OTSndDisconnect(epi->erf, NULL);            OTUnbind(epi->erf);            OTCloseProvider(epi->erf);            OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);			            OTAtomicSetBit(&epi->stateFlags3, kSleepKilledMe);            TapAllInterestedSemaphores(epi); 		    return;		}		case kOTProviderIsClosed: //Sleep lurks		{		    makeEPBroken(epi,-12345678);            OTSetSynchronous(epi->erf);			        // set endpoint to sync	        	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )        		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);            OTCloseProvider(epi->erf);            OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);			            OTAtomicSetBit(&epi->stateFlags3, kSleepKilledMe);            TapAllInterestedSemaphores(epi); 			return;		}		//		//	default:		//		//	There are events which we don''t handle, but we don''t expect to see		//	any of them.   When running in debugging mode while developing a program,		//	we exit with an informational alert.   Later, in the production version		//	of the program, we ignore the event and try to keep running.		//		default:		{			return;		}	}}////	Notifier for listen socket://static pascal void NotifierSocketListener(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	if (gProgramState !!= kProgramRunning)	{		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED))		{			return;		}	}	JMMLogMessageAndNumber("\p Listener Event  ",event);	JMMLogMessageAndNumber("\p Listener Result ",result);	JMMLogMessageAndNumber("\p Listener Id ",epi->semaIndex);		switch (event)	{		//		//	T_BINDCOMPLETE:		//		//	We only bind the listener endpoint, and bind failure is a fatal error.  		//	Acceptor endpoints are bound within the OTAccept() call when they get a connection.		//		case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			OTAtomicClearBit(&epi->stateFlags3, kWaitingForBind);			if (result !!= kOTNoError)   				makeEPUnconnected(epi);      			return;		}						//		//	T_LISTEN:		//		case T_LISTEN:		{            SetEPLastError(epi,result);   			makeEPConnected(epi);			return;		}		//		//	T_ACCEPTCOMPLETE:		//		//	This event is received by the listener endpoint only.   		//	The acceptor endpoint will get a T_PASSCON event instead.		//		case T_ACCEPTCOMPLETE:		{            SetEPLastError(epi,result);			return;		}				//		//	default:		//		//	There are events which we don''t handle, pass them onwards		//		default:		{            NotifierSocket(context,  event,  result, cookie);			return;		}	}}////	Notifier for UDP listen socket://static pascal void NotifierSocketUDP(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	OSStatus err;	JMMLogMessageAndNumber("\p DNS Event  ",event);	JMMLogMessageAndNumber("\p DNS Result ",result);	JMMLogMessageAndNumber("\p Id ",epi->semaIndex);	if (gProgramState !!= kProgramRunning) {		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED)) {			return;		}	}			switch (event)	{		//Some sort of UDP send error, too late to tell anyone?		//		case T_UDERR: {      		TUDErr 		uderr;		    InetAddress errorAddress;                        uderr.addr.maxlen   = sizeof(InetAddress);            uderr.addr.len      = sizeof(InetAddress);            uderr.addr.buf      = (UInt8 *) &errorAddress;            uderr.opt.maxlen    = 0;            uderr.opt.len       = 0;            uderr.opt.buf       = NULL;   		    err =  OTRcvUDErr(epi->erf, &uderr);            if (err !!= kOTNoError)   				makeEPBroken(epi,err);			            SetEPLastError(epi,uderr.error);		    return;		}				//		//	T_DATA:		//		//  Got milk?		//				case T_DATA: {			ReadData(epi,NULL,0);		    return;		}				//		//	T_BINDCOMPLETE:		//		//	This event is returned when an endpoint has been bound.		//	No errors are expected.   		//				case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			OTAtomicClearBit(&epi->stateFlags3, kWaitingForBind);			if (result !!= kOTNoError) {   				makeEPUnconnected(epi);				return;			}   			makeEPConnected(epi);			return;		}		//		//	default:		//		//	There are events which we don''t handle, pass them onwards to the regular notifier		//				default:		{            NotifierSocket(context,  event,  result, cookie);			return;		}    }}short	        gJMMFile=0;OTTimeStamp 	JMMStartTimeStamp;OTLIFO			JMMLogBufferLIFO;    	//  Buffers that are free to read intoOTLIFO*			JMMLogBufferBuffers			= &JMMLogBufferLIFO; void JMMWriteLog() {	OSErr			error;	OTLink* 	    list = OTReverseList(OTLIFOStealList(JMMLogBufferBuffers));	OTLink*		    link;	ReadBuffer      *aBuffer;	long           dummySize;	char			CH=0x0D;	if (true) return;		error = HCreate(0,0,"\pJMMFOOBAR.txt",''TEXT'',''TEXT'');	error = HOpenDF(0,0,"\pJMMFOOBAR.txt",fsRdWrPerm,&gJMMFile);	error = SetFPos(gJMMFile,fsFromLEOF,0);	while ( (link = list) !!= NULL ) {		list = link->fNext;    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);    	error = FSWrite(gJMMFile,(long *)&aBuffer->readBufferSize,aBuffer->readBufferData);    	dummySize = 1;    	error = FSWrite(gJMMFile,&dummySize,&CH);	}	error = FSClose(gJMMFile);		while ( (link = list) !!= NULL ) {		list = link->fNext;    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);        OTFreeMem(aBuffer->readBufferData);        OTFreeMem(aBuffer); 	}	}void JMMLogMessage(Str255 input) {	Str255 			timeString;	long 			timeStringLength,inputLength;	UInt32			duration;	ReadBuffer      *readBufferObject;		if (true) return;		if (gJMMFile == 0) {		gJMMFile = 1;		OTGetTimeStamp(&JMMStartTimeStamp);		JMMLogBufferBuffers->fHead 		= NULL;	}		duration = OTElapsedMilliseconds(&JMMStartTimeStamp);	NumToString(duration,timeString);	timeStringLength = (unsigned char) timeString[0];	inputLength = (unsigned char) input[0];	#if TARGET_API_MAC_CARBON	readBufferObject = OTAllocMemInContext(sizeof(ReadBuffer), gClientContext);#else	readBufferObject = OTAllocMem(sizeof(ReadBuffer));#endif	if (readBufferObject == NULL) return;	OTMemzero(readBufferObject,sizeof(ReadBuffer));	#if TARGET_API_MAC_CARBON	readBufferObject->readBufferData = OTAllocMemInContext(60, gClientContext);#else	readBufferObject->readBufferData = OTAllocMem(60);#endif	if (readBufferObject->readBufferData == NULL) {	    OTFreeMem(readBufferObject);	    return;	}		OTMemcpy(readBufferObject->readBufferData,timeString+1,timeStringLength);	OTMemcpy(readBufferObject->readBufferData+timeStringLength,input+1,inputLength);	readBufferObject->readBufferSize= timeStringLength+inputLength;    OTLIFOEnqueue(JMMLogBufferBuffers, &readBufferObject->fNext);	}void JMMLogMessageAndNumber(Str255 msg,long number) {	Str255 buffer,numberString;	long msgLength,numberLength;		if (true) return;		NumToString(number,numberString);	numberLength = (unsigned char) numberString[0];	msgLength = (unsigned char) msg[0];		OTMemcpy(buffer+1,msg+1,msgLength);	OTMemcpy(buffer+1+msgLength,numberString+1,numberLength);	buffer[0] = (unsigned char) msgLength+numberLength;	JMMLogMessage(buffer);}/*The Open Transport TCP/IP software modules provide a RawIP interface to the IP protocolhostname of '''' lookup fails This is OK? Same on linux and old mac versionJMM look at tlook page, not sure if we have completely understood itJMM is it legal to send a zero byte buffer need case for this?/* According to the XTI spec ("Section 4.6 Events and TLOOK Error indication"), the SndOrderlyDisconnect and RcvOrderlyDisconnect calls can fail because of a pending T_DISCONNECT event. This is XTI trying to tell you that the a connection on that endpoint broke. This can happen in this asynchronous wacky world of networks and your program will have to call a RcvDisconnect to acknowledge that your endpoint dropped.You might want to check out the OTI spec, which, although it is not always written in the most lucid fashion, does contain valuable information for those involved in OpenTransport programming.Further Information:Title: X/OPEN TRANSPORT INTERFACE (XTI) VER 2 [ 1.0 ed]Author: X/OPEN ISBN #: 0133534596A Prior to Open Transport 1.3, there was no supported way of calling Open Transport from CFM-68K code. With the introduction of Open Transport 1.3, it is now possible to call the Open Transport client interface from CFM-68K code. The Open Transport 1.3 SDK includes stub libraries and a document, "Open Tpt CFM68K Dev. Note", which explains Open Transport''s support for CFM-68K. which is supporte for syste 7.x but you can''t install!! No standalone installer exists. Coping the OT files kinda works*/#else/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "SocketPlugin.h"/* initialize/shutdown */int socketInit() { return true; }int socketShutdown() { sqNetworkShutdown(); }/* End of adjustments for pluginized VM */#include <Events.h>#include <Devices.h>#include <Processes.h>#include <Traps.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "MacTCP.h"#include "AddressXLation.h"/*** Socket Type Constants ***/#define TCPSocketType 		0#define UDPSocketType 		1#define ListenerQueueType	2/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3/* Resolver State */typedef struct {	int				semaIndex;	int				status;	int				error;	int				localAddress;	int				remoteAddress;	struct hostInfo	hostInfo;} ResolverStatusRec, *ResolverStatusPtr;/*** TCP Socket Status Constants ***/#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4/*** TCP Socket State ***/#define SendBufferSize	(8 * 1024)#define RecvBufferSize	(8 * 1024)typedef struct {	TCPiopb		tcpPB;				/* TCP parameter block for open/send (must be first) */	TCPiopb		closePB;			/* TCP parameter block for close */	StreamPtr	tcpStream;			/* TCP stream */	void *		next;				/* next socket in a linked list of open sockets */	int			semaIndex;	int			connectStatus;	void *		nextInListenerQueue; /* next socket in a ListenderQueue waiting socket list */	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;//xxx	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} TCPSockRec, *TCPSockPtr;typedef struct {	TCPiopb		tcpPB;	TCPSockPtr	mySocket;	struct wdsEntry wds[2];	char		data[SendBufferSize];} TCPSendBuf, *TCPSendBufPtr;#define SendBufCount 8TCPSendBuf sendBufPool[SendBufCount];int nextSendBuf = 0;typedef struct {	int			localAddress;	int			localPort;	int			closed;				/* set true by close or abort */	int			semaIndex;			/* semaphore of the server socket */	int			desiredQueueLength;	TCPSockPtr	waitingSockets;} ListenerQueueRec, *ListenerQueuePtr;/*** UDP Socket Status Constants ***/#define UnknowRemoteAddrAndPort	0#define Ready					1/*** UDP Socket State ***/typedef struct {	void *		next;				/* next socket in a linked list of open sockets */	int			remoteAddress;	int			remotePort;	int			semaIndex;	int			connectStatus;	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} UDPSockRec, *UDPSockPtr;/*** Variables ***/extern struct VirtualMachine *interpreterProxy;short				macTCPRefNum = 0;int					mtuSize = 1024;TCPSockPtr 			openTCPSockets = nil;UDPSockPtr			openUDPSockets = nil;ResolverStatusRec 	resolver = {0, 0, 0, 0, 0, 0, 0};UniversalProcPtr	myExitHandlerProc = nil;UniversalProcPtr	oldExitHandlerProc = nil;ResultUPP			resolverDoneProc = nil;TCPIOCompletionUPP	tcpCloseDoneProc = nil;TCPIOCompletionUPP	tcpConnectDoneProc = nil;TCPNotifyUPP		tcpNotifyProc = nil;TCPIOCompletionUPP	tcpSendDoneProc = nil;UDPNotifyUPP		udpNotifyProc = nil;UDPIOCompletionUPP	udpSendDoneProc = nil;int					thisNetSession = 0;/*** Private TCP Socket Functions ***/void *		TCPSockCreate(void);void		TCPSockDestroy(TCPSockPtr s);void		TCPSockRemoveFromOpenList(TCPSockPtr s);int			TCPSockLocalAddress(TCPSockPtr s);int			TCPSockLocalPort(TCPSockPtr s);int			TCPSockRemoteAddress(TCPSockPtr s);int			TCPSockRemotePort(TCPSockPtr s);void		TCPSockConnectTo(TCPSockPtr s, int addr, int port);void		TCPSockListenOn(TCPSockPtr s, int port);void		TCPSockAbortConnection(TCPSockPtr s);void		TCPSockCloseConnection(TCPSockPtr s);int			TCPSockDataAvailable(TCPSockPtr s);int			TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize);int			TCPSockSendData(TCPSockPtr s, char *buf, int bufSize);/*** Private ListenerQueue Socket Functions ***/void		FillListenerQueue(ListenerQueuePtr listener);TCPSockPtr	FindConnectedSocket(ListenerQueuePtr listener);TCPSockPtr	FindZombieSocket(ListenerQueuePtr listener);void		RemoveSocketFromListenerQueue(TCPSockPtr sockToRemove, ListenerQueuePtr listener);ListenerQueuePtr ListenerQueueCreate(TCPSockPtr tcpSocket, int port, int backlogSize);void		ListenerQueueDestroy(ListenerQueuePtr listener);int			ListenerQueueStatus(ListenerQueuePtr listener);/*** Private UDP Socket Functions ***/void *		UDPSockCreate(void);void		UDPSockDestroy(UDPSockPtr s);void		UDPSockRemoveFromOpenList(UDPSockPtr s);int			UDPSockLocalAddress(UDPSockPtr s);int			UDPSockLocalPort(UDPSockPtr s);int			UDPSockRemoteAddress(UDPSockPtr s);int			UDPSockRemotePort(UDPSockPtr s);void		UDPSockConnectTo(UDPSockPtr s, int addr, int port);void		UDPSockListenOn(UDPSockPtr s, int port);int			UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize);int			UDPSockSendData(UDPSockPtr s, char *buf, int bufSize);/*** Other Private Functions ***/void		DestroyAllOpenSockets(void);void		InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr);void		InstallExitHandler(void);void		MyExitHandler(void);int			PortNumberValid(int port);pascal void	ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr);int			ResolverInitialize(int resolverSemaIndex);void		ResolverTerminate(void);int			SocketValid(SocketPtr s);void		TCPCloseCompletionRoutine(struct TCPiopb *s);void		TCPConnectCompletionRoutine(struct TCPiopb *s);pascal void	TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg);void		TCPSendCompletionRoutine(struct TCPiopb *s);/*** Network Functions ***/void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {  interpreterProxy->success(false);}int sqSockettoHostportSendDataBufCount(SocketPtr s, int address, int port, int buf, int bufSize) {  interpreterProxy->success(false);}int sqSocketGetOptionsoptionNameStartoptionNameSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int *result)	{  interpreterProxy->success(false);}void	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {  interpreterProxy->success(false);}int sqSocketReceiveUDPDataBufCountaddressportmoreFlag(SocketPtr s, int buf, int bufSize,  int *address,  int *port, int *moreFlag) {  interpreterProxy->success(false);}int sqSocketSetOptionsoptionNameStartoptionNameSizeoptionValueStartoptionValueSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int optionValueT, int optionValueSize, int *result)	{  interpreterProxy->success(false);}int sqNetworkInit(int resolverSemaIndex) {	/* initialize the network and return 0 if successful */	int localAddr;	UDPiopb paramBlock;	OSErr err = noErr;	if (thisNetSession !!= 0) return 0;  /* noop if network is already initialized */	/* open network driver */	macTCPRefNum = 0;	err = OpenDriver("\p.IPP", &macTCPRefNum);	if (err !!= noErr) {		return -1;	}	/* open resolver */	err = ResolverInitialize(resolverSemaIndex);	if (err !!= noErr) {		ResolverTerminate();		return -1;	}	/* get local address */	localAddr = sqResolverLocalAddress();	if (sqResolverError() !!= noErr) {		ResolverTerminate();		return -1;	}	/* compute MTU (maximum transfer unit) size */	memset(&paramBlock, 0, sizeof(paramBlock));	paramBlock.csCode = UDPMaxMTUSize;	paramBlock.csParam.mtu.remoteHost = localAddr;	paramBlock.ioCRefNum = macTCPRefNum;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err == noErr) {		mtuSize = paramBlock.csParam.mtu.mtuSize;	} else {		mtuSize = 1024;  /* guess */		ResolverTerminate();		return -1;	}	resolverDoneProc	= NewResultProc(ResolverCompletionRoutine);	tcpCloseDoneProc 	= NewTCPIOCompletionProc(TCPCloseCompletionRoutine);	tcpConnectDoneProc	= NewTCPIOCompletionProc(TCPConnectCompletionRoutine);	tcpNotifyProc		= NewTCPNotifyProc(TCPNotificationRoutine);	tcpSendDoneProc		= NewTCPIOCompletionProc(TCPSendCompletionRoutine);	InstallExitHandler();	/* Success!! Create a session ID that is unlikely to be	   repeated. Zero is never used for a valid session number.	*/	thisNetSession = clock() + time(NULL);	if (thisNetSession == 0) thisNetSession = 1;  /* don''t use 0 */	return 0;}void sqNetworkShutdown(void) {	/* shut down the network */	if (thisNetSession == 0) return;  /* noop if network is already shut down */	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	thisNetSession = 0;}/*** Squeak Generic Socket Functions ***/void sqSocketAbortConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockAbortConnection((TCPSockPtr) s->privateSocketPtr);		return;	}	if (s->socketType == ListenerQueueType) {		((ListenerQueuePtr) s->privateSocketPtr)->closed = true; /* set closed flag */		return;	}	success(false);}void sqSocketCloseConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockCloseConnection((TCPSockPtr) s->privateSocketPtr);		return;	}	if (s->socketType == ListenerQueueType) {		((ListenerQueuePtr) s->privateSocketPtr)->closed = true; /* set closed flag */		return;	}	success(false);}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->connectStatus;	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->connectStatus;	}	if (s->socketType == ListenerQueueType) {		return ListenerQueueStatus((ListenerQueuePtr) s->privateSocketPtr);	}	success(false);}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockConnectTo((TCPSockPtr) s->privateSocketPtr, addr, port);		return;	}	if (s->socketType == UDPSocketType) {		UDPSockConnectTo((UDPSockPtr) s->privateSocketPtr, addr, port);		return;	}	success(false);}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {	TCPSockPtr tcpSock = nil;	UDPSockPtr udpSock = nil;	/* reference args to suppress compiler warnings about unused variables */	s; netType; recvBufSize; sendBufSize;	s->sessionID = 0;	if (socketType == TCPSocketType) {		tcpSock = TCPSockCreate();		if (tcpSock == nil) {			success(false);		} else {			tcpSock->semaIndex = semaIndex;			tcpSock->next = openTCPSockets;			openTCPSockets = tcpSock;			s->sessionID = thisNetSession;			s->socketType = TCPSocketType;			s->privateSocketPtr = tcpSock;		}		return;	}	if (s->socketType == UDPSocketType) {		udpSock = UDPSockCreate();		if (udpSock == nil) {			success(false);		} else {			udpSock->semaIndex = semaIndex;			udpSock->next = openUDPSockets;			openUDPSockets = udpSock;			s->sessionID = thisNetSession;			s->socketType = UDPSocketType;			s->privateSocketPtr = udpSock;		}		return;	}	success(false);}void sqSocketDestroy(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockDestroy((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		UDPSockDestroy((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		ListenerQueueDestroy((ListenerQueuePtr) s->privateSocketPtr);	}	s->sessionID = 0;	s->socketType = -1;	s->privateSocketPtr = nil;}int sqSocketError(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->lastError;	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->lastError;	}	if (s->socketType == ListenerQueueType) {		return 0;  /* ListenerQueue''s themselves never get an error */	}}void sqSocketListenOnPort(SocketPtr s, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockListenOn((TCPSockPtr) s->privateSocketPtr, port);		return;	}	if (s->socketType == UDPSocketType) {		UDPSockListenOn((UDPSockPtr) s->privateSocketPtr, port);		return;	}	success(false);}int sqSocketLocalAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalAddress((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockLocalAddress((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		return ((ListenerQueuePtr) s->privateSocketPtr)->localAddress;	}	success(false);}int sqSocketLocalPort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalPort((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockLocalPort((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		return ((ListenerQueuePtr) s->privateSocketPtr)->localPort;	}	success(false);}int sqSocketReceiveDataAvailable(SocketPtr s) {	if (!!SocketValid(s)) return 0;	if (s->socketType == TCPSocketType) {		return TCPSockDataAvailable((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->dataAvailable;	}	success(false);}int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRecvData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	if (s->socketType == UDPSocketType) {		return UDPSockRecvData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	success(false);}int sqSocketRemoteAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemoteAddress((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockRemoteAddress((UDPSockPtr) s->privateSocketPtr);	}	success(false);}int sqSocketRemotePort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemotePort((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockRemotePort((UDPSockPtr) s->privateSocketPtr);	}	success(false);}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockSendData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	if (s->socketType == UDPSocketType) {		return UDPSockSendData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	success(false);}int sqSocketSendDone(SocketPtr s) {	if (!!SocketValid(s)) return 1;	if (s->socketType == TCPSocketType) {		return !!((TCPSockPtr) s->privateSocketPtr)->sendInProgress;	}	if (s->socketType == UDPSocketType) {		return !!((UDPSockPtr) s->privateSocketPtr)->sendInProgress;	}	success(false);}/*** Resolver Functions ***/void sqResolverAbort(void) {	int semaIndex;	/* abort the current request */	if (resolver.status == RESOLVER_BUSY) {		semaIndex = resolver.semaIndex;		ResolverTerminate();		ResolverInitialize(semaIndex);	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	/* copy the name found by the last address lookup into the given string */	memcpy(nameForAddress, resolver.hostInfo.cname, nameSize);}int sqResolverAddrLookupResultSize(void) {	return strlen(resolver.hostInfo.cname);}int sqResolverError(void) {	return resolver.error;}int sqResolverLocalAddress(void) {	struct GetAddrParamBlock paramBlock;	if (resolver.localAddress == 0) {		resolver.remoteAddress = 0;		memset(&paramBlock, 0, sizeof(struct GetAddrParamBlock));		paramBlock.ioResult = 1;		paramBlock.csCode = ipctlGetAddr;		paramBlock.ioCRefNum = macTCPRefNum;		PBControlSync((ParmBlkPtr) &paramBlock);		if (paramBlock.ioResult == noErr) {			resolver.status = RESOLVER_SUCCESS;			resolver.localAddress = paramBlock.ourAddress;			resolver.error = noErr;		} else {			resolver.status = RESOLVER_ERROR;			resolver.error = paramBlock.ioResult;		}	} else {		resolver.status = RESOLVER_SUCCESS;		resolver.error = noErr;	}	return resolver.localAddress;}int sqResolverNameLookupResult(void) {	/* return the result of the last successful lookup */	return resolver.remoteAddress;}void sqResolverStartAddrLookup(int address) {	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = AddrToName(address, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}void sqResolverStartNameLookup(char *hostName, int nameSize) {	char name[501];	int len; 	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	len = ((nameSize <= 500) ? nameSize : 500);	memcpy(name, hostName, len);	name[len] = ''\0'';	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = StrToAddr(name, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;		resolver.remoteAddress = resolver.hostInfo.addr[0];	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}int sqResolverStatus(void) {	return resolver.status;}/*** Private Resolver Functions ***/int ResolverInitialize(int resolverSemaIndex) {	if (resolver.status !!= RESOLVER_UNINITIALIZED) {		ResolverTerminate();	}	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;	resolver.error = OpenResolver(nil);	if (resolver.error !!= noErr) {		resolver.status = RESOLVER_ERROR;		return resolver.error;	}	resolver.semaIndex = resolverSemaIndex;	resolver.status = RESOLVER_SUCCESS;	return noErr;}static pascal void ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr) {	ResolverStatusPtr r = (ResolverStatusPtr) userDataPtr;	if ((r == null) || (r->status !!= RESOLVER_BUSY)) return;	/* completion routine */	if (r->hostInfo.rtnCode == noErr) {		r->status = RESOLVER_SUCCESS;		r->remoteAddress = hostInfoPtr->addr[0];	} else {		r->status = RESOLVER_ERROR;		r->error = hostInfoPtr->rtnCode;	}	signalSemaphoreWithIndex(r->semaIndex);}void ResolverTerminate(void) {	CloseResolver();	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;}/*** Squeak TCP Socket Listen/Accept Functions ***/ListenerQueuePtr ListenerQueueCreate(TCPSockPtr tcpSocket, int port, int backlogSize) {	ListenerQueuePtr listener;	/* allocate a new ListenerQueue */	listener = (ListenerQueuePtr) malloc(sizeof(ListenerQueueRec));	if (listener == nil) return nil;	/* initialize it */	listener->localAddress = TCPSockLocalAddress(tcpSocket);	listener->localPort = port;	listener->closed = false;	listener->semaIndex = tcpSocket->semaIndex;	listener->desiredQueueLength = (backlogSize < 1) ? 1 : backlogSize;	listener->waitingSockets = nil;	/* add the given socket to the new ListenerQueue */	tcpSocket->nextInListenerQueue = listener->waitingSockets;	listener->waitingSockets = tcpSocket;	TCPSockListenOn(tcpSocket, listener->localPort);	/* create additional waiting sockets in necessary to fill the ListenerQueue */	FillListenerQueue(listener);	return listener;}void ListenerQueueDestroy(ListenerQueuePtr listener) {	TCPSockPtr thisSock, nextSock;	/* destroy all sockets in this ListenerQueue''s waiting socket list */	thisSock = listener->waitingSockets;	while (thisSock !!= nil) {		nextSock = thisSock->nextInListenerQueue;		TCPSockDestroy(thisSock);		thisSock = nextSock;	}	/* clear a few fields, just in case of a dangling reference */	listener->closed = true;	listener->semaIndex = 0;	listener->waitingSockets = nil;	/* free the ListenerQueue */	free(listener);}int ListenerQueueStatus(ListenerQueuePtr listener) {	TCPSockPtr sock;	if (listener == nil) {		success(false);		return Unconnected;	}	if (listener->closed) return Unconnected;	/* check for zombie sockets; if there is one, clean up the queue */	if (FindZombieSocket(listener) !!= nil) {		FillListenerQueue(listener);  /* removes zombies and refills queue */	}	/* scan queue for a connected socket */	sock = FindConnectedSocket(listener);	return (sock == nil) ? WaitingForConnection : Connected;}void FillListenerQueue(ListenerQueuePtr listener) {	TCPSockPtr sock, newSock;	int count, socksToAdd;	/* remove from the queue and destroy any zombie sockets */	while ((sock = FindZombieSocket(listener)) !!= nil) {		RemoveSocketFromListenerQueue(sock, listener);		TCPSockDestroy(sock);	}	/* count the number of remaining sockets */	count = 0;	sock = listener->waitingSockets;	while (sock !!= nil) {		count++;		sock = sock->nextInListenerQueue;	}	/* create enough new sockets up to fill ListenerQueue to desired size */	socksToAdd = listener->desiredQueueLength - count;	while (socksToAdd > 0) {		newSock = TCPSockCreate();		if (newSock!!= nil) {			/* set semaphore of the new socket*/			newSock->semaIndex = listener->semaIndex;			/* record new socket in openTCPSockets */			newSock->next = openTCPSockets;			openTCPSockets = newSock;			/* add new socket to the listener queue and start it listening */			newSock->nextInListenerQueue = listener->waitingSockets;			listener->waitingSockets = newSock;			TCPSockListenOn(newSock, listener->localPort);		}		socksToAdd--;	}}TCPSockPtr FindConnectedSocket(ListenerQueuePtr listener) {  /* Return the first connected socket in the given ListenerQueue,     or nil if there isn''t one. */	TCPSockPtr sock;	sock = listener->waitingSockets;	while (sock !!= nil) {		if (sock->connectStatus == Connected) return sock;		sock = sock->nextInListenerQueue;	}	return nil;}TCPSockPtr FindZombieSocket(ListenerQueuePtr listener) {  /* Return the first socket in the given ListenerQueue that is not connected or     waiting for a connection (we call this a zombie), or nil if there isn''t one.     Zombies are created when a connection is made but broken again before an     accept has been done. Since a zombie are no longer waiting for a connection,     it takes the place of listening socket. If the queue became filled with zombies     no connections could get through. Thus, zombies must be eliminated. As the     saying goes: "the only good zombie is a dead zombie." */	TCPSockPtr sock;	sock = listener->waitingSockets;	while (sock !!= nil) {		if ((sock->connectStatus !!= WaitingForConnection) &&			(sock->connectStatus !!= Connected)) return sock;		sock = sock->nextInListenerQueue;	}	return nil;}void sqSocketAcceptFromRecvBytesSendBytesSemaID(  SocketPtr s, SocketPtr serverSocket,  int recvBufSize, int sendBufSize, int semaIndex) {  /* Accept a connection for the given server socket. The server socket must     have been turned into a listener queue via sqSocketListenOnPortBacklogSize().     If successful, s is initialized to newly connected socket using the     given paramenters, and a new listening socket will be created and added     to the ListenerQueue to maintain the desired queue length. Note that MacTCP     allows multiple sockets to be listening on the same port number and, indeed,     this is the only way to support the Unix socket notion of a socket backlog. */	ListenerQueuePtr listener;	TCPSockPtr connectedSock;	/* server socket must be a valid ListenerQueue */	if ((serverSocket == nil) ||		(serverSocket->sessionID !!= thisNetSession) ||		(serverSocket->socketType !!= ListenerQueueType) ||		(serverSocket->privateSocketPtr == nil)) {			success(false);			return;	}	/* result socket must be a new, unintialized socket */	if ((s == nil) ||		(s->sessionID !!= 0) ||		(s->socketType !!= 0) ||		(s->privateSocketPtr !!= nil)) {			success(false);			return;	}	/* look for a connected socket */	listener = (ListenerQueuePtr) serverSocket->privateSocketPtr;	connectedSock = FindConnectedSocket(listener);	if (connectedSock == nil) {		success(false);	} else {		/* remove connected socket from the listener queue */		RemoveSocketFromListenerQueue(connectedSock, listener);		/* fill in the result socket handle */		connectedSock->semaIndex = semaIndex;		s->sessionID = thisNetSession;		s->socketType = TCPSocketType;		s->privateSocketPtr = connectedSock;	}	/* ensure that the queue has the desired number of listenening sockets */	FillListenerQueue(listener);}void RemoveSocketFromListenerQueue(TCPSockPtr sockToRemove, ListenerQueuePtr listener) {	TCPSockPtr lastSock, thisSock;	if (sockToRemove == nil) return;	if (listener->waitingSockets == sockToRemove) {		listener->waitingSockets = sockToRemove->nextInListenerQueue;		sockToRemove->nextInListenerQueue = nil;		return;	}	lastSock = listener->waitingSockets;	thisSock = lastSock->nextInListenerQueue;	while (thisSock !!= nil) {		if (thisSock == sockToRemove) {			lastSock->nextInListenerQueue = sockToRemove->nextInListenerQueue;			sockToRemove->nextInListenerQueue = nil;			return;		}		lastSock = thisSock;		thisSock = lastSock->nextInListenerQueue;	}}void sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize) {	TCPSockPtr tcpSocket;	ListenerQueuePtr listener;	/* s must be an TCP socket that is initialized but unconnected */	if ((!!SocketValid(s)) || (s->socketType !!= TCPSocketType)) {		success(false);		return;	}	tcpSocket = (TCPSockPtr) s->privateSocketPtr;	if (tcpSocket->connectStatus !!= Unconnected) {		success(false);		return;	}	/* make sure the port number is in range */	if (!!PortNumberValid(port)) {;		success(false);		return;	}	/* create a new listener on the given with the given backlog size */	listener = ListenerQueueCreate((TCPSockPtr) s->privateSocketPtr, port, backlogSize);	if (listener == nil) {		success(false);		return;	}	/* mutate s into a listener socket: replace the original TCP socket in s with	   the new listener, and change the type of s to ListenerQueueType */	s->socketType = ListenerQueueType;	s->privateSocketPtr = listener;}/*** Private TCP Socket Functions ***/void * TCPSockCreate(void) {	TCPiopb paramBlock;	TCPSockPtr s = nil;	int minRcvBufSize, rcvBufSize;	OSErr err = noErr;	rcvBufSize = RecvBufferSize;	minRcvBufSize = (4 * mtuSize) + 1024;	if (rcvBufSize < minRcvBufSize) rcvBufSize = minRcvBufSize;	s = (TCPSockPtr) malloc(sizeof(TCPSockRec) + rcvBufSize);	if (s == nil) return nil;  /* allocation failed */	memset(s, 0, sizeof(TCPSockRec) + rcvBufSize);	InitTCPCmd(TCPCreate, nil, &paramBlock);	paramBlock.csParam.create.rcvBuff = s->rcvBuf;	paramBlock.csParam.create.rcvBuffLen = rcvBufSize;	paramBlock.csParam.create.notifyProc = tcpNotifyProc;	paramBlock.csParam.create.userDataPtr = (Ptr) s;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		free(s);		return nil;	}	s->tcpStream = paramBlock.tcpStream;	return s;}int TCPSockDataAvailable(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return false;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.amtUnreadData > 0;}void TCPSockDestroy(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return;  /* already destroyed */	}	InitTCPCmd(TCPRelease, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	TCPSockRemoveFromOpenList(s);	s->tcpStream = nil;	free(s);}int TCPSockLocalAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localHost;}int TCPSockLocalPort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localPort;}int TCPSockRemoteAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remoteHost;}int TCPSockRemotePort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remotePort;}void TCPSockRemoveFromOpenList(TCPSockPtr s) {	TCPSockPtr thisSock, nextSock, previousSock;	previousSock = nil;	for (thisSock = openTCPSockets; thisSock !!= nil; thisSock = nextSock) {		nextSock = thisSock->next;		if (thisSock == s) {			if (previousSock == nil) {				openTCPSockets = nextSock;			} else {				previousSock->next = nextSock;			}			break;		}		previousSock = thisSock;	}}void TCPSockConnectTo(TCPSockPtr s, int addr, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPActiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.remoteHost = addr;	s->tcpPB.csParam.open.remotePort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockListenOn(TCPSockPtr s, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPPassiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.localPort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockCloseConnection(TCPSockPtr s) {	/* Note: This operation uses a dedicated parameter block so that it	   can be invoked even in the previous send is not yet complete.	   It will eventually use a completion routine to delete the	   socket automatically. For now, this is the client''s responsibility.	*/	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPClose, s->tcpStream, &s->closePB);//	s->closePB.ioCompletion = tcpCloseDoneProc;	s->connectStatus = ThisEndClosed; // xxx remove when making this async	s->lastError = PBControlSync((ParmBlkPtr) &s->closePB);}void TCPSockAbortConnection(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPAbort, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	s->connectStatus = Unconnected;}int TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize) {	TCPiopb paramBlock;  /* use local parameter block since send may be using one in socket */	OSErr err = noErr;	int bytesRead;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	if (!!TCPSockDataAvailable(s)) return 0;  /* no data available */	InitTCPCmd(TCPRcv, s->tcpStream, &paramBlock);	paramBlock.csParam.receive.commandTimeoutValue = 1; /* finish in one second, data or not */	paramBlock.csParam.receive.rcvBuff = buf;	paramBlock.csParam.receive.rcvBuffLen = bufSize;	s->lastError = noErr;	err = PBControlSync((ParmBlkPtr) &paramBlock);  /* synchronous */	if (err == noErr) {		bytesRead = paramBlock.csParam.receive.rcvBuffLen;	} else {		/* if err == commandTimeout, no data was available */		bytesRead = 0;		if (!!((err == commandTimeout) || (err == connectionClosing))) {			s->lastError = err;		}	}	s->dataAvailable = (bytesRead !!= 0);  /* if we got data, there may be more */	return bytesRead;}int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize);int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	int sendCount;	struct wdsEntry wds[2];	buf;  /* xxx avoid compiler complaint about unreferenced vars */	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;//xxx	memcpy(s->sendBuf, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	wds[0].length = sendCount;//xxx		wds[0].ptr = s->sendBuf;	wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.send.wdsPtr = (Ptr) &wds;	s->tcpPB.csParam.send.pushFlag = true;	s->sendInProgress = true;	s->tcpPB.ioCompletion = tcpSendDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}int TCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	TCPSendBufPtr sendBuf;	int sendCount;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	sendBuf = &sendBufPool[nextSendBuf++];	if (nextSendBuf >= SendBufCount) nextSendBuf = 0;	sendBuf->mySocket = s;	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;	memcpy(sendBuf->data, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	sendBuf->wds[0].length = sendCount;	sendBuf->wds[0].ptr = sendBuf->data;	sendBuf->wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &sendBuf->tcpPB);	sendBuf->tcpPB.csParam.send.wdsPtr = (Ptr) &sendBuf->wds;	sendBuf->tcpPB.csParam.send.pushFlag = true;	sendBuf->tcpPB.ioCompletion = tcpSendDoneProc;	s->sendInProgress = true;	s->lastError = PBControlAsync((ParmBlkPtr) &sendBuf->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}/*** Private General Utilities ***/void DestroyAllOpenSockets(void) {	while (openTCPSockets !!= nil) {		TCPSockDestroy(openTCPSockets);  /* removes socket from the list */	}	while (openUDPSockets !!= nil) {		UDPSockDestroy(openUDPSockets);  /* removes socket from the list */	}}void InstallExitHandler(void) {	/* Install a handler to release all open sockets when terminating this	   application. The handler will be called even if you type ''es'' to	   MacsBug or use Command-Option-Escape for force the program to exit.	   The handler is only installed the first time the network is initialized.	*/	if (oldExitHandlerProc == nil) {		oldExitHandlerProc = GetToolTrapAddress(_ExitToShell);		myExitHandlerProc = 			NewRoutineDescriptor((ProcPtr) MyExitHandler, kPascalStackBased, GetCurrentISA());		SetToolTrapAddress(myExitHandlerProc, _ExitToShell);	}}void MyExitHandler(void) {	SetCurrentA5();	if (thisNetSession == 0) return;  /* noop if network is already shut down */	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	ExitToShell();}int PortNumberValid(int port) {	if (port < 0xFFFF) {		return true;	}	success(false);	return false;}int SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == thisNetSession)) {			if (s->socketType == TCPSocketType) {				if (((TCPSockPtr) s->privateSocketPtr)->tcpStream !!= nil) {					return true;				}			}			return true;	}	success(false);	return false;}/*** Private TCP Utilities ***/void InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr) {	memset(paramBlkPtr, 0, sizeof(TCPiopb));	paramBlkPtr->csCode = cmd;	paramBlkPtr->tcpStream = tcpStream;	paramBlkPtr->ioCRefNum = macTCPRefNum;	paramBlkPtr->ioResult = 1;}void TCPCloseCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		if (s->connectStatus == OtherEndClosed) {			s->connectStatus = Unconnected;		} else {			s->connectStatus = ThisEndClosed;		}	}	signalSemaphoreWithIndex(s->semaIndex);}void TCPConnectCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		s->connectStatus = Connected;	} else {		s->connectStatus = Unconnected;	}	signalSemaphoreWithIndex(s->semaIndex);}pascal void TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg) {	/* called when data arrives or stream status changes */	/* reference args to suppress compiler warnings about unused variables */	s; terminReason; icmpMsg;	if (eventCode == TCPDataArrival) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->dataAvailable = true;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPClosing) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		if (tcpSock->connectStatus == ThisEndClosed) {			tcpSock->connectStatus = Unconnected;		} else {			tcpSock->connectStatus = OtherEndClosed;		}		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPTerminate) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->connectStatus = Unconnected;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}}void TCPSendCompletionRoutine(struct TCPiopb *pbPtr) {//xxx	TCPSockPtr s = (TCPSockPtr) pbPtr;TCPSockPtr s = ((TCPSendBufPtr) pbPtr)->mySocket;	s->lastError = s->tcpPB.ioResult;	s->sendInProgress = false;	signalSemaphoreWithIndex(s->semaIndex);}/*** Private UDP Socket Functions (not yet implemented) ***/void * UDPSockCreate(void) {	return nil;}void UDPSockDestroy(UDPSockPtr s) {	s;}int UDPSockLocalAddress(UDPSockPtr s) {	s;}int UDPSockLocalPort(UDPSockPtr s) {	s;}int UDPSockRemoteAddress(UDPSockPtr s) {	s;}int UDPSockRemotePort(UDPSockPtr s) {	s;}void UDPSockConnectTo(UDPSockPtr s, int addr, int port) {	s; addr; port;}void UDPSockListenOn(UDPSockPtr s, int port) {	s; port;}int UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize) {	s; buf; bufSize;}int UDPSockSendData(UDPSockPtr s, char *buf, int bufSize) {	s; buf; bufSize;}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/1/2001 23:44'!macSerialAndMIDIPortFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "SerialPlugin.h"#include "MidiPlugin.h"/* initialize/shutdown */int midiInit() { return true; }int midiShutdown() {}int serialPortInit() { return true; }int serialPortShutdown() {	serialPortClose(0);	serialPortClose(1);}/* helper function for MIDI module */int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIParameterSet(int whichParameter, int newValue) {	sqMIDIParameter(whichParameter, true, newValue);}int sqMIDIParameterGet(int whichParameter) {	sqMIDIParameter(whichParameter, false, 0);}/* End of adjustments for pluginized VM */#include <CommResources.h>#include <CRMSerialDevices.h>#include <Devices.h>#include <QuickTimeComponents.h>#include <QuickTimeMusic.h>#include <Serial.h>#include <Strings.h>/*** Constants ***/#define INPUT_BUF_SIZE 1000#define FIRST_DRUM_KIT 16385/*** Imported Variables ***/extern int successFlag;/*** Serial Ports ***/#define MAX_PORTS 4short inRefNum[MAX_PORTS] = {0, 0, 0, 0};short outRefNum[MAX_PORTS] = {0, 0, 0, 0};char inputBuffer[MAX_PORTS][INPUT_BUF_SIZE];/* Quicktime MIDI note allocator and channels */NoteAllocator na = nil;NoteChannel channel[16] = {	nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil};/* Initial instruments: drums on channel 10, piano on all other channels */int channelInstrument[16] = {	1, 1, 1, 1, 1, 1, 1, 1, 1, FIRST_DRUM_KIT, 1, 1, 1, 1, 1, 1};/* Quicktime MIDI parser state */enum {idle, want1of2, want2of2, want1of1, sysExclusive};int state = idle;int argByte1 = 0;int argByte2 = 0;int lastCmdByte = nil;/* number of argument bytes for each MIDI command */char argumentBytes[128] = {	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	3, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};/*** Private Functions ***/int portIsOpen(int portNum);int portNames(int portNum, char *portName, char *inName, char *outName);int serialPortCount(void);int setHandshakeOptions(int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int setMidiClockRate(int portNum, int interfaceClockRate);/*** Quicktime MIDI Support Functions ***/void closeQuicktimeMIDIPort(void);void openQuicktimeMIDIPort(void);void performMIDICmd(int cmdByte, int arg1, int arg2);void processMIDIByte(int aByte);void startMIDICommand(int cmdByte);int serialPortCount(void) {  /* Return the number of serial ports available on this machine */#if TARGET_API_MAC_CARBON    return false;#else 	CRMRec		commRec; 	CRMRecPtr	thisRecPtr; 	int			count = 0; 	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    }    if (count > MAX_PORTS) count = MAX_PORTS; 	return count;#endif }int portIsOpen(int portNum) {	if ((portNum < 0) || (portNum > 1)) return false;	return outRefNum[portNum] !!= 0;}int portNames(int portNum, char *portName, char *inName, char *outName) {/* Fill in the user name and input and output port names for the given   port number. Note that ports are numbered starting with zero. */#if TARGET_API_MAC_CARBON    return false;#else 	CRMRec			commRec; 	CRMRecPtr		thisRecPtr; 	CRMSerialPtr	serialPtr; 	int				count = 0;  	portName[0] = inName[0] = outName[0] = 0;	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		if (count == portNum) {			serialPtr = (CRMSerialPtr) thisRecPtr->crmAttributes;			CopyPascalStringToC((void *) *(serialPtr->name),portName);			CopyPascalStringToC((void *) *(serialPtr->inputDriverName),inName);			CopyPascalStringToC((void *) *(serialPtr->outputDriverName),outName); 		} 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    }#endif }int setHandshakeOptions(  int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Set the given port''s handshaking parameters. */#if TARGET_API_MAC_CARBON    return false;#else	SerShk handshakeOptions;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	handshakeOptions.fInX = false;	handshakeOptions.fDTR = false;	if (inFlowCtrl == 1) handshakeOptions.fInX = true;  /* XOn/XOff handshaking */	if (inFlowCtrl == 2) handshakeOptions.fDTR = true;  /* hardware handshaking */	handshakeOptions.fXOn = false;	handshakeOptions.fCTS = false;	if (outFlowCtrl == 1) handshakeOptions.fXOn = true;  /* XOn/XOff handshaking */	if (outFlowCtrl == 2) handshakeOptions.fCTS = true;  /* hardware handshaking */	handshakeOptions.xOn  = xOnChar;	/* XOn character */	handshakeOptions.xOff = xOffChar;	/* XOff character */	handshakeOptions.errs = 0;			/* clear errors mask bits */	handshakeOptions.evts = 0;			/* clear event enable mask bits */	osErr = Control(outRefNum[portNum], 14, &handshakeOptions);	if (osErr !!= noErr) {		success(false);	}#endif}int setMidiClockRate(int portNum, int interfaceClockRate) {/* Put the given port into MIDI mode, which uses a clock supplied   by an external MIDI interface adaptor to determine the baud rate.   Possible external clock rates: 31.25 KHz, 0.5 MHz, 1 MHz, or 2 MHz. */#if TARGET_API_MAC_CARBON    return false;#else	char midiParam = 15;  /* dummy value */	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	if (interfaceClockRate ==   31250) midiParam = 0x00;	if (interfaceClockRate ==  500000) midiParam = 0x40;	if (interfaceClockRate == 1000000) midiParam = 0x80;	if (interfaceClockRate == 2000000) midiParam = 0xC0;	if (midiParam == 15) {		return success(false);  /* bad interfaceClockRate */	}	osErr = Control(outRefNum[portNum], 15, &midiParam);	if (osErr !!= noErr) {		return success(false);	}#endif}/*** Serial Port Functions ***/int serialPortClose(int portNum) {#if TARGET_API_MAC_CARBON    return false;#else	int osErr;	if ((portNum < 0) || (portNum > 1)) {		return success(false); /* bad port number */	}	if (!!portIsOpen(portNum)) {		return;  /* already closed */	}	osErr = KillIO(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(inRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	inRefNum[portNum] = 0;	outRefNum[portNum] = 0;#endif}int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Open the given serial port using the given settings. The baud rate can be   any number between about 224 and 57600; the driver will pick a clock   divisor that will generate the closest available baud rate. */#if TARGET_API_MAC_CARBON    return false;#else	short int options, baudRateParam;	char userName[256], inName[256], outName[256];	int osErr;	if ((portNum < 0) || (portNum > 1) || portIsOpen(portNum)) {		return success(false); /* bad port number or port already open */	}	options = baud9600;	switch (stopBitsType) {	case 0:		options += stop15;		break;	case 1:		options += stop10;		break;	case 2:		options += stop20;		break;	default:		return success(false);	}	switch (parityType) {	case 0:		options += noParity;		break;	case 1:		options += oddParity;		break;	case 2:		options += evenParity;		break;	default:		return success(false);	}	switch (dataBits) {	case 5:		options += data5;		break;	case 6:		options += data6;		break;	case 7:		options += data7;		break;	case 8:		options += data8;		break;	default:		return success(false);	}	portNames(portNum, userName, inName, outName);	CopyCStringToPascal((const char *)outName,(unsigned char *) outName);	osErr = OpenDriver((unsigned char *)outName, &outRefNum[portNum]);	if (osErr !!= noErr) {		return success(false);	}	CopyCStringToPascal((const char *)inName,(unsigned char *)inName);	osErr = OpenDriver((unsigned char *)inName, &inRefNum[portNum]);	if (osErr !!= noErr) {		CloseDriver(outRefNum[portNum]);		return success(false);	}	/* set the handshaking options */	setHandshakeOptions(portNum, inFlowCtrl, outFlowCtrl, xOnChar, xOffChar);	/* install a larger input buffer */	osErr = SerSetBuf(inRefNum[portNum], &inputBuffer[portNum][0], INPUT_BUF_SIZE);	if (osErr !!= noErr) {		success(false);	}	/* set data bits, parity type, and stop bits */	osErr = SerReset(outRefNum[portNum], options);	if (osErr !!= noErr) {		success(false);	}	/* set the baud rate (e.g., the value 9600 gives 9600 baud) */	baudRateParam = baudRate;	osErr = Control(outRefNum[portNum], 13, &baudRateParam);	if (osErr !!= noErr) {		success(false);	}	if (!!successFlag) {		CloseDriver(inRefNum[portNum]);		CloseDriver(outRefNum[portNum]);		inRefNum[portNum] = 0;		outRefNum[portNum] = 0;	}#endif}int serialPortReadInto(int portNum, int count, int bufferPtr) {/* Read up to count bytes from the given serial port into the given byte array.   Read only up to the number of bytes in the port''s input buffer; if fewer bytes   than count have been received, do not wait for additional data to arrive.   Return zero if no data is available. */#if TARGET_API_MAC_CARBON    return false;#else	long int byteCount;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = SerGetBuf(inRefNum[portNum], &byteCount);  /* bytes available */	if (osErr !!= noErr) {		return success(false);	}	if (byteCount > count) byteCount = count;  /* read at most count bytes */	osErr = FSRead(inRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;#endif}int serialPortWriteFrom(int portNum, int count, int bufferPtr) {/* Write count bytes from the given byte array to the given serial port''s   output buffer. Return the number of bytes written. This implementation is   synchronous: it doesn''t return until the data has been sent. However, other   implementations may return before transmission is complete. */	long int byteCount = count;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = FSWrite(outRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}/*** MIDI Parameters (used with sqMIDIParameter function) ***/#define sqMIDIInstalled				1/* Read-only. Return 1 if a MIDI driver is installed, 0 if not.   On OMS-based MIDI drivers, this returns 1 only if the OMS   system is properly installed and configured. */#define sqMIDIVersion				2/* Read-only. Return the integer version number of this MIDI driver.   The version numbering sequence is relative to a particular driver.   That is, version 3 of the Macintosh MIDI driver is not necessarily   related to version 3 of the Win95 MIDI driver. */#define sqMIDIHasBuffer				3/* Read-only. Return 1 if this MIDI driver has a time-stamped output   buffer, 0 otherwise. Such a buffer allows the client to schedule   MIDI output packets to be sent later. This can allow more precise   timing, since the driver uses timer interrupts to send the data   at the right time even if the processor is in the midst of a   long-running Squeak primitive or is running some other application   or system task. */#define sqMIDIHasDurs				4/* Read-only. Return 1 if this MIDI driver supports an extended   primitive for note-playing that includes the note duration and   schedules both the note-on and the note-off messages in the   driver. Otherwise, return 0. */#define sqMIDICanSetClock			5/* Read-only. Return 1 if this MIDI driverÕs clock can be set   via an extended primitive, 0 if not. */#define sqMIDICanUseSemaphore		6/* Read-only. Return 1 if this MIDI driver can signal a semaphore   when MIDI input arrives. Otherwise, return 0. If this driver   supports controller caching and it is enabled, then incoming   controller messages will not signal the semaphore. */#define sqMIDIEchoOn				7/* Read-write. If this flag is set to a non-zero value, and if   the driver supports echoing, then incoming MIDI events will   be echoed immediately. If this driver does not support echoing,   then queries of this parameter will always return 0 and   attempts to change its value will do nothing. */#define sqMIDIUseControllerCache	8/* Read-write. If this flag is set to a non-zero value, and if   the driver supports a controller cache, then the driver will   maintain a cache of the latest value seen for each MIDI controller,   and control update messages will be filtered out of the incoming   MIDI stream. An extended MIDI primitive allows the client to   poll the driver for the current value of each controller. If   this driver does not support a controller cache, then queries   of this parameter will always return 0 and attempts to change   its value will do nothing. */#define sqMIDIEventsAvailable		9/* Read-only. Return the number of MIDI packets in the input queue. */#define sqMIDIFlushDriver			10/* Write-only. Setting this parameter to any value forces the driver   to flush its I/0 buffer, discarding all unprocessed data. Reading   this parameter returns 0. Setting this parameter will do nothing   if the driver does not support buffer flushing. */#define sqMIDIClockTicksPerSec		11/* Read-only. Return the MIDI clock rate in ticks per second. */#define sqMIDIHasInputClock			12/* Read-only. Return 1 if this MIDI driver timestamps incoming   MIDI data with the current value of the MIDI clock, 0 otherwise.   If the driver does not support such timestamping, then the   client must read input data frequently and provide its own   timestamping. *//*** MIDI Functions ***/int sqMIDIClosePort(int portNum) {/* Close the given MIDI port. Do nothing if the port is not open.   Fail if there is no port of the given number.*/	int serialPorts;		serialPorts = serialPortCount();	if (portNum == serialPorts) {		closeQuicktimeMIDIPort();		return;	} else {		return serialPortClose(portNum);	}}int sqMIDIGetClock(void) {/* Return the current value of the clock used to schedule MIDI events.   The MIDI clock is assumed to wrap at or before half the maximum   positive SmallInteger value. This allows events to be scheduled   into the future without overflowing into LargePositiveIntegers.    This implementation does not support event scheduling, so it   just returns the value of the Squeak millisecond clock. */	return ioMicroMSecs();}int sqMIDIGetPortCount(void) {/* Return the number of available MIDI interfaces, including both   hardware ports and software entities that act like ports. Ports   are numbered from 0 to N-1, where N is the number returned by this   primitive. */	return serialPortCount() + 1;  /* serial ports + QuickTime Synth */}int sqMIDIGetPortDirectionality(int portNum) {/* Return an integer indicating the directionality of the given   port where: 1 = input, 2 = output, 3 = bidirectional. Fail if   there is no port of the given number. */		int serialPorts;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		return 2;	} else {		return 3;	}}int sqMIDIGetPortName(int portNum, int namePtr, int length) {/* Copy the name of the given MIDI port into the string at the given   address. Copy at most length characters, and return the number of   characters copied. Fail if there is no port of the given number.*/	char userName[256], inName[256], outName[256];	int serialPorts, count;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		strcpy(userName, "QuickTime MIDI");	} else {		portNames(portNum, userName, inName, outName);	}	count = strlen(userName);	if (count > length) count = length;	memcpy((void *) namePtr, userName, count);	return count;}int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate) {/* Open the given port, if possible. If non-zero, readSemaphoreIndex   specifies the index in the external objects array of a semaphore   to be signalled when incoming MIDI data is available. Note that   not all implementations support read semaphores (this one does   not); see sqMIDICanUseSemaphore. The interfaceClockRate parameter   specifies the clock speed for an external MIDI interface   adaptor on platforms that use such adaptors (e.g., Macintosh).   Fail if there is no port of the given number.*/	int serialPorts;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		openQuicktimeMIDIPort();		return;	}	serialPortOpen(portNum, 9600, 1, 0, 8, 0, 0, 0, 0);	if (successFlag) {		setMidiClockRate(portNum, interfaceClockRate);		if (!!successFlag) {			serialPortClose(portNum);		}	}}int sqMIDIParameter(int whichParameter, int modify, int newValue) {/* Read or write the given MIDI driver parameter. If modify is 0,   then newValue is ignored and the current value of the specified   parameter is returned. If modify is non-zero, then the specified   parameter is set to newValue. Note that many MIDI driver parameters   are read-only; attempting to set one of these parameters fails.   For boolean parameters, true = 1, false = 0. */	if (modify == 0) {		switch(whichParameter) {		case sqMIDIInstalled:			return 1;			break;		case sqMIDIVersion:			return 100;			break;		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:		case sqMIDIEchoOn:		case sqMIDIUseControllerCache:			return 0;			break;		case sqMIDIEventsAvailable:			return 1;  /* pretend that events are always available */			break;		case sqMIDIFlushDriver:			return 0;			break;		case sqMIDIClockTicksPerSec:			return 1000;			break;		case sqMIDIHasInputClock:			return 0;			break;		default:			return success(false);		}	} else {		switch(whichParameter) {		case sqMIDIInstalled:		case sqMIDIVersion:		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:			return success(false);			break;		case sqMIDIEchoOn:			/* noop; echoing not supported */			break;		case sqMIDIUseControllerCache:			/* noop; controller cache not supported */			break;		case sqMIDIEventsAvailable:			return success(false);			break;		case sqMIDIFlushDriver:			/* noop; buffer flushing not supported */			break;		case sqMIDIClockTicksPerSec:			return success(false);			break;		default:			return success(false);		}	}}int sqMIDIPortReadInto(int portNum, int count, int bufferPtr) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Copy up to (length - 4) bytes   of incoming MIDI data into that buffer, preceded by a 4-byte   timestamp in the units of the MIDI clock, most significant byte   first. Implementations that do not support timestamping of   incoming data as it arrives (see sqMIDIHasInputClock) simply   set the timestamp to the value of the MIDI clock when this   function is called. Return the total number of bytes read,   including the timestamp bytes. Return zero if no data is   available. Fail if the buffer is shorter than five bytes,   since there must be enough room for the timestamp plus at   least one data byte. */	int bytesRead;	if (count < 5) return success(false);	bytesRead = serialPortReadInto(portNum, count - 4, bufferPtr + 4);	if (bytesRead == 0) return 0;	*((int *) bufferPtr) = sqMIDIGetClock();  /* set timestamp */	return bytesRead + 4;}int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Send its contents to the given   port when the MIDI clock reaches the given time. If time equals   zero, then send the data immediately. Implementations that do   not support a timestamped output queue, such as this one, always   send the data immediately; see sqMIDIHasBuffer. */	int serialPorts, i;	unsigned char *bytePtr;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		if (!!na) return success(false);  /* QuickTime port not open */		bytePtr = (unsigned char *) bufferPtr;		for (i = 0; i < count; i++) {			processMIDIByte(*bytePtr++);		}		return count;	}	return serialPortWriteFrom(portNum, count, bufferPtr);}/*** Quicktime MIDI Support Functions ***/void closeQuicktimeMIDIPort(void) {	int i;	if (!!na) return;	for (i = 0; i < 16; i++) {		/* dispose of note channels */		if (channel[i]) NADisposeNoteChannel(na, channel[i]);		channel[i] = nil;	}	CloseComponent(na);  /* close note allocator */}void openQuicktimeMIDIPort(void) {	ComponentResult err;	NoteRequest nr;	NoteChannel nc;	int i;	closeQuicktimeMIDIPort();	na = OpenDefaultComponent(''nota'', 0);	if (!!na) return;	for (i = 0; i < 16; i++) {		nr.info.polyphony = 11;					/* max simultaneous tones */		nr.info.typicalPolyphony = 0x00010000;	/* typical simultaneous tones */		NAStuffToneDescription(na, 1, &nr.tone);		err = NANewNoteChannel(na, &nr, &nc);		if (err || !!nc) {			closeQuicktimeMIDIPort();			return;		}		NAResetNoteChannel(na, nc);		NASetInstrumentNumber(na, nc, channelInstrument[i]);		channel[i] = nc;	}	state = idle;	argByte1 = 0;	argByte2 = 0;	lastCmdByte = nil;	return;}void performMIDICmd(int cmdByte, int arg1, int arg2) {	/* Perform the given MIDI command with the given arguments. */	int ch, cmd, val, instrument, bend;	ch = cmdByte & 0x0F;	cmd = cmdByte & 0xF0;	if (cmd == 128) {  /* note off */		NAPlayNote(na, channel[ch], arg1, 0);	}	if (cmd == 144) {  /* note on */		NAPlayNote(na, channel[ch], arg1, arg2);	}	if (cmd == 176) {  /* control change */		if ((arg1 >= 32) && (arg1 <= 63)) {			val = arg2 << 1;  /* LSB of controllers 0-31 */		} else {			val = arg2 << 8;  /* scale MSB to QT controller range */		}		NASetController(na, channel[ch], arg1, val);	}	if (cmd == 192) {  /* program change */		if (ch == 9) {			instrument = FIRST_DRUM_KIT + arg1;  /* if channel 10, select a drum set */		} else {			instrument = arg1 + 1;		}		NASetInstrumentNumber(na, channel[ch], instrument);		channelInstrument[ch] = instrument;	}	if (cmd == 224) {  /* pitch bend */		bend = ((arg2 << 7) + arg1) - (64 << 7);		bend = bend / 32;  /* default sensitivity = +/- 2 semitones */		NASetController(na, channel[ch], kControllerPitchBend, bend);	}}void processMIDIByte(int aByte) {	/* Process the given incoming MIDI byte and perform any completed commands. */	if (aByte > 247) return;  /* skip all real-time messages */	switch (state) {	case idle:		if (aByte >= 128) {			/* start a new command using the action table */			startMIDICommand(aByte);		} else {			/* data byte arrived in idle state: use running status if possible */			if (lastCmdByte == nil) {				return;  /* last command byte is not defined; just skip this byte */			} else {				/* process this data as if it had the last command byte in front of it */				startMIDICommand(lastCmdByte);				/* the previous line put us into a new state; we now do a recursive			   	   call to process the data byte in this new state. */				processMIDIByte(aByte);				return;			}		}		break;	case want1of2:		argByte1 = aByte;		state = want2of2;		break;	case want2of2:		argByte2 = aByte;		performMIDICmd(lastCmdByte, argByte1, argByte2);		state = idle;		break;	case want1of1:		argByte1 = aByte;		performMIDICmd(lastCmdByte, argByte1, 0);		state = idle;		break;	case sysExclusive:		if (aByte < 128) {			/* skip a system exclusive data byte */		} else {			if (aByte < 248) {				/* a system exclusive message can be terminated by any non-real-time command byte */				state = idle;				if (aByte !!= 247) {					processMIDIByte(aByte);	/* if not endSysExclusive, byte is the start the next command */				}			}		}		break;	}}void startMIDICommand(int cmdByte) {	/* Start processing a MIDI message beginning with the given command byte. */	int argCount;	argCount = argumentBytes[cmdByte - 128];	switch (argCount) {	case 0:						/* start a zero argument command (e.g., a real-time message) */		/* Stay in the current state and don''t change active status.		   Real-time messages may arrive between data bytes without disruption. */		performMIDICmd(cmdByte, 0, 0);		break;	case 1:						/* start a one argument command */		lastCmdByte = cmdByte;		state = want1of1;		break;	case 2:						/* start a two argument command */		lastCmdByte = cmdByte;		state = want1of2;		break;	case 3:						/* start a variable length ''system exclusive'' command */		/* a system exclusive command clears running status */		lastCmdByte = nil;		state = sysExclusive;		break;	}}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/1/2001 23:45'!macSoundFile	^ '/*Carbon porting notes:	Carbon doesn''t support the SndPlayDoubleBuffer system routine.	This is a command you put in the sound channel which repeatedly	calls a callback routine.		Technote 1198 describes the situation, a work-around and provides	example code.  I merely added this code to the end of this file	and plugged it into the existing Squeak code.Karl Goiser 14/01/01*///johnmci@smalltalkconsulting.com Nov 6th 2000. Added sound volume logic/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */ #include "sq.h"#include "SoundPlugin.h"/* initialize/shutdown */int soundInit() { return true; }int soundShutdown() { snd_Stop(); }/* End of adjustments for pluginized VM */#include <Sound.h>#include <SoundInput.h>/******  Mac Sound Output Notes:	The Squeak sound code produces 16-bit, stereo sound buffers. The was	arrived at after experimentation on a PPC 601 at 110 MHz on which I	found that:	  a. using 16-bit sound only slightly increased the background CPU burden and	  b. 16-bit sound yielded vastly superior sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	In earlier versions, I experimented with other sound buffer formats. Here	are all the sound buffer formats that were used at one point or another:		1. mono,    8-bits -- packed array of bytes (not currently used)		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes (not currently used)		3. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	Note: When the sound drive is operating in "mono", the two stereo channels are mixed	      together. This feature was added in January, 1998.	-- John Maloney, July 28, 1996	-- edited: John Maloney, January 5, 1998  Mac Sound Input Notes:	Squeak sound input is currently defined to provide a single (mono) stream	of signed 16-bit samples for all platforms. Platforms that only support	8-bit sound input should convert samples to signed 16 bit values, leaving	the low order bits zero. Since the available sampling rates differ from	platform to platform, the client may not get the requested sampling rate;	however, the call snd_GetRecordingSampleRate returns the sampling rate.	On many platforms, simultaneous record and playback is permitted only if	the input and output sampling rates are the same.	-- John Maloney, Aug 22, 1997******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int sampleRate;	int lastFlipTime;	int playSemaIndex;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} PlayStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** record buffer state record ***//* Note: RECORD_BUFFER_SIZE should be a multiple of 4096 bytes to avoid clicking.   (The clicking was observed on a Mac 8100; the behavior of other Macs could differ.)   Note: G3 Series Powerbook requires minimum of 4 * 4096 buffer size for stereo.*/#define RECORD_BUFFER_SIZE (4096 * 2)typedef struct {	SPB paramBlock;	int stereo;	int bytesPerSample;	int recordSemaIndex;	int readIndex;  /* index of the next sample to read */	char samples[RECORD_BUFFER_SIZE];} RecordBufferRec, *RecordBuffer;/*** sound output variables ***/SndChannelPtr chan;PlayStateRec bufState = {false, false, 0, 0, 0, 0, 0, 0, 0, true};SndDoubleBufferHeader dblBufHeader;/*** sound input variables ***/RecordBufferRec recordBuffer1, recordBuffer2;int recordingInProgress;long soundInputRefNum;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void FlipRecordBuffers(SPBPtr pb);int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex);OSErr CarbonSndPlayDoubleBuffer (SndChannelPtr chan, SndDoubleBufferHeaderPtr theParams);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {  /* Switch buffers (at interrupt time). The given buffer just finished playing. */	PlayStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	state = (PlayStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		buf->dbFlags = buf->dbFlags | dbLastBuffer;	} else {		signalSemaphoreWithIndex(state->playSemaIndex);	}	state->lastFlipTime = ioMicroMSecs();	FillBufferWithSilence(buf);  /* avoids ugly stutter if not filled in time */}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}pascal void FlipRecordBuffers(SPBPtr pb) {	/* called at interrupt time to exchange the active and inactive record buffers */	RecordBuffer thisBuffer = (RecordBuffer) pb;	RecordBuffer nextBuffer = (RecordBuffer) pb->userLong;	if (pb->error == 0) {		/* restart recording using the other buffer */		SPBRecord(&nextBuffer->paramBlock, true);		/* reset the read pointer for the buffer that has just been filled */		thisBuffer->readIndex = 0;		signalSemaphoreWithIndex(nextBuffer->recordSemaIndex);	}}/*** exported sound output functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			while (src < end) {				*dst++ = (*src++ + *src++) / 2;			}		}	}	return framesWritten;}int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex) {	int sample;	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) srcBufPtr + srcStartIndex;		end = (unsigned char *) srcBufPtr + (count * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) dstBufPtr + dstStartIndex;		while (src < end) {			sample = *dst + (*src++ - 128);			if (sample > 255) sample = 255;			if (sample < 0) sample = 0;			*dst++ = sample;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (srcBufPtr + (srcStartIndex * 4));		end = (short int *) (srcBufPtr + ((srcStartIndex + count) * 4));		if (bufState.stereo) {  /* stereo */			dst = (short int *) (dstBufPtr + (dstStartIndex * 4));			while (src < end) {				sample = *dst + *src++;				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			dst = (short int *) (dstBufPtr + (dstStartIndex * 2));			while (src < end) {				sample = *dst + ((*src++ + *src++) / 2);				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		}	}}int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime) {	SndDoubleBufferPtr bufPlaying, otherBuf;	int samplesInserted, startSample, count;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_PLAYING) {		bufPlaying = dblBufHeader.dbhBufferPtr[0];		otherBuf = dblBufHeader.dbhBufferPtr[1];	} else {		bufPlaying = dblBufHeader.dbhBufferPtr[1];		otherBuf = dblBufHeader.dbhBufferPtr[0];	}	samplesInserted = 0;	/* mix as many samples as can fit into the remainder of the currently playing buffer */	startSample =		((bufState.sampleRate * (ioMicroMSecs() - bufState.lastFlipTime)) / 1000) + samplesOfLeadTime;	if (startSample < bufState.frameCount) {		count = bufState.frameCount - startSample;		if (count > frameCount) count = frameCount;		MixInSamples(count, (char *) srcBufPtr, 0, (char *) &bufPlaying->dbSoundData[0], startSample);		samplesInserted = count;	}	/* mix remaining samples into the inactive buffer */	count = bufState.frameCount;	if (count > (frameCount - samplesInserted)) {		count = frameCount - samplesInserted;	}	MixInSamples(count, (char *) srcBufPtr, samplesInserted, (char *) &otherBuf->dbSoundData[0], 0);	return samplesInserted + count;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.sampleRate		= samplesPerSec;	bufState.lastFlipTime	= ioMicroMSecs();	bufState.playSemaIndex	= semaIndex;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0		= BUF_EMPTY;	bufState.bufState1		= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */#if TARGET_API_MAC_CARBON	dblBufHeader.dbhDoubleBack		= nil;#else	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);#endif	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) {   /* could not allocate memory for a buffer; clean up and abort */			SndDisposeChannel(chan, true);#if !!TARGET_API_MAC_CARBON			DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);#endif			if (i == 1) {  /* free the first buffer */				DisposePtr((char *) dblBufHeader.dbhBufferPtr[1]);				dblBufHeader.dbhBufferPtr[1] = NULL;			}			return false;		}		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}#if TARGET_API_MAC_CARBON	err = CarbonSndPlayDoubleBuffer(chan, &dblBufHeader);#else	err = SndPlayDoubleBuffer(chan, &dblBufHeader);#endif	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.open = false;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, (void *) &junk);	}	SndDisposeChannel(chan, true);#if !!TARGET_API_MAC_CARBON	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);#endif	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}/*** exported sound input functions ***/int snd_SetRecordLevel(int level) {	/* set the recording level to a value between 0 (minimum gain) and 1000. */	Fixed inputGainArg;	int err;	if (!!recordingInProgress || (level < 0) || (level > 1000)) {		success(false);		return;  /* noop if not recording */	}	inputGainArg = ((500 + level) << 16) / 1000;  /* gain is Fixed between 0.5 and 1.5 */	err = SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	/* don''t fail on error; hardware may not support setting the gain */}int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex) {	/* turn on sound recording, trying to use a sampling rate close to	   the one specified. semaIndex is the index in the exportedObject	   array of a semaphore to be signalled when input data is available. */	Str255 deviceName = "";	short automaticGainControlArg;	Fixed inputGainArg;	long  compressionTypeArg;	short continuousArg;	short sampleSizeArg;	short channelCountArg;	UnsignedFixed sampleRateArg;	int err;	err = SPBOpenDevice(deviceName, siWritePermission, &soundInputRefNum);	if (err !!= noErr) {		success(false);		return;	}	/* try to initialize some optional parameters, but don''t fail if we can''t */	automaticGainControlArg = false;	SPBSetDeviceInfo(soundInputRefNum, siAGCOnOff, &automaticGainControlArg);	inputGainArg = 1 << 16;  /* 1.0 in Fixed */	SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	compressionTypeArg = ''NONE'';	SPBSetDeviceInfo(soundInputRefNum, siCompressionType, &compressionTypeArg);	continuousArg = true;	err = SPBSetDeviceInfo(soundInputRefNum, siContinuous, &continuousArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	sampleSizeArg = 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);	if (err !!= noErr) {		/* use 8-bit samples */		sampleSizeArg = 8;		err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);		if (err !!= noErr) {			success(false);			SPBCloseDevice(soundInputRefNum);			return;		}	}	channelCountArg = stereo ? 2 : 1;	err = SPBSetDeviceInfo(soundInputRefNum, siNumberChannels, &channelCountArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	/* try to set the client''s desired sample rate */	sampleRateArg = desiredSamplesPerSec << 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		/* if client''s rate fails, try the nearest common sampling rates in {11025, 22050, 44100} */		if (desiredSamplesPerSec <= 16538) {			sampleRateArg = 11025 << 16;		} else {			if (desiredSamplesPerSec <= 33075) {				sampleRateArg = 22050 << 16;			} else {				sampleRateArg = 44100 << 16;			}		}		/* even if following fails, recording can go on at the default sample rate */		SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	}	recordBuffer1.paramBlock.inRefNum = soundInputRefNum;	recordBuffer1.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.milliseconds = 0;	recordBuffer1.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.bufferPtr = recordBuffer1.samples;#if TARGET_API_MAC_CARBON	recordBuffer1.paramBlock.completionRoutine = NewSICompletionUPP(FlipRecordBuffers);#else	recordBuffer1.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);#endif	recordBuffer1.paramBlock.interruptRoutine = nil;	recordBuffer1.paramBlock.userLong = (long) &recordBuffer2;  /* pointer to other buffer */	recordBuffer1.paramBlock.error = noErr;	recordBuffer1.paramBlock.unused1 = 0;	recordBuffer1.stereo = stereo;	recordBuffer1.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer1.recordSemaIndex = semaIndex;	recordBuffer1.readIndex = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.inRefNum = soundInputRefNum;	recordBuffer2.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.milliseconds = 0;	recordBuffer2.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.bufferPtr = recordBuffer2.samples;#if TARGET_API_MAC_CARBON	recordBuffer2.paramBlock.completionRoutine = NewSICompletionUPP(FlipRecordBuffers);#else	recordBuffer2.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);#endif	recordBuffer2.paramBlock.interruptRoutine = nil;	recordBuffer2.paramBlock.userLong = (long) &recordBuffer1;  /* pointer to other buffer */	recordBuffer2.paramBlock.error = noErr;	recordBuffer2.paramBlock.unused1 = 0;	recordBuffer2.stereo = stereo;	recordBuffer2.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer2.recordSemaIndex = semaIndex;	recordBuffer2.readIndex = RECORD_BUFFER_SIZE;	err = SPBRecord(&recordBuffer1.paramBlock, true);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	recordingInProgress = true;}int snd_StopRecording(void) {	/* turn off sound recording */	int err;	if (!!recordingInProgress) return;  /* noop if not recording */	err = SPBStopRecording(soundInputRefNum);	if (err !!= noErr) success(false);	SPBCloseDevice(soundInputRefNum);#if TARGET_API_MAC_CARBON	DisposeSICompletionUPP(recordBuffer1.paramBlock.completionRoutine);#else	DisposeRoutineDescriptor(recordBuffer1.paramBlock.completionRoutine);#endif	recordBuffer1.paramBlock.completionRoutine = nil;#if TARGET_API_MAC_CARBON	DisposeSICompletionUPP(recordBuffer2.paramBlock.completionRoutine);#else	DisposeRoutineDescriptor(recordBuffer2.paramBlock.completionRoutine);#endif	recordBuffer2.paramBlock.completionRoutine = nil;	recordBuffer1.recordSemaIndex = 0;	recordBuffer2.recordSemaIndex = 0;	recordingInProgress = false;}double snd_GetRecordingSampleRate(void) {	/* return the actual recording rate; fail if not currently recording */	UnsignedFixed sampleRateArg;	int err;	if (!!recordingInProgress) {		success(false);		return 0.0;	}	err = SPBGetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		success(false);		return 0.0;	}	return  (double) ((sampleRateArg >> 16) & 0xFFFF) +			((double) (sampleRateArg & 0xFFFF) / 65536.0);}int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes) {	/* if data is available, copy as many sample slices as possible into the	   given buffer starting at the given slice index. do not write past the	   end of the buffer, which is buf + bufferSizeInBytes. return the number	   of slices (not bytes) copied. a slice is one 16-bit sample in mono	   or two 16-bit samples in stereo. */	int bytesPerSlice = (recordBuffer1.stereo ? 4 : 2);	char *nextBuf = (char *) buf + (startSliceIndex * bytesPerSlice);	char *bufEnd = (char *) buf + bufferSizeInBytes;	char *src, *srcEnd;	RecordBuffer recBuf = nil;	int bytesCopied;	if (!!recordingInProgress) {		success(false);		return 0;	}	/* select the buffer with unread samples, if any */	recBuf = nil;	if (recordBuffer1.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer1;	if (recordBuffer2.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer2;	if (recBuf == nil) return 0;  /* no samples available */	/* copy samples into the client''s buffer */	src = &recBuf->samples[0] + recBuf->readIndex;	srcEnd = &recBuf->samples[RECORD_BUFFER_SIZE];	if (recBuf->bytesPerSample == 1) {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			/* convert 8-bit sample to 16-bit sample */			*nextBuf++ = (*src++) - 128;  /* convert from [0-255] to [-128-127] */			*nextBuf++ = 0;  /* low-order byte is zero */		}	} else {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			*nextBuf++ = *src++;		}	}	recBuf->readIndex = src - &recBuf->samples[0];  /* update read index */	/* return the number of slices copied */	bytesCopied = (int) nextBuf - (buf + (startSliceIndex * bytesPerSlice));	return bytesCopied / bytesPerSlice;}//Nov 6th 2000void snd_Volume(double *left, double *right) {	double temp;	SndCommand cmd;    long   results;	OSErr  err;		*left = 1.0;	*right = 1.0;	cmd.cmd = getVolumeCmd;	cmd.param1 = 0;	cmd.param2 = (long) &results;	err = -1;	if (chan !!= null)	    err = SndDoImmediate(chan,&cmd);	    	if (err !!= noErr) {	   err = GetDefaultOutputVolume(&results);	}	if (err !!= noErr) 	    return;	temp  = (results & 0xFFFF);	*left = temp/256.0;		temp = (results >> 16);	*right = temp/256.0;}void snd_SetVolume(double left, double right) {	unsigned long tempLeft,tempRight;	SndCommand cmd;	OSErr  err;		tempLeft = left*256.0 + 0.5;	tempLeft = tempLeft & 0xFFFF;	tempRight = right*256.0 + 0.5;	tempRight= tempRight & 0xFFFF;	cmd.cmd = volumeCmd;	cmd.param1 = 0;	cmd.param2 = (tempRight << 16) | tempLeft;	err = -1;	if (chan !!= null)	    err= SndDoImmediate(chan,&cmd);	if (err !!= noErr) {	   err = SetDefaultOutputVolume(cmd.param2);	}}/*	File:		CarbonSndPlayDB.c		Description:Routines demonstrating how to create a function that works				much like the original SndPlayDoubleBuffer but is Carbon compatible				(which SndPlayDoubleBuffer isn''t).	Author:		MC	Copyright: 	© Copyright 1999-2000 Apple Computer, Inc. All rights reserved.		Disclaimer:	IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.				("Apple") in consideration of your agreement to the following terms, and your				use, installation, modification or redistribution of this Apple software				constitutes acceptance of these terms.  If you do not agree with these terms,				please do not use, install, modify or redistribute this Apple software.				In consideration of your agreement to abide by the following terms, and subject				to these terms, Apple grants you a personal, non-exclusive license, under AppleÕs				copyrights in this original Apple software (the "Apple Software"), to use,				reproduce, modify and redistribute the Apple Software, with or without				modifications, in source and/or binary forms; provided that if you redistribute				the Apple Software in its entirety and without modifications, you must retain				this notice and the following text and disclaimers in all such redistributions of				the Apple Software.  Neither the name, trademarks, service marks or logos of				Apple Computer, Inc. may be used to endorse or promote products derived from the				Apple Software without specific prior written permission from Apple.  Except as				expressly stated in this notice, no other rights or licenses, express or implied,				are granted by Apple herein, including but not limited to any patent rights that				may be infringed by your derivative works or by other works in which the Apple				Software may be incorporated.				The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO				WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED				WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR				PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN				COMBINATION WITH YOUR PRODUCTS.				IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR				CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE				GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)				ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION				OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT				(INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN				ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.					Change History (most recent first):*//* Requirements for using this shim code:	1) The sound channel''s queue must be empty before you call CarbonSndPlayDoubleBuffer	2) You cannot call MySndDoImmediate until CarbonSndPlayDoubleBuffer returns.  Be	   careful about calling MySndDoImmediate at interrupt time with a quietCmd.*//*Some code is commented out becuase knowing who calls it and how allows shortcutsKarl Goiser 14/01/01*/#undef UNNECESSARY_FOR_SQUEAK#if UNNECESSARY_FOR_SQUEAKstatic	pascal	void	CarbonSndPlayDoubleBufferCleanUpProc (SndChannelPtr theChannel, SndCommand * theCallBackCmd);#endifstatic  pascal  void	CarbonSndPlayDoubleBufferCallBackProc (SndChannelPtr theChannel, SndCommand * theCallBackCmd);static			void	InsertSndDoCommand (SndChannelPtr chan, SndCommand * theCmd);static	pascal	void	NMResponseProc (NMRecPtr nmReqPtr);#define kBufSize					2048// Structsstruct PerChanInfo {	QElemPtr 						qLink;						/* next queue entry */	short 							qType;						/* queue type = 0 */	short							stopping;	#if DEBUG		OSType						magic;	#endif	SndCallBackUPP 					usersCallBack;	SndDoubleBufferHeaderPtr		theParams;	CmpSoundHeader					soundHeader;};typedef struct PerChanInfo			PerChanInfo;typedef struct PerChanInfo *		PerChanInfoPtr;// Globals	Boolean							gNMRecBusy;	NMRecPtr						gNMRecPtr;	QHdrPtr							gFreeList;	Ptr								gSilenceTwos;	Ptr								gSilenceOnes;static SndCallBackUPP				gCarbonSndPlayDoubleBufferCallBackUPP = nil;static SndCallBackUPP				gCarbonSndPlayDoubleBufferCleanUpUPP = nil;#if UNNECESSARY_FOR_SQUEAK// Remember this routine could be called at interrupt time, so don''t allocate or deallocate memory.OSErr	MySndDoImmediate (SndChannelPtr chan, SndCommand * cmd) {	PerChanInfoPtr					perChanInfoPtr;	// Is this being called on one of the sound channels we are manipulating?	// If so, we need to pull our callback out of the way so that the user''s commands run	if (gCarbonSndPlayDoubleBufferCallBackUPP == chan->callBack) {		if (quietCmd == cmd->cmd || flushCmd == cmd->cmd) {			// We know that our callBackCmd is the first item in the queue if this is our channel			perChanInfoPtr = (PerChanInfoPtr)(chan->queue[chan->qHead].param2);			#if DEBUG				if (perChanInfoPtr->magic !!= ''SANE'') DebugStr("\pBAD in MySndDoImmediate");			#endif			perChanInfoPtr->stopping = true;			Enqueue ((QElemPtr)perChanInfoPtr, gFreeList);			if (!! OTAtomicSetBit (&gNMRecBusy, 0)) {				NMInstall (gNMRecPtr);			}			chan->callBack = perChanInfoPtr->usersCallBack;		}	}	return (SndDoImmediate (chan, cmd));}#endif UNNECESSARY_FOR_SQUEAK// This must be called at task time.OSErr	CarbonSndPlayDoubleBuffer (SndChannelPtr chan, SndDoubleBufferHeaderPtr theParams) {	OSErr							err;	CompressionInfo					compInfo;	PerChanInfoPtr					perChanInfoPtr;	SndCommand						playCmd;	SndCommand						callBack;	if (nil == chan)		return badChannel;	if (nil == theParams)	return paramErr;	if (nil == gFreeList) {		// This can''t ever be disposed since we don''t know when we might need to use it (at interrupt time)		gFreeList = (QHdrPtr)NewPtrClear (sizeof (QHdr));		err = MemError ();		if (noErr !!= err) goto exit;	}	if (nil == gSilenceOnes) {		short		i;		// This can''t ever be disposed since we don''t know when we might need to use it (at interrupt time)		gSilenceOnes = NewPtr (kBufSize);		err = MemError ();		if (noErr !!= err) goto exit;		for (i = 0; i < kBufSize; i++)			*gSilenceOnes++ = (char)0x80;	}	if (nil == gSilenceTwos) {		// This can''t ever be disposed since we don''t know when we might need to use it (at interrupt time)		gSilenceTwos = NewPtrClear (kBufSize);		err = MemError ();		if (noErr !!= err) goto exit;	}	if (nil == gNMRecPtr) {		// This can''t ever be disposed since we don''t know when we might need to use it (at interrupt time)		gNMRecPtr = (NMRecPtr)NewPtr (sizeof (NMRec));		err = MemError ();		if (noErr !!= err) goto exit;		// Set up our NMProc info that will dispose of most (but not all) of our memory		gNMRecPtr->qLink = nil;		gNMRecPtr->qType = 8;		gNMRecPtr->nmFlags = 0;		gNMRecPtr->nmPrivate = 0;		gNMRecPtr->nmReserved = 0;		gNMRecPtr->nmMark = nil;		gNMRecPtr->nmIcon = nil;		gNMRecPtr->nmSound = nil;		gNMRecPtr->nmStr = nil;		gNMRecPtr->nmResp = NewNMUPP (NMResponseProc);		gNMRecPtr->nmRefCon = 0;	}	perChanInfoPtr = (PerChanInfoPtr)NewPtr (sizeof (PerChanInfo));	err = MemError ();	if (noErr !!= err) goto exit;	// Init basic per channel information	perChanInfoPtr->qLink = nil;	perChanInfoPtr->qType = 0;				// not used	perChanInfoPtr->stopping = 0;	#if DEBUG		perChanInfoPtr->magic = ''SANE'';	#endif		perChanInfoPtr->theParams = theParams;	// Have to remember the user''s callback function from the sound because	// we are going to overwrite it with our own callback function.	perChanInfoPtr->usersCallBack = chan->callBack;	// Set up the sound header for the bufferCmd that will be used to play	// the buffers passed in by the SndPlayDoubleBuffer call.	perChanInfoPtr->soundHeader.samplePtr = (Ptr)(theParams->dbhBufferPtr[0]->dbSoundData);	perChanInfoPtr->soundHeader.numChannels = theParams->dbhNumChannels;	perChanInfoPtr->soundHeader.sampleRate = theParams->dbhSampleRate;	perChanInfoPtr->soundHeader.loopStart = 0;	perChanInfoPtr->soundHeader.loopEnd = 0;	perChanInfoPtr->soundHeader.encode = cmpSH;	perChanInfoPtr->soundHeader.baseFrequency = kMiddleC;	perChanInfoPtr->soundHeader.numFrames = (unsigned long)theParams->dbhBufferPtr[0]->dbNumFrames;	//	perChanInfoPtr->soundHeader.AIFFSampleRate = 0;				// unused	perChanInfoPtr->soundHeader.markerChunk = nil;	perChanInfoPtr->soundHeader.futureUse2 = nil;	perChanInfoPtr->soundHeader.stateVars = nil;	perChanInfoPtr->soundHeader.leftOverSamples = nil;	perChanInfoPtr->soundHeader.compressionID = theParams->dbhCompressionID;	perChanInfoPtr->soundHeader.packetSize = (unsigned short)theParams->dbhPacketSize;	perChanInfoPtr->soundHeader.snthID = 0;	perChanInfoPtr->soundHeader.sampleSize = (unsigned short)theParams->dbhSampleSize;	perChanInfoPtr->soundHeader.sampleArea[0] = 0;	// Is the sound compressed?  If so, we need to treat theParams as a SndDoubleBufferHeader2Ptr.	if (0 !!= theParams->dbhCompressionID) {		// Sound is compressed		err = GetCompressionInfo (theParams->dbhCompressionID,								((SndDoubleBufferHeader2Ptr)theParams)->dbhFormat,								theParams->dbhNumChannels,								theParams->dbhSampleSize,								&compInfo);		if (noErr !!= err) goto exitDispose;		perChanInfoPtr->soundHeader.format = compInfo.format;	} else {		// Sound is not compressed		perChanInfoPtr->soundHeader.format = kSoundNotCompressed;	}	playCmd.cmd = bufferCmd;	playCmd.param1 = 0;							// unused	playCmd.param2 = (long)&perChanInfoPtr->soundHeader;	callBack.cmd = callBackCmd;	callBack.param1 = 0;						// which buffer to fill, 0 buffer, 1, 0, ...	callBack.param2 = (long)perChanInfoPtr;	// Install our callback function pointer straight into the sound channel structure	if (nil == gCarbonSndPlayDoubleBufferCallBackUPP) {		gCarbonSndPlayDoubleBufferCallBackUPP = NewSndCallBackUPP(CarbonSndPlayDoubleBufferCallBackProc);	}	chan->callBack = gCarbonSndPlayDoubleBufferCallBackUPP;#if UNNECESSARY_FOR_SQUEAK	if (gCarbonSndPlayDoubleBufferCleanUpUPP == nil) {			gCarbonSndPlayDoubleBufferCleanUpUPP = NewSndCallBackProc (CarbonSndPlayDoubleBufferCleanUpProc);	}#endif	err = SndDoCommand (chan, &playCmd, true);	if (noErr !!= err) goto exitDispose;	err = SndDoCommand (chan, &callBack, true);	if (noErr !!= err) goto exitDispose;exit:	return err;exitDispose:	if (nil !!= perChanInfoPtr)		DisposePtr ((Ptr)perChanInfoPtr);	goto exit;}#if UNNECESSARY_FOR_SQUEAKstatic pascal void	CarbonSndPlayDoubleBufferCleanUpProc(								SndChannelPtr theChannel, SndCommand * theCallBackCmd){	PerChanInfoPtr	perChanInfoPtr;	perChanInfoPtr = (PerChanInfoPtr)(theCallBackCmd->param2);	#if DEBUG		if (perChanInfoPtr->magic !!= ''SANE'') DebugStr("\pBAD in CarbonSndPlayDoubleBufferCleanUpProc");	#endif	// Put our per channel data on the free queue so we can clean up later	Enqueue ((QElemPtr)perChanInfoPtr, gFreeList);	// Have to install our Notification Manager routine so that we can clean up the gFreeList	if (!! OTAtomicSetBit (&gNMRecBusy, 0)) {		NMInstall (gNMRecPtr);	}	// Have to put the user''s callback proc back so they get called when the next buffer finishes	theChannel->callBack = perChanInfoPtr->usersCallBack;}#endifstatic pascal void	CarbonSndPlayDoubleBufferCallBackProc (SndChannelPtr theChannel, SndCommand * theCallBackCmd) {	SndDoubleBufferHeaderPtr		theParams;	SndDoubleBufferPtr				emptyBuf;	SndDoubleBufferPtr				nextBuf;	PerChanInfoPtr					perChanInfoPtr;	SndCommand						playCmd;	perChanInfoPtr = (PerChanInfoPtr)(theCallBackCmd->param2);	#if DEBUG		if (perChanInfoPtr->magic !!= ''SANE'') DebugStr("\pBAD in CarbonSndPlayDoubleBufferCallBackProc");	#endif	if (true == perChanInfoPtr->stopping) goto exit;	theParams = perChanInfoPtr->theParams;	// The buffer that just played and needs to be filled	emptyBuf = theParams->dbhBufferPtr[theCallBackCmd->param1];	// Clear the ready flag	emptyBuf->dbFlags ^= dbBufferReady;	// This is the buffer to play now	nextBuf = theParams->dbhBufferPtr[!!theCallBackCmd->param1];	// Check to see if it is ready, or if we have to wait a bit	if (nextBuf->dbFlags & dbBufferReady) {		perChanInfoPtr->soundHeader.numFrames = (unsigned long)nextBuf->dbNumFrames;		perChanInfoPtr->soundHeader.samplePtr = (Ptr)(nextBuf->dbSoundData);		// Flip the bit telling us which buffer is next		theCallBackCmd->param1 = !!theCallBackCmd->param1;		// If this isn''t the last buffer, call the user''s fill routine		if (!!(nextBuf->dbFlags & dbLastBuffer)) {				// Declare a function pointer to the user''s double back proc				void (*doubleBackProc)(SndChannel*, SndDoubleBuffer*);				// Call user''s double back proc				doubleBackProc = (void*)DoubleBack;				(*doubleBackProc) (theChannel, emptyBuf);		} else {			// Call our clean up proc when the last buffer finishes			theChannel->callBack = gCarbonSndPlayDoubleBufferCleanUpUPP;		}	} else {		// We have to wait for the buffer to become ready.		// The real SndPlayDoubleBuffer would play a short bit of silence waiting for		// the user to read the audio from disk, so that''s what we do here.		#if DEBUG			DebugStr ("\p buffer is not ready!!");		#endif		// Play a short section of silence so that we can check the ready flag again		if (theParams->dbhSampleSize == 8) {			perChanInfoPtr->soundHeader.numFrames = (UInt32)(kBufSize / theParams->dbhNumChannels);			perChanInfoPtr->soundHeader.samplePtr = gSilenceOnes;		} else {			perChanInfoPtr->soundHeader.numFrames = (UInt32)(kBufSize / (theParams->dbhNumChannels * (theParams->dbhSampleSize / 8)));			perChanInfoPtr->soundHeader.samplePtr = gSilenceTwos;		}	}	// Insert our callback command	InsertSndDoCommand (theChannel, theCallBackCmd);	// Play the next buffer	playCmd.cmd = bufferCmd;	playCmd.param1 = 0;	playCmd.param2 = (long)&(perChanInfoPtr->soundHeader);	InsertSndDoCommand (theChannel, &playCmd);exit:	return;}static void	InsertSndDoCommand (SndChannelPtr chan, SndCommand * newCmd) {	if (-1 == chan->qHead) {		chan->qHead = chan->qTail;	}	if (1 <= chan->qHead) {		chan->qHead--;	} else {		chan->qHead = chan->qTail;	}	chan->queue[chan->qHead] = *newCmd;}static pascal void NMResponseProc (NMRecPtr nmReqPtr) {	PerChanInfoPtr					perChanInfoPtr;	OSErr							err;	NMRemove (nmReqPtr);	gNMRecBusy = false;	do {		perChanInfoPtr = (PerChanInfoPtr)gFreeList->qHead;		if (nil !!= perChanInfoPtr) {			err = Dequeue ((QElemPtr)perChanInfoPtr, gFreeList);			if (noErr == err) {				DisposePtr ((Ptr)perChanInfoPtr);			}		}	} while (nil !!= perChanInfoPtr && noErr == err);}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/1/2001 23:45'!macWindowFile	^ '#include "sq.h"#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include <sound.h>#include <Math64.h>#include <cstddef>#include <processes.h>#include <OpenTransport.h>#include <stddef.h>/*** Compilation Options:**	define PLUGIN		to compile code for Netscape or IE Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE//#define IHAVENOHEAD//Aug 7th 2000,JMM Added logic for interrupt driven dispatching//Sept 1st 2000, JMM fix problem with modifier information being passed back incorrectly.//Sept 1st 2000, JMM use floating point for time versus 64bit math (faster!!)//Sept 1st 2000, JMM watch mouse movement foreground only, ignore when squeak in background.//Sept 18th 2000, JMM fix to cmpSize //Sept 19th 2000, JMM Sept 1st fix to keyboard modifier info broke cmd shift//Sept 27 2000, JMM fix to documentPath//Nov 13 2000, JMM logic to read/write image from VM. //Nov 22 2000, JMM Bob Arning found a bug with the duplicate mouse event logic (we were altering the event then recording the altered value)//Nov 30 2000, JMM Use Open Transport clock versus upTime, solves some issues for jitter and it''s faster//Dec 5th 2000, JMM poll 60 times a second... do event polling via checkForInterrupts and drive semaphore//Dec 6th 2000, JMM added logic to interface with power manger (1997 was there but dropped..., back again for ibooks)//Jan 14th 2001, KG Did some carbon porting.#if TARGET_API_MAC_CARBON    #define EnableMenuItemCarbon(m1,v1)  EnableMenuItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableMenuItem(m1,v1);#else    #ifndef NewAEEventHandlerUPP    	#define NewAEEventHandlerUPP NewAEEventHandlerProc     #endif    #define EnableMenuItemCarbon(m1,v1)  EnableItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableItem(m1,v1);        inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}          inline BitMap *GetQDGlobalsScreenBits(BitMap *bm){*bm = qd.screenBits; return &qd.screenBits; }        inline BitMap * GetPortBitMapForCopyBits (CGrafPtr w) { return &((GrafPtr)w)->portBits;}        inline pascal long InvalWindowRect(WindowRef  window,  const Rect * bounds) {InvalRect (bounds);}#endif/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/* The following prototype is missing from the CW11 header files: */pascal void ExitToShell(void);/*** Variables -- Imported from Browser Plugin Module ***/#ifdef PLUGINextern int pluginArgCount;extern char *pluginArgName[100];extern char *pluginArgValue[100];#endif/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image file */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document file */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;OTTimeStamp     timeStart;Boolean         gTapPowerManager=false;Boolean         gDisablePowerManager=false;const long      gDisableIdleTickCount=60*10;long            gDisableIdleTickLimit=0;/*** Variables -- Event Recording ***/#define MAX_EVENT_BUFFER 1024int inputSemaphoreIndex = 0;/* if non-zero the event semaphore index */sqInputEvent eventBuffer[MAX_EVENT_BUFFER];int eventBufferGet = 0;int eventBufferPut = 0;/* declaration of the event message hook */typedef int (*eventMessageHook)(EventRecord* event);eventMessageHook messageHook = NULL;eventMessageHook postMessageHook = NULL;#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */int cachedButtonState = 0;	/* buffered mouse button and modifier state for							   last mouse click even if button has since gone up;							   this cache is kept until the next time ioGetButtonState()							   is called to avoid missing short clicks */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath);void MenuBarHide(void);void MenuBarRestore(void);int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID);int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short VolumeNumber,long directoryID);void SqueakTerminate();void ExitCleanup();int calculateStartLocationForImage();extern int dropInit(void);Boolean RunningOnCarbonX(void);OSStatus GetApplicationDirectory(short *vRefNum, long *dirID);pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath);pascal	OSErr	FSpGetFullPath(const FSSpec *spec,							   short *fullPathLength,							   Handle *fullPath);pascal OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec);pascal	OSErr	FSMakeFSSpecCompat(short vRefNum,								   long dirID,								   ConstStr255Param fileName,								   FSSpec *spec);/* event capture */sqInputEvent *nextEventPut(void);int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);int recordMouseEvent(EventRecord *theEvent, int theButtonState);int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType);int recordKeyboardEvent(EventRecord *theEvent, int keyType);int MouseModifierState(EventRecord *theEvent);WindowPtr getSTWindow(void);int setMessageHook(eventMessageHook theHook);int setPostMessageHook(eventMessageHook theHook);void PowerMgrCheck(void);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);static pascal OSErr HandleOpenDocEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);static pascal OSErr HandlePrintDocEvent(const AEDescList *aevt, AEDescList *reply, long refCon);static pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerUPP(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerUPP(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerUPP(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */    int                 checkValueForEmbeddedImage;    OSErr               err;	FSSpec		        fileSpec;	Str32                name; 	/* record path to VM''s home folder */	short vRefNum;	long dirID;	// Get the Volume ref and Directory id of the Application''s directory.    err = GetApplicationDirectory(&vRefNum, &dirID);    if (err !!= noErr) return err;	// Convert that to a full path string.	PathToWorkingDir(vmPath, VMPATH_SIZE, vRefNum, dirID);	checkValueForEmbeddedImage = calculateStartLocationForImage();	if (checkValueForEmbeddedImage == 0) {	    /* use default image name in same directory as the VM */	    strcpy(shortImageName, "squeak.image");	    return noErr;	}	if (err !!= noErr) {		strcpy(shortImageName, "squeak.image");	    return noErr;	}		CopyPascalStringToC(name,shortImageName);	StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);    return noErr;}pascal OSErr HandleOpenDocEvent(const AEDescList *aevt, AEDescList *reply, long refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	FInfo		finderInformation;	char 		tempShortName[SHORTIMAGE_NAME_SIZE + 1];		short vRefNum;	long dirID;		reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */    err = GetApplicationDirectory(&vRefNum, &dirID);    if (err !!= noErr) return err;    	PathToWorkingDir(vmPath, VMPATH_SIZE, vRefNum, dirID);		/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) return errAEEventNotHandled;;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;		if (shortImageName[0] !!= 0) {#ifdef IHAVENOHEAD		/* get image name */		err = AEGetNthPtr(&fileList, 1, typeFSS,						  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);		if (err) goto done;				err = FSpGetFInfo(&fileSpec,&finderInformation);		if (err) goto done;					CopyPascalStringToC(fileSpec.name,tempShortName);		if (finderInformation.fdType == ''SOBJ'') {			StoreFullPathForLocalNameInto(tempShortName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		}#endif		goto done;	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;		err = FSpGetFInfo(&fileSpec,&finderInformation);	if (err) goto done;			CopyPascalStringToC(fileSpec.name,shortImageName);	if (!!(IsImageName(shortImageName) || finderInformation.fdType == ''STim'') || finderInformation.fdType == ''STch'') {		/* record the document name, but run the default image in VM directory */		if (finderInformation.fdType == ''SOBJ'')			StoreFullPathForLocalNameInto(shortImageName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowRef		wp;	int				isDeskAccessory;	wp = FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = GetWindowKind(wp) < 0;	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableMenuItemCarbon(editMenu, 1);		EnableMenuItemCarbon(editMenu, 3);		EnableMenuItemCarbon(editMenu, 4);		EnableMenuItemCarbon(editMenu, 5);		EnableMenuItemCarbon(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableMenuItemCarbon(editMenu, 1);		DisableMenuItemCarbon(editMenu, 3);		DisableMenuItemCarbon(editMenu, 4);		DisableMenuItemCarbon(editMenu, 5);		DisableMenuItemCarbon(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	static EventRecord oldEvent;	int				ok;	Rect    bounds;	ok = WaitNextEvent(everyEvent, &theEvent,0,null);	if((messageHook) && (messageHook(&theEvent))) {        return ok;    }	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case mouseUp:				if(inputSemaphoreIndex) {					recordMouseEvent(&theEvent,MouseModifierState(&theEvent));    				if(postMessageHook) postMessageHook(&theEvent);					return false;				}				recordModifierButtons(&theEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyDown);					break;				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;						case keyUp:				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyUp);				}			break;#ifndef IHAVENOHEAD			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				GetPortBounds(GetWindowPort(stWindow),&bounds);				InvalWindowRect(stWindow,&bounds);			break;#endif			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;						case osEvt: 				if (((theEvent.message>>24)& 0xFF) == suspendResumeMessage) {									//JMM July 4th 2000					//Fix for menu bar tabbing, thanks to Javier Diaz-Reinoso for pointing this out					//					if (fullScreenFlag) {						if ((theEvent.message & resumeFlag) == 0) {							MenuBarRestore();						}						else {							MenuBarHide();						}					}				}				break;		}	}	else {		if(inputSemaphoreIndex && windowActive && 		    !!((oldEvent.what == theEvent.what) &&  		    (oldEvent.message == theEvent.message) && 		    ((oldEvent.where.v == theEvent.where.v) && (oldEvent.where.h == theEvent.where.h)) && 		    (oldEvent.modifiers == theEvent.modifiers))) {    		oldEvent = theEvent; //JMM Nov 11th 2000 bug fix 			recordMouseEvent(&theEvent,MouseModifierState(&theEvent)); 		} 		else		 oldEvent = theEvent;	}	if(postMessageHook) postMessageHook(&theEvent); 	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);#if !!TARGET_API_MAC_CARBON			OpenDeskAcc(name);#endif 			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:#if !!TARGET_API_MAC_CARBON			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}#endif		break;	}}void HandleMouseDown(EventRecord *theEvent) {    BitMap      bmap;	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:#if !!TARGET_API_MAC_CARBON			SystemClick(theEvent, theWindow);#endif		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;#ifndef IHAVENOHEAD		case inDrag:			GetQDGlobalsScreenBits(&bmap);			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &bmap.bounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				if(inputSemaphoreIndex) {					recordMouseEvent(theEvent,MouseModifierState(theEvent));					break;				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;#endif	}}#if TARGET_API_MAC_CARBONvoid InitMacintosh(void) {	FlushEvents(everyEvent, 0);	InitCursor();}void MenuBarHide(void) { 	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */    menuBarRegion = (RgnHandle) 1;    HideMenuBar();}void MenuBarRestore(void) {	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */    ShowMenuBar();    menuBarRegion = nil;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {}void FreeClipboard(void) {}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;       	clipSize = clipboardSize(); 	charsToMove = (count < clipSize) ? count : clipSize;    err = GetScrapFlavorData(scrap,kScrapFlavorTypeText,(long *) &charsToMove,(char *) byteArrayIndex + startIndex);    if (err !!= noErr) {         FreeClipboard();        return 0;           }	return charsToMove;}int clipboardSize(void) {	long count;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;           err = GetScrapFlavorSize (scrap, kScrapFlavorTypeText, &count); 	if (err !!= noErr) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ScrapRef scrap;	OSErr err;	err = ClearCurrentScrap();    err = GetCurrentScrap (&scrap);	err = PutScrapFlavor ( scrap, kScrapFlavorTypeText, kScrapFlavorMaskNone , count,  (const void *) (byteArrayIndex + startIndex));}#else void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */  	WindowPtr win; 		if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	LMSetMBarHeight(menuBarHeight);		win = FrontWindow();	if (win) {		CalcVis(win);		CalcVisBehind(win,menuBarRegion);	}	HiliteMenu(0);	DisposeRgn(menuBarRegion);		menuBarRegion = nil;	DrawMenuBar();}/*** Clipboard Support (text only for now) ***/Handle			clipboardBuffer = nil;void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;    //JMM locking    HLock(clipboardBuffer); 	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}    HUnlock(clipboardBuffer); 	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}#endifvoid SetUpMenus(void) {	long decideOnQuitMenu;		InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();#if TARGET_API_MAC_CARBON    Gestalt( gestaltMenuMgrAttr, &decideOnQuitMenu);    if (!!(decideOnQuitMenu & gestaltMenuMgrAquaLayoutMask))	        AppendMenu(fileMenu, "\pQuit");#else	AppendResMenu(appleMenu, ''DRVR'');    AppendMenu(fileMenu, "\pQuit");#endif 	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};#ifndef IHAVENOHEAD	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, false, 0);#endif}void SetWindowTitle(char *title) {    Str255 tempTitle;	CopyCStringToPascal(title,tempTitle);#ifndef IHAVENOHEAD	SetWTitle(stWindow, tempTitle);#endif}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int asciiChar, modifierBits, keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = modifierMap[(theEvent->modifiers >> 8) & 0x1F];	if ((modifierBits & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	keystate = (modifierBits << 8) | asciiChar;	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState = MouseModifierState(theEvent);	cachedButtonState = cachedButtonState | buttonState;}int MouseModifierState(EventRecord *theEvent) {	int stButtons;	stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {  /* is false if button is down */		stButtons = 4;		/* red button by default */		if ((theEvent->modifiers & optionKey) !!= 0) {			stButtons = 2;	/* yellow button if option down */		}		if ((theEvent->modifiers & cmdKey) !!= 0) {			stButtons = 1;	/* blue button if command down */		}	} 	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	return ((modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7));}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordMouseEvent(EventRecord *theEvent, int theButtonState) {	sqMouseEvent *evt;		evt = (sqMouseEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeMouse;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	/* then the buttons */	evt->buttons = theButtonState & 0x07;	/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType) {	sqDragDropFilesEvent *evt;		evt = (sqDragDropFilesEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeDragDropFiles;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	evt->numFiles = numberOfItems;	evt->dragType = dragType;		/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordKeyboardEvent(EventRecord *theEvent, int keyType) {	int stButtons = 0;	int asciiChar, modifierBits;	sqKeyboardEvent *evt, *extra;	evt = (sqKeyboardEvent*) nextEventPut();	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = MouseModifierState(theEvent); //Capture mouse/option states	if (((modifierBits >> 3) & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	/* first the basics */	evt->type = EventTypeKeyboard;	evt->timeStamp = ioMSecs();	/* now the key code */	/* press code must differentiate */	evt->charCode = (theEvent->message & keyCodeMask) >> 8;	evt->pressCode = keyType;	evt->modifiers = modifierBits >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;	/* generate extra character event */	if (keyType == EventKeyDown) {		extra = (sqKeyboardEvent*)nextEventPut();		*extra = *evt;		extra->charCode = asciiChar;		extra->pressCode = EventKeyChar;	}//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}static sqInputEvent *nextEventPut(void) {	sqInputEvent *evt;	evt = eventBuffer + eventBufferPut;	eventBufferPut = (eventBufferPut + 1) % MAX_EVENT_BUFFER;	if (eventBufferGet == eventBufferPut) {		/* buffer overflow; drop the last event */		eventBufferGet = (eventBufferGet + 1) % MAX_EVENT_BUFFER;	}	return evt;}int ioSetInputSemaphore(int semaIndex) {	inputSemaphoreIndex = semaIndex;	return 1;}int ioGetNextEvent(sqInputEvent *evt) {	if (eventBufferGet == eventBufferPut) {		ioProcessEvents();	}	if (eventBufferGet == eventBufferPut) 		return false;	*evt = eventBuffer[eventBufferGet];	eventBufferGet = (eventBufferGet+1) % MAX_EVENT_BUFFER;	return true;}/*** Mac Specific External Primitive Support ***//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName) {	char pluginDirPath[1000];	CFragConnectionID libHandle;	Ptr mainAddr;	Str255 errorMsg,tempPluginName;	OSErr err;        	/* first, look in the "<Squeak VM directory>Plugins" directory for the library */	strcpy(pluginDirPath, vmPath);	#ifdef PLUGIN	strcat(pluginDirPath, ":Plugins");#else	strcat(pluginDirPath, "Plugins");#endif 	        libHandle = LoadLibViaPath(pluginName, pluginDirPath);	if (libHandle !!= nil) return (int) libHandle;#ifndef PLUGIN	/* second, look directly in Squeak VM directory for the library */	libHandle = LoadLibViaPath(pluginName, vmPath);	if (libHandle !!= nil) return (int) libHandle;        /* Lastly look for it as a shared import library */        CopyCStringToPascal(pluginName,tempPluginName);    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kLoadCFrag, &libHandle, &mainAddr, errorMsg);	if (err == noErr) 	    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kFindCFrag, &libHandle, &mainAddr, errorMsg);	if (libHandle !!= nil) return (int) libHandle;#endif    	return nil;}/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle) {	CFragSymbolClass ignored;	Ptr functionPtr = 0;	OSErr err;    Str255 tempLookupName;    	if (!!moduleHandle) return 0;	/* get the address of the desired primitive function */	CopyCStringToPascal(lookupName,tempLookupName);	err = FindSymbol(		(CFragConnectionID) moduleHandle, (unsigned char *) tempLookupName,		&functionPtr, &ignored);	if (err) return 0;	return (int) functionPtr;}/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle) {	CFragConnectionID libHandle;	OSErr err;	if (!!moduleHandle) return 0;	libHandle = (CFragConnectionID) moduleHandle;	err = CloseConnection(&libHandle);	return 0;}CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath) {	short 				vRefNum;	long				ignore;	CInfoPBRec 			pb;	FSSpec				fileSpec;	Str255				problemLibName,fileSpecName,tempPlugindirPath;    Ptr					junk;	CFragConnectionID	libHandle = 0;	OSErr				err = noErr;	/* get the default volume */	HGetVol( nil, &vRefNum, &ignore);	/* get the directory ID for the given path */	CopyCStringToPascal(pluginDirPath,tempPlugindirPath);	pb.hFileInfo.ioNamePtr = tempPlugindirPath;	pb.hFileInfo.ioVRefNum = 0;  /* use the default volume */	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	err = PBGetCatInfoSync(&pb);	if (err) return nil; /* bad plugin directory path */	/* make a file spec for the given file name in the plugin directory */	CopyCStringToPascal(libName,fileSpecName);	FSMakeFSSpec(vRefNum,pb.hFileInfo.ioDirID,fileSpecName,&fileSpec);	err = GetDiskFragment(		&fileSpec, 0, kCFragGoesToEOF, nil, kLoadCFrag, &libHandle, &junk, problemLibName);	if (err) return nil;	return libHandle;}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}#ifndef PLUGINint ioExit(void) {	ioShutdownAllModules();	MenuBarRestore();	ExitToShell();}#endifint ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	if ((cachedButtonState & 0x7) !!= 0) {		int result = cachedButtonState;		cachedButtonState = 0;  /* clear cached button state */		return result;	}	cachedButtonState = 0;  /* clear cached button state */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioHasDisplayDepth(int depth) {	/* Return true if this platform supports the given color display depth. */	switch (depth) {	case 1:	case 2:	case 4:	case 8:	case 16:	case 32:		return true;	}	return false;}int ioMicroMSecsExpensive(void);int ioMicroMSecsExpensive(void) {	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}#if TARGET_CPU_PPCint ioMicroMSecs(void) {	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. */		register long check;		if((Ptr)OTElapsedMilliseconds!!=(Ptr)kUnresolvedCFragSymbolAddress){    	check = OTElapsedMilliseconds(&timeStart);    	if (check !!= -1)     	    return check;    	OTGetTimeStamp(&timeStart);	    return ioMicroMSecs();	}else {	    return ioMicroMSecsExpensive();	}}#elseint ioMicroMSecs(void) {    return ioMicroMSecsExpensive();}#endifint ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	return ioMicroMSecs();}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	const int nextPollOffsetCheck = CLOCKS_PER_SEC/60, nextPowerCheckOffset=CLOCKS_PER_SEC/2; 	static clock_t nextPollTick = 0, nextPowerCheck;	long    clockTime;#ifndef PLUGIN	if (clock() >= nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		        clockTime = clock();                if (gDisablePowerManager && gTapPowerManager) {            if (clockTime > gDisableIdleTickLimit)                gDisableIdleTickLimit = IdleUpdate() + gDisableIdleTickCount;                #if TARGET_CPU_PPC            if (clockTime > nextPowerCheck) {                 UpdateSystemActivity(UsrActivity);                 nextPowerCheck = clockTime + nextPowerCheckOffset;            }#endif        }        		/* wait a while before trying again */		nextPollTick = clockTime + nextPollOffsetCheck;	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * ioProcessEvents(), which gives other applications a chance to run.	 */       microSeconds;	ioProcessEvents();  /* process all pending events */}#ifndef PLUGINint ioScreenSize(void) {	int w = 10, h = 10;    Rect portRect;    #ifndef IHAVENOHEAD	if (stWindow !!= nil) {        GetPortBounds(GetWindowPort(stWindow),&portRect);		w =  portRect.right -  portRect.left;		h =  portRect.bottom - portRect.top;	}#endif	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}#endifint ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag) {	/* Set the window to the given width, height, and color depth. Put the window	   into the full screen mode specified by fullscreenFlag. */	/* Note: Changing display depth is not yet, and may never be, implemented	   on the Macintosh, where (a) it is considered inappropriate and (b) it may	   not even be a well-defined operation if the Squeak window spans several	   displays (which display''s depth should be changed?). */	depth;#ifndef IHAVENOHEAD	ioSetFullScreen(fullscreenFlag);	if (!!fullscreenFlag) {		SizeWindow(stWindow, width, height, true);	}#endif}#ifndef PLUGINint ioSetFullScreen(int fullScreen) {	Rect screen,portRect;	BitMap bmap;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;				GetQDGlobalsScreenBits(&bmap);    screen = bmap.bounds;    	if (fullScreen) {		MenuBarHide();		GetPortBounds(GetWindowPort(stWindow),&portRect);		oldWidth =  portRect.right -  portRect.left;		oldHeight =  portRect.bottom -  portRect.top;		width  = screen.right - screen.left; 		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}#endifint ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;    if (depth<=8) { /*Duane Maxwell <dmaxwell@exobox.com> fix cmpSize Sept 18,2000 */    	(*stPixMap)->cmpSize = depth;    	(*stPixMap)->cmpCount = 1;    } else if (depth==16) {    	(*stPixMap)->cmpSize = 5;    	(*stPixMap)->cmpCount = 3;    } else if (depth==32) {    	(*stPixMap)->cmpSize = 8;    	(*stPixMap)->cmpCount = 3;    }	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPortWindowPort(stWindow);	CopyBits((BitMap *) *stPixMap, GetPortBitMapForCopyBits(GetWindowPort(stWindow)), &srcRect, &dstRect, srcCopy, maskRect);#if TARGET_API_MAC_CARBON	QDFlushPortBuffer (GetWindowPort(stWindow), maskRect);#endif	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short volumeNumber,long directoryID) {	int offset, sz, i;	offset = PathToWorkingDir(fullName, length, volumeNumber, directoryID);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*****************************************************************************************GetApplicationDirectoryGet the volume reference number and directory id of this application.Code taken from Apple:	Technical Q&As: FL 14 - Finding your application''s directory (19-June-2000)Karl Goiser 14/01/01*****************************************************************************************/        /* GetApplicationDirectory returns the volume reference number        and directory ID for the current application''s directory. */    OSStatus GetApplicationDirectory(short *vRefNum, long *dirID) {        ProcessSerialNumber PSN;        ProcessInfoRec pinfo;        FSSpec pspec;        OSStatus err;            /* valid parameters */        if (vRefNum == NULL || dirID == NULL) return paramErr;            /* set up process serial number */        PSN.highLongOfPSN = 0;        PSN.lowLongOfPSN = kCurrentProcess;            /* set up info block */        pinfo.processInfoLength = sizeof(pinfo);        pinfo.processName = NULL;        pinfo.processAppSpec = &pspec;            /* grab the vrefnum and directory */        err = GetProcessInformation(&PSN, &pinfo);        if (err == noErr) {            *vRefNum = pspec.vRefNum;            *dirID = pspec.parID;        }        return err;    }/*** Initializing the path to Working Dir ***/int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	short	fullPathLength;	Handle	fullPathHandle;	if (GetFullPath(volumeNumber, directoryID, nil, &fullPathLength, &fullPathHandle) !!= noErr) {		//Some sort of random guff for failure:		pathName[0] = 1;		pathName[1] = (char)":";		return 1;	}	strncpy((char *) pathName, (char *) *fullPathHandle, fullPathLength);	DisposeHandle(fullPathHandle);	return fullPathLength;}pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath){	OSErr		result;	FSSpec		spec;		*fullPathLength = 0;	*fullPath = NULL;		result = FSMakeFSSpecCompat(vRefNum, dirID, name, &spec);	if ( (result == noErr) || (result == fnfErr) )	{		result = FSpGetFullPath(&spec, fullPathLength, fullPath);	}		return ( result );}pascal	OSErr	FSpGetFullPath(const FSSpec *spec,							   short *fullPathLength,							   Handle *fullPath){	OSErr		result;	OSErr		realResult;	FSSpec		tempSpec;	CInfoPBRec	pb;		*fullPathLength = 0;	*fullPath = NULL;			/* Default to noErr */	realResult = result = noErr;	#if 0//The following code doesn''t seem to work in OS X, the BloackMoveData crashes the// machine, the the FSMakeFSSpecCompat works, so go figure...  KG 4/1/01	/* work around Nav Services "bug" (it returns invalid FSSpecs with empty names) */	if ( spec->name[0] == 0 )	{		result = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, spec->name, &tempSpec);	}	else	{		/* Make a copy of the input FSSpec that can be modified */		BlockMoveData(spec, &tempSpec, sizeof(FSSpec));	}#endif 0	result = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, spec->name, &tempSpec);	if ( result == noErr )	{		if ( tempSpec.parID == fsRtParID )		{			/* The object is a volume */						/* Add a colon to make it a full pathname */			++tempSpec.name[0];			tempSpec.name[tempSpec.name[0]] = '':'';						/* We''re done */			result = PtrToHand(&tempSpec.name[1], fullPath, tempSpec.name[0]);			*fullPathLength = tempSpec.name[0];		}		else		{			/* The object isn''t a volume */						/* Is the object a file or a directory? */			pb.dirInfo.ioNamePtr = tempSpec.name;			pb.dirInfo.ioVRefNum = tempSpec.vRefNum;			pb.dirInfo.ioDrDirID = tempSpec.parID;			pb.dirInfo.ioFDirIndex = 0;			result = PBGetCatInfoSync(&pb);			// Allow file/directory name at end of path to not exist.			realResult = result;			if ( (result == noErr) || (result == fnfErr) )			{				/* if the object is a directory, append a colon so full pathname ends with colon */				if ( (result == noErr) && (pb.hFileInfo.ioFlAttrib & kioFlAttribDirMask) !!= 0 )				{					++tempSpec.name[0];					tempSpec.name[tempSpec.name[0]] = '':'';				}								/* Put the object name in first */				result = PtrToHand(&tempSpec.name[1], fullPath, tempSpec.name[0]);				*fullPathLength = tempSpec.name[0];				if ( result == noErr )				{					/* Get the ancestor directory names */					pb.dirInfo.ioNamePtr = tempSpec.name;					pb.dirInfo.ioVRefNum = tempSpec.vRefNum;					pb.dirInfo.ioDrParID = tempSpec.parID;					do	/* loop until we have an error or find the root directory */					{						pb.dirInfo.ioFDirIndex = -1;						pb.dirInfo.ioDrDirID = pb.dirInfo.ioDrParID;						result = PBGetCatInfoSync(&pb);						if ( result == noErr )						{							/* Append colon to directory name */							++tempSpec.name[0];							tempSpec.name[tempSpec.name[0]] = '':'';														/* Add directory name to beginning of fullPath */							(void) Munger(*fullPath, 0, NULL, 0, &tempSpec.name[1], tempSpec.name[0]);							*fullPathLength += tempSpec.name[0];							result = MemError();						}					} while ( (result == noErr) && (pb.dirInfo.ioDrDirID !!= fsRtDirID) );				}			}		}	}		if ( result == noErr )	{		/* Return the length *////		*fullPathLength = GetHandleSize(*fullPath);		result = realResult;	// return realResult in case it was fnfErr	}	else	{		/* Dispose of the handle and return NULL and zero length */		if ( *fullPath !!= NULL )		{			DisposeHandle(*fullPath);		}		*fullPath = NULL;		*fullPathLength = 0;	}		return ( result );}/*****************************************************************************/pascal OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec){	AliasHandle	alias;	OSErr		result;	Boolean		wasChanged;	Str32		nullString;		/* Create a minimal alias from the full pathname */	nullString[0] = 0;	/* null string to indicate no zone or server name */	result = NewAliasMinimalFromFullPath(fullPathLength, fullPath, nullString, nullString, &alias);	if ( result == noErr )	{		/* Let the Alias Manager resolve the alias. */		result = ResolveAlias(NULL, alias, spec, &wasChanged);				/* work around Alias Mgr sloppy volume matching bug */		if ( spec->vRefNum == 0 )		{			/* invalidate wrong FSSpec */			spec->parID = 0;			spec->name[0] =  0;			result = nsvErr;		}		DisposeHandle((Handle)alias);	/* Free up memory used */	}	return ( result );}/*****************************************************************************//***	File Manager FSp calls*//*****************************************************************************/pascal	OSErr	FSMakeFSSpecCompat(short vRefNum,								   long dirID,								   ConstStr255Param fileName,								   FSSpec *spec){	OSErr	result;		/* Let the file system create the FSSpec if it can since it does the job */	/* much more efficiently than I can. */	result = FSMakeFSSpec(vRefNum, dirID, fileName, spec);	/* Fix a bug in Macintosh PC Exchange''s MakeFSSpec code where 0 is */	/* returned in the parID field when making an FSSpec to the volume''s */	/* root directory by passing a full pathname in MakeFSSpec''s */	/* fileName parameter. Fixed in Mac OS 8.1 */	if ( (result == noErr) && (spec->parID == 0) )		spec->parID = fsRtParID;	return ( result );}int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		return pathNameSize;	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = '':'';  /* insert delimitor */	return pathNameSize + offset;}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	fullImagePath;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;#if TARGET_CPU_PPC	if((Ptr)OTGetTimeStamp!!=(Ptr)kUnresolvedCFragSymbolAddress) 	    OTGetTimeStamp(&timeStart);#endif	PowerMgrCheck();	SetUpClipboard();	SetUpPixmap();	dropInit();}int plugInShutdown(void) {	ioShutdownAllModules();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}#ifndef PLUGINint plugInAllowAccessToFilePath(char *pathString, int pathStringLength) {  /* Grant permission to all files. */	pathString; pathStringLength;	return true;}#endif/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	/* Note: 1.3x images will try to read the image as a document because they	   expect attribute #1 to be the document name. A 1.3x image can be patched	   using a VM of 2.6 or earlier. */	if (id == 1) return imageName;	if (id == 2) return documentName;#ifdef PLUGIN	/* When running in browser, return the EMBED tag info */	if ((id > 2) && (id <= (2 + (2 * pluginArgCount)))) {		int i = id - 3;		if ((i & 1) == 0) {  /* i is even */			return pluginArgName[i/2];		} else {			return pluginArgValue[i/2];		}	}#endif	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	Str255 tempPascalFileName;     FInfo fileInfo;	CopyCStringToPascal(fileName,tempPascalFileName);	if (strchr(mode, ''w'') !!= null) 	    err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);	 else	    err = HOpenDF(0,0,tempPascalFileName,fsRdPerm, &fRefNum);	    	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = HCreate(0,0,tempPascalFileName,  ''FAST'', ''STim'');		if (err2 == 0) {			err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);		}	}	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {        err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);        if (err !!= noErr) return 0; //This should not happen                //On the mac we start at location 0 if this isn''t an VM            	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')){    		/* truncate non-VM file if opening in write mode */    		err = SetEOF(fRefNum, 0);    		if (err !!= 0) {    			FSClose(fRefNum);    			return null;    		}	    }	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}int calculateStartLocationForImage() { 	Handle cfrgResource;  	long	memberCount,i;	CFragResourceMember *target;	Str255 tempPascalFileName;	OSErr   err;    int     resFileRef;		cfrgResource = GetResource(kCFragResourceType,0); 	if (cfrgResource == nil || ResError() !!= noErr) { return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {        ReleaseResource(cfrgResource);	    return 0; //Need FAT to get counters right	}		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {					    ReleaseResource(cfrgResource);		    return target->offset;		}		target = NextCFragResourceMemberPtr(target); 	}    ReleaseResource(cfrgResource);	return 0;}int sqImageFileStartLocation(int fileRef, char *filename, int imageSize){    FInfo fileInfo;	Str255 tempPascalFileName;	OSErr   err;     int     resFileRef;	Handle  cfrgResource,newcfrgResource;  	UInt32	maxOffset=0,maxOffsetLength,targetOffset;	long    memberCount,i;	CFragResourceMember *target;      	CopyCStringToPascal(filename,tempPascalFileName);    err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);    if (err !!= noErr) return 0; //This should not happen        //On the mac we start at location 0 if this isn''t an VM    	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')) return 0;        //Ok we have an application file, open the resource part and attempt to find the crfg        resFileRef = HOpenResFile(0,0,tempPascalFileName,fsWrPerm);    if (resFileRef == -1) return 0;    	cfrgResource = GetResource(kCFragResourceType,0);	if (cfrgResource == nil || ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};  //Need FAT to get counters right		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {		    targetOffset = target->offset;		    target->length = imageSize;		    ChangedResource(cfrgResource);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		    UpdateResFile(resFileRef);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};             ReleaseResource(cfrgResource); 		    CloseResFile(resFileRef);			return targetOffset;		}		if (target->offset > maxOffset) {			maxOffset = target->offset;			maxOffsetLength = target->length;		}		target = NextCFragResourceMemberPtr(target);	}		//Ok at this point we need to alter the crfg to add the new tag for the image part		newcfrgResource = cfrgResource;	err = HandToHand(&newcfrgResource);	if (err !!= noErr || MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 	SetHandleSize(newcfrgResource,GetHandleSize(cfrgResource)+AlignToFour(kBaseCFragResourceMemberSize + 1));	if (MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		target = &((CFragResource *)(*newcfrgResource))->firstMember; 	for(i=0;i<memberCount;i++) {		target = NextCFragResourceMemberPtr(target); 	}    target->architecture = ''FAST'';    target->reservedA = 0;                  /* !! Must be zero!!*/    target->reservedB = 0;                  /* !! Must be zero!!*/    target->updateLevel = 0;    target->currentVersion = 0;    target->oldDefVersion = 0;    target->uUsage1.appStackSize = 0;    target->uUsage2.appSubdirID = 0;    target->uUsage2.libFlags = 0;    target->usage = kApplicationCFrag;    target->where = kDataForkCFragLocator;    target->offset = maxOffset + maxOffsetLength;    targetOffset = target->offset;    target->length = imageSize;    target->uWhere1.spaceID = 0;    target->extensionCount = 0;             /* The number of extensions beyond the name.*/    target->memberSize = AlignToFour(kBaseCFragResourceMemberSize + 1);   /* Size in bytes, includes all extensions.*/    target->name[0] = 0x00;	((CFragResource *)(*newcfrgResource))->memberCount = memberCount+1;	RemoveResource(cfrgResource);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  	AddResource(newcfrgResource,kCFragResourceType,0,nil);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     UpdateResFile(resFileRef);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     CloseResFile(resFileRef);    	return targetOffset;}#ifndef PLUGINvoid * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* Application allocates Squeak object heap memory from its own heap. */		minHeapSize;	return NewPtr(desiredHeapSize);;}#endifvoid PowerMgrCheck(void) {	long pmgrAttributes;		gTapPowerManager = false;	gDisablePowerManager = false;	if (!! Gestalt(gestaltPowerMgrAttr, &pmgrAttributes))		if ((pmgrAttributes & (1<<gestaltPMgrExists)) 		    && (pmgrAttributes & (1<<gestaltPMgrDispatchExists))		    && (PMSelectorCount() >= 0x24)) {		    gTapPowerManager = true;			gDisableIdleTickLimit = clock();		}}int ioDisablePowerManager(int disableIfNonZero) {    gDisablePowerManager = disableIfNonZero;}Boolean RunningOnCarbonX(void){    UInt32 response;        return (Gestalt(gestaltSystemVersion,                     (SInt32 *) &response) == noErr)                && (response >= 0x01000);}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	short vRefNum;	long dirID;	OSErr err;	InitMacintosh();	PowerMgrCheck();		SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	dropInit();	SetEventMask(everyEvent); // also get key up events	#if TARGET_CPU_PPC	if((Ptr)OTGetTimeStamp!!=(Ptr)kUnresolvedCFragSymbolAddress) 	    OTGetTimeStamp(&timeStart);#endif 	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		err = GetApplicationDirectory(&vRefNum, &dirID);		if (err !!= noErr) error("Could not obtain default directory");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 500000;	if (RunningOnCarbonX())	    availableMemory = 100*1024*1024 - reservedMemory;	else     	availableMemory = MaxBlock() - reservedMemory;		/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 50K to that.)	    	    JMM Note changed to 500 for Open Transport support on 68K machines	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSizeStartingAt(f, availableMemory, calculateStartLocationForImage());	sqImageFileClose(f);#ifndef IHAVENOHEAD	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);#endif	/* run Squeak */	interpret();}#endifvoid SqueakTerminate() {#ifdef PLUGIN	ExitCleanup();#else	ioShutdownAllModules();#endif}WindowPtr getSTWindow(void) {    return stWindow;}int setMessageHook(eventMessageHook theHook) {    messageHook = theHook;}int setPostMessageHook(eventMessageHook theHook) {    postMessageHook = theHook;}#if !!TARGET_API_MAC_CARBON////	CopyPascalStringToC converts the source pascal string to a destination//	C string as it copies. //void CopyPascalStringToC(ConstStr255Param src, char* dst){	if ( src !!= NULL )	{		short   length  = *src++;			while ( length > 0 ) 		{			*dst++ = *(char*)src++;			--length;		}	}	*dst = ''\0'';}////	CopyCStringToPascal converts the source C string to a destination//	pascal string as it copies. The dest string will//	be truncated to fit into an Str255 if necessary.//  If the C String pointer is NULL, the pascal string''s length is set to zero//void CopyCStringToPascal(const char* src, Str255 dst){	short 	length  = 0;		// handle case of overlapping strings	if ( (void*)src == (void*)dst )	{		unsigned char*		curdst = &dst[1];		unsigned char		thisChar;						thisChar = *(const unsigned char*)src++;		while ( thisChar !!= ''\0'' ) 		{			unsigned char	nextChar;						// use nextChar so we don''t overwrite what we are about to read			nextChar = *(const unsigned char*)src++;			*curdst++ = thisChar;			thisChar = nextChar;						if ( ++length >= 255 )				break;		}	}	else if ( src !!= NULL )	{		unsigned char*		curdst = &dst[1];		short 				overflow = 255;		// count down so test it loop is faster		register char		temp;			// Can''t do the K&R C thing of Òwhile (*s++ = *t++)Ó because it will copy trailing zero		// which might overrun pascal buffer.  Instead we use a temp variable.		while ( (temp = *src++) !!= 0 ) 		{			*(char*)curdst++ = temp;							if ( --overflow <= 0 )				break;		}		length = 255 - overflow;	}	dst[0] = length;}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/1/2001 23:37'!squeakHeaderFile	^'#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#include "sqVirtualMachine.h"#define true 1#define false 0#define null 0  /* using "null" because nil is predefined in Think C *//* pluggable primitives macros *//* Note: All pluggable primitives are defined as	EXPORT(int) somePrimitive(void)   If the platform requires special declaration modifiers   the EXPORT macro can be redefined*/#define EXPORT(returnType) returnType/* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqImageFileStartLocation(fileRef, fileName, size)  0#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* platform-dependent memory size adjustment macro *//* Note: This macro can be redefined to allows platforms with a   fixed application memory partition (notably, the Macintosh)   to reserve extra C heap memory for special applications that need   it (e.g., for a 3D graphics library). Since most platforms can   extend their application memory partition at run time if needed,   this macro is defined as a noop here and redefined if necessary   in sqPlatformSpecific.h.*/#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) origHeapSize/* platform-dependent millisecond clock macros *//* Note: The Squeak VM uses three different clocks functions for   timing. The primary one, ioMSecs(), is used to implement Delay   and Time millisecondClockValue. The resolution of this clock   determines the resolution of these basic timing functions. For   doing real-time control of music and MIDI, a clock with resolution   down to one millisecond is preferred, but a coarser clock (say,   1/60th second) can be used in a pinch. The VM calls a different   clock function, ioLowResMSecs(), in order to detect long-running   primitives. This function must be inexpensive to call because when   a Delay is active it is polled twice per primitive call. On several   platforms (Mac, Win32), the high-resolution system clock used in   ioMSecs() would incur enough overhead in this case to slow down the   the VM significantly. Thus, a cheaper clock with low resolution is   used to implement ioLowResMSecs() on these platforms. Finally, the   function ioMicroMSecs() is used only to collect timing statistics   for the garbage collector and other VM facilities. (The function   name is meant to suggest that the function is based on a clock   with microsecond accuracy, even though the times it returns are   in units of milliseconds.) This clock must have enough precision to   provide accurate timings, and normally isn''t called frequently   enough to slow down the VM. Thus, it can use a more expensive clock   that ioMSecs(). By default, all three clock functions are defined   here as macros based on the standard C library function clock().   Any of these macros can be overridden in sqPlatformSpecific.h.*/int ioMSecs(void);int ioLowResMSecs(void);int ioMicroMSecs(void);#define ioMSecs()		((1000 * clock()) / CLOCKS_PER_SEC)#define ioLowResMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)#define ioMicroMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)/* filename copy/transform macro. An opportunity to transform the filenames for   platforms with strange needs, anda simple encapsulation for everyone else*/#define sqFilenameFromString(dst, src, num) \if (1) { \	int i; \	for (i = 0; i < num; i++) { \		dst[i] = *((char *) (src + i)); \	} \	dst[num] = 0;\}/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);int ioHasDisplayDepth(int depth);int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag);/* Power Management */int ioDisablePowerManager(int disableIfNonZero);/* User input recording I:   In general, either set of input function can be supported,   depending on the platform. This (first) set is state based   and should be supported even on platforms that make use   of the newer event driven API to support older images    without event support.*/int ioGetButtonState(void);int ioGetKeystroke(void);int ioMousePoint(void);int ioPeekKeystroke(void);/* Note: In an event driven architecture, ioProcessEvents is obsolete.   It can be implemented as a no-op since the image will check for   events in regular intervals. */int ioProcessEvents(void);/* User input recording II:   The following functions and definition can be used on   platform supporting events directly.*//* types of events */#define EventTypeNone 0#define EventTypeMouse 1#define EventTypeKeyboard 2#define EventTypeDragDropFiles 3/* keypress state for keyboard events */#define EventKeyChar 0#define EventKeyDown 1#define EventKeyUp 2/* button definitions */#define RedButtonBit 4#define BlueButtonBit 2#define YellowButtonBit 1/* modifier definitions */#define ShiftKeyBit 1#define CtrlKeyBit 2#define OptionKeyBit 4#define CommandKeyBit 8/* generic input event definition */typedef struct sqInputEvent {	int type; /* type of event; either one of EventTypeXXX */	unsigned int timeStamp; /* time stamp */     /* the interpretation of the following fields depend on the type of the event */	int unused1;	int unused2;	int unused3;	int unused4;	int unused5;	int unused6;} sqInputEvent;/* mouse input event definition */typedef struct sqMouseEvent {	int type; /* EventTypeMouse */	unsigned int timeStamp; /* time stamp */	int x; /* mouse position x */	int y; /* mouse position y */	int buttons; /* combination of xxxButtonBit */	int modifiers; /* combination of xxxKeyBit */	int reserved1; /* reserved for future use */	int reserved2; /* reserved for future use */} sqMouseEvent;/* keyboard input event definition */typedef struct sqKeyboardEvent {	int type; /* EventTypeKeyboard */	unsigned int timeStamp; /* time stamp */	int charCode; /* character code in Mac Roman encoding */	int pressCode; /* press code; any of EventKeyXXX */	int modifiers; /* combination of xxxKeyBit */	int reserved1; /* reserved for future use */	int reserved2; /* reserved for future use */	int reserved3; /* reserved for future use */} sqKeyboardEvent;/* drop files event definition:   DragEnter - drag operation from OS entered Squeak window   DragMove  - drag operation from OS moved within Squeak window   DragLeave - drag operation from OS left Squeak window   DragDrop  - drag operation dropped contents onto Squeak.*/#define DragEnter 1#define DragMove  2#define DragLeave 3#define DragDrop  4typedef struct sqDragDropFilesEvent {	int type; /* EventTypeDropFiles */	unsigned int timeStamp; /* time stamp */	int dragType; /* one of the DragXXX constants */	int x; /* mouse position x */	int y; /* mouse position y */	int modifiers; /* combination of xxxKeyBit */	int numFiles; /* number of files in transaction */	int reserved1; /* reserved for future use */} sqDragDropFilesEvent;/* set an asynchronous input semaphore index for events */int ioSetInputSemaphore(int semaIndex);/* retrieve the next input event from the OS */int ioGetNextEvent(sqInputEvent *evt);/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore *//* Read the image from the given file starting at the given image offset */int readImageFromFileHeapSizeStartingAt(sqImageFile f, int desiredHeapSize, int imageOffset);/* NOTE: The following is obsolete - it is only provided for compatibility */#define readImageFromFileHeapSize(f, s) readImageFromFileHeapSizeStartingAt(f,s,0)/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* browser plug-in support */int plugInAllowAccessToFilePath(char *pathString, int pathStringLength);void plugInForceTimeToReturn(void);int plugInInit(char *imageName);int plugInNotifyUser(char *msg);void plugInSetStartTime(void);int plugInShutdown(void);int plugInTimeToReturn(void);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* ar 5/13/2000:	The following set of miscellaneous and sound primitives should	at some point go into named primitives. Right now there are a few	problems with that (related to how the distinct set of methods can	be defined as residing in one plugin).*//* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringfindSubstringinstartingAtmatchTable(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);int oldprimSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/*** sound compression primitives ***/int primADPCMCodecprivateDecodeMono(void);int primADPCMCodecprivateDecodeStereo(void);int primADPCMCodecprivateEncodeMono(void);int primADPCMCodecprivateEncodeStereo(void);/*** pluggable primitive support ***//* NOTE: The following functions are those implemented by sqNamedPrims.c */int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength,  int moduleNameIndex, int moduleNameLength);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadFunctionFrom(char *functionName, char *pluginName);int ioShutdownAllModules(void);int ioUnloadModule(char *);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);char *ioListBuiltinModule(int moduleIndex);char *ioListLoadedModule(int moduleIndex);/* The next two are FFI entries!! (implemented in sqNamedPrims.c as well) */int ioLoadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadSymbolOfLengthFromModule(int functionNameIndex, int functionNameLength, int moduleHandle);/* The next three functions must be implemented by sqXYZExternalPrims.c *//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName);/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle);/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle);/* The Squeak version this interpreter was generated from */extern const char *interpreterVersion;'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/1/2001 23:38'!squeakPlatSpecFile	^ '/* sqPlatformSpecific.h -- Platform-specific prototypes and definitions *//* How to use this file:   This file is for general platform-specific macros and declarations.   Function prototypes that are unlikely to introduce name conflicts on   other platforms can be added directly. Macro re-definitions or conflicting   function prototypes can be wrapped in a #ifdefs. Alternatively, a customized   version of this file can be used on that platform. The goal is to keep all   the other header files generic across platforms. To override a definition or   macro from sq.h, you must first #undef it, then provide the new definition.*/#ifdef UNIX/* unix-specific prototypes and definitions */void aioPollForIO(int microSeconds, int extraFd);#define SQ_FORM_FILENAME	"squeak-form.ppm"/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs#undef ioLowResMSecs#endif /* UNIX */#ifdef macintosh// CARBON/*#ifdef TARGET_API_MAC_CARBON      #undef TARGET_API_MAC_CARBON    #define TARGET_API_MAC_CARBON 1#else    #define TARGET_API_MAC_CARBON 1#endif *//* replace the image file manipulation macros with functions */#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#undef sqImageFileStartLocation#undef sqAllocateMemorytypedef int sqImageFile;void        sqImageFileClose(sqImageFile f);sqImageFile sqImageFileOpen(char *fileName, char *mode);int         sqImageFilePosition(sqImageFile f);int         sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f);void        sqImageFileSeek(sqImageFile f, int pos);int         sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f);int         sqImageFileStartLocation(int fileRef, char *filename, int imageSize);void *						sqAllocateMemory(int minHeapSize, int desiredHeapSize);/* override reserveExtraCHeapBytes() macro to reduce Squeak object heap size on Mac */#undef reserveExtraCHeapBytes#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) (origHeapSize - bytesToReserve)/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs/* macro to return from interpret() loop in browser plugin VM */#define ReturnFromInterpret() return/* prototypes missing from CW11 headers */#include <textutils.h>void CopyPascalStringToC(ConstStr255Param src, char* dst);void CopyCStringToPascal(const char* src, Str255 dst);#endif /* macintosh */#ifdef ACORN/* acorn memory allocation */#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) platAllocateMemory(desiredHeapSize)#undef sqFilenameFromString#define sqFilenameFromString(dst, src, num) sqFilenameFromString(dst, src, num)/* string copying macro to compensate for bug in Acorn library code */#define copyNCharsFromTo(num, src, dst)\if(1) {int sqfni;\	char cc;\	for (sqfni = 0; sqfni < num; sqfni++) {\		dst[sqfni] = cc = *((char *) (src + sqfni));\		if ( cc == 0) break;\	}\	dst[num] = 0;\}/* undefine clock macros that are implemented as functions */#undef ioMicroMSecs#undef ioMSecs#define ioMSecs() (10* (int)os_read_monotonic_time())#undef ioLowResMSecs#define ioLowResMSecs() (ioMSecs())#endif /* ACORN */#ifdef WIN32/* Override necessary definitions */#undef putchar#include "sqWin32Alloc.h"#ifdef WIN32_FILE_SUPPORT#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#define sqImageFile unsigned longint sqImageFileClose(sqImageFile h);sqImageFile sqImageFileOpen(char *fileName, char *mode);int sqImageFilePosition(sqImageFile h);int sqImageFileRead(void *ptr, int sz, int count, sqImageFile h);int sqImageFileSeek(sqImageFile h, int pos);int sqImageFileWrite(void *ptr, int sz, int count, sqImageFile h);#endif /* WIN32_FILE_SUPPORT *//* pluggable primitive support */#if defined(_MSC_VER) || defined(__MINGW32__)#  undef EXPORT#  define EXPORT(returnType) __declspec( dllexport ) returnType#endif /* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioLowResMSecs#undef ioMicroMSecs/* Declare GetTickCount() in case <windows.h> is not included */#if !!defined(_WINDOWS_) && !!defined(_WIN32_WCE) && !!defined(_WINDOWS_H)__declspec(dllimport) unsigned long __stdcall GetTickCount(void);#endif#define ioLowResMSecs() GetTickCount()#endif /* WIN32 */'! !