'From Squeak 2.0 BETA of May 8, 1998 on 13 May 1998 at 11:39:39 pm'!Object subclass: #ActorState	instanceVariableNames: 'owningPlayer penDown penSize penColor fractionalPosition instantiatedUserScriptsDictionary '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Object subclass: #ScriptInstantiation	instanceVariableNames: 'player selector status frequency anonymous '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!PasteUpMorph subclass: #WorldMorph	instanceVariableNames: 'hands activeHand viewBox canvas damageRecorder stepList lastStepTime playerList '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!!ActorState methodsFor: 'initialization' stamp: 'sw 5/13/1998 16:37'!initializeFor: aPlayer	| aNewDictionary |	owningPlayer _ aPlayer.	instantiatedUserScriptsDictionary ifNil: [^ self].	aNewDictionary _ IdentityDictionary new.	instantiatedUserScriptsDictionary associationsDo: 		[:assoc |			aNewDictionary at: assoc key put: (assoc value shallowCopy player: aPlayer)].	instantiatedUserScriptsDictionary _ aNewDictionary.! !!ActorState methodsFor: 'other' stamp: 'sw 5/12/1998 23:35'!printOn: aStream	aStream nextPutAll: 'ActorState for ', owningPlayer externalName, ' '.	penDown ifNotNil: [aStream cr; nextPutAll: 'penDown ', penDown printString].	penColor ifNotNil: [aStream cr; nextPutAll: 'penColor ', penColor printString].	penSize ifNotNil: [aStream cr; nextPutAll: 'penSize ', penSize printString].	instantiatedUserScriptsDictionary ifNotNil:		[aStream cr; nextPutAll:			'+ ', instantiatedUserScriptsDictionary size printString, ' user scripts'].! !!BookMorph class methodsFor: 'all' stamp: 'sw 5/13/1998 11:43'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book removeEverything; pageSize: 128@102; color: (Color r: 0.9 g: 0.9 b: 0.9).	book borderWidth: 1; borderColor: Color black.	book addDressing; insertPage.	^ book! !!EToyHolder methodsFor: 'initialization' stamp: 'sw 5/13/1998 00:15'!initialize	"Initialize this EToyHolder for a new, empty EToy."	title _ self defaultTitle.	playfield _ PasteUpMorph new.	playfield borderWidth: 4; borderColor: Color green.	playfield beSticky.	playfield setNameTo: 'playfield'.	playfield color: Color transparent.	playfield changed.	BookMorph turnOffSoundWhile:		[scaffoldingBook _ TabbedPaletteComplex new setNameTo: 'Scaffolding'.		self initializeScaffoldingContentsForFreshEToy].! !!EToyHolder methodsFor: 'hooks' stamp: 'sw 5/11/1998 17:27'!chooseExternalNameFor: anObject	| avail used |	avail _ self favoredActorNames asOrderedCollection.	avail removeAllFoundIn: (used _ playfield world allKnownNames).	avail size > 0 ifTrue: [^ avail atRandom].	^ Utilities keyLike: 'obj1' satisfying: [:f |  (used includes: f) not]! !!EToyHolder methodsFor: 'object storing' stamp: 'sw 5/11/1998 19:59'!trimScaffoldingBookBeforeSaving	| toy bb |	"Currently disused"	true ifTrue: [^ self].	"Look for Actors in BookMorph, and ask author if they should really carry scripts.""	model class instVarNames size > 0 ifTrue: [^ self]."	"User is saving.  Don't bother her"	toy _ scaffoldingBook pageNamed: 'Toy'.	SketchMorph allInstancesDo: [:aa | 		aa hasScript ifTrue:		[(bb _ aa owner "page") ifNotNil: [(bb _ bb owner "book") == toy 			ifTrue: [self mayActorDropScript: aa]			ifFalse: [bb ifNotNil: [(bb _ bb owner "book?") == toy							ifTrue: [self mayActorDropScript: aa]]]]]]! !!EToyHolder class methodsFor: 'class initialization' stamp: 'sw 5/13/1998 18:58'!initialize	"EToyHolder initialize"	| ok |	ok _ true.	"UserStuffBook ~~ nil ifTrue:		[ok _ self confirm: 'Are you sure you want to clear the user''s parts book?']."	ok ifTrue: [UserStuffBook _ BookMorph new openToDragNDrop: true].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 5/13/1998 22:47'!replaceSubmorph: oldMorph by: newMorph	| index itsPosition |	oldMorph stopStepping.	itsPosition _ oldMorph position.	index _ submorphs indexOf: oldMorph.	oldMorph privateDelete.	self privateAddMorph: newMorph atIndex: index.	newMorph position: itsPosition.	self autoLineLayout		ifTrue:			[self fixLayout]! !!Morph methodsFor: 'stepping' stamp: 'sw 5/13/1998 16:26'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	costumee ifNotNil: [^ true].	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'menu' stamp: 'sw 5/13/1998 17:12'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	aMenu addLine.	aMenu add: 'open viewer' action: #openViewerForArgument.	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [GIFImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	costumee ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	self colorSettable ifTrue:		[aMenu add: 'fill color' action: #changeColor].	(aHandMorph argument pasteUpMorph morphsAt: aHandMorph menuTargetOffset) size > 2 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self addSensitivityItemsTo: aMenu hand: aHandMorph.	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!Morph methodsFor: 'menu' stamp: 'sw 5/12/1998 23:47'!addFlexShell	"Wrap a rotating and scaling shell around this morph."	| oldHalo flexMorph anActorState aName |	self isFlexMorph ifTrue: [^ self].	oldHalo _ self halo.	self owner addMorph:		(flexMorph _ TransformationMorph new asFlexOf: self).	(anActorState _ self valueOfProperty: #actorState) ifNotNil:		[flexMorph setProperty: #actorState toValue: anActorState.		self removeProperty: #actorState].	(aName _ self valueOfProperty: #name) ifNotNil:		[flexMorph setProperty: #name toValue: aName.		self removeProperty: #name].	costumee ifNotNil:		[flexMorph costumee: costumee.		costumee rawCostume: flexMorph].	oldHalo ifNotNil: [oldHalo setTarget: flexMorph]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 5/13/1998 00:42'!allMorphsIncludingBookPages	"Like allMorphs, but includes the hidden ones like BookMorph pages that are not showing." 	^ self allMorphsAndBookPagesInto: Set new! !!Morph methodsFor: 'e-toy support' stamp: 'sw 5/13/1998 00:14'!externalName	| aName aHolder |	(aName _ self knownName) ifNotNil: [^ aName].	^ (aHolder _ self standardHolder)		ifNil:			[self innocuousName]		ifNotNil:			[aName _ aHolder chooseExternalNameFor: self.			self setNamePropertyTo: aName.			aName]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 5/12/1998 10:50'!specialNameInModel	"Return the name for this morph in the underlying model or nil."	"Not an easy problem.  For now, take the first part of the mouseDownSelector symbol in my eventHandler (fillBrushMouseUp:morph: gives 'fillBrush').  5/26/97 tk"	| hh |	(self isKindOf: MorphicModel)		ifTrue: [^ self slotName]		ifFalse: [			eventHandler ifNotNil: [				eventHandler mouseDownSelector ifNotNil: [					hh _ eventHandler mouseDownSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ eventHandler mouseDownSelector copyFrom: 1 to: hh-1]].				eventHandler mouseUpSelector ifNotNil: [					hh _ eventHandler mouseUpSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ eventHandler mouseUpSelector copyFrom: 1 to: hh-1]].				]].			"	(eventHandler mouseDownRecipient respondsTo: #nameFor:) ifTrue: [					^ eventHandler mouseDownRecipient nameFor: self]]].	"			"myModel _ self findA: MorphicModel.			myModel ifNotNil: [^ myModel slotName]"		^ self world specialNameInModelFor: self! !!Morph methodsFor: 'e-toy support' stamp: 'sw 5/12/1998 16:41'!standardHolder	| p |	^ (p _ self presenter) ifNil: [nil] ifNotNil: [p standardHolder]! !!Morph methodsFor: 'naming' stamp: 'sw 5/13/1998 00:16'!knownName	^ self valueOfProperty: #name! !!Morph methodsFor: 'naming' stamp: 'sw 5/13/1998 00:16'!setNameTo: aName	self setNamePropertyTo: aName! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 5/13/1998 16:15'!inPartsBin	| o |	(self hasProperty: #partsDonor) ifTrue: [^ true].	o _ self owner.	[o == nil] whileFalse:		[o isPartsBin ifTrue: [^ true].		o _ o owner].	^ false! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 5/13/1998 12:18'!assuredCostumee	"Answer the receiver's costumee, a Player,, creating a new one if none currently exists"	costumee ifNil:		[self externalName.  "a default may be given if not named yet"		costumee _ self newPlayerInstance.  "Different morphs may demand different player types"		costumee costume: self.		self world flushPlayerListCache].	^ costumee! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/13/1998 13:11'!instantiatedUserScriptsDo: aBlock	| aState |	(aState _ self actorState) ifNotNil:		[aState instantiatedUserScriptsDictionary do: aBlock]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/13/1998 11:50'!restoreSuspendedEventHandler	| savedHandler |	(savedHandler _ self valueOfProperty: #suspendedEventHandler) ifNotNil:		[self eventHandler: savedHandler]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/13/1998 11:49'!suspendEventHandler	eventHandler ifNotNil:		[self setProperty: #suspendedEventHandler toValue: eventHandler.		eventHandler _ nil]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/6/1998 13:27'!tempCommand	"To use this, comment out what's below here, and substitute your own code, or else reimplement in a subclass.  "	self inform: 'Morph tempCommandPut your own temporarydebugging code in this method, eitherin generic Morph or in some subclass,and you will be able to invoke it directlythe standard debugging menu.'.	"Later, give user a chance at this juncture to spawn a browser on this very method"! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/13/1998 17:33'!usableDuplicate	|  aName usedNames newPlayer newMorph |	newMorph _ self fullCopy.	costumee ifNotNil:		[newPlayer _ costumee duplicatedPlayerForCostume: newMorph.			"nb newPlayer has had his costume set to newMorph in the above-called method"		self isFlexMorph ifTrue: [newMorph renderedMorph costumee: newPlayer]. "???"		newMorph actorState: (costumee actorState shallowCopy initializeFor: newPlayer)].	(aName _ self knownName) == nil ifTrue:		[costumee ~~ nil ifTrue: [aName _ newMorph innocuousName]].  "Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	newMorph justDuplicatedFrom: self.	newMorph removeProperty: #partsDonor.	newMorph privateOwner: nil.	(newPlayer ~~ nil and: [newMorph renderedMorph eventHandler ~~ nil]) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	newPlayer ifNotNil: [self world flushPlayerListCache].	^ newMorph! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/13/1998 23:04'!usableSiblingInstance	|  aName usedNames newPlayer newMorph |	newMorph _ self fullCopy.	newPlayer _ costumee class new costume: newMorph.	self isFlexMorph ifTrue: [newMorph renderedMorph costumee: newPlayer]. "???"	newMorph actorState: (costumee actorState shallowCopy initializeFor: newPlayer).	(aName _ self knownName) == nil ifTrue:		[costumee ~~ nil ifTrue: [aName _ newMorph innocuousName]].  "Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	"newMorph justDuplicatedFrom: self.  NOT done for sibling inst"	newMorph privateOwner: nil.	(newMorph renderedMorph eventHandler ~~ nil) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	self world flushPlayerListCache.	^ newMorph! !!BorderedMorph methodsFor: 'menu' stamp: 'sw 5/13/1998 12:08'!changeBorderColor: evt	| aHand |	aHand _ evt ifNotNil: [evt hand] ifNil: [self primaryHand].	aHand changeColorTarget: self selector: #borderColor:.! !!BorderedMorph methodsFor: 'menu' stamp: 'sw 5/13/1998 12:11'!changeBorderWidth: evt	| handle origin aHand |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand gridPointRaw.	handle _ HandleMorph new forEachPointDo:		[:newPoint | handle removeAllMorphs.		handle addMorph:			(PolygonMorph vertices: (Array with: origin with: newPoint)				color: Color black borderWidth: 1 borderColor: Color black).		self borderWidth: (newPoint - origin) r asInteger // 5].	aHand attachMorph: handle.	handle startStepping! !!AlignmentMorph methodsFor: 'classification' stamp: 'sw 5/13/1998 14:50'!demandsBoolean	"unique to the TEST frame inside a CompoundTileMorph"	^ self hasProperty: #demandsBoolean! !!BookMorph methodsFor: 'menu' stamp: 'sw 5/13/1998 15:11'!insertPage: aPage pageSize: aPageSize atIndex: anIndex	| sz  predecessor |	sz _ aPageSize		ifNil: [currentPage == nil			ifTrue: [pageSize]			ifFalse: [currentPage extent]]		ifNotNil:			[aPageSize].	aPage extent: sz.	((pages isEmpty | anIndex == nil) or: [anIndex > pages size])		ifTrue:			[pages add: (currentPage _ aPage)]		ifFalse:			[anIndex == 1				ifTrue:					[pages addFirst: aPage]				ifFalse:					[predecessor _ anIndex == nil						ifTrue:							[currentPage]						ifFalse:							[pages at: anIndex].					self pages add: aPage after: predecessor]].	self nextPage! !!BookMorph methodsFor: 'menu' stamp: 'sw 5/13/1998 11:40'!insertPageColored: aColor	| sz newPage bw bc |	currentPage == nil		ifTrue:			[sz _ pageSize.			bw _ 0.			bc _ Color blue muchLighter]		ifFalse:			[sz _ currentPage extent.			bw _ currentPage borderWidth.			bc _ currentPage borderColor].	newPage _ PasteUpMorph new extent: sz; color: aColor.	newPage borderWidth: bw; borderColor: bc.	newPage resizeToFit: false.	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage.! !!BookMorph methodsFor: 'menu' stamp: 'sw 5/13/1998 12:13'!invokeBookMenu	"Answer a menu to be popped up from the book-control panel"	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		"	('border color...' 		changeBorderColor:)			('border width...' 		changeBorderWidth:)			('lock'					lock)"			('make bookmark'		bookmarkForThisPage)			('sort pages'				sortPages:)			('remove control panel'	deleteControls)		).	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	aMenu invokeOn: self defaultSelection: nil! !!BookMorph methodsFor: 'private' stamp: 'sw 5/13/1998 11:46'!authorControlSpecs	^ #(				( '<--'		firstPage		'Go to first page')			( '<-' 		previousPage	'Go to previous page')			('-'			deletePage		'Delete current page')			('<<>>'		invokeBookMenu 'Get a menu')			('+'			insertPage		'Insert new page after this one')			('->'			nextPage		'Go to next page')			( '-->'		lastPage			'Go to final page'))! !!BookMorph methodsFor: 'private' stamp: 'sw 5/13/1998 15:11'!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending |	pages isEmpty ifTrue: [^ self].	oldPageNumber _ pages indexOf: currentPage ifAbsent: [1].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	ascending _ oldPageNumber < pageIndex.	oldPageNumber = pageIndex ifTrue: [ascending _ nil].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		currentPage releaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending]! !!CompoundTileMorph methodsFor: 'all' stamp: 'sw 5/13/1998 14:49'!initialize	| r |	super initialize.	self color: Color orange muchLighter.	self borderWidth: 1.	self inset: 2.	self orientation: #vertical.	r _ AlignmentMorph newRow color: color; inset: 0.	r setProperty: #demandsBoolean toValue: true.	r addMorphBack: (Morph new color: color; extent: 2@5).  "spacer"	r addMorphBack: (StringMorph new contents: 'Test').	r addMorphBack: (Morph new color: color; extent: 5@5).  "spacer"	r addMorphBack: (testPart _ BooleanScriptEditor new borderWidth: 0; inset: 1).	testPart color: Color transparent.	self addMorphBack: r.	r _ AlignmentMorph newRow color: color; inset: 0.	r addMorphBack: (Morph new color: color; extent: 30@5).  "spacer"	r addMorphBack: (StringMorph new contents: 'Yes').	r addMorphBack: (Morph new color: color; extent: 5@5).  "spacer"	r addMorphBack: (yesPart _ ScriptEditorMorph new borderWidth: 0; inset: 2).	yesPart color: Color transparent.	self addMorphBack: r.	r _ AlignmentMorph newRow color: color; inset: 0.	r addMorphBack: (Morph new color: color; extent: 35@5).  "spacer"	r addMorphBack: (StringMorph new contents: 'No').	r addMorphBack: (Morph new color: color; extent: 5@5).  "spacer"	r addMorphBack: (noPart _ ScriptEditorMorph new borderWidth: 0; inset: 2).	noPart color: Color transparent.	self addMorphBack: r.	self extent: 5@5.  "will grow to fit"! !!CompoundTileMorph methodsFor: 'all' stamp: 'sw 5/13/1998 15:19'!rowOfRightTypeFor: aLayoutMorph forActor: anActor	aLayoutMorph demandsBoolean ifTrue:		[^ self error: 'oops, cannot do that, please close this'].	^ self! !!EToyPalette methodsFor: 'initialization' stamp: 'sw 5/13/1998 00:18'!viewMorph: aMorph		| aPlayer aPresenter |	currentPalette ifNotNil: [currentPalette delete].  "was the Paint palette"	currentPalette _ nil.	aPlayer _ aMorph assuredCostumee.	aPresenter _ self presenter.	viewPalette _ aPresenter viewerCache at: aPlayer ifAbsent:		[self world "temp" addMorph: (viewPalette _ self partsViewerClass newSticky).		viewPalette setPlayer: aPlayer.		aPresenter cacheViewer: viewPalette forPlayer: aPlayer.		viewPalette delete.		viewPalette].	BookMorph classPool at: #PageFlipSoundOn put: true.		"In case an error turned 		the sound off"	self presenter coloredTilesEnabled ifFalse:		[viewPalette makeAllTilesGreen].	self showViewPalette.! !!EToyPalette methodsFor: 'widgets ' stamp: 'sw 5/13/1998 20:01'!alternateWidgets	| aHolder widgets |	aHolder _ self world standardHolder.	widgets _ OrderedCollection new. 	#(TextMorph PaintInvokingMorph RecordingControlsMorph) do:		[:sym | widgets add: ((Smalltalk at: sym) authoringPrototypeIn: aHolder)].	widgets add: self nextPageButton markAsPartsDonor.	widgets add: self previousPageButton markAsPartsDonor.	^ widgets! !!HaloMorph methodsFor: 'private' stamp: 'sw 5/13/1998 00:04'!addHandles	| box |	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target fullBoundsInWorld.  "update my size"	box _ (self fullBounds expandBy: 17)			intersect: (self world bounds insetBy: 5@5).	(self addHandleAt: box topLeft color: Color red)		on: #mouseDown send: #doMenu:with: to: self.	(self addHandleAt: (box topLeft + (0@18)) color: Color lightBrown)		on: #mouseDown send: #tearOffTile to: innerTarget.	(self addHandleAt: (box topLeft + (18@0)) color: Color transparent)		on: #mouseDown send: #dismiss to: self.	(self addHandleAt: (box leftCenter) color: Color cyan)		on: #mouseDown send: #openViewerForArgument to: innerTarget.	(self addHandleAt: box topCenter color: Color black)		on: #mouseDown send: #doGrab:with: to: self.	(self addHandleAt: box topRight color: Color green)		on: #mouseDown send: #doDup:with: to: self.	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue)			on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget;			on: #mouseUp send: #deleteBalloon to: innerTarget].	(self addHandleAt: box bottomLeft color: Color blue)		on: #mouseDown send: #startRot:with: to: self;		on: #mouseStillDown send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [			(self addHandleAt: box bottomRight color: Color lightOrange)				on: #mouseDown send: #startScale:with: to: self;				on: #mouseStillDown send: #doScale:with: to: self]		ifFalse: [			(self addHandleAt: box bottomRight color: Color yellow)				on: #mouseDown send: #startGrow:with: to: self;				on: #mouseStillDown send: #doGrow:with: to: self].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: box string: target "innerTarget" externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 5/13/1998 17:11'!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #duplicateMorph.	(argument pasteUpMorph morphsAt: targetOffset) size > 2 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	(argMorph isKindOf: SketchMorph)  ifFalse: [		menu add: 'fill color' action: #changeColor].	(argMorph morphsAt: targetOffset) size > 1 ifTrue: [		menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	menu add: 'inspect' action: #inspectMorph.	menu add: 'inspect in Morphic' action: #inspectMorphInMorphic.	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'name me' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue: [		menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue: [			 menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveMorphInFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 5/13/1998 17:36'!duplicateMorph	| newMorph |	newMorph _ argument usableDuplicate.	self grabMorphFromMenu: newMorph.	newMorph costumee ifNotNil: [newMorph costumee startRunning].	" -- End of presently active code -- "	self flag: #noteToDan.  "The following code was formerly in duplicateMorph, and may need to be reincorporated somewhere:	oldModel _ argument findA: MorphicModel.	oldModel ifNotNil:		[oldModel model duplicate: (new findA: MorphicModel) from: oldModel]."	self flag: #noteToTed.  "the following corrsponds to the hook you had in for getting script tiles straightened out:	newMorph justDuplicatedFrom: argument.		We depend on nameInModel working, and hand having grabbed already (old tck note)"! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 5/12/1998 11:52'!embedMorph 	| rootMorphs morphToEmbed targetRoot targetMorph worldPosition |	self flag: #noteToJohn.  "The original Morphic implementation.  This is theoretically supplanted by #placeArgumentIn, but is retained here, unsent, for the time being"	rootMorphs _ self world rootMorphsAt: targetOffset.	rootMorphs size < 2 ifTrue: [^ self].	morphToEmbed _ rootMorphs at: 1.	worldPosition _ morphToEmbed position.	targetRoot _ rootMorphs at: 2.	targetMorph _ self chooseTargetSubmorphOf: targetRoot caption: 'Embed in...'.	targetMorph ifNotNil:		[targetMorph addMorphFront: morphToEmbed				fromWorldPosition: worldPosition].! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 5/12/1998 11:45'!menuTargetOffset	^ menuTargetOffset! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 5/13/1998 17:34'!pasteMorph	| aPastee |	self attachMorph: (aPastee _ PasteBuffer usableDuplicate).	aPastee costumee ifNotNil: [aPastee costumee startRunning]! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 5/12/1998 11:42'!selectTargetMorph: caption excluding: morphToExclude	"Put up a menu of morphs found in a core sample taken of the world at the receiver's menuTargetOffset, with the given caption, but exclude morphToExclude and all of its submorphs.  This latter is for use with embed/place facilties, to avoid strange loops. "	| possibleTargets menu |	possibleTargets _ argument pasteUpMorph morphsAt: menuTargetOffset.	morphToExclude ifNotNil:		[possibleTargets removeAllFoundIn: morphToExclude allMorphs].	possibleTargets size < 2 ifTrue:		[self inform: 'Sorry -- not applicable here'.		^ nil].	menu _ CustomMenu new.	possibleTargets do: [:m | menu add: (self submorphNameFor: m) action: m].	^ caption size == 0		ifTrue:			[menu startUp]		ifFalse:			[menu startUpWithCaption: caption]! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 5/13/1998 00:18'!makeNewDrawingIn: aPasteUpMorph	"Make a new drawing inside aPasteUpMorph"	| rect aPaintWindow  aSketchMorph aPlayer aWorld |	(aWorld _ self world) stopRunningAll; abandonAllHalos.	(aPasteUpMorph == nil or: [aPasteUpMorph isPlayfieldLike not])  ifTrue:  [^ self beep].	rect _ aPasteUpMorph bounds.	aSketchMorph _ self drawingClass new costumee: (aPlayer _ Player newUserInstance).	aPlayer costume: aSketchMorph.	aSketchMorph form: (Form extent: rect extent depth: aWorld assuredCanvas depth).	aSketchMorph bounds: rect.	aPaintWindow _ SketchEditorMorph new.	aWorld addMorphFront: aPaintWindow.	aPaintWindow initializeFor: aSketchMorph inPasteUpMorph: aPasteUpMorph.	aPaintWindow 		afterNewPicDo: [:aForm :aRect |			owner fullRepaintNeeded.			aSketchMorph form: aForm.			aSketchMorph position: aRect origin.			aSketchMorph forwardDirection: aPaintWindow forwardDirection.			aSketchMorph rotationDegrees: aPaintWindow forwardDirection.	"Same orientation as she drew it"			aSketchMorph rotationStyle: aPaintWindow rotationStyle.			aPasteUpMorph addMorphFront: aSketchMorph.			aWorld startSteppingSubmorphsOf: aSketchMorph.			self presenter drawingJustCompleted: aSketchMorph]		 ifNoBits: [aPasteUpMorph standardPalette ifNotNil: [aPasteUpMorph standardPalette showNoPalette]]! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 5/13/1998 18:39'!makeNewPlayerInstance	"Make a duplicate of the receiver's argument.  This is called only where the argument has an associated Player as its costumee, and the intent here is to make another instance of the same uniclass as the donor Player itself.  Much works, but there are flaws so this shouldn't be used without recognizing the risks"	self attachMorph: argument usableSiblingInstance! !!MorphicModel class methodsFor: 'compilation' stamp: 'sw 5/13/1998 14:33'!acceptsLoggingOfCompilation	"Dont log sources for my automatically-generated subclasses.  Can easily switch this back when it comes to deal with Versions, etc."	^ self == MorphicModel or: [(name last isDigit) not]! !!PaintInvokingMorph methodsFor: 'all' stamp: 'sw 5/13/1998 20:08'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	aMorph isPlayfieldLike ifFalse: [self beep.  ^ self].	self delete.	anEvent hand makeNewDrawingIn: aMorph! !!PaintInvokingMorph class methodsFor: 'as yet unclassified' stamp: 'sw 5/13/1998 15:21'!authoringPrototype	^ self new image: (ScriptingSystem formAtKey: 'Painting')! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 5/12/1998 10:16'!experimentalCommand	"Use for experimental command-key implementation.  using this, you can try things out without forever needing to reinitialize the ParagraphEditor. "	sensor keyboard.	self inform: 'Cmd-t is not currently used.To get "ifTrue: [" inserted, use Cmd-SHIFT-t'.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 5/12/1998 10:16'!tempCommand: characterStream 	"Experimental.  Triggered by Cmd-t; put trial cmd-key commands here to see how they work, before hanging them on their own cmd accelerators."	self experimentalCommand.	^ true	"sensor keyboard.	self spawnWorkspace.	^ true"! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/13/1998 10:53'!rowBeforeParts	| r nail aButton aTextMorph aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	r addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Hit the X to remove this Viewer'.	r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousPartsBank; label: '<' font: aFont; color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'Show previous bank of parts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextPartsBank; label: '>' font: aFont; color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Show next bank of parts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: '+' font: aFont; color: Color gray muchLighter; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Hit plus to addan instance variableto this player.'.	r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	r  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousCostume; label: '<' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to previous costume'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextCostume; label: '>' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to next costume'.	r addTransparentSpacerOfSize: 10@5.	nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #newCostume to: scriptedPlayer.	r addMorphBack: nail.	nail setBalloonText: 'click here to specify new costume.'.		^ r! !!PasteUpMorph methodsFor: 'cursor' stamp: 'sw 5/12/1998 12:54'!cursor: aNumber	"Set the cursor to the given number, modulo the number of items I contain. Fractional cursor values are allowed."	| truncP |	cursor ~= aNumber ifTrue: 		[cursor _ self asNumber: aNumber.		truncP _ cursor truncated.		truncP > submorphs size ifTrue:			[submorphs size > 0				ifTrue: [cursor _ cursor \\ submorphs size]				ifFalse: [cursor _ 1]].		truncP < 0 ifTrue: [cursor _ 1].		self changed]! !!PasteUpMorph methodsFor: 'cursor' stamp: 'sw 5/12/1998 10:55'!rectifyCursor	cursor _ ((cursor truncated max: 1) min: submorphs size)! !!PasteUpMorph methodsFor: 'cursor' stamp: 'sw 5/12/1998 10:55'!valueAtCursor: aMorph	submorphs isEmpty ifTrue: [^ self].	self rectifyCursor.	self replaceSubmorph: self valueAtCursor by: aMorph! !!PasteUpMorph methodsFor: 'slots' stamp: 'sw 5/13/1998 18:26'!slotNamesAndTypesForBank: aBank	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	aBank == 1 ifTrue: [^ Array new].	aBank == 2 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(color			color		readWrite	getColor				setColor:)		(borderWidth 	number		readWrite	getBorderWidth		setBorderWidth:)		(borderColor		color		readWrite	getBorderColor		setBorderColor:))].	aBank == 3 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(cursor 			number		readWrite	getCursor			setCursor:)		(valueAtCursor	player		readOnly	getValueAtCursor	unused)									"readWrite						setValueAtCursor:"		(mouseX			number		readOnly	getMouseX			unused)		(mouseY		number		readOnly	getMouseY			unused))].	^ #()! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 5/13/1998 11:51'!toggleIsPartsBin	isPartsBin _ self isPartsBin not.	isPartsBin		ifTrue:			[submorphs do:				[:m | m setProperty: #partsDonor toValue: true.					m suspendEventHandler]]		ifFalse:			[submorphs do:				[:m | m removeProperty: #partsDonor.					m restoreSuspendedEventHandler]]! !!PasteUpMorph methodsFor: 'model' stamp: 'sw 5/13/1998 00:21'!createCustomModel	"Create a model object for this world if it does not yet have one. A model object is an initially empty subclass of MorphicModel. As the user names parts and adds behavior, instance variables and methods are added to this class."	model == nil ifFalse: [^ self].	model _ MorphicModel newSubclass new.! !!PasteUpMorph methodsFor: 'mouse sensitivity' stamp: 'sw 5/12/1998 12:45'!establishMouseScriptFor: aMorph mouseState: aMouseState 	"aMorph, presumably one of my submorphs, is to react to the mouse via a script in me; create an empty script to cover the circumstance, so that the user can flesh it out.  Part of a disused branch of experiment, not quite ready to let it go yet"	| stem usedNames aSelector aUserScript aScriptInstantiation |	stem _ aMorph externalName asLegalSelector.	usedNames _ self assuredCostumee class tileScriptNames.	aSelector _ Utilities keyLike: (stem, aMouseState capitalized) asSymbol satisfying:		[:aKey | (usedNames includes: aKey) not].	aUserScript _ costumee class userScriptForPlayer: costumee selector: aSelector.	(aUserScript makeScriptEditorWithStatus: aSelector) install; bringUpToDate.	aScriptInstantiation _ costumee scriptInstantiationForSelector: aSelector.	aScriptInstantiation setToRunOn: aMouseState in: aMorph.  "that code no longer exists"	aMorph on: aMouseState send: aSelector to: self costumee.	self costumee updateAllViewers! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 5/13/1998 16:42'!topEditor	^ self outermostMorphThat: [:m | (m isKindOf: ScriptEditorMorph) or:		 [m isKindOf: CompoundTileMorph]]! !!Player methodsFor: 'name' stamp: 'sw 5/12/1998 16:46'!externalName	^ self costume externalName! !!Player methodsFor: 'name' stamp: 'sw 5/12/1998 23:56'!renameTo: aName	costume topRendererOrSelf renameTo: aName! !!Player methodsFor: 'costume' stamp: 'sw 5/13/1998 14:07'!availableCostumeNames	"Answer a list of class names (minus trailing ...Morph) to be offered in the thumbnail 'new-Costume' menu in the Viewer" 	^ #(Book BouncingAtoms Curve Ellipse  Flasher Image Joystick  PasteUp Polygon Rectangle Ruler Sketch Star String Text  )"  ScrollBar  SimpleButton SimpleSlider SimpleSwitch  UserFrame  "! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/12/1998 12:55'!getCursor	| aMorph |	((aMorph _ costume renderedMorph) respondsTo: #cursor) ifTrue: [^ aMorph cursor].	^ (self costumeNamed: #PasteUpMorph) cursor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/13/1998 22:31'!getX	self flag: #hottest.		"emergency patch; unclear why not needed in getY; in any case, will probably		 remove the getX/getY retrievals from the viewer in 2.0-final anyway"	costume isInWorld ifFalse: [^ 100].	^ costume x! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/12/1998 12:53'!setCursor: aNumber	| aMorph |	((aMorph _ costume renderedMorph) respondsTo: #cursor:) ifTrue: [^ aMorph cursor: aNumber].	^ (self costumeNamed: #PasteUpMorph) cursor: aNumber! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/12/1998 11:11'!setValueAtCursor: aPlayer	(costume respondsTo: #valueAtCursor:) ifTrue: [costume valueAtCursor: aPlayer costume]! !!Player methodsFor: 'slots-user' stamp: 'sw 5/13/1998 19:18'!addInstanceVariable	| itsName initialValue typeChosen suggestedNames usedNames initialAnswer setterSelector |	suggestedNames _ #('cargo' 'speed' 'weight' 'mzee' 'friml' 'verp' 'znak').	usedNames _ self class instVarNames.	initialAnswer _ suggestedNames detect: [:aName |  (usedNames includes: aName) not] ifNone:		[Utilities keyLike: 'var1'  satisfying: [:aKey | (usedNames includes: aKey) not]].	itsName _ FillInTheBlank request: 'name for new inst var: ' initialAnswer: initialAnswer. 	itsName size == 0 ifTrue: [^ self].	(Utilities isLegalInstVarName: itsName) ifFalse: [^ self inform: 'sorry, illegal name, try again.'].	itsName _ itsName asSymbol.	(self class allInstVarNames includes: itsName) ifTrue: [^ self inform: 'that name is already used.'].	typeChosen _ self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: typeChosen.	initialValue _ self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileAccessorsFor: itsName.	setterSelector _ Utilities setterSelectorFor: itsName.	(self class allInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewers! !!Player methodsFor: 'slots-user' stamp: 'sw 5/13/1998 19:32'!chooseSlotTypeFor: slotName	| typeChoices typeChosen |	typeChoices _ #(number player boolean color point string costume).	typeChosen _ (SelectionMenu selections: typeChoices lines: #()) startUpWithCaption: 'Choose the TYPEfor ', slotName.	(typeChosen size == 0) ifTrue: [^ self].	(self typeForSlot: slotName) = typeChosen ifTrue: [^ self].	self slotInfo at: slotName put: typeChosen.	self class allInstancesDo:		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName)).		anInst updateAllViewers]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/13/1998 16:17'!maxPartsBankNumber	^ 5! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/13/1998 10:51'!maxScriptsBankNumber	"later make sensitive to number of user scripts, and more general."	^ self  class namedTileScriptSelectors size > 11		ifTrue:			[5]		ifFalse:			[4]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/11/1998 17:21'!okayToDestroyScriptNamed: scriptName	costume world allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptInvoking: scriptName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/11/1998 17:20'!okayToRemoveSlotNamed: aSlotName	costume world allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptReferencing: aSlotName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-execution' stamp: 'sw 5/13/1998 13:10'!assureEventHandlerRepresentsStatus	self instantiatedUserScriptsDo:			[:aScriptInst | aScriptInst assureEventHandlerRepresentsStatus]! !!Player methodsFor: 'scripts-execution' stamp: 'sw 5/13/1998 16:04'!startRunning	costume startStepping.	self instantiatedUserScriptsDo:		[:aScript | aScript startRunningIfPaused]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 5/13/1998 19:13'!turn: degrees	degrees ifNotNil:		[self setHeading: (self getHeading + degrees asFloat) \\ 360.0]! !!Player methodsFor: 'clone' stamp: 'sw 5/13/1998 16:43'!justDuplicatedFrom: donorActor	"Convert all references to actor1 to actor2, who now owns the script"	"This is the case of true duplication, where the receiver and the donorPlayer are of distinct classes"	self class userScriptsDo:		[:aScript | aScript donorActor: donorActor ownActor: self; bringUpToDate]! !!PlayerReferenceReadout methodsFor: 'all' stamp: 'sw 5/13/1998 18:27'!mouseDown: evt	"Allow the user to respecify this by direct clicking"	| aMorph |	putSelector == #unused ifTrue: [^ self].	Sensor waitNoButton.	aMorph _ self world chooseClickTarget.	aMorph ifNil: [^ self].	objectToView perform: putSelector with: aMorph assuredCostumee.	self changed! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/12/1998 01:13'!stepButton	| aDict aPosition |	stepButton ifNil:		[aDict _ ScriptingSystem formDictionary.		stepButton _ ThreePhaseButtonMorph new.		stepButton image:  (aDict at: 'StepPicOn');			offImage: (aDict at: 'StepPic'); pressedImage:  (aDict at: 'StepPicOn');			actionSelector: #stepStillDown:with:; 			arguments: (Array with: nil with: stepButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Step Button'; 			setProperty: #scriptingControl toValue: true;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Press Step to run every pausedscript exactly once.  Keepthe mouse button down over "Step"and everything will keep runninguntil you release it'].	stepButton isInWorld ifFalse:		[aPosition _ associatedMorph			positionNear:				(self stopButton topRight + (1@0))			 forExtent:				stepButton extent			adjustmentSuggestion:				(0 @ (stepButton height negated)).		associatedMorph addMorph: (stepButton beRepelling position: aPosition)].	^ stepButton! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/12/1998 15:35'!goButtonState: newState	goButton ifNotNil:		[newState			ifTrue: [goButton state: #on]			ifFalse: [goButton state: #off]]! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/12/1998 15:35'!stepButtonState: newState	stepButton ifNotNil:		[newState			ifTrue: [stepButton state: #on]			ifFalse: [stepButton state: #off]]! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/12/1998 12:47'!stepStillDown: dummy with: theButton	self stepButtonState: true.	self stopButtonState: false.	theButton world stepAll; displayWorld.	(Delay forMilliseconds: 200) wait.	self stepButtonState: false.	self stopButtonState: true! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/12/1998 15:34'!stopButtonState: newState	stopButton ifNotNil:		[newState			ifTrue: [stopButton state: #on]			ifFalse: [stopButton state: #off]]! !!Presenter methodsFor: 'viewer' stamp: 'sw 5/13/1998 00:17'!viewMorph: aMorph	| aPlayer aViewer aPalette |	(aPalette _ aMorph standardPalette) ifNotNil:		[^ aPalette viewMorph: aMorph].	aPlayer _ aMorph assuredCostumee.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	aViewer setPlayer: aPlayer.	aViewer makeAllTilesGreen.	aMorph primaryHand attachMorph: aViewer! !!EToyPlayer methodsFor: 'other' stamp: 'sw 5/13/1998 00:10'!currentlyViewing: aPlayer	^ standardHolder eToyPalette currentlyViewing: aPlayer! !!EToyPlayer methodsFor: 'other' stamp: 'sw 5/13/1998 20:10'!morph: aMorph droppedIntoPasteUpMorph: aPasteUpMorph	(aPasteUpMorph == standardPlayfield) ifTrue:		[self viewMorph: aMorph]! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 5/13/1998 11:57'!bringUpToDate	"Make certain that the script name and the names of actors within are up to date"	| currentName titleMorph newName |	currentName _ playerScripted externalName.	titleMorph _ self findDeepSubmorphThat: [:m | m externalName = 'title'] ifAbsent: [nil].	titleMorph ifNotNil:		[newName _ self isAnonymous			ifTrue:				['script']			ifFalse:				[self scriptName].		titleMorph label: currentName, ' ', newName font: ScriptingSystem fontForTiles]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/13/1998 11:58'!scriptTitle	^ self isAnonymous ifFalse: [scriptName] ifTrue: ['script']! !!ScriptEditorMorph methodsFor: 'private' stamp: 'sw 5/13/1998 16:22'!removeEmptyRows	submorphs copy do: [:m |		(m isAlignmentMorph and: [m submorphCount = 0])			ifTrue: [m delete]].	self fullBounds.	self layoutChanged.	self flag: #noteToJohn.  "Screws up when we have nested IFs.  got broken in 11/97 when you made some emergency fixes for some other reason, and has never worked since...  Would be nice to have a more robust reaction to this!!""	self removeEmptyLayoutMorphs.	spacer _ LayoutMorph new extent: 10@12.	spacer vResizing: #rigid.	self privateAddMorph: spacer atIndex: self indexForLeadingSpacer.	spacer _ LayoutMorph new  extent: 10@12.	spacer vResizing: #rigid.	self privateAddMorph: spacer atIndex: (submorphs size + 1).	self fullBounds; layoutChanged."! !!ScriptInstantiation methodsFor: 'all' stamp: 'sw 5/13/1998 13:06'!assureEventHandlerRepresentsStatus	self status: self status! !!ScriptInstantiation methodsFor: 'all' stamp: 'sw 5/13/1998 10:43'!player: p	"Needed for making duplicate players, otherwise private"	player _ p! !!SystemWindow methodsFor: 'initialization' stamp: 'sw 5/11/1998 16:58'!step	model ifNotNil: [model step]! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'sw 5/13/1998 16:21'!deleteTab	self notYetImplemented! !!TileMorph methodsFor: 'private' stamp: 'sw 5/13/1998 14:53'!updateLiteralLabelClipped	"now works for operator tiles also"	|  desiredW leader myLabel |	myLabel _ nil.	submorphs do: [:m | (m isKindOf: StringMorph) ifTrue: [myLabel _ m]].	myLabel ifNil: [^ self].	myLabel contentsClipped:		(type == #literal			ifTrue:				[literal stringForReadout] 			ifFalse: [operatorReadoutString 				ifNil:		[ScriptingSystem wordingForOperator: operatorOrExpression]				ifNotNil:  	[operatorReadoutString]]).	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + myLabel width.	suffixArrow ifNotNil: [desiredW _ desiredW + SuffixArrowAllowance].	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	myLabel position: (self left + leader)@(bounds top + 5).	suffixArrow ifNotNil: [		suffixArrow			align: suffixArrow topRight			with: bounds topRight + (-2@(self height//2)) - (0@(suffixArrow height//2))].	self changed.! !!NumericReadoutTile methodsFor: 'all' stamp: 'sw 5/13/1998 15:20'!literal: anObject	literal _ anObject.	self updateLiteralLabel.	submorphs last informTarget.	"self acceptNewLiteral."		"Show that we are out of date, install is needed"	"self updateLiteralLabel"! !!NumericReadoutTile methodsFor: 'all' stamp: 'sw 5/13/1998 15:20'!literal: anObject width: w	literal _ anObject.	self updateLiteralLabelClipped.	submorphs last		setWidth: w;		informTarget.	self updateLiteralLabelClipped.	"self acceptNewLiteral."		"Show that we are out of date, install is needed"	"self updateLiteralLabel"! !!TransformationMorph methodsFor: 'accessing' stamp: 'sw 5/13/1998 10:32'!innocuousName	| r |	^ (r _ self renderedMorph) == self		ifTrue: [super innocuousName] ifFalse: [r innocuousName]! !!TransformationMorph methodsFor: 'menu' stamp: 'sw 5/12/1998 23:50'!removeFlexShell	"Remove the shell used to make a morph rotatable and scalable."	| oldHalo unflexed anActorState aName |	oldHalo _ self halo.	submorphs isEmpty ifTrue: [^ self delete].	unflexed _ self firstSubmorph.	(anActorState _ self valueOfProperty: #actorState) ifNotNil:		[unflexed setProperty: #actorState toValue: anActorState].	(aName _ self valueOfProperty: #name) ifNotNil:		[unflexed setProperty: #name toValue: aName].	unflexed costumee: costumee.	costumee ifNotNil:		[costumee costume: unflexed.		costumee _ nil].	self submorphs copy do: [:m |		m position: self center - (m extent // 2).		owner addMorph: m].	oldHalo ifNotNil: [oldHalo setTarget: unflexed].	self delete.! !!UserScript methodsFor: 'all' stamp: 'sw 5/13/1998 15:38'!bringUpToDate	self allScriptVersionsDo: [:v | v bringUpToDate]! !!UserScript methodsFor: 'all' stamp: 'sw 5/13/1998 12:49'!donorActor: player1 ownActor: player2	player _ player2.	currentScriptEditor ifNotNil: [currentScriptEditor donorActor: player1 ownActor: player2].	self allScriptVersionsDo: [:anEditor | anEditor donorActor: player1 ownActor: player2]! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 5/12/1998 10:01'!allExtantPlayers	"Inefficient and ultimately unacceptable, but for the current round of demos it will help keep things from stalling just because they're on hidden book pages.  Produces a list of all Player objects associated with any Morph in the tree.  Call #flushPlayerListCache to force recomputation."	playerList ifNotNil:		[^ playerList].	^ playerList _ (self allMorphsIncludingBookPages select: [:m | m costumee ~~ nil] thenCollect: [:m | m costumee]) asArray! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 5/13/1998 00:15'!allKnownNames	^ self allMorphs collect: [:m | m knownName] thenSelect: [:n | n ~~ nil]! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 5/11/1998 17:14'!flushPlayerListCache	playerList _ nil! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 5/12/1998 10:49'!specialNameInModelFor: aMorph	^ model ifNotNil: [model nameFor: aMorph] ifNil: [nil]! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 5/11/1998 19:33'!startRunningAll	"Start running all scripted morphs.  Triggered by user hitting GO button"	self flushPlayerListCache.  "Inefficient, but makes sure things come right whenever GO hit"	self allExtantPlayers do: [:aPlayer | aPlayer costume residesInPartsBin ifFalse: [aPlayer startRunning]].	self updateStatusForAllScriptEditors! !ActorState removeSelector: #externalName:!ActorState removeSelector: #knownName!ActorState removeSelector: #redirectToward:!ActorState removeSelector: #externalName!ChangeSet removeSelector: #removeNamedClassChanges:!EToyHolder removeSelector: #model:!EToyHolder removeSelector: #name!EToyHolder removeSelector: #model!EToyHolder removeSelector: #name:!EToyHolder initialize!EToyParameters class removeSelector: #dropAnythingOnPlayfield!Morph removeSelector: #assureExternalNameIn:!Morph removeSelector: #assureNameInModel!Player removeSelector: #knownName!Player removeSelector: #externalName:!Player removeSelector: #innocuousName!Player removeSelector: #duplicatedPlayer!Presenter removeSelector: #viewMorph:at:!ScriptEditorMorph removeSelector: #revert!ScriptEditorMorph removeSelector: #copyFrom:!ScriptEvaluatorMorph removeSelector: #updateStatus!ScriptInstantiation removeSelector: #redirectToward:!ScriptInstantiation removeSelector: #morphHandled!ScriptInstantiation removeSelector: #setToRunOn:in:!SimpleButtonMorph removeSelector: #initializeIconFromGIFNamed:!TransformationMorph removeSelector: #addFlexShellTo:!