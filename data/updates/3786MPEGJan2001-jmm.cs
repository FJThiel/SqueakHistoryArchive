'From Squeak3.1alpha of 5 February 2001 [latest update: #3795] on 6 March 2001 at 11:41:59 am'!"Change Set:		MPEGJan2001ConsolidationDate:			22 January 2001Author:			johnmci@smalltalkconsulting.comConsolidate MPEG change sets"!BlobMorph subclass: #BlobMPEGMorph	instanceVariableNames: 'mpegLogic form movieDrawArea primary quadNumber '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!BlobMPEGMorph commentStamp: '<historical>' prior: 0!Ok this is a little follow on to David's BlobMorph. Why not embedded a movie in the blob I thought. So with a few minutes of help from John Maloney we have something very interesting.Enjoy John M McIntosh <johnmci@smalltalkconsulting.com> Dec 2000. (Christmas early)!Morph subclass: #LedCharacterMorph	instanceVariableNames: 'char highlighted '	classVariableNames: 'BSegments CHSegmentOrigins CHSegments CVSegmentOrigins CVSegments DSegments TSegments '	poolDictionaries: ''	category: 'Morphic-Games'!!LedCharacterMorph commentStamp: '<historical>' prior: 0!char 36 is SPACE!LedCharacterMorph class	instanceVariableNames: ''!!LedMorph methodsFor: 'initialization' stamp: 'di 3/8/2001 23:44'!initialize	super initialize.	flashing _ false.	flash _ false.	self scrollInit.	self digits: 2.	self value: 0.	self color: Color green.! !!LedMorph methodsFor: 'initialization' stamp: 'di 3/8/2001 23:44'!scrollInit	chars _ 0.	scroller _ 1.	string _ ''.	scrollLoop _ false.! !Morph subclass: #LedMorph	instanceVariableNames: 'digits value flashing flash chars scrollLoop string scroller '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!LedMorph allInstancesDo: [:m | m scrollInit].!!LedMorph commentStamp: '<historical>' prior: 0!I am a collection of LED digits that can display a decimal value.  The display can be set to flash by sending flash: true.LedMorph can now display characters:LedMorph new  string:'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; openInWorldLowercase letters will be converted to Uppercase. Carachters not in the examleabove will be shown as SPACE which is char 36 in LedCharacterMorph.LedMorph new  chars: 10; string:'           I must get a life';flash:true;scrollLoop:true; openInWorldThe number of letters is set by chars. If chars is not specified it will be set to the string size. When the string size is bigger than charsthe string will scroll across the led. WOW!!scrollLoop let's you set the scrolling to start over once its finished.Enjoy.!Object subclass: #MPEGFile	instanceVariableNames: 'pathToFile fileBits fileIndex endianness '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'MPEG3-Kernel'!!MPEGFile commentStamp: '<historical>' prior: 0!* An interface to LibMPEG3 * Author: Adam Williams <broadcast@earthling.net> * Page: heroine.linuxbox.com * * Changed for Squeak to work with Squeak and to work on the Macintosh * Sept 2000, by John M McIntosh johnmci@smalltalkconsulting.com * The smalltalk code and the C code it produces is released under the  * Squeak licence. The libmpeg3 C code is co-licenced under either the Squeak licence or * the GNU LGPL!MPEGFile class	instanceVariableNames: ''!SketchMorph subclass: #MPEGImageMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MPEG3-Kernel'!Object subclass: #MPEGPlayer	instanceVariableNames: 'external form startTime clockBias frameRate lastDelay noSound sampleRate audioPlayerProcess videoPlayerProcess playerProcessPriority soundQueue timeCheck semaphoreForSound errorForSoundStart morph volume '	classVariableNames: ''	poolDictionaries: ''	category: 'MPEG3-Kernel'!!MPEGPlayer commentStamp: '<historical>' prior: 0!V1.01 johnmci@smalltalkconsulting.com Nov 8th 2000A Simple MPEG Player for playing MPEG3 audio or video | foo |foo _ MpegPlayer playFile: 'my.mpg'.foo playStream: 0. "To play both audio and video, stream #0 "foo playAudioStream: 0 "To play audio stream".foo playVideoStream: 0 "To play video stream"foo playStreamWaitTilDone: 0 "To play audio/video as currrent process"or 	| foo |	foo _ MPEGPlayer playFile: 'my.mpg' onForm: Display.	foo playStream: 0.	To play full screen.!MPEGPlayer class	instanceVariableNames: ''!Object subclass: #MPEGPlayer2	instanceVariableNames: 'foo soundQueue startTime audioPlayerProcess videoPlayerProcess timecode volume videoMorph startFrame dropOut time '	classVariableNames: ''	poolDictionaries: ''	category: 'MPEG3-Kernel'!MPEGPlayer2 class	instanceVariableNames: ''!Morph subclass: #MPEGPlayerMorph	instanceVariableNames: 'foo play progress videoMorph volume playOrStop ledWasUndeclared '	classVariableNames: ''	poolDictionaries: ''	category: 'MPEG3-Kernel'!TestInterpreterPlugin subclass: #Mpeg3Plugin	instanceVariableNames: 'maximumNumberOfFilesToWatch mpegFiles '	classVariableNames: ''	poolDictionaries: ''	category: 'VMConstruction-Plugins'!!Mpeg3Plugin commentStamp: '<historical>' prior: 0!/******************************************************** * An interface to LibMPEG3 * Author: Adam Williams <broadcast@earthling.net> * Page: heroine.linuxbox.com * * Changed for Squeak to work with Squeak and to work on the Macintosh * Sept 2000, by John M McIntosh johnmci@smalltalkconsulting.com * The smalltalk code and the C code it produces is released under the  * Squeak licence. The libmpeg3 C code is co-licenced under either the Squeak licence or * the GNU LGPL!Mpeg3Plugin class	instanceVariableNames: ''!Slider subclass: #VolumeMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MPEG3-Kernel'!!BlobMPEGMorph methodsFor: 'access' stamp: 'JMM 10/19/2000 16:02'!form	^form! !!BlobMPEGMorph methodsFor: 'access' stamp: 'JMM 10/19/2000 16:02'!form: aForm	form _ aForm! !!BlobMPEGMorph methodsFor: 'access' stamp: 'JMM 12/19/2000 16:01'!movieDrawArea	^movieDrawArea! !!BlobMPEGMorph methodsFor: 'access' stamp: 'JMM 10/19/2000 15:54'!mpegLogic	^mpegLogic! !!BlobMPEGMorph methodsFor: 'access' stamp: 'JMM 10/19/2000 15:54'!mpegLogic: aValue	mpegLogic _ aValue! !!BlobMPEGMorph methodsFor: 'access' stamp: 'JMM 12/19/2000 15:45'!primary	^primary! !!BlobMPEGMorph methodsFor: 'access' stamp: 'JMM 12/19/2000 21:52'!quadNumber	^quadNumber! !!BlobMPEGMorph methodsFor: 'access' stamp: 'JMM 1/4/2001 10:53'!quadNumber: aNumber	quadNumber _ aNumber! !!BlobMPEGMorph methodsFor: 'access' stamp: 'JMM 10/19/2000 15:59'!stream	^0! !!BlobMPEGMorph methodsFor: 'initialization' stamp: 'JMM 1/4/2001 11:06'!initialize: primaryFlag mpegPlayer: aMpegPlayerOrFileName 	| rect sizeToOverLapBoundary |	primary _ primaryFlag.	rect _ self bounds.	sizeToOverLapBoundary _ 3.0.	primary 		ifTrue: [form _ Form extent: 					((sizeToOverLapBoundary * rect width) @ (sizeToOverLapBoundary * rect height)) truncated depth: 32.				movieDrawArea _ SketchMorph withForm: form.				mpegLogic _ MPEGPlayer playFile: aMpegPlayerOrFileName onMorph: movieDrawArea]		ifFalse: [form _ aMpegPlayerOrFileName form.				movieDrawArea _ aMpegPlayerOrFileName movieDrawArea.				mpegLogic _ aMpegPlayerOrFileName mpegLogic]! !!BlobMPEGMorph methodsFor: 'initialization' stamp: 'JMM 1/4/2001 11:02'!initializeBlobShape	| verts modifier |	verts _ {59@40. 74@54. 79@74. 77@93. 57@97. 37@97. 22@83. 15@67. 22@50. 33@35. 47@33}.	modifier _ 0 @ 0.	(self quadNumber = 2) ifTrue: [ modifier _ 0 @ 75].	(self quadNumber = 3) ifTrue: [ modifier _ 75 @ 0].	(self quadNumber = 4) ifTrue: [ modifier _ 75 @ 75].	verts _ verts + modifier.	self 		vertices: verts		color: self color		borderWidth: 1		borderColor: Color black! !!BlobMPEGMorph methodsFor: 'initialization' stamp: 'JMM 1/4/2001 10:54'!initializeChildMpegPlayer: aMpegPlayerOrFileName  	self initialize: false mpegPlayer: aMpegPlayerOrFileName ! !!BlobMPEGMorph methodsFor: 'initialization' stamp: 'JMM 1/4/2001 10:54'!initializePrimaryMpegPlayer: aMpegPlayerOrFileName  	self initialize: true mpegPlayer: aMpegPlayerOrFileName  ! !!BlobMPEGMorph methodsFor: 'stepping' stamp: 'JMM 10/19/2000 15:57'!adjustColors	^self! !!BlobMPEGMorph methodsFor: 'stepping' stamp: 'JMM 12/19/2000 15:39'!limitRange: verts	" limit radius to range 20-120; limit interpoint angle to surrounding angles with max of twice of average separation. "	| cent new prevn nextn prevDeg nextDeg thisDeg dincr |	cent := self bounds center.	new := Array new: verts size.	dincr := 360 // verts size.	verts doWithIndex: [ :pt :n |		"Find prev/next points, allowing for wrapping around "		prevn := n-1 < 1 ifTrue: [new size] ifFalse: [n-1].		nextn := n+1 > new size ifTrue: [1] ifFalse: [n+1].		"Get prev/this/next point's angles "		prevDeg := ((verts at: prevn)-cent) degrees.		thisDeg := ((verts at: n)-cent) degrees.		nextDeg := ((verts at: nextn)-cent) degrees.		"Adjust if this is where angles wrap from 0 to 360"		(thisDeg - prevDeg) abs > 180 ifTrue: [ prevDeg := prevDeg - 360 ].		(thisDeg - nextDeg) abs > 180 ifTrue: [ nextDeg := nextDeg + 360 ].		"Put adjusted point into new collection"		new at: n put: cent +			(self selfPolarPointRadius: ((((pt - cent) r) min: 60) max: 20) "was min: 80"				degrees: (((thisDeg min: nextDeg-5) max: prevDeg+5) min: dincr*2+prevDeg)) ].	^ new! !!BlobMPEGMorph methodsFor: 'stepping' stamp: 'JMM 12/19/2000 15:29'!mergeBlobs	^self! !!BlobMPEGMorph methodsFor: 'stepping' stamp: 'JMM 10/19/2000 16:29'!stepTime	^1.0 / (self mpegLogic videoFrameRate: self stream) * 1000! !!BlobMPEGMorph methodsFor: 'drawing' stamp: 'JMM 1/4/2001 11:18'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line 	segments. Fill with the MPEG movie"	| cm f filled quadRect |	cm _ Bitmap new: 2.	cm at: 1 put: 0.	cm at: 2 put: 32767.	f _ Form extent: self extent depth: 16.	filled _ self filledForm.	(BitBlt toForm: f) sourceForm: filled;		 sourceRect: filled boundingBox;				destRect: (0 @ 0 extent: filled extent);		 colorMap: cm;		 combinationRule: Form over;		 copyBits.	quadNumber = 1		ifTrue: [quadRect _ Rectangle origin: form boundingBox topLeft corner: form boundingBox center].	quadNumber = 2		ifTrue: [quadRect _ Rectangle origin: form boundingBox topCenter corner: form boundingBox rightCenter].	quadNumber = 3		ifTrue: [quadRect _ Rectangle origin: form boundingBox leftCenter corner: form boundingBox bottomCenter].	quadNumber = 4		ifTrue: [quadRect _ Rectangle origin: form boundingBox center corner: form boundingBox bottomRight].	(BitBlt toForm: f) sourceForm: form;		 sourceRect: quadRect;				destRect: (0 @ 0 extent: f extent);		 combinationRule: Form and;		 copyBits.	aCanvas image: f at: self position.	self drawBorderOn: aCanvas.	self drawArrowsOn: aCanvas! !!BlobMPEGMorph methodsFor: 'drawing' stamp: 'JMM 1/4/2001 11:07'!playStream: aStream	mpegLogic playStream: aStream.! !!BlobMPEGMorph methodsFor: 'drawing' stamp: 'JMM 12/19/2000 16:41'!playVideoStream: aStream	mpegLogic playVideoStream: aStream.! !!BlobMPEGMorph class methodsFor: 'instance creation' stamp: 'JMM 1/4/2001 11:10'!buildMorphics: aFileName	| primary child |	primary _ (self basicNew quadNumber: 1) initialize.	self remember: primary.	primary initializePrimaryMpegPlayer: aFileName.	primary openInWorld.	2 to: 4 do: [:i | 		child _ (self basicNew quadNumber: i) initialize.		self remember: child.		child initializeChildMpegPlayer: primary.		child openInWorld].	^primary! !!BlobMPEGMorph class methodsFor: 'instance creation' stamp: 'JMM 1/4/2001 11:11'!newWithMovie: aFileName	| primary |	primary _ self buildMorphics: aFileName.	primary playStream: 0.	^primary! !!BlobMPEGMorph class methodsFor: 'instance creation' stamp: 'JMM 1/4/2001 11:12'!newWithMovieNoSound: aFileName	| primary |	primary _ self buildMorphics: aFileName.	primary playVideoStream: 0.	^primary! !!LedCharacterMorph methodsFor: 'initialization' stamp: 'kfr 5/26/2000 20:12'!initialize	super initialize.	color _ Color green.	highlighted _ false.	char _ 0.! !!LedCharacterMorph methodsFor: 'accessing' stamp: 'kfr 5/26/2000 20:02'!char	 ^ char ! !!LedCharacterMorph methodsFor: 'accessing' stamp: 'kfr 6/12/2000 15:13'!char: aCharacter 	char _ aCharacter digitValue.	char >= 0 & (char <= 35) ifFalse: [char _ 36]! !!LedCharacterMorph methodsFor: 'accessing' stamp: 'kfr 5/26/2000 19:03'!highlighted	^ highlighted! !!LedCharacterMorph methodsFor: 'accessing' stamp: 'kfr 5/26/2000 19:03'!highlighted: aBoolean	highlighted _ aBoolean.	self changed.! !!LedCharacterMorph methodsFor: 'drawing' stamp: 'kfr 6/3/2000 21:29'!drawOn: aCanvas 	| foregroundColor backgroundColor thickness hThickness vThickness hOffset vOffset bOrigin i |	i _ 0.	foregroundColor _ highlighted				ifTrue: [Color white]				ifFalse: [color].	backgroundColor _ color darker darker darker.	hThickness _ self height * 0.1.	vThickness _ self width * 0.1.	thickness _ hThickness min: vThickness.	vOffset _ hThickness - thickness // 2 max: 0.	hOffset _ vThickness - thickness // 2 max: 0.	aCanvas fillRectangle: self bounds color: backgroundColor.	CHSegmentOrigins with: (CHSegments at: char + 1)		do: [:o :isLit | aCanvas fillRectangle: (Rectangle origin: (self position + (0 @ vOffset) + (o * self extent)) rounded extent: (self width * 0.6 @ thickness) rounded)				color: (isLit						ifTrue: [foregroundColor]						ifFalse: [backgroundColor])].	CVSegmentOrigins with: (CVSegments at: char + 1)		do: [:o :isLit | aCanvas fillRectangle: (Rectangle origin: (self position + (hOffset @ 0) + (o * self extent)) rounded extent: (thickness @ (self height * 0.25)) rounded)				color: (isLit						ifTrue: [foregroundColor]						ifFalse: [backgroundColor])].	TSegments with: (DSegments at: char + 1)		do: 			[:tOrigin :isLit | 			i _ i + 1.			bOrigin _ BSegments at: i.			aCanvas				line: self position x - hOffset + (self width * tOrigin x) @ (self position y - vOffset + (self height * tOrigin y))				to: self position x + hOffset + (self width * bOrigin x) @ (self position y + vOffset + (self height * bOrigin y))				width: thickness + 1 // 1.25				color: (isLit						ifTrue: [foregroundColor]						ifFalse: [Color transparent])]! !!LedCharacterMorph methodsFor: 'drawing' stamp: 'kfr 5/26/2000 19:03'!drawOnFills: aRectangle	^ true! !!LedCharacterMorph class methodsFor: 'initialization' stamp: 'kfr 5/26/2000 19:03'!includeInNewMorphMenu	^false! !!LedCharacterMorph class methodsFor: 'initialization' stamp: 'kfr 6/3/2000 21:32'!initialize	CHSegmentOrigins _ {0.2@0.1. 0.2@0.45. 0.2@0.8}.	CVSegmentOrigins _ {0.1@0.2. 0.1@0.55. 0.8@0.2. 0.8@0.55}.	TSegments _ { 0.25@0.25. 0.45@0.25. 0.55@0.25. 0.75@0.25. 0.25@0.6. 0.45@0.6. 0.55@0.6. 0.75@0.6. }.	BSegments _ { 0.45@0.4. 0.25@0.4. 0.75@0.4. 0.55@0.4. 0.45@0.76. 0.25@0.76. 0.75@0.76. 0.55@0.76. }.	DSegments  _ {	{false. false. false. false. false. false. false. false. }."0"	{false. false. false. false. false. false. false. false. }."1"	{false. false. false. false. false. false. false. false. }."2"	{false. false. false. false. false. false. false. false. }."3"	{false. false. false. false. false. false. false. false. }."4"	{false. false. false. false. false. false. false. false. }."5"	{false. false. false. false. false. false. false. false. }."6"	{false. false. false. false. false. false. false. false. }."7"	{false. false. false. false. false. false. false. false. }."8"	{false. false. false. false. false. false. false. false. }."9"	{false. false. false. false. false. false. false. false. }."A"	{false. false. false. false. false. false. false. false. }."B"	{false. false. false. false. false. false. false. false. }."C"	{false. false. false. false. false. false. false. false. }."D"	{false. false. false. false. false. false. false. false. }."E"	{false. false. false. false. false. false. false. false. }."F"	{false. false. false. false. false. false. false. false. }."G"	{false. false. false. false. false. false. false. false. }."H"	{false. false. false. false. false. false. false. false. }."I"	{false. false. false. false. false. false. false. false. }."J"	{false. false. false. true. false. false. false. false. }."K"	{false. false. false. false. false. false. false. false. }."L"	{true. false. false. true. false. false. false. false. }."M"	{true. false. false. false. false. false. true. false. }."N"	{false. true. true. false. true. false. false. true.  }."O"	{false. false. false. false. false. false. false. false. }."P"	{false. false. false. false. false. false. true. false. }."Q"	{false. false. false. false. false. false. true. false. }."R"	{false. false. false. false. false. false. false. false. }."S"	{false. false. false. false. false. false. false. false. }."T"	{false. false. false. false. false. false. false. false. }."U"	{false. false. false. false. true. false. false. true. }."V"	{false. false. false. false. false. true. true. false. }."W"	{true. false. false. true. false. true. true. false. }."X"	{false. false. false. false. false. false. false. false. }."Y"	{false. false. false. true. false. true. false. false. }."Z"	{false. false. false. false. false. false. false. false. }}."SPACE"	CHSegments _ {		{true. false. true}."0"		{false. false. false}."1"		{true. true. true}."2"		{true. true. true}."3"		{false. true. false}."4"		{true. true. true}."5"		{true. true. true}."6"		{true. false. false}."7"		{true. true. true}."8"		{true. true. true}."9"		{true. true. false}."A"		{true. true. true}."B"		{true. false. true}."C"		{true. false. true}."D"		{true. true. true}."E"		{true. true. false}."F"		{true. true. true}."G"		{false. true. false}."H"		{false. false. false}."I"		{false. false. true}."J"		{false. true. false}."K"		{false. false. true}."L"		{false. false. false}."M"		{false. false. false}."N"		{false. false. false}."O"		{true. true. false}."P"		{true. false. true}."Q"		{true. true. false}."R"		{true. true. true}."S"		{false. true. true}."t"		{false. false. true}."U"		{false. false. false}."V"		{false. false. false}."W"		{false. false. false}."X"		{false. true. true}."Y"		{true. false. true}."Z"		{false. false. false.}}."SPACE"	CVSegments _ {		{true. true.  true. true}."0"		{false. false. true. true}."1"		{false. true. true. false}."2"		{false. false. true. true}."3"		{true. false. true. true}."4"		{true. false. false. true}."5"		{true. true. false. true}."6"		{false. false. true. true}."7"		{true. true. true. true}."8"		{true. false. true. true}."9"		{true. true. true. true}."A"		{true. true. true. true}."B"		{true. true. false. false}."C"		{true. true. true. true}."D"		{true. true. false. false}."E"		{true. true. false. false}."F"		{true. true. false. true}."G"		{true. true. true. true}."H"		{true. true. false. false}."I"		{false. true. true. true}."J"		{true. true. false. true}."K"		{true. true. false. false}."L"		{true. true.  true. true}."N"		{true. true. true. true}."N"		{false. false. false. false}."O"		{true. true. true. false}."P"		{true. true.  true. true}."q"		{true. true. true. false}."R"		{true. false. false. true}."S"		{true. true. false. false}."t"		{true. true. true. true}."U"		{true. false. true. false}."V"		{true. true.  true. true}."w"		{false. false. false. false}."x"		{true. false. true. true}."y"		{false. false. false. false}."z"		{false. false. false. false}}."SPACE"! !!LedMorph methodsFor: 'accessing' stamp: 'kfr 5/26/2000 20:16'!chars	 ^ chars! !!LedMorph methodsFor: 'accessing' stamp: 'kfr 6/3/2000 21:27'!chars: aNumber 	chars _ aNumber.	self removeAllMorphs.	1 to: chars do: [:i | self addMorph: (LedCharacterMorph new color: color)].	self layoutChanged.	self changed! !!LedMorph methodsFor: 'accessing' stamp: 'kfr 6/1/2000 18:50'!scrollLoop		^ scrollLoop! !!LedMorph methodsFor: 'accessing' stamp: 'kfr 6/1/2000 18:50'!scrollLoop: aBoolean	scrollLoop _ aBoolean.! !!LedMorph methodsFor: 'accessing' stamp: 'kfr 5/26/2000 20:25'!string	^ string! !!LedMorph methodsFor: 'accessing' stamp: 'kfr 6/12/2000 15:29'!string: aString 	string _ aString.	chars = 0		ifTrue: 			[chars _ string size.			self chars: chars].	self stringToLed! !!LedMorph methodsFor: 'accessing' stamp: 'kfr 6/3/2000 21:26'!stringToLed	| i k actualString |	i _ scroller.	k _ 1.	actualString _ String new: chars.	actualString do: 		[:m | 		i > string size ifFalse: [actualString at: k put: (string at: i) asUppercase asCharacter].		i _ i + 1.		k _ k + 1].	i _ 1.	submorphs do: 		[:m | 		m char: (actualString at: i).		i _ i + 1].	self changed! !!LedMorph methodsFor: 'stepping' stamp: 'kfr 6/3/2000 21:28'!step	(flash or: [flashing])		ifTrue: 			[flashing _ flashing not.			self highlighted: flashing].	scroller + chars < (string size + 1)		ifTrue: 			[scroller _ scroller + 1.			self stringToLed]		ifFalse: [scrollLoop ifTrue: [scroller _ 1]]! !!MPEGFile methodsFor: 'access' stamp: 'JMM 11/10/2000 00:26'!endianness	^endianness isNil ifTrue: [endianness _ Smalltalk endianness] ifFalse: [endianness]! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 19:04'!fileHandle	(Smalltalk externalObjects at: fileIndex ifAbsent: [^nil]) == fileBits 		ifTrue: [^fileBits]		ifFalse: [^nil].! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/18/2000 18:38'!fileName	^pathToFile! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:54'!getPercentage	"Return current location by percentage, 0.0-1.0"	^self primGetPercentage: self fileHandle ! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/29/2000 19:28'!getTOC: timecode doStreams: streams	| buffer |		buffer _ String new: 64*1024+1.	self primGenerateToc: self fileHandle useSearch: timecode doStreams: streams buffer: buffer.	^buffer! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:56'!getTimeCode	"Return time code, (float) "	^self primGetTime: self fileHandle! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:53'!seekPercentage: aFloat	self primSeekPercentage: self fileHandle percentage: aFloat asFloat ! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:56'!setMMX: aValue	" true is set, false is off. May not be supported "	self primSetMMX: self fileHandle useMMX: aValue  ! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:12'!audioChannels: aStream	"Returns -1 if error, otherwise returns audioChannels for stream aStream"	self hasAudio ifFalse: [^-1].	^[self primAudioChannels: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioGetSample: aStream	"Returns number of current sample, or -1 if error"	self hasAudio ifFalse: [^-1].	^[(self primGetSample: self fileHandle stream: aStream) asInteger] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioReReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber	"Used to read other channels after first ReadBuffer 	Returns -1 if error, otherwise 0"	self hasAudio ifFalse: [^-1].	^[self audioReReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: (aBuffer size * aBuffer bytesPerElement // 2)] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioReReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: aSampleNumber	"Used to read other channels after first ReadBuffer 	Returns -1 if error, otherwise 0	Note this call requires passing in the samples to read, ensure you get the number right"	self hasAudio ifFalse: [^-1].	^[self primAudioReReadBuffer: self fileHandle  buffer: aBuffer channel: aChannelNumber samples: aSampleNumber stream: aStreamNumber] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber 	"Returns -1 if error, otherwise 0"	self hasAudio ifFalse: [^-1].	^[self audioReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: (aBuffer size* aBuffer bytesPerElement)//2] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: aSampleNumber	"Returns -1 if error, otherwise 0	Note this call requires passing in the samples to read, ensure you get the number right"	self hasAudio ifFalse: [^-1].	^[self primAudioReadBuffer: self fileHandle  buffer: aBuffer channel: aChannelNumber samples: aSampleNumber stream: aStreamNumber] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioSampleRate: aStream	"Returns sample rate, or -1 if error"	self hasAudio ifFalse: [^-1].	^[self primSampleRate: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioSamples: aStream	"Returns -1 if error, 	otherwise returns audioSamples for stream aStream"	self hasAudio ifFalse: [^-1].	^[(self primAudioSamples: self fileHandle stream: aStream) asInteger] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioSetSample: aNumber stream: aStream	"Set number of targeted sample, returns 0 if ok, -1 if failure"	self hasAudio ifFalse: [^-1].	^[self primSetSample: self fileHandle sample: aNumber asFloat stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 9/20/2000 01:57'!endOfAudio: aStream	"Returns true if end of Audio"	self hasAudio ifFalse: [^true].	^self primEndOfAudio: self fileHandle stream: aStream! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 9/20/2000 01:56'!hasAudio	"Returns true if file has audio"	^self primHasAudio: self fileHandle ! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 9/20/2000 01:53'!totalAudioStreams	"Returns total number of audio streams"	^self primTotalAudioStreams: self fileHandle ! !!MPEGFile methodsFor: 'finalization' stamp: 'JMM 9/20/2000 02:05'!finalize	self fileHandle notNil ifTrue: [self primFileClose: self fileHandle].	self fileHandle = fileBits ifTrue: [Smalltalk unregisterExternalObject: fileIndex].	fileBits _ nil.		fileIndex _ 0.! !!MPEGFile methodsFor: 'initialize-release' stamp: 'JMM 9/20/2000 01:59'!closeFile	self finalize.! !!MPEGFile methodsFor: 'initialize-release' stamp: 'JMM 9/18/2000 03:21'!initialize! !!MPEGFile methodsFor: 'initialize-release' stamp: 'JMM 9/20/2000 01:57'!openFile: aPath	pathToFile _ aPath.	fileBits _ self primFileOpen: aPath.	fileBits notNil ifTrue: 		[fileIndex _ Smalltalk registerExternalObject: fileBits.		self register.]	! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:19'!primAudioChannels: aHandle stream: aStream	<primitive: 'primitiveMPEG3AudioChannels' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/19/2000 13:35'!primAudioReReadBuffer: aFileHandle  buffer: aBuffer channel: aChannel samples: aSampleNumber stream: aStreamNumber	<primitive: 'primitiveMPEG3ReReadAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/19/2000 13:31'!primAudioReadBuffer: aFileHandle  buffer: aBuffer channel: aChannel samples: aSampleNumber stream: aStreamNumber	<primitive: 'primitiveMPEG3ReadAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:23'!primAudioSamples: aHandle stream: aStream	<primitive: 'primitiveMPEG3AudioSamples' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 17:54'!primDropFrame: aHandle frame: aNumberOfFrames stream: aStream	<primitive: 'primitiveMPEG3DropFrames' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:50'!primEndOfAudio: aHandle stream: aStream	<primitive: 'primitiveMPEG3EndOfAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:51'!primEndOfVideo: aHandle stream: aStream	<primitive: 'primitiveMPEG3EndOfVideo' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 13:58'!primFileClose: aHandle	"Close the file"	<primitive: 'primitiveMPEG3Close' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 03:56'!primFileOpen: aPath	"Open the file"	<primitive: 'primitiveMPEG3Open' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:52'!primFrameRate: aHandle stream: aStream	<primitive: 'primitiveMPEG3FrameRate' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/29/2000 17:29'!primGenerateToc: fileHandle useSearch: timecode doStreams: streams buffer: aString	<primitive: 'primitiveMPEG3GenerateToc' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:11'!primGetFrame: aHandle stream: aStream	<primitive: 'primitiveMPEG3GetFrame' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:37'!primGetPercentage: aHandle	<primitive: 'primitiveMPEG3TellPercentage' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:12'!primGetSample: aHandle stream: aStream	<primitive: 'primitiveMPEG3GetSample' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:15'!primGetTime: aFileHandle	<primitive: 'primitiveMPEG3GetTime' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:59'!primHasAudio: aHandle	<primitive: 'primitiveMPEG3HasAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:59'!primHasVideo: aHandle	<primitive: 'primitiveMPEG3HasVideo' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:17'!primPreviousFrame: aHandle stream: aStream	<primitive: 'primitiveMPEG3PreviousFrame' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:19'!primSampleRate: aHandle stream: aStream	<primitive: 'primitiveMPEG3SampleRate' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:23'!primSeekPercentage: aHandle percentage: aNumber	<primitive: 'primitiveMPEG3SeekPercentage' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:27'!primSetCPUs: aHandle number: aNumber	"Not support on the macintosh below OS X"	<primitive: 'primitiveMPEG3SetCpus' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:29'!primSetFrame: aHandle frame: aFrameNumber stream: aStream	<primitive: 'primitiveMPEG3SetFrame' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:31'!primSetMMX: aFileHandle useMMX: aValue  	<primitive: 'primitiveMPEG3SetMmx' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:35'!primSetSample: aHandle sample: aSampleNumber stream: aStream	<primitive: 'primitiveMPEG3SetSample' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:39'!primTotalAudioStreams: aFileHandle 	<primitive: 'primitiveMPEG3TotalAStreams' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:40'!primTotalVideoStreams: aFileHandle 	<primitive: 'primitiveMPEG3TotalVStreams' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:41'!primVideoFrames: aFileHandle  stream: aStream	<primitive: 'primitiveMPEG3VideoFrames' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:41'!primVideoHeight: aFileHandle  stream: aStream	<primitive: 'primitiveMPEG3VideoHeight' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/19/2000 13:28'!primVideoReadNextFrameFor: aFileHandle into: aFormBuffer x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aByteCount	<primitive: 'primitiveMPEG3ReadFrame' module: 'Mpeg3Plugin'>! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 16:35'!primVideoWidth: aFileHandle  stream: aStream	<primitive: 'primitiveMPEG3VideoWidth' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'registry' stamp: 'JMM 9/17/2000 23:58'!register	^self class register: self! !!MPEGFile methodsFor: 'registry' stamp: 'JMM 9/17/2000 23:58'!unregister	^self class unregister: self! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:54'!endOfVideo: aStream	"Returns true if end of video"	self hasVideo ifFalse: [^true].	^self primEndOfVideo: self fileHandle stream: aStream! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:54'!hasVideo	"Returns true if file has video"	^self primHasVideo: self fileHandle ! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:59'!totalVideoStreams	"Returns total number of video streams"	^self primTotalVideoStreams: self fileHandle ! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:14'!videoDropFrames: aNumberOfFrames stream: aStream	"Returns -1 if setFrame failed"	self hasVideo ifFalse: [^-1].	^[self primDropFrame: self fileHandle frame: aNumberOfFrames stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:14'!videoFrameHeight: aStream	"Returns video frame height, -1 if error "	self hasVideo ifFalse: [^-1].	^[self primVideoHeight: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:14'!videoFrameRate: aStream	"Returns video frame rate (float), -1 if error"	self hasVideo ifFalse: [^-1].	^[self primFrameRate: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:14'!videoFrameWidth: aStream	"Returns video frame width, -1 if error"	self hasVideo ifFalse: [^-1].	^[self primVideoWidth: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:58'!videoFrames: aStream	"Total number of frames" 	^(self primVideoFrames: self fileHandle stream: aStream) asInteger! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:14'!videoGetFrame: aStream	"Returns frame number, or -1 if error"	self hasVideo ifFalse: [^-1].	^[(self primGetFrame: self fileHandle stream: aStream) asInteger] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:15'!videoPreviousFrame: aStream	"Returns 0 if ok"	self hasVideo ifFalse: [^-1].	^[self primPreviousFrame: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/10/2000 00:24'!videoReadNext16BitFrameInto: aFormBuffer width: aTargetWidth height: aTargetHeight stream: aStream	"return non zero if failure"	| width height colorModel x y |	width _ self videoFrameWidth: aStream.	height _ self videoFrameHeight: aStream.	colorModel _ self endianness = #big ifTrue: [14] ifFalse: [16]. 	x _ 0.	y _ 0. 	^self videoReadNextFrameInto: aFormBuffer x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aTargetWidth*2! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/10/2000 00:24'!videoReadNextFrameInto: aFormBuffer width: aTargetWidth height: aTargetHeight stream: aStream	"return non zero if failure"	| width height colorModel x y |	width _ self videoFrameWidth: aStream.	height _ self videoFrameHeight: aStream.	colorModel _ self endianness = #big ifTrue: [13] ifFalse: [1]. 	x _ 0.	y _ 0. 	^self videoReadNextFrameInto: aFormBuffer x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aTargetWidth*4! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:15'!videoReadNextFrameInto: aFormBuffer x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aByteCount	"return nonZero if failure "	self hasVideo ifFalse: [^-1].	^[self primVideoReadNextFrameFor: self fileHandle into: aFormBuffer x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aByteCount] on: Error do: [-1]"/* Supported color models for mpeg3_read_frame */#define MPEG3_RGB565 2#define MPEG3_RGB555 14  //JMM for mac#define MPEG3_RGBI555 16  //SVP for intel#define MPEG3_BGR888 0#define MPEG3_BGRA8888 1#define MPEG3_RGB888 3#define MPEG3_RGBA8888 4  #define MPEG3_ARGB8888 13  //JMM for mac#define MPEG3_RGBA16161616 5/* Color models for the 601 to RGB conversion *//* 601 not implemented for scalar code */#define MPEG3_601_RGB565 11#define MPEG3_601_RGB555 15 //JMM for Squeak#define MPEG3_601_RGBI555 17 //SVP for intel#define MPEG3_601_BGR888 7#define MPEG3_601_BGRA8888 8#define MPEG3_601_RGB888 9#define MPEG3_601_RGBA8888 10#define MPEG3_601_ARGB8888 12 //JMM for Squeak"! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:58'!videoSetCPUs: aNumber	self primSetCPUs: self fileHandle number: aNumber! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:15'!videoSetFrame: aFrameNumber stream: aStream	"Returns -1 if setFrame failed"	self hasVideo ifFalse: [^-1].	^[self primSetFrame: self fileHandle frame: aFrameNumber asFloat stream: aStream] on: Error do: [-1]! !!MPEGFile class methodsFor: 'registry' stamp: 'JMM 9/17/2000 23:56'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!MPEGFile class methodsFor: 'registry' stamp: 'JMM 9/17/2000 23:56'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!MPEGFile class methodsFor: 'registry' stamp: 'JMM 9/17/2000 23:56'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!MPEGFile class methodsFor: 'instance creation' stamp: 'JMM 9/18/2000 03:27'!openFile: aPath	^self new initialize openFile: aPath.! !!MPEGFile class methodsFor: 'testing' stamp: 'JMM 9/18/2000 14:28'!isFileValidMPEG: path	^self primFileValidMPEG: path! !!MPEGFile class methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:27'!primFileValidMPEG: aPath	"Check to see if the file is valid"	<primitive: 'primitiveMPEG3CheckSig' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGImageMorph methodsFor: 'drawing' stamp: 'JMM 11/8/2000 14:47'!drawOn: aCanvas	aCanvas drawImage: self rotatedForm at: bounds origin ! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:59'!audioPlayerProcess	^audioPlayerProcess ! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:39'!audioPlayerProcess: aProcess	audioPlayerProcess _ aProcess! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:31'!clockBias	^clockBias! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:31'!clockBias: aArray	clockBias _ aArray! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:31'!clockBiasForStream: aStream	^self clockBias at: aStream + 1.! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:32'!clockBiasForStream: aStream put: aValue	self clockBias at: aStream + 1 put: aValue! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 11/8/2000 10:30'!currentAudioSampleForStream: aStream	^self external audioGetSample: aStream! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 11/8/2000 10:31'!currentAudioSampleForStream: aStream put: aNumber	self external audioSetSample: aNumber stream: aStream! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 11/8/2000 10:29'!currentVideoFrameForStream: aStream	^self external videoGetFrame: aStream! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 11/8/2000 10:30'!currentVideoFrameForStream: aStream put: aNumber	self external videoSetFrame: aNumber stream: aStream! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 18:33'!errorForSoundStart: aValueInMilliseconds	errorForSoundStart _ aValueInMilliseconds! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 11/19/2000 11:52'!external	[external hasVideo] on: Error do: 		[(MPEGFile isFileValidMPEG: external fileName) 			ifFalse: [^self error: 'Mpeg File is invalid'].		external _ MPEGFile openFile: external fileName].	^external! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 11/8/2000 10:31'!fileName	^self external fileName! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 10/17/2000 23:29'!form	form isNil ifTrue: 		[self morph isNil ifTrue: [^nil].		^self morph form].	^form! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:37'!form: aForm	form _ aForm! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/19/2000 17:39'!frameRate	^frameRate! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:36'!frameRate: aRate	frameRate _ aRate! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:04'!lastDelay	^lastDelay! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:03'!lastDelay: aNumber	lastDelay _ aNumber! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 10/17/2000 23:20'!morph	^morph! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 10/17/2000 23:20'!morph: aMorph		morph _ aMorph.! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 10/20/2000 22:36'!mpegFile	^external! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:59'!noSound	^noSound! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:59'!noSound: flag	noSound _ flag! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/19/2000 17:59'!playerProcessPriority	^playerProcessPriority! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/19/2000 17:59'!playerProcessPriority: aNumber	playerProcessPriority _ aNumber! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/19/2000 17:34'!sampleRate	^sampleRate! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:36'!sampleRate: aRate	sampleRate _ aRate! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:01'!soundQueue	^soundQueue! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:01'!soundQueue: aQueue	soundQueue _ aQueue! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:38'!startTime	^startTime! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:38'!startTime: aArray	startTime _ aArray! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:12'!startTimeForStream: aStream	^self startTime at: aStream + 1! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:11'!startTimeForStream: aStream put: aNumber	^self startTime at: aStream + 1 put: aNumber! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:03'!timeCheck	^timeCheck! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:02'!timeCheck: aNumber	timeCheck _ aNumber! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:58'!videoPlayerProcess	^videoPlayerProcess ! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:58'!videoPlayerProcess: aProcess	videoPlayerProcess _ aProcess! !!MPEGPlayer methodsFor: 'access' stamp: 'kfr 11/9/2000 21:21'!volume: aVolume	volume _ aVolume! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:29'!audioChannels: aStream	^self external audioChannels: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:31'!audioSampleRate: aStream	^self external audioSampleRate: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!audioSamples: aStream	^self external audioSamples: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/13/2000 20:05'!currentExternalLocationInPercent	"Warning this might not return what you want, it gets percentage based on audio, or video stream based on last usage, because we buffer audio it may give incorrect information when playing mpeg movies"	^self external getPercentage! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/13/2000 20:09'!currentLocationInPercent: aStream	self hasVideo ifTrue: [^ ((self currentVideoFrameForStream: aStream)/(self videoFrames: aStream)) asFloat].	self hasAudio ifTrue: [^ ((self currentAudioSampleForStream: aStream)/(self audioSamples: aStream)) asFloat].! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:32'!endOfAudio: aStream	^self external endOfAudio: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:30'!endOfVideo: aStream	^self external endOfVideo: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!getTOC: timecode doStreams: streams	^self external getTOC: timecode doStreams: streams! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:31'!getTimeCode	^self external getTimeCode! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:31'!hasAudio	^self external hasAudio	! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:30'!hasVideo	^self external hasVideo! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:31'!setMMX: aBoolean	self external setMMX: aBoolean! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!totalVideoStreams	^self external totalVideoStreams! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:32'!videoDropFrames: aNumberOfFrames stream: aStream	^self external videoDropFrames: aNumberOfFrames stream: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:30'!videoFrameHeight: aStream	^self external videoFrameHeight: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:29'!videoFrameRate: aStream	^self external videoFrameRate: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:29'!videoFrameWidth: aStream	^self external videoFrameWidth: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!videoFrames: aStream	^self external videoFrames: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!videoPreviousFrame: aStream	^self external videoPreviousFrame: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!videoSetCPUs: aNumber	^self external videoSetCPUs: aNumber! !!MPEGPlayer methodsFor: 'audio' stamp: 'kfr 11/9/2000 22:26'!createSoundFrom: aStream 	| snds channels |		snds _ OrderedCollection new.	channels _ self audioChannels: 0.	1 to: channels do: [:c | snds add: (self readSoundChannel: c - 1 stream: aStream)].	channels = 1		ifTrue:[^ MixedSound new				add: (snds at: 1) pan: 0.5 volume: volume;								yourself]		ifFalse: [			^ MixedSound new				add: (snds at: 1) pan: 0.0 volume: volume;				add: (snds at: 2) pan: 1.0 volume: volume;				yourself].! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 11/19/2000 18:03'!privatePlayAudioStream: aStream	| number |	number _ 5.	self soundQueue: (QueueSound new startTime: 0).	[number + 2 timesRepeat: [self soundQueue add: (self createSoundFrom: aStream)].	self soundQueue play.	semaphoreForSound signal.	[[self soundQueue sounds size > number] whileTrue: [(Delay forMilliseconds: 100) wait].	self soundQueue add: (self createSoundFrom: aStream).	(self endOfAudio: aStream) 		ifTrue: 			[self audioPlayerProcess: nil.			^self]] repeat] on: Error do: 				[self audioPlayerProcess: nil.				^self]! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 11/19/2000 18:02'!readSoundChannel: aChannel stream: aStream	| buffer result samples |	samples _ (self sampleRate // 10)  min: 		((self audioSamples: aStream) - (self currentAudioSampleForStream: aStream)).	(samples == 0) ifTrue: [self error: 'Mpeg at end of stream, toss error, catch up high']. 	buffer _ SoundBuffer newMonoSampleCount: samples.	aChannel = 0 		ifTrue: [result _ self external audioReadBuffer: buffer stream: 					aStream channel: aChannel]		ifFalse: [result _ self external audioReReadBuffer: buffer stream: 					aStream channel: aChannel].	^SampledSound samples: buffer samplingRate: self sampleRate.! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 11/8/2000 10:49'!setupStream: aStream	self sampleRate: (self audioSampleRate: aStream).	SoundPlayer startPlayerProcessBufferSize:  8192 "(SoundPlayer bufferMSecs * self sampleRate) // 1000"		rate: self sampleRate stereo: true.! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 11/8/2000 10:33'!setupStreamNoSeek: aStream	self sampleRate: (self audioSampleRate: aStream).	SoundPlayer startPlayerProcessBufferSize:  8192 "(SoundPlayer bufferMSecs * self sampleRate) // 1000"		rate: self sampleRate stereo: ((self  audioChannels: aStream) > 1).! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 9/20/2000 13:38'!startAudioPlayerProcess: aStream	self audioPlayerProcess: ([self privatePlayAudioStream: aStream] forkAt: Processor userInterruptPriority)! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 9/19/2000 16:59'!updateSoundStream: aStream! !!MPEGPlayer methodsFor: 'delay' stamp: 'JMM 11/8/2000 15:30'!calculateDelayGivenFrame: frame stream: aStream	| estimated current delta |	current _  Time millisecondClockValue  - (self startTimeForStream: aStream).	estimated _ ((frame asFloat / self frameRate) * 1000) asInteger  - (self clockBiasForStream: aStream).	delta _ estimated - current.	delta > 33  ifTrue: 		[self lastDelay: (delta + self lastDelay) // 2. 		 (Delay forMilliseconds: self lastDelay) wait].	delta < -33  ifTrue: 		[self lastDelay: self lastDelay // 2.		 self decideToSkipAFrame: delta averageWait: current//frame stream: aStream].	! !!MPEGPlayer methodsFor: 'delay' stamp: 'JMM 11/8/2000 10:13'!calculateDelayToSoundGivenFrame: frame stream: aStream	| current delta buffers estimatedAudio estimatedVideo |	current _  Time millisecondClockValue   - (self startTimeForStream: aStream) + (self clockBiasForStream: aStream).	buffers _ (self soundQueue sounds size - 1 ) max: 0.	buffers = 0 ifTrue: [^self].	estimatedAudio _  ((self currentAudioSampleForStream: aStream) 			- (buffers * self sampleRate // 10) 			- self soundQueue currentSound samplesRemaining) * 1000 / self sampleRate.	estimatedAudio _ estimatedAudio - 0000.	estimatedVideo _ ((frame asFloat / self frameRate) * 1000) asInteger.	delta _ estimatedVideo - estimatedAudio.	delta > 100  ifTrue: 		[self lastDelay < delta ifTrue: [self lastDelay: self lastDelay + (((delta-self lastDelay)/10) max: 1)].		(Delay forMilliseconds: self lastDelay) wait].	delta < -100  ifTrue: 		[self lastDelay: ((self lastDelay - 10) max: 1).		 self decideToSkipAFrame: delta averageWait: current//frame stream: aStream].! !!MPEGPlayer methodsFor: 'delay' stamp: 'JMM 11/8/2000 14:28'!decideToSkipAFrame: delta averageWait: aWaitTime stream: aStream	| estimatedFrames |	delta abs > aWaitTime ifTrue: 		[estimatedFrames _ ( delta abs / (1000 / self frameRate)) asInteger.		self videoDropFrames:  estimatedFrames stream: aStream].! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 11/8/2000 10:31'!close	self external closeFile! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'kfr 11/9/2000 21:19'!initialize: aPath	(MPEGFile isFileValidMPEG: aPath) ifFalse: [^nil].	external _ MPEGFile openFile: aPath.	self playerProcessPriority: Processor userSchedulingPriority.	self lastDelay: 10.	volume _ 1.0.	errorForSoundStart _ 500.	semaphoreForSound _ Semaphore new.	self startTime: (Array new: self totalVideoStreams).	self clockBias: (Array new: self totalVideoStreams withAll: 0).! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 9/20/2000 14:06'!initializeWithFileName: aPath 	self initialize: aPath.	self form: nil.	^self! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 9/20/2000 14:06'!initializeWithFileName: aPath form: aForm	self initialize: aPath.	self form: aForm.	^self! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 10/17/2000 23:34'!initializeWithFileName: aPath morph: aMorphic	self initialize: aPath.	self morph: aMorphic.	^self! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 9/20/2000 14:15'!stopAndClose	self stop.	self close! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 11/8/2000 10:20'!playAudioStream: aStream	self hasAudio ifFalse: [^self].	self setupStream: aStream.	self startAudioPlayerProcess: aStream.! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 11/8/2000 10:20'!playAudioStreamNoSeek: aStream	self hasAudio ifFalse: [^self].	self setupStreamNoSeek: aStream.	self startAudioPlayerProcess: aStream.! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 11/8/2000 10:20'!playAudioStreamWaitTilDone: aStream	self hasAudio ifFalse: [^self].	self setupStream: aStream.	self privatePlayAudioStream: aStream.! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 11/8/2000 10:20'!playStream: aStream	self noSound: self hasAudio not.	self startVideoPlayerProcess: aStream! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 11/8/2000 10:20'!playStreamWaitTilDone: aStream	self noSound: self hasAudio not.	self privatePlayVideoStream: aStream.! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 9/20/2000 14:00'!playVideoStream: aStream	self noSound: true.	self startVideoPlayerProcess: aStream! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 9/20/2000 14:00'!playVideoStreamWaitTilDone: aStream	self noSound: true.	self privatePlayVideoStream: aStream! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/8/2000 10:38'!backAudio: aNumber forStream: aStream	self forwardAudio: (0-aNumber) forStream: aStream! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/8/2000 10:39'!backVideo: aNumber forStream: aStream	self forwardVideo: (0-aNumber) forStream: aStream! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/13/2000 19:35'!forwardAudio: aNumber forStream: aStream	| newLocation |	self hasAudio ifFalse: [^self].	newLocation _ (((self currentAudioSampleForStream: aStream) + aNumber) min: (self audioSamples: aStream)) max: 0 .	self currentAudioSampleForStream: aStream put: newLocation! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/13/2000 19:35'!forwardVideo: aNumber forStream: aStream	| newLocation |	self hasVideo ifFalse: [^self].	newLocation _ (((self currentVideoFrameForStream: aStream) + aNumber) min: (self videoFrames: aStream)) max: 0.	self currentVideoFrameForStream: aStream put: newLocation.! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/19/2000 12:50'!isPlaying	^((self audioPlayerProcess isNil) and: [self videoPlayerProcess isNil]) not! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/13/2000 19:37'!recalculateNewSampleLocationForStream: aStream givenFrame: aFrame	| estimated |	self hasAudio ifFalse: [^self].	estimated _ (aFrame / (self videoFrames: aStream) * (self audioSampleRate: aStream)) asInteger.	self currentAudioSampleForStream: aStream put: estimated.! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/8/2000 10:47'!seekToHere: aPercentage forStream: aStream	"Alternate method is to seek all video/audio for stream to a certain percentage using the primitive, but I think your mpeg must have timecodes!! otherwise endless loop"	self external seekPercentage: aPercentage! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/19/2000 11:44'!seekVideoAudioBasedOnFrame: aFrame forStream: aStream	self external hasVideo ifTrue: 		[self currentVideoFrameForStream: aStream put:  aFrame].	self recalculateNewSampleLocationForStream: aStream givenFrame: aFrame! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/10/2000 00:19'!setLocation: aPercentage forStream: aStream	self hasAudio ifTrue: [self currentAudioSampleForStream: aStream put: ((self audioSamples: aStream) * aPercentage) asInteger]. 	self hasVideo ifTrue: [self currentVideoFrameForStream: aStream put: ((self videoFrames: aStream) * aPercentage) asInteger].! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 9/20/2000 18:46'!stop	self videoPlayerProcess notNil ifTrue: 		[self videoPlayerProcess terminate. 		self videoPlayerProcess: nil].	self audioPlayerProcess notNil ifTrue: 		[self audioPlayerProcess terminate. 		self audioPlayerProcess: nil.		SoundPlayer stopPlayingAll]! !!MPEGPlayer methodsFor: 'utility' stamp: 'JMM 10/17/2000 23:22'!changed	self morph notNil ifTrue: [self morph changed].! !!MPEGPlayer methodsFor: 'utility' stamp: 'JMM 11/8/2000 10:25'!checkForm: aStream	| y x |	self form notNil ifTrue: [^self].	y _ self videoFrameHeight: aStream.	x _ self videoFrameWidth: aStream.	self form:  (Form extent: x@y depth: 32)! !!MPEGPlayer methodsFor: 'video' stamp: 'JMM 11/19/2000 12:47'!privatePlayVideoStream: aStream		| location |	self hasVideo ifFalse: 		[self timeCheck: 0@0.		^self].	self checkForm: aStream.	self frameRate: (self videoFrameRate: aStream).	location _ self currentVideoFrameForStream: aStream.	self clockBiasForStream: aStream 		put: (1/self frameRate*location*1000) asInteger.	self videoLoop: aStream.	self timeCheck: ((Time millisecondClockValue + (self clockBiasForStream: aStream) - (self startTimeForStream: aStream))/1000.0) @ ((self videoFrames: aStream) / self frameRate).	self videoPlayerProcess: nil! !!MPEGPlayer methodsFor: 'video' stamp: 'JMM 9/20/2000 13:59'!startVideoPlayerProcess: aStream	self videoPlayerProcess: ([self privatePlayVideoStream: aStream] forkAt: self playerProcessPriority)! !!MPEGPlayer methodsFor: 'video' stamp: 'JMM 11/19/2000 12:45'!videoLoop: aStream	| location oneTime | 	oneTime _ true.	[self form depth = 16			ifTrue:				[self external videoReadNext16BitFrameInto: self form bits 				width: self form width height:  self form height  stream: aStream]			ifFalse: 				[self external videoReadNextFrameInto: self form bits 				width: self form width height:  self form height  stream: aStream].	oneTime ifTrue: 			[oneTime _ false.			self noSound ifFalse: 				[self playAudioStreamNoSeek: aStream.				semaphoreForSound wait.				(Delay forMilliseconds: errorForSoundStart) wait].			self startTimeForStream: aStream put: (Time millisecondClockValue)].	self morph ifNil: 			[self form == Display				ifTrue: [Display forceToScreen]				ifFalse: [self form displayOn: Display]].	self changed.		location _ (self currentVideoFrameForStream: aStream)+1.	true 			ifTrue: [self calculateDelayGivenFrame: location stream: aStream]			ifFalse: [self calculateDelayToSoundGivenFrame: location stream: aStream].	(self endOfVideo: aStream)  ifTrue: [^self]] repeat.! !!MPEGPlayer class methodsFor: 'instance creation' stamp: 'JMM 9/18/2000 19:02'!playFile: aPath	^self new initializeWithFileName: aPath ! !!MPEGPlayer class methodsFor: 'instance creation' stamp: 'JMM 9/18/2000 18:32'!playFile: aPath onForm: aForm	^self new initializeWithFileName: aPath form: aForm! !!MPEGPlayer class methodsFor: 'instance creation' stamp: 'JMM 10/17/2000 23:19'!playFile: aPath onMorph: aMorph	^self new initializeWithFileName: aPath morph: aMorph! !!MPEGPlayer2 methodsFor: 'video' stamp: 'kfr 12/1/2000 22:23'!getVideoPicture| fum |self foo hasVideo ifFalse:[^self].fum _ videoMorph rotatedForm.foo						videoReadNextFrameInto: fum bits						width: fum width						height: fum height						stream: 0.					videoMorph changed.! !!MPEGPlayer2 methodsFor: 'video' stamp: 'kfr 12/11/2000 21:23'!playVideo: aStream 	| fum |	dropOut _ OrderedCollection new.	time _  OrderedCollection new.	fum _ self videoMorph rotatedForm.	startTime _ Time millisecondClockValue.	startFrame _ foo videoGetFrame:aStream.	"delay _ 1000// (foo videoFrameRate:0)."	videoPlayerProcess _ ([[ (foo videoGetFrame:0) <= (foo videoFrames: 0) ] 				whileTrue: [ self timing.						 foo						videoReadNextFrameInto: fum bits						width: fum width						height: fum height						stream: aStream.					        fum displayAt: videoMorph topLeft.					"videoMorph changed."					"(Delay forMilliseconds: delay) wait."					] .videoPlayerProcess _ nil]forkAt:4)	! !!MPEGPlayer2 methodsFor: 'video' stamp: 'kfr 12/7/2000 07:57'!timing		 	| frameNow frameItShouldBe timeNow frameRate   totalFrames delay |	frameRate _ foo videoFrameRate:0.	frameNow _ foo videoGetFrame:0.	totalFrames _ foo videoFrames: 0.	delay _ 1000// frameRate.	timeNow _ (Time millisecondsSince: startTime) .	frameItShouldBe _ ((timeNow * frameRate) // 1000) + startFrame.	timecode _ frameItShouldBe  / totalFrames.	(frameNow < frameItShouldBe)		ifTrue:[ foo videoDropFrames: (frameItShouldBe - frameNow) stream: 0]		ifFalse:[(frameNow > frameItShouldBe)				ifTrue:[(Delay forMilliseconds: ((frameNow - frameItShouldBe) * delay)) wait]].	"dropOut add:(frameItShouldBe - frameNow)".	 ! !!MPEGPlayer2 methodsFor: 'video' stamp: 'kfr 11/28/2000 23:03'!videoMorph	| y x fum |	foo hasVideo		ifFalse: [^ nil].	videoMorph		ifNil: [y _ foo videoFrameHeight: 0.			x _ foo videoFrameWidth: 0.			fum _ Form extent: x @ y depth: 32.			videoMorph _ MPEGImageMorph withForm: fum.			self getVideoPicture].	^ videoMorph! !!MPEGPlayer2 methodsFor: 'access' stamp: 'kfr 12/2/2000 16:36'!foo	[foo hasVideo | foo hasAudio] on: Error do: 		[self initialize: foo fileName].		^foo! !!MPEGPlayer2 methodsFor: 'access' stamp: 'kfr 11/25/2000 10:12'!isPlaying(videoPlayerProcess = nil) & (audioPlayerProcess = nil)ifFalse:[ ^true]ifTrue:[ ^false]	! !!MPEGPlayer2 methodsFor: 'access' stamp: 'kfr 12/2/2000 17:05'!playMPEG self foo.foo hasAudio		ifTrue: [self playAudio: 0].foo hasVideo		ifTrue: [self playVideo: 0].! !!MPEGPlayer2 methodsFor: 'access' stamp: 'kfr 12/8/2000 20:45'!setLocation: aPercentage	self foo.	foo hasAudio ifTrue:[foo audioSetSample: ((foo audioSamples: 0) * aPercentage)rounded stream: 0].	foo hasVideo ifTrue: [foo videoSetFrame: (( foo videoFrames:0) * aPercentage)rounded stream: 0].     timecode _ aPercentage	! !!MPEGPlayer2 methodsFor: 'access' stamp: 'kfr 11/18/2000 14:39'!stop	videoPlayerProcess notNil ifTrue: 		[videoPlayerProcess terminate.			videoPlayerProcess _ nil.].	audioPlayerProcess notNil ifTrue: 		[audioPlayerProcess terminate. audioPlayerProcess _ nil.		SoundPlayer stopPlayerProcess]! !!MPEGPlayer2 methodsFor: 'access' stamp: 'kfr 11/16/2000 21:35'!timecode	^timecode! !!MPEGPlayer2 methodsFor: 'access' stamp: 'kfr 11/16/2000 21:42'!volume	^ volume! !!MPEGPlayer2 methodsFor: 'access' stamp: 'kfr 11/16/2000 21:42'!volume: aNumber	volume _ aNumber! !!MPEGPlayer2 methodsFor: 'audio' stamp: 'kfr 12/8/2000 11:27'!createSoundFrom: aStream 	| channels |	channels _ foo audioChannels: aStream.	channels = 2		ifTrue: [self stereo]		ifFalse: [self mono].	! !!MPEGPlayer2 methodsFor: 'audio' stamp: 'kfr 12/8/2000 10:10'!mono| sound sampleRate buffer |sound _ MixedSound new.	sampleRate _ foo audioSampleRate: 0.	buffer _ SoundBuffer newMonoSampleCount: sampleRate.	foo		audioReadBuffer: buffer		stream: 0		channel: 0.	sound		add: (SampledSound samples: buffer samplingRate: sampleRate)		pan: 0.5		volume: volume.		soundQueue add: sound! !!MPEGPlayer2 methodsFor: 'audio' stamp: 'kfr 12/2/2000 17:47'!playAudio: aStream 	| sampleRate number |	soundQueue _ QueueSound new startTime: 0.	number _ 5.	sampleRate _ foo audioSampleRate: 0.	SoundPlayer		startPlayerProcessBufferSize: 8192 		rate: sampleRate		stereo: true.	2 timesRepeat: [self createSoundFrom: aStream].	soundQueue play.	audioPlayerProcess _ ([[ foo endOfAudio: aStream]				whileFalse: [						[(soundQueue sounds size) > number]						whileTrue:[ foo hasVideo ifFalse:[ timecode _  foo getPercentage].(Delay forMilliseconds: 3000) wait].						self createSoundFrom: aStream												]. audioPlayerProcess _ nil] 				forkAt:4)		! !!MPEGPlayer2 methodsFor: 'audio' stamp: 'kfr 12/8/2000 11:40'!stereo| sound sampleRate buffer buffer2 |sound _ MixedSound new.	sampleRate _  foo audioSampleRate: 0.	buffer _ SoundBuffer newMonoSampleCount: sampleRate .	buffer2 _ SoundBuffer newMonoSampleCount: sampleRate . foo		audioReadBuffer: buffer		stream: 0		channel: 0.	sound		add: (SampledSound samples: buffer samplingRate: sampleRate)		pan: 0.0		volume: volume.	foo				audioReReadBuffer: buffer2				stream: 0				channel: 1.			sound				add: (SampledSound samples: buffer2 samplingRate: sampleRate)				pan: 1.0				volume: volume.	soundQueue add: sound.	! !!MPEGPlayer2 methodsFor: 'initializing' stamp: 'kfr 12/5/2000 22:00'!initialize: aPath 		| |	(MPEGFile isFileValidMPEG: aPath)		ifFalse:[^nil].		timecode _ 0.	foo ifNotNil:[foo finalize].	foo _ MPEGFile openFile: aPath.	self volume	ifNil: [ volume _ 1.0].	foo hasVideo	ifTrue:[self videoMorph]			! !!MPEGPlayer2 class methodsFor: 'as yet unclassified' stamp: 'kfr 11/17/2000 18:02'!openFile: aPath ^self new initialize: aPath.! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/29/2000 22:51'!addButtons	| open alignment   volumeButton |	alignment _ Morph new listDirection: #leftToRight;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		changeTableLayout;		color: Color transparent. 	open _ IconicButton new 				labelGraphic: (ScriptingSystem formAtKey: 'openMPEG');				 target: self;				color: Color transparent; borderWidth:0;				 actionSelector: #openMPEGFile.	volumeButton _ IconicButton new 				labelGraphic: (ScriptingSystem formAtKey: 'volumeMPEG');				 target: self;color: Color transparent; borderWidth:0;				 actionSelector: #setVolume.	play _ IconicButton new 				labelGraphic: (ScriptingSystem formAtKey: 'playMPEG');				 target: self;color: Color transparent; borderWidth:0;				 actionSelector: #playMPEG.		alignment addMorph: play.	alignment addMorph: volumeButton.	alignment addMorph: open.    ^ alignment! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/6/2001 11:40'!addLed	| alignment |	self addMorph: (alignment _ AlignmentMorph new color: Color transparent).		ledWasUndeclared _ LedMorph new  chars: 20; extent: 18@15; string:'MPEG PLAYER'.	alignment addMorph: ledWasUndeclared.! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/1/2000 23:50'!addProgress	| alignment |	self addMorph: (alignment _ AlignmentMorph new color: Color transparent; extent: 150 @ 20).		progress _ Slider new extent: 180 @ 13.	alignment addMorph: progress.! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/9/2000 21:32'!addVolume	| alignment |	self addMorph: (alignment _ AlignmentMorph new color: Color transparent; extent: 150 @ 20; orientation: #vertical; centering: #center).		volume _ Slider new extent: 100 @ 13; value: 1.0.	alignment addMorph: volume.! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/6/2001 11:40'!fileNameToLed: aFileName| delim i theFileName croppedName |	theFileName _ aFileName.		delim _ FileDirectory extensionDelimiter.	i _ theFileName findLast: [:c | c = delim].	i = 0				ifFalse: [croppedName _ theFileName copyFrom: 1 to: i].	ledWasUndeclared string: croppedName	! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/28/2000 19:02'!initialize		| alignment |	super initialize.		volume _ VolumeMorph new extent: 13@75; value: 1.0.	progress _ Slider new extent: 120@13.	alignment _ Morph new listDirection: #leftToRight;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		changeTableLayout;		color: Color transparent; addMorph: progress; addMorph:		self addButtons .     self listDirection: #topToBottom;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		changeTableLayout;		color: Color orange; addMorph: alignment		! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/28/2000 23:15'!openMPEGFile	| file dir test delimiter full |	(file _ StandardFileMenu oldFile)		ifNotNil: [dir _ file directory pathName.			test _ file name.			delimiter _ FileDirectory pathNameDelimiter asString.			full _ dir , delimiter , test.			foo _ MPEGPlayer2 openFile: full asLowercase.			foo ifNil:[^nil].			videoMorph ifNotNil:[videoMorph delete. videoMorph _ nil].			foo videoMorph				ifNotNil: [.self addMorph: (videoMorph _ foo videoMorph)].							progress setValue: 0]! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/28/2000 23:18'!playMPEG		foo ifNotNil:[ 	foo playMPEG. self setPlayOrStop]			! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/6/2001 11:41'!playMPEG:aPath video:hasVideo audio:hasAudio x:x y:y	| form morph |	foo ifNotNil:[foo stopAndClose].	hasVideo		ifTrue:[ form _ Form extent: x@y depth: 32.				morph _ MPEGImageMorph withForm: form.				morph openInWorld.				foo _ MPEGPlayer playFile: aPath onMorph: morph.				foo morph: morph.									hasAudio					ifTrue:[ foo playStream: 0]					ifFalse:[ foo playVideoStream:0]]		 ifFalse:[foo _ MPEGPlayer playFile: aPath.				foo playAudioStream:0].		"isPlaying _ true."	! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/29/2000 22:26'!playOrStop	playOrStop	ifFalse:[play  				labelGraphic: (ScriptingSystem formAtKey: 'playMPEG');				 				 actionSelector: #playMPEG]	ifTrue:[play labelGraphic: (ScriptingSystem formAtKey: 'stopMPEG');				 				 actionSelector: #stopPlaying]		! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 10/24/2000 20:11'!playWhatEver: aPath	| whatIsThis |	whatIsThis _ MPEGFile openFile: aPath.	self playMPEG:aPath 		video:(whatIsThis hasVideo) 		audio:(whatIsThis hasAudio)  		x:(whatIsThis videoFrameWidth:0) 		y:(whatIsThis videoFrameHeight:0)! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/28/2000 23:20'!setPlayOrStop	playOrStop _ foo isPlaying.	self playOrStop	! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/29/2000 22:52'!setVolume	volume openInWorld; position: ((play position) - (18@(-20))).! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 12/6/2000 08:04'!step	foo		ifNil: [^ self].	(playOrStop = foo isPlaying)		ifFalse:[self setPlayOrStop].	foo isPlaying		ifTrue: [progress setValue: foo timecode]		ifFalse: [progress value = foo timecode				ifFalse: [foo setLocation: progress value.					foo getVideoPicture]].	(foo volume) = (volume value) ifFalse:[foo volume: volume value]! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/28/2000 23:20'!stopPlaying	foo ifNotNil:[foo stop. foo setLocation: progress value.     self setPlayOrStop.	]			! !!MPEGPlayerMorph methodsFor: 'as yet unclassified' stamp: 'kfr 10/31/2000 07:08'!wantsSteps	^ true! !!Mpeg3Plugin methodsFor: 'support' stamp: 'JMM 10/2/2000 12:14'!checkFileEntry: aMpegFile	self var: #aMpegFile declareC: 'mpeg3_t * aMpegFile'.	1 to: maximumNumberOfFilesToWatch do: 		[:i | ((mpegFiles at: i) = aMpegFile) ifTrue: 				[^true]].	^false.			! !!Mpeg3Plugin methodsFor: 'support' stamp: 'JMM 10/2/2000 11:44'!initialiseModule	self export: true.	maximumNumberOfFilesToWatch _ 1024.	1 to: maximumNumberOfFilesToWatch do: [:i | mpegFiles at: i put: 0].	^self cCode: 'true' inSmalltalk:[true]! !!Mpeg3Plugin methodsFor: 'support' stamp: 'JMM 10/2/2000 12:16'!makeFileEntry: aMpegFile	self var: #aMpegFile declareC: 'mpeg3_t * aMpegFile'.	1 to: maximumNumberOfFilesToWatch do: 		[:i | ((mpegFiles at: i) = 0) ifTrue: 				[mpegFiles at: i put: aMpegFile.				^true]].	^false	"Ok no room just ignore, we'll get a primitive failure later"			! !!Mpeg3Plugin methodsFor: 'support' stamp: 'JMM 10/2/2000 11:55'!mpeg3tValueOf: mpeg3tHandle 	"Return a pointer to the first byte of of the mpeg3_t record within the  	given Smalltalk object, or nil if socketOop is not a mpeg3_t record."	| index check |	self returnTypeC: 'mpeg3_t *'.	self var: #index declareC: 'mpeg3_t ** index'.	interpreterProxy success: ((interpreterProxy isBytes: mpeg3tHandle)			and: [(interpreterProxy byteSizeOf: mpeg3tHandle)					= 4]).	interpreterProxy failed		ifTrue: [^ nil]		ifFalse: 			[index _ self cCoerce: (interpreterProxy firstIndexableField: mpeg3tHandle)						to: 'mpeg3_t **'.			self cCode: 'check = checkFileEntry(*index)'.			check = 0 ifTrue: [^nil]. 			^ self cCode: '*index']! !!Mpeg3Plugin methodsFor: 'support' stamp: 'JMM 10/2/2000 12:14'!removeFileEntry: aMpegFile	self var: #aMpegFile declareC: 'mpeg3_t * aMpegFile'.	1 to: maximumNumberOfFilesToWatch do: 		[:i | ((mpegFiles at: i) = aMpegFile) ifTrue: 				[mpegFiles at: i put: 0.				^true]].	"Just ignore"	^false			! !!Mpeg3Plugin methodsFor: 'support' stamp: 'JMM 10/2/2000 12:03'!shutdownModule	self export: true.	1 to: maximumNumberOfFilesToWatch do: 		[:i | ((mpegFiles at: i) ~= 0) ifTrue:			[self cCode: 'mpeg3_close(mpegFiles[i])'.			mpegFiles at: i put: 0]].	^self cCode:  'true' inSmalltalk:[true]! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 13:27'!primitiveMPEG3AudioChannels: fileHandle stream: aNumber	| file result |	"int mpeg3_audio_channels(mpeg3_t *file,int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3AudioChannels'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^0].	aNumber >= (self cCode: 'mpeg3_total_astreams(file)') ifTrue: [		interpreterProxy success: false. ^0.	].	result := self cCode: 'mpeg3_audio_channels(file,aNumber)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 13:26'!primitiveMPEG3AudioSamples: fileHandle stream: aNumber	| file result |	"long mpeg3_audio_samples(mpeg3_t *file, int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3AudioSamples'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'mpeg3_total_astreams(file)') ifTrue: [		interpreterProxy success: false. ^0.	].	self cCode: 'result = mpeg3_audio_samples(file,aNumber)'.	^result asOop: Float! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 9/18/2000 20:11'!primitiveMPEG3CheckSig: path	| result sz storage |	"int mpeg3_check_sig(char *path)"	self var: #storage declareC: 'char storage[1024] '.	self primitive: 'primitiveMPEG3CheckSig'		parameters: #(String).	sz _ interpreterProxy byteSizeOf: path cPtrAsOop.	self cCode: 'strncpy(storage,path,sz)'.	storage at: sz put: 0.	self cCode: 'result = mpeg3_check_sig(storage)'.	^result asOop: Boolean! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 10/2/2000 11:52'!primitiveMPEG3Close: fileHandle	| file index |	"int mpeg3_close(mpeg3_t *file)"	self var: #file declareC: 'mpeg3_t * file'.	self var: #index declareC: 'mpeg3_t ** index'.	self primitive: 'primitiveMPEG3Close'		parameters: #(Oop).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^nil].	self cCode: 'removeFileEntry(file); mpeg3_close(file)'.	index _ self cCoerce: (interpreterProxy firstIndexableField: fileHandle)						to: 'mpeg3_t **'.	self cCode: '*index = 0'.! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 13:41'!primitiveMPEG3DropFrames: fileHandle frames: aFrameNumber stream: aNumber	| file result |	"int mpeg3_drop_frames(mpeg3_t *file, long frames, int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3DropFrames'		parameters: #(Oop SmallInteger SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_vstreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result = mpeg3_drop_frames(file,aFrameNumber,aNumber)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 13:41'!primitiveMPEG3EndOfAudio: fileHandle stream: aNumber	| file result |	"int mpeg3_end_of_audio(mpeg3_t *file, int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3EndOfAudio'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_astreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result = mpeg3_end_of_audio(file,aNumber)'.	^result asOop: Boolean! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 13:58'!primitiveMPEG3EndOfVideo: fileHandle stream: aNumber	| file result |	"int mpeg3_end_of_video(mpeg3_t *file, int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3EndOfVideo'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_vstreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result = mpeg3_end_of_video(file,aNumber)'.	^result asOop: Boolean! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 13:59'!primitiveMPEG3FrameRate: fileHandle stream: aNumber	| file result |	"float mpeg3_frame_rate(mpeg3_t *file, int stream)"	self var: #result declareC: 'double result'.	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3FrameRate'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_vstreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result =  mpeg3_frame_rate(file,aNumber)'.	^result asOop: Float! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 10/2/2000 12:19'!primitiveMPEG3GenerateToc: fileHandle useSearch: timecode doStreams: streams buffer: aString	| file bufferSize |	"int mpeg3_generate_toc_for_Squeak(FILE *output, char *path, int timecode_search, int print_streams, char *buffer)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3GenerateToc'		parameters: #(Oop SmallInteger Boolean  String).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^nil].	bufferSize _ interpreterProxy slotSizeOf: (interpreterProxy stackValue: 0).	self cCode: 'mpeg3_generate_toc_for_Squeak(file,timecode,streams,aString,bufferSize)'.! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 13:59'!primitiveMPEG3GetFrame: fileHandle stream: aNumber	| file result |	"long mpeg3_get_frame(mpeg3_t *file,int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3GetFrame'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_vstreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result = mpeg3_get_frame(file,aNumber)'.	^result asOop: Float.! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 13:59'!primitiveMPEG3GetSample: fileHandle stream: aNumber	| file result |	"int mpeg3_video_width(mpeg3_t *file, int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3GetSample'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_astreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result = mpeg3_get_sample(file,aNumber)'.	^result asOop: Float! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 9/18/2000 00:55'!primitiveMPEG3GetTime: fileHandle 	| file result |	"double mpeg3_get_time(mpeg3_t *file)"	self var: # result declareC: 'double result'.	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3GetTime'		parameters: #(Oop).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^nil].	self cCode: 'result = mpeg3_get_time(file)'.	^result asOop: Float.! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:33'!primitiveMPEG3HasAudio: fileHandle	| file result |	"int mpeg3_has_audio(mpeg3_t *file)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3HasAudio'		parameters: #(Oop).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^nil].	self cCode: 'result = mpeg3_has_audio(file)'.	^result asOop: Boolean! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:57'!primitiveMPEG3HasVideo: fileHandle	| file result |	"int mpeg3_has_video(mpeg3_t *file)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3HasVideo'		parameters: #(Oop).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^nil].	self cCode: 'result = mpeg3_has_video(file)'.	^result asOop: Boolean! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 10/2/2000 11:51'!primitiveMPEG3Open: path	| mpeg3Oop index sz storage |	"mpeg3_t* mpeg3_open(char *path)"	self var: #index declareC: 'mpeg3_t ** index'.	self var: #storage declareC: 'char storage[1024]'.	self primitive: 'primitiveMPEG3Open'		parameters: #(String).	sz _ interpreterProxy byteSizeOf: path cPtrAsOop.	self cCode: 'strncpy(storage,path,sz)'.	storage at: sz put: 0.	mpeg3Oop _ interpreterProxy instantiateClass: interpreterProxy classByteArray					indexableSize: 4.		index _ self cCoerce: (interpreterProxy firstIndexableField: mpeg3Oop)						to: 'mpeg3_t **'.	self cCode: '*index = mpeg3_open(storage); makeFileEntry(*index)'.	^mpeg3Oop.! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 14:00'!primitiveMPEG3PreviousFrame: fileHandle stream: aNumber	| file result |	"int mpeg3_previous_frame(mpeg3_t *file, int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3PreviousFrame'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	file = nil ifTrue: [^nil].	aNumber >= (self cCode: 'result = mpeg3_total_vstreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result = mpeg3_previous_frame(file,aNumber)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 14:09'!primitiveMPEG3ReReadAudio: fileHandle shortArray: anArray channel: aChannelNumber samples: aSampleNumber stream: aNumber	| file result arrayBase |	"int mpeg3_reread_audio(mpeg3_t *file, 		float *output_f, 		short *output_i, 		int channel, 		long samples,		int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self var: #arrayBase declareC: 'short * arrayBase'.	self primitive: 'primitiveMPEG3ReReadAudio'		parameters: #(Oop Array SmallInteger SmallInteger SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_astreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	arrayBase _ self cCoerce: anArray to: 'short *'.	interpreterProxy failed ifTrue: [^nil].	self cCode: 'result = mpeg3_reread_audio(file,(float *) NULL,arrayBase,aChannelNumber,aSampleNumber,aNumber)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 14:09'!primitiveMPEG3ReadAudio: fileHandle shortArray: anArray channel: aChannelNumber samples: aSampleNumber stream: aNumber	| file result arrayBase |	"int mpeg3_read_audio(mpeg3_t *file, 		float *output_f, 		short *output_i, 		int channel, 		long samples,		int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self var: #arrayBase declareC: 'short * arrayBase'.	self primitive: 'primitiveMPEG3ReadAudio'		parameters: #(Oop Array SmallInteger SmallInteger SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_astreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	arrayBase _ self cCoerce: anArray to: 'short *'.	interpreterProxy failed ifTrue: [^nil].	self cCode: 'result = mpeg3_read_audio(file,(float *) NULL,arrayBase,aChannelNumber,aSampleNumber,aNumber)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 14:02'!primitiveMPEG3ReadFrame: fileHandle buffer: aBuffer x: xNumber y: yNumber w: width h: height ow: outWidth oh: outHeight colorModel: model stream: aNumber bytesPerRow: aByteNumber 	| file result outputRowsPtr bufferBaseAddr |	"int mpeg3_read_frame(mpeg3_t *file, 		unsigned char **output_rows, 		int in_x, 		int in_y, 		int in_w, 		int in_h, 		int out_w, 		int out_h, 		int color_model,		int stream)"	self primitive: 'primitiveMPEG3ReadFrame'		parameters: #(Oop WordArray  SmallInteger  SmallInteger  SmallInteger  SmallInteger  SmallInteger  SmallInteger  SmallInteger  SmallInteger SmallInteger).	self var: #file declareC: 'mpeg3_t * file'.	self var: #bufferBaseAddr declareC: 'unsigned char *bufferBaseAddr'.	self var: #outputRowsPtr declareC: 'unsigned char  ** outputRowsPtr'.	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [ interpreterProxy success: false.  ^nil ].	aNumber >= (self cCode: 'result = mpeg3_total_vstreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	bufferBaseAddr _ self cCoerce: aBuffer to: 'unsigned char *'.	self cCode: 'outputRowsPtr = (unsigned char **) memoryAllocate(1,sizeof(unsigned char*) * outHeight)'.	0 to: outHeight-1 do: [:i | outputRowsPtr at: i put: (bufferBaseAddr + (aByteNumber*i))].			self cCode: 'result = mpeg3_read_frame(file,outputRowsPtr,xNumber,yNumber,width,height,outWidth,outHeight,model,aNumber)'.	self cCode: 'memoryFree(outputRowsPtr)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 14:02'!primitiveMPEG3SampleRate: fileHandle stream: aNumber	| file result |	"int mpeg3_sample_rate(mpeg3_t *file,int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3SampleRate'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_astreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result = mpeg3_sample_rate(file,aNumber)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 9/18/2000 00:49'!primitiveMPEG3SeekPercentage: fileHandle percentage: aNumber	| file result |	"int mpeg3_seek_percentage(mpeg3_t *file, double percentage)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3SeekPercentage'		parameters: #(Oop Float).	file _ self mpeg3tValueOf: fileHandle.	aNumber < 0.0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber > 1.0 ifTrue: [interpreterProxy success: false. ^nil].	file = nil ifTrue: [^nil].	self cCode: 'result = mpeg3_seek_percentage(file,aNumber)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 9/18/2000 00:49'!primitiveMPEG3SetCpus: fileHandle number: cpus	| file |	"int mpeg3_set_cpus(mpeg3_t *file, int cpus)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3SetCpus'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	cpus < 0 ifTrue: [interpreterProxy success: false. ^nil].	file = nil ifTrue: [^nil].	self cCode: 'mpeg3_set_cpus(file,cpus)'.! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 14:02'!primitiveMPEG3SetFrame: fileHandle frame: aFrameNumber stream: aNumber	| file result |	"int mpeg3_set_frame(mpeg3_t *file, long frame, int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3SetFrame'		parameters: #(Oop Float SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_vstreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result = mpeg3_set_frame(file,(long) aFrameNumber,aNumber)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 9/18/2000 00:49'!primitiveMPEG3SetMmx: fileHandle useMmx: mmx	| file |	"int mpeg3_set_mmx(mpeg3_t *file, int use_mmx)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3SetMmx'		parameters: #(Oop Boolean).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^nil].	self cCode: 'mpeg3_set_mmx(file,mmx)'.! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 14:03'!primitiveMPEG3SetSample: fileHandle sample: aSampleNumber stream: aNumber	| file result |	"int mpeg3_set_sample(mpeg3_t *file, long sample, int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3SetSample'		parameters: #(Oop Float SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_astreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	aSampleNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	self cCode: 'result = mpeg3_set_sample(file,aSampleNumber,aNumber)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 9/18/2000 01:45'!primitiveMPEG3TellPercentage: fileHandle	| file result |	"double mpeg3_tell_percentage(mpeg3_t *file)"	self var: # result declareC: 'double result'.	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3TellPercentage'		parameters: #(Oop).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^nil].	self cCode: 'result = mpeg3_tell_percentage(file)'.	^result asOop: Float.! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 9/18/2000 00:49'!primitiveMPEG3TotalAStreams: fileHandle	| file result |	"int mpeg3_total_astreams(mpeg3_t *file)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3TotalAStreams'		parameters: #(Oop).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	self cCode: 'result = mpeg3_total_astreams(file)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:34'!primitiveMPEG3TotalVStreams: fileHandle	| file result |	"int mpeg3_total_vstreams(mpeg3_t *file)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3TotalVStreams'		parameters: #(Oop).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^nil].	self cCode: 'result = mpeg3_total_vstreams(file)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 14:03'!primitiveMPEG3VideoFrames: fileHandle stream: aNumber	| file result |	"long mpeg3_video_frames(mpeg3_t *file, int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3VideoFrames'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_vstreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result = mpeg3_video_frames(file,aNumber)'.	^result asOop: Float.! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 14:03'!primitiveMPEG3VideoHeight: fileHandle stream: aNumber	| file result |	"int mpeg3_video_height(mpeg3_t *file,int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3VideoHeight'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_vstreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result = mpeg3_video_height(file,aNumber)'.	^result asSmallIntegerObj! !!Mpeg3Plugin methodsFor: 'primitives' stamp: 'ls 11/4/2000 14:04'!primitiveMPEG3VideoWidth: fileHandle stream: aNumber	| file result |	"int mpeg3_video_width(mpeg3_t *file, int stream)"	self var: #file declareC: 'mpeg3_t * file'.	self primitive: 'primitiveMPEG3VideoWidth'		parameters: #(Oop SmallInteger).	file _ self mpeg3tValueOf: fileHandle.	file = nil ifTrue: [^0].	aNumber < 0 ifTrue: [interpreterProxy success: false. ^nil].	aNumber >= (self cCode: 'result = mpeg3_total_vstreams(file)') ifTrue: [		interpreterProxy success: false.  ^0 ].	self cCode: 'result = mpeg3_video_width(file,aNumber)'.	^result asSmallIntegerObj! !!Mpeg3Plugin class methodsFor: 'initialize-release' stamp: 'JMM 10/2/2000 12:56'!declareCVarsIn: cg 	super declareCVarsIn: cg.	cg var: 'mpegFiles' declareC: 'mpeg3_t *mpegFiles[1024+1]'.! !!Mpeg3Plugin class methodsFor: 'initialize-release' stamp: 'JMM 10/2/2000 12:53'!headerFile ^'	#include "changesForSqueak.h"	#include "libmpeg3.h"'! !!VolumeMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/28/2000 19:07'!handlesMouseOver: event	^true! !!VolumeMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/28/2000 19:02'!initialize	super initialize! !!VolumeMorph methodsFor: 'as yet unclassified' stamp: 'kfr 11/28/2000 19:08'!mouseLeave:event self delete	! !!MPEGPlayer reorganize!('access' audioPlayerProcess audioPlayerProcess: clockBias clockBias: clockBiasForStream: clockBiasForStream:put: currentAudioSampleForStream: currentAudioSampleForStream:put: currentVideoFrameForStream: currentVideoFrameForStream:put: errorForSoundStart: external fileName form form: frameRate frameRate: lastDelay lastDelay: morph morph: mpegFile noSound noSound: playerProcessPriority playerProcessPriority: sampleRate sampleRate: soundQueue soundQueue: startTime startTime: startTimeForStream: startTimeForStream:put: timeCheck timeCheck: videoPlayerProcess videoPlayerProcess: volume:)('access to attributes' audioChannels: audioSampleRate: audioSamples: currentExternalLocationInPercent currentLocationInPercent: endOfAudio: endOfVideo: getTOC:doStreams: getTimeCode hasAudio hasVideo setMMX: totalVideoStreams videoDropFrames:stream: videoFrameHeight: videoFrameRate: videoFrameWidth: videoFrames: videoPreviousFrame: videoSetCPUs:)('audio' createSoundFrom: privatePlayAudioStream: readSoundChannel:stream: setupStream: setupStreamNoSeek: startAudioPlayerProcess: updateSoundStream:)('delay' calculateDelayGivenFrame:stream: calculateDelayToSoundGivenFrame:stream: decideToSkipAFrame:averageWait:stream:)('initialize-release' close initialize: initializeWithFileName: initializeWithFileName:form: initializeWithFileName:morph: stopAndClose)('play' playAudioStream: playAudioStreamNoSeek: playAudioStreamWaitTilDone: playStream: playStreamWaitTilDone: playVideoStream: playVideoStreamWaitTilDone:)('play controls' backAudio:forStream: backVideo:forStream: forwardAudio:forStream: forwardVideo:forStream: isPlaying recalculateNewSampleLocationForStream:givenFrame: seekToHere:forStream: seekVideoAudioBasedOnFrame:forStream: setLocation:forStream: stop)('utility' changed checkForm:)('video' privatePlayVideoStream: startVideoPlayerProcess: videoLoop:)!Morph subclass: #LedMorph	instanceVariableNames: 'digits chars value flashing flash string scroller scrollLoop '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!LedCharacterMorph initialize!!BlobMPEGMorph reorganize!('access' form form: movieDrawArea mpegLogic mpegLogic: primary quadNumber quadNumber: stream)('initialization' initialize:mpegPlayer: initializeBlobShape initializeChildMpegPlayer: initializePrimaryMpegPlayer:)('stepping' adjustColors limitRange: mergeBlobs stepTime)('drawing' drawOn: playStream: playVideoStream:)!"Postscript:"ScriptingSystem mergeGraphicsFrom: ((Dictionary new) add: ('playMPEG'				-> (Form						extent: 17 @ 17						depth: 32						fromArray: #(4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 )						offset: 0 @ 0));			 add: ('volumeMPEG'				-> (Form						extent: 17 @ 17						depth: 32						fromArray: #(4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 16777215 4278190081 16777215 16777215 16777215 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 16777215 16777215 4278190081 16777215 4278190081 16777215 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 16777215 4278190081 16777215 16777215 4278190081 16777215 16777215 4278190081 4278190081 16777215 4278190081 16777215 4278190081 16777215 16777215 16777215 4278190081 16777215 16777215 4278190081 16777215 4278190081 16777215 16777215 4278190081 4278190081 16777215 4278190081 16777215 4278190081 16777215 16777215 16777215 4278190081 16777215 16777215 4278190081 16777215 4278190081 16777215 16777215 4278190081 4278190081 16777215 4278190081 16777215 4278190081 16777215 16777215 16777215 4278190081 16777215 16777215 4278190081 16777215 4278190081 16777215 16777215 4278190081 4278190081 16777215 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 16777215 4278190081 16777215 16777215 4278190081 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 16777215 16777215 4278190081 16777215 4278190081 16777215 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 16777215 4278190081 16777215 16777215 16777215 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 )						offset: 0 @ 0));			 add: ('stopMPEG'				-> (Form						extent: 17 @ 17						depth: 32						fromArray: #(4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 )						offset: 0 @ 0));			 add: ('openMPEG'				-> (Form						extent: 17 @ 17						depth: 32						fromArray: #(4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 )						offset: 0 @ 0)); yourself ).!