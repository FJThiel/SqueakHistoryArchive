'From Squeak2.9alpha of 16 June 2000 [latest update: #2812] on 6 October 2000 at 3:21:49 pm'!!CompiledMethod methodsFor: 'file in/out' stamp: 'tk 10/6/2000 14:22'!readDataFrom: aDataStream size: varsOnDisk	"Fill in my fields.  My header and number of literals are already installed.  Must read both objects for the literals and bytes for the bytecodes."	self error: 'Must use readMethod'.! !!DataStream methodsFor: 'write and read' stamp: 'tk 10/6/2000 14:36'!readMethod	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.	Let the instance, not the class read the data.  "	| instSize refPosn newClass className xxHeader nLits byteCodeSizePlusTrailer newMethod lits |	instSize _ (byteStream nextNumber: 4) - 1.	refPosn _ self getCurrentReference.	className _ self next.	newClass _ Smalltalk at: className asSymbol.	xxHeader _ self next.		"nArgs _ (xxHeader >> 24) bitAnd: 16rF."		"nTemps _ (xxHeader >> 18) bitAnd: 16r3F."		"largeBit _ (xxHeader >> 17) bitAnd: 1."	nLits _ (xxHeader >> 9) bitAnd: 16rFF.		"primBits _ ((xxHeader >> 19) bitAnd: 16r600) + (xxHeader bitAnd: 16r1FF)."	byteCodeSizePlusTrailer _ instSize - (newClass instSize "0") - (nLits + 1 * 4).	newMethod _ newClass 		newMethod: byteCodeSizePlusTrailer		header: xxHeader.	self setCurrentReference: refPosn.  "before readDataFrom:size:"	self beginReference: newMethod.	lits _ newMethod numLiterals + 1.	"counting header"	2 to: lits do:		[:ii | newMethod objectAt: ii put: self next].	lits*4+1 to: newMethod basicSize do:		[:ii | newMethod basicAt: ii put: byteStream next].			"Get raw bytes directly from the file"	self setCurrentReference: refPosn.  "before returning to next"	^ newMethod! !!DiskProxy methodsFor: 'as yet unclassified' stamp: 'tk 10/6/2000 15:18'!simpleGlobalOrNil	"Return the object I refer to if it is a simple global in Smalltalk."	preSelector ifNotNil: [^ nil].	constructorSelector == #yourself ifFalse: [^ nil].	^ Smalltalk at: globalObjectName ifAbsent: [nil].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/6/2000 13:06'!smartFillRoots: dummy	| refs known ours ww blockers |	"Put all traced objects into my arrayOfRoots.  Remove some that want to be in outPointers.  Return blockers, an IdentityDictionary of objects to replace in outPointers."	blockers _ dummy blockers.	known _ (refs _ dummy references) size.	refs keys do: [:obj | "copy keys to be OK with removing items"		(obj class == Symbol) ifTrue: [refs removeKey: obj.  known _ known-1].		(obj class == PasteUpMorph) ifTrue: [			obj isWorldMorph & (obj owner == nil) ifTrue: [				obj == dummy project world ifFalse: [					refs removeKey: obj.  known _ known-1.					blockers at: obj put: 						(StringMorph contents: 'The worldMorph of a different world')]]].					"Make a ProjectViewMorph here"		"obj class == Project ifTrue: [Transcript show: obj; cr]."		(blockers includesKey: obj) ifTrue: [			refs removeKey: obj ifAbsent: [known _ known+1].  known _ known-1].		].	ours _ dummy project world.	refs keysDo: [:obj |			obj isMorph ifTrue: [				ww _ obj world. 				(ww == ours) | (ww == nil) ifFalse: [					refs removeKey: obj.  known _ known-1.					blockers at: obj put: (StringMorph contents: 								obj printString, ' from another world')]]].	"keep original roots on the front of the list"	(dummy rootObject) do: [:rr | refs removeKey: rr ifAbsent: []].	^ dummy rootObject, refs keys asArray.! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 10/6/2000 15:21'!recordImageSegment: refs	"Besides the objects being written out, record the structure of instances inside the image segment we are writing out."	| cls list |	"Do not record Player class inst vars.  They are in the segement."	refs keysDo: [:each | 		cls _ each class.		cls isObsolete ifTrue: [self error: 'Trying to write ', cls name].		cls class == Metaclass 			ifFalse: [structures at: cls name put: false.				(each isKindOf: ImageSegment) ifTrue: [					each outPointers do: [:out | "Why necessary??"						(out isKindOf: Class) ifTrue: [							structures at: out theNonMetaClass name put: false].						out class == DiskProxy ifTrue: [							out simpleGlobalOrNil ifNotNil: [								(out simpleGlobalOrNil isKindOf: Class) ifTrue: [									structures at: out simpleGlobalOrNil name put: false]]]].					each arrayOfRoots do: [:rr | (rr isKindOf: Class) ifTrue: [							structures at: rr theNonMetaClass name put: false]]]]].	list _ refs at: #BlockReceiverClasses ifAbsent: [^ self].	list do: [:meta | structures at: meta name put: false].		"Just the metaclasses whose instances are block receivers.  Otherwise metaclasses are not allowed."! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'tk 10/6/2000 14:32'!doFastWindowReframe: ptName	| newBounds |	"For fast display, only higlight the rectangle during loop"	newBounds _ self bounds newRectButtonPressedDo: [:f | 		f 			withSideOrCorner: ptName			setToPoint: (self pointFromWorld: Sensor cursorPoint)			minExtent: self minimumExtent].	self bounds: newBounds! !!Utilities class methodsFor: 'flaps' stamp: 'tk 10/6/2000 13:07'!globalFlapTabOrDummy: aName	| gg |	"Find a global flap tab by name.  May be either 'flap: Tools' or 'Tools'.  Be sure to supply a "	(gg _ self globalFlapTab: aName) ifNil: [		^ StringMorph contents: aName, ' can''t be found'].	^ gg! !