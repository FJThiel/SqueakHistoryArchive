'From Squeak 2.5 of August 6, 1999 on 8 September 1999 at 9:26:24 pm'!"Change Set:		reframe-bfDate:			6 September 1999Author:			Bert FreudenbergFixes getting stuck in minimal extent frame when resizing system windows and fastDragWindows is on. Also enhances reframing with corner handles when fastDrag is off.Tweaked by Dan Ingalls for better code sharing (withSideOrCorner:setToPoint: calls withSideOrCorner:setToPoint:minExtent:)  and to accomodate other changes to spawnPaneFrameHandle:."!!Rectangle methodsFor: 'rectangle functions' stamp: 'di 9/8/1999 21:25'!withSideOrCorner: side setToPoint: newPoint	"Return a copy with side set to newPoint"	^ self withSideOrCorner: side setToPoint: newPoint minExtent: 0@0! !!Rectangle methodsFor: 'rectangle functions' stamp: 'bf 9/6/1999 10:49'!withSideOrCorner: side setToPoint: newPoint minExtent: minExtent	"Return a copy with side set to newPoint"	side = #top ifTrue: [^ self withTop: (newPoint y min: corner y - minExtent y)].	side = #bottom ifTrue: [^ self withBottom: (newPoint y max: origin y + minExtent y)].	side = #left ifTrue: [^ self withLeft: (newPoint x min: corner x - minExtent x)].	side = #right ifTrue: [^ self withRight: (newPoint x max: origin x + minExtent x)].	side = #topLeft ifTrue: [^ (newPoint min: corner - minExtent) corner: self bottomRight].	side = #bottomRight ifTrue: [^ self topLeft corner: (newPoint max: origin + minExtent)].	side = #bottomLeft ifTrue: [^ self topRight rect: ((newPoint x min: corner x - minExtent x) @ (newPoint y max: origin y + minExtent y))].	side = #topRight ifTrue: [^ self bottomLeft rect: ((newPoint x max: origin x + minExtent x) @ (newPoint y min: corner y - minExtent y))].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 9/8/1999 14:43'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds vbtl |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) ifTrue:  [^ self].	((self world ifNil: [^ self]) firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[^ self  "Prevent multiple handles"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	vbtl _ self world viewBox topLeft.	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ self bounds withSideOrCorner: ptName setToPoint: localPt minExtent: 100@80.			Preferences fastDragWindowForMorphic			ifTrue:				["For fast display, only higlight the rectangle during loop"				newBounds _ (self bounds translateBy: vbtl) newRectFrom:					[:f | f withSideOrCorner: ptName							setToPoint: (self pointFromWorld: Sensor cursorPoint)							minExtent: 100@80].				self bounds: (newBounds translateBy: vbtl negated)]			ifFalse:				[self bounds: newBounds.				(Preferences roundedWindowCorners					and: [#(bottom right bottomRight) includes: ptName])					ifTrue:					["Complete kluge: causes rounded corners to get painted correctly,					in spite of not working with top-down displayWorld."					ptName = #bottom ifFalse:						[self invalidRect: (self bounds topRight - (6@0) extent: 7@7)].					ptName = #right ifFalse:						[self invalidRect: (self bounds bottomLeft - (0@6) extent: 7@7)].					self invalidRect: (self bounds bottomRight - (6@6) extent: 7@7)]]]		lastPointDo:			[:p | ].	event hand world addMorph: resizer.	resizer startStepping! !