'From Squeak3.2alpha of 3 October 2001 [latest update: #4603] on 12 December 2001 at 2:15:52 pm'!"Change Set:		baseGraphic-swDate:			12 December 2001Author:			Scott WallaceMakes a SketchMorph keep track of a 'baseGraphic' -- normally its original picture, but settable by the user.  Support is provided via new items in the #graphics category of the Viewer and new items in a Sketch's halo menu for reverting to the baseGraphic and for changing what the baseGraphic is."!!EToyVocabulary methodsFor: 'method list' stamp: 'sw 12/12/2001 11:57'!masterOrderingOfPhraseSymbols	"Answer a dictatorially-imposed presentation list of phrase-symbols.  This governs the order in which suitable phrases are presented in etoy viewers using the etoy vocabulary.  For any given category, the default implementation is that any items that are in this list will occur first, in the order specified here; after that, all other items will come, in alphabetic order by formal selector."	^ #(beep: forward: turn: getX getY  getHeading		startScript: pauseScript: stopScript: startAll: pauseAll: stopAll: tellAllSiblings: doScript:		getColor getUseGradientFill getSecondColor  getRadialGradientFill  getBorderWidth getBorderColor getBorderStyle getRoundedCorners getDropShadow getShadowColor 		getGraphic getBaseGraphic)! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 12/12/2001 11:36'!makeNewDrawing: evt at: aPoint	"make a new drawing, triggered by the given event, with the painting area centered around the given point"	| w newSketch newPlayer sketchEditor aPaintBox aPalette tfx whereToPresent rect ownerBeforeHack aPaintTab aWorld |	w _ self world.	w assureNotPaintingElse: [^ self].	rect _ self paintingBoundsAround: aPoint.	aPalette _ self standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w prepareToPaint.	newSketch _ self drawingClass new player: (newPlayer _ UnscriptedPlayer newUserInstance).	newPlayer costume: newSketch.	newSketch nominalForm: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: self.	sketchEditor		afterNewPicDo: [:aForm :aRect |			whereToPresent _ self presenter.			newSketch form: aForm.			tfx _ self transformFrom: w.			newSketch position: (tfx globalPointToLocal: aRect origin).			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch forwardDirection: sketchEditor forwardDirection.			ownerBeforeHack _ newSketch owner.	"about to break the invariant!!!!"			newSketch privateOwner: self. "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			(aPaintTab _ (aWorld _ self world) paintingFlapTab)				ifNotNil:[aPaintTab hideFlap]				ifNil:[(aPaintBox _ aWorld paintBox) ifNotNil:[aPaintBox delete]].			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			newSketch privateOwner: ownerBeforeHack. "probably nil, but let's be certain"			self addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			whereToPresent drawingJustCompleted: newSketch]		 ifNoBits:[			(aPaintTab _ (aWorld _ self world) paintingFlapTab)				ifNotNil:[aPaintTab hideFlap]				ifNil:[(aPaintBox _ aWorld paintBox) ifNotNil:[aPaintBox delete]].			aPalette ifNotNil: [aPalette showNoPalette].]! !!Player methodsFor: 'costume' stamp: 'sw 12/12/2001 14:13'!renderedCostume: aMorph remember: rememberCostume	"Make aMorph be the receiver's rendered costume; if flexing is currently in effect, make the new morph be flexed correspondingly"	| renderedMorph known anEventHandler w baseGraphic |	renderedMorph _ costume renderedMorph.	renderedMorph == aMorph ifTrue: [^ self].	baseGraphic _ costume renderedMorph valueOfProperty: #baseGraphic.	rememberCostume		ifTrue: [self rememberCostume: renderedMorph].	renderedMorph changed.	w _ renderedMorph world.	"Copy 'player state' (e.g., state which should be associated with the player but is stored in the morph itself these days) from the old rendered morph the new morph."	aMorph rotationStyle: renderedMorph rotationStyle.	aMorph forwardDirection: renderedMorph forwardDirection.	"Note: referencePosition is *not* state but #moveTo: behavior"	aMorph referencePosition: renderedMorph referencePosition.	anEventHandler _ renderedMorph eventHandler.	costume isFlexMorph		ifTrue:			[costume adjustAfter:				[costume replaceSubmorph: renderedMorph by: aMorph]]		ifFalse:			[costume owner ifNotNil: [costume owner replaceSubmorph: costume by: aMorph].			aMorph player: self.			aMorph actorState: costume actorState.			(known _ costume knownName) ifNotNil:				[aMorph setNameTo: known].			costume _ aMorph.			w ifNotNil:				[w stopStepping: renderedMorph.				w startStepping: aMorph]].	baseGraphic ifNotNil: [self setBaseGraphic: baseGraphic].	aMorph eventHandler: anEventHandler.	aMorph changed! !!Player methodsFor: 'costume' stamp: 'sw 12/12/2001 12:24'!restoreBaseGraphic	"Restore my base graphic"	| cos |	((cos _ self costume renderedMorph) isKindOf: SketchMorph)		ifTrue:			[cos restoreBaseGraphic]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 12/12/2001 11:05'!usableMethodInterfacesIn: methodInterfaceList	"Filter the list given by methodInterfaceList, to remove items inappropriate to the receiver"	self hasCostumeThatIsAWorld ifTrue:		[^ methodInterfaceList select: [:anInterface |			#(append: beep: clearTurtleTrails doScript: getColor "color" getCursor "cursor" deleteCard doMenuItem emptyScript firstPage goToFirstCardInBackground goToFirstCardOfStack goToLastCardInBackground goToLastCardOfStack goToNextCardInStack goToPreviousCardInStack initiatePainting insertCard  liftAllPens lowerAllPens arrowheadsOnAllPens noArrowheadsOnAllPens getMouseX getMouseY "mouseX mouseY" pauseScript: reverse roundUpStrays shuffleContents startScript: stopScript: unhideHiddenObjects getValueAtCursor "valueAtCursor"startAll: pauseAll: stopAll:  viewAllMessengers clobberAllMessengers openAllScriptsTool handScriptControlButtons viewAllReferencedObjects jumpToProject:)includes: anInterface selector]].	self hasAnyBorderedCostumes ifTrue: [^ methodInterfaceList].	^ self hasOnlySketchCostumes		ifTrue:			[methodInterfaceList select: [:anInterface | (#(getColor getSecondColor getBorderColor getBorderWidth getBorderStyle  getRoundedCorners getUseGradientFill getRadialGradientFill ) includes: anInterface selector) not]]		ifFalse:			[methodInterfaceList select: [:anInterface | (#(getBorderColor getBorderWidth) includes: anInterface selector) not]]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 12/12/2001 11:36'!getBaseGraphic	"Answer a form representing the receiver's base graphic"	| aMorph |	^ ((aMorph _ costume renderedMorph) isKindOf: SketchMorph)		ifTrue:			[aMorph baseGraphic]		ifFalse:			[aMorph imageForm]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 12/12/2001 11:42'!setBaseGraphic: aGraphic	"Set the base graphic"	| aMorph |	^ ((aMorph _ costume renderedMorph) isKindOf: SketchMorph)		ifTrue:			[aMorph baseGraphic: aGraphic]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 12/12/2001 10:14'!setGraphic: aForm	"Set the receiver's graphic as indicated"	| aMorph |	^ ((aMorph _ costume renderedMorph) isKindOf: SketchMorph)		ifTrue:			[aMorph form: aForm]		ifFalse:			["what to do?"]! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 12/12/2001 13:13'!form: aForm	"Set the receiver's form"	| oldForm |	oldForm _ originalForm.	(self hasProperty: #baseGraphic) ifFalse: [self setProperty: #baseGraphic toValue: aForm].	originalForm _ aForm.	self rotationCenter: 0.5@0.5.	self layoutChanged.	oldForm ifNotNil: [self position: self position + (oldForm extent - aForm extent // 2)].! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 12/12/2001 10:49'!nominalForm: aForm	"Ascribe the blank nominal form"	originalForm _ aForm.	self rotationCenter: 0.5@0.5.	self layoutChanged! !!SketchMorph methodsFor: 'menu' stamp: 'sw 12/12/2001 12:36'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add custom menu items"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'restore base graphic' target: self action: #restoreBaseGraphicFromMenu.	aCustomMenu add: 'call this my base graphic' target: self action: #callThisBaseGraphic.	aCustomMenu add: 'choose new graphic...' target: self action: #chooseNewGraphic.	aCustomMenu addLine.	aCustomMenu add: 'set as background' target: rotatedForm action: #setAsBackground.	self addPaintingItemsTo: aCustomMenu hand: aHandMorph! !!SketchMorph methodsFor: 'menu' stamp: 'sw 12/12/2001 12:50'!callThisBaseGraphic	"Set my baseGraphic to be the current form"	| aGraphic |	self isInWorld ifFalse: [^ self inform: 'oops, this menu is a for a morph thathas been replaced, probably because a"look like" script was run.  Please dismissthe menu and get a new one!!.  Sorry!!'].	((aGraphic _ self valueOfProperty: #baseGraphic)				notNil and: [aGraphic ~= originalForm])		ifTrue:			[self setProperty: #baseGraphic toValue: originalForm]		ifFalse:			[self inform: 'this already *was* your baseGraphic']! !!SketchMorph methodsFor: 'menu' stamp: 'sw 12/12/2001 13:14'!restoreBaseGraphic	"Restore the receiver's base graphic"	| aGraphic |	((aGraphic _ self baseGraphic) notNil and:				[aGraphic ~= originalForm])		ifTrue:			[self form: aGraphic]! !!SketchMorph methodsFor: 'menu' stamp: 'sw 12/12/2001 13:14'!restoreBaseGraphicFromMenu	"Restore the base graphic -- invoked from a menu, so give interactive feedback if appropriate"	self isInWorld ifFalse: [^ self inform: 'oops, this menu is a for a morph thathas been replaced, probably because a"look like" script was run.  Please dismissthe menu and get a new one!!.  Sorry!!'].	 self baseGraphic = originalForm ifTrue: [^ self inform: 'This object is *already* showing its baseGraphic'].	self restoreBaseGraphic! !!SketchMorph methodsFor: 'e-toy support' stamp: 'sw 12/12/2001 13:10'!baseGraphic	"Answer my base graphic"	^ self valueOfProperty: #baseGraphic ifAbsent:		[self setProperty: #baseGraphic toValue: originalForm.		^ originalForm]! !!SketchMorph methodsFor: 'e-toy support' stamp: 'sw 12/12/2001 13:15'!baseGraphic: aForm	"Remember the given form as the receiver's base graphic"	^ self setProperty: #baseGraphic toValue: aForm! !!SketchMorph class methodsFor: 'scripting' stamp: 'sw 12/12/2001 12:27'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((graphics ((slot graphic 	'The picture currently being worn' Graphic	 readWrite Player getGraphic Player setGraphic:)(slot baseGraphic 	'The picture originally painted for this object, but can subsequently be changed via menu or script' Graphic	 readWrite Player getBaseGraphic Player setBaseGraphic:)(command restoreBaseGraphic 'Make my picture be the one I remember in my baseGraphic'))))! !!StandardViewer methodsFor: 'categories' stamp: 'sw 12/12/2001 11:15'!likelyCategoryToShow	"Choose a category to show based on what's already showing and on some predefined heuristics"	| possible all aCat currVocab |	all _ (scriptedPlayer categoriesForViewer: self) asOrderedCollection.	possible _ all copy.	currVocab _ self currentVocabulary.	self categoryMorphs do:		[:m |			aCat _ currVocab categoryWhoseTranslatedWordingIs:  m currentCategory.			aCat ifNotNil: [possible remove: aCat categoryName ifAbsent: []]].	(currVocab isKindOf: EToyVocabulary)  ifTrue: "hateful!!"		[((possible includes: #'instance variables') and: [scriptedPlayer hasUserDefinedSlots])			ifTrue:	[^ #'instance variables'].		((possible includes: #scripts) and: [scriptedPlayer hasUserDefinedScripts])			ifTrue:	[^ #'scripts']].	#(basic ) do:		[:preferred | (possible includes: preferred) ifTrue: [^ preferred]].	scriptedPlayer hasOnlySketchCostumes ifTrue: [(possible includes: #tests) ifTrue: [^ #tests]].	#(#'color & border' tests color flagging comparing) do:		[:preferred | (possible includes: preferred) ifTrue: [^ preferred]].	^ possible size > 0		ifTrue:			[possible first]		ifFalse:			[all first]! !