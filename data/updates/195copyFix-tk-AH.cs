'From Squeak 2.1 of June 30, 1998 on 18 August 1998 at 9:07:01 am'!!DataStream methodsFor: 'all' stamp: 'tk 8/18/1998 08:59'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	aStream binary.	basePos _ aStream position.	"Remember where we start.  Earlier part of file contains a class or method file-in.  Allow that to be edited.  We don't deal in absolute file locations."	byteStream _ aStream.! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 8/18/1998 08:38'!reset	"PRIVATE -- Reset my internal state.	   11/15-17/92 jhm: Added transients and fwdRefEnds.	   7/11/93 sw: Give substantial initial sizes to avoid huge time spent growing.	   9/3/93 sw: monster version for Sasha"	super reset.	references _ IdentityDictionary new: 4096 * 5."	objects _ IdentityDictionary new: 4096 * 5.	fwdRefEnds _ IdentityDictionary new."	blockers ifNil: [blockers _ IdentityDictionary new]. ! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 8/18/1998 08:58'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	super setStream: aStream reading: isReading.	"isReading ifFalse: [  when we are sure"	references _ IdentityDictionary new: 4096 * 5.	isReading ifTrue: [		objects _ IdentityDictionary new: 4096 * 5.		fwdRefEnds _ IdentityDictionary new].	blockers ifNil: [blockers _ IdentityDictionary new].	"keep blockers we just passed in"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 09:01'!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall == nil 	ifTrue:		[topCall _ anObject.		'Please wait while objects are counted' 			displayProgressAt: Sensor cursorPoint			from: 0 to: 10			during: [:bar | info _ self instVarInfo: anObject].		self appendClassDefns.	"For instance-specific classes"		'Writing an object file' displayProgressAt: Sensor cursorPoint			from: 0 to: objCount*4	"estimate"			during: [:bar |				objCount _ 0.				progressBar _ bar.				self setStream: byteStream reading: false.					"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject.		"<- the real writing"				classInstVars size > 0 ifTrue: [super nextPut: classInstVars]].					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		topCall _ progressBar _ nil]	"reset it"	ifFalse:		[super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 09:02'!scanFrom: aByteStream	"During a code fileIn, we need to read in an object, and stash it in ScannedObject.  "	self setStream: aByteStream reading: true.	ScannedObject _ self next.	byteStream ascii.	byteStream next == $!! ifFalse: [		byteStream close.		self error: 'Object did not end correctly']. 	"caller will close the byteStream"	"HandMorph.readMorphFile will retrieve the ScannedObject"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 08:56'!setStream: aStream reading: isReading	"Initialize me. "	super setStream: aStream reading: isReading.	steady _ Set new.	#(Array Dictionary Association String SmallInteger) do: [:sym |		steady add: (Smalltalk at: sym)].		"These must stay constant.  When structures read in, then things can change."	reshaped ifNil: [reshaped _ Dictionary new].			"(old class name -> method selector to fill in data for version to version)"	renamed ifNil: [renamed _ Dictionary new].		"(old class name symbol -> new class name)"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 08:39'!veryDeepCopy: anObject	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream and storeDataOn:"	| dummy refs class new uniClasses uc old stillWeakRefs |	dummy _ DeepCopyStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"  		"Note that dummy is a ReferenceStream.  instVarInfo: will not be called."	dummy nextPut: anObject.	"Do the traverse of the tree"	uniClasses _ Dictionary new.	"UniClass -> new UniClass"	renamed _ Dictionary new.	stillWeakRefs _ OrderedCollection new: 30.	refs _ dummy references.	"all the objects"	"For each object, make a simple copy, then replace all fields with new copy from dict"	refs keysDo: [:each | 		class _ each class.		class == Metaclass ifTrue: ["object is a metaclass" self error: 'can''t copy a class'].		class isMeta 			ifTrue: ["a class" self error: 'can''t copy a class']			ifFalse: ["an instance" class isSystemDefined 				ifFalse: [uc _ uniClasses at: class ifAbsent: [nil].					uc ifNil: [uniClasses at: class put: (uc _ each copyUniClass)]]				ifTrue: [(refs at: each) class == OrderedCollection ifTrue: [						"Is a weak reference that was not confirmed"						stillWeakRefs add: each]]]].	uniClasses do: [:uniCls | 		dummy nextPut: uniCls scripts].	"more objects to veryDeepCopy"	refs associationsDo: [:assoc | 		(uniClasses includesKey: assoc key class)			ifFalse: [(#(Form Color StrikeFont) includes: assoc key class name)				ifFalse: [assoc key class == DiskProxy					ifFalse: [assoc value: assoc key clone]					ifTrue: [assoc value: nil "assoc key comeFullyUpOnReload"]]						"a DiskProxy will never be looked up -- its not in any field.						Old value of field is used."				ifTrue: [assoc value: assoc key]]		"Don't copy Forms, Colors"			ifTrue: [old _ assoc key.				assoc value: (new _ (uc _ uniClasses at: assoc key class) new).				1 to: uc instSize do: [:ii | new instVarAt: ii put: (old instVarAt: ii)]]].		"Watch out for classes that do extra things in copy but not in clone"	stillWeakRefs do: [:each | refs at: each put: nil]. 	"nil out weak refs"	self veryDeepRectify: refs.	"rehashes Sets and Dictionaries"	self veryDeepClassVars: refs.		"ScannedObject _ refs.	debug"	^ refs at: anObject! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 08:22'!veryDeepRectify: refs	"refs is a dictionary of (old object -> shallow copy of it).  For each field, map the value to a new object.  This is for copying, so if an object is not in refs, use its old value.	Rehash the Sets.  If any other class depends on the hashes of its inst vars, let is recompute also."	| hashers new class index sub subAss |	hashers _ OrderedCollection new.	refs associationsDo: [:assoc | 		assoc key == assoc value ifFalse: ["is a new object"			new _ assoc value.			class _ new class.			(class isVariable and: [class isPointers])				ifTrue: 					[index _ new basicSize.					[index > 0] whileTrue: 						[sub _ new basicAt: index.						(subAss _ refs associationAt: sub ifAbsent: [nil]) ifNotNil: [								"If not in refs, then the right value is already in the field"								new basicAt: index put: subAss value].						index _ index - 1]].			index _ class instSize.			[index > 0] whileTrue: 				[sub _ new instVarAt: index.				(subAss _ refs associationAt: sub ifAbsent: [nil]) ifNotNil: [						"If not in refs, then the right value is already in the field"						new instVarAt: index put: subAss value].				index _ index - 1].			(new respondsTo: #rehash) ifTrue: [hashers add: new].			]].	"Force new Sets and Dictionaries to rehash"	hashers do: [:each | each rehash].! !