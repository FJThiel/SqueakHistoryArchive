'From Squeak2.7alpha of 23 October 1999 [latest update: #1696] on 6 December 1999 at 11:00:15 pm'!"Change Set:		SqkEnvts1TweaksDate:			6 December 1999Author:			Dan IngallsSeveral tweaks needed to get Environment>>reorganizeEverything to work in the 2.7alpha image.  Plus...Makes FillInTheBlankMorphs erase their image promptly after dismissal, rather than lingering until the next screen update.Makes the debugger display the full error message in the debug.log file."!!Browser methodsFor: 'system category list' stamp: 'di 12/6/1999 20:11'!selectedEnvironment	"Answer the name of the selected system category or nil."	systemCategoryListIndex = 0 ifTrue: [^nil].	^ Smalltalk environmentForCategory: self selectedSystemCategoryName! !!Browser methodsFor: 'class list' stamp: 'di 12/6/1999 20:41'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."	| name envt |	(name _ self selectedClassName) ifNil: [^ nil].	(envt _ self selectedEnvironment) ifNil: [^ nil].	^ envt at: name! !!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'di 12/6/1999 19:42'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	w _ self world.	w ifNil: [^ response].	done _ false.	[done] whileFalse: [w doOneCycle].	self delete.	w doOneCycle.	^ response! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/6/1999 20:36'!environmentForCategory: catName	"Default response for non-partitioned systems"	^ Smalltalk! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'di 12/6/1999 19:54'!logError: errMsg inContext: aContext to: aFilename	"Log the error message and a stack trace to the given file."	| ff ctx |	FileDirectory default deleteFileNamed: aFilename ifAbsent: [].	(ff _ FileStream fileNamed: aFilename) ifNil: [^ self "avoid recursive errors"].  	ff print: Date today; space; print: Time now; cr.  	ff nextPutAll: errMsg; cr.	"Note: The following is an open-coded version of ContextPart>>stackOfSize:	since this method may be called during a low space condition and we might	run out of space for allocating the full stack."	ctx _ aContext.	[ctx == nil] whileFalse:[		ff print: ctx; cr.		ctx _ ctx sender].	ff close.! !!Environment reorganize!('instance creation' makeSubEnvironmentNamed: setOuterEnvt:)('dictionary access' allClassesAnywhereDo: associationAtOrAbove:ifAbsent: at: atOrAbove:ifAbsent: atOrBelow:ifAbsent: deepAssociationsDo: environmentForCategory: exportMethodFor: lenientScopeHas:ifTrue:)('system conversion' browseIndirectRefs doesNotUnderstand: kernelCategories rebuildSystemOrganization rewriteIndirectRefs rewriteSourceForSelector:inClass:using: tallyIndirectRefs transferBindingsNamedIn:from:)('printing' printOn:)!!Environment methodsFor: 'instance creation' stamp: 'di 12/6/1999 22:49'!makeSubEnvironmentNamed: name	| envtClass envt |	envtClass _ self class subclass: (name , 'Environment') asSymbol				instanceVariableNames: '' classVariableNames: ''				poolDictionaries: '' category: 'System-Environments'.	envt _ envtClass new setOuterEnvt: self.  "make an instance linked to parent"	self at: name asSymbol put: envt.  "install it in parent by name"	envtClass addSharedPool: envt.  "add it to its own compilation context for exports"	^ envt! !!Environment methodsFor: 'dictionary access' stamp: 'di 12/6/1999 20:51'!environmentForCategory: catName	"Smalltalk environmentForCategory:'Morphic'"	"Accepts a category name which may be a symbol or a string,	and which may have trailing parts of the form '-zort'.	Returns the environment object of that name."	| envtName |	envtName _ (catName copyUpTo: $-) asSymbol.	(Smalltalk kernelCategories includes: envtName)		ifTrue: [^ Smalltalk].	^ self atOrBelow: envtName ifAbsent: [nil]! !!Environment methodsFor: 'system conversion' stamp: 'di 12/6/1999 22:36'!doesNotUnderstand: message	message selector first isUppercase ifFalse: [^ super doesNotUnderstand: message].	(message selector includes: $:) ifTrue: [^ super doesNotUnderstand: message].	^ self atOrAbove: message selector ifAbsent: [^ super doesNotUnderstand: message]! !!Environment methodsFor: 'system conversion' stamp: 'di 12/6/1999 20:50'!kernelCategories	^ #(Kernel Collections Graphics Tools System)! !!Environment methodsFor: 'system conversion' stamp: 'di 12/6/1999 13:31'!rewriteSourceForSelector: selector inClass: aClass using: envtForVar	"Rewrite the source code for the method in question so that all global references out of the direct access path are converted to indirect global references.  This is done by parsing the source with a lenient parser able to find variables in any environment.  Then the parse tree is consulted for the source code ranges of each reference that needs to be rewritten and the pattern to which it should be rewritten.  Note that assignments, which will take the form	envt setValueOf: #GlobalName to: ...may generate spurious message due to agglutination of keywords with the value expression."	| code methodNode edits varName envtName envt |	code _ aClass sourceCodeAt: selector.	methodNode _ Compiler new parse: code in: aClass notifying: nil.	edits _ OrderedCollection new.	methodNode encoder globalSourceRanges do:		[:tuple |   "{ varName. srcRange. store }"		(aClass scopeHas: (varName _ tuple first asSymbol) ifTrue: [:ignored]) ifFalse:			["This is a remote global.  Add it as reference to be edited."			edits addLast: { varName. tuple at: 2. tuple at: 3 }]].	"Sort the edits by source position."	edits _ edits asSortedCollection: [:a :b | a second first < b second first].	edits reverseDo:		[:edit | varName _ edit first.		(envtName _ envtForVar at: varName ifAbsent: [nil]) ifNotNil:			["Replace each access out of scope with a proper remote reference"			code _ code copyReplaceFrom: edit second first						to: edit second last						with: envtName , ' ' , varName.			"If varName is not already exported, define an export method"			envt _ self at: envtName.			(envt class includesSelector: varName) ifFalse:				[envt class compile: (self exportMethodFor: varName)						 classified: 'exports']]].	aClass compile: code classified: (aClass organization categoryOfElement: selector)! !!Environment class reorganize!('system conversion' reorganizeEverything)!!Environment class methodsFor: 'system conversion' stamp: 'di 12/6/1999 20:51'!reorganizeEverything		"Environment reorganizeEverything.		Smalltalk browseIndirectRefs.		Smalltalk tallyIndirectRefs.		Smalltalk rewriteIndirectRefs."	| bigCat envt |	"Paint the world so we know not to save it."	World == nil		ifTrue: [Preferences desktopColor: Color red darker darker.				ScheduledControllers updateGray; restore]		ifFalse: [World color: Color red darker darker].	"Recreate the Smalltalk dictionary as the top-level Environment."	Smalltalk _ SmalltalkEnvironment newFrom: Smalltalk.	"Don't hang onto old copy of Smalltalk ."	Smalltalk recreateSpecialObjectsArray.	"Store values for environment and category in each class."	Smalltalk allClassesDo:		[:c | c environment: nil category: nil. "Flush any old values"		c environment: c environment category: c category].	"Run through all categories making up new sub-environments"	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			["Not a kernel category ..."			envt _ Smalltalk at: bigCat						ifAbsent: ["... make up a new environment if necessary ..."									Smalltalk makeSubEnvironmentNamed: bigCat].			"... and install the member classes in that category"			envt transferBindingsNamedIn: (SystemOrganization listAtCategoryNamed: cat)									from: Smalltalk].		].	Smalltalk rebuildSystemOrganization.	Smalltalk rewriteIndirectRefs.	Preferences enable: #browserShowsPackagePane.! !