'From Squeakland 3.8.5976 of 25 August 2004 [latest update: #388] on 23 February 2005 at 4:23:11 pm'!"Change Set:		changesFromSql38ToJaDate:			23 February 2005Author:			Yoshiki Ohshima and Takashi YamamiyaMerge all the changes from Squeakland 3.8 388 to the latest working version of Japanese."!ClipboardInterpreter subclass: #CP1250ClipboardInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!KeyboardInputInterpreter subclass: #CP1250InputInterpreter	instanceVariableNames: 'converter'	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!TextConverter subclass: #CP1250TextConverter	instanceVariableNames: ''	classVariableNames: 'FromTable'	poolDictionaries: ''	category: 'Multilingual-TextConversion'!Smalltalk renameClassNamed: #PasswordFont as: #FixedFaceFont!AbstractFont subclass: #FixedFaceFont	instanceVariableNames: 'baseFont substitutionCharacter displaySelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Display'!!FixedFaceFont commentStamp: 'tak 12/22/2004 01:45' prior: 0!I am a font for special purpose like password or fallback.I can show same form whenever someone requests any character.Variable displaySelector is future use to show a form dynamically.(Although it would be unnecessary...)!TestCase subclass: #FontTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Display'!BitBlt subclass: #GrafPort	instanceVariableNames: 'alpha fillPattern lastFont lastFontForegroundColor lastFontBackgroundColor'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!ClipboardInterpreter subclass: #ISO88592ClipboardInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!KeyboardInputInterpreter subclass: #ISO88592InputInterpreter	instanceVariableNames: 'converter'	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!TextConverter subclass: #ISO88592TextConverter	instanceVariableNames: ''	classVariableNames: 'FromTable'	poolDictionaries: ''	category: 'Multilingual-TextConversion'!LanguageEnvironment subclass: #Latin2Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Languages'!TestCase subclass: #MorphTest	instanceVariableNames: 'morph world'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel-Tests'!Object subclass: #MultiCharacterScanner	instanceVariableNames: 'destX lastIndex xTable map destY stopConditions text textStyle alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth emphasisCode kern indentationLevel wantsColumnBreaks presentation presentationLine numOfComposition baselineY'	classVariableNames: 'DefaultStopConditions NilCondition PaddedSpaceCondition SpaceCondition'	poolDictionaries: 'TextConstants'	category: 'Multilingual-Scanning'!Object subclass: #NaturalLanguageFormTranslator	instanceVariableNames: 'id generics'	classVariableNames: 'CachedTranslations'	poolDictionaries: ''	category: 'System-Localization'!SystemWindow subclass: #LanguageEditor	instanceVariableNames: 'translator selectedTranslation selectedTranslations selectedUntranslated translationsList untranslatedList translationText translationsFilter untranslatedFilter'	classVariableNames: 'CheckMethods'	poolDictionaries: ''	category: 'Multilingual-Editor'!!LanguageEditor commentStamp: 'dgd 11/16/2003 15:02' prior: 0!Editor for Babel's languages.Open it from	World Menu >> open... >> Language Editor			(to open on default language)	World Menu >> open... >> Language Editor for...	(to choose the language)Or click:	LanguageEditor openOnDefault.	LanguageEditor open.See http://swiki.agro.uba.ar/small_land/191 for documentation!!AbstractFont methodsFor: 'accessing' stamp: 'yo 1/7/2005 11:19'!ascent	self subclassResponsibility.! !!AbstractFont methodsFor: 'accessing' stamp: 'yo 1/7/2005 11:18'!ascentOf: aCharacter	^ self ascent.! !!AbstractFont methodsFor: 'accessing' stamp: 'yo 1/7/2005 11:18'!basicAscentOf: aCharacter	^ self ascent.! !!AbstractFont methodsFor: 'accessing' stamp: 'yo 1/7/2005 11:19'!basicDescentOf: aCharacter	^ self descent.! !!AbstractFont methodsFor: 'accessing' stamp: 'yo 1/7/2005 11:20'!descent	self subclassResponsibility.! !!AbstractFont methodsFor: 'accessing' stamp: 'yo 1/7/2005 11:20'!descentOf: aCharacter	^ self descent.! !!AbstractFont methodsFor: 'displaying' stamp: 'yo 1/7/2005 11:36'!displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) display context."	^self subclassResponsibility! !!AbstractFont methodsFor: 'measuring' stamp: 'tak 1/11/2005 17:20'!approxWidthOfText: aText"Return the width of aText -- quickly, and a little bit dirty. Used by lists morphs containing Text objects to get a quick, fairly accurate measure of the width of a list item."    | w |        (aText isNil or: [aText size == 0 ])        ifTrue:[^0].           w _ self        widthOfString: aText asString.     "If the text has no emphasis, just return the string size.  If it is empasized,     just approximate the width by adding about 20% to the width"       (((aText runLengthFor: 1) == aText size)        and: [(aText emphasisAt: 1) == 0 ])            ifTrue:[^w]            ifFalse:[ ^w * 6 // 5 ]. ! !!Archive methodsFor: 'archive operations' stamp: 'tak 2/2/2005 13:22'!addTree: aFileNameOrDirectory match: aBlock 	| nameSize |	nameSize := aFileNameOrDirectory isString				ifTrue: [aFileNameOrDirectory size]				ifFalse: [aFileNameOrDirectory pathName size].	^ self		addTree: aFileNameOrDirectory		removingFirstCharacters: nameSize + 1		match: aBlock! !!Archive methodsFor: 'archive operations' stamp: 'tak 2/2/2005 13:00'!addTree: aFileNameOrDirectory removingFirstCharacters: n 	^ self		addTree: aFileNameOrDirectory		removingFirstCharacters: n		match: [:e | true]! !!Archive methodsFor: 'archive operations' stamp: 'tak 2/15/2005 11:27'!addTree: aFileNameOrDirectory removingFirstCharacters: n match: aBlock	| dir newMember fullPath relativePath |	dir _ (aFileNameOrDirectory isString)		ifTrue: [ FileDirectory on: aFileNameOrDirectory ]		ifFalse: [ aFileNameOrDirectory ].	fullPath _ dir pathName, dir slash.	relativePath _ fullPath copyFrom: n + 1 to: fullPath size.	(dir entries select: [ :entry | aBlock value: entry])		do: [ :ea | | fullName |		fullName _ fullPath, ea name.		newMember _ ea isDirectory				ifTrue: [ self memberClass newFromDirectory: fullName ]				ifFalse: [ self memberClass newFromFile: fullName ].		newMember localFileName: relativePath, ea name.		self addMember: newMember.		ea isDirectory ifTrue: [ self addTree: fullName removingFirstCharacters: n match: aBlock].	].! !!BitBlt methodsFor: 'private' stamp: 'yo 1/8/2005 09:12'!installTTCFont: aTTCFont foregroundColor: foregroundColor backgroundColor: backgroundColor	"Set up the parameters.  Since the glyphs in a TTCFont is 32bit depth form, it tries to use rule=34 to get better AA result if possible."	((aTTCFont depth = 32)) ifTrue: [		destForm depth <= 8 ifTrue: [			self colorMap: (self cachedFontColormapFrom: aTTCFont depth to: destForm depth).			self combinationRule: Form paint.		] ifFalse: [			self colorMap: nil.			self combinationRule: 34.		].		halftoneForm _ nil.		sourceY _ 0.		height _ aTTCFont height.	].! !!CP1250ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'pk 1/19/2005 20:26'!fromSystemClipboard: aString	| result converter |	result := WriteStream on: (String new: aString size).	converter := CP1250TextConverter new.	aString do: [:each |		result nextPut: (converter toSqueak: each squeakToIso) asCharacter.	].	^ result contents.! !!CP1250ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'pk 1/19/2005 15:13'!toSystemClipboard: aString	| result converter r |	aString isAsciiString ifTrue: [^ aString asOctetString]. "optimization"	result _ WriteStream on: (String new: aString size).	converter _ CP1250TextConverter new.	aString do: [:each |		r _ converter fromSqueak: each.		r charCode < 255 ifTrue: [		result nextPut: r isoToSqueak]].	^ result contents.! !!CP1250InputInterpreter methodsFor: 'as yet unclassified' stamp: 'pk 1/19/2005 20:40'!initialize	converter _ CP1250TextConverter new.! !!CP1250InputInterpreter methodsFor: 'as yet unclassified' stamp: 'pk 1/19/2005 20:31'!nextCharFrom: sensor firstEvt: evtBuf	"Input from the Czech keyboard under Windows doesn't correspond to cp-1250 or iso-8859-2 encoding!!"	| keyValue |	keyValue := evtBuf third.	^ converter toSqueak: keyValue asCharacter squeakToIso.! !!CP1250TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 2/9/2005 05:29'!fromSqueak: char	^ Character value: (FromTable at: char charCode ifAbsent: [char asciiValue])! !!CP1250TextConverter methodsFor: 'as yet unclassified' stamp: 'pk 1/19/2005 14:34'!nextFromStream: aStream	| character1 |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 _ aStream basicNext.	character1 isNil ifTrue: [^ nil].	^ self toSqueak: character1.! !!CP1250TextConverter methodsFor: 'as yet unclassified' stamp: 'pk 1/19/2005 14:34'!nextPut: aCharacter toStream: aStream	aStream isBinary ifTrue: [		aCharacter class == Character ifTrue: [			aStream basicNextPut: aCharacter charCode.			^ aStream.		].		aCharacter class == MultiCharacter ifTrue: [			aStream nextInt32Put: aCharacter charCode.			^ aStream.		].	].	aCharacter charCode < 128 ifTrue: [		aStream basicNextPut: aCharacter.	] ifFalse: [		aStream basicNextPut: ((Character value: (self fromSqueak: aCharacter) charCode)).	].! !!CP1250TextConverter methodsFor: 'as yet unclassified' stamp: 'pk 1/19/2005 18:05'!toSqueak: char	| value |	value _ char charCode.	value < 129 ifTrue: [^ char].	value > 255 ifTrue: [^ char].	^ MultiCharacter leadingChar: Latin2Environment leadingChar code: (#(		16r0081 16r201A 16r0083 16r201E 16r2026 		16r2020 16r2021 16r0088 16r2030 16r0160 		16r2039 16r015A 16r0164 16r017D 16r0179 		16r0090 16r2018 16r2019 16r201C 16r201D 		16r2022 16r2013 16r2014 16r0098 16r2122 		16r0161 16r203A 16r015B 16r0165 16r017E 		16r017A 16r00A0 16r02C7 16r02D8 16r0141 		16r00A4 16r0104 16r00A6 16r00A7 16r00A8 		16r00A9 16r015E 16r00AB 16r00AC 16r00AD 		16r00AE 16r017B 16r00B0 16r00B1 16r02DB 		16r0142 16r00B4 16r00B5 16r00B6 16r00B7 		16r00B8 16r0105 16r015F 16r00BB 16r013D 		16r02DD 16r013E 16r017C 16r0154 16r00C1 		16r00C2 16r0102 16r00C4 16r0139 16r0106 		16r00C7 16r010C 16r00C9 16r0118 16r00CB 		16r011A 16r00CD 16r00CE 16r010E 16r0110 		16r0143 16r0147 16r00D3 16r00D4 16r0150 		16r00D6 16r00D7 16r0158 16r016E 16r00DA 		16r0170 16r00DC 16r00DD 16r0162 16r00DF 		16r0155 16r00E1 16r00E2 16r0103 16r00E4 		16r013A 16r0107 16r00E7 16r010D 16r00E9 		16r0119 16r00EB 16r011B 16r00ED 16r00EE 		16r010F 16r0111 16r0144 16r0148 16r00F3 		16r00F4 16r0151 16r00F6 16r00F7 16r0159 		16r016F 16r00FA 16r0171 16r00FC 16r00FD 		16r0163 16r02D9 ) at: (value - 129 + 1)).! !!CP1250TextConverter class methodsFor: 'as yet unclassified' stamp: 'pk 1/19/2005 14:35'!encodingNames 	^ #('cp-1250') copy! !!CP1250TextConverter class methodsFor: 'as yet unclassified' stamp: 'pk 1/19/2005 19:35'!initialize"	CP1250TextConverter initialize"	FromTable _ Dictionary new.	FromTable at: 16r0081 put: 16r81.	FromTable at: 16r201A put: 16r82.	FromTable at: 16r0083 put: 16r83.	FromTable at: 16r201E put: 16r84.	FromTable at: 16r2026 put: 16r85.	FromTable at: 16r2020 put: 16r86.	FromTable at: 16r2021 put: 16r87.	FromTable at: 16r0088 put: 16r88.	FromTable at: 16r2030 put: 16r89.	FromTable at: 16r0160 put: 16r8A.	FromTable at: 16r2039 put: 16r8B.	FromTable at: 16r015A put: 16r8C.	FromTable at: 16r0164 put: 16r8D.	FromTable at: 16r017D put: 16r8E.	FromTable at: 16r0179 put: 16r8F.	FromTable at: 16r0090 put: 16r90.	FromTable at: 16r2018 put: 16r91.	FromTable at: 16r2019 put: 16r92.	FromTable at: 16r201C put: 16r93.	FromTable at: 16r201D put: 16r94.	FromTable at: 16r2022 put: 16r95.	FromTable at: 16r2013 put: 16r96.	FromTable at: 16r2014 put: 16r97.	FromTable at: 16r0098 put: 16r98.	FromTable at: 16r2122 put: 16r99.	FromTable at: 16r0161 put: 16r9A.	FromTable at: 16r203A put: 16r9B.	FromTable at: 16r015B put: 16r9C.	FromTable at: 16r0165 put: 16r9D.	FromTable at: 16r017E put: 16r9E.	FromTable at: 16r017A put: 16r9F.	FromTable at: 16r00A0 put: 16rA0.	FromTable at: 16r02C7 put: 16rA1.	FromTable at: 16r02D8 put: 16rA2.	FromTable at: 16r0141 put: 16rA3.	FromTable at: 16r00A4 put: 16rA4.	FromTable at: 16r0104 put: 16rA5.	FromTable at: 16r00A6 put: 16rA6.	FromTable at: 16r00A7 put: 16rA7.	FromTable at: 16r00A8 put: 16rA8.	FromTable at: 16r00A9 put: 16rA9.	FromTable at: 16r015E put: 16rAA.	FromTable at: 16r00AB put: 16rAB.	FromTable at: 16r00AC put: 16rAC.	FromTable at: 16r00AD put: 16rAD.	FromTable at: 16r00AE put: 16rAE.	FromTable at: 16r017B put: 16rAF.	FromTable at: 16r00B0 put: 16rB0.	FromTable at: 16r00B1 put: 16rB1.	FromTable at: 16r02DB put: 16rB2.	FromTable at: 16r0142 put: 16rB3.	FromTable at: 16r00B4 put: 16rB4.	FromTable at: 16r00B5 put: 16rB5.	FromTable at: 16r00B6 put: 16rB6.	FromTable at: 16r00B7 put: 16rB7.	FromTable at: 16r00B8 put: 16rB8.	FromTable at: 16r0105 put: 16rB9.	FromTable at: 16r015F put: 16rBA.	FromTable at: 16r00BB put: 16rBB.	FromTable at: 16r013D put: 16rBC.	FromTable at: 16r02DD put: 16rBD.	FromTable at: 16r013E put: 16rBE.	FromTable at: 16r017C put: 16rBF.	FromTable at: 16r0154 put: 16rC0.	FromTable at: 16r00C1 put: 16rC1.	FromTable at: 16r00C2 put: 16rC2.	FromTable at: 16r0102 put: 16rC3.	FromTable at: 16r00C4 put: 16rC4.	FromTable at: 16r0139 put: 16rC5.	FromTable at: 16r0106 put: 16rC6.	FromTable at: 16r00C7 put: 16rC7.	FromTable at: 16r010C put: 16rC8.	FromTable at: 16r00C9 put: 16rC9.	FromTable at: 16r0118 put: 16rCA.	FromTable at: 16r00CB put: 16rCB.	FromTable at: 16r011A put: 16rCC.	FromTable at: 16r00CD put: 16rCD.	FromTable at: 16r00CE put: 16rCE.	FromTable at: 16r010E put: 16rCF.	FromTable at: 16r0110 put: 16rD0.	FromTable at: 16r0143 put: 16rD1.	FromTable at: 16r0147 put: 16rD2.	FromTable at: 16r00D3 put: 16rD3.	FromTable at: 16r00D4 put: 16rD4.	FromTable at: 16r0150 put: 16rD5.	FromTable at: 16r00D6 put: 16rD6.	FromTable at: 16r00D7 put: 16rD7.	FromTable at: 16r0158 put: 16rD8.	FromTable at: 16r016E put: 16rD9.	FromTable at: 16r00DA put: 16rDA.	FromTable at: 16r0170 put: 16rDB.	FromTable at: 16r00DC put: 16rDC.	FromTable at: 16r00DD put: 16rDD.	FromTable at: 16r0162 put: 16rDE.	FromTable at: 16r00DF put: 16rDF.	FromTable at: 16r0155 put: 16rE0.	FromTable at: 16r00E1 put: 16rE1.	FromTable at: 16r00E2 put: 16rE2.	FromTable at: 16r0103 put: 16rE3.	FromTable at: 16r00E4 put: 16rE4.	FromTable at: 16r013A put: 16rE5.	FromTable at: 16r0107 put: 16rE6.	FromTable at: 16r00E7 put: 16rE7.	FromTable at: 16r010D put: 16rE8.	FromTable at: 16r00E9 put: 16rE9.	FromTable at: 16r0119 put: 16rEA.	FromTable at: 16r00EB put: 16rEB.	FromTable at: 16r011B put: 16rEC.	FromTable at: 16r00ED put: 16rED.	FromTable at: 16r00EE put: 16rEE.	FromTable at: 16r010F put: 16rEF.	FromTable at: 16r0111 put: 16rF0.	FromTable at: 16r0144 put: 16rF1.	FromTable at: 16r0148 put: 16rF2.	FromTable at: 16r00F3 put: 16rF3.	FromTable at: 16r00F4 put: 16rF4.	FromTable at: 16r0151 put: 16rF5.	FromTable at: 16r00F6 put: 16rF6.	FromTable at: 16r00F7 put: 16rF7.	FromTable at: 16r0159 put: 16rF8.	FromTable at: 16r016F put: 16rF9.	FromTable at: 16r00FA put: 16rFA.	FromTable at: 16r0171 put: 16rFB.	FromTable at: 16r00FC put: 16rFC.	FromTable at: 16r00FD put: 16rFD.	FromTable at: 16r0163 put: 16rFE.	FromTable at: 16r02D9 put: 16rFF! !!CodeHolder methodsFor: 'what to show' stamp: 'yo 2/17/2005 18:09'!offerWhatToShowMenu	"Offer a menu governing what to show"	| aMenu |	Smalltalk isMorphic		ifTrue: [aMenu := MenuMorph new defaultTarget: self.			aMenu addTitle: 'What to show' translated.			aMenu addStayUpItem.			self addContentsTogglesTo: aMenu.			aMenu popUpInWorld]		ifFalse: [aMenu := CustomMenu new.			self addContentsTogglesTo: aMenu.			aMenu title: 'What to show' translated.			aMenu invokeOn: self.			self changed: #contents ]! !!CodeHolder methodsFor: 'tiles' stamp: 'yo 2/17/2005 18:14'!addModelItemsToWindowMenu: aMenu	"Add model-related item to the window menu"	super addModelItemsToWindowMenu: aMenu. 	Smalltalk isMorphic ifTrue:		[aMenu addLine.		aMenu add: 'what to show...' translated target: self action: #offerWhatToShowMenu]! !!Color class methodsFor: 'color from user' stamp: 'ka 2/18/2005 02:29'!colorPaletteForDepth: depth extent: chartExtent	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."	"Note: It is slow to build this palette, so it should be cached for quick access."	"(Color colorPaletteForDepth: 16 extent: 190@60) display"	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps formTranslator noColorForm |	formTranslator := NaturalLanguageFormTranslator localeID: Locale current localeID.	noColorForm := formTranslator translate: 'no color'.	noColorForm		ifNil: [noColorForm := Form						extent: 34 @ 9						depth: 1						fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0 )						offset: 0 @ 0].	palette _ Form extent: chartExtent depth: depth.	transCaption _ "(DisplayText text: 'no color' asText textStyle: (TextConstants at: #ComicPlain)) form storeString"		noColorForm.	transHt _ transCaption height.	palette fillWhite: (0@0 extent: palette width@transHt).	palette fillBlack: (0@transHt extent: palette width@1).	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).	grayWidth _ 10.	startHue _ 338.0.	vSteps _ palette height - transHt // 2.	hSteps _ palette width - grayWidth.	x _ 0.	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.		y _ transHt+1.		0 to: vSteps do: [:n | 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		1 to: vSteps do: [:n | 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		x _ x + 1].	y _ transHt + 1.	1 to: vSteps * 2 do: [:n | 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.		palette fill: (x@y extent: 10@1) fillColor: c.		y _ y + 1].	^ palette! !!EFontBDFFontReader methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 15:29'!readFrom: start to: end	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx width blt lastAscii pointSize ret lastValue |	form _ encoding _ bbx _ nil.	self initialize.	self readAttributes.	height _ Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent _ Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent _ Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	(properties includesKey: 'POINT_SIZE' asSymbol) ifTrue: [		pointSize _ (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.	] ifFalse: [		pointSize _ (ascent + descent) * 72 // 96.	].				maxWidth _ 0.	minAscii _ 16r200000.	strikeWidth _ 0.	maxAscii _ 0.	charsNum _ Integer readFromString: (properties at: #CHARS) first.	chars _ Set new: charsNum.	self readCharactersInRangeFrom: start to: end totalNums: charsNum storeInto: chars.	chars _ chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum _ chars size. "undefined encodings make this different"	chars do: [:array |		encoding _ array at: 2.		bbx _ array at: 3..		width _ bbx at: 1.		maxWidth _ maxWidth max: width.		minAscii _ minAscii min: encoding.		maxAscii _ maxAscii max: encoding.		strikeWidth _ strikeWidth + width.	].	glyphs _ Form extent: strikeWidth@height.	blt _ BitBlt toForm: glyphs.	"xTable _ XTableForUnicodeFont new ranges: (Array with: (Array with: start with: end))."	xTable _ SparseLargeTable new: end + 3 chunkSize: 32 arrayClass: Array base: start + 1 defaultValue: -1.	lastAscii _ start.		1 to: charsNum do: [:i |		form _ (chars at: i) first.		encoding _ (chars at: i) second.		bbx _ (chars at: i) third.		"lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)]."		lastValue _ xTable at: lastAscii + 1 + 1.		xTable at: encoding + 1 put: lastValue.		blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form.		xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).		lastAscii _ encoding.	].	xTable zapDefaultOnlyEntries.	ret _ Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'yo 1/19/2005 11:20'!rangesForLatin2	^ {		Array with: 0 with: 16r17F.		Array with: 16r2B0 with: 16r2FF.		Array with: 16r2000 with: 16r206F.		Array with: 16r2122 with: 16r2122.		Array with: 16rFFFF with: 16rFFFF. "sentinel"	}.! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'yo 1/19/2005 11:26'!readRanges: ranges	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx width blt lastAscii pointSize ret lastValue start end |	form _ encoding _ bbx _ nil.	self initialize.	self readAttributes.	height _ Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent _ Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent _ Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	(properties includesKey: 'POINT_SIZE' asSymbol) ifTrue: [		pointSize _ (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.	] ifFalse: [		pointSize _ (ascent + descent) * 72 // 96.	].	maxWidth _ 0.	minAscii _ 16r200000.	strikeWidth _ 0.	maxAscii _ 0.	charsNum _ Integer readFromString: (properties at: #CHARS) first.	chars _ Set new: charsNum.	self readCharactersInRanges: ranges storeInto: chars.	chars _ chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum _ chars size. "undefined encodings make this different"	chars do: [:array |		encoding _ array at: 2.		bbx _ array at: 3..		width _ bbx at: 1.		maxWidth _ maxWidth max: width.		minAscii _ minAscii min: encoding.		maxAscii _ maxAscii max: encoding.		strikeWidth _ strikeWidth + width.	].	glyphs _ Form extent: strikeWidth@height.	blt _ BitBlt toForm: glyphs.	start _ (ranges collect: [:r | r first]) min.	end _ (ranges collect: [:r | r second]) max + 3.	xTable _ SparseLargeTable new: end chunkSize: 64 arrayClass: Array base: start +1 defaultValue: -1.	lastAscii _ start.	xTable at: lastAscii + 2 put: 0.	1 to: charsNum do: [:i |		form _ (chars at: i) first.		encoding _ (chars at: i) second.		bbx _ (chars at: i) third.		"lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)]."		lastValue _ xTable at: lastAscii + 1 + 1.		xTable at: encoding + 1 put: lastValue.		blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form.		xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).		lastAscii _ encoding.	].	xTable at: xTable size put: (xTable at: xTable size - 1).	xTable zapDefaultOnlyEntries.	ret _ Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!EUCTextConverter methodsFor: 'as yet unclassified' stamp: 'ei 2/3/2005 20:10'!nextFromStream: aStream	| character1 character2 offset value1 value2 nonUnicodeChar |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 _ aStream basicNext.	character1 isNil ifTrue: [^ nil].	character1 asciiValue <= 127 ifTrue: [^ character1].	character2 _ aStream basicNext.	character2 = nil ifTrue: [^ nil].	offset _ 16rA1.	value1 _ character1 asciiValue - offset.	value2 _ character2 asciiValue - offset.	(value1 < 0 or: [value1 > 93]) ifTrue: [^ nil].	(value2 < 0 or: [value2 > 93]) ifTrue: [^ nil].	nonUnicodeChar _ MultiCharacter leadingChar: self leadingChar code: value1 * 94 + value2.	^ MultiCharacter leadingChar: self languageEnvironment leadingChar code: nonUnicodeChar asUnicode.! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 1/19/2005 11:33'!initialize"	self initialize"	self allSubclassesDo: [:each | each initialize].	EncodedCharSets _ Array new: 256.	EncodedCharSets at: 0+1 put: Latin1Environment.	EncodedCharSets at: 1+1 put: JISX0208.	EncodedCharSets at: 2+1 put: GB2312.	EncodedCharSets at: 3+1 put: KSX1001.	EncodedCharSets at: 4+1 put: JISX0208.	EncodedCharSets at: 5+1 put: JapaneseEnvironment.	EncodedCharSets at: 6+1 put: SimplifiedChineseEnvironment.	EncodedCharSets at: 7+1 put: KoreanEnvironment.	EncodedCharSets at: 8+1 put: GB2312.	"EncodedCharSets at: 9+1 put: UnicodeTraditionalChinese."	"EncodedCharSets at: 10+1 put: UnicodeVietnamese."	EncodedCharSets at: 12+1 put: KSX1001.	EncodedCharSets at: 13+1 put: GreekEnvironment.	EncodedCharSets at: 14+1 put: Latin2Environment.	EncodedCharSets at: 256 put: Unicode.! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'yo 12/2/2004 16:13'!isCharset	^ true.! !!FileDirectory class methodsFor: 'system start up' stamp: 'tak 12/17/2004 14:03'!setDefaultDirectory: directoryName	"Initialize the default directory to the directory supplied. This method is called when the image starts up."	| dirName |	DirectoryClass _ self activeDirectoryClass.	dirName _ (FilePath pathName: directoryName) asSqueakPathName.	[dirName endsWith: self slash] whileTrue:[		dirName _ dirName copyFrom: 1 to: dirName size - self slash size.	].	DefaultDirectory _ self on: dirName.! !!FileStream class methodsFor: 'file reader services' stamp: 'tak 1/12/2005 14:59'!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	| extension converter f fileName |	aStream contents isAsciiString ifTrue: [		stOrCsFlag ifTrue: [			extension _ (FileDirectory dot, FileStream st).		] ifFalse: [			extension _ (FileDirectory dot, FileStream cs).		].		converter _ MacRomanTextConverter new.	] ifFalse: [		stOrCsFlag ifTrue: [			extension _ (FileDirectory dot, FileStream st "multiSt").		] ifFalse: [			extension _ (FileDirectory dot, FileStream cs "multiCs").		].		converter _ UTF8TextConverter new.	].	fileName _ useHtml ifTrue: [baseName, '.html'] ifFalse: [baseName, extension].	f _ FileStream newFileNamed: fileName.	f ifNil: [^ self error: 'Cannot open file'].	(converter isMemberOf: UTF8TextConverter)		ifTrue: [f binary.			UTF8TextConverter writeBOMOn: f].	f text.	f converter: converter.	f nextPutAll: aStream contents.	f close.! !!EFontBDFFontReaderForRanges class methodsFor: 'as yet unclassified' stamp: 'yo 1/19/2005 11:24'!rangesForGreek	^ {		Array with: 16r1 with: 16rFF.		Array with: 16r370 with: 16r3FF.		Array with: 16r1F00 with: 16r1FFF.		Array with: 16r2000 with: 16r206F.		Array with: 16r20A0 with: 16r20AF	}.! !!EFontBDFFontReaderForRanges class methodsFor: 'as yet unclassified' stamp: 'yo 1/19/2005 11:24'!rangesForLatin2	^ {		Array with: 0 with: 16r17F.		Array with: 16r2B0 with: 16r2FF.		Array with: 16r2000 with: 16r206F.		Array with: 16r2122 with: 16r2122.		Array with: 16rFFFF with: 16rFFFF. "sentinel"	}.! !!FixedFaceFont methodsFor: 'accessing' stamp: 'tak 12/20/2004 10:51'!ascentOf: aCharacter	^ self ascent! !!FixedFaceFont methodsFor: 'accessing' stamp: 'tak 12/22/2004 02:01'!characterFormAt: character 	^ baseFont characterFormAt: substitutionCharacter! !!FixedFaceFont methodsFor: 'accessing' stamp: 'tak 12/20/2004 10:51'!descentOf: aCharacter	^ self descent! !!FixedFaceFont methodsFor: 'accessing' stamp: 'tak 12/20/2004 10:10'!emphasized: emph	^self class new baseFont: (baseFont emphasized: emph)! !!FixedFaceFont methodsFor: 'accessing' stamp: 'tak 12/20/2004 10:19'!fontSize: aNumber 	self baseFont: (StrikeFont familyName: baseFont familyName size: aNumber) copy! !!FixedFaceFont methodsFor: 'accessing' stamp: 'tak 12/20/2004 10:51'!maxAscii	^ SmallInteger maxVal! !!FixedFaceFont methodsFor: 'measuring' stamp: 'tak 12/20/2004 18:05'!widthOf: aCharacter 	^ baseFont widthOf: substitutionCharacter! !!FixedFaceFont methodsFor: 'displaying' stamp: 'tak 12/20/2004 18:06'!displayErrorOn: aCanvas length: length at: aPoint kern: kernDelta 	| maskedString |	maskedString := String new: length.	maskedString atAllPut: substitutionCharacter.	^ baseFont		displayString: maskedString		on: aCanvas		from: 1		to: length		at: aPoint		kern: kernDelta! !!FixedFaceFont methodsFor: 'displaying' stamp: 'yo 1/7/2005 11:49'!displayErrorOn: aCanvas length: length at: aPoint kern: kernDelta baselineY: baselineY	| maskedString |	maskedString := String new: length.	maskedString atAllPut: substitutionCharacter.	^ baseFont		displayString: maskedString		on: aCanvas		from: 1		to: length		at: aPoint		kern: kernDelta		baselineY: baselineY! !!FixedFaceFont methodsFor: 'displaying' stamp: 'tak 12/20/2004 18:06'!displayPasswordOn: aCanvas length: length at: aPoint kern: kernDelta 	| maskedString |	maskedString := String new: length.	maskedString atAllPut: substitutionCharacter.	^ baseFont		displayString: maskedString		on: aCanvas		from: 1		to: length		at: aPoint		kern: kernDelta! !!FixedFaceFont methodsFor: 'displaying' stamp: 'yo 1/7/2005 11:50'!displayPasswordOn: aCanvas length: length at: aPoint kern: kernDelta baselineY: baselineY	| maskedString |	maskedString := String new: length.	maskedString atAllPut: substitutionCharacter.	^ baseFont		displayString: maskedString		on: aCanvas		from: 1		to: length		at: aPoint		kern: kernDelta		baselineY: baselineY! !!FixedFaceFont methodsFor: 'displaying' stamp: 'yo 1/7/2005 12:00'!displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDelta 	| size |	size := stopIndex - startIndex + 1.	^ self perform: displaySelector withArguments: (Array with: aDisplayContext with: size with: aPoint with: kernDelta with: aPoint y + self ascent).! !!FixedFaceFont methodsFor: 'displaying' stamp: 'yo 1/7/2005 12:19'!displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| size |	size := stopIndex - startIndex + 1.	^ self perform: displaySelector withArguments: (Array with: aDisplayContext with: size with: aPoint with: kernDelta with: baselineY).! !!FixedFaceFont methodsFor: 'displaying' stamp: 'tak 12/20/2004 11:10'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta from: fromFont 	| destPoint |	destPoint := self				displayString: aString				on: aBitBlt				from: startIndex				to: stopIndex				at: aPoint				kern: kernDelta.	^ Array with: stopIndex + 1 with: destPoint! !!FixedFaceFont methodsFor: 'displaying' stamp: 'yo 1/7/2005 11:51'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta from: fromFont baselineY: baselineY	| destPoint |	destPoint := self				displayString: aString				on: aBitBlt				from: startIndex				to: stopIndex				at: aPoint				kern: kernDelta				baselineY: baselineY.	^ Array with: stopIndex + 1 with: destPoint! !!FixedFaceFont methodsFor: 'initialize-release' stamp: 'yo 1/7/2005 11:59'!errorFont	displaySelector := #displayErrorOn:length:at:kern:baselineY:.	substitutionCharacter := $?.! !!FixedFaceFont methodsFor: 'initialize-release' stamp: 'tak 12/20/2004 10:37'!initialize	baseFont := TextStyle defaultFont.	self passwordFont! !!FixedFaceFont methodsFor: 'initialize-release' stamp: 'yo 1/7/2005 11:59'!passwordFont	displaySelector := #displayPasswordOn:length:at:kern:baselineY:.	substitutionCharacter := $*! !!FixedFaceFont methodsFor: 'private' stamp: 'yo 1/11/2005 18:54'!glyphInfoOf: aCharacter into: glyphInfoArray	^ baseFont glyphInfoOf: substitutionCharacter into: glyphInfoArray.! !!FontTest methodsFor: 'testing' stamp: 'yo 1/13/2005 16:44'!testDisplay	"self debug: #testDisplay"	| text font bb destPoint width |	text _ 'test' asText.	font _ TextStyle default fontOfSize: 21.	text addAttribute: (TextFontReference toFont: font).	bb _ (Form extent: 100 @ 30) getCanvas privatePort.	bb combinationRule: Form paint.	font installOn: bb foregroundColor: Color black backgroundColor: Color white.	destPoint _ font displayString: text on: bb from: 1 to: 4 at: 0@0 kern: 1.	width _ text inject: 0 into: [:max :char | max + (font widthOf: char)].	self assert: destPoint x = (width + 4).	"bb destForm asMorph openInHand."! !!FontTest methodsFor: 'testing' stamp: 'yo 1/13/2005 16:41'!testFallback	"self debug: #testFallback"	| text font bb destPoint |	text _ (Character value: 257) asString asText.	font _ TextStyle default fontOfSize: 21.	text addAttribute: (TextFontReference toFont: font).	bb _ (Form extent: 100 @ 30) getCanvas privatePort.	bb combinationRule: Form paint.	font installOn: bb foregroundColor: Color black backgroundColor: Color white.	destPoint _ font displayString: text on: bb from: 1 to: 1 at: 0@0 kern: 1.	"bb destForm asMorph openInHand."	self assert: destPoint x = ((font widthOf: $?) + 1).! !!FontTest methodsFor: 'testing' stamp: 'tak 12/22/2004 00:56'!testMultistringFallbackFont	"self debug: #testMultistringFallbackFont"	| text p style height width |	[(TextStyle default fontArray at: JapaneseEnvironment leadingChar)		ifNil: [^ self]]		ifError: [:err :rcvr | ^ self].	text := ((#(20983874 20983876 20983878 )				collect: [:e | e asCharacter])				as: String) asText.	p := MultiNewParagraph new.	style := TextStyle new leading: 0; newFontArray: {Preferences standardFlapFont}.	p		compose: text		style: style		from: 1		in: (0 @ 0 corner: 100 @ 100).	"See CompositionScanner>>setActualFont: &  	CompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:"	height := style defaultFont height + style leading.	width := text				inject: 0				into: [:tally :next | tally						+ (style defaultFont widthOf: next)].	p adjustRightX.	self assert: p extent = (width @ height).	"Display getCanvas		paragraph: p		bounds: (10 @ 10 extent: 100 @ 100)		color: Color black"! !!FontTest methodsFor: 'testing' stamp: 'tak 12/21/2004 18:02'!testMultistringFont	"self debug: #testMultistringFont"	| text p style height width |	[(TextStyle default fontArray at: JapaneseEnvironment leadingChar)		ifNil: [^ self]]		ifError: [:err :rcvr | ^ self].	text := ((#(20983874 20983876 20983878 )				collect: [:e | e asCharacter])				as: String) asText.	p := MultiNewParagraph new.	style := TextStyle default.	p		compose: text		style: style		from: 1		in: (0 @ 0 corner: 100 @ 100).	"See CompositionScanner>>setActualFont: &  	CompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:"	height := style defaultFont height + style leading.	width := text				inject: 0				into: [:tally :next | tally						+ (style defaultFont widthOf: next)].	p adjustRightX.	self assert: p extent = (width @ height).	"Display getCanvas		paragraph: p		bounds: (10 @ 10 extent: 100 @ 100)		color: Color black"! !!FontTest methodsFor: 'testing' stamp: 'tak 12/21/2004 14:50'!testParagraph	"self debug: #testParagraph"	| text p style height width |	text := 'test' asText.	p := MultiNewParagraph new.	style := TextStyle default.	p		compose: text		style: style		from: 1		in: (0 @ 0 corner: 100 @ 100).	"See CompositionScanner>>setActualFont: &  	CompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:"	height := style defaultFont height + style leading.	width := text				inject: 0				into: [:tally :next | tally						+ (style defaultFont widthOf: next)].	p adjustRightX.	self assert: p extent = (width @ height)! !!FontTest methodsFor: 'testing' stamp: 'tak 12/21/2004 17:19'!testParagraphFallback	"self debug: #testParagraphFallback"	| text p style height width e expect |	e := (Character value: 257) asString.	text := ('test' , e , e , e , e , 'test') asText.	expect := 'test????test'.	p := MultiNewParagraph new.	style := TextStyle default.	p		compose: text		style: style		from: 1		in: (0 @ 0 corner: 100 @ 100).	"See CompositionScanner>>setActualFont: &  	CompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:"	height := style defaultFont height + style leading.	width := expect				inject: 0				into: [:tally :next | tally						+ (style defaultFont widthOf: next)].	p adjustRightX.	self assert: p extent = (width @ height).	"Display getCanvas		paragraph: p		bounds: (10 @ 10 extent: 100 @ 100)		color: Color black"! !!GrafPort methodsFor: 'private' stamp: 'yo 1/8/2005 09:12'!installStrikeFont: aStrikeFont	^ self installStrikeFont: aStrikeFont foregroundColor: (lastFontForegroundColor ifNil: [Color black]) backgroundColor: (lastFontBackgroundColor ifNil: [Color transparent]).! !!GrafPort methodsFor: 'private' stamp: 'yo 1/8/2005 09:11'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	super installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor.	alpha _ foregroundColor privateAlpha.	"dynamically switch between blend modes to support translucent text"	"To handle the transition from TTCFont to StrikeFont, rule 34 must be taken into account."	alpha = 255 ifTrue:[		combinationRule = 30 ifTrue: [combinationRule _ Form over].		combinationRule = 31 ifTrue: [combinationRule _ Form paint].		combinationRule = 34 ifTrue: [combinationRule _ Form paint].	] ifFalse:[		combinationRule = Form over ifTrue: [combinationRule _ 30].		combinationRule = Form paint ifTrue: [combinationRule _ 31].		combinationRule = 34 ifTrue: [combinationRule _ 31].	].	lastFont _ aStrikeFont.	lastFontForegroundColor _ foregroundColor.	lastFontBackgroundColor _ backgroundColor.! !!GrafPort methodsFor: 'private' stamp: 'yo 1/12/2005 16:39'!installTTCFont: aTTCFont	^ self installTTCFont: aTTCFont foregroundColor: (lastFontForegroundColor ifNil: [Color black]) backgroundColor: (lastFontBackgroundColor ifNil: [Color transparent]).! !!GrafPort methodsFor: 'private' stamp: 'yo 1/8/2005 09:12'!installTTCFont: aTTCFont foregroundColor: foregroundColor backgroundColor: backgroundColor	super installTTCFont: aTTCFont foregroundColor: foregroundColor backgroundColor: backgroundColor.	lastFont _ aTTCFont.	lastFontForegroundColor _ foregroundColor.	lastFontBackgroundColor _ backgroundColor.! !!GrafPort methodsFor: 'private' stamp: 'yo 1/8/2005 09:13'!lastFont	^ lastFont.! !!ISO88592ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 08:35'!fromSystemClipboard: aString	^ aString convertFromWithConverter: ISO88592TextConverter new.! !!ISO88592ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'pk 1/4/2005 03:56'!toSystemClipboard: aString	| result converter r |	aString isAsciiString ifTrue: [^ aString asOctetString]. "optimization"	result _ WriteStream on: (String new: aString size).	converter _ ISO88592TextConverter new.	aString do: [:each |		r _ converter fromSqueak: each.].	^ result contents.! !!ISO88592InputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 08:58'!initialize	converter _ ISO88592TextConverter new.! !!ISO88592InputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 08:58'!nextCharFrom: sensor firstEvt: evtBuf	| keyValue |	keyValue := evtBuf third.	^ converter toSqueak: keyValue asCharacter.! !!ISO88592TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 2/9/2005 05:29'!fromSqueak: char	^ Character value: (FromTable at: char charCode ifAbsent: [char asciiValue])! !!ISO88592TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 08:30'!nextFromStream: aStream	| character1 |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 _ aStream basicNext.	character1 isNil ifTrue: [^ nil].	^ self toSqueak: character1.! !!ISO88592TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 17:06'!nextPut: aCharacter toStream: aStream	aStream isBinary ifTrue: [		aCharacter class == Character ifTrue: [			aStream basicNextPut: aCharacter charCode.			^ aStream.		].		aCharacter class == MultiCharacter ifTrue: [			aStream nextInt32Put: aCharacter charCode.			^ aStream.		].	].	aCharacter charCode < 128 ifTrue: [		aStream basicNextPut: aCharacter.	] ifFalse: [		aStream basicNextPut: ((Character value: (self fromSqueak: aCharacter) charCode)).	].! !!ISO88592TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 09:20'!toSqueak: char	| value |	value _ char charCode.	value < 160 ifTrue: [^ char].	value > 255 ifTrue: [^ char].	^ MultiCharacter leadingChar: Latin2Environment leadingChar code: (#(16r00A0 16r0104 16r02D8 16r0141 16r00A4 16r013D 16r015A 16r00A716r00A8 16r0160 16r015E 16r0164 16r0179 16r00AD 16r017D 16r017B16r00B0 16r0105 16r02DB 16r0142 16r00B4 16r013E 16r015B 16r02C716r00B8 16r0161 16r015F 16r0165 16r017A 16r02DD 16r017E 16r017C16r0154 16r00C1 16r00C2 16r0102 16r00C4 16r0139 16r0106 16r00C716r010C 16r00C9 16r0118 16r00CB 16r011A 16r00CD 16r00CE 16r010E16r0110 16r0143 16r0147 16r00D3 16r00D4 16r0150 16r00D6 16r00D716r0158 16r016E 16r00DA 16r0170 16r00DC 16r00DD 16r0162 16r00DF16r0155 16r00E1 16r00E2 16r0103 16r00E4 16r013A 16r0107 16r00E716r010D 16r00E9 16r0119 16r00EB 16r011B 16r00ED 16r00EE 16r010F16r0111 16r0144 16r0148 16r00F3 16r00F4 16r0151 16r00F6 16r00F716r0159 16r016F 16r00FA 16r0171 16r00FC 16r00FD 16r0163 16r02D9) at: (value - 160 + 1)).! !!ISO88592TextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 09:17'!encodingNames 	^ #('iso-8859-2') copy! !!ISO88592TextConverter class methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 09:17'!initialize"	self initialize"	FromTable _ Dictionary new.	FromTable at: 16r00A0 put: 16rA0.		FromTable at: 16r0104 put: 16rA1.		FromTable at: 16r02D8 put: 16rA2.		FromTable at: 16r0141 put: 16rA3.		FromTable at: 16r00A4 put: 16rA4.		FromTable at: 16r013D put: 16rA5.		FromTable at: 16r015A put: 16rA6.		FromTable at: 16r00A7 put: 16rA7.		FromTable at: 16r00A8 put: 16rA8.		FromTable at: 16r0160 put: 16rA9.		FromTable at: 16r015E put: 16rAA.		FromTable at: 16r0164 put: 16rAB.		FromTable at: 16r0179 put: 16rAC.		FromTable at: 16r00AD put: 16rAD.		FromTable at: 16r017D put: 16rAE.		FromTable at: 16r017B put: 16rAF.		FromTable at: 16r00B0 put: 16rB0.		FromTable at: 16r0105 put: 16rB1.		FromTable at: 16r02DB put: 16rB2.		FromTable at: 16r0142 put: 16rB3.		FromTable at: 16r00B4 put: 16rB4.		FromTable at: 16r013E put: 16rB5.		FromTable at: 16r015B put: 16rB6.		FromTable at: 16r02C7 put: 16rB7.		FromTable at: 16r00B8 put: 16rB8.		FromTable at: 16r0161 put: 16rB9.		FromTable at: 16r015F put: 16rBA.		FromTable at: 16r0165 put: 16rBB.		FromTable at: 16r017A put: 16rBC.		FromTable at: 16r02DD put: 16rBD.		FromTable at: 16r017E put: 16rBE.		FromTable at: 16r017C put: 16rBF.		FromTable at: 16r0154 put: 16rC0.		FromTable at: 16r00C1 put: 16rC1.		FromTable at: 16r00C2 put: 16rC2.		FromTable at: 16r0102 put: 16rC3.		FromTable at: 16r00C4 put: 16rC4.		FromTable at: 16r0139 put: 16rC5.		FromTable at: 16r0106 put: 16rC6.		FromTable at: 16r00C7 put: 16rC7.		FromTable at: 16r010C put: 16rC8.		FromTable at: 16r00C9 put: 16rC9.		FromTable at: 16r0118 put: 16rCA.		FromTable at: 16r00CB put: 16rCB.		FromTable at: 16r011A put: 16rCC.		FromTable at: 16r00CD put: 16rCD.		FromTable at: 16r00CE put: 16rCE.		FromTable at: 16r010E put: 16rCF.		FromTable at: 16r0110 put: 16rD0.		FromTable at: 16r0143 put: 16rD1.		FromTable at: 16r0147 put: 16rD2.		FromTable at: 16r00D3 put: 16rD3.		FromTable at: 16r00D4 put: 16rD4.		FromTable at: 16r0150 put: 16rD5.		FromTable at: 16r00D6 put: 16rD6.		FromTable at: 16r00D7 put: 16rD7.		FromTable at: 16r0158 put: 16rD8.		FromTable at: 16r016E put: 16rD9.		FromTable at: 16r00DA put: 16rDA.		FromTable at: 16r0170 put: 16rDB.		FromTable at: 16r00DC put: 16rDC.		FromTable at: 16r00DD put: 16rDD.		FromTable at: 16r0162 put: 16rDE.		FromTable at: 16r00DF put: 16rDF.		FromTable at: 16r0155 put: 16rE0.		FromTable at: 16r00E1 put: 16rE1.		FromTable at: 16r00E2 put: 16rE2.		FromTable at: 16r0103 put: 16rE3.		FromTable at: 16r00E4 put: 16rE4.		FromTable at: 16r013A put: 16rE5.		FromTable at: 16r0107 put: 16rE6.		FromTable at: 16r00E7 put: 16rE7.		FromTable at: 16r010D put: 16rE8.		FromTable at: 16r00E9 put: 16rE9.		FromTable at: 16r0119 put: 16rEA.		FromTable at: 16r00EB put: 16rEB.		FromTable at: 16r011B put: 16rEC.		FromTable at: 16r00ED put: 16rED.		FromTable at: 16r00EE put: 16rEE.		FromTable at: 16r010F put: 16rEF.		FromTable at: 16r0111 put: 16rF0.		FromTable at: 16r0144 put: 16rF1.		FromTable at: 16r0148 put: 16rF2.		FromTable at: 16r00F3 put: 16rF3.		FromTable at: 16r00F4 put: 16rF4.		FromTable at: 16r0151 put: 16rF5.		FromTable at: 16r00F6 put: 16rF6.		FromTable at: 16r00F7 put: 16rF7.		FromTable at: 16r0159 put: 16rF8.		FromTable at: 16r016F put: 16rF9.		FromTable at: 16r00FA put: 16rFA.		FromTable at: 16r0171 put: 16rFB.		FromTable at: 16r00FC put: 16rFC.		FromTable at: 16r00FD put: 16rFD.		FromTable at: 16r0163 put: 16rFE.		FromTable at: 16r02D9 put: 16rFF.	! !!ISO88597TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 2/9/2005 05:29'!fromSqueak: char	^ Character value: (FromTable at: char charCode ifAbsent: [char asciiValue])! !!ISO88597TextConverter methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 17:10'!nextPut: aCharacter toStream: aStream	aStream isBinary ifTrue: [		aCharacter class == Character ifTrue: [			aStream basicNextPut: aCharacter charCode.			^ aStream.		].		aCharacter class == MultiCharacter ifTrue: [			aStream nextInt32Put: aCharacter charCode.			^ aStream.		].	].	aCharacter charCode < 128 ifTrue: [		aStream basicNextPut: aCharacter.	] ifFalse: [		aStream basicNextPut: ((Character value: (self fromSqueak: aCharacter) charCode)).	].! !!LanguageEnvironment class methodsFor: 'language methods' stamp: 'yo 1/18/2005 15:56'!scanSelector	^ #scanMultiCharactersFrom:to:in:rightX:stopConditions:kern:! !!LanguageEnvironment class methodsFor: 'accessing' stamp: 'yo 12/2/2004 16:13'!isCharset	^ false.! !!JapaneseEnvironment class methodsFor: 'language methods' stamp: 'yo 8/3/2004 21:25'!flapTabTextFor: aString in: aFlapTab	| string |	string _ super flapTabTextFor: aString.	string isEmptyOrNil ifTrue: [^ self].	string _ aFlapTab orientation == #vertical				ifTrue: [string copyReplaceAll: 'ー' with: '｜']				ifFalse: [string copyReplaceAll: '｜' with: 'ー'].	^ string.!]lang[(211 1 9 1 41 1 9 1 16)0,5,0,5,0,5,0,5,0! !!JapaneseEnvironment class methodsFor: 'as yet unclassified' stamp: 'T2 2/3/2005 13:07'!systemConverterClass	| platformName osVersion encoding |	platformName := SmalltalkImage current platformName.	osVersion := SmalltalkImage current getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) 		ifTrue: [^UTF8TextConverter].	(#('Win32' 'ZaurusOS') includes: platformName) 		ifTrue: [^ShiftJISTextConverter].	platformName = 'Mac OS' 		ifTrue: 			[^('10*' match: SmalltalkImage current osVersion) 				ifTrue: [UTF8TextConverter]				ifFalse: [ShiftJISTextConverter]].	platformName = 'unix' 		ifTrue: 			[encoding := X11Encoding encoding.			encoding ifNil: [^EUCJPTextConverter].			(encoding = 'utf-8') 				ifTrue: [^UTF8TextConverter].							(encoding = 'shiftjis' | encoding = 'sjis') 				ifTrue: [^ShiftJISTextConverter].							^EUCJPTextConverter].	^MacRomanTextConverter! !!JapaneseEnvironment class methodsFor: 'accessing - encoding' stamp: 'yo 8/3/2004 16:58'!isBreakableAt: index in: text	| prev |	index = 1 ifTrue: [^ false].	prev _ text at: index - 1.	prev leadingChar ~= 1 ifTrue: [^ true].	^ (('、。，．・：；？！゛゜´｀¨＾―‐／\〜‖｜…‥’”）〕］｝〉》」』】°′″℃' includes: (text at: index)) or: ['‘“（〔［｛〈《「『【°′″℃＠§' includes: prev]) not.!]lang[(146 11 1 1 1 4 1 16 1 3 36 11 1 4 25)0,5,0,5,0,5,0,5,0,5,0,5,0,5,0! !!Latin1Environment class methodsFor: 'language methods' stamp: 'yo 1/24/2005 10:00'!nextPutRightHalfValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state	^ self traditionalCharsetClass nextPutRightHalfValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state.! !!Latin1Environment class methodsFor: 'language methods' stamp: 'yo 1/24/2005 10:00'!nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state	^ self traditionalCharsetClass nextPutValue: ascii toStream: aStream withShiftSequenceIfNeededForTextConverterState: state.! !!Latin1Environment class methodsFor: 'language methods' stamp: 'yo 1/24/2005 09:59'!traditionalCharsetClass	^ Latin1.! !!Latin2Environment class methodsFor: 'language methods' stamp: 'yo 1/18/2005 08:32'!beCurrentNaturalLanguage! !!Latin2Environment class methodsFor: 'subclass responsibilities' stamp: 'pk 1/19/2005 16:00'!clipboardInterpreterClass	(#('Win32') includes: SmalltalkImage current platformName) 		ifTrue: [^CP1250ClipboardInterpreter  ].	^ ISO88592ClipboardInterpreter .! !!Latin2Environment class methodsFor: 'subclass responsibilities' stamp: 'pk 1/19/2005 15:05'!defaultEncodingName	| platformName osVersion |	platformName := SmalltalkImage current platformName.	osVersion := SmalltalkImage current  getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) ifTrue: [^'utf-8' copy].	(#('Win32') includes: platformName) 		ifTrue: [^'cp-1250' copy].	(#('unix') includes: platformName) ifTrue: [^'iso8859-2' copy].	^'mac-roman'! !!Latin2Environment class methodsFor: 'subclass responsibilities' stamp: 'pk 1/19/2005 15:05'!fileNameConverterClass	(#('Win32') includes: SmalltalkImage current platformName) 		ifTrue: [^CP1250TextConverter ].	^ ISO88592TextConverter.! !!Latin2Environment class methodsFor: 'subclass responsibilities' stamp: 'pk 1/19/2005 20:43'!inputInterpreterClass	(#('Win32') includes: SmalltalkImage current platformName) 		ifTrue: [^CP1250InputInterpreter ].	^ ISO88592InputInterpreter.! !!Latin2Environment class methodsFor: 'subclass responsibilities' stamp: 'yo 1/18/2005 15:53'!leadingChar	^ 14.! !!Latin2Environment class methodsFor: 'subclass responsibilities' stamp: 'yo 1/19/2005 09:16'!supportedLanguages	"Return the languages that this class supports. 	Any translations for those languages will use this class as their environment."		^#('cs' 'hu' 'ro' 'hr' 'sk' 'sl')  "Sorbian languages don't have two char code?"! !!Latin2Environment class methodsFor: 'subclass responsibilities' stamp: 'pk 1/19/2005 15:04'!systemConverterClass	(#('Win32') includes: SmalltalkImage current platformName) 		ifTrue: [^CP1250TextConverter ].	^ ISO88592TextConverter.! !!Latin2Environment class methodsFor: 'rendering support' stamp: 'yo 1/18/2005 08:32'!flapTabTextFor: aString	^ aString.! !!Latin2Environment class methodsFor: 'rendering support' stamp: 'yo 1/18/2005 08:32'!flapTabTextFor: aString in: aFlapTab	^ aString.! !!Latin2Environment class methodsFor: 'rendering support' stamp: 'yo 1/18/2005 08:32'!isBreakableAt: index in: text	| char |	char _ text at: index.	char = Character space ifTrue: [^ true].	char = Character cr ifTrue: [^ true].	^ false.! !!Lexicon methodsFor: 'vocabulary' stamp: 'yo 1/14/2005 19:57'!chooseVocabulary	"Put up a dialog affording the user a chance to choose a different vocabulary to be installed in the receiver"	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'Choose a vocabularyblue = currentred = imperfect' translated.	aMenu addStayUpItem.	Vocabulary allStandardVocabularies do:		[:aVocabulary |			(targetClass implementsVocabulary: aVocabulary)				ifTrue:					[aMenu add: aVocabulary vocabularyName selector: #switchToVocabulary: argument: aVocabulary.					(targetClass fullyImplementsVocabulary: aVocabulary) ifFalse:						[aMenu lastItem color: Color red].					aVocabulary == currentVocabulary ifTrue:						[aMenu lastItem color: Color blue]. 					aMenu balloonTextForLastItem: aVocabulary documentation]].	aMenu popUpInWorld: self currentWorld! !!Locale class methodsFor: 'private' stamp: 'ka 2/18/2005 02:40'!migrateSystem	"Locale migrateSystem"	"Do all the necessary operations to switch to the new Locale environment."	LocaleChangeListeners _ nil.	self		addLocalChangedListener: HandMorph;		addLocalChangedListener: Clipboard;		addLocalChangedListener: Vocabulary;		addLocalChangedListener: PartsBin;		addLocalChangedListener: Project;		addLocalChangedListener: PaintBoxMorph;		yourself! !!Locale class methodsFor: 'notification' stamp: 'ka 2/19/2005 02:15'!localeChanged	#(PartsBin ParagraphEditor BitEditor FormEditor StandardSystemController ColorPickerMorph) 		do: [ :key | Smalltalk at: key ifPresent: [ :class | class initialize ]].	Project current localeChanged.	self localeChangedListeners do: [:each | each localeChanged]! !!LocaleID methodsFor: 'printing' stamp: 'tak 11/15/2004 12:45'!storeOn: aStream 	aStream nextPut: $(.	aStream nextPutAll: self class name.	aStream nextPutAll: ' isoString: '.	aStream nextPutAll: '''' , self printString , ''''.	aStream nextPut: $).! !!MacRomanInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 08:57'!nextCharFrom: sensor firstEvt: evtBuf	| keyValue |	keyValue := evtBuf third.	^ keyValue asCharacter squeakToIso.! !!Morph methodsFor: 'caching' stamp: 'tak 1/12/2005 14:57'!releaseCachedState	"Release any state that can be recomputed on demand, such as the pixel values for a color gradient or the editor state for a TextMorph. This method may be called to save space when a morph becomes inaccessible. Implementations of this method should do 'super releaseCachedState'."	self formerOwner: nil.	self formerPosition: nil.	self removeProperty: #undoGrabCommand.	self wonderlandTexture: nil. "We can recreate it if needed"	self borderStyle releaseCachedState.! !!Morph methodsFor: 'card in a stack' stamp: 'yo 2/17/2005 17:47'!insertAsStackBackground	"I am not yet in a stack.  Find a Stack that my reference point (center) overlaps, and insert me as a new background."	| aMorph |	self isStackBackground ifTrue: [^ Beeper beep].			"already in a stack.  Must clear flags when remove.""	self potentialEmbeddingTargets do: [:mm |   No, force user to choose a stack.  		(mm respondsTo: #insertAsBackground:resize:) ifTrue: [			^ mm insertAsBackground: self resize: false]]."	"None found, ask user"	self inform: 'Please click on a Stack' translated.	Sensor waitNoButton.	aMorph _ self world chooseClickTarget.	aMorph ifNil: [^ self].	(aMorph ownerThatIsA: StackMorph) insertAsBackground: self resize: false.! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 17:50'!exportAsBMP	| fName |	fName _ FillInTheBlank request:'Please enter the name' translated initialAnswer: self externalName,'.bmp'.	fName isEmpty ifTrue:[^self].	self imageForm writeBMPfileNamed: fName.! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 17:50'!exportAsGIF	| fName |	fName _ FillInTheBlank request:'Please enter the name' translated initialAnswer: self externalName,'.gif'.	fName isEmpty ifTrue:[^self].	GIFReadWriter putForm: self imageForm onFileNamed: fName.! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 17:51'!exportAsJPEG	"Export the receiver's image as a JPEG"	| fName |	fName _ FillInTheBlank request: 'Please enter the name' translated initialAnswer: self externalName,'.jpeg'.	fName isEmpty ifTrue: [^ self].	self imageForm writeJPEGfileNamed: fName! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 17:51'!exportAsPNG	| fName |	fName _ FillInTheBlank request:'Please enter the name' translated initialAnswer: self externalName,'.png'.	fName isEmpty ifTrue:[^self].	PNGReadWriter putForm: self imageForm onFileNamed: fName.! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 18:03'!printPSToFileNamed: aString 	"Ask the user for a filename and print this morph as postscript."	| fileName rotateFlag psCanvasType psExtension |	fileName := aString asFileName.	psCanvasType _ PostscriptCanvas defaultCanvasType.	psExtension _ psCanvasType defaultExtension.	fileName := FillInTheBlank request: (String streamContents: [ :s |		s nextPutAll: ('File name? ("{1}" will be added to end)' translated format: {psExtension})])			initialAnswer: fileName.	fileName isEmpty		ifTrue: [^ Beeper beep].	(fileName endsWith: psExtension)		ifFalse: [fileName := fileName , psExtension].	rotateFlag := ((PopUpMenu labels: 'portrait (tall)landscape (wide)' translated)				startUpWithCaption: 'Choose orientation...' translated)				= 2.	((FileStream newFileNamed: fileName asFileName) converter: TextConverter defaultSystemConverter)		nextPutAll: (psCanvasType morphAsPostscript: self rotated: rotateFlag);		 close! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 16:58'!setArrowheads	"Let the user edit the size of arrowheads for this object"	| aParameter result  |	aParameter _ self renderedMorph valueOfProperty:  #arrowSpec ifAbsent:		[Preferences parameterAt: #arrowSpec ifAbsent: [5 @ 4]].	result _ Morph obtainArrowheadFor: 'Head size for arrowheads: ' translated defaultValue: aParameter asString.	result ifNotNil:			[self renderedMorph  setProperty: #arrowSpec toValue: result]		ifNil:			[Beeper beep]! !!Morph methodsFor: 'meta-actions' stamp: 'yo 2/12/2005 15:25'!indicateAllSiblings	"Indicate all the receiver and all its siblings by flashing momentarily."	| aPlayer allBoxes |	(aPlayer _ self topRendererOrSelf player) belongsToUniClass ifFalse: [^ self "error: 'not uniclass'"].	allBoxes _ aPlayer class allInstances		select: [:m | m costume world == ActiveWorld]		thenCollect: [:m | m costume boundsInWorld].	5 timesRepeat:		[Display flashAll: allBoxes andWait: 120]! !!Morph methodsFor: 'pen' stamp: 'tak 1/17/2005 10:22'!addImageToPenTrails: aForm 	owner		ifNil: [^ self].	owner addImageToPenTrails: aForm! !!Morph methodsFor: 'pen' stamp: 'tak 1/17/2005 10:21'!stamp	self addImageToPenTrails: self imageForm! !!BooklikeMorph methodsFor: 'page controls' stamp: 'yo 1/14/2005 19:25'!fullControlSpecs	^ {		#spacer.		#variableSpacer.		{'-'.		#deletePage.				'Delete this page' translated}.		#spacer.		{'«'.		#firstPage.				'First page' translated}.		#spacer.		{'<'. 		#previousPage.			'Previous page' translated}.		#spacer.		{'·'.		#invokeBookMenu. 		'Click here to get a menu of options for this book.' translated}.		#spacer.		{'>'.		#nextPage.				'Next page' translated}.		#spacer.		{ '»'.		#lastPage.				'Final page' translated}.		#spacer.		{'+'.		#insertPage.				'Add a new page after this one' translated}.		#variableSpacer.		{'³'.		#fewerPageControls.	'Fewer controls' translated}}! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'yo 1/14/2005 19:52'!valueForMouseDownHaloWidth	^ 'mouse-down halo width: ' translated, self targetProperties mouseDownHaloWidth printString! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'yo 1/14/2005 19:53'!valueForMouseOverHaloWidth	^ 'mouse-over halo width: ' translated, self targetProperties mouseOverHaloWidth printString! !!EventRecorderMorph methodsFor: 'commands' stamp: 'yo 2/11/2005 09:59'!button	"Make a simple button interface for replay only"	| butnCaption erm |	butnCaption _ FillInTheBlank request: 'Caption for this butn?' translated initialAnswer: 'play' translated.	butnCaption isEmpty ifTrue: [^ self].	erm _ (EventRecorderMorph basicNew				caption: butnCaption				voiceRecorder: voiceRecorder copy				tape: tape) initialize.	self world primaryHand attachMorph: erm! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'yo 2/11/2005 09:56'!buttonFor: data 	| b |	b _ SimpleButtonMorph new 		target: self;		label: data first asString translated;		actionSelector: data first.	data second ifNotNil: [b width < data second ifTrue: [b width: data second]].	data third ifNotNil: [b setBalloonText: data third translated].	^b! !!FlapTab methodsFor: 'edge' stamp: 'yo 2/10/2005 18:06'!edgeString	^ 'cling to edge... (current: {1})' translated format: {edgeToAdhereTo translated}! !!GraphMorph methodsFor: '*sound' stamp: 'yo 2/16/2005 10:43'!readDataFromFile	| fileName |	fileName _ FillInTheBlank		request: 'File name?' translated		initialAnswer: ''.	fileName isEmpty ifTrue: [^ self].	(StandardFileStream isAFileNamed: fileName) ifFalse: [		^ self inform: 'Sorry, I cannot find that file' translated].	self data: (SampledSound fromAIFFfileNamed: fileName) samples.! !!HaloMorph methodsFor: 'private' stamp: 'yo 2/12/2005 19:24'!addDirectionHandles	| centerHandle d w directionShaft patch patchColor crossHairColor |	self showingDirectionHandles ifFalse: [^ self].	directionArrowAnchor _ (target point: target referencePosition in: self world) rounded.	patch _ target imageFormForRectangle: (Rectangle center: directionArrowAnchor extent: 3@3).	patchColor _ patch colorAt: 1@1.	(directionShaft _ LineMorph newSticky makeForwardArrow)		borderWidth: 2; borderColor: (Color green orColorUnlike: patchColor).	self positionDirectionShaft: directionShaft.	self addMorphFront: directionShaft.	directionShaft setCenteredBalloonText: 'Set forward direction' translated;		on: #mouseDown send: #doDirection:with: to: self;		on: #mouseMove send: #trackDirectionArrow:with: to: self;		on: #mouseUp send: #setDirection:with: to: self.	d _ 15.  "diameter"  w _ 3.  "borderWidth"	crossHairColor _ Color red orColorUnlike: patchColor.	(centerHandle _ EllipseMorph newBounds: (0@0 extent: d@d) color: Color transparent)			borderWidth: w; borderColor: (Color blue orColorUnlike: patchColor);			addMorph: (LineMorph from: (d//2)@w to: (d//2)@(d-w-1) color: crossHairColor width: 1) lock;			addMorph: (LineMorph from: w@(d//2) to: (d-w-1)@(d//2) color: crossHairColor width: 1) lock;			align: centerHandle bounds center with: directionArrowAnchor.	self addMorph: centerHandle.	centerHandle setCenteredBalloonText: 'Set rotation center' translated;			on: #mouseDown send: #prepareToTrackCenterOfRotation:with: to: self;			on: #mouseMove send: #trackCenterOfRotation:with: to: self;			on: #mouseUp send: #setCenterOfRotation:with: to: self! !!KeyboardMorphForInput methodsFor: 'initialization' stamp: 'yo 2/11/2005 10:39'!addRecordingControls	| button switch playRow durRow articRow modRow |	"Add chord, rest and delete buttons"	playRow _ AlignmentMorph newRow.	playRow color: color; borderWidth: 0; layoutInset: 0.	playRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	playRow addMorphBack: (switch label: 'chord' translated; actionSelector: #buildChord:).	button _ SimpleButtonMorph new target: self;		borderColor: #raised; borderWidth: 2; color: color.	playRow addMorphBack: (button label: '          rest          ' translated; actionSelector: #emitRest).	button _ SimpleButtonMorph new target: self;		borderColor: #raised; borderWidth: 2; color: color.	playRow addMorphBack: (button label: 'del' translated; actionSelector: #deleteNotes).	self addMorph: playRow.	playRow align: playRow fullBounds topCenter			with: self fullBounds bottomCenter.	"Add note duration buttons"	durRow _ AlignmentMorph newRow.	durRow color: color; borderWidth: 0; layoutInset: 0.	durRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	durRow addMorphBack: (switch label: 'whole' translated;				actionSelector: #duration:onOff:; arguments: #(1)).	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	durRow addMorphBack: (switch label: 'half' translated;				actionSelector: #duration:onOff:; arguments: #(2)).	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	durRow addMorphBack: (switch label: 'quarter' translated;				actionSelector: #duration:onOff:; arguments: #(4)).	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	durRow addMorphBack: (switch label: 'eighth' translated;				actionSelector: #duration:onOff:; arguments: #(8)).	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	durRow addMorphBack: (switch label: 'sixteenth' translated;				actionSelector: #duration:onOff:; arguments: #(16)).	self addMorph: durRow.	durRow align: durRow fullBounds topCenter			with: playRow fullBounds bottomCenter.	"Add note duration modifier buttons"	modRow _ AlignmentMorph newRow.	modRow color: color; borderWidth: 0; layoutInset: 0.	modRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	modRow addMorphBack: (switch label: 'dotted' translated;				actionSelector: #durMod:onOff:; arguments: #(dotted)).	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	modRow addMorphBack: (switch label: 'normal' translated;				actionSelector: #durMod:onOff:; arguments: #(normal)).	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	modRow addMorphBack: (switch label: 'triplets' translated;				actionSelector: #durMod:onOff:; arguments: #(triplets)).	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	modRow addMorphBack: (switch label: 'quints' translated;				actionSelector: #durMod:onOff:; arguments: #(quints)).	self addMorph: modRow.	modRow align: modRow fullBounds topCenter			with: durRow fullBounds bottomCenter.	"Add articulation buttons"	articRow _ AlignmentMorph newRow.	articRow color: color; borderWidth: 0; layoutInset: 0.	articRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	articRow addMorphBack: (switch label: 'legato' translated;				actionSelector: #articulation:onOff:; arguments: #(legato)).	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	articRow addMorphBack: (switch label: 'normal' translated;				actionSelector: #articulation:onOff:; arguments: #(normal)).	switch _ SimpleSwitchMorph new target: self; borderWidth: 2;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); setSwitchState: false.	articRow addMorphBack: (switch label: 'staccato' translated;				actionSelector: #articulation:onOff:; arguments: #(staccato)).	self addMorph: articRow.	articRow align: articRow fullBounds topCenter			with: modRow fullBounds bottomCenter.	self bounds: (self fullBounds expandBy: (0@0 extent: 0@borderWidth))! !!MPEGDisplayMorph methodsFor: 'menu' stamp: 'yo 2/20/2005 20:10'!createJPEGfromFolderOfFrames	"Create a new JPEG movie file from an folder of individual frames. Prompt the user for the folder and file names and the quality setting, then do the conversion."	| result folderName jpegFileName q frameRate |	result := StandardFileMenu oldFile.	result ifNil: [^self].	folderName := result directory pathName.	jpegFileName := FillInTheBlank request: 'New movie name?' translated.	jpegFileName isEmpty ifTrue: [^self].	(jpegFileName asLowercase endsWith: '.jmv') 		ifFalse: [jpegFileName := jpegFileName , '.jmv'].	result := FillInTheBlank request: 'Quality level (1 to 100)?' translated.	q := result ifNil: [50]				ifNotNil: [(result asNumber rounded max: 1) min: 100].	result := FillInTheBlank request: 'Frame rate?' translated.	frameRate := result ifNil: [10]				ifNotNil: [(result asNumber rounded max: 1) min: 100].	JPEGMovieFile 		convertFromFolderOfFramesNamed: folderName		toJPEGMovieNamed: jpegFileName		frameRate: frameRate		quality: q! !!MPEGDisplayMorph methodsFor: 'menu' stamp: 'yo 2/20/2005 20:04'!createJPEGfromMPEG	"Create a new JPEG movie file from an MPEG movie. Prompt the user for the file names and the quality setting, then do the conversion."	| result mpegFileName jpegFileName q |	result := StandardFileMenu oldFile.	result ifNil: [^self].	mpegFileName := result directory pathName , FileDirectory slash 				, result name.	jpegFileName := FillInTheBlank request: 'New movie name?' translated.	jpegFileName isEmpty ifTrue: [^self].	(jpegFileName asLowercase endsWith: '.jmv') 		ifFalse: [jpegFileName := jpegFileName , '.jmv'].	result := FillInTheBlank request: 'Quality level (1 to 100)?' translated.	q := result ifNil: [50]				ifNotNil: [(result asNumber rounded max: 1) min: 100].	JPEGMovieFile 		convertMPEGFileNamed: mpegFileName		toJPEGMovieNamed: jpegFileName		quality: q! !!MPEGDisplayMorph methodsFor: 'menu' stamp: 'yo 2/20/2005 20:05'!createJPEGfromSqueakMovie	"Create a new JPEG movie file from an SqueakTime movie. Prompt the user for the file names and the quality setting, then do the conversion."	| result squeakMovieFileName jpegFileName q |	result := StandardFileMenu oldFile.	result ifNil: [^self].	squeakMovieFileName := result directory pathName , FileDirectory slash 				, result name.	jpegFileName := FillInTheBlank request: 'New movie name?' translated.	jpegFileName isEmpty ifTrue: [^self].	(jpegFileName asLowercase endsWith: '.jmv') 		ifFalse: [jpegFileName := jpegFileName , '.jmv'].	result := FillInTheBlank request: 'Quality level (1 to 100)?' translated.	q := result ifNil: [50]				ifNotNil: [(result asNumber rounded max: 1) min: 100].	JPEGMovieFile 		convertSqueakMovieNamed: squeakMovieFileName		toJPEGMovieNamed: jpegFileName		quality: q! !!MPEGMoviePlayerMorph class methodsFor: 'scripting' stamp: 'yo 1/14/2005 19:17'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #(	(basic		(			(command play 'Start playing the movie/sound')			(command stop 'Stop playing the movie/sound')			(command rewind 'Rewind the movie/sound')))	(#'movie controls'		(			(slot videoFileName	'The name for the video file' 											String	readWrite Player getVideoFileName Player setVideoFileName:)			(slot subtitlesFileName	'The name for the subtitles file' 										String	readWrite Player getSubtitlesFileName Player setSubtitlesFileName:)			(slot position 			'A number representing the current position of the movie/sound.'	Number readWrite Player getPosition Player setPosition:)			(slot volume 			'A number representing the volume of the movie.' 					Number readWrite Player getVolume Player setVolume:)			(command play 'Start playing the movie/sound')			(command playUntilPosition: 'Play until the given position, then stop' Number)						(command stop 'Stop playing the movie/sound')			(command rewind 'Rewind the movie/sound')			(slot isRunning 'Whether the movie/sound is being played' Boolean readOnly	Player getIsRunning unused unused)			(slot repeat 'Whether the movie/sound will play in an endless loop' Boolean readWrite	Player getRepeat Player setRepeat:)			(slot totalFrames 'Length of this movie in number of frames' Number readOnly	Player getTotalFrames unused unused)			(slot totalSeconds 'Length of this movie in seconds' Number readOnly	Player getTotalSeconds unused unused)			(slot frameGraphic 'A graphic for the current frame' Graphic readOnly Player getFrameGraphic unused unused)		)	))! !!MenuMorph methodsFor: 'control' stamp: 'tak 1/6/2005 13:28'!popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 	"Present this menu at the given point under control of the given  	hand."	| evt |	aWorld submorphs		select: [ :each | (each isKindOf: MenuMorph)			and: [each stayUp not]]		thenCollect: [ :menu | menu delete].	self items isEmpty		ifTrue: [^ self].	MenuIcons decorateMenu: self.	(self submorphs		select: [:m | m isKindOf: UpdatingMenuItemMorph])		do: [:m | m updateContents].	"precompute width"	self		positionAt: aPoint		relativeTo: (selectedItem				ifNil: [self items first])		inWorld: aWorld.	aWorld addMorphFront: self.	"Acquire focus for valid pop up behavior"	hand newMouseFocus: self.	aBoolean		ifTrue: [hand newKeyboardFocus: self].	evt := hand lastEvent.	(evt isKeyboard			or: [evt isMouse					and: [evt anyButtonPressed not]])		ifTrue: ["Select first item if button not down"			self moveSelectionDown: 1 event: evt].	self updateColor.	self changed! !!MorphTest methodsFor: 'initialize-release' stamp: 'tak 1/21/2005 11:12'!getWorld	^ world		ifNil: [world := Project newMorphic world]! !!MorphTest methodsFor: 'initialize-release' stamp: 'tak 1/21/2005 11:12'!setUp	morph := Morph new! !!MorphTest methodsFor: 'initialize-release' stamp: 'tak 1/21/2005 11:12'!tearDown	morph delete.	world		ifNotNil: [Project deletingProject: world project]! !!MorphTest methodsFor: 'testing - etoys' stamp: 'tak 1/21/2005 11:31'!testOverlapAny	"self debug: #testOverlapAny"	| p1 p2 |	p1 _ Morph new assuredPlayer.	p2 _ EllipseMorph new assuredPlayer.	"Same position"	p1 costume position: 0@0.	p2 costume position: 0@0.	self assert: (p1 overlapsAny: p2).	"Different position"	p1 costume position: 0@0.	p2 costume position: 500@0.	self assert: (p1 overlapsAny: p2) not.! !!MorphTest methodsFor: 'testing - etoys' stamp: 'tak 1/21/2005 11:56'!testOverlapAnyDeletedPlayer	"self debug: #testOverlapAnyDeletedPlayer"	| me friend sibling |	me := Morph new assuredPlayer assureUniClass; yourself.	friend := EllipseMorph new assuredPlayer assureUniClass; yourself.	sibling := friend getNewClone.	sibling costume delete.	self getWorld addMorph: me costume.	"Same position but deleted"	me costume position: 0 @ 0.	friend costume position: 0 @ 0.	sibling costume position: 0 @ 0.	self assert: (me overlapsAny: friend) not.	self assert: (me overlapsAny: sibling) not! !!MorphTest methodsFor: 'testing - etoys' stamp: 'tak 1/21/2005 11:40'!testOverlapAnyScriptedPlayer	"self debug: #testOverlapAnyScriptedPlayer"	| me friend other sibling |	me := Morph new assuredPlayer assureUniClass; yourself.	friend := EllipseMorph new assuredPlayer assureUniClass; yourself.	sibling := friend getNewClone.	other := EllipseMorph new assuredPlayer assureUniClass; yourself.	self getWorld addMorph: me costume;		 addMorph: friend costume;		 addMorph: other costume;		 addMorph: sibling costume.	"myself"	self assert: (me overlapsAny: me) not.	"Same position with sibling"	me costume position: 0 @ 0.	friend costume position: 500 @ 0.	other costume position: 500 @ 0.	sibling costume position: 0@0.	self assert: (me overlapsAny: friend).	"Different position with sibling but same class"	me costume position: 0 @ 0.	friend costume position: 500 @ 0.	sibling costume position: 500@ 0.	other costume position: 0 @ 0.	self assert: (me overlapsAny: friend) not! !!MorphTest methodsFor: 'testing - etoys' stamp: 'tak 1/21/2005 11:32'!testOverlapAnyUnscriptedPlayer	"self debug: #testOverlapAnyUnscriptedPlayer"	| p1 p2 p3 |	p1 := Morph new assuredPlayer.	p2 := EllipseMorph new assuredPlayer.	p3 := EllipseMorph new assuredPlayer.	self getWorld addMorph: p1 costume;		 addMorph: p2 costume;		 addMorph: p3 costume.	"Same class, same position"	p1 costume position: 0 @ 0.	p2 costume position: 500 @ 0.	p3 costume position: 0 @ 0.	self		assert: (p1 overlapsAny: p2).	"Same class, different position"	p1 costume position: 0 @ 0.	p2 costume position: 1000 @ 0.	p3 costume position: 500 @ 0.	self assert: (p1 overlapsAny: p2) not.! !!MultiByteBinaryOrTextStream methodsFor: 'fileIn/Out' stamp: 'tak 1/12/2005 13:47'!fileOutClass: extraClass andObject: theObject 	UTF8TextConverter writeBOMOn: self.	^ super fileOutClass: extraClass andObject: theObject! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'tak 1/12/2005 14:48'!fileOutClass: extraClass andObject: theObject 	self binary.	UTF8TextConverter writeBOMOn: self.	self text.	^ super fileOutClass: extraClass andObject: theObject! !!MultiCharacter methodsFor: 'converting' stamp: 'yo 12/2/2004 16:13'!asUnicode	| table charset v |	self leadingChar = 0 ifTrue: [^ value].	charset _ EncodedCharSet charsetAt: self leadingChar.	charset isCharset ifFalse: [^ self charCode].	table _ charset ucsTable.	table isNil ifTrue: [^ 16rFFFD].	v _ table at: self charCode + 1.	v = -1 ifTrue: [^ 16rFFFD].	^ v.! !!MultiCharacter methodsFor: 'converting' stamp: 'yo 12/2/2004 16:16'!asUnicodeChar	| table charset v |	self leadingChar = 0 ifTrue: [^ value].	charset _ EncodedCharSet charsetAt: self leadingChar.	charset isCharset ifFalse: [^ self].	table _ charset ucsTable.	table isNil ifTrue: [^ Character value: 16rFFFD].	v _ table at: self charCode + 1.	v = -1 ifTrue: [^ Character value: 16rFFFD].	^ MultiCharacter leadingChar: charset unicodeLeadingChar code: v.! !!MultiCharacterScanner methodsFor: 'private' stamp: 'tak 12/19/2004 15:45'!setFont	| priorFont |	"Set the font and other emphasis."	priorFont _ font.	text == nil ifFalse:[		emphasisCode _ 0.		kern _ 0.		indentationLevel _ 0.		alignment _ textStyle alignment.		font _ nil.		(text attributesAt: lastIndex forStyle: textStyle)			do: [:att | att emphasizeScanner: self]].	font == nil ifTrue:		[self setFont: textStyle defaultFontIndex].	font _ font emphasized: emphasisCode.	priorFont ifNotNil: [destX _ destX + priorFont descentKern].	destX _ destX - font descentKern.	"NOTE: next statement should be removed when clipping works"	leftMargin ifNotNil: [destX _ destX max: leftMargin].	kern _ kern - font baseKern.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space.	xTable _ font xTable."	map _ font characterToGlyphMap."	stopConditions _ DefaultStopConditions.! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'yo 1/18/2005 08:08'!measureString: aString inFont: aFont from: startIndex to: stopIndex	"WARNING: In order to use this method the receiver has to be set up using #initializeStringMeasurer"	destX _ destY _ lastIndex _ 0.	baselineY _ aFont ascent.	xTable _ aFont xTable.	font := aFont.  " added Dec 03, 2004 ""	map _ aFont characterToGlyphMap."	self scanCharactersFrom: startIndex to: stopIndex in: aString rightX: 999999 stopConditions: stopConditions kern: 0.	^destX! !!MultiCanvasCharacterScanner methodsFor: 'private' stamp: 'yo 1/6/2005 23:00'!setFont	foregroundColor ifNil: [foregroundColor _ Color black].	super setFont.	baselineY _ lineY + line baseline.	destY _ baselineY - font ascent.! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'yo 1/6/2005 22:55'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				baselineY _ line lineHeight.				lastCharacter _ nil.				characterPoint _ (nextLeftMargin ifNil: [leftMargin]) @ destY.				lastIndex _ lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'yo 1/6/2005 22:58'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	destX _ spaceX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."	baseline _ textStyle baseline.	baselineY _ destY + baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	presentationLine _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	numOfComposition _ 0.	presentation _ TextStream on: (Text fromString: (MultiString new: text size)).	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading.						^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'tak 12/22/2004 00:59'!setActualFont: aFont	"Keep track of max height and ascent for auto lineheight"	| descent |	super setActualFont: aFont.	"'   ', lastIndex printString, '   ' displayAt: (lastIndex * 15)@0."	lineHeight == nil		ifTrue: [descent _ font descent.				baseline _ font ascent.				lineHeight _ baseline + descent]		ifFalse: [descent _ lineHeight - baseline max: font descent.				baseline _ baseline max: font ascent.				lineHeight _ lineHeight max: baseline + descent]! !!MultiDisplayScanner methodsFor: 'private' stamp: 'yo 1/6/2005 23:06'!setFont 	foregroundColor _ paragraphColor.	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"	font installOn: bitBlt foregroundColor: foregroundColor backgroundColor: Color transparent.	text ifNotNil:[		baselineY _ lineY + line baseline.		destY _ baselineY - font ascent].! !!MultiDisplayScanner methodsFor: 'MVC-compatibility' stamp: 'yo 1/7/2005 12:15'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	morphicOffset _ 0@0.	leftInRun _ 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment]).			destX _ (runX _ leftMargin).			line _ aParagraph lines at: lineIndex.			lineHeight _ line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex _ line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun _ text runLengthFor: line first].			baselineY _ lineY + line baseline.			destY _ baselineY - font ascent.  "Should have happened in setFont"			runLength _ leftInRun.			runStopIndex _ lastIndex + (runLength - 1) min: line last.			leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).			spaceCount _ 0.			done _ false.			string _ text string.			self handleIndentation.			[done] whileFalse:[				startIndex _ lastIndex.				lastPos _ destX@destY.				stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern baselineY: baselineY].				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].			fillBlt == nil ifFalse:				[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY _ lineY + lineHeight]]! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'yo 1/7/2005 12:15'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line _ textLine.	morphicOffset _ offset.	lineY _ line top + offset y.	lineHeight _ line lineHeight.	rightMargin _ line rightMargin + offset x.	lastIndex _ line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin _ (line leftMarginForAlignment: alignment) + offset x.	destX _ runX _ leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex _ line first.	leftInRun <= 0		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	baselineY _ lineY + line baseline.	destY _ baselineY - font ascent.	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	done _ false.	string _ text string.	[done] whileFalse:[		startIndex _ lastIndex.		lastPos _ destX@destY.		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern baselineY: baselineY].		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition.		"lastIndex > runStopIndex ifTrue: [done _ true]."	].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'yo 1/6/2005 22:56'!placeEmbeddedObject: anchoredMorph	anchoredMorph relativeTextAnchorPosition ifNotNil:[		anchoredMorph position: 			anchoredMorph relativeTextAnchorPosition +			(anchoredMorph owner textBounds origin x @ 0)			- (0@morphicOffset y) + (0@lineY).		^true	].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph ifTrue: [		anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset	] ifFalse: [		destY _ lineY.		baselineY _ lineY + anchoredMorph height..		runX _ destX.		anchoredMorph 			displayOn: bitBlt destForm 			at: destX - anchoredMorph width @ destY			clippingBox: bitBlt clipRect	].	^ true! !!MultiString methodsFor: 'converting' stamp: 'yo 2/18/2005 00:23'!asFileName	"Answer a String made up from the receiver that is an acceptable file 	name."	| string checkedString |	string _ FileDirectory checkName: self fixErrors: true.	checkedString _ (FilePath pathName: string) asSystemPathName.	^ (FilePath pathName: checkedString isEncoded: true) asSqueakPathName.! !!MultiString methodsFor: 'converting' stamp: 'H.Hachisuka 12/10/2004 22:34'!convertFromSuperSwikiServerString	^self.! !!MultiString methodsFor: 'converting' stamp: 'H.Hachisuka 12/10/2004 22:34'!convertToSuperSwikiServerString	^self convertToWithConverter: (TextConverter newForEncoding: 'shift_jis').! !!NaturalLanguageFormTranslator methodsFor: 'as yet unclassified' stamp: 'yo 1/13/2005 11:15'!generics	^generics ifNil: [generics := Dictionary new]! !!NaturalLanguageFormTranslator methodsFor: 'as yet unclassified' stamp: 'yo 1/13/2005 11:27'!localeID	^id! !!NaturalLanguageFormTranslator methodsFor: 'as yet unclassified' stamp: 'yo 1/13/2005 11:26'!localeID: anID	id := anID! !!NaturalLanguageFormTranslator methodsFor: 'as yet unclassified' stamp: 'yo 1/13/2005 11:17'!name: formName form: translatedForm 	self generics at: formName put: translatedForm.! !!NaturalLanguageFormTranslator methodsFor: 'as yet unclassified' stamp: 'yo 1/13/2005 14:02'!saveFormsOn: aStream	| rr |	rr _ ReferenceStream on: aStream.	rr nextPut: {id isoString. generics}.	rr close.! !!NaturalLanguageFormTranslator methodsFor: 'as yet unclassified' stamp: 'yo 1/13/2005 11:35'!translate: aString	^ (self generics		at: aString ifAbsent: [nil]) deepCopy.	"Do you like to write 'form ifNotNil: [form deepCopy]'?"! !!NaturalLanguageFormTranslator class methodsFor: 'as yet unclassified' stamp: 'yo 1/13/2005 11:13'!cachedTranslations	"CachedTranslations := nil" 	^CachedTranslations ifNil: [CachedTranslations := Dictionary new]! !!NaturalLanguageFormTranslator class methodsFor: 'as yet unclassified' stamp: 'yo 1/13/2005 11:13'!isoLanguage: isoLanguage	"Return the generic language translator as there is no information about the country code"	^self isoLanguage: isoLanguage isoCountry: nil! !!NaturalLanguageFormTranslator class methodsFor: 'as yet unclassified' stamp: 'yo 1/13/2005 11:13'!isoLanguage: isoLanguage isoCountry: isoCountry	^self localeID: (LocaleID  isoLanguage: isoLanguage isoCountry: isoCountry)! !!NaturalLanguageFormTranslator class methodsFor: 'as yet unclassified' stamp: 'yo 1/13/2005 14:02'!loadFormsFrom: aStream	| rr pair inst |	rr _ ReferenceStream on: aStream.	pair _ rr next.	inst _ self localeID: (LocaleID isoString: pair first).	pair second associationsDo: [:assoc |		inst name: assoc key form: assoc value.	].	^ inst.! !!NaturalLanguageFormTranslator class methodsFor: 'as yet unclassified' stamp: 'yo 1/13/2005 11:13'!localeID: localeID 	^ self cachedTranslations		at: localeID		ifAbsentPut: [self new localeID: localeID]! !!NaturalLanguageTranslator methodsFor: 'translation' stamp: 'yo 8/2/2004 12:27'!rawPhrase: phraseString translation: translationString 	self generics at: phraseString put: translationString asString.! !!NaturalLanguageTranslator methodsFor: 'translation' stamp: 'yo 1/14/2005 16:25'!rawRemoveUntranslated: untranslated	self class allKnownPhrases removeKey: untranslated ifAbsent: [].	self changed: #untranslated.! !!NaturalLanguageTranslator methodsFor: 'translation' stamp: 'yo 8/1/2004 01:07'!removeTranslationFor: phraseString	self generics removeKey: phraseString ifAbsent: [].	self changed: #translations.	self changed: #untranslated.! !!NaturalLanguageTranslator methodsFor: 'translation' stamp: 'yo 1/14/2005 16:25'!removeUntranslated: untranslated	self class allKnownPhrases removeKey: untranslated ifAbsent: [].! !!NaturalLanguageTranslator methodsFor: 'private store-retrieve' stamp: 'yo 7/30/2004 13:00'!loadFromFileNamed: fileNameString 	"Load translations from an external file"	| stream |	[stream := FileStream readOnlyFileNamed: fileNameString.	self loadFromStream: stream]		ensure: [stream close].	self changed: #translations.	self changed: #untranslated.! !!NaturalLanguageTranslator methodsFor: 'private store-retrieve' stamp: 'tak 11/16/2004 12:37'!loadFromRefStream: stream 	"Load translations from an external file"	| loadedArray refStream |	refStream := ReferenceStream on: stream.	[loadedArray := refStream next]		ensure: [refStream close].	self processExternalObject: loadedArray ! !!NaturalLanguageTranslator methodsFor: 'private store-retrieve' stamp: 'tak 11/16/2004 12:39'!loadFromStream: stream 	"Load translations from an external file"	| header isFileIn |	header := '''Translation dictionary'''.	isFileIn := (stream next: header size)				= header.	stream reset.	isFileIn		ifTrue: [stream fileInAnnouncing: 'Loading ' , stream localName]		ifFalse: [self loadFromRefStream: stream]! !!NaturalLanguageTranslator methodsFor: 'private store-retrieve' stamp: 'yo 8/2/2004 12:27'!mergeTranslations: newTranslations	"Merge a new set of translations into the exiting table.	Overwrites existing entries."	newTranslations keysAndValuesDo: [:key :value |		self rawPhrase: (self class registeredPhraseFor: key) translation: value].	self changed: #translations.	self changed: #untranslated.! !!NaturalLanguageTranslator methodsFor: 'private store-retrieve' stamp: 'yo 2/17/2005 15:45'!saveToFileNamed: fileNameString 	"save the receiver's translations to a file named fileNameString"	| stream |	"Set true if you need to save as binary"	false		ifTrue: [stream := ReferenceStream fileNamed: fileNameString.			stream nextPut: {self translations. self untranslated}.			stream close.			^ self].	stream := FileStream fileNamed: fileNameString.	[self fileOutOn: stream]		ensure: [stream close]! !!NaturalLanguageTranslator methodsFor: 'fileIn/fileOut' stamp: 'tak 11/16/2004 11:04'!fileOutHeader	^ '''Translation dictionary'''! !!NaturalLanguageTranslator methodsFor: 'fileIn/fileOut' stamp: 'tak 11/28/2004 14:50'!fileOutHeaderOn: aStream 	aStream nextChunkPut: self fileOutHeader;		 cr.	aStream timeStamp; cr.	aStream nextPut: $!!.	aStream nextChunkPut: '(' , self class name , ' localeID: ' , id storeString , ')'.	aStream cr! !!NaturalLanguageTranslator methodsFor: 'fileIn/fileOut' stamp: 'tak 11/28/2004 14:55'!fileOutOn: aStream 	"self current fileOutOn: Transcript. Transcript endEntry"	self fileOutOn: aStream keys: nil! !!NaturalLanguageTranslator methodsFor: 'fileIn/fileOut' stamp: 'tak 11/28/2004 14:54'!fileOutOn: aStream keys: keys 	"self current fileOutOn: Transcript. Transcript endEntry"	self fileOutHeaderOn: aStream.	(keys		ifNil: [generics keys asSortedCollection])		do: [:key | self				nextChunkPut: (generics associationAt: key)				on: aStream].	keys		ifNil: [self untranslated				do: [:each | self nextChunkPut: each -> '' on: aStream]].	aStream nextPut: $!!;		 cr! !!NaturalLanguageTranslator methodsFor: 'fileIn/fileOut' stamp: 'tak 11/16/2004 09:26'!nextChunkPut: anObject on: aStream 	| i remainder terminator |	terminator := $!!.	remainder := anObject storeString.	[(i := remainder indexOf: terminator) = 0]		whileFalse: [aStream				nextPutAll: (remainder copyFrom: 1 to: i).			aStream nextPut: terminator.			"double imbedded terminators"			remainder := remainder copyFrom: i + 1 to: remainder size].	aStream nextPutAll: remainder.	aStream nextPut: terminator; cr.! !!NaturalLanguageTranslator methodsFor: 'fileIn/fileOut' stamp: 'tak 12/15/2004 16:07'!scanFrom: aStream 	"Read a definition of dictionary.  	Make sure current locale corresponds my locale id"	| aString newTranslations assoc currentPlatform |	newTranslations := Dictionary new.	currentPlatform := Locale currentPlatform.	[Locale		currentPlatform: (Locale localeID: id).	[aString := aStream nextChunk withSqueakLineEndings.	aString size > 0]		whileTrue: [assoc := Compiler evaluate: aString.			assoc value = ''				ifTrue: [self class registerPhrase: assoc key]				ifFalse: [newTranslations add: assoc]]]		ensure: [Locale currentPlatform: currentPlatform].	self mergeTranslations: newTranslations! !!NewParagraph methodsFor: 'initialize-release' stamp: 'tak 12/21/2004 13:29'!initialize	self positionWhenComposed: 0 @ 0! !!ObjectWithDocumentation methodsFor: 'documentation' stamp: 'yo 2/11/2005 15:41'!editDescription	"Allow the user to see and edit the documentation for this object"	| reply helpMessage |	helpMessage _ self documentation isNil				ifTrue: [String new]				ifFalse: [self documentation].	reply _ FillInTheBlank				multiLineRequest: 'Kindly edit the description' translated				centerAt: Sensor cursorPoint				initialAnswer: helpMessage				answerHeight: 200.	reply isEmptyOrNil		ifFalse: [self documentation: reply]! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'yo 1/13/2005 12:20'!loadJapanesePaintBoxBitmaps"	PaintBoxMorph new loadJapanesePaintBoxBitmaps."	| formTranslator form bb |	self position: 0@0.	formTranslator _ NaturalLanguageFormTranslator localeID: (LocaleID isoString: 'ja').	form _ Form fromFileNamed: 'offPaletteJapanese(children).form'.	#('keep:' 'undo:' 'clear:' 'toss:') with: #('KEEP' 'UNDO' 'CLEAR' 'TOSS') do: [:extName :label |		bb _ (self submorphs detect: [:e | e externalName = extName]) bounds.		formTranslator name: label, '-off' form: (form copy: bb)	].	form _ Form fromFileNamed: 'pressedPaletteJapanese(children).form'.	#('keep:' 'undo:' 'clear:' 'toss:') with: #('KEEP' 'UNDO' 'CLEAR' 'TOSS') do: [:extName :label |		bb _ (self submorphs detect: [:e | e externalName = extName]) bounds.		formTranslator name: label, '-pressed' form: (form copy: bb)	].! !!PaintBoxMorph methodsFor: 'other' stamp: 'yo 1/13/2005 14:08'!addGraphicLabels	"translate button labels"	| formTranslator ext pos newForm |	formTranslator _ NaturalLanguageFormTranslator localeID: (Locale current localeID).	#('KEEP' 'UNDO' 'CLEAR' 'TOSS') do: [:label |		(formTranslator translate: label, '-off') ifNil: [^ false].		(formTranslator translate: label, '-pressed') ifNil: [^ false].	].		#('keep:' 'undo:' 'clear:' 'toss:') with: #('KEEP' 'UNDO' 'CLEAR' 'TOSS') do: [:extName :label |		| button |		button _ submorphs detect: [:m | m externalName = extName] ifNone: [nil].		button ifNotNil: [			button removeAllMorphs.			ext _ button extent.			pos _ button position.			(newForm _ formTranslator translate: label, '-off') ifNotNil: [				button offImage: newForm.			].			(newForm _ formTranslator translate: label, '-pressed') ifNotNil: [				button pressedImage: newForm.			].			button extent: ext.			button position: pos.		].	].	^ true.! !!PaintBoxMorph methodsFor: 'other' stamp: 'yo 1/13/2005 14:08'!addLabels	Preferences useFormsInPaintBox ifFalse: [		self addTextualLabels.	] ifTrue: [		self addGraphicLabels ifFalse: [self addTextualLabels].	].! !!PaintBoxMorph methodsFor: 'other' stamp: 'yo 1/13/2005 11:06'!addTextualLabels	"translate button labels"	#('keep:' 'undo:' 'clear:' 'toss:') with: #('KEEP' 'UNDO' 'CLEAR' 'TOSS') do: [:extName :label |		| button |		button _ submorphs detect: [:m | m externalName = extName] ifNone: [nil].		button ifNotNil: [			button removeAllMorphs.			button addMorph: (TextMorph new 				contentsWrapped: (Text string: label translated					attributes: {						TextAlignment centered. 						TextEmphasis bold.						TextFontReference toFont:							(Preferences standardPaintBoxButtonFont)});				bounds: (button bounds translateBy: 0@3);				lock)]]! !!PaintBoxMorph class methodsFor: 'notification' stamp: 'ka 2/19/2005 01:54'!localeChanged	self initializeColorChart! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'yo 2/17/2005 17:53'!changeAlignment	| aList reply  |	aList _ #(leftFlush centered justified rightFlush).	reply _ (SelectionMenu labelList: (aList collect: [:t | t translated]) selections: aList) startUp.	reply ifNil:[^self].	self setAlignment: reply.	paragraph composeAll.	self recomputeSelection.	self mvcRedisplay.	^ true! !!PasteUpMorph methodsFor: 'cursor' stamp: 'tak 11/7/2004 18:33'!cursorWrapped: aNumber 	"Set the cursor to the given number, modulo the number of items I	contain. Fractional cursor values are allowed."	| oldRect newRect offset |	cursor = aNumber		ifTrue: [^ self].	self hasSubmorphs		ifFalse: [cursor := 1.			^ self].	oldRect := self selectedRect.	offset := (self asNumber: aNumber) - 1 \\ submorphs size.	cursor := offset + 1.	newRect := self selectedRect.	self indicateCursor		ifTrue: [self invalidRect: oldRect;				 invalidRect: newRect]! !!PasteUpMorph methodsFor: 'halos and balloon help' stamp: 'yo 2/17/2005 14:45'!wantsHaloFromClick	(owner isSystemWindow) ifTrue: [^ false].	self paintBoxOrNil ifNotNil: [^ false].	^ true.! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'yo 2/10/2005 17:40'!playfieldOptionsMenu	"Answer an auxiliary menu with options specific to playfields -- too many to be housed in the main menu"	| aMenu isWorld |	isWorld _ self isWorldMorph.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu add: 'save on file...' translated action: #saveOnFile.	aMenu add: 'save as SqueakPage at url...' translated action: #saveOnURL.	aMenu add: 'update all from resources' translated action: #updateAllFromResources.	(self valueOfProperty: #classAndMethod) ifNotNil:		[aMenu add: 'broadcast as documentation' translated action: #saveDocPane].	aMenu add: 'round up strays' translated action: #roundUpStrays.	aMenu balloonTextForLastItem:  'Bring back all objects whose current coordinates keep them from being visible, so that at least a portion of each of my interior objects can be seen.' translated.	aMenu add: 'show all players' translated action: #showAllPlayers.	aMenu balloonTextForLastItem:  'Make visible the viewers for all players which have user-written scripts in this playfield.' translated.	aMenu add: 'hide all players' translated action: #hideAllPlayers.	aMenu balloonTextForLastItem:  'Make invisible the viewers for all players in this playfield. This will save space before you publish this project' translated.	aMenu addLine.	aMenu add: 'shuffle contents' translated action: #shuffleSubmorphs.	aMenu balloonTextForLastItem: 'Rearranges my contents in random order' translated.	self griddingOn		ifTrue: [aMenu add: 'turn gridding off' translated action: #griddingOnOff.				aMenu add: (self gridVisible ifTrue: ['hide'] ifFalse: ['show']) translated, ' grid' translated						action: #gridVisibleOnOff.				aMenu add: 'set grid spacing...' translated action: #setGridSpec]		ifFalse: [aMenu add: 'turn gridding on' translated action: #griddingOnOff].	aMenu addLine.	#(	(autoLineLayoutString	toggleAutoLineLayout			'whether submorphs should automatically be laid out in lines')		(indicateCursorString	toggleIndicateCursor			'whether the "current" submorph should be indicated with a dark black border')		(isPartsBinString		toggleIsPartsBin			'whether dragging an object from the interior should produce a COPY of the object')		(isOpenForDragNDropString	toggleDragNDrop			'whether objects can be dropped into and dragged out of me')		(mouseOverHalosString	toggleMouseOverHalos			'whether objects should put up halos when the mouse is over them')		(autoExpansionString	toggleAutomaticPhraseExpansion			'whether tile phrases, dropped on me, should automatically sprout Scriptors around them')		(originAtCenterString	toggleOriginAtCenter			'whether the cartesian origin of the playfield should be at its lower-left corner or at the center of the playfield')		(showThumbnailString	toggleAlwaysShowThumbnail			'whether large objects should be represented by thumbnail miniatures of themselves')		(fenceEnabledString	toggleFenceEnabled			'whether moving objects should stop at the edge of their container')		(batchPenTrailsString	toggleBatchPenTrails 			'if true, detailed movement of pens between display updates is ignored.  Thus multiple line segments drawn within a script may not be seen individually.')	) do:			[:triplet |				(isWorld and: [#(toggleAutoLineLayout toggleIndicateCursor toggleIsPartsBin toggleAlwaysShowThumbnail) includes: triplet second]) ifFalse:					[aMenu addUpdating: triplet first action: triplet second.					aMenu balloonTextForLastItem: triplet third translated]]. 	aMenu addUpdating: #autoViewingString action: #toggleAutomaticViewing.	aMenu balloonTextForLastItem:  'governs whether, when an object is touched inside me, a viewer should automatically be launched for it.' translated.	((isWorld not or: [self backgroundSketch notNil]) or: [presenter isNil])		ifTrue:			[aMenu addLine].	isWorld ifFalse:		[aMenu add: 'set thumbnail height...' translated action: #setThumbnailHeight.		aMenu balloonTextForLastItem: 'if currently showing thumbnails governs the standard height for them' translated.		aMenu add: 'behave like a Holder' translated action: #becomeLikeAHolder.		aMenu balloonTextForLastItem: 'Set properties to make this object nicely set up to hold frames of a scripted animation.' translated].	self backgroundSketch ifNotNil:		[aMenu add: 'delete background painting' translated action: #deleteBackgroundPainting.		aMenu balloonTextForLastItem: 'delete the graphic that forms the background for this me.' translated].	presenter ifNil:		[aMenu add: 'make detachable' translated action: #makeDetachable.		aMenu balloonTextForLastItem: 'Allow this area to be separately governed by its own controls.' translated].	aMenu addLine.	aMenu add: 'use standard texture' translated action: #setStandardTexture.	aMenu balloonTextForLastItem: 'use a pale yellow-and-blue background texture here.' translated.	aMenu add: 'make graph paper...' translated action: #makeGraphPaper.	aMenu balloonTextForLastItem: 'Design your own graph paper and use it as the background texture here.' translated.	aMenu addTitle: 'playfield options...' translated.	^ aMenu! !!PasteUpMorph methodsFor: 'misc' stamp: 'yo 2/17/2005 16:58'!mouseX	"Answer the x-coordinate of the mouse, in my coordinate system"	^ self isInWorld		ifTrue:			[((self pointFromWorld: self cursorPoint) x) - self cartesianOrigin x]		ifFalse:			[0]! !!PasteUpMorph methodsFor: 'misc' stamp: 'yo 2/17/2005 16:58'!mouseY	"Answer the y-coordinate of the mouse, in my coordinate system"	^ self isInWorld		ifTrue:			[self cartesianOrigin y - ((self pointFromWorld: self cursorPoint) y)]		ifFalse:			[0]! !!PasteUpMorph methodsFor: 'pen' stamp: 'tak 1/18/2005 13:40'!addImageToPenTrails: aForm 	"The turtleTrailsForm is created on demand when the first pen is put  	down and removed (to save space) when turtle trails are cleared."	self createOrResizeTrailsForm.	aForm		displayOn: turtleTrailsForm		at: self topLeft negated		rule: Form paint.	self		invalidRect: (aForm offset extent: aForm extent)! !!PasteUpMorph methodsFor: 'world menu' stamp: 'tak 1/26/2005 22:08'!keystrokeInWorld: evt	"A keystroke was hit when no keyboard focus was set, so it is sent here to the world instead."	|  aChar isCmd ascii |	aChar _ evt keyCharacter.	(ascii _ aChar asciiValue) = 27 ifTrue: "escape key"		[^ self putUpWorldMenuFromEscapeKey].	(evt controlKeyPressed not		and: [(#(1 4 8 28 29 30 31 32) includes: ascii)  "home, end, backspace, arrow keys, space"			and: [self keyboardNavigationHandler notNil]])				ifTrue: [self keyboardNavigationHandler navigateFromKeystroke: aChar].	isCmd _ evt commandKeyPressed and: [Preferences cmdKeysInText].	(evt commandKeyPressed and: [Preferences eToyFriendly])			ifTrue:				[(aChar == $W) ifTrue: [^ self putUpWorldMenu: evt]].	(isCmd and: [Preferences honorDesktopCmdKeys]) ifTrue:		[^ self dispatchCommandKeyInWorld: aChar event: evt].	"It was unhandled. Remember the keystroke."	self lastKeystroke: evt keyString.	self triggerEvent: #keyStroke! !!PasteUpMorph methodsFor: 'world state' stamp: 'yo 2/17/2005 14:49'!assureNotPaintingElse: aBlock	"If painting is already underway in the receiver, put up an informer to that effect and evalute aBlock"	self sketchEditorOrNil ifNotNil:		[self inform: 'Sorry, you can only paintone object at a time' translated.		Cursor normal show.		^ aBlock value]! !!PasteUpMorphTest methodsFor: 'cursor' stamp: 'tak 11/7/2004 18:29'!testCursorWrapped	"self debug: #testCursorWrapped"	| holder |	holder := PasteUpMorph new.	self assert: holder cursor = 1.	holder cursorWrapped: 2.	self assert: holder cursor = 1.	holder addMorph: Morph new;		 addMorph: Morph new;		 addMorph: Morph new.	holder cursorWrapped: 3.	self assert: holder cursor = 3.	holder cursorWrapped: 5.	self assert: holder cursor = 2.	holder cursorWrapped: 0.	self assert: holder cursor = 3.	holder cursorWrapped: -1.	self assert: holder cursor = 2.! !!PasteUpMorphTest methodsFor: 'cursor' stamp: 'tak 11/7/2004 18:34'!testCursorWrappedWithFraction	"self debug: #testCursorWrappedWithFraction"	| holder |	holder := PasteUpMorph new.	holder addMorph: Morph new;		 addMorph: Morph new;		 addMorph: Morph new.	holder cursorWrapped: 3.5.	self assert: holder cursor = 3.5.	holder cursorWrapped: 5.5.	self assert: holder cursor = 2.5.	holder cursorWrapped: 0.5.	self assert: holder cursor = 3.5.	holder cursorWrapped: -0.5.	self assert: holder cursor = 2.5.! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'yo 2/11/2005 10:19'!invokeScoreMenu: evt	"Invoke the score's edit menu."	| menu subMenu |	menu _ MenuMorph new defaultTarget: self.	menu addList:		{{'cut' translated.		#cutSelection}.		{'copy' translated.		#copySelection}.		{'paste' translated.		#insertSelection}.		{'paste...' translated.		#insertTransposed}}.	menu addLine.	menu addList:		{{'legato' translated.		#selectionBeLegato}.		{'staccato' translated.	#selectionBeStaccato}.		{'normal' translated.		#selectionBeNormal}}.	menu addLine.	menu addList:		{{'expand time' translated.		#expandTime}.		{'contract time' translated.		#contractTime}}.	menu addLine.	subMenu _ MenuMorph new defaultTarget: self.		(2 to: 12) do: [:i | subMenu add: i printString selector: #beatsPerMeasure: argument: i].		menu add: 'time   ' translated, beatsPerMeasure printString subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.		#(2 4 8) do: [:i | subMenu add: i printString selector: #notePerBeat: argument: i].		menu add: 'sig     ' translated, notePerBeat printString subMenu: subMenu.	menu addLine.	showMeasureLines		ifTrue: [menu add: 'hide measure lines' translated action: #measureLinesOnOff]		ifFalse: [menu add: 'show measure lines' translated action: #measureLinesOnOff].	showBeatLines		ifTrue: [menu add: 'hide beat lines' translated action: #beatLinesOnOff]		ifFalse: [menu add: 'show beat lines' translated action: #beatLinesOnOff].	menu addLine.	menu add: 'add keyboard' translated action: #addKeyboard.	menu popUpEvent: evt in: self world.! !!Player methodsFor: 'costume' stamp: 'tak 1/17/2005 13:32'!stamp	"stamp an image of ourself onto the pen trails form"	costume stamp! !!Player methodsFor: 'misc' stamp: 'tak 1/21/2005 11:59'!overlaps: aPlayer 	"Answer whether my costume overlaps that of another player"	| goalCostume intersection myShadow goalShadow bb myRect goalRect |	aPlayer ifNil: [^false].	goalCostume := aPlayer costume.	costume world == goalCostume world ifFalse: [^false].	"check if the 2 player costumes intersect"	intersection := costume bounds intersect: goalCostume bounds.	(intersection width = 0 or: [intersection height = 0]) 		ifTrue: [^false]		ifFalse: 			["check if the overlapping region is non-transparent"			"compute 1-bit, black and white versions (stencils) of the intersecting  			part of each morph's costume"			myRect := intersection translateBy: 0 @ 0 - costume topLeft.			myShadow := (costume imageForm contentsOfArea: myRect) stencil.			goalRect := intersection translateBy: 0 @ 0 - goalCostume topLeft.			goalShadow := (goalCostume imageForm contentsOfArea: goalRect) stencil.			"compute a pixel-by-pixel AND of the two stencils.  Result will be black 			(pixel value = 1) where black parts of the stencils overlap"			bb := BitBlt toForm: myShadow.			bb 				copyForm: goalShadow				to: 0 @ 0				rule: Form and.			"return TRUE if resulting form contains any black pixels"			^(bb destForm tallyPixelValues second) > 0]! !!Player methodsFor: 'scripts-kernel' stamp: 'yo 2/12/2005 19:53'!addIdiosyncraticMenuItemsTo: aMenu forSlotSymol: slotSym	"The menu provided has the receiver as its argument, and is used as the menu for the given slot-symbol in a line of a Viewer.  Add special-case items"	(#(copy getNewClone newClone) includes: slotSym) ifTrue:		[aMenu add: 'give me a copy now' translated action: #handTheUserACopy]."	(slotSym == #dropShadow) ifTrue:		[aMenu add: 'set shadow offset' translated action: #setShadowOffset].	(slotSym == #useGradientFill) ifTrue:		[aMenu add: 'set gradient origin...' translated action: #setGradientOffset.		aMenu add: 'set gradient direction...' translated action: #setGradientDirection]."! !!Player methodsFor: 'scripts-kernel' stamp: 'yo 2/11/2005 15:37'!renameScript: oldSelector 	"The user has asked to rename the script formerly known by oldSelector; obtain a new selector from the user, check it out, and if all is well, ascribe the new name as appropriate"	| reply newSelector aUserScript |	self flag: #deferred.	"Relax the restriction below, before too long"	aUserScript := self class userScriptForPlayer: self selector: oldSelector.	aUserScript okayToRename 		ifFalse: 			[self 				inform: 'Sorry, we do not permit you to renameclassic-tiled scripts that are currentlytextually coded.  Go back to tile scriptsand try again.  Humble apologies.' translated.			^self].	reply := FillInTheBlank request: 'Script Name' translated initialAnswer: oldSelector.	reply isEmpty ifTrue: [^self].	reply = oldSelector ifTrue: [^Beeper beep].	newSelector := self acceptableScriptNameFrom: reply				forScriptCurrentlyNamed: oldSelector.	Preferences universalTiles 		ifTrue: 			["allow colons"			(reply copyWithout: $:) = newSelector 				ifTrue: [newSelector := reply asSymbol]				ifFalse: [self inform: 'name will be modified']].	self renameScript: oldSelector newSelector: newSelector! !!Player methodsFor: 'scripts-kernel' stamp: 'yo 2/16/2005 07:58'!slotInfoButtonHitFor: aGetterSymbol inViewer: aViewer	"The user made a gesture asking for slot menu for the given getter symbol in a viewer; put up the menu."	| aMenu slotSym aType typeVocab interface selector |	slotSym _ Utilities inherentSelectorForGetter: aGetterSymbol.	aType _ self typeForSlotWithGetter: aGetterSymbol asSymbol.	aMenu _ MenuMorph new defaultTarget: self.	interface := aViewer currentVocabulary methodInterfaceAt: aGetterSymbol ifAbsent: [nil].	selector := interface isNil		ifTrue: [slotSym asString]		ifFalse: [interface selector].	aMenu addTitle: (selector, ' (', (aType asString translated), ')').	(typeVocab _ Vocabulary vocabularyForType: aType) addWatcherItemsToMenu: aMenu forGetter: aGetterSymbol.	(self slotInfo includesKey: slotSym)		ifTrue:			[aMenu add: 'change value type' translated selector: #chooseSlotTypeFor: argument: aGetterSymbol.			typeVocab addUserSlotItemsTo: aMenu slotSymbol: slotSym.			aMenu add: ('remove "{1}"' translated format: {slotSym}) selector: #removeSlotNamed: argument: slotSym.			aMenu add: ('rename "{1}"' translated format: {slotSym}) selector: #renameSlot: argument: slotSym.			aMenu addLine].	typeVocab addExtraItemsToMenu: aMenu forSlotSymbol: slotSym.  "e.g. Player type adds hand-me-tiles"	aMenu add: 'show categories....' translated target: aViewer selector: #showCategoriesFor: argument: aGetterSymbol.	self addIdiosyncraticMenuItemsTo: aMenu forSlotSymol: slotSym.	aMenu items isEmpty ifTrue:		[aMenu add: 'ok' translated action: #yourself].	aMenu popUpForHand: aViewer primaryHand in: aViewer world! !!Player methodsFor: 'scripts-standard' stamp: 'tak 1/21/2005 12:08'!overlapsAny: aPlayer 	"Answer true if my costume overlaps that of aPlayer, or any of its  	siblings (if aPlayer is a scripted player)  	or if my costume overlaps any morphs of the same class (if aPlayer is  	unscripted)."	| possibleCostumes itsCostume itsCostumeClass myShadow |	(self ~= aPlayer			and: [self overlaps: aPlayer])		ifTrue: [^ true].	possibleCostumes := IdentitySet new.	aPlayer belongsToUniClass		ifTrue: [aPlayer class				allSubInstancesDo: [:anInstance | (anInstance ~~ aPlayer							and: [itsCostume := anInstance costume.								(itsCostume bounds intersects: costume bounds)									and: [itsCostume world == costume world]])						ifTrue: [possibleCostumes add: itsCostume]]]		ifFalse: [itsCostumeClass := aPlayer costume class.			self costume world presenter allExtantPlayers				do: [:ep | ep costume						ifNotNilDo: [:ea | (ea class == itsCostumeClass									and: [ea bounds intersects: costume bounds])								ifTrue: [possibleCostumes add: ea]]]].	possibleCostumes isEmpty		ifTrue: [^ false].	myShadow := costume shadowForm.	^ possibleCostumes		anySatisfy: [:m | m overlapsShadowForm: myShadow bounds: costume fullBounds]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 2/12/2005 20:18'!getMouseX	^ self costume renderedMorph mouseX! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 2/12/2005 20:26'!getMouseY	^ self costume renderedMorph mouseY.! !!Player methodsFor: 'slot getters/setters' stamp: 'tak 1/26/2005 14:58'!getNewClone	"Answer a new player of the same class as the receiver, with a costume much like mine"	| clone |	clone _  costume usableSiblingInstance.	costume pasteUpMorph ifNotNilDo: [:parent | parent addMorph: clone].	^ clone player! !!Player methodsFor: 'slots-user' stamp: 'yo 2/11/2005 16:01'!chooseSlotTypeFor: aGetter	"Let the user designate a type for the slot associated with the given getter"	| typeChoices typeChosen slotName |	slotName _ Utilities inherentSelectorForGetter: aGetter.	typeChoices _ Vocabulary typeChoices.	typeChosen _ (SelectionMenu labelList: (typeChoices collect: [:t | t translated]) lines: #() selections: typeChoices) startUpWithCaption: 		('Choose the TYPEfor ' translated, slotName, '(currently ' translated, (self slotInfoAt: slotName) type translated, ')').	typeChosen isEmptyOrNil ifTrue: [^ self].	(self typeForSlot: slotName) capitalized = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:   "allSubInstancesDo:"		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName))].	self updateAllViewers.	"does siblings too"! !!Player methodsFor: 'slots-user' stamp: 'yo 2/12/2005 18:58'!fancyWatcherFor: aGetter	"Anser a labeled readout for viewing a value textuallyi"	| aWatcher aColor aLine itsName aSelector aLabel |	aWatcher _ self unlabeledWatcherFor: aGetter.	aColor _ Color r: 0.387 g: 0.581 b: 1.0.	aLine _ WatcherWrapper newRow.	aLine player: self variableName: (aSelector _ Utilities inherentSelectorForGetter: aGetter).	itsName _ aWatcher externalName.	aWatcher setNameTo: 'readout'.	aLine addMorphFront: (self tileReferringToSelf				borderWidth: 0; layoutInset: 4@0;				typeColor: aColor; 				color: aColor; bePossessive).	aLabel _ StringMorph contents: aSelector translated, ' = ' font: ScriptingSystem fontForTiles.	aLabel setProperty: #watcherLabel toValue: true.	aLine addMorphBack: aLabel.	aLine addMorphBack: aWatcher.	aLine setNameTo: itsName.	^ aLine! !!Player methodsFor: 'slots-user' stamp: 'yo 2/12/2005 20:09'!offerGetterTiles: slotName 	"For a player-type slot, offer to build convenient compound tiles that otherwise would be hard to get"	| typeChoices typeChosen thePlayerThereNow slotChoices slotChosen getterTiles aCategoryViewer playerGetter |	typeChoices := Vocabulary typeChoices.	typeChosen := (SelectionMenu labelList: (typeChoices collect: [:t | t translated]) lines: #() selections: typeChoices) 				startUpWithCaption: ('Choose the TYPEof data to get from{1}''s {2}' translated format: {self externalName. slotName translated}).	typeChosen isEmptyOrNil ifTrue: [^self].	thePlayerThereNow := self perform: (Utilities getterSelectorFor: slotName).	thePlayerThereNow 		ifNil: [thePlayerThereNow := self presenter standardPlayer].	slotChoices := thePlayerThereNow slotNamesOfType: typeChosen.	slotChoices isEmpty 		ifTrue: [^self inform: 'sorry -- no slots of that type' translated].	slotChoices _ slotChoices asSortedArray.	slotChosen := (SelectionMenu labelList: (slotChoices collect: [:t | t translated]) selections: slotChoices) 				startUpWithCaption: ('Choose the datumyou want to extract from {1}''s {2}' translated format: {self externalName. slotName translated}).	slotChosen isEmptyOrNil ifTrue: [^self].	"Now we want to tear off tiles of the form		holder's valueAtCursor's foo"	getterTiles := nil.	aCategoryViewer := CategoryViewer new initializeFor: thePlayerThereNow				categoryChoice: 'basic'.	getterTiles := aCategoryViewer 				getterTilesFor: (Utilities getterSelectorFor: slotChosen)				type: typeChosen.	aCategoryViewer := CategoryViewer new initializeFor: self				categoryChoice: 'basic'.	playerGetter := aCategoryViewer 				getterTilesFor: (Utilities getterSelectorFor: slotName)				type: #Player.	getterTiles submorphs first acceptDroppingMorph: playerGetter event: nil.	"the pad"	"simulate a drop"	getterTiles makeAllTilesGreen.	getterTiles justGrabbedFromViewer: false.	(getterTiles firstSubmorph)		changeTableLayout;		hResizing: #shrinkWrap;		vResizing: #spaceFill.	ActiveHand attachMorph: getterTiles! !!Player methodsFor: 'slots-user' stamp: 'yo 2/11/2005 15:44'!removeSlotNamed: aSlotName	"The user has requested that an instance variable be removed..."	| aSetter aGetter |	(self okayToRemoveSlotNamed: aSlotName) ifFalse:		[^ self inform: ('Sorry, {1} is inuse in a script.' translated format: {aSlotName})].	aSetter _ Utilities setterSelectorFor: aSlotName.	aGetter _ Utilities getterSelectorFor: aSlotName.	((self systemNavigation allCallsOn: aSetter) size > 0 or: [(self systemNavigation allCallsOn: aGetter) size > 0]) ifTrue:		[self inform: 'Caution!!  There may be scripts belonging toother objects that may rely on the presence ofthis variable.  If there are, they may now be broken.You may need to fix them up manually.' translated].	self class removeInstVarName: aSlotName asString.	self updateAllViewers! !!Player methodsFor: 'viewer' stamp: 'yo 2/11/2005 15:48'!infoFor: anElement inViewer: aViewer 	"The user made a gesture asking for info/menu relating"	| aMenu elementType aSelector |	elementType := self elementTypeFor: anElement				vocabulary: aViewer currentVocabulary.	elementType = #systemSlot | (elementType == #userSlot) 		ifTrue: [^self slotInfoButtonHitFor: anElement inViewer: aViewer].	aMenu := MenuMorph new defaultTarget: self.	aMenu defaultTarget: self.	aSelector := anElement asSymbol.	elementType == #userScript 		ifTrue: 			[aMenu 				add: 'destroy "' translated , anElement , '"'				selector: #removeScriptWithSelector:				argument: aSelector.			aMenu 				add: 'rename  "' translated, anElement , '"'				selector: #renameScript:				argument: aSelector.			aMenu 				add: 'textual scripting pane' translated				selector: #makeIsolatedCodePaneForSelector:				argument: aSelector.			aSelector numArgs > 0 				ifTrue: 					[aMenu 						add: 'remove parameter' translated						selector: #ceaseHavingAParameterFor:						argument: aSelector]				ifFalse: 					[aMenu 						add: 'add parameter' translated						selector: #startHavingParameterFor:						argument: aSelector.					aMenu 						add: 'button to fire this script' translated						selector: #tearOffButtonToFireScriptForSelector:						argument: aSelector].			aMenu 				add: 'edit balloon help' translated				selector: #editDescriptionForSelector:				argument: aSelector].	aMenu 		add: 'show categories....' translated		target: aViewer		selector: #showCategoriesFor:		argument: aSelector.	aMenu items isEmpty 		ifTrue: 			["Never 0 at the moment because of show categories addition"			aMenu add: 'ok' translated action: nil].	aMenu addTitle: anElement asString , ' (' , elementType translated , ')'.	aMenu popUpInWorld: aViewer world! !!Preferences class methodsFor: 'fonts' stamp: 'yo 1/12/2005 22:43'!restoreDefaultFonts	"Since this is called from menus, we can take the opportunity to prompt for missing font styles."	"	Preferences restoreDefaultFonts	"	self setDefaultFonts: #(		(setSystemFontTo:		Accuny				10)		(setListFontTo:			Accuny				10)		(setFlapsFontTo:			Accushi				12)		(setEToysFontTo:			BitstreamVeraSansBold	9)		(setPaintBoxButtonFontTo:			BitstreamVeraSansBold	9)		(setMenuFontTo:			Accuny				10)		(setWindowTitleFontTo:	BitstreamVeraSansBold	12)		(setBalloonHelpFontTo:	Accujen				9)		(setCodeFontTo:			Accuny				10)		(setButtonFontTo:		BitstreamVeraSansMono				9)	)! !!Preferences class methodsFor: 'fonts' stamp: 'yo 1/12/2005 22:43'!setPaintBoxButtonFontTo: aFont 	"change the font used in the buttons in PaintBox."	Parameters at: #paintBoxButtonFont put: aFont! !!Preferences class methodsFor: 'fonts' stamp: 'yo 1/12/2005 22:40'!standardPaintBoxButtonFont	"Answer the font to be used in the eToys environment"	^ Parameters		at: #paintBoxButtonFont		ifAbsent: [Parameters at: #paintBoxButtonFont put: self standardButtonFont]! !!Preferences class methodsFor: 'misc' stamp: 'yo 2/10/2005 16:15'!roundedCornersString	^ (((self valueOfFlag: #roundedWindowCorners)		ifTrue: ['stop']		ifFalse: ['start']) , ' rounding window corners') translated! !!Preferences class methodsFor: 'standard queries'!useFormsInPaintBox	^ self		valueOfFlag: #useFormsInPaintBox		ifAbsent: [false]! !!Preferences class methodsFor: 'themes' stamp: 'tak 12/8/2004 18:51'!takanawa	self setPreferencesFrom: #(		(alternativeScrollbarLook true)		(alternativeWindowLook true)		(canRecordWhilePlaying true)		(classicNavigatorEnabled false)		(eToyFriendly true)		(haloTransitions true)		(honorDesktopCmdKeys false)		(includeSoundControlInNavigator true)		(magicHalos true)		(menuKeyboardControl false)		(mouseOverHalos true)		(preserveTrash true)		(projectViewsInWindows true)		(propertySheetFromHalo true)		(showDirectionHandles true)		(showProjectNavigator true)		(soundQuickStart true)		(soundStopWhenDone true)		(uniTilesClassic false)		(uniqueNamesInHalos true)		(unlimitedPaintArea true))! !!Preferences class methodsFor: 'paintbox' stamp: 'yo 1/13/2005 11:05'!useFormsInPaintBox: aBoolean	self setPreference: #useFormsInPaintBox toValue: aBoolean! !!Presenter methodsFor: 'playerList' stamp: 'yo 2/10/2005 17:07'!reportPlayersAndScripts	"Open a window which contains a report on players and their scripts"	| aList aString |	(aList _ self uniclassesAndCounts) ifEmpty:  [^ self inform: 'there are no scripted players' translated].	aString _ String streamContents:		[:aStream |			aList do:				[:aPair |					aStream nextPutAll: aPair first name, ' -- ', aPair second printString.					aStream nextPutAll: ' ', (aPair second > 1 ifTrue: ['instances'] ifFalse: ['instance']) translated, ', '.					aStream nextPutAll: 'named' translated.					aPair first allInstancesDo: [:inst | aStream space; nextPutAll: inst externalName].					aStream cr].			aStream cr.			aList do:				[:aPair |					aStream cr.					aStream nextPutAll: '--------------------------------------------------------------------------------------------'.					aStream cr; nextPutAll: aPair first typicalInstanceName.					aStream nextPutAll: '''s' translated.					aStream nextPutAll: ' scripts:' translated.					aPair first addDocumentationForScriptsTo: aStream]].	(StringHolder new contents: aString)		openLabel: 'All scripts in this project' translated"self currentWorld presenter reportPlayersAndScripts"! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'yo 1/14/2005 19:37'!createStandardPlayer	| aMorph |	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	standardPlayer _ aMorph assuredPlayer renameTo: 'dot' translated.	aMorph setBalloonText: '...'.	self positionStandardPlayer.	^ standardPlayer! !!Project methodsFor: 'menu messages' stamp: 'yo 2/17/2005 15:07'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess |	(world isKindOf: StringMorph) ifTrue: [		self inform: 'This project is not all here. I will try to load a complete version.' translated.		^self loadFromServer: true	"try to get a fresh copy"	].	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	CurrentProject world triggerEvent: #aboutToLeaveWorld.	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to' translated]]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' translated withCRs			trueChoice: 'Revert to saved version' translated			falseChoice: 'Cancel' translated.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to' translated]]		ifFalse: [			CurrentProject finalExitActions.			CurrentProject makeThumbnail.			returningFlag == #specialReturn				ifTrue:					[ProjectHistory forget: CurrentProject.		"this guy is irrelevant"					Project forget: CurrentProject]				ifFalse:					[ProjectHistory remember: CurrentProject]].	(revertFlag | saveForRevert | forceRevert) ifFalse:		[(Preferences valueOfFlag: #projectsSentToDisk) ifTrue:			[self storeToMakeRoom]].	CurrentProject abortResourceLoading.	Smalltalk isMorphic ifTrue: [CurrentProject world triggerClosingScripts].	CurrentProject saveProjectPreferences.	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresentAndInMemory:					[:playerClass | playerClass allSubInstancesDo:						[:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject _ nil	] ifFalse: [		returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	self installProjectPreferences.	ChangeSet  newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ World pauseEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			world transferRemoteServerFrom: old world.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		world repairEmbeddedWorlds.		world triggerEvent: #aboutToEnterWorld.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess _ [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!Project methodsFor: 'file in/out' stamp: 'yo 2/13/2005 18:54'!exportSegmentWithChangeSet: aChangeSetOrNil fileName: aFileName
directory: aDirectory
	"Store my project out on the disk as an *exported*
ImageSegment.  All outPointers will be in a form that can be resolved
in the target image.  Name it <project name>.extSeg.  Whatdo we do
about subProjects, especially if they are out as local image
segments?  Force them to come in?
	Player classes are included automatically."

	| is str ans revertSeg roots holder collector fd mgr stacks |

	"Files out a changeSet first, so that a project can contain
its own classes"
world isMorph ifFalse: [
	self projectParameters at: #isMVC put: true.
	^ false].	"Only Morphic projects for now"
world ifNil: [^ false].  world presenter ifNil: [^ false].

Utilities emptyScrapsBook.
world currentHand pasteBuffer: nil.	  "don't write the paste buffer."
world currentHand mouseOverHandler initialize.	  "forget about any
references here"
	"Display checkCurrentHandForObjectToPaste."
Command initialize.
world clearCommandHistory.
world fullReleaseCachedState; releaseViewers.
world cleanseStepList.
world localFlapTabs size = world flapTabs size ifFalse: [
	self error: 'Still holding onto Global flaps'].
world releaseSqueakPages.
ScriptEditorMorph writingUniversalTiles: (self projectParameterAt:
#universalTiles ifAbsent: [false]).
holder _ Project allProjects.	"force them in to outPointers, where
DiskProxys are made"

"Just export me, not my previous version"
revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].
self projectParameters removeKey: #revertToMe ifAbsent: [].

roots _ OrderedCollection new.
roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.
roots add: world activeHand.

	"; addAll: classList; addAll: (classList collect: [:cls | cls class])"

roots _ roots reject: [ :x | x isNil].	"early saves may not have
active hand or thumbnail"

	fd _ aDirectory directoryNamed: self resourceDirectoryName.
	fd assureExistence.
	"Clean up resource references before writing out"
	mgr _ self resourceManager.
	self resourceManager: nil.
	ResourceCollector current: ResourceCollector new.
	ResourceCollector current localDirectory: fd.
	ResourceCollector current baseUrl: self resourceUrl.
	ResourceCollector current initializeFrom: mgr.
	ProgressNotification signal: '2:findingResources' extra:
'(collecting resources...)' translated.
	"Must activate old world because this is run at #armsLength.
	Otherwise references to ActiveWorld, ActiveHand, or ActiveEvent
	will not be captured correctly if referenced from blocks or user code."
	world becomeActiveDuring:[
		is _ ImageSegment new copySmartRootsExport: roots asArray.
		"old way was (is _ ImageSegment new
copyFromRootsForExport: roots asArray)"
	].
	self resourceManager: mgr.
	collector _ ResourceCollector current.
	ResourceCollector current: nil.
	ProgressNotification signal: '2:foundResources' extra: ''.
	is state = #tooBig ifTrue: [
		collector replaceAll.
		^ false].

str _ ''.
"considered legal to save a project that has never been entered"
(is outPointers includes: world) ifTrue: [
	str _ str, '\Project''s own world is not in the segment.' translated withCRs].
str isEmpty ifFalse: [
	ans _ (PopUpMenu labels: 'Do not write file
Write file anyway
Debug' translated) startUpWithCaption: str.
	ans = 1 ifTrue: [
		revertSeg ifNotNil: [projectParameters at:
#revertToMe put: revertSeg].
		collector replaceAll.
		^ false].
	ans = 3 ifTrue: [
		collector replaceAll.
		self halt: 'Segment not written' translated]].
	stacks _ is findStacks.

	is
		writeForExportWithSources: aFileName
		inDirectory: fd
		changeSet: aChangeSetOrNil.
	SecurityManager default signFile: aFileName directory: fd.
	"Compress all files and update check sums"
	collector forgetObsolete.
	self storeResourceList: collector in: fd.
	self storeHtmlPageIn: fd.
	self writeStackText: stacks in: fd registerIn: collector.
	"local proj.005.myStack.t"
	self compressFilesIn: fd to: aFileName in: aDirectory
resources: collector.
			"also deletes the resource directory"
	"Now update everything that we know about"
	mgr updateResourcesFrom: collector.

revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].
holder.

collector replaceAll.

world flapTabs do: [:ft |
		(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].
is arrayOfRoots do: [:obj |
	obj class == ScriptEditorMorph ifTrue: [obj unhibernate]].
^ true
! !!Project methodsFor: 'file in/out' stamp: 'yo 2/17/2005 15:05'!loadFromServer: newerAutomatically	"If a newer version of me is on the server, load it."	| pair resp server |	self assureIntegerVersion.	self isCurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #loadFromServer withDescription: 'Loading' translated	].	server _ self tryToFindAServerWithMe ifNil: [^ nil].	pair _ self class mostRecent: self name onServer: server.	pair first ifNil: [^ self inform: ('can''t find file on server for {1}' translated format: {self name})].	self currentVersionNumber > pair second ifTrue: [		^ self inform: ('That server has an older version of the project.' translated)].	version = (Project parseProjectFileName: pair first) second ifTrue: [		resp _ (PopUpMenu labels: 'Reload anyway\Cancel' translated withCRs) startUpWithCaption: 					'The only changes are the ones you made here.' translated.		resp ~= 1 ifTrue: [^ nil]	] ifFalse: [		newerAutomatically ifFalse: [			resp _ (PopUpMenu labels: 'Load it\Cancel' translated withCRs) startUpWithCaption: 						'A newer version exists on the server.' translated.			resp ~= 1 ifTrue: [^ nil]		].	].	"let's avoid renaming the loaded change set since it will be replacing ours"	self projectParameters at: #loadingNewerVersion put: true.	ComplexProgressIndicator new 		targetMorph: nil;		historyCategory: 'project loading';		withProgressDo: [			ProjectLoading				installRemoteNamed: pair first				from: server				named: self name				in: parentProject		]! !!Project methodsFor: 'file in/out' stamp: 'yo 2/17/2005 15:10'!tryToFindAServerWithMe	| resp primaryServerDirectory |	urlList isEmptyOrNil ifTrue: [urlList _ parentProject urlList copy].	[self primaryServer isNil] whileTrue: [		resp _ (PopUpMenu labels: 'Try to find a server\Cancel' translated withCRs) startUpWithCaption: 					'This project thinks it has never been on a server' translated.		resp ~= 1 ifTrue: [^ nil].		(primaryServerDirectory _ self findAFolderToLoadProjectFrom) ifNil: [^nil].		self storeNewPrimaryURL: primaryServerDirectory downloadUrl.	].	^self primaryServer! !!Project methodsFor: 'SuperSwiki' stamp: 'yo 2/12/2005 19:25'!tellAFriend: emailAddressOrNil	| urlForLoading |"Project current tellAFriend"	(urlForLoading _ self urlForLoading) ifNil: [		urlForLoading _ self url		"fallback for dtp servers"	].	urlForLoading isEmptyOrNil ifTrue: [		^self inform: 'Since this project has not been saved yet,I cannot tell someone where it is.' translated	].	HTTPClient tellAFriend: emailAddressOrNil url: urlForLoading name: self name! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'yo 2/17/2005 15:40'!doNewPainting		| w f |	w _ self world.	w assureNotPaintingElse: [^ self].	(f _ self owner flapTab) ifNotNil: [f hideFlap].	w makeNewDrawing: (self primaryHand lastEvent copy setPosition: w center)! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'yo 2/10/2005 15:42'!doPublishButtonMenuEvent: evt	| menu selection |	menu _ CustomMenu new.	menu 		add: 'Publish' translated action: [self publishProject];		add: 'Publish As...' translated action: [self publishProjectAs];		add: 'Publish to Different Server' translated action: [self publishDifferent];		add: 'edit project info' translated action: [self editProjectInfo].	selection _ menu build startUpCenteredWithCaption: 'Publish options' translated.	selection ifNil: [^self].	selection value.! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'yo 2/17/2005 14:55'!publishProject	self world paintBoxOrNil ifNotNil: [		(self confirm: 'You seem to be painting a sketch.Do you continue and publish the project with the paint tool?' translated) ifFalse: [^ self].	].	self 		publishStyle: #limitedSuperSwikiPublishDirectoryList 		forgetURL: false		withRename: false! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'yo 2/10/2005 15:37'!buttonFind
	"Answer a button for finding/loading projects"

	^ self makeButton: 'FIND' balloonText: 'Click here to find a project.  Hold down this button to reveal additional options.' translated for: #findAProjectSimple
! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'yo 2/10/2005 19:27'!buttonLanguage	"Answer a button for changing the language"	| myButton m |	myButton _ self makeButton: ''		balloonText:  'Click here to choose your language.' translated		for: #chooseLanguage.	myButton addMorph: (m _ self languageIcon asMorph lock).	myButton extent: m extent + (myButton borderWidth + 6).	m position: myButton center - (m extent // 2).	^ myButton! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'yo 2/10/2005 15:42'!buttonPublish
	"Answer a button for publishing the project"

	^ self makeButton: 'PUBLISH IT!!' translated balloonText: 'Click here to save a project.  Hold down this button to reveal additional publishing options' translated for: #publishProject! !!SARInstaller methodsFor: 'client services' stamp: 'tak 1/24/2005 19:12'!installMember: memberOrName	| memberName extension isGraphic stream member |	member _ self memberNamed: memberOrName.	member ifNil: [ ^false ].	memberName _ member fileName.	extension _ (FileDirectory extensionFor: memberName) asLowercase.	Smalltalk at: #CRDictionary ifPresent: [ :crDictionary |		(extension = crDictionary fileNameSuffix) ifTrue: [  self fileInGenieDictionaryNamed: memberName. ^true ] ].	extension caseOf: {		[ Project projectExtension ] -> [ self fileInProjectNamed: memberName createView: true ].		[ FileStream st ] -> [ self fileInPackageNamed: memberName ].		[ FileStream cs ] -> [  self fileInMemberNamed: memberName  ]."		[ FileStream multiSt ] -> [  self fileInMemberNamedAsUTF8: memberName  ].		[ FileStream multiCs ] -> [  self fileInMemberNamedAsUTF8: memberName  ]."		[ 'mc' ] -> [ self fileInMonticelloPackageNamed: memberName ].		[ 'mcv' ] -> [ self fileInMonticelloVersionNamed: memberName ].		[ 'mcz' ] -> [ self fileInMonticelloZipVersionNamed: memberName ].		[ 'morph' ] -> [ self fileInMorphsNamed: member addToWorld: true ].		[ 'ttf' ] -> [ self fileInTrueTypeFontNamed: memberName ].		[ 'translation' ] -> [  self fileInMemberNamed: memberName  ].	} otherwise: [		('t*xt' match: extension) ifTrue: [ self openTextFile: memberName ]			ifFalse: [ stream _ member contentStream.		isGraphic _ ImageReadWriter understandsImageFormat: stream.		stream reset.		isGraphic			ifTrue: [ self openGraphicsFile: member ]			ifFalse: [ "now what?" ^false ]]	].	^true! !!ScriptEditorMorph methodsFor: 'frequency' stamp: 'yo 2/14/2005 13:51'!typeInFrequency	| reply aNumber |	reply _ FillInTheBlank request: 'Number of firings per tick: ' translated initialAnswer: self scriptInstantiation frequency printString.	reply ifNotNil:		[aNumber _ reply asNumber.		aNumber > 0 ifTrue:			[self setFrequencyTo: aNumber]]! !!SecurityManager methodsFor: 'accessing' stamp: 'tak 12/17/2004 14:19'!untrustedUserDirectory	"SecurityManager default untrustedUserDirectory"	| dir |	dir := self primUntrustedUserDirectory.	^ dir		ifNil: [FileDirectory default pathName]		ifNotNil: [(FilePath pathName: dir isEncoded: true) asSqueakPathName]! !!SecurityManager methodsFor: 'private' stamp: 'tak 12/17/2004 14:15'!primUntrustedUserDirectory	"Primitive. Return the untrusted user directory that is the root directory for files that are visible even in restricted mode."	<primitive: 'primitiveGetUntrustedUserDirectory' module: 'SecurityPlugin'>	^ nil! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'yo 1/14/2005 19:43'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addLabelItemsTo: aCustomMenu hand: aHandMorph.	(target isKindOf: BookMorph)		ifTrue:			[aCustomMenu add: 'set page sound' translated action: #setPageSound:.			aCustomMenu add: 'set page visual' translated action: #setPageVisual:]		ifFalse:			[aCustomMenu add: 'change action selector' translated action: #setActionSelector.			aCustomMenu add: 'change arguments' translated action: #setArguments.			aCustomMenu add: 'change when to act' translated action: #setActWhen.			aCustomMenu add: 'change target' translated action: #setTarget.			((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue:				[aCustomMenu add: 'set target' translated action: #setTarget:]].! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'yo 1/14/2005 19:49'!setTarget		| newLabel |	newLabel := FillInTheBlank request: 'Enter an expression that create the target' translated initialAnswer: 'World'.	newLabel isEmpty		ifFalse: [self target: (Compiler evaluate: newLabel)]! !!ScriptableButton methodsFor: 'script' stamp: 'yo 2/10/2005 20:09'!editButtonsScript	"The user has touched my Scriptor halo-handle.  Bring up a Scriptor on the script of the button."	| cardsPasteUp cardsPlayer anEditor |	cardsPasteUp := self pasteUpMorph.	(cardsPlayer := cardsPasteUp assuredPlayer) assureUniClass.	anEditor := scriptSelector ifNil: 					[scriptSelector := cardsPasteUp scriptSelectorToTriggerFor: self.					cardsPlayer newTextualScriptorFor: scriptSelector.					cardsPlayer scriptEditorFor: scriptSelector					]				ifNotNil: 					[(cardsPlayer class selectors includes: scriptSelector) 						ifTrue: [cardsPlayer scriptEditorFor: scriptSelector]						ifFalse: 							["Method somehow got removed; I guess we start afresh"							scriptSelector := nil.							^self editButtonsScript]].	anEditor showingMethodPane ifTrue: [anEditor toggleWhetherShowingTiles].	self currentHand attachMorph: anEditor! !!ScriptableButton methodsFor: 'script' stamp: 'yo 2/10/2005 20:04'!isLikelyRecipientForMouseOverHalos	self player ifNil: [^ false].	self player getHeading = 0.0 ifTrue: [^ false].	^ true.! !!SimpleSliderMorph methodsFor: 'e-toy support' stamp: 'yo 2/10/2005 20:38'!isLikelyRecipientForMouseOverHalos	self player ifNil: [^ false].	self player getHeading = 0.0 ifTrue: [^ false].	^ true.! !!SketchEditorMorph methodsFor: 'e-toy support' stamp: 'yo 2/17/2005 14:31'!wantsHaloFromClick	^ Preferences eToyFriendly not.! !!SketchMorph methodsFor: 'menu' stamp: 'yo 2/12/2005 19:11'!addBorderToShape: evt	| str borderWidth borderedForm r |	str _ FillInTheBlank		request: 'Please enter the desired border width' translated		initialAnswer: '0'.	borderWidth _ Integer readFrom: (ReadStream on: str).	(borderWidth between: 1 and: 10) ifFalse: [^ self].	"Take care of growing appropriately.  Does this lose the reg point?"	borderedForm _ originalForm shapeBorder: Color black width: borderWidth.	r _ borderedForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (borderedForm copy: r).! !!SketchMorph methodsFor: 'menu' stamp: 'yo 2/12/2005 19:08'!recolorPixelsOfColor: evt	"Let the user select a color to be remapped, and then a color to map that color to, then carry it out."	| c d newForm map newC |	self inform: 'choose the color you want to replace' translated.	self changeColorTarget: self selector: #rememberedColor: originalColor: nil hand: evt hand.   "color to replace"	c _ self rememberedColor ifNil: [Color red].	self inform: 'now choose the color you want to replace it with' translated.	self changeColorTarget: self selector:  #rememberedColor: originalColor: c hand: evt hand.  "new color"	newC _ self rememberedColor ifNil: [Color blue].	d _ originalForm depth.	newForm _ Form extent: originalForm extent depth: d.	map _ (Color cachedColormapFrom: d to: d) copy.	map at: (c indexInMap: map) put: (newC pixelValueForDepth: d).	newForm copyBits: newForm boundingBox		from: originalForm at: 0@0		colorMap: map.	self form: newForm.! !!SketchMorph methodsFor: 'menu' stamp: 'yo 2/12/2005 19:11'!reduceColorPalette: evt	"Let the user ask for a reduced number of colors in this sketch"	| str nColors |	str _ FillInTheBlank		request: 'Please enter a number greater than one.(note: this cannot be undone, so answer zeroto abort if you need to make a backup first)' translated		initialAnswer: '256'.	nColors _ Integer readFrom: (ReadStream on: str).	(nColors between: 2 and: 256) ifFalse: [^ self].	originalForm _ originalForm copyWithColorsReducedTo: nColors.	rotatedForm _ nil.	self changed! !!SketchMorph methodsFor: 'menu' stamp: 'yo 2/12/2005 19:04'!setRotationStyle	| selections labels sel reply |	selections _ #(normal leftRight upDown none).	labels _ #('rotate smoothly' 'left-right flip only' 'top-down flip only' 'don''t rotate').	sel _ labels at: (selections indexOf: self rotationStyle ifAbsent:[1]).	labels _ labels collect:[:lbl| sel = lbl ifTrue:['<on>', lbl translated] ifFalse:['<off>', lbl translated]].	reply _ (SelectionMenu labelList: labels selections: selections) startUp.	reply ifNotNil: [self rotationStyle: reply].! !!ColorPickerMorph class methodsFor: 'class initialization' stamp: 'ka 2/19/2005 02:39'!initialize	"ColorPickerMorph initialize"	| formTranslator |	ColorChart _ Color colorPaletteForDepth: 16 extent: 190@60.	DragBox _  (11@0) extent: 9@8.	RevertBox _ (ColorChart width - 20)@1 extent: 9@8.	FeedbackBox _ (ColorChart width - 10)@1 extent: 9@8.	TransparentBox _ DragBox topRight corner: RevertBox bottomLeft.		ColorChart fillBlack: ((DragBox left - 1)@0 extent: 1@9).		ColorChart fillBlack: ((TransparentBox left)@0 extent: 1@9).		ColorChart fillBlack: ((FeedbackBox left - 1)@0 extent: 1@9).		ColorChart fillBlack: ((RevertBox left - 1)@0 extent: 1@9).		(Form dotOfSize: 5) displayOn: ColorChart at: DragBox center + (0@1).	formTranslator := NaturalLanguageFormTranslator localeID: Locale current localeID.	TransText := formTranslator translate: 'translucent'.	TransText		ifNil: [TransText := Form						extent: 63 @ 8						depth: 1						fromArray: #(4194306 1024 4194306 1024 15628058 2476592640								4887714 2485462016 1883804850 2486772764 4756618								2485462016 4748474 1939416064 0 0)						offset: 0 @ 0].	TransText _ ColorForm mappingWhiteToTransparentFrom: TransText! !!JoystickMorph methodsFor: 'menu' stamp: 'yo 2/11/2005 09:16'!chooseJoystickNumber	"Allow the user to select a joystick number"	| result aNumber str |	str := self lastRealJoystickIndex asString.	result := FillInTheBlank 				request: ('Joystick device number (currently {1})' translated format: {str})				initialAnswer: str.	[aNumber := result asNumber] on: Error do: [:err | ^self beep].	(aNumber > 0 and: [aNumber <= 32]) 		ifFalse: 			["???"			^Beeper beep].	realJoystickIndex := aNumber.	self setProperty: #lastRealJoystickIndex toValue: aNumber.	self startStepping! !!JoystickMorph methodsFor: 'menu' stamp: 'yo 2/11/2005 09:19'!joystickNumberString	"Answer a string characterizing the joystick number"	^ 'set real joystick number (now {1})' translated format: {self lastRealJoystickIndex asString}.! !!SparseLargeTable methodsFor: 'accessing' stamp: 'tak 12/21/2004 16:59'!noCheckAt: index	| chunkIndex t |	chunkIndex := index - base // chunkSize + 1.	(chunkIndex > self basicSize or: [chunkIndex < 1]) ifTrue: [^ defaultValue].	t _ self basicAt: chunkIndex.	t ifNil: [^ defaultValue].	^ t at: (index - base + 1 - (chunkIndex - 1 * chunkSize))! !!StrikeFont methodsFor: 'accessing' stamp: 'yo 1/6/2005 04:19'!ascentOf: aCharacter	(self hasGlyphOf: aCharacter) ifFalse: [		fallbackFont ifNotNil: [			^ fallbackFont ascentOf: aCharacter.		].	].	^ self ascent.! !!StrikeFont methodsFor: 'accessing' stamp: 'yo 1/6/2005 04:19'!descentOf: aCharacter	(self hasGlyphOf: aCharacter) ifFalse: [		fallbackFont ifNotNil: [			^ fallbackFont descentOf: aCharacter.		].	].	^ self descent.! !!StrikeFont methodsFor: 'accessing' stamp: 'tak 12/22/2004 01:25'!fallbackFont	^ fallbackFont		ifNil: [fallbackFont _ FixedFaceFont new errorFont fontSize: self height]! !!StrikeFont methodsFor: 'accessing' stamp: 'yo 1/7/2005 11:15'!glyphInfoOf: aCharacter into: glyphInfoArray	"Answer the width of the argument as a character in the receiver."	| code |	(self hasGlyphOf: aCharacter) ifFalse: [		fallbackFont ifNotNil: [			^ fallbackFont glyphInfoOf: aCharacter into: glyphInfoArray.		].		code _ 0.	] ifTrue: [		code _ aCharacter charCode.	].	glyphInfoArray at: 1 put: glyphs;		at: 2 put: (xTable at: code + 1);		at: 3 put: (xTable at: code + 2);		at: 4 put: (self ascentOf: aCharacter);		at: 5 put: self.	^ glyphInfoArray.! !!StrikeFont methodsFor: 'accessing' stamp: 'yo 1/6/2005 04:19'!glyphOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| code |	(self hasGlyphOf: aCharacter) ifFalse: [		fallbackFont ifNotNil: [			^ fallbackFont glyphOf: aCharacter.		].		^ (Form extent: 1@self height) fillColor: Color white	].	code _ aCharacter charCode.	^ glyphs copy: (((xTable at: code + 1)@0) corner: (xTable at: code +2)@self height).! !!StrikeFont methodsFor: 'accessing' stamp: 'yo 1/6/2005 04:19'!heightOf: aCharacter	(self hasGlyphOf: aCharacter) ifFalse: [		fallbackFont ifNotNil: [			^ fallbackFont heightOf: aCharacter.		].	].	^ self height.! !!StrikeFont methodsFor: 'accessing' stamp: 'tak 1/11/2005 18:10'!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| code |	code := aCharacter class == Character				ifTrue: [aCharacter asciiValue]				ifFalse: [aCharacter charCode].	((code < minAscii				or: [maxAscii < code])			or: [(xTable at: code + 1)					< 0])		ifTrue: [^ self fallbackFont widthOf: aCharacter].	^ (xTable at: code + 2)		- (xTable at: code + 1)! !!StrikeFont methodsFor: 'displaying' stamp: 'yo 1/18/2005 16:09'!displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta	| destPoint leftX rightX glyphInfo char displayInfo |	destPoint _ aPoint.	charIndex _ startIndex.	[charIndex <= stopIndex] whileTrue: [		char _ aString at: charIndex.		(self hasGlyphOf: char) not ifTrue: [				displayInfo _ self fallbackFont displayString: aString on: aBitBlt from: charIndex to: stopIndex at: destPoint kern: kernDelta from: self.				charIndex _ displayInfo first.				destPoint _ displayInfo second.		] ifFalse: [			glyphInfo _ self glyphInfoOf: char.			leftX _ glyphInfo second.			rightX _ glyphInfo third.			aBitBlt sourceForm: glyphInfo first.			aBitBlt destX: destPoint x.			aBitBlt destY: destPoint y.			aBitBlt sourceOrigin: leftX @ 0.			aBitBlt width: rightX - leftX.			aBitBlt height: self height.			aBitBlt copyBits.			destPoint _ destPoint + (rightX - leftX + kernDelta @ 0).			charIndex _ charIndex + 1.		].	].	^ Array with: charIndex with: destPoint.! !!StrikeFont methodsFor: 'displaying' stamp: 'yo 1/7/2005 15:16'!displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| destPoint leftX rightX glyphInfo char displayInfo destY |	destPoint _ aPoint.	charIndex _ startIndex.	glyphInfo _ Array new: 5.	[charIndex <= stopIndex] whileTrue: [		char _ aString at: charIndex.		(self hasGlyphOf: char) not ifTrue: [				displayInfo _ self fallbackFont displayString: aString on: aBitBlt from: charIndex to: stopIndex at: destPoint kern: kernDelta from: self baselineY: baselineY.				charIndex _ displayInfo first.				destPoint _ displayInfo second.		] ifFalse: [			self glyphInfoOf: char into: glyphInfo.			leftX _ glyphInfo second.			rightX _ glyphInfo third.			(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [				glyphInfo fifth installOn: aBitBlt.			].			aBitBlt sourceForm: glyphInfo first.			destY _ baselineY - glyphInfo fourth. 			aBitBlt destX: destPoint x.			aBitBlt destY: destY.			aBitBlt sourceOrigin: leftX @ 0.			aBitBlt width: rightX - leftX.			aBitBlt height: self height.			aBitBlt copyBits.			destPoint _ destPoint + (rightX - leftX + kernDelta @ 0).			charIndex _ charIndex + 1.		].	].	^ Array with: charIndex with: destPoint.! !!StrikeFont methodsFor: 'displaying' stamp: 'yo 1/7/2005 12:03'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) BitBlt."		(aString class == MultiString) ifTrue: [^ self displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: aPoint y + self ascent.].	^ aBitBlt displayString: aString 			from: startIndex 			to: stopIndex 			at: aPoint 			strikeFont: self			kern: kernDelta.! !!StrikeFont methodsFor: 'displaying' stamp: 'yo 1/7/2005 15:01'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) BitBlt."		(aString class == MultiString) ifTrue: [^ self displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY.].	^ aBitBlt displayString: aString 			from: startIndex 			to: stopIndex 			at: aPoint 			strikeFont: self			kern: kernDelta.! !!StrikeFont methodsFor: 'displaying' stamp: 'yo 1/5/2005 13:59'!installOn: aDisplayContext	^aDisplayContext installStrikeFont: self.! !!StrikeFont methodsFor: 'displaying' stamp: 'tak 1/11/2005 18:03'!widthOfString: aString from: firstIndex to: lastIndex	| resultX |	resultX _ 0.	firstIndex to: lastIndex do:[:i | 		resultX _ resultX + (self widthOf: (aString at: i))].	^ resultX.! !!StrikeFont methodsFor: 'file in/out' stamp: 'yo 1/19/2005 11:22'!readEFontBDFFromFile: fileName name: aString ranges: ranges	| fontReader stream |	fontReader _ EFontBDFFontReaderForRanges readOnlyFileNamed: fileName.	stream _ ReadStream on: (fontReader readRanges: ranges).	xTable _ stream next.	glyphs _ stream next.	minAscii _ stream next.	maxAscii _ stream next.	maxWidth _ stream next.	ascent _ stream next.	descent _ stream next.	pointSize _ stream next.	name _ aString.	type _ 0. "no one see this"	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	self reset.! !!StrikeFont methodsFor: 'character shapes' stamp: 'BG 12/6/2004 19:22'!ensureCleanBold	"This ensures that all character glyphs have at least one pixel of white space on the right	so as not to cause artifacts in neighboring characters in bold or italic."	| newGlyphs newXTable newGlyphPos startPos newWidth widthOfGlyph increment lastCol |	emphasis = 0 ifFalse: [^ self].    newWidth := glyphs width + maxAscii - minAscii + 1.    lastCol := Form extent: 1@ glyphs height.    newGlyphs := Form extent: newWidth @ glyphs height.    newXTable := Array new: xTable size.    1 to: minAscii do: [:idx | newXTable at: idx put: (xTable at: idx)].       newGlyphPos := startPos := 0.    minAscii to: maxAscii do:      [:idx |          newXTable at: idx + 1 put: newGlyphPos.         widthOfGlyph := (xTable at: idx + 2 ) - (xTable at: idx + 1).         widthOfGlyph > 0           ifTrue:             [newGlyphs copy: (newGlyphPos @ 0 extent: widthOfGlyph @ glyphs height)                          from: startPos@0 in: glyphs rule: Form over.              lastCol copy: (0 @ 0 extent: 1 @ glyphs height)                          from: startPos + widthOfGlyph - 1 @0 in: glyphs rule: Form over.              increment := lastCol isAllWhite ifTrue: [0] ifFalse: [1].              startPos := startPos + widthOfGlyph.              newGlyphPos := newGlyphPos + widthOfGlyph + increment.             ].      ].    maxAscii + 2 to: newXTable size do: [:idx | newXTable at: idx put: newGlyphPos.].    glyphs := Form extent: newGlyphPos @ glyphs height.    glyphs copy: (0 @ 0 extent: glyphs extent)            from: 0@0 in: newGlyphs rule: Form over.    xTable := newXTable."StrikeFont allInstancesDo: [:f | f ensureCleanBold].(StrikeFont familyName: 'NewYork' size: 21) ensureCleanBold.StrikeFont shutDown.  'Flush synthetic fonts'."! !!StrikeFont methodsFor: 'copying' stamp: 'BG 12/9/2004 17:27'!deepCopy " there is a circular reference from the derivative fonts back to the receiver. It is therefore not possible to make a deep copy. We make a sahllow copy. The method postCopy can be used to modify the shallow copy. "   ^self copy! !!StrikeFont methodsFor: 'copying' stamp: 'BG 12/9/2004 17:35'!postCopy " the receiver is a just created shallow copy. This method gives it the final touch. "      glyphs := glyphs copy.    xTable := xTable copy.    characterToGlyphMap := characterToGlyphMap copy.     self reset.  " takes care of the derivative fonts "! !!StrikeFont methodsFor: 'private' stamp: 'BG 11/26/2004 16:18'!createCharacterToGlyphMap	"Private. Create the character to glyph mapping for a font that didn't have any before. This is basically equivalent to what the former setStopCondition did, only based on indexes."	| map |	map _ Array new: maxAscii + 1.	0 to: minAscii - 1 do:[:i| map at: i + 1 put: maxAscii + 1].	minAscii to: maxAscii do:[:i| map at: i + 1 put: i].	maxAscii + 1 to: 255 do:[:i| map at: i + 1 put: maxAscii + 1].	^map! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 1/6/2005 04:18'!hasGlyphOf: aCharacter	| code |	code _ aCharacter charCode.	((code between: self minAscii and: self maxAscii) not) ifTrue: [		^ false.	].	(xTable at: code + 1) < 0 ifTrue: [		^ false.	].	^ true.! !!HostFont methodsFor: 'accessing' stamp: 'yo 1/7/2005 12:03'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	^ self displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: aPoint y + self ascent.! !!HostFont methodsFor: 'accessing' stamp: 'yo 1/7/2005 15:14'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY 	^ super displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY.! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 1/19/2005 11:22'!newFromEFontBDFFile: fileName name: aString ranges: ranges	| n |	n _ self new.	n readEFontBDFFromFile: fileName name: aString ranges: ranges.	^ n.! !!StrikeFont class methodsFor: 'instance creation' stamp: 'tak 12/20/2004 10:23'!passwordFontSize: aSize 	^ FixedFaceFont new passwordFont fontSize: aSize! !!StrikeFont class methodsFor: 'accessing' stamp: 'tak 11/11/2004 21:14'!setupDefaultFallbackFont"	StrikeFont setupDefaultFallbackFont"	(#(#Accuat #Accujen #Accula #Accumon #Accusf #Accushi #Accuve #Atlanta) collect: [:e | TextStyle named: e]) do: [:style |		style fontArray do: [:e |			e reset.			e setupDefaultFallbackFont.		].	].	TTCFont allSubInstances		do: [:font | font reset.			font setupDefaultFallbackFont]! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'tak 12/16/2004 19:15'!initializeWithFontArray: anArray 	"Initialize with given font array, the ascent of primary font is modified 	if another font has higher size"	| primaryFont maxHeight newFont |	fontArray := anArray.	primaryFont := anArray first.	emphasis := 0.	name := primaryFont name.	maxHeight := anArray				inject: 0				into: [:theHeight :font | (font notNil							and: [theHeight < font height])						ifTrue: [font height]						ifFalse: [theHeight]].	primaryFont height < maxHeight		ifTrue: [newFont := primaryFont copy						fixAscent: primaryFont ascent + (maxHeight - primaryFont height)						andDescent: primaryFont descent						head: 0.			fontArray at: 1 put: newFont].	self reset! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 1/5/2005 13:59'!installOn: aDisplayContext	^ aDisplayContext installStrikeFont: self.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'tak 1/11/2005 17:29'!widthOfString: aString	aString ifNil:[^0].	"Optimizing"	(aString isKindOf: String) ifTrue: [		^ self fontArray first widthOfString: aString from: 1 to: aString size].	^ self widthOfString: aString from: 1 to: aString size."	TextStyle default defaultFont widthOfString: 'zort' 21"! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'tak 1/11/2005 17:59'!widthOfString: aString from: startIndex to: stopIndex	"Measure the length of the given string between start and stop index"	| resultX |	resultX _ 0.	startIndex to: stopIndex do:[:i | 		resultX _ resultX + (self widthOf: (aString at: i))].	^ resultX.! !!StrikeFontSet methodsFor: 'accessing' stamp: 'tak 12/21/2004 16:43'!latin1	"Answer primary font"	^ fontArray at: 1! !!StrikeFontSet methodsFor: 'accessing' stamp: 'tak 1/11/2005 15:49'!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	"1: optimizing"	| encoding f |	aCharacter class == Character		ifTrue: [^ (fontArray at: 1)				widthOf: aCharacter].	"2: other case"	encoding := aCharacter leadingChar + 1.	f := ((((aCharacter isMemberOf: Character) not							and: [encoding > 1])						and: [encoding <= fontArray size])					and: [(fontArray at: encoding) notNil])				ifTrue: [fontArray at: encoding]				ifFalse: [self latin1].	^ f widthOf: aCharacter! !!StrikeFontSet methodsFor: 'displaying' stamp: 'yo 1/7/2005 12:04'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	^ self displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: aPoint y + self ascent.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'yo 1/7/2005 15:16'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| destPoint leftX rightX glyphInfo g destY |	destPoint _ aPoint.	glyphInfo _ Array new: 5.	startIndex to: stopIndex do: [:charIndex |		self glyphInfoOf: (aString at: charIndex) into: glyphInfo.		g _ glyphInfo first.		leftX _ glyphInfo second.		rightX _ glyphInfo third.		(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [			glyphInfo fifth installOn: aBitBlt.		].		aBitBlt sourceForm: g.		destY _ baselineY - glyphInfo fourth. 		aBitBlt destX: destPoint x.		aBitBlt destY: destY.		aBitBlt sourceOrigin: leftX @ 0.		aBitBlt width: rightX - leftX.		aBitBlt height: self height.		aBitBlt copyBits.		destPoint _ destPoint + (rightX - leftX + kernDelta @ 0).	].	^ destPoint.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'yo 1/18/2005 16:09'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta from: fromFont	| destPoint leftX rightX glyphInfo g tag char deltaY |	destPoint _ aPoint.	rIndex _ startIndex.	tag _ (aString at: rIndex) leadingChar.	"aPoint printString displayAt: 0@0."	[rIndex <= stopIndex] whileTrue: [		char _ aString at: rIndex.		((fromFont hasGlyphOf: char) or: [char leadingChar ~= tag]) ifTrue: [^ Array with: rIndex with: destPoint].		glyphInfo _ self glyphInfoOf: char.		g _ glyphInfo first.		"TODO: computation of deltaY should be on sender"		deltaY _ fromFont ascent - self ascent.		leftX _ glyphInfo second.		rightX _ glyphInfo third.		aBitBlt sourceForm: g.		aBitBlt destX: destPoint x.		aBitBlt destY: destPoint y + deltaY.		aBitBlt sourceOrigin: leftX @ 0.		aBitBlt width: rightX - leftX.		aBitBlt height: self height.		aBitBlt copyBits.		destPoint _ destPoint + (rightX - leftX + kernDelta @ 0).		rIndex _ rIndex + 1.	].	^ Array with: rIndex with: destPoint.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'yo 1/7/2005 15:17'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta from: fromFont baselineY: baselineY	| destPoint leftX rightX glyphInfo g tag char destY |	destPoint _ aPoint.	rIndex _ startIndex.	tag _ (aString at: rIndex) leadingChar.	glyphInfo _ Array new: 5.	[rIndex <= stopIndex] whileTrue: [		char _ aString at: rIndex.		((fromFont hasGlyphOf: char) or: [char leadingChar ~= tag]) ifTrue: [^ Array with: rIndex with: destPoint].		self glyphInfoOf: char into: glyphInfo.		g _ glyphInfo first.		leftX _ glyphInfo second.		rightX _ glyphInfo third.		(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [			glyphInfo fifth installOn: aBitBlt.		].		aBitBlt sourceForm: g.		destY _ baselineY - glyphInfo fourth. 		aBitBlt destX: destPoint x.		aBitBlt destY: destY.		aBitBlt sourceOrigin: leftX @ 0.		aBitBlt width: rightX - leftX.		aBitBlt height: self height.		aBitBlt copyBits.		destPoint _ destPoint + (rightX - leftX + kernDelta @ 0).		rIndex _ rIndex + 1.	].	^ Array with: rIndex with: destPoint.! !!StrikeFontSet methodsFor: 'private' stamp: 'yo 1/7/2005 11:16'!glyphInfoOf: aCharacter into: glyphInfoArray	| index f code leftX |	index _ aCharacter leadingChar + 1.	fontArray size < index ifTrue: [^ self questionGlyphInfoInto: glyphInfoArray].	(f _ fontArray at: index) ifNil: [^ self questionGlyphInfoInto: glyphInfoArray].	code _ aCharacter charCode.	((code between: f minAscii and: f maxAscii) not) ifTrue: [		^ self questionGlyphInfoInto: glyphInfoArray.	].	leftX _ f xTable at: code + 1.	leftX < 0 ifTrue: [		^ self questionGlyphInfoInto: glyphInfoArray.	].	glyphInfoArray at: 1 put: f glyphs;		at: 2 put: leftX;		at: 3 put: (f xTable at: code + 2);		at: 4 put: (f ascentOf: aCharacter);		at: 5 put: self.	^ glyphInfoArray.! !!StrikeFontSet methodsFor: 'private' stamp: 'yo 1/13/2005 16:43'!questionGlyphInfoInto: glyphInfoArray	| f ascii |	f _ fontArray at: 1.	ascii _ $? asciiValue.	glyphInfoArray at: 1 put: f glyphs;		at: 2 put: (f xTable at: ascii + 1);		at: 3 put: (f xTable at: ascii + 2);		at: 4 put: (self ascentOf: $?);		at: 5 put: self.	^ glyphInfoArray.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 1/19/2005 11:25'!createExternalFontFileForLatin2: fileName"	StrikeFontSet createExternalFontFileForLatin2: 'latin2.out'."	| file array f installDirectory |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array _ Array				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b10.bdf' name: 'LatinTwo9' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'LatinTwo10' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'LatinTwo12' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'LatingTwo14' ranges: EFontBDFFontReaderForRanges rangesForLatin2)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'LatinTwo20' ranges: EFontBDFFontReaderForRanges rangesForLatin2).	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 5/25/2004 11:05'!createExternalFontFileForUnicodeJapanese: fileName"	StrikeFontSet createExternalFontFileForUnicodeJapanese: 'uJapaneseFont.out'."	| file array f installDirectory |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array _ Array				with: (StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'Japanese10' overrideWith: 'shnmk12.bdf')				with: ((StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'Japanese12' overrideWith: 'shnmk14.bdf') "fixAscent: 14 andDescent: 1 head: 1")				with: ((StrikeFont newForJapaneseFromEFontBDFFile: 'b16.bdf' name: 'Japanese14' overrideWith: 'shnmk16.bdf') "fixAscent: 16 andDescent: 4 head: 4")				with: (StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'Japanese18' overrideWith: 'kanji24.bdf').	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 1/18/2005 16:00'!installExternalFontFileName6: fileName encoding: encoding encodingName: aString textStyleName: styleName	^ self installExternalFontFileName6: fileName inDir: FileDirectory default encoding: encoding encodingName: aString textStyleName: styleName."StrikeFontSet createExternalFontFileForCyrillic: 'cyrillicFont.out'.StrikeFontSet installExternalFontFileName6: 'latin2.out' encoding: Latin2Environment leadingChar encodingName: #Latin2 textStyleName: #DefaultMultiStyle.StrikeFontSet installExternalFontFileName6: 'uJapaneseFont.out' encoding: JapaneseEnvironment leadingChar encodingName: #Japanese textStyleName: #DefaultMultiStyle.StrikeFontSet installExternalFontFileName6: 'uKoreanFont.out' encoding: UnicodeKorean leadingChar encodingName: #Korean textStyleName: #DefaultMultiStyle.StrikeFontSet removeFontsForEncoding: 2 encodingName: #Gb2312.self halt.StrikeFontSet removeFontsForEncoding: 3 encodingName: #KsX1001."! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'tak 12/16/2004 21:03'!installExternalFontFileName6: fileName inDir: dir encoding: encoding encodingName: aString textStyleName: styleName	| array fonts encodingIndex textStyle |	array _ (ReferenceStream on: (dir readOnlyFileNamed: fileName)) next.	TextConstants at: aString asSymbol put: array.	textStyle _ TextConstants at: styleName asSymbol.	encodingIndex _ encoding + 1.	textStyle fontArray do: [:fs |		fonts _ fs fontArray.		encodingIndex > fonts size			ifTrue: [fonts _  (Array new: encodingIndex)				replaceFrom: 1 to: fonts size with: fonts startingAt: 1].		fonts at: encodingIndex put: (self findMaximumLessThan: fs fontArray first in: array).		fs initializeWithFontArray: fonts.	].! !!String methodsFor: 'converting' stamp: 'H.Hachisuka 12/10/2004 22:34'!convertFromSuperSwikiServerString	^self convertFromWithConverter: (TextConverter newForEncoding: 'shift_jis')! !!String methodsFor: 'converting' stamp: 'H.Hachisuka 12/10/2004 22:35'!convertToSuperSwikiServerString	^self.! !!SuperSwikiServer methodsFor: 'for real' stamp: 'H.Hachisuka 12/10/2004 22:35'!fastParseEntriesFrom: aString	| c first strm xEntryName xCreationTime xModificationTime xIsDirectory xFileSize ch |	c _ OrderedCollection new.	first _ true.	aString linesDo: [ :x |		first ifFalse: [			strm _ ReadStream on: x.			(strm upTo: $ ) = '(DirectoryEntry' ifFalse: [^nil].			(strm upTo: $ ) = 'name:' ifFalse: [^nil].			xEntryName _ WriteStream on: String new.			strm next = $' ifFalse: [^nil].			[				ch _ strm next.				ch = $' and: [(strm peekFor: $') not]			] whileFalse: [				xEntryName nextPut: ch.			].			xEntryName _ xEntryName contents.			strm skipSeparators.			(strm upTo: $ ) = 'creationTime:' ifFalse: [^nil].			xCreationTime _ (strm upTo: $ ) asNumber.			(strm upTo: $ ) = 'modificationTime:' ifFalse: [^nil].			xModificationTime _ (strm upTo: $ ) asNumber.			(strm upTo: $ ) = 'isDirectory:' ifFalse: [^nil].			xIsDirectory _ (strm upTo: $ ) = 'true'.			(strm upTo: $ ) = 'fileSize:' ifFalse: [^nil].			xFileSize _ (strm upTo: $ ) asNumber.			c add: (DirectoryEntry 				name: xEntryName convertFromSuperSwikiServerString				creationTime: xCreationTime 				modificationTime: xModificationTime 				isDirectory: xIsDirectory 				fileSize: xFileSize			)		].		first _ false.	].	^c! !!SuperSwikiServer methodsFor: 'for real' stamp: 'H.Hachisuka 12/10/2004 22:36'!oldFileNamed: aName	| answer |	answer _ self sendToSwikiProjectServer: {		'action: readnamedfile'.		'projectname: ',aName convertToSuperSwikiServerString.	}.	(answer beginsWith: 'OK') ifFalse: [ ^nil].	^(SwikiPseudoFileStream with: (answer allButFirst: 3))		reset;		directory: self;		localName: aName convertToSuperSwikiServerString;		yourself! !!SuperSwikiServer methodsFor: 'for real' stamp: 'H.Hachisuka 12/10/2004 22:37'!putFile: fileStream named: fileNameOnServer		^(		self sendToSwikiProjectServer: {			'uploadproject: ',fileNameOnServer convertToSuperSwikiServerString.			'password: ',ProjectPasswordNotification signal.			fileStream contentsOfEntireFile.		}	) beginsWith: 'OK'! !!SuperSwikiServer methodsFor: 'for real' stamp: 'H.Hachisuka 12/10/2004 22:36'!updateProjectInfoFor: aProject	| data details projectLinks linkString uploader |	data _ OrderedCollection new.	data add: 'action: updatepage'.	data add: 'password: ',ProjectPasswordNotification signal.	data add: 'projectimage: ',aProject name convertToSuperSwikiServerString,'.gif'.	uploader _ Utilities authorNamePerSe.	uploader isEmptyOrNil ifTrue: [uploader _ Utilities authorInitialsPerSe].	uploader isEmptyOrNil ifFalse: [		data add: 'submittedBy: ',uploader convertToSuperSwikiServerString.	].	projectLinks _ Set new.	aProject world allMorphsDo: [ :each |		(each isKindOf: ProjectViewMorph) ifTrue: [			projectLinks add: each safeProjectName.		].	].	details _ aProject world valueOfProperty: #ProjectDetails ifAbsent: [Dictionary new].	details at: 'projectname' ifAbsentPut: [aProject name].	projectLinks isEmpty ifTrue: [		details removeKey: 'projectlinks' ifAbsent: []	] ifFalse: [		linkString _ String streamContents: [ :strm |			projectLinks asSortedCollection do: [ :each |				strm nextPutAll: each			] separatedBy: [				strm nextPut: $.			].		].		details at: 'projectlinks' put: linkString	].	details keysAndValuesDo: [ :k :v |		data add: k , ': ' , (v convertToSuperSwikiServerString). self flag: #yoFlag.	].	^self sendToSwikiProjectServer: data.! !!SuperSwikiServer methodsFor: 'squeaklets' stamp: 'ka 1/2/2005 21:56'!upLoadProject: projectName members: archiveMembers retry: aBool	| answer |	archiveMembers do:[:entry|		ProgressNotification signal: '4:uploadingFile' extra:'(uploading ' translated, entry fileName convertFromSystemString , '...)' translated.		answer _ self sendToSwikiProjectServer: {			'uploadproject2: ', entry fileName convertFromSystemString convertToSuperSwikiServerString.			'password: ',ProjectPasswordNotification signal.			entry contents.		}.		answer = 'OK' ifFalse:[			self inform:'Server responded ' translated, answer.			^false].	].	ProgressNotification signal: '4:uploadingFile' extra:''.	^true! !!SyntaxError methodsFor: 'initialization' stamp: 'tak 11/16/2004 14:58'!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	| types printables badChar |	class _ aClass.	debugger _ aDebugger.	selector _ aClass parserClass new parseSelector: aString.	types _ Scanner classPool at: #TypeTable.	"dictionary"	printables _ '!!@#$%&*-_=+<>{}?/\,·£¢§¶ªºÚæÚ¯×¿«»`~`' asSet.	badChar _ aString detect: [:aChar | (types at: aChar asciiValue ifAbsent: [#xLetter]) == #xBinary and: [			(printables includes: aChar) not]] ifNone: [nil].	contents _ badChar 		ifNil: [aString]		ifNotNil: ['<<<This string contains a character (ascii value ', 			badChar asciiValue printString,			') that is not normally used in code>>> ', aString].	category ifNil: [category _ aClass organization categoryOfElement: selector].	category ifNil: [category _ ClassOrganizer default].	doitFlag _ flag! !!SystemDictionary methodsFor: 'squeakland' stamp: 'tak 2/15/2005 12:03'!makeSqueaklandReleasePhaseFinalSettings	"Smalltalk makeSqueaklandReleasePhaseFinalSettings"	| serverName serverURL serverDir updateServer highestUpdate newVersion |	ProjectLauncher splashMorph: ((FileDirectory default directoryNamed: 'scripts' )readOnlyFileNamed: 'SqueaklandSplash.morph') fileInObjectAndCode.	"Dump all morphs so we don't hold onto anything"	World submorphsDo:[:m| m delete].	#(		(honorDesktopCmdKeys false)		(warnIfNoChangesFile false)		(warnIfNoSourcesFile false)		(showDirectionForSketches true)		(menuColorFromWorld false)		(unlimitedPaintArea true)		(useGlobalFlaps false)		(mvcProjectsAllowed false)		(projectViewsInWindows false)		(automaticKeyGeneration true)		(securityChecksEnabled true)		(showSecurityStatus false)		(startInUntrustedDirectory true)		(warnAboutInsecureContent false)		(promptForUpdateServer false)		(fastDragWindowForMorphic false)		(externalServerDefsOnly true)		(expandedFormat false)		(allowCelesteTell false)		(eToyFriendly true)		(eToyLoginEnabled true)		(magicHalos true)		(mouseOverHalos true)		(biggerHandles false)		(selectiveHalos true)		(includeSoundControlInNavigator true)		(readDocumentAtStartup true)		(preserveTrash true)		(slideDismissalsToTrash true)	) do:[:spec|		Preferences setPreference: spec first toValue: spec last].	"Workaround for bug"	Preferences enable: #readDocumentAtStartup.	World color: (Color r: 0.9 g: 0.9 b: 1.0).	"Clear all server entries"	ServerDirectory serverNames do: [:each | ServerDirectory removeServerNamed: each].	SystemVersion current resetHighestUpdate.	"Add the squeakalpha update stream"	serverName _ 'Squeakalpha'.	serverURL _ 'squeakalpha.org'.	serverDir _ serverURL , '/'.	updateServer _ ServerDirectory new.	updateServer		server: serverURL;		directory: 'updates/';		altUrl: serverDir;		user: 'sqland';		password: nil.	Utilities updateUrlLists addFirst: {serverName. {serverDir. }.}.	"Add the squeakland update stream"	serverName _ 'Squeakland'.	serverURL _ 'squeakland.org'.	serverDir _ serverURL , '/'.	updateServer _ ServerDirectory new.	updateServer		server: serverURL;		directory: 'public_html/updates/';		altUrl: serverDir.	Utilities updateUrlLists addFirst: {serverName. {serverDir. }.}.	highestUpdate _ SystemVersion current highestUpdate.	(self confirm: 'Reset highest update (' , highestUpdate printString , ')?')		ifTrue: [SystemVersion current highestUpdate: 0].	newVersion _ FillInTheBlank request: 'New version designation:' initialAnswer: 'Squeakland 3.8.' , highestUpdate printString. 	SystemVersion newVersion: newVersion.	(self confirm: self version , 'Is this the correct version designation?If not, choose no, and fix it.') ifFalse: [^ self].! !!SystemNavigation methodsFor: '*Multilingual-Editor' stamp: 'sd 12/18/2004 18:17'!allSelect: aBlock 	"Answer a SortedCollection of each method that, when used as 	the block  	argument to aBlock, gives a true result."	| aCollection |	aCollection := SortedCollection new.	Cursor execute		showWhile: [self				allBehaviorsDo: [:class | class						selectorsDo: [:sel | (aBlock									value: (class compiledMethodAt: sel))								ifTrue: [aCollection add: class name , ' ' , sel]]]].	^ aCollection! !!SystemWindow methodsFor: 'initialization' stamp: 'yo 2/12/2005 19:21'!createCollapseBox	^ self createBox labelGraphic: self class collapseBoxImage;		 extent: self boxExtent;		 actionSelector: #collapseOrExpand;		 setBalloonText: 'collapse this window' translated.! !!SystemWindow methodsFor: 'label' stamp: 'yo 2/17/2005 17:52'!relabel	| newLabel |	newLabel _ FillInTheBlank 		request: 'New title for this window' translated		initialAnswer: labelString.	newLabel isEmpty ifTrue: [^self].	(model windowReqNewLabel: newLabel)		ifTrue: [self setLabel: newLabel]! !!LanguageEditor methodsFor: 'accessing' stamp: 'dgd 8/24/2003 19:13'!selectedTranslation	"answer the selectedTranslation"	^ selectedTranslation! !!LanguageEditor methodsFor: 'accessing' stamp: 'dgd 8/24/2003 21:56'!selectedTranslation: anInteger 	"change the receiver's selectedTranslation"	selectedTranslation := anInteger.	""	self changed: #selectedTranslation.	self changed: #translation! !!LanguageEditor methodsFor: 'accessing' stamp: 'tak 11/28/2004 14:12'!selectedTranslationsAt: index	^ selectedTranslations includes: index! !!LanguageEditor methodsFor: 'accessing' stamp: 'tak 11/28/2004 14:15'!selectedTranslationsAt: index put: value 	value = true		ifTrue: [selectedTranslations add: index]		ifFalse: [selectedTranslations				remove: index				ifAbsent: []]! !!LanguageEditor methodsFor: 'accessing' stamp: 'dgd 8/24/2003 21:57'!selectedUntranslated	"answer the selectedUntranslated"	^ selectedUntranslated! !!LanguageEditor methodsFor: 'accessing' stamp: 'dgd 8/24/2003 21:57'!selectedUntranslated: anInteger 	"change the selectedUntranslated"	selectedUntranslated := anInteger.	""	self changed: #selectedUntranslated! !!LanguageEditor methodsFor: 'accessing' stamp: 'mir 8/11/2004 10:00'!translation	"answer the translation for the selected phrase"	self selectedTranslation isZero		ifTrue: [^ '<select a phrase from the upper list>' translated].	""	^ self translator		translationFor: (self translations at: self selectedTranslation)! !!LanguageEditor methodsFor: 'accessing' stamp: 'tak 11/16/2004 14:44'!translation: aStringOrText 	"change the translation for the selected phrase"	self selectedTranslation isZero		ifTrue: [^ self].	translator		phrase: (self translations at: self selectedTranslation)		translation: aStringOrText asString.	^ true! !!LanguageEditor methodsFor: 'accessing' stamp: 'mir 8/11/2004 10:00'!translations	"answet the translator's translations"	| allTranslations filterString |	allTranslations := self translator translations keys.	""	filterString := self translationsFilter.	""	filterString isEmpty		ifFalse: [allTranslations := allTranslations						select: [:each | ""							('*' , filterString , '*' match: each)								or: ['*' , filterString , '*'										match: (self translator translationFor: each)]]].""	^ allTranslations asSortedCollection! !!LanguageEditor methodsFor: 'accessing' stamp: 'dgd 9/21/2003 12:00'!translationsFilter^translationsFilter ifNil:['']! !!LanguageEditor methodsFor: 'accessing' stamp: 'mir 8/11/2004 10:00'!untranslated	"answer the translator's untranslated phrases"	| all filterString |	all := self translator untranslated.	""	filterString := self untranslatedFilter.	""	filterString isEmpty		ifFalse: [all := all						select: [:each | ""							('*' , filterString , '*' match: each)								or: ['*' , filterString , '*'										match: (self translator translationFor: each)]]].	""	^ all asSortedCollection! !!LanguageEditor methodsFor: 'accessing' stamp: 'dgd 9/21/2003 12:19'!untranslatedFilter	^ untranslatedFilter		ifNil: ['']! !!LanguageEditor methodsFor: 'initialization' stamp: 'tak 11/28/2004 14:10'!initializeOn: aLanguage 	"initialize the receiver on aLanguage"	""	selectedTranslation := 0.	selectedUntranslated := 0.	selectedTranslations := IdentitySet new.	""	translator := aLanguage.	""	self setLabel: 'Language editor for: ' translated , self translator name.	""	self initializeToolbars.	self initializePanels.	self initializeStatusbar! !!LanguageEditor methodsFor: 'initialization' stamp: 'tak 11/28/2004 14:12'!initializePanels	"initialize the receiver's panels"	translationsList := PluggableListMorphOfMany				on: self				list: #translations				primarySelection: #selectedTranslation				changePrimarySelection: #selectedTranslation:				listSelection: #selectedTranslationsAt:				changeListSelection: #selectedTranslationsAt:put:				menu: #translationsMenu:				keystroke: #translationsKeystroke:.	translationsList setBalloonText: 'List of all the translated phrases.' translated.	""	untranslatedList := PluggableListMorph				on: self				list: #untranslated				selected: #selectedUntranslated				changeSelected: #selectedUntranslated:				menu: #untranslatedMenu:				keystroke: #untranslatedKeystroke:.	untranslatedList setBalloonText: 'List of all the untranslated phrases.' translated.	""	translationText := PluggableTextMorph				on: self				text: #translation				accept: #translation:				readSelection: nil				menu: nil.	translationText setBalloonText: 'Translation for the selected phrase in the upper list.' translated.	""	self		addMorph: translationsList		frame: (0 @ 0.18 corner: 0.5 @ 0.66).	self		addMorph: untranslatedList		frame: (0.5 @ 0.18 corner: 1 @ 0.93).	self		addMorph: translationText		frame: (0 @ 0.66 corner: 0.5 @ 0.93)! !!LanguageEditor methodsFor: 'initialization - statusbar' stamp: 'tak 11/15/2004 12:15'!createStatusbar	"create the statusbar for the receiver"	| statusbar |	statusbar := self createRow.	statusbar addMorph: ((UpdatingStringMorph on: self selector: #status) growable: true;			 useStringFormat;			 hResizing: #spaceFill;			 stepTime: 2000).	^ statusbar! !!LanguageEditor methodsFor: 'initialization - statusbar' stamp: 'dgd 9/21/2003 11:39'!initializeStatusbar	"initialize the receiver's statusbar"	self		addMorph: self createStatusbar		frame: (0 @ 0.93 corner: 1 @ 1)! !!LanguageEditor methodsFor: 'gui methods' stamp: 'yo 2/17/2005 18:23'!addTranslation	"translate a phrase"	| phrase |	phrase := FillInTheBlank				request: 'enter the original:'				initialAnswer: ''.	(phrase isNil			or: [phrase = ''])		ifTrue: [""			self beep.			^ self].	""	self translatePhrase: phrase! !!LanguageEditor methodsFor: 'gui methods' stamp: 'mir 7/21/2004 16:55'!applyTranslations	"private - try to apply the translations as much as possible all  	over the image"	Project current updateLocaleDependents! !!LanguageEditor methodsFor: 'gui methods' stamp: 'yo 7/30/2004 22:25'!browseMethodsWithTranslation	| translation |	self selectedTranslation isZero		ifTrue: [""			self beep.			self inform: 'select the translation to look for' translated.			^ self].	""	translation := self translations at: self selectedTranslation.	self systemNavigation browseMethodsWithLiteral: translation! !!LanguageEditor methodsFor: 'gui methods' stamp: 'yo 7/13/2004 10:19'!browseMethodsWithUntranslated	| untranslated |	self selectedUntranslated isZero		ifTrue: [""			self beep.			self inform: 'select the untranslated phrase to look for' translated.			^ self].	""	untranslated := self untranslated at: self selectedUntranslated.	SystemNavigation default browseMethodsWithLiteral: untranslated.! !!LanguageEditor methodsFor: 'gui methods' stamp: 'tak 11/28/2004 15:01'!codeSelectedTranslation	| keys code |	keys := selectedTranslations				collect: [:key | self translations at: key].	code := String				streamContents: [:aStream | self translator fileOutOn: aStream keys: keys].	(StringHolder new contents: code)		openLabel: 'exported codes'! !!LanguageEditor methodsFor: 'gui methods' stamp: 'tak 11/28/2004 14:27'!deselectAllTranslation	selectedTranslations := IdentitySet new.	self changed: #allSelections! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 9/21/2003 12:14'!filterTranslations	| filter |	filter := FillInTheBlank request: 'filter with(empty string means no-filtering)' translated initialAnswer: self translationsFilter.	""	self filterTranslations: filter! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 9/21/2003 12:12'!filterTranslations: aString | filter |filter := aString ifNil:[''].""	translationsFilter _ filter.self update: #translations.! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 9/21/2003 12:20'!filterUntranslated	| filter |	filter := FillInTheBlank request: 'filter with(empty string means no-filtering)' translated initialAnswer: self untranslatedFilter.	""	self filterUntranslated: filter! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 9/21/2003 12:20'!filterUntranslated: aString 	| filter |	filter := aString				ifNil: [''].	""	untranslatedFilter := filter.	self update: #untranslated! !!LanguageEditor methodsFor: 'gui methods' stamp: 'tak 1/4/2005 09:24'!getTextExport	(Smalltalk at: #GetTextExporter) new export: self model! !!LanguageEditor methodsFor: 'gui methods' stamp: 'mir 8/11/2004 09:56'!loadFromFile	| fileName |	fileName := self selectTranslationFileName.	fileName isNil		ifTrue: [""			self beep.			^ self].	""	Cursor wait		showWhile: [			self translator loadFromFileNamed: fileName.			self changed: #translations.			self changed: #untranslated]! !!LanguageEditor methodsFor: 'gui methods' stamp: 'mir 8/11/2004 09:56'!mergeFromFile	| fileName |	fileName := self selectTranslationFileName.	fileName isNil		ifTrue: [""			self beep.			^ self].	""	Cursor wait		showWhile: [			self translator loadFromFileNamed: fileName.			self changed: #translations.			self changed: #untranslated]! !!LanguageEditor methodsFor: 'gui methods' stamp: 'mir 8/11/2004 09:59'!phrase: phraseString translation: translationString 	"set the models's translation for phraseString"	self translator phrase: phraseString translation: translationString.	self changed: #translations.	self changed: #untranslated.! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 8/24/2003 21:53'!phraseToTranslate	"answer a phrase to translate.  use the selected untranslated phrase or ask for a new one"	^ self selectedUntranslated isZero		ifTrue: [FillInTheBlank				multiLineRequest: 'new phrase to translate' translated				centerAt: Sensor cursorPoint				initialAnswer: ''				answerHeight: 200]		ifFalse: [self untranslated at: self selectedUntranslated]! !!LanguageEditor methodsFor: 'gui methods' stamp: 'yo 1/14/2005 18:00'!removeTranslation	"remove the selected translation"	| translation |	self selectedTranslation isZero		ifTrue: [""			self beep.			self inform: 'select the translation to remove' translated.			^ self].	""	translation := self translations at: self selectedTranslation.""	(self			confirm: ('Removing "{1}".Are you sure you want to do this?' translated format: {translation}))		ifFalse: [^ self].""	self translator removeTranslationFor: translation.	self changed: #translations.	self changed: #untranslated.! !!LanguageEditor methodsFor: 'gui methods' stamp: 'mir 8/11/2004 09:59'!removeUntranslated	"remove the selected untranslated phrase"	| untranslated |	self selectedUntranslated isZero		ifTrue: [""			self beep.			self inform: 'select the untranslated phrase to remove' translated.			^ self].	""	untranslated := self untranslated at: self selectedUntranslated.	""	(self			confirm: ('Removing "{1}".Are you sure you want to do this?' translated format: {untranslated}))		ifFalse: [^ self].	""	self translator removeUntranslated: untranslated! !!LanguageEditor methodsFor: 'gui methods' stamp: 'mir 7/21/2004 19:27'!report	self reportString openInWorkspaceWithTitle: 'report' translated! !!LanguageEditor methodsFor: 'gui methods' stamp: 'tak 11/9/2004 18:39'!saveToFile	"save the translator to a file"	| fileName |	fileName := FillInTheBlank request: 'file name' translated initialAnswer: translator localeID isoString , '.translation'.	(fileName isNil			or: [fileName isEmpty])		ifTrue: [""			self beep.			^ self].	""Cursor wait		showWhile: [	self translator saveToFileNamed: fileName]! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 8/24/2003 22:40'!searchTranslation	| search |	search := FillInTheBlank request: 'search for' translated initialAnswer: ''.	(search isNil			or: [search isEmpty])		ifTrue: [""			self beep.			^ self].""self searchTranslation: search! !!LanguageEditor methodsFor: 'gui methods' stamp: 'mir 8/11/2004 10:00'!searchTranslation: aString 	| translations results index |	translations := self translations.	results := translations				select: [:each | ""					('*' , aString , '*' match: each)						or: ['*' , aString , '*' match: (self translator translationFor: each)]].	""	results isEmpty		ifTrue: [""			self inform: 'no matches for' translated , ' ''' , aString , ''''.			^ self].	""	results size = 1		ifTrue: [""			self selectTranslationPhrase: results first.			^ self].	""	index := (PopUpMenu				labelArray: (results						collect: [:each | ""							(each copy replaceAll: Character cr with: $\)								, ' -> '								, ((self translator translationFor: each) copy replaceAll: Character cr with: $\)]))				startUpWithCaption: 'select the translation...' translated.	""	index isZero		ifTrue: [""			self beep.			^ self].	""	self		selectTranslationPhrase: (results at: index)! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 8/27/2003 20:42'!searchUntranslated	| search |	search := FillInTheBlank request: 'search for' translated initialAnswer: ''.	(search isNil			or: [search isEmpty])		ifTrue: [""			self beep.			^ self].	""	self searchUntranslated: search! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 9/1/2003 14:28'!searchUntranslated: aString 	| untranslateds results index |	untranslateds := self untranslated.	results := untranslateds				select: [:each | '*' , aString , '*' match: each].	""	results isEmpty		ifTrue: [""			self inform: 'no matches for' translated , ' ''' , aString , ''''.			^ self].	""	results size = 1		ifTrue: [""			self selectUntranslatedPhrase: results first.			^ self].	""	index := (PopUpMenu				labelArray: (results						collect: [:each | each copy replaceAll: Character cr with: $\]))				startUpWithCaption: 'select the untranslated phrase...' translated.	""	index isZero		ifTrue: [""			self beep.			^ self].	""	self		selectUntranslatedPhrase: (results at: index)! !!LanguageEditor methodsFor: 'gui methods' stamp: 'tak 11/28/2004 14:26'!selectAllTranslation	selectedTranslations := (1 to: self translations size) asIdentitySet.	self changed: #allSelections! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 8/24/2003 22:15'!selectTranslationFileName	"answer a file with a translation"	| file |	file := (StandardFileMenu oldFileMenu: FileDirectory default withPattern: '*.translation')				startUpWithCaption: 'Select the file...' translated.	^ file isNil		ifFalse: [file directory fullNameFor: file name]! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 8/24/2003 22:49'!selectTranslationPhrase: phraseString 	self selectedTranslation: (self translations indexOf: phraseString)! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 8/27/2003 20:43'!selectUntranslatedPhrase: phraseString 	self		selectedUntranslated: (self untranslated indexOf: phraseString)! !!LanguageEditor methodsFor: 'gui methods' stamp: 'mir 8/11/2004 10:00'!status	"answer a status string"	| translationsSize untranslatedSize |	translationsSize := self translator translations size.	untranslatedSize := self translator untranslated size.	^ 'ÆÀ {1} phrases ÆÀ {2} translated ÆÀ {3} untranslated ÆÀ' translated format: {translationsSize + untranslatedSize. translationsSize. untranslatedSize}! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 8/24/2003 21:53'!translate	"translate a phrase"	| phrase |	phrase := self phraseToTranslate.	""	(phrase isNil			or: [phrase = ''])		ifTrue: [""			self beep.			^ self].	""	self translatePhrase: phrase! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 8/24/2003 21:55'!translatePhrase: aString 	"translate aString"	| translation |	translation := FillInTheBlank				multiLineRequest: 'translation for: ' translated , '''' , aString , ''''				centerAt: Sensor cursorPoint				initialAnswer: aString				answerHeight: 200.	""	(translation isNil			or: [translation = ''])		ifTrue: [""			self beep.			^ self].	""	self phrase: aString translation: translation! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 9/21/2003 12:09'!translationsFilterWording	^ (self translationsFilter isEmpty		ifTrue: ['filter' translated]		ifFalse: ['filtering: {1}' translated format:{self translationsFilter}]) ! !!LanguageEditor methodsFor: 'gui methods' stamp: 'gm 8/30/2003 02:00'!translationsKeystroke: aChar 	"Respond to a Command key in the translations list."	aChar == $x		ifTrue: [^ self removeTranslation].	aChar == $E		ifTrue: [^ self browseMethodsWithTranslation]! !!LanguageEditor methodsFor: 'gui methods' stamp: 'tak 11/28/2004 14:39'!translationsMenu: aMenu 	^ aMenu add: 'remove (x)' translated action: #removeTranslation;		 add: 'where (E)' translated action: #browseMethodsWithTranslation;		 add: 'select all' translated action: #selectAllTranslation;		 add: 'deselect all' translated action: #deselectAllTranslation;		 add: 'code selection' translated action: #codeSelectedTranslation;		 yourself! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 9/21/2003 12:19'!untranslatedFilterWording	^ self untranslatedFilter isEmpty		ifTrue: ['filter' translated]		ifFalse: ['filtering: {1}' translated format: {self untranslatedFilter}]! !!LanguageEditor methodsFor: 'gui methods' stamp: 'gm 8/30/2003 02:01'!untranslatedKeystroke: aChar 	"Respond to a Command key in the translations list."	aChar == $t		ifTrue: [^ self translate].	aChar == $E		ifTrue: [^ self browseMethodsWithUntranslated]! !!LanguageEditor methodsFor: 'gui methods' stamp: 'dgd 10/13/2003 18:30'!untranslatedMenu: aMenu 	^ aMenu add: 'remove' translated action: #removeUntranslated;		 add: 'translate (t)' translated action: #translate;		 add: 'where (E)' translated action: #browseMethodsWithUntranslated;		 yourself! !!LanguageEditor methodsFor: 'reporting' stamp: 'mir 7/21/2004 19:24'!asHtml: aString 	| stream |	stream := String new writeStream.	aString		do: [:each | 			each caseOf: {				[Character cr] -> [stream nextPutAll: '<br>'].				[$&] -> [stream nextPutAll: '&amp;'].				[$<] -> [stream nextPutAll: '&lt;'].				[$>] -> [stream nextPutAll: '&gt;'].				[$*] -> [stream nextPutAll: '&star;'].				[$@] -> [stream nextPutAll: '&at;']}				 otherwise: [stream nextPut: each]].	^ stream contents! !!LanguageEditor methodsFor: 'reporting' stamp: 'mir 8/11/2004 09:59'!printHeaderReportOn: aStream 	"append to aStream a header report of the receiver with swiki  	format"	aStream nextPutAll: '!!!!';				nextPutAll: ('Language: {1}' translated format: {self translator localeID isoString});		 cr.	aStream nextPutAll: '- ';				nextPutAll: ('{1} translated phrases' translated format: {self translator translations size});		 cr.	aStream nextPutAll: '- ';				nextPutAll: ('{1} untranslated phrases' translated format: {self translator untranslated size});		 cr.	aStream cr; cr! !!LanguageEditor methodsFor: 'reporting' stamp: 'mir 7/21/2004 19:25'!printReportOn: aStream 	"append to aStream a report of the receiver with swiki format"	self printHeaderReportOn: aStream.	self printUntranslatedReportOn: aStream.	self printTranslationsReportOn: aStream! !!LanguageEditor methodsFor: 'reporting' stamp: 'mir 8/11/2004 10:01'!printTranslationsReportOn: aStream 	"append to aStream a report of the receiver's translations"	| originalPhrases |	aStream nextPutAll: '!!';		 nextPutAll: 'translations' translated;		 cr.	originalPhrases := self translator translations keys asSortedCollection.	originalPhrases		do: [:each | 			aStream				nextPutAll: ('|{1}|{2}|' format: {self asHtml: each. self							asHtml: (self translator translationFor: each)});				 cr].	aStream cr; cr! !!LanguageEditor methodsFor: 'reporting' stamp: 'mir 7/21/2004 19:26'!printUntranslatedReportOn: aStream 	"append to aStream a report of the receiver's translations"	aStream nextPutAll: '!!';		 nextPutAll: 'not translated' translated;		 cr.	self untranslated asSortedCollection		do: [:each | 			aStream				nextPutAll: ('|{1}|' format: {self asHtml: each});				 cr].	aStream cr; cr! !!LanguageEditor methodsFor: 'reporting' stamp: 'mir 7/21/2004 19:26'!reportString	"answer a string with a report of the receiver"	| stream |	stream := String new writeStream.	self printReportOn: stream.	^ stream contents! !!LanguageEditor methodsFor: 'initialization - toolbar' stamp: 'tak 11/16/2004 15:07'!createButtonLabel: aString action: actionSelector help: helpString 	"create a toolbar for the receiver"	| button |	button := SimpleButtonMorph new target: self;				 label: aString translated "font: Preferences standardButtonFont";				 actionSelector: actionSelector;				 setBalloonText: helpString translated;				 color: translator defaultBackgroundColor twiceDarker;				 borderWidth: 2;				 borderColor: #raised.	""	^ button! !!LanguageEditor methodsFor: 'initialization - toolbar' stamp: 'mir 7/21/2004 18:01'!createMainToolbar	"create a toolbar for the receiver"	| toolbar |	toolbar := self createRow.	"""	toolbar		addMorphBack: (self				createUpdatingButtonWording: #debugWording				action: #switchDebug				help: 'Switch the debug flag')."	toolbar addTransparentSpacerOfSize: 5 @ 0.	""	toolbar		addMorphBack: (self				createButtonLabel: 'save'				action: #saveToFile				help: 'Save the translations to a file').	toolbar		addMorphBack: (self				createButtonLabel: 'load'				action: #loadFromFile				help: 'Load the translations from a file').	toolbar		addMorphBack: (self				createButtonLabel: 'merge'				action: #mergeFromFile				help: 'Merge the current translations with the translations in a file').	""	toolbar addTransparentSpacerOfSize: 5 @ 0.	toolbar		addMorphBack: (self				createButtonLabel: 'apply'				action: #applyTranslations				help: 'Apply the translations as much as possible.').	""	toolbar addTransparentSpacerOfSize: 5 @ 0.	toolbar		addMorphBack: (self				createButtonLabel: 'check translations'				action: #check				help: 'Check the translations and report the results.').	toolbar		addMorphBack: (self				createButtonLabel: 'report'				action: #report				help: 'Create a report.').	toolbar		addMorphBack: (self				createButtonLabel: 'gettext export'				action: #getTextExport				help: 'Exports the translations in GetText format.').	""	^ toolbar! !!LanguageEditor methodsFor: 'initialization - toolbar' stamp: 'dgd 9/21/2003 11:46'!createRow	"create a row"	| row |	row := AlignmentMorph newRow.	row layoutInset: 3;		 wrapCentering: #center;		 cellPositioning: #leftCenter.	""	^ row! !!LanguageEditor methodsFor: 'initialization - toolbar' stamp: 'yo 2/17/2005 18:24'!createTranslationsToolbar	"create a toolbar for the receiver"	| toolbar |	toolbar := self createRow.	""	toolbar		addMorphBack: (self				createUpdatingButtonWording: #translationsFilterWording				action: #filterTranslations				help: 'Filter the translations list.').	toolbar addTransparentSpacerOfSize: 5 @ 0.	""	toolbar		addMorphBack: (self				createButtonLabel: 'search'				action: #searchTranslation				help: 'Search for a translation containing...').	toolbar addTransparentSpacerOfSize: 5 @ 0.	toolbar		addMorphBack: (self				createButtonLabel: 'remove'				action: #removeTranslation				help: 'Remove the selected translation.  If none is selected, ask for the one to remove.').	""	toolbar addTransparentSpacerOfSize: 5 @ 0.	toolbar		addMorphBack: (self				createButtonLabel: 'where'				action: #browseMethodsWithTranslation				help: 'Launch a browser on all methods that contain the phrase as a substring of any literal String.').	toolbar addTransparentSpacerOfSize: 5 @ 0.	toolbar		addMorphBack: (self				createButtonLabel: 'r-unused'				action: #removeTranslatedButUnusedStrings				help: 'Remove all the strings that are not used by the system').	toolbar addTransparentSpacerOfSize: 5 @ 0.	toolbar		addMorphBack: (self				createButtonLabel: 'add '				action: #addTranslation				help: 'Add a new phrase').	^ toolbar! !!LanguageEditor methodsFor: 'initialization - toolbar' stamp: 'sd 12/18/2004 18:10'!createUntranslatedToolbar	"create a toolbar for the receiver"	| toolbar |	toolbar := self createRow.	""	toolbar		addMorphBack: (self				createUpdatingButtonWording: #untranslatedFilterWording				action: #filterUntranslated				help: 'Filter the untranslated list.').	toolbar addTransparentSpacerOfSize: 5 @ 0.	""	toolbar		addMorphBack: (self				createButtonLabel: 'search'				action: #searchUntranslated				help: 'Search for a untranslated phrase containing...').	toolbar addTransparentSpacerOfSize: 5 @ 0.	toolbar		addMorphBack: (self				createButtonLabel: 'remove'				action: #removeUntranslated				help: 'Remove the selected untranslated phrease.  If none is selected, ask for the one to remove.').	""	toolbar addTransparentSpacerOfSize: 5 @ 0.	toolbar		addMorphBack: (self				createButtonLabel: 'translate'				action: #translate				help: 'Translate the selected untranslated phrase or a new phrase').	""	toolbar addTransparentSpacerOfSize: 5 @ 0.	toolbar		addMorphBack: (self				createButtonLabel: 'where'				action: #browseMethodsWithUntranslated				help: 'Launch a browser on all methods that contain the phrase as a substring of any literal String.').	toolbar addTransparentSpacerOfSize: 5 @ 0.	toolbar		addMorphBack: (self				createButtonLabel: 'r-unused'				action: #removeUntranslatedButUnusedStrings				help: 'Remove all the strings that are not used by the system').	^ toolbar! !!LanguageEditor methodsFor: 'initialization - toolbar' stamp: 'tak 11/16/2004 15:06'!createUpdatingButtonWording: wordingSelector action: actionSelector help: helpString 	"create a toolbar for the receiver"	| button |	button := (UpdatingSimpleButtonMorph newWithLabel: '-') target: self;				 wordingSelector: wordingSelector;				 actionSelector: actionSelector;				 setBalloonText: helpString translated;				 color: translator defaultBackgroundColor twiceDarker;				 borderWidth: 1;				 borderColor: #raised; cornerStyle: #square.	""	^ button! !!LanguageEditor methodsFor: 'initialization - toolbar' stamp: 'dgd 9/21/2003 11:27'!initializeToolbars	"initialize the receiver's toolbar"	self		addMorph: self createMainToolbar		frame: (0 @ 0 corner: 1 @ 0.09).	""	self		addMorph: self createTranslationsToolbar		frame: (0 @ 0.09 corner: 0.5 @ 0.18).	self		addMorph: self createUntranslatedToolbar		frame: (0.5 @ 0.09 corner: 1 @ 0.18)! !!LanguageEditor methodsFor: 'stef' stamp: 'sd 11/25/2004 09:32'!identifyUnusedStrings	"self new identifyUnusedStrings"	translationsList getList		do: [:each | 			Transcript show: each.			Transcript show: (Smalltalk					allSelect: [:method | method							hasLiteralSuchThat: [:lit | lit class == String									and: [lit includesSubstring: each caseSensitive: true]]]) size printString; cr]! !!LanguageEditor methodsFor: 'stef' stamp: 'sd 12/18/2004 18:15'!numberOfTimesStringIsUsed: aString	^ (self systemNavigation allSelect: [:method | method							hasLiteralSuchThat: [:lit | lit class == String									and: [lit includesSubstring: aString caseSensitive: true]]]) size! !!LanguageEditor methodsFor: 'stef' stamp: 'tak 1/4/2005 09:26'!removeTranslatedButUnusedStrings	(self confirm: 'Are you sure that you want to remove unused strings?' translated)		ifFalse: [^ self].	translationsList getList		do: [:each | 			| timesUsed | 			timesUsed := self numberOfTimesStringIsUsed: each.			Transcript show: each.			Transcript show: timesUsed printString;				 cr.			timesUsed isZero				ifTrue: [self translator removeTranslationFor: each]]! !!LanguageEditor methodsFor: 'stef' stamp: 'yo 1/14/2005 16:55'!removeUntranslatedButUnusedStrings	(self confirm: 'Are you sure that you want to remove unused strings?' translated)		ifFalse: [^ self].	untranslatedList getList		do: [:each | 			| timesUsed | 			timesUsed := self numberOfTimesStringIsUsed: each.			Transcript show: each.			Transcript show: timesUsed printString;				 cr.			timesUsed isZero 				ifTrue: [self translator removeUntranslated: each]].	self update: #untranslated.! !!LanguageEditor methodsFor: 'updating' stamp: 'dgd 8/28/2003 10:31'!okToChange	"Allows a controller to ask this of any model"	self selectedTranslation isZero		ifTrue: [^ true].	""	translationText hasUnacceptedEdits		ifFalse: [^ true].	^ (CustomMenu confirm: 'Discard the changes to currently selected translated phrase?' translated)		and: [""			translationText hasUnacceptedEdits: false.			true]! !!LanguageEditor methodsFor: 'updating' stamp: 'dgd 8/27/2003 19:59'!refreshTranslations	"refresh the translations panel"	self changed: #translations.	self selectedTranslation: 0! !!LanguageEditor methodsFor: 'updating' stamp: 'dgd 8/27/2003 19:59'!refreshUntranslated"refresh the untranslated panel"	self changed: #untranslated.	self selectedUntranslated: 0! !!LanguageEditor methodsFor: 'updating' stamp: 'dgd 8/25/2003 20:11'!update: aSymbol 	"Receive a change notice from an object of whom the receiver  	is a dependent."	super update: aSymbol.	""	aSymbol == #untranslated		ifTrue: [self refreshUntranslated].	aSymbol == #translations		ifTrue: [self refreshTranslations]! !!LanguageEditor methodsFor: 'private' stamp: 'mir 8/11/2004 09:58'!check	"check the translations and answer a collection with the results"	| results counter phrasesCount  untranslated translations checkMethod |	results := OrderedCollection new.	untranslated := self translator untranslated.	translations := self translator translations.	phrasesCount := translations size + untranslated size.	counter := 0.	checkMethod := self class checkMethods at: self translator localeID printString ifAbsent: [^results].		translations		keysAndValuesDo: [:phrase :translation | 			| result | 			result := self perform: checkMethod with: phrase with: translation.			(result notNil					and: [result notEmpty])				ifTrue: [results add: {phrase. translation. result}].					counter := counter + 1.			(counter isDivisibleBy: 50)				ifTrue: [| percent | 					percent := counter / phrasesCount * 100 roundTo: 0.01.					Transcript						show: ('- checked {1} phrases of {2} ({3}%)...' translated format: {counter. phrasesCount. percent});						 cr]].	untranslated		do: [:phrase | 			| result | 			result := self checkUntranslatedPhrase: phrase.			(result notNil					and: [result notEmpty])				ifTrue: [results add: {phrase. nil. result}].					counter := counter + 1.			(counter isDivisibleBy: 50)				ifTrue: [| percent | 					percent := counter / phrasesCount * 100 roundTo: 0.01.					Transcript						show: ('- checked {1} phrases of {2} ({3}%)...' translated format: {counter. phrasesCount. percent});						 cr]].	^ results! !!LanguageEditor methodsFor: 'private' stamp: 'mir 7/21/2004 18:58'!checkPhrase: phraseString translation: translationString	^nil! !!LanguageEditor methodsFor: 'private' stamp: 'tak 12/26/2004 12:10'!checkSpanishPhrase: phraseString translation: translationString 	"check the translation an aswer a string with a comment or a  	nil meaning no-comments"	| superResult |	superResult := self checkPhrase: phraseString translation: translationString.	superResult isNil		ifFalse: [^ superResult]."For some reason, MCInstaller couldn't read Spanish character.""	((translationString withBlanksTrimmed includes: $?)			and: [(translationString withBlanksTrimmed includes: $é) not])		ifTrue: [^ 'éOlvidÆ§ el signo de pregunta?'].	((translationString withBlanksTrimmed includes: $!!)			and: [(translationString withBlanksTrimmed includes: $éÄ) not])		ifTrue: [^ 'éOlvidÆ§ el signo de admiraciÆ§n?']."	^ nil! !!LanguageEditor methodsFor: 'private' stamp: 'mir 7/21/2004 18:57'!checkUntranslatedPhrase: phraseString 	"check the phrase an aswer a string with a comment or a nil  	meaning no-comments"	(self translations includes: phraseString)		ifTrue: [^ 'possible double-translation' translated].	^ nil! !!LanguageEditor methodsFor: 'private' stamp: 'mir 8/11/2004 09:57'!translator	^translator! !!LanguageEditor methodsFor: 'message handling' stamp: 'gm 8/30/2003 01:54'!perform: selector orSendTo: otherTarget 	"I wish to intercept and handle selector myself"	^ self perform: selector! !!LanguageEditor methodsFor: 'open/close' stamp: 'dgd 8/26/2003 14:20'!delete	"Remove the receiver as a submorph of its owner"	self model: nil.	super delete ! !!LanguageEditor class methodsFor: 'instance creation' stamp: 'mir 7/21/2004 17:00'!on: aLanguage	"answer an instance of the receiver on aLanguage"	^ self new initializeOn: (NaturalLanguageTranslator localeID: aLanguage)! !!LanguageEditor class methodsFor: 'instance creation' stamp: 'mir 8/11/2004 10:00'!openOn: aLanguage 	"open an instance on aLanguage"	World submorphs		do: [:each | ""			((each isKindOf: LanguageEditor)					and: [each translator == aLanguage])				ifTrue: [""					self ensureVisibilityOfWindow: each.					^ self]].	""	^ (self on: aLanguage) openInWorld! !!LanguageEditor class methodsFor: 'opening' stamp: 'mir 7/21/2004 16:57'!open	"open the receiver on any language"	" 	LanguageEditor open. 	"	| menu |	menu := MenuMorph new defaultTarget: self.	menu addTitle: 'Language Editor for...' translated.	""	(NaturalLanguageTranslator availableLanguageLocaleIDs		asSortedCollection: [:x :y | x asString <= y asString])		do: [:eachLanguage | ""			menu				add: eachLanguage name				target: self				selector: #openOn:				argument: eachLanguage].	""	menu popUpInWorld! !!LanguageEditor class methodsFor: 'opening' stamp: 'mir 7/21/2004 16:59'!openOnDefault	"open the receiver on the default language"	self openOn: NaturalLanguageTranslator current! !!LanguageEditor class methodsFor: 'private' stamp: 'mir 7/21/2004 18:47'!checkMethods	^CheckMethods ifNil: [CheckMethods := self initCheckMethods]! !!LanguageEditor class methodsFor: 'private' stamp: 'dgd 11/9/2003 15:39'!ensureVisibilityOfWindow: aWindow 	"private - activate the window"	| |	aWindow expand.	aWindow comeToFront.	""	aWindow		right: (aWindow right min: World right).	aWindow		bottom: (aWindow bottom min: World bottom).	aWindow		left: (aWindow left max: World left).	aWindow		top: (aWindow top max: World top).	""	aWindow flash; flash! !!LanguageEditor class methodsFor: 'initialize-release' stamp: 'mir 7/21/2004 18:47'!initCheckMethods	"LanguageEditor initCheckMethods"	| registry |	registry := Dictionary new.	registry		at: 'es' put: #checkSpanishPhrase:translation:;		yourself.	^registry! !!LanguageEditor class methodsFor: 'initialize-release' stamp: 'dgd 11/9/2003 14:27'!initialize	"initialize the receiver"	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [""			TheWorldMenu registerOpenCommand: {'Language Editor'. {self. #openOnDefault}}.			TheWorldMenu registerOpenCommand: {'Language Editor for...'. {self. #open}}]! !!LanguageEditor class methodsFor: 'initialize-release' stamp: 'dgd 11/9/2003 14:27'!unload	"the receiver is being unloaded"	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [""			TheWorldMenu unregisterOpenCommand: 'Language Editor'.			TheWorldMenu unregisterOpenCommand: 'Language Editor for...'] ! !!TTCFont methodsFor: 'accessing' stamp: 'tak 12/22/2004 02:28'!ascent	| ascent |	ascent := ttcDescription ascender * self pixelSize // (ttcDescription ascender - ttcDescription descender) * Scale y.	^ (fallbackFont notNil			and: [fallbackFont ascent > ascent])		ifTrue: [fallbackFont ascent]		ifFalse: [ascent]! !!TTCFont methodsFor: 'accessing' stamp: 'tak 12/22/2004 01:25'!fallbackFont	^ fallbackFont		ifNil: [fallbackFont _ FixedFaceFont new errorFont fontSize: self height]! !!TTCFont methodsFor: 'friend' stamp: 'yo 1/7/2005 12:04'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	^ self displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: aPoint y + self ascent.! !!TTCFont methodsFor: 'friend' stamp: 'yo 1/7/2005 15:17'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| destPoint form glyphInfo destY |	destPoint _ aPoint.	glyphInfo _ Array new: 5.	startIndex to: stopIndex do: [:charIndex |		self glyphInfoOf: (aString at: charIndex) into: glyphInfo.		form _ glyphInfo first.		(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [			glyphInfo fifth installOn: aBitBlt.		].		destY _ baselineY - glyphInfo fourth. 		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x.		aBitBlt destY: destY.		aBitBlt sourceOrigin: (glyphInfo second) @ 0.		aBitBlt width: glyphInfo third - glyphInfo second.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint _ destPoint + ((glyphInfo third - glyphInfo second) + kernDelta @ 0).	].	^ destPoint.! !!TTCFont methodsFor: 'friend' stamp: 'yo 1/6/2005 21:59'!installOn: aDisplayContext	^aDisplayContext installTTCFont: self.! !!TTCFont methodsFor: 'friend' stamp: 'yo 1/20/2005 12:20'!setupDefaultFallbackFontTo: aTextStyle"	TTCFont allInstances do: [:i | i setupDefaultFallbackFontTo: (TextStyle named: 'MultiMSMincho')]."	| fonts f |	fonts _ aTextStyle fontArray.	(aTextStyle defaultFont familyName endsWith: self familyName) ifTrue: [fallbackFont _ nil. ^ self].	f _ fonts first.	1 to: fonts size do: [:i |		self height >= (fonts at: i) height ifTrue: [f _ fonts at: i].	].	self fallbackFont: f.	self reset.! !!TTCFont methodsFor: 'public' stamp: 'yo 1/18/2005 16:10'!widthOf: aCharacter	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	| f assoc |	aCharacter charCode > 255 ifTrue: [		fallbackFont ifNotNil: [^ fallbackFont widthOf: aCharacter].		^ 1	].	assoc _ self cache at: (aCharacter charCode + 1).	assoc ifNotNil: [		^ assoc value width	].	f _ self computeForm: aCharacter.	self at: aCharacter charCode put: f.	^ f width.! !!TTCFont methodsFor: 'private' stamp: 'yo 1/18/2005 16:13'!computeForm: char	| ttGlyph scale |	scale _ self pixelSize asFloat / (ttcDescription ascender - ttcDescription descender).	Scale ifNotNil: [scale _ Scale * scale].	ttGlyph _ ttcDescription at: (char isCharacter ifTrue: [char charCode] ifFalse: [char]).	^ ttGlyph asFormWithScale: scale ascender: ttcDescription ascender descender: ttcDescription descender fgColor: foregroundColor bgColor: Color transparent depth: self depth.! !!TTCFont methodsFor: 'private' stamp: 'yo 1/7/2005 13:13'!formOf: char	| f assoc code |	char charCode > 255		ifTrue: [^ self fallbackFont formOf: char].	code _ char charCode.	assoc _ self cache at: (code + 1).	assoc ifNotNil: [		(assoc key = foregroundColor) ifTrue: [			^ assoc value.		].	].	f _ self computeForm: code.	self at: code put: f.	^ f.! !!TTCFont methodsFor: 'private' stamp: 'yo 1/11/2005 18:48'!glyphInfoOf: aCharacter into: glyphInfoArray	"Answer the width of the argument as a character in the receiver."	| form |	(self hasGlyphOf: aCharacter) ifFalse: [		^ self fallbackFont glyphInfoOf: aCharacter into: glyphInfoArray.	].	form _ self formOf: aCharacter.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: (self ascentOf: aCharacter);		at: 5 put: self.	^ glyphInfoArray.! !!TTCFont methodsFor: 'private' stamp: 'yo 1/6/2005 04:43'!hasGlyphOf: aCharacter	^ aCharacter charCode <= 255! !!TTCFont methodsFor: 'as yet unclassified' stamp: 'tak 11/11/2004 16:42'!setupDefaultFallbackFont	| fonts f |	fonts _ TextStyle default fontArray.	f _ fonts first.	1 to: fonts size do: [:i |		self height > (fonts at: i) height ifTrue: [f _ fonts at: i].	].	self fallbackFont: f.	self reset.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'yo 1/7/2005 11:09'!glyphInfoOf: char into: glyphInfoArray	| newForm |	self hasCached: char ifTrue: [:form :index |		self access: char at: index.		glyphInfoArray at: 1 put: form;			at: 2 put: 0;			at: 3 put: form width;			at: 4 put: (self ascentOf: char);			at: 5 put: self.		^ glyphInfoArray.	].	newForm _ self computeForm: char.	self at: char put: newForm.	glyphInfoArray at: 1 put: newForm;		at: 2 put: 0;		at: 3 put: newForm width;		at: 4 put: (self ascentOf: char);		at: 5 put: self.	^ glyphInfoArray.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 1/7/2005 12:05'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta	^ self displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: aPoint y + self ascent.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 1/7/2005 15:17'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| destPoint font form encoding glyphInfo char charCode destY |	destPoint _ aPoint.	glyphInfo _ Array new: 5.	startIndex to: stopIndex do: [:charIndex |		char _ aString at: charIndex.		encoding _ char leadingChar + 1.		charCode _ char charCode.		font _ fontArray at: encoding.		((charCode between: font minAscii and: font maxAscii) not) ifTrue: [			charCode _ font maxAscii].		self glyphInfoOf: char into: glyphInfo.		form _ glyphInfo first.		(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [			glyphInfo fifth installOn: aBitBlt.		].		destY _ baselineY - glyphInfo fourth. 		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x.		aBitBlt destY: destY.		aBitBlt sourceOrigin: 0 @ 0.		aBitBlt width: form width.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint _ destPoint + (form width + kernDelta @ 0).	].	^ destPoint.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 1/7/2005 11:00'!displayStringR2L: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	| destPoint font form encoding char charCode glyphInfo |	destPoint _ aPoint.	glyphInfo _ Array new: 5.	startIndex to: stopIndex do: [:charIndex |		char _ aString at: charIndex.		encoding _ char leadingChar + 1.		charCode _ char charCode.		font _ fontArray at: encoding.		((charCode between: font minAscii and: font maxAscii) not) ifTrue: [			charCode _ font maxAscii].		self glyphInfoOf: char into: glyphInfo.		form _ glyphInfo first.			(glyphInfo size > 4 and: [glyphInfo fifth notNil and: [glyphInfo fifth ~= aBitBlt lastFont]]) ifTrue: [				glyphInfo fifth installOn: aBitBlt.			].		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x - form width.		aBitBlt destY: destPoint y.		aBitBlt sourceOrigin: 0 @ 0.		aBitBlt width: form width.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint _ destPoint - (form width + kernDelta @ 0).	].! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 1/7/2005 11:17'!glyphInfoOf: aCharacter into: glyphInfoArray	| index f code |	index _ aCharacter leadingChar + 1.	fontArray size < index ifTrue: [^ self questionGlyphInfoInto: glyphInfoArray].	(f _ fontArray at: index) ifNil: [^ self questionGlyphInfoInto: glyphInfoArray].	code _ aCharacter charCode.	((code between: f minAscii and: f maxAscii) not) ifTrue: [		^ self questionGlyphInfoInto: glyphInfoArray.	].	f glyphInfoOf: aCharacter into: glyphInfoArray.	glyphInfoArray at: 5 put: self.	^ glyphInfoArray.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 1/6/2005 22:00'!installOn: aDisplayContext	^aDisplayContext installTTCFont: self.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 1/6/2005 17:16'!questionGlyphInfoInto: glyphInfoArray	| f form |	f _ fontArray at: 1.	form _ f formOf: $?.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: self.	^ glyphInfoArray.! !!Text methodsFor: 'converting' stamp: 'BG 12/9/2004 17:38'!asMultiStringText	string class == MultiString ifFalse: [		^ self class string: (MultiString from: string) runs: self runs copy.	].	^ self.! !!Text methodsFor: 'converting' stamp: 'BG 12/9/2004 17:23'!asOctetStringText	string class == MultiString ifTrue: [		^ self class string: string asOctetString runs: self runs copy.	].	^self.! !!TextMorph class methodsFor: '*connectorstext-parts bin' stamp: 'yo 1/20/2005 12:44'!boldAuthoringPrototype	"TextMorph boldAuthoringPrototype openInHand"	| text |	text := Text string: 'Text' translated attributes: { TextEmphasis bold. }.	^self new		contentsWrapped: text;		fontName: 'BitstreamVeraSans' pointSize: 24;		paragraph;		extent: 79@36;		margins: 4@0;		fit;		yourself! !!TileMorph methodsFor: 'mouse handling' stamp: 'yo 1/12/2005 18:25'!showOptions	"The receiver is a tile that represents an operator; a click on the 	receiver's label will pop up a menu of alternative operator choices"	| result menuChoices |	menuChoices _ self options first collect: [:each | each asString translated].	result _ (SelectionMenu labelList: menuChoices lines: nil selections: self options first) startUp.	result 		ifNotNil: [self value: result.			self scriptEdited]! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'yo 2/11/2005 16:12'!setLiteral: aLiteral
	super  setLiteral: aLiteral.
	(self findA: UpdatingStringMorph) useSymbolFormat; lock! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'yo 2/11/2005 16:08'!soundNameFromUser	"Obtain a sound from the user.  Exclude the items designated as being discouraged, except that if the current selection is one of those, show it anyway"	| choices |	choices _ self soundChoices.	^ (SelectionMenu labels: (choices collect: [:t | t translated]) selections: self soundChoices) startUpWithCaption: 'Sounds' translated! !!SoundReadoutTile methodsFor: 'private' stamp: 'yo 2/11/2005 16:13'!updateLiteralLabel
	"Update the wording emblazoned on the tile, if needed"

	super updateLiteralLabel.
	(self findA: UpdatingStringMorph) useSymbolFormat; lock! !!SoundTile methodsFor: 'initialization' stamp: 'yo 1/12/2005 15:04'!initialize	"Initialize the state of the receiver. Pick the croak sound	if available, otherwise any sound."		| soundChoices startingSoundName |	super initialize.	soundChoices _ SoundService default sampledSoundChoices.	startingSoundName _ (soundChoices includes: 'croak')							ifTrue: ['croak']							ifFalse: [[soundChoices anyOne] ifError: ['silence']].	self addArrows; setLiteral: startingSoundName.	self labelMorph useSymbolFormat! !!SymbolListTile methodsFor: 'player viewer' stamp: 'yo 1/12/2005 14:28'!updateLiteralLabel	"Update the wording emblazoned on the tile, if needed.  Copied down, for jimmying, unfortunately"	| myLabel |	(myLabel _ self labelMorph) ifNil: [^ self].	myLabel useSymbolFormat.	myLabel acceptValue: literal asString.	self changed.! !!SymbolListTile methodsFor: 'user interface' stamp: 'yo 1/12/2005 14:38'!acceptNewLiteral: aLiteral	"Accept the new literal"	self labelMorph useSymbolFormat.	self literal: aLiteral.	self adjustHelpMessage.	self acceptNewLiteral.  "so tile scriptor can recompile if necessary"	self labelMorph informTarget! !!SymbolListTile methodsFor: 'private' stamp: 'yo 1/12/2005 14:28'!line1: line1	"Emblazon the receiver with the requested label.  If the receiver already has a label, make the new label be of the same class"	super line1: line1.	self labelMorph useSymbolFormat! !!TransformMorph methodsFor: 'drawing' stamp: 'tak 1/17/2005 13:16'!addImageToPenTrails: aForm 	| canvas |	owner		ifNil: [^ self].	canvas := Display defaultCanvasClass extent: self extent depth: Display depth.	canvas		translateBy: self topLeft negated		during: [:tempCanvas | tempCanvas				transformBy: transform				clippingTo: self innerBounds				during: [:myCanvas | myCanvas drawImage: aForm at: aForm offset]				smoothing: smoothing].	owner		addImageToPenTrails: (canvas form offset: self topLeft)! !!TranslatedReceiverFinder methodsFor: 'as yet unclassified' stamp: 'yo 8/2/2004 17:22'!searchBlockNode: aBlockNode addTo: aCollection	aBlockNode statements do: [:e |		(e isMemberOf: MessageNode) ifTrue: [self searchMessageNode: e addTo: aCollection].		(e isMemberOf: ReturnNode) ifTrue: [self searchReturnNode: e addTo: aCollection].	].! !!TranslatedReceiverFinder methodsFor: 'as yet unclassified' stamp: 'yo 8/2/2004 17:23'!searchMessageNode: aMessageNode addTo: aCollection	((aMessageNode receiver isMemberOf: LiteralNode) and: [(aMessageNode selector isMemberOf: SelectorNode) and: [aMessageNode selector key = #translated]]) ifTrue: [		aCollection add: aMessageNode receiver key.	].	(aMessageNode receiver isMemberOf: BlockNode) ifTrue: [self searchBlockNode: aMessageNode receiver addTo: aCollection].	(aMessageNode receiver isMemberOf: MessageNode) ifTrue: [self searchMessageNode: aMessageNode receiver addTo: aCollection].	(aMessageNode receiver isMemberOf: ReturnNode) ifTrue: [self searchReturnNode: aMessageNode receiver addTo: aCollection].	aMessageNode arguments do: [:a |		(a isMemberOf: BlockNode) ifTrue: [self searchBlockNode: a addTo: aCollection].		(a isMemberOf: MessageNode) ifTrue: [self searchMessageNode: a addTo: aCollection].		(a isMemberOf: ReturnNode) ifTrue: [self searchReturnNode: a addTo: aCollection].	].! !!TranslatedReceiverFinder methodsFor: 'as yet unclassified' stamp: 'yo 8/2/2004 17:22'!searchMethodNode: aMethodNode addTo: aCollection	(aMethodNode block isMemberOf: BlockNode) ifTrue: [self searchBlockNode: aMethodNode block addTo: aCollection].	(aMethodNode block isMemberOf: MessageNode) ifTrue: [self searchMessageNode: aMethodNode block addTo: aCollection].	(aMethodNode block isMemberOf: ReturnNode) ifTrue: [self searchReturnNode: aMethodNode block addTo: aCollection].! !!TranslatedReceiverFinder methodsFor: 'as yet unclassified' stamp: 'yo 8/2/2004 17:21'!searchReturnNode: aReturnNode addTo: aCollection	(aReturnNode expr isMemberOf: BlockNode) ifTrue: [self searchBlockNode: aReturnNode expr addTo: aCollection].	(aReturnNode expr isMemberOf: MessageNode) ifTrue: [self searchMessageNode: aReturnNode expr addTo: aCollection].! !!TranslatedReceiverFinder methodsFor: 'as yet unclassified' stamp: 'yo 7/29/2004 18:22'!senders	| m o |	m _ SystemNavigation default allCallsOn: #translated.	m _ m collect: [:e |		e classIsMeta ifTrue: [			(Smalltalk at: e classSymbol) class decompile: e methodSymbol.		] ifFalse: [			(Smalltalk at: e classSymbol) decompile: e methodSymbol.		]	].	o _ SortedCollection new.	m do: [:e | self searchMethodNode: e addTo: o].	^ o.! !!TranslatedReceiverFinder class methodsFor: 'as yet unclassified' stamp: 'yo 7/29/2004 20:31'!makeJapaneseTranslationFile	| t n |	NaturalLanguageTranslator allKnownPhrases removeAll.	t _ TranslatedReceiverFinder new senders.	n _ NaturalLanguageTranslator localeID: (LocaleID isoLanguage: 'ja').	t do: [:w |		NaturalLanguageTranslator registerPhrase: w.		self at: w ifPresent: [:k | n phrase: w translation: k].	].	n saveToFileNamed: 'ja.translation'. ! !!UTF8TextConverter class methodsFor: 'accessing' stamp: 'tak 1/12/2005 13:22'!writeBOMOn: aStream	"Write Byte Order Mark"	aStream nextPut: 16rEF.	aStream nextPut: 16rBB.	aStream nextPut: 16rBF.! !!Unicode class methodsFor: 'class methods' stamp: 'yo 1/19/2005 10:58'!digitValue: char	| value |	value _ char charCode.	value <= $9 asciiValue 		ifTrue: [^value - $0 asciiValue].	value >= $A asciiValue 		ifTrue: [value <= $Z asciiValue ifTrue: [^value - $A asciiValue + 10]].	value > (DecimalProperty size - 1) ifTrue: [^ -1].	^ (DecimalProperty at: value+1)! !!Unicode class methodsFor: 'class methods' stamp: 'yo 12/4/2004 22:47'!isCharset	^ false.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'yo 1/12/2005 14:38'!valueFromContents	"Return a new value from the current contents string.""	| expression tilePadMorphOrNil asNumberBlock |	asNumberBlock _ [:string | [string asNumber]				on: Error				do: []].	format = #string		ifTrue: [^ contents].	(format = #default			and: [self owner isKindOf: NumericReadoutTile])		ifTrue: [^ asNumberBlock value: contents].	tilePadMorphOrNil _ self ownerThatIsA: TilePadMorph.	(tilePadMorphOrNil notNil			and: [tilePadMorphOrNil type = #Number])		ifTrue: [^ asNumberBlock value: contents].	expression _ Vocabulary eToyVocabulary translationKeyFor: contents.	expression isNil		ifTrue: [expression _ contents].	^ Compiler evaluate: expression"	format = #symbol ifTrue: [^ lastValue].	format = #string ifTrue: [^ contents].	^ Compiler evaluate: contents! !!UpdatingStringMorph methodsFor: 'formats' stamp: 'yo 1/12/2005 14:28'!useSymbolFormat	format _ #symbol.! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'yo 1/12/2005 14:27'!acceptValueFromTarget: v	"Accept a value from the target"	self flag: #yo.  "we may want to translate the v asString result."	lastValue _ v.	self format == #string ifTrue: [^ v asString].	self format == #symbol ifTrue: [^ v asString translated].	(format == #default and: [v isNumber]) ifTrue:		[^ v printShowingDecimalPlaces: self decimalPlaces].	^ v printString translated.! !!Utilities class methodsFor: 'tailoring system' stamp: 'tak 1/22/2005 15:52'!makeNihongoImage	"self makeNihongoImage"	Utilities emptyScrapsBook.	Display setExtent: 960@720 depth: 16.	World color: (Color r: 0.935 g: 0.935 b: 0.935).	Preferences takanawa.	Preferences setPreference: #magicHalos toValue: false.	Preferences setPreference: #magicHalos toValue: true.	Preferences setPreference: #mouseOverHalos toValue: false.	Preferences setPreference: #mouseOverHalos toValue: true.	Player abandonUnnecessaryUniclasses.	Player freeUnreferencedSubclasses.	Player removeUninstantiatedSubclassesSilently.	PartsBin initialize.	Flaps disableGlobalFlaps: false.	Flaps addAndEnableEToyFlaps.	ActiveWorld addGlobalFlaps.	Flaps sharedFlapsAlongBottom.	Locale currentPlatform: (Locale isoLanguage: 'ja').	Locale switchToID: (LocaleID isoLanguage: 'ja').	Preferences restoreDefaultFonts.	StrikeFont setupDefaultFallbackFont.	Project current updateLocaleDependents.	"Dump all projects"	Project allSubInstancesDo:[:prj| prj == Project current ifFalse:[Project deletingProject: prj]].	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk garbageCollect.! !!Viewer methodsFor: 'commands' stamp: 'yo 1/14/2005 19:57'!chooseVocabulary	"Put up a menu allowing the user to specify which protocol to use in this viewer"	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'Choose a vocabulary' translated.	"aMenu addStayUpItem."  "For debugging only"	Vocabulary allStandardVocabularies do:		[:aVocabulary |			(scriptedPlayer class implementsVocabulary: aVocabulary)				ifTrue:					[aMenu add: aVocabulary vocabularyName selector: #switchToVocabulary: argument: aVocabulary.					aVocabulary == self currentVocabulary ifTrue:						[aMenu lastItem color: Color blue]. 					aMenu balloonTextForLastItem: aVocabulary documentation]].	aMenu popUpInWorld: self currentWorld! !!CategoryViewer methodsFor: 'entries' stamp: 'yo 1/14/2005 19:41'!phraseForCommandFrom: aMethodInterface
	"Answer a phrase for the non-slot-like command represented by aMethodInterface - classic tiles"

	| aRow resultType cmd names argType argTile selfTile aPhrase balloonTextSelector stat inst aDocString universal tileBearingHelp |
	aDocString _ aMethodInterface documentation.
	names _ scriptedPlayer class namedTileScriptSelectors.

	resultType _ aMethodInterface resultType.
	cmd _ aMethodInterface selector.
	(universal _ scriptedPlayer isUniversalTiles)
		ifTrue:
			[aPhrase _ scriptedPlayer universalTilesForInterface: aMethodInterface]
		ifFalse: [cmd numArgs == 0
			ifTrue:
				[aPhrase _ PhraseTileMorph new vocabulary: self currentVocabulary.
				aPhrase setOperator: cmd
					type: resultType
					rcvrType: #Player]
			ifFalse:
				["only one arg supported in classic tiles, so if this is fed
				with a selector with > 1 arg, results will be very strange"
				argType _ aMethodInterface typeForArgumentNumber: 1.
				aPhrase _ PhraseTileMorph new vocabulary: self currentVocabulary.
				aPhrase setOperator: cmd
					type: resultType
					rcvrType: #Player
					argType: argType.
				argTile _ ScriptingSystem tileForArgType: argType.				(#(bounce: wrap:) includes: cmd) ifTrue:					["help for the embattled bj"					argTile setLiteral: #silence translated].
				argTile position: aPhrase lastSubmorph position.
				aPhrase lastSubmorph addMorph: argTile]].

	(scriptedPlayer slotInfo includesKey: cmd)
		ifTrue: [balloonTextSelector _ #userSlot].

	(scriptedPlayer belongsToUniClass and: [scriptedPlayer class includesSelector: cmd])
		ifTrue:
			[aDocString ifNil:
				[aDocString _ (scriptedPlayer class userScriptForPlayer: scriptedPlayer selector: cmd) documentation].
			aDocString ifNil:
				[balloonTextSelector _ #userScript]].

	tileBearingHelp _ universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]. 
	aDocString
		ifNotNil:
			[tileBearingHelp setBalloonText: aDocString]
		ifNil:
			[balloonTextSelector ifNil:
				[tileBearingHelp setProperty: #inherentSelector toValue: cmd.
				balloonTextSelector _ #methodComment].
			tileBearingHelp balloonTextSelector: balloonTextSelector].
	aPhrase markAsPartsDonor.
	cmd == #emptyScript ifTrue:
		[aPhrase setProperty: #newPermanentScript toValue: true.
		aPhrase setProperty: #newPermanentPlayer toValue: scriptedPlayer.
		aPhrase submorphs second setBalloonText: 
'drag and drop to 
add a new script' translated].

	universal ifFalse:
		[selfTile _ self tileForSelf.
		selfTile position: aPhrase firstSubmorph position.
		aPhrase firstSubmorph addMorph: selfTile].

	aRow _ ViewerLine newRow borderWidth: 0; color: self color.
	aRow elementSymbol: cmd asSymbol.

	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).
	aRow addMorphBack: (Morph new extent: 2@2; beTransparent).
	aRow addMorphBack: (self infoButtonFor: cmd).
	aRow addMorphBack: aPhrase.
	aPhrase on: #mouseEnter send: #addCommandFeedback to: aRow.
	aPhrase on: #mouseLeave send: #removeHighlightFeedback to: aRow.
	aPhrase on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow.

	(names includes: cmd) ifTrue:
		[aPhrase userScriptSelector: cmd.
		cmd numArgs == 0 ifTrue:
			[aPhrase beTransparent.
			aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.
			aRow addMorphBack: (stat _ (inst _ scriptedPlayer scriptInstantiationForSelector: cmd) statusControlMorph).
			inst updateStatusMorph: stat]].

	aRow beSticky; disableDragNDrop.

	^ aRow! !!Vocabulary methodsFor: 'queries' stamp: 'yo 2/19/2005 23:41'!tileWordingForSelector: aSelector	"Answer the wording to emblazon on tiles representing aSelector"	| anInterface inherent |	anInterface _ self methodInterfaceAt: aSelector asSymbol ifAbsent:		[inherent _ Utilities inherentSelectorForGetter: aSelector.		^ inherent			ifNil:				[self translatedWordingFor: aSelector]			ifNotNil:				[inherent translated]].	^ anInterface wording! !!BooleanType methodsFor: 'tiles' stamp: 'yo 2/18/2005 16:39'!setFormatForDisplayer: aDisplayer	"Set up the displayer to have the right format characteristics"	aDisplayer useSymbolFormat.	aDisplayer growable: true! !Unicode class removeSelector: #charSetSize!!UTF8TextConverter class reorganize!('accessing' writeBOMOn:)('as yet unclassified' encodingNames)!LanguageEditor initialize!StrikeFontSet class removeSelector: #createExternalFontFileForArmenian:!StrikeFontSet class removeSelector: #createExternalFontFileForArrow:!StrikeFontSet class removeSelector: #createExternalFontFileForChinese:!StrikeFontSet class removeSelector: #createExternalFontFileForCyrillic:!StrikeFontSet class removeSelector: #createExternalFontFileForDefault:!StrikeFontSet class removeSelector: #createExternalFontFileForExtendedLatin:!StrikeFontSet class removeSelector: #createExternalFontFileForGreek:!StrikeFontSet class removeSelector: #createExternalFontFileForIPA:!StrikeFontSet class removeSelector: #createExternalFontFileForJapanese:!StrikeFontSet class removeSelector: #createExternalFontFileForKorean:!StrikeFontSet removeSelector: #glyphInfoOf:!StrikeFontSet removeSelector: #questionGlyphInfo!StrikeFont class removeSelector: #newForGreekFromEFontBDFFile:name:!StrikeFont removeSelector: #displayMultiString0:on:from:to:at:kern:!StrikeFont removeSelector: #displayMultiString2:on:from:to:at:kern:!StrikeFont removeSelector: #glyphInfoOf:!StrikeFont removeSelector: #hasGlyphFor:!StrikeFont removeSelector: #readEFontBDFForGreekFromFile:name:!ColorPickerMorph initialize!SelectionMenu class removeSelector: #selectionsString:!SelectionMenu class removeSelector: #selectionsString:lines:!!Preferences class reorganize!('add preferences' addPreference:categories:default:balloonHelp: addPreference:categories:default:balloonHelp:projectLocal:changeInformee:changeSelector: addPreference:category:default:balloonHelp:)('factored pref panel' categoriesContainingPreference:)('fonts' attemptToRestoreClassicFonts chooseBalloonHelpFont chooseCodeFont chooseEToysFont chooseFlapsFont chooseFontWithPrompt:andSendTo:withSelector: chooseFontWithPrompt:andSendTo:withSelector:highlight: chooseHaloLabelFont chooseListFont chooseMenuFont chooseSystemFont chooseWindowTitleFont fontConfigurationMenu printStandardSystemFonts restoreDefaultFonts restoreDefaultFontsForJapanese setBalloonHelpFontTo: setButtonFontTo: setCodeFontTo: setDefaultFonts: setEToysFontTo: setFlapsFontTo: setHaloLabelFontTo: setListFontTo: setMenuFontTo: setPaintBoxButtonFontTo: setSystemFontTo: setWindowTitleFontTo: standardBalloonHelpFont standardButtonFont standardCodeFont standardDefaultTextFont standardEToysFont standardFlapFont standardHaloLabelFont standardListFont standardMenuFont standardPaintBoxButtonFont windowTitleFont windowTitleStyle)('get/set' automaticFlapLayoutString disable: disableGently: doesNotUnderstand: enable: enableGently: enableOrDisable:asPer: enableProjectNavigator navigatorShowingString setPreference:toValue: togglePreference: valueOfFlag: valueOfFlag:ifAbsent:)('halos' classicHaloSpecs classicHalosInForce customHaloSpecs customHalosInForce editCustomHalos haloSpecifications haloSpecificationsForWorld haloTheme iconicHaloSpecifications iconicHalosInForce installClassicHaloSpecs installCustomHaloSpecs installHaloSpecsFromArray: installHaloTheme: installIconicHaloSpecs installSimpleHaloSpecs resetHaloSpecifications showChooseGraphicHaloHandle simpleFullHaloSpecifications simpleHalosInForce)('hard-coded prefs' browseToolClass cmdGesturesEnabled cmdKeysInText debugMenuItemsInvokableFromScripts desktopMenuTitle isFlagship messengersInViewers metaMenuDisabled preserveCommandExcursions suppressWindowTitlesInInstanceBrowsers useCategoryListsInViewers)('initialization' addPreferenceForCelesteShowingAttachmentsFlag addPreferenceForOptionalCelesteStatusPane chooseInitialSettings compileAccessMethodForPreference: initializeDictionaryOfPreferences removePreference: setPreferencesFrom:)('menu parameters' menuBorderColor menuBorderWidth menuColor menuLineColor menuTitleBorderColor menuTitleBorderWidth menuTitleColor restoreDefaultMenuParameters)('misc' addModelItemsToWindowMenu: browseThemes defaultValueTableForCurrentRelease giveHelpWithPreferences installTheme: menuColorString offerThemesMenu okayToChangeProjectLocalnessOf: roundedCornersString setArrowheads setFlag:toValue:during: soundEnablingString staggerPolicyString themeChoiceButtonOfColor:font: toggleMenuColorPolicy toggleRoundedCorners toggleSoundEnabling toggleWindowPolicy wantsChangeSetLogging)('parameters' acceptAnnotationsFrom: annotationEditingWindow annotationInfo borderColorWhenRunning defaultAnnotationRequests defaultAnnotationRequests: defaultAuthorName defaultPaintingExtent desktopColor desktopColor: editAnnotations expungeParameter: initializeParameters inspectParameters maxBalloonHelpLineLength parameterAt: parameterAt:default: parameterAt:ifAbsent: parameterAt:ifAbsentPut: scrollBarColor scrollBarWidth setDefaultAnnotationInfo setParameter:to:)('personalization' compileHardCodedPref:enable: disableProgrammerFacilities enableProgrammerFacilities letUserPersonalizeMenu loadPreferencesFrom: personalizeUserMenu: restorePersonalPreferences restorePreferencesFromDisk savePersonalPreferences storePreferencesIn: storePreferencesToDisk)('preference-object access' allPreferenceObjects preferenceAt: preferenceAt:ifAbsent:)('preferences panel' initialExtent initializePreferencePanel:in: inspectPreferences listOfCategories openFactoredPanel openFactoredPanelWithWidth: openNewPreferencesPanel openPreferencesControlPanel openPreferencesInspector preferenceObjectsInCategory: preferencesControlPanel)('reacting to change' annotationPanesChanged classicTilesSettingToggled eToyFriendlyChanged infiniteUndoChanged largeTilesSettingToggled mouseOverHalosChanged optionalButtonsChanged roundedWindowCornersChanged setNotificationParametersForStandardPreferences sharedFlapsSettingChanged showProjectNavigatorChanged smartUpdatingChanged universalTilesSettingToggled)('scrollbar parameters' fontFactor)('standard queries' abbreviatedBrowserButtons allowCelesteTell alphabeticalProjectMenu alternativeBrowseIt alternativeButtonsInScrollBars alternativeScrollbarLook alternativeWindowBoxesLook alternativeWindowLook alwaysHideHScrollbar alwaysShowConnectionVocabulary alwaysShowHScrollbar alwaysShowVScrollbar annotationPanes ansiAssignmentOperatorWhenPrettyPrinting areaFillsAreTolerant areaFillsAreVeryTolerant autoAccessors automaticFlapLayout automaticKeyGeneration automaticPlatformSettings automaticViewerPlacement balloonHelpEnabled balloonHelpInMessageLists batchPenTrails biggerHandles browseWithDragNDrop browseWithPrettyPrint browserNagIfNoClassComment browserShowsPackagePane canRecordWhilePlaying capitalizedReferences caseSensitiveFinds cautionBeforeClosing celesteHasStatusPane celesteShowsAttachmentsFlag changeSetVersionNumbers checkForSlips checkForUnsavedProjects classicNavigatorEnabled classicNewMorphMenu clickOnLabelToEdit cmdDotEnabled collapseWindowsInPlace colorWhenPrettyPrinting compactViewerFlaps compressFlashImages confirmFirstUseOfStyle conversionMethodsAtFileOut cpuWatcherEnabled debugHaloHandle debugLogTimestamp debugPrintSpaceLog debugShowDamage decorateBrowserButtons diffsInChangeList diffsWithPrettyPrint dismissAllOnOptionClose dragNDropWithAnimation dropProducesWatcher duplicateControlAndAltKeys eToyFriendly eToyLoginEnabled enableLocalSave expandedPublishing extraDebuggerButtons extractFlashInHighQuality extractFlashInHighestQuality fastDragWindowForMorphic fenceEnabled fenceSoundEnabled fenceSoundEnabled: fullScreenLeavesDeskMargins gradientMenu gradientScrollBars haloEnclosesFullBounds haloTransitions higherPerformance honorDesktopCmdKeys ignoreStyleIfOnlyBold inboardScrollbars includeSoundControlInNavigator infiniteUndo logDebuggerStackToFile magicHalos menuAppearance3d menuButtonInToolPane menuColorFromWorld menuKeyboardControl menuWithIcons modalColorPickers mouseOverForKeyboardFocus mouseOverHalos mvcProjectsAllowed navigatorOnLeftEdge noviceMode okToReinitializeFlaps oliveHandleForScriptedObjects optionalButtons passwordsOnPublish personalizedWorldMenu postscriptStoredAsEPS preserveTrash printAlternateSyntax projectViewsInWindows projectZoom projectsSentToDisk promptForUpdateServer propertySheetFromHalo restartAlsoProceeds reverseWindowStagger roundedMenuCorners roundedWindowCorners scrollBarsNarrow scrollBarsOnRight scrollBarsWithoutMenuButton securityChecksEnabled selectionsMayShrink selectiveHalos showBoundsInHalo showDeprecationWarnings showDirectionForSketches showDirectionHandles showFlapsWhenPublishing showLinesInHierarchyViews showProjectNavigator showSecurityStatus showSharedFlaps signProjectFiles simpleMenus slideDismissalsToTrash smartUpdating soundQuickStart soundStopWhenDone soundsEnabled standaloneSecurityChecksEnabled startInUntrustedDirectory swapControlAndAltKeys swapMouseButtons systemWindowEmbedOK thoroughSenders tileTranslucentDrag timeStampsInMenuTitles turnOffPowerManager twentyFourHourFileStamps twoSidedPoohTextures typeCheckingInTileScripting uniTilesClassic uniqueNamesInHalos universalTiles unlimitedPaintArea updateSavesFile useButtonProprtiesToFire useFileList2 useFormsInPaintBox useSmartLabels useUndo viewersInFlaps warnAboutInsecureContent warnIfNoChangesFile warnIfNoSourcesFile warningForMacOSFileNameLength wordStyleCursorMovement)('text highlighting' chooseInsertionPointColor chooseKeyboardFocusColor chooseTextHighlightColor initializeTextHighlightingParameters insertionPointColor insertionPointColor: keyboardFocusColor keyboardFocusColor: textHighlightColor textHighlightColor:)('themes' brightSqueak keihanna magdeburg outOfTheBox paloAlto personal smalltalk80 takanawa westwood)('window colors' darkenStandardWindowPreferences installBrightWindowColors installMissingWindowColors installPastelWindowColors installUniformWindowColors installWindowColorsVia: lightenStandardWindowPreferences setWindowColorFor:to: windowColorFor: windowColorHelp windowColorTable windowSpecificationPanel)('paintbox' useFormsInPaintBox:)('class initialization' initialize registerInFlapsRegistry unload)('*customevents-preferences' allowEtoyUserCustomEvents)('*connectors-preferences' chooseConnectorsLabelFont connectorsLabelFont setConnectorsLabelFontTo:)('*connectors-fonts-override' presentMvcFontConfigurationMenu)!!MorphTest reorganize!('initialize-release' getWorld setUp tearDown)('testing - into/outOf World' testIntoWorldCollapseOutOfWorld testIntoWorldDeleteOutOfWorld testIntoWorldTransferToNewGuy)('testing - classification' testIsMorph)('testing - file in/file out')('testing - initialization' testOpenInWorld)('testing - etoys' testOverlapAny testOverlapAnyDeletedPlayer testOverlapAnyScriptedPlayer testOverlapAnyUnscriptedPlayer)!Latin1 class removeSelector: #charSetSize!Latin1 class removeSelector: #scanSelector!KSX1001 class removeSelector: #charSetSize!JISX0208 class removeSelector: #charSetSize!ISO88592TextConverter initialize!GB2312 class removeSelector: #charSetSize!FileStream class removeSelector: #writeUTF8PreambleOn:!EncodedCharSet class removeSelector: #charSetSize!EncodedCharSet initialize!CP1250TextConverter initialize!