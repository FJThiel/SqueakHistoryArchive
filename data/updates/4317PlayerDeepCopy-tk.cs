'From Squeak3.1alpha of 28 February 2001 [latest update: #4298] on 4 September 2001 at 5:57:59 pm'!"Change Set:		PlayerDeepCopy-tkDate:			4 September 2001Author:			Ted KaehlerWhen the user instance variables of a Player are veryDeepCopied, what do we do?  Default is veryDeepCopy.  For a Player, costume of a Player, or morph:	If the morph is in the dictionary (in the subtree), veryDeepCopy it.  (Make a sibling instance of any Player.)  If not, just point at the original.	Another fix:  Players created by vector arithmetic are not installed in the world.  Use append: if you want the result to show in the world."!!DeepCopier commentStamp: 'tk 9/4/2001 09:48' prior: 0!DeepCopier does a veryDeepCopy.  It is a complete tree copy using a dictionary.  Any object that is in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy.  See Object|veryDeepCopy which calls (self veryDeepCopyWith: aDeepCopier).The dictionary of objects that have been seen, holds the correspondance (uniClass -> new uniClass).When a tree of morphs points at a morph outside of itself, that morph should not be copied.  Use our own kind of weak pointers for the 'potentially outside' morphs.   Default is that any new class will have all of its fields deeply copied.  If a field needs to be weakly copied, define veryDeepInner: and veryDeepFixupWith:.     veryDeepInner: has the loop that actually copies the fields.  If a class defines its own copy of veryDeepInner: (to leave some fields out), then veryDeepFixupWith: will be called on that object at the end.  veryDeepInner: can compute an alternate object to put in a field.  (Object veryDeepCopyWith: discovers which superclasses did not define veryDeepInner:, and very deeply copies the variables defined in those classes).	To decide if a class needs veryDeepInner: and veryDeepFixupWith:, ask this about an instance:  If I duplicate this object, does that mean that I also want to make duplicates of the things it holds onto?  If yes, (i.e. a Paragraph does want a new copy of its Text) then do nothing.  If no, (i.e. an undo command does not want to copy the objects it acts upon), then define veryDeepInner: and veryDeepFixupWith:.	Here is an analysis for the specific case of a morph being held by another morph.  Does field X contain a morph (or a Player whose costume is a morph)?  If not, no action needed.Is the morph in field X already a submorph of the object?  Is it down lower in the submorph tree?	If so, no action needed.Could the morph in field X every appear on the screen (be a submorph of some other morph)?	If not, no action needed.	If it could, you must write the methods veryDeepFixupWith:   and   veryDeepInner:, and in them, refrain from sending veryDeepCopyWith: to the contents of field X.----- Things Ted is still considering -----Rule:  If a morph stores a uniClass class (Player 57) as an object in a field, the new uniClass will not be stored there.   Each uniClass instance does have a new class created for it.  (fix this by putting the old class in references and allow lookup?  Wrong if encounter it before seeing an instance?)Rule: If object A has object C in a field, and A says (^ C) for the copy, but object B has A in a normal field and it gets deepCopied, and A in encountered first, then there will be two copies of C.  (just be aware of it)Dependents are now fixed up.  Suppose a model has a dependent view.  In the DependentFields dictionary, model -> (view ...).  	If only the model is copied, no dependents are created (no one knows about the new model).  	If only the view is copied, it is inserted into DependentFields on the right side.  model -> (view  copiedView ...).  	If both are copied, the new model has the new view as its dependent.	If additional things depend on a model that is copied, the caller must add them to its dependents.!!Object methodsFor: 'copying' stamp: 'tk 9/4/2001 10:51'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new uc sup has mine |	deepCopier references at: self ifPresent: [:newer | ^ newer]. 	"already did him"	class _ self class.	class isMeta ifTrue: [^ self].		"a class"	new _ self clone.	class isSystemDefined ifFalse: [		uc _ deepCopier uniClasses at: class ifAbsent: [nil].		uc ifNil: [			deepCopier uniClasses at: class put: (uc _ self copyUniClassWith: deepCopier).			deepCopier references at: class put: uc].	"remember"		new _ uc new.		new copyFrom: self].	"copy inst vars in case any are weak"	deepCopier references at: self put: new.	"remember"	(class isVariable and: [class isPointers]) ifTrue: 		[index _ self basicSize.		[index > 0] whileTrue: 			[sub _ self basicAt: index.			(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])				ifNil: [new basicAt: index put: (sub veryDeepCopyWith: deepCopier)]				ifNotNil: [new basicAt: index put: subAss value].			index _ index - 1]].	"Ask each superclass if it wants to share (weak copy) any inst vars"	new veryDeepInner: deepCopier.		"does super a lot"	"other superclasses want all inst vars deep copied"	sup _ class.  index _ class instSize.	[has _ sup compiledMethodAt: #veryDeepInner: ifAbsent: [nil].	has _ has ifNil: [class isSystemDefined not "is a uniClass"] ifNotNil: [true].	mine _ sup instVarNames.	has ifTrue: [index _ index - mine size]	"skip inst vars"		ifFalse: [1 to: mine size do: [:xx |				sub _ self instVarAt: index.				(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])						"use association, not value, so nil is an exceptional value"					ifNil: [new instVarAt: index put: 								(sub veryDeepCopyWith: deepCopier)]					ifNotNil: [new instVarAt: index put: subAss value].				index _ index - 1]].	(sup _ sup superclass) == nil] whileFalse.	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!Object methodsFor: 'copying' stamp: 'tk 9/4/2001 10:30'!veryDeepInner: deepCopier	"No special treatment for inst vars of my superclasses.  Override when some need to be weakly copied.  Object>>veryDeepCopyWith: will veryDeepCopy any inst var whose class does not actually define veryDeepInner:"! !!Object methodsFor: 'copying' stamp: 'tk 9/4/2001 17:57'!veryDeepPvtSibling: deepCopier	"Copy the instance variables of a new sibling of a Player.  Private method."	| index sub subAss sup has mine |	"Ask each superclass if it wants to share (weak copy) any inst vars"	self veryDeepInner: deepCopier.		"does super a lot"	"other superclasses want all inst vars deep copied"	sup _ self class.  index _ self class instSize.	[has _ sup compiledMethodAt: #veryDeepInner: ifAbsent: [nil].	has _ has ifNil: [self class isSystemDefined not "is a uniClass"] ifNotNil: [true].	mine _ sup instVarNames.	has ifTrue: [index _ index - mine size]	"skip inst vars"		ifFalse: [1 to: mine size do: [:xx |				sub _ self instVarAt: index.				(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])						"use association, not value, so nil is an exceptional value"					ifNil: [self instVarAt: index put: 								(sub veryDeepCopyWith: deepCopier)]					ifNotNil: [self instVarAt: index put: subAss value].				index _ index - 1]].	(sup _ sup superclass) == nil] whileFalse.	self rehash. 	"force Sets and Dictionaries to rehash"! !!Player methodsFor: 'copying' stamp: 'tk 9/4/2001 11:10'!veryDeepFixupWith: deepCopier	| old |	"Any uniClass inst var may have been weakly copied.  If they were in the tree being copied, fix them up, otherwise point to the originals."super veryDeepFixupWith: deepCopier.Player instSize + 1 to: self class instSize do:	[:ii | old _ self instVarAt: ii.	self instVarAt: ii put: (deepCopier references at: old ifAbsent: [old])].! !!Player methodsFor: 'copying' stamp: 'tk 9/4/2001 17:14'!veryDeepInner: deepCopier	"Special code that handles user added instance variables of 	Copy all of my instance variables.  Some need to be not copied at all, but shared.  This is special code for the dictionary.  See DeepCopier."	| instVar weak subAss |	super veryDeepInner: deepCopier.	"my own instance variables are completely normal"	costume _ costume veryDeepCopyWith: deepCopier.	costumes _ costumes veryDeepCopyWith: deepCopier.	Player instSize + 1 to: self class instSize do: [:index |		instVar _ self instVarAt: index.		weak _ instVar isMorph | instVar class isSystemDefined not. 		(subAss _ deepCopier references associationAt: instVar ifAbsent: [nil])				"use association, not value, so nil is an exceptional value"			ifNil: [weak ifFalse: [					self instVarAt: index put: (instVar veryDeepCopyWith: deepCopier)]]			ifNotNil: [self instVarAt: index put: subAss value].		].!]style[(25 194 10 672)f1b,f1,f1LDeepCopier Comment;,f1! !!Player reorganize!('card/stack commands' deleteCard firstPage getRoundedCorners goToCard: goToFirstCardInBackground goToFirstCardOfStack goToLastCardInBackground goToLastCardOfStack goToNextCardInStack goToPreviousCardInStack goto: insertCard lastPage nextPage previousPage setRoundedCorners:)('copying' copyUniClassWith: initializeCostumesFrom: veryDeepFixupWith: veryDeepInner:)('costume' availableCostumeNames availableCostumesForArrows clearOwnersPenTrails clearPenTrails costume costume: costumeRespondingTo: costumes costumesDo: forgetOtherCostumes getValueFromCostume: hasAnyBorderedCostumes hasCostumeThatIsAWorld hasOnlySketchCostumes knownSketchCostumeWithSameFormAs: newCostume rawCostume: recaptureUniqueCostumes rememberCostume: renderedCostume: renderedCostume:remember: resetCostumeList sendMessageToCostume: sendMessageToCostume:with: setCostumeSlot:toValue: stamp stampAndErase tearOffButtonToFireScriptForSelector: wearCostumeOf: wearCostumeOfClass: wearCostumeOfName:)('heading' headDown headLeft headRight headUp)('name' externalName knownName renameTo: tryToRenameTo:)('pen' addPlayerMenuItemsTo:hand: choosePenColor: choosePenSize clearTurtleTrails colorUnder defaultPenColor defaultPenSize getPenColor getPenDown getPenSize liftAllPens liftPen lowerAllPens lowerPen penColor: setPenColor: uniqueNameForReference)('slots-kernel' categories categoriesForWorld methodInterfacesForInstanceVariablesCategoryIn: methodInterfacesForScriptsCategoryIn: slotInfo slotNames typeForSlot: typeForSlot:vocabulary: typeForSlotWithGetter: usableMethodInterfacesIn: usablePhraseSpecsIn:)('slot getters/setters' cameraPoint cameraPoint: getActWhen getAllButFirstCharacter getAmount getAngle getBorderColor getBorderWidth getBottom getBrightnessUnder getCameraPoint getCharacters getColor getColorUnder getConePosition getCostume getCostumeAtCursor getCursor getCursorWrapped getDescending getDistance getFirstCharacter getFirstElement getGetListSelector getGraphic getGraphicAtCursor getHeading getHeadingUnrounded getHeight getHolder getIndexInOwner getIsUnderMouse getKnobColor getLabel getLastValue getLeft getLeftRight getLuminanceUnder getMaxVal getMinVal getMouseX getMouseY getName getNewClone getNumberAtCursor getNumericValue getOffsetX getOffsetY getPlayerAtCursor getRight getRotationStyle getSampleAtCursor getSaturationUnder getScale getScaleFactor getSpeed getTheta getTop getTruncate getUpDown getValueAtCursor getViewingByIcon getWidth getX getY handTheUserACopy setActWhen: setAllButFirstCharacter: setBorderColor: setBorderWidth: setBottom: setCameraPoint: setCharacters: setColor: setColorUnder: setConePosition: setCostume: setCursor: setCursorWrapped: setDescending: setDistance: setFirstCharacter: setFirstElement: setGetListSelector: setGraphic: setHeading: setHeight: setIndexInOwner: setKnobColor: setLabel: setLastValue: setLeft: setMaxVal: setMinVal: setName: setNumberAtCursor: setNumericValue: setOffsetX: setOffsetY: setRight: setRotationStyle: setSampleAtCursor: setScale: setScaleFactor: setTheta: setTop: setTruncate: setValueAtCursor: setViewingByIcon: setWidth: setX: setY:)('slots-user' addInstanceVariable addInstanceVariableNamed:type:value: addSpecialSetter: chooseSlotTypeFor: chooseUserSlot compileInstVarAccessorsFor: doesNotUnderstand: hasUserDefinedScripts hasUserDefinedSlots initialTypeForSlotNamed: initialValueForSlotOfType: offerGetterTiles: removeSlotNamed: renameSlot: renameSlot:newSlotName: setPrecisionFor: slotInfoAt: slotInfoAt:ifAbsent: slotInfoForGetter: slotNamesOfType: tearOffFancyWatcherFor: tearOffWatcherFor: valueOfType:from:)('slots-assignment' assignDecrGetter:setter:amt: assignGetter:setter:amt: assignIncrGetter:setter:amt: assignMultGetter:setter:amt:)('scripts-kernel' acceptScript:for: allScriptEditors editDescriptionForSelector: elementTypeFor:vocabulary: emptyScript expungeEmptyScripts expungeEmptyUnRenamedScripts hasScriptInvoking:ofPlayer: hasScriptReferencing:ofPlayer: infoFor:inViewer: instantiatedUserScriptsDo: isEmptyTileScript: isExpendableScript: isUniversalTiles makeIsolatedCodePaneForSelector: methodInterfaceForEmptyScript newScriptorAround: newTextualScriptorFor: noteRenameOf:to:inPlayer: okayToDestroyScriptNamed: okayToRemoveSlotNamed: pacifyScript: removeScript:fromWorld: removeScriptWithSelector: removeScriptWithoutUpdatingViewers: removeScriptWithoutUpdatingViewers:fromWorld: renameScript: renameScript:newSelector: runScript: scriptEditorFor: scriptEvaluatorFor:phrase: scriptInstantiationForSelector: scriptorsForSelector:inWorld: slotInfoButtonHitFor:inViewer: sourceCodeFor: tileScriptCommands tilesToCall: universalTilesForInterface:)('scripts-execution' assureEventHandlerRepresentsStatus fireOnce prepareToBeRunning runAllClosingScripts runAllOpeningScripts runAllTickingScripts: scriptPerformer scriptingError: startRunning startRunningScripts step stepAt: stopProgramatically stopRunning wantsSteps)('scripts-standard' append: bounce: changeScript:toStatus: clear contents contents: doButtonAction doMenuItem: fire followPath forward: getObtrudes goToRightOf: hide initiatePainting loadSineWave loadSound: makeNewDrawingIn: menuItemAfter: menuItemBefore: moveToward: pauseScript: play removeAll reverse setPenDown: setPenSize: show shuffleContents startScript: stopScript: tellAllSiblings: turn: wrap)('scripts-vector' * + - / asPoint decr: dividedBy: incr: multBy:)('misc' actorState allOpenViewers allOpenViewersOnReceiverAndSiblings assureUniClass basicType beNotZero: belongsToUniClass browseEToyVocabulary browsePlayerClass categoriesForViewer: color color:sees: defaultFloatPrecisionFor: defaultLabelForInspector dummy erase getIsOverColor: grabPlayerIn: grabScriptorForSelector:in: graphicForViewerTab indicateLocationOnScreen isPlayerLike makeBounceSound: nameForViewer noteDeletionOf:fromWorld: offerAlternateViewerMenuFor:event: offerViewerMenuFor:event: openSearchingVocabularyBrowser openUnderlyingScriptorFor: ordinalNumber presenter printOn: revealPlayerIn: revertToUnscriptedPlayerIfAppropriate roundUpStrays seesColor: stack stringForReadout tearOffTileForSelf thumbnailMenuEvt:forMorph: tileReferringToSelf tileToRefer touchesA: unhideHiddenObjects uninstallFrom: unusedScriptName updateAllViewers updateAllViewersAndForceToShow: viewerFlapTab width)('object fileIn')('fileIn/Out' comeFullyUpOnReload: releaseCachedState storeDataOn:)('slots-wonderland' getFogColor getFogDensity getFogRangeEnd getFogRangeStart getFogType setFogColor: setFogDensity: setFogRangeEnd: setFogRangeStart: setFogType:)!