'From Squeak2.9alpha of 13 June 2000 [latest update: #2989] on 9 November 2000 at 7:01:29 pm'!"Change Set:		RenameMethods-arDate:			9 November 2000Author:			Andreas RaabRenames some methods that were to dangerous to put into the previous update."!!Morph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:48'!adjustBounds	"Adjust the receivers bounds depending on the resizing strategy imposed"	| hFit vFit box myExtent extent |	hFit _ self hResizing.	vFit _ self vResizing.	(hFit == #shrinkWrap or:[vFit == #shrinkWrap]) ifFalse:[^self]. "not needed"	box _ self layoutBounds.	myExtent _ box extent.	extent _ self submorphBounds corner - box origin.	hFit == #shrinkWrap ifTrue:[myExtent _ extent x @ myExtent y].	vFit == #shrinkWrap ifTrue:[myExtent _ myExtent x @ extent y].	"Make sure we don't get smaller than minWidth/minHeight"	myExtent x < self minWidth ifTrue:[		myExtent _ (myExtent x max: 			(self minWidth - self bounds width + self layoutBounds width)) @ myExtent y].	myExtent y < self minHeight ifTrue:[		myExtent _ myExtent x @ (myExtent y max:			(self minHeight - self bounds height + self layoutBounds height))].	self layoutBounds: (box origin extent: myExtent).! !!Morph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:48'!minExtent	"Layout specific. Return the minimum size the receiver can be represented in.	Implementation note: When this message is sent from an owner trying to lay out its children it will traverse down the morph tree and recompute the minimal arrangement of the morphs based on which the minimal extent is returned. When a morph with some layout strategy is encountered, the morph will ask its strategy to compute the new arrangement. However, since the final size given to the receiver is unknown at the point of the query, the assumption is made that the current bounds of the receiver are the base on which the layout should be computed. This scheme prevents strange layout changes when for instance, a table is contained in another table. Unless the inner table has been resized manually (which means its bounds are already enlarged) the arrangement of the inner table will not change here. Thus the entire layout computation is basically an iterative process which may have different results depending on the incremental changes applied."	| layout minExtent extra |self flag: #arNote. "take a clipping receiver into account..."	"optimize for #rigid receiver (doesn't require layout computation)"	(self hResizing == #rigid and:[self vResizing == #rigid]) 		ifTrue:[^self fullBounds extent].	layout _ self layoutPolicy.	layout == nil		ifTrue:[minExtent _ self hasSubmorphs 					ifTrue:[self submorphBounds corner - bounds origin]					ifFalse:[0@0]]		ifFalse:[minExtent _ layout minExtentOf: self in: self layoutBounds].	minExtent _ minExtent max: (self minWidth@self minHeight).	self hResizing == #rigid		ifTrue:[	minExtent _ self fullBounds extent x @ minExtent y]		ifFalse:[	extra _ self bounds width - self layoutBounds width.				minExtent _ (minExtent x + extra) @ minExtent y].	self vResizing == #rigid		ifTrue:[minExtent _ minExtent x @ self fullBounds extent y]		ifFalse:[extra _ self bounds height - self layoutBounds height.				minExtent _ minExtent x @ (minExtent y + extra)].	^minExtent! !!Morph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:46'!minHeight	^self valueOfProperty: #minHeight ifAbsent:[2]! !!Morph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:45'!minHeight: aNumber	aNumber == nil		ifTrue:[self removeProperty: #minHeight]		ifFalse:[self setProperty: #minHeight toValue: aNumber].	self layoutChanged.! !!Morph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:46'!minWidth	^self valueOfProperty: #minWidth ifAbsent:[2]! !!Morph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:45'!minWidth: aNumber	aNumber == nil		ifTrue:[self removeProperty: #minWidth]		ifFalse:[self setProperty: #minWidth toValue: aNumber].	self layoutChanged.! !!MenuLineMorph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:46'!minHeight	^ 2! !!MenuLineMorph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:46'!minWidth	^ 10! !!PasteUpMorph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:47'!convertAlignment	self clipSubmorphs: true.	(autoLineLayout == true) ifTrue:[		self layoutPolicy: TableLayout new.		self layoutInset: 8; cellInset: 4.		self listDirection: #leftToRight; wrapDirection: #topToBottom.		self minHeight: self height.	] ifFalse:[		self layoutPolicy: nil.		self layoutInset: 0; cellInset: 0.	].	(resizeToFit == true) ifTrue:[		self vResizing: #shrinkWrap.	] ifFalse:[		self vResizing: #rigid.	].! !!ScriptEditorMorph methodsFor: 'other' stamp: 'ar 11/9/2000 18:46'!minWidth	^160! !!StringMorph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:46'!minHeight	^self fontToUse height! !!MenuItemMorph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:46'!minHeight	^ self fontToUse height! !!MenuItemMorph methodsFor: 'layout' stamp: 'ar 11/9/2000 18:46'!minWidth	| scanner |	scanner _ DisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.	^ (scanner stringWidth: contents) + (subMenu == nil ifTrue: [0] ifFalse: [10])! !MenuItemMorph removeSelector: #xMinHeight!MenuItemMorph removeSelector: #xMinWidth!StringMorph removeSelector: #xMinHeight!ScriptEditorMorph removeSelector: #xMinWidth!MenuLineMorph removeSelector: #xMinHeight!MenuLineMorph removeSelector: #xMinWidth!Morph removeSelector: #xMinHeight!Morph removeSelector: #xMinHeight:!Morph removeSelector: #xMinWidth!Morph removeSelector: #xMinWidth:!