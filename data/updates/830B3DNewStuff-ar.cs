'From Squeak 2.3 of January 14, 1999 on 18 April 1999 at 8:14:39 am'!"Change Set:		B3DNewStuff-arDate:			18 April 1999Author:			Andreas RaabThis change set contains several modifications to the low level Balloon 3D engine including:* The first version of the portable rasterizer* Primitive support for clipping and picking* Lots of fixes all over the place"!B3DEnginePlugin subclass: #B3DClipperPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Plugins'!B3DEnginePlugin subclass: #B3DPickerPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Plugins'!Object variableWordSubclass: #B3DPrimitiveRasterizerData	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-PrimitiveEngine'!Object subclass: #B3DPrimitiveRasterizerState	instanceVariableNames: 'faceAlloc edgeAlloc attrAlloc aet addedEdges fillList objects textures spanBuffer bitBlt '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-PrimitiveEngine'!B3DEnginePlugin subclass: #B3DRasterizerPlugin	instanceVariableNames: 'state viewport '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Plugins'!B3DEnginePart subclass: #B3DRenderEngine	instanceVariableNames: 'vertexBuffer transformer shader clipper rasterizer '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!B3DRenderEngine subclass: #B3DPickerEngine	instanceVariableNames: 'pickMatrix pickList objects '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!B3DRenderEngine subclass: #B3DPrimitiveEngine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-PrimitiveEngine'!B3DVertexClipper subclass: #B3DPrimitiveClipper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'B3DEngineConstants '	category: 'Balloon-3D-PrimitiveEngine'!B3DVertexRasterizer subclass: #B3DPrimitiveRasterizer	instanceVariableNames: 'canvas state primObjects textures '	classVariableNames: 'B3DNoMoreAET B3DNoMoreAdded B3DNoMoreAttrs B3DNoMoreEdges B3DNoMoreFaces '	poolDictionaries: ''	category: 'Balloon-3D-PrimitiveEngine'!B3DVertexShader subclass: #B3DPrimitiveShader	instanceVariableNames: 'primitiveLights '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-PrimitiveEngine'!B3DEnginePart subclass: #B3DVertexTransformer	instanceVariableNames: 'modelMatrix viewMatrix textureMatrix currentMatrix needsUpdate matrixStack matrixState '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!B3DVertexTransformer subclass: #B3DPrimitiveTransformer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-PrimitiveEngine'!B3DMaterialColor variableWordSubclass: #B3DPrimitiveLight	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'B3DEngineConstants '	category: 'Balloon-3D-PrimitiveEngine'!!B3DEnginePart methodsFor: 'initialize' stamp: 'ar 4/10/1999 22:52'!reset! !!B3DEnginePlugin methodsFor: 'primitive support' stamp: 'ar 4/12/1999 02:15'!stackPrimitiveIndexArray: stackIndex ofSize: nItems validate: aBool forVertexSize: maxIndex	"Load a primitive index array from the interpreter stack.	If aBool is true then check that all the indexes are in the range (1,maxIndex).	Return a pointer to the index data if successful, nil otherwise."	| oop oopSize idxPtr index |	self inline: false.	self returnTypeC:'void*'.	self var: #idxPtr declareC:'int *idxPtr'.	oop _ interpreterProxy stackObjectValue: stackIndex.	oop = nil ifTrue:[^nil].	(interpreterProxy isWords: oop) ifFalse:[^nil]. 	oopSize _ interpreterProxy slotSizeOf: oop.	oopSize < nItems ifTrue:[^nil].	idxPtr _ self cCoerce: (interpreterProxy firstIndexableField: oop) to:'int *'.	aBool ifTrue:[		0 to: nItems-1 do:[:i|			index _ idxPtr at: i.			(index < 0 or:[index > maxIndex]) ifTrue:[^nil]]].	^idxPtr! !!B3DClipperPlugin methodsFor: 'primitives' stamp: 'ar 4/18/1999 02:58'!b3dClipPolygon	"Primitive. Clip the polygon given in the vertexArray using the temporary vertex array which is assumed to have sufficient size."	| outMask vtxCount vtxArray tempVtxArray count |	self export: true.	self inline: false.	self var: #vtxArray declareC:'int *vtxArray'.	self var: #tempVtxArray declareC:'int *tempVtxArray'.	interpreterProxy methodArgumentCount = 4		ifFalse:[^interpreterProxy primitiveFail].	outMask _ interpreterProxy stackIntegerValue: 0.	vtxCount _ interpreterProxy stackIntegerValue: 2.	vtxArray _ self stackPrimitiveVertexArray: 3 ofSize: vtxCount + 4.	tempVtxArray _ self stackPrimitiveVertexArray: 1 ofSize: vtxCount + 4.	(vtxArray == nil or:[tempVtxArray == nil or:[interpreterProxy failed]])		ifTrue:[^interpreterProxy primitiveFail].	"Hack pointers for one-based indexes"	vtxArray _ vtxArray - PrimVertexSize.	tempVtxArray _ tempVtxArray - PrimVertexSize.	count _ self clipPolygon: vtxArray count: vtxCount with: tempVtxArray mask: outMask.	interpreterProxy pop: 4.	interpreterProxy pushInteger: count.! !!B3DClipperPlugin methodsFor: 'primitives' stamp: 'ar 4/16/1999 01:54'!b3dDetermineClipFlags	"Primitive. Determine the clipping flags for all vertices."	| vtxCount vtxArray result |	self export: true.	self inline: false.	self var: #vtxArray declareC:'void *vtxArray'.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	vtxCount _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	vtxArray _ self stackPrimitiveVertexArray: 1 ofSize: vtxCount.	(vtxArray == nil or:[interpreterProxy failed])		ifTrue:[^interpreterProxy primitiveFail].	result _ self determineClipFlags: vtxArray count: vtxCount.	interpreterProxy failed ifFalse:[		interpreterProxy pop: 3.		interpreterProxy pushInteger: result.	].! !!B3DClipperPlugin methodsFor: 'primitives' stamp: 'ar 4/18/1999 02:59'!b3dPrimitiveNextClippedTriangle	"Primitive. Return the next clipped triangle from the vertex buffer and return its index."	| idxCount vtxCount firstIndex vtxArray idxArray idx1 idx2 idx3 triMask |	self export: true.	self inline: false.	self var: #idxArray declareC:'int *idxArray'.	self var: #vtxArray declareC:'int *vtxArray'.	interpreterProxy methodArgumentCount = 5		ifFalse:[^interpreterProxy primitiveFail].	idxCount _ interpreterProxy stackIntegerValue: 0.	vtxCount _ interpreterProxy stackIntegerValue: 2.	firstIndex _ interpreterProxy stackIntegerValue: 4.	interpreterProxy failed ifTrue:[^nil].	vtxArray _ self stackPrimitiveVertexArray: 3 ofSize: vtxCount.	idxArray _ self stackPrimitiveIndexArray: 1 ofSize: idxCount validate: true forVertexSize: vtxCount.	(vtxArray == nil or:[idxArray == nil or:[interpreterProxy failed]])		ifTrue:[^interpreterProxy primitiveFail].	"Hack idxArray and vtxArray for 1-based indexes"	idxArray _ idxArray - 1.	vtxArray _ vtxArray - PrimVertexSize.	firstIndex to: idxCount by: 3 do:[:i|		idx1 _ idxArray at: i.		idx2 _ idxArray at: i+1.		idx3 _ idxArray at: i+2.		(idx1 == 0 or:[idx2 == 0 or:[idx3 == 0]]) ifFalse:[			triMask _ ((vtxArray at: idx1 * PrimVertexSize + PrimVtxClipFlags) bitAnd:						((vtxArray at: idx2 * PrimVertexSize + PrimVtxClipFlags) bitAnd:						(vtxArray at: idx3 * PrimVertexSize + PrimVtxClipFlags))).			"Check if tri is completely inside"			(InAllMask bitAnd: triMask) = InAllMask ifFalse:[				"Tri is not completely inside -> needs clipping."				(triMask anyMask: OutAllMask) ifTrue:[					"tri is completely outside. Store all zeros"					idxArray at: i put: 0.					idxArray at: i+1 put: 0.					idxArray at: i+2 put: 0.				] ifFalse:[					"tri must be partially clipped."					interpreterProxy pop: 6. "args + rcvr"					interpreterProxy pushInteger: i.					^nil				].			].		].	].	"No more entries"	interpreterProxy pop: 6. "args + rcvr"	interpreterProxy pushInteger: 0.! !!B3DClipperPlugin methodsFor: 'clipping' stamp: 'ar 4/16/1999 06:03'!clipPolygon: vtxArray count: vtxCount with: tempVtxArray mask: outMask	| count |	self var: #vtxArray declareC:'int *vtxArray'.	self var: #tempVtxArray declareC:'int *tempVtxArray'.	"Check if the polygon is outside one boundary only.	If so, just do this single clipping operation avoiding multiple enumeration."	outMask = OutLeftBit 		ifTrue:[^self clipPolygonLeftFrom: tempVtxArray to: vtxArray count: vtxCount].	outMask = OutRightBit 		ifTrue:[^self clipPolygonRightFrom: tempVtxArray to: vtxArray count: vtxCount].	outMask = OutTopBit 		ifTrue:[^self clipPolygonTopFrom: tempVtxArray to: vtxArray count: vtxCount].	outMask = OutBottomBit 		ifTrue:[^self clipPolygonBottomFrom: tempVtxArray to: vtxArray count: vtxCount].	outMask = OutFrontBit 		ifTrue:[^self clipPolygonFrontFrom: tempVtxArray to: vtxArray count: vtxCount].	outMask = OutBackBit 		ifTrue:[^self clipPolygonBackFrom: tempVtxArray to: vtxArray count: vtxCount].	"Just do each of the clipping operations"	count _ vtxCount.	count _ self clipPolygonLeftFrom: vtxArray to: tempVtxArray count: count.	count = 0 ifTrue:[^0].	count _ self clipPolygonRightFrom: tempVtxArray to: vtxArray count: count.	count = 0 ifTrue:[^0].	count _ self clipPolygonTopFrom: vtxArray to: tempVtxArray count: count.	count = 0 ifTrue:[^0].	count _ self clipPolygonBottomFrom: tempVtxArray to: vtxArray count: count.	count = 0 ifTrue:[^0].	count _ self clipPolygonFrontFrom: vtxArray to: tempVtxArray count: count.	count = 0 ifTrue:[^0].	count _ self clipPolygonBackFrom: tempVtxArray to: vtxArray count: count.	^count! !!B3DClipperPlugin methodsFor: 'clipping' stamp: 'ar 4/16/1999 01:57'!determineClipFlags: vtxArray count: count	| vtxPtr fullMask w w2 flags x y z |	self var: #vtxPtr declareC:'float *vtxPtr'.	self var: #vtxArray declareC:'void *vtxArray'.	self var: #x declareC:'double x'.	self var: #y declareC:'double y'.	self var: #z declareC:'double z'.	self var: #w declareC:'double w'.	self var: #w2 declareC:'double w2'.	vtxPtr _ self cCoerce: vtxArray to: 'float *'.	fullMask _ InAllMask + OutAllMask.	1 to: count do:[:i|		w _ vtxPtr at: PrimVtxRasterPosW.		w2 _ 0.0 - w.		flags _ 0.		x _ vtxPtr at: PrimVtxRasterPosX.		x >= w2 ifTrue:[flags _ flags bitOr: InLeftBit] ifFalse:[flags _ flags bitOr: OutLeftBit].		x <= w ifTrue:[flags _ flags bitOr: InRightBit] ifFalse:[flags _ flags bitOr: OutRightBit].		y _ vtxPtr at: PrimVtxRasterPosY.		y >= w2 ifTrue:[flags _ flags bitOr: InBottomBit] ifFalse:[flags _ flags bitOr: OutBottomBit].		y <= w ifTrue:[flags _ flags bitOr: InTopBit] ifFalse:[flags _ flags bitOr: OutTopBit].		z _ vtxPtr at: PrimVtxRasterPosZ.		z >= w2 ifTrue:[flags _ flags bitOr: InFrontBit] ifFalse:[flags _ flags bitOr: OutFrontBit].		z <= w ifTrue:[flags _ flags bitOr: InBackBit] ifFalse:[flags _ flags bitOr: OutBackBit].		fullMask _ fullMask bitAnd: flags.		(self cCoerce: vtxPtr to:'int *') at: PrimVtxClipFlags put: flags.		vtxPtr _ vtxPtr + PrimVertexSize.	].	^fullMask! !!B3DClipperPlugin methodsFor: 'clipping' stamp: 'ar 4/17/1999 22:21'!interpolateFrom: last to: next at: t into: out	"Interpolate the primitive vertices last/next at the parameter t"	| delta rgbaLast lastValue rgbaNext nextValue newValue x y z w w2 flags |	self var: #last declareC:'float *last'.	self var: #next declareC:'float *next'.	self var: #out declareC:'float *out'.	self var: #t declareC: 'double t'.	self var: #delta declareC: 'double delta'.	self var: #rgbaLast declareC:'unsigned int rgbaLast'.	self var: #rgbaNext declareC:'unsigned int rgbaNext'.	self var: #lastValue declareC:'unsigned int lastValue'.	self var: #nextValue declareC:'unsigned int nextValue'.	self var: #newValue declareC:'unsigned int newValue'.	self var: #x declareC:'double x'.	self var: #y declareC:'double y'.	self var: #z declareC:'double z'.	self var: #w declareC:'double w'.	self var: #w2 declareC:'double w2'.	"Interpolate raster position"	delta _ (next at: PrimVtxRasterPosX) - (last at: PrimVtxRasterPosX).	x _ (last at: PrimVtxRasterPosX) + (delta * t).	out at: PrimVtxRasterPosX put: (self cCoerce: x to: 'float').	delta _ (next at: PrimVtxRasterPosY) - (last at: PrimVtxRasterPosY).	y _ (last at: PrimVtxRasterPosY) + (delta * t).	out at: PrimVtxRasterPosY put: (self cCoerce: y to: 'float').	delta _ (next at: PrimVtxRasterPosZ) - (last at: PrimVtxRasterPosZ).	z _ (last at: PrimVtxRasterPosZ) + (delta * t).	out at: PrimVtxRasterPosZ put: (self cCoerce: z to: 'float').	delta _ (next at: PrimVtxRasterPosW) - (last at: PrimVtxRasterPosW).	w _ (last at: PrimVtxRasterPosW) + (delta * t).	out at: PrimVtxRasterPosW put: (self cCoerce: w to: 'float').	"Determine new clipFlags"	w2 _ 0.0 - w.	flags _ 0.	x >= w2 ifTrue:[flags _ flags bitOr: InLeftBit] ifFalse:[flags _ flags bitOr: OutLeftBit].	x <= w ifTrue:[flags _ flags bitOr: InRightBit] ifFalse:[flags _ flags bitOr: OutRightBit].	y >= w2 ifTrue:[flags _ flags bitOr: InBottomBit] ifFalse:[flags _ flags bitOr: OutBottomBit].	y <= w ifTrue:[flags _ flags bitOr: InTopBit] ifFalse:[flags _ flags bitOr: OutTopBit].	z >= w2 ifTrue:[flags _ flags bitOr: InFrontBit] ifFalse:[flags _ flags bitOr: OutFrontBit].	z <= w ifTrue:[flags _ flags bitOr: InBackBit] ifFalse:[flags _ flags bitOr: OutBackBit].	(self cCoerce: out to: 'int *') at: PrimVtxClipFlags put: flags.	"Interpolate color"	rgbaLast _ (self cCoerce: last to:'unsigned int *') at: PrimVtxColor32.	lastValue _ rgbaLast bitAnd: 255. rgbaLast _ rgbaLast >> 8.	rgbaNext _ (self cCoerce: next to: 'unsigned int *') at: PrimVtxColor32.	nextValue _ rgbaNext bitAnd: 255. rgbaNext _ rgbaNext >> 8.	delta _ (lastValue - nextValue) * t.	newValue _ (lastValue + delta) asInteger.	lastValue _ rgbaLast bitAnd: 255. rgbaLast _ rgbaLast >> 8.	nextValue _ rgbaNext bitAnd: 255. rgbaNext _ rgbaNext >> 8.	delta _ (lastValue - nextValue) * t.	newValue _ newValue + ((lastValue + delta) asInteger << 8).	lastValue _ rgbaLast bitAnd: 255. rgbaLast _ rgbaLast >> 8.	nextValue _ rgbaNext bitAnd: 255. rgbaNext _ rgbaNext >> 8.	delta _ (lastValue - nextValue) * t.	newValue _ newValue + ((lastValue + delta) asInteger << 16).	lastValue _ rgbaLast bitAnd: 255.	nextValue _ rgbaNext bitAnd: 255.	delta _ (lastValue - nextValue) * t.	newValue _ newValue + ((lastValue + delta) asInteger << 24).	(self cCoerce: out to:'unsigned int*') at: PrimVtxColor32 put: newValue.	"Interpolate texture coordinates"	delta _ (next at: PrimVtxTexCoordU) - (last at: PrimVtxTexCoordU).	out at: PrimVtxTexCoordU put: (self cCoerce: (last at: PrimVtxTexCoordU) + (delta * t) to:'float').	delta _ (next at: PrimVtxTexCoordV) - (last at: PrimVtxTexCoordV).	out at: PrimVtxTexCoordV put: (self cCoerce: (last at: PrimVtxTexCoordV) + (delta * t) to:'float').! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/16/1999 01:56'!backClipValueFrom: last to: next	self returnTypeC:'double'.	^(((self cCoerce: last to: 'float *') at: PrimVtxRasterPosZ) - 		((self cCoerce: last to:'float *') at: PrimVtxRasterPosW)) /	(	(((self cCoerce: next to:'float *') at: PrimVtxRasterPosW) -		((self cCoerce: last to: 'float *') at: PrimVtxRasterPosW))	-	 (((self cCoerce: next to:'float *') at: PrimVtxRasterPosZ) -		((self cCoerce: last to:'float *') at: PrimVtxRasterPosZ))	).! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/16/1999 06:43'!bottomClipValueFrom: last to: next	self returnTypeC:'double'.	^(0.0 - (((self cCoerce: last to: 'float *') at: PrimVtxRasterPosY) + 		((self cCoerce: last to:'float *') at: PrimVtxRasterPosW))) /	(	(((self cCoerce: next to:'float *') at: PrimVtxRasterPosW) -		((self cCoerce: last to: 'float *') at: PrimVtxRasterPosW))	+	 (((self cCoerce: next to:'float *') at: PrimVtxRasterPosY) -		((self cCoerce: last to:'float *') at: PrimVtxRasterPosY))	).! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/17/1999 22:18'!clipPolygonBackFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext |	self var: #buf1 declareC:'int *buf1'.	self var: #buf2 declareC:'int *buf2'.	self var: #last declareC:'int *last'.	self var: #next declareC:'int *next'.	self var: #t declareC: 'double t'.	outIndex _ 0.	last _ buf1 + (n * PrimVertexSize).	next _ buf1 + PrimVertexSize.	inLast _ (last at: PrimVtxClipFlags) anyMask: InBackBit.	1 to: n do:[:i|		inNext _ (next at: PrimVtxClipFlags) anyMask: InBackBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self backClipValueFrom: last to: next.			outIndex _ outIndex + 1.			self interpolateFrom: (self cCoerce: last to:'float *')				to: (self cCoerce: next to:'float *')				at: t 				into: (self cCoerce: (buf2 + (outIndex * PrimVertexSize)) to:'float*')].		inNext ifTrue:[			outIndex _ outIndex+1.			0 to: PrimVertexSize-1 do:[:j|				buf2 at: (outIndex*PrimVertexSize + j) put: (next at: j)].		].		last _ next.		inLast _ inNext.		next _ next + PrimVertexSize.	].	^outIndex! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/17/1999 22:18'!clipPolygonBottomFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext |	self var: #buf1 declareC:'int *buf1'.	self var: #buf2 declareC:'int *buf2'.	self var: #last declareC:'int *last'.	self var: #next declareC:'int *next'.	self var: #t declareC: 'double t'.	outIndex _ 0.	last _ buf1 + (n * PrimVertexSize).	next _ buf1 + PrimVertexSize.	inLast _ (last at: PrimVtxClipFlags) anyMask: InBottomBit.	1 to: n do:[:i|		inNext _ (next at: PrimVtxClipFlags) anyMask: InBottomBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self bottomClipValueFrom: last to: next.			outIndex _ outIndex + 1.			self interpolateFrom: (self cCoerce: last to:'float *')				to: (self cCoerce: next to:'float *')				at: t 				into: (self cCoerce: (buf2 + (outIndex * PrimVertexSize)) to:'float*')].		inNext ifTrue:[			outIndex _ outIndex+1.			0 to: PrimVertexSize-1 do:[:j|				buf2 at: (outIndex*PrimVertexSize + j) put: (next at: j)].		].		last _ next.		inLast _ inNext.		next _ next + PrimVertexSize.	].	^outIndex! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/17/1999 22:18'!clipPolygonFrontFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext |	self var: #buf1 declareC:'int *buf1'.	self var: #buf2 declareC:'int *buf2'.	self var: #last declareC:'int *last'.	self var: #next declareC:'int *next'.	self var: #t declareC: 'double t'.	outIndex _ 0.	last _ buf1 + (n * PrimVertexSize).	next _ buf1 + PrimVertexSize.	inLast _ (last at: PrimVtxClipFlags) anyMask: InFrontBit.	1 to: n do:[:i|		inNext _ (next at: PrimVtxClipFlags) anyMask: InFrontBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self frontClipValueFrom: last to: next.			outIndex _ outIndex + 1.			self interpolateFrom: (self cCoerce: last to:'float *')				to: (self cCoerce: next to:'float *')				at: t 				into: (self cCoerce: (buf2 + (outIndex * PrimVertexSize)) to:'float*')].		inNext ifTrue:[			outIndex _ outIndex+1.			0 to: PrimVertexSize-1 do:[:j|				buf2 at: (outIndex*PrimVertexSize + j) put: (next at: j)].		].		last _ next.		inLast _ inNext.		next _ next + PrimVertexSize.	].	^outIndex! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/17/1999 22:18'!clipPolygonLeftFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext |	self var: #buf1 declareC:'int *buf1'.	self var: #buf2 declareC:'int *buf2'.	self var: #last declareC:'int *last'.	self var: #next declareC:'int *next'.	self var: #t declareC: 'double t'.	outIndex _ 0.	last _ buf1 + (n * PrimVertexSize).	next _ buf1 + PrimVertexSize.	inLast _ (last at: PrimVtxClipFlags) anyMask: InLeftBit.	1 to: n do:[:i|		inNext _ (next at: PrimVtxClipFlags) anyMask: InLeftBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self leftClipValueFrom: last to: next.			outIndex _ outIndex + 1.			self interpolateFrom: (self cCoerce: last to:'float *')				to: (self cCoerce: next to:'float *')				at: t 				into: (self cCoerce: (buf2 + (outIndex * PrimVertexSize)) to:'float*')].		inNext ifTrue:[			outIndex _ outIndex+1.			0 to: PrimVertexSize-1 do:[:j|				buf2 at: (outIndex*PrimVertexSize + j) put: (next at: j)].		].		last _ next.		inLast _ inNext.		next _ next + PrimVertexSize.	].	^outIndex! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/17/1999 22:18'!clipPolygonRightFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext |	self var: #buf1 declareC:'int *buf1'.	self var: #buf2 declareC:'int *buf2'.	self var: #last declareC:'int *last'.	self var: #next declareC:'int *next'.	self var: #t declareC: 'double t'.	outIndex _ 0.	last _ buf1 + (n * PrimVertexSize).	next _ buf1 + PrimVertexSize.	inLast _ (last at: PrimVtxClipFlags) anyMask: InRightBit.	1 to: n do:[:i|		inNext _ (next at: PrimVtxClipFlags) anyMask: InRightBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self rightClipValueFrom: last to: next.			outIndex _ outIndex + 1.			self interpolateFrom: (self cCoerce: last to:'float *')				to: (self cCoerce: next to:'float *')				at: t 				into: (self cCoerce: (buf2 + (outIndex * PrimVertexSize)) to:'float*')].		inNext ifTrue:[			outIndex _ outIndex+1.			0 to: PrimVertexSize-1 do:[:j|				buf2 at: (outIndex*PrimVertexSize + j) put: (next at: j)].		].		last _ next.		inLast _ inNext.		next _ next + PrimVertexSize.	].	^outIndex! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/17/1999 22:19'!clipPolygonTopFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext |	self var: #buf1 declareC:'int *buf1'.	self var: #buf2 declareC:'int *buf2'.	self var: #last declareC:'int *last'.	self var: #next declareC:'int *next'.	self var: #t declareC: 'double t'.	outIndex _ 0.	last _ buf1 + (n * PrimVertexSize).	next _ buf1 + PrimVertexSize.	inLast _ (last at: PrimVtxClipFlags) anyMask: InTopBit.	1 to: n do:[:i|		inNext _ (next at: PrimVtxClipFlags) anyMask: InTopBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self topClipValueFrom: last to: next.			outIndex _ outIndex + 1.			self interpolateFrom: (self cCoerce: last to:'float *')				to: (self cCoerce: next to:'float *')				at: t 				into: (self cCoerce: (buf2 + (outIndex * PrimVertexSize)) to:'float*')].		inNext ifTrue:[			outIndex _ outIndex+1.			0 to: PrimVertexSize-1 do:[:j|				buf2 at: (outIndex*PrimVertexSize + j) put: (next at: j)].		].		last _ next.		inLast _ inNext.		next _ next + PrimVertexSize.	].	^outIndex! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/16/1999 06:43'!frontClipValueFrom: last to: next	self returnTypeC:'double'.	^(0.0 - (((self cCoerce: last to: 'float *') at: PrimVtxRasterPosZ) + 		((self cCoerce: last to:'float *') at: PrimVtxRasterPosW))) /	(	(((self cCoerce: next to:'float *') at: PrimVtxRasterPosW) -		((self cCoerce: last to: 'float *') at: PrimVtxRasterPosW))	+	 (((self cCoerce: next to:'float *') at: PrimVtxRasterPosZ) -		((self cCoerce: last to:'float *') at: PrimVtxRasterPosZ))	).! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/16/1999 06:43'!leftClipValueFrom: last to: next	self returnTypeC:'double'.	^(0.0 - (((self cCoerce: last to: 'float *') at: PrimVtxRasterPosX) + 		((self cCoerce: last to:'float *') at: PrimVtxRasterPosW))) /	(	(((self cCoerce: next to:'float *') at: PrimVtxRasterPosW) -		((self cCoerce: last to: 'float *') at: PrimVtxRasterPosW))	+	 (((self cCoerce: next to:'float *') at: PrimVtxRasterPosX) -		((self cCoerce: last to:'float *') at: PrimVtxRasterPosX))	).! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/16/1999 01:56'!rightClipValueFrom: last to: next	self returnTypeC:'double'.	^(((self cCoerce: last to: 'float *') at: PrimVtxRasterPosX) - 		((self cCoerce: last to:'float *') at: PrimVtxRasterPosW)) /	(	(((self cCoerce: next to:'float *') at: PrimVtxRasterPosW) -		((self cCoerce: last to: 'float *') at: PrimVtxRasterPosW))	-	 (((self cCoerce: next to:'float *') at: PrimVtxRasterPosX) -		((self cCoerce: last to:'float *') at: PrimVtxRasterPosX))	).! !!B3DClipperPlugin methodsFor: 'clipping utilities' stamp: 'ar 4/16/1999 01:56'!topClipValueFrom: last to: next	self returnTypeC:'double'.	^(((self cCoerce: last to: 'float *') at: PrimVtxRasterPosY) - 		((self cCoerce: last to:'float *') at: PrimVtxRasterPosW)) /	(	(((self cCoerce: next to:'float *') at: PrimVtxRasterPosW) -		((self cCoerce: last to: 'float *') at: PrimVtxRasterPosW))	-	 (((self cCoerce: next to:'float *') at: PrimVtxRasterPosY) -		((self cCoerce: last to:'float *') at: PrimVtxRasterPosY))	).! !!B3DEnginePlugin class methodsFor: 'translation' stamp: 'ar 4/18/1999 02:51'!translateB3D		"B3DEnginePlugin translateB3D"	"Translate all the basic plugins into one support module."	| cg |	cg _ PluggableCodeGenerator new initialize.	{	InterpreterPlugin. 		B3DEnginePlugin.		B3DTransformerPlugin. 		B3DVertexBufferPlugin.		B3DShaderPlugin.		B3DClipperPlugin.		B3DPickerPlugin.		B3DRasterizerPlugin	} do:[:theClass|		theClass initialize.		cg addClass: theClass.		theClass declareCVarsIn: cg].	cg storeCodeOnFile: self moduleName,'.c' doInlining: true.! !!B3DPickerPlugin methodsFor: 'primitives' stamp: 'ar 4/18/1999 02:59'!b3dComputeMinZ	"Primitive. Compute and return the minimal z value of all objects in the vertex buffer."	| idxSize vtxSize primType vtxArray idxArray minZ |	self export: true.	self inline: false.	self var: #vtxArray declareC:'float *vtxArray'.	self var: #idxArray declareC:'int *idxArray'.	self var: #minZ declareC:'double minZ'.	interpreterProxy methodArgumentCount = 5		ifFalse:[^interpreterProxy primitiveFail].	idxSize _ interpreterProxy stackIntegerValue: 0.	vtxSize _ interpreterProxy stackIntegerValue: 2.	primType _ interpreterProxy stackIntegerValue: 4.	interpreterProxy failed ifTrue:[^nil].	vtxArray _ self stackPrimitiveVertexArray: 3 ofSize: vtxSize.	idxArray _ self stackPrimitiveIndexArray: 1 ofSize: idxSize validate: true forVertexSize: vtxSize.	(vtxArray == nil or:[idxArray == nil or:[interpreterProxy failed]])		ifTrue:[^interpreterProxy primitiveFail].	(primType < 1 or:[primType > 6])		ifTrue:[^interpreterProxy primitiveFail].	primType <= 3 ifTrue:[		minZ _ self processNonIndexed: vtxArray ofSize: vtxSize.	] ifFalse:[		minZ _ self processIndexed: vtxArray ofSize: vtxSize idxArray: idxArray idxSize: idxSize.	].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 6. "nArgs+rcvr"		interpreterProxy pushFloat: minZ.	].! !!B3DPickerPlugin methodsFor: 'processing' stamp: 'ar 4/18/1999 03:05'!processIndexed: vtxArray ofSize: vtxSize idxArray: idxArray idxSize: idxSize	| vtxPtr zValue wValue minZ index |	self returnTypeC:'double'.	self var: #vtxArray declareC:'float *vtxArray'.	self var: #vtxPtr declareC:'float *vtxPtr'.	self var: #idxArray declareC:'int *idxArray'.	self var: #wValue declareC:'double wValue'.	self var: #zValue declareC:'double zValue'.	self var: #minZ declareC:'double minZ'.	minZ _ 10.0.	1 to: idxSize do:[:i|		index _ idxArray at: i.		index > 0 ifTrue:[			vtxPtr _ vtxArray + (index-1 * PrimVertexSize).			zValue _ vtxPtr at: PrimVtxRasterPosZ.			wValue _ vtxPtr at: PrimVtxRasterPosW.			wValue = 0.0 ifFalse:[zValue _ zValue / wValue].			zValue < minZ ifTrue:[minZ _ zValue].		].	].	^minZ! !!B3DPickerPlugin methodsFor: 'processing' stamp: 'ar 4/18/1999 02:49'!processNonIndexed: vtxArray ofSize: vtxSize	| vtxPtr zValue wValue minZ |	self returnTypeC:'double'.	self var: #vtxArray declareC:'float *vtxArray'.	self var: #vtxPtr declareC:'float *vtxPtr'.	self var: #wValue declareC:'double wValue'.	self var: #zValue declareC:'double zValue'.	self var: #minZ declareC:'double minZ'.	minZ _ 10.0.	vtxPtr _ vtxArray.	1 to: vtxSize do:[:i|		zValue _ vtxPtr at: PrimVtxRasterPosZ.		wValue _ vtxPtr at: PrimVtxRasterPosW.		wValue = 0.0 ifFalse:[zValue _ zValue / wValue].		zValue < minZ ifTrue:[minZ _ zValue].	].	^minZ! !!B3DPoolDefiner class methodsFor: 'pool definition' stamp: 'ar 4/4/1999 00:46'!definePrimitiveVertexIndexes: dict	"Define the indexes for primitive vertices"	"B3DPoolDefiner initPool"	self initFromSpecArray:	#(		"Full vertex size is 16 to simplify index computation"		(PrimVertexSize 16)		"Position"		(PrimVtxPosition 0)		(PrimVtxPositionX 0)		(PrimVtxPositionY 1)		(PrimVtxPositionZ 2)		"Normal"		(PrimVtxNormal 3)		(PrimVtxNormalX 3)		(PrimVtxNormalY 4)		(PrimVtxNormalZ 5)		"Tex coord"		(PrimVtxTexCoords 6)		(PrimVtxTexCoordU 6)		(PrimVtxTexCoordV 7)		"RasterPos"		(PrimVtxRasterPos 8)		(PrimVtxRasterPosX 8)		(PrimVtxRasterPosY 9)		(PrimVtxRasterPosZ 10)		(PrimVtxRasterPosW 11)		"Color"		(PrimVtxColor32 12)		"Clip flags"		(PrimVtxClipFlags 13)		"(Integer) window position"		(PrimVtxWindowPosX 14)		(PrimVtxWindowPosY 15)	) in: dict! !!B3DPrimitiveRasterizer class methodsFor: 'class initialization' stamp: 'ar 4/13/1999 01:52'!initialize	"B3DPrimitiveRasterizer initialize"	B3DNoMoreEdges _ 1.	B3DNoMoreFaces _ 2.	B3DNoMoreAttrs _ 3.	B3DNoMoreAET _ 4.	B3DNoMoreAdded _ 5.! !!B3DPrimitiveRasterizer class methodsFor: 'accessing' stamp: 'ar 4/12/1999 03:46'!version	"B3DPrimitiveRasterizer version"	<primitive:'b3dRasterizerVersion' module:'Squeak3D'>	^0! !!B3DPrimitiveRasterizer class methodsFor: 'testing' stamp: 'ar 4/12/1999 03:48'!isAvailable	^self version > 0! !!B3DPrimitiveRasterizerData commentStamp: '<historical>' prior: 0!Instances of this class represent data on the primitive level. The major reason for the existance of this class is that all memory needed by the rasterizer is allocated from Smalltalk code[*]. Instances of this class should not be modified from Smalltalk code - they may contain pointers to other memory locations and thus modification of these instances could easily break the system.[*] This is for two reasons:	* Some systems (e.g., Mac) don't have the necessary allocation facilities from the primitive level (This REALLY sucks. We have 1999 and MacOS 8.5.1 still has static memory allocation!!)	* Allocation from Smalltalk allows us to share memory between Smalltalk and C code, take advantage of GCs if the physically available space is small (e.g., on PDAs) as well as gracefully failing if there is no memory left (e.g., by signalling the low space condition).!!B3DPrimitiveRasterizerData reorganize!('accessing' at:put:)('private' replaceFrom:to:with:startingAt:)!!B3DPrimitiveRasterizerData methodsFor: 'accessing' stamp: 'ar 4/10/1999 05:36'!at: index put: value	"See the class comment"	^self error:'You must not modify primitive level data'! !!B3DPrimitiveRasterizerData methodsFor: 'private' stamp: 'ar 4/12/1999 02:36'!replaceFrom: start to: stop with: replacement startingAt: repStart	"Private. Used for growing rasterizer data only."	<primitive: 105>	^self primitiveFailed! !!B3DPrimitiveRasterizerState commentStamp: 'ar 4/18/1999 03:12' prior: 0!This class represents a set of objects that are known to the primitive level rasterizer. It should not be modified unless you know *exactly* what you're doing. The instance variables could actually be indexed but I decided to give them names for readability.Instance variables:	faceAlloc	<B3DPrimitiveRasterizerData>	- Source for primitive level face allocation.	edgeAlloc	<B3DPrimitiveRasterizerData>	- Source for primitive level edge allocation.	attrAlloc	<B3DPrimitiveRasterizerData>	- Source for primitive level attribute allocation.	aet			<B3DPrimitiveRasterizerData>	- Primitive level active edge table.	addedEdges	<B3DPrimitiveRasterizerData>	- Primitive level temporary edge storage.	fillList		<B3DPrimitiveRasterizerData>	- Primitive level fill list.	objects		<B3DPrimitiveRasterizerData> - Primitive level list of objects.	textures		<B3DPrimitiveRasterizerData> - Primitive level lists of textures.	spanBuffer	<Bitmap>						- 32bit bitmap to render into	bitBlt		<BitBlt>						- Final output device!!B3DPrimitiveRasterizerState methodsFor: 'initialize' stamp: 'ar 4/14/1999 05:14'!initObjects: nObjects	objects _ B3DPrimitiveRasterizerData new: nObjects! !!B3DPrimitiveRasterizerState methodsFor: 'initialize' stamp: 'ar 4/14/1999 05:13'!initTextures: nTextures	textures _ B3DPrimitiveRasterizerData new: (self primTextureSize * nTextures).! !!B3DPrimitiveRasterizerState methodsFor: 'initialize' stamp: 'ar 4/13/1999 06:29'!initialize	faceAlloc ifNil:[faceAlloc _ B3DPrimitiveRasterizerData new: 32768].	edgeAlloc ifNil:[edgeAlloc _ B3DPrimitiveRasterizerData new: 16384].	attrAlloc ifNil:[attrAlloc _ B3DPrimitiveRasterizerData new: 4096].	aet ifNil:[aet _ B3DPrimitiveRasterizerData new: 4096].	addedEdges ifNil:[addedEdges _ B3DPrimitiveRasterizerData new: 4096].	fillList ifNil:[fillList _ B3DPrimitiveRasterizerData new: 32].	self primInitializeBuffers.! !!B3DPrimitiveRasterizerState methodsFor: 'initialize' stamp: 'ar 4/11/1999 23:47'!reset	self primInitializeBuffers.! !!B3DPrimitiveRasterizerState methodsFor: 'accessing' stamp: 'ar 4/13/1999 00:10'!bitBlt	^bitBlt! !!B3DPrimitiveRasterizerState methodsFor: 'accessing' stamp: 'ar 4/13/1999 00:10'!bitBlt: aBitBlt	bitBlt _ aBitBlt.! !!B3DPrimitiveRasterizerState methodsFor: 'accessing' stamp: 'ar 4/13/1999 02:09'!spaceUsed	^faceAlloc basicSize + edgeAlloc basicSize + attrAlloc basicSize + aet basicSize + addedEdges basicSize + fillList basicSize + objects basicSize + spanBuffer basicSize! !!B3DPrimitiveRasterizerState methodsFor: 'accessing' stamp: 'ar 4/13/1999 00:10'!spanBuffer	^spanBuffer! !!B3DPrimitiveRasterizerState methodsFor: 'accessing' stamp: 'ar 4/13/1999 00:10'!spanBuffer: aBitmap	spanBuffer _ aBitmap.! !!B3DPrimitiveRasterizerState methodsFor: 'growing' stamp: 'ar 4/14/1999 01:45'!grow: anArray	| newArray |	newArray _ anArray species new: anArray size + (anArray size // 4 max: 100).	newArray replaceFrom: 1 to: anArray size with: anArray startingAt: 1.	^newArray! !!B3DPrimitiveRasterizerState methodsFor: 'growing' stamp: 'ar 4/13/1999 06:30'!growAET	"Transcript cr; show:'Growing AET'."	aet _ self grow: aet.! !!B3DPrimitiveRasterizerState methodsFor: 'growing' stamp: 'ar 4/13/1999 06:30'!growAdded	"Transcript cr; show:'Growing addedEdges'."	aet _ self grow: addedEdges.! !!B3DPrimitiveRasterizerState methodsFor: 'growing' stamp: 'ar 4/13/1999 06:30'!growAttrs	"Transcript cr; show:'Growing attrAlloc'."	attrAlloc _ self grow: attrAlloc.! !!B3DPrimitiveRasterizerState methodsFor: 'growing' stamp: 'ar 4/13/1999 06:30'!growEdges	"Transcript cr; show:'Growing edgeAlloc'."	edgeAlloc _ self grow: edgeAlloc.! !!B3DPrimitiveRasterizerState methodsFor: 'growing' stamp: 'ar 4/13/1999 06:30'!growFaces	"Transcript cr; show:'Growing faceAlloc'."	faceAlloc _ self grow: faceAlloc.! !!B3DPrimitiveRasterizerState methodsFor: 'private' stamp: 'ar 4/10/1999 21:29'!primInitializeBuffers	<primitive: 'b3dInitializeRasterizerState' module:'Squeak3D'>	^self primitiveFailed! !!B3DPrimitiveRasterizerState methodsFor: 'private' stamp: 'ar 4/14/1999 05:13'!primTextureSize	<primitive:'b3dPrimitiveTextureSize' module:'Squeak3D'>	^self primitiveFailed! !!B3DPrimitiveVertex commentStamp: '<historical>' prior: 0!I represent all per vertex information used in Balloon 3D primitive operations. I store either 32bit floats or integers depending on what is requested.C representation:	typedef struct B3DPrimitiveVertex {		float position[3];		float normal[3];		float texCoord[2];		float rasterPos[4];		int pixelValue32;		int clipFlags;		int windowPos[2];	} B3DPrimitiveVertex;!!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 4/4/1999 00:29'!integerAt: index	| word |	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 4/4/1999 00:29'!integerAt: index put: anInteger	| word |	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 4/4/1999 00:21'!windowPos	^self windowPosX@self windowPosY! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 4/4/1999 00:22'!windowPos: aPoint	self windowPosX: aPoint x.	self windowPosY: aPoint y.! !!B3DPrimitiveVertex methodsFor: 'transform-support' stamp: 'ar 4/4/1999 00:31'!windowPosX	^self integerAt: 15! !!B3DPrimitiveVertex methodsFor: 'transform-support' stamp: 'ar 4/4/1999 00:31'!windowPosX: anInteger	self integerAt: 15 put: anInteger! !!B3DPrimitiveVertex methodsFor: 'transform-support' stamp: 'ar 4/4/1999 00:31'!windowPosY	^self integerAt: 16! !!B3DPrimitiveVertex methodsFor: 'transform-support' stamp: 'ar 4/4/1999 00:31'!windowPosY: anInteger	self integerAt: 16 put: anInteger! !!B3DPrimitiveVertex methodsFor: 'rasterizer-support' stamp: 'ar 4/6/1999 22:27'!aValue	^self pixelValue32 bitShift: -24! !!B3DPrimitiveVertex methodsFor: 'rasterizer-support' stamp: 'ar 4/6/1999 22:29'!alphaValue	^self pixelValue32 bitShift: -24! !!B3DPrimitiveVertex methodsFor: 'rasterizer-support' stamp: 'ar 4/6/1999 22:28'!bValue	^self pixelValue32 bitAnd: 255! !!B3DPrimitiveVertex methodsFor: 'rasterizer-support' stamp: 'ar 4/6/1999 22:29'!blueValue	^self pixelValue32 bitAnd: 255! !!B3DPrimitiveVertex methodsFor: 'rasterizer-support' stamp: 'ar 4/6/1999 22:28'!gValue	^(self pixelValue32 bitShift: -8) bitAnd: 255! !!B3DPrimitiveVertex methodsFor: 'rasterizer-support' stamp: 'ar 4/6/1999 22:29'!greenValue	^(self pixelValue32 bitShift: -8) bitAnd: 255! !!B3DPrimitiveVertex methodsFor: 'rasterizer-support' stamp: 'ar 4/6/1999 22:28'!rValue	^(self pixelValue32 bitShift: -16) bitAnd: 255! !!B3DPrimitiveVertex methodsFor: 'rasterizer-support' stamp: 'ar 4/6/1999 22:29'!redValue	^(self pixelValue32 bitShift: -16) bitAnd: 255! !!B3DPrimitiveVertex methodsFor: 'testing' stamp: 'ar 4/4/1999 00:50'!sortsBefore: pVertex	"Return true if the receiver should be sorted before the given primitive vertex.	Support for rasterizer simulation. Only valid if window position has been computed before."	| y0 y1 |	y0 _ self windowPosY.	y1 _ pVertex windowPosY.	y0 = y1 		ifTrue:[^self windowPosX <= pVertex windowPosX]		ifFalse:[^y0 < y1]! !!B3DRasterizerPlugin methodsFor: 'primitives' stamp: 'ar 4/17/1999 20:57'!b3dInitPrimitiveObject	| vtxSize vtxArray idxSize idxArray primitive primOop primObj primSize textureIndex |	self export: true.	self inline: false.	self var: #vtxArray declareC:'int *vtxArray'.	self var: #idxArray declareC:'int *idxArray'.	self var: #primObj declareC:'void *primObj'.	"Check argument count"	interpreterProxy methodArgumentCount = 8		ifFalse:[^interpreterProxy primitiveFail].	"Fetch the texture index"	textureIndex _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	"Load the viewport"	self loadViewportFrom: 1.	interpreterProxy failed ifTrue:[^nil].	"Fetch and validate the primitive vertex array"	vtxSize _ interpreterProxy stackIntegerValue: 4.	vtxArray _ self stackPrimitiveVertexArray: 5 ofSize: vtxSize.	vtxArray = nil		ifTrue:[^interpreterProxy primitiveFail].	"Fetch and validate the primitive index array"	idxSize _ interpreterProxy stackIntegerValue: 2.	idxArray _ self stackPrimitiveIndexArray: 3 ofSize: idxSize validate: true forVertexSize: vtxSize.	idxArray = nil		ifTrue:[^interpreterProxy primitiveFail].	"Fetch and validate the primitive type"	primitive _ interpreterProxy stackIntegerValue: 6.	(primitive < 1 or:[primitive > PrimTypeMax]) 		ifTrue:[^interpreterProxy primitiveFail].	"For now we only support indexed triangles, quads and polys"	(primitive = 3 or:[primitive = 5 or:[primitive = 6]]) ifFalse:[^interpreterProxy primitiveFail].	"Load the primitive object"	primOop _ interpreterProxy stackObjectValue: 7.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: primOop)		ifFalse:[^interpreterProxy primitiveFail].	primObj _ interpreterProxy firstIndexableField: primOop.	primSize _ interpreterProxy byteSizeOf: primOop.	"Do the work"	primitive = 3 ifTrue:[		(self cCode: 'b3dAddPolygonObject((void*) primObj, primSize, B3D_FACE_RGB, textureIndex, (B3DPrimitiveVertex*) vtxArray, vtxSize, &viewport) !!= B3D_NO_ERROR')			ifTrue:[^interpreterProxy primitiveFail].	].	primitive = 5 ifTrue:[		(self cCode:'b3dAddIndexedTriangleObject((void*) primObj, primSize, B3D_FACE_RGB, textureIndex, (B3DPrimitiveVertex*) vtxArray, vtxSize, (B3DInputFace*) idxArray, idxSize / 3, &viewport) !!= B3D_NO_ERROR') 			ifTrue:[^interpreterProxy primitiveFail].	].	primitive = 6 ifTrue:[		(self cCode:'b3dAddIndexedQuadObject((void*) primObj, primSize, B3D_FACE_RGB, textureIndex, (B3DPrimitiveVertex*) vtxArray, vtxSize, (B3DInputQuad*) idxArray, idxSize / 4, &viewport) !!= B3D_NO_ERROR')			ifTrue:[^interpreterProxy primitiveFail].	].	"Pop args+rcvr; return primitive object"	interpreterProxy pop: 9.	interpreterProxy push: primOop.! !!B3DRasterizerPlugin methodsFor: 'primitives' stamp: 'ar 4/14/1999 05:59'!b3dInitializeRasterizerState	"Primitive. Initialize the primitive level objects of the given rasterizer."	| stateOop objOop objLen obj |	self export: true.	self inline: false.	self var: #obj declareC:'void *obj'.	"Check argument count"	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	stateOop _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isPointers: stateOop) and:[(interpreterProxy slotSizeOf: stateOop) >= 7])		ifFalse:[^interpreterProxy primitiveFail].	objOop _ interpreterProxy fetchPointer: 0 ofObject: stateOop.	((interpreterProxy isIntegerObject: objOop) or:[(interpreterProxy isWords: objOop)  not])		ifTrue:[^interpreterProxy primitiveFail].	objLen _ interpreterProxy byteSizeOf: objOop.	obj _ interpreterProxy firstIndexableField: objOop.	(self cCode: 'b3dInitializeFaceAllocator(obj, objLen) !!= B3D_NO_ERROR') 		ifTrue:[^interpreterProxy primitiveFail].	objOop _ interpreterProxy fetchPointer: 1 ofObject: stateOop.	((interpreterProxy isIntegerObject: objOop) or:[(interpreterProxy isWords: objOop)  not])		ifTrue:[^interpreterProxy primitiveFail].	objLen _ interpreterProxy byteSizeOf: objOop.	obj _ interpreterProxy firstIndexableField: objOop.	(self cCode: 'b3dInitializeEdgeAllocator(obj, objLen) !!= B3D_NO_ERROR') 		ifTrue:[^interpreterProxy primitiveFail].	objOop _ interpreterProxy fetchPointer: 2 ofObject: stateOop.	((interpreterProxy isIntegerObject: objOop) or:[(interpreterProxy isWords: objOop)  not])		ifTrue:[^interpreterProxy primitiveFail].	objLen _ interpreterProxy byteSizeOf: objOop.	obj _ interpreterProxy firstIndexableField: objOop.	(self cCode: 'b3dInitializeAttrAllocator(obj, objLen) !!= B3D_NO_ERROR') 		ifTrue:[^interpreterProxy primitiveFail].	objOop _ interpreterProxy fetchPointer: 3 ofObject: stateOop.	((interpreterProxy isIntegerObject: objOop) or:[(interpreterProxy isWords: objOop)  not])		ifTrue:[^interpreterProxy primitiveFail].	objLen _ interpreterProxy byteSizeOf: objOop.	obj _ interpreterProxy firstIndexableField: objOop.	(self cCode: 'b3dInitializeAET(obj, objLen) !!= B3D_NO_ERROR') 		ifTrue:[^interpreterProxy primitiveFail].	objOop _ interpreterProxy fetchPointer: 4 ofObject: stateOop.	((interpreterProxy isIntegerObject: objOop) or:[(interpreterProxy isWords: objOop)  not])		ifTrue:[^interpreterProxy primitiveFail].	objLen _ interpreterProxy byteSizeOf: objOop.	obj _ interpreterProxy firstIndexableField: objOop.	(self cCode: 'b3dInitializeEdgeList(obj, objLen) !!= B3D_NO_ERROR') 		ifTrue:[^interpreterProxy primitiveFail].	objOop _ interpreterProxy fetchPointer: 5 ofObject: stateOop.	((interpreterProxy isIntegerObject: objOop) or:[(interpreterProxy isWords: objOop)  not])		ifTrue:[^interpreterProxy primitiveFail].	objLen _ interpreterProxy byteSizeOf: objOop.	obj _ interpreterProxy firstIndexableField: objOop.	(self cCode: 'b3dInitializeFillList(obj, objLen) !!= B3D_NO_ERROR') 		ifTrue:[^interpreterProxy primitiveFail].	"Don't pop anything - return the receiver"! !!B3DRasterizerPlugin methodsFor: 'primitives' stamp: 'ar 4/14/1999 02:06'!b3dPrimitiveObjectSize	"Primitive. Return the minimal number of words needed for a primitive object."	| objSize |	self export: true.	self inline: false.	objSize _ (self cCode:'sizeof(B3DPrimitiveObject) + sizeof(B3DPrimitiveVertex)') // 4 + 1.	interpreterProxy pop: 1.	interpreterProxy pushInteger: objSize.! !!B3DRasterizerPlugin methodsFor: 'primitives' stamp: 'ar 4/14/1999 05:22'!b3dPrimitiveTextureSize	"Primitive. Return the minimal number of words needed for a primitive object."	| objSize |	self export: true.	self inline: false.	objSize _ (self cCode:'sizeof(B3DTexture)') // 4 + 1.	interpreterProxy pop: 1.	interpreterProxy pushInteger: objSize.! !!B3DRasterizerPlugin methodsFor: 'primitives' stamp: 'ar 4/12/1999 02:19'!b3dRasterizerVersion	"Primitive. Return the version of the rasterizer."	self export: true.	self inline: false.	interpreterProxy pop: 1.	interpreterProxy pushInteger: 1. "Version 1"! !!B3DRasterizerPlugin methodsFor: 'primitives' stamp: 'ar 4/14/1999 20:45'!b3dStartRasterizer	"Primitive. Start the rasterizer."	| errCode |	self export: true.	self inline: false.	"Check argument count"	interpreterProxy methodArgumentCount = 3		ifFalse:[^interpreterProxy primitiveFail].	"Load the base rasterizer state"	(self loadRasterizerState: 2)		ifFalse:[^interpreterProxy primitiveFail].	"Load the textures"	self loadTexturesFrom: 0.	interpreterProxy failed ifTrue:[^nil].	"And the objects"	self loadObjectsFrom: 1.	interpreterProxy failed ifTrue:[^nil].	"And go ..."	errCode _ self cCode:'b3dMainLoop(&state, B3D_NO_ERROR)'.	self storeObjectsInto: 1.	interpreterProxy pop: 4.	interpreterProxy pushInteger: errCode.! !!B3DRasterizerPlugin methodsFor: 'primitive support' stamp: 'ar 4/12/1999 06:02'!loadObjectsFrom: stackIndex	| arrayOop arraySize objArray objOop objPtr |	self var:#objArray declareC:'B3DPrimitiveObject **objArray'.	self var:#objPtr declareC:'B3DPrimitiveObject *objPtr'.	arrayOop _ interpreterProxy stackObjectValue: stackIndex.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: arrayOop) == (interpreterProxy classArray)		ifFalse:[^interpreterProxy primitiveFail].	arraySize _ interpreterProxy slotSizeOf: arrayOop.	arraySize > (self cCode:'state.nObjects')		ifTrue:[^interpreterProxy primitiveFail].	objArray _ self cCode:'state.objects'.	0 to: arraySize-1 do:[:i|		objOop _ interpreterProxy fetchPointer: i ofObject: arrayOop.		((interpreterProxy isIntegerObject: objOop) or:[(interpreterProxy isWords: objOop) not])			ifTrue:[^interpreterProxy primitiveFail].		objPtr _ self cCoerce: (interpreterProxy firstIndexableField: objOop) to:'B3DPrimitiveObject*'.		(self cCode:'objPtr->magic !!= B3D_PRIMITIVE_OBJECT_MAGIC')			ifTrue:[^interpreterProxy primitiveFail].		self cCode:'objPtr->__oop__ = objOop'.		objArray at: i put: objPtr.	].! !!B3DRasterizerPlugin methodsFor: 'primitive support' stamp: 'ar 4/14/1999 06:03'!loadRasterizerState: stackIndex	"Load the rasterizer state from the given stack index."	| stateOop obj objPtr objLen |	self var: #objPtr declareC:'void *objPtr'.	stateOop _ interpreterProxy stackObjectValue: stackIndex.	interpreterProxy failed ifTrue:[^false].	((interpreterProxy isPointers: stateOop) and:[(interpreterProxy slotSizeOf: stateOop) >= 10])		ifFalse:[^false].	obj _ interpreterProxy fetchPointer: 0 ofObject: stateOop.	((interpreterProxy isIntegerObject: obj) or:[(interpreterProxy isWords: obj) not])		ifTrue:[^false].	objPtr _ interpreterProxy firstIndexableField: obj.	self cCode:'state.faceAlloc = objPtr'.	obj _ interpreterProxy fetchPointer: 1 ofObject: stateOop.	((interpreterProxy isIntegerObject: obj) or:[(interpreterProxy isWords: obj) not])		ifTrue:[^false].	objPtr _ interpreterProxy firstIndexableField: obj.	self cCode:'state.edgeAlloc = objPtr'.	obj _ interpreterProxy fetchPointer: 2 ofObject: stateOop.	((interpreterProxy isIntegerObject: obj) or:[(interpreterProxy isWords: obj) not])		ifTrue:[^false].	objPtr _ interpreterProxy firstIndexableField: obj.	self cCode:'state.attrAlloc = objPtr'.	obj _ interpreterProxy fetchPointer: 3 ofObject: stateOop.	((interpreterProxy isIntegerObject: obj) or:[(interpreterProxy isWords: obj) not])		ifTrue:[^false].	objPtr _ interpreterProxy firstIndexableField: obj.	self cCode:'state.aet = objPtr'.	obj _ interpreterProxy fetchPointer: 4 ofObject: stateOop.	((interpreterProxy isIntegerObject: obj) or:[(interpreterProxy isWords: obj) not])		ifTrue:[^false].	objPtr _ interpreterProxy firstIndexableField: obj.	self cCode:'state.addedEdges = objPtr'.	obj _ interpreterProxy fetchPointer: 5 ofObject: stateOop.	((interpreterProxy isIntegerObject: obj) or:[(interpreterProxy isWords: obj) not])		ifTrue:[^false].	objPtr _ interpreterProxy firstIndexableField: obj.	self cCode:'state.fillList = objPtr'.	obj _ interpreterProxy fetchPointer: 6 ofObject: stateOop.	obj == interpreterProxy nilObject ifTrue:[		self cCode:'state.nObjects = 0'.		self cCode:'state.objects = NULL'.	] ifFalse:[		((interpreterProxy isIntegerObject: obj) or:[(interpreterProxy isWords: obj) not])			ifTrue:[^false].		objLen _ interpreterProxy slotSizeOf: obj.		objPtr _ interpreterProxy firstIndexableField: obj.		self cCode:'state.objects = (B3DPrimitiveObject **)objPtr'.		self cCode:'state.nObjects = objLen'.	].	obj _ interpreterProxy fetchPointer: 7 ofObject: stateOop.	obj == interpreterProxy nilObject ifTrue:[		self cCode:'state.nTextures = 0'.		self cCode:'state.textures = NULL'.	] ifFalse:[		((interpreterProxy isIntegerObject: obj) or:[(interpreterProxy isWords: obj) not])			ifTrue:[^false].		objLen _ interpreterProxy byteSizeOf: obj.		objPtr _ interpreterProxy firstIndexableField: obj.		self cCode:'state.textures = (B3DTexture *)objPtr'.		self cCode:'state.nTextures = objLen / sizeof(B3DTexture)'.	].	obj _ interpreterProxy fetchPointer: 8 ofObject: stateOop.	obj == interpreterProxy nilObject ifTrue:[		self cCode:'state.spanSize = 0'.		self cCode:'state.spanBuffer = NULL'.	] ifFalse:[		(interpreterProxy fetchClassOf: obj) == (interpreterProxy classBitmap)			ifFalse:[^false].		objLen _ interpreterProxy slotSizeOf: obj.		objPtr _ interpreterProxy firstIndexableField: obj.		self cCode:'state.spanBuffer = (unsigned int *)objPtr'.		self cCode:'state.spanSize = objLen'.	].	obj _ interpreterProxy fetchPointer: 9 ofObject: stateOop.	obj == interpreterProxy nilObject ifTrue:[		self cCode:'state.spanDrawer = NULL'.	] ifFalse:[		(interpreterProxy loadBitBltFrom: obj) ifFalse:[^false].		self cCode:'state.spanDrawer = interpreterProxy->copyBitsFromtoat'.	].	^interpreterProxy failed not! !!B3DRasterizerPlugin methodsFor: 'primitive support' stamp: 'ar 4/14/1999 05:50'!loadTexture: textureOop into: destPtr	"Note: This still uses the old-style textures"	| form formBits formWidth formHeight formDepth texWrap texInterpolate texEnvMode bitsPtr |	self var: #bitsPtr declareC:'void *bitsPtr'.	self var: #destPtr declareC:'B3DTexture *destPtr'.	"Fetch and validate the form"	form _ textureOop.	(interpreterProxy isPointers: form) ifFalse:[^false].	(interpreterProxy slotSizeOf: form) < 8 ifTrue:[^false].	formBits _ interpreterProxy fetchPointer: 0 ofObject: form.	formWidth _ interpreterProxy fetchInteger: 1 ofObject: form.	formHeight _ interpreterProxy fetchInteger: 2 ofObject: form.	formDepth _ interpreterProxy fetchInteger: 3 ofObject: form.	texWrap _ interpreterProxy booleanValueOf: 		(interpreterProxy fetchPointer: 5 ofObject: form).	texInterpolate _ interpreterProxy booleanValueOf: 		(interpreterProxy fetchPointer: 6 ofObject: form).	texEnvMode _ interpreterProxy fetchInteger: 7 ofObject: form.	interpreterProxy failed ifTrue:[^false].	(formWidth < 1 or:[formHeight < 1 or:[formDepth ~= 32]]) ifTrue:[^false].	(interpreterProxy fetchClassOf: formBits) = interpreterProxy classBitmap ifFalse:[^false].	(interpreterProxy byteSizeOf: formBits) = (formWidth * formHeight * 4) ifFalse:[^false].	(texEnvMode < 0 or:[texEnvMode > 1]) ifTrue:[^false].	"Now fetch the bits"	bitsPtr _ interpreterProxy firstIndexableField: formBits.	"Set the texture parameters"	^self cCode:'b3dLoadTexture(destPtr, formWidth, formHeight, formDepth, (unsigned int*) bitsPtr, 0, NULL) == B3D_NO_ERROR'.! !!B3DRasterizerPlugin methodsFor: 'primitive support' stamp: 'ar 4/14/1999 05:52'!loadTexturesFrom: stackIndex	| arrayOop destPtr n textureOop |	self var: #destPtr declareC:'B3DTexture *destPtr'.	arrayOop _ interpreterProxy stackObjectValue: stackIndex.	(interpreterProxy fetchClassOf: arrayOop) == interpreterProxy classArray		ifFalse:[^interpreterProxy primitiveFail].	n _ interpreterProxy slotSizeOf: arrayOop.	n _ n min: (self cCode: 'state.nTextures').	0 to: n-1 do:[:i|		destPtr _ self cCode:'state.textures + i'.		textureOop _ interpreterProxy fetchPointer: i ofObject: arrayOop.		(self loadTexture: textureOop into: destPtr) 			ifFalse:[^interpreterProxy primitiveFail].	].	^0! !!B3DRasterizerPlugin methodsFor: 'primitive support' stamp: 'ar 4/10/1999 23:24'!loadViewportFrom: stackIndex	"Load the viewport from the given stack index"	| oop p1 p2 x0 y0 x1 y1 |	oop _ interpreterProxy stackObjectValue: stackIndex.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isPointers: oop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: oop) < 2		ifTrue:[^interpreterProxy primitiveFail].	p1 _ interpreterProxy fetchPointer: 0 ofObject: oop.	p2 _ interpreterProxy fetchPointer: 1 ofObject: oop.	(interpreterProxy fetchClassOf: p1) = interpreterProxy classPoint		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy fetchClassOf: p2) = interpreterProxy classPoint		ifFalse:[^interpreterProxy primitiveFail].	x0 _ interpreterProxy fetchInteger: 0 ofObject: p1.	y0 _ interpreterProxy fetchInteger: 1 ofObject: p1.	x1 _ (interpreterProxy fetchInteger: 0 ofObject: p2).	y1 _ (interpreterProxy fetchInteger: 1 ofObject: p2).	interpreterProxy failed ifTrue:[^nil].	self cCode:'viewport.x0 = x0'.	self cCode:'viewport.y0 = y0'.	self cCode:'viewport.x1 = x1'.	self cCode:'viewport.y1 = y1'.	^0! !!B3DRasterizerPlugin methodsFor: 'primitive support' stamp: 'ar 4/12/1999 06:01'!storeObjectsInto: stackIndex	| arrayOop arraySize objOop |	arrayOop _ interpreterProxy stackObjectValue: stackIndex.	arraySize _ self cCode: 'state.nObjects'.	0 to: arraySize-1 do:[:i|		objOop _ self cCode:'state.objects[i]->__oop__'.		interpreterProxy storePointer: i ofObject: arrayOop withValue: objOop.	].! !!B3DRasterizerPlugin class methodsFor: 'translation' stamp: 'ar 4/10/1999 23:35'!declareCVarsIn: cg	cg addHeaderFile:'"b3d.h"'.	cg var: 'viewport' declareC:'static B3DPrimitiveViewport viewport'.	cg var: 'state' declareC:'static B3DRasterizerState state'.! !!B3DRasterizerPlugin class methodsFor: 'translation' stamp: 'ar 4/11/1999 23:42'!translateSupportCode: cSrc inlining: inlineFlag	"Inline the given C support code if inlineFlag is set.	Inlining converts any functions of the form:		/* INLINE someFunction(args) */		void someFunction(declaration args)		{			... actual code ...		}		/* --INLINE-- */	into 		#define someFunction(args) \		/* void someFunction(declaration args) */ \		{ \			... actual code ... \		} \		/* --INLINE-- */	thus using a hard way of forcing inlining by the C compiler."	| in out postfix line |	inlineFlag ifFalse:[^cSrc].	in _ ReadStream on: cSrc.	out _ WriteStream on: (String new: cSrc size).	postfix _ ''.	[in atEnd] whileFalse:[		line _ in upTo: Character cr.		(line includesSubString:' INLINE ') ifTrue:[			"New inline start"			postfix _ ' \'.			line _ line copyFrom: (line findString: 'INLINE')+6 to: line size.			line _ line copyFrom: 1 to: (line findString: '*/')-1.			out nextPutAll:'#define'; nextPutAll: line; nextPutAll: postfix; cr.			"Next line has function declaration -- comment this out"			[line _ in upTo: Character cr.			line includes: ${] whileFalse:[				out nextPutAll:'/* '; nextPutAll: line; nextPutAll:' */'; nextPutAll: postfix; cr.			].			(line first = ${) ifTrue:[				out nextPutAll: line; nextPutAll: postfix; cr.			] ifFalse:[				out nextPutAll: '/* '; 					nextPutAll:(line copyFrom: 1 to: (line findString:'{')-1);					nextPutAll:' */';					nextPutAll:(line copyFrom: (line findString:'{') to: line size);					nextPutAll: postfix;					cr.			].		] ifFalse:[			(line includesSubString:'--INLINE--') ifTrue:[postfix _ ''].			out nextPutAll: line; nextPutAll: postfix; cr.		].	].	^out contents.	"| fs |	fs _ FileStream newFileNamed:'b3dr.c'.	fs nextPutAll: (B3DRasterizerPlugin translateSupportCode: B3DRasterizerPlugin b3dRemapC inlining: true).	fs close."! !!B3DRasterizerPlugin class methodsFor: 'translation' stamp: 'ar 4/11/1999 23:42'!writeSupportCode: inlineFlag	"B3DRasterizerPlugin writeSupportCode: true"	"B3DRasterizerPlugin writeSupportCode: false"	"Translate all the C support files for the Balloon 3D rasterizer plugin."	| src fs |	#(		"(b3dTypesH 'b3dTypes.h')		(b3dAllocH 'b3dAlloc.h')		(b3dHeaderH 'b3d.h')		(b3dInitC 'b3dInit.c')		(b3dAllocC 'b3dAlloc.c')		(b3dRemapC 'b3dRemap.c')		(b3dDrawC 'b3dDraw.c')		(b3dMainC 'b3dMain.c')"	) do:[:spec|		src _ self perform: (spec at: 1).		src _ self translateSupportCode: src inlining: inlineFlag.		fs _ FileStream newFileNamed: (spec at: 2).		fs nextPutAll: src.		fs close.	].! !!B3DRenderEngine reorganize!('attributes' clearDepthBuffer clearViewport: color color: material material: materialColor materialColor: normal normal: popMaterial popTexture pushMaterial pushTexture texCoords texCoords: texture texture: vertex vertex: viewport viewport:)('draw primitives' drawPolygonAfter: drawPolygonMesh: render:)('private-rendering' privateClipVB: privateNeedsClipVB: privateNeedsShadingVB privateRasterizeVB: privateShadeVB: privateTransformVB: privateVisibleVB: renderPrimitive)('transforming' loadIdentity lookFrom:to:up: perspective: popMatrix pushMatrix rotateBy: scaleBy: transformBy: translateBy:)('initialize' canvas: destroy finish flush initialize reset)('shading' addLight: removeLight: trackAmbientColor trackAmbientColor: trackDiffuseColor trackDiffuseColor: trackEmissionColor trackEmissionColor: trackSpecularColor trackSpecularColor:)('indexed primitives' drawIndexedLines:vertices:normals:colors:texCoords: drawIndexedQuads:vertices:normals:colors:texCoords: drawIndexedTriangles:vertices:normals:colors:texCoords:)('private-access' getClipper getRasterizer getShader getTransformer getVertexBuffer)('picking' asPickerAt: asPickerAt:extent: pickingMatrixAt:extent:)!!B3DRenderEngine methodsFor: 'private-rendering' stamp: 'ar 4/17/1999 23:05'!renderPrimitive	"This is the main rendering loop for all operations"	| visible |	"Step 1: Check if the mesh is visible at all"	visible _ self privateVisibleVB: vertexBuffer.	visible == false ifTrue:[^self].	"Step 2: Transform vertices, normals, texture coords of the mesh"	self privateTransformVB: vertexBuffer.	"Step 3: Light the vertices of the mesh."	self privateNeedsShadingVB		ifTrue:[self privateShadeVB: vertexBuffer].	"Step 4: Clip the mesh if necessary"	(self privateNeedsClipVB: visible)		ifTrue:[visible _ self privateClipVB: vertexBuffer].	visible == false ifTrue:[^self].	"Step 5: Rasterize the mesh"	self privateRasterizeVB: vertexBuffer.! !!B3DRenderEngine methodsFor: 'initialize' stamp: 'ar 4/18/1999 00:35'!initialize	engine _ self. "Obviously ;-)"	vertexBuffer _ B3DVertexBuffer new.	transformer _ self class transformer engine: self.	shader _ self class shader engine: self.	clipper _ self class clipper engine: self.	rasterizer _ self class rasterizer engine: self.	self materialColor: Color white.! !!B3DRenderEngine methodsFor: 'initialize' stamp: 'ar 4/10/1999 22:51'!reset	vertexBuffer reset.	transformer reset.	shader reset.	clipper reset.	rasterizer reset.	self materialColor: Color white.! !!B3DRenderEngine methodsFor: 'private-access' stamp: 'ar 4/17/1999 23:12'!getClipper	"Private. Return the clipper used with this engine."	^clipper! !!B3DRenderEngine methodsFor: 'private-access' stamp: 'ar 4/17/1999 23:13'!getRasterizer	"Private. Return the rasterizer used with this engine."	^rasterizer! !!B3DRenderEngine methodsFor: 'private-access' stamp: 'ar 4/17/1999 23:12'!getShader	"Private. Return the shader used with this engine."	^shader! !!B3DRenderEngine methodsFor: 'private-access' stamp: 'ar 4/17/1999 23:12'!getTransformer	"Private. Return the transformer used with this engine."	^transformer! !!B3DRenderEngine methodsFor: 'private-access' stamp: 'ar 4/17/1999 23:11'!getVertexBuffer	"Private. Return the vertex buffer used with this engine."	^vertexBuffer! !!B3DRenderEngine methodsFor: 'picking' stamp: 'ar 4/18/1999 02:28'!asPickerAt: aPoint	^self asPickerAt: aPoint extent: 1@1! !!B3DRenderEngine methodsFor: 'picking' stamp: 'ar 4/17/1999 23:56'!asPickerAt: aPoint extent: extentPoint	| picker |	picker _ B3DPickerEngine new.	picker loadFrom: self.	picker pickAt: aPoint extent: extentPoint.	^picker! !!B3DRenderEngine methodsFor: 'picking' stamp: 'ar 4/18/1999 02:31'!pickingMatrixAt: aPoint extent: extentPoint	"Return a matrix for picking at the given point using the given extent."	| vp m scaleX scaleY ofsX ofsY |	vp _ self viewport.	scaleX _ vp width / extentPoint x.	scaleY _ vp height / extentPoint y.	ofsX _ (vp width + (2.0 * (vp origin x - aPoint x))) / extentPoint x.	ofsY _ (vp height + (2.0 * (aPoint y - vp corner y))) / extentPoint y.	m _ B3DMatrix4x4 identity.	m a11: scaleX; a22: scaleY.	m a14: ofsX; a24: ofsY.	^m! !!B3DPickerEngine reorganize!('initialize' flush initialize loadFrom:)('picking' pickAt:extent: render: topMostObject)('private-rendering' primComputeMinZ:vtxArray:vtxSize:idxArray:idxSize: privateTransformVB: processIndexed: processIndexedLines: processIndexedQuads: processIndexedTriangles: processLineLoop: processLines: processNonIndexed: processPoints: processPolygon: processVertexBuffer: renderPrimitive)!!B3DPickerEngine methodsFor: 'initialize' stamp: 'ar 4/18/1999 00:21'!flush	"Ignored"! !!B3DPickerEngine methodsFor: 'initialize' stamp: 'ar 4/17/1999 23:46'!initialize	"Do not call super initialize here. We get our components directly by the creating engine."	pickList _ SortedCollection new: 100.	pickList sortBlock:[:a1 :a2| a1 value < a2 value].	objects _ OrderedCollection new: 100.	objects resetTo: 1.! !!B3DPickerEngine methodsFor: 'initialize' stamp: 'ar 4/17/1999 23:11'!loadFrom: aRenderEngine	"Load our components from the given render engine.	The idea is that all of the state is shared so that transformations	send during picking will be preserved in the given render engine."	vertexBuffer _ aRenderEngine getVertexBuffer.	transformer _ aRenderEngine getTransformer.	shader _ aRenderEngine getShader.	clipper _ aRenderEngine getClipper.	rasterizer _ aRenderEngine getRasterizer. ! !!B3DPickerEngine methodsFor: 'picking' stamp: 'ar 4/18/1999 02:25'!pickAt: aPoint extent: extentPoint	"Initialize the receiver for picking at the given point using the given extent."	pickMatrix _ self pickingMatrixAt: aPoint extent: extentPoint.! !!B3DPickerEngine methodsFor: 'picking' stamp: 'ar 4/18/1999 02:32'!render: anObject	| assoc |	assoc _ Association key: anObject value: 1.0e100.	objects addLast: assoc.	anObject renderOn: self.	(objects removeLast == assoc) ifFalse:[^self error:'Object stack is confused'].	assoc value > 2.0 ifFalse:[pickList add: assoc].! !!B3DPickerEngine methodsFor: 'picking' stamp: 'ar 4/18/1999 00:08'!topMostObject	"Return the top most of all picked objects"	^pickList isEmpty		ifTrue:[nil]		ifFalse:[pickList first key]! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 03:01'!primComputeMinZ: primType vtxArray: vtxArray vtxSize: vtxSize idxArray: idxArray idxSize: idxSize	<primitive: 'b3dComputeMinZ' module: 'Squeak3D'>	^nil "Indicates failure"! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 02:26'!privateTransformVB: vb	"Transform the contents of the vertex buffer.	Transforming may include normals (if lighting enabled) and textures (if textures enabled)."	^transformer processVertexBuffer: vb					modelView: transformer modelViewMatrix					projection: (transformer projectionMatrix composedWithGlobal: pickMatrix)! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 02:34'!processIndexed: vb	| idxArray vtxArray index vtx zValue minZ wValue |	idxArray _ vb indexArray.	vtxArray _ vb vertexArray.	minZ _ 10.0.	1 to: vb indexCount do:[:i|		index _ idxArray at: i.		index = 0 ifFalse:[			vtx _ vtxArray at: index.			zValue _ vtx rasterPosZ.			wValue _ vtx rasterPosW.			wValue = 0.0 ifFalse:[zValue _ zValue / wValue].			zValue < minZ ifTrue:[minZ _ zValue].		].	].	^minZ! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 00:42'!processIndexedLines: vb	^self processIndexed: vb! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 00:41'!processIndexedQuads: vb	^self processIndexed: vb! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 00:41'!processIndexedTriangles: vb	^self processIndexed: vb! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 00:43'!processLineLoop: vb	^self processNonIndexed: vb! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 00:43'!processLines: vb	^self processNonIndexed: vb! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 02:33'!processNonIndexed: vb	| vtxArray vtx zValue minZ wValue |	vtxArray _ vb vertexArray.	minZ _ 10.0.	1 to: vb vertexCount do:[:i|		vtx _ vtxArray at: i.		zValue _ vtx rasterPosZ.		wValue _ vtx rasterPosW.		wValue = 0.0 ifFalse:[zValue _ zValue / wValue].		zValue < minZ ifTrue:[minZ _ zValue].	].	^minZ! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 00:44'!processPoints: vb	^self processNonIndexed: vb! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 00:43'!processPolygon: vb	^self processNonIndexed: vb! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 03:02'!processVertexBuffer: vb	| minZ |	minZ _ self primComputeMinZ: vb primitive vtxArray: vb vertexArray vtxSize: vb vertexCount idxArray: vb indexArray idxSize: vb indexCount.	minZ == nil ifTrue:[minZ _ super processVertexBuffer: vb].	^minZ! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 4/18/1999 02:35'!renderPrimitive	"This is the main rendering loop for all operations"	| visible minZ |	"Step 1: Check if the mesh is visible at all"	visible _ self privateVisibleVB: vertexBuffer.	visible == false ifTrue:[^self].	"Step 2: Transform vertices, normals, texture coords of the mesh"	self privateTransformVB: vertexBuffer.	"Step 3: Clip the mesh if necessary"	visible _ self privateClipVB: vertexBuffer.	visible == false ifTrue:[^self].	"Step 4: Collect the minimal/maximal distances for the current object."	minZ _ self processVertexBuffer: vertexBuffer.	objects isEmpty ifFalse:[		objects last value > minZ ifTrue:[objects last value: minZ].	].! !!B3DRenderEngine class methodsFor: 'instance creation' stamp: 'ar 4/16/1999 22:24'!defaultForPlatformOn: aForm	"Return the render engine that is most appropriate for the current host platform.	If aForm is nil, then the engine may render directly onto the host window.	For now, we only have the choice between OSMesa (preferred),	a primitive accellerated and the fully simulated version"	(Sensor leftShiftDown not and:[OSMesaRenderEngine isAvailableFor: aForm])		ifTrue:[^OSMesaRenderEngine].	(B3DPrimitiveEngine isAvailableFor: aForm) ifTrue:[^B3DPrimitiveEngine].	^B3DRenderEngine! !!B3DPrimitiveEngine class methodsFor: 'accessing' stamp: 'ar 4/16/1999 06:45'!clipper	^B3DPrimitiveClipper	"^B3DVertexClipper"! !!B3DPrimitiveEngine class methodsFor: 'accessing' stamp: 'ar 4/12/1999 03:47'!rasterizer	"Return the rasterizer to use with this engine"	^B3DPrimitiveRasterizer! !!B3DSceneMorph methodsFor: 'drawing' stamp: 'ar 4/16/1999 19:43'!debugDraw	self fullDrawOn: (FormCanvas on: Display).	Display forceToScreen: bounds.! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 4/17/1999 22:31'!computeDirection	"Compute the direction for the current light and vertex"	| scale |	self inline: true.	self var: #scale declareC:'double scale'.	(lightFlags anyMask: FlagPositional) ifTrue:[		"Must compute the direction for this vertex"		l2vDirection at: 0 put: (litVertex at: PrimVtxPositionX) - (primLight at: PrimLightPositionX).		l2vDirection at: 1 put: (litVertex at: PrimVtxPositionY) - (primLight at: PrimLightPositionY).		l2vDirection at: 2 put: (litVertex at: PrimVtxPositionZ) - (primLight at: PrimLightPositionZ).		"l2vDistance _ self dotProductOf: l2vDirection with: l2vDirection."		l2vDistance _ ((l2vDirection at: 0) * (l2vDirection at: 0)) +						((l2vDirection at: 1) * (l2vDirection at: 1)) +							((l2vDirection at: 2) * (l2vDirection at: 2)).		(l2vDistance = 0.0 or:[l2vDistance = 1.0]) 			ifFalse:[	l2vDistance _ l2vDistance sqrt.					scale _ -1.0/l2vDistance].		l2vDirection at: 0 put: (l2vDirection at: 0) * scale.		l2vDirection at: 1 put: (l2vDirection at: 1) * scale.		l2vDirection at: 2 put: (l2vDirection at: 2) * scale.	] ifFalse:[		(lightFlags anyMask: FlagDirectional) ifTrue:[			l2vDirection at: 0 put: (primLight at: PrimLightDirectionX).			l2vDirection at: 1 put: (primLight at: PrimLightDirectionY).			l2vDirection at: 2 put: (primLight at: PrimLightDirectionZ).		].	].! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 4/17/1999 22:39'!computeSpecularDirection	"Computes		l2vSpecDir _ l2vSpecDir - vtx position safelyNormalized.	"	| scale |	self var: #scale declareC:'double scale'.	scale _ self inverseLengthOfFloat: litVertex + PrimVtxPosition.	l2vSpecDir at: 0 put: (l2vSpecDir at: 0) - ((litVertex at: PrimVtxPositionX) * scale).	l2vSpecDir at: 1 put: (l2vSpecDir at: 1) - ((litVertex at: PrimVtxPositionY) * scale).	l2vSpecDir at: 2 put: (l2vSpecDir at: 2) - ((litVertex at: PrimVtxPositionZ) * scale).! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 4/17/1999 22:39'!computeSpotFactor	"Compute the spot factor for a spot light"	| cosAngle minCos deltaCos |	self returnTypeC:'double'.	self var: #cosAngle declareC:'double cosAngle'.	self var: #minCos declareC:'double minCos'.	self var: #deltaCos declareC:'double deltaCos'.	"Compute cos angle between direction of the spot light and direction to vertex"	cosAngle _ self dotProductOfFloat: primLight + PrimLightDirection withDouble: l2vDirection.	cosAngle _ 0.0 - cosAngle.	minCos _ primLight at: SpotLightMinCos.	cosAngle < minCos ifTrue:[^0.0].	deltaCos _ primLight at: SpotLightDeltaCos.	deltaCos <= 0.00001 ifTrue:[		"No delta -- a sharp boundary between on and off.		Since off has already been determined above, we are on"		^1.0].	"Scale the angle to 0/1 range"	cosAngle _ (cosAngle - minCos) / deltaCos.	^cosAngle raisedTo: (primLight at: SpotLightExponent)! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 4/17/1999 22:39'!dotProductOfFloat: v1 withDouble: v2	self var: #v1 declareC:'float * v1'.	self var: #v2 declareC:'double *v2'.	self returnTypeC:'double'.	^((v1 at: 0) * (v2 at: 0)) +		((v1 at: 1) * (v2 at: 1)) +			((v1 at: 2) * (v2 at: 2)).! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 4/17/1999 22:38'!inverseLengthOfDouble: aVector	| scale |	self returnTypeC:'double'.	self var: #aVector declareC:'double * aVector'.	self var: #scale declareC:'double scale'.	"scale _ self dotProductOf: aVector with: aVector."	scale _ ((aVector at: 0) * (aVector at: 0)) +				((aVector at: 1) * (aVector at: 1)) +					((aVector at: 2) * (aVector at: 2)).	(scale = 0.0 or:[scale = 1.0]) ifTrue:[^scale].	^1.0 / scale sqrt! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 4/17/1999 22:38'!inverseLengthOfFloat: aVector	| scale |	self returnTypeC:'double'.	self var: #aVector declareC:'float * aVector'.	self var: #scale declareC:'double scale'.	"scale _ self dotProductOf: aVector with: aVector."	scale _ ((aVector at: 0) * (aVector at: 0)) +				((aVector at: 1) * (aVector at: 1)) +					((aVector at: 2) * (aVector at: 2)).	(scale = 0.0 or:[scale = 1.0]) ifTrue:[^scale].	^1.0 / scale sqrt! !!B3DShaderPlugin methodsFor: 'shading' stamp: 'ar 4/17/1999 22:40'!shadeVertex	| cosAngle specularFactor |	self var: #cosAngle declareC:'double cosAngle'.	self var: #specularFactor declareC:'double specularFactor'.	self computeDirection.	self computeAttenuation.	(lightFlags anyMask: FlagHasSpot) ifTrue:[		lightScale _ lightScale * self computeSpotFactor.	].	"Compute ambient and diffuse part only if lightScale is non-zero."	(lightScale > 0.001) ifTrue:[		"Compute the ambient part"		(lightFlags anyMask: FlagAmbientPart) ifTrue:[			self addPart: (primLight + AmbientPart) 				from: primMaterial + AmbientPart 				trackFlag: VBTrackAmbient 				scale: lightScale.		].		"Compute the diffuse part"		(lightFlags anyMask: FlagDiffusePart) ifTrue:[			"Compute angle from light->vertex to vertex normal"			cosAngle _ self dotProductOfFloat: (litVertex + PrimVtxNormal) withDouble: l2vDirection.			"For one-sided lighting negate cosAngle if necessary"			((vbFlags bitAnd: VBTwoSidedLighting) = 0 and:[cosAngle < 0.0])				ifTrue:[cosAngle _ 0.0 - cosAngle].			"For two-sided lighting check if cosAngle > 0.0 meaning that it is a front face"			cosAngle > 0.0 ifTrue:[				self addPart: primLight + DiffusePart 					from: primMaterial + DiffusePart 					trackFlag: VBTrackDiffuse 					scale: lightScale * cosAngle.			].		].	]. "lightScale > 0.001"	"Compute the specular part"	((lightFlags anyMask: FlagSpecularPart) and:[		(primMaterial at: MaterialShininess) > 0.0]) ifTrue:[		"Compute specular part"		l2vSpecDir at: 0 put: (l2vDirection at: 0).		l2vSpecDir at: 1 put: (l2vDirection at: 1).		l2vSpecDir at: 2 put: (l2vDirection at: 2).		(vbFlags anyMask: VBUseLocalViewer) 			ifTrue:[self computeSpecularDirection]			ifFalse:[l2vSpecDir at: 2 put: (l2vSpecDir at: 2) - 1.0].		cosAngle _ self dotProductOfFloat: (litVertex + PrimVtxNormal) withDouble: l2vSpecDir.		cosAngle > 0.0 ifTrue:[			"Normalize the angle"			cosAngle _ cosAngle * (self inverseLengthOfDouble: l2vSpecDir).			"cosAngle should be somewhere between 0 and 1.			If not, then the vertex normal was not normalized"			cosAngle > 1.0 ifTrue:[				specularFactor _ cosAngle raisedTo: (primMaterial at: MaterialShininess).			] ifFalse:[				cosAngle = 0.0 					ifTrue:[specularFactor _ 1.0]					ifFalse:[specularFactor _ cosAngle raisedTo: (primMaterial at: MaterialShininess)].			].			self addPart: primLight + SpecularPart 				from: primMaterial + SpecularPart 				trackFlag: VBTrackSpecular 				scale: specularFactor.		].	].! !!B3DShaderPlugin class methodsFor: 'translation' stamp: 'ar 4/17/1999 22:16'!declareCVarsIn: cg	cg var: 'litVertex' declareC:'static float *litVertex'.	cg var: 'primLight' declareC:'static float *primLight'.	cg var: 'primMaterial' declareC:'static float *primMaterial'.	cg var: 'l2vDirection' declareC:'static double l2vDirection[3]'.	cg var: 'l2vSpecDir' declareC:'static double l2vSpecDir[3]'.	cg var: 'vtxInColor' declareC:'static double vtxInColor[4]'.	cg var: 'vtxOutColor' declareC:'static double vtxOutColor[4]'.	cg var: 'l2vDistance' declareC:'static double l2vDistance'.	cg var: 'lightScale' declareC:'static double lightScale'.! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 4/17/1999 22:22'!transformPrimitiveNormal: pVertex by: matrix rescale: rescale	"Transform the normal of the given primitive vertex"	| x y z rx ry rz dot |	self var: #pVertex declareC:'float *pVertex'.	self var: #matrix declareC:'float *matrix'.	self var: #x declareC:'double x'.	self var: #y declareC:'double y'.	self var: #z declareC:'double z'.	self var: #rx declareC:'double rx'.	self var: #ry declareC:'double ry'.	self var: #rz declareC:'double rz'.	self var: #dot declareC:'double dot'.	x _ pVertex at: PrimVtxNormalX.	y _ pVertex at: PrimVtxNormalY.	z _ pVertex at: PrimVtxNormalZ.	rx _ (x * (matrix at: 0)) + (y * (matrix at: 1)) + (z * (matrix at: 2)).	ry _ (x * (matrix at: 4)) + (y * (matrix at: 5)) + (z * (matrix at: 6)).	rz _ (x * (matrix at: 8)) + (y * (matrix at: 9)) + (z * (matrix at: 10)).	rescale ifTrue:[		dot _ (rx * rx) + (ry * ry) + (rz * rz).		dot < 1.0e-20 			ifTrue:[rx _ ry _ rz _ 0.0]			ifFalse:[dot = 1.0 ifFalse:[dot _ 1.0 / dot sqrt.									rx _ rx * dot. ry _ ry * dot. rz _ rz * dot]]].	pVertex at: PrimVtxNormalX put: (self cCoerce: rx to:'float').	pVertex at: PrimVtxNormalY put: (self cCoerce: ry to:'float').	pVertex at: PrimVtxNormalZ put: (self cCoerce: rz to:'float').! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 4/17/1999 22:24'!transformPrimitivePosition: pVertex by: matrix	"Transform the normal of the given primitive vertex"	| x y z rx ry rz rw |	self var: #pVertex declareC:'float *pVertex'.	self var: #matrix declareC:'float *matrix'.	self var: #x declareC:'double x'.	self var: #y declareC:'double y'.	self var: #z declareC:'double z'.	self var: #rx declareC:'double rx'.	self var: #ry declareC:'double ry'.	self var: #rz declareC:'double rz'.	self var: #rw declareC:'double rw'.	x _ pVertex at: PrimVtxPositionX.	y _ pVertex at: PrimVtxPositionY.	z _ pVertex at: PrimVtxPositionZ.	rx _ (x * (matrix at: 0)) + (y * (matrix at: 1)) + (z * (matrix at: 2)) + (matrix at: 3).	ry _ (x * (matrix at: 4)) + (y * (matrix at: 5)) + (z * (matrix at: 6)) + (matrix at: 7).	rz _ (x * (matrix at: 8)) + (y * (matrix at: 9)) + (z * (matrix at: 10)) + (matrix at: 11).	rw _ (x * (matrix at: 12)) + (y * (matrix at: 13)) + (z * (matrix at: 14)) + (matrix at: 15).	rw = 1.0 ifTrue:[		pVertex at: PrimVtxPositionX put: (self cCoerce: rx to: 'float').		pVertex at: PrimVtxPositionY put: (self cCoerce: ry to:'float').		pVertex at: PrimVtxPositionZ put: (self cCoerce: rz to: 'float').	] ifFalse:[		rw = 0.0 			ifTrue:[rw _ 0.0]			ifFalse:[rw _ 1.0 / rw].		pVertex at: PrimVtxPositionX put: (self cCoerce: rx*rw to:'float').		pVertex at: PrimVtxPositionY put: (self cCoerce: ry*rw to:'float').		pVertex at: PrimVtxPositionZ put: (self cCoerce: rz*rw to: 'float').	].! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 4/17/1999 22:24'!transformPrimitivePositionFast: pVertex by: matrix	"Transform the position of the given primitive vertex assuming that 	matrix a41 = a42 = a43 = 0.0 and a44 = 1.0"	| x y z rx ry rz |	self var: #pVertex declareC:'float *pVertex'.	self var: #matrix declareC:'float *matrix'.	self var: #x declareC:'double x'.	self var: #y declareC:'double y'.	self var: #z declareC:'double z'.	self var: #rx declareC:'double rx'.	self var: #ry declareC:'double ry'.	self var: #rz declareC:'double rz'.	x _ pVertex at: PrimVtxPositionX.	y _ pVertex at: PrimVtxPositionY.	z _ pVertex at: PrimVtxPositionZ.	rx _ (x * (matrix at: 0)) + (y * (matrix at: 1)) + (z * (matrix at: 2)) + (matrix at: 3).	ry _ (x * (matrix at: 4)) + (y * (matrix at: 5)) + (z * (matrix at: 6)) + (matrix at: 7).	rz _ (x * (matrix at: 8)) + (y * (matrix at: 9)) + (z * (matrix at: 10)) + (matrix at: 11).	pVertex at: PrimVtxPositionX put: (self cCoerce: rx to: 'float').	pVertex at: PrimVtxPositionY put: (self cCoerce: ry to: 'float').	pVertex at: PrimVtxPositionZ put: (self cCoerce: rz to: 'float').! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 4/17/1999 22:25'!transformPrimitivePositionFaster: pVertex by: matrix	"Transform the position of the given primitive vertex assuming that 	matrix a14 = a24 = a34 = a41 = a42 = a43 = 0.0 and a44 = 1.0"	| x y z rx ry rz |	self var: #pVertex declareC:'float *pVertex'.	self var: #matrix declareC:'float *matrix'.	self var: #x declareC:'double x'.	self var: #y declareC:'double y'.	self var: #z declareC:'double z'.	self var: #rx declareC:'double rx'.	self var: #ry declareC:'double ry'.	self var: #rz declareC:'double rz'.	x _ pVertex at: PrimVtxPositionX.	y _ pVertex at: PrimVtxPositionY.	z _ pVertex at: PrimVtxPositionZ.	rx _ (x * (matrix at: 0)) + (y * (matrix at: 1)) + (z * (matrix at: 2)).	ry _ (x * (matrix at: 4)) + (y * (matrix at: 5)) + (z * (matrix at: 6)).	rz _ (x * (matrix at: 8)) + (y * (matrix at: 9)) + (z * (matrix at: 10)).	pVertex at: PrimVtxPositionX put: (self cCoerce: rx to:'float').	pVertex at: PrimVtxPositionY put: (self cCoerce: ry to:'float').	pVertex at: PrimVtxPositionZ put: (self cCoerce: rz to: 'float').! !!B3DTransformerPlugin methodsFor: 'transforming' stamp: 'ar 4/17/1999 22:26'!transformPrimitiveRasterPosition: pVertex by: matrix	"Transform the normal of the given primitive vertex"	| x y z rx ry rz rw |	self var: #pVertex declareC:'float *pVertex'.	self var: #matrix declareC:'float *matrix'.	self var: #x declareC:'double x'.	self var: #y declareC:'double y'.	self var: #z declareC:'double z'.	self var: #rx declareC:'double rx'.	self var: #ry declareC:'double ry'.	self var: #rz declareC:'double rz'.	self var: #rw declareC:'double rw'.	x _ pVertex at: PrimVtxPositionX.	y _ pVertex at: PrimVtxPositionY.	z _ pVertex at: PrimVtxPositionZ.	rx _ (x * (matrix at: 0)) + (y * (matrix at: 1)) + (z * (matrix at: 2)) + (matrix at: 3).	ry _ (x * (matrix at: 4)) + (y * (matrix at: 5)) + (z * (matrix at: 6)) + (matrix at: 7).	rz _ (x * (matrix at: 8)) + (y * (matrix at: 9)) + (z * (matrix at: 10)) + (matrix at: 11).	rw _ (x * (matrix at: 12)) + (y * (matrix at: 13)) + (z * (matrix at: 14)) + (matrix at: 15).	pVertex at: PrimVtxRasterPosX put: (self cCoerce: rx to:'float').	pVertex at: PrimVtxRasterPosY put: (self cCoerce: ry to:'float').	pVertex at: PrimVtxRasterPosZ put: (self cCoerce: rz to:'float').	pVertex at: PrimVtxRasterPosW put: (self cCoerce: rw to:'float').! !!B3DVertexBuffer methodsFor: 'private' stamp: 'ar 4/14/1999 02:35'!growVertexArray: newSize	| newVtxArray |	newVtxArray _ vertexArray species new: newSize.	newVtxArray privateReplaceFrom: 1 to: vertexArray basicSize with: vertexArray startingAt: 1.	vertexArray _ newVtxArray.! !!B3DVertexBufferPlugin methodsFor: 'private' stamp: 'ar 4/17/1999 22:29'!vbLoadArray: oop size: count	"Load the word based array of size count from the given oop"	self returnTypeC: 'void*'.	self inline: false.	oop == nil ifTrue:[interpreterProxy primitiveFail. ^nil].	oop == interpreterProxy nilObject ifTrue:[^nil].	(interpreterProxy isWords: oop) 		ifFalse:[interpreterProxy primitiveFail. ^nil].	(interpreterProxy slotSizeOf: oop) = count		ifFalse:[interpreterProxy primitiveFail. ^nil].	^interpreterProxy firstIndexableField: oop! !!B3DVertexClipper methodsFor: 'processing' stamp: 'ar 4/17/1999 23:06'!processIndexedLines: vb	"Process an indexed line set"	^self error:'Lines are not yet implemented'! !!B3DVertexClipper methodsFor: 'processing' stamp: 'ar 4/16/1999 06:46'!processIndexedTriangles: vb	"Clip an indexed triangle set"	| vtxArray idxArray tempVB idx1 idx2 idx3 maxVtx maxIdx index lastIndex clipFlags vtx |	self flag: #b3dPrimitive.	tempVB _ B3DVertexBuffer new.	vtxArray _ vb vertexArray.	idxArray _ vb indexArray.	maxVtx _ vb indexCount.	maxIdx _ vb indexCount.	lastIndex _ -2. "Hack the lastIndex ;-)"	[index _ self primNextClippedTriangleAfter: lastIndex + 3					vertices: vtxArray count: maxVtx					indexes: idxArray count: maxIdx.	index = 0] whileFalse:[		"Need a partial clip here, storing the triangulated polygon at the end"		tempVB reset.		clipFlags _ InAllMask + OutAllMask.		"Copy the poly into tempVB"		0 to: 2 do:[:i|			vtx _ vtxArray at: (idxArray at: index+i).			idxArray at: index+i put: 0.			tempVB addClipVertex: vtx.			clipFlags _ clipFlags bitAnd: vtx clipFlags].		tempVB clipFlags: clipFlags.		self processPolygon: tempVB.		tempVB vertexCount > 2 ifTrue:[			idx1 _ vb addClipVertex: (tempVB vertexArray at: 1).			3 to: tempVB vertexCount do:[:j|				idx2 _ vb addClipVertex: (tempVB vertexArray at: j-1).				idx3 _ vb addClipVertex: (tempVB vertexArray at: j).				vb addClipIndex: idx1.				vb addClipIndex: idx2.				vb addClipIndex: idx3.			].		].		lastIndex _ index.	].! !!B3DVertexClipper methodsFor: 'processing' stamp: 'ar 4/17/1999 23:06'!processLineLoop: vertexBuffer	"Process a closed line defined by the vertex buffer"	^self error:'Lines are not yet implemented'! !!B3DVertexClipper methodsFor: 'processing' stamp: 'ar 4/17/1999 23:06'!processLines: vertexBuffer	"Process a series of lines defined by each two points the vertex buffer"	^self error:'Lines are not yet implemented'! !!B3DVertexClipper methodsFor: 'processing' stamp: 'ar 4/17/1999 23:06'!processPoints: vertexBuffer	"Process a series of points defined by the vertex buffer"	^self error:'Points are not yet implemented'! !!B3DVertexClipper methodsFor: 'processing' stamp: 'ar 4/14/1999 02:19'!processPolygon: vb	"Process a polygon from the vertex buffer that requires partial clipping"	| outMask vtxArray tempVtxArray count |	outMask := vb clipFlags bitAnd: OutAllMask.	vtxArray _ vb vertexArray.	tempVtxArray _ vtxArray clone.	"Note: tempVtxArray has the SAME contents as vtxArray since the data is stored inplace.	Thus we can decide from which buffer to start the clipping operation later on."	count _ self clipPolygon: vtxArray count: vb vertexCount with: tempVtxArray mask: outMask.	vb vertexCount: count.! !!B3DVertexClipper methodsFor: 'clipping polygons' stamp: 'ar 4/16/1999 06:01'!clipPolygonLeftFrom: buf1 to: buf2 count: n	| last next t outIndex inLast inNext outVtx |	outIndex _ 0.	last _ buf1 at: n.	inLast _ last clipFlags anyMask: InLeftBit.	1 to: n do:[:i|		next _ buf1 at: i.		inNext _ next clipFlags anyMask: InLeftBit.		inLast = inNext ifFalse:["Passes clip boundary"			t _ self leftClipValueFrom: last to: next.			outVtx _ self interpolateFrom: last to: next at: t.			buf2 at: (outIndex _ outIndex+1) put: outVtx].		inNext ifTrue:[buf2 at: (outIndex _ outIndex+1) put: next].		last _ next.		inLast _ inNext.	].	^outIndex! !!B3DVertexClipper methodsFor: 'clipping utilitites' stamp: 'ar 4/16/1999 06:43'!interpolateFrom: last to: next at: t	"Interpolate the primitive vertices last/next at the parameter t"	| out |	out _ next clone.	"Interpolate raster position"	out rasterPos: ((next rasterPos - last rasterPos) * t) + last rasterPos.	out clipFlags: (self clipFlagsX: out rasterPosX y: out rasterPosY z: out rasterPosZ w: out rasterPosW).	"Interpolate color"	out b3dColor: ((next b3dColor - last b3dColor) * t) + last b3dColor.	"Interpolate texture coordinates"	out texCoords: ((next texCoords - last texCoords) * t) + last texCoords.	^out! !!B3DPrimitiveClipper methodsFor: 'clip flags' stamp: 'ar 4/18/1999 02:05'!determineClipFlags: vtxArray count: vtxCount	<primitive: 'b3dDetermineClipFlags' module:'Squeak3D'>	^super determineClipFlags: vtxArray count: vtxCount! !!B3DPrimitiveClipper methodsFor: 'clipping polygons' stamp: 'ar 4/18/1999 02:08'!clipPolygon: vtxArray count: vtxCount with: tempVtxArray mask: outMask	<primitive:'b3dClipPolygon' module:'Squeak3D'>	^super clipPolygon: vtxArray count: vtxCount with: tempVtxArray mask: outMask! !!B3DPrimitiveClipper methodsFor: 'private' stamp: 'ar 4/18/1999 02:07'!primNextClippedTriangleAfter: firstIndex vertices: vtxArray count: vtxCount indexes: idxArray count: idxCount	<primitive: 'b3dPrimitiveNextClippedTriangle' module:'Squeak3D'>	^super primNextClippedTriangleAfter: firstIndex vertices: vtxArray count: vtxCount indexes: idxArray count: idxCount! !!B3DVertexRasterizer methodsFor: 'initialize' stamp: 'ar 4/10/1999 22:53'!reset	super reset.	textureStack _ OrderedCollection new.! !!B3DPrimitiveRasterizer methodsFor: 'initialize' stamp: 'ar 4/17/1999 21:10'!canvas: aCanvas	| bb span sourceForm destForm |	canvas _ aCanvas.	span _ Bitmap new: 2048.	sourceForm _ Form extent: span size@1 depth: 32 bits: span.	destForm _ aCanvas form.	bb _ BitBlt toForm: destForm.	bb sourceForm: sourceForm.	bb colorMap: (sourceForm colormapIfNeededForDepth: destForm depth).	bb combinationRule: 34 "Form paint". "Later we'll change this to 34 for alpha blending"	bb clipRect: (aCanvas clipRect translateBy: aCanvas origin).	bb destX: 0; destY: 0; sourceX: 0; sourceY: 0; width: 1; height: 1.	state spanBuffer: span.	state bitBlt: bb.! !!B3DPrimitiveRasterizer methodsFor: 'initialize' stamp: 'ar 4/17/1999 21:10'!flush	self mainLoop.! !!B3DPrimitiveRasterizer methodsFor: 'initialize' stamp: 'ar 4/16/1999 07:54'!initialize	super initialize.	primObjects _ WriteStream on: (Array new: 100).	state _ B3DPrimitiveRasterizerState new.	state initialize.	textures _ IdentityDictionary new: 33.! !!B3DPrimitiveRasterizer methodsFor: 'initialize' stamp: 'ar 4/10/1999 22:53'!reset	super reset.	state reset.! !!B3DPrimitiveRasterizer methodsFor: 'accessing' stamp: 'ar 4/18/1999 01:00'!viewport: vp	canvas == nil		ifTrue:[super viewport: vp]		ifFalse:[super viewport: (vp translateBy: canvas origin)].	viewport toggleYScale.! !!B3DPrimitiveRasterizer methodsFor: 'testing' stamp: 'ar 4/14/1999 02:08'!needsClip	^true! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/17/1999 20:59'!addPrimitiveObject: vb ofSize: objSize	| obj textureIndex |	texture == nil		ifTrue:[textureIndex _ 0]		ifFalse:[textureIndex _ textures at: texture ifAbsentPut:[textures size+1]].	obj _ B3DPrimitiveRasterizerData new: objSize.	self primAddObject: obj		primitive: vb primitive		vertexArray: vb vertexArray		size: vb vertexCount		indexArray: vb indexArray		size: vb indexCount		viewport: viewport		textureIndex: textureIndex.	primObjects nextPut: obj.! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/18/1999 00:24'!clearViewport: aColor	canvas ifNotNil:[canvas fillRectangle: viewport color: aColor asColor]! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/14/1999 02:36'!debugDrawVB: vb	| vtx idx1 idx2 idx3 v1 v2 v3 vp |	vp _ viewport clone.	vp toggleYScale.	vtx _ Array new: vb vertexCount.	vb vertexArray upTo: vb vertexCount doWithIndex:[:v :i|		vtx at: i put: (vp mapVertex4: v rasterPos).	].	1 to: vb indexCount-1 by: 3 do:[:i|		idx1 _ vb indexArray at: i.		idx2 _ vb indexArray at: i+1.		idx3 _ vb indexArray at: i+2.		idx1 = 0 ifFalse:[			v1 _ vtx at: idx1.			v2 _ vtx at: idx2.			v3 _ vtx at: idx3.			canvas line: v1 to: v2 width: 1 color: Color black.			canvas line: v2 to: v3 width: 1 color: Color black.			canvas line: v3 to: v1 width: 1 color: Color black.		].	].! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/16/1999 07:57'!mainLoop	"Do the actual rasterization"	| errCode objects textureArray |	objects _ primObjects contents.	objects size = 0 ifTrue:[^self]. "Nothing to do"	textureArray _ Array new: textures size.	textures associationsDo:[:assoc| textureArray at: assoc value put: assoc key].	state initObjects: objects size.	state initTextures: textureArray size.	[errCode _ self primStartRasterizer: state objects: objects textures: textureArray.	errCode = 0] whileFalse:[		"Not yet finished"		self processErrorCode: (errCode bitAnd: 255).		state reset].	primObjects reset.	textures _ IdentityDictionary new: textures capacity.	false ifTrue:[self printSpaceUsage: objects].! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/12/1999 02:32'!processErrorCode: errCode	errCode = 0 ifTrue:[^true]. "This is allowed!!"	(errCode = B3DNoMoreEdges) 		ifTrue:[^state growEdges].	(errCode = B3DNoMoreFaces)		ifTrue:[^state growFaces].	(errCode = B3DNoMoreAttrs)		ifTrue:[^state growAttrs].	(errCode = B3DNoMoreAET)		ifTrue:[^state growAET].	(errCode = B3DNoMoreAdded)		ifTrue:[^state growAdded].	self error:'Unknown rasterizer error code ', errCode printString.! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/17/1999 20:29'!processIndexedLines: vb	"Process an indexed line set"	self error:'Indexed lines are not yet implemented'! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/17/1999 21:01'!processIndexedQuads: vb	"Process an indexed quad set"	| objSize |	objSize _ self primObjectSize + (vb vertexCount * PrimVertexSize) + (vb indexCount // 4 * 2).	self addPrimitiveObject: vb ofSize: objSize.! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/17/1999 21:00'!processIndexedTriangles: vb	| objSize |	objSize _ self primObjectSize + (vb vertexCount * PrimVertexSize) + (vb indexCount * 3).	self addPrimitiveObject: vb ofSize: objSize.! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/17/1999 20:29'!processLineLoop: vb	"Process a closed line defined by the vertex buffer"	self error:'Lines are not yet implemented'! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/17/1999 20:29'!processLines: vb	"Process a series of lines defined by each two points the vertex buffer"	self error:'Lines are not yet implemented'! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/17/1999 20:30'!processPoints: vertexBuffer	"Process a series of points defined by the vertex buffer"	self error:'Points are not yet implemented'! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 4/17/1999 21:02'!processPolygon: vb	"Process a polygon defined by the vertex buffer"	| objSize |	objSize _ self primObjectSize + (vb vertexCount * PrimVertexSize) + (vb vertexCount - 2 * 3).	self addPrimitiveObject: vb ofSize: objSize.! !!B3DPrimitiveRasterizer methodsFor: 'primitives' stamp: 'ar 4/14/1999 05:12'!primAddObject: obj primitive: primitive vertexArray: vertexArray size: vertexCount indexArray: indexArray size: indexCount viewport: vp textureIndex: txIndex	<primitive:'b3dInitPrimitiveObject' module:'Squeak3D'>	^self primitiveFailed! !!B3DPrimitiveRasterizer methodsFor: 'primitives' stamp: 'ar 4/12/1999 02:17'!primObjectSize	<primitive: 'b3dPrimitiveObjectSize' module:'Squeak3D'>	^self primitiveFailed! !!B3DPrimitiveRasterizer methodsFor: 'primitives' stamp: 'ar 4/14/1999 05:18'!primStartRasterizer: primState objects: primitiveObjects textures: textureArray	"Primitive. Start the rasterizer. Return an error code."	<primitive:'b3dStartRasterizer' module:'Squeak3D'>	^self primitiveFailed! !!B3DPrimitiveRasterizer methodsFor: 'private' stamp: 'ar 4/13/1999 02:13'!printSpaceUsage: objects	"Print out the maximum space used for processing the given objects"	| spaceUsed |	spaceUsed _ state spaceUsed.	objects do:[:obj| spaceUsed _ spaceUsed + obj basicSize].	spaceUsed _ spaceUsed * 4.	Transcript cr; nextPutAll: spaceUsed asStringWithCommas; nextPutAll:' bytes max working set'; endEntry.! !!B3DSqueakFormRasterizer methodsFor: 'initialize' stamp: 'ar 4/10/1999 22:54'!reset	super reset.! !!B3DVertexShader methodsFor: 'initialize' stamp: 'ar 4/10/1999 22:55'!reset	super reset.	lights _ OrderedCollection new.	material _ B3DMaterial new.	materialStack _ OrderedCollection new: 10.! !!B3DVertexShader methodsFor: 'shading' stamp: 'ar 4/3/1999 20:10'!processVertexBuffer: vb	| colors emissionPart |	colors _ B3DColor4Array new: vb vertexCount.	"Load initial colors (e.g., emission part)"	vb trackEmissionColor ifFalse:[		emissionPart _ material emission.		1 to: vb vertexCount do:[:i| colors at: i put: emissionPart].	] ifTrue:[		1 to: vb vertexCount do:[:i| colors at: i put: (vb primitiveVertexAt: i) b3dColor].	].	lights do:[:light|		light shadeVertexBuffer: vb with: material into: colors.	].	colors clampAllFrom: 0.0 to: 1.0.	vb vertexArray upTo: vb vertexCount doWithIndex:[:vtx :i| vtx color: (colors at: i)].! !!B3DPrimitiveShader methodsFor: 'initialize' stamp: 'ar 4/10/1999 22:56'!reset	super reset.	primitiveLights _ #().! !!B3DVertexTransformer methodsFor: 'initialize' stamp: 'ar 4/18/1999 02:23'!initialize	super initialize.	modelMatrix _ B3DMatrix4x4 identity.	viewMatrix _ B3DMatrix4x4 identity.	textureMatrix _ B3DMatrix4x4 identity.	currentMatrix _ modelMatrix.	matrixStack _ OrderedCollection new: 30.	matrixStack resetTo: 1.	needsUpdate _ false.! !!B3DVertexTransformer methodsFor: 'initialize' stamp: 'ar 4/16/1999 07:59'!reset	super reset.	modelMatrix := B3DMatrix4x4 identity.	viewMatrix := B3DMatrix4x4 identity.	textureMatrix := B3DMatrix4x4 identity.	currentMatrix := modelMatrix.	matrixStack := OrderedCollection new: 30.	matrixStack resetTo: 1.	needsUpdate := false.! !!B3DVertexTransformer methodsFor: 'processing' stamp: 'ar 4/18/1999 02:23'!processVertexBuffer: vb	^self processVertexBuffer: vb modelView: self modelViewMatrix projection: self projectionMatrix! !!B3DVertexTransformer methodsFor: 'processing' stamp: 'ar 4/18/1999 02:22'!processVertexBuffer: vb modelView: modelViewMatrix projection: projectionMatrix	^self privateTransformVB: vb vertexArray 			count: vb vertexCount			modelViewMatrix: modelViewMatrix			projectionMatrix: projectionMatrix			flags: vb flags! !!B3DViewport methodsFor: 'accessing' stamp: 'ar 4/3/1999 20:29'!center	^center! !!B3DViewport methodsFor: 'accessing' stamp: 'ar 4/3/1999 20:29'!scale	^scale! !!Collection methodsFor: 'accessing' stamp: 'ar 4/16/1999 07:56'!capacity	"Return the current capacity of the receiver"	^self size! !!B3DMatrix4x4 methodsFor: 'accessing' stamp: 'jsp 2/25/1999 13:58'!alternateRotation	"Return the angular rotation around each axis of the matrix"	| cp sp cy sy cr sr vAngles |	vAngles _ B3DVector3 new.	((self a13) = 0) ifTrue: [ ((self a33) >= 0)  ifTrue: [ vAngles at: 2 put: 0.													  cr _ (self a11).													  sr _ (self a12).													  cp _ (self a33). ]											 ifFalse: [ vAngles at: 2 put: (Float pi).														cr _ (self a11) negated.														sr _ (self a12) negated.														cp _ (self a33) negated. ]							]					ifFalse: [								vAngles at: 2 put: (((self a13) negated) arcTan: (self a33)).								cy _ (vAngles at: 3) cos.								sy _ (vAngles at: 3) sin.								cr _ (cy * (self a11)) + (sy * (self a31)).								sr _ (cy* (self a12)) + (sy * (self a32)).								cp _ (cy * (self a33)) - (sy * (self a13)).							].	sp _ (self a23). 	vAngles at: 1 put: (sp arcTan: cp).	vAngles at: 3 put: (sr arcTan: cr).	vAngles at: 1 put: ((vAngles at: 1) radiansToDegrees).	vAngles at: 2 put: ((vAngles at: 2) radiansToDegrees).	vAngles at: 3 put: ((vAngles at: 3) radiansToDegrees).	^ vAngles.! !!B3DMatrix4x4 methodsFor: 'accessing' stamp: 'jsp 2/25/1999 13:58'!rotation	"Return the angular rotation around each axis of the matrix"	| vRow1 vRow2 vRow3 vScale vShear vAngles vRowCross determinate |	vRow1 _ self row1.	vRow2 _ self row2.	vRow3 _ self row3.	vScale _ B3DVector3 new.	vShear _ B3DVector3 new.	vAngles _ B3DVector3 new.	vScale at: 1 put: (vRow1 length).	vRow1 normalize.	vShear at: 1 put: (vRow1 dot: vRow2).	vRow2 _ vRow2 + (vRow1 * ((vShear at: 1) negated)).	vScale at: 2 put: (vRow2 length).	vRow2 normalize.	vShear at: 1 put: ((vShear at: 1) / (vScale at: 2)).	vShear at: 2 put: (vRow1 dot: vRow3).	vRow3 _ vRow3 + (vRow1 * ((vShear at: 2) negated)).	vShear at: 3 put: (vRow2 dot: vRow3).	vRow3 _ vRow3 + (vRow2 * ((vShear at: 3) negated)).	vScale at: 3 put: (vRow3 length).	vRow3 normalize.	vShear at: 2 put: ((vShear at: 2) / (vScale at: 3)).	vShear at: 3 put: ((vShear at: 3) / (vScale at: 3)).	vRowCross _ vRow2 cross: vRow3.	determinate _ vRow1 dot: vRowCross.	(determinate < 0.0) ifTrue: [ vRow1 _ vRow1 negated.								vRow2 _ vRow2 negated.								vRow3 _ vRow3 negated.								vScale _ vScale negated. ].	vAngles at: 2 put: ((vRow1 at: 3) negated) arcSin.	(((vAngles at: 2) cos) ~= 0.0) 								ifTrue: [ vAngles at: 1 put:												((vRow2 at: 3) arcTan: (vRow3 at: 3)).										  vAngles at: 3 put:												((vRow1 at: 2) arcTan: (vRow1 at: 1)). ]								ifFalse: [ vAngles at: 1 put:												((vRow2 at: 1) arcTan: (vRow2 at: 2)).										  vAngles at: 3 put: 0.0 ].	vAngles at: 1 put: ((vAngles at: 1) radiansToDegrees).	vAngles at: 2 put: ((vAngles at: 2) radiansToDegrees).	vAngles at: 3 put: ((vAngles at: 3) radiansToDegrees).	^ vAngles.! !!B3DMatrix4x4 methodsFor: 'accessing' stamp: 'jsp 2/24/1999 09:46'!rotation: aVector	| xRot yRot zRot cosPitch sinPitch cosYaw sinYaw cosRoll sinRoll |	xRot _ (aVector x) degreesToRadians.	yRot _ (aVector y) degreesToRadians.	zRot _ (aVector z) degreesToRadians.	cosPitch _ xRot cos.	sinPitch _ xRot sin.	cosYaw _ yRot cos.	sinYaw _ yRot sin.	cosRoll _ zRot cos.	sinRoll _ zRot sin.	self a11: (cosRoll*cosYaw).	self a12: (sinRoll*cosYaw).	self a13: (sinYaw negated).	self a21: ((cosRoll*sinYaw*sinPitch) - (sinRoll*cosPitch)).	self a22: ((cosRoll*cosPitch) + (sinRoll*sinYaw*sinPitch)).	self a23: (cosYaw*sinPitch).	self a31: ((cosRoll*sinYaw*cosPitch) + (sinRoll*sinPitch)).	self a32: ((sinRoll*sinYaw*cosPitch) - (cosRoll*sinPitch)).	self a33: (cosYaw*cosPitch).	^ self.! !!B3DMatrix4x4 methodsFor: 'accessing' stamp: 'ar 4/16/1999 21:51'!squaredDistanceFrom: aMatrix	| sum |	sum _ 0.0.	1 to: 4 do:[:i|		1 to: 4 do:[:j|			sum _ sum + ((self at: i at: j) - (aMatrix at: i at: j)) squared]].	^sum! !!B3DMatrix4x4 methodsFor: 'accessing' stamp: 'jsp 2/25/1999 13:58'!trotation	"Return the angular rotation around each axis of the matrix"	| cp sp cy sy cr sr vAngles |	vAngles _ B3DVector3 new.	((self a13) = 0) ifTrue: [ ((self a33) >= 0)  ifTrue: [ vAngles at: 2 put: 0.													  cr _ (self a11).													  sr _ (self a12).													  cp _ (self a33). ]											 ifFalse: [ vAngles at: 2 put: (Float pi).														cr _ (self a11) negated.														sr _ (self a12) negated.														cp _ (self a33) negated. ]							]					ifFalse: [								vAngles at: 2 put: (((self a13) negated) arcTan: (self a33)).								cy _ (vAngles at: 3) cos.								sy _ (vAngles at: 3) sin.								cr _ (cy * (self a11)) + (sy * (self a31)).								sr _ (cy* (self a12)) + (sy * (self a32)).								cp _ (cy * (self a33)) - (sy * (self a13)).							].	sp _ (self a23). 	vAngles at: 1 put: (sp arcTan: cp).	vAngles at: 3 put: (sr arcTan: cr).	vAngles at: 1 put: ((vAngles at: 1) radiansToDegrees).	vAngles at: 2 put: ((vAngles at: 2) radiansToDegrees).	vAngles at: 3 put: ((vAngles at: 3) radiansToDegrees).	^ vAngles.! !!B3DRotation methodsFor: 'interpolating' stamp: 'jsp 2/25/1999 15:57'!interpolateTo: aRotation at: t	"Spherical linear interpolation (slerp) from the receiver to aQuaternion"	^self slerpTo: aRotation at: t extraSpins: 0! !!B3DRotation methodsFor: 'interpolating' stamp: 'ar 3/24/1999 14:58'!slerpTo: aRotation at: t extraSpins: spin	"Sperical Linear Interpolation (slerp).	Calculate the new quaternion when applying slerp from the receiver (t = 0.0)	to aRotation (t = 1.0). spin indicates the number of extra rotations to be added.	The code shown below is from Graphics Gems III"	| cosT alpha beta flip theta phi sinT |	alpha := t.	flip := false.	"calculate the cosine of the two quaternions on the 4d sphere"	cosT := self dot: aRotation.	"if aQuaternion is on the opposite hemisphere reverse the direction	(note that in quaternion space two points describe the same rotation)"	cosT < 0.0 ifTrue:[		flip := true.		cosT := cosT negated].	"If the aQuaternion is nearly the same as I am use linear interpolation"	cosT > 0.99999 ifTrue:[		"Linear Interpolation"		beta := 1.0 - alpha	] ifFalse:[		"Spherical Interpolation"		theta := cosT arcCos.		phi := (spin * Float pi) + theta.		sinT := theta sin.		beta := (theta - (alpha * phi)) sin / sinT.		alpha := (alpha * phi) sin / sinT].	flip ifTrue:[alpha := alpha negated].	^B3DRotation 		a: (alpha * aRotation a) + (beta * self a)		b: (alpha * aRotation b) + (beta * self b)		c: (alpha * aRotation c) + (beta * self c)		d: (alpha * aRotation d) + (beta * self d)! !!OSMesaRasterizer methodsFor: 'initialize' stamp: 'ar 4/10/1999 22:55'!reset	super reset.	handle ifNil:[		handle _ self privateCreateHandle.		self register].! !!OrderedCollection methodsFor: 'private' stamp: 'ar 4/16/1999 07:59'!resetTo: index	firstIndex _ index.	lastIndex _ firstIndex - 1! !!Set methodsFor: 'accessing' stamp: 'ar 4/16/1999 07:56'!capacity	"Return the current capacity of the receiver"	^array size! !!String methodsFor: 'accessing' stamp: 'ar 4/11/1999 22:15'!findString: subString	"Answer the index of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	^self findString: subString startingAt: 1.! !!WonderlandCameraMorph methodsFor: 'debug' stamp: 'ar 4/18/1999 05:28'!debugDraw	Display deferUpdates: false.	self fullDrawOn: (FormCanvas on: Display).	Display deferUpdates: false.	Display forceToScreen: bounds.! !B3DPrimitiveRasterizer initialize!B3DRasterizerPlugin removeSelector: #b3dProceedRasterizer!B3DRenderEngine removeSelector: #processVertexBuffer:!B3DRenderEngine removeSelector: #asPicker!B3DPickerEngine removeSelector: #pickingMatrixAt:extent:!B3DPickerEngine removeSelector: #clearViewport:!B3DPickerEngine removeSelector: #clearDepthBuffer!B3DShaderPlugin removeSelector: #inverseLengthOf:!B3DShaderPlugin removeSelector: #dotProductOf:with:!B3DPrimitiveRasterizer removeSelector: #primAddObject:primitive:vertexArray:size:indexArray:size:viewport:!B3DPrimitiveRasterizer removeSelector: #primStartRasterizer:using:!B3DPrimitiveRasterizer removeSelector: #primProceedRasterizer:after:using:!B3DVertexTransformer removeSelector: #pickMatrix!B3DVertexTransformer removeSelector: #setPickingMatrix:!B3DVertexTransformer removeSelector: #pickMatrix:!B3DPrimitiveTransformer removeSelector: #transformBy:!B3DPrimitiveVertexArray removeSelector: #replaceFrom:to:with:startingAt:!Smalltalk removeClassNamed: #B3DPrimitiveRasterizerObject!