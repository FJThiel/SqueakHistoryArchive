'From Squeak 2.3 of January 14, 1999 on 28 January 1999 at 11:11:52 pm'!"Change Set:		annotationPaneDate:			28 January 1999Author:			Scott WallaceUnder control of a Preference, #useAnnotationPanes, offers user a new little horizontal pane in message-list browsers which (for starters, anyway) can show the time-stamp, the category, counts of senders and implementors -- and later, potentially, other documentation.Look at Preferences class method #defaultAnnotationRequests to see the initial default set of annotations; you can manually edit this method to alter the default.In any message-list-browser, you can change the specification of desired kinds of annotations -- look on the shifted side of the selector menu for 'annotations in this browser'"!StringHolder subclass: #Browser	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer systemCategoryListIndex classListIndex messageCategoryListIndex messageListIndex editSelection metaClassIndicated annotationRequests '	classVariableNames: 'RecentClasses '	poolDictionaries: ''	category: 'Interface-Browser'!!Object methodsFor: 'macpal' stamp: 'sw 1/28/1999 17:31'!contentsChanged	self changed: #contents! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 1/14/1999 17:33'!allChangeSetsWithClass: class selector: selector	^ self gatherChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none]! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 1/14/1999 17:23'!mostRecentChangeSetWithChangeForClass: class selector: selector	| hits |	hits _ self gatherChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ 'not in any change set'].	^ 'change set: ', hits last name! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 1/16/1999 14:40'!open: aMessageSet name: aString 	"Create a standard system view for the messageSet, aMessageSet, whose label is aString."	| topView aListView aBrowserCodeView aTextView |	World ifNotNil: [^ self openAsMorph: aMessageSet name: aString].	topView _ (StandardSystemView new) model: aMessageSet.	topView label: aString.	topView minimumSize: 180 @ 120.	topView borderWidth: 1.	aListView _ PluggableListView on: aMessageSet		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	aListView  menuTitleSelector: #messageListSelectorTitle.	aListView window: (0 @ 0 extent: 180 @ 100).	topView addSubView: aListView.	Preferences useAnnotationPanes ifTrue:			[aTextView _ PluggableTextView on: aMessageSet 			text: #annotation accept: nil			readSelection: nil menu: nil.			aTextView window: (0 @ 0 extent: 180 @ 24).			topView addSubView: aTextView below: aListView.			aTextView askBeforeDiscardingEdits: false].	aBrowserCodeView _ PluggableTextView on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aBrowserCodeView window: (0 @ 0 extent: 180 @ 300).	topView addSubView: aBrowserCodeView below: (aTextView ifNil: [aListView]).	topView controller open! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 1/12/1999 10:40'!openAsMorph: aMessageSet name: labelString inWorld: aWorld	"Create a SystemWindow aMessageSet, with the label labelString."	| window aListMorph topOfText aTextMorph |	window _ (SystemWindow labelled: labelString) model: aMessageSet.	aListMorph _ PluggableListMorph on: aMessageSet list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0@0 extent: 1@0.2).	Preferences useAnnotationPanes		ifFalse:			[topOfText _ 0.2]		ifTrue:			[aTextMorph _ PluggableTextMorph on: aMessageSet					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.2 corner: 1@0.25).			topOfText _ 0.25].	window addMorph: (PluggableTextMorph on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@topOfText corner: 1@1).	window openInWorld: aWorld! !!PluggableTextMorph methodsFor: 'updating' stamp: 'sw 1/11/1999 14:35'!update: aSymbol	aSymbol == #flash ifTrue: [^ self flash].	aSymbol == getTextSelector ifTrue:			[self setText: self getText.			^ self setSelection: self getSelection].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector ~~ nil]) ifTrue:			[self handleEdit:				[textMorph editor setSearch: model autoSelectString;							againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [^ self promptForCancel].			^ self].	aSymbol == #appendEntry ifTrue:			[self handleEdit: [self appendEntry].			^ self world ifNotNil: [ self world displayWorld]].	aSymbol == #clearText ifTrue:			[self handleEdit: [self changeText: Text new].			^ self world displayWorld].! !!PluggableTextView methodsFor: 'model access' stamp: 'sw 1/16/1999 14:31'!getSelection	"Answer the model's selection interval."	getSelectionSelector == nil ifTrue: [^ 1 to: 0].  "null selection"	^ getSelectionSelector ifNotNil: [model perform: getSelectionSelector]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 1/25/1999 13:51'!chooseInitialSettings 	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	#(	(allowSysWindowEmbedding			false)		(automaticViewerPlacement			true)		(browseWithPrettyPrint				false)		(cmdDotEnabled						true)		(confirmFirstUseOfStyle				true)		(disableSounds						false)		(fastDragWindowForMorphic			false)		(ignoreStyleIfOnlyBold				true)		(inboardScrollbars					false)		(logDebuggerStackToFile				true)		(noviceMode							false)		(printAlternateSyntax				false)		(reverseWindowStagger				true)		(showDebugHaloHandle				true)		(showDiffsInChangeList				true)		(showPlayerSource					false)		(showScriptSource					false)		(showTimeStampsInMenuTitles		false)		(showProjectZoom					false)		(suppressCheckForSlips				false)		(suppressUpdateServerPrompt		false)		(thoroughSenders					true)		(unlimitedPaintArea					false)		(updateSavesFile						false)		(useAnnotationPanes				false)		(useDetailPanesInViewers			false)		(warnIfNoChangesFile				true)		(warnIfNoSourcesFile				true))	do:		[:aPair |			aPair last == #true				ifTrue:					[self enable: aPair first]				ifFalse:					[self disable: aPair first]]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 1/25/1999 13:54'!initializeHelpMessages 	"Preferences initializeHelpMessages"  	HelpDictionary _ Dictionary new.	#((allowSysWindowEmbedding'Determines whether, in Morphic, SystemWindows should automatically be droppable into willing receptors')(automaticViewerPlacement'If true, new viewers are automatically positioned near the objects they view; if false, new viewers are attached to the hand, from whence you much choose a destination for them')(browseWithPrettyPrint'If true, browsers will automatically format their contents')(cautionBeforeClosing 'If true, Morphic windows seen in an mvc project will put up a warning before allowing themselves to be dismissed')(cmdDotEnabled'If true, cmd-dot brings up a debugger;if false, the cmd-dot interrupt is disabled')(confirmFirstUseOfStyle'If true, the first attempt to submit a method with non-standard style will bring up a confirmation dialog')(disableSounds'If true, all sound playing is disabled')	(editPlayerScriptsInPlace 'If true, textual player scripts are edited in place in Scriptors (still imperfectly implemented)')(eToyScheme'If true, new scripting spaces place the Playfield to the left and the the palette to the right of the window; if false, the opposite is true.')(fastDragWindowForMorphic'If true, morphic window drag will be done by dragging an outline of the window.')(ignoreStyleIfOnlyBold'If true, then any method submission in which the only style change is for bolding will be treated as a method with no style specifications')(inboardScrollbars'If true, then ScrollPane will place scrollbars inside on the right and will not hide them on exit')(logDebuggerStackToFile'If true, whenever you fall into a debugger a summary of its stack will be written to a file named''SqueakDebug.log''')(noviceMode 'If true, certain novice-mode accommodations are made.')(printAlternateSyntax'If true, thenprettyPrint using experimental syntax.Otherwise use normal ST-80 syntax.')(reverseWindowStagger'If true, a reverse-stagger strategy  is used for determining where newly launched windows will be placed; if false, a direct- stagger strategy is used.')(showDebugHaloHandle 'If true, a special debugging halo handle is displayed at the right of the halo; if false, no such handle is shown.')(showDiffsInChangeList'If true, changeList browsers and Versions browsers reveal the differences between successive versions or between the in-memory code and the code on disk')(showPlayerSource'If true, then all Player methods with fewer than 2 arguments are included in Viewers, whether or not they are intended for end-user use.  This can be dangerous')(showProjectZoom'If true, then show a zoom effect when entering or leaving projects.  This can be costly of memory (at least an extra screen buffer) so dont use it in low space situations.  But it is cool.')(showScriptSource'If true, then the actual Smalltalk source code for methods is shown in the detail panes for scripts in a viewer; if false, then a help message for scripts is shown instead.')(showTimeStampsInMenuTitles'If true, then the author''s timestamp is displayed as the menu title of any message list; if false, no author''s timestamps are shown')(suppressCheckForSlips 'If false, then whenever you file out a change set, it is checked for ''slips'' and if any are found, you are so informed and given a chance to open a browser on them')(suppressUpdateServerPrompt'If true, the prompt for server choice when updating code from the server is suppressed.  Set this to true to leave the server choice unchanged from update to update.')(thoroughSenders'If true, then ''senders'' browsers will dive inside structured literals in their search')(uniformWindowColors'If true, then all standard windows are given the same color rather than their customized window-type-specific colors')(unlimitedPaintArea'If true, the painting area for a new drawing will not be limited in size; if false, a reasonablelimit will be applied, in an attempt to hold down memory and time price.')(updateRemoveSequenceNum'If true, then remove the leading sequence number from the filename before automatically saving a local copy of any update loaded.')(updateSavesFile'If true, then when an update is loaded from the server, a copy of it will automatically be saved on a local file as well.')(useAnnotationPanes'If true, a thin horizontal annotation pane is used in message-list browsers.')(useDetailPanesInViewers'If true, then Viewers will have an extra "¦" control at the left of each row, the hitting of which toggles the appearance of a textual detail pane.')(useNewViewers'If true, then the new kinds of viewers introduced in Squeak 2.3 are used; if false, then the old style, from earlier releases, are still used.  Old viewers will hopefully soon be removed from the system.')(warnIfNoChangesFile'If true, then you will be warned, whenever you start up, if no changes filecan be found')(warnIfNoSourcesFile 'If true, then you will be warned, whenever you start up, if no sources file can be found')) do:		[:pair | HelpDictionary at: pair first put: 			(pair first, ':', pair last)]! !!Preferences class methodsFor: 'parameters' stamp: 'sw 1/15/1999 12:54'!defaultAnnotationRequests	"Manually change this method to alter what the default for any new browser is"	^ #(timeStamp messageCategory implementorsCount allChangeSets)	 "Available annotations at present (feel free to add your own):		timeStamp			The time stamp of the last submission fo the method.		messageCategory	Which method category the method lies in.		sendersCount		A report of how many senders there of the message.		implementorsCount	A report of how many implementors there are of the message.		recentChangeSet		The most recent change set bearing the method.		allChangeSets		A list of all change sets bearing the method.		rating				A numeric rating for the method.		testing				Just for testing."! !!StringHolder methodsFor: 'annotation pane' stamp: 'sw 1/28/1999 17:16'!annotation	"Provide a line of annotation material for a middle pane.  In time, we should give the user options about what to show here.  For the moment, the way to customize what is shown is to change this method"	| stamp aMessage sendersCount implementorsCount toShow aCategory separator aString aList |	(aMessage _ self selectedMessageName)		ifNil:			[^ '------'].	toShow _ ReadWriteStream on: ''.	separator _ ' ¥ '.	self annotationRequests do:		[:aRequest |		(aRequest == #timeStamp) ifTrue:			[stamp _ self timeStamp.			toShow nextPutAll: 'stamp: '.			toShow nextPutAll: (stamp size > 0				ifFalse:					['none', separator]				ifTrue:					[stamp, separator])].		(aRequest == #messageCategory) ifTrue:			[aCategory _ self selectedClassOrMetaClass organization categoryOfElement: self selectedMessageName.			aCategory ifNotNil: "woud be nil for a method no longer present, e.g. in a recent-submissions browser"				[toShow nextPutAll: 'category: ', aCategory, separator]].		(aRequest == #sendersCount) ifTrue:			[sendersCount _ (Smalltalk allCallsOn: aMessage) size.			sendersCount _ sendersCount == 1				ifTrue:					['1 sender']				ifFalse:					[sendersCount printString, ' senders'].			toShow nextPutAll: sendersCount, separator].		(aRequest == #implementorsCount) ifTrue:			[implementorsCount _ (Smalltalk allImplementorsOf: aMessage) size.			implementorsCount _ implementorsCount == 1				ifTrue:					['1 implementor']				ifFalse:					[implementorsCount printString, ' implementors'].			toShow nextPutAll: implementorsCount,  separator].		(aRequest == #rating) ifTrue:			[toShow nextPutAll: 'rating ', (10 atRandom - 5) printString, separator].		(aRequest == #testing) ifTrue:			[toShow nextPutAll: 'TESTING', separator]].		(aRequest == #recentChangeSet) ifTrue:			[aString _ ChangeSorter mostRecentChangeSetWithChangeForClass: self selectedClassOrMetaClass selector: self selectedMessageName.			aString size > 0 ifTrue: [toShow nextPutAll: aString, separator]].		(aRequest == #allChangeSets) ifTrue:			[aList _ ChangeSorter allChangeSetsWithClass: self selectedClassOrMetaClass selector: self selectedMessageName.			aList size > 0 ifTrue:				[aList size == 1					ifTrue:						[toShow nextPutAll: 'only in change set ']					ifFalse:						[toShow nextPutAll: 'in change sets: '].				aList do:					[:aChangeSet | toShow nextPutAll: aChangeSet name, ' '].				toShow nextPutAll: separator]].			^ toShow contents! !!StringHolder methodsFor: 'annotation pane' stamp: 'sw 1/28/1999 17:18'!annotationRequests	^ Preferences defaultAnnotationRequests! !!StringHolder methodsFor: 'annotation pane' stamp: 'sw 1/28/1999 17:30'!contentsChanged	self changed: #contents.	self changed: #annotation! !!StringHolder methodsFor: 'annotation pane' stamp: 'sw 1/28/1999 17:20'!noteContentsChanged	"Update the contents pane.  Subclasses that have an element between the selector list and the contents pane can intercept here to note the change to that last pane also"	self changed: #contents.	self changed: #annotation! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 1/28/1999 12:34'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self contentsChanged! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 1/28/1999 12:34'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords codeController |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	changeRecords size <= 1 ifTrue: [self changed: #flash.  ^ self beep].	codeController _ Smalltalk isMorphic		ifTrue: [(self dependents detect: [:v | v isKindOf: PluggableTextMorph])]		ifFalse: [(self dependents detect: [:v | v isKindOf: PluggableTextView]) controller].		"later find a better way to do this!!"	self contents: (changeRecords at: 2) string notifying: codeController.	self contentsChanged! !!Browser methodsFor: 'initialize-release' stamp: 'sw 1/28/1999 18:27'!buildCommentSwitchView	| aSwitchView |	aSwitchView _ PluggableButtonView		on: self		getState: #classCommentIndicated		action: #plusButtonHit.	aSwitchView		label: '?' asText allBold asParagraph;		borderWidthLeft: 0 right: 1 top: 0 bottom: 0;			window: (0@0 extent: 10@8);		askBeforeChanging: true.	^ aSwitchView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 1/28/1999 18:27'!buildMorphicSwitches	| instanceSwitch commentSwitch classSwitch row aColor |	instanceSwitch _ PluggableButtonMorph		on: self		getState: #instanceMessagesIndicated		action: #indicateInstanceMessages.	instanceSwitch		label: 'instance';		askBeforeChanging: true.	commentSwitch _ PluggableButtonMorph		on: self		getState: #classCommentIndicated		action: #plusButtonHit.	commentSwitch		label: '?' asText allBold asParagraph;		askBeforeChanging: true;		setBalloonText: 'class comment'.	classSwitch _ PluggableButtonMorph		on: self		getState: #classMessagesIndicated		action: #indicateClassMessages.	classSwitch		label: 'class';		askBeforeChanging: true.	row _ AlignmentMorph newRow		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 0;		borderColor: Color transparent;		addMorphBack: instanceSwitch;		addMorphBack: commentSwitch;		addMorphBack: classSwitch.	aColor _ Color colorFrom: self defaultBackgroundColor.	row submorphs do:		[:m | m color: aColor.		m onColor: aColor darker offColor: aColor].	^ row! !!Browser methodsFor: 'system category list' stamp: 'sw 1/28/1999 12:30'!systemCategoryListIndex: anInteger 	"Set the selected system category index to be anInteger. Update all other 	selections to be deselected."	systemCategoryListIndex _ anInteger.	classListIndex _ 0.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	editSelection _ anInteger = 0 ifTrue: [#none] ifFalse: [#newClass].	metaClassIndicated _ false.	self setClassOrganizer.	contents _ nil.	self changed: #systemCategorySelectionChanged.	self changed: #systemCategoryListIndex.	"update my selection"	self changed: #classList.	self changed: #messageCategoryList.	self changed: #messageList.	self contentsChanged.! !!Browser methodsFor: 'system category functions' stamp: 'sw 1/28/1999 12:30'!editSystemCategories	"Retrieve the description of the class categories of the system organizer."	self okToChange ifFalse: [^ self].	self systemCategoryListIndex: 0.	editSelection _ #editSystemCategories.	self changed: #editSystemCategories.	self contentsChanged! !!Browser methodsFor: 'class functions' stamp: 'sw 1/28/1999 22:56'!editComment	"Retrieve the description of the class comment."	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	editSelection _ #editComment.	self changed: #classSelectionChanged.	self contentsChanged! !!Browser methodsFor: 'class functions' stamp: 'sw 1/28/1999 12:30'!hierarchy	"Display the inheritance hierarchy of the receiver's selected class."	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	editSelection := #hierarchy.	self changed: #editComment.	self contentsChanged.	^ self! !!Browser methodsFor: 'class functions' stamp: 'sw 1/28/1999 18:27'!plusButtonHit	"Cycle between definition, comment, and hierachy"	editSelection == #editComment		ifTrue: [self hierarchy. ^ self].	editSelection == #hierarchy		ifTrue: [editSelection := #editClass.			classListIndex = 0 ifTrue: [^ self].			self okToChange ifFalse: [^ self].			self changed: #editComment.			self contentsChanged.			^self].	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	editSelection := #editComment.	self changed: #classSelectionChanged.	self contentsChanged.! !!Browser methodsFor: 'message category functions' stamp: 'sw 1/28/1999 12:30'!editMessageCategories	"Indicate to the receiver and its dependents that the message categories of 	the selected class have been changed."	self okToChange ifFalse: [^ self].	classListIndex ~= 0		ifTrue: 			[self messageCategoryListIndex: 0.			editSelection _ #editMessageCategories.			self changed: #editMessageCategories.			self contentsChanged]! !!Browser methodsFor: 'message functions' stamp: 'sw 1/16/1999 15:12'!chooseAnnotations	| reply newList |	reply _ FillInTheBlank request: 'Annotations: ' initialAnswer: '#', self annotationRequests printString.	newList _ Compiler evaluate: reply.	(newList size > 0 and: [newList isKindOf: Array])		ifTrue: [annotationRequests _ newList]! !!Browser methodsFor: 'message functions' stamp: 'sw 1/26/1999 08:43'!messageListMenu: aMenu shifted: shifted	^ shifted ifFalse: [aMenu labels:'browse full (b)fileOutprintOutsenders of... (n)implementors of... (m)method inheritanceversions (v)inst var refs...inst var defs...class var refs...class variablesclass refs (N)removemore...'	lines: #(3 7 12)	selections:		#(browseMethodFull fileOutMessage printOutMessage		browseSendersOfMessages browseMessages methodHierarchy browseVersions		browseInstVarRefs browseInstVarDefs browseClassVarRefs 			browseClassVariables browseClassRefs		removeMessage shiftedYellowButtonActivity )]	ifTrue: [aMenu labels: 'browse class hierarchybrowse classbrowse methodimplementors of sent messageschange sets with this methodinspect instancesinspect subinstancesremove from this browserannotations in this browserrevert to previous versionremove from current change setrevert and forgetmore...' 	lines: #(5 7 9 12)	selections: #(classHierarchy browseClass 		buildMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		removeMessageFromBrowser chooseAnnotations		revertToPreviousVersion 		removeFromCurrentChanges revertAndForget		unshiftedYellowButtonActivity)]! !!Browser methodsFor: 'message functions' stamp: 'sw 1/28/1999 12:30'!prettyPrint	"Reformat the selected method"	| selectedClass |	((self messageListIndex = 0) | (self okToChange not))		ifTrue: [^ self changed: #flash].	selectedClass _ self selectedClassOrMetaClass.	contents _ selectedClass compilerClass new			format: contents			in: selectedClass			notifying: nil.	self contentsChanged.! !!Browser methodsFor: 'code pane' stamp: 'sw 1/28/1999 12:30'!showBytecodes	"Show the bytecodes of the selected method."	"Set a mode for contents!!"	((self messageListIndex = 0) | (self okToChange not))		ifTrue: [^ self changed: #flash].	editSelection _ #byteCodes.	self contentsChanged.! !!Browser methodsFor: 'annotations' stamp: 'sw 1/15/1999 12:55'!annotationRequests	annotationRequests ifNil: [annotationRequests _ Preferences defaultAnnotationRequests].	^ annotationRequests! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 1/28/1999 12:30'!toggleListIndex: newListIndex	listIndex ~= 0 ifTrue: [listSelections at: listIndex put: false].	newListIndex ~= 0 ifTrue: [listSelections at: newListIndex put: true].	listIndex _ newListIndex.	self changed: #listIndex.	self contentsChanged! !!ChangeSorter methodsFor: 'access' stamp: 'sw 1/28/1999 12:31'!showChangeSet: chgSet	myChangeSet == chgSet ifFalse: [		myChangeSet _ chgSet.		currentClassName _ nil.		currentSelector _ nil].	self changed: #relabel.	self changed: #currentCngSet.	"new -- list of sets"	self changed: #mainButtonName.	"old, button"	self changed: #classList.	self changed: #messageList.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 1/28/1999 12:30'!clearChangeSet	"Clear out the current change set, after getting a confirmation."	| message |	self okToChange ifFalse: [^ self].	myChangeSet isEmpty ifFalse:		[message _ 'Are you certain that you want to\forget all the changes in this set?' withCRs.		(self confirm: message) ifFalse: [^ self]].	myChangeSet clear.	self changed: #classList.	self changed: #messageList.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 1/28/1999 12:30'!currentClassName: aString	currentClassName _ aString.	currentSelector _ nil.	"fix by wod"	self changed: #currentClassName.	self changed: #messageList.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 1/28/1999 12:31'!currentSelector: messageName	currentSelector _ messageName.	self changed: #currentSelector.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 1/28/1999 12:31'!removeMessage	"Remove the selected msg from the system.  Real work done by the parent, a ChangeSorter"	| confirmation sel |	self okToChange ifFalse: [^ self].	currentSelector ifNotNil: [		confirmation _ self selectedClassOrMetaClass 			confirmRemovalOf: (sel _ self selectedMessageName).		confirmation == 3 ifTrue: [^ self].		myChangeSet removeSelectorChanges: sel 			class: self selectedClassOrMetaClass.		self selectedClassOrMetaClass removeSelector: sel.		self update.	"	self changed: #messageList.		self setContents.		self contentsChanged.	"		confirmation == 2 ifTrue:			[Smalltalk browseAllCallsOn: sel]]! !!Debugger methodsFor: 'private' stamp: 'sw 1/28/1999 12:31'!contextStackIndex: anInteger oldContextWas: oldContext	| newMethod |	contextStackIndex _ anInteger.	anInteger = 0		ifTrue:			[tempNames _ sourceMap _ contents _ nil.			self changed: #contextStackIndex.			self contentsChanged.			contextVariablesInspector object: nil.			receiverInspector object: self receiver.			^self].	(newMethod _ oldContext == nil or:		[oldContext method ~~ self selectedContext method])		ifTrue:			[tempNames _ sourceMap _ nil.			contents _ self selectedMessage.			self changed: #contents.			self pcRange "will compute tempNamesunless noFrills"].	self changed: #contextStackIndex.	tempNames == nil		ifTrue: [tempNames _ 					self selectedClassOrMetaClass parserClass new parseArgsAndTemps: contents notifying: nil].	contextVariablesInspector object: self selectedContext.	receiverInspector object: self receiver.	newMethod ifFalse: [self changed: #contentsSelection]! !!MessageSet methodsFor: 'message list' stamp: 'sw 1/28/1999 12:32'!messageListIndex: anInteger 	"Set the index of the selected item to be anInteger."	messageListIndex _ anInteger.	contents _ 		messageListIndex ~= 0			ifTrue: [self selectedMessage]			ifFalse: [''].	self changed: #messageListIndex.	"update my selection"	self contentsChanged.	(messageListIndex ~= 0 and: [autoSelectString notNil])		ifTrue: [self changed: #autoSelect].! !!MessageSet methodsFor: 'message functions' stamp: 'sw 1/28/1999 12:34'!removeMessage	"Remove the selected message from the system. 1/15/96 sw"	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self initializeMessageList: (messageList copyWithout: self selection).		"self messageListIndex: 0."	self changed: #messageList.	self changed: #messageListIndex.	self contentsChanged.	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !!MessageSet methodsFor: 'message functions' stamp: 'sw 1/28/1999 12:34'!removeMessageFromBrowser	"Remove the selected message from the browser."	messageListIndex = 0 ifTrue: [^ self].	self initializeMessageList: (messageList copyWithout: self selection).	"self messageListIndex: 0."	self changed: #messageList.	self changed: #messageListIndex.	self contentsChanged.! !!MessageSet methodsFor: 'message functions' stamp: 'sw 1/28/1999 12:34'!showBytecodes	"Show the bytecodes of the selected method."	"Set a mode for contents!!"	((self messageListIndex = 0) | (self okToChange not))		ifTrue: [^ self changed: #flash].	contents _ (self selectedClassOrMetaClass compiledMethodAt: 					self selectedMessageName) symbolic asText.	self contentsChanged.! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'sw 1/28/1999 12:35'!contents: newContents	contents _ newContents.	self contentsChanged! !Browser removeSelector: #setDefaultAnnotationRequests!Browser removeSelector: #annotation!Browser removeSelector: #noteContentsChanged!MessageSet removeSelector: #contentsChanged!"Postscript:"Preferences disable: #useAnnotationPanes.Preferences disable: #useDetailPanesInViewers.Preferences initializeHelpMessages.!