'From Squeak2.8 of 18 June 2000 [latest update: #2348] on 27 July 2000 at 12:24:01 pm'!"Change Set:		SoundDate:			27 July 2000Author:			John Maloney, Michael RuegerThis change set adds- messages to sound readers enabling them to read from any stream, not just a file.- two new sounds marimba and pluckedElecBass- messages for settings in the ScorePlayer."!!AIFFFileReader methodsFor: 'reading'!readFrom: binaryStream mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag	"Read the AIFF file of the given name. If mergeFlag is true and the file contains stereo data, then the left and right channels will be mixed together as the samples are read in. If skipDataFlag is true, then the data chunk to be skipped; this allows the other chunks of a file to be processed in order to extract format information quickly without reading the data."	"AIFFFileReader new readFromFile: 'test.aif' mergeIfStereo: false skipDataChunk: false"	mergeIfStereo _ mergeFlag.	skipDataChunk _ skipDataFlag.	isLooped _ false.	gain _ 1.0.	self readFrom: binaryStream.	binaryStream close.! !!AIFFFileReader methodsFor: 'reading'!readFromFile: fileName mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag	"Read the AIFF file of the given name. If mergeFlag is true and the file contains stereo data, then the left and right channels will be mixed together as the samples are read in. If skipDataFlag is true, then the data chunk to be skipped; this allows the other chunks of a file to be processed in order to extract format information quickly without reading the data."	"AIFFFileReader new readFromFile: 'test.aiff' mergeIfStereo: false skipDataChunk: true"	| binaryStream |	binaryStream _ (FileStream readOnlyFileNamed: fileName) binary.	self readFrom: binaryStream mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag! !!FMSound class methodsFor: 'instruments' stamp: 'jm 9/2/1999 13:32'!marimba	"FMSound marimba play"	"(FMSound majorScaleOn: FMSound marimba) play"	| snd p env |	snd _ FMSound new modulation: 1 ratio: 0.98.	p _ OrderedCollection new.	p add: 0@1.0; add: 10@0.3; add: 40@0.1; add: 80@0.02; add: 120@0.1; add: 160@0.02; add: 220@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 4 loopEnd: 6).	p _ OrderedCollection new.	p add: 0@1.2; add: 80@0.85; add: 120@1.0; add: 160@0.85; add: 220@0.0.	env _ Envelope points: p loopStart: 2 loopEnd: 4.	env updateSelector: #modulation:.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 9/1/1999 17:33'!pluckedElecBass	"FMSound pluckedElecBass play"	"(FMSound lowMajorScaleOn: FMSound pluckedElecBass) play"	| snd p env |	snd _ FMSound new modulation: 1 ratio: 3.0.	p _ OrderedCollection new.	p add: 0@0.4; add: 20@1.0; add: 30@0.6; add: 100@0.6; add: 130@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 4).	p _ OrderedCollection new.	p add: 0@1.0; add: 20@2.0; add: 30@4.5; add: 100@4.5; add: 130@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 4.	env updateSelector: #modulation:.	snd addEnvelope: env.	p _ OrderedCollection new.	p add: 0@6.0; add: 20@4.0; add: 30@3.0; add: 100@3.0; add: 130@3.0.	env _ Envelope points: p loopStart: 3 loopEnd: 4.	env updateSelector: #ratio:.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!LoopedSampledSound methodsFor: 'initialization'!fromAIFFFileReader: aiffFileReader mergeIfStereo: mergeFlag	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	aiffFileReader isLooped		ifTrue: [			self samples: aiffFileReader leftSamples				loopEnd: aiffFileReader loopEnd				loopLength: aiffFileReader loopLength				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate]		ifFalse: [			self unloopedSamples: aiffFileReader leftSamples				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate].	"the following must be done second, since the initialization above sets	 leftSamples and rightSamples to the same sample data"	aiffFileReader isStereo		ifTrue: [rightSamples _ aiffFileReader rightSamples].	initialCount _ (leftSamples size * self samplingRate) // originalSamplingRate.	self loudness: 1.0.	self addReleaseEnvelope.! !!LoopedSampledSound class methodsFor: 'instance creation'!fromAIFFFileNamed: fileName mergeIfStereo: mergeFlag	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	| aiffFileReader |	aiffFileReader _ AIFFFileReader new.	aiffFileReader readFromFile: fileName		mergeIfStereo: mergeFlag		skipDataChunk: false.	self new fromAIFFFileReader: aiffFileReader mergeIfStereo: mergeFlag! !!LoopedSampledSound class methodsFor: 'instance creation'!fromAIFFStream: fileStream	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	^self fromAIFFStream: fileStream mergeIfStereo: true! !!LoopedSampledSound class methodsFor: 'instance creation'!fromAIFFStream: fileStream mergeIfStereo: mergeFlag	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	| aiffFileReader |	aiffFileReader _ AIFFFileReader new.	aiffFileReader readFrom: fileStream		mergeIfStereo: mergeFlag		skipDataChunk: false.	^self new fromAIFFFileReader: aiffFileReader mergeIfStereo: mergeFlag! !!SampledSound class methodsFor: 'instance creation'!fromAIFFStream: fileStream	| aiffFileReader |	aiffFileReader _ AIFFFileReader new.	aiffFileReader readFrom: fileStream		mergeIfStereo: true		skipDataChunk: false.	^ self		samples: (aiffFileReader channelData at: 1)		samplingRate: aiffFileReader samplingRate! !!SampledSound class methodsFor: 'instance creation'!fromWaveFileNamed: fileName	"(SampledSound fromWaveFileNamed: 'c:\windows\media\chimes.wav') play"	"| snd fd |	fd := FileDirectory on:'c:\windows\media\'.	fd fileNames do: [:n |		(n asLowercase endsWith: '.wav')			ifTrue: [				snd _ SampledSound fromWaveFileNamed: (fd pathName,n).				snd play.				SoundPlayer waitUntilDonePlaying: snd]]."	^self fromWaveStream: (FileStream oldFileNamed: fileName)! !!SampledSound class methodsFor: 'instance creation'!fromWaveStream: fileStream	| stream header data type channels samplingRate blockAlign bitsPerSample leftAndRight |	header _ self readWaveChunk: 'fmt ' inRIFF: fileStream.	data _ self readWaveChunk: 'data' inRIFF: fileStream.	fileStream close.	stream _ ReadStream on: header.	type _ self next16BitWord: false from: stream.	type = 1 ifFalse: [^ self error:'Unexpected wave format'].	channels _ self next16BitWord: false from: stream.	(channels < 1 or: [channels > 2])		ifTrue: [^ self error: 'Unexpected number of wave channels'].	samplingRate _ self next32BitWord: false from: stream.	stream skip: 4. "skip average bytes per second"	blockAlign _ self next16BitWord: false from: stream.	bitsPerSample _ self next16BitWord: false from: stream.	(bitsPerSample = 8 or: [bitsPerSample = 16])		ifFalse: [  "recompute bits per sample"			bitsPerSample _ (blockAlign // channels) * 8].	bitsPerSample = 8		ifTrue: [data _ self convert8bitUnsignedTo16Bit: data]		ifFalse: [data _ self convertBytesTo16BitSamples: data mostSignificantByteFirst: false].	channels = 2 ifTrue: [		leftAndRight _ data splitStereo.		^ MixedSound new			add: (self samples: leftAndRight first samplingRate: samplingRate) pan: 0.0;			add: (self samples: leftAndRight last samplingRate: samplingRate) pan: 1.0;			yourself].	^ self samples: data samplingRate: samplingRate! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/1/1999 20:33'!instrumentForTrack: trackIndex put: aSoundProto	trackIndex > instruments size ifTrue: [^ self].	instruments at: trackIndex put: aSoundProto.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/1/1999 20:33'!mutedForTrack: trackIndex put: aBoolean	trackIndex > muted size ifTrue: [^ self].	muted at: trackIndex put: aBoolean.	aBoolean ifFalse: [^ self].	"silence any currently sounding notes for this track"	activeSounds do: [:pair |		pair last = trackIndex ifTrue: [activeSounds remove: pair ifAbsent: []]].	midiPort ifNotNil: [		activeMIDINotes do: [:pair |			pair last = trackIndex ifTrue: [				pair first endNoteOnMidiPort: midiPort.				activeMIDINotes remove: pair ifAbsent: []]]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/2/1999 13:33'!panForTrack: trackIndex put: aNumber	"Set the left-right pan for this track to a value in the range [0.0..1.0], where 0.0 means full-left."	| fullVol pan left right |	trackIndex > leftVols size ifTrue: [^ self].	fullVol _ (leftVols at: trackIndex) max: (rightVols at: trackIndex).	pan _ (aNumber asFloat min: 1.0) max: 0.0.	pan <= 0.5		ifTrue: [  "attenuate right channel"			left _ fullVol.			right _ 2.0 * pan * fullVol]		ifFalse: [  "attenuate left channel"			left _ 2.0 * (1.0 - pan) * fullVol.			right _ fullVol].	rightVols at: trackIndex put: right asInteger.	leftVols at: trackIndex put: left asInteger.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/1/1999 14:33'!settingsString	| s |	s _ WriteStream on: (String new: 1000).	s nextPutAll: 'player'; cr.	s tab; nextPutAll: 'rate: ', self rate printString, ';'; cr.	s tab; nextPutAll: 'overallVolume: ', self overallVolume printString, ';'; cr.	1 to: self trackCount do: [:t |		s tab; nextPutAll: 'instrumentForTrack: ', t printString,			' put: (AbstractSound soundNamed: #default);'; cr.		s tab; nextPutAll: 'mutedForTrack: ', t printString,			' put: ', (self mutedForTrack: t) printString, ';'; cr.		s tab; nextPutAll: 'volumeForTrack: ', t printString,			' put: ', (self volumeForTrack: t) printString, ';'; cr.		s tab; nextPutAll: 'panForTrack: ', t printString,			' put: ', (self panForTrack: t) printString, ';'; cr].	s tab; nextPutAll: 'repeat: ', self repeat printString, '.'; cr.	^ s contents! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/2/1999 13:34'!volumeForTrack: trackIndex put: aNumber	| newVol oldLeft oldRight oldFullVol left right |	trackIndex > leftVols size ifTrue: [^ self].	newVol _ ((aNumber asFloat max: 0.0) min: 1.0) * ScaleFactor.	oldLeft _ leftVols at: trackIndex.	oldRight _ rightVols at: trackIndex.	oldFullVol _ oldLeft max: oldRight.	oldFullVol = 0 ifTrue: [oldFullVol _ 1.0].	oldLeft < oldFullVol		ifTrue: [			left _ newVol * oldLeft / oldFullVol.			right _ newVol]		ifFalse: [			left _ newVol.			right _ newVol * oldRight / oldFullVol].	leftVols at: trackIndex put: left asInteger.	rightVols at: trackIndex put: right asInteger.! !"Postscript:Register new FM sounds."AbstractSound updateFMSounds!