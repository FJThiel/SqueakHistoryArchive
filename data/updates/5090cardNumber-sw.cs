'From Squeak3.2 of 18 January 2002 [latest update: #4956] on 4 November 2002 at 9:27:47 pm'!"Change Set:		cardNumber-swDate:			4 November 2002Author:			Scott WallaceAdds the ability to get and set card-numbers when scripting the cards of stacks.Improves the UI for setting the instance-variable order in a stack.Makes the tab-among-fields feature of stacks follow the instance variable order.Preserve the order of existing fields in the instance-variable list when adding or deleting things from the background.In a viewer, show Text types as strings"!!Morph methodsFor: 'card in a stack' stamp: 'sw 11/2/2002 20:17'!reassessBackgroundShape	"A change has been made which may affect the instance structure of the Card uniclass that holds the instance state, which can also be thought of as the 'card data'."	| takenNames uniqueName requestedName  variableDocks docks sepDataMorphs sorted existing name1 name2 |	"Caution: still to be done: the mechanism so that when a new instance variable is added, it gets initialized in all subinstances of the receiver's player, which are the cards of this shape.  One needs to take into account here the instance variable names coming in; those that are unchanged should keep their values, but those that have newly arrived should obtain their default values from the morphs on whose behalf they are being maintained in the model"self isStackBackground ifFalse: [^ self beep].  "bulletproof against deconstruction"Cursor wait showWhile:	[variableDocks _ OrderedCollection new.  "This will be stored in the uniclass's 			class-side inst var #variableDocks"	takenNames _ OrderedCollection new.	sepDataMorphs _ OrderedCollection new.	"fields, holders of per-card data"	self submorphs do: [:aMorph | 		aMorph renderedMorph holdsSeparateDataForEachInstance			ifTrue: [sepDataMorphs add: aMorph renderedMorph]			ifFalse: ["look for buried fields, inside a frame"				aMorph renderedMorph isShared ifTrue: [					aMorph allMorphs do: [:mm |						mm renderedMorph holdsSeparateDataForEachInstance ifTrue: [							sepDataMorphs add: mm renderedMorph]]]]].	sorted _ (SortedCollection new) sortBlock: 				[:a :b | (a valueOfProperty: #cardInstance) ~~ nil].	"puts existing ones first"	sorted addAll: sepDataMorphs.	sorted do: [:aMorph |			docks _ aMorph variableDocks.  	"Each morph can request multiple variables.  	This complicates matters somewhat but creates a generality for Fabrk-like uses.	Each spec is an instance of VariableDock, and it provides a point of departure	for the negotiation between the PasteUp and its constitutent morphs"			docks do:				[:aVariableDock |					uniqueName _ self player uniqueInstanceVariableNameLike: 						(requestedName _ aVariableDock variableName) excluding: takenNames.					uniqueName ~= requestedName ifTrue:						[aVariableDock variableName: uniqueName.						aMorph noteNegotiatedName: uniqueName for: requestedName].					takenNames add: uniqueName].			variableDocks addAll: docks].	existing _ self player class instVarNames.	variableDocks _ (variableDocks asSortedCollection: [:dock1 :dock2 | 			name1 _ dock1 variableName.			name2 _ dock2 variableName.			(existing indexOf: name1 ifAbsent: [0]) < (existing indexOf: name2 ifAbsent: [variableDocks size])]) asOrderedCollection.	self player class setNewInstVarNames: 		(variableDocks collect: [:info | info variableName asString]).		"NB: sets up accessors, and removes obsolete ones"	self player class newVariableDocks: variableDocks]! !!Morph methodsFor: 'card in a stack' stamp: 'sw 11/2/2002 20:17'!tabHitWithEvent: anEvent	"The tab key was hit.  The keyboard focus has referred this event to me, though this perhaps seems rather backwards.  Anyway, the assumption is that I have the property #tabAmongFields, so now the task is to tab to the next field."	| currentFocus fieldList anIndex itemToHighlight variableBearingMorphs otherAmenableMorphs |	currentFocus _ anEvent hand keyboardFocus.	fieldList _ self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]].	variableBearingMorphs _ self player class variableDocks collect: [:vd | vd definingMorph] thenSelect: [:m | m isInWorld].	otherAmenableMorphs _ (self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]])			copyWithoutAll: variableBearingMorphs.	fieldList _ variableBearingMorphs, otherAmenableMorphs.	anIndex _ fieldList indexOf: currentFocus ifAbsent: [nil].	itemToHighlight _ fieldList atWrap: 		(anIndex ifNotNil: [anEvent shiftPressed ifTrue: [anIndex - 1] ifFalse: [anIndex + 1]]				ifNil: [1]).	anEvent hand newKeyboardFocus: itemToHighlight. self flag: #arNote. "really???"	itemToHighlight editor selectAll.	itemToHighlight invalidRect: itemToHighlight bounds ! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/4/2002 19:31'!getCardNumber	"Answer the current card number"	| aStack |	^ (aStack _ self stackEmbodied) cardNumberOf: aStack currentCard! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/4/2002 19:32'!setCardNumber: aNumber	"Go to the given card number"	self stackEmbodied goToCardNumber: aNumber! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/4/2002 19:31'!stackEmbodied	"Answer the stack embodied by the receiver's costume; usually this is directly the receiver's costume, but in case it is not, we look up the owner chain for one.  This allows card-number messages to be sent to a *page* of the stack, as Alan is wont to do, and have them still find their way to the right place"	| aMorph |	^ ((aMorph _ self costume renderedMorph) isKindOf: StackMorph)		ifTrue:			[aMorph]		ifFalse:			[aMorph ownerThatIsA: StackMorph]! !!StackMorph methodsFor: 'background' stamp: 'sw 11/2/2002 17:56'!changeInstVarOrder	"Change the order of the receiver's instance variables"	| reply |	reply _ FillInTheBlank request: 'rearrange, then accept; or cancel' initialAnswer:		((self currentPage player class instVarNames asArray collect: [:v | v asSymbol]) storeString copyWithoutAll: #($# $( $))) asString.	reply isEmptyOrNil ifTrue: [^ self].	self flag: #deferred.  "Error checking and graceful escape wanted"	self currentPage player class resortInstanceVariables: (Compiler evaluate:		('#(', reply, ')'))! !!StackMorph methodsFor: 'card access' stamp: 'sw 11/2/2002 19:48'!goToCardNumber: aCardNumber	"Install the card whose ordinal number is provided as the current card in the stack"	self goToCard: (cards atWrap: aCardNumber)! !!StackMorph methodsFor: 'accessing' stamp: 'sw 11/2/2002 15:51'!cardNumberOf: aPlayer	"Answer the card-number of the given player, in the which-card-of-the-stack sense."	^ self cards identityIndexOf: aPlayer ifAbsent: [0]! !!StackMorph class methodsFor: 'viewer' stamp: 'sw 11/2/2002 15:47'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ # ((#'stack navigation'			((command goToNextCardInStack 'Go to the next card')			(command goToPreviousCardInStack  'Go to the previous card')			(command goToFirstCardInBackground 'Go to the first card of the current background')			(command goToFirstCardOfStack 'Go to the first card of the entire stack')			(command goToLastCardInBackground 'Go to the last card of the current background')			(command goToLastCardOfStack 'Go to the last card of the entire stack')			(command deleteCard 'Delete the current card')			(command insertCard 'Create a new card')			(slot cardNumber 'The ordinal number of the current card' Number readWrite Player getCardNumber Player setCardNumber:))))! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 11/4/2002 21:06'!readFromTarget	"Update my readout from my target"	| v |	((target == nil) or: [getSelector == nil]) ifTrue: [^ contents].	self checkTarget.	v _ target "scriptPerformer" perform: getSelector.	(v isKindOf: Text) ifTrue: [v _ v asString].	^ self acceptValueFromTarget: v! !!VariableDock methodsFor: 'accessing' stamp: 'sw 11/2/2002 18:09'!definingMorph	"Answer the defining morph"	^ definingMorph! !