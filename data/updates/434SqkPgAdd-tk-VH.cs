'From Squeak 2.2 of Sept 23, 1998 on 23 November 1998 at 5:38:15 pm'!!BookMorph methodsFor: 'navigation' stamp: 'tk 11/23/1998 14:49'!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending newPage |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	oldPageNumber _ self pageNumberOf: currentPage.	oldPageNumber = 0 ifTrue: [oldPageNumber _ nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue:				[nil]			ifFalse:				[oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	self currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		currentPage fullReleaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	self snapToEdgeIfAppropriate.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["Nil at init time, for example" aWorld displayWorld].! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/23/1998 15:01'!previousPage	| ii |	ii _ (self pageNumberOf: currentPage) - 1.	ii = 0 ifTrue: [ii _ pages size].	self goToPage: ii.! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/23/1998 15:03'!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	subMenu add: 'send other pages to server' action: #savePagesOnURL.	aMenu add: 'book...' subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/23/1998 16:31'!savePagesOnURL	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are already totally out will stay that way."	| response curr pg |	response _ (PopUpMenu labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)' withCRs)			startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' withCRs.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 0 ifTrue: [^ self].curr _ currentPage.pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		self goToPageMorph: aPage.		aPage saveOnURLbasic.	"ask user if no url"		]].self goToPageMorph: curr.pages do: [:aPage |	"does write the current page too"	(aPage isInMemory and: [(curr == aPage) not]) ifTrue: [		pg _ aPage valueOfProperty: #SqueakPage.		pg purge]].	"recover the space"! !!FileUrl methodsFor: 'access' stamp: 'tk 11/23/1998 17:17'!pathForDirectory	"Path using local file system's delimiter.  $\ or $:"	^ String streamContents: [ :s |		1 to: self path size - 1 do: [ :ii |			s nextPutAll: (path at: ii); nextPut: FileDirectory default pathNameDelimiter			 ] ]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'tk 11/23/1998 15:09'!addPlayfieldMenuItems: menu hand: aHandMorph	| subMenu prefix hasPalette |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'save as SqueakPage at url...' action: #saveOnURL.	subMenu add: 'navigate to...' action: #navigateTo.	subMenu add: 'round up strays' action: #roundUpStrays.	subMenu addLine.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	prefix _ (self hasProperty: #automaticPhraseExpansion) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'phrase expansion') action: #toggleAutomaticPhraseExpansion.	prefix _ (self hasProperty: #alwaysShowThumbnail) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'showing thumbnails') action: #toggleAlwaysShowThumbnail.	(self hasProperty: #alwaysShowThumbnail) ifTrue:		[subMenu add: 'set thumbnail height...' action: #setThumbnailHeight].	(hasPalette _ self standardPalette ~~ nil) ifTrue:		[prefix _ self automaticViewing ifTrue: ['stop '] ifFalse: ['start '].		subMenu add: (prefix, 'automatic viewing') action: #toggleAutomaticViewing].	subMenu addLine.	hasPalette ifTrue: [subMenu add: 'clear palette area' action: #clearPaletteArea].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	presenter ifNil:		[subMenu add: 'make detachable' action: #makeDetachable].	subMenu addLine.	subMenu add: 'use standard texture' action: #setStandardTexture.	subMenu add: 'make graph paper...' action: #makeGraphPaper.	subMenu addTitle: 'Playfield options'.	menu add: 'playfield options...' subMenu: subMenu.! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 11/23/1998 17:24'!fileNameRelativeTo: aServerDir	"Produce an absolute fileName from me and an absolute directory"	urlObject isAbsolute ifFalse: [		(aServerDir urlObject ~~ nil and: [aServerDir urlObject isAbsolute]) 			ifTrue: [urlObject 				privateInitializeFromText: urlObject pathString 				relativeTo: aServerDir urlObject]			ifFalse: [urlObject default]].	"relative to Squeak directory"	^ urlObject pathForDirectory, self fileName! !!SqueakPage methodsFor: 'private' stamp: 'tk 11/23/1998 17:31'!postChangeNotification	"Inform all thumbnails and books that this page has been updated."	URLMorph allInstancesDo: [:m | m pageHasChanged: self].! !!SqueakPage methodsFor: 'saving' stamp: 'tk 11/23/1998 16:51'!write	"Decide whether to write this page on the disk."	| sf remoteFile |	policy == #neverWrite ifTrue: [^ self].		"demo mode, or write only when user explicitly orders it"	"All other policies do write:   #now"	contentsMorph ifNil: [^ self].	dirty _ dirty | ((contentsMorph valueOfProperty: #pageDirty) == true).		"set by layoutChanged"	dirty == true ifTrue: [ 		sf _ ServerDirectory new fullPath: url.		"check for shared password"		"contentsMorph allMorphsDo: [:m | m prepareToBeSaved].				done in objectToStoreOnDataStream"		Cursor wait showWhile: [			remoteFile _ sf newFileNamed: url.			remoteFile fileOutClass: nil andObject: self.			remoteFile close].		contentsMorph setProperty: #pageDirty toValue: nil.		dirty _ false].! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'tk 11/23/1998 17:34'!deleteUnreferencedPages	"Remove any pages that are not current referred to by any book or URL morph."	"Details: Since unreferenced pages could refer to other pages, this process is iterated until no unreferenced pages can be found. It currently does not collect cycles."	"SqueakPageCache deleteUnreferencedPages"	| unreferenced |	[true] whileTrue: [		Smalltalk garbageCollect.		unreferenced _ PageCache keys.		URLMorph allInstancesDo: [:m | unreferenced remove: m url ifAbsent: []].		MorphObjectOut allInstancesDo: [:ticklish |			unreferenced remove: ticklish xxxUrl ifAbsent: []].		unreferenced size = 0 ifTrue: [^ self].		unreferenced do: [:url | PageCache removeKey: url ifAbsent: []]].! !!URLMorph methodsFor: 'event handling' stamp: 'tk 11/23/1998 17:36'!mouseUp: evt	| pg ow newPage mm |	"If inside a SqueakPage, replace it!!"	pg _ self enclosingPage.	pg ifNotNil: [		(ow _ pg contentsMorph owner) ifNotNil: [			pg contentsMorph delete.	"from its owner"			newPage _ SqueakPageCache atURL: url.			mm _ newPage fetchContents.			mm ifNotNil: [ow addMorph: mm.				page _ newPage].			^ self]].	"If I am a project, jump  -- not done yet"	"For now, just put new page on the hand"	newPage _ SqueakPageCache atURL: url.	mm _ newPage fetchInformIfError.	mm ifNotNil: [self primaryHand attachMorph: mm.		page _ newPage].! !!URLMorph methodsFor: 'private' stamp: 'tk 11/23/1998 17:37'!enclosingBook	"rethink this since class WebBookMorph is gone"! !Smalltalk removeClassNamed: #WebBookMorph!