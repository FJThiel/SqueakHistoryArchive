'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5623] on 28 January 2004 at 3:59:19 pm'!"Change Set:		KCP-0160-SystemChangeNotifDate:			28 January 2004Author:			Roel Wuyts & Nathanael SchaerliNew version of the system change notification framework. Working with image v5623."!Object subclass: #AbstractEvent	instanceVariableNames: 'item itemKind environment'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!AbstractEvent subclass: #AddedEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!AbstractEvent subclass: #CommentedEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!AbstractEvent subclass: #DoItEvent	instanceVariableNames: 'context'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!AbstractEvent subclass: #ModifiedEvent	instanceVariableNames: 'oldItem'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!ModifiedEvent subclass: #ModifiedClassDefinitionEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!AbstractEvent subclass: #RecategorizedEvent	instanceVariableNames: 'oldCategory'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!AbstractEvent subclass: #RemovedEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!AbstractEvent subclass: #RenamedEvent	instanceVariableNames: 'newName oldName'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Smalltalk renameClassNamed: #ReorganizedClassEvent as: #ReorganizedEvent!AbstractEvent subclass: #ReorganizedEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!Object subclass: #SystemChangeNotifier	instanceVariableNames: 'eventSource silenceLevel'	classVariableNames: 'UniqueInstance'	poolDictionaries: ''	category: 'System-Change Notification'!EventManager subclass: #SystemEventManager	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!WeakActionSequence variableSubclass: #WeakActionSequenceTrappingErrors	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Change Notification'!!Object methodsFor: 'converting' stamp: 'rw 7/20/2003 16:03'!asActionSequenceTrappingErrors	^WeakActionSequenceTrappingErrors with: self! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:10'!changeKind	^self class changeKind! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:43'!environmentAt: anItemKind	(self itemKind = anItemKind) ifTrue: [^self item].	^environment at: anItemKind ifAbsent: [nil]! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:20'!eventSelector	^self class eventSelectorBlock value: itemKind value: self changeKind! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:36'!item: anItem kind: anItemKind	item := anItem.	itemKind := anItemKind.	environment := Dictionary new! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:37'!itemCategory: aCategory	environment at: self class categoryKind put: aCategory! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:36'!itemClass: aClass	environment at: self class classKind put: aClass! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/14/2003 12:11'!itemExpression: anExpression	environment at: self class expressionKind put: anExpression! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:38'!itemMethod: aMethod	environment at: self class methodKind put: aMethod! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'rw 7/10/2003 12:38'!itemProtocol: aProtocol	environment at: self class protocolKind put: aProtocol! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'NS 1/27/2004 10:38'!itemRequestor: requestor	environment at: #requestor put: requestor! !!AbstractEvent methodsFor: 'private-accessing' stamp: 'NS 1/27/2004 10:39'!itemSelector: aSymbol	environment at: #selector put: aSymbol! !!AbstractEvent methodsFor: 'accessing' stamp: 'rw 6/30/2003 08:22'!item	"Return the item that triggered the event (typically the name of a class, a category, a protocol, a method)."	^item! !!AbstractEvent methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:43'!itemCategory	^self environmentAt: self class categoryKind! !!AbstractEvent methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:43'!itemClass	^self environmentAt: self class classKind! !!AbstractEvent methodsFor: 'accessing' stamp: 'rw 7/14/2003 12:10'!itemExpression	^self environmentAt: self class expressionKind! !!AbstractEvent methodsFor: 'accessing' stamp: 'rw 6/30/2003 08:22'!itemKind	"Return the kind of the item of the event (#category, #class, #protocol, #method, ...)"	^itemKind! !!AbstractEvent methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:44'!itemMethod	^self environmentAt: self class methodKind! !!AbstractEvent methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:44'!itemProtocol	^self environmentAt: self class protocolKind! !!AbstractEvent methodsFor: 'accessing' stamp: 'NS 1/27/2004 10:38'!itemRequestor	^self environmentAt: #requestor! !!AbstractEvent methodsFor: 'accessing' stamp: 'NS 1/27/2004 10:38'!itemSelector	^self environmentAt: #selector! !!AbstractEvent methodsFor: 'printing' stamp: 'NS 1/19/2004 17:52'!printOn: aStream	self printEventKindOn: aStream.	aStream		nextPutAll: ' Event for item: ';		print: self item;		nextPutAll: ' of kind: ';		print: self itemKind! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 6/30/2003 08:34'!isAdded	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'NS 1/19/2004 18:41'!isCategoryKnown	^self itemCategory notNil! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 7/10/2003 15:01'!isCommented	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 7/14/2003 10:15'!isDoIt	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'NS 1/19/2004 15:09'!isModified	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'NS 1/21/2004 09:40'!isProtocolKnown	^self itemCategory notNil! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 7/1/2003 19:53'!isRecategorized	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 6/30/2003 08:34'!isRemoved	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'rw 7/1/2003 11:35'!isRenamed	^false! !!AbstractEvent methodsFor: 'testing' stamp: 'NS 1/27/2004 12:44'!isReorganized	^ false! !!AbstractEvent methodsFor: 'triggering' stamp: 'rw 7/14/2003 17:06'!trigger: anEventManager 	"Trigger the event manager."	anEventManager triggerEvent: self eventSelector with: self.! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/19/2004 18:42'!class: aClass	^ self item: aClass kind: AbstractEvent classKind.! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/19/2004 18:42'!class: aClass category: cat 	| instance |	instance := self class: aClass.	instance itemCategory: cat.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'rw 7/9/2003 11:19'!item: anItem kind: anItemKind	^self basicNew item: anItem kind: anItemKind! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/16/2004 14:19'!method: aMethod class: aClass	| instance |	instance := self item: aMethod kind: self methodKind.	instance itemClass: aClass.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/16/2004 14:20'!method: aMethod protocol: prot class: aClass	| instance |	instance := self method: aMethod class: aClass.	instance itemProtocol: prot.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 10:48'!method: aMethod selector: aSymbol class: aClass	| instance |	instance := self item: aMethod kind: self methodKind.	instance itemSelector: aSymbol.	instance itemClass: aClass.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 10:49'!method: aMethod selector: aSymbol class: aClass requestor: requestor	| instance |	instance := self method: aMethod selector: aSymbol class: aClass.	instance itemRequestor: requestor.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 10:49'!method: aMethod selector: aSymbol protocol: prot class: aClass	| instance |	instance := self method: aMethod selector: aSymbol class: aClass.	instance itemProtocol: prot.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 10:50'!method: aMethod selector: aSymbol protocol: prot class: aClass requestor: requestor	| instance |	instance := self method: aMethod selector: aSymbol protocol: prot class: aClass.	instance itemRequestor: requestor.	^instance! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'rw 6/30/2003 09:20'!new	"Override new to trigger an error, since we want to use specialized methods to create basic and higher-level events."	^self error: 'Instances can only be created using specialized instance creation methods.'! !!AbstractEvent class methodsFor: 'accessing' stamp: 'NS 1/16/2004 14:08'!allChangeKinds	"AbstractEvent allChangeKinds"	^AbstractEvent allSubclasses collect: [:cl | cl changeKind]! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/29/2003 15:14'!allItemKinds	"SystemEvent allItemKinds"	^(AbstractEvent class organization listAtCategoryNamed: #'item kinds') 		collect: [:sel | self perform: sel]! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:08'!changeKind	"Return a symbol, with a : as last character, identifying the change kind."	self subclassResponsibility! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:18'!eventSelectorBlock	^[:itemKind :changeKind | itemKind, changeKind, 'Event:']! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:19'!itemChangeCombinations	^self supportedKinds collect: [:itemKind | self eventSelectorBlock value: itemKind value: self changeKind]! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:04'!supportedKinds	"All the kinds of items that this event can take. By default this is all the kinds in the system. But subclasses can override this to limit the choices. For example, the SuperChangedEvent only works with classes, and not with methods, instance variables, ..."	^self allItemKinds! !!AbstractEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 11:39'!systemEvents	"Return all the possible events in the system. Make a cross product of 	the items and the change types."	"self systemEvents"	^self allSubclasses		inject: OrderedCollection new		into: [:allEvents :eventClass | allEvents addAll: eventClass itemChangeCombinations; yourself]! !!AbstractEvent class methodsFor: 'item kinds' stamp: 'rw 7/9/2003 11:12'!categoryKind	^#category! !!AbstractEvent class methodsFor: 'item kinds' stamp: 'rw 7/9/2003 11:12'!classKind	^#class! !!AbstractEvent class methodsFor: 'item kinds' stamp: 'rw 7/14/2003 11:41'!expressionKind	^#expression! !!AbstractEvent class methodsFor: 'item kinds' stamp: 'rw 7/9/2003 11:12'!methodKind	^#method! !!AbstractEvent class methodsFor: 'item kinds' stamp: 'rw 7/10/2003 12:36'!protocolKind	^#protocol! !!AbstractEvent class methodsFor: 'temporary' stamp: 'rw 7/11/2003 10:23'!comment1"Smalltalk organization removeElement: #ClassForTestingSystemChanges3Smalltalk garbageCollect Smalltalk organizaticlassify:under:SystemChangeNotifier uniqueInstance releaseAllSystemChangeNotifier uniqueInstance noMoreNotificationsFor: aDependent.aDependent := SystemChangeNotifierTest new.SystemChangeNotifier uniqueInstance	notifyOfAllSystemChanges: aDependent	using: #event:SystemChangeNotifier uniqueInstance classAdded: #Foo inCategory: #FooCat| eventSource dependentObject |eventSource := EventManager new.dependentObject := Object new.register - dependentObject becomes dependent:eventSource	when: #anEvent send: #error to: dependentObject.unregister dependentObject:eventSource removeDependent: dependentObject.[eventSource triggerEvent: #anEvent]	on: Error	do: [:exc | self halt: 'Should not be!!']."! !!AbstractEvent class methodsFor: 'temporary' stamp: 'rw 7/11/2003 10:24'!comment2"HTTPSocket useProxyServerNamed: 'proxy.telenet.be' port: 8080TestRunner open--------------------We propose two orthogonal groups to categorize each event:(1) the 'change type':	added, removed, modified, renamed	+ the composite 'changed' (see below for an explanation)(2) the 'item type':	class, method, instance variable, pool variable, protocol, category	+ the composite 'any' (see below for an explanation).The list of supported events is the cross product of these two lists (see below for an explicit enumeration of the events).Depending on the change type, certain information related to the change is always present (for adding, the new things that was added, for removals, what was removed, for renaming, the old and the new name, etc.).Depending on the item type, information regarding the item is present (for a method, which class it belongs to). Certain events 'overlap', for example, a method rename triggers a class change. To capture this I impose a hierarchy on the 'item types' (just put some numbers to clearly show the idea. They don't need numbers, really. Items at a certain categories are included by items one category number higher):level 1 categorylevel 2 classlevel 3 instance variable, pool variable, protocol, method.Changes propagate according to this tree: any 'added', 'removed' or 'renamed' change type in level X triggers a 'changed' change type in level X - 1. A 'modified' change type does not trigger anything special.For example, a method additions triggers a class modification. This does not trigger a category modification.Note that we added 'composite events': wildcards for the 'change type' ('any' - any system additions) and for the 'item type' ('Changed' - all changes related to classes), and one for 'any change systemwide' (systemChanged).This result is this list of Events:classAddedclassRemovedclassModifiedclassRenamed (?)classChanged (composite)methodAddedmethodRemovedmethodModifiedmethodRenamed (?)methodChanged (composite)instanceVariableAddedinstanceVariableRemovedinstanceVariableModified instanceVariableRenamed (?)instanceVariableChanged (composite)protocolAddedprotocolRemovedprotocolModifiedprotocolRenamed (?)protocolChanged (composite)poolVariableAddedpoolVariableRemovedpoolVariableModifiedpoolVariableRenamed (?)poolChanged (composite)categoryAddedcategoryRemovedcategoryModifiedcategeryRenamed (?)categoryChanged (composite)anyAdded (composite)anyRemoved (composite)anyModified (composite)anyRenamed (composite)anyChanged (composite)To check: can we pass somehow the 'source' of the change (a browser, a file-in, something else) ? Maybe by checking the context, but should not be too expensive either... I found this useful in some of my tools, but it might be too advanced to have in general. Tools that need this can always write code to check it for them.  But is not always simple...Utilities (for the recent methods) and ChangeSet are the two main clients at this moment.Important: make it very explicit that the event is send synchronously (or asynchronously, would we take that route).					category						class							comment							protocol								methodOR				category				Smalltalk					class						comment						protocol						method??						Smalltalk	category								\	/								class							/	  |	\						comment  |	protocol								  |	/								method"! !!AbstractEvent class methodsFor: 'temporary' stamp: 'rw 7/11/2003 15:43'!comment3"Things to consider for trapping:ClassOrganizer>>#changeFromCategorySpecs:	Problem: I want to trap this to send the appropriate bunch of ReCategorization events, but ClassOrganizer instances do not know where they belong to (what class, or what system); it just uses symbols. So I cannot trigger the change, because not enough information is available. This is a conceptual problem: the organization is stand-alone implementation-wise, while conceptually it belongs to a class. The clean solution could be to reroute this message to a class, but this does not work for all of the senders (that would work from the browserm but not for the file-in).Browser>>#categorizeAllUncategorizedMethods	Problem: should be trapped to send a ReCategorization event. However, this is model code that should not be in the Browser. Clean solution is to move it out of there to the model, and then trap it there (or reroute it to one of the trapped places).Note: Debugger>>#contents:notifying: recompiles methods when needed, so I trapped it to get updates. However, I need to find a way to write a unit test for this. Haven't gotten around yet for doing this though..."! !!AbstractEvent class methodsFor: 'temporary' stamp: 'rw 11/4/2003 14:32'!saveChangeNotificationAsSARFileWithNumber: aNumber 	"Use the SARBuilder package to output the SystemChangeNotification 	stuff as a SAR file. Put this statement here so that I don't forget it 	when moving between images :-)"	"self saveChangeNotificationAsSARFileWithNumber: 6"	| filename changesText readmeText |	filename := 'SystemchangeNotification'.	changesText := '0.6 Version for Squeak 3.7 (no longer for 3.6!!!!) Changed one hook method to make this version work in Squeak3.7. Download version 5 from http://www.iam.unibe.ch/~wuyts/SystemchangeNotification5.sar if you are working with Squeak 3.6.0.5 Updated the safeguard mechanism so that clients with halts and errors do not stop all notifications. Added and updated new tests for this. If this interests you have a look at the class WeakActionSequenceTrappingErrors.0.4 Ported to Squeak 3.6.0.3 Added the hooks for instance variables (addition, removal and renaming). Refactored the tests.0.2 Added hooks and tests for method removal and method recategorization.0.1 First release'.	readmeText :='Implements (part of) the system change notification mechanism. Clients that want to receive notifications about system changes should look at the category #public of the class SystemChangeNotifier, and the unit tests.VERY IMPORTANT: This version is for Squeak 3.7 only. It will not work in Squeak version 3.6. Download and install the last version that worked in Squeak 3.6 (version 5) from the following URL: http://www.iam.unibe.ch/~wuyts/SystemchangeNotification5.sar'.	(SARChangeSetDumper		on: Project current changeSet		including: (ChangeSorter allChangeSetNames				select: [:ea | 'SystemChangeHooks' match: ea])) changesText: changesText;		 readmeText: readmeText;		 fileOutAsZipNamed: filename , aNumber printString , '.sar'! !!ActionSequence methodsFor: 'converting' stamp: 'rw 7/20/2003 16:03'!asActionSequenceTrappingErrors	^WeakActionSequenceTrappingErrors withAll: self! !!AddedEvent methodsFor: 'testing' stamp: 'rw 6/30/2003 08:35'!isAdded	^true! !!AddedEvent methodsFor: 'printing' stamp: 'rw 6/30/2003 09:31'!printEventKindOn: aStream	aStream nextPutAll: 'Added'! !!AddedEvent class methodsFor: 'accessing' stamp: 'rw 7/19/2003 09:52'!changeKind	^#Added! !!AddedEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:22'!supportedKinds	"All the kinds of items that this event can take."		^ Array with: self classKind with: self methodKind with: self categoryKind with: self protocolKind! !!ClassOrganizer methodsFor: 'private' stamp: 'rw 7/31/2003 17:22'!ifClassOrganizerDo: aBlock	aBlock value! !!CommentedEvent methodsFor: 'testing' stamp: 'rw 7/1/2003 11:37'!isCommented	^true! !!CommentedEvent methodsFor: 'printing' stamp: 'rw 7/1/2003 11:37'!printEventKindOn: aStream	aStream nextPutAll: 'Commented'! !!CommentedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:08'!changeKind	^#Commented! !!CommentedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 11:20'!supportedKinds	^Array with: self classKind! !!DoItEvent methodsFor: 'testing' stamp: 'rw 7/14/2003 10:15'!isDoIt	^true! !!DoItEvent methodsFor: 'printing' stamp: 'rw 7/14/2003 10:15'!printEventKindOn: aStream	aStream nextPutAll: 'DoIt'! !!DoItEvent methodsFor: 'accessing' stamp: 'rw 7/14/2003 11:29'!context	^context! !!DoItEvent methodsFor: 'private-accessing' stamp: 'rw 7/14/2003 11:29'!context: aContext	context := aContext! !!DoItEvent class methodsFor: 'accessing' stamp: 'rw 7/14/2003 10:19'!changeKind	^#DoIt! !!DoItEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:23'!supportedKinds	^ Array with: self expressionKind! !!DoItEvent class methodsFor: 'instance creation' stamp: 'NS 1/19/2004 09:47'!expression: stringOrStream context: aContext	| instance |	instance := self item: stringOrStream kind: AbstractEvent expressionKind.	instance context: aContext.	^instance! !!ModifiedEvent methodsFor: 'testing' stamp: 'NS 1/19/2004 15:09'!isModified	^true! !!ModifiedEvent methodsFor: 'printing' stamp: 'NS 1/19/2004 15:10'!printEventKindOn: aStream	aStream nextPutAll: 'Modified'! !!ModifiedEvent methodsFor: 'printing' stamp: 'NS 1/19/2004 17:57'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' oldItem: ';		print: oldItem.! !!ModifiedEvent methodsFor: 'accessing' stamp: 'NS 1/19/2004 15:08'!oldItem	^ oldItem! !!ModifiedEvent methodsFor: 'private-accessing' stamp: 'NS 1/19/2004 15:08'!oldItem: anItem	oldItem _ anItem! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:30'!classVarNames	^ item classVarNames asSet! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:29'!instVarNames	^ item instVarNames asSet! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:30'!oldClassVarNames	^ oldItem classVarNames asSet! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:29'!oldInstVarNames	^ oldItem instVarNames asSet! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:31'!oldSharedPools	^ oldItem sharedPools! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:28'!oldSuperclass	^ oldItem superclass! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:31'!sharedPools	^ item sharedPools! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'NS 1/20/2004 19:28'!superclass	^ item superclass! !!ModifiedClassDefinitionEvent methodsFor: 'testing' stamp: 'NS 1/26/2004 09:33'!anyChanges	^ self isSuperclassModified or: [self areInstVarsModified or: [self areClassVarsModified or: [self areSharedPoolsModified]]]! !!ModifiedClassDefinitionEvent methodsFor: 'testing' stamp: 'NS 1/20/2004 19:31'!areClassVarsModified	^ self classVarNames ~= self oldClassVarNames! !!ModifiedClassDefinitionEvent methodsFor: 'testing' stamp: 'NS 1/20/2004 19:30'!areInstVarsModified	^ self instVarNames ~= self oldInstVarNames! !!ModifiedClassDefinitionEvent methodsFor: 'testing' stamp: 'NS 1/20/2004 19:32'!areSharedPoolsModified	^ self sharedPools ~= self oldSharedPools! !!ModifiedClassDefinitionEvent methodsFor: 'testing' stamp: 'NS 1/20/2004 19:29'!isSuperclassModified	^ item superclass ~~ oldItem superclass! !!ModifiedClassDefinitionEvent methodsFor: 'printing' stamp: 'NS 1/21/2004 09:25'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' Super: ';		print: self isSuperclassModified;		nextPutAll: ' InstVars: ';		print: self areInstVarsModified;		nextPutAll: ' ClassVars: ';		print: self areClassVarsModified;		nextPutAll: ' SharedPools: ';		print: self areSharedPoolsModified.! !!ModifiedEvent class methodsFor: 'accessing' stamp: 'NS 1/19/2004 15:10'!changeKind	^#Modified! !!ModifiedEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:25'!supportedKinds	"All the kinds of items that this event can take."		^ Array with: self classKind with: self methodKind with: self categoryKind with: self protocolKind! !!ModifiedEvent class methodsFor: 'instance creation' stamp: 'NS 1/20/2004 19:37'!classDefinitionChangedFrom: oldClass to: newClass	^ ModifiedClassDefinitionEvent classDefinitionChangedFrom: oldClass to: newClass! !!ModifiedEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 11:40'!methodChangedFrom: oldMethod to: newMethod selector: aSymbol inClass: aClass	| instance |	instance := self method: newMethod selector: aSymbol class: aClass.	instance oldItem: oldMethod.	^ instance! !!ModifiedEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 11:40'!methodChangedFrom: oldMethod to: newMethod selector: aSymbol inClass: aClass requestor: requestor	| instance |	instance := self method: newMethod selector: aSymbol class: aClass requestor: requestor.	instance oldItem: oldMethod.	^ instance! !!ModifiedClassDefinitionEvent class methodsFor: 'instance creation' stamp: 'NS 1/20/2004 11:52'!classDefinitionChangedFrom: oldClass to: newClass	| instance |	instance := self item: newClass kind: self classKind.	instance oldItem: oldClass.	^instance! !!ModifiedClassDefinitionEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:26'!supportedKinds	"All the kinds of items that this event can take."		^ Array with: self classKind! !!PseudoClassOrganizer methodsFor: 'private' stamp: 'rw 7/31/2003 17:23'!ifClassOrganizerDo: aBlock	"Do nothing, since this is not a class organizer"! !!RecategorizedEvent methodsFor: 'testing' stamp: 'rw 7/1/2003 19:51'!isRecategorized	^true! !!RecategorizedEvent methodsFor: 'printing' stamp: 'rw 7/2/2003 09:12'!printEventKindOn: aStream	aStream nextPutAll: 'Recategorized'! !!RecategorizedEvent methodsFor: 'accessing' stamp: 'rw 7/1/2003 20:08'!oldCategory	^oldCategory! !!RecategorizedEvent methodsFor: 'accessing' stamp: 'rw 7/1/2003 20:08'!oldCategory: aCategoryName	oldCategory := aCategoryName! !!RecategorizedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:09'!changeKind	^#Recategorized! !!RecategorizedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 11:20'!supportedKinds	^Array with: self classKind with: self methodKind! !!RecategorizedEvent class methodsFor: 'instance creation' stamp: 'rw 7/9/2003 14:21'!class: aClass category: cat oldCategory: oldName	^(self class: aClass category: cat) oldCategory: oldName! !!RecategorizedEvent class methodsFor: 'instance creation' stamp: 'rw 7/31/2003 16:35'!method: aMethod protocol: prot class: aClass oldProtocol: oldName	^(self method: aMethod protocol: prot class: aClass) oldCategory: oldName! !!RemovedEvent methodsFor: 'testing' stamp: 'rw 6/30/2003 08:35'!isRemoved	^true! !!RemovedEvent methodsFor: 'printing' stamp: 'rw 6/30/2003 09:31'!printEventKindOn: aStream	aStream nextPutAll: 'Removed'! !!RemovedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:09'!changeKind	^#Removed! !!RemovedEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:28'!supportedKinds	"All the kinds of items that this event can take."		^ Array with: self classKind with: self methodKind with: self categoryKind with: self protocolKind! !!RenamedEvent methodsFor: 'printing' stamp: 'rw 7/1/2003 11:34'!printEventKindOn: aStream	aStream nextPutAll: 'Renamed'! !!RenamedEvent methodsFor: 'testing' stamp: 'rw 7/1/2003 11:34'!isRenamed	^true! !!RenamedEvent methodsFor: 'accessing' stamp: 'NS 1/27/2004 12:18'!newName	^ newName! !!RenamedEvent methodsFor: 'accessing' stamp: 'NS 1/27/2004 12:18'!newName: aName	newName := aName! !!RenamedEvent methodsFor: 'accessing' stamp: 'rw 7/1/2003 12:00'!oldName	^oldName! !!RenamedEvent methodsFor: 'accessing' stamp: 'rw 7/1/2003 12:01'!oldName: aName	oldName := aName! !!RenamedEvent class methodsFor: 'accessing' stamp: 'rw 7/10/2003 12:09'!changeKind	^#Renamed! !!RenamedEvent class methodsFor: 'accessing' stamp: 'NS 1/20/2004 12:30'!supportedKinds	"All the kinds of items that this event can take."		^ Array with: self classKind with: self categoryKind with: self protocolKind! !!RenamedEvent class methodsFor: 'instance creation' stamp: 'NS 1/27/2004 12:19'!class: aClass category: cat oldName: oldName newName: newName	^(self class: aClass category: cat) oldName: oldName; newName: newName! !!ReorganizedEvent methodsFor: 'testing' stamp: 'NS 1/27/2004 12:44'!isReorganized	^ true! !!ReorganizedEvent methodsFor: 'printing' stamp: 'NS 1/27/2004 12:44'!printEventKindOn: aStream	aStream nextPutAll: 'Reorganized'! !!ReorganizedEvent class methodsFor: 'accessing' stamp: 'NS 1/27/2004 12:46'!changeKind	^#Reorganized! !!ReorganizedEvent class methodsFor: 'accessing' stamp: 'NS 1/27/2004 12:46'!supportedKinds	^Array with: self classKind! !!SystemChangeNotifier methodsFor: 'initialize' stamp: 'NS 1/26/2004 20:41'!initialize	eventSource := SystemEventManager new.	silenceLevel _ 0.! !!SystemChangeNotifier methodsFor: 'private' stamp: 'rw 7/10/2003 15:15'!notify: anObject ofEvents: eventsCollection using: oneArgumentSelector	"Notifies an object of any events in the eventsCollection. Send it back a message #oneArgumentSelector, with as argument the particular system event instance."	eventsCollection do: [:eachEvent |		eventSource when: eachEvent send: oneArgumentSelector to: anObject]! !!SystemChangeNotifier methodsFor: 'private' stamp: 'rw 7/29/2003 17:05'!releaseAll	"Release all the dependents so that nobody receives notifications anymore."	"Done for cleaning up the system."	"self uniqueInstance releaseAll"	eventSource releaseActionMap! !!SystemChangeNotifier methodsFor: 'private' stamp: 'NS 1/26/2004 20:43'!setBroadcasting	silenceLevel := 0.! !!SystemChangeNotifier methodsFor: 'private' stamp: 'NS 1/26/2004 20:41'!trigger: event	self isBroadcasting ifTrue: [event trigger: eventSource]"	| caughtExceptions |	caughtExceptions := OrderedCollection new.	self isBroadcasting ifTrue: [		[(eventSource actionForEvent: event eventSelector) valueWithArguments: (Array with: event)] on: Exception do: [:exc | caughtExceptions add: exc]].	caughtExceptions do: [:exc | exc resignalAs: exc class new]"! !!SystemChangeNotifier methodsFor: 'private-event lists' stamp: 'rw 7/29/2003 15:14'!allSystemEvents	^AbstractEvent systemEvents! !!SystemChangeNotifier methodsFor: 'private-event lists' stamp: 'rw 7/29/2003 15:14'!systemEventsForChange: changeKind 	| selectorBlock |	selectorBlock := AbstractEvent eventSelectorBlock.	^AbstractEvent allItemKinds 		collect: [:itemKind | selectorBlock value: itemKind value: changeKind]! !!SystemChangeNotifier methodsFor: 'private-event lists' stamp: 'rw 7/29/2003 15:14'!systemEventsForItem: itemKind 	| selectorBlock |	selectorBlock := AbstractEvent eventSelectorBlock.	^AbstractEvent allChangeKinds 		collect: [:changeKind | selectorBlock value: itemKind value: changeKind]! !!SystemChangeNotifier methodsFor: 'private-event lists' stamp: 'rw 7/29/2003 15:14'!systemEventsForItem: itemKind change: changeKind 	^AbstractEvent eventSelectorBlock value: itemKind value: changeKind! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'rw 7/29/2003 15:12'!class: aClass recategorizedFrom: oldCategory to: newCategory 	self trigger: (RecategorizedEvent 				class: aClass				category: newCategory				oldCategory: oldCategory)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'rw 7/29/2003 15:11'!classAdded: aClass inCategory: aCategoryName 	self trigger: (AddedEvent class: aClass category: aCategoryName)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/26/2004 09:37'!classCommented: aClass	"A class with the given name was commented in the system."	self trigger: (CommentedEvent class: aClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'rw 7/29/2003 15:11'!classCommented: aClass inCategory: aCategoryName 	"A class with the given name was commented in the system."	self trigger: (CommentedEvent class: aClass category: aCategoryName)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/20/2004 19:37'!classDefinitionChangedFrom: oldClass to: newClass	self trigger: (ModifiedClassDefinitionEvent classDefinitionChangedFrom: oldClass to: newClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/16/2004 15:10'!classRemoved: aClass fromCategory: aCategoryName 	self trigger: (RemovedEvent class: aClass category: aCategoryName)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 12:19'!classRenamed: aClass from: oldClassName to: newClassName inCategory: aCategoryName 	self trigger: (RenamedEvent 				class: aClass				category: aCategoryName				oldName: oldClassName				newName: newClassName)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 12:48'!classReorganized: aClass	self trigger: (ReorganizedEvent class: aClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/19/2004 09:48'!evaluated: textOrStream	^ self evaluated: textOrStream context: nil.! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/19/2004 09:47'!evaluated: expression context: aContext	self trigger: (DoItEvent 				expression: expression				context: aContext)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 11:24'!methodAdded: aMethod selector: aSymbol inClass: aClass 	"A method with the given selector was added to aClass, but not put in a protocol."	self trigger: (AddedEvent				method: aMethod 				selector: aSymbol				class: aClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 11:24'!methodAdded: aMethod selector: aSymbol inClass: aClass requestor: requestor	"A method with the given selector was added to aClass, but not put in a protocol."	self trigger: (AddedEvent				method: aMethod 				selector: aSymbol				class: aClass				requestor: requestor)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 11:24'!methodAdded: aMethod selector: aSymbol inProtocol: aCategoryName class: aClass 	"A method with the given selector was added to aClass in protocol aCategoryName."	self trigger: (AddedEvent				method: aMethod				selector: aSymbol				protocol: aCategoryName				class: aClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 11:24'!methodAdded: aMethod selector: aSymbol inProtocol: aCategoryName class: aClass requestor: requestor	"A method with the given selector was added to aClass in protocol aCategoryName."	self trigger: (AddedEvent				method: aMethod				selector: aSymbol				protocol: aCategoryName				class: aClass				requestor: requestor)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 11:41'!methodChangedFrom: oldMethod to: newMethod selector: aSymbol inClass: aClass	self trigger: (ModifiedEvent					methodChangedFrom: oldMethod					to: newMethod					selector: aSymbol 					inClass: aClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 11:41'!methodChangedFrom: oldMethod to: newMethod selector: aSymbol inClass: aClass requestor: requestor	self trigger: (ModifiedEvent					methodChangedFrom: oldMethod					to: newMethod					selector: aSymbol 					inClass: aClass					requestor: requestor)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/28/2004 11:12'!methodRemoved: aMethod selector: aSymbol class: aClass 	"A method with the given selector was removed from the class."	self trigger: (RemovedEvent				method: aMethod 				selector: aSymbol				class: aClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/28/2004 11:11'!methodRemoved: aMethod selector: aSymbol inProtocol: protocol class: aClass 	"A method with the given selector was removed from the class."	self trigger: (RemovedEvent				method: aMethod 				selector: aSymbol				protocol: protocol				class: aClass)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'NS 1/27/2004 12:06'!selector: selector recategorizedFrom: oldCategory to: newCategory inClass: aClass	self trigger: (RecategorizedEvent 				method: aClass >> selector				protocol: newCategory				class: aClass				oldProtocol: oldCategory)! !!SystemChangeNotifier methodsFor: 'public' stamp: 'NS 1/28/2004 11:29'!doSilently: aBlock	"Perform the block, and ensure that no system notification are broadcasted while doing so."	| result |	silenceLevel := silenceLevel + 1.	[result := aBlock value] ensure: [silenceLevel > 0 ifTrue: [silenceLevel := silenceLevel - 1]].	^ result.! !!SystemChangeNotifier methodsFor: 'public' stamp: 'NS 1/26/2004 20:41'!isBroadcasting	^ silenceLevel = 0! !!SystemChangeNotifier methodsFor: 'public' stamp: 'rw 7/29/2003 17:01'!noMoreNotificationsFor: anObject	"Stop sending system notifications to an object."	eventSource removeActionsWithReceiver: anObject! !!SystemChangeNotifier methodsFor: 'public' stamp: 'rw 7/10/2003 12:00'!notify: anObject ofAllSystemChangesUsing: oneArgumentSelector 	"Notifies an object of any system changes."	self 		notify: anObject		ofEvents: self allSystemEvents		using: oneArgumentSelector! !!SystemChangeNotifier methodsFor: 'public' stamp: 'rw 7/10/2003 12:26'!notify: anObject ofSystemChangesOfChange: changeKind using: oneArgumentSelector 	"Notifies an object of system changes of the specified changeKind (#added, #removed, ...). Evaluate 'SystemEvent allChangeKinds' to get the complete list."	self 		notify: anObject		ofEvents: (self systemEventsForChange: changeKind)		using: oneArgumentSelector! !!SystemChangeNotifier methodsFor: 'public' stamp: 'rw 7/20/2003 17:06'!notify: anObject ofSystemChangesOfItem: itemKind change: changeKind using: oneArgumentSelector 	"Notifies an object of system changes of the specified itemKind (#class, #category, ...) and changeKind (#added, #removed, ...). This is the finest granularity possible.	Evaluate 'SystemEvent allChangeKinds' to get the complete list of change kinds, and 'SystemEvent allItemKinds to get all the possible item kinds supported."	self 		notify: anObject		ofEvents: (Bag with: (self systemEventsForItem: itemKind change: changeKind))		using: oneArgumentSelector! !!SystemChangeNotifier methodsFor: 'public' stamp: 'rw 7/10/2003 12:03'!notify: anObject ofSystemChangesOfItem: itemKind  using: oneArgumentSelector 	"Notifies an object of system changes of the specified itemKind (#class, #method, #protocol, ...). Evaluate 'SystemEvent allItemKinds' to get the complete list."	self 		notify: anObject		ofEvents: (self systemEventsForItem: itemKind)		using: oneArgumentSelector! !!SystemChangeNotifier class methodsFor: 'instance creation' stamp: 'rw 6/28/2003 09:41'!new	^self error: self instanceCreationErrorString! !!SystemChangeNotifier class methodsFor: 'private' stamp: 'NS 1/27/2004 16:23'!createInstance	^self basicNew initialize! !!SystemChangeNotifier class methodsFor: 'private' stamp: 'rw 6/28/2003 09:41'!instanceCreationErrorString	^'This is a singleton implementation, so you are not allowed to create instances yourself. Use #uniqueInstance to access the instance.'! !!SystemChangeNotifier class methodsFor: 'private' stamp: 'rw 7/11/2003 14:36'!resetUniqueInstance	"self resetUniqueInstance"	UniqueInstance		ifNotNilDo: [:u | UniqueInstance releaseAll.			UniqueInstance _ nil]! !!SystemChangeNotifier class methodsFor: 'public' stamp: 'NS 1/27/2004 16:23'!uniqueInstance	UniqueInstance ifNil: [UniqueInstance := self createInstance].	^UniqueInstance! !!SystemChangeNotifier class methodsFor: 'item kinds' stamp: 'NS 1/21/2004 09:31'!categoryKind	^ AbstractEvent categoryKind! !!SystemChangeNotifier class methodsFor: 'item kinds' stamp: 'NS 1/21/2004 09:31'!classKind	^ AbstractEvent classKind! !!SystemChangeNotifier class methodsFor: 'item kinds' stamp: 'NS 1/21/2004 09:32'!expressionKind	^ AbstractEvent expressionKind! !!SystemChangeNotifier class methodsFor: 'item kinds' stamp: 'NS 1/21/2004 09:31'!methodKind	^ AbstractEvent methodKind! !!SystemChangeNotifier class methodsFor: 'item kinds' stamp: 'NS 1/21/2004 09:32'!protocolKind	^ AbstractEvent protocolKind! !!SystemEventManager methodsFor: 'events-accessing' stamp: 'rw 7/20/2003 17:02'!actionSequenceForEvent: anEventSelector    ^(self actionMap        at: anEventSelector asSymbol        ifAbsent: [^WeakActionSequenceTrappingErrors new])            asActionSequenceTrappingErrors! !!SystemOrganizer methodsFor: 'private' stamp: 'rw 7/31/2003 17:23'!ifClassOrganizerDo: aBlock	"Do nothing, since this is not a class organizer"! !!WeakActionSequence methodsFor: 'converting' stamp: 'rw 7/20/2003 16:03'!asActionSequenceTrappingErrors	^WeakActionSequenceTrappingErrors withAll: self! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'rw 8/6/2003 12:09'!value	"Do the same as my parent, but make sure that all actions that do not  	give errors are evaluated before resignaling the ones that gave errors  	(giving the chance to clients to handle them)."	^self valueStartingFrom: 1! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'rw 8/6/2003 12:12'!valueStartingFrom: startIndex	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	"Note: I currently trap Halt,Exception so that I am sure to get a Halt event in case of a Halt. This is being fixed in the exception system - when the fix is done it will be enough to capture only Exception."	| each answer |	startIndex to: self size do: [:index |		each := self at: index.		each isReceiverOrAnyArgumentGarbage ifFalse: [			[answer _ each value]				on: Halt, Exception				do: [:exc | 						self valueStartingFrom: index + 1.						exc pass]]].	^ answer! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'rw 8/6/2003 12:07'!valueWithArguments: anArray 	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	^self valueWithArguments: anArray startingFrom: 1! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'rw 8/6/2003 12:11'!valueWithArguments: anArray startingFrom: startIndex	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	"Note: I currently trap Halt,Exception so that I am sure to get a Halt event in case of a Halt. This is being fixed in the exception system - when the fix is done it will be enough to capture only Exception."	| each answer |	startIndex to: self size do: [:index |		each := self at: index.		each isReceiverOrAnyArgumentGarbage ifFalse: [			[answer _ each valueWithArguments: anArray]				on: Halt, Exception				do: [:exc | 						self valueWithArguments: anArray startingFrom: index + 1.						exc pass]]].	^ answer! !!WeakActionSequenceTrappingErrors methodsFor: 'converting' stamp: 'rw 7/20/2003 16:03'!asActionSequenceTrappingErrors	^self! !SystemChangeNotifier class removeSelector: #createUniqueInstance!SystemChangeNotifier class removeSelector: #instanceVariableKind!SystemChangeNotifier class removeSelector: #newForTest!SystemChangeNotifier class removeSelector: #newForTesting!SystemChangeNotifier removeSelector: #classRenamed:from:inCategory:!SystemChangeNotifier removeSelector: #instanceVariableRenamed:from:inClass:!SystemChangeNotifier removeSelector: #isBroadcasting:!SystemChangeNotifier removeSelector: #methodAdded:inClass:!SystemChangeNotifier removeSelector: #methodAdded:inProtocol:class:!SystemChangeNotifier removeSelector: #methodChangedFrom:to:inClass:!SystemChangeNotifier removeSelector: #methodRemoved:inProtocol:fromClass:!SystemChangeNotifier removeSelector: #methodRemoved:selector:inProtocol:fromClass:!!SystemChangeNotifier reorganize!('initialize' initialize)('private' notify:ofEvents:using: releaseAll setBroadcasting trigger:)('private-event lists' allSystemEvents systemEventsForChange: systemEventsForItem: systemEventsForItem:change:)('system triggers' class:recategorizedFrom:to: classAdded:inCategory: classCommented: classCommented:inCategory: classDefinitionChangedFrom:to: classRemoved:fromCategory: classRenamed:from:to:inCategory: classReorganized: evaluated: evaluated:context: methodAdded:selector:inClass: methodAdded:selector:inClass:requestor: methodAdded:selector:inProtocol:class: methodAdded:selector:inProtocol:class:requestor: methodChangedFrom:to:selector:inClass: methodChangedFrom:to:selector:inClass:requestor: methodRemoved:selector:class: methodRemoved:selector:inProtocol:class: selector:recategorizedFrom:to:inClass:)('public' doSilently: isBroadcasting noMoreNotificationsFor: notify:ofAllSystemChangesUsing: notify:ofSystemChangesOfChange:using: notify:ofSystemChangesOfItem:change:using: notify:ofSystemChangesOfItem:using:)!RenamedEvent class removeSelector: #class:category:oldName:!RenamedEvent class removeSelector: #instanceVariable:class:oldName:!RenamedEvent class removeSelector: #method:protocol:class:oldName:!RemovedEvent class removeSelector: #selector:protocol:class:!!ModifiedClassDefinitionEvent class reorganize!('instance creation' classDefinitionChangedFrom:to:)('accessing' supportedKinds)!ModifiedEvent class removeSelector: #instanceVariablesChangedFrom:to:inClass:!ModifiedEvent class removeSelector: #methodChangedFrom:to:inClass:!ModifiedEvent class removeSelector: #methodSelector:changedFrom:to:inClass:!ModifiedEvent class removeSelector: #methodSelector:changedFrom:to:inClass:requestor:!ModifiedEvent removeSelector: #itemMethod!ModifiedEvent removeSelector: #itemSelector!AbstractEvent class removeSelector: #instanceVariableKind!AbstractEvent class removeSelector: #selector:class:!AbstractEvent class removeSelector: #selector:method:class:!AbstractEvent class removeSelector: #selector:method:class:requestor:!AbstractEvent class removeSelector: #selector:method:protocol:class:!AbstractEvent class removeSelector: #selector:method:protocol:class:requestor:!AbstractEvent class removeSelector: #selector:protocol:class:!!AbstractEvent class reorganize!('instance creation' class: class:category: item:kind: method:class: method:protocol:class: method:selector:class: method:selector:class:requestor: method:selector:protocol:class: method:selector:protocol:class:requestor: new)('accessing' allChangeKinds allItemKinds changeKind eventSelectorBlock itemChangeCombinations supportedKinds systemEvents)('item kinds' categoryKind classKind expressionKind methodKind protocolKind)('temporary' comment1 comment2 comment3 saveChangeNotificationAsSARFileWithNumber:)!AbstractEvent removeSelector: #isReorganizedClass!AbstractEvent removeSelector: #itemInstanceVariable!AbstractEvent removeSelector: #itemInstanceVariable:!AbstractEvent removeSelector: #requestor!AbstractEvent removeSelector: #requestor:!