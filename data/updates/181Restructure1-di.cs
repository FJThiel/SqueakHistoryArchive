'From Squeak 2.1 of June 30, 1998 on 11 August 1998 at 9:53:01 pm'!"Change Set:		MorphRestructuring1-diDate:			10 August 1998Author:			Dan IngallsThis file defines MorphicExtension, and adds a filed, extension, for it in all extant morphs.In the doit at the end, all morphs are converted, with references to costumee (to become player) and eventHandler moved into the extension, as well as the common properties, locked, visible, sticky, balloonText, balloonTextSelector, externalName (was name), isPartsDonor (was partsDonor), and actorState.Many references are made for compatibility to Morph>>convertedToExtendedFormat.  These will be removed in a later file and the three variables, eventHandler, properties, and costumee, removed from Morph."!Utilities informUser: 'Recompiling all subclasses or Morph.This may take a few minutes...' during: [Object subclass: #Morph	instanceVariableNames: 'bounds owner submorphs fullBounds color eventHandler properties costumee extension '	classVariableNames: 'EmptyArray '	poolDictionaries: ''	category: 'Morphic-Kernel']!Object subclass: #MorphExtension	instanceVariableNames: 'locked visible sticky balloonText balloonTextSelector externalName isPartsDonor actorState player eventHandler otherProperties '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!RectangleMorph subclass: #TileMorph	instanceVariableNames: 'type slotName literal operatorOrExpression actualObject downArrow upArrow suffixArrow typeColor lastArrowTick nArrowTicks operatorReadoutString possessive '	classVariableNames: 'DownPicture SuffixArrowAllowance SuffixPicture UpArrowAllowance UpPicture UpdatingOperators '	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!!Morph reorganize!('initialization' initialExtent initialize openInMVC openInWorld openInWorld: standardPalette)('classification' isAlignmentMorph isFlexMorph isHandMorph isLayoutMorph isMorph isRenderer isWorldMorph isWorldOrHandMorph)('accessing' balloonHelpTextForHandle: color color: colorForInsets eventHandler: forwardDirection hasTranslucentColor rotationDegrees)('copying' copy fullCopy updateReferencesUsing: veryDeepCopy veryDeepCopyWithoutCostumee)('structure' isInWorld nearestOwnerThat: outermostMorphThat: owner ownerThatIsA: renderedMorph root topRendererOrSelf world)('submorphs-accessing' allFindA: allMorphs allMorphsDo: allNonSubmorphMorphs couldBeOwnedBy: findA: findInWorldA: firstSubmorph hasSubmorphs lastSubmorph morphsAt: morphsAt:addTo: submorphCount submorphs submorphsBehind:do: submorphsDo: submorphsInFrontOf:do: submorphsReverseDo: uncoveredAt: unlockedMorphsAt: unlockedMorphsAt:addTo:)('submorphs-add/remove' addAllMorphs: addMorph: addMorphBack: addMorphCentered: addMorphFront: addMorphFront:fromWorldPosition: addMorphNearBack: copyWithoutSubmorph: delete deleteSubmorphsWithProperty: goBehind privateDelete removeAllMorphs replaceSubmorph:by:)('drawing' areasRemainingToFill: doesOwnRotation drawOn: fullDrawOn: fullDrawOn:butDoNotDraw: imageForm imageForm:forRectangle: imageFormDepth: imageFormForRectangle:)('geometry' align:with: bottom bottom: bottomLeft bottomLeft: bottomRight bottomRight: bounds bounds: boundsInWorld center extent extent: fullBounds fullBoundsInWorld height height: innerBounds left left: nextOwnerPage pointInWorld: position position: previousOwnerPage right right: setConstrainedPositionFrom: top top: topLeft topLeft: topRight topRight: width width: worldBounds)('geometry testing' containsPoint: fullContainsPoint:)('dropping/grabbing' acceptDroppingMorph:event: allowSubmorphExtraction closeDragAndDrop justDroppedInto:event: openDragAndDrop wantsDroppedMorph:event:)('event handling' click: doubleClick: drag: handlesDragOver: handlesMouseDown: handlesMouseOver: keyStroke: keyboardFocusChange: mouseDown: mouseEnter: mouseLeave: mouseMove: mouseUp: mouseUpBalk: on:send:to: on:send:to:withValue: passToEventHandler: preemptsMouseDown: transformFrom: transformFromWorld trumpsMouseDown:)('stepping' arrangeToStartStepping startStepping startSteppingIn: step stepTime stopStepping wantsSteps)('menu' addAddHandMenuItemsForHalo:hand: addCustomHaloMenuItems:hand: addCustomMenuItems:hand: addDropShadow addFlexShell addFlexShellForRotation adhereToEdge adhereToEdge: setToAdhereToEdge:)('layout' minHeight minWidth)('change reporting' changed invalidRect: layoutChanged ownerChanged)('printing' colorString: constructorString defaultLabelForInspector fullPrintOn: initString printConstructorOn:indent: printConstructorOn:indent:nodeDict: printOn: printStructureOn:indent: structureString)('e-toy commands' beep beep: color:sees: colorUnder hide jumpTo: makeFenceSound referencePosition: set: show start stop wearCostume: wrap)('e-toy support' allMorphsAndBookPagesInto: allMorphsIncludingBookPages asNumber: canHaveScript choosePartNameSilently externalName goHome isTileLike makeAllTilesColored makeAllTilesGreen move:toPosition: nameInModel referencePlayfield referencePosition restoreTypeColor specialNameInModel standardHolder useUniformTileColor x x: y y:)('model access' choosePartName innocuousName installModelIn:)('other' flash fullLoadCachedState fullReleaseCachedState loadCachedState objectToStoreOnDataStream prepareToBeSaved releaseCachedState saveOnFile storeDataOn:)('private' copyRecordingIn: copyWithoutSubmorphs privateAddMorph:atIndex: privateBounds: privateColor: privateFullMoveBy: privateMoveBy: privateOwner: privateRemoveMorph: privateSubmorphs privateSubmorphs:)('naming' knownName renameTo: setNamePropertyTo: setNameTo: submorphNamed: submorphNamed:ifNone: updateWorldAfterRenamingMe:)('flags')('locking' isLocked lock lock: unlock)('aug97 additions' aboutToBeGrabbedBy: addLabel: addLabel:outset: addTransparentSpacerOfSize: beRepelling beSticky colorSettable configureForKids eachStepInOwnerChainDo: findDeepSubmorphThat:ifAbsent: findSubmorphThat:ifAbsent: highlightColor highlightColor: inPartsBin isPartsBin isPartsDonor isPartsDonor: isSticky justClonedFrom: justDuplicatedFrom: markAsPartsDonor morphToDropFrom: morphToGrabFrom: name: nextPageButton objectViewed playfield positionAtBottomLeft positionAtBottomRight previousPageButton primaryHand regularColor regularColor: removeEmptyLayoutMorphs repelsMorph:event: rootForGrabOf: screenLocation screenRectangle slideBackToFormerSituation: slideToTrash: submorphsSatisfying: unlockContents unlockOneSubpart updatingTileForArgType:partName:getSelector:putSelector: vanishAfterSlidingTo:event: wantsKeyboardFocusFor: withAllContainers wouldAcceptKeyboardFocus)('extended access' assureExtension balloonText balloonTextSelector: convertToExtendedFormat convertedToExtendedFormat copyPropertiesFrom:dict: extension hasProperty: otherProperties properties removeProperty: setProperty:toValue: valueOfProperty: valueOfProperty:ifAbsent:)('object fileIn' convertbosfce0:bosfcep0: convertbosfcep0:bosfcepc0:)('halos and balloon help' addHalo addOptionalHandlesTo:box: deleteBalloon editBalloonHelpContent: editBalloonHelpText halo hasHalo mouseDownOnHelpHandle: noHelpString removeHalo setBalloonText: showBalloon: wantsBalloon wantsHalo wantsHaloFor:)('dec97 additions' assuredCostumee choosePenColor: choosePenSize costumee costumee: eventHandler formalCostumeName getPenColor getPenDown getPenSize isPlayfieldLike jettisonScripts liftPen lowerPen maxScaleFactor newPlayerInstance newScaleFactor:previousScaleFactor: penColor: scriptEditorFor: scriptPerformer showPlayerMenu slotNamesAndTypesForBank: tearOffTile updateLiteralLabel viewAfreshShowingScript:at:)('apr98 additions' actorState actorState: actorStateOrNil addDebuggingItemsTo:hand: addPaintingItemsTo:hand: allSubmorphNames hasFocus holdsDataForEachInstance inspectInMorphic instantiatedUserScriptsDo: isTileScriptingElement mustBeBackmost okayToDuplicate openViewerForArgument pasteUpMorph presenter removeLink: residesInPartsBin restoreSuspendedEventHandler slotSpecifications suspendEventHandler tempCommand toggleStickiness usableDuplicate usableDuplicateIn: usableSiblingInstance)('jun98 additions' addFontHandlesTo:box: clearPaletteArea cursorPoint hasSubmorphWithProperty: inspectOwnerChain makeGraphPaper makeGraphPaperGrid:background:line: newThumbnailOfHeight: setStandardTexture snapToEdgeIfAppropriate submorphWithProperty: substituteForMorph:beingDroppedOn: succeededInRevealing: textureParameters thumbnailOfHeight: valueAsConstant)!!Morph methodsFor: 'initialization' stamp: 'di 8/10/1998 13:08'!initialize	bounds _ 0@0 corner: 50@40.	owner _ nil.	submorphs _ EmptyArray.	color _ Color blue.! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 15:01'!eventHandler: anEventHandler	"Note that morphs can share eventHandlers and all is OK.  "self convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [self assureExtension].	extension eventHandler: anEventHandler.^ self].	"Old code..."	eventHandler _ anEventHandler.! !!Morph methodsFor: 'copying' stamp: 'di 8/11/1998 15:03'!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot. It may beoverridden to avoid this behavior if so desired."	| old |	Morph instSize + 1 to: self class instSize do:		[:i | old _ self instVarAt: i.		old isMorph ifTrue:			[self instVarAt: i put: (aDictionary at: old ifAbsent: [old])]].self convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifFalse: [extension updateReferencesUsing: aDictionary].^ self].	"Old code..."	self eventHandler ifNotNil:		[self eventHandler: self eventHandler copy.		1 to: self eventHandler class instSize do:			[:i | old _ self eventHandler instVarAt: i.			old isMorph ifTrue:				[self eventHandler instVarAt: i put: (aDictionary at: old ifAbsent: [old])]]].	properties ifNotNil: [		properties associationsDo: [:ass |			ass value: (aDictionary at: ass value ifAbsent: [ass value])]].	"note side effecting"! !!Morph methodsFor: 'copying' stamp: 'di 8/11/1998 14:36'!veryDeepCopyWithoutCostumee	| hold copy holdState |	hold _ self costumee.	holdState _ self actorStateOrNil.	holdState ifNotNil: [self actorState: nil].	self costumee: nil.	copy _ self veryDeepCopy.	holdState ifNotNil:		[copy actorState: (holdState copyWithPlayerReferenceNilled)].	self costumee: hold.	holdState ifNotNil: [self actorState: holdState].	^ copy! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'tk 8/10/1998 16:08'!delete	"Remove the receiver as a submorph of its owner and make its new owner be nil."	| aWorld |	owner ifNotNil:		[self costumee ifNotNil: [aWorld _ self world].		owner privateRemoveMorph: self.		owner _ nil.		self costumee ifNotNil: [self costumee noteDeletionOf: self fromWorld: aWorld]].! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/11/1998 13:01'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	self isPartsDonor: false! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!handlesMouseDown: evt	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"	"NOTE: The default response is false, except if you have added sensitivity to mouseDown events using the on:send:to: mechanism.  Subclasses that implement these messages directly should override this one to return true." 	self eventHandler ifNotNil: [^ self eventHandler handlesMouseDown: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!handlesMouseOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?"	"NOTE: The default response is false, except if you have added sensitivity to mouseEnter: or mouseLeave:, using the on:send:to: mechanism." 	self eventHandler ifNotNil: [^ self eventHandler handlesMouseOver: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!keyStroke: anEvent	"Handle a keystroke event.  The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler keyStroke: anEvent fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!mouseDown: evt	"Handle a mouse down event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:00'!mouseEnter: evt	"Handle a mouseEnter event, meaning the mouse just entered my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseEnter: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:01'!mouseLeave: evt	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseLeave: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:02'!mouseMove: evt	"Handle a mouse move event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseStillDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!mouseUp: evt	"Handle a mouse up event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseUp: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:01'!on: eventName send: selector to: recipient	self eventHandler ifNil: [self eventHandler: EventHandler new].	self eventHandler on: eventName send: selector to: recipient! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!on: eventName send: selector to: recipient withValue: value	"NOTE: selector must take 3 arguments, of which value will be the 3rd"	self eventHandler ifNil: [self eventHandler: EventHandler new].	self eventHandler on: eventName send: selector to: recipient withValue: value! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!passToEventHandler: evt	"Pass the given event to my event handler, if any."	self eventHandler ifNotNil:		[self eventHandler handleEvent: evt fromMorph: self].! !!Morph methodsFor: 'stepping' stamp: 'tk 8/10/1998 16:13'!step	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message. This default implementation does nothing."	self costumee ifNotNil: [self costumee step]! !!Morph methodsFor: 'stepping' stamp: 'tk 8/10/1998 16:18'!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^ self costumee ifNotNil: [125] ifNil: [1000]! !!Morph methodsFor: 'stepping' stamp: 'tk 8/10/1998 16:12'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	self costumee ifNotNil: [^ true].	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'menu' stamp: 'tk 8/10/1998 16:16'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	self costumee ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	aMenu add: 'open viewer' action: #openViewerForArgument.	(self isKindOf: MorphThumbnail) ifFalse:		[aMenu add: 'make alias' action: #makeAliasForArgument].	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [GIFImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	self colorSettable ifTrue:		[aMenu add: 'change color...' action: #changeColor].	(aHandMorph argument pasteUpMorph morphsAt: aHandMorph menuTargetOffset) size > 2 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!Morph methodsFor: 'menu' stamp: 'di 8/11/1998 14:41'!addFlexShell	"Wrap a rotating and scaling shell around this morph."	| oldHalo flexMorph anActorState aName |	self isFlexMorph ifTrue: [^ self].	oldHalo _ self halo.	self owner addMorph:		(flexMorph _ TransformationMorph new asFlexOf: self).	(anActorState _ self actorStateOrNil) ifNotNil:		[flexMorph actorState: anActorState.		self actorState: nil].	(aName _ self knownName) ifNotNil:		[flexMorph setNameTo: aName.		self setNameTo: nil].	self costumee ifNotNil:		[flexMorph costumee: self costumee.		self costumee rawCostume: flexMorph].	oldHalo ifNotNil: [oldHalo setTarget: flexMorph]! !!Morph methodsFor: 'e-toy support' stamp: 'tk 8/10/1998 16:10'!restoreTypeColor	self costumee ifNotNil: [self costumee allScriptEditors do:		[:anEditor | anEditor allMorphsDo:			[:m | m restoreTypeColor]]]! !!Morph methodsFor: 'e-toy support' stamp: 'tk 8/10/1998 16:00'!specialNameInModel	"Return the name for this morph in the underlying model or nil."	"Not an easy problem.  For now, take the first part of the mouseDownSelector symbol in my eventHandler (fillBrushMouseUp:morph: gives 'fillBrush').  5/26/97 tk"	| hh |	(self isKindOf: MorphicModel)		ifTrue: [^ self slotName]		ifFalse: [			self eventHandler ifNotNil: [				self eventHandler mouseDownSelector ifNotNil: [					hh _ self eventHandler mouseDownSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ self eventHandler mouseDownSelector copyFrom: 1 to: hh-1]].				self eventHandler mouseUpSelector ifNotNil: [					hh _ self eventHandler mouseUpSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ self eventHandler mouseUpSelector copyFrom: 1 to: hh-1]].				]].			"	(self eventHandler mouseDownRecipient respondsTo: #nameFor:) ifTrue: [					^ self eventHandler mouseDownRecipient nameFor: self]]].	"			"myModel _ self findA: MorphicModel.			myModel ifNotNil: [^ myModel slotName]"		^ self world specialNameInModelFor: self! !!Morph methodsFor: 'e-toy support' stamp: 'tk 8/10/1998 16:13'!useUniformTileColor	self costumee ifNotNil:		[self costumee allScriptEditors do:			[:anEditor | anEditor allMorphsDo:				[:m | m useUniformTileColor]]]! !!Morph methodsFor: 'naming' stamp: 'di 8/10/1998 14:52'!knownNameself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ nil].	^ extension externalName].	"Old code..."	^ self valueOfProperty: #name! !!Morph methodsFor: 'naming' stamp: 'tk 8/10/1998 16:08'!renameTo: aName	| aPresenter putInViewer |	self setNameTo: aName.	(aPresenter _ self world presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: self costumee.		aPresenter flushViewerCache.		putInViewer ifTrue: [aPresenter viewMorph: self]].	self world allTileScriptingElements do:		[:m | m bringUpToDate]! !!Morph methodsFor: 'naming' stamp: 'di 8/11/1998 15:02'!setNamePropertyTo: aNameself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [self assureExtension].	extension externalName: aName.^ self].	"Old code..."	self setProperty: #name toValue: aName! !!Morph methodsFor: 'locking' stamp: 'di 8/11/1998 12:21'!isLockedself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ false].	^ extension locked].	"Old code..."	^ (self valueOfProperty: #locked) == true! !!Morph methodsFor: 'locking' stamp: 'di 8/11/1998 15:02'!lock: aBooleanself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue:		[aBoolean ifFalse: [^ self].		self assureExtension].	extension locked: aBoolean.^ self].	"Old code..."	self setProperty: #locked toValue: aBoolean! !!Morph methodsFor: 'locking' stamp: 'di 8/11/1998 12:33'!unlock	self lock: false! !!Morph methodsFor: 'aug97 additions' stamp: 'di 8/11/1998 14:59'!beStickyself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [self assureExtension].	extension sticky: true.^ self].	"Old code..."	self setProperty: #sticky toValue: true! !!Morph methodsFor: 'aug97 additions' stamp: 'di 8/11/1998 12:48'!inPartsBin	| o |	self isPartsDonor ifTrue: [^ true].	o _ self owner.	[o == nil] whileFalse:		[o isPartsBin ifTrue: [^ true].		o _ o owner].	^ false! !!Morph methodsFor: 'aug97 additions' stamp: 'di 8/11/1998 12:51'!isPartsDonorself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ false].	^ extension isPartsDonor].	"Old code..."	^ self hasProperty: #partsDonor! !!Morph methodsFor: 'aug97 additions' stamp: 'di 8/11/1998 15:01'!isPartsDonor: aBooleanself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue:		[aBoolean ifFalse: [^ self].		self assureExtension].	extension isPartsDonor: aBoolean.^ self].	"Old code..."	self setProperty: #partsDonor toValue: aBoolean! !!Morph methodsFor: 'aug97 additions' stamp: 'di 8/11/1998 12:35'!isStickyself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ false].	^ extension sticky].	"Old code..."	^ (self valueOfProperty: #sticky) == true! !!Morph methodsFor: 'aug97 additions' stamp: 'tk 8/10/1998 16:12'!justClonedFrom: aDonor	"A hook so that after the Duplicate command is issued by a user, the clone gets a chance to get things right." 	self costumee ifNotNil:		[self costumee justClonedFrom: aDonor costumee]! !!Morph methodsFor: 'aug97 additions' stamp: 'tk 8/10/1998 16:12'!justDuplicatedFrom: aDonor	"A hook so that after the Duplicate command is issued by a user, the dup gets a chance to get things right.  If a costumee (Player) is involved, the duplication involved the creation of a fresh Player subclass rather than another instance of the original." 	self costumee ifNotNil:		[self costumee justDuplicatedFrom: aDonor costumee]! !!Morph methodsFor: 'aug97 additions' stamp: 'di 8/11/1998 13:02'!markAsPartsDonor	"Mark the receiver specially so that mouse actions on it are interpreted as 'tearing off a copy'"	self isPartsDonor: true! !!Morph methodsFor: 'extended access' stamp: 'di 8/11/1998 10:38'!assureExtension	extension == nil ifTrue: [extension _ MorphExtension new]! !!Morph methodsFor: 'extended access' stamp: 'di 8/11/1998 12:41'!balloonText	"NB: subclasses may override such that they programatically construct the text, for economy's sake, such as model phrases in a Viewer"	| val |self convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ nil].	(val _  extension balloonText) ifNotNil: [^ val].	(val _ extension balloonTextSelector) ifNotNil:		[^ ScriptingSystem helpStringFor: val].	^ nil].	"Old code..."	(val _ self valueOfProperty: #balloonText) ifNotNil: [^ val].	(val _ self valueOfProperty: #balloonTextSelector) ifNotNil:		[^ ScriptingSystem helpStringFor: val].	^ nil! !!Morph methodsFor: 'extended access' stamp: 'di 8/11/1998 14:59'!balloonTextSelector: aSelectorself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [self assureExtension].	extension balloonTextSelector: aSelector.^ self].	"Old code..."	self setProperty: #balloonTextSelector toValue: aSelector! !!Morph methodsFor: 'extended access' stamp: 'di 8/11/1998 21:45'!convertToExtendedFormat	"This method moves all property variables as well as eventHandler, and costumee into a morphicExtension.  It assumes that the convertedTo... compatibility method has been set to return true.  Once this has been run, (and the methods that access them have been changed), these fields can be removed from Morph"	| propVal |	"Move refs to eventhandler and costumee into extension"	eventHandler == nil ifFalse:		[self eventHandler: eventHandler.		eventHandler _ nil].	costumee == nil ifFalse:		[self costumee: costumee.		costumee _ nil].	properties == nil ifFalse:		[properties keys do:			[:key |  "Move property extensions into extension"			propVal _ properties at: key.			propVal ifNotNil:				[key == #possessive				ifTrue: [propVal == true ifTrue: [self bePossessive]]				ifFalse: [key ifNotNil: [self setProperty: key toValue: propVal]]]]].	properties _ nil.! !!Morph methodsFor: 'extended access' stamp: 'di 8/11/1998 10:43'!convertedToExtendedFormat	^ false "Not yet..."! !!Morph methodsFor: 'extended access' stamp: 'di 8/11/1998 15:00'!copyPropertiesFrom: donorMorph dict: dictself convertedToExtendedFormat ifTrue: ["New code..."	(extension _ donorMorph extension copy) == nil ifTrue: [^ self].	extension copyPropertiesFrom: donorMorph dict: dict.^ self].	"Old code..."	properties _ donorMorph properties copy.	properties ifNotNil: [		properties associationsDo: [:ass |			ass value isMorph ifTrue: [				ass value owner ifNil: [ass value: (assvalue copyRecordingIn: dict)]]]].					"note side effecting.  Any un-ownedmorph belongs to us."! !!Morph methodsFor: 'extended access' stamp: 'di 8/10/1998 14:25'!extension	^ extension! !!Morph methodsFor: 'extended access' stamp: 'di 8/10/1998 14:24'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	| prop |self convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ false].	^ extension hasProperty: propName].	"Old code..."	^ properties ~~ nil and:		[((prop _ properties at: propName ifAbsent: [nil]) ~~ false) and:			[prop ~~ nil]]! !!Morph methodsFor: 'extended access' stamp: 'di 8/11/1998 12:01'!otherProperties	extension == nil ifTrue: [^ nil].	^ extension otherProperties! !!Morph methodsFor: 'extended access' stamp: 'di 8/11/1998 15:02'!removeProperty: propNameself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ self].	extension removeProperty: propName.^ self].	"Old code..."	properties ifNil: [^ self].	properties removeKey: propName ifAbsent: [].	properties size == 0 ifTrue: [properties _ nil]! !!Morph methodsFor: 'extended access' stamp: 'di 8/11/1998 15:02'!setProperty: propName toValue: aValue	aValue ifNil: [^ self removeProperty: propName].self convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [self assureExtension].	extension setProperty: propName toValue: aValue.^ self].	"Old code..."	properties ifNil: [properties _ IdentityDictionary new].	properties at: propName put: aValue.! !!Morph methodsFor: 'extended access' stamp: 'di 8/10/1998 14:29'!valueOfProperty: propNameself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ nil].	^ extension valueOfProperty: propName].	"Old code..."	properties ifNil: [^ nil].	^ properties at: propName ifAbsent: [nil]! !!Morph methodsFor: 'extended access' stamp: 'di 8/10/1998 16:33'!valueOfProperty: propName ifAbsent: aBlockself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ aBlock value].	^ extension valueOfProperty: propName ifAbsent: aBlock].	"Old code..."	properties ifNil: [^ aBlock value].	^ properties at: propName ifAbsent: [aBlock value]! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 8/11/1998 12:43'!editBalloonHelpText	| str  |	str _ self balloonText.	str ifNil: [str _ self noHelpString].	self editBalloonHelpContent: str! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 8/11/1998 15:02'!setBalloonText: stringOrTextself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [self assureExtension].	extension balloonText: stringOrText.^ self].	"Old code..."	self setProperty: #balloonText toValue: stringOrText! !!Morph methodsFor: 'dec97 additions' stamp: 'tk 8/10/1998 16:09'!assuredCostumee	"Answer the receiver's costumee, a Player,, creating a new one if none currently exists"	self costumee ifNil:		[self externalName.  "a default may be given if not named yet"		self costumee: self newPlayerInstance.  			"Different morphs may demand different player types"		self costumee costume: self.		self presenter ifNotNil: [self presenter flushPlayerListCache]].	^ self costumee! !!Morph methodsFor: 'dec97 additions' stamp: 'di 8/11/1998 10:34'!costumeeself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ nil].	^ extension player].	"Old code..."	^ costumee! !!Morph methodsFor: 'dec97 additions' stamp: 'di 8/11/1998 15:00'!costumee: anObjectself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [self assureExtension].	extension player: anObject.^ self].	"Old code..."	costumee _ anObject! !!Morph methodsFor: 'dec97 additions' stamp: 'di 8/11/1998 10:35'!eventHandlerself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ nil].	^ extension eventHandler].	"Old code..."	^ eventHandler! !!Morph methodsFor: 'dec97 additions' stamp: 'tk 8/10/1998 16:11'!getPenColor	^ self costumee ifNotNil: [self actorState getPenColor] ifNil: [Color green]! !!Morph methodsFor: 'dec97 additions' stamp: 'tk 8/10/1998 16:18'!getPenDown	self costumee ifNil: [^ false].	^ self actorState getPenDown! !!Morph methodsFor: 'dec97 additions' stamp: 'tk 8/10/1998 16:13'!getPenSize	self costumee ifNil: [^ 1].	^ self actorState getPenSize! !!Morph methodsFor: 'dec97 additions' stamp: 'tk 8/10/1998 16:11'!jettisonScripts	self costumee ifNotNil: [self costumee class jettisonScripts]! !!Morph methodsFor: 'dec97 additions' stamp: 'tk 8/10/1998 16:12'!scriptPerformer	^ self costumee ifNil: [self] ifNotNil: [self costumee]! !!Morph methodsFor: 'dec97 additions' stamp: 'tk 8/10/1998 16:18'!showPlayerMenu	self costumee ifNotNil:		[self costumee showPlayerMenu]! !!Morph methodsFor: 'dec97 additions' stamp: 'tk 8/10/1998 16:18'!tearOffTile	| aValue |	self costumee ifNotNil: [^ self costumee tearOffTileForSelf].		(aValue _ self valueAsConstant) ifNotNil:		[^ self world primaryHand attachMorph: aValue newTileMorphRepresentative]. 	^ self assuredCostumee tearOffTileForSelf! !!Morph methodsFor: 'dec97 additions' stamp: 'tk 8/10/1998 16:08'!viewAfreshShowingScript: aScriptName at: aPosition	| anEditor |	self costumee updateAllViewers.	self world addMorph: (anEditor _ self costumee scriptEditorFor: aScriptName).	anEditor position: aPosition! !!Morph methodsFor: 'apr98 additions' stamp: 'di 8/11/1998 14:49'!actorState	"This method instantiates actorState as a side-effect.	For simple queries, use actorStateOrNil"	| state |	state _ self actorStateOrNil.	state ifNil:		[state _ ActorState new initializeFor: self assuredCostumee.		self actorState: state].	^ state! !!Morph methodsFor: 'apr98 additions' stamp: 'di 8/11/1998 14:58'!actorState: anActorStateself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [self assureExtension].	extension actorState: anActorState.^ self].	"Old code..."	self setProperty: #actorState toValue: anActorState! !!Morph methodsFor: 'apr98 additions' stamp: 'di 8/11/1998 15:00'!actorStateOrNilself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ nil].	^ extension actorState].	"Old code..."	^ self valueOfProperty: #actorState! !!Morph methodsFor: 'apr98 additions' stamp: 'tk 8/10/1998 16:11'!addDebuggingItemsTo: aMenu hand: aHandMorph	| subMenu |	subMenu _ MenuMorph new defaultTarget: aHandMorph.	subMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	subMenu add: 'inspect morph' action: #inspectArgument.	World ifNil:		[subMenu add: 'inspect morph (morphic)' action: #inspectArgumentInMorphic].	subMenu add: 'browse morph class' action: #browseMorphClass.	self costumee ifNotNil:		[subMenu add: 'inspect player' action: #inspectCostumee.		World ifNil: [subMenu add: 'inspect player (morphic)' action: #inspectArgumentsCostumeeInMorphic].		subMenu add: 'browse player class' action: #browsePlayerClass].	subMenu add: 'make own subclass' action: #subclassMorph.	subMenu add: 'internal name' action: #nameMorph.	subMenu add: 'save morph in file' action: #saveOnFile.	subMenu defaultTarget: self.	subMenu add: 'edit balloon help' action: #editBalloonHelpText.	subMenu add: 'temp command' action: #tempCommand.	aMenu add: 'debug...' subMenu: subMenu! !!Morph methodsFor: 'apr98 additions' stamp: 'tk 8/10/1998 16:09'!okayToDuplicate	self costumee ifNil: [^ true].	self instantiatedUserScriptsDo:		[:aScript | aScript isAnonymous ifTrue:			[self inform: 'This object has one or moreunnamed, unsaved scripts,which would not be partof a duplicate.  So, for now,we just won''t let you dothis.  Sorry!!'.			^ false]].	^ true! !!Morph methodsFor: 'apr98 additions' stamp: 'tk 8/10/1998 16:02'!removeLink: actionCode	self eventHandler ifNotNil:		[self eventHandler on: actionCode send: nil to: nil]! !!Morph methodsFor: 'apr98 additions' stamp: 'tk 8/10/1998 16:05'!suspendEventHandler	self eventHandler ifNotNil:		[self setProperty: #suspendedEventHandler toValue: self eventHandler.		self eventHandler: nil]! !!Morph methodsFor: 'apr98 additions' stamp: 'di 8/11/1998 15:03'!toggleStickinessself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ self beSticky].	extension sticky: extension sticky not.^ self].	"Old code..."	self setProperty: #sticky toValue: self isSticky not! !!Morph methodsFor: 'apr98 additions' stamp: 'di 8/11/1998 13:02'!usableDuplicateIn: aWorld	|  aName usedNames newPlayer newMorph |	newMorph _ self fullCopy.	self costumee ifNotNil:		[newPlayer _ self costumee duplicatedPlayerForCostume: newMorph.			"nb newPlayer has had his costume set to newMorph in the above-called method"		self isFlexMorph ifTrue: [newMorph renderedMorph costumee: newPlayer]. "???"		newMorph actorState: (self costumee actorState shallowCopy initializeFor: newPlayer)].	(aName _ self knownName) == nil ifTrue:		[self costumee ~~ nil ifTrue: [aName _ newMorph innocuousName]].			"Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ aWorld allKnownNames copyWith: aName.		newMorph setNameTo: (			Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	newMorph justDuplicatedFrom: self.	newMorph isPartsDonor: false.	newMorph privateOwner: nil.	(newPlayer ~~ nil and: [newMorph renderedMorph eventHandler ~~ nil]) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	newPlayer ifNotNil: [self presenter flushPlayerListCache].	^ newMorph! !!Morph methodsFor: 'apr98 additions' stamp: 'tk 8/10/1998 16:15'!usableSiblingInstance	|  aName usedNames newPlayer newMorph |	self flag: #noteToTed.  "Note I've fallen back on veryDeepCopyWithoutCostumee here, because I want another instance of my Player's class rather than a new Player subclass."	newMorph _ self veryDeepCopyWithoutCostumee.	newPlayer _ self costumee class new costume: newMorph.	self isFlexMorph ifTrue: [newMorph renderedMorph costumee: newPlayer]. "???"	newMorph actorState: (self costumee actorState shallowCopy initializeFor: newPlayer).	(aName _ self knownName) == nil ifTrue:		[self costumee ~~ nil ifTrue: [aName _ newMorph innocuousName]].			"Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	"newMorph justDuplicatedFrom: self.  NOT done for sibling inst"	newMorph privateOwner: nil.	(newMorph renderedMorph eventHandler ~~ nil) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	self presenter flushPlayerListCache.	^ newMorph! !!Morph methodsFor: 'jun98 additions' stamp: 'tk 8/10/1998 16:11'!succeededInRevealing: aPlayer	aPlayer == self costumee ifTrue: [^ true].	submorphs do:		[:m | (m succeededInRevealing: aPlayer) ifTrue: [^ true]].	^ false! !!BookMorph methodsFor: 'menu' stamp: 'di 8/11/1998 12:47'!saveAsMyPartsBin	| aBin |	aBin _ self veryDeepCopy.	aBin pages do:		[:aPage | 			aPage isPartsBin: true.			aPage openToDragNDrop: false.			aPage submorphs do:				[:m | m markAsPartsDonor.				m suspendEventHandler]].	ScriptingSystem setPartsBinFrom: aBin! !!MorphExtension commentStamp: 'di 8/11/1998 21:53' prior: 0!MorphExtension provides access to extra instance state that is not required in most simple morphs.  This allows simple morphs to remain relatively lightweight while still admitting more complex structures as necessary.  The otherProperties field takes this policy to the extreme of allowing any number of additional named attributes, albeit at a certain cost in speed and space.!!MorphExtension reorganize!('named access' actorState actorState: balloonText balloonText: balloonTextSelector balloonTextSelector: eventHandler eventHandler: externalName externalName: isPartsDonor isPartsDonor: locked locked: player player: sticky sticky: visible visible:)('other properties' checkForConversionError: hasProperty: otherProperties removeProperty: setProperty:toValue: valueOfProperty: valueOfProperty:ifAbsent:)('copying' copyPropertiesFrom:dict: updateReferencesUsing:)!!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:53'!actorState	^ actorState! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!actorState: newValue	actorState _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:52'!balloonText	^ balloonText! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!balloonText: newValue	balloonText _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:52'!balloonTextSelector	^ balloonTextSelector! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!balloonTextSelector: newValue	balloonTextSelector _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:54'!eventHandler	^ eventHandler! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!eventHandler: newValue	eventHandler _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 14:47'!externalName	^ externalName! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 14:47'!externalName: newValue	externalName _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/11/1998 12:52'!isPartsDonor	isPartsDonor == nil ifTrue: [^ false].	^ isPartsDonor! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/11/1998 12:52'!isPartsDonor: newValue	isPartsDonor _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/11/1998 12:30'!locked	locked == nil ifTrue: [^ false].	^ locked! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:54'!locked: newValue	locked _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:53'!player	^ player! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!player: newValue	player _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/11/1998 12:30'!sticky	sticky == nil ifTrue: [^ false].	^ sticky! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!sticky: newValue	sticky _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/11/1998 12:31'!visible	visible == nil ifTrue: [^ false].	^ visible! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!visible: newValue	visible _ newValue! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 21:49'!checkForConversionError: propName	propName == #locked ifTrue: [self halt].	propName == #visible ifTrue: [self halt].	propName == #sticky ifTrue: [self halt].	propName == #balloonText ifTrue: [self halt].	propName == #balloonTextSelector ifTrue: [self halt].	propName == #possessive ifTrue: [self halt].	propName == #actorState ifTrue: [self halt].	propName == #player ifTrue: [self halt].	propName == #name ifTrue: [self halt].  "*renamed*"	propName == #partsDonor ifTrue: [self halt].  "*renamed*"	propName == #possessive ifTrue: [self halt].  "*renamed*"! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 21:49'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	| prop |	self checkForConversionError: propName.	otherProperties == nil ifTrue: [^ false].	prop _ otherProperties at: propName ifAbsent: [nil].	prop == nil ifTrue: [^ false].	prop == false ifTrue: [^ false].	^ true! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 12:02'!otherProperties	^ otherProperties! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 21:50'!removeProperty: propName	self checkForConversionError: propName.	otherProperties == nil ifTrue: [^ self].	otherProperties removeKey: propName ifAbsent: [].	otherProperties size == 0 ifTrue: [otherProperties _ nil]! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 21:52'!setProperty: propName toValue: aValue	"These special cases move old properties into named fields of the extension"	propName == #locked ifTrue: [^ locked _ aValue].	propName == #visible ifTrue: [^ visible _ aValue].	propName == #sticky ifTrue: [^ sticky _ aValue].	propName == #balloonText ifTrue: [^ balloonText _ aValue].	propName == #balloonTextSelector ifTrue: [^ balloonTextSelector _ aValue].	propName == #actorState ifTrue: [^ actorState _ aValue].	propName == #player ifTrue: [^ player _ aValue].	propName == #name ifTrue: [^ externalName _ aValue].  "*renamed*"	propName == #partsDonor ifTrue: [^ isPartsDonor _ aValue].  "*renamed*"	otherProperties == nil ifTrue: [otherProperties _ IdentityDictionary new].	otherProperties at: propName put: aValue.! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 21:51'!valueOfProperty: propName	self checkForConversionError: propName.	otherProperties == nil ifTrue: [^ nil].	^ otherProperties at: propName ifAbsent: [nil]! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 21:51'!valueOfProperty: propName ifAbsent: aBlock	self checkForConversionError: propName.	otherProperties == nil ifTrue: [^ aBlock value].	^ otherProperties at: propName ifAbsent: [^ aBlock value]! !!MorphExtension methodsFor: 'copying' stamp: 'di 8/11/1998 15:14'!copyPropertiesFrom: donorMorph dict: dict	| val |	otherProperties _ donorMorph otherProperties copy.	otherProperties ifNotNil: [		otherProperties associationsDo:			[:assn | val _ assn value.			val isMorph ifTrue: [				val owner ifNil: [assn value: (val copyRecordingIn: dict)]]]].					"note side effecting.  Any un-owned morph belongs to us."! !!MorphExtension methodsFor: 'copying' stamp: 'di 8/11/1998 15:16'!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot."	| old |	eventHandler == nil ifFalse:		[self eventHandler: self eventHandler copy.		1 to: self eventHandler class instSize do:			[:i | old _ eventHandler instVarAt: i.			old isMorph ifTrue:				[eventHandler instVarAt: i put: (aDictionary at: old ifAbsent: [old])]]].	otherProperties ifNotNil: [		otherProperties associationsDo:			[:assn | assn value: (aDictionary at: assn value ifAbsent: [assn value])]].			"note side effecting"! !!PaintInvokingMorph methodsFor: 'all' stamp: 'di 8/11/1998 13:03'!justDroppedInto: aPasteUpMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	self isPartsDonor ifFalse: [^ self].	aPasteUpMorph isPlayfieldLike ifFalse: [self beep.  ^ self].	self delete.	anEvent hand makeNewDrawingInBounds: (aPasteUpMorph paintingBoundsAround: anEvent cursorPoint) pasteUpMorph: aPasteUpMorph! !!PartsBinMorph methodsFor: 'extraction support' stamp: 'di 8/11/1998 13:03'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. Otherwise, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner = self ifTrue:			[^ openToDragNDrop				ifTrue: [root]				ifFalse: [root fullCopy isPartsDonor: false]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'tk 8/10/1998 16:19'!acceptDroppingMorph: aMorph event: evt	| slotSpecs aValue incomingName nameObtained |	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	incomingName _ aMorph knownName.	self changed.	self layoutChanged.	self autoLineLayout ifTrue: [self fixLayout].	self world startSteppingSubmorphsOf: aMorph.	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	slotSpecs _ aMorph slotSpecifications.  "A Fabrik component, for example.  Just a hook at this time"	slotSpecs size > 0 ifTrue:		[self assuredCostumee.		slotSpecs do:			[:tuple |				aValue _ aMorph initialValueFor: tuple first.				nameObtained _ self costumee addSlotNamedLike: tuple first withValue: aValue.				nameObtained ~= incomingName ifTrue:					[aMorph setNameTo: nameObtained]].		self costumee updateAllViewers]! !!PasteUpMorph methodsFor: 'options' stamp: 'di 8/11/1998 13:04'!toggleIsPartsBin	"Not entirely happy with the openToDragNDrop not being directly manipulable etc, but still living with it for now."	isPartsBin _ self isPartsBin not.	openToDragNDrop _ isPartsBin not.	isPartsBin		ifTrue:			[submorphs do:				[:m | m isPartsDonor: true.					m suspendEventHandler]]		ifFalse:			[submorphs do:				[:m | m isPartsDonor: false.					m restoreSuspendedEventHandler]]! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'tk 8/10/1998 16:19'!installAsCurrent: anInstance	self flag: #deferred.	currentDataInstance _ anInstance.	"aList _ self world allViewersOn: currentDataInstance."	anInstance costume: self.	self costumee: anInstance.	self morphsForInstanceData do:			[:m | m dockUpToInstance: anInstance]."	aList do:		[:aViewer |  ... remove it, or install the new instance into it."! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 8/11/1998 13:15'!isPossessive	^ false! !!TabMorph methodsFor: 'all' stamp: 'tk 8/10/1998 16:08'!tabSelected	"Called when the receiver is hit.  First, bulletproof against someone having taken the structure apart.  My own action basically requires that my grand-owner be aTabbedPalette"	self costumee ifNotNil: [self costumee runAllOpeningScripts ifTrue: [^ self]].	(owner isKindOf: IndexTabs) ifFalse: [^ self beep].	(owner owner isKindOf: TabbedPalette) ifFalse: [^ self beep].	owner owner selectTab: self! !!TabbedPaletteComplex methodsFor: 'initialization' stamp: 'di 8/11/1998 14:42'!replaceBook: aName with: newBook	"replace the old book with a new book.  Great for bringing Alan's scaffolding in""Inspect the new bookMorph.  In it, set 	AA _ self.Inspect the TabbedPaletteComplex.  Execute:	self replaceBook: 'Toy' with: AA." 	newBook setNameTo: 'Toy'.	self selectTabNamed: aName.	currentPage delete.	self addMorph: newBook.	pages add: newBook after: currentPage.	pages remove: currentPage.	newBook position: currentPage position.	currentPage _ newBook.	self changed.! !!TextMorph methodsFor: 'editing' stamp: 'di 8/11/1998 13:04'!handlesMouseDown: evt	self isPartsDonor ifTrue: [^ false].	^ self uncoveredAt: evt cursorPoint! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 8/10/1998 13:07'!keyStroke: evt	| view |	self editor model: editView model.  "For evaluateSelection"	view _ editView.  "Copy into temp for case of a self-mutating doit"	super keyStroke: evt.	view scrollSelectionIntoView! !!TileMorph methodsFor: 'initialization' stamp: 'di 8/11/1998 14:58'!bePossessiveself convertedToExtendedFormat ifTrue: ["New code..."	possessive _ true.	self line1: actualObject externalName, '''s'.^ self].	"Old code..."	self setProperty: #possessive toValue: true.	self line1: actualObject externalName, '''s'! !!TileMorph methodsFor: 'initialization' stamp: 'di 8/11/1998 13:18'!isPossessiveself convertedToExtendedFormat ifTrue: ["New code..."	possessive == nil ifTrue: [^ false].	^ possessive].	"Old code..."	^ self hasProperty: #possessive! !!TransformationMorph methodsFor: 'menu' stamp: 'di 8/11/1998 14:42'!removeFlexShell	"Remove the shell used to make a morph rotatable and scalable."	| oldHalo unflexed anActorState aName |	oldHalo _ self halo.	submorphs isEmpty ifTrue: [^ self delete].	unflexed _ self firstSubmorph.	(anActorState _ self actorStateOrNil) ifNotNil:		[unflexed actorState: anActorState].	(aName _ self knownName) ifNotNil:		[unflexed setNameTo: aName].	unflexed costumee: self costumee.	self costumee ifNotNil:		[self costumee rawCostume: unflexed.		self costumee: nil].	self submorphs copy do: [:m |		m position: self center - (m extent // 2).		owner addMorph: m].	oldHalo ifNotNil: [oldHalo setTarget: unflexed].	self delete.! !Morph removeSelector: #isFlaggedNormallyTrue:!Morph removeSelector: #assuredPropertyDictionary!Morph removeSelector: #isFlaggedNormallyTrue!Morph removeSelector: #isFlagged:!Morph removeSelector: #isFlagged!MorphExtension removeSelector: #possessive:!MorphExtension removeSelector: #partsDonor:!MorphExtension removeSelector: #name:!MorphExtension removeSelector: #possessive!MorphExtension removeSelector: #name!MorphExtension removeSelector: #partsDonor!"Postscript:Enable the new extended access mechanism, and convert all extant morphs.Executable statements after this comment quote..."Morph compile: 'convertedToExtendedFormat	^ true'	classified: 'extended access'.Morph allSubInstancesDo:	[:m | m convertToExtendedFormat].!