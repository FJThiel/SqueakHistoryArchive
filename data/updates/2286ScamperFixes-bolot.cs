'From Squeak2.8alpha of 4 February 2000 [latest update: #2210] on 3 June 2000 at 8:32:31 pm'!"Change Set:		ScamperFixesDate:			18 May 2000Author:			Bolot KerimbaevFixes to Scamper and HTTP facilities.- handling of 401 unauthorized fixed and refactored (since it was almost identically reproduced in three methods: postFormArgs:, postMultipartFormArgs:, retrieveContentsArgs:- also fixed a typo in postMultipartFormArgs: (it was retrying as postFormArgs:)- ENH: password dialog box uses password font"!!FillInTheBlank class methodsFor: 'instance creation' stamp: 'sma 6/3/2000 20:22'!requestPassword: queryString	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlankMorph requestPassword: queryString"	Smalltalk isMorphic ifFalse: [self error: 'not yet implemented'].	^ FillInTheBlankMorph requestPassword: queryString! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'bolot 5/18/2000 13:52'!setPasswordQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight acceptOnCR: acceptBoolean	response _ initialAnswer.	done _ false.	self removeAllMorphs.	self extent: 200@70.	self addQuery: queryString.	self width: (self width max: self firstSubmorph width + (2 * borderWidth)).	self addLine.	textPane _ PluggableTextMorph on: self		text: #response		accept: #response:		readSelection: #selectionInterval		menu: #codePaneMenu:shifted:.	textPane hasUnacceptedEdits: true.	textPane acceptOnCR: acceptBoolean.	textPane extent: self innerBounds width@answerHeight.	textPane position: self innerBounds left@self lastSubmorph bottom.	textPane font: (StrikeFont passwordFontSize: 12).	self addMorphBack: textPane.	self addLine.	self addButtonRow.	self height: (self height max: (self lastSubmorph bottom - self top) + borderWidth).! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'bolot 5/18/2000 13:57'!requestPassword: queryString	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."	"use password font"	"FillInTheBlankMorph requestPassword: 'Password?'"	^ self		requestPassword: queryString		initialAnswer: ''		centerAt: Sensor cursorPoint		inWorld: World		onCancelReturn: ''		acceptOnCR: true! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'bolot 5/18/2000 13:53'!requestPassword: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| aFillInTheBlankMorph |	aFillInTheBlankMorph _ self new		setPasswordQuery: queryString		initialAnswer: defaultAnswer		answerHeight: 50		acceptOnCR: acceptBoolean.	aFillInTheBlankMorph responseUponCancel: returnOnCancel.	aWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.	^ aFillInTheBlankMorph getUserResponse! !!HttpUrl methodsFor: 'downloading' stamp: 'bolot 5/18/2000 13:55'!askNamePassword	"Authorization is required by the host site.  Ask the user for a userName and password.  Encode them and store under this realm.  Return false if the user wants to give up."	| user password |	(self confirm: 'Host ', self toText, 'wants a different user and password.  Type them now?' orCancel: [false])		ifFalse: [^ false].	"Note: When Scamper is converted to run under MVC, we'll have to pass in topView in order to decide which FillInTheBlank to call."	user _ FillInTheBlank request: 'User account name?' initialAnswer: '' 				centerAt: Sensor cursorPoint - (50@0).	password _ FillInTheBlank requestPassword: 'Password?'.	Passwords at: realm put: (Authorizer new encode: user password: password).	^ true! !!HttpUrl methodsFor: 'downloading' stamp: 'bolot 5/18/2000 13:11'!checkAuthorization: webDocument retry: retryBlock	"authorization failed if webDocument is a String"	| oldRealm i end encoded |	((webDocument isKindOf: String)		and: [(webDocument beginsWith: 'HTTP/1.0 401')			or: [webDocument beginsWith: 'HTTP/1.1 401']])	ifFalse: [^self].	oldRealm _ realm.	i _ webDocument findString: 'realm="'.	i = 0 ifTrue: [^self].	end _ webDocument indexOf: $" startingAt: i.	realm _ webDocument copyFrom: i+7 to: end.	"realm _ (webDocument findTokens: '""') at: 2."	Passwords ifNil: [Passwords _ Dictionary new].	encoded _ Passwords at: realm ifAbsent: [nil].	(oldRealm ~= realm) & (encoded ~~ nil) 		ifTrue: [^ retryBlock value]		ifFalse: ["ask the user"			self askNamePassword ifTrue: [^ retryBlock value]]! !!HttpUrl methodsFor: 'downloading' stamp: 'bolot 5/18/2000 13:22'!normalizeContents: webDocument	webDocument contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: webDocument content url: webDocument url ].	(webDocument isKindOf: String) ifTrue: [		^MIMEDocument			contentType: 'text/plain'			content: 'error occured retrieving ', self toText, ': ', webDocument].	^webDocument! !!HttpUrl methodsFor: 'downloading' stamp: 'bolot 5/18/2000 13:24'!postFormArgs: args	| contents request |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpPostDocument: self toText args: args				accept: 'application/octet-stream' request: request).	self checkAuthorization: contents retry: [^ self postFormArgs: args].	^self normalizeContents: contents! !!HttpUrl methodsFor: 'downloading' stamp: 'bolot 5/18/2000 13:24'!postMultipartFormArgs: args	| contents request |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpPostMultipart: self toText args: args				accept: 'application/octet-stream' request: request).	self checkAuthorization: contents retry: [^ self postMultipartFormArgs: args].	^self normalizeContents: contents! !!HttpUrl methodsFor: 'downloading' stamp: 'bolot 5/18/2000 13:24'!retrieveContentsArgs: args	| contents request |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpGetDocument: self toText args: args				accept: 'application/octet-stream' request: request).	self checkAuthorization: contents retry: [^self retrieveContentsArgs: args].	^self normalizeContents: contents! !!String methodsFor: 'internet' stamp: 'sma 6/3/2000 20:26'!unescapePercents	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"	| ans c asciiVal pos oldPos specialChars |	ans _ WriteStream on: String new.	oldPos _ 1.	specialChars _ '+%' asCharacterSet.	[pos _ self indexOfAnyOf: specialChars startingAt: oldPos. pos > 0]	whileTrue: [		ans nextPutAll: (self copyFrom: oldPos to: pos - 1).		c _ self at: pos.		c = $+ ifTrue: [ans nextPut: $ ] ifFalse: [			(c = $% and: [pos + 2 <= self size]) ifTrue: [				asciiVal _ (self at: pos+1) asUppercase digitValue * 16 +					(self at: pos+2) asUppercase digitValue.				pos _ pos + 2.				ans nextPut: (Character value: asciiVal)]			ifFalse: [ans nextPut: c]].		oldPos _ pos+1].	ans nextPutAll: (self copyFrom: oldPos to: self size).	^ ans contents! !