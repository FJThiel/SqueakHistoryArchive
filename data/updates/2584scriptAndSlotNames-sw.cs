'From Squeak2.9alpha of 26 July 2000 [latest update: #2574] on 8 September 2000 at 8:54:04 pm'!"Change Set:		scriptAndSlotNames-swDate:			8 September 2000Author:			Scott WallaceInstead of tormenting the etoy user about unacceptable script and inst-var names, now takes whatever the user submits and converts it into something that's acceptable and uses that; no error message will ever be generated after the user submits a putative slot or script name -- a suitable name will always be producedCaution: prerequisite is eToyAdditions at present"!!Player methodsFor: 'slots-user' stamp: 'sw 9/8/2000 16:43'!addInstanceVariable	"Offer the user the opportunity to add an instance variable, and if he goes through with it, actually add it"	| itsName initialValue typeChosen suggestedNames usedNames initialAnswer setterSelector originalString |	suggestedNames _ #('cargo' 'speed' 'weight' 'mzee' 'friml' 'verp' 'znak').	usedNames _ self class instVarNames.	initialAnswer _ suggestedNames detect: [:aName |  (usedNames includes: aName) not] ifNone:		[Utilities keyLike: 'var1'  satisfying: [:aKey | (usedNames includes: aKey) not]].	originalString _ FillInTheBlank request: 'name for new inst var: ' initialAnswer: initialAnswer.	itsName _ ScriptingSystem acceptableSlotNameFrom: originalString forSlotCurrentlyNamed: nil asSlotNameIn: self world: self costume world. 	itsName size == 0 ifTrue: [^ self].		self assureUniClass.	typeChosen _ self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: (SlotInformation new initialize type: typeChosen).	initialValue _ self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self class compileAccessorsFor: itsName.	setterSelector _ Utilities setterSelectorFor: itsName.	(self class allSubInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: #'instance variables'! !!Player methodsFor: 'slots-user' stamp: 'sw 9/8/2000 14:47'!addInstanceVariableNamed: nameSymbol type: typeChosen value: aValue	"Add an instance variable of the given name and type, and initialize it to have the given value"	| initialValue setterSelector |	self assureUniClass.	self slotInfo at: nameSymbol put: (SlotInformation new initialize type: typeChosen).	initialValue _ self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: nameSymbol withValue: aValue.	self class compileAccessorsFor: nameSymbol.	setterSelector _ Utilities setterSelectorFor: nameSymbol.	(self class allSubInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: #'instance variables'! !!Player methodsFor: 'slots-user' stamp: 'sw 9/6/2000 04:36'!renameSlot: oldSlotName	| reply newSlotName |	reply _   FillInTheBlank request: 'New name for "', oldSlotName, '":' initialAnswer: oldSlotName. 	reply size == 0 ifTrue: [^ self].	newSlotName _ ScriptingSystem acceptableSlotNameFrom: reply forSlotCurrentlyNamed:  oldSlotName asSlotNameIn: self world: self costume currentWorld.	self renameSlot: oldSlotName newSlotName: newSlotName! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 9/8/2000 20:22'!renameScript: oldSelector	| reply newSelector aUserScript |	self flag: #deferred.  "Relax the below, yes?"	aUserScript _ self class userScriptForPlayer: self selector: oldSelector.	aUserScript isTextuallyCoded ifTrue:		[self inform: 'Sorry, for now you can only rename tiled scripts'.		^ self].	reply _   FillInTheBlank request: 'Script Name' initialAnswer: oldSelector. 	reply size == 0 ifTrue: [^ self].	reply = oldSelector ifTrue:[^ self beep].	newSelector _ ScriptingSystem acceptableScriptNameFrom: reply  forScriptCurrentlyNamed:  oldSelector asScriptNameIn: self world: costume world.	self renameScript: oldSelector newSelector: newSelector! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 9/5/2000 11:27'!renameScript	"Invoked at user menu request"	| reply aPosition oldSelector dflt oldStatus oldOwner aUserScript newSelector |	oldSelector _ self scriptName.	aUserScript _ playerScripted class userScriptForPlayer: self selector: oldSelector.	aUserScript isTextuallyCoded ifTrue:		[self inform: 'Sorry, for now you can only rename tiled scripts'.		^ self].	oldStatus _ self scriptInstantiation status.	dflt _ self isAnonymous ifTrue: [''] ifFalse: [self scriptTitle].	reply _   FillInTheBlank request: 'Script Name' initialAnswer: dflt. 	reply size == 0 ifTrue: [^ self].	newSelector _ ScriptingSystem acceptableScriptNameFrom: reply  forScriptCurrentlyNamed: oldSelector asScriptNameIn: self playerScripted world: self world.	self titleMorph borderColor: Color black.	scriptName _ newSelector.	playerScripted class atSelector: newSelector putScriptEditor: self.	self scriptInstantiation status: oldStatus.	playerScripted class removeScriptNamed: oldSelector.	playerScripted actorState instantiatedUserScriptsDictionary removeKey: oldSelector.	submorphs first delete.  "the button row"	self addMorphFront: self buttonRowForEditor.  "up to date"	self install.	aPosition _ self position.	oldOwner _ self topRendererOrSelf owner.	self delete	playerScripted costume viewAfreshIn: oldOwner showingScript: scriptName at: aPosition! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 9/8/2000 17:21'!acceptableScriptNameFrom: originalString forScriptCurrentlyNamed: currentName asScriptNameIn: aPlayer world: aWorld	"Produce an acceptable script name, derived from the current name, for aPlayer.  This method will always return a valid script name that will be suitable for use in the given situation, though you might not like its beauty sometimes."	| aString stemAndSuffix proscribed stem suffix putative |	aString _ originalString asIdentifier: false.  "get an identifier not lowercase"	stemAndSuffix _ aString stemAndNumericSuffix.	proscribed _ #(self super thisContext costume costumes dependents true false size).	stem _ stemAndSuffix first.	suffix _ stemAndSuffix last.	putative _ aString asSymbol.	[(putative ~~ currentName) and: [(proscribed includes: putative)		or:	[(aPlayer class tileScriptNames includes: putative)		or: [(aPlayer respondsTo: putative)		or: [(SystemSlotDictionary includesKey: putative)		or: [(ReservedScriptNames includes: putative)		or:	[Smalltalk includesKey: putative]]]]]]]	whileTrue:		[suffix _ suffix + 1.		putative _ (stem, suffix printString) asSymbol].	^ putative! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 9/8/2000 17:20'!acceptableSlotNameFrom: originalString forSlotCurrentlyNamed: currentName asSlotNameIn: aPlayer world: aWorld	"Produce an acceptable slot name, derived from the current name, for aPlayer.  This method will always return a valid slot name that will be suitable for use in the given situation, though you might not like its beauty sometimes."	| aString stemAndSuffix proscribed stem suffix putative |	aString _ originalString asIdentifier: false.  "get an identifier not lowercase"	stemAndSuffix _ aString stemAndNumericSuffix.	proscribed _ #(self super thisContext costume costumes dependents true false size), aPlayer class allInstVarNames.	stem _ stemAndSuffix first.	suffix _ stemAndSuffix last.	putative _ aString asSymbol.		[(putative ~~ currentName) and: [(proscribed includes: putative)		or:	[(aPlayer class tileScriptNames includes: putative)		or: [(aPlayer respondsTo: putative)		or: [(SystemSlotDictionary includesKey: putative)		or: [(ReservedScriptNames includes: putative)		or:	[Smalltalk includesKey: putative]]]]]]]	whileTrue:		[suffix _ suffix + 1.		putative _ (stem, suffix printString) asSymbol].	^ putative! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 9/8/2000 18:22'!isAcceptablePlayerSlotName: aSymbol	"Answer whether the given symbol is a suitable slot name for a player.  It is assumed to be a well-formed inst-var-name already.  No senders at the moment, because the current UI always corrects the input into an acceptable name.  But could return"	self noOtherSenders: #isAcceptablePlayerSlotName:.  "keeps this from getting mentally garbage-collected"	(SystemSlotDictionary includesKey: aSymbol) ifTrue: [^ false].	(ReservedScriptNames includes: aSymbol) ifTrue: [^ false].	(#(costume costumes dependents true false size) includes: aSymbol) ifTrue: [^ false].	^ true! !!String methodsFor: 'converting' stamp: 'sw 9/5/2000 09:03'!asIdentifier: shouldBeCapitalized	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"	| aString firstChar firstLetterPosition |	aString _ self select: [:el | el isAlphaNumeric].	firstLetterPosition _ aString findFirst: [:ch | ch isLetter].	aString _ firstLetterPosition == 0		ifFalse:			[aString copyFrom: firstLetterPosition to: aString size]		ifTrue:			['a', aString].	firstChar _ shouldBeCapitalized ifTrue: [aString first asUppercase] ifFalse: [aString first asLowercase].	^ firstChar asString, (aString copyFrom: 2 to: aString size)"'234Fred987' asIdentifier: false'235Fred987' asIdentifier: true'' asIdentifier: true'()87234' asIdentifier: false'())z>=PPve889  U >' asIdentifier: false"! !StandardScriptingSystem removeSelector: #acceptableScriptNameFrom:asScriptNameIn:world:!StandardScriptingSystem removeSelector: #isAcceptablePlayerScriptName:!Player removeSelector: #addInstanceVariableNamed:type:!