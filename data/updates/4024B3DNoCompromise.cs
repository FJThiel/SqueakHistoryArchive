'From Squeak3.1alpha of 28 February 2001 [latest update: #4021] on 16 May 2001 at 12:43:06 am'!"Change Set:		B3DNoCompromiseDate:			16 May 2001Author:			Andreas RaabThis change set includes a complete reimplementation of 3D hardware acceleration. The new approach goes exclusively for speed and much less for compatibility. It also provides two different approaches for Morphic integration depending upon whether the underlying implementation supports direct frame buffer access or not. Both variants are currently implemented; on Windows we're using direct frame buffer access, on Macs we're using texture compositing. Of course, texture compositing is a lot slower than direct access but it's still faster than having to deal with glReadPixels...Acceleration is available from both, Wonderlands (in the camera's red halo menu) as well as the scene explorer morph (where it is directly integrated in the user interface).Because of the capabilities of modern 3D hardware and APIs various improvements have been made to the general interface of B3DRenderEngine, including a 'polygon mode' (for rendering point/wireframe representation of meshes), points and lines in general, as well as fog (I just needed this so it's part of the interface; also available from the wonderland camera's viewer). More capabilities can and will be added but care must be taken that these are available across varying APIs.Currently, the new scheme supports OpenGL for Macs and Direct3D (DirectX 7) for Windows. DirectX7 was taken because it provides serious improvements in terms of speed and structure (DX7 is the first DX version treating renderer state as renderer state and is therefore much more closely related to OpenGL). An OpenGL implementation of the accelerator for Windows is also available (I'm planning to integrate both D3D and OpenGL at some point so people can use what's best on their machines) but for now only D3D is tested (because my OpenGL drivers crash on me).Porting to *nix should be relatively straightforward given the existance of GLX. The platform dependent code for the OpenGL bindings are a few hundred lines of code mostly concerned with how to interface to the host platform. It should also be possible to implement direct frame buffer support through the use of p-buffers but I have no hardware that does support p-buffers so that remains to be seen.Anyways. Seeing the scene explorer in 1024x768 with 150fps on a Laptop is fun. Running the Nudibranch at roughly 20fps even more :-)"!B3DPrimitiveEngine subclass: #B3DHardwareEngine	instanceVariableNames: 'vpTransform target bufRect handle textures backingForm '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Acceleration'!B3DRenderEngine subclass: #B3DMapperEngine	instanceVariableNames: 'bounds boundsMap '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Engine'!!B3DMapperEngine commentStamp: '<historical>' prior: 0!The mapper engine computes 2D bounding rectangles for arbitrary objects.Instance variables:	bounds	<Rectangle>	The currently recorded bounds for any object.	boundsMap	<IdentityDictionary of: (Object -> Rectangle)> The bounds of all objects.!B3DRenderEngine subclass: #B3DPickerEngine	instanceVariableNames: 'pickMatrix pickList objects maxVtx '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Engine'!B3DEnginePart subclass: #B3DVertexShader	instanceVariableNames: 'lights material materialStack needsLightUpdate needsMaterialUpdate '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Engine'!B3DTexture subclass: #B3DBackingForm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Acceleration'!B3DTexture subclass: #B3DHardwareTexture	instanceVariableNames: 'renderer handle argbMap '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Acceleration'!!B3DHardwareTexture commentStamp: '<historical>' prior: 0!This class represents a texture managed by the hardware. Depending on the underlying 3D implementation, the texture may be directly accessible for blitting operations or it may not. If it is directly accessible, then the 'bits' will provide a surface handle for BitBlt. If not, the bits will shadow the upload contents in the format that matches what the underlying implementation requires. In other words: The format of the texture is always identical with the hardware's assumption so that we can perform dithering etc. to achieve the best effect from within Squeak.WARNING: This class is private to the B3DHardwareEngine; use outside of this context (in particular in client applications) is *STRONGLY* discouraged. Client applications should use regular B3DTextures.!Form subclass: #DisplayScreen	instanceVariableNames: 'clippingBox extraRegions '	classVariableNames: 'DeferringUpdates DisplayChangeSignature ScreenSave '	poolDictionaries: ''	category: 'Graphics-Display Objects'!Morph subclass: #B3DSceneMorph	instanceVariableNames: 'scene myRenderer '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Demo Morphs'!WonderlandMorph subclass: #WonderlandCameraMorph	instanceVariableNames: 'myCamera myControls eventFocus lastCursorPoint mouseUpButton firstPersonControls mode outline currentActor currentPosition currentCanvas currentColor currentNib lastPosition paintMode palette restore backup pickedPoint pickedActor myRenderer '	classVariableNames: ''	poolDictionaries: 'WonderlandConstants '	category: 'Balloon3D-Wonderland Morphs'!!B3DAcceleratorPlugin methodsFor: 'primitives-textures' stamp: 'ar 9/9/2000 15:50'!primitiveAllocateTexture	| h w d result renderer |	self export: true.	interpreterProxy methodArgumentCount = 4		ifFalse:[^interpreterProxy primitiveFail].	h _ interpreterProxy stackIntegerValue: 0.	w _ interpreterProxy stackIntegerValue: 1.	d _ interpreterProxy stackIntegerValue: 2.	renderer _ interpreterProxy stackIntegerValue: 3.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxAllocateTexture(renderer, w, h, d)' inSmalltalk:[-1].	result = -1 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: 5. "args+rcvr"	^interpreterProxy pushInteger: result.! !!B3DAcceleratorPlugin methodsFor: 'primitives-textures' stamp: 'ar 9/9/2000 16:08'!primitiveCompositeTexture	| result translucent y x w h texHandle rendererHandle |	self export: true.	interpreterProxy methodArgumentCount = 7		ifFalse:[^interpreterProxy primitiveFail].	translucent _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	h _ interpreterProxy stackIntegerValue: 1.	w _ interpreterProxy stackIntegerValue: 2.	y _ interpreterProxy stackIntegerValue: 3.	x _ interpreterProxy stackIntegerValue: 4.	texHandle _ interpreterProxy stackIntegerValue: 5.	rendererHandle _ interpreterProxy stackIntegerValue: 6.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxCompositeTexture(rendererHandle, texHandle, x, y, w, h, translucent)' inSmalltalk:[false].	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 7. "args"! !!B3DAcceleratorPlugin methodsFor: 'primitives-textures' stamp: 'ar 9/9/2000 15:50'!primitiveDestroyTexture	| handle result renderer |	self export: true.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	renderer _ interpreterProxy stackIntegerValue: 1.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxDestroyTexture(renderer, handle)' inSmalltalk:[false].	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 2. "pop arg; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-textures' stamp: 'ar 9/9/2000 15:50'!primitiveTextureByteSex	| handle result renderer |	self export: true.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	renderer _ interpreterProxy stackIntegerValue: 1.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxTextureByteSex(renderer, handle)' inSmalltalk:[-1].	result < 0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: 3.	^interpreterProxy pushBool: result.! !!B3DAcceleratorPlugin methodsFor: 'primitives-textures' stamp: 'ar 9/9/2000 15:50'!primitiveTextureDepth	| handle result renderer |	self export: true.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	renderer _ interpreterProxy stackIntegerValue: 1.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxActualTextureDepth(renderer, handle)' inSmalltalk:[-1].	result < 0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: 3.	^interpreterProxy pushInteger: result.! !!B3DAcceleratorPlugin methodsFor: 'primitives-textures' stamp: 'ar 9/9/2000 15:50'!primitiveTextureGetColorMasks	| handle result masks array renderer |	self export: true.	self var: #masks declareC:'int masks[4]'.	interpreterProxy methodArgumentCount = 3		ifFalse:[^interpreterProxy primitiveFail].	array _ interpreterProxy stackObjectValue: 0.	handle _ interpreterProxy stackIntegerValue: 1.	renderer _ interpreterProxy stackIntegerValue: 2.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: array) = interpreterProxy classArray		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: array) = 4		ifFalse:[^interpreterProxy primitiveFail].	result _ self cCode:'b3dxTextureColorMasks(renderer, handle, masks)' inSmalltalk:[false].	result ifFalse:[^interpreterProxy primitiveFail].	0 to: 3 do:[:i|		interpreterProxy storePointer: i ofObject: array withValue:			(interpreterProxy positive32BitIntegerFor: (masks at: i))].	^interpreterProxy pop: 3. "pop args return receiver"! !!B3DAcceleratorPlugin methodsFor: 'primitives-textures' stamp: 'ar 5/14/2001 20:01'!primitiveTextureSurfaceHandle	| handle result renderer |	self export: true.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	renderer _ interpreterProxy stackIntegerValue: 1.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxTextureSurfaceHandle(renderer, handle)' inSmalltalk:[-1].	result < 0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: 3.	^interpreterProxy pushInteger: result! !!B3DAcceleratorPlugin methodsFor: 'primitives-textures' stamp: 'ar 9/9/2000 15:50'!primitiveTextureUpload	| h w d result form bits ppw bitsPtr handle renderer |	self export: true.	self var: #bitsPtr type: 'void*'.	interpreterProxy methodArgumentCount = 3		ifFalse:[^interpreterProxy primitiveFail].	form _ interpreterProxy stackValue: 0.	((interpreterProxy isPointers: form) and:[(interpreterProxy slotSizeOf: form) >= 4])		ifFalse:[^interpreterProxy primitiveFail].	bits _ interpreterProxy fetchPointer: 0 ofObject: form.	w _ interpreterProxy fetchInteger: 1 ofObject: form.	h _ interpreterProxy fetchInteger: 2 ofObject: form.	d _ interpreterProxy fetchInteger: 3 ofObject: form.	ppw _ 32 // d.	(interpreterProxy isWords: bits)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: bits) = (w + ppw - 1 // ppw * h)		ifFalse:[^interpreterProxy primitiveFail].	bitsPtr _ interpreterProxy firstIndexableField: bits.	handle _ interpreterProxy stackIntegerValue: 1.	renderer _ interpreterProxy stackIntegerValue: 2.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxUploadTexture(renderer, handle, w, h, d, bitsPtr)' inSmalltalk:[false].	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 3. "args; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitive support' stamp: 'ar 9/6/2000 22:14'!fetchLightSource: index ofObject: anArray	"Fetch the primitive light source from the given array.	Note: No checks are done within here - that happened in stackLightArrayValue:"	| lightOop |	self inline: true.	self returnTypeC:'void*'.	lightOop _ interpreterProxy fetchPointer: index ofObject: anArray.	^interpreterProxy firstIndexableField: lightOop! !!B3DAcceleratorPlugin methodsFor: 'primitive support' stamp: 'ar 9/6/2000 22:13'!stackLightArrayValue: stackIndex	"Load an Array of B3DPrimitiveLights from the given stack index"	| oop array arraySize |	self inline: false.	array _ interpreterProxy stackObjectValue: stackIndex.	array = nil ifTrue:[^nil].	array = interpreterProxy nilObject ifTrue:[^nil].	(interpreterProxy fetchClassOf: array) = interpreterProxy classArray		ifFalse:[^interpreterProxy primitiveFail].	arraySize _ interpreterProxy slotSizeOf: array.	0 to: arraySize-1 do:[:i|		oop _ interpreterProxy fetchPointer: i ofObject: array.		(interpreterProxy isIntegerObject: oop)			ifTrue:[^interpreterProxy primitiveFail].		((interpreterProxy isWords: oop) and:[(interpreterProxy slotSizeOf: oop) = PrimLightSize])			ifFalse:[^interpreterProxy primitiveFail].	].	^array! !!B3DAcceleratorPlugin methodsFor: 'primitive support' stamp: 'ar 9/6/2000 22:13'!stackMaterialValue: stackIndex	"Load a B3DMaterial from the given stack index"	| oop |	self inline: false.	self returnTypeC:'void *'.	oop _ interpreterProxy stackObjectValue: stackIndex.	oop = nil ifTrue:[^nil].	oop = interpreterProxy nilObject ifTrue:[^nil].	((interpreterProxy isWords: oop) and:[(interpreterProxy slotSizeOf: oop) = MaterialSize])		ifTrue:[^interpreterProxy firstIndexableField: oop].	^nil! !!B3DAcceleratorPlugin methodsFor: 'primitive support' stamp: 'ar 9/6/2000 22:14'!stackMatrix: index	"Load a 4x4 transformation matrix from the interpreter stack.	Return a pointer to the matrix data if successful, nil otherwise."	| oop |	self inline: false.	self returnTypeC:'void*'.	oop _ interpreterProxy stackObjectValue: index.	oop = nil ifTrue:[^nil].	oop = interpreterProxy nilObject ifTrue:[^nil].	((interpreterProxy isWords: oop) and:[(interpreterProxy slotSizeOf: oop) = 16])		ifTrue:[^interpreterProxy firstIndexableField: oop].	^nil! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/9/2000 15:51'!primitiveClearDepthBuffer	| result handle |	self export: true.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxClearDepthBuffer(handle)'.	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 1. "pop args; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/9/2000 15:51'!primitiveClearViewport	| result handle pv rgba |	self export: true.	interpreterProxy methodArgumentCount = 3		ifFalse:[^interpreterProxy primitiveFail].	pv _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	rgba _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	handle _ interpreterProxy stackIntegerValue: 2.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxClearViewport(handle, rgba, pv)'.	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 3. "pop args; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:00'!primitiveCreateRenderer	| h w y x result allowHardware allowSoftware |	self export: true.	interpreterProxy methodArgumentCount = 6		ifFalse:[^interpreterProxy primitiveFail].	h _ interpreterProxy stackIntegerValue: 0.	w _ interpreterProxy stackIntegerValue: 1.	y _ interpreterProxy stackIntegerValue: 2.	x _ interpreterProxy stackIntegerValue: 3.	allowHardware _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 4).	allowSoftware _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 5).	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxCreateRenderer(allowSoftware, allowHardware, x, y, w, h)'.	result < 0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: 7.	^interpreterProxy pushInteger: result.! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 20:59'!primitiveDestroyRenderer	| handle result |	self export: true.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxDestroyRenderer(handle)' inSmalltalk:[false].	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 1. "pop arg; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/9/2000 15:52'!primitiveFinishRenderer	| handle result |	self export: true.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxFinishRenderer(handle)' inSmalltalk:[false].	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 1. "pop arg; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/9/2000 15:52'!primitiveFlushRenderer	| handle result |	self export: true.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxFlushRenderer(handle)' inSmalltalk:[false].	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 1. "pop arg; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/10/2000 00:04'!primitiveGetIntProperty	| handle prop result |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	prop _ interpreterProxy stackIntegerValue: 0.	handle _ interpreterProxy stackIntegerValue: 1.	result _ self cCode:'b3dxGetIntProperty(handle, prop)'.	interpreterProxy pop: 3. "args+rcvr"	^interpreterProxy pushInteger: result! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:11'!primitiveGetRendererColorMasks	| handle result masks array |	self export: true.	self var: #masks declareC:'int masks[4]'.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	array _ interpreterProxy stackObjectValue: 0.	handle _ interpreterProxy stackIntegerValue: 1.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: array) = interpreterProxy classArray		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: array) = 4		ifFalse:[^interpreterProxy primitiveFail].	result _ self cCode:'b3dxGetRendererColorMasks(handle, masks)' inSmalltalk:[false].	result ifFalse:[^interpreterProxy primitiveFail].	0 to: 3 do:[:i|		interpreterProxy storePointer: i ofObject: array withValue:			(interpreterProxy positive32BitIntegerFor: (masks at: i))].	^interpreterProxy pop: 2. "pop args return receiver"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:41'!primitiveGetRendererSurfaceDepth	| handle result |	self export: true.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxGetRendererSurfaceDepth(handle)' inSmalltalk:[-1].	result < 0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: 2. "args+rcvr"	^interpreterProxy pushInteger: result! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:09'!primitiveGetRendererSurfaceHandle	| handle result |	self export: true.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxGetRendererSurfaceHandle(handle)' inSmalltalk:[-1].	result < 0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: 2. "args+rcvr"	^interpreterProxy pushInteger: result! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:41'!primitiveGetRendererSurfaceHeight	| handle result |	self export: true.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxGetRendererSurfaceHeight(handle)' inSmalltalk:[-1].	result < 0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: 2. "args+rcvr"	^interpreterProxy pushInteger: result! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:41'!primitiveGetRendererSurfaceWidth	| handle result |	self export: true.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxGetRendererSurfaceWidth(handle)' inSmalltalk:[-1].	result < 0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pop: 2. "args+rcvr"	^interpreterProxy pushInteger: result! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:00'!primitiveIsOverlayRenderer	| handle result |	self export: true.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxIsOverlayRenderer(handle)' inSmalltalk:[false].	interpreterProxy pop: 2. "args+rcvr"	^interpreterProxy pushBool: result.! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/9/2000 15:52'!primitiveRenderVertexBuffer	| idxCount vtxCount vtxArray idxArray texHandle primType result flags handle |	self export: true.	self var: #idxArray type: 'int *'.	self var: #vtxArray type: 'float *'.	interpreterProxy methodArgumentCount = 8		ifFalse:[^interpreterProxy primitiveFail].	idxCount _ interpreterProxy stackIntegerValue: 0.	vtxCount _ interpreterProxy stackIntegerValue: 2.	texHandle _ interpreterProxy stackIntegerValue: 4.	flags _ interpreterProxy stackIntegerValue: 5.	primType _ interpreterProxy stackIntegerValue: 6.	handle _ interpreterProxy stackIntegerValue: 7.	interpreterProxy failed ifTrue:[^nil].	vtxArray _ self stackPrimitiveVertexArray: 3 ofSize: vtxCount.	idxArray _ self stackPrimitiveIndexArray: 1 ofSize: idxCount validate: true forVertexSize: vtxCount.	(vtxArray == nil or:[idxArray == nil 		or:[primType < 1 or:[primType > PrimTypeMax 			or:[interpreterProxy failed]]]])				ifTrue:[^interpreterProxy primitiveFail].	result _ self cCode:'b3dxRenderVertexBuffer(handle, primType, flags, texHandle, vtxArray, vtxCount, idxArray, idxCount)' inSmalltalk:[false].	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 8. "pop args; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/9/2000 15:52'!primitiveRendererVersion	self export: true.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	^interpreterProxy pushInteger: 1.! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 4/19/2001 02:19'!primitiveSetBufferRect	"Primitive. Set the buffer rectangle (e.g., the pixel area on screen) to use for this renderer.	The viewport is positioned within the buffer rectangle."	| h w y x result handle |	self export: true.	interpreterProxy methodArgumentCount = 5		ifFalse:[^interpreterProxy primitiveFail].	h _ interpreterProxy stackIntegerValue: 0.	w _ interpreterProxy stackIntegerValue: 1.	y _ interpreterProxy stackIntegerValue: 2.	x _ interpreterProxy stackIntegerValue: 3.	handle _ interpreterProxy stackIntegerValue: 4.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxSetBufferRect(handle, x, y, w, h)'.	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 5. "pop args; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 5/15/2001 16:11'!primitiveSetFog	| result handle rgba density fogType stop start |	self export: true.	self var: #density type:'double'.	self var: #start type: 'double'.	self var: #stop type: 'double'.	interpreterProxy methodArgumentCount = 6		ifFalse:[^interpreterProxy primitiveFail].	rgba _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	stop _ interpreterProxy floatValueOf: (interpreterProxy stackValue: 1).	start _ interpreterProxy floatValueOf: (interpreterProxy stackValue: 2).	density _ interpreterProxy floatValueOf: (interpreterProxy stackValue: 3).	fogType _ interpreterProxy stackIntegerValue: 4.	handle _ interpreterProxy stackIntegerValue: 5.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxSetFog(handle, fogType, density, start, stop, rgba)'.	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 6. "pop args; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/10/2000 00:05'!primitiveSetIntProperty	| handle prop result value |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 3		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy stackIntegerValue: 0.	prop _ interpreterProxy stackIntegerValue: 1.	handle _ interpreterProxy stackIntegerValue: 2.	result _ self cCode:'b3dxSetIntProperty(handle, prop, value)'.	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 3. "args; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/9/2000 15:52'!primitiveSetLights	| lightArray lightCount light handle |	self export: true.	self inline: false.	self var: #light type: 'void*'.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	lightArray _ self stackLightArrayValue: 0.	handle _ interpreterProxy stackIntegerValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self b3dxDisableLights: handle)		ifFalse:[^interpreterProxy primitiveFail].	lightArray == nil ifTrue:[^nil].	lightCount _ interpreterProxy slotSizeOf: lightArray.	"For each enabled light source"	0 to: lightCount-1 do:[:i|		light _ self fetchLightSource: i ofObject: lightArray.		(self cCode:'b3dxLoadLight(handle, i, light)' inSmalltalk:[false])			ifFalse:[^interpreterProxy primitiveFail].	].	^interpreterProxy pop: 2. "args; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/9/2000 15:52'!primitiveSetMaterial	| material handle |	self export: true.	self inline: false.	self var: #material type: 'void*'.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	material _ self stackMaterialValue: 0.	handle _ interpreterProxy stackIntegerValue: 1.	(self cCode:'b3dxLoadMaterial(handle, material)' inSmalltalk:[false])		ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 2. "args; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/9/2000 15:52'!primitiveSetTransform	"Transform an entire vertex buffer using the supplied modelview and projection matrix."	| projectionMatrix modelViewMatrix handle |	self export: true.	self inline: false.	self var: #projectionMatrix declareC:'float *projectionMatrix'.	self var: #modelViewMatrix declareC:'float *modelViewMatrix'.	interpreterProxy methodArgumentCount = 3		ifFalse:[^interpreterProxy primitiveFail].	projectionMatrix _ self stackMatrix: 0.	modelViewMatrix _ self stackMatrix: 1.	handle _ interpreterProxy stackIntegerValue: 2.	interpreterProxy failed ifTrue:[^nil].	self cCode: 'b3dxSetTransform(handle, modelViewMatrix, projectionMatrix)'.	^interpreterProxy pop: 3. "Leave rcvr on stack"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 4/20/2001 01:47'!primitiveSetVerboseLevel	| result level |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	level _ interpreterProxy stackIntegerValue: 0.	result _ self cCode:'b3dxSetVerboseLevel(level)'.	interpreterProxy pop: 2. "args+rcvr"	^interpreterProxy pushInteger: result! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/9/2000 15:53'!primitiveSetViewport	| h w y x result handle |	self export: true.	interpreterProxy methodArgumentCount = 5		ifFalse:[^interpreterProxy primitiveFail].	h _ interpreterProxy stackIntegerValue: 0.	w _ interpreterProxy stackIntegerValue: 1.	y _ interpreterProxy stackIntegerValue: 2.	x _ interpreterProxy stackIntegerValue: 3.	handle _ interpreterProxy stackIntegerValue: 4.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxSetViewport(handle, x, y, w, h)'.	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 5. "pop args; return rcvr"! !!B3DAcceleratorPlugin methodsFor: 'primitives-renderer' stamp: 'ar 9/9/2000 15:53'!primitiveSwapRendererBuffers	| handle result |	self export: true.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	handle _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue:[^nil].	result _ self cCode:'b3dxSwapRendererBuffers(handle)' inSmalltalk:[false].	result ifFalse:[^interpreterProxy primitiveFail].	^interpreterProxy pop: 1. "pop arg; return rcvr"! !!B3DAcceleratorPlugin class methodsFor: 'translation' stamp: 'ar 5/15/2001 02:16'!headerFile^'/* Header file for 3D accelerator plugin *//* Vertex buffer flags */#define B3D_VB_TRACK_AMBIENT 1#define B3D_VB_TRACK_DIFFUSE 2#define B3D_VB_TRACK_SPECULAR 4#define B3D_VB_TRACK_EMISSION 8#define B3D_VB_HAS_NORMALS 16#define B3D_VB_HAS_TEXTURES 32#define B3D_VB_TWO_SIDED 64#define B3D_VB_LOCAL_VIEWER 128typedef struct B3DPrimitiveVertex {	float position[3];	float normal[3];	float texCoord[2];	float rasterPos[4];	int pixelValue32;	int clipFlags;	int windowPos[2];} B3DPrimitiveVertex;typedef struct B3DPrimitiveMaterial {	float ambient[4];	float diffuse[4];	float specular[4];	float emission[4];	float shininess;} B3DPrimitiveMaterial;/* Light type flags */#define B3D_LIGHT_POSITIONAL 0x0001#define B3D_LIGHT_DIRECTIONAL 0x0002#define B3D_LIGHT_ATTENUATED 0x0004#define B3D_LIGHT_HAS_SPOT 0x0008/* Light color flags */#define B3D_LIGHT_AMBIENT 0x0100#define B3D_LIGHT_DIFFUSE 0x0200#define B3D_LIGHT_SPECULAR 0x0400typedef struct B3DPrimitiveLight {	float ambient[4];	float diffuse[4];	float specular[4];	float position[3];	float direction[3];	float attenuation[3];	int flags;	float spotMinCos;	float spotMaxCos;	float spotDeltaCos;	float spotExponent;} B3DPrimitiveLight;/* Win32 defaults to D3D everyone else to OpenGL */#if defined(WIN32) && !!defined(WIN32_NO_D3D)#define B3DX_D3D#else#define B3DX_GL#endif#if defined(B3DX_GL)#define b3dxInitialize            glInitialize#define b3dxShutdown              glShutdown#define b3dxAllocateTexture       glAllocateTexture#define b3dxDestroyTexture        glDestroyTexture#define b3dxActualTextureDepth    glActualTextureDepth#define b3dxTextureColorMasks     glTextureColorMasks#define b3dxUploadTexture         glUploadTexture#define b3dxTextureByteSex        glTextureByteSex#define b3dxTextureSurfaceHandle glTextureSurfaceHandle#define b3dxCompositeTexture      glCompositeTexture#define b3dxCreateRenderer        glCreateRenderer#define b3dxDestroyRenderer        glDestroyRenderer#define b3dxIsOverlayRenderer     glIsOverlayRenderer#define b3dxGetRendererSurfaceHandle glGetRendererSurfaceHandle#define b3dxGetRendererSurfaceWidth glGetRendererSurfaceWidth#define b3dxGetRendererSurfaceHeight glGetRendererSurfaceHeight#define b3dxGetRendererSurfaceDepth glGetRendererSurfaceDepth#define b3dxGetRendererColorMasks glGetRendererColorMasks#define b3dxSetBufferRect           glSetBufferRect#define b3dxSetViewport           glSetViewport#define b3dxClearDepthBuffer      glClearDepthBuffer#define b3dxClearViewport          glClearViewport#define b3dxRenderVertexBuffer   glRenderVertexBuffer#define b3dxSetTransform          glSetTransform#define b3dxDisableLights          glDisableLights#define b3dxLoadLight             glLoadLight#define b3dxLoadMaterial          glLoadMaterial#define b3dxFlushRenderer        glFlushRenderer#define b3dxFinishRenderer       glFinishRenderer#define b3dxSwapRendererBuffers glSwapRendererBuffers#define b3dxGetIntProperty       glGetIntProperty#define b3dxSetIntProperty       glSetIntProperty#define b3dxSetVerboseLevel     glSetVerboseLevel#define b3dxSetFog               glSetFog#endif#if defined(B3DX_D3D)#define b3dxInitialize            d3dInitialize#define b3dxShutdown              d3dShutdown#define b3dxAllocateTexture       d3dAllocateTexture#define b3dxDestroyTexture        d3dDestroyTexture#define b3dxActualTextureDepth    d3dActualTextureDepth#define b3dxTextureColorMasks     d3dTextureColorMasks#define b3dxUploadTexture         d3dUploadTexture#define b3dxTextureByteSex        d3dTextureByteSex#define b3dxTextureSurfaceHandle d3dTextureSurfaceHandle#define b3dxCompositeTexture      d3dCompositeTexture#define b3dxCreateRenderer        d3dCreateRenderer#define b3dxDestroyRenderer        d3dDestroyRenderer#define b3dxGetRendererSurfaceHandle d3dGetRendererSurfaceHandle#define b3dxGetRendererSurfaceWidth d3dGetRendererSurfaceWidth#define b3dxGetRendererSurfaceHeight d3dGetRendererSurfaceHeight#define b3dxGetRendererSurfaceDepth d3dGetRendererSurfaceDepth#define b3dxGetRendererColorMasks d3dGetRendererColorMasks#define b3dxIsOverlayRenderer    d3dIsOverlayRenderer#define b3dxSetBufferRect           d3dSetBufferRect#define b3dxSetViewport           d3dSetViewport#define b3dxClearDepthBuffer      d3dClearDepthBuffer#define b3dxClearViewport          d3dClearViewport#define b3dxRenderVertexBuffer   d3dRenderVertexBuffer#define b3dxSetTransform          d3dSetTransform#define b3dxDisableLights          d3dDisableLights#define b3dxLoadLight             d3dLoadLight#define b3dxLoadMaterial          d3dLoadMaterial#define b3dxFlushRenderer        d3dFlushRenderer#define b3dxFinishRenderer       d3dFinishRenderer#define b3dxSwapRendererBuffers d3dSwapRendererBuffers#define b3dxGetIntProperty       d3dGetIntProperty#define b3dxSetIntProperty       d3dSetIntProperty#define b3dxSetVerboseLevel     d3dSetVerboseLevel#define b3dxSetFog               d3dSetFog#endif/* module initialization support */int b3dxInitialize(void); /* return true on success, false on error */int b3dxShutdown(void); /* return true on success, false on error *//* Texture support primitives */int b3dxAllocateTexture(int renderer, int w, int h, int d); /* return handle or -1 on error */int b3dxDestroyTexture(int renderer, int handle); /* return true on success, false on error */int b3dxActualTextureDepth(int renderer, int handle); /* return depth or <0 on error */int b3dxTextureColorMasks(int renderer, int handle, int masks[4]);  /* return true on success, false on error */int b3dxUploadTexture(int renderer, int handle, int w, int h, int d, void* bits); /* return true on success, false on error */int b3dxTextureByteSex(int renderer, int handle); /* return > 0 for MSB, = 0 for LSB, < 0 for error */int b3dxTextureSurfaceHandle(int renderer, int handle); /* return handle or <0 if error */int b3dxCompositeTexture(int renderer, int handle, int x, int y, int w, int h, int translucent); /* return true on success; else false *//* Renderer primitives */int b3dxCreateRenderer(int allowSoftware, int allowHardware, int x, int y, int w, int h); /* return handle or -1 on error */int b3dxDestroyRenderer(int handle); /* return true on success, else false */int b3dxIsOverlayRenderer(int handle); /* return true/false */int b3dxSetBufferRect(int handle, int x, int y, int w, int h); /* return true on success, false on error */int b3dxGetRendererSurfaceHandle(int handle); /* return handle or <0 if error */int b3dxGetRendererSurfaceWidth(int handle); /* return width or <0 if error */int b3dxGetRendererSurfaceHeight(int handle); /* return height or <0 if error */int b3dxGetRendererSurfaceDepth(int handle); /* return depth or <0 if error */int b3dxGetRendererColorMasks(int handle, int *masks); /* return true on success, false on error */int b3dxSetViewport(int handle, int x, int y, int w, int h); /* return true on success, false on error */int b3dxClearDepthBuffer(int handle); /* return true on success, false on error */int b3dxClearViewport(int handle, unsigned int rgba, unsigned int pv); /* return true on success, else false */int b3dxSetTransform(int handle, float *modelView, float *projection);int b3dxDisableLights(int handle);int b3dxLoadLight(int handle, int index, B3DPrimitiveLight *light);int b3dxLoadMaterial(int handle, B3DPrimitiveMaterial *material);int b3dxRenderVertexBuffer(int handle, int primType, int flags, int texHandle, float *vtxArray, int vtxSize, int *idxArray, int idxSize); /* return true on success, false on error */int b3dxFlushRenderer(int handle);int b3dxFinishRenderer(int handle);int b3dxSwapRendererBuffers(int handle);int b3dxGetIntProperty(int handle, int prop);int b3dxSetIntProperty(int handle, int prop, int value);int b3dxSetVerboseLevel(int level);int b3dxSetFog(int handle, int fogType, double density, double rangeStart, double rangeEnd, int rgba);'.! !!B3DAcceleratorPlugin class methodsFor: 'translation' stamp: 'ar 4/19/2001 02:21'!moduleName	^'B3DAcceleratorPlugin'! !!B3DClipperPlugin methodsFor: 'primitives' stamp: 'ar 4/20/2001 04:06'!b3dMapVertexBuffer	"Primitive. Determine the bounds for all vertices in the vertex buffer."	| vtxCount vtxArray boxArray |	self export: true.	self inline: false.	self var: #vtxArray declareC:'void *vtxArray'.	interpreterProxy methodArgumentCount = 3		ifFalse:[^interpreterProxy primitiveFail].	boxArray _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy fetchClassOf: boxArray) = interpreterProxy classArray		and:[(interpreterProxy slotSizeOf: boxArray) = 4])			ifFalse:[^interpreterProxy primitiveFail].	vtxCount _ interpreterProxy stackIntegerValue: 1.	interpreterProxy failed ifTrue:[^nil].	vtxArray _ self stackPrimitiveVertexArray: 2 ofSize: vtxCount.	(vtxArray == nil or:[interpreterProxy failed])		ifTrue:[^interpreterProxy primitiveFail].	self mapVB: vtxArray ofSize: vtxCount into: boxArray.	interpreterProxy failed ifFalse:[		interpreterProxy pop: 3. "pop args; return rcvr"	].! !!B3DClipperPlugin methodsFor: 'clipping' stamp: 'ar 5/15/2001 18:29'!mapVB: vtxArray ofSize: vtxCount into: boxArray	| left right top bottom vtxPtr flags w x y |	self var: #vtxPtr declareC:'float *vtxPtr'.	self var: #vtxArray declareC:'void *vtxArray'.	self var: #x declareC:'double x'.	self var: #y declareC:'double y'.	self var: #w declareC:'double w'.	self var: #left declareC:'double left'.	self var: #right declareC:'double right'.	self var: #top declareC:'double top'.	self var: #bottom declareC:'double bottom'.	vtxPtr _ self cCoerce: vtxArray to: 'float *'.	1 to: vtxCount do:[:i|		flags _ (self cCoerce: vtxPtr to:'int *') at: PrimVtxClipFlags.		w _ vtxPtr at: PrimVtxRasterPosW.		w = 0.0 ifFalse:[w _ 1.0 / w].		(flags bitAnd: OutLeftBit) ~= 0			ifTrue:[x _ -1.0]			ifFalse:[(flags bitAnd: OutRightBit) ~= 0				ifTrue:[x _ 1.0]				ifFalse:[x _ (vtxPtr at: PrimVtxRasterPosX) * w]].		(flags bitAnd: OutTopBit) ~= 0			ifTrue:[y _ -1.0]			ifFalse:[(flags bitAnd: OutBottomBit) ~= 0				ifTrue:[y _ 1.0]				ifFalse:[y _ (vtxPtr at: PrimVtxRasterPosX) * w]].		i = 1 ifTrue:[			left _ right _ x.			top _ bottom _ y.		].		x < left ifTrue:[left _ x].		x > right ifTrue:[right _ x].		y < top ifTrue:[top _ y].		y > bottom ifTrue:[bottom _ y].		vtxPtr _ vtxPtr + PrimVertexSize.	].	interpreterProxy storePointer: 0 ofObject: boxArray		withValue: (interpreterProxy floatObjectOf: left).	interpreterProxy storePointer: 1 ofObject: boxArray		withValue: (interpreterProxy floatObjectOf: top).	interpreterProxy storePointer: 2 ofObject: boxArray		withValue: (interpreterProxy floatObjectOf: right).	interpreterProxy storePointer: 3 ofObject: boxArray		withValue: (interpreterProxy floatObjectOf: bottom).! !!B3DPrimitiveRasterizer methodsFor: 'initialize' stamp: 'ar 4/19/2001 03:50'!clipRect: aRectangle	super clipRect: aRectangle.	(state notNil and:[state bitBlt notNil]) ifTrue:[state bitBlt clipRect: aRectangle].! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 9/9/2000 23:56'!cullFace: aSymbol	"Set backface culling. aSymbol must be either #cw, #ccw or nil."! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 5/15/2001 02:13'!fogType: aSymbol density: aNumber rangeStart: fogRangeStart rangeEnd: fogRangeEnd color: aColor	"Unsupported here"! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:13'!lineWidth	"Return the current line width"	^0! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:13'!lineWidth: aNumber	"Set the current line width"! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:13'!pointSize	"Return the current point size"	^0! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:13'!pointSize: aNumber	"Set the current point size"! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:14'!polygonMode	"Return the current polygon mode (either #points, #lines or nil)"	^nil! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:14'!polygonMode: aSymbol	"Set the current polygon mode (either #points, #lines or nil)"! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 00:20'!swapInterval	"Return the swap interval for the receiver (only in HW implementations)."	^0! !!B3DRenderEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 00:20'!swapInterval: aNumber	"Set the swap interval for the receiver (only in HW implementations)."! !!B3DRenderEngine methodsFor: 'initialize' stamp: 'ar 9/8/2000 23:04'!destroy	"Utility - destroy all resources associated with any part of the engine"	transformer ifNotNil:[transformer destroy].	shader ifNotNil:[shader destroy].	clipper ifNotNil:[clipper destroy].	rasterizer ifNotNil:[rasterizer destroy].	transformer _ shader _ clipper _ rasterizer _ nil.! !!B3DRenderEngine methodsFor: 'mapping' stamp: 'ar 9/9/2000 03:00'!asMapperEngine	^B3DMapperEngine new loadFrom: self! !!B3DRenderEngine methodsFor: 'morphic-support' stamp: 'ar 9/7/2000 23:00'!restoreMorphicBackground: aRectangle under: aMorph	"If necessary upload the contents of aRectangle from the rendering target into the engine."! !!B3DRenderEngine methodsFor: 'morphic-support' stamp: 'ar 9/7/2000 23:01'!restoreMorphicForeground: aRectangle above: aMorph	"If necessary upload the contents of aRectangle from the rendering target into the engine."! !!B3DRenderEngine methodsFor: 'testing' stamp: 'ar 4/19/2001 05:49'!isAccelerated	^false! !!B3DHardwareEngine methodsFor: 'initialize' stamp: 'ar 5/15/2001 18:34'!bufferRect: box	"Set and validate the receiver's buffer rectangle"	bufRect = box ifTrue:[^self].	(self primRender: handle setBufferRectX: box left y: box top w: box width h: box height) ifNil:[		"Failed to set the buffer rect. Destroy the receiver and start over."		self destroy.		^nil].	"We did change the buffer rect; make sure our target is up to date"	self initializeTarget.	^self! !!B3DHardwareEngine methodsFor: 'initialize' stamp: 'ar 4/19/2001 03:38'!destroy	super destroy.	textures ifNotNil:[textures do:[:tex| tex destroy]].	self primDestroyRenderer: handle.	handle _ nil.	textures _ target _ nil.! !!B3DHardwareEngine methodsFor: 'initialize' stamp: 'ar 9/9/2000 16:16'!finish	self primFinish: handle.! !!B3DHardwareEngine methodsFor: 'initialize' stamp: 'ar 9/8/2000 16:10'!flush	self primFlush: handle! !!B3DHardwareEngine methodsFor: 'initialize' stamp: 'ar 5/15/2001 18:31'!initialize	super initialize.	textures _ IdentityDictionary new: 37.	backingForm _ B3DBackingForm extent: 64@64 depth: 32.! !!B3DHardwareEngine methodsFor: 'initialize' stamp: 'ar 5/14/2001 21:39'!initializeIn: bounds	handle _ self primCreateRendererSW: true hw: true 				x: bounds left y: bounds top w: bounds width h: bounds height.	bufRect _ bounds.	handle ifNil:[^nil].	self initializeTarget.	^self! !!B3DHardwareEngine methodsFor: 'initialize' stamp: 'ar 5/14/2001 21:41'!initializeTarget	"See if the renderer exposes its rendering target for blts.	If so, initialize the rendere's target with a form that we can use."	| targetHandle targetWidth targetHeight targetDepth rgbaBitMasks |	targetHandle _ self primRenderGetSurfaceHandle: handle.	targetHandle ifNil:[^target _ nil]. "nope"	targetWidth _ self primRenderGetSurfaceWidth: handle.	targetHeight _ self primRenderGetSurfaceHeight: handle.	targetDepth _ self primRenderGetSurfaceDepth: handle.	rgbaBitMasks _ Array new: 4.	self primRender: handle getColorMasksInto: rgbaBitMasks.	"Now we're all set up. Create the target form."	target _ ExternalForm extent: targetWidth@targetHeight depth: targetDepth bits: nil.	target setExternalHandle: targetHandle on: nil. "Since the form will be automatically destroyed"	target colormapFromARGB: (ColorMap mappingFromARGB: rgbaBitMasks).! !!B3DHardwareEngine methodsFor: 'initialize' stamp: 'ar 5/15/2001 18:31'!reset	super reset.	self primRender: handle setModelView: nil projection: nil.	self primRender: handle setLights: nil.	self primRender: handle setMaterial: nil.! !!B3DHardwareEngine methodsFor: 'initialize' stamp: 'ar 5/14/2001 23:08'!swapBuffers	"Swap the receiver's buffers. Return true if successful, false otherwise"	^(self primSwapBuffers: handle) notNil! !!B3DHardwareEngine methodsFor: 'accessing' stamp: 'ar 9/8/2000 16:54'!target	^target! !!B3DHardwareEngine methodsFor: 'accessing' stamp: 'ar 9/8/2000 16:12'!target: aForm	"Set the rendering target"	target _ aForm.	^rasterizer target: aForm! !!B3DHardwareEngine methodsFor: 'accessing' stamp: 'ar 5/15/2001 18:33'!viewport: aRectangle	super viewport: aRectangle.	self privateSetViewport: aRectangle.! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 9/8/2000 16:09'!clearDepthBuffer	self primClearDepthBuffer: handle.! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 4/19/2001 03:51'!clearViewport: aColor	| cc |	cc _ aColor asColor.	self primRender: handle 			clearViewport: (cc pixelWordForDepth: 32)			with: 0 "(target pixelWordFor: cc)".! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 00:01'!cullFace	"Return the current culling mode"	| value |	value _ self primRender: handle getProperty: 1.	value = 1 ifTrue:[^#cw].	value = -1 ifTrue:[^#ccw].	^nil! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 00:32'!cullFace: aSymbol	"Set backface culling. aSymbol must be either #cw, #ccw or nil."	| value |	value _ aSymbol == #cw ifTrue:[1] ifFalse:[				aSymbol == #ccw ifTrue:[-1] ifFalse:[0]].	self primRender: handle setProperty: 1 toInteger: value.! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 5/15/2001 02:13'!fogType: aSymbol density: aNumber rangeStart: fogRangeStart rangeEnd: fogRangeEnd color: aColor	"Set the current fog mode. aSymbol must be either one of #none, #linear, #exp, or #exp2."	| type |	type _ 0.	aSymbol == #linear ifTrue:[type _ 1].	aSymbol == #exp ifTrue:[type _ 2].	aSymbol == #exp2 ifTrue:[type _ 3].	self primRender: handle		setFog: type		density: aNumber asFloat		rangeStart: fogRangeStart asFloat		rangeEnd: fogRangeEnd asFloat		color: aColor pixelValue32.! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:17'!lineWidth	"Return the current line width"	^self primRender: handle getProperty: 4.! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:17'!lineWidth: aNumber	"Set the current line width"	^self primRender: handle setProperty: 4 toInteger: aNumber! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:16'!pointSize	"Return the current point size"	^self primRender: handle getProperty: 3.! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:17'!pointSize: aNumber	"Set the current point size"	^self primRender: handle setProperty: 3 toInteger: aNumber.! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:16'!polygonMode	"Return the current polygon mode (either #points, #lines or nil)"	| value |	value _ self primRender: handle getProperty: 2.	value = 1 ifTrue:[^#lines].	value = 2 ifTrue:[^#points].	^nil! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:15'!polygonMode: aSymbol	"Set the current polygon mode (either #points, #lines or nil)"	| value |	value _ aSymbol == #lines ifTrue:[1] ifFalse:[				aSymbol == #points ifTrue:[2] ifFalse:[0]].	self primRender: handle setProperty: 2 toInteger: value.! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:14'!swapInterval	"Return the swap interval for the receiver (only in HW implementations).	The swap interval is defined as:		0	-	don't wait for vertical blank.		1	-	swap only on vertical blank.		n	-	swap only every n vertical blanks."	self primRender: handle getProperty: -1.! !!B3DHardwareEngine methodsFor: 'attributes' stamp: 'ar 9/10/2000 02:14'!swapInterval: interval	"Set the swap interval for the receiver (only in HW implementations).	The swap interval is defined as:		0	-	don't wait for vertical blank.		1	-	swap only on vertical blank.		n	-	swap only every n vertical blanks."	self primRender: handle setProperty: -1 toInteger: interval.! !!B3DHardwareEngine methodsFor: 'testing' stamp: 'ar 4/19/2001 05:49'!isAccelerated	^true! !!B3DHardwareEngine methodsFor: 'testing' stamp: 'ar 5/14/2001 20:56'!isOverlayRenderer	"Return true if the renderer is associated with a target that is always in front of Squeak's host window (such as when the renderer is bound to a separate OS window). If this is the case, then the renderer must be destroyed prior to actions that may result in somebody else attempting to draw in the occupied area. As an example, dragging a morph around that contains such an overlay renderer would not restore the original region of this renderer."	^self primRenderIsOverlay: handle! !!B3DHardwareEngine methodsFor: 'morphic-support' stamp: 'ar 9/9/2000 16:10'!compositeTexture: aTexture at: aPoint translucent: aBool	"Composite the given texture at aPoint into the receiver."	self primRender: handle		compositeTexture: aTexture getExternalHandle		x: aPoint x		y: aPoint y		w: aTexture width		h: aTexture height		translucent: aBool.! !!B3DHardwareEngine methodsFor: 'morphic-support' stamp: 'ar 5/14/2001 22:03'!provideOverlayCanvasDuring: aBlock	"Hand the sender a canvas that can be used for overlayed drawing.	For now, we only provide one for renderers with direct frame buffer access.	At some point I really want to revisit this scheme and use the overlay	canvas for drawing the morphs in front but I don't have the time right now."	target ifNil:[^self].	aBlock value: target getCanvas.! !!B3DHardwareEngine methodsFor: 'morphic-support' stamp: 'ar 5/14/2001 22:46'!restoreMorphicBackground: aRectangle under: aMorph	"If necessary upload the contents of aRectangle from the rendering target into the engine."	| backingTexture x0 y0 x1 y1 y x |	target ifNotNil:["It's a lot simpler and faster to do it this way"		^self displayForm: Display on: target from: aRectangle origin.	].	backingTexture _ self allocateOrRecycleTexture: backingForm.	x0 _ aRectangle left truncated.	y0 _ aRectangle top truncated.	x1 _ aRectangle right truncated.	y1 _ aRectangle bottom truncated.	y _ y0.	[y < y1] whileTrue:[		x _ x0.		[x < x1] whileTrue:[			Display displayOn: backingForm at: (x@y) negated.			"@@@ FIXME: Fix #displayOn: to use real color map if needed"			self displayForm: backingForm on: backingTexture.			self uploadTexture: backingTexture.			self compositeTexture: backingTexture at: x@y translucent: false.			x _ x + backingTexture width.		].		y _ y + backingTexture height.	].! !!B3DHardwareEngine methodsFor: 'morphic-support' stamp: 'ar 5/14/2001 22:04'!restoreMorphicForeground: aRectangle above: aMorph	"If necessary upload the contents of aRectangle from the rendering target into the engine."	| backingTexture x0 y0 x1 y1 y x backingBox box texRect any |	target ifNotNil:[		"As usual, it's a lot faster and easier if we have framebuffer access"		any _ false.		target getCanvas translateBy: aRectangle origin negated during:[:canvas|			aMorph morphsInFrontOverlapping: aRectangle do:[:m|				"Note: if there are overlaps we need to sync the receiver"				any ifFalse:[self finish].				any _ true.				canvas transformBy: m transformFromWorld inverseTransformation						clippingTo: aRectangle						during:[:c| c fullDrawMorph: m]]].		^self].	"Compute the backing box; e.g., the area that needs compositing"	backingBox _ nil.	aMorph morphsInFrontOverlapping: aRectangle do:[:m|		box _ m fullBoundsInWorld intersect: aRectangle.		box area > 0 ifTrue:[			backingBox == nil 				ifTrue:[backingBox _ box]				ifFalse:[backingBox _ backingBox quickMerge: box]]].	backingBox == nil ifTrue:[^self].	backingTexture _ self allocateOrRecycleTexture: backingForm.	x0 _ backingBox left truncated.	y0 _ backingBox top truncated.	x1 _ backingBox right truncated.	y1 _ backingBox bottom truncated.	y _ y0.	[y < y1] whileTrue:[		x _ x0.		[x < x1] whileTrue:[			"Clean up texture - in many cases we might not have to draw anything"			backingForm hasBeenModified: false.			"The current drawing rectangle"			texRect _ x@y extent: backingForm extent.			"Draw the current patch"			backingForm getCanvas translateBy: (x@y) negated during:[:canvas|				aMorph morphsInFrontOverlapping: texRect do:[:m|					canvas transformBy: m transformFromWorld inverseTransformation							clippingTo: texRect							during:[:c| c fullDrawMorph: m]]].			backingForm hasBeenModified ifTrue:[				"@@@ FIXME: Fix #displayOn: to use real color map if needed"				self displayForm: backingForm on: backingTexture.				self uploadTexture: backingTexture.				self compositeTexture: backingTexture at: x@y translucent: true.			].			x _ x + backingTexture width.		].		y _ y + backingTexture height.	].! !!B3DHardwareEngine methodsFor: 'private-rendering' stamp: 'ar 9/8/2000 16:09'!privateSetViewport: vp	^self primRender: handle setViewportX: vp left y: vp top w: vp width h: vp height! !!B3DHardwareEngine methodsFor: 'private-rendering' stamp: 'ar 5/15/2001 18:36'!processVertexBuffer: vb	self primRenderVB: handle		primitive: vb primitive 		flags: vb flags		texture: (self textureHandleOf: rasterizer texture)		vertices: vb vertexArray 		vertexCount: vb vertexCount 		faces: vb indexArray 		faceCount: vb indexCount.! !!B3DHardwareEngine methodsFor: 'private-rendering' stamp: 'ar 5/15/2001 18:33'!renderPrimitive	"Use underlying support for transform, clip and lighting if possible.	This might actually be slower than the Squeak simulation but if the 	hardware does in fact support TL then it's going to be REALLY fast."	| projection |	transformer needsUpdate ifTrue:[		projection _ transformer projectionMatrix.		self primRender: handle 			setModelView: transformer modelViewMatrix 			projection: projection.		transformer needsUpdate: false.	].	shader needsLightUpdate ifTrue:[		self primRender: handle setLights: shader primitiveLights.		shader needsLightUpdate: false.	].	shader needsMaterialUpdate ifTrue:[		self primRender: handle setMaterial: shader primitiveMaterial.		shader needsMaterialUpdate: false.	].	^self processVertexBuffer: vertexBuffer.! !!B3DHardwareEngine methodsFor: 'private-textures' stamp: 'ar 9/8/2000 20:29'!allocateOrRecycleTexture: aB3DTexture	"If a texture for the given one has already been allocated return it. If not, allocate a new texture."	| texture |	^textures at: aB3DTexture ifAbsent:[		texture _ self allocateTexture: aB3DTexture.		texture ifNotNil:[			textures at: aB3DTexture put: texture.			aB3DTexture hasBeenModified: true].		texture]! !!B3DHardwareEngine methodsFor: 'private-textures' stamp: 'ar 5/14/2001 20:31'!allocateTexture: aB3DTexture	"Allocate a new texture for the given (Squeak internal) form.	NOTE: The size/depth of the texture allocated can differ. Right now	there's an implicit strategy in the primitive code for choosing the	right tradeoff between speed and space. In the optimal case this	will result in a texture which is 'good enough' for what we have	but if that can't be achieved anything might come back.		Also, textures might be subject to certain restrictions. Some 	graphics cards have minimum/maximum sizes of textures (some 	older even require squared textures) and this needs to be taken	into account by the primitive.		One thing that's currently not handled is if insufficient	memory is encountered. This can happen if there's just not enough	VRAM or AGP memory. A good idea would be to free up some of	the already allocated textures but it's not quite sure if that'll do	the trick and it would require flushing the renderer. Tricky."	| textureHandle w h d rgbaBitMasks msbFlag textureBits |	w _ aB3DTexture width asSmallerPowerOfTwo.	h _ aB3DTexture height asSmallerPowerOfTwo.	textureHandle _ self primRender: handle allocateTexture: aB3DTexture depth width: w height: h.	textureHandle = nil ifTrue:[^nil].	d _ self primRender: handle getTextureDepth: textureHandle.	rgbaBitMasks _ Array new: 4.	self primRender: handle texture: textureHandle colorMasksInto: rgbaBitMasks.	msbFlag _ self primRender: handle getTextureByteSex: textureHandle.	textureBits _ self primRender: handle getTextureSurface: textureHandle.	textureBits ifNil:[		"means that the texture is not directly accessible"		textureBits _ msbFlag ifTrue:[Bitmap new] ifFalse:[Pixmap new]].	"And return the allocated texture"	^(B3DHardwareTexture new initializeFrom: aB3DTexture) 		setExtent: w@h depth: d bits: textureBits 		rgbaBitMasks: rgbaBitMasks handle: textureHandle renderer: self.! !!B3DHardwareEngine methodsFor: 'private-textures' stamp: 'ar 9/8/2000 23:05'!destroyTexture: anExternalTexture	"Destroy the given external form"	self primRender: handle destroyTexture: anExternalTexture getExternalHandle.! !!B3DHardwareEngine methodsFor: 'private-textures' stamp: 'ar 4/19/2001 07:43'!displayForm: sourceForm on: destForm	"@@@ FIXME: Fix #displayOn: to use real color map if needed"	(BitBlt toForm: destForm)		sourceForm: sourceForm;		combinationRule: 3;		colorMap: (sourceForm colormapIfNeededFor: destForm);		copyBits.! !!B3DHardwareEngine methodsFor: 'private-textures' stamp: 'ar 5/14/2001 22:46'!displayForm: sourceForm on: destForm from: sourceOrigin	"@@@ FIXME: Fix #displayOn: to use real color map if needed"	(BitBlt toForm: destForm)		sourceOrigin: sourceOrigin;		sourceForm: sourceForm;		combinationRule: 3;		colorMap: (sourceForm colormapIfNeededFor: destForm);		copyBits.! !!B3DHardwareEngine methodsFor: 'private-textures' stamp: 'ar 4/19/2001 07:44'!textureHandleOf: aTexture	| textureForm |	aTexture ifNil:[^-1].	textureForm _ self allocateOrRecycleTexture: aTexture.	textureForm ifNil:[^-1].	"Update textureForm if aTexture is dirty"	aTexture hasBeenModified ifTrue:[		"Use the best method we have"		textureForm prepareForUpload.		"@@@ FIXME: We need to fix displayOn: etc. to deal with color maps @@@"		textureForm extent = aTexture extent ifTrue:[			self displayForm: aTexture on: textureForm.		] ifFalse:[aTexture displayInterpolatedOn: textureForm].		self uploadTexture: textureForm.		textureForm releaseFromUpload.		aTexture hasBeenModified: false].	^textureForm getExternalHandle! !!B3DHardwareEngine methodsFor: 'private-textures' stamp: 'ar 5/14/2001 20:06'!uploadTexture: aTexture	aTexture ifNil:[^nil].	aTexture needsUpload ifFalse:[^self]. "no point"	self primRender: handle uploadTexture: aTexture getExternalHandle from: aTexture.! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 18:40'!primClearDepthBuffer: aHandle	<primitive:'primitiveClearDepthBuffer' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 18:39'!primFinish: aHandle	"Primitive. Finish all rendering operations on the receiver.	Do not return before all rendering operations have taken effect."	<primitive: 'primitiveFinishRenderer' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 18:39'!primFlush: aHandle	"Primitive. If any rendering operations are pending, force them to be executed.	Do not wait until they have taken effect."	<primitive: 'primitiveFlushRenderer' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 18:39'!primRender: aHandle clearViewport: rgbaValue with: pixelWord	<primitive:'primitiveClearViewport' module: 'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 4/19/2001 03:36'!primRender: aHandle getProperty: propNumber	"Primitive. Get some property."	<primitive:'primitiveGetIntProperty' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/14/2001 20:36'!primRender: aHandle setBufferRectX: left y: top w: width h: height	<primitive:'primitiveSetBufferRect' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 02:14'!primRender: aHandle setFog: type density: aDensity rangeStart: start rangeEnd: end color: pixelValue32	"Primitive. Set the current fog parameters."	<primitive: 'primitiveSetFog' module: 'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 18:39'!primRender: aHandle setLights: lightArray	<primitive:'primitiveSetLights' module: 'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 18:39'!primRender: aHandle setMaterial: aMaterial	<primitive:'primitiveSetMaterial' module: 'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 18:39'!primRender: aHandle setModelView: modelViewMatrix projection: projectionMatrix	<primitive:'primitiveSetTransform' module: 'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 18:39'!primRender: aHandle setProperty: propNumber toInteger: value	"Primitive. Set some property."	<primitive:'primitiveSetIntProperty' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 18:39'!primRender: aHandle setViewportX: left y: top w: width h: height	<primitive:'primitiveSetViewport' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 18:38'!primRenderVB: aHandle primitive: primitiveType flags: flags texture: textureHandle vertices: vtxArray vertexCount: vtxCount faces: idxArray faceCount: idxCount	<primitive:'primitiveRenderVertexBuffer' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-rendering' stamp: 'ar 5/15/2001 18:40'!primSwapBuffers: aHandle	"Primitive. Finish all rendering operations on the receiver.	Do not return before all rendering operations have taken effect."	<primitive: 'primitiveSwapRendererBuffers' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-textures' stamp: 'ar 4/19/2001 03:37'!primRender: aHandle allocateTexture: d width: w height: h	"Primitive. Allocate a texture with the given dimensions.	Note: The depth of the texture allocated may *not* match the specified values here."	<primitive:'primitiveAllocateTexture' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-textures' stamp: 'ar 5/15/2001 18:40'!primRender: rendererHandle compositeTexture: textureHandle x: x y: y w: w h: h translucent: aBool	<primitive: 'primitiveCompositeTexture' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-textures' stamp: 'ar 4/19/2001 03:37'!primRender: rendererHandle destroyTexture: textureHandle	"Primitive. Destroy the texture associated with the given handle."	<primitive:'primitiveDestroyTexture' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-textures' stamp: 'ar 5/15/2001 18:40'!primRender: rendererHandle getTextureByteSex: textureHandle	"Primitive. Return the byte sex of the texture (e.g., true for MSB false for LSB)"	<primitive:'primitiveTextureByteSex' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-textures' stamp: 'ar 5/15/2001 18:40'!primRender: rendererHandle getTextureDepth: textureHandle	"Primitive. Return the actual depth of the texture with the given handle"	<primitive:'primitiveTextureDepth' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-textures' stamp: 'ar 5/14/2001 20:00'!primRender: rendererHandle getTextureSurface: textureHandle	"Primitive. Return the texture's surface handle for blitting from within Squeak.	Fail if the surface cannot be accessed directly."	<primitive:'primitiveTextureSurfaceHandle' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-textures' stamp: 'ar 4/19/2001 03:37'!primRender: rendererHandle texture: textureHandle colorMasksInto: anArray	"Primitive. Store the bit masks for each color into the given array."	<primitive: 'primitiveTextureGetColorMasks' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-textures' stamp: 'ar 5/15/2001 18:40'!primRender: rendererHandle uploadTexture: textureHandle from: aForm	"Primitive. Upload the given form into the texture identified by handle."	<primitive: 'primitiveTextureUpload' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-renderer' stamp: 'ar 4/20/2001 01:52'!primCreateRendererSW: allowSoftware hw: allowHardware x: x y: y w: w h: h	<primitive: 'primitiveCreateRenderer' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-renderer' stamp: 'ar 4/19/2001 03:38'!primDestroyRenderer: aHandle	<primitive: 'primitiveDestroyRenderer' module:'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:08'!primRender: aHandle getColorMasksInto: anArray	"Primitive. If this renderer is associated with a surface that we can blt directly to, return the color masks for it."	<primitive:'primitiveGetRendererColorMasks' module: 'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:34'!primRenderGetSurfaceDepth: aHandle	"Primitive. If this renderer is associated with a surface that we can blt directly to, return the surface height for it."	<primitive:'primitiveGetRendererSurfaceDepth' module: 'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:07'!primRenderGetSurfaceHandle: aHandle	"Primitive. If this renderer is associated with a surface that we can blt directly to, return the surface handle for it. This is usually the case if the receiver is rendering to some offscreen target device (OpenGL p-buffers; DirectDraw surfaces)."	<primitive:'primitiveGetRendererSurfaceHandle' module: 'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:34'!primRenderGetSurfaceHeight: aHandle	"Primitive. If this renderer is associated with a surface that we can blt directly to, return the surface height for it."	<primitive:'primitiveGetRendererSurfaceHeight' module: 'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-renderer' stamp: 'ar 5/14/2001 21:33'!primRenderGetSurfaceWidth: aHandle	"Primitive. If this renderer is associated with a surface that we can blt directly to, return the surface width for it."	<primitive:'primitiveGetRendererSurfaceWidth' module: 'B3DAcceleratorPlugin'>	^nil! !!B3DHardwareEngine methodsFor: 'primitives-renderer' stamp: 'ar 5/15/2001 18:41'!primRenderIsOverlay: aHandle	"Primitive. Return true if the receiver is represented by a native window and Squeak cannot draw on top of it. On some systems (for instance Mac) it is possible to draw on top of the rendering target although it may be bound to a window. On others (like Windows and AFAIK most Unix systems) it is impossible to draw on top of a rendering context that is directly bound to a window."	<primitive:'primitiveIsOverlayRenderer' module: 'B3DAcceleratorPlugin'>	^nil! !!B3DMapperEngine methodsFor: 'initialize' stamp: 'ar 9/9/2000 03:00'!initialize	super initialize.	boundsMap _ IdentityDictionary new.! !!B3DMapperEngine methodsFor: 'initialize' stamp: 'ar 9/9/2000 02:52'!loadFrom: aRenderEngine	"Load our components from the given render engine.	The idea is that all of the state is shared so that transformations	send during picking will be preserved in the given render engine."	vertexBuffer _ aRenderEngine getVertexBuffer.	transformer _ aRenderEngine getTransformer.	shader _ aRenderEngine getShader.	clipper _ aRenderEngine getClipper.	rasterizer _ aRenderEngine getRasterizer. ! !!B3DMapperEngine methodsFor: 'accessing' stamp: 'ar 9/9/2000 02:48'!bounds	^bounds! !!B3DMapperEngine methodsFor: 'accessing' stamp: 'ar 9/9/2000 02:57'!boundsMap	^boundsMap! !!B3DMapperEngine methodsFor: 'accessing' stamp: 'ar 9/9/2000 02:57'!render: anObject	| oldBounds|	oldBounds _ bounds.	bounds _ nil.	anObject renderOn: self.	boundsMap at: anObject put: bounds.	oldBounds == nil ifTrue:[^self].	bounds == nil ifTrue:[^bounds _ oldBounds].	oldBounds == nil ifTrue:[^bounds].	bounds _ bounds quickMerge: oldBounds.	^bounds! !!B3DMapperEngine methodsFor: 'private-rendering' stamp: 'ar 4/20/2001 04:07'!primProcessVB: vertexArray size: arraySize into: array	| left right top bottom vtx flags w x y |	<primitive: 'b3dMapVertexBuffer' module: 'Squeak3D'>	1 to: arraySize do:[:i|		vtx _ vertexArray at: i.		flags _ vtx clipFlags.		w _ vtx rasterPosW.		w isZero ifFalse:[w _ 1.0 / w].		(flags anyMask: OutLeftBit) 			ifTrue:[x _ -1.0]			ifFalse:[(flags anyMask: OutRightBit) 				ifTrue:[x _ 1.0]				ifFalse:[x _ vtx rasterPosX * w]].		(flags anyMask: OutTopBit) 			ifTrue:[y _ -1.0]			ifFalse:[(flags anyMask: OutBottomBit) 				ifTrue:[y _ 1.0]				ifFalse:[y _ vtx rasterPosY * w]].		i = 1 ifTrue:[			left _ right _ x.			top _ bottom _ y.		].		left _ left min: x.		right _ right max: x.		top _ top min: y.		bottom _ bottom max: y.	].	array at: 1 put: left.	array at: 2 put: top.	array at: 3 put: right.	array at: 4 put: bottom.! !!B3DMapperEngine methodsFor: 'private-rendering' stamp: 'ar 4/20/2001 03:50'!processVertexBuffer: vb	| box vp |	box _ Array new: 4.	self primProcessVB: vb vertexArray size: vb vertexCount into: box.	vp _ self viewport.	^(vp mapVertex2: (box at: 1) @ (box at: 2)) rect: 		(vp mapVertex2: (box at: 3) @ (box at: 4))! !!B3DMapperEngine methodsFor: 'private-rendering' stamp: 'ar 4/20/2001 02:36'!renderPrimitive	"This is the main rendering loop for all operations"	| visible box |	"Step 1: Override vertex buffer flags, ignoring normals and tex coords"	vertexBuffer clearFlags: (VBVtxHasNormals bitOr: VBVtxHasTexCoords).	"Step 2: Set the primitive type in the vertex buffer to points (that's all we need)"	vertexBuffer primitive: PrimTypePoints.	"Step 3: Transform vertices, normals, texture coords of the mesh"	self privateTransformVB: vertexBuffer.	"Step 4: Clip the mesh if necessary"	visible _ self privatePreClipVB: vertexBuffer.	visible == false ifTrue:[^nil].	"Step 5: Compute min/max of object vertices."	box _ self processVertexBuffer: vertexBuffer.	box == nil ifTrue:[^self].	bounds == nil 		ifTrue:[bounds _ box]		ifFalse:[bounds _ bounds quickMerge: box].	^bounds! !!B3DRenderEngine class methodsFor: 'instance creation' stamp: 'ar 4/20/2001 03:17'!defaultForPlatformOn: aForm	"Return the render engine that is most appropriate for the current host platform."	(B3DPrimitiveEngine isAvailableFor: aForm) 		ifTrue:[^B3DPrimitiveEngine newOn: aForm].	^B3DRenderEngine newOn: aForm! !!B3DHardwareEngine class methodsFor: 'accessing' stamp: 'ar 4/19/2001 03:30'!version	"B3DHardwareEngine version"	<primitive:'primitiveRendererVersion' module:'B3DAcceleratorPlugin'>	^0! !!B3DHardwareEngine class methodsFor: 'instance creation' stamp: 'ar 4/19/2001 03:35'!newIn: bounds	^(self new) initializeIn: bounds! !!B3DHardwareEngine class methodsFor: 'instance creation' stamp: 'ar 9/9/2000 22:13'!newOn: aForm	"Accelerated engines want a buffer rectangle"	^self shouldNotImplement! !!B3DHardwareEngine class methodsFor: 'testing' stamp: 'ar 9/8/2000 16:07'!isAvailable	^self version > 0! !!B3DHardwareEngine class methodsFor: 'primitives' stamp: 'ar 4/20/2001 01:51'!primitiveSetVerboseLevel: newLevel	"Primitive. Set the reporting level for the engine. Values are		0 - print NO information ever		1 - print critical debug errors		2 - print debug warnings		3 - print extra information		4 - print extra warnings		5 - print information about primitive execution	   10 - print information about each vertex and face	"	<primitive:'primitiveSetVerboseLevel' module:'B3DAcceleratorPlugin'>! !!B3DVertexBuffer methodsFor: 'attributes' stamp: 'ar 4/20/2001 02:30'!clearFlags: flagsToClear	flags _ flags bitClear: flagsToClear.! !!B3DVertexShader methodsFor: 'initialize' stamp: 'ar 9/6/2000 23:37'!initialize	super initialize.	lights _ OrderedCollection new.	material _ B3DMaterial new.	materialStack _ OrderedCollection new: 10.	needsLightUpdate _ needsMaterialUpdate _ true.! !!B3DVertexShader methodsFor: 'initialize' stamp: 'ar 9/6/2000 23:37'!reset	super reset.	lights _ OrderedCollection new.	material _ B3DMaterial new.	materialStack _ OrderedCollection new: 10.	needsLightUpdate _ needsMaterialUpdate _ true.! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:36'!addLight: aLightSource	lights add: aLightSource.	needsLightUpdate _ true.	^lights size! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:37'!material: aMaterial	material _ aMaterial.	needsMaterialUpdate _ true.! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:37'!materialColor: aColor	material ambientPart: aColor.	material diffusePart: aColor.	material specularPart: aColor.	needsMaterialUpdate _ true.! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:38'!needsLightUpdate	^needsLightUpdate! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:39'!needsLightUpdate: aBool	needsLightUpdate _ aBool! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:38'!needsMaterialUpdate	^needsMaterialUpdate! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:38'!needsMaterialUpdate: aBool	needsMaterialUpdate _ aBool! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:37'!popMaterial	material _ materialStack removeLast.	needsMaterialUpdate _ true.! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:38'!pushMaterial	materialStack addLast: material.! !!B3DVertexShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:37'!removeLight: lightIndex	"Remove the light with the given index"	(lightIndex < 1 or:[lightIndex > lights size]) ifTrue:[^nil].	lights at: lightIndex put: nil. "So we don't change the indexes"	needsLightUpdate _ true.! !!B3DPrimitiveShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:43'!primitiveLights	^primitiveLights! !!B3DPrimitiveShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:43'!primitiveMaterial	^material! !!B3DPrimitiveShader methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:37'!removeLight: lightIndex	| pLight |	super removeLight: lightIndex.	self flag: #b3dBug. 	"There should be a better way then doing this."	primitiveLights _ #().	lights do:[:light| 		light ifNotNil:[pLight _ light asPrimitiveLight].		pLight ifNotNil:[primitiveLights _ primitiveLights copyWith: pLight]].	needsLightUpdate _ true.! !!B3DVertexTransformer methodsFor: 'initialize' stamp: 'ar 9/6/2000 23:33'!initialize	super initialize.	modelMatrix _ B3DMatrix4x4 identity.	viewMatrix _ B3DMatrix4x4 identity.	textureMatrix _ B3DMatrix4x4 identity.	currentMatrix _ modelMatrix.	matrixStack _ OrderedCollection new: 30.	matrixStack resetTo: 1.	needsUpdate _ true.! !!B3DVertexTransformer methodsFor: 'initialize' stamp: 'ar 9/6/2000 23:33'!reset	super reset.	modelMatrix := B3DMatrix4x4 identity.	viewMatrix := B3DMatrix4x4 identity.	textureMatrix := B3DMatrix4x4 identity.	currentMatrix := modelMatrix.	matrixStack := OrderedCollection new: 30.	matrixStack resetTo: 1.	needsUpdate := true.! !!B3DVertexTransformer methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:33'!needsUpdate	^needsUpdate! !!B3DVertexTransformer methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:33'!needsUpdate: aBool	needsUpdate _ aBool! !!B3DVertexTransformer methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:34'!popMatrix	"Pop the current matrix from the stack"	matrixStack isEmpty ifTrue:[^self error:'Empty matrix stack'].	currentMatrix loadFrom: matrixStack removeLast.	needsUpdate _ true.! !!B3DVertexTransformer methodsFor: 'accessing' stamp: 'ar 9/6/2000 23:42'!pushMatrix	"Push the current matrix"	| theMatrix |	theMatrix := B3DMatrix4x4 new.	theMatrix loadFrom: currentMatrix.	matrixStack addLast: theMatrix.! !!B3DVertexTransformer methodsFor: 'modifying' stamp: 'ar 9/6/2000 18:35'!multiplyMatrix: aMatrix	"Multiply aMatrix with the current matrix"	currentMatrix *= aMatrix.	needsUpdate _ true.! !!B3DViewingFrustum methodsFor: 'private' stamp: 'ar 5/15/2001 00:48'!asPerspectiveMatrixInto: aB3DMatrix4x4	| x y a b c d dx dy dz z2 |	(self near <= 0.0 or:[self far <= 0.0 or:[self near >= self far]]) 		ifTrue: [^self error:'Clipping plane error'].	dx := self right - self left.	dy := self top - self bottom.	dz := self far - self near.	z2 := 2.0 * self near.	x := z2 / dx.	y := z2 / dy.	a := (self left + self right) / dx.	b := (self top + self bottom) / dy.	c := (self near + self far) "*negated*" / dz.	d := (-2.0 * self near * self far) / dz.	aB3DMatrix4x4		a11: x;			a12: 0.0;	a13: a;		a14: 0.0;		a21: 0.0;		a22: y;		a23: b;		a24: 0.0;		a31: 0.0;		a32: 0.0;	a33: c;		a34: d;		a41: 0.0;		a42: 0.0;	a43: "*-1*"1;		a44: 0.0.	^aB3DMatrix4x4! !!B3DViewport methodsFor: 'mapping' stamp: 'ar 9/9/2000 03:14'!mapVertex2: aPoint	^(aPoint * scale + center) truncated! !!Color methodsFor: 'queries' stamp: 'ar 4/20/2001 04:33'!isOpaque	^true! !!Color methodsFor: 'conversions' stamp: 'ar 5/15/2001 16:12'!pixelValue32	"Note: pixelWord not pixelValue so we include translucency"	^self pixelWordForDepth: 32! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 5/15/2001 16:12'!mapPixel: pixelValue	"Perform a forward pixel mapping operation"	| pv |	(shifts == nil and:[masks == nil]) ifFalse:[		pv _ (((pixelValue bitAnd: self redMask) bitShift: self redShift) bitOr:			((pixelValue bitAnd: self greenMask) bitShift: self greenShift)) bitOr:			(((pixelValue bitAnd: self blueMask) bitShift: self blueShift) bitOr:			((pixelValue bitAnd: self alphaMask) bitShift: self alphaShift)).	] ifTrue:[pv _ pixelValue].	colors ifNotNil:[pv _ colors at: pv].	"Need to check for translucency else Form>>paint goes gaga"	pv = 0 ifTrue:[pixelValue = 0 ifFalse:[pv _ 1]].	^pv! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 5/15/2001 16:12'!pixelMap: pixelValue	"Perform a reverse pixel mapping operation"	| pv |	colors == nil		ifTrue:[pv _ pixelValue]		ifFalse:[pv _ colors at: pixelValue].	(shifts == nil and:[masks == nil]) 		ifFalse:[pv _ (((pv bitAnd: self redMask) bitShift: self redShift) bitOr: 				((pv bitAnd: self greenMask) bitShift: self greenShift)) bitOr:					(((pv bitAnd: self blueMask) bitShift: self blueShift) bitOr: 						((pv bitAnd: self alphaMask) bitShift: self alphaShift))].	"Need to check for translucency else Form>>paint goes gaga"	pv = 0 ifTrue:[pixelValue = 0 ifFalse:[pv _ 1]].	^pv! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!balancedPatternFor: aColor	"Return the pixel word for representing the given color on the receiver"	self hasNonStandardPalette		ifTrue:[^self bitPatternFor: aColor]		ifFalse:[^aColor balancedPatternForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!bitPatternFor: aColor	"Return the pixel word for representing the given color on the receiver"	aColor isColor ifFalse:[^aColor bitPatternForDepth: self depth].	self hasNonStandardPalette		ifTrue:[^Bitmap with: (self pixelWordFor: aColor)]		ifFalse:[^aColor bitPatternForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!colormapFromARGB	"Return a ColorMap mapping from canonical ARGB space into the receiver.	Note: This version is optimized for Squeak forms."	| map nBits |	self hasNonStandardPalette 		ifTrue:[^ColorMap mappingFromARGB: self rgbaBitMasks].	self depth <= 8 ifTrue:[		map _ Color colorMapIfNeededFrom: 32 to: self depth.		map size = 512 ifTrue:[nBits _ 3].		map size = 4096 ifTrue:[nBits _ 4].		map size = 32768 ifTrue:[nBits _ 5].		^ColorMap			shifts: (Array 						with: 3 * nBits - 24						with: 2 * nBits - 16						with: 1 * nBits - 8						with: 0)			masks: (Array						with: (1 << nBits) - 1 << (24 - nBits)						with: (1 << nBits) - 1 << (16 - nBits)						with: (1 << nBits) - 1 << (8 - nBits)						with: 0)			colors: map].	self depth = 16 ifTrue:[		^ColorMap			shifts: #(-9 -6 -3 0)			masks: #(16rF80000 16rF800 16rF8 0)].	self depth = 32 ifTrue:[		^ColorMap			shifts: #(0 0 0 0)			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)].	self error:'Bad depth'! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!colormapIfNeededFor: destForm	"Return a ColorMap mapping from the receiver to destForm."	"Note: This is very magical for now - we really need to switch	to palettes here but as long as this isn't done we need something	that works."	| map nBits myBits |	(self hasNonStandardPalette or:[destForm hasNonStandardPalette]) ifTrue:[		^self colormapFromARGB mappingTo: destForm colormapFromARGB].	self depth = destForm depth ifTrue:[^nil]. "no conversion"	self depth <= 8 ifTrue:["Always map indexed"		^ColorMap			shifts: nil			masks: nil			colors: (Color colorMapIfNeededFrom: self depth to: destForm depth)].	(self depth = 16 and:[destForm depth = 32]) ifTrue:["Expand bits"		^ColorMap 			shifts: #( 9 6 3 0) 			masks: #(16r7C00 16r3E0 16r1F 0)].	(self depth = 32 and:[destForm depth = 16]) ifTrue:["Contract bits"		^ColorMap			shifts: #(-9 -6 -3 0)			masks: #(16rF80000 16rF800 16rF8 0)].	"destForm is indexed, I am non-indexed"	map _ Color colorMapIfNeededFrom: self depth to: destForm depth.	map size = 512 ifTrue:[nBits _ 3].	map size = 4096 ifTrue:[nBits _ 4].	map size = 32768 ifTrue:[nBits _ 5].	myBits _ depth == 16 ifTrue:[5] ifFalse:[8].	^ColorMap		shifts: {	(3 * nBits) - (3 * myBits).				(2 * nBits) - (2 * myBits).				(1 * nBits) - (1 * myBits).				0}		masks: {	(1 bitShift: nBits) - 1 bitShift: (3 * myBits - nBits).				(1 bitShift: nBits) - 1 bitShift: (2 * myBits - nBits).				(1 bitShift: nBits) - 1 bitShift: (1 * myBits - nBits).				0}		colors: map.! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!colormapToARGB	"Return a ColorMap mapping from the receiver into canonical ARGB space."	self hasNonStandardPalette 		ifTrue:[^self colormapFromARGB inverseMap].	self depth <= 8 ifTrue:[		^ColorMap			shifts: #(0 0 0 0)			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)			colors: (Color colorMapIfNeededFrom: self depth to: 32)].	self depth = 16 ifTrue:[		^ColorMap 			shifts: #( 9 6 3 0) 			masks: #(16r7C00 16r3E0 16r1F 0)].	self depth = 32 ifTrue:[		^ColorMap			shifts: #(0 0 0 0) 			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)].	self error:'Bad depth'! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!pixelValueFor: aColor	"Return the pixel word for representing the given color on the receiver"	self hasNonStandardPalette		ifTrue:[^self colormapFromARGB mapPixel: (aColor pixelValueForDepth: 32)]		ifFalse:[^aColor pixelValueForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!pixelWordFor: aColor	"Return the pixel word for representing the given color on the receiver"	| basicPattern |	self hasNonStandardPalette 		ifFalse:[^aColor pixelWordForDepth: self depth].	basicPattern _ self pixelValueFor: aColor.	self depth = 32 		ifTrue:[^basicPattern]		ifFalse:[^aColor pixelWordFor: self depth filledWith: basicPattern]! !!Form methodsFor: 'testing' stamp: 'ar 5/15/2001 16:14'!hasNonStandardPalette	"Return true if the receiver has a non-standard palette.	Non-standard means that RGBA components may be located	at positions differing from the standard Squeak RGBA layout	at the receiver's depth."	^false! !!B3DBackingForm methodsFor: 'accessing' stamp: 'ar 9/9/2000 19:19'!shouldPreserveContents	^false! !!B3DHardwareTexture methodsFor: 'initialize-release' stamp: 'ar 9/8/2000 20:39'!destroy	"Destroy the receiver"	renderer == nil ifFalse:[renderer destroyTexture: self].	renderer _ nil.! !!B3DHardwareTexture methodsFor: 'accessing' stamp: 'ar 9/8/2000 20:39'!colormapFromARGB	"Return a ColorMap mapping from canonical ARGB pixel values into the receiver"	^argbMap! !!B3DHardwareTexture methodsFor: 'accessing' stamp: 'ar 9/8/2000 20:39'!rgbaBitMasks	"Return the masks for specifying the R,G,B, and A components in the receiver"	^argbMap rgbaBitMasks! !!B3DHardwareTexture methodsFor: 'upload/download' stamp: 'ar 5/14/2001 19:52'!needsUpload	"Return true if the receiver needs to be uploaded"	bits isInteger ifTrue:[^false]. "handled transparently"	^bits size = self bitsSize! !!B3DHardwareTexture methodsFor: 'upload/download' stamp: 'ar 5/14/2001 19:53'!prepareForUpload	"The receiver is about to be modified for a texture upload. Bring it's bits in place."	| bitsSize |	bits isInteger ifTrue:[^self]. "handled transparently"	bitsSize _ self bitsSize.	bits size = bitsSize ifFalse:[bits _ bits class new: bitsSize].! !!B3DHardwareTexture methodsFor: 'upload/download' stamp: 'ar 5/14/2001 19:53'!releaseFromUpload	"The receiver has been uploaded. Release its bits."	bits isInteger ifTrue:[^self]. "handled transparently"	bits _ bits class new.! !!B3DHardwareTexture methodsFor: 'upload/download' stamp: 'ar 5/14/2001 19:53'!unhibernate	bits isInteger ifTrue:[^false]. "handled transparently"	bits ifNotNil:[		bits size = 0 ifTrue:[self prepareForUpload. ^true]].	^super unhibernate! !!B3DHardwareTexture methodsFor: 'testing' stamp: 'ar 5/15/2001 16:15'!hasNonStandardPalette	"Quite possible."	^true! !!B3DHardwareTexture methodsFor: 'testing' stamp: 'ar 5/15/2001 16:17'!isExternalForm	"Yup."	^true! !!B3DHardwareTexture methodsFor: 'private' stamp: 'ar 9/8/2000 20:40'!getExternalHandle	"Private. Return the virtual handle used to represent the receiver"	^handle! !!B3DHardwareTexture methodsFor: 'private' stamp: 'ar 9/8/2000 20:40'!initializeFrom: aTexture	"Private. Initialize the receiver from aTexture."	wrap _ aTexture wrap.	envMode _ aTexture envMode.	interpolate _ aTexture interpolate.! !!B3DHardwareTexture methodsFor: 'private' stamp: 'ar 9/8/2000 20:41'!setExtent: extent depth: bitsPerPixel bits: bitOrPixmap rgbaBitMasks: bitMasks handle: aHandle renderer: aRenderer	width _ extent x asInteger.	width < 0 ifTrue: [width _ 0].	height _ extent y asInteger.	height < 0 ifTrue: [height _ 0].	depth _ bitsPerPixel.	bits _ bitOrPixmap.	argbMap _ ColorMap mappingFromARGB: bitMasks.	handle _ aHandle.	renderer _ aRenderer.! !!DisplayScreen methodsFor: 'displaying' stamp: 'ar 4/19/2001 05:44'!addExtraRegion: aRectangle for: regionDrawer	"Register the given rectangle as a region which is drawn by the specified region drawer. The region will be excluded from any updates when #forceDamageToScreen: is called. Note that the rectangle is only valid for a single update cycle; once #forceDamageToScreen: has been called, the region drawer and its region are being removed from the list"	extraRegions ifNil:[extraRegions _ #()].	extraRegions _ extraRegions copyWith: (Array with: regionDrawer with: aRectangle).! !!DisplayScreen methodsFor: 'displaying' stamp: 'ar 5/15/2001 20:08'!forceDamageToScreen: allDamage	"Force all the damage rects to the screen."	| rectList excluded remaining regions |	rectList _ allDamage.	"Note: Reset extra regions at the beginning to prevent repeated errors"	regions _ extraRegions.	extraRegions _ nil.	regions ifNotNil:[		"exclude extra regions"		regions do:[:drawerAndRect|			excluded _ drawerAndRect at: 2.			remaining _ WriteStream on: #().			rectList do:[:r|				remaining nextPutAll:(r areasOutside: excluded)].			rectList _ remaining contents].	].	rectList do:[:r| self forceToScreen: r].	regions ifNotNil:[		"Have the drawers paint what is needed"		regions do:[:drawerAndRect| (drawerAndRect at: 1) forceToScreen].	].! !!ExternalForm methodsFor: 'accessing' stamp: 'ar 5/14/2001 21:37'!colormapFromARGB: aMap	"Set the ColorMap mapping from canonical ARGB pixel values into the receiver"	argbMap _ aMap! !!ExternalForm methodsFor: 'testing' stamp: 'ar 5/15/2001 16:15'!hasNonStandardPalette	"Quite possible."	^display notNil or:[argbMap notNil]! !!ExternalForm methodsFor: 'testing' stamp: 'ar 5/15/2001 16:17'!isExternalForm	"I am an external form but only as long as I'm allocated on a display"	^display notNil! !!ExternalScreen methodsFor: 'testing' stamp: 'ar 5/15/2001 16:15'!hasNonStandardPalette	"Quite possible."	^true! !!ExternalTexture methodsFor: 'testing' stamp: 'ar 5/15/2001 16:15'!hasNonStandardPalette	"Quite possible."	^true! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 9/9/2000 22:18'!render: anObject	"Do some 3D operations with the object if possible"	^self asBalloonCanvas render: anObject! !!IdentityTransform methodsFor: 'accessing' stamp: 'ar 4/19/2001 06:01'!offset	^0@0! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 9/9/2000 17:31'!morphsInFrontOf: someMorph overlapping: aRectangle do: aBlock	"Evaluate aBlock with all top-level morphs in front of someMorph that overlap with the given rectangle. someMorph is either an immediate child of the receiver or nil (in which case all submorphs of the receiver are enumerated)."	self submorphsDo:[:m|		m == someMorph ifTrue:["Try getting out quickly"			owner ifNil:[^self].			^owner morphsInFrontOf: self overlapping: aRectangle do: aBlock].		(m fullBoundsInWorld intersects: aRectangle)			ifTrue:[aBlock value: m]].	owner ifNil:[^self].	^owner morphsInFrontOf: self overlapping: aRectangle do: aBlock.! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 9/9/2000 17:31'!morphsInFrontOverlapping: aRectangle	"Return all top-level morphs in front of someMorph that overlap with the given rectangle."	| morphList |	morphList _ WriteStream on: Array new.	self morphsInFrontOf: nil overlapping: aRectangle do:[:m | morphList nextPut: m].	^morphList contents! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 9/9/2000 17:31'!morphsInFrontOverlapping: aRectangle do: aBlock	"Evaluate aBlock with all top-level morphs in front of someMorph that overlap with the given rectangle."	^self morphsInFrontOf: nil overlapping: aRectangle do: aBlock! !!Morph methodsFor: 'private' stamp: 'ar 4/20/2001 02:02'!myEvents	^self valueOfProperty: #myEvents! !!Morph methodsFor: 'private' stamp: 'ar 4/20/2001 02:03'!myEvents: events	self setProperty: #myEvents toValue: events! !!B3DMorph methodsFor: 'drawing' stamp: 'ar 9/9/2000 22:06'!drawOn: aCanvas	color ifNotNil:["aCanvas frameAndFillRectangle: self bounds fillColor: color borderWidth: 1 borderColor: Color black."		aCanvas frameRectangle: self bounds color: self color].	aCanvas render: self.! !!B3DSceneExplorerMorph methodsFor: 'accessing' stamp: 'ar 9/9/2000 22:31'!accelerationEnabled	^b3DSceneMorph ifNil:[false] ifNotNil:[b3DSceneMorph accelerationEnabled].! !!B3DSceneExplorerMorph methodsFor: 'accessing' stamp: 'ar 9/9/2000 22:31'!accelerationEnabled: aBool	^b3DSceneMorph ifNotNil:[b3DSceneMorph accelerationEnabled: aBool].! !!B3DSceneExplorerMorph methodsFor: 'actions' stamp: 'ar 9/9/2000 22:29'!toggleAcceleration	self accelerationEnabled: self accelerationEnabled not.! !!B3DSceneExplorerMorph methodsFor: 'change reporting' stamp: 'ar 9/9/2000 22:28'!layoutChanged	| ctrl |	super layoutChanged.	b3DSceneMorph ifNil: [^self].	b3DSceneMorph extent: (self extent - ((frameWidth * 2)@(frameWidth * 2))).	b3DSceneMorph position: (self bounds origin + ((frameWidth)@(frameWidth))).	wheels ifNil: [^self].	wheels isEmpty ifTrue: [^self].	ctrl := wheels at: #fov ifAbsent: [nil].	ctrl ifNotNil: [		ctrl position:			self bounds corner -				ctrl extent - 				(frameWidth@((frameWidth - ctrl extent y) / 2) rounded)].	ctrl := wheels at: #dolly ifAbsent: [nil].	ctrl ifNotNil: [		ctrl position:			self bounds corner -				ctrl extent - 				((((frameWidth - ctrl extent x) / 2) rounded)@frameWidth)].	ctrl := wheels at: #rotX ifAbsent: [nil].	ctrl ifNotNil: [		ctrl position:			(self bounds origin x + (((frameWidth - ctrl extent x) / 2) rounded))@(self bounds corner y - ctrl extent y - frameWidth)].	ctrl := wheels at: #rotY ifAbsent: [nil].	ctrl ifNotNil: [		ctrl position:			(self bounds origin x + frameWidth)@(self bounds corner y - ctrl extent y - (((frameWidth - ctrl extent y) / 2) rounded))].	ctrl := wheels at: #rotZ ifAbsent: [nil].	ctrl ifNotNil: [		ctrl position:			self bounds origin +			((((frameWidth - ctrl extent x) / 2) rounded)@frameWidth)].	ctrl := wheels at: #accel ifAbsent:[nil].	ctrl ifNotNil:[		ctrl position:			self bounds origin +			(frameWidth @ ((((frameWidth - ctrl extent y) / 2) rounded)))].! !!B3DSceneExplorerMorph methodsFor: 'drawing' stamp: 'ar 4/20/2001 04:34'!drawOn: aCanvas	"Don't fill if my b3dScene does it"	(b3DSceneMorph notNil and:[b3DSceneMorph color isOpaque]) ifTrue:[		(aCanvas clipRect areasOutside: b3DSceneMorph bounds) do:[:r|			aCanvas clipBy: r during:[:cc| super drawOn: cc].		].	] ifFalse:[super drawOn: aCanvas].! !!B3DSceneExplorerMorph methodsFor: 'initialization' stamp: 'ar 9/9/2000 22:33'!acceleratorButton	| outerButton aButton str miniWrapper aHelp |	outerButton _ AlignmentMorph newRow height: 24.	outerButton beTransparent.	outerButton hResizing: #spaceFill; vResizing: #shrinkWrap.	outerButton addMorph: (aButton _ UpdatingThreePhaseButtonMorph checkBox).	aButton		target: self;		actionSelector: #toggleAcceleration;		arguments: #();		getSelector: #accelerationEnabled.	outerButton addTransparentSpacerOfSize: (2 @ 0).	str _ StringMorph contents: 'Enable hardware acceleration' font: nil. "(StrikeFont familyName: 'NewYork' size: 12)."	miniWrapper _ AlignmentMorph newRow hResizing: #shrinkWrap; vResizing: #shrinkWrap.	miniWrapper beTransparent addMorphBack: str lock.	outerButton addMorphBack: miniWrapper.	aButton setBalloonText: (aHelp _ 'Turn on hardware acceleration if supported').	miniWrapper setBalloonText: aHelp; setProperty: #balloonTarget toValue: aButton.	^outerButton! !!B3DSceneExplorerMorph methodsFor: 'initialization' stamp: 'ar 4/20/2001 04:17'!initialize	| ctrl |	super initialize.	self extent: 300@300.	self borderRaised.	color := Color gray: 0.8.	frameWidth := 25.	b3DSceneMorph := AdvancedB3DSceneMorph new.	b3DSceneMorph color: Color black.	self addMorphFront: b3DSceneMorph.		wheels := Dictionary new.	ctrl := WheelMorph new.	ctrl target: b3DSceneMorph.	ctrl actionSelector: #addFovAngle:.	ctrl factor: -0.07.	ctrl setBalloonText: 'FOV'.	self addMorphFront: ctrl.	wheels at: #fov put: ctrl.	ctrl := WheelMorph new.	ctrl target: b3DSceneMorph.	ctrl actionSelector: #addDolly:.	ctrl factor: 0.005.	ctrl beVertical.	ctrl setBalloonText: 'Dolly'.	self addMorphFront: ctrl.	wheels at: #dolly put: ctrl.	ctrl := WheelMorph new.	ctrl target: b3DSceneMorph.	ctrl actionSelector: #rotateZ:.	ctrl beVertical.	ctrl setBalloonText: 'z Axis'.	self addMorphFront: ctrl.	wheels at: #rotZ put: ctrl.	ctrl := WheelMorph new.	ctrl target: b3DSceneMorph.	ctrl actionSelector: #rotateY:.	ctrl setBalloonText: 'y Axis'.	self addMorphFront: ctrl.	wheels at: #rotY put: ctrl.	ctrl := WheelMorph new.	ctrl target: b3DSceneMorph.	ctrl actionSelector: #rotateX:.	ctrl beVertical.	ctrl setBalloonText: 'x Axis'.	self addMorphFront: ctrl.	wheels at: #rotX put: ctrl.	ctrl _ self acceleratorButton.	self addMorphFront: ctrl.	wheels at: #accel put: ctrl.! !!B3DSceneMorph methodsFor: 'drawing' stamp: 'ar 4/20/2001 04:22'!drawAcceleratedOn: aCanvas	| myRect |	myRect _ (self bounds: bounds in: nil) intersect: (0@0 extent: DisplayScreen actualScreenSize).	(myRenderer notNil and:[myRenderer isAccelerated]) ifFalse:[		myRenderer ifNotNil:[myRenderer destroy].		myRenderer _ nil.	].	myRenderer ifNotNil:[		myRenderer _ myRenderer bufferRect: myRect.	].	myRenderer ifNil:[		myRenderer _ B3DHardwareEngine newIn: myRect.		myRenderer ifNil:[^self drawSimulatedOn: aCanvas].	] ifNotNil:[		myRenderer reset.	].	myRenderer viewportOffset: aCanvas origin.	myRenderer clipRect: aCanvas clipRect.	self renderOn: myRenderer.	Display addExtraRegion: myRect for: self.! !!B3DSceneMorph methodsFor: 'drawing' stamp: 'ar 4/20/2001 04:20'!drawOn: aCanvas 	(aCanvas form == Display and:[self accelerationEnabled and:[self isFlexed not]])		ifTrue:[self drawAcceleratedOn: aCanvas]		ifFalse:[self drawSimulatedOn: aCanvas].! !!B3DSceneMorph methodsFor: 'drawing' stamp: 'ar 5/14/2001 20:58'!drawSimulatedOn: aCanvas	"Draw the receiver using the builtin software renderer"	(myRenderer notNil and:[myRenderer isOverlayRenderer]) ifTrue:[		"Dump it. We may just being dragged around by the hand."		myRenderer destroy.		myRenderer _ nil].	aCanvas asBalloonCanvas render: self.! !!B3DSceneMorph methodsFor: 'drawing' stamp: 'ar 5/14/2001 23:09'!forceToScreen	"When using hardware acceleration, this method forces the receiver to swap its buffers."	myRenderer ifNotNil:[		myRenderer swapBuffers ifFalse:[			"Something went wrong"			myRenderer destroy.			myRenderer _ nil]].! !!B3DSceneMorph methodsFor: 'drawing' stamp: 'ar 9/9/2000 22:43'!renderOn: aRenderer	(color isTransparent or:[color isTranslucent]) 		ifTrue:[aRenderer restoreMorphicBackground: self bounds under: self].	aRenderer viewport: self bounds.	aRenderer clearDepthBuffer.	color isTransparent 		ifFalse:[aRenderer clearViewport: color].	aRenderer loadIdentity.	scene renderOn: aRenderer.	aRenderer restoreMorphicForeground: self bounds above: self.! !!B3DSceneMorph methodsFor: 'initialize' stamp: 'ar 9/9/2000 22:49'!initialize	super initialize.	self createDefaultScene.	self beTransparent.! !!B3DSceneMorph methodsFor: 'initialize' stamp: 'ar 4/20/2001 04:22'!intoWorld: aWorld	"The receiver is showing in the given world"	aWorld ifNil:[^self].	super intoWorld: aWorld.	aWorld when: #aboutToLeaveWorld send: #suspendAcceleration to: self.	aWorld when: #aboutToEnterWorld send: #restoreAcceleration to: self.	self restoreAcceleration.! !!B3DSceneMorph methodsFor: 'initialize' stamp: 'ar 4/20/2001 04:22'!outOfWorld: aWorld	"The receiver is leaving the given world"	aWorld ifNil:[^self].	self suspendAcceleration.	aWorld removeEventsTriggeredFor: self.	super outOfWorld: aWorld.! !!B3DSceneMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 04:19'!accelerationEnabled	"Return true if hardware acceleration is enabled"	self accelerationSuspended ifTrue:[^false].	^self valueOfProperty: #accelerationEnabled ifAbsent:[false]! !!B3DSceneMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 04:29'!accelerationEnabled: aBool	"Enable or disable hardware acceleration"	myRenderer ifNotNil:[		myRenderer destroy.		myRenderer _ nil].	aBool		ifTrue:[self setProperty: #accelerationEnabled toValue: aBool]		ifFalse:[self removeProperty: #accelerationEnabled]! !!B3DSceneMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 04:19'!accelerationSuspended	"Return true if hardware acceleration is temporarily suspended"	^self valueOfProperty: #accelerationSuspended ifAbsent:[false]! !!B3DSceneMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 04:19'!accelerationSuspended: aBool	"Temporarily suspend hardware acceleration"	aBool		ifTrue:[self setProperty: #accelerationSuspended toValue: aBool]		ifFalse:[self removeProperty: #accelerationSuspended]! !!B3DSceneMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 04:19'!restoreAcceleration	"Restore temporarily suspend acceleration"	self accelerationSuspended: false.! !!B3DSceneMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 04:19'!suspendAcceleration	"Temporarily suspend acceleration"	myRenderer ifNotNil:[myRenderer destroy].	myRenderer _ nil.	self accelerationSuspended: true.	self changed.! !!PasteUpMorph methodsFor: 'submorphs-accessing' stamp: 'ar 9/9/2000 18:14'!morphsInFrontOf: someMorph overlapping: aRectangle do: aBlock	"Include hands if the receiver is the World"	self isWorldMorph ifTrue:[		self handsDo:[:m|			m == someMorph ifTrue:["Try getting out quickly"				owner ifNil:[^self].				^owner morphsInFrontOf: self overlapping: aRectangle do: aBlock].			"The hand only overlaps if it's not the hardware cursor"			m needsToBeDrawn ifTrue:[				(m fullBoundsInWorld intersects: aRectangle)					ifTrue:[aBlock value: m]]]].	^super morphsInFrontOf: someMorph overlapping: aRectangle do: aBlock! !!PasteUpMorph class methodsFor: 'project' stamp: 'ar 4/20/2001 04:54'!shutDown		World ifNotNil:[		World trigger: #aboutToLeaveWorld.	].! !!PasteUpMorph class methodsFor: 'project' stamp: 'ar 4/20/2001 04:54'!startUp		World ifNotNil:[		World restoreMorphicDisplay.		World trigger: #aboutToEnterWorld.	].! !!Player methodsFor: 'slots-wonderland' stamp: 'ar 5/15/2001 14:11'!getFogColor	^self costume renderedMorph fogColor! !!Player methodsFor: 'slots-wonderland' stamp: 'ar 5/15/2001 14:22'!getFogDensity	^self costume renderedMorph fogDensity * 100! !!Player methodsFor: 'slots-wonderland' stamp: 'ar 5/15/2001 14:23'!getFogRangeEnd	^self costume renderedMorph fogRangeEnd * 100! !!Player methodsFor: 'slots-wonderland' stamp: 'ar 5/15/2001 14:23'!getFogRangeStart	^self costume renderedMorph fogRangeStart * 100! !!Player methodsFor: 'slots-wonderland' stamp: 'ar 5/15/2001 14:11'!getFogType	^self costume renderedMorph fogType! !!Player methodsFor: 'slots-wonderland' stamp: 'ar 5/15/2001 14:11'!setFogColor: x	self costume renderedMorph fogColor: x! !!Player methodsFor: 'slots-wonderland' stamp: 'ar 5/15/2001 14:23'!setFogDensity: x	self costume renderedMorph fogDensity: x * 0.01! !!Player methodsFor: 'slots-wonderland' stamp: 'ar 5/15/2001 14:23'!setFogRangeEnd: x	self costume renderedMorph fogRangeEnd: x * 0.01! !!Player methodsFor: 'slots-wonderland' stamp: 'ar 5/15/2001 14:23'!setFogRangeStart: x	self costume renderedMorph fogRangeStart: x * 0.01! !!Player methodsFor: 'slots-wonderland' stamp: 'ar 5/15/2001 14:12'!setFogType: x	self costume renderedMorph fogType: x! !!Project methodsFor: 'menu messages' stamp: 'ar 4/20/2001 02:10'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess |	(world isKindOf: StringMorph) ifTrue: [		self inform: 'This project is not all here. I will try to load a complete version.'.		^self loadFromServer: true	"try to get a fresh copy"	].	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	CurrentProject world trigger: #aboutToLeaveWorld.	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [			CurrentProject finalExitActions.			CurrentProject makeThumbnail.			returningFlag == #specialReturn				ifTrue:					[ProjectHistory forget: CurrentProject.		"this guy is irrelevant"					Project forget: CurrentProject]				ifFalse:					[ProjectHistory remember: CurrentProject]].	(revertFlag | saveForRevert | forceRevert) ifFalse:		[(Preferences valueOfFlag: #projectsSentToDisk) ifTrue:			[self storeToMakeRoom]].	CurrentProject abortResourceLoading.	Smalltalk isMorphic ifTrue: [CurrentProject world triggerClosingScripts].	CurrentProject saveProjectPreferences.	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresentAndInMemory:					[:playerClass | playerClass allSubInstancesDo:						[:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject _ nil	] ifFalse: [		returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	self installProjectPreferences.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ World pauseEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			world transferRemoteServerFrom: old world.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		world repairEmbeddedWorlds.		world trigger: #aboutToEnterWorld.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess _ [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!SystemDictionary class methodsFor: 'initialization' stamp: 'ar 4/20/2001 04:53'!initialize	"SystemDictionary initialize"	| oldList |	oldList _ StartUpList.	StartUpList _ OrderedCollection new.	"These get processed from the top down..."	Smalltalk addToStartUpList: DisplayScreen.	Smalltalk addToStartUpList: Cursor.	Smalltalk addToStartUpList: InputSensor.	Smalltalk addToStartUpList: ProcessorScheduler.  "Starts low space watcher and bkground."	Smalltalk addToStartUpList: Delay.	Smalltalk addToStartUpList: FileDirectory.  "Enables file stack dump and opens sources."	Smalltalk addToStartUpList: ShortIntegerArray.	Smalltalk addToStartUpList: ShortRunArray.	Smalltalk addToStartUpList: CrLfFileStream.	oldList ifNotNil: [oldList do: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToStartUpList: theClass]]].	Smalltalk addToStartUpList: ImageSegment.	Smalltalk addToStartUpList: PasteUpMorph.	Smalltalk addToStartUpList: ControlManager.	oldList _ ShutDownList.	ShutDownList _ OrderedCollection new.	"These get processed from the bottom up..."	Smalltalk addToShutDownList: DisplayScreen.	Smalltalk addToShutDownList: Form.	Smalltalk addToShutDownList: ControlManager.	Smalltalk addToShutDownList: PasteUpMorph.	Smalltalk addToShutDownList: StrikeFont.	Smalltalk addToShutDownList: Color.	Smalltalk addToShutDownList: FileDirectory.	Smalltalk addToShutDownList: Delay.	Smalltalk addToShutDownList: SoundPlayer.	Smalltalk addToShutDownList: HttpUrl.	Smalltalk addToShutDownList: Password.	Smalltalk addToShutDownList: PWS.	Smalltalk addToShutDownList: MailDB.	Smalltalk addToShutDownList: ImageSegment.	oldList ifNotNil: [oldList reverseDo: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToShutDownList: theClass]]].! !!TranslucentColor methodsFor: 'queries' stamp: 'ar 4/20/2001 04:33'!isOpaque	^alpha = 255! !!WonderlandActor methodsFor: 'drawing' stamp: 'ar 9/10/2000 02:24'!drawMesh: aRenderer	"Draw the mesh for this actor."	| polyMode |	myMaterial ifNotNil: [			aRenderer pushMaterial.			aRenderer material: myMaterial.						].	myTexture ifNotNil: [			aRenderer pushTexture.			aRenderer texture: myTexture.						].	aRenderer cullFace: self getBackfaceCulling.	polyMode _ self getPolygonMode.	aRenderer polygonMode: polyMode.	polyMode == nil ifFalse:[		aRenderer lineWidth: self getLineWidth.		aRenderer pointSize: self getPointSize.	].	"Note: Using myMesh>>renderOn: here prevents meshes from being picked!!"	myMesh ifNotNil: [ myMesh renderOn: aRenderer].	myTexture ifNotNil: [ aRenderer popTexture ].	myMaterial ifNotNil: [ aRenderer popMaterial ].! !!WonderlandActor methodsFor: 'private' stamp: 'ar 9/10/2000 00:24'!getBackfaceCulling	"Return backface culling - either #cw, #ccw or nil"	^self getProperty: #backfaceCulling! !!WonderlandActor methodsFor: 'private' stamp: 'ar 9/10/2000 02:21'!getLineWidth	^self getProperty: #lineWidth ifAbsent:[1]! !!WonderlandActor methodsFor: 'private' stamp: 'ar 9/10/2000 02:21'!getPointSize	^self getProperty: #pointSize ifAbsent:[1].! !!WonderlandActor methodsFor: 'private' stamp: 'ar 9/10/2000 02:20'!getPolygonMode	^self getProperty: #polygonMode! !!WonderlandActor methodsFor: 'private' stamp: 'ar 9/9/2000 23:53'!setBackfaceCulling: aSymbol	"Set backface culling. aSymbol must be either #cw, #ccw or nil"	self setProperty: #backfaceCulling toValue: aSymbol.! !!WonderlandActor methodsFor: 'private' stamp: 'ar 9/10/2000 02:22'!setLineWidth: aNumber	self setProperty: #lineWidth toValue: aNumber.! !!WonderlandActor methodsFor: 'private' stamp: 'ar 9/10/2000 02:22'!setPointSize: aNumber	self setProperty: #pointSize toValue: aNumber.! !!WonderlandActor methodsFor: 'private' stamp: 'ar 9/10/2000 02:22'!setPolygonMode: aSymbol	self setProperty: #polygonMode toValue: aSymbol.! !!WonderlandActor methodsFor: 'eToy-fake' stamp: 'ar 4/20/2001 05:11'!renameTo: aName	"Dunno what needs to be done here"! !!WonderlandCamera methodsFor: 'rendering' stamp: 'ar 5/15/2001 16:27'!render: aRenderEngine pickingAt: aPointOrNil withPrimitiveVertex: aBoolean	"Render one frame of the Wonderland using this camera.	If aPointOrNil is not nil then pick the top most object at this point.	For picking only: If aBoolean is true return an association 	object -> B3DPrimitiveVertex; otherwise simply return the top most object.	Note: If picking, no objects are actually drawn."	| aRenderer pickedObject |	aRenderer _ aRenderEngine. "A couple of things must be set before we can pick!!"	bounds _ nil. "forget bounds"	aRenderer viewport: myMorph bounds.	(drawSceneBackground)		ifTrue: [ aRenderer clearViewport: (myWonderland getScene) getColorObject. ]		ifFalse: [ ].	self renderFogOn: aRenderer.	aRenderer clearDepthBuffer.	aRenderer loadIdentity.	"Add any existing lights to the renderer for this camera"	(myWonderland getLights) do: [:light | aRenderer addLight: light ].	"Calculate our view matrix by inverting the camera's composite matrix and hand it	to the renderer - note that this will eventually have to walk up the tree"	viewMatrix _ self getMatrixToRoot.	aRenderer transformBy: viewMatrix.	aRenderer perspective: perspective.	"Initialize picking if necessary"	aPointOrNil == nil		ifFalse:[	"Make us a picker"				aRenderer _ aRenderer asPickerAt: aPointOrNil].	"Now render the scene"	myWonderland renderWonderland: aRenderer.	"Force the renderer to draw to the screen"	aRenderer finish.	"Fetch the picked object"	aPointOrNil ifNotNil:[		aBoolean			ifTrue:[pickedObject _ aRenderer topMostObject -> aRenderer topMostVertex]			ifFalse:[pickedObject _ aRenderer topMostObject]].	^pickedObject "Will be nil if not picking"! !!WonderlandCamera methodsFor: 'rendering' stamp: 'ar 9/9/2000 03:03'!renderBounds	"Compute 2D bounding boxes for all scene elements"	| engine |	engine _ (B3DRenderEngine defaultForPlatformOn: nil) asMapperEngine.	self render: engine.	bounds _ engine boundsMap.! !!WonderlandCamera methodsFor: 'rendering' stamp: 'ar 5/15/2001 14:04'!renderFogOn: aRenderer	"Set fog parameters if requested"	aRenderer		fogType: self getFogType		density: self getFogDensity		rangeStart: self getFogRangeStart		rangeEnd: self getFogRangeEnd		color: self getFogColor.! !!WonderlandCamera methodsFor: 'get property' stamp: 'ar 4/20/2001 03:32'!getBoundsForActor: anActor	"Return the 2D bounds of the actor as seen by the receiver"	bounds == nil ifTrue:[self renderBounds].	^bounds at: anActor ifAbsent:[nil]! !!WonderlandCamera methodsFor: 'get property' stamp: 'ar 5/15/2001 14:16'!getFogColor	^self getProperty: #fogColor ifAbsent:[Color black]! !!WonderlandCamera methodsFor: 'get property' stamp: 'ar 5/15/2001 14:16'!getFogDensity	^self getProperty: #fogDensity ifAbsent:[1.0]! !!WonderlandCamera methodsFor: 'get property' stamp: 'ar 5/15/2001 14:16'!getFogRangeEnd	^self getProperty: #fogRangeEnd ifAbsent:[1.0]! !!WonderlandCamera methodsFor: 'get property' stamp: 'ar 5/15/2001 14:16'!getFogRangeStart	^self getProperty: #fogRangeStart ifAbsent:[0.0]! !!WonderlandCamera methodsFor: 'get property' stamp: 'ar 5/15/2001 14:16'!getFogType	^self getProperty: #fogType ifAbsent:[#none]! !!WonderlandCamera methodsFor: 'set property' stamp: 'ar 5/15/2001 14:03'!setFogColor: aColor	self setProperty: #fogColor toValue: aColor! !!WonderlandCamera methodsFor: 'set property' stamp: 'ar 5/15/2001 14:03'!setFogDensity: aNumber	self setProperty: #fogDensity toValue: aNumber! !!WonderlandCamera methodsFor: 'set property' stamp: 'ar 5/15/2001 14:03'!setFogRangeEnd: aNumber	self setProperty: #fogRangeEnd toValue: aNumber! !!WonderlandCamera methodsFor: 'set property' stamp: 'ar 5/15/2001 14:03'!setFogRangeStart: aNumber	self setProperty: #fogRangeStart toValue: aNumber! !!WonderlandCamera methodsFor: 'set property' stamp: 'ar 5/15/2001 14:03'!setFogType: aSymbol	self setProperty: #fogType toValue: aSymbol! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'ar 5/14/2001 22:01'!drawAcceleratedOn: aCanvas	| myRect |	myRect _ (self bounds: bounds in: nil) intersect: (0@0 extent: DisplayScreen actualScreenSize).	(myRenderer notNil and:[myRenderer isAccelerated]) ifFalse:[		myRenderer ifNotNil:[myRenderer destroy].		myRenderer _ nil.	].	myRenderer ifNotNil:[		myRenderer _ myRenderer bufferRect: myRect.	].	myRenderer ifNil:[		myRenderer _ B3DHardwareEngine newIn: myRect.		myRenderer ifNil:[^self drawSimulatedOn: aCanvas].	] ifNotNil:[		myRenderer reset.	].	myRenderer viewportOffset: aCanvas origin.	myRenderer clipRect: aCanvas clipRect.	myCamera drawSceneBackground ifFalse:[		myRenderer restoreMorphicBackground: myRect under: self.	].	self renderOn: myRenderer.	self outline ifNotNil:[		myRenderer provideOverlayCanvasDuring:[:overlay| self sketchOn: overlay].	].	myRenderer restoreMorphicForeground: myRect above: self.	Display addExtraRegion: myRect for: self.! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'ar 4/19/2001 05:51'!drawOn: aCanvas 	(aCanvas form == Display and:[self accelerationEnabled and:[self isFlexed not]])		ifTrue:[self drawAcceleratedOn: aCanvas]		ifFalse:[self drawSimulatedOn: aCanvas].! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'ar 5/14/2001 20:57'!drawSimulatedOn: aCanvas	"Draw the receiver using the builtin software renderer"	(myRenderer notNil and:[myRenderer isOverlayRenderer]) ifTrue:[		"Dump it. We may just being dragged around by the hand."		myRenderer destroy.		myRenderer _ nil].	aCanvas asBalloonCanvas render: self.	self outline ifNotNil:[self sketchOn: aCanvas].! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'ar 5/14/2001 23:09'!forceToScreen	"When using hardware acceleration, this method forces the receiver to swap its buffers."	myRenderer ifNotNil:[		myRenderer swapBuffers ifFalse:[			"Something went wrong"			myRenderer destroy.			myRenderer _ nil]].! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'ar 4/20/2001 02:47'!renderOn: aRenderer	"Tell our camera to draw"	myCamera render: aRenderer.! !!WonderlandCameraMorph methodsFor: 'initialization' stamp: 'ar 4/20/2001 02:17'!intoWorld: aWorld	"The receiver is showing in the given world"	aWorld ifNil:[^self].	super intoWorld: aWorld.	aWorld when: #aboutToLeaveWorld send: #suspendAcceleration to: self.	aWorld when: #aboutToEnterWorld send: #restoreAcceleration to: self.	self restoreAcceleration.! !!WonderlandCameraMorph methodsFor: 'initialization' stamp: 'ar 4/20/2001 02:17'!outOfWorld: aWorld	"The receiver is leaving the given world"	aWorld ifNil:[^self].	self suspendAcceleration.	aWorld removeEventsTriggeredFor: self.	super outOfWorld: aWorld.! !!WonderlandCameraMorph methodsFor: 'menu' stamp: 'ar 4/20/2001 02:54'!addCustomMenuItems: aCustomMenu hand: aHandMorph 	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu addUpdating: #snapshotBackgroundString action: #toggleSnapshotBackground.	aCustomMenu addUpdating: #firstPersonControlString action: #toggleFirstPersonControl.	aCustomMenu addUpdating: #showControlsString action: #toggleCameraControls.	aCustomMenu addUpdating: #getAcceleratorState action: #toggleAcceleratorState.	aCustomMenu addLine.	aCustomMenu add: 'Stop/Go button' action: #attachStopGoButtons.	aCustomMenu add: 'Load actor' action: #loadActor.! !!WonderlandCameraMorph methodsFor: 'menu' stamp: 'ar 4/20/2001 04:10'!getAcceleratorState	^self accelerationEnabled		ifTrue:['<on>hardware acceleration']		ifFalse:['<off>hardware acceleration']! !!WonderlandCameraMorph methodsFor: 'menu' stamp: 'ar 4/20/2001 05:05'!toggleAcceleratorState	self accelerationEnabled: self accelerationEnabled not.! !!WonderlandCameraMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 02:15'!accelerationEnabled	"Return true if hardware acceleration is enabled"	self accelerationSuspended ifTrue:[^false].	^self valueOfProperty: #accelerationEnabled ifAbsent:[false]! !!WonderlandCameraMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 05:08'!accelerationEnabled: aBool	"Enable or disable hardware acceleration"	| aWorld |	"no dangling renderers please"	myRenderer ifNotNil:[myRenderer destroy].	myRenderer _ nil.	aBool		ifTrue:[self setProperty: #accelerationEnabled toValue: aBool]		ifFalse:[self removeProperty: #accelerationEnabled].	"For now make sure we're registered with the world in case this guy came from the disk"	(aWorld _ self world) ifNotNil:[		aWorld removeEventsTriggeredFor: self.		aWorld when: #aboutToLeaveWorld send: #suspendAcceleration to: self.		aWorld when: #aboutToEnterWorld send: #restoreAcceleration to: self.	].! !!WonderlandCameraMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 02:15'!accelerationSuspended	"Return true if hardware acceleration is temporarily suspended"	^self valueOfProperty: #accelerationSuspended ifAbsent:[false]! !!WonderlandCameraMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 05:08'!accelerationSuspended: aBool	"Temporarily suspend hardware acceleration"	myRenderer ifNotNil:[myRenderer destroy].	myRenderer _ nil.	aBool		ifTrue:[self setProperty: #accelerationSuspended toValue: aBool]		ifFalse:[self removeProperty: #accelerationSuspended]! !!WonderlandCameraMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 02:14'!restoreAcceleration	"Restore temporarily suspend acceleration"	self accelerationSuspended: false.! !!WonderlandCameraMorph methodsFor: 'hardware acceleration' stamp: 'ar 4/20/2001 05:08'!suspendAcceleration	"Temporarily suspend acceleration"	self accelerationSuspended: true.	self changed.! !!WonderlandCameraMorph methodsFor: 'fog properties' stamp: 'ar 5/15/2001 13:59'!fogColor	^myCamera getFogColor! !!WonderlandCameraMorph methodsFor: 'fog properties' stamp: 'ar 5/15/2001 14:00'!fogColor: aColor	myCamera setFogColor: aColor! !!WonderlandCameraMorph methodsFor: 'fog properties' stamp: 'ar 5/15/2001 14:00'!fogDensity	^myCamera getFogDensity! !!WonderlandCameraMorph methodsFor: 'fog properties' stamp: 'ar 5/15/2001 14:12'!fogDensity: aNumber	myCamera setFogDensity: (aNumber max: 0.0)! !!WonderlandCameraMorph methodsFor: 'fog properties' stamp: 'ar 5/15/2001 14:00'!fogRangeEnd	^myCamera getFogRangeEnd! !!WonderlandCameraMorph methodsFor: 'fog properties' stamp: 'ar 5/15/2001 14:22'!fogRangeEnd: aNumber	myCamera setFogRangeEnd: (aNumber min: 1.0 max: 0.0)! !!WonderlandCameraMorph methodsFor: 'fog properties' stamp: 'ar 5/15/2001 14:00'!fogRangeStart	^myCamera getFogRangeStart! !!WonderlandCameraMorph methodsFor: 'fog properties' stamp: 'ar 5/15/2001 14:24'!fogRangeStart: aNumber	myCamera setFogRangeStart: (aNumber min: self fogRangeEnd max: 0.0)! !!WonderlandCameraMorph methodsFor: 'fog properties' stamp: 'ar 5/15/2001 14:01'!fogType	^(#(none linear exp exp2) indexOf: myCamera getFogType) - 1! !!WonderlandCameraMorph methodsFor: 'fog properties' stamp: 'ar 5/15/2001 14:21'!fogType: aNumber	myCamera setFogType: (#(none linear exp exp2) atWrap: aNumber + 1)! !!WonderlandCameraMorph class methodsFor: 'scripting' stamp: 'ar 5/15/2001 14:10'!additionsToViewerCategories	^ #((fog (			(slot fogColor 'The color of fog being applied' color readWrite 				player getFogColor player setFogColor:)			(slot fogType 'The type of fog being applied' number readWrite 				player getFogType player setFogType:)			(slot fogDensity 'The density of fog being applied' number readWrite 				player getFogDensity player setFogDensity:)			(slot fogRangeStart 'The range start of fog being applied' number readWrite 				player getFogRangeStart player setFogRangeStart:)			(slot fogRangeEnd 'The range start of fog being applied' number readWrite 				player getFogRangeEnd player setFogRangeEnd:))))! !!WonderlandStillCamera methodsFor: 'rendering' stamp: 'ar 9/8/2000 16:52'!render: aRenderEngine pickingAt: aPointOrNil withPrimitiveVertex: aBoolean	"Override the parent method. A WonderlandStillCamera only renders the object that it's focusing on."	| aRenderer pickedObject |	aRenderer _ aRenderEngine. "A couple of things must be set before we can pick!!"	aRenderer viewport: (myMorph bounds insetBy: 1@1).	(drawSceneBackground)		ifTrue: [ aRenderer clearViewport: (myWonderland getScene getColorObject). ]		ifFalse: [ ].	aRenderer clearDepthBuffer.	aRenderer loadIdentity.	focusObject ifNotNil: [		"Add any existing lights to the renderer for this camera"		(myWonderland getLights) do: [:light | aRenderer addLight: light ].		"Calculate our view matrix by inverting the camera's composite matrix and hand it		to the renderer - note that this will eventually have to walk up the tree"		viewMatrix _ self getMatrixToRoot.		aRenderer transformBy: viewMatrix.		aRenderer perspective: perspective.		"Initialize picking if necessary"		aPointOrNil ifNotNil:[aRenderer _ aRenderer asPickerAt: aPointOrNil].		(focusObject isKindOf: WonderlandScene)			ifTrue: [ myWonderland renderWonderland: aRenderer ]			ifFalse: [ aRenderer transformBy: (focusObject getParent getMatrixFromRoot).					  focusObject renderOn: aRenderer ].		"Fetch the picked object"		aPointOrNil ifNotNil:[			aBoolean				ifTrue:[pickedObject _ aRenderer topMostObject -> aRenderer topMostVertex]				ifFalse:[pickedObject _ aRenderer topMostObject]].	].	"Force the renderer to draw to the screen"	aRenderer finish.	^pickedObject "Will be nil if not picking".! !!WonderlandWrapperMorph methodsFor: 'private' stamp: 'ar 4/20/2001 03:37'!computeBounds: morph	| box |	box _ myActor getFullBoundsFor: morph getCamera.	box == nil ifFalse:[bounds _ box].! !!WorldState methodsFor: 'update cycle' stamp: 'ar 4/19/2001 05:45'!forceDamageToScreen: allDamage	"here for the convenience of NebraskaWorldState"	Display forceDamageToScreen: allDamage.	self remoteCanvasesDo: [ :each | 		allDamage do: [:r | each forceToScreen: r].		each displayIsFullyUpdated.	].! !SystemDictionary initialize!B3DHardwareEngine class removeSelector: #rasterizer!B3DHardwareEngine removeSelector: #privateTransformVB:!B3DPrimitiveEngine subclass: #B3DHardwareEngine	instanceVariableNames: 'handle target bufRect textures backingForm '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Acceleration'!!B3DHardwareEngine reorganize!('initialize' bufferRect: destroy finish flush initialize initializeIn: initializeTarget reset swapBuffers)('accessing' target target: viewport:)('attributes' clearDepthBuffer clearViewport: cullFace cullFace: fogType:density:rangeStart:rangeEnd:color: lineWidth lineWidth: pointSize pointSize: polygonMode polygonMode: swapInterval swapInterval:)('testing' isAccelerated isOverlayRenderer)('morphic-support' compositeTexture:at:translucent: provideOverlayCanvasDuring: restoreMorphicBackground:under: restoreMorphicForeground:above:)('private-rendering' privateSetViewport: processVertexBuffer: renderPrimitive)('private-textures' allocateOrRecycleTexture: allocateTexture: destroyTexture: displayForm:on: displayForm:on:from: textureHandleOf: uploadTexture:)('primitives-rendering' primClearDepthBuffer: primFinish: primFlush: primRender:clearViewport:with: primRender:getProperty: primRender:setBufferRectX:y:w:h: primRender:setFog:density:rangeStart:rangeEnd:color: primRender:setLights: primRender:setMaterial: primRender:setModelView:projection: primRender:setProperty:toInteger: primRender:setViewportX:y:w:h: primRenderVB:primitive:flags:texture:vertices:vertexCount:faces:faceCount: primSwapBuffers:)('primitives-textures' primRender:allocateTexture:width:height: primRender:compositeTexture:x:y:w:h:translucent: primRender:destroyTexture: primRender:getTextureByteSex: primRender:getTextureDepth: primRender:getTextureSurface: primRender:texture:colorMasksInto: primRender:uploadTexture:from:)('primitives-renderer' primCreateRendererSW:hw:x:y:w:h: primDestroyRenderer: primRender:getColorMasksInto: primRenderGetSurfaceDepth: primRenderGetSurfaceHandle: primRenderGetSurfaceHeight: primRenderGetSurfaceWidth: primRenderIsOverlay:)!B3DAcceleratorPlugin removeSelector: #primitiveAllocateForm!B3DAcceleratorPlugin removeSelector: #primitiveBltFromDisplay!B3DAcceleratorPlugin removeSelector: #primitiveBltToDisplay!B3DAcceleratorPlugin removeSelector: #primitiveCreateDisplaySurface!B3DAcceleratorPlugin removeSelector: #primitiveDestroyDisplaySurface!B3DAcceleratorPlugin removeSelector: #primitiveDestroyForm!B3DAcceleratorPlugin removeSelector: #primitiveDisplayGetColorMasks!B3DAcceleratorPlugin removeSelector: #primitiveFillDisplaySurface!B3DAcceleratorPlugin removeSelector: #primitiveFinishDisplaySurface!B3DAcceleratorPlugin removeSelector: #primitiveFlushDisplaySurface!B3DAcceleratorPlugin removeSelector: #primitiveFormGetColorMasks!B3DAcceleratorPlugin removeSelector: #primitiveProcessVertexBuffer!B3DAcceleratorPlugin removeSelector: #primitiveRasterizerVersion!B3DAcceleratorPlugin removeSelector: #primitiveSupportsDisplayDepth!B3DAcceleratorPlugin removeSelector: #primitiveTextureHeight!B3DAcceleratorPlugin removeSelector: #primitiveTextureWidth!"Postscript:Make all wonderlands register and fix up the wrong pool definition."B3DPoolDefiner initPool.WonderlandCameraMorph allSubInstancesDo:[:m| m intoWorld: m world].B3DSceneMorph allSubInstancesDo:[:m| m intoWorld: m world].Vocabulary initialize.!