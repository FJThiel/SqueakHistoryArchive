'From Squeak2.9alpha of 13 June 2000 [latest update: #3385] on 2 February 2001 at 3:14:28 pm'!"Change Set:		AllNamedPrimsDate:			2 February 2001Author:			Andreas RaabThe change set replaces all the obsolete indexed primitives with named primitives."!!AsyncFile methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primClose: fHandle	"Close this file. Do nothing if primitive fails."	<primitive: 'primitiveAsyncFileClose' module: 'AsynchFilePlugin'>! !!AsyncFile methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primOpen: fileName forWrite: openForWrite semaIndex: semaIndex	"Open a file of the given name, and return a handle for that file. Answer the receiver if the primitive succeeds, nil otherwise."	<primitive: 'primitiveAsyncFileOpen' module: 'AsynchFilePlugin'>	^ nil! !!AsyncFile methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primReadResult: fHandle intoBuffer: buffer at: startIndex count: count	"Copy the result of the last read operation into the given buffer starting at the given index. The buffer may be any sort of bytes or words object, excluding CompiledMethods. Answer the number of bytes read. A negative result means:		-1 the last operation is still in progress		-2 the last operation encountered an error"	<primitive: 'primitiveAsyncFileReadResult' module: 'AsynchFilePlugin'>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primReadStart: fHandle fPosition: fPosition count: count	"Start a read operation of count bytes starting at the given offset in the given file."	<primitive: 'primitiveAsyncFileReadStart' module: 'AsynchFilePlugin'>	self error: 'READ THE COMMENT FOR THIS METHOD.'"NOTE: This method will fail if there is insufficient C heap to allocate an internal buffer of the required size (the value of count).  If you are trying to read a movie file, then the buffer size will be height*width*2 bytes.  Each Squeak image retains a value to be used for this allocation, and it it initially set to 0.  If you are wish to play a 640x480 movie, you need room for a buffer of 640*480*2 = 614400 bytes.  You should execute the following...	Smalltalk extraVMMemory 2555000.Then save-and-quit, restart, and try to open the movie file again.  If you are using Async files in another way, find out the value of count when this failure occurs (call it NNNN), and instead of the above, execute...	Smalltalk extraVMMemory: Smalltalk extraVMMemory + NNNNthen save-and-quit, restart, and try again."! !!AsyncFile methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primWriteResult: fHandle	"Answer the number of bytes written. A negative result means:		-1 the last operation is still in progress		-2 the last operation encountered an error"	<primitive: 'primitiveAsyncFileWriteResult' module: 'AsynchFilePlugin'>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primWriteStart: fHandle fPosition: fPosition fromBuffer: buffer at: startIndex count: count	"Start a write operation of count bytes starting at the given index in the given buffer. The buffer may be any sort of bytes or words object, excluding CompiledMethods. The contents of the buffer are copied into an internal buffer immediately, so the buffer can be reused after the write operation has been started. Fail if there is insufficient C heap to allocate an internal buffer of the requested size."	<primitive: 'primitiveAsyncFileWriteStart' module: 'AsynchFilePlugin'>	writeable ifFalse: [^ self error: 'attempt to write a file opened read-only'].	self primitiveFailed! !!BitBlt methodsFor: 'copying' stamp: 'ar 2/2/2001 15:09'!copyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'copying' stamp: 'ar 2/2/2001 15:09'!copyBitsTranslucent: factor	"This entry point to BitBlt supplies an extra argument to specify translucency	for operations 30 and 31.  The argument must be an integer between 0 and 255."	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	self primitiveFailed  "Later do nicer error recovery -- share copyBits recovery"! !!BitBlt methodsFor: 'line drawing' stamp: 'ar 2/2/2001 15:09'!drawLoopX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."	| dx dy px py P |	<primitive: 'primitiveDrawLoop' module: 'BitBltPlugin'>	dx _ xDelta sign.	dy _ yDelta sign.	px _ yDelta abs.	py _ xDelta abs.	"self copyBits."	py > px		ifTrue: 			["more horizontal"			P _ py // 2.			1 to: py do: 				[:i |				destX _ destX + dx.				(P _ P - px) < 0 ifTrue: 						[destY _ destY + dy.						P _ P + py].				i < py ifTrue: [self copyBits]]]		ifFalse: 			["more vertical"			P _ px // 2.			1 to: px do:				[:i |				destY _ destY + dy.				(P _ P - py) < 0 ifTrue: 						[destX _ destX + dx.						P _ P + px].				i < px ifTrue: [self copyBits]]]! !!BitBlt methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!copyBitsAgain	"Primitive. See BitBlt|copyBits, also a Primitive. Essential. See Object	documentation whatIsAPrimitive."	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	self primitiveFailed! !!FXBlt methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!copyBitsAgain	"Primitive. See BitBlt|copyBits, also a Primitive. Essential. See Object	documentation whatIsAPrimitive."	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	self primitiveFailed! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primCreateDirectory: fullPath	"Create a directory named by the given path. Fail if the path is bad or if a file or directory by that name already exists." 	<primitive: 'primitiveDirectoryCreate' module: 'FilePlugin'>	self primitiveFailed! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primDeleteDirectory: fullPath	"Delete the directory named by the given path. Fail if the path is bad or if a directory by that name does not exist." 	<primitive: 'primitiveDirectoryDelete' module: 'FilePlugin'>	self primitiveFailed! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primDeleteFileNamed: aFileName	"Delete the file of the given name. Return self if the primitive succeeds, nil otherwise."	<primitive: 'primitiveFileDelete' module: 'FilePlugin'>	^ nil! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primGetMacFileNamed: fileName type: typeString creator: creatorString	"Get the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4. This primitive is Mac specific; it is a noop on other platforms." 	<primitive: 'primitiveDirectoryGetMacTypeAndCreator' module: 'FilePlugin'>! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primLookupEntryIn: fullPath index: index	"Look up the index-th entry of the directory with the given fully-qualified path (i.e., starting from the root of the file hierarchy) and return an array containing:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>	The empty string enumerates the top-level files or drives. (For example, on Unix, the empty path enumerates the contents of '/'. On Macs and PCs, it enumerates the mounted volumes/drives.)	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad." 	<primitive: 'primitiveDirectoryLookup' module: 'FilePlugin'>	^ #badDirectoryPath! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primRename: oldFileFullName to: newFileFullName 	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name.	Changed to return nil instead of failing ar 3/21/98 18:04"	<primitive: 'primitiveFileRename' module: 'FilePlugin'>	^nil! !!FileDirectory methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primSetMacFileNamed: fileName type: typeString creator: creatorString	"Set the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4. This primitive is Mac specific; it is a noop on other platforms." 	<primitive: 'primitiveDirectorySetMacTypeAndCreator' module: 'FilePlugin'>	self primitiveFailed! !!FileDirectory class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primPathNameDelimiter	"Return the path delimiter for the underlying platform's file system." 	<primitive: 'primitiveDirectoryDelimitor' module: 'FilePlugin'>	self primitiveFailed! !!InputSensor methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primReadJoystick: index	"Return the joystick input word for the joystick with the given index in the range [1..16]. Returns zero if the index does not correspond to a currently installed joystick."	<primitive: 'primitiveReadJoystick' module: 'JoystickTabletPlugin'>	^ 0	! !!InputSensor methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primTabletGetParameters: cursorIndex	"Answer the pen tablet parameters. For parameters that differ from cursor to cursor, answer those associated with the cursor having the given index. Answer nil if there is no pen tablet. The parameters are:	1. tablet width, in tablet units	2. tablet height, in tablet units	3. number of tablet units per inch	4. number of cursors (pens, pucks, etc; some tablets have more than one)	5. this cursor index	6. and 7. x scale and x offset for scaling tablet coordintes (e.g., to fit the screen)	8. and 9. y scale and y offset for scaling tablet coordintes  (e.g., to fit the screen)	10. number of pressure levels	11. presure threshold needed close pen tip switch 	12. number of pen tilt angles"	<primitive: 'primitiveGetTabletParameters' module: 'JoystickTabletPlugin'>	^ nil! !!InputSensor methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primTabletRead: cursorIndex	"Answer the pen tablet data for the cursor having the given index. Answer nil if there is no pen tablet. The data is:	1. index of the cursor to which this data applies	2. timestamp of the last state chance for this cursor	3., 4., and 5. x, y, and z coordinates of the cursor (z is typically 0)	6. and 7. xTilt and yTilt of the cursor; (signed)	8. type of cursor (0 = unknown, 1 = pen, 2 = puck, 3 = eraser)	9. cursor buttons	10. cursor pressure, downward	11. cursor pressure, tangential	12. flags"	<primitive: 'primitiveReadTablet' module: 'JoystickTabletPlugin'>	self primitiveFailed! !!MidiPrimTester methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIClosePort: portNum	<primitive: 'primitiveMIDIClosePort' module: 'MIDIPlugin'>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIGetClock	<primitive: 'primitiveMIDIGetClock' module: 'MIDIPlugin'>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIGetPortCount	<primitive: 'primitiveMIDIGetPortCount' module: 'MIDIPlugin'>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIGetPortDirectionality: portNum	<primitive: 'primitiveMIDIGetPortDirectionality' module: 'MIDIPlugin'>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIGetPortName: portNum	<primitive: 'primitiveMIDIGetPortName' module: 'MIDIPlugin'>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIOpenPort: portNum readSemaIndex: readSemaIndex interfaceClockRate: interfaceClockRate	"Open the given MIDI port. If non-zero, readSemaIndex specifies the index in the external objects array of a semaphore to be signalled when incoming MIDI data is available. Not all platforms support signalling the read semaphore. InterfaceClockRate specifies the clock rate of the external MIDI interface adaptor on Macintosh computers; it is ignored on other platforms."	<primitive: 'primitiveMIDIOpenPort' module: 'MIDIPlugin'>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIParameterGet: whichParameter	<primitive: 'primitiveMIDIParameterGetOrSet' module: 'MIDIPlugin'>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIParameterSet: whichParameter to: newValue	<primitive: 'primitiveMIDIParameterGetOrSet' module: 'MIDIPlugin'>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIReadPort: portNum into: byteArray	<primitive: 'primitiveMIDIRead' module: 'MIDIPlugin'>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIWritePort: portNum from: byteArray at: midiClockValue	<primitive: 'primitiveMIDIWrite' module: 'MIDIPlugin'>	self primitiveFailed.! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'ar 2/2/2001 15:09'!primInitializeNetwork: resolverSemaIndex	"Initialize the network drivers on platforms that need it, such as the Macintosh, and return nil if network initialization failed or the reciever if it succeeds. Since mobile computers may not always be connected to a network, this method should NOT be called automatically at startup time; rather, it should be called when first starting a networking application. It is a noop if the network driver has already been initialized. If non-zero, resolverSemaIndex is the index of a VM semaphore to be associated with the network name resolver. This semaphore will be signalled when the resolver status changes, such as when a name lookup query is completed."	"Note: some platforms (e.g., Mac) only allow only one name lookup query at a time, so a manager process should be used to serialize resolver lookup requests."	<primitive: 'primitiveInitializeNetwork' module: 'SocketPlugin'>	^ nil  "return nil if primitive fails"! !!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primAbortLookup	"Abort the current lookup operation, freeing the name resolver for the next query."	<primitive: 'primitiveResolverAbortLookup' module: 'SocketPlugin'>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primAddressLookupResult	"Return the host name found by the last host address lookup. Returns nil if the last lookup was unsuccessful."	<primitive: 'primitiveResolverAddressLookupResult' module: 'SocketPlugin'>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primLocalAddress	"Return the local address of this host."	<primitive: 'primitiveResolverLocalAddress' module: 'SocketPlugin'>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primNameLookupResult	"Return the host address found by the last host name lookup. Returns nil if the last lookup was unsuccessful."	<primitive: 'primitiveResolverNameLookupResult' module: 'SocketPlugin'>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primNameResolverError	"Return an integer reflecting the error status of the last network name resolver request. Zero means no error."	<primitive: 'primitiveResolverError' module: 'SocketPlugin'>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primNameResolverStatus	"Return an integer reflecting the status of the network name resolver. For a list of possible values, see the comment in the 'initialize' method of this class."	<primitive: 'primitiveResolverStatus' module: 'SocketPlugin'>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primStartLookupOfAddress: hostAddr	"Look up the given host address in the Domain Name Server to find its name. This call is asynchronous. To get the results, wait for it to complete or time out and then use primAddressLookupResult."	<primitive: 'primitiveResolverStartAddressLookup' module: 'SocketPlugin'>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primStartLookupOfName: hostName	"Look up the given host name in the Domain Name Server to find its address. This call is asynchronous. To get the results, wait for it to complete or time out and then use primNameLookupResult."	<primitive: 'primitiveResolverStartNameLookup' module: 'SocketPlugin'>	self primitiveFailed! !!SerialPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primClosePort: portNumber	<primitive: 'primitiveSerialPortClose' module: 'SerialPlugin'>	^ nil  "(DNS)"	"self primitiveFailed."! !!SerialPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primOpenPort: portNumber baudRate: baud stopBitsType: stop	parityType: parity dataBits: numDataBits	inFlowControlType: inFlowCtrl outFlowControlType: outFlowCtrl	xOnByte: xOn xOffByte: xOff	<primitive: 'primitiveSerialPortOpen' module: 'SerialPlugin'>	^ nil  "(DNS)"! !!SerialPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primReadPort: portNumber into: byteArray startingAt: startIndex count: count	<primitive: 'primitiveSerialPortRead' module: 'SerialPlugin'>	self primitiveFailed.! !!SerialPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primWritePort: portNumber from: byteArray startingAt: startIndex count: count	<primitive: 'primitiveSerialPortWrite' module: 'SerialPlugin'>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIClosePort: portNum	"Close the given MIDI port. Don't fail if port is already closed."	<primitive: 'primitiveMIDIClosePort' module: 'MIDIPlugin'>! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIOpenPort: portNum readSemaIndex: readSemaIndex interfaceClockRate: interfaceClockRate	"Open the given MIDI port. If non-zero, readSemaIndex specifies the index in the external objects array of a semaphore to be signalled when incoming MIDI data is available. Not all platforms support signalling the read semaphore. InterfaceClockRate specifies the clock rate of the external MIDI interface adaptor on Macintosh computers; it is ignored on other platforms."	<primitive: 'primitiveMIDIOpenPort' module: 'MIDIPlugin'>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIReadPort: portNum into: byteArray	"Read any available MIDI data into the given buffer (up to the size of the buffer) and answer the number of bytes read."	<primitive: 'primitiveMIDIRead' module: 'MIDIPlugin'>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primMIDIWritePort: portNum from: byteArray at: midiClockValue	"Queue the given data to be sent through the given MIDI port at the given time. If midiClockValue is zero, send the data immediately."	<primitive: 'primitiveMIDIWrite' module: 'MIDIPlugin'>	self primitiveFailed.! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primPortCount	"Answer the number of MIDI ports supported by this platform, or zero if this primitive is not implemented."	<primitive: 'primitiveMIDIGetPortCount' module: 'MIDIPlugin'>	^ 0! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primPortDirectionalityOf: portNum	"Answer the platform-specific name for the given MIDI port."	<primitive: 'primitiveMIDIGetPortDirectionality' module: 'MIDIPlugin'>	self primitiveFailed.! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primPortNameOf: portNum	"Answer the platform-specific name for the given MIDI port."	<primitive: 'primitiveMIDIGetPortName' module: 'MIDIPlugin'>	self primitiveFailed.! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex	"Create and return a new socket handle based on accepting the connection from the given listening socket"	<primitive: 'primitiveSocketAccept' module: 'SocketPlugin'>	^self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID connectTo: hostAddress port: port	"Attempt to establish a connection to the given port of the given host. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 'primitiveSocketConnectToPort' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID listenOn: port	"Listen for a connection on the given port. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: aHandle listenOn: portNumber backlogSize: backlog	"Primitive. Set up the socket to listen on the given port.	Will be used in conjunction with #accept only."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self destroy. "Accept not supported so clean up"! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID receiveDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."	<primitive: 'primitiveSocketReceiveDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID sendData: aStringOrByteArray startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive: 'primitiveSocketSendDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID setPort: port	"Set the local port associated with a UDP socket.	Note: this primitive is overloaded.  The primitive will not fail on a TCP socket, but	the effects will not be what was desired.  Best solution would be to split Socket into	two subclasses, TCPSocket and UDPSocket."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketAbortConnection: socketID	"Terminate the connection on the given port immediately without going through the normal close sequence. This is an asynchronous call; query the socket status to discover if and when the connection is actually terminated."	<primitive: 'primitiveSocketAbortConnection' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketCloseConnection: socketID	"Close the connection on the given port. The remote end is informed that this end has closed and will do no further sends. This is an asynchronous call; query the socket status to discover if and when the connection is actually closed."	<primitive: 'primitiveSocketCloseConnection' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketConnectionStatus: socketID	"Return an integer reflecting the connection status of this socket. For a list of possible values, see the comment in the 'initialize' method of this class. If the primitive fails, return a status indicating that the socket handle is no longer valid, perhaps because the Squeak image was saved and restored since the socket was created. (Sockets do not survive snapshots.)"	<primitive: 'primitiveSocketConnectionStatus' module: 'SocketPlugin'>	^ InvalidSocket! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex	"Return a new socket handle for a socket of the given type and buffer sizes. Return nil if socket creation fails.	The netType parameter is platform dependent and can be used to encode both the protocol type (IP, Xerox XNS, etc.) and/or the physical network interface to use if this host is connected to multiple networks. A zero netType means to use IP protocols and the primary (or only) network interface.	The socketType parameter specifies:		0	reliable stream socket (TCP if the protocol is IP)		1	unreliable datagram socket (UDP if the protocol is IP)	The buffer size parameters allow performance to be tuned to the application. For example, a larger receive buffer should be used when the application expects to be receiving large amounts of data, especially from a host that is far away. These values are considered requests only; the underlying implementation will ensure that the buffer sizes actually used are within allowable bounds. Note that memory may be limited, so an application that keeps many sockets open should use smaller buffer sizes. Note the macintosh implementation ignores this buffer size. Also see setOption to get/set socket buffer sizes which allows you to set/get the current buffer sizes for reading and writing. 	If semaIndex is > 0, it is taken to be the index of a Semaphore in the external objects array to be associated with this socket. This semaphore will be signalled when the socket status changes, such as when data arrives or a send completes. All processes waiting on the semaphore will be awoken for each such event; each process must then query the socket state to figure out if the conditions they are waiting for have been met. For example, a process waiting to send some data can see if the last send has completed."	<primitive: 'primitiveSocketCreate' module: 'SocketPlugin'>	^ nil  "socket creation failed"! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketDestroy: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted."	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketDestroyGently: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted.	Do not fail if the receiver is already closed."	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketError: socketID	"Return an integer encoding the most recent error on this socket. Zero means no error."	<primitive: 'primitiveSocketError' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketLocalAddress: socketID	"Return the local host address for this socket."	<primitive: 'primitiveSocketLocalAddress' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketLocalPort: socketID	"Return the local port for this socket, or zero if no port has yet been assigned."	<primitive: 'primitiveSocketLocalPort' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketReceiveDataAvailable: socketID	"Return true if data may be available for reading from the current socket."	<primitive: 'primitiveSocketReceiveDataAvailable' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketRemoteAddress: socketID	"Return the remote host address for this socket, or zero if no connection has been made."	<primitive: 'primitiveSocketRemoteAddress' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketRemotePort: socketID	"Return the remote port for this socket, or zero if no connection has been made."	<primitive: 'primitiveSocketRemotePort' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketSendDone: socketID	"Return true if there is no send in progress on the current socket."	<primitive: 'primitiveSocketSendDone' module: 'SocketPlugin'>	self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primSoundAvailableBytes	"Return the number of bytes of available space in the sound output buffer."	"Note: Squeak always uses buffers containing 4-bytes per sample (2 channels at 2 bytes per channel) regardless of the state of the Stereo flag."	<primitive: 'primitiveSoundAvailableSpace' module: 'SoundPlugin'>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primSoundInsertSamples: count from: aSoundBuffer samplesOfLeadTime: anInteger	"Mix the given number of sample frames from the given sound buffer into the queue of samples that has already been submitted to the sound driver. This primitive is used to start a sound playing with minimum latency, even if large sound output buffers are being used to ensure smooth sound output. Returns the number of samples consumed, or zero if the primitive is not implemented or fails."	<primitive: 'primitiveSoundInsertSamples' module: 'SoundPlugin'>	^ 0! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primSoundPlaySamples: count from: aSampleBuffer startingAt: index	"Copy count bytes into the current sound output buffer from the given sample buffer starting at the given index."	<primitive: 'primitiveSoundPlaySamples' module: 'SoundPlugin'>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start double-buffered sound output with the given buffer size and sampling rate. This version has been superceded by primitive 171 (primSoundStartBufferSize:rate:stereo:semaIndex:)."	"ar 12/5/1998 Turn off the sound if not supported"	<primitive: 'primitiveSoundStart' module: 'SoundPlugin'>	SoundSupported _ false.! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag semaIndex: anInteger	"Start double-buffered sound output with the given buffer size and sampling rate. If the given semaphore index is > 0, it is taken to be the index of a Semaphore in the external objects array to be signalled when the sound driver is ready to accept another buffer of samples."	"Details: If this primitive fails, this method tries to use the older version instead."	<primitive: 'primitiveSoundStartWithSemaphore' module: 'SoundPlugin'>	UseReadySemaphore _ false.	self primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag.! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primSoundStop	"Stop double-buffered sound output."	<primitive: 'primitiveSoundStop' module: 'SoundPlugin'>	^ self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primGetActualRecordingSampleRate	"Return the actual sample rate being used for recording. This primitive fails unless sound recording is currently in progress."	<primitive: 'primitiveSoundGetRecordingSampleRate' module: 'SoundPlugin'>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primRecordSamplesInto: aWordArray startingAt: index	"Record a sequence of 16-bit sound samples into the given array starting at the given sample index. Return the number of samples recorded, which may be zero if no samples are currently available."	<primitive: 'primitiveSoundRecordSamples' module: 'SoundPlugin'>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSetRecordLevel: anInteger	"Set the desired recording level to the given value in the range 0-1000, where 0 is the lowest recording level and 1000 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	<primitive: 'primitiveSoundSetRecordLevel' module: 'SoundPlugin'>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primStartRecordingDesiredSampleRate: samplesPerSec stereo: stereoFlag semaIndex: anInteger	"Start sound recording with the given stereo setting. Use a sampling rate as close to the desired rate as the underlying platform will support. If the given semaphore index is > 0, it is taken to be the index of a Semaphore in the external objects array to be signalled every time a recording buffer is filled."	<primitive: 'primitiveSoundStartRecording' module: 'SoundPlugin'>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primStopRecording	"Stop sound recording. Does nothing if recording is not currently in progress."	<primitive: 'primitiveSoundStopRecording' module: 'SoundPlugin'>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primAtEnd: id	"Answer true if the file position is at the end of the file."	<primitive: 'primitiveFileAtEnd' module: 'FilePlugin'>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primClose: id	"Close this file."	<primitive: 'primitiveFileClose' module: 'FilePlugin'>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primCloseNoError: id	"Close this file. Don't raise an error if the primitive fails."	<primitive: 'primitiveFileClose' module: 'FilePlugin'>! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primGetPosition: id	"Get this files current position."	<primitive: 'primitiveFileGetPosition' module: 'FilePlugin'>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primOpen: fileName writable: writableFlag	"Open a file of the given name, and return the file ID obtained.	If writableFlag is true, then		if there is none with this name, then create one		else prepare to overwrite the existing from the beginning	otherwise		if the file exists, open it read-only		else return nil"	<primitive: 'primitiveFileOpen' module: 'FilePlugin'>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primRead: id into: byteArray startingAt: startIndex count: count	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."	<primitive: 'primitiveFileRead' module: 'FilePlugin'>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File read failed'.! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSetPosition: id to: anInteger	"Set this file to the given position."	<primitive: 'primitiveFileSetPosition' module: 'FilePlugin'>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSize: id	"Answer the size of this file."	<primitive: 'primitiveFileSize' module: 'FilePlugin'>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSizeNoError: id	"Answer the size of this file. Answer nil if the primitive fails; this indicates that the file handle has become stale."	<primitive: 'primitiveFileSize' module: 'FilePlugin'>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primWrite: id from: stringOrByteArray startingAt: startIndex count: count	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File write failed'.! !!WarpBlt methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps |	<primitive: 'primitiveWarpBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	(width < 1) | (height < 1) ifTrue: [^ self].	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix _ Array new: n*n].	nSteps _ height-1 max: 1.	deltaP12 _ (self deltaFrom: p1x to: p2x nSteps: nSteps)			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).	pA _ (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).	deltaP43 _ (self deltaFrom: p4x to: p3x nSteps: nSteps)			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).	pB _ (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).	picker _ BitBlt current bitPeekerFromForm: sourceForm.	poker _ BitBlt current bitPokerToForm: destForm.	poker clipRect: self clipRect.	nSteps _ width-1 max: 1.	destY to: destY+height-1 do:		[:y |		deltaPAB _ (self deltaFrom: pA x to: pB x nSteps: nSteps)				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).		sp _ (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp _ sp + deltaPAB].		pA _ pA + deltaP12.		pB _ pB + deltaP43]! !