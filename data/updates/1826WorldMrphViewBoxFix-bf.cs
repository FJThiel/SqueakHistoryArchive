'From Squeak2.7 of 5 January 2000 [latest update: #1789] on 5 February 2000 at 2:25:12 pm'!"Change Set:		1007WorldMorphViewBoxFix-bfDate:			5 January 2000Author:			Bert FreudenbergRemoves numerous references to the world's viewBox origin. A not so long time ago the viewBox origin determined an offset that had to be used for low level stuff, while nowadays all coords are global, even in inner worlds. One bug example is changing the border width of a morph in an inner world.Also fixes Morph>>openInWorld so it is positioned at the world's viewbox's origin.ToDo:	Check PasteUpMorph>>displayWorld* for non-deferred updating."!!Morph methodsFor: 'initialization' stamp: 'bf 1/5/2000 19:57'!openInWorld: aWorld	"Add this morph to the requested World."	(aWorld viewBox origin ~= (0@0) and: [self position = (0@0)]) ifTrue:		[self position: aWorld viewBox origin].	aWorld addMorph: self.	aWorld startSteppingSubmorphsOf: self! !!Morph methodsFor: 'geometry' stamp: 'bf 1/5/2000 19:08'!screenLocation	"For compatibility only"	^ self fullBounds origin! !!Morph methodsFor: 'geometry' stamp: 'sma 2/5/2000 13:58'!screenRectangle	"For compatibility only"	^ self fullBounds! !!Morph methodsFor: 'dropping/grabbing' stamp: 'bf 1/5/2000 19:10'!slideBackToFormerSituation: evt	| slideForm formerOwner formerPosition aWorld startPoint endPoint trans |	formerOwner _ evt hand formerOwner.	formerPosition _ evt hand formerPosition.	aWorld _ self world.	trans _ formerOwner transformFromWorld.	trans isPureTranslation 		ifTrue: [slideForm _ self imageForm offset: 0@0]		ifFalse: [slideForm _ ((TransformationMorph new asFlexOf: self) transform: trans)								imageForm offset: 0@0].	startPoint _ evt hand fullBounds origin.	endPoint _ trans localPointToGlobal: formerPosition.	owner privateRemoveMorph: self.	aWorld displayWorld.	slideForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'bf 1/5/2000 19:10'!slideToTrash: evt	| aForm aWorld trash startPoint endPoint |	aForm _ self imageForm offset: 0@0.	aWorld _ self world.	trash _ aWorld findA: TrashCanMorph.	trash ifNil: [^ self].	startPoint _ evt hand fullBounds origin.	endPoint _ trash position.	self delete.	aWorld displayWorld.	aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	trash acceptDroppingMorph: self event: evt.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'bf 1/5/2000 19:11'!vanishAfterSlidingTo: aPosition event: evt	| aForm aWorld startPoint endPoint |	aForm _ self imageForm offset: 0@0.	aWorld _ self world.	startPoint _ evt hand fullBounds origin.	self delete.	aWorld displayWorld.	endPoint _ aPosition.	aForm slideFrom: startPoint  to: endPoint nSteps: 12 delay: 15.	Preferences soundsEnabled ifTrue: [TrashCanMorph playDeleteSound].! !!HandMorph methodsFor: 'event handling' stamp: 'bf 1/5/2000 18:18'!gridPointRaw	"Private!! Returns the nearest grid point to the cursor to be used as the coordinate for the current event.  Do not include a cursor offset"	| where |	where _ Sensor cursorPoint.	^ gridOn ifTrue: [where grid: grid]			ifFalse: [where]! !!HandMorph methodsFor: 'event handling' stamp: 'bf 1/5/2000 18:54'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: Sensor cursorPoint]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				clickState == #firstClickDown ifFalse:					["ensure that at least one mouseMove: is reported for each mouse transaction:"					m mouseMove: (localEvt copy setType: #mouseMove).					(m handlesMouseOverDragging: localEvt) ifTrue:						["If m also handles dragOver, enter it in the list"						dragOverMorphs add: m.						mouseOverMorphs remove: m ifAbsent: []]]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes removeKey: m ifAbsent: []]! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'bf 1/5/2000 19:04'!displayAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	World ifNil: [^ self].	World addMorph: self centeredNear: aPoint.	World displayWorld.  "show myself"	aBlock value.	self delete.! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'bf 1/5/2000 19:04'!informUserAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	| title |	World ifNil: [^ self].	title _ submorphs first submorphs first.	self visible: false.	aBlock value:[:string|		self visible ifFalse:[			World addMorph: self centeredNear: aPoint.			self visible: true].		title contents: string.		self setConstrainedPositionFrom: Sensor cursorPoint.		self changed.		World displayWorld].  "show myself"	self delete.	World displayWorld.! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'bf 1/5/2000 18:25'!magnifiedForm	| srcRect form exclusion |	lastPos _ self sourcePoint.	srcRect _ self sourceRectFrom: lastPos.	((srcRect intersects: self bounds) and: [ RecursionLock == nil ])		ifTrue: [RecursionLock _ self.				self isRound					ifTrue: [exclusion _ owner]					ifFalse: [exclusion _ self].				form _ self world patchAt: srcRect without: exclusion andNothingAbove: false.				RecursionLock _ nil]		ifFalse: ["cheaper method if the source is not occluded"				form _ Display copy: srcRect].	"smooth if non-integer scale"	^ form magnify: form boundingBox		by: magnification		smoothing: (magnification isInteger ifTrue: [1] ifFalse: [2])! !!MovieMorph methodsFor: 'menu' stamp: 'bf 1/5/2000 19:11'!setRotationCenter	| frame p |	frame _ self currentFrame.	frame ifNil: [^ self].	self rotationDegrees: 0.0.   "must set rotation center with no rotation"	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton].	p _ self transformFromWorld globalPointToLocal: p.	Sensor waitNoButton.	frame rotationCenter: p - frame bounds origin.	self setFrame: currentFrameIndex.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'bf 1/5/2000 19:42'!createButtons	"Create buttons one at a time and let the user place them over the background.  Later can move them again by turning on AuthorModeOwner in ThreePhaseButtonMorph.	self createButtons.	"| rect button nib |#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: pickup: "pickup: pickup: pickup:" stamp: "stamp: stamp: stamp:" undo: keep: toss: prevStamp: nextStamp:) do: [:sel |	(self findButton: sel) ifNil: [		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser.		button _ ThreePhaseButtonMorph new.		button onImage: nil; bounds: rect.		self addMorph: button.		button actionSelector: #tool:action:cursor:; arguments: (Array with: button with: sel with: nil).		button actWhen: #buttonUp; target: self.		]].#(brush1: brush2: brush3: brush4: brush5: brush6: ) doWithIndex: [:sel :ind |	(self findButton: sel) ifNil: [		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser.		button _ ThreePhaseButtonMorph new.		button onImage: nil; bounds: rect.		self addMorph: button.		nib _ Form dotOfSize: (#(1 2 3 6 11 26) at: ind).		button actionSelector: #brush:action:nib:; 				arguments: (Array with: button with: sel with: nib).		button actWhen: #buttonUp; target: self.		]]."stamp:  Stamps are held in a ScrollingToolHolder.  Pickups and stamps and brushes are id-ed by the button == with item from a list."! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'bf 1/5/2000 19:42'!init3	"Just a record of how we loaded in the latest paintbox button images"| bb rect lay pic16Bit aa blt on thin |self loadoffImage: 'etoy_default.gif'.self allMorphsDo: [:button |	(button isKindOf: ThreePhaseButtonMorph) 		ifTrue: [button offImage: nil]		ifFalse: [button position: button position + (100@0)]].(bb _ self findButton: #keep:) position: bb position + (100@0).(bb _ self findButton: #toss:) position: bb position + (100@0).(bb _ self findButton: #undo:) position: bb position + (100@0)."Transparent is (Color r: 1.0 g: 0 b: 1.0)"self moveButtons.self loadOnImage: 'etoy_in.gif'.AllOnImage _ nil.	'save space'.	self loadPressedImage: 'etoy_in.gif'.AllPressedImage _ nil.	'save space'.self loadCursors."position the stamp buttons"stampHolder stampButtons owner last delete.stampHolder pickupButtons last delete.stampHolder stampButtons: (stampHolder stampButtons copyFrom: 1 to: 3).stampHolder pickupButtons: (stampHolder pickupButtons copyFrom: 1 to: 3)."| rect |"stampHolder pickupButtons do: [:button |		"PopUpMenu notify: 'Rectangle for ',sel."		rect _ Rectangle fromUser.		button bounds: rect.	"image is nil"		]."| rect lay |"stampHolder clear.stampHolder stampButtons do: [:button |		button offImage: nil; pressedImage: nil.		lay _ button owner.		"PopUpMenu notify: 'Rectangle for ',sel."		rect _ Rectangle fromUser.		button image: (Form fromDisplay: (rect insetBy: 2)).		lay borderWidth: 2.		lay bounds: rect.	"image is nil"		]."| pic16Bit blt aa on |"	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: 'etoy_in.gif'.	aa _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	"Collect all the images for the buttons in the on state"	stampHolder pickupButtons do: [:button |			on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors.			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button image: on; pressedImage: on; offImage: nil.			].	self invalidRect: bounds.((self findButton: #erase:) arguments at: 3) offset: (12@35).((self findButton: #eyedropper:) arguments at: 3) offset: (0@0).((self findButton: #fill:) arguments at: 3) offset: (10@44).((self findButton: #paint:) arguments at: 3) offset: (3@3). "unused"((self findButton: #rect:) arguments at: 3) offset: (6@17).((self findButton: #ellipse:) arguments at: 3) offset: (5@4).((self findButton: #polygon:) arguments at: 3) offset: (5@4).((self findButton: #line:) arguments at: 3) offset: (5@17).((self findButton: #star:) arguments at: 3) offset: (2@5).thumbnail delete.thumbnail _ nil.(submorphs select: [:e | e class == RectangleMorph]) first bounds: 	Rectangle fromUser.(submorphs select: [:e | e class == RectangleMorph]) first borderWidth: 1; borderColor: Color black."| thin |"	submorphs do: [:ss | ss class == ImageMorph ifTrue: [thin _ ss "first"]].colorMemoryThin _ thin.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'bf 1/5/2000 19:42'!moveButtons	"Move buttons one at a time and let the user place them over the background.  Later can move them again by turning on AuthorModeOwner in ThreePhaseButtonMorph.	self createButtons.	"| rect button |#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: "pickup: pickup: pickup: pickup:" "stamp: stamp: stamp: stamp:" undo: keep: toss: prevStamp: nextStamp:) do: [:sel |		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser.		button _ self findButton: sel.		button bounds: rect.	"image is nil"		].#(brush1: brush2: brush3: brush4: brush5: brush6: ) doWithIndex: [:sel :ind |		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser.		button _ self findButton: sel.		button bounds: rect.	"image is nil"		]."stamp:  Stamps are held in a ScrollingToolHolder.  Pickups and stamps and brushes are id-ed by the button == with item from a list."""! !!PaintBoxMorph methodsFor: 'actions' stamp: 'bf 1/5/2000 19:22'!eyedropper: aButton action: aSelector cursor: aCursor	"Take total control and pick up a color!!!!"	| pt feedbackColor |	aButton state: #on.	tool ifNotNil: [tool state: #off].	currentCursor _ aCursor."	self world hands first showTemporaryCursor: aCursor 		hotSpotOffset: (aCursor ifNil: [0@0] ifNotNil: [aCursor offset])."	feedbackColor _ Display colorAt: Sensor cursorPoint.	self addMorphFront: colorMemory.	"Full color picker"	self world displayWorld.		[Sensor anyButtonPressed] whileFalse: [			pt _ Sensor cursorPoint.			feedbackColor _ Display colorAt: pt.			Display fill: colorPatch bounds 					fillColor: feedbackColor].		Sensor waitNoButton."	self world hands first showTemporaryCursor: nil 		hotSpotOffset: 0@0."	self currentColor: feedbackColor.	colorMemory delete.	tool ifNotNil: [tool state: #on.		currentCursor _ tool arguments at: 3].	aButton state: #off.! !!PasteUpMorph methodsFor: 'world state' stamp: 'bf 1/5/2000 19:25'!chooseClickTarget	Cursor crossHair showWhile:		[Sensor waitButton].	Cursor down showWhile:		[Sensor anyButtonPressed].	^ (self morphsAt: Sensor cursorPoint) first! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'bf 1/5/2000 19:34'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: aPosition	"NB: if aPosition is nil, then it's assumed that the paintbox is obtained from a flap or some such, so do nothing special regarding a palette in this case.  The palette needs already to be in the world for this to work."	| w  |	(w _ aPasteUpMorph world) addMorphFront: self.	enclosingPasteUpMorph _ aPasteUpMorph.	hostView _ aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	canvasRectangle _ bounds.	palette _ w paintBox.	aPosition ifNotNil:		[w addMorphFront: palette.  "bring to front"		palette position: aPosition].	paintingForm _ Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	self addRotationScaleHandles.	aSketchMorph ifNotNil:		[aSketchMorph rotationDegrees: 0.		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter]! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'bf 1/5/2000 19:36'!pickupMouseUp: evt	"Grab a part of the picture (or screen) and store it in a known place. Like Copy on the Mac menu. Then switch to the stamp tool."	| rr pForm ii oldRect curs |	lastEvent == nil ifFalse: [			"Last draw will stick out, must erase the area"			oldRect _ strokeOrigin rect: lastEvent cursorPoint + (14@14).			self restoreRect: (oldRect insetBy: -2)].	self primaryHand showTemporaryCursor: nil.	"later get rid of this"		rr _ strokeOrigin rect: evt cursorPoint + (14@14).	ii _ rr translateBy: (0@0) - bounds origin.	(rr intersects: bounds) ifTrue: [		pForm _ paintingForm copy: ii.		pForm isAllWhite "means transparent" 			ifFalse: []	"normal case.  Can be transparent in parts"			ifTrue: [pForm _ nil.			"Get an un-dimmed picture of other objects on the playfield"			"don't know how yet"]].	pForm ifNil: [pForm _ Form fromDisplay: rr].		"Anywhere on the screen"	palette pickupForm: pForm.	curs _ palette actionCursor.	evt hand showTemporaryCursor: curs.! !!SketchMorph methodsFor: 'menu' stamp: 'bf 1/5/2000 19:36'!setRotationCenter	| oldRotation p oldScale |	oldRotation _ rotationDegrees.	oldScale _ scalePoint.	scalePoint _ 1.0@1.0.	self rotationDegrees: 0.0.	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton].	p _ self transformFromWorld globalPointToLocal: p.	Sensor waitNoButton.	self rotationCenter: p - bounds origin.	scalePoint _ oldScale.	self rotationDegrees: oldRotation.! !!FatBitsPaint methodsFor: 'menu' stamp: 'bf 1/5/2000 18:48'!fill	| fillPt |	Cursor blank show.	Cursor crossHair showWhile:		[fillPt _ Sensor waitButton - self position].	originalForm shapeFill: brushColor interiorPoint: fillPt.	self changed.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'bf 1/5/2000 19:12'!fill: evt	| state fillPt |	(drawState includesKey: evt hand) ifFalse: [self createDrawStateFor: evt hand].	state _ drawState at: evt hand.	Cursor blank show.	Cursor crossHair showWhile:		[fillPt _ Sensor waitButton - self position].	originalForm shapeFill: (state at: PenColorIndex) interiorPoint: fillPt.	self changed.! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'bf 1/5/2000 19:38'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds adjoiningPanes limit |	(self world firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[ ^ self  "Prevent multiple handles"].	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	adjoiningPanes _ paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side].	limit _ adjoiningPanes isEmpty		ifFalse: [ (adjoiningPanes collect: [:pane | pane bounds perform: side])			perform: ((#(top left) includes: side) ifTrue: [#max] ifFalse: [#min])]		ifTrue: [self bounds perform: side].	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ growingPane bounds withSideOrCorner: side setToPoint: localPt minExtent: 40@20 limit: limit.			self fastFramingOn 			ifTrue:				["For fast display, only higlight the rectangle during loop"				newBounds _ growingPane bounds					 newRectFrom:					[:f | growingPane bounds withSideOrCorner: side							setToPoint: (self pointFromWorld: Sensor cursorPoint)							minExtent: 40@20 limit: limit].					self reframePanesAdjoining: growingPane along: side						to: newBounds]			ifFalse:				[self reframePanesAdjoining: growingPane along: side to: newBounds]]		lastPointDo: [:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!TinyPaint methodsFor: 'menu' stamp: 'bf 1/5/2000 19:39'!fill	| fillPt |	Cursor blank show.	Cursor crossHair showWhile:		[fillPt _ Sensor waitButton - self position].	originalForm shapeFill: brushColor interiorPoint: fillPt.	self changed.! !