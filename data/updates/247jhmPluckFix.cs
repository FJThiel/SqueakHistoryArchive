'From Squeak 2.1 of June 30, 1998 on 11 September 1998 at 3:54:35 pm'!"Change Set:		jhmPluckFixDate:			11 September 1998Author:			John MaloneyFixes a bug in the plucked sound generation primitive when generatingzero samples. Also makes bars disappear from the PianoRoll only when theyare completely off the screen."!!AbstractScoreEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38'!endTime	"Subclasses should override to return the ending time if the event has some duration."	^ time! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38'!endTime	^ time + duration! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 8/27/1998 16:39'!goToTime: scoreTime	| track trackSize index |	scoreTime < leftEdgeTime		ifTrue: [indexInTrack _ Array new: score tracks size+1 withAll: 1].	leftEdgeTime _ scoreTime.	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		index _ indexInTrack at: trackIndex.		trackSize _ track size.		[(index < trackSize) and:		 [(track at: index) endTime < leftEdgeTime]]			whileTrue: [index _ index + 1].		indexInTrack at: trackIndex put: index].! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 9/8/1998 16:18'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive: 181>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #ring declareC: 'short int *ring'.	lastIndex _ (startIndex + n) - 1.	scaledThisIndex _ scaledNextIndex _ scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex _ scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex _ ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average _			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample _ (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex _ scaledNextIndex.		leftVol > 0 ifTrue: [			i _ (2 * sliceIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * sliceIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]]].	scaledIndex _ scaledNextIndex.	count _ count - n.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 9/8/1998 16:24'!memorySpace	"Answer the number of bytes required to store the samples for this instrument."	| total |	total _ 0.	self allNotes do: [:n |		total _ total + (n leftSamples monoSampleCount * 2).		n isStereo ifTrue: [total _ total + (n leftSamples monoSampleCount * 2)]].	^ total! !