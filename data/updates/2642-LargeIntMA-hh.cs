'From Squeak2.9alpha of 13 June 2000 [latest update: #2558] on 3 September 2000 at 3:40:31 pm'!"Change Set:		019-LargeIntMA-hhDate:			3 September 2000Author:			  Ok, so I loaded Jesse's second version (Thanks to you, too!!) of #raisedTo:modulo: (very close to the DSA method), and I used the above implementation of Integer>>\\\.  I had to bump up the loop by a factor of 10 to see a difference for small integers (which really aren't the point of the whole business):[1000 timesRepeat: [855 raisedTo: 2753 modulo: 3233]] timeToRun --> 40[1000 timesRepeat: [DigitalSignatureAlgorithm new raise: 855 to: 2753 mod: 3233]] timeToRun --> 60And, just to round it up with numbers comparable to those posted before, the DSA #timeDecode: test using Jesse's code and the simplified #\\\ lingers around 7,290 to 8,492 ms.  After replacing #\\ with #\\\ in Jesse's code (which I think is reasonable), I finally reach the former region of 5,789 to 6,960 ms.Should we thus1/  include Integer>>\\\,2/  include Jesse's slightly modified Integer>>raisedTo:modulo:,3/  drop DSA>>raise:to:mod:4/  let DSA use Integer>>raisedTo:modulo:as per the attached changeset?  Gives us generality, a better-located method, and doesn't significantly harm performance."!!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'hh 8/3/2000 18:17'!computeSignatureForMessageHash: hash privateKey: privateKey	"Answer the digital signature of the given message hash using the given private key. A signature is a pair of large integers. The private key is an array of four large integers: (p, q, g, x)."	| p q g x r s k tmp |	p _ privateKey first.	q _ privateKey second.	g _ privateKey third.	x _ privateKey fourth.	r _ s _ 0.	[r = 0 or: [s = 0]] whileTrue: [		k _ self nextRandom160 \\ q.		r _ (g raisedTo: k modulo: p) \\ q.		tmp _ (hash + (x * r)) \\ q.		s _ ((self inverseOf: k mod: q) * tmp) \\ q].	^ Array with: r with: s! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'hh 8/3/2000 18:19'!generateKeySet	"Generate and answer a key set for DSA. The result is a pair (<private key><public key>). Each key is an array of four large integers. The private key is (p, q, g, x); the public one is (p, q, g, y). The signer must be sure to record (p, q, g, x), and must keep x secret to prevent someone from forging their signature."	"Note: Key generation can take some time. Open a transcript so you can see what's happening and take a coffee break!!"	| qAndPandS q p exp g h x y |	qAndPandS _ self generateQandP.	Transcript show: 'Computing g...'.	q _ qAndPandS first.	p _ qAndPandS second.	exp _ (p - 1) / q.	h _ 2.	[g _ h raisedTo: exp modulo: p. g = 1] whileTrue: [h _ h + 1].	Transcript show: 'done.'; cr.	Transcript show: 'Computing x and y...'.	x _ self nextRandom160.	y _ g raisedTo: x modulo: p.	Transcript show: 'done.'; cr.	Transcript show: 'Key generation complete!!'; cr.	^ Array		with: (Array with: p with: q with: g with: x)		with: (Array with: p with: q with: g with: y)! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'hh 8/3/2000 18:18'!verifySignature: aSignature ofMessageHash: hash publicKey: publicKey	"Answer true if the given signature is the authentic signature of the given message hash. That is, if the signature must have been computed using the private key set corresponding to the given public key. The public key is an array of four large integers: (p, q, g, y)."	| p q g y r s w u1 u2 v0 v |	p _ publicKey first.	q _ publicKey second.	g _ publicKey third.	y _ publicKey fourth.	r _ aSignature first.	s _ aSignature last.	((r > 0) and: [r < q]) ifFalse: [^ false].  "reject"	((s > 0) and: [s < q]) ifFalse: [^ false].  "reject"	w _ self inverseOf: s mod: q.	u1 _ (hash * w) \\ q.	u2 _ (r * w) \\ q.	v0 _ (g raisedTo: u1 modulo: p) * (y raisedTo: u2 modulo: p).	v _ ( v0 \\ p) \\ q.	^ v = r! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'hh 8/3/2000 18:18'!isProbablyPrime: p	"Answer true if p is prime with very high probability. Such a number is sometimes called an 'industrial grade prime'--a large number that is so extremely likely to be prime that it can assumed that it actually is prime for all practical purposes. This implementation uses the Rabin-Miller algorithm (Schneier, p. 159)."	| iterations factor pMinusOne b m r a j z couldBePrime |	iterations _ 50.  "Note: The DSA spec requires >50 iterations; Schneier says 5 are enough (p. 260)"	"quick elimination: check for p divisible by a small prime"	SmallPrimes ifNil: [  "generate list of small primes > 2"		SmallPrimes _ Integer primesUpTo: 2000.		SmallPrimes _ SmallPrimes copyFrom: 2 to: SmallPrimes size].	factor _ SmallPrimes detect: [:f | (p \\ f) = 0] ifNone: [nil].	factor ifNotNil: [^ p = factor].	pMinusOne _ p - 1.	b _ self logOfLargestPowerOfTwoDividing: pMinusOne.	m _ pMinusOne // (2 raisedTo: b).	"Assert: pMinusOne = m * (2 raisedTo: b) and m is odd"	Transcript show: '      Prime test pass '.	r _ Random new.	1 to: iterations do: [:i |		Transcript show: i printString; space.		a _ (r next * 16rFFFFFF) truncated.		j _ 0.		z _ (a raisedTo: m modulo: p) normalize.		couldBePrime _ z = 1.		[couldBePrime] whileFalse: [			z = 1 ifTrue: [Transcript show: 'failed!!'; cr. ^ false].  "not prime"			z = pMinusOne				ifTrue: [couldBePrime _ true]				ifFalse: [					(j _ j + 1) < b						ifTrue: [z _ (z * z) \\ p]						ifFalse: [Transcript show: 'failed!!'; cr. ^ false]]]].  "not prime"	Transcript show: 'passed!!'; cr.	^ true  "passed all tests; probably prime"! !!Integer methodsFor: 'arithmetic' stamp: 'hh 8/4/2000 00:39'!\\\ anInteger 	"a modulo method for use in DSA. Be careful if you try to use this elsewhere"	^self \\ anInteger! !!Integer methodsFor: 'mathematical functions' stamp: 'hh 8/4/2000 01:09'!raisedTo: y modulo: n	"Answer the modular exponential. Code by Jesse Welton."	| s t u |	s _ 1.	t _ self.	u _ y.	[u = 0] whileFalse: [		u odd ifTrue: [			s _ s * t.			s >= n ifTrue: [s _ s \\\ n]].		t _ t * t.		t >= n ifTrue: [t _ t \\\ n].		u _ u bitShift: -1].	^ s! !DigitalSignatureAlgorithm removeSelector: #raise:to:mod:!