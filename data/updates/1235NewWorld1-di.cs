'From Squeak 2.4c of May 10, 1999 on 8 June 1999 at 1:00:00 pm'!"Change Set:		NewWorld1Date:			7 June 1999Author:			Dan IngallsPhase 1 of the refactoring of WorldMorph.Supplants existing external access to WorldMorph>>hands by firstHand and handsDo:.Defines a MorphicProject subclass with instVars for all the project state currently carried in WorldMorph.Adds a 'project' slot to PasteUpMorph for access to the project state.Adds methods to access the project state in both WorldMorph and PasteUpMorph.Finally points the project slot of all WorldMorphs at themselves so they will continue to work during the change to access project state via that slot."!Project subclass: #MorphicProject	instanceVariableNames: 'hands activeHand viewBox canvas damageRecorder stepList lastStepTime lastCycleTime '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Projects'!GradientFillMorph subclass: #PasteUpMorph	instanceVariableNames: 'presenter model cursor padding backgroundMorph turtleTrailsForm turtlePen lastTurtlePositions openToDragNDrop isPartsBin autoLineLayout indicateCursor resizeToFit fileName isStackLike dataInstances currentDataInstance userFrameRectangle wantsMouseOverHalos project '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!!Object methodsFor: 'macpal' stamp: 'di 6/7/1999 15:42'!currentHand	"Return a usable HandMorph -- the one associated with the object's current environment.  This method will always return a hand, even if it has to conjure one up as a last resort.  If a particular hand is actually handling events at the moment (such as a remote hand or a ghost hand), it will be returned."	^ self currentWorld primaryHand! !!Morph methodsFor: 'structure' stamp: 'di 6/7/1999 15:39'!primaryHand	^ self activeHand ifNil: [self world firstHand]! !!Morph methodsFor: 'structure' stamp: 'di 6/7/1999 20:04'!world	^ owner == nil ifTrue: [nil] ifFalse: [owner world]! !!EnvelopeEditorMorph methodsFor: 'stepping' stamp: 'di 6/7/1999 15:37'!step	| mouseDown hand |	hand _ self world firstHand.	(bounds containsPoint: hand position) ifFalse: [^ self].	mouseDown _ hand lastEvent redButtonPressed.	mouseDown not & prevMouseDown ifTrue:		["Mouse just went up"		limitXs = (limits collect: [:i | (envelope points at: i) x]) ifFalse:			["Redisplay after changing limits"			self editEnvelope: envelope]].	prevMouseDown _ mouseDown! !!HandMorph methodsFor: 'remote morphic' stamp: 'di 6/7/1999 15:38'!disconnectAllRemoteUsers	"Disconnect all remote hands and stop transmitting events."	| addr |	self world handsDo: [:h |		(h isKindOf: RemoteHandMorph) ifTrue: [			addr _ h remoteHostAddress.			addr = 0 ifFalse: [self stopTransmittingEventsTo: addr].			h withdrawFromWorld]].	remoteConnections do: [:triple | triple first closeAndDestroy: 5].	remoteConnections _ OrderedCollection new.! !!HandMorph methodsFor: 'remote morphic' stamp: 'di 6/7/1999 15:39'!disconnectRemoteUser	"Prompt for the initials of the remote user, then remove the remote hand with those initials, breaking its connection."	"select hand to remove"	| initials handToRemove addr |	initials _ FillInTheBlank request: 'Enter initials for remote user''s cursor?'.	initials isEmpty ifTrue: [^ self].  "abort"	handToRemove _ nil.	self world handsDo: [:h |		h userInitials = initials ifTrue: [handToRemove _ h]].	handToRemove ifNil: [^ self].  "no hand with those initials"	addr _ handToRemove remoteHostAddress.	addr = 0 ifFalse: [self stopTransmittingEventsTo: addr].	handToRemove withdrawFromWorld.! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'di 6/7/1999 15:45'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	self popUpAt: aPoint forHand: aWorld primaryHand.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneSubCycle].	self delete.	^ selectedItem! !!MorphWorldController methodsFor: 'control sequence' stamp: 'di 6/7/1999 15:40'!controlInitialize	"This window is becoming active."	model canvas ifNil: [  "i.e., only on first entry"		"In case of, eg, inspect during balloon help..."		model submorphsDo: [:m |  "delete any existing balloons"			(m isKindOf: BalloonMorph) ifTrue: [m delete]].		model handsDo: [:h | h initForEvents].		view displayView].  "initializes the WorldMorph's canvas"! !!MorphWorldView methodsFor: 'as yet unclassified' stamp: 'di 6/7/1999 15:40'!deEmphasizeView 	"This window is becoming inactive."	Cursor normal show.    "restore the normal cursor"	model handsDo:          "free dependents links if any"		[:h | h newKeyboardFocus: nil].	model canvas: nil.		"free model's canvas to save space"	model fullReleaseCachedState.	self topView cacheBitsAsTwoTone ifTrue: [		"draw deEmphasized as a two-tone (monochrome) form"		model displayWorldAsTwoTone].! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:42'!activeHand	^ activeHand! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:50'!activeHand: x	activeHand _ x! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:44'!canvas	^ canvas! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:50'!canvas: x	canvas _ x! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:45'!damageRecorder	^ damageRecorder! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:51'!damageRecorder: x	damageRecorder _ x! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:40'!hands	^ hands! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:51'!hands: x	hands _ x! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:47'!lastCycleTime	^ lastCycleTime! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:52'!lastCycleTime: x	lastCycleTime _ x! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:46'!lastStepTime	^ lastStepTime! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:52'!lastStepTime: x	lastStepTime _ x! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:45'!stepList	^ stepList! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:52'!stepList: x	stepList _ x! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:44'!viewBox	^ viewBox! !!MorphicProject methodsFor: 'project state' stamp: 'di 6/7/1999 17:58'!viewBox: x	viewBox _ x! !!PasteUpMorph methodsFor: 'classification' stamp: 'di 6/8/1999 12:26'!isWorldMorph	^ project notNil! !!PasteUpMorph methodsFor: 'classification' stamp: 'di 6/8/1999 12:16'!world	project == nil ifTrue: [^ super world].	^ self! !!PasteUpMorph methodsFor: 'painting' stamp: 'di 6/7/1999 15:46'!paintBackground	| pic rect |	self world abandonAllHalos.	self world stopRunningAll.	pic _ self backgroundSketch.	pic ifNotNil: [pic editDrawingIn: self forBackground: true]		"need to resubmit it? (tck comment)"		ifNil: [rect _ self bounds.			pic _ self world firstHand drawingClass new form: 				(Form extent: rect extent depth: Display depth).			pic bounds: rect.			"self world addMorphBack: pic.  done below"			pic _ self backgroundSketch: pic.	"returns a different guy"			pic ifNotNil: [pic editDrawingIn: self forBackground: true]]! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!activeHand	^ project activeHand! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!activeHand: x	project activeHand: x! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!canvas	^ project canvas! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!canvas: x	project canvas: x.	self fullRepaintNeeded.! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!damageRecorder	^ project damageRecorder! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!damageRecorder: x	project damageRecorder: x! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:18'!firstHand	^ project hands first! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!hands	^ project hands! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!hands: x	project hands: x! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:18'!handsDo: aBlock	^ project hands do: aBlock! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!lastCycleTime	^ project lastCycleTime! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!lastCycleTime: x	project lastCycleTime: x! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!lastStepTime	^ project lastStepTime! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!lastStepTime: x	project lastStepTime: x! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!stepList	^ project stepList! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!stepList: x	project stepList: x! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!viewBox	^ project viewBox! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:16'!viewBox: newViewBox	| vb |	((vb _ self viewBox) == nil or: [vb extent ~= newViewBox extent])		ifTrue: [self canvas: nil].	project viewBox: newViewBox.	bounds _ 0@0 extent: newViewBox extent.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self handsDo: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'di 6/7/1999 15:46'!makeTile	| newStyleTile sndName tile |	recorder pause.	newStyleTile _ true.	newStyleTile		ifTrue: [			sndName _ FillInTheBlank				request: 'Please enter a name this sound'				initialAnswer: 'sound'.			sndName isEmpty ifTrue: [^ self].			sndName _ SampledSound unusedSoundNameLike: sndName.			SampledSound				addLibrarySoundNamed: sndName				samples: recorder condensedSamples				samplingRate: recorder samplingRate.			tile _ SoundTile new literal: sndName]		ifFalse: [			tile _ InterimSoundMorph new sound: 				(SampledSound					samples: recorder condensedSamples					samplingRate: recorder samplingRate)].	self world firstHand attachMorph: tile.! !!TextMorph methodsFor: 'editing' stamp: 'di 6/7/1999 15:51'!keyboardFocusChange: aBoolean	| w |	aBoolean		ifTrue: ["A hand is wanting to send us characters..."				self hasFocus ifFalse: [self editor "Forces install"]]		ifFalse: ["A hand has clicked elsewhere..."				(w _ self world) == nil ifFalse:					[w handsDo: [:h | h keyboardFocus == self ifTrue: [^ self]].					"Release control unless some hand is still holding on"					self releaseEditor]].! !!TextMorph methodsFor: 'editing' stamp: 'di 6/7/1999 15:56'!passKeyboardFocusTo: otherMorph	| w |	(w _ self world) == nil ifFalse:		[w handsDo:			[:h | h keyboardFocus == self				ifTrue: [h newKeyboardFocus: otherMorph]]].! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/7/1999 15:53'!pauseEventRecorder	"Suspend any event recorder, and return it if found"	| er |	self handsDo: [:h | (er _ h pauseEventRecorderIn: self) ifNotNil: [^ er]].	^ nil! !!WorldMorph methodsFor: 'hands' stamp: 'di 6/7/1999 15:37'!firstHand	^ hands first! !!WorldMorph methodsFor: 'hands' stamp: 'di 6/7/1999 15:38'!handsDo: aBlock	^ hands do: aBlock! !!WorldMorph methodsFor: 'painting support' stamp: 'di 6/7/1999 15:52'!paintArea	"What rectangle should the user be allowed to create a new painting in??  An area beside the paintBox.  Allow playArea to override with its own bounds!!  "	| playfield paintBoxBounds |	playfield _ self submorphNamed: 'playfield' ifNone: [nil].	playfield ifNotNil: [^ playfield bounds].	paintBoxBounds _ self paintBox bounds.	self firstHand targetOffset x < paintBoxBounds center x		ifTrue: [^ bounds topLeft corner: paintBoxBounds left@bounds bottom]   "paint on left side"		ifFalse: [^ paintBoxBounds right@bounds top corner: bounds bottomRight].  "paint on right side"! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'di 6/7/1999 15:52'!addMorphsAndModel: aMorphOrList	"Dump in submorphs, model, and stepList from aMorphOrList.  Used to bring a world, paste-up, or other morph in from an object file."	aMorphOrList isMorph		ifTrue:			[aMorphOrList isWorldMorph				ifFalse:					["one morph, put on hand"					"aMorphOrList installModelIn: self.  	a chance to install model pointers"					aMorphOrList privateOwner: nil.					self firstHand attachMorph: aMorphOrList.					self startSteppingSubmorphsOf: aMorphOrList]				ifTrue: 					[model == nil						ifTrue:							[self setModel: (aMorphOrList modelOrNil)]						ifFalse:							[aMorphOrList modelOrNil ifNotNil:								[aMorphOrList modelOrNil privateOwner: nil.								self addMorph: (aMorphOrList modelOrNil)]].					aMorphOrList privateSubmorphs reverseDo: [:m |						m privateOwner: nil.						self addMorph: m.						m changed].					(aMorphOrList instVarNamed: 'stepList') do:						[:entry | entry first startSteppingIn: self]]]		ifFalse:  "list, add them all"			[aMorphOrList reverseDo: [:m |				m privateOwner: nil.				self addMorph: m.				self startSteppingSubmorphsOf: m.	"It may not want this!!"				m changed]]! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:52'!activeHand	(project == nil or: [project == self]) ifTrue: [^ activeHand].	^ project activeHand! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:53'!activeHand: x	(project == nil or: [project == self])		ifTrue: [activeHand _ x]		ifFalse: [project activeHand: x]! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:53'!canvas	(project == nil or: [project == self]) ifTrue: [^ canvas].	^ project canvas! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:53'!canvas: x	(project == nil or: [project == self])		ifTrue: [canvas _ x]		ifFalse: [project canvas: x].	self fullRepaintNeeded.! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:53'!damageRecorder	(project == nil or: [project == self]) ifTrue: [^ damageRecorder].	^ project damageRecorder! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:53'!damageRecorder: x	(project == nil or: [project == self])		ifTrue: [damageRecorder _ x]		ifFalse: [project damageRecorder: x]! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:53'!hands	(project == nil or: [project == self]) ifTrue: [^ hands].	^ project hands! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:53'!hands: x	(project == nil or: [project == self])		ifTrue: [hands _ x]		ifFalse: [project hands: x]! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:53'!lastCycleTime	(project == nil or: [project == self]) ifTrue: [^ lastCycleTime].	^ project lastCycleTime! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:53'!lastCycleTime: x	(project == nil or: [project == self])		ifTrue: [lastCycleTime _ x]		ifFalse: [project lastCycleTime: x]! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:53'!lastStepTime	(project == nil or: [project == self]) ifTrue: [^ lastStepTime].	^ project lastStepTime! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:53'!lastStepTime: x	(project == nil or: [project == self])		ifTrue: [lastStepTime _ x]		ifFalse: [project lastStepTime: x]! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:54'!stepList	(project == nil or: [project == self]) ifTrue: [^ stepList].	^ project stepList! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:54'!stepList: x	(project == nil or: [project == self])		ifTrue: [stepList _ x]		ifFalse: [project stepList: x]! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:54'!viewBox	(project == nil or: [project == self]) ifTrue: [^ viewBox].	^ project viewBox! !!WorldMorph methodsFor: 'project state' stamp: 'di 6/8/1999 12:54'!viewBox: newViewBox	| vb |	((vb _ self viewBox) == nil or: [vb extent ~= newViewBox extent])		ifTrue: [self canvas: nil].	(project == nil or: [project == self])		ifTrue: [viewBox _ newViewBox]		ifFalse: [project viewBox: newViewBox].	bounds _ 0@0 extent: newViewBox extent.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self handsDo: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !"Postscript:Point the project slot of all WorldMorphs at themselves so they will continue to work during the change to access project state via that slot."WorldMorph allInstancesDo: [:wm | wm instVarNamed: 'project' put: wm].!