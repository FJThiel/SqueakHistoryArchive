'From Squeak 2.2 of Sept 23, 1998 on 9 October 1998 at 12:09:21 am'!"Change Set:		Round Three-diDate:			6 October 1998Author:			Dan IngallsThis ChangeSet includes Bob Arning's fix for indent/outdent in morphic [thanks!!].ZoomMorphs have been removed from the 'new morph' menu.A CursorWithMask class has been added.  You can try it out by executing...		Cursor initNormalWithMask.  Cursor normal show.	and you can revert by executing...		Cursor initNormal.  Cursor normal show.There is a general method that will derive all the cursors automatically from their unmasked counterparts.  However the above method simply installs a hand-tweaked masked version of the normal cursor.TextMorphs with drop-shadows can now fill their owner's shape.TextMorphs with drop-shadows can be embedded in Project links.Embedded text now remembers its fill properties when duplicated."!Cursor subclass: #CursorWithMask	instanceVariableNames: 'maskForm '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!Cursor class methodsFor: 'class initialization' stamp: 'di 10/8/1998 17:04'!initNormalWithMask    "Cursor initNormalWithMask.  Cursor normal show"	"Next two lines work simply for any cursor..."	self initNormal.	NormalCursor _ CursorWithMask derivedFrom: NormalCursor.	"But for a good looking cursor, you have to tweak things..."	NormalCursor _ (CursorWithMask extent: 16@16 depth: 1			fromArray: #( 0 1073741824 1610612736 1879048192				2013265920 2080374784 2113929216 2130706432				2080374784 2080374784 1275068416 100663296				100663296 50331648 50331648 0)			offset: -1@-1)		setMaskForm: (Form extent: 16@16 depth: 1			fromArray: #( 3221225472 3758096384 4026531840 4160749568				4227858432 4261412864 4278190080 4286578688				4278190080 4261412864 4261412864 3472883712				251658240 125829120 125829120 50331648)			offset: 0@0).! !!Cursor class methodsFor: 'class initialization' stamp: 'di 10/6/1998 13:29'!initialize	"Create all the standard cursors..."		self initOrigin.		self initRightArrow.		self initMenu.		self initCorner.		self initRead.		self initWrite.		self initWait.		BlankCursor _ Cursor new.		self initXeq.		self initSquare.		self initNormal.		self initCrossHair.		self initMarker.		self initUp.		self initDown.		self initMove.		"Cursor initialize"! !!Cursor class methodsFor: 'instance creation' stamp: 'di 10/6/1998 13:53'!new	^ self extent: 16 @ 16		fromArray: (Array new: 16 withAll: 0)		offset: 0 @ 0	"Cursor new bitEdit show"! !!Cursor class methodsFor: 'current cursor' stamp: 'di 10/6/1998 13:57'!currentCursor: aCursor 	"Make the instance of cursor, aCursor, be the current cursor. Display it. 	Create an error if the argument is not a Cursor."	(aCursor isKindOf: self)		ifTrue: [CurrentCursor _ aCursor.				aCursor beCursor]		ifFalse: [self error: 'The new cursor must be an instance of class Cursor']! !!CursorWithMask reorganize!('all' beCursor maskForm setMaskForm:)!!CursorWithMask methodsFor: 'all' stamp: 'di 10/6/1998 15:16'!beCursor	maskForm unhibernate.	^ self beCursorWithMask: maskForm! !!CursorWithMask methodsFor: 'all' stamp: 'di 10/8/1998 16:46'!maskForm	^ maskForm! !!CursorWithMask methodsFor: 'all' stamp: 'di 10/8/1998 16:46'!setMaskForm: aForm	maskForm _ aForm! !!CursorWithMask class methodsFor: 'as yet unclassified' stamp: 'di 10/8/1998 16:46'!derivedFrom: aForm      "Cursor initNormalWithMask.  Cursor normal show"	"aForm is presumably a cursor"	| cursor mask |	cursor _ self new.	cursor copy: (1@1 extent: 16@16) from: 0@0 in: aForm rule: Form over.	mask _ Form extent: 16@16.	(0@0) eightNeighbors do:		[:p | mask copy: (p extent: 16@16) from: 0@0 in: aForm rule: Form under].	cursor setMaskForm: mask.	cursor offset: aForm offset - (1@1).	^ cursor! !!DropShadowMorph methodsFor: 'geometry' stamp: 'di 10/8/1998 14:43'!ownerChanged	super ownerChanged.	self submorphsDo: [:m | m ownerChanged].	self computeBounds! !!NewParagraph methodsFor: 'private' stamp: 'RAA 8/30/1998 15:30'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last cr |	cr _ Character cr.	arrayIndex _ lineIndex.	[first _ (lines at: arrayIndex) first.	 first > 1 and: [(text string at: first - 1) ~~ cr]] whileTrue: "word wrap"		[arrayIndex _ arrayIndex - 1].	last _ (lines at: arrayIndex) last.		^(text string copyFrom: first to: last) indentationIfBlank: aBlock.! !!NewParagraph methodsFor: 'private' stamp: 'RAA 8/30/1998 15:04'!lineIndexOfCharacterIndex: characterIndex 	"Answer the line index for a given characterIndex."	"apparently the selector changed with NewParagraph"	^self lineIndexForCharacter: characterIndex ! !!String methodsFor: 'paragraph support' stamp: 'RAA 8/30/1998 15:20'!indentationIfBlank: aBlock	"Answer the number of leading tabs in the receiver.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value."	| reader leadingTabs lastSeparator cr tab ch |	cr _ Character cr.	tab _ Character tab.	reader _ ReadStream on: self.	leadingTabs _ 0.	[reader atEnd not and: [(ch _ reader next) == tab]]		whileTrue: [leadingTabs _ leadingTabs + 1].	lastSeparator _ leadingTabs + 1.	[reader atEnd not and: [ch isSeparator and: [ch ~~ cr]]]		whileTrue: [lastSeparator _ lastSeparator + 1. ch _ reader next].	lastSeparator = self size | (ch == cr)		ifTrue: [^aBlock value: leadingTabs].	^leadingTabs! !!TextContainer methodsFor: 'private' stamp: 'di 10/8/1998 14:24'!bounds	| bounds theText |	self fillsOwner ifFalse: [^ textMorph textBounds].	theText _ textMorph meOrMyDropShadow.	bounds _ theText owner bounds.	theText owner submorphsBehind: theText do:		[:m | bounds _ bounds merge: m fullBounds].	^ bounds! !!TextContainer methodsFor: 'private' stamp: 'di 10/8/1998 14:21'!computeShadow	| canvas back bounds theText |	bounds _ self bounds.	theText _ textMorph meOrMyDropShadow.	canvas _ (FormCanvas extent: bounds extent depth: 1)			setShadowDrawing; stipple: Color black;			copyOffset: bounds topLeft negated.	self fillsOwner		ifTrue: [(theText owner copyWithoutSubmorph: theText) fullDrawOn: canvas]		ifFalse: [canvas fillRectangle: textMorph bounds color: Color black].	self avoidsOcclusions ifTrue:		[back _ canvas form deepCopy.		canvas form fillWhite.		theText owner submorphsInFrontOf: theText do:			[:m | (textMorph isLinkedTo: m)				ifTrue: []				ifFalse: [m fullDrawOn: canvas]].		back displayOn: canvas form at: 0@0 rule: Form reverse].	shadowForm _ canvas form offset: bounds topLeft.	vertProfile _ shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache _ Dictionary new.	^ shadowForm! !!TextMorph methodsFor: 'geometry' stamp: 'di 10/8/1998 23:46'!bounds	container ifNil: [^ bounds].	^ container bounds ifNil: [bounds]! !!TextMorph methodsFor: 'menu' stamp: 'di 10/8/1998 14:22'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| outer |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'add predecessor' action: #addPredecessor:.	aCustomMenu add: 'add successor' action: #addSuccessor:.	outer _ self meOrMyDropShadow owner.	((outer isKindOf: PolygonMorph) and: [outer isOpen]) ifTrue:		[container == nil			ifTrue: [aCustomMenu add: 'follow owner''s curve' action: #followCurve]			ifFalse: [aCustomMenu add: 'reverse direction' action: #reverseCurveDirection.					aCustomMenu add: 'set baseline' action: #setCurveBaseline:]]		ifFalse:		[(container == nil or: [container fillsOwner not])			ifTrue: [aCustomMenu add: 'fill owner''s shape' action: #fillingOnOff]			ifFalse: [aCustomMenu add: 'rectangluar bounds' action: #fillingOnOff].		(container == nil or: [container avoidsOcclusions not])			ifTrue: [aCustomMenu add: 'avoid occlusions' action: #occlusionsOnOff]			ifFalse: [aCustomMenu add: 'ignore occlusions' action: #occlusionsOnOff]].! !!TextMorph methodsFor: 'menu' stamp: 'di 10/8/1998 23:40'!followCurve	self setContainer: (TextOnCurveContainer new baseline: 0; textDirection: 1).	self changed! !!TextMorph methodsFor: 'private' stamp: 'di 10/8/1998 14:23'!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	self setDefaultContentsIfNil.	"...Code here to recreate the paragraph..."	paragraph _ (self paragraphClass new textOwner: self meOrMyDropShadow owner)					compose: text style: textStyle copy					from: self startingIndex in: self container.	wrapFlag ifFalse:		["Was given huge container at first... now adjust"		paragraph adjustRightX].	self fit.	^ paragraph! !!TextMorph methodsFor: 'containment' stamp: 'di 10/8/1998 14:17'!meOrMyDropShadow	^ (owner isKindOf: DropShadowMorph)			ifTrue: [owner]			ifFalse: [self]! !!TextMorph methodsFor: 'containment' stamp: 'di 10/8/1998 23:20'!privateOwner: newOwner	"Nil the container when text gets extracted"	super privateOwner: newOwner.	container ifNotNil: [newOwner isWorldOrHandMorph ifTrue: [self setContainer: nil]]! !!ZoomMorph class methodsFor: 'as yet unclassified' stamp: 'di 10/6/1998 13:15'!includeInNewMorphMenu	"Zooms aren't meaningful without initializations"	^ false! !Cursor initialize!