'From Squeak 2.1 of June 30, 1998 on 11 September 1998 at 4:08:58 pm'!"Change Set:		jhmMIDIPlayDate:			11 September 1998Author:			John MaloneyAdds support for three new kinds of MIDI score events:control change, program change, and pitch bend. Addsrudimentary ability to play scores via an external MIDIsynthesizer, but does not yet supply a UI to turn it on."!AbstractScoreEvent subclass: #ControlChangeEvent	instanceVariableNames: 'control value channel '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!AbstractScoreEvent subclass: #PitchBendEvent	instanceVariableNames: 'bend channel '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!AbstractScoreEvent subclass: #ProgramChangeEvent	instanceVariableNames: 'program channel '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!AbstractSound subclass: #ScorePlayer	instanceVariableNames: 'score instruments overallVolume leftVols rightVols muted rate tempo secsPerTick done repeat ticksSinceStart ticksClockIncr trackEventIndex tempoMapIndex activeSounds activeMIDINotes midiPort midiPlayerProcess '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!Object subclass: #SimpleMIDIPort	instanceVariableNames: 'portNumber lastCommandByteOut '	classVariableNames: 'DefaultPortNumber InterfaceClockRate '	poolDictionaries: ''	category: 'Music-Scores'!!AbstractScoreEvent reorganize!('accessing' endTime time time:)('classification' isControlChange isNoteEvent isPitchBend isProgramChange isTempoEvent)('midi' outputOnMidiPort:)!!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isControlChange	^ false! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isPitchBend	^ false! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isProgramChange	^ false! !!AbstractScoreEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port. This default implementation does nothing."! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!control	^ control! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!control: midiControl	control _ midiControl.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!control: midiControl value: midiControlValue channel: midiChannel	control _ midiControl.	value _ midiControlValue.	channel _ midiChannel.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:02'!value	^ value! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!value: midiControlValue	value _ midiControlValue.! !!ControlChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45'!isControlChange	^ true! !!ControlChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rB0		channel: channel		byte: control		byte: value.! !!ControlChangeEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 08:34'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': ctrl['.	control printOn: aStream.	aStream nextPutAll: ']='.	value printOn: aStream.	aStream nextPut: $).! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/10/1998 09:57'!readTrackEvents	"Read the events of the current track."	| cmd chan key vel ticks byte length evt |	cmd _ #unknown.	chan _ key _ vel _ 0.	ticks _ 0.	[trackStream atEnd] whileFalse: [		ticks _ ticks + (self readVarLengthIntFrom: trackStream).		byte _ trackStream next.		byte >= 16rF0			ifTrue: [  "meta or system exclusive event"				byte = 16rFF ifTrue: [self metaEventAt: ticks].				((byte = 16rF0) or: [byte = 16rF7]) ifTrue: [  "system exclusive data"					length _ self readVarLengthIntFrom: trackStream.					trackStream skip: length].				cmd _ #unknown]			ifFalse: [  "channel message event"				byte >= 16r80					ifTrue: [  "new command"						cmd _ byte bitAnd: 16rF0.						chan _ byte bitAnd: 16r0F.						key _ trackStream next]					ifFalse: [  "use running status"						cmd == #unknown							ifTrue: [self error: 'undefined running status; bad MIDI file?'].						key _ byte].				((cmd = 16rC0) or: [cmd = 16rD0]) ifFalse: [					"all but program change and channel pressure have two data bytes"					vel _ trackStream next].				cmd = 16r80 ifTrue: [  "note off"					self endNote: key chan: chan at: ticks].				cmd = 16r90 ifTrue: [  "note on"					vel = 0						ifTrue: [self endNote: key chan: chan at: ticks]						ifFalse: [self startNote: key vel: vel chan: chan at: ticks]].				"cmd = 16A0 -- polyphonic key pressure; skip"				cmd = 16rB0 ifTrue: [					evt _ ControlChangeEvent new control: key value: vel channel: chan.					evt time: ticks.					track add: evt].				cmd = 16rC0 ifTrue: [					evt _ ProgramChangeEvent new program: key channel: chan.					evt time: ticks.					track add: evt].				"cmd = 16D0 -- channel aftertouch pressure; skip"				cmd = 16rE0 ifTrue: [					evt _ PitchBendEvent new bend: key + (vel bitShift: 7) channel: chan.					evt time: ticks.					track add: evt]	]].! !!MIDIScore methodsFor: 'all' stamp: 'jm 9/10/1998 17:22'!eventForTrack: trackIndex after: eventIndex ticks: scoreTick	| track evt |	track _ tracks at: trackIndex.	eventIndex > track size ifTrue: [^ nil].	evt _ track at: eventIndex.	evt time > scoreTick ifTrue: [^ nil].	^ evt! !!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:58'!endNoteOnMidiPort: aMidiPort	"Output a noteOff event to the given MIDI port. (Actually, output a noteOff event with zero velocity. This does the same thing, but allows running status to be used when sending a mixture of note on and off commands.)"	aMidiPort		midiCmd: 16r90		channel: channel		byte: midiKey		byte: 0.! !!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:56'!startNoteOnMidiPort: aMidiPort	"Output a noteOn event to the given MIDI port."	aMidiPort		midiCmd: 16r90		channel: channel		byte: midiKey		byte: velocity.! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!bend	^ bend! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!bend: midiPitchBend	bend _ midiPitchBend.! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!bend: midiPitchBend channel: midiChannel	bend _ midiPitchBend.	channel _ midiChannel.! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!PitchBendEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45'!isPitchBend	^ true! !!PitchBendEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rE0		channel: channel		byte: (bend bitAnd: 16r7F)		byte: (bend bitShift: -7).! !!PitchBendEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 09:42'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': bend '.	bend printOn: aStream.	aStream nextPut: $).! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!program	^ program! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!program: midiProgramChange	program _ midiProgramChange.! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!program: midiProgramChange channel: midiChannel	program _ midiProgramChange.	channel _ midiChannel.! !!ProgramChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:46'!isProgramChange	^ true! !!ProgramChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rC0		channel: channel		byte: program.! !!ProgramChangeEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 08:28'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': prog '.	program printOn: aStream.	aStream nextPut: $).! !!ScorePlayer commentStamp: 'jm 9/11/1998 16:08' prior: 0!This is a real-time player for MIDI scores (i.e., scores read from MIDI files). Score can be played using either the internal sound synthesis or an external MIDI synthesizer on platforms that support MIDI output.!!ScorePlayer reorganize!('initialization' initialize onScore: playOnMidiPort:)('sound generation' doControl isDone isPlaying mixSampleCount:into:startingAt:leftVol:rightVol: processAllAtTick: processAmbientEventsAtTick: processNoteEventsAtTick: processTempoMapAtTick: reset samplesRemaining)('midi output' midiPlayLoop processMIDIEventsAtTick: startMIDIPlaying stopMIDIPlaying turnOffActiveMIDINotesAt:)('accessing' infoForTrack: instrumentForTrack: instrumentForTrack:put: msecsSinceStart mutedForTrack: mutedForTrack:put: overallVolume overallVolume: panForTrack: panForTrack:put: rate rate: repeat repeat: score tempo ticksSinceStart trackCount volumeForTrack: volumeForTrack:put:)('operating' disableReverb: pause resumePlaying tempoOrRateChanged)('copying' copy copySounds)!!ScorePlayer methodsFor: 'initialization' stamp: 'jm 9/10/1998 16:13'!playOnMidiPort: aMIDIPortOrNil	"Direct output as MIDI commands to the given MIDI port. If the argument is nil, use internal sound synthesis."	midiPort _ aMIDIPortOrNil.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 19:07'!doControl	super doControl.	1 to: activeSounds size do: [:i | (activeSounds at: i) first doControl].	ticksSinceStart _ ticksSinceStart + ticksClockIncr.	self processAllAtTick: ticksSinceStart asInteger.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 16:58'!isDone	| track |	activeSounds size > 0 ifTrue: [^ false].	activeMIDINotes size > 0 ifTrue: [^ false].	1 to: score tracks size do: [:i |		track _ score tracks at: i.		(trackEventIndex at: i) <= track size ifTrue: [^ false]].	^ true! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 19:06'!processAllAtTick: scoreTick	self processTempoMapAtTick: scoreTick.	midiPort		ifNil: [self processNoteEventsAtTick: scoreTick]		ifNotNil: [self processMIDIEventsAtTick: scoreTick].	self processAmbientEventsAtTick: scoreTick.	self isDone ifTrue: [		repeat			ifTrue: [self reset]			ifFalse: [done _ true]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:50'!processAmbientEventsAtTick: scoreTick	"Process ambient events through the given tick."	| i evt |	i _ trackEventIndex at: trackEventIndex size.	[evt _ score ambientEventAfter: i ticks: scoreTick.	 evt ~~ nil] whileTrue: [		i _ i + 1.		evt occurAtTime: scoreTick inScorePlayer: self atIndex: i inEventTrack: score ambientTrack secsPerTick: secsPerTick].	trackEventIndex at: trackEventIndex size put: i.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:49'!processNoteEventsAtTick: scoreTick	"Process note events through the given score tick using internal Squeak sound synthesis."	| instr j evt snd |	1 to: score tracks size do: [:i |		instr _ instruments at: i.		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: scoreTick.		 evt ~~ nil] whileTrue: [			(evt isNoteEvent and: [(muted at: i) not]) ifTrue: [				snd _ instr					soundForMidiKey: evt midiKey					dur: secsPerTick * evt duration					loudness: evt velocity asFloat / 127.0.				activeSounds add: (Array with: snd with: i)].			j _ j + 1.			trackEventIndex at: i put: j]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:51'!processTempoMapAtTick: scoreTick	"Process tempo changes through the given score tick."	| map |	map _ score tempoMap.	map ifNil: [^ self].	[(tempoMapIndex <= map size) and:	 [(map at: tempoMapIndex) time <= scoreTick]] whileTrue: [		tempo _ (120.0 * (500000.0 / (map at: tempoMapIndex) tempo)) roundTo: 0.01.		self tempoOrRateChanged.		tempoMapIndex _ tempoMapIndex + 1].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 16:58'!reset	super reset.	tempo _ 120.0.	self tempoOrRateChanged.	done _ false.	ticksSinceStart _ 0.	"one index for each sound track, plus one for the ambient track..."	trackEventIndex _ Array new: score tracks size+1 withAll: 1.	tempoMapIndex _ 1.	activeSounds _ OrderedCollection new.	activeMIDINotes _ OrderedCollection new.	score resetFrom: self.	overallVolume ifNil: [overallVolume _ 0.5].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 21:37'!midiPlayLoop	| mSecsPerStep tStart mSecs |	mSecsPerStep _ 10.	[done] whileFalse: [		tStart _ Time millisecondClockValue.		self processAllAtTick: ticksSinceStart asInteger.		(Delay forMilliseconds: mSecsPerStep) wait.		mSecs _ Time millisecondClockValue - tStart.		mSecs < 0 ifTrue: [mSecs _ mSecsPerStep].  "clock wrap"		ticksSinceStart _ ticksSinceStart + (mSecs asFloat / (1000.0 * secsPerTick))].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 18:31'!processMIDIEventsAtTick: scoreTick	"Process note events through the given score tick using MIDI."	| j evt |	1 to: score tracks size do: [:i |		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: scoreTick.		 evt ~~ nil] whileTrue: [			evt isNoteEvent				ifTrue: [					(muted at: i) ifFalse: [						evt startNoteOnMidiPort: midiPort.						activeMIDINotes add: (Array with: evt with: i)]]				ifFalse: [evt outputOnMidiPort: midiPort].			j _ j + 1.			trackEventIndex at: i put: j]].	self turnOffActiveMIDINotesAt: scoreTick.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 20:45'!startMIDIPlaying	"Start up a process to play this score via MIDI."	midiPort ensureOpen.	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].	midiPlayerProcess _ [self midiPlayLoop] newProcess.	midiPlayerProcess		priority: Processor userInterruptPriority;		resume.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 20:44'!stopMIDIPlaying	"Terminate the MIDI player process and turn off any active notes."	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].	midiPlayerProcess _ nil.	activeMIDINotes do: [:pair | pair first endNoteOnMidiPort: midiPort].	activeMIDINotes _ activeMIDINotes species new.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 17:48'!turnOffActiveMIDINotesAt: scoreTick	"Turn off any active MIDI notes that should be turned off at the given score tick."	| evt someNoteEnded |	midiPort ifNil: [^ self].	someNoteEnded _ false. 	activeMIDINotes do: [:pair |		evt _ pair first.		evt endTime <= scoreTick ifTrue: [			evt endNoteOnMidiPort: midiPort.			someNoteEnded _ true]].	someNoteEnded ifTrue: [		activeMIDINotes _ activeMIDINotes select: [:p | p first endTime > scoreTick]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 20:54'!msecsSinceStart	"Answer the approximate number of milliseconds of real time since the beginning of the score. Since this calculation uses the current tempo, which can change throughout the piece, it is safer to use ticksSinceStart for synchronization."	^ (secsPerTick * ticksSinceStart * 1000) asInteger! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 17:25'!mutedForTrack: trackIndex put: aBoolean	muted at: trackIndex put: aBoolean.	aBoolean ifFalse: [^ self].	"silence any currently sounding notes for this track"	activeSounds do: [:pair |		pair last = trackIndex ifTrue: [activeSounds remove: pair ifAbsent: []]].	midiPort ifNotNil: [		activeMIDINotes do: [:pair |			pair last = trackIndex ifTrue: [				pair first endNoteOnMidiPort: midiPort.				activeMIDINotes remove: pair ifAbsent: []]]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 20:48'!ticksSinceStart	"Answer the number of score ticks that have elapsed since this piece started playing. The duration of a tick is determined by the MIDI score."	^ ticksSinceStart! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:46'!pause	"Pause this sound. It can be resumed from this point, or reset and resumed to start from the beginning."	score pauseFrom: self.	super pause.	activeSounds _ activeSounds species new.	midiPort ifNotNil: [self stopMIDIPlaying].! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:45'!resumePlaying	"Resume playing. Start over if done."	done ifTrue: [self reset].	score resumeFrom: self.	midiPort		ifNil: [super resumePlaying]  "let the sound player drive sound generation" 		ifNotNil: [self startMIDIPlaying].  "start a process to drive MIDI output"! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:56'!tempoOrRateChanged	"This method should be called after changing the tempo or rate."	secsPerTick _ 60.0 / (tempo * rate * score ticksPerQuarterNote).	ticksClockIncr _ (1.0 / self controlRate) / secsPerTick.! !!SimpleMIDIPort commentStamp: 'jm 9/11/1998 16:08' prior: 0!This is a first cut at a simple MIDI output port.!!SimpleMIDIPort reorganize!('open/close' close ensureOpen openOnPortNumber:)('output' midiCmd:channel:byte: midiCmd:channel:byte:byte: midiOutput:)('primitives' primMIDIClosePort: primMIDIOpenPort:readSemaIndex:interfaceClockRate: primMIDIWritePort:from:at:)!!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 9/10/1998 18:48'!close	"Close this MIDI port."	portNumber ifNil: [^ self].	self primMIDIClosePort: portNumber.		portNumber _ nil.	lastCommandByteOut _ nil.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 9/10/1998 18:40'!ensureOpen	"Make sure this MIDI port is open. It is good to call this before starting to use a port in case an intervening image save/restore has caused the underlying hardware port to get closed."	| portNum |	portNumber ifNil: [^ self openOnPortNumber: 'Use "openOn:" to open a MIDI port initially'].	portNum _ portNumber.	self close.	self openOnPortNumber: portNum.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 9/10/1998 18:48'!openOnPortNumber: portNum	"Open this MIDI port on the given port number."	self close.	portNumber _ portNum.	self primMIDIOpenPort: portNum readSemaIndex: 0 interfaceClockRate: InterfaceClockRate.	lastCommandByteOut _ Array new: 16 withAll: 0.  "initialize running status state for output"! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/10/1998 15:55'!midiCmd: cmd channel: channel byte: dataByte	"Immediately output the given MIDI command with the given channel and argument byte to this MIDI port. Assume that the port is open."	self primMIDIWritePort: portNumber		from: (ByteArray			with: (cmd bitOr: channel)			with: dataByte)		at: 0.! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/10/1998 15:54'!midiCmd: cmd channel: channel byte: dataByte1 byte: dataByte2	"Immediately output the given MIDI command with the given channel and argument bytes to this MIDI port. Assume that the port is open."	self primMIDIWritePort: portNumber		from: (ByteArray			with: (cmd bitOr: channel)			with: dataByte1			with: dataByte2)		at: 0.! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/10/1998 18:39'!midiOutput: aByteArray	"Output the given bytes to this MIDI port immediately. Assume that the port is open."	self primMIDIWritePort: portNumber from: aByteArray at: 0.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 9/10/1998 15:11'!primMIDIClosePort: portNum	<primitive: 521>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 9/10/1998 15:11'!primMIDIOpenPort: portNum readSemaIndex: readSemaIndex interfaceClockRate: interfaceClockRate	"Open the given MIDI port. If non-zero, readSemaIndex specifies the index in the external objects array of a semaphore to be signalled when incoming MIDI data is available. Not all platforms support signalling the read semaphore. InterfaceClockRate specifies the clock rate of the external MIDI interface adaptor on Macintosh computers; it is ignored on other platforms."	<primitive: 526>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 9/10/1998 15:14'!primMIDIWritePort: portNum from: byteArray at: midiClockValue	<primitive: 529>	self primitiveFailed.! !!SimpleMIDIPort class reorganize!('class initialization' initialize)('instance creation' openDefault openOnPortNumber:)!!SimpleMIDIPort class methodsFor: 'class initialization' stamp: 'jm 9/10/1998 15:33'!initialize	"SimpleMIDIPort initialize"	InterfaceClockRate _ 1000000.	DefaultPortNumber _ 0.! !!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 9/10/1998 18:36'!openDefault	"Answer a new instance of me opened on the default MIDI port."	^ self openOnPortNumber: DefaultPortNumber! !!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 9/10/1998 18:38'!openOnPortNumber: portNum	"Answer a new instance of me open on the given MIDI port."	^ super new openOnPortNumber: portNum! !!TempoEvent methodsFor: 'all' stamp: 'jm 9/10/1998 08:37'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': tempo '.	((120.0 * (500000.0 / tempo)) roundTo: 0.01) printOn: aStream.	aStream nextPut: $).! !AbstractScoreEvent removeSelector: #playOnMidiPort:!AbstractScoreEvent removeSelector: #writeOnMidiPort:!ControlChangeEvent removeSelector: #control:channel:!ControlChangeEvent removeSelector: #playOnMidiPort:!ControlChangeEvent removeSelector: #writeOnMidiPort:!MIDIScore removeSelector: #eventForTrack:after:ticks:secsPerTick:!MIDIScore removeSelector: #soundForTrack:after:ticks:instrument:secsPerTick:!PitchBendEvent removeSelector: #playOnMidiPort:!PitchBendEvent removeSelector: #writeOnMidiPort:!ProgramChangeEvent removeSelector: #playOnMidiPort:!ProgramChangeEvent removeSelector: #isControlChange!ProgramChangeEvent removeSelector: #writeOnMidiPort:!ScorePlayer removeSelector: #processMIDINoteEventsAtTick:!ScorePlayer removeSelector: #processEventsAtTick:!ScorePlayer removeSelector: #turnOffActiveMIDINotes!ScorePlayer removeSelector: #midiDoControl!ScorePlayer removeSelector: #reverbState:!ScorePlayer removeSelector: #startMIDIPlayerProcess!SimpleMIDIPort removeSelector: #initializeRunningStatus!SimpleMIDIPort removeSelector: #nextPutAll:!SimpleMIDIPort removeSelector: #write:!SimpleMIDIPort removeSelector: #resetRunningStatus!SimpleMIDIPort removeSelector: #primMIDIGetPortDirectionality:!SimpleMIDIPort removeSelector: #putAll:!SimpleMIDIPort removeSelector: #openOn:!SimpleMIDIPort removeSelector: #outputNow:!SimpleMIDIPort removeSelector: #output:!SimpleMIDIPort removeSelector: #midiWrite:!SimpleMIDIPort removeSelector: #primMIDIGetPortName:!SimpleMIDIPort initialize!SimpleMIDIPort class removeSelector: #default!SimpleMIDIPort class removeSelector: #on:!SimpleMIDIPort class removeSelector: #new!TempoEvent removeSelector: #channel!