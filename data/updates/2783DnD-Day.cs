'From Squeak2.9alpha of 13 June 2000 [latest update: #2813] on 7 October 2000 at 4:24:53 pm'!"Change Set:		DnD-DayDate:			7 October 2000Author:			Andreas RaabThe third wave of the event rewrite. Fixes tons of issues in the strange protocols involved in drag and drop (although not all). Most of the stuff has been achieved by simply removing all strange looking code and by inserting the most straightforward solution coming to mind (e.g., such as '^true' ;-)The ChangeSet also fixes the issue of lagging events and mouse move sends on each cycle. With these changes you will get #mouseMove IF AND ONLY IF the mouse has moved. Mouse move events have a trail of all the intermediate (untransformed) mouse locations recorded with the same state. #mouseEnter/#mouseLeave events are generated by other means (from the hand's mouseOverHandler). ScrollBars have been fixed to take the new regime into account and use stepping rather than relying on implicit sends of #mouseStillDown.The issue of parts donors and parts bins has only partly been solved (due to the problem of converting old parts bins). The new regime basically has the following rules:* PasteUpMorphs have the hand pick up the top-level object if a mouse down is not handled.* When picking up an object which is flagged as a parts donor, the partRepresented (which may not be the morph itself, such as for thumbnails) is being duplicated.This restores the basic behavior from before the changes. Other objects which may be flagged as being 'parts donors' and not residing in a paste up need to take care of the appropriate operations itself - as an example PhraseTileMorphs (usually residing in some viewer) handle mouseDown by returning a duplicate of itself if the tile is flagged as being a parts donor.Also, the use of a modal shell for pop up menus (introduced during the first wave) has been extended for FillInTheBlanks making those guys really modal."!!KeyboardEvent methodsFor: 'private' stamp: 'ar 10/5/2000 23:54'!setType: aSymbol buttons: anInteger position: pos keyValue: aValue hand: aHand stamp: stamp	type _ aSymbol.	buttons _ anInteger.	position _ pos.	keyValue _ aValue.	source _ aHand.	wasHandled _ false.	timeStamp _ stamp.! !!Morph methodsFor: 'copying' stamp: 'ar 10/7/2000 13:54'!duplicate	"Make and return a duplicate of the receiver"	| newMorph aName w |	self okayToDuplicate ifFalse:[^self].	aName _ (w _ self world) ifNotNil:[w nameForCopyIfAlreadyNamed: self].	newMorph _ self veryDeepCopy.	aName ifNotNil: [newMorph setNameTo: aName].	newMorph player ifNotNil: [newMorph player startRunning].	^ newMorph! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 10/6/2000 19:09'!allKnownNames	"Return a list of all known names based on the scope of the receiver"	| allNames theName |	self isPartsBin ifTrue:[^#()]. "Don't report names from parts bins"	allNames _ WriteStream on: #().	self submorphsDo:[:m|		(theName _ m knownName) ifNotNil:[allNames nextPut: theName].		allNames nextPutAll: m allKnownNames.	].	^allNames contents! !!Morph methodsFor: 'geometry' stamp: 'ar 10/6/2000 15:16'!boundsIn: referenceMorph	"Return the receiver's bounds as seen by aMorphs coordinate frame"	owner ifNil: [^ self bounds].	^(owner transformFrom: referenceMorph) localBoundsToGlobal: self bounds.! !!Morph methodsFor: 'geometry' stamp: 'ar 10/6/2000 15:36'!transformedBy: aTransform	aTransform isIdentity ifTrue:[^self].	aTransform isPureTranslation ifTrue:[		self position: self position + aTransform translation.	].	^self addFlexShell transformedBy: aTransform! !!Morph methodsFor: 'geometry' stamp: 'ar 10/6/2000 15:16'!worldBoundsForHalo	"To restore older behavior, change this to return  self fullBoundsInWorld"	^ self boundsIn: nil! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/6/2000 15:13'!grabTransform	"Return the transform for the receiver which should be applied during grabbing"	^owner ifNil:[IdentityTransform new] ifNotNil:[owner grabTransform]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/6/2000 22:51'!undoGrabCommand	"Return the undo command for grabbing the receiver"	| cmd |	owner ifNil:[^nil]. "no owner - no undo"	^(cmd _ Command new)		cmdWording: 'move ', (self externalName truncateTo: 10);		undoTarget: self		selector: #undoMove:redo:owner:bounds:predecessor:		arguments: {cmd. false. owner. self bounds. (owner morphPreceding: self)}! !!Morph methodsFor: 'scripting' stamp: 'ar 10/6/2000 18:52'!asEmptyPermanentScriptor	"Answer a new empty permanent scriptor derived from info deftly secreted in the receiver.  Good grief"	| aScriptor aPlayer |	aPlayer _ self valueOfProperty: #player.	aPlayer assureUniClass.	aScriptor _  aPlayer permanentScriptEditorFor: nil.	aScriptor position: (self world primaryHand position - (10 @ 10)).	aPlayer updateAllViewersAndForceToShow: #scripts.	^ aScriptor! !!Morph methodsFor: 'parts bin' stamp: 'ar 10/6/2000 22:45'!partRepresented	^self! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/7/2000 13:50'!handleDropMorph: anEvent	"Handle a dropping morph."	| aMorph |	aMorph _ anEvent contents.	"Do a symmetric check if both morphs like each other"	(self wantsDroppedMorph: aMorph event: anEvent) ifFalse:[^self]. "I don't want her"	(aMorph wantsToBeDroppedInto: self) ifFalse:[^self]. "She doesn't want me"	anEvent wasHandled: true.	self acceptDroppingMorph: aMorph event: anEvent.	aMorph justDroppedInto: self event: anEvent.! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/6/2000 00:15'!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingBalloonFor: self.	anEvent hand removePendingHaloFor: self.	anEvent wasHandled: true.	self flag: #arNote. "For now bail out into hand meta menu"	anEvent controlKeyPressed ifTrue:[^self invokeMetaMenu: anEvent].	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent blueButtonChanged ifTrue:[^self blueButtonDown: anEvent].	self mouseDown: anEvent.	anEvent hand removeHaloFromClick: anEvent on: self.! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/6/2000 00:15'!handleMouseLeave: anEvent	"System level event handling."	anEvent hand removePendingBalloonFor: self.	anEvent hand removePendingHaloFor: self.	anEvent isDraggingEvent ifTrue:[		(self handlesMouseOverDragging: anEvent) ifTrue:[			anEvent wasHandled: true.			self mouseLeaveDragging: anEvent].		^self].	(self handlesMouseOver: anEvent) ifTrue:[		anEvent wasHandled: true.		self mouseLeave: anEvent.	].! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/7/2000 13:53'!duplicateMorph: evt	"Make and return a duplicate of the receiver's argument"	| dup |	dup _ self duplicate.	self isPartsDonor ifTrue:[dup isPartsDonor: false].	(dup fullBounds containsPoint: evt position) 		ifFalse:[dup position: evt position].	evt hand grabMorph: dup.	^dup! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/6/2000 16:37'!grabMorph: evt	evt hand grabMorph: self! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/6/2000 16:36'!makeFlexMorphFor: aHand	aHand grabMorph: (FlexMorph new originalMorph: page)! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'ar 10/7/2000 15:43'!addModalShell	"Add a new modal shell to the receiver"	| shell |	shell _ ModalShellMorph new.	shell primaryMouseReceiver: self.	shell setProperty: #morphicLayerNumber toValue: self morphicLayerNumber.	owner ifNotNil:[owner replaceSubmorph: self by: shell].	shell addMorphFront: self.	^shell! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'ar 10/7/2000 15:54'!delete	self breakDependents.	owner isModalShell ifTrue:[owner delete] ifFalse:[super delete].! !!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'ar 10/7/2000 15:49'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w shell |	w _ self world.	w ifNil: [^ response].	shell _ self addModalShell.	w primaryHand newMouseFocus: shell.	done _ false.	[done] whileFalse: [Display doOneCycleMorphic].	owner isModalShell ifTrue:[owner delete] ifFalse:[self delete].	Display doOneCycleMorphic.	^ response! !!FillInTheBlankMorph methodsFor: 'event handling' stamp: 'ar 10/7/2000 15:47'!handlesMouseDown: evt	^true! !!FillInTheBlankMorph methodsFor: 'event handling' stamp: 'ar 10/7/2000 16:00'!mouseDown: evt	(self containsPoint: evt position) ifFalse:[^Smalltalk beep]. "sent in response to outside modal click"	evt hand grabMorph: self. "allow repositioning"! !!FillInTheBlankMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/7/2000 15:51'!aboutToBeGrabbedBy: aHand	(owner notNil and:[owner isModalShell]) ifTrue:[owner delete].	^super aboutToBeGrabbedBy: aHand.! !!FillInTheBlankMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/7/2000 15:51'!justDroppedInto: aMorph event: anEvent	"This FITBM was grabbed and moved"	| shell |	super justDroppedInto: aMorph event: anEvent.	shell _ self addModalShell.	shell receiveNewFocus: anEvent! !!FillInTheBlankMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/7/2000 15:50'!undoGrabCommand	^nil! !!HandMorph methodsFor: 'initialization' stamp: 'ar 10/5/2000 23:20'!initForEvents	lastMouseEvent _ MouseEvent new setType: #mouseMove position: 0@0 buttons: 0 hand: self.	self resetClickState.! !!HandMorph methodsFor: 'accessing' stamp: 'ar 10/5/2000 23:17'!lastEvent	^ lastMouseEvent! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 23:16'!checkForMoreKeyboard	"Quick check for more keyboard activity -- Allows, eg, many characters	to be accumulated into a single replacement during type-in."	self flag: #arNote. "Will not work if we don't examine event queue in Sensor"	^nil! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 23:17'!flushEvents	"Flush any events that may be pending"	self flag: #arNote. "Remove it and fix senders"	Sensor flushEvents.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/6/2000 18:39'!handleEvent: anEvent	| evt prevEvt |	anEvent isMorphicEvent 		ifTrue:[evt _ anEvent]		ifFalse:[			prevEvt _ lastEvent.			lastEvent _ anEvent.			evt _ anEvent asNewEventFrom: prevEvt].	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendEvent: evt focus: mouseFocus].ShowEvents == true ifTrue:[	evt printString displayAt: (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	keyboardFocus printString displayAt: 0@45.].	"Notify listeners"	self sendListenEvent: evt to: eventListeners.	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: keyboardListeners.		self sendEvent: evt focus: keyboardFocus.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[self sendListenEvent: evt to: mouseListeners].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		evt isMouse ifTrue:[lastMouseEvent _ evt].		(mouseClickState handleEvent: evt from: self) ifFalse:[^self]].	evt isMove ifTrue:[		self position: evt position.		self sendEvent: evt focus: mouseFocus.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on non-move mouse events"		(self hasSubmorphs) ifTrue:[self dropMorphs: evt].		self sendEvent: evt focus: mouseFocus.	].	ShowEvents == true ifTrue:[mouseFocus printString displayAt: 0@15].	evt isMouse ifTrue:[lastMouseEvent _ evt].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/7/2000 15:19'!newProcessEvents	"Process user input events from the local input devices.	An interesting problem. Morphic is always supposed to run in an event driven environment but for now it is possible that a Morphic window is run from MVC so that we have to synthesize events in the sensor. That's quite a bit of a problem because it means that we'll get endless mouse events. To compensate for this, EventSensor will always return keyboard events first if synthesized so if we're running into a mouse event AND Sensor doesn't have an event queue we can safely break out of the event processing loop. See also EventSensor>>nextEventSynthesized."	| evt currentExtent evtBuf type hadMouse hadAny |	hadMouse _ hadAny _ false.	[(evtBuf _ Sensor nextEvent) == nil] whileFalse:[		evt _ nil. "for unknown event types"		type _ evtBuf at: 1.		(type = EventTypeMouse)			ifTrue:[evt _ self generateMouseEvent: evtBuf. hadMouse _ true].		(type = EventTypeKeyboard) 			ifTrue:[evt _ self generateKeyboardEvent: evtBuf].		"All other events are ignored"		(evt notNil and:[remoteConnections size > 0]) ifTrue: [			"Transmit the event to interested listeners"			currentExtent _ self worldBounds extent.			self lastWorldExtent ~= currentExtent ifTrue: [				self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).				self lastWorldExtent: currentExtent].			self transmitEvent: evt].		evt == nil ifFalse:[			"Finally, handle it"			self handleEvent: evt.			hadAny _ true].		"See the note on running a World in MVC in the method comment"		(evt isMouse and:[Sensor eventQueue == nil]) ifTrue:[^self].	].	(mouseClickState notNil and:[hadMouse not]) ifTrue:[		"No mouse events during this cycle. Make sure click states time out accordingly"		mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	hadAny ifFalse:[		"No pending events. Make sure z-order is up to date"		self mouseOverHandler processMouseOver: lastMouseEvent.	].! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/7/2000 15:19'!processEvents	"Process user input events from the local input devices.	An interesting problem. Morphic is always supposed to run in an event driven environment but for now it is possible that a Morphic window is run from MVC so that we have to synthesize events in the sensor. That's quite a bit of a problem because it means that we'll get endless mouse events. To compensate for this, EventSensor will always return keyboard events first if synthesized so if we're running into a mouse event AND Sensor doesn't have an event queue we can safely break out of the event processing loop. See also EventSensor>>nextEventSynthesized."	| evt currentExtent evtBuf type hadMouse hadAny |	hadMouse _ hadAny _ false.	[(evtBuf _ Sensor nextEvent) == nil] whileFalse:[		evt _ nil. "for unknown event types"		type _ evtBuf at: 1.		(type = EventTypeMouse)			ifTrue:[evt _ self generateMouseEvent: evtBuf. hadMouse _ true].		(type = EventTypeKeyboard) 			ifTrue:[evt _ self generateKeyboardEvent: evtBuf].		"All other events are ignored"		(evt notNil and:[remoteConnections size > 0]) ifTrue: [			"Transmit the event to interested listeners"			currentExtent _ self worldBounds extent.			self lastWorldExtent ~= currentExtent ifTrue: [				self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).				self lastWorldExtent: currentExtent].			self transmitEvent: evt].		evt == nil ifFalse:[			"Finally, handle it"			self handleEvent: evt.			hadAny _ true].		"See the note on running a World in MVC in the method comment"		(evt isMouse and:[Sensor eventQueue == nil]) ifTrue:[^self].	].	(mouseClickState notNil and:[hadMouse not]) ifTrue:[		"No mouse events during this cycle. Make sure click states time out accordingly"		mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	hadAny ifFalse:[		"No pending events. Make sure z-order is up to date"		self mouseOverHandler processMouseOver: lastMouseEvent.	].! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:09'!keyboardFocus 	^ keyboardFocus! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:10'!mouseFocus	^mouseFocus! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:09'!newKeyboardFocus: aMorphOrNil	"Make the given morph the new keyboard focus, canceling the previous keyboard focus if any. If the argument is nil, the current keyboard focus is cancelled."	| oldFocus |	oldFocus _ keyboardFocus.	keyboardFocus _ aMorphOrNil.	oldFocus ifNotNil: [oldFocus == aMorphOrNil ifFalse: [oldFocus keyboardFocusChange: false]].	aMorphOrNil ifNotNil: [aMorphOrNil keyboardFocusChange: true].! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:09'!newMouseFocus: aMorphOrNil	| itsPasteUp toView |	self flag: #arNote. "Clean this up"	aMorphOrNil ifNotNil: 		[((itsPasteUp  _ aMorphOrNil pasteUpMorph) notNil and:			[itsPasteUp automaticViewing]) ifTrue:				[toView _ itsPasteUp					submorphThat:						[:aMorph | aMorphOrNil hasOwner: aMorph]					ifNone:						[nil].				(toView notNil and: [toView isCandidateForAutomaticViewing]) ifTrue:					[toView openViewerForArgument]]].	mouseFocus _ aMorphOrNil.! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:09'!newMouseFocus: aMorph event: event	aMorph == nil ifFalse:[		targetOffset _ event cursorPoint - aMorph position.	].	^self newMouseFocus: aMorph.! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:09'!releaseAllFoci	mouseFocus _ nil.	keyboardFocus _ nil.! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:09'!releaseKeyboardFocus	"Release the current keyboard focus unconditionally"	self newKeyboardFocus: nil.! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:09'!releaseKeyboardFocus: aMorph	"If the given morph had the keyboard focus before, release it"	keyboardFocus == aMorph ifTrue:[self releaseKeyboardFocus].! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:10'!releaseMouseFocus	"Release the current mouse focus unconditionally."	self newMouseFocus: nil.! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:10'!releaseMouseFocus: aMorph	"If the given morph had the mouse focus before, release it"	self mouseFocus == aMorph ifTrue:[self releaseMouseFocus].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/6/2000 16:43'!dropMorph: aMorph event: anEvent	"Drop the given morph which was carried by the hand"	| event |	event _ DropEvent new setPosition: self position contents: aMorph hand: self.	owner processEvent: event.	event wasHandled ifFalse:[aMorph rejectDropMorphEvent: event].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/6/2000 23:26'!grabMorph: aMorph	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor grabbed tfm |	self releaseMouseFocus.	aMorph isTileLike ifTrue: [editor _ aMorph topEditor].	editor ifNotNil:[editor scriptEdited].	self flag: #arNote. "Fix dropping by taking the target offset into account"	grabbed _ aMorph aboutToBeGrabbedBy: self.	grabbed ifNil:[^self].	grabbed _ grabbed topRendererOrSelf.	tfm _ grabbed owner ifNil:[IdentityTransform new] ifNotNil:[grabbed owner grabTransform].	grabbed _ grabbed transformedBy: tfm.	targetOffset _ grabbed position - self position.	self addMorphBack: grabbed.	editor ifNotNil: [editor scriptEdited].! !!HandMorph methodsFor: 'balloon help' stamp: 'ar 10/6/2000 00:14'!removePendingBalloonFor: aMorph	"Get rid of pending balloon help."	self removeAlarm: #spawnBalloonFor:.	self deleteBalloonTarget: aMorph.! !!HandMorph methodsFor: 'halo handling' stamp: 'ar 10/6/2000 00:14'!removePendingHaloFor: aMorph	"Get rid of pending balloon help or halo actions."	self removeAlarm: #spawnHaloFor:.! !!HandMorph methodsFor: 'private events' stamp: 'ar 10/6/2000 00:07'!generateKeyboardEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	| buttons modifiers type keyValue pressType stamp |	stamp _ (evtBuf at: 2).	stamp = 0 ifTrue:[stamp _ Time millisecondClockValue].	keyValue _ evtBuf at: 3.	pressType _ evtBuf at: 4.	pressType = EventKeyDown ifTrue:[type _ #keyDown].	pressType = EventKeyUp ifTrue:[type _ #keyUp].	pressType = EventKeyChar ifTrue:[type _ #keystroke].	modifiers _ evtBuf at: 5.	buttons _ modifiers bitShift: 3.	^KeyboardEvent new		setType: type		buttons: buttons		position: self position		keyValue: keyValue		hand: self		stamp: stamp! !!HandMorph methodsFor: 'private events' stamp: 'ar 10/6/2000 00:07'!generateMouseEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	| position buttons modifiers type trail stamp |	stamp _ (evtBuf at: 2).	stamp = 0 ifTrue:[stamp _ Time millisecondClockValue].	position _ (evtBuf at: 3) @ (evtBuf at: 4).	buttons _ (evtBuf at: 5).	modifiers _ (evtBuf at: 6).	buttons = 0 		ifTrue:[	lastMouseEvent anyButtonPressed					ifTrue:[type _ #mouseUp]					ifFalse:[type _ #mouseMove]]		ifFalse:[	lastMouseEvent anyButtonPressed					ifTrue:[type _ #mouseMove]					ifFalse:[type _ #mouseDown]].	buttons _ buttons bitOr: (modifiers bitShift: 3).	type == #mouseMove ifTrue:[		trail _ self mouseTrailFrom: evtBuf.		^MouseMoveEvent new 			setType: type 			startPoint: trail first			endPoint: trail last 			trail: trail			buttons: buttons			hand: self			stamp: stamp.	].	^MouseButtonEvent new 		setType: type 		position: position		which: (lastMouseEvent buttons bitXor: buttons)		buttons: buttons 		hand: self		stamp: stamp! !!HandMorph methodsFor: 'private events' stamp: 'ar 10/6/2000 00:08'!mouseTrailFrom: currentBuf	"Current event, a mouse event buffer, is about to be processed.  If there are other similar mouse events queued up, then drop them from the queue, and report the positions inbetween."	| nextEvent trail |	trail _ WriteStream on: (Array new: 1).	trail nextPut: ((currentBuf at: 3) @ (currentBuf at: 4)).	[(nextEvent _ Sensor peekEvent) == nil] whileFalse:[		(nextEvent at: 1) = (currentBuf at: 1) ifFalse:			[^ trail contents  "different event type"].		(nextEvent at: 5) = (currentBuf at: 5) ifFalse:			[^ trail contents  "buttons changed"].		(nextEvent at: 6) = (currentBuf at: 6) ifFalse:			[^ trail contents  "modifiers changed"].		"nextEvent is similar.  Remove it from the queue, and check the next."		nextEvent _ Sensor nextEvent.		trail nextPut: ((nextEvent at: 3) @ (nextEvent at: 4))	].	^trail contents! !!HandMorph methodsFor: 'private events' stamp: 'ar 10/6/2000 00:08'!moveToEvent: anEvent	"Issue a mouse move event to make the receiver appear at the given position"	self handleEvent: (MouseMoveEvent new		setType: #mouseMove 		startPoint: self position 		endPoint: anEvent position 		trail: (Array with: self position with: anEvent position)		buttons: anEvent buttons		hand: self		stamp: anEvent timeStamp)! !!HandMorph methodsFor: 'private events' stamp: 'ar 10/6/2000 00:08'!sendEvent: anEvent focus: focusHolder	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."	focusHolder ifNil:[^owner processEvent: anEvent].	^self sendFocusEvent: anEvent to: focusHolder.! !!HandMorph methodsFor: 'private events' stamp: 'ar 10/6/2000 00:08'!sendFocusEvent: anEvent to: focusHolder	"Send the event to the morph currently holding the focus"	^focusHolder handleFocusEvent: 		(anEvent transformedBy: (focusHolder transformedFrom: self)).! !!HandMorph methodsFor: 'private events' stamp: 'ar 10/6/2000 00:08'!sendListenEvent: anEvent to: listenerGroup	"Send the event to the given group of listeners"	listenerGroup ifNil:[^self].	listenerGroup do:[:listener| listener handleListenEvent: anEvent copy].! !!HandMorph methodsFor: 'private' stamp: 'ar 10/6/2000 00:11'!veryDeepCopyWith: deepCopier	"Return self.  Do not copy hands this way."	^ self! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 10/6/2000 15:37'!transformedBy: aTransform	self transform: (self transform composedWithGlobal: aTransform).! !!MenuMorph methodsFor: 'control' stamp: 'ar 10/7/2000 15:50'!aboutToBeGrabbedBy: aHand	popUpOwner ifNotNil:["Detach submenu from popUpOwner and delete its menu"		popUpOwner delete.		popUpOwner _ nil].	(owner notNil and:[owner isModalShell]) ifTrue:[owner delete].	^super aboutToBeGrabbedBy: aHand.! !!MenuMorph methodsFor: 'control' stamp: 'ar 10/7/2000 13:57'!addModalShell	"Add a new modal shell to the receiver"	| shell |	shell _ ModalShellMorph new.	shell primaryMouseReceiver: self.	shell setProperty: #morphicLayerNumber toValue: self morphicLayerNumber.	owner ifNotNil:[owner replaceSubmorph: self by: shell].	shell addMorphFront: self.	^shell! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'ar 10/7/2000 00:16'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	self flag: #bob.		"is <aPoint> global or local?"	self flag: #arNote.	self flag: #workAround. "ar 10/7/2000: 10@0 offset below is to prevent a pop up menu from being directly under the cursor in which case it may get a mouseUp immediately invoking some action."	self popUpAt: aPoint+(10@0) forHand: aWorld primaryHand in: aWorld.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneSubCycle].	self delete.	^ mvcSelection! !!MorphThumbnail methodsFor: 'as yet unclassified' stamp: 'ar 10/7/2000 15:38'!morphRepresented: aMorph	morphRepresented _ aMorph.	self computeThumbnail.! !!MorphThumbnail methodsFor: 'parts bin' stamp: 'ar 10/7/2000 15:38'!isPartsDonor	^self partRepresented isPartsDonor! !!MorphThumbnail methodsFor: 'parts bin' stamp: 'ar 10/7/2000 15:38'!isPartsDonor: aBool	self partRepresented isPartsDonor: aBool! !!MorphThumbnail methodsFor: 'parts bin' stamp: 'ar 10/6/2000 22:46'!partRepresented	^self morphRepresented! !!MorphicEvent methodsFor: 'private' stamp: 'ar 10/5/2000 23:56'!asNewEventFrom: lastEvent	(self isMouseDown or:[self isMouseUp]) ifTrue:[		^MouseButtonEvent new 			setType: type 			position: cursorPoint 			which: (lastEvent buttons bitXor: buttons)			buttons: buttons 			hand: sourceHand			stamp: Time millisecondClockValue.	].	self isMouseMove ifTrue:[		^MouseMoveEvent new 			setType: type 			startPoint: sourceHand position			endPoint: cursorPoint 			trail: #()			buttons: buttons 			hand: sourceHand			stamp: Time millisecondClockValue.	].	self isKeyboard ifTrue:[		^KeyboardEvent new			setType: type			buttons: buttons			position: sourceHand position			keyValue: keyValue			hand: sourceHand			stamp: Time millisecondClockValue.	].! !!MorphicModel methodsFor: 'access' stamp: 'ar 10/6/2000 19:21'!allKnownNames	"Answer a list of all the names of all named objects borne in my instance variable values"	^ super allKnownNames, (self instanceVariableValues select: [:e | (e ~~ nil) and: [e knownName ~~ nil]] thenCollect: [:e | e knownName])! !!MouseEvent methodsFor: 'converting' stamp: 'ar 10/6/2000 18:59'!asMouseMove	"Convert the receiver into a mouse move"	^MouseMoveEvent new setType: #mouseMove startPoint: position endPoint: position trail: {position. position} buttons: buttons hand: source stamp: Time millisecondClockValue.! !!MouseButtonEvent methodsFor: 'private' stamp: 'ar 10/5/2000 23:55'!setType: evtType position: evtPos which: button buttons: evtButtons hand: evtHand stamp: stamp	type _ evtType.	position _ evtPos.	buttons _ evtButtons.	source _ evtHand.	wasHandled _ false.	whichButton _ button.	timeStamp _ stamp.! !!MouseMoveEvent methodsFor: 'private' stamp: 'ar 10/5/2000 23:55'!setType: evtType startPoint: evtStart endPoint: evtEnd trail: evtTrail buttons: evtButtons hand: evtHand stamp: stamp	type _ evtType.	startPoint _ evtStart.	position _ evtEnd.	trail _ evtTrail.	buttons _ evtButtons.	source _ evtHand.	wasHandled _ false.	timeStamp _ stamp.! !!PaintInvokingMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/6/2000 22:50'!justDroppedInto: aPasteUpMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	self delete.	aPasteUpMorph makeNewDrawing: anEvent.! !!PaintInvokingMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/6/2000 22:50'!wantsToBeDroppedInto: aMorph	"Only into PasteUps that are not part bins"	^aMorph isPlayfieldLike and:[aMorph isPartsBin not]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/6/2000 23:19'!acceptDroppingMorph: dropped event: evt	| slotSpecs aValue incomingName nameObtained mm tfm aMorph |	aMorph _ self morphToDropFrom: dropped.	self isWorldMorph		ifTrue:			["Add the given morph to this world and start stepping it if it wants to be."			self addMorphFront: aMorph.			(aMorph fullBounds intersects: self viewBox) ifFalse:				[self beep.  aMorph position: self bounds center]]		ifFalse:			[self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).			self changed.			self layoutChanged].	incomingName _ aMorph knownName.	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self autoLineLayout ifTrue: [self fixLayout].	aMorph allMorphsDo:  "Establish any penDown morphs in new world"		[:m | m player ifNotNil:			[m player getPenDown ifTrue:				[((mm _ m player costume) notNil and: [(tfm _ mm owner transformFrom: self) notNil])					ifTrue: [self noteNewLocation: (tfm localPointToGlobal: mm referencePosition)									forPlayer: m player]]]].	self isPartsBin		ifTrue:			[aMorph isPartsDonor: true.			aMorph stopSteppingSelfAndSubmorphs.			aMorph suspendEventHandler]		ifFalse:			[self world startSteppingSubmorphsOf: aMorph].	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	slotSpecs _ aMorph slotSpecifications.  "A Fabrik component, for example.  Just a hook at this time"	slotSpecs size > 0 ifTrue:		[self assuredPlayer.		slotSpecs do:			[:tuple |				aValue _ aMorph initialValueFor: tuple first.				nameObtained _ self player addSlotNamedLike: tuple first withValue: aValue.				nameObtained ~= incomingName ifTrue:					[aMorph setNameTo: nameObtained]].		self player updateAllViewers]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/7/2000 15:54'!morphToDropFrom: aMorph 	| aNail representee handy posBlock tempPos |	handy _ self primaryHand.	posBlock _ [:z | 			tempPos _ handy position - (handy targetOffset - aMorph formerPosition * (z extent / aMorph extent)) rounded.			self pointFromWorld: tempPos].	self alwaysShowThumbnail		ifTrue: [aNail _ aMorph						representativeNoTallerThan: self maxHeightToAvoidThumbnailing						norWiderThan: self maximumThumbnailWidth						thumbnailHeight: self heightForThumbnails.			aNail == aMorph				ifFalse: [aNail						position: (posBlock value: aNail)].			^ aNail].	((aMorph isKindOf: MorphThumbnail)			and: [(representee _ aMorph morphRepresented) owner == nil])		ifTrue: [representee				position: (posBlock value: representee).			^ representee].	self automaticPhraseExpansion		ifFalse: [^ aMorph].	(aMorph hasProperty: #newPermanentScript)		ifTrue: [^ aMorph asEmptyPermanentScriptor].	(aMorph isKindOf: PhraseTileMorph)		ifFalse: [^ aMorph].	^ aMorph morphToDropInPasteUp: self! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/6/2000 00:19'!repelsMorph: aMorph event: ev	(aMorph wantsToBeDroppedInto: self) ifFalse: [^ false].	self dragNDropEnabled ifFalse: [^ true].	(self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].	^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/6/2000 00:21'!wantsDroppedMorph: aMorph event: evt	self isWorldMorph ifTrue:[^true]. "always"	self visible ifFalse: [^ false].  "will be a call to #hidden again very soon"	self dragNDropEnabled ifFalse: [^ false].	^ true! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 10/6/2000 17:57'!morphToGrab: event	"Return the morph to grab from a mouse down event. If none, return nil."	self submorphsDo:[:m|		(m fullContainsPoint: event cursorPoint) ifTrue:[			(m isSticky or:[m isLocked]) 				ifTrue:[^nil] "so we don't grab stuff behind"				ifFalse:[^m]].	].	^nil! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 10/7/2000 13:53'!mouseDown: evt	"Handle a mouse down event."	| grabbedMorph |	grabbedMorph _ self morphToGrab: evt.	grabbedMorph ifNotNil:[		grabbedMorph isPartsDonor 			ifTrue:[^grabbedMorph partRepresented duplicateMorph: evt].		^evt hand grabMorph: grabbedMorph].	(super handlesMouseDown: evt)		ifTrue:[^super mouseDown: evt].	evt hand releaseKeyboardFocus. "shake of keyboard foci"	evt shiftPressed ifTrue:[^self dragThroughOnDesktop: evt].	self isWorldMorph ifTrue:[self addAlarm: #invokeWorldMenu: with: evt after: 200].! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 10/6/2000 00:04'!mouseUp: evt	self isWorldMorph ifTrue:[self removeAlarm: #invokeWorldMenu:].	super mouseUp: evt.! !!ComponentLayout methodsFor: 'as yet unclassified' stamp: 'ar 10/6/2000 19:20'!allKnownNames	^ super allKnownNames, (self submorphs collect: [:m | m knownName] thenSelect: [:m | m ~~ nil])! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'ar 10/6/2000 23:38'!handlesMouseDown: evt	^true! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'ar 10/6/2000 23:11'!morphToDropInPasteUp: aPasteUp	| actualObject itsSelector aScriptor anEditor adjustment handy |	self isCommand ifFalse: [^ self].	(actualObject _ self actualObject) ifNil: [^ self].	actualObject assureUniClass.	itsSelector _ self userScriptSelector.	aScriptor _ (itsSelector ~~ nil and: [itsSelector size > 0])		ifTrue:			[actualObject isFlagshipForClass				ifFalse: 					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: self.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					[(actualObject class userScriptForPlayer: actualObject selector: itsSelector) 						isTextuallyCoded ifTrue:							[^ aPasteUp scriptorForTextualScript: itsSelector ofPlayer: actualObject].					adjustment _ 0@0.					aScriptor _ actualObject scriptEditorFor: itsSelector]]		ifFalse:			["It's a system-defined selector; construct an anonymous scriptor around it"			adjustment _ 60 @ 20.			actualObject permanentScriptEditorFor: self].	handy _ aPasteUp primaryHand.	aScriptor position: handy position - adjustment.	(aScriptor isMemberOf: ScriptEditorMorph) ifTrue:		[aScriptor playerScripted expungeEmptyUnRenamedScripts].	^ aScriptor! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'ar 10/6/2000 23:00'!mouseDown: evt 	"Pretend we picked up the tile and then put it down for a trial  	positioning."	"The essence of ScriptEditor mouseEnter:"	| ed ss |	self isPartsDonor ifTrue:[^self duplicateMorph: evt].	submorphs isEmpty		ifTrue: [^ self].	owner class == TilePadMorph		ifTrue: ["picking me out of another phrase"			(ss _ submorphs first) class == TilePadMorph				ifTrue: [ss _ ss submorphs first].			owner addMorph: ss fullCopy].	(ed _ self enclosingEditor)		ifNotNil: [evt hand grabMorph: self.			ed startStepping]! !!PlayingCardMorph methodsFor: 'events' stamp: 'ar 10/6/2000 18:21'!startDrag: evt	| root popUp |	evt isMouseDown ifTrue:		[root _ owner rootForGrabOf: self.		root == nil			ifTrue: ["Display hidden card in front"					popUp _ self copy.					self board owner owner addMorphFront: popUp.					self world displayWorld.					(Delay forMilliseconds: 750) wait.					popUp delete]			ifFalse: [evt hand grabMorph: root]]! !!PolygonMorph methodsFor: 'halo control' stamp: 'ar 10/6/2000 15:40'!transformedBy: aTransform	self setVertices: (self vertices collect:[:v| aTransform localPointToGlobal: v])! !!ScrollBar methodsFor: 'initialize' stamp: 'ar 10/7/2000 15:06'!initializeDownButton	downButton := RectangleMorph		newBounds: (self innerBounds bottomRight - self buttonExtent extent: self buttonExtent)		color: Color lightGray.	downButton on: #mouseDown send: #scrollDownInit to: self.	downButton on: #mouseUp send: #finishedScrolling to: self.	downButton addMorphCentered: (ImageMorph new image: 		(self 			cachedImageAt: (bounds isWide ifTrue: ['right'] ifFalse: ['down']) 			ifAbsentPut: [				self upArrow8Bit					rotateBy: (bounds isWide ifTrue: [#right] ifFalse: [#pi])					centerAt: 0@0			]		)	).	downButton setBorderWidth: 1 borderColor: #raised.	self addMorph: downButton! !!ScrollBar methodsFor: 'initialize' stamp: 'ar 10/7/2000 15:07'!initializePagingArea	pagingArea := RectangleMorph newBounds: self totalSliderArea								color: (Color r: 0.6 g: 0.6 b: 0.8).	pagingArea borderWidth: 0.	pagingArea on: #mouseDown send: #scrollPageInit: to: self.	pagingArea on: #mouseUp send: #finishedScrolling to: self.	self addMorph: pagingArea! !!ScrollBar methodsFor: 'initialize' stamp: 'ar 10/7/2000 15:06'!initializeUpButton	upButton := RectangleMorph		newBounds: ((menuButton ifNil: [self innerBounds topLeft]				ifNotNil: [bounds isWide ifTrue: [menuButton bounds topRight]									ifFalse: [menuButton bounds bottomLeft]])					extent: self buttonExtent)		color: Color lightGray.	upButton on: #mouseDown send: #scrollUpInit to: self.	upButton on: #mouseUp send: #finishedScrolling to: self.	upButton addMorphCentered: (ImageMorph new image:		(self 			cachedImageAt: (bounds isWide ifTrue: ['left'] ifFalse: ['up'])			ifAbsentPut: [				bounds isWide ifTrue: [					self upArrow8Bit rotateBy: #left centerAt: 0@0				] ifFalse: [					self upArrow8Bit				]			]		)	).	upButton setBorderWidth: 1 borderColor: #raised.	self addMorph: upButton! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:13'!doScrollByPage	"Scroll automatically while mouse is down"	(self waitForDelay1: 300 delay2: 100) ifFalse: [^ self].	nextPageDirection		ifTrue: [self setValue: (value + pageDelta min: 1.0)]		ifFalse: [self setValue: (value - pageDelta max: 0.0)]! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:13'!doScrollDown	"Scroll automatically while mouse is down"	(self waitForDelay1: 300 delay2: 50) ifFalse: [^ self].	self setValue: (value + scrollDelta + 0.000001 min: 1.0)! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:14'!doScrollUp	"Scroll automatically while mouse is down"	(self waitForDelay1: 300 delay2: 50) ifFalse: [^ self].	self setValue: (value - scrollDelta - 0.000001 max: 0.0)! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:06'!finishedScrolling	self stopStepping.	self scrollBarAction: nil.	downButton borderRaised.	upButton borderRaised.! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 14:56'!scrollBarAction	^self valueOfProperty: #scrollBarAction! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 14:56'!scrollBarAction: aSymbol	self setProperty: #scrollBarAction toValue: aSymbol! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:12'!scrollByPage: event	self flag: #obsolete.	pagingArea eventHandler: nil.	pagingArea on: #mouseDown send: #scrollPageInit: to: self.	pagingArea on: #mouseUp send: #finishedScrolling to: self.	^self scrollPageInit: event! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:12'!scrollDown	self flag: #obsolete.	downButton eventHandler: nil.	downButton on: #mouseDown send: #scrollDownInit to: self.	downButton on: #mouseUp send: #finishedScrolling to: self.	^self scrollDownInit! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:05'!scrollDownInit	downButton borderInset.	self resetTimer.	self scrollBarAction: #doScrollDown.	self startStepping.! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:08'!scrollPageInit: evt	self resetTimer.	nextPageDirection _ evt cursorPoint y >= slider center y.	self scrollBarAction: #doScrollByPage.	self startStepping.! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:11'!scrollUp	self flag: #obsolete.	upButton eventHandler: nil.	upButton on: #mouseDown send: #scrollUpInit to: self.	upButton on: #mouseUp send: #finishedScrolling to: self.	^self scrollUpInit! !!ScrollBar methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:05'!scrollUpInit	upButton borderInset.	self resetTimer.	self scrollBarAction: #doScrollUp.	self startStepping.! !!ScrollBar methodsFor: 'stepping' stamp: 'ar 10/7/2000 15:02'!step	| action |	action _ self scrollBarAction.	action ifNotNil:[self perform: action].! !!ScrollBar methodsFor: 'stepping' stamp: 'ar 10/7/2000 15:02'!stepTime	^25! !!ScrollBar methodsFor: 'stepping' stamp: 'ar 10/7/2000 15:02'!wantsSteps	^self scrollBarAction notNil! !!ScrollPane methodsFor: 'pane events' stamp: 'ar 10/7/2000 15:57'!handlesMouseOverDragging: evt	^self handlesMouseOver: evt! !!ScrollPane methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:57'!mouseEnterDragging: event	"Ignored"! !!ScrollPane methodsFor: 'scrolling' stamp: 'ar 10/7/2000 15:57'!mouseLeaveDragging: event	^self mouseLeave: event! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/6/2000 16:36'!mouseUp: evt inMorph: aMorph	evt hand grabMorph: aMorph	"old instances may have a handler we no longer use"! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'ar 10/6/2000 23:26'!startDrag: evt onItem: itemMorph 	| ddm |	evt hand hasSubmorphs		ifTrue: [^self].	itemMorph ifNotNil: [itemMorph highlightForMouseDown: false].	model okToChange ifFalse: [		Cursor normal show.		^ self].  "No change if model is locked"	"itemMorph ~= self selection ifTrue: [self setSelectedMorph: itemMorph]."	ddm _ TransferMorph withPassenger: (self model dragPassengerFor: itemMorph inMorph: self) from: self.	ddm dragTransferType: (self model dragTransferTypeForMorph: self).	Preferences dragNDropWithAnimation			ifTrue: [self model dragAnimationFor: itemMorph transferMorph: ddm].	evt hand grabMorph: ddm.! !!StringMorph methodsFor: 'editing' stamp: 'ar 10/6/2000 00:16'!handlesMouseDown: evt	^ (evt shiftPressed and: [self wantsKeyboardFocusOnShiftClick])		ifTrue: [true]		ifFalse: [super handlesMouseDown: evt].! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/6/2000 19:01'!invokeWithEvent: evt	"Perform the action associated with the given menu item."	| selArgCount w |	self isEnabled ifFalse: [^ self].	selector ifNil:[^self].	target class == HandMorph ifTrue: [(self notObsolete) ifFalse: [^ self]].	owner ifNotNil:[selector == #toggleStayUp: ifFalse:[		w _ self world ifNil:[^self]. "Brrrrr ... a menu item invoked outside a world???"		owner deleteIfPopUp: evt.		w displayWorldSafely]].	Cursor normal showWhile: [  "show cursor in case item opens a new MVC window"		(selArgCount _ selector numArgs) = 0			ifTrue:				[target perform: selector]			ifFalse:				[selArgCount = arguments size					ifTrue: [target perform: selector withArguments: arguments]					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]]].! !!TextMorph methodsFor: 'editing' stamp: 'ar 10/6/2000 00:16'!handlesMouseDown: evt	self isPartsDonor ifTrue: [^ false].	^true! !!TextMorphForEditView methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 23:30'!mouseMove: evt	super mouseMove: evt.	editView scrollSelectionIntoView: evt.! !!TextPlusPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/6/2000 00:06'!mouseDown: evt	"Handle a mouse down event."	evt shiftPressed ifTrue: [^ self dragThroughOnDesktop: evt].! !!TransferMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/6/2000 17:30'!undoGrabCommand	^nil! !!TransformationMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/6/2000 15:20'!grabTransform	"Return the transform for the receiver which should be applied during grabbing"	self renderedMorph isWorldMorph ifTrue:[^super grabTransform].	^owner ifNil:[self transform] ifNotNil:[owner grabTransform composedWithLocal: self transform]! !!TransformationMorph methodsFor: 'geometry' stamp: 'ar 10/6/2000 15:37'!transformedBy: aTransform	self transform: (self transform composedWithGlobal: aTransform).! !!TrashCanMorph methodsFor: 'event handling' stamp: 'ar 10/6/2000 00:17'!handlesMouseDown: evt	^ self inPartsBin not! !!UpdatingMenuItemMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/7/2000 15:35'!arrangeToStartSteppingIn: aWorld	super arrangeToStartSteppingIn: aWorld.	self updateContents.! !!UpdatingMenuItemMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/7/2000 15:34'!step	super step.	self updateContents.! !!UpdatingMenuItemMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/7/2000 15:34'!updateContents	| newString enablement |	wordingProvider ifNotNil:		[wordingSelector ifNotNil:			[newString _ wordingProvider perform: wordingSelector.			newString = contents ifFalse: [self contents: newString]].		enablementSelector ifNotNil:			[(enablement _ self enablement) == isEnabled ifFalse:				[self isEnabled: enablement]]]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'ar 10/6/2000 00:17'!handlesMouseDown: evt	(owner wantsKeyboardFocusFor: self)		ifTrue:[^true].	^ super handlesMouseDown: evt! !ViewerRow removeSelector: #rootForGrabOf:!ViewerEntry removeSelector: #rootForGrabOf:!Viewer removeSelector: #willingToBeEmbeddedUponLanding!TilePadMorph removeSelector: #rootForGrabOf:!MenuTile removeSelector: #trumpsMouseDown:!TileMorph removeSelector: #trumpsMouseDown:!TabbedPalette removeSelector: #repelsMorph:event:!TabSorterMorph removeSelector: #substituteForMorph:beingDroppedOn:!SystemWindow removeSelector: #willingToBeEmbeddedUponLanding!StickySketchMorph removeSelector: #rootForGrabOf:!ScrollBar removeSelector: #finishScrolling!ScrollBar removeSelector: #nextPage:!ScriptEditorMorph removeSelector: #rootForGrabOf:!PlayingCardMorph removeSelector: #rootForGrabOf:!PhraseTileMorph removeSelector: #rootForGrabOf:!GeeBookPageMorph removeSelector: #recipientForMouseDown:!PasteUpMorph removeSelector: #allKnownNames!PasteUpMorph removeSelector: #clickOnDesktop:!PasteUpMorph removeSelector: #emptyPermanentScriptorFrom:!PasteUpMorph removeSelector: #expandPhrasesToScripts!PasteUpMorph removeSelector: #quickClickOnDesktop:!PasteUpMorph removeSelector: #rootForGrabOf:!PasteUpMorph removeSelector: #seeksOutHalo!MouseMoveEvent removeSelector: #setType:startPoint:endPoint:trail:buttons:hand:!MouseButtonEvent removeSelector: #setType:position:which:buttons:hand:!MenuMorph removeSelector: #willingToBeEmbeddedUponLanding!FlashButtonMorph removeSelector: #trumpsMouseDown:!HandMorph removeSelector: #grabMorph:in:!HandMorph removeSelector: #grabMorphFromMenu:inWorld:!HandMorph removeSelector: #grabMorphInner:!HandMorph removeSelector: #grabMorphInner:inWorld:!HandMorph removeSelector: #latestEventSimilarTo:!HandMorph removeSelector: #removePendingTriggersFor:!HandMorph removeSelector: #testEvent:ifQuickClick:ifMoved:!HandMorph removeSelector: #updateMouseDownTransform!!HandMorph reorganize!('initialization' initForEvents initialize)('accessing' lastEvent mouseOverHandler targetOffset userInitials)('classification' isHandMorph)('cursor' cursorBounds showTemporaryCursor: showTemporaryCursor:hotSpotOffset:)('geometry' changed fullBounds invalidRect: position position: userInitials:andPicture:)('drawing' colorForInsets drawOn: fullDrawOn: hasChanged hasUserInformation needsToBeDrawn nonCachingFullDrawOn: restoreSavedPatchOn: savePatchFrom: shadowForm shadowOffset trailMorph updateCacheCanvas:)('event handling' checkForMoreKeyboard flushEvents handleEvent: newProcessEvents noticeMouseOver:event: pauseEventRecorderIn: processEvents)('focus handling' keyboardFocus mouseFocus newKeyboardFocus: newMouseFocus: newMouseFocus:event: releaseAllFoci releaseKeyboardFocus releaseKeyboardFocus: releaseMouseFocus releaseMouseFocus:)('double click support' resetClickState waitForClicksOrDrag:event: waitForClicksOrDrag:event:selectors:threshold:)('grabbing/dropping' attachMorph: dropMorph:event: dropMorphs dropMorphs: grabMorph:)('remote morphic' cleanupDeadConnections connectRemoteUser connectRemoteUserWithName:picture:andIPAddress: disconnectAllRemoteUsers disconnectRemoteUser lastEventTransmitted lastEventTransmitted: lastWorldExtent lastWorldExtent: readyToTransmit reportLocalAddress startTransmittingEventsTo: stopTransmittingEventsTo: transmitEvent:)('listeners' addEventListener: addKeyboardListener: addMouseListener: removeEventListener: removeKeyboardListener: removeMouseListener:)('balloon help' balloonHelp balloonHelp: deleteBalloonTarget: removePendingBalloonFor: spawnBalloonFor: triggerBalloonFor:after:)('halo handling' halo halo: removeHaloFromClick:on: removePendingHaloFor: spawnHaloFor: triggerHaloFor:after:)('paste buffer' copyToPasteBuffer: objectToPaste pasteBuffer pasteBuffer: pasteMorph)('private events' generateKeyboardEvent: generateMouseEvent: mouseTrailFrom: moveToEvent: sendEvent:focus: sendFocusEvent:to: sendListenEvent:to:)('object fileIn' convertbosfceekmmmdccffuleatdccttggrtllmhssffa0:bosfceekmmmdccffuleatdccttggrtllmhssffac0: convertbosfceekmmmdccffuleatdccttggrtllmhssffa0:bosfceekmmmdccffuleatdccttggrtllmhssffacw0: convertbosfceekmmmdccffuleatdccttggrtllmhssffac0:bosfceekmmmdccffuleatdccttggrtllmhssffacw0:)('private' objectForDataStream: releaseCachedState veryDeepCopyWith:)!EToyFridgeMorph removeSelector: #rootForGrabOf:!BookPageSorterMorph removeSelector: #willingToBeEmbeddedUponLanding!BookMorph removeSelector: #rootForGrabOf:!BookMorph removeSelector: #seeksOutHalo!BackgroundMorph removeSelector: #rootForGrabOf:!AlignmentMorph removeSelector: #rootForGrabOf:!Morph removeSelector: #allMorphsNotInPartsBins!Morph removeSelector: #allMorphsNotInPartsBinsDo:!Morph removeSelector: #morphToDropFrom:!Morph removeSelector: #preemptsMouseDown:!Morph removeSelector: #rootForGrabOf:!Morph removeSelector: #seeksOutHalo!Morph removeSelector: #substituteForMorph:beingDroppedOn:!Morph removeSelector: #trumpsMouseDown:!Morph removeSelector: #willingToBeEmbeddedUponLanding!KeyboardEvent removeSelector: #setType:buttons:position:keyValue:hand:!"Postscript:"Smalltalk isMorphic ifTrue:[World primaryHand initForEvents].!