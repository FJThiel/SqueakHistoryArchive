'From Squeak 2.1 of June 30, 1998 on 15 September 1998 at 12:11:52 am'!"Change Set:		celest-lsDate:			14 September 1998Author:			Lex SpoonMakes Celeste work with POP and SMTP, thus connecting Squeak to Internet email.To try it out, choose 'email reader' from the World-open menu, and do a 'fetch email' from the top left pane.  Your messages will NOT be deleted from the POP server; they will be merely downloaded.  Then play away.  To give two hints, Celeste divides mail into 'categories', and many actions are performed from menu items."!Model subclass: #Celeste	instanceVariableNames: 'mailDB currentCategory currentMessages currentTOC currentMsgID lastCategory subjectFilter fromFilter dateFilter customFilterBlock formatMessages lastCategoryList lastCategoryMenu messageTextView '	classVariableNames: 'CCList CustomFilters DeleteInboxAfterFetching EmailDBName FormatWhenFetching InOutFolder PopServer PopUserName QueueDBName SmtpServer SuppressWorthlessHeaderFields UserName '	poolDictionaries: ''	category: 'NetTools-Celeste'!Object subclass: #MailAddressParser	instanceVariableNames: 'tokens addresses curAddrTokens '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-RFC822'!Object subclass: #MailAddressToken	instanceVariableNames: 'type text '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-RFC822'!Stream subclass: #MailAddressTokenizer	instanceVariableNames: 'cachedToken text pos '	classVariableNames: 'CSNonAtom CSNonSeparators CSParens CSSpecials '	poolDictionaries: ''	category: 'Network-RFC822'!!Celeste methodsFor: 'open-close' stamp: 'ls 9/13/1998 00:01'!close	"Close the mail database."	mailDB ifNotNil: [		mailDB close; release.		mailDB _ nil ].! !!Celeste methodsFor: 'open-close' stamp: 'ls 9/13/1998 21:15'!openOnDatabase: aMailDB	"Initialize myself for the mail database with the given root filename."	mailDB _ aMailDB.	mailDB addDependent: self.	currentCategory _ 'new'.	lastCategory _ ''.	subjectFilter _ ''.	fromFilter _ ''.	dateFilter _ nil.	self setCategory: currentCategory.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/13/1998 02:35'!categoryMenu: aMenu	"Answer the menu for the categories pane."	| labels lineSeparations selectors lines |	labels _ 'save\close\fetch mail\send queued mail\add category' withCRs.	lineSeparations _  #(2 2).	selectors _ #(save saveAndClose fetchMail sendQueuedMail addCategory).	"add extra commands if a normal category is selected"	((currentCategory notNil) and:	 [(currentCategory ~= '.all.') &	  (currentCategory ~= '.unclassified.')])		ifTrue: [			labels _ labels, '\rename category\remove category\export category' withCRs.			lineSeparations _ lineSeparations, #(4).			selectors _ selectors, #(renameCategory removeCategory exportCategory ). ]		ifFalse: [			lineSeparations _ lineSeparations, #(1) ].	labels _ labels, '\empty trash\compact\toggle headers\set user name\set cc: list\set POP server\set POP username\set SMTP server' withCRs.	lineSeparations _ lineSeparations, #(2 1 5).	selectors _ selectors, #(emptyTrash compact toggleSuppressHeaders setUserName setCCList setPopServer setPopUSername setSmtpServer).	"add toggle for whether to delete messages on download"	DeleteInboxAfterFetching		ifTrue: [ labels _ labels, '\leave messages on server' withCRs.			selectors _ selectors, #(keepMessagesOnServer) ]		ifFalse: [ labels _ labels, '\don''t leave messages on server' withCRs.			selectors _ selectors, #(deleteMessagesAfterFetching) ].	lineSeparations _ lineSeparations, #(1).	"convert lineSeperations into absolute line positions"	lines _ lineSeparations copyFrom: 1 to: (lineSeparations size - 1).	(2 to: lines size) do: [ :i |		lines at: i put: ((lines at: i) + (lines at: i-1)) ].	^aMenu labels: labels lines: lines  selections: selectors! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 01:45'!deleteMessagesAfterFetching	"start deleting messages off the server after POP-ing"	DeleteInboxAfterFetching _ true! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/14/1998 07:33'!fetchMail	"Add the messages from the mail inbox file into this mail database."	| count server userName password |	self checkTrash.	server _ self class popServer.	userName _ self class popUserName.	password _ self class popPassword.	[count _ mailDB POPMailFrom: server		userName: userName		password: password		doFormatting: FormatWhenFetching		deleteInbox: DeleteInboxAfterFetching		informingUser: true.	 Transcript nextPutAll: count printString, ' messages'; cr; endEntry.	 currentCategory _ 'new'. 	] ifError: [ :err :rcvr | 			Transcript show: err.			(self confirm: 'Error: ', err, String cr,'debug it?') ifTrue: [ self halt ]. ].	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/10/1998 01:46'!importMail	"Add the messages from the mail inbox file into this mail database."	| inboxPath count |	inboxPath _ Celeste inOutFolder.	inboxPath size > 0		ifTrue: [ inboxPath _ inboxPath, '/inbox' ]		ifFalse: [ inboxPath _ 'inbox' ].	Transcript show: 'Fetching mail from ', inboxPath.	count _ mailDB fetchMailFrom: inboxPath		doFormatting: FormatWhenFetching		deleteInbox: DeleteInboxAfterFetching.	Transcript nextPutAll: count printString, ' messages'; cr; endEntry.	currentCategory _ 'new'.	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 01:45'!keepMessagesOnServer	"start keeping messages on the server after POP-ing"	DeleteInboxAfterFetching _ false! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/13/1998 20:10'!setCategory: newCategory	"Change the currently selected category. We must also compute the table of contents and message list for the new category."	currentCategory _ newCategory.	(newCategory isNil)		ifTrue:			[currentMessages _ currentTOC _ currentMsgID _ nil]		ifFalse:			[currentMessages _ self filteredMessagesIn: newCategory.			 currentTOC _ OrderedCollection new: currentMessages size.			 1 to: currentMessages size do:				[: i |				 currentTOC add:					(i printString, ' ',					 (mailDB getTOCstring: (currentMessages at: i)))].			 currentTOC _ currentTOC asArray.			 (currentMessages includes: currentMsgID) ifFalse:				[currentMsgID _ nil]].	self changed: #category.	self changed: #tocEntryList.	self changed: #messageText.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 00:37'!setPopServer	^self class setPopServer! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 00:39'!setPopUserName	^self class setPopUserName! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/13/1998 02:31'!setSmtpServer	^self class setSmtpServer! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 9/10/1998 02:19'!updateTOC	"Update the table of contents after a moving, removing, or deleting a message. Select a message near the removed message in the table of contents if possible."	| currentMsgIndex |	((currentCategory isNil) |	 (currentMsgID isNil) |	 (currentMessages size < 2))		ifTrue: [currentMsgIndex _ 1]		ifFalse: [currentMsgIndex _ currentMessages indexOf: currentMsgID].	currentMsgID _ nil.	self setCategory: currentCategory.  "update currentMessages, currentTOC"	currentMessages isEmpty ifFalse: [		(currentMsgIndex <= currentMessages size)			ifTrue: [currentMsgID _ currentMessages at: currentMsgIndex]			ifFalse: [currentMsgID _ currentMessages last].	].	self changed: #tocEntryList.	self changed: #messageText.! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/11/1998 19:37'!customFilterOn	"Select or define and activate a custom filter."	| filterList filterName filterExpr |	filterList _ CustomFilters keys asSortedCollection asOrderedCollection.	filterList addLast: '<define new filter...>'.	filterList addLast: '<edit exising filter...>'.	filterList addLast: '<delete a filter...>'.	filterName _ (CustomMenu selections: filterList)			startUpWithCaption: 'Select a filter:'.	filterName = nil ifTrue: [^self].	filterName = '<delete a filter...>' ifTrue: [^ self deleteFilter].	filterName = '<edit exising filter...>'		ifTrue: [filterExpr _ self editFilter]		ifFalse: [			filterName = '<define new filter...>'				ifTrue: [filterExpr _ self defineFilter]				ifFalse: [filterExpr _ CustomFilters at: filterName]].	filterExpr isEmpty ifTrue: [^self].	customFilterBlock _ Compiler evaluate: '[ :m | ', filterExpr, ']'.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/14/1998 10:38'!filteredMessagesIn: categoryName	| msgList |	msgList _ mailDB messagesIn: categoryName.	(customFilterBlock notNil) ifTrue:		[msgList _ msgList select:			[: id | customFilterBlock value: (mailDB getTOCentry: id) ]].	(fromFilter size > 0) ifTrue:		[msgList _ msgList select:			[: id | (mailDB getTOCentry: id) from includesSubstring: fromFilter caseSensitive: false]].	(subjectFilter size > 0) ifTrue:		[msgList _ msgList select:			[: id | (mailDB getTOCentry: id) subject includesSubstring: subjectFilter caseSensitive: false]].	^msgList! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/12/1998 19:37'!subjectFilterOn	"Show only those messages whose subject matches the currently selected message. The user is given a chance to edit the pattern string used to match 'Subject:' fields."	subjectFilter _		(currentMsgID isNil)			ifTrue: ['']			ifFalse: [(mailDB getTOCentry: currentMsgID) subject].	subjectFilter _ subjectFilter withBlanksTrimmed.	(subjectFilter asLowercase beginsWith: 're:') ifTrue: [		subjectFilter _ subjectFilter copyFrom: 4 to: subjectFilter size.		subjectFilter _ subjectFilter withBlanksTrimmed ].	subjectFilter _ FillInTheBlank		request: '''Subject:'' filter pattern?'		initialAnswer: subjectFilter.	subjectFilter _ self removeTrailingSeparators: subjectFilter.	self updateTOC.! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 02:56'!compose	"Make a MailSendTool for composing a new message."	self openSender: self composeText.! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/14/1998 22:23'!doItContext	^nil! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/14/1998 22:23'!doItReceiver	^nil! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 02:57'!forward	"Make a MailSendTool for forwarding the current message."	(currentMsgID notNil) ifTrue:		[self openSender: (self forwardTextFor: currentMsgID)].! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 03:08'!reply	"Make a MailSendTool for replying to the current message."	(currentMsgID notNil) ifTrue:		[self openSender: (self replyTextFor: currentMsgID)].! !!Celeste methodsFor: 'other' stamp: 'ls 9/14/1998 07:33'!checkTrash	"check the .trash. folder, and inform the user if it's getting excessively large"	| numTrash numTotal |	numTrash _ (mailDB messagesIn: '.trash.') size.	numTotal _ (mailDB messagesIn: '.all.') size.	(numTrash > 20 and: [ numTrash > (numTotal / 2)]) ifTrue: [		self inform: 'you have more deleted email than non-deleted.You might consider running "empty trash" and "compact"' ].! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 02:55'!composeText	"Answer the template for a new message."	^String streamContents: [ :str |		str nextPutAll: 'From: '.		str nextPutAll: Celeste userName.		str cr.		str nextPutAll: 'To: '; cr.		str nextPutAll: 'Subject: '; cr.		Celeste ccList isEmpty ifFalse: [			str nextPutAll: 'Cc: '.			str nextPutAll: Celeste ccList.			str cr ].		str cr. ]! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 03:07'!forwardTextFor: msgID	"Answer the template for forwarding the message with the given ID."	^self composeText, '---------- Forwarded ----------',	(mailDB getText: msgID), '-------------------------------'! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 02:56'!hasUsername: aString	"Answer true if the given string contains the user's name."	^((aString asLowercase)		findString: (Celeste userName) asLowercase		startingAt: 1) ~= 0! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/12/1998 02:40'!openSender: initialText	"open a message sender with the given initial text"	Smalltalk isMorphic ifTrue: [ ^self openSenderInMorphic: initialText ].	^self notYetImplemented.! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/14/1998 10:57'!openSenderInMorphic: initialText	"open an interface for sending a mail message with the given initial text"	| textHolder win textMorph buttonsList sendButton |	textHolder _ StringHolder new.	textHolder contents: initialText.	win _ SystemWindow labelled: 'Mister Postman'.		textMorph _ PluggableTextMorph on: textHolder text: #contents  accept: #acceptContents:.	win addMorph: textMorph  frame: (0@0.1 corner: 1@1).	buttonsList _ AlignmentMorph newRow.	sendButton _ PluggableButtonMorph on: [			textMorph hasUnacceptedEdits ifTrue: [ textMorph accept ].			self queueMessageWithText: textHolder contents.			win delete. ]		getState: nil		action: #value.	sendButton label: 'send mesage'.	sendButton onColor: Color white  offColor: Color white.	buttonsList addMorphBack: sendButton.		win addMorph: buttonsList  frame: (0@0 extent: 1@0.1).	win openInMVC.! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 03:10'!queueMessageWithText: aStringOrText	"queue a message for sending.  Currently, this simply sticks it in .tosend."	"add a x-mailer line"	| messageText id |	messageText _		'X-Mailer: ',		Celeste versionString, 		String cr, 		aStringOrText asString.		"actually queue the message"	id _ mailDB addNewMessage: (MailMessage from: messageText) inCategory: '.tosend.'.	mailDB file: id inCategory: 'sent'.	self changed: #categoryList.	self changed: #tocEntryList.! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 06:12'!replyTextFor: msgID	"Answer the template for a reply to the message with the given ID."	| msg s anyCCs |	msg _ mailDB getMessage: msgID.	s _ WriteStream on: (String new: 500).	"add From:"	s nextPutAll: 'From: ', Celeste userName; cr.	"add To:"	s nextPutAll: 'To: ', msg from; cr.	"add CC:s from the message and from the user's CC list"	s nextPutAll: 'CC: '.	anyCCs _ false.	(msg to isEmpty) ifFalse: [		anyCCs ifTrue:[ s nextPutAll: ', '] ifFalse: [ anyCCs _ true ].		s nextPutAll: msg to ].	(msg cc isEmpty) ifFalse: [		anyCCs ifTrue: [ s nextPutAll: ', ' ] ifFalse: [ anyCCs _ true ].		s nextPutAll: msg cc ].	(Celeste ccList isEmpty) ifFalse: [		anyCCs ifTrue: [ s nextPutAll: ', ' ] ifFalse: [ anyCCs _ true ].			s nextPutAll: Celeste ccList ].	s cr.	"add Subject:"	((msg subject asLowercase indexOfSubCollection: 're:' startingAt: 1) ~= 0)		ifTrue: [s nextPutAll: 'Subject: ', msg subject]		ifFalse: [s nextPutAll: 'Subject: Re: ', msg subject].	s cr.	"add contents of previous message"	s cr.	s nextPutAll: msg from; nextPutAll: ' wrote:'; cr.	msg body linesDo: [ :line |		s nextPutAll: '> '.		s nextPutAll: line.		s cr ].	s cr.	^s contents! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/14/1998 10:38'!sendQueuedMail	"send queued mail out"	| msgIds msgNum message recipients |	"gather up message IDs of messages to send"	msgIds _ mailDB messagesIn: '.tosend.'.	msgIds isEmpty ifTrue: [		^self inform: 'all messages have been sent' ].	msgNum _ 1.	('sending ', msgIds size printString, ' messages...')		displayProgressAt: Sensor mousePoint		from: 0		to: msgIds size		during: 	[ :bar | msgIds do: [ :id |		message _ mailDB getMessage: id.				"gather up the recipients"		recipients _ Set new.		recipients addAll: (MailAddressParser addressesIn: message to).		recipients addAll: (MailAddressParser addressesIn: message cc).		"send it out"		[(SMTPSocket 			deliverMailFrom: Celeste userName 			to: recipients 			text: message text 			usingServer: Celeste smtpServer) ifFalse: [ self error: 'error delivering mail' ].		] ifError: [ :a :b |			self error: 'error delivering message' ].			"inform the user we are starting a new message"		bar value: msgNum.		msgNum _ msgNum + 1.		].	"remove all these messages from the queue"	msgIds do: [ :id |		mailDB remove: id  fromCategory: '.tosend.' ].	].	mailDB saveDB.	"update any Celeste display windows to account for the changing .tosend. category"	self updateTOC.! !!Celeste class methodsFor: 'class initialization' stamp: 'ls 9/10/1998 23:36'!initialize	"Celeste initialize"	"user preferences"	InOutFolder _ nil.	UserName _ nil.	CCList _ nil.	SuppressWorthlessHeaderFields _ true.	EmailDBName _ 'EMAIL'.		"file to store user's EMAIL in"	QueueDBName _ 'QUEUE'.		"file to store outgoing email in"	"options with no UI; just set their values directly"	FormatWhenFetching _ false.	DeleteInboxAfterFetching _ false.	"dictionary of custom filters"	CustomFilters _ Dictionary new.! !!Celeste class methodsFor: 'class initialization' stamp: 'ls 9/13/1998 02:14'!versionString	"return a short string describing this version of Celeste"	^'Celeste 2.0'! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/10/1998 01:44'!popPassword	"answer the password to use when retrieving mail via POP"	^FillInTheBlank request: 'POP password'! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/10/1998 01:46'!popServer	"Answer the server for downloading email via POP"	[PopServer isNil or: [PopServer isEmpty]]		whileTrue: [self setPopServer].	^PopServer! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/10/1998 01:42'!popUserName	"Answer the user's username on the POP server"	[PopUserName isNil or: [PopUserName isEmpty]]		whileTrue: [self setPopUserName].	^PopUserName! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/13/1998 02:21'!setCCList	"Change the list of names used in the default cc list. Items in the list should be valid mail addresses and should be separated by commas."	| newList |	(CCList isNil) ifTrue: [CCList _ ''].	newList _ FillInTheBlank		request: 'Please type a list of email addresses for the cc: field,separated by commas:'		initialAnswer: CCList.	CCList _ newList.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/10/1998 01:44'!setPopServer	"Change the user's email name for use in composing messages."	(PopServer isNil) ifTrue: [PopServer _ ''].	PopServer _ FillInTheBlank		request: 'What is your POP server?'		initialAnswer: PopServer.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/13/1998 02:31'!setPopUserName	"set the POP server used for downloading email"	(PopUserName isNil) ifTrue: [PopUserName _ ''].	PopUserName _ FillInTheBlank		request: 'What is your POP username?'		initialAnswer: PopUserName.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/13/1998 02:30'!setSmtpServer	"Set the SMTP server used to send outgoing messages via"	(SmtpServer isNil) ifTrue: [		PopServer isNil			ifTrue: [ SmtpServer _ '' ]			ifFalse: [ SmtpServer _ PopServer ] ].	SmtpServer _ FillInTheBlank		request: 'What is your mail server?'		initialAnswer: SmtpServer.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/13/1998 02:31'!smtpServer	"Answer the server for sending email"	[SmtpServer isNil or: [SmtpServer isEmpty]]		whileTrue: [self setSmtpServer].	^SmtpServer! !!Celeste class methodsFor: 'sending' stamp: 'ls 9/10/1998 23:27'!openMailSenderOn: aStringOrText	"Open an instance of me for editing with the given initial message text."	| model messageTextView topView |	Smalltalk isMorphic ifTrue: [		^self openMorphicMailSenderOn: aStringOrText ].	model _ StringHolder new contents: aStringOrText.	messageTextView _ PluggableTextView on: model 		text: #contents		accept: nil		readSelection: #contentsSelection		menu: #codePaneMenu:shifted:.	messageTextView		window: (0@0 extent: 100@90);		borderWidth: 1.	topView _ StandardSystemView new.	topView		model: model;		label: 'Mister Postman';		minimumSize: 300@200;		addSubView: messageTextView.	self addMVCMailSenderButtons: topView textView: messageTextView.	topView controller open.! !!Celeste class methodsFor: 'sending' stamp: 'ls 9/10/1998 23:38'!openMorphicMailSenderOn: aStringOrText	"Open an instance of me for editing with the given initial message text."	| model messageTextView topView sendButton |		model _ StringHolder new contents: aStringOrText.	topView _ SystemWindow labelled: 'Mister Postman'.	topView	model: model.	messageTextView _ PluggableTextMorph on: model 		text: #contents		accept: #acceptContents:		readSelection: nil		menu: #codePaneMenu:shifted:.	sendButton _ SimpleButtonMorph new.	sendButton label: 'Send'.	sendButton target: [		messageTextView accept.		Celeste postMessage: messageTextView model contents ].	sendButton actionSelector: #value.	topView addMorph: messageTextView frame: (0@0.2 extent: 1@0.8).	topView addMorph: sendButton  frame: (0@0 extent: 1@0.2).	topView openInWorld! !!Celeste class methodsFor: 'sending' stamp: 'ls 9/10/1998 23:41'!postMessage: msgString	"Send the message on its merry way..."	| queueDB |	queueDB _ MailDB openOn: 'QUEUE'.	queueDB addNewMessage: (MailMessage from: msgString) inCategory: '.tosend.'.	queueDB saveDB.! !!FileDirectory class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 00:59'!forFileName: aString	| path |	path _ self dirPathFor: aString.	path isEmpty ifTrue: [^ self default].	^ self on: path! !!HandMorph methodsFor: 'meta menu' stamp: 'ls 9/8/1998 04:58'!buildWorldMenu	"Build the meta menu for the world."	| menu subMenu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'go back' target: owner action: #goBack.	menu add: 'jump to...'		subMenu: (Project buildJumpToMenu: (MenuMorph new defaultTarget: Project)).	menu addLine.	menu add: 'paste morph' action: #pasteMorph.	menu add: 'new morph...' action: #newMorph.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'workspace' action: #openWorkspace.	subMenu add: 'browser' action: #openBrowser.	subMenu add: 'transcript' action: #openTranscript.	subMenu add: 'file list' action: #openFileList.	subMenu add: 'parts bin' target: self presenter action: #launchMyPartsBin.	subMenu addLine.	subMenu add: 'email reader' action: #openEmail.	subMenu add: 'web browser' action: #openWebBrowser.	subMenu add: 'IRC' action: #openIRC.	subMenu addLine.	subMenu add: 'project (mvc)' action: #openMVCProject.	subMenu add: 'project (morphic)' action: #openMorphicProject.	subMenu add: 'project (construction)' action: #openConstructionProject.	subMenu add: 'project link...' action: #projectThumbnail.	subMenu addLine.	subMenu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	subMenu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	subMenu add: 'recent submisisons' action: #openRecentChanges.	subMenu add: 'changed methods' action: #browseChangedMessages.	subMenu add: 'changes log' action: #openChangesLog.	menu add: 'open new...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'collapse all' action: #collapseAll.	subMenu add: 'expand all' action: #expandAll.	subMenu add: 'find window' action: #findWindow.	menu add: 'window...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'grab drawing from screen' action: #grabDrawingFromScreen.	subMenu add: 'read drawing from file' action: #importImageFromDisk.	subMenu add: 'make new drawing' target: self presenter associatedMorph action: #makeNewDrawingWithin.	menu add: 'graphics...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'add slot to model' action: #newVariable.	subMenu add: 'write init method for model' action: #writeInitMethodForModel.	subMenu add: 'grab model for this world' action: #grabModel.	menu add: 'model...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'restore display' action: #restoreDisplay.	subMenu add: 'set display depth...' action: #setDisplayDepth.	subMenu add: 'change background color' action: #changeBackgroundColor.	subMenu add: 'use texture background' target: self world action: #setStandardTexture.	subMenu add: 'unlock contents' action: #unlockWorldContents.	subMenu add: 'unhide hidden objects' action: #showHiders.	subMenu add: 'round up stray objects' action: #roundUpStrayObjects.	gridOn		ifTrue: [subMenu add: 'turn gridding off' action: #setGridding]		ifFalse: [subMenu add: 'turn gridding on' action: #setGridding].	menu add: 'viewing...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'update code from server' action: #updateFromServer.	subMenu addLine.	subMenu add: 'local host address' action: #reportLocalAddress.	subMenu add: 'connect remote user' action: #connectRemoteUser.	subMenu add: 'disconnect remote user' action: #disconnectRemoteUser.	subMenu add: 'disconnect all remote users' action: #disconnectAllRemoteUsers.	menu add: 'remote...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'read drawing from file' action: #importImageFromDisk.	subMenu add: 'save world in file' action: #saveWorldInFile.	subMenu add: 'read morph(s) from file' action: #readMorphFile.	menu add: 'file...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self world.	subMenu add: 'detachable scripting space' target: self action: #detachableScriptingSpace.	subMenu add: 'default parts bin' target: self presenter action: #createStandardPartsBin.	subMenu add: 'control panel' target: self presenter action: #createControlPanel.	subMenu add: 'add stop, step, and go buttons' target: self world presenter action: #addStopStepGoButtons.	menu add: 'scripting...' subMenu: subMenu.	menu add: 'do...' target: Utilities action: #offerCommonRequests.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'inspect world' action: #inspectWorld.	subMenu add: 'inspect model' action: #inspectWorldModel.	subMenu add: 'clear palette area' action: #clearPaletteArea.	subMenu add: 'flush viewer cache' action: #flushViewerCache.	subMenu add: 'full screen' action: #fullScreen.	subMenu add: 'start MessageTally' action: #startMessageTally.	subMenu add: 'call #tempCommand' action: #callTempCommand.	subMenu add: 'show space left' action: #showSpaceLeft.	subMenu add: 'vm statistics' action: #vmStatistics.	menu add: 'debug...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save' action: #saveSession.	subMenu add: 'save as...' action: #saveAs.	subMenu add: 'save and quit' action: #saveAndQuit.	subMenu add: 'quit...' action: #quitSession.	menu add: 'save / quit...' subMenu: subMenu.	^ menu! !!HandMorph methodsFor: 'meta menu' stamp: 'ls 9/8/1998 04:57'!openEmail	"open an email interface"	Celeste openOn: 'EMAIL'! !!IndexFileEntry methodsFor: 'printing' stamp: 'ls 9/10/1998 21:15'!fromStringLimit: limit	"Answer a cleaned up 'from' field for the table of contents."	| editedFrom s ch i |	editedFrom _ WriteStream on: (String new: limit + 1).	s _ ReadStream on: from.	s skipSeparators.	('"<' includes: s peek) ifTrue: [s next].	((i _ from indexOf: $() > 0) ifTrue: [s position: i].	[s atEnd] whileFalse: [		ch _ s next.		(('@<>)$"' includes: ch) or: [editedFrom position >= limit])			ifTrue: [^editedFrom contents]			ifFalse: [editedFrom nextPut: ch]].	^editedFrom contents! !!MailAddressParser commentStamp: '<historical>' prior: 0!Parse mail addresses.  The basic syntax is:	addressList := MailAddressParser addressesIn: aStringThis currently only returns the bare addresses, but it could also return a list of the address "source codes".  For example, if you give it "Joe <joe@foo>, <jane>", it will currently return a list ('joe@foo' 'jane').  It would be nice to also get a list ('Joe <joe@foo>'  '<jane>').!!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:31'!addToAddress	"add the last token to the address.  removes the token from the collection"	curAddrTokens addFirst: (tokens removeLast)! !!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:30'!finishAddress	"we've finished one address.  Bundle it up and add it to the list of addresses"	| address |	address _ String streamContents: [ :str |		curAddrTokens do: [ :tok | str nextPutAll: tok text ] ].	addresses addFirst: address.	curAddrTokens _ nil.! !!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:30'!startNewAddress	"set up data structures to begin a new address"	(curAddrTokens ~~ nil) ifTrue: [		self error: 'starting new address before finishing the last one!!' ].	curAddrTokens _ OrderedCollection new.	! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:08'!grabAddressWithRoute	"grad an address of the form 'Descriptive Text <real.address@c.d.e>"		self startNewAddress.	tokens removeLast.	"remove the >"	"grab until we see a $<"	[ 		tokens isEmpty ifTrue: [			self error: '<> are not matched' ].		tokens last type = $<	] whileFalse: [ self addToAddress ].	tokens removeLast.  "remove the <"	self removePhrase.	self finishAddress! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:25'!grabAddresses	"grab all the addresses in the string"	| token |	"grab one address or address group each time through this loop"	[ 		"remove commas"		[			tokens isEmpty not and: [ tokens last type = $, ]		] whileTrue: [ tokens removeLast ].		"check whether any tokens are left"		tokens isEmpty 	] whileFalse: [		token _ tokens last.		"delegate, depending on what form the address is in"		"the from can be determined from the last token"		token type = $> ifTrue: [			self grabAddressWithRoute ]		ifFalse: [ 			(#(Atom DomainLiteral QuotedString) includes: token type)  ifTrue: [				self grabBasicAddress ]		ifFalse: [			token type = $; ifTrue: [				self grabGroupAddress ]		ifFalse: [			^self error: 'un-recognized address format' ] ] ]	].	^addresses! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:32'!grabBasicAddress	"grad an address of the form a.b@c.d.e"		self startNewAddress.	"grab either the domain if specified, or the domain if not"	self addToAddress.		[ tokens last type = $. ] whileTrue: [		"add name-dot pairs of tokens"		self addToAddress.		(#(Atom QuotedString) includes: tokens last type) ifFalse: [			self error: 'bad token in address: ', tokens last text ].		self addToAddress ].	(tokens isEmpty or: [ tokens last type ~= $@]) ifTrue: [		"no domain specified"		self finishAddress ]	ifFalse: [		"that was the domain.  check that no QuotedString's slipped in"		curAddrTokens do: [ :tok |			tok type = #QuotedString ifTrue: [				self error: 'quote marks are not allowed within a domain name (',					tok text, ')'. ] ].		"add the @ sign"		self addToAddress.		"add the local part"		(#(Atom QuotedString) includes: tokens last type) ifFalse: [			self error: 'invalid local part for address: ', tokens last text ].		self addToAddress.		"add word-dot pairs if there are any"		[ tokens isEmpty not and: [ tokens last type = $. ] ] whileTrue: [			self addToAddress.			(tokens isEmpty not 			  and: [ #(Atom QuotedString) includes: tokens last type ]) 			  ifTrue: [ self addToAddress ] ].		self finishAddress ].! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:07'!grabGroupAddress	"grab an address of the form 'phrase : address, address, ..., address;'"	"I'm not 100% sure what this format means, so I'm just returningthe list of addresses between the : and ;   -ls  (if this sounds right to someone, feel free to remove this comment :)"	"remove the $; "	tokens removeLast.	"grab one address each time through this loop"	[ 		"remove commas"		[			tokens isEmpty not and: [ tokens last type = $, ]		] whileTrue: [ tokens removeLast ].		tokens isEmpty ifTrue: [			"no matching :"			^self error: 'stray ; in address list'. ].		tokens last type = $:	] whileFalse: [		"delegate to either grabAddressWithRoute, or grabBasicAddress.  nested groups are not allowed"		tokens last type = $> ifTrue: [			self grabAddressWithRoute ]		ifFalse: [ 			(#(Atom DomainLiteral QuotedString) includes: tokens last type)  ifTrue: [				self grabBasicAddress ]		ifFalse: [			^self error: 'un-recognized address format' ] ]	].	tokens removeLast.   "remove the :"	self removePhrase.! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:08'!removePhrase	"skip most characters to the left of this"	[		tokens isEmpty not and: [			#(Atom QuotedString $. $@) includes: (tokens last type) ]	] whileTrue: [ tokens removeLast ].! !!MailAddressParser methodsFor: 'private-initialization' stamp: 'ls 9/13/1998 01:25'!initialize: tokenList	tokens _ tokenList asOrderedCollection copy.	addresses _ OrderedCollection new.! !!MailAddressParser class methodsFor: 'examples' stamp: 'ls 9/13/1998 02:08'!example	"test out several correct formats"	"MailAddressParser example"	^self addressesIn: 'joe@lama.com, joe2@lama.com joe3@lama.com joe4 , Not an Address <joe5@address>, joe.(annoying (nested) comment)literal@[1.2.3.4], "an annoying" group : joe1@groupie, joe2@groupie, "Joey" joe3@groupy, "joe6"."joe8"@group.com;,  Lex''s email account <lex>'! !!MailAddressParser class methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:34'!addressesIn: aString	"return a collection of the bare addresses listed in aString"	| tokens |	tokens _ MailAddressTokenizer tokensIn: aString.	^(self new initialize: tokens) grabAddresses! !!MailAddressToken commentStamp: '<historical>' prior: 0!a single token from an RFC822 mail address.  Used internally in MailAddressParser!!MailAddressToken methodsFor: 'access' stamp: 'ls 9/12/1998 20:42'!text	^text! !!MailAddressToken methodsFor: 'access' stamp: 'ls 9/12/1998 20:42'!type	^type! !!MailAddressToken methodsFor: 'private' stamp: 'ls 9/12/1998 20:24'!type: type0  text: text0	type _ type0.	text _ text0.! !!MailAddressToken methodsFor: 'printing' stamp: 'ls 9/12/1998 20:40'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self type asString.	aStream nextPut: $|.	aStream nextPutAll: self text.	aStream nextPut: $].! !!MailAddressToken class methodsFor: 'instance creation' stamp: 'ls 9/12/1998 20:31'!type: type  text: text	^self new type: type text: text! !!MailAddressTokenizer commentStamp: '<historical>' prior: 0!Divides an address into tokens, as specified in RFC 822.  Used by MailAddressParser.!!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:51'!atEndOfChars	^pos > text size! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:44'!nextAtom	| start end |	start _ pos.	pos _ text indexOfAnyOf: CSNonAtom startingAt: start ifAbsent: [ text size + 1].	end _ pos - 1.	^MailAddressToken		type: #Atom		text: (text copyFrom: start to: end)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:52'!nextChar	self atEndOfChars ifTrue: [ ^nil ].	pos _ pos + 1.	^text at: (pos-1)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:39'!nextDomainLiteral	| start end |	start _ pos.	end _ text indexOf: $] startingAt: start ifAbsent: [ 0 ].	end = 0 ifTrue: [		"not specified"		self error: 'saw [ without a matching ]' ].	pos _ end+1.	^MailAddressToken		type: #DomainLiteral		text: (text copyFrom: start to: end)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:51'!nextQuotedString	| res c |	res _ WriteStream on: String new.	res nextPut: self nextChar.   "record the starting quote"	[ self atEndOfChars ] whileFalse: [		c _ self nextChar.		c = $\ ifTrue: [			res nextPut: c.			res nextPut: self nextChar ]		ifFalse: [			c = $" ifTrue: [				res nextPut: c.				^MailAddressToken type: #QuotedString  text: res contents ]			ifFalse: [				res nextPut: c ] ] ].	"hmm, never saw the final quote mark"	^MailAddressToken type: #QuotedString  text: (res contents, '"')! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:44'!nextSpecial	| c |	c _ self nextChar.	^MailAddressToken type: c  text: c asString.! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:49'!nextToken	| c |	self skipSeparatorsAndComments.	c _ self peekChar.	c ifNil: [ ^nil ].	c = $" ifTrue: [ ^self nextQuotedString ].	c = $[ ifTrue: [ ^self nextDomainLiteral ].	(CSSpecials includes: c) ifTrue: [ ^self nextSpecial ].	^self nextAtom! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:15'!peekChar	^text at: pos ifAbsent: [ nil ]! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 02:02'!skipComment	| nestLevel paren |	pos _ pos + 1.	nestLevel _ 1.	[ nestLevel > 0 ] whileTrue: [		pos _ text indexOfAnyOf: CSParens startingAt: pos  ifAbsent: [ 0 ].		pos = 0 ifTrue: [ 			self error: 'unterminated comment.  ie, more (''s than )''s' ].		paren _ self nextChar.		paren = $( ifTrue: [ nestLevel _ nestLevel + 1 ] ifFalse: [ nestLevel _ nestLevel - 1 ]. ]! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:14'!skipSeparators	pos _ text indexOfAnyOf: CSNonSeparators  startingAt: pos  ifAbsent: [ text size + 1 ].! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:49'!skipSeparatorsAndComments	[	self skipSeparators.		self peekChar = $(	] whileTrue: [ self skipComment ]! !!MailAddressTokenizer methodsFor: 'initialization' stamp: 'ls 9/12/1998 20:13'!initialize: aString	text _ aString.	pos _ 1.! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:53'!atEnd	^self peek == nil! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:51'!next	| ans |	cachedToken ifNil: [ ^self nextToken ].	ans _ cachedToken.	cachedToken _ nil.	^ans! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:53'!peek	cachedToken ifNil: [ cachedToken _ self nextToken. ].		^cachedToken	! !!MailAddressTokenizer class methodsFor: 'instance creation' stamp: 'ls 9/12/1998 20:54'!forString: aString	^super basicNew initialize: aString! !!MailAddressTokenizer class methodsFor: 'instance creation' stamp: 'ls 9/13/1998 01:34'!tokensIn: aString	"return a collection of the tokens in aString"	^(self forString: aString) upToEnd! !!MailAddressTokenizer class methodsFor: 'class initialization' stamp: 'ls 9/13/1998 02:02'!initialize	"MailAddressTokenizer initialize"	CSNonSeparators _ CharacterSet separators complement.	CSSpecials _ CharacterSet empty.	CSSpecials addAll: '()<>@,;:\".[]'.	CSNonAtom _ CharacterSet separators.	CSNonAtom addAll: CSSpecials.	0 to: 31 do: [ :c |		CSNonAtom add: (Character value: c) ].	CSNonAtom add: (Character value: 127).	CSParens _ CharacterSet empty.	CSParens addAll: '()'.! !!MailDB reorganize!('initialize-release' close openOn: release)('open-create-save' createDB dbStatus openDB recoverDB rootFilename saveDB)('fetch-merge-compact' POPMailFrom:userName:password:doFormatting:deleteInbox:informingUser: appendMessages:messageFile:indexFile: cleanUpCategories compact copyUndeletedTo:indexFile: fetchMailFrom:doFormatting:deleteInbox: fetchNewsFrom:doFormatting:deleteInbox: fileDuplicatesIn: findDuplicates mergeMessages:from: nextUnusedID)('categories' addCategory: addNewMessage:inCategory: allCategories categoriesThatInclude: file:inCategory: fileAll:inCategory: messagesIn: remove:fromCategory: removeAll:fromCategory: removeCategory: removeFromAllCategories: renameCategory:to:)('messages' delete: deleteAll: getMessage: getTOCentry: getTOCstring: getText: newText:for:)('composing')('printing' printOn:)('private' do:andInform: showProgress:from:to:message:during:)!!MailDB methodsFor: 'fetch-merge-compact' stamp: 'ls 9/14/1998 06:38'!POPMailFrom: server  userName: userName password: passworddoFormatting: doFormatting deleteInbox: deleteInbox informingUser: informUser	"Download mail via POP and append to this mail database. Answer the number of messages fetched."	| nextID msg location connection numMessages msgText displayMessage  |	"is there any mail?"		"connect to the POP server"	connection _ POPSocket createIfFail: [ ^0 ].	self do: [		connection serverName: server.			connection userName: userName.		connection password: password.		connection addProgressObserver: Transcript.		connection connectToPOP. ] 	andInform: (informUser ifTrue: ['connecting to ', server] ifFalse: [nil]).	connection isConnected ifFalse: [ ^ 0 ].	"download each message"	numMessages _ connection numMessages.	displayMessage _ 'downloading ', numMessages printString, ' messages'.	self showProgress: informUser from: 0 to: numMessages message: displayMessage during: [ :bar |		nextID _ self nextUnusedID.		1 to: numMessages do: [ :messageNum |			bar value: messageNum.			msgText _ connection retrieveMessage: messageNum.			"save the message"			msg _ MailMessage from: msgText.			doFormatting ifTrue: [msg format].			location _ messageFile basicAppend: msg text id: nextID.			indexFile				at: nextID				put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).			categoriesFile file: nextID inCategory: 'new'.			nextID _ nextID + 1.				"delete the message from the server, if desired"			deleteInbox ifTrue: [ connection deleteMessage: messageNum ].		].		messageFile endAppend.		LastID _ nextID.		connection disconnectFromPOP.		"snapshot the database and remove the inbox file"		self saveDB.	].	^numMessages! !!MailDB methodsFor: 'categories' stamp: 'ls 9/12/1998 02:17'!addNewMessage: message inCategory: category	"add the given message to the database, putting it in the given category.	Returns the message id"	|id location |	id _ self nextUnusedID.	location _ messageFile append: message text  id: id.	indexFile		at: id		put: (IndexFileEntry				message: message				location: location				messageFile: messageFile				msgID: id).	categoriesFile file: id inCategory: category.	^id! !!MailDB methodsFor: 'private' stamp: 'ls 9/12/1998 00:26'!do: aBlock  andInform: aString	"evaluate aBlock.  If aString is non-nil, display it to the user while doing the evaluation"	^aString		ifNil: [ aBlock value ]		ifNotNil: [ Utilities informUser: aString during: aBlock ]! !!MailDB methodsFor: 'private' stamp: 'ls 9/12/1998 01:12'!showProgress: showProgress  from: start  to:  end message: message during: aBlock	"evaluate aBlock.  If showProgress is true, then displaya progress meter while evaluating"	showProgress ifFalse: [ ^aBlock value: [ :ignored | ] ].	^message displayProgressAt: Sensor mousePoint from: start to: end during: aBlock! !!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:40'!delete	"Delete this file."	FileDirectory splitName: filename to: [:dirPath :name |		(FileDirectory forFileName: filename) 			deleteFileNamed: name ifAbsent: []].! !!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:35'!rename: newFileName	"Rename this file."	FileDirectory splitName: filename to: [:dirPath :oldFileName |		(FileDirectory forFileName: filename) 			rename: oldFileName toBe: newFileName].	filename _ newFileName.! !!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:00'!save	"Atomically save a representation of this object to its file. The old file is renamed to '<oldname>.bak' before the new file is written. If the write operation fails, the old file may be restored by renaming it. If it succeeds, the .bak file is deleted."	| f dir shortName |	"create the file if it doesn't already exist"	(StandardFileStream isAFileNamed: filename) ifFalse: [		f _ StandardFileStream new open: filename forWrite: true.		f close].	shortName _ FileDirectory localNameFor: filename.	dir _ FileDirectory forFileName: filename.	dir rename: shortName toBe: shortName, '.bak'.	f _ FileStream fileNamed: filename.	self writeOn: f.	f setToEnd; close.	dir deleteFileNamed: (shortName, '.bak') ifAbsent: [].! !!MailMessage methodsFor: 'access' stamp: 'ls 9/13/1998 06:15'!body	"return just the body of the message"	| s |	s _ ReadStream on: self text.	"scan until a blank line is seen"	[ s atEnd not and: [ (s peek = Character cr) not ] ] whileTrue: [		s upTo: Character cr ].	s next. 	"skip the blank line"	"the body is the rest of the text"	^s upToEnd! !!MailMessage methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:27'!fieldsFrom: aStream do: aBlock	"Invoke the given block with each of the header fields from the given stream. The block arguments are the field name and value."	| savedLine line s |	savedLine _ MailDB readStringLineFrom: aStream.	[aStream atEnd] whileFalse: [		line _ savedLine.		(line isEmpty) ifTrue: [^self].  "quit when we hit a blank line"		[savedLine _ MailDB readStringLineFrom: aStream.		 (savedLine size > 0) and: [savedLine first isSeparator]] whileTrue: [			"lines starting with white space are continuation lines"			s _ ReadStream on: savedLine.			s skipSeparators; skip: -1.			line _ line, s upToEnd].		self reportField: line withBlanksTrimmed to: aBlock].	"process final header line of a body-less message"	(savedLine isEmpty) ifFalse: [self reportField: savedLine withBlanksTrimmed to: aBlock].! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'ls 9/14/1998 22:46'!nextString	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."	| aString length |	"read the length in binary mode"	self binary.	length _ self next.		"first byte."	length >= 192 ifTrue: [length _ length - 192.		1 to: 3 do: [:ii | length _ length * 256 + self next]].	aString _ String new: length.	"read the characters in ASCII mode"	self ascii.	self nextInto: aString.	^aString! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upTo: anObject	"fast version using indexOf:"	| start end |	start _ position+1.	end _ collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		end = 0 ifTrue: [ ^self upToEnd ].	"skip to the end and return the data passed over"	position _ end.	^collection copyFrom: start to: (end-1)! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upToEnd	| start |	start _ position+1.	position _ collection size.	^collection copyFrom: start to: position! !!String methodsFor: 'converting' stamp: 'ls 9/10/1998 08:48'!capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap _ self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !Celeste removeSelector: #notify:!Celeste removeSelector: #setPOPUsername!Celeste removeSelector: #setPopUsername!Celeste removeSelector: #setPOPServer!Celeste initialize!MailAddressTokenizer initialize!MailDB removeSelector: #hasUsername:!MailDB removeSelector: #replyTextFor:!MailDB removeSelector: #POPMailFrom:userName:password:doFormatting:deleteInbox:!MailDB removeSelector: #do:showingProgress:from:to:message:!MailDB removeSelector: #composeText!MailDB removeSelector: #forwardTextFor:!