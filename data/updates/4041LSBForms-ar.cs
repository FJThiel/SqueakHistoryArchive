'From Squeak3.1alpha of 28 February 2001 [latest update: #4037] on 17 May 2001 at 3:51:51 pm'!"Change Set:		LSBForms-arDate:			17 May 2001Author:			Andreas RaabDisplayMake forms capable of dealing with little endian pixels. Whenever we ask a form about its depth we will return the 'absolute' depth but internally we may use negative depths to indicate little endian pixels."!!Form methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:45'!depth	^ depth < 0 ifTrue:[0-depth] ifFalse:[depth]! !!Form methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:50'!nativeDepth	"Return the 'native' depth of the receiver, e.g., including the endianess"	^depth! !!Form methodsFor: 'displaying' stamp: 'ar 5/17/2001 15:42'!colormapIfNeededForDepth: destDepth	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."	self depth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"	^ Color colorMapIfNeededFrom: self depth to: destDepth! !!Form methodsFor: 'displaying' stamp: 'ar 5/17/2001 15:40'!displayResourceFormOn: aForm	"a special display method for blowing up resource thumbnails"	| engine tx cmap blitter |	self extent = aForm extent ifTrue:[^self displayOn: aForm].	Smalltalk at: #B3DRenderEngine ifPresentAndInMemory:		[:engineClass | engine _ engineClass defaultForPlatformOn: aForm].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aForm boundingBox;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	tx _ self asTexture.	(blitter _ BitBlt current toForm: tx)		sourceForm: self; destRect: aForm boundingBox;		sourceOrigin: 0@0;		combinationRule: Form paint.	"map transparency to current World background color"	(World color respondsTo: #pixelWordForDepth:) ifTrue: [		cmap _ Bitmap new: (self depth <= 8 ifTrue: [1 << self depth] ifFalse: [4096]).		cmap at: 1 put: (tx pixelWordFor: World color).		blitter colorMap: cmap.	].	blitter copyBits.	engine viewport: aForm boundingBox.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: tx.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.	"the above, using bilinear interpolation doesn't leave transparent pixel values intact"	(WarpBlt current toForm: aForm)		sourceForm: self destRect: aForm boundingBox;		combinationRule: Form and;		colorMap: (Color maskingMap: self depth);		warpBits.! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:42'!colorAt: aPoint	"Return the color in the pixel at the given point.  "	^ Color 		colorFromPixelValue: (self pixelValueAt: aPoint)		depth: self depth! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:38'!fillFromXYColorBlock: colorBlock	"General Gradient Fill.	Supply relative x and y in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| poker yRel xRel |	poker _ BitBlt current bitPokerToForm: self.	0 to: height-1 do:		[:y | yRel _ y asFloat / (height-1) asFloat.		0 to: width-1 do:			[:x |  xRel _ x asFloat / (width-1) asFloat.			poker pixelAt: x@y				put: ((colorBlock value: xRel value: yRel) pixelWordForDepth: self depth)]]" | d |((Form extent: 100@20 depth: Display depth)	fillFromXYColorBlock:	[:x :y | d _ 1.0 - (x - 0.5) abs - (y - 0.5) abs.	Color r: d g: 0 b: 1.0-d]) display"! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:38'!findShapeAroundSeedBlock: seedBlock	"Build a shape that is black in any region marked by seedBlock. 	SeedBlock will be supplied a form, in which to blacken various	pixels as 'seeds'.  Then the seeds are smeared until 	there is no change in the smear when it fills the region, ie,	when smearing hits a black border and thus goes no further."	| smearForm previousSmear all count smearPort |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	all _ self boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt current toForm: smearForm.	seedBlock value: smearForm.		"Blacken seeds to be smeared"	smearPort copyForm: self to: 0@0 rule: Form erase.  "Clear any in black"	previousSmear _ smearForm deepCopy.	count _ 1.	[count = 10 and:   "check for no change every 10 smears"		[count _ 1.		previousSmear copy: all from: 0@0 in: smearForm rule: Form reverse.		previousSmear isAllWhite]]		whileFalse: 			[smearPort copyForm: smearForm to: 1@0 rule: Form under.			smearPort copyForm: smearForm to: -1@0 rule: Form under.			"After horiz smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			smearPort copyForm: smearForm to: 0@1 rule: Form under.			smearPort copyForm: smearForm to: 0@-1 rule: Form under.			"After vert smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			count _ count+1.			count = 9 ifTrue: "Save penultimate smear for comparison"				[previousSmear copy: all from: 0@0 in: smearForm rule: Form over]].	"Now paint the filled region in me with aHalftone"	^ smearForm! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:39'!isTransparentAt: aPoint 	"Return true if the receiver is transparent at the given point."	self depth = 1 ifTrue: [^ false].  "no transparency at depth 1"	^ (self pixelValueAt: aPoint) = (self pixelValueFor: Color transparent)! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:43'!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	self depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (self depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ self depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: self depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.		"bwForm _ self makeBWForm: interiorColor."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	((BitBlt current destForm: self sourceForm: bwForm 		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits.	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:38'!shapeFill: aColor seedBlock: seedBlock	self depth > 1 ifTrue: [self error: 'This call only meaningful for B/W forms'].	(self findShapeAroundSeedBlock: seedBlock)		displayOn: self at: 0@0 clippingBox: self boundingBox		rule: Form under fillColor: aColor ! !!Form methodsFor: 'bordering' stamp: 'ar 5/17/2001 15:42'!borderFormOfWidth: borderWidth sharpCorners: sharpen	"Smear this form around and then subtract the original to produce	an outline.  If sharpen is true, then cause right angles to be outlined	by right angles (takes an additional diagonal smears ANDed with both	horizontal and vertical smears)."	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	bigForm _ self deepCopy.	all _ bigForm boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt current toForm: smearForm.	sharpen ifTrue:		[cornerForm _ Form extent: self extent.		cornerPort _ BitBlt current toForm: cornerForm].	nbrs _ (0@0) fourNeighbors.	1 to: borderWidth do:		[:i |  "Iterate to get several layers of 'skin'"		nbrs do:			[:d |  "Smear the self in 4 directions to grow each layer of skin"			smearPort copyForm: bigForm to: d rule: Form under].		sharpen ifTrue:			["Special treatment to smear sharp corners"			nbrs with: ((2 to: 5) collect: [:i2 | nbrs atWrap: i2]) do:				[:d1 :d2 |				"Copy corner points diagonally"				cornerPort copyForm: bigForm to: d1+d2 rule: Form over.				"But only preserve if there were dots on either side"				cornerPort copyForm: bigForm to: d1+d1+d2 rule: Form and.				cornerPort copyForm: bigForm to: d1+d2+d2 rule: Form and.				smearPort copyForm: cornerForm to: 0@0 rule: Form under].			].		bigForm copy: all from: 0@0 in: smearForm rule: Form over.		].	"Now erase the original shape to obtain the outline"	bigForm copy: all from: 0@0 in: self rule: Form erase.	^ bigForm! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/17/2001 15:40'!dominantColor	| tally max maxi |	self depth > 16 ifTrue:		[^(self asFormOfDepth: 16) dominantColor].	tally _ self tallyPixelValues.	max _ maxi _ 0.	tally withIndexDo: [:n :i | n > max ifTrue: [max _ n. maxi _ i]].	^ Color colorFromPixelValue: maxi - 1 depth: self depth! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/17/2001 15:40'!pixelCompare: aRect with: otherForm at: otherLoc	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom.  Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord _ 32//self depth.	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:		["If word-aligned, use on-the-fly difference"		^ (BitBlt current toForm: self) copy: aRect from: otherLoc in: otherForm				fillColor: nil rule: 32].	"Otherwise, combine in a word-sized form and then compute difference"	temp _ self copy: aRect.	temp copy: aRect from: otherLoc in: otherForm rule: 21.	^ (BitBlt current toForm: temp) copy: aRect from: otherLoc in: nil				fillColor: (Bitmap with: 0) rule: 32"  Dumb example prints zero only when you move over the original rectangle... | f diff | f _ Form fromUser.[Sensor anyButtonPressed] whileFalse:	[diff _ f pixelCompare: f boundingBox		with: Display at: Sensor cursorPoint.	diff printString , '        ' displayAt: 0@0]"! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/17/2001 15:42'!primCountBits	"Count the non-zero pixels of this form."	self depth > 8 ifTrue:		[^(self asFormOfDepth: 8) primCountBits].	^ (BitBlt current toForm: self)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: width@height);		combinationRule: 32;		copyBits! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/17/2001 15:37'!rectangleEnclosingPixelsNotOfColor: aColor	"Answer the smallest rectangle enclosing all the pixels of me that are different from the given color. Useful for extracting a foreground graphic from its background."	| cm slice copyBlt countBlt top bottom newH left right |	"map the specified color to 1 and all others to 0"	cm _ Bitmap new: (1 bitShift: (self depth min: 15)).	cm primFill: 1.	cm at: (aColor indexInMap: cm) put: 0.	"build a 1-pixel high horizontal slice and BitBlts for counting pixels of interest"	slice _ Form extent: width@1 depth: 1.	copyBlt _ (BitBlt current toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: 1;		colorMap: cm.	countBlt _ (BitBlt current toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from top and bottom"	top _ (0 to: height)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0]		ifNone: [^ 0@0 extent: 0@0].	bottom _ (height - 1 to: top by: -1)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0].	"build a 1-pixel wide vertical slice and BitBlts for counting pixels of interest"	newH _ bottom - top + 1.	slice _ Form extent: 1@newH depth: 1.	copyBlt _ (BitBlt current toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: 1 height: newH;		colorMap: cm.	countBlt _ (BitBlt current toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from left and right"	left _ (0 to: width)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	right _ (width - 1 to: left by: -1)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	^ left@top corner: (right + 1)@(bottom + 1)! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/17/2001 15:40'!replaceColor: oldColor withColor: newColor	"Replace one color with another everywhere is this form"	| cm newInd target ff |	self depth = 32		ifTrue: [cm _ (Color  cachedColormapFrom: 16 to: 32) copy]		ifFalse: [cm _ Bitmap new: (1 bitShift: (self depth min: 15)).				1 to: cm size do: [:i | cm at: i put: i - 1]].	newInd _ newColor pixelValueForDepth: self depth.	cm at: (oldColor pixelValueForDepth: (self depth min: 16))+1 put: newInd.	target _ newColor isTransparent 		ifTrue: [ff _ Form extent: self extent depth: depth.			ff fillWithColor: newColor.  ff]		ifFalse: [self].	(BitBlt current toForm: target)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form paint;		destX: 0 destY: 0 width: width height: height;		colorMap: cm;		copyBits.	newColor = Color transparent 		ifTrue: [target displayOn: self].! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 5/17/2001 15:38'!readFrom: aBinaryStream	"Reads the receiver from the given binary stream with the format:		depth, extent, offset, bits."	| offsetX offsetY |	depth _ aBinaryStream next.	(self depth isPowerOfTwo and: [self depth between: 1 and: 32])		ifFalse: [self error: 'invalid depth; bad Form file?'].	width _ aBinaryStream nextWord.	height _ aBinaryStream nextWord.	offsetX  _ aBinaryStream nextWord.	offsetY _ aBinaryStream nextWord.	offsetX > 32767 ifTrue: [offsetX _ offsetX - 65536].	offsetY > 32767 ifTrue: [offsetY _ offsetY - 65536].	bits _ Bitmap newFromStream: aBinaryStream.	bits size = self bitsSize ifFalse: [self error: 'wrong bitmap size; bad Form file?'].	^ self! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 5/17/2001 15:37'!writeBMPfileNamed: fName  "Display writeBMPfileNamed: 'display'"	| fileName bhSize biSize biClrUsed f biSizeImage bfOffBits rowBytes rgb data colorValues d |	d _ self depth.	d = 16 ifTrue:[^(self asFormOfDepth: 32) writeBMPfileNamed: fName].	self unhibernate.	(#(1 4 8 32) includes: d) ifFalse: [self halt  "depth must be one of these"].	((fileName _ fName) asUppercase endsWith: '.BMP')		ifFalse: [fileName _ fName , '.BMP'].	bhSize _ 14.  "# bytes in file header"	biSize _ 40.  "info header size in bytes"	biClrUsed _ d = 32 ifTrue: [0] ifFalse:[1 << d].  "No. color table entries"	bfOffBits _ biSize + bhSize + (4*biClrUsed).	rowBytes _ ((d min: 24) * width + 31 // 32) * 4.	biSizeImage _ height * rowBytes. 	f _ (FileStream newFileNamed: fileName) binary.	"Write the file header"	f position: 0.	f nextLittleEndianNumber: 2 put: 19778.  "bfType = BM"	f nextLittleEndianNumber: 4 put: bfOffBits + biSizeImage.  "Entire file size in bytes"	f nextLittleEndianNumber: 4 put: 0.  "bfReserved"	f nextLittleEndianNumber: 4 put: bfOffBits.  "Offset of bitmap data from start of hdr (and file)"	"Write the bitmap info header"	f position: bhSize.	f nextLittleEndianNumber: 4 put: biSize.  "info header size in bytes"	f nextLittleEndianNumber: 4 put: width.  "biWidth"	f nextLittleEndianNumber: 4 put: height.  "biHeight"	f nextLittleEndianNumber: 2 put: 1.  "biPlanes"	f nextLittleEndianNumber: 2 put: (d min: 24).  "biBitCount"	f nextLittleEndianNumber: 4 put: 0.  "biCompression"	f nextLittleEndianNumber: 4 put: biSizeImage.  "size of image section in bytes"	f nextLittleEndianNumber: 4 put: 2800.  "biXPelsPerMeter"	f nextLittleEndianNumber: 4 put: 2800.  "biYPelsPerMeter"	f nextLittleEndianNumber: 4 put: biClrUsed.	f nextLittleEndianNumber: 4 put: 0.  "biClrImportant"	biClrUsed > 0 ifTrue: [		"write color map; this works for ColorForms, too"		colorValues _ self colormapIfNeededForDepth: 32.		1 to: biClrUsed do: [:i |			rgb _ colorValues at: i.			0 to: 24 by: 8 do: [:j | f nextPut: (rgb >> j bitAnd: 16rFF)]]].	'Writing image data' displayProgressAt: Sensor cursorPoint		from: 1 to: height during: [:bar |			1 to: height do:				[:i | bar value: i.				data _ (self copy: (0@(height-i) extent: width@1)) bits.				d = 32				ifTrue: [1 to: data size do: [:j | f nextLittleEndianNumber: 3 put: (data at: j)].						1 to: (data size*3)+3//4*4-(data size*3) do: [:j | f nextPut: 0 "pad to 32-bits"]]				ifFalse: [1 to: data size do: [:j | f nextNumber: 4 put: (data at: j)]]]].	f position = (bfOffBits + biSizeImage) ifFalse: [self halt].	f close.! !!Form methodsFor: 'other' stamp: 'ar 5/17/2001 15:39'!asGrayScale	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)"	| f32 srcForm result map bb grays |	self depth = 32 ifFalse: [		f32 _ Form extent: width@height depth: 32.		self displayOn: f32.		^ f32 asGrayScale].	self unhibernate.	srcForm _ Form extent: (width * 4)@height depth: 8.	srcForm bits: bits.	result _ ColorForm extent: width@height depth: 8.	map _ Bitmap new: 256.	2 to: 256 do: [:i | map at: i put: i - 1].	map at: 1 put: 1.  "map zero pixel values to near-black"	bb _ (BitBlt current toForm: result)		sourceForm: srcForm;		combinationRule: Form over;		colorMap: map.	0 to: width - 1 do: [:dstX |		bb  sourceRect: (((dstX * 4) + 2)@0 extent: 1@height);			destOrigin: dstX@0;			copyBits].	"final BitBlt to zero-out pixels that were truely transparent in the original"	map _ Bitmap new: 512.	map at: 1 put: 16rFF.	(BitBlt current toForm: result)		sourceForm: self;		sourceRect: self boundingBox;		destOrigin: 0@0;		combinationRule: Form erase;		colorMap: map;		copyBits.		grays _ (0 to: 255) collect: [:brightness | Color gray: brightness asFloat / 255.0].	grays at: 1 put: Color transparent.	result colors: grays.	^ result! !!Form methodsFor: 'other' stamp: 'ar 5/17/2001 15:41'!bitsSize	| pixPerWord |	depth == nil ifTrue: [depth _ 1].	pixPerWord _ 32 // self depth.	^ width + pixPerWord - 1 // pixPerWord * height! !!Form methodsFor: 'other' stamp: 'ar 5/17/2001 15:38'!mapColor: oldColor to: newColor	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	map _ (Color cachedColormapFrom: self depth to: self depth) copy.	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: self depth).	(BitBlt current toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!Form methodsFor: 'other' stamp: 'ar 5/17/2001 15:40'!mapColors: oldColorBitsCollection to: newColorBits	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	self depth < 16		ifTrue: [map _ (Color cachedColormapFrom: self depth to: self depth) copy]		ifFalse: [			"use maximum resolution color map"			"source is 16-bit or 32-bit RGB; use colormap with 5 bits per color component"			map _ Color computeRGBColormapFor: self depth bitsPerColor: 5].	oldColorBitsCollection do:[ :oldColor | map at: oldColor put: newColorBits].	(BitBlt current toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!Form methodsFor: 'other' stamp: 'ar 5/17/2001 15:41'!newColorMap 	"Return an uninitialized color map array appropriate to this Form's depth."	^ Bitmap new: (1 bitShift: (self depth min: 15))! !!Form methodsFor: 'transitions' stamp: 'ar 5/17/2001 15:42'!fadeImageCoarse: otherImage at: topLeft	"Display fadeImageCoarse: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	| pix j d |	d _ self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		i=1 ifTrue: [pix _ (1 bitShift: d) - 1.					1 to: 8//d-1 do: [:q | pix _ pix bitOr: (pix bitShift: d*4)]].		i <= 16 ifTrue:		[j _ i-1//4+1.		(0 to: 28 by: 4) do: [:k |			mask bits at: j+k				put: ((mask bits at: j+k) bitOr: (pix bitShift: i-1\\4*d))].		"mask display." true]		ifFalse: [false]]! !!Form methodsFor: 'transitions' stamp: 'ar 5/17/2001 15:41'!fadeImageFine: otherImage at: topLeft	"Display fadeImageFine: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	| pix j ii d |	d _ self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		i=1 ifTrue: [pix _ (1 bitShift: d) - 1.					1 to: 8//d-1 do:						[:q | pix _ pix bitOr: (pix bitShift: d*4)]].		i <= 16 ifTrue:		[ii _ #(0 10 2 8 7 13 5 15 1 11 3 9 6 12 4 14) at: i.		j _ ii//4+1.		(0 to: 28 by: 4) do:			[:k | mask bits at: j+k put:				((mask bits at: j+k) bitOr: (pix bitShift: ii\\4*d))].		true]		ifFalse: [false]]! !!Form methodsFor: 'transitions' stamp: 'ar 5/17/2001 15:39'!fadeImageVert: otherImage at: topLeft	"Display fadeImageVert: (Form fromDisplay: (10@10 extent: 300@300)) reverse at: 10@10"	| d |	d _ self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		mask fill: ((mask width//2//d-i*d)@0 extent: i*2*d@mask height) fillColor: Color black.		i <= (mask width//d)]! !!Form methodsFor: 'postscript generation' stamp: 'ar 5/17/2001 15:36'!bitsPerComponent	^self depth <= 8 ifTrue:[self depth] ifFalse:[8].! !!Form methodsFor: 'postscript generation' stamp: 'ar 5/17/2001 15:39'!decodeArray	^self depth <= 8 ifTrue:['[1 0]'] ifFalse:['[0 1 0 1 0 1 ]'].! !!Form methodsFor: 'postscript generation' stamp: 'ar 5/17/2001 15:43'!numComponents	^self depth <= 8 ifTrue:[1] ifFalse:[3].! !!Form methodsFor: 'testing' stamp: 'ar 5/17/2001 15:46'!isBigEndian	"Return true if the receiver contains big endian pixels, meaning the left-most pixel is stored in the most significant bits of a word."	^depth > 0! !!Form methodsFor: 'testing' stamp: 'ar 5/17/2001 15:47'!isLittleEndian	"Return true if the receiver contains little endian pixels, meaning the left-most pixel is stored in the least significant bits of a word."	^depth < 0! !!ColorForm methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:45'!colors: colorList	"Set my color palette to the given collection."	| colorArray colorCount newColors |	colorList ifNil: [		colors _ cachedDepth _ cachedColormap _ nil.		^ self].	colorArray _ colorList asArray.	colorCount _ colorArray size.	newColors _ Array new: (1 bitShift: self depth).	1 to: newColors size do: [:i |		i <= colorCount			ifTrue: [newColors at: i put: (colorArray at: i)]			ifFalse: [newColors at: i put: Color transparent]].	colors _ newColors.	cachedDepth _ nil.	cachedColormap _ nil.! !!ColorForm methodsFor: 'color manipulation' stamp: 'ar 5/17/2001 15:44'!colormapIfNeededForDepth: destDepth	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."	| newMap |	colors == nil ifTrue: [		"use the standard colormap"		^ Color colorMapIfNeededFrom: self depth to: destDepth].	(destDepth = cachedDepth and:[cachedColormap isColormap not]) 		ifTrue: [^ cachedColormap].	newMap _ Bitmap new: colors size.	1 to: colors size do: [:i |		newMap			at: i			put: ((colors at: i) pixelValueForDepth: destDepth)].	cachedDepth _ destDepth.	^ cachedColormap _ newMap.! !!ColorForm methodsFor: 'copying' stamp: 'ar 5/17/2001 15:44'!blankCopyOf: aRectangle scaledBy: scale        | newForm |        newForm _ self class extent: (aRectangle extent * scale) truncated depth: self depth.        colors ifNotNil: [newForm colors: colors copy].        ^ newForm! !!ColorForm methodsFor: 'private' stamp: 'ar 5/17/2001 15:44'!ensureColorArrayExists	"Return my color palette."	colors ifNil: [		self depth > 8 ifTrue: [^ self error: 'ColorForms only support depths up to 8 bits'].		self colors: (Color indexedColors copyFrom: 1 to: (1 bitShift: self depth))].! !!ColorForm methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:44'!colormapIfNeededFor: destForm	| newMap color pv |	(self hasNonStandardPalette or:[destForm hasNonStandardPalette]) ifFalse:[		^self colormapIfNeededForDepth: destForm depth.	].	colors == nil ifTrue: [		"use the standard colormap"		^ super colormapIfNeededFor: destForm].	(destForm depth = cachedDepth and:[cachedColormap isColormap]) 		ifTrue: [^ cachedColormap].	newMap _ WordArray new: (1 bitShift: self depth).	1 to: colors size do: [:i |		color _ colors at: i.		pv _ destForm pixelValueFor: color.		(pv = 0 and:[color isTransparent not]) ifTrue:[pv _ 1].		newMap at: i put: pv].	cachedDepth _ destForm depth.	^cachedColormap _ ColorMap shifts: nil masks: nil colors: newMap.! !!DisplayScreen methodsFor: 'private' stamp: 'ar 5/17/2001 15:44'!newDepthNoRestore: pixelSize	"Change depths.  Check if there is enough space!!  , di"	| area need |	pixelSize = depth ifTrue: [^ self  "no change"].	pixelSize abs < self depth ifFalse:		["Make sure there is enough space"		area _ Display boundingBox area. "pixels"		Smalltalk isMorphic ifFalse:			[ScheduledControllers scheduledWindowControllers do:				[:aController | "This should be refined..."				aController view cacheBitsAsTwoTone ifFalse:					[area _ area + aController view windowBox area]]].		need _ (area * (pixelSize abs - self depth) // 8)  "new bytes needed"				+ Smalltalk lowSpaceThreshold.		(Smalltalk garbageCollectMost <= need			and: [Smalltalk garbageCollect <= need])			ifTrue: [self error: 'Insufficient free space']].	self setExtent: self extent depth: pixelSize.	Smalltalk isMorphic ifFalse: [ScheduledControllers updateGray].	DisplayScreen startUp! !!DisplayScreen class methodsFor: 'snapshots' stamp: 'ar 5/17/2001 15:50'!startUp  "DisplayScreen startUp"	Display setExtent: self actualScreenSize depth: Display nativeDepth.	Display beDisplay! !