'From Squeak2.7 of 5 January 2000 [latest update: #1762] on 4 February 2000 at 1:40:52 pm'!"Change Set:		MiscFixes-arDate:			4 February 2000Author:			Andreas RaabFixes to different problems.* Make DisplayObject #follow:while:bitsBehind:startingLoc: use deferred display updates* Fixes computations of pixel ramps in gradient fill styles* Fixes an order problem in the execution of flash actions.* Makes FlashPlayers keep their aspect ratio."!!DisplayObject methodsFor: 'displaying-Display' stamp: 'ar 2/3/2000 23:41'!follow: locationBlock while: durationBlock bitsBehind: initialBitsBehind startingLoc: loc   "Move an image around on the Display. Restore the background continuously without causing flashing. The argument, locationBlock, supplies each new location, and the argument, durationBlock, supplies true to continue or false to stop. This variant takes the bitsBehind as an input argument, and returns the final saved saved bits as method value."   | location rect1 save1 save1Blt buffer bufferBlt newLoc rect2 bothRects |   location _ loc.   rect1 _ location extent: self extent.   save1 _ initialBitsBehind.   save1Blt _ BitBlt toForm: save1.   buffer _ Form extent: self extent*2 depth: Display depth.  "Holds overlapping region"   bufferBlt _ BitBlt toForm: buffer.   Display deferUpdates: true.   self displayOn: Display at: location rule: Form paint.   Display deferUpdates: false; forceToScreen: (location extent: self extent).   [durationBlock value] whileTrue: [		newLoc _ locationBlock value.		newLoc ~= location ifTrue: [			rect2 _ newLoc extent: self extent.			bothRects _ rect1 merge: rect2.			(rect1 intersects: rect2)				ifTrue: [  "when overlap, buffer background for both rectangles"					bufferBlt copyFrom: bothRects in: Display to: 0@0.					bufferBlt copyFrom: save1 boundingBox in: save1 to: rect1 origin - bothRects origin.					"now buffer is clean background; get new bits for save1"					save1Blt copy: (0@0 extent: self extent) from: rect2 origin - bothRects origin in: buffer.					self displayOnPort: bufferBlt at: rect2 origin - bothRects origin rule: Form paint.					Display deferUpdates: true.					Display copy: bothRects from: 0@0 in: buffer rule: Form over.					Display deferUpdates: false; forceToScreen: bothRects]				ifFalse: [  "when no overlap, do the simple thing (both rects might be too big)"					Display deferUpdates: true.					Display copy: (location extent: save1 extent) from: 0@0 in: save1 rule: Form over.					save1Blt copyFrom: rect2 in: Display to: 0@0.					self displayOn: Display at: newLoc rule: Form paint.					Display deferUpdates: false; 						forceToScreen: (location extent: save1 extent); 						forceToScreen: (newLoc extent: self extent)].			location _ newLoc.			rect1 _ rect2]].	^ save1 displayOn: Display at: location! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 2/3/2000 17:46'!startPlaying	"Start playing from the current frame"	playing ifTrue:[^self].	loadedFrames = 0 ifTrue:[^nil].	frameNumber >= maxFrames ifTrue:[self frameNumber: 1].	playing _ true.	self playSoundsAt: frameNumber.	self executeActionsAt: frameNumber.	lastStepTime _ Time millisecondClockValue.! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 2/3/2000 17:21'!stepToFrame: frame	"Step to the given frame"	| fullRect postDamage lastVisible resortNeeded |	frame = frameNumber ifTrue:[^self].	frame > loadedFrames ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	lastVisible _ nil.	resortNeeded _ false.	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m stepToFrame: frame.			m visible ifTrue:[				(lastVisible notNil and:[lastVisible depth < m depth])					ifTrue:[resortNeeded _ true].				lastVisible _ m.				(bounds containsRect: m bounds) ifFalse:[bounds _ bounds merge: m bounds].			].		].	].	resortNeeded ifTrue:[submorphs _ submorphs sortBy:[:m1 :m2| m1 depth > m2 depth]].	frameNumber _ frame.	playing ifTrue:[		self playSoundsAt: frame.		self executeActionsAt: frame.	].	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			"fullRect _ damageRecorder fullDamageRect.			fullRect _ (self transform localBoundsToGlobal: fullRect)."			fullRect _ bounds.			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[		damageRecorder _ nil].! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 2/3/2000 17:21'!gotoFrame: frame	"Jump to the given frame"	self stopPlaying.	self frameNumber: frame+1.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 2/3/2000 17:20'!playSoundsAt: frame	(sounds at: frame ifAbsent:[#()]) 		do: [:sound | sound ifNotNil:[self playFlashSound: sound]].! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 2/3/2000 17:23'!boundsChangedFrom: oldBounds to: newBounds	| newWidth newLeft |	newWidth _ localBounds width * newBounds height // localBounds height.	newLeft _ newBounds left + (newBounds width - newWidth // 2).	transform _ MatrixTransform2x3		transformFromLocal: localBounds		toGlobal: (newLeft @ newBounds top extent: newWidth @ newBounds height).! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 2/3/2000 17:20'!stepToFrame: frame	| fullRect postDamage |	frame = frameNumber ifTrue:[^self].	frame > loadedFrames ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	frame = (frameNumber+1) ifTrue:[		self stepToFrameForward: frame.	] ifFalse:[		activeMorphs _ activeMorphs select:[:any| false].		submorphs do:[:m|			(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[				m stepToFrame: frame.				m visible ifTrue:[activeMorphs add: m].			]].	].	frameNumber _ frame.	playing ifTrue:[		self playSoundsAt: frame.		self executeActionsAt: frame.	].	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			fullRect _ damageRecorder fullDamageRect: self localBounds.			fullRect _ (self transform localBoundsToGlobal: fullRect).			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[damageRecorder _ nil].! !!GradientFillStyle methodsFor: 'private' stamp: 'ar 2/3/2000 18:01'!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver"	| bits lastColor lastIndex nextIndex nextColor distance theta color lastValue ramp |	ramp _ colorRamp asSortedCollection:[:a1 :a2| a1 key < a2 key].	bits _ Bitmap new: length.	lastColor _ ramp first value.	lastIndex _ 0.	ramp do:[:assoc|		nextIndex _ (assoc key * length) rounded.		nextColor _ assoc value.		distance _ (nextIndex - lastIndex).		distance = 0 ifTrue:[distance _ 1].		lastIndex+1 to: nextIndex do:[:i|			theta _ (i - lastIndex) asFloat / distance asFloat.			color _ nextColor alphaMixed: theta with: lastColor.			bits at: i put: (color scaledPixelValue32).		].		lastIndex _ nextIndex.		lastColor _ nextColor.	].	lastValue _ lastColor scaledPixelValue32.	lastIndex+1 to: length do:[:i| bits at: i put: lastValue].	^bits! !