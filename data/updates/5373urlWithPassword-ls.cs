'From Squeak3.6beta of ''4 July 2003'' [latest update: #5371] on 22 July 2003 at 2:43:29 pm'!"Change Set:		urlWithPassword-lsDate:			15 June 2003Author:			Lex Spoonremoved testcases (v5, approved)Parse URL's that have a password specified in them.Adds test cases for this situation in the UrlTestCase classe; if there is a package somewhere that has URL tests in it, these should be moved there.Also does some minor refactoring of the relevant code.The current code gives a walkback on encountering such URL's, which is frustrating if you are trying to delete spams within Celeste.Note: this code does not actually *use* the username and password that are specified; it only parses them."!Url subclass: #HierarchicalUrl	instanceVariableNames: 'schemeName authority path query port password username '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!!FtpUrl commentStamp: 'ls 6/15/2003 13:44' prior: 0!a reference to a file which may be downloaded by anonymous ftp .TODO: use the username and password, if specified!!HttpUrl commentStamp: 'ls 6/15/2003 13:44' prior: 0!A URL that can be accessed via the Hypertext Transfer Protocol (HTTP), ie, a standard Web URLrealm = the name of the security realm that has been discovered for this URL.   Look it up in Passwords.Passwords = a Dictionary of (realm -> encoded user&password)TODO: use the username and password, if specified!!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 6/15/2003 13:40'!privateInitializeFromText: aString 	| remainder ind specifiedSchemeName |	remainder := aString.	schemeName ifNil: 			[specifiedSchemeName := Url schemeNameForString: remainder.			specifiedSchemeName ifNotNil: 					[schemeName := specifiedSchemeName.					remainder := remainder copyFrom: schemeName size + 2 to: remainder size].			schemeName ifNil: 					["assume HTTP"					schemeName := 'http']].	"remove leading // if it's there"	(remainder beginsWith: '//') 		ifTrue: [remainder := remainder copyFrom: 3 to: remainder size].	"get the query"	ind := remainder indexOf: $?.	ind > 0 		ifTrue: 			[query := remainder copyFrom: ind + 1 to: remainder size.			remainder := remainder copyFrom: 1 to: ind - 1].	"get the authority"	ind := remainder indexOf: $/.	ind > 0 		ifTrue: 			[ind = 1 				ifTrue: [authority := '']				ifFalse: 					[authority := remainder copyFrom: 1 to: ind - 1.					remainder := remainder copyFrom: ind + 1 to: remainder size]]		ifFalse: 			[authority := remainder.			remainder := ''].	"Extract the port"	(authority includes: $:) 		ifTrue: 			[| lastColonIndex portString |			lastColonIndex := authority findLast: [:c | c = $:].			portString := authority copyFrom: lastColonIndex + 1 to: authority size.			portString isAllDigits 				ifTrue: 					[port := Integer readFromString: portString.					authority := authority copyFrom: 1 to: lastColonIndex - 1]].	"extract the username+password"	(authority includes: $@) 		ifTrue: 			[username := authority copyUpTo: $@.			authority := authority copyFrom: (authority indexOf: $@) + 1						to: authority size.			(username includes: $:) 				ifTrue: 					[password := username copyFrom: (username indexOf: $:) + 1 to: username size.					username := username copyUpTo: $:]].	"get the path"	path := self privateParsePath: remainder relativeTo: #() .! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 6/15/2003 13:40'!privateInitializeFromText: aString relativeTo: aUrl 	| remainder ind basePath |	remainder _ aString.	"set the scheme"	schemeName _ aUrl schemeName.	"a leading // means the authority is specified, meaning it is absolute"	(remainder beginsWith: '//')		ifTrue: [^ self privateInitializeFromText: aString].	"otherwise, use the same authority"	authority _ aUrl authority.	port _ aUrl port.	username _ aUrl username.	password _ aUrl password.	"get the query"	ind _ remainder indexOf: $?.	ind > 0		ifTrue: [query _ remainder copyFrom: ind + 1 to: remainder size.			remainder _ remainder copyFrom: 1 to: ind - 1].	"get the path"	(remainder beginsWith: '/')		ifTrue: [ basePath := #() ]		ifFalse: [ basePath := aUrl path ].	path := self privateParsePath: remainder  relativeTo: basePath.! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 7/21/2003 11:55'!privateParsePath: remainder relativeTo: basePath 	| nextTok s parsedPath |	s := ReadStream on: remainder.	parsedPath := OrderedCollection new.	parsedPath addAll: basePath.	parsedPath isEmpty ifFalse: [ parsedPath removeLast ].		[s peek = $/ ifTrue: [s next].	nextTok := WriteStream on: String new.	[s atEnd or: [s peek = $/]] whileFalse: [nextTok nextPut: s next].	nextTok := nextTok contents unescapePercents.	nextTok = '..' 		ifTrue: [parsedPath size > 0 ifTrue: [parsedPath removeLast]]		ifFalse: [nextTok ~= '.' ifTrue: [parsedPath add: nextTok]].	s atEnd] 			whileFalse.	parsedPath isEmpty ifTrue: [parsedPath add: ''].	^parsedPath! !!HierarchicalUrl methodsFor: 'printing' stamp: 'ls 6/15/2003 13:27'!toText	| ans |	ans _ WriteStream on: String new.	ans nextPutAll: self schemeName.	ans nextPutAll: '://'.	self username ifNotNil: [		ans nextPutAll: self username.		self password ifNotNil: [			ans nextPutAll: ':'.			ans nextPutAll: self password ].		ans nextPutAll: '@' ].	ans nextPutAll: self authority.	port ifNotNil: [ans nextPut: $:; print: port].	path do: [ :pathElem |		ans nextPut: $/.		ans nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		ans nextPut: $?.		ans nextPutAll: self query. ].	self fragment isNil ifFalse: [		ans nextPut: $#.		ans nextPutAll: self fragment encodeForHTTP. ].		^ans contents! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/15/2003 13:13'!password	"http://user:pword@foo.com' asUrl password"	^password! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/15/2003 13:13'!username	"http://user:pword@foo.com' asUrl username"	^username! !Url subclass: #HierarchicalUrl	instanceVariableNames: 'schemeName authority path query port username password '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!