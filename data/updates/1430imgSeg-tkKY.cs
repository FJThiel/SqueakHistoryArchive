'From Squeak 2.5 of August 6, 1999 on 8 September 1999 at 4:36:46 pm'!!Behavior methodsFor: 'enumerating' stamp: 'tk 8/18/1999 17:38'!allSubclassesDoGently: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's subclasses."	self subclassesDoGently: 		[:cl | 		cl isInMemory ifTrue: [			aBlock value: cl.			cl allSubclassesDoGently: aBlock]]! !!Class methodsFor: 'testing' stamp: 'tk 8/12/1999 15:47'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'testing' stamp: 'tk 8/12/1999 15:49'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'accessing class hierarchy' stamp: 'tk 8/18/1999 17:42'!subclassesDoGently: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	subclasses == nil 		ifFalse: [subclasses do: aBlock]! !!ImageSegment commentStamp: 'tk 9/7/1999 13:29' prior: 0!I represent a segment of Squeak address space.  I am created from an array of root objects.  After storing, my segment contains a binary encoding of every object accessible from my roots but not otherwise accessible from anywhere else in the system.  My segment contains outward pointers that are indices into my table of outPointers.To put out a segment that can only be read by this image.  Make PV be a ProjectViewerMorph on a thumbnail of a project (not the current project).World currentHand objectToPaste ifNotNil: [	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString].(ImageSegment new copyFromRootsLocalFileFor: 	(Array with: PV project world presenter with: PV project world))		extract; writeToFile: 'myFile.seg'.To discover why the whole project is not going out (***Destructive Test***).  This breaks lots of backpointers in the target project, and puts up an array of suspicious objects, a list of the classes of the outPointers, and a debugger."Close any transcripts in the target project"World currentHand objectToPaste ifNotNil: [	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString].Smalltalk forgetDoIts.(IS _ ImageSegment new) findRogueRootsImSeg: 	(Array with: PV project world presenter with: PV project world)."Quit without saving""After the destructive analysis, write a file with owner chains"IS findOwnersOutPtrs.To put out a segment that can be read into a different image:(ImageSegment new copyFromRootsForExport: (Array with: Baz with: Baz class))		writeForExport: 'myFile.extSeg'.To read into another image:  Select 'myFile.extSeg' in a FileList, Menu more..., fileIn.  It will install classes automatically.  If you need to see the roots array, it is temporarily stored in (SmartRefStream scannedObject).I may exist in several states...#activeCopyarrayOfRoots segment outPointers are all as created by the copyFromRoots: initialization message.  Nothing else has changed about the Squeak system.#activeEach of the original roots has been transmuted into an ImageSegmentRootStub that refers back to this image segment.  The original objects in the segment will all be garbageCollected.#onFileThe segment has been written out to a file and replaced by a file pointer.  Only the array of outPointers remains in the image.(ImageSegment new copyFromRoots: (Array with: Baz with: Baz class))		writeToFile: 'myFile.extSeg'.#onFileWithSymbolsThe segment has been written out to a file, along with the text of all the symbols in the outPointers array, and replaced by a file pointer.  This reduces the size of the outPointers array, and also allows the system to reclaim any symbols that are not referred to from elsewhere in the image.  The specific format used is that of a literal array as follows:	#(symbol1 symbol2 # symbol3 symbol4 'symbolWithSpaces' # symbol5).In this case, the original outPointers array was 8 long, but the compacted table of outPointers retains only two entries.  These get inserted in place of the #'s in the array of symbols after it is read back in.  Symbols with embedded spaces or other strange characters are written as strings, and converted back to symbols when read back in.  The symbol # is never written out.	NOTE: All IdentitySets or dictionaries must be rehashed when being read back from this format.  The symbols are effectively internal.  (No, not if read back into same image.  If a different image, then use #imported.  -tk)#importedThe segment is on an external file or just read in from one.  The segment and outPointers are meant to be read into a foreign image.   (It is in SmartRefStream format.)  In this form the segment can be read from a URL, and installed.  A copy of the original array of root objects is constructed, with former outPointers bound to existing objects in the host system.  	(Any Class inside the segment MUST be in the arrayOfRoots.  This is so its association can be inserted into Smalltalk.  The class's metaclass must be in roots also.  Methods that are in outPointers because blocks point at them, are found and added to the roots.)	All IdentitySets and dictionaries are rehashed when being read back from exported segments.) #inactiveIn this state, the rootsArray is set, but the segment is invalid.!!ImageSegment methodsFor: 'access' stamp: 'tk 8/18/1999 22:19'!segment	^ segment! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 8/18/1999 16:40'!copyFromRoots: aRootArray 	| segmentWordArray outPointerArray segSize |	aRootArray ifNil: [self errorWrongState].	arrayOfRoots _ aRootArray.	outPointers _ nil.	"If iterative discovery of roots, erase pointers from pervious try"	segSize _ 50000.		["Guess a reasonable segment size"	segmentWordArray _ WordArray new: segSize.	outPointerArray _ Array new: segSize // 20.	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 8/19/1999 15:51'!copyFromRootsForExport: aRootArray 	"Add to roots:  Any methods pointed to from the outside by blocks."	| newRoots |	self copyFromRoots: aRootArray.	"Include compiledMethods that spawned blocks"	(newRoots _ self rootsIncludingBlockMethods) ifNotNil: [		Smalltalk garbageCollect.	"Why is this needed?"		self copyFromRootsForExport: newRoots].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/7/1999 13:33'!copyFromRootsLocalFileFor: rootArray 	| newRoots |	"Add Player classes to the roots."arrayOfRoots _ rootArray.[newRoots _ self rootsIncludingPlayers.  newRoots == nil] whileFalse: [	arrayOfRoots _ newRoots].		"project, world, and all Players"Smalltalk forgetDoIts.  outPointers _ nil.Smalltalk garbageCollect.self copyFromRoots: arrayOfRoots.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 8/19/1999 15:38'!install	"This operation retrieves the segment if necessary from file storage, installs it in memory, and replaces (using become:) all the root stubs with the reconstructed roots of the segment."	| newRoots |	state = #onFile ifTrue: [self readFromFile].	state = #onFileWithSymbols ifTrue: [self readFromFileWithSymbols].	(state = #active) | (state = #imported) ifFalse: [self errorWrongState].	newRoots _ self loadSegmentFrom: segment outPointers: outPointers.	state = #imported 		ifTrue: ["just came in from exported file"			arrayOfRoots _ newRoots]		ifFalse: [			arrayOfRoots elementsForwardIdentityTo: newRoots].	self rehashSets.	"(self confirm: 'Installing segment.  Want a debugger?') ifTrue: [self halt]."	state _ #inactive.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 8/19/1999 15:53'!rootsIncludingBlockMethods	"Return a new roots array with more objects.  (Caller should store into rootArray.) Any CompiledMethods that create blocks will be in outPointers if the block is held outside of this segment.  Put such methods into the roots list.  Then ask for the segment again."| extras myClasses gotIt |extras _ OrderedCollection new.myClasses _ OrderedCollection new.arrayOfRoots do: [:aRoot | aRoot class class == Metaclass ifTrue: [					myClasses add: aRoot]].myClasses isEmpty ifTrue: [^ nil].	"no change"outPointers do: [:anOut | 	anOut class == CompiledMethod ifTrue: [		"specialized version of who"		gotIt _ false.		myClasses detect: [:class |			class selectorsDo: [:sel |				(class compiledMethodAt: sel) == anOut 					ifTrue: [extras add: anOut.  gotIt _ true]].			gotIt] 			ifNone: []		].	anOut _ nil].extras isEmpty ifTrue: [^ nil].	"no change"^ arrayOfRoots, extras! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/3/1999 08:35'!rootsIncludingPlayers	"Return a new roots array with more objects.  (Caller should store into rootArray.) Player (non-systemDefined) gets its class and metaclass put into the Roots array.  Then ask for the segment again.	Temporarily: SystemWindows (MorphicModels) need to be roots because of dependents."| extras havePresenter players |extras _ OrderedCollection new.arrayOfRoots do: [:root | 	(root isKindOf: Presenter) ifTrue: [havePresenter _ root].	(root isKindOf: PasteUpMorph) ifTrue: [			root isWorldMorph ifTrue: [				havePresenter _ root presenter.			"	root submorphs do: [:sub |					(sub isKindOf: MorphicModel) ifTrue: [						(arrayOfRoots includes: sub) ifFalse: [extras add: sub]]]."				]].	(root isKindOf: Project) ifTrue: [havePresenter _ root world presenter]].havePresenter ifNotNil: [havePresenter flushPlayerListCache.	players _ havePresenter allExtantPlayers.	players _ players select: [:ap | (arrayOfRoots includes: ap class) not		& (ap class isSystemDefined not)].	"extras addAll: players.	Why needed?"	extras addAll: (players collect: [:each | each class]).	extras addAll: (players collect: [:each | each class class]).	"outPointers do: [:out | out class == ScriptEditorMorph ifTrue: [			(havePresenter allExtantPlayers includes: out playerScripted) ifTrue: [				extras add: out]].			out _ nil].	Why needed?"	].extras isEmpty ifTrue: [^ nil].	"no change"^ arrayOfRoots, extras! !!ImageSegment methodsFor: 'testing' stamp: 'tk 9/3/1999 14:11'!findInOut: anArray	"Take an array of references to a morph, and try to classify them:  in the segment, in outPointers, or other."String streamContents: [:strm |	anArray withIndexDo: [:obj :ind |		strm cr; nextPutAll: obj printString; space.		]].! !!ImageSegment methodsFor: 'testing' stamp: 'tk 9/3/1999 13:55'!findOwnerMap: morphs	| st |	"Construct a string that has a printout of the owner chain for every morph in the list.  Need it as a string so not hold onto them."st _ ''.morphs do: [:mm |	(st includesSubString: mm printString) ifFalse: [		st _ st, '', mm withAllContainers printString]].Smalltalk at: #Owners put: st.! !!ImageSegment methodsFor: 'testing' stamp: 'tk 9/7/1999 09:48'!findOwnersOutPtrs| ow ff |ow _ Smalltalk at: #Owners ifAbsent: [^ self].ow ifNil: [^ self].outPointers do: [:oo | 	oo isMorph ifTrue: [		ow _ ow copyReplaceAll: oo printString with: oo printString, '[<<<- Pointed at]']].ff _ FileStream fileNamed: 'Owners log'.ff nextPutAll: ow; close.Smalltalk at: #Owners put: ow.ff edit.! !!ImageSegment methodsFor: 'testing' stamp: 'tk 9/8/1999 16:35'!findRogueRootsAllMorphs: rootArray	"This is a tool to track down unwanted pointers into the segment.  If we don't deal with these pointers, the segment turns out much smaller than it should.  These pointers keep a subtree of objects out of the segment.1) assemble all objects should be in seg:  morph tree, presenter, scripts, player classes, metaclasses.  Put in a Set.2) Remove the roots from this list.  Ask for senders of each.  Of the senders, forget the ones that are in the segment already.  Keep others.  The list is now all the 'incorrect' pointers into the segment."| inSeg testRoots scriptEditors pointIn wld xRoots |Smalltalk garbageCollect.inSeg _ IdentitySet new: 200.arrayOfRoots _ rootArray.(testRoots _ self rootsIncludingPlayers) ifNil: [testRoots _ rootArray].testRoots do: [:obj |	(obj isKindOf: Project) ifTrue: [inSeg add: obj.			wld _ obj world.			inSeg add: wld presenter].	(obj isKindOf: Presenter) ifTrue: [inSeg add: obj].	].xRoots _ wld ifNil: [testRoots] ifNotNil: [testRoots, (Array with: wld)].xRoots do: [:obj |	"root is a project"	obj isMorph ifTrue: [		obj allMorphs do: [:mm | inSeg add: mm.			mm player ifNotNil: [inSeg add: mm player]].		obj isWorldMorph ifTrue: [inSeg add: obj presenter]]].inSeg do: [:obj |	(obj isKindOf: Player) ifTrue: [		scriptEditors _ obj class tileScriptNames collect: [:nn | 			obj scriptEditorFor: nn].		scriptEditors do: [:se | inSeg addAll: se allMorphs]].	].testRoots do: [:each | inSeg remove: each ifAbsent: []].	"want them to be pointed at from outside"pointIn _ IdentitySet new: 400.inSeg do: [:ob |	pointIn addAll: (Smalltalk pointersTo: ob except: inSeg)].testRoots do: [:each | pointIn remove: each ifAbsent: []].pointIn remove: inSeg array ifAbsent: [].pointIn remove: pointIn array ifAbsent: [].inSeg do: [:obj |	(obj isKindOf: Morph) ifTrue: [		pointIn remove: (obj "submorphs" instVarAt: 3) ifAbsent: [].		"associations in extension"		pointIn remove: obj extension ifAbsent: [].		obj extension ifNotNil: [obj extension otherProperties ifNotNil: [			obj extension otherProperties associationsDo: [:ass | 				pointIn remove: ass ifAbsent: []]]			"*** and extension actorState"			"*** and ActorState instantiatedUserScriptsDictionary ScriptInstantiations"]].	(obj isKindOf: Player) ifTrue: [obj class scripts values do: [:us | 			pointIn remove: us ifAbsent: []]]]."*** presenter playerlist"self halt: 'Examine local variables pointIn and inSeg'.^ pointIn! !!ImageSegment methodsFor: 'testing' stamp: 'tk 9/8/1999 16:36'!findRogueRootsImSeg: rootArray	"This is a tool to track down unwanted pointers into the segment.  If we don't deal with these pointers, the segment turns out much smaller than it should.  These pointers keep a subtree of objects out of the segment.1) Break all owner pointers in submorphs and all scripts.2) Create the segment and look at outPointers.3) Remove those we expect.4) Remember to quit without saving -- the owner pointers are smashed."| newRoots suspects bag1 bag2 |arrayOfRoots _ rootArray.[newRoots _ self rootsIncludingPlayers.  newRoots == nil] whileFalse: [	arrayOfRoots _ newRoots].		"project, world, and all Players"self findRogueRootsPrep.	"and free that context!!"Smalltalk forgetDoIts.  outPointers _ nil.Smalltalk garbageCollect.self copyFromRoots: arrayOfRoots.suspects _ outPointers select: [:oo | oo isMorph].suspects size > 0 ifTrue: [suspects inspect].bag1 _ Bag new.  bag2 _ Bag new.outPointers do: [:key | 	(key isKindOf: Class) 		ifTrue: [bag2 add: key class name]		ifFalse: [(#(Symbol Point Rectangle True False String Float Color Form ColorForm StrikeFont Metaclass UndefinedObject TranslucentColor) includes: key class name)			ifTrue: [bag2 add: key class name]			ifFalse: [bag1 add: key class name]]]."(bag sortedCounts) is the SortedCollection"(StringHolder new contents: bag1 sortedCounts printString, '', bag2 sortedCounts printString) 	openLabel: 'Objects pointed at by the outside'.self halt: 'Examine local variables pointIn and inSeg'."Use this in inspectors:	outPointers select: [:oo | oo class == <a Class>].		"! !!ImageSegment methodsFor: 'testing' stamp: 'tk 9/7/1999 12:57'!findRogueRootsPrep	"Part of the tool to track down unwanted pointers into the segment.  Break all owner pointers in submorphs, scripts, and viewers in flaps."| wld players morphs scriptEditors |wld _ arrayOfRoots detect: [:obj | obj isMorph].wld ifNil: [wld _ (arrayOfRoots detect: [:obj | obj isKindOf: Project]) world].wld ifNil: [^ self error: 'can''t find a root morph'].wld presenter flushPlayerListCache.morphs _ IdentitySet new: 400.wld allMorphsAndBookPagesInto: morphs.players _ wld presenter allExtantPlayers.players do: [:pp |	scriptEditors _ pp class tileScriptNames collect: [:nn | 			pp scriptEditorFor: nn].	scriptEditors do: [:se | morphs addAll: se allMorphs]].wld submorphs do: [:mm | 	"non showing flaps"	(mm isKindOf: ViewerFlapTab) ifTrue: [		mm referent allMorphsAndBookPagesInto: morphs]].morphs do: [:mm | 	"break the back pointers"	(mm respondsTo: #target) ifTrue: [		mm nearestOwnerThat: [:ow | ow == mm target 			ifTrue: [mm target: nil. true]			ifFalse: [false]]].	(mm respondsTo: #arguments) ifTrue: [		mm arguments do: [:arg | arg ifNotNil: [			mm nearestOwnerThat: [:ow | ow == arg				ifTrue: [mm arguments at: (mm arguments indexOf: arg) put: nil. true]				ifFalse: [false]]]]].	mm eventHandler ifNotNil: ["recipients point back up"		(morphs includesAllOf: (mm eventHandler allRecipients)) ifTrue: [			mm eventHandler: nil]].	"temporary, until using Model for PartsBin"	(mm isKindOf: MorphicModel) ifTrue: [		(mm model isKindOf: MorphicModel) ifTrue: [			mm model breakDependents]]].(Smalltalk includesKey: #Owners) ifTrue: [Smalltalk at: #Owners put: nil].	"in case findOwnerMap: is commented out"self findOwnerMap: morphs.morphs do: [:mm | 	"break the back pointers"	mm privateOwner: nil]."more in extensions?"! !!ImageSegment methodsFor: 'testing' stamp: 'tk 9/8/1999 16:34'!findRogueRootsRefStrm: rootArray	"This is a tool to track down unwanted pointers into the segment.  If we don't deal with these pointers, the segment turns out much smaller than it should.  These pointers keep a subtree of objects out of the segment.1) assemble all objects that should be in the segment by using SmartReference Stream and a dummyReference Stream.  Put in a Set.2) Remove the roots from this list.  Ask for senders of each.  Of the senders, forget the ones that are in the segment already.  Keep others.  The list is now all the 'incorrect' pointers into the segment."| dummy goodInSeg inSeg ok pointIn |dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"rootArray do: [:root |	dummy rootObject: root.	"inform him about the root"	dummy nextPut: root.	].inSeg _ dummy references keys.dummy _ nil.   Smalltalk garbageCollect.  "dump refs dictionary"rootArray do: [:each | inSeg remove: each ifAbsent: []].	"want them to be pointed at from outside"pointIn _ IdentitySet new: 500.goodInSeg _ IdentitySet new: 2000.inSeg do: [:obj |	ok _ obj class isPointers.	obj class == Color ifTrue: [ok _ false].	obj class == TranslucentColor ifTrue: [ok _ false].	obj class == Array ifTrue: [obj size = 0 ifTrue: [ok _ false]].		"shared #() in submorphs of all Morphs"	ok ifTrue: [goodInSeg add: obj]].goodInSeg do: [:ob |		pointIn addAll: (Smalltalk pointersTo: ob except: #())].inSeg do: [:each | pointIn remove: each ifAbsent: []].rootArray do: [:each | pointIn remove: each ifAbsent: []].pointIn remove: inSeg array ifAbsent: [].pointIn remove: goodInSeg array ifAbsent: [].pointIn remove: pointIn array ifAbsent: [].self halt: 'Examine local variables pointIn and inSeg'.^ pointIn! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 8/13/1999 17:22'!rehashSets	"I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it)."	| object sets |	object _ segment.	sets _ OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	[object _ object nextObject.  		object isInMemory ifTrue: [			(object isKindOf: Set) ifTrue: [sets add: object]]. 		object == 0] whileFalse.	sets do: [:each | each rehash]. ! !!ImageSegmentRootStub reorganize!('fetch from disk' doesNotUnderstand: xxSuperclass:format:segment: xxxClass)('basics' == become: identityHash ifNil: ifNil:ifNotNil: ifNotNil: isInMemory nextInstance nextObject ~~)!!ImageSegmentRootStub methodsFor: 'basics' stamp: 'tk 8/13/1999 16:32'!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	"This is just a comment, since this message is never looked up"	<primitive: 110>	self primitiveFailed! !!ImageSegmentRootStub methodsFor: 'basics' stamp: 'tk 8/13/1999 16:33'!become: otherObject 	"Primitive. Swap the object pointers of the receiver and the argument.	All variables in the entire system that used to point to the 	receiver now point to the argument, and vice-versa.	Fails if either object is a SmallInteger"	(Array with: self)		elementsExchangeIdentityWith:			(Array with: otherObject)! !!ImageSegmentRootStub methodsFor: 'basics' stamp: 'tk 8/13/1999 16:33'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override."	<primitive: 75>	self primitiveFailed! !!ImageSegmentRootStub methodsFor: 'basics' stamp: 'tk 8/18/1999 18:15'!ifNil: nilBlock	"Know I'm not nil, so don't evaluate the block"	^ self! !!ImageSegmentRootStub methodsFor: 'basics' stamp: 'tk 8/13/1999 16:33'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock value! !!ImageSegmentRootStub methodsFor: 'basics' stamp: 'tk 8/13/1999 16:33'!ifNotNil: aBlock	"know its not nil, since we can't stand for a nil"	^ aBlock value! !!ImageSegmentRootStub methodsFor: 'basics' stamp: 'tk 8/13/1999 15:59'!isInMemory	"We are a place holder for an object that is out."	^ false! !!ImageSegmentRootStub methodsFor: 'basics' stamp: 'tk 8/13/1999 16:34'!nextInstance	"Primitive. Answer the next instance after the receiver in the 	enumeration of all instances of this class. Fails if all instances have been 	enumerated. Essential. See Object documentation whatIsAPrimitive."	<primitive: 78>	^nil! !!ImageSegmentRootStub methodsFor: 'basics' stamp: 'tk 8/13/1999 16:34'!nextObject	"Primitive. Answer the next object after the receiver in the 	enumeration of all objects. Return 0 when all objects have been 	enumerated."	<primitive: 139>	self primitiveFailed.! !!ImageSegmentRootStub methodsFor: 'basics' stamp: 'tk 8/13/1999 16:36'!~~ anObject	"Answer whether the receiver and the argument are not the same object 	(do not have the same object pointer)."	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Metaclass methodsFor: 'class hierarchy' stamp: 'tk 8/18/1999 17:37'!subclassesDoGently: aBlock	"Evaluate aBlock for each of the receiver's immediate subclasses."	thisClass subclassesDo: [:aSubclass |		"The following test is for Class class which has to exclude			the Metaclasses being subclasses of Class."		aSubclass isInMemory ifTrue: [			aSubclass isMeta ifFalse: [aBlock value: aSubclass class]]].! !!Morph methodsFor: 'e-toy support' stamp: 'tk 9/3/1999 11:46'!wrappedInWindow: aSystemWindow	| aWindow |	aWindow _ aSystemWindow model: Model new.	aWindow addMorph: self frame: (0@0 extent: 1@1).	aWindow extent: self extent.	^ aWindow! !!Morph methodsFor: 'e-toy support' stamp: 'tk 9/3/1999 11:46'!wrappedInWindowWithTitle: aTitle	| aWindow |	aWindow _ (SystemWindow labelled: aTitle) model: Model new.	aWindow addMorph: self frame: (0@0 extent: 1@1).	aWindow extent: self extent + (2 @ 18).	^ aWindow! !!BookMorph methodsFor: 'other' stamp: 'tk 9/3/1999 11:41'!wrappedInPartsWindowWithTitle: aTitle	| aWindow |	aWindow _ (PartsWindow labelled: aTitle) model: Model new.	aWindow book: self.	aWindow extent: self extent.	^ aWindow! !!ObjectOut methodsFor: 'basics' stamp: 'tk 8/18/1999 18:15'!ifNil: nilBlock	"Know I'm not nil, so don't evaluate the block"	^ self! !!ObjectScanner methodsFor: 'as yet unclassified' stamp: 'tk 8/12/1999 15:41'!lookAhead: aChunk	"See if this chunk is a class Definition, and if the new class name already exists and is instance-specific.  Modify the chunk, and record the rename in the SmartRefStream and in me."	| pieces sup oldName existing newName newDefn |	aChunk size < 90 ifTrue: [^ aChunk].		"class defn is big!!"	(aChunk at: 1) == $!! ifTrue: [^ aChunk].	"method def, fast exit"	pieces _ (aChunk copyFrom: 1 to: (300 min: aChunk size)) findTokens: ' #	\' withCRs.	pieces size < 3 ifTrue: [^ aChunk].	"really bigger, but just took front"	(pieces at: 2) = 'subclass:' ifFalse: [^ aChunk].	sup _ Smalltalk at: (pieces at: 1) asSymbol ifAbsent: [^ aChunk].	sup class class == Metaclass ifFalse: [^ aChunk].	((oldName _ pieces at: 3) at: 1) isUppercase ifFalse: [^ aChunk].	oldName _ oldName asSymbol.	(Smalltalk includesKey: oldName) ifFalse: [^ aChunk].	"no conflict"	existing _ Smalltalk at: oldName.	(existing isKindOf: Class) ifFalse: [^ aChunk].	"Write over non-class global"	existing isSystemDefined ifTrue: [^ aChunk].	"Go ahead and redefine it!!"	"Is a UniClass"	newName _ sup chooseUniqueClassName.	newDefn _ aChunk copyReplaceAll: oldName with: newName.	Compiler evaluate: newDefn for: self logged: true.	"Create the new class"	self rename: oldName toBe: newName.	^ newName asString		"to be evaluated"! !!PasteUpMorph methodsFor: 'project' stamp: 'tk 9/3/1999 12:07'!project	"Find the project that owns me.  Not efficient to call this."	^ Project ofWorld: self! !!PasteUpMorph methodsFor: 'project' stamp: 'tk 9/7/1999 13:52'!storeProjectsAsSegments	"Force my sub-projects out to disk"submorphs do: [:sub |	(sub isKindOf: ProjectViewMorph) ifTrue: [		sub storeSegment]].	"OK is was already out"! !!Player class methodsFor: 'housekeeping' stamp: 'tk 8/12/1999 15:45'!playersWithUnnecessarySubclasses	"Return a list of all players whose scripts dictionaries contain entries with nil selectors"	"Player playersWithUnnecessarySubclasses size"	^ self class allSubInstances select:		[:p | p class isSystemDefined not and: [p scripts size == 0 and: [p instVarNames size == 0]]] ! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 8/21/1999 17:11'!nextInto: buffer 	"fill buffer from my collection"	(buffer class isWords & collection class isBytes) ifTrue:		[1 to: buffer size do:			[:index | buffer at: index put: (self nextNumber: 4)].		^ buffer]."How dump bytes into a word object using a primitive???	(buffer isMemberOf: WordArray) ifTrue:		[buffer replaceFrom: 1 to: buffer size 			with: collection startingAt: position.		^ buffer]."	1 to: buffer size do:		[:index | buffer at: index put: self next].	^ buffer! !!Project methodsFor: 'file in/out' stamp: 'tk 8/21/1999 07:45'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."	^ DiskProxy global: #Project selector: #named: args: (Array with: self name)"	self inform: 'Project ', self name, ' is being written'.	super objectForDataStream: refStrm."! !!Project methodsFor: 'file in/out' stamp: 'tk 8/21/1999 07:31'!storeDataOn: aDataStream	"Write me out.  All references to other projects are weak references.  They only go out if they are written for another reason."	| cntInstVars cntIndexedVars localInstVars offset |	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	localInstVars _ Project instVarNames.	offset _ Project superclass instSize.	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:ii | 		(ii between: offset+1 and: offset + localInstVars size) 			ifTrue: [(#('parentProject' 'previousProject' 'nextProject') includes: 				(localInstVars at: ii-offset)) 					ifTrue: [aDataStream nextPutWeak: (self instVarAt: ii)]								"owner only written if in our tree"					ifFalse: [aDataStream nextPut: (self instVarAt: ii)]]			ifFalse: [aDataStream nextPut: (self instVarAt: ii)]].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!Project class methodsFor: 'utilities' stamp: 'tk 9/3/1999 12:06'!ofWorld: aPasteUpMorph	"Find the project of a world.  Not efficient"	^ self allSubInstances detect: [:pr | pr world == aPasteUpMorph] ifNone: [nil]! !!ProjectViewMorph methodsFor: 'as yet unclassified' stamp: 'tk 8/18/1999 18:01'!drawOn: aCanvas	project ifNil: [^ super drawOn: aCanvas].	project isInMemory ifFalse: [^ super drawOn: aCanvas].	"use lastProjectThumbnail"	project thumbnail ifNil: [		image fill: (0@0 extent: image extent) rule: Form over 			fillColor: project defaultBackgroundColor.		^ super drawOn: aCanvas].	project thumbnail ~~ lastProjectThumbnail ifTrue:			["scale thumbnail to fit my bounds"			(WarpBlt toForm: image)				sourceForm: project thumbnail;				cellSize: 2;  "installs a colormap"				combinationRule: Form over;				copyQuad: (project thumbnail boundingBox) innerCorners				toRect: (0@0 extent: image extent).			lastProjectThumbnail _ project thumbnail.			image borderWidth: 1].	super drawOn: aCanvas.! !!ProjectViewMorph methodsFor: 'fileIn/out' stamp: 'tk 8/19/1999 16:00'!exportSegment	"Store my project out on the disk as an ImageSegment.  Write the outPointers on the file also.  Name it <project name>.extSeg"| is fileName str |project world == World ifTrue: [^ self inform: 'Can''t send the current world out']."Do this on project enter"Utilities emptyScrapsBook.World flapTabs do: [:ft | ft referent adaptToWorld: World].	"Hack to keep the Menu flap from pointing at my project""Preferences setPreference: #useGlobalFlaps toValue: false."Utilities globalFlapTabsIfAny do:	[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: false].Utilities clobberFlapTabList.project world deleteAllFlapArtifacts.self currentWorld deleteAllFlapArtifacts.fileName _ project name,'.extSeg'.is _ ImageSegment new copyFromRootsLocalFileFor: 	(Array with: project). 	"project, world, and all Players""is copyFromRootsForExport: is arrayOfRoots.	additional roots -- Blocks"is segment size < 800 ifTrue: [	str _ String streamContents: [:strm |		strm nextPutAll: 'Only a tiny part of the project got into the segment'.		strm nextPutAll: '\These are pointed to from the outside:' withCRs.		is outPointers do: [:out |			(out class == Presenter) | (out class == ScriptEditorMorph) ifTrue: [				strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]].			(is arrayOfRoots includes: out class) ifTrue: [strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]]]].	self inform: str.	^ is inspect].is writeForExport: fileName.! !!ProjectViewMorph methodsFor: 'fileIn/out' stamp: 'tk 9/7/1999 13:49'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg"| is fileName str |project world == World ifTrue: [^ self inform: 'Can''t send the current world out'].project world isInMemory ifFalse: [^ self].  "already done""Do this on project enter"World flapTabs do: [:ft | ft referent adaptToWorld: World].	"Hack to keep the Menu flap from pointing at my project""Preferences setPreference: #useGlobalFlaps toValue: false."Utilities globalFlapTabsIfAny do:	[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: false].Utilities clobberFlapTabList."project world deleteAllFlapArtifacts."self currentWorld deleteAllFlapArtifacts.Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString].fileName _ project name,'.seg'.is _ ImageSegment new copyFromRootsLocalFileFor: 	(Array with: project world presenter with: project world).	 	"world, and all Players"is segment size < 800 ifTrue: ["debugging"	str _ String streamContents: [:strm |		strm nextPutAll: 'Only a tiny part of the project got into the segment'.		strm nextPutAll: '\These are pointed to from the outside:' withCRs.		is outPointers do: [:out |			(out class == Presenter) | (out class == ScriptEditorMorph) ifTrue: [				strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]].			(is arrayOfRoots includes: out class) ifTrue: [strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]]]].	self inform: str.	^ is inspect].is extract; writeToFile: fileName.! !!ProjectViewMorph methodsFor: 'accessing' stamp: 'tk 8/30/1999 11:48'!project	^project! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/17/1999 16:06'!saveClassInstVars	"Install the values of the instance variables of UniClasses.classInstVars is an array of arrays (#Player3 (Player3 class's inst varscripts) (Player3 class's inst var slotInfo) ...) "	| normal mySize list clsPoolIndex |	classInstVars _ OrderedCollection new: 100.	normal _ Object class instSize.	clsPoolIndex _ Object class allInstVarNames indexOf: 'classPool'.	self uniClasesDo: [:aUniClass |		list _ OrderedCollection new.		mySize _ aUniClass class instSize.		mySize = normal ifFalse:			[list add: aUniClass name.	"a symbol"			list add: 'Update to read classPool'.	"newconvention for saving the classPool"			list add: (aUniClass instVarAt: clsPoolIndex)"classPool".						"write actual value of nilinstead of Dictionary()"			normal + 1 to: mySize do: [:ii |				list addLast: (aUniClass instVarAt: ii)]].		classInstVars add: list asArray].	classInstVars _ classInstVars asArray.	! !!SystemDictionary methodsFor: 'retrieving' stamp: 'tk 8/18/1999 17:50'!allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system 	(that is, Object and its subclasses).	ar 7/15/1999: The code below will not enumerate any obsolete or anonymous	behaviors for which the following should be executed:		Smalltalk allObjectsDo:[:obj| obj isBehavior ifTrue:[aBlock value: obj]].	but what follows is way faster than enumerating all objects."	aBlock value: Object.	Object allSubclassesDoGently: aBlock.		"don't bring in ImageSegments"	"Classes outside the Object hierarchy"	Class subclassesDo: [:aClass |		aClass == Object class ifFalse: ["Do not enumerate Object"			"Enumerate the non-meta class and its subclasses"			aBlock value: aClass soleInstance.			aClass soleInstance allSubclassesDoGently: aBlock]].! !!SystemWindow methodsFor: 'panes' stamp: 'tk 8/13/1999 17:50'!paneColor	Display depth > 2 ifTrue:		[model ifNotNil: [			model isInMemory ifTrue: [				^ Color colorFrom: model defaultBackgroundColor]].		paneMorphs isEmptyOrNil ifFalse: [^ paneMorphs first color]].	^ Color white! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'tk 8/18/1999 17:46'!subclassesDoGently: aBlock	"Evaluate aBlock with all subclasses of nil.  Others are not direct subclasses of Class."	^ Class subclassesDoGently: [:cl | 			cl isMeta ifTrue: [aBlock value: cl soleInstance]].! !ImageSegment removeSelector: #findRogueRoots:!ImageSegment removeSelector: #findRogueRootsOld:!Object class removeSelector: #isSystemDefined!Object class removeSelector: #officialClass!"Postscript:"ScriptingSystem resetStandardPartsBin.!