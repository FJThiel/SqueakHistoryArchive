'From Squeak3.2alpha of 2 October 2001 [latest update: #4522] on 17 November 2001 at 11:02:40 am'!"Change Set:		HaloBoundsFixDate:			14 November 2001Author:			Dan IngallsThis changeSet does several things:It expands the bounds in the case that the halo is showing the target bounds rectangle, thus fixing a bug that left gribblies on the screen when dragging some morphs with this feature enabled.It also reduces the damage area when halos are added to and removed from large morphs, especially the world.  It does this by invalidating four strips that include the handles and name.Damage resulting from adding or removing morphs is now recorded by sending #changed to the morphs, thus allowing unusual shapes, such as halos, to override the default behavior.Finally a tweak to DamageRecorder>>recordInvalidRect: makes the threshold for merging rectangles be relative to the rectangle size rather than a fixed value.The net result is MUCH faster response on halos, and probably better management of  damage generally."!!DamageRecorder methodsFor: 'recording' stamp: 'di 11/17/2001 10:44'!recordInvalidRect: aRectangle	"Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle."	| mergeRect significant |	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"	significant _ aRectangle area // 4.  "Threshold for significant overlap"	invalidRects do: [:rect |		(rect intersect: aRectangle) area > significant ifTrue:			["merge rectangle in place (see note below) if there is any overlap"			rect setOrigin: (rect origin min: aRectangle origin) truncated				corner: (rect corner max: aRectangle corner) truncated.			^ self]].	invalidRects size >= 15 ifTrue:		["if there are too many separate areas, merge them all"		mergeRect _ Rectangle merging: invalidRects.		self reset.		invalidRects addLast: mergeRect].	"add the given rectangle to the damage list"	"Note: We make a deep copy of all rectangles added to the damage list,		since rectangles in this list may be extended in place."	invalidRects addLast:		(aRectangle topLeft truncated corner: aRectangle bottomRight truncated).! !!Morph methodsFor: 'change reporting' stamp: 'di 11/17/2001 11:02'!addedOrRemovedSubmorph: aMorph	"Report that the area occupied by this morph should be redrawn."	"NOTE: this is subtly different from 'aMorph changed'	in that it forces computation of aMorph fullBounds."	"Used to be...	self invalidRect: aMorph fullBounds from: aMorph"	aMorph fullBounds.	aMorph changed! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'di 11/17/2001 09:27'!addAllMorphs: aCollection	| inWorld myWorld itsWorld |	myWorld _ self world.	inWorld _ myWorld notNil.	aCollection do: [:m |		m owner ifNotNil: [			itsWorld _ m world.			itsWorld == myWorld ifFalse: [m outOfWorld: itsWorld].			m owner privateRemoveMorph: m].		m privateOwner: self.		inWorld ifTrue: [self addedOrRemovedSubmorph: m].		itsWorld == myWorld ifFalse: [m intoWorld: myWorld].		].	submorphs _ submorphs, aCollection.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'di 11/17/2001 09:32'!addAllMorphs: aCollection after: anotherMorph	| index inWorld myWorld itsWorld |	myWorld _ self world.	inWorld _ myWorld notNil.	index _ submorphs indexOf: anotherMorph ifAbsent: [submorphs size].	aCollection do: [:m |		m owner ifNotNil: [			itsWorld _ m world.			itsWorld == myWorld ifFalse: [m outOfWorld: itsWorld].			m owner privateRemoveMorph: m].		m privateOwner: self.		inWorld ifTrue: [self addedOrRemovedSubmorph: m].		itsWorld == myWorld ifFalse: [m intoWorld: myWorld].		].	submorphs _ (submorphs copyFrom: 1 to: index), aCollection,			(submorphs copyFrom: index+1 to: submorphs size).	self layoutChanged.! !!Morph methodsFor: 'private' stamp: 'di 11/17/2001 09:36'!privateAddMorph: aMorph atIndex: index	| oldIndex myWorld itsWorld |	((index >= 1) and: [index <= (submorphs size + 1)])		ifFalse: [^ self error: 'index out of range'].	myWorld _ self world.	aMorph owner == self		ifTrue:		["aMorph's position changes within in the submorph chain"		oldIndex _ submorphs indexOf: aMorph.		oldIndex < index			ifTrue:			["moving aMorph to back"			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.			submorphs at: index-1 put: aMorph]			ifFalse:			["moving aMorph to front"			oldIndex-1 to: index by: -1 do:[:i|				submorphs at: i+1 put: (submorphs at: i)].			submorphs at: index put: aMorph]]		ifFalse:		["adding a new morph"		aMorph owner ifNotNil:			[itsWorld _ aMorph world.			itsWorld == myWorld ifFalse: [aMorph outOfWorld: itsWorld].			aMorph owner privateRemoveMorph: aMorph].		aMorph privateOwner: self.		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).		itsWorld == myWorld ifFalse:[aMorph intoWorld: myWorld]].	self layoutChanged.	myWorld ifNotNil: [self addedOrRemovedSubmorph: aMorph].! !!Morph methodsFor: 'private' stamp: 'di 11/17/2001 09:37'!privateRemoveMorph: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	self isInWorld ifTrue: [self addedOrRemovedSubmorph: aMorph].	submorphs _ submorphs copyWithout: aMorph.	self layoutChanged.! !!HaloMorph methodsFor: 'geometry' stamp: 'di 11/14/2001 11:11'!bounds: newBounds	Preferences showBoundsInHalo		ifTrue: [super bounds: (newBounds expandBy: 1)]		ifFalse: [super bounds: newBounds]! !!HaloMorph methodsFor: 'geometry' stamp: 'di 11/17/2001 10:56'!changed	"Quicker to invalidate handles individually if target is large (especially the world)"	self extent > (200@200)		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue:					["Invalidate 4 outer strips first, thus subsuming separate damage."					(self fullBounds areasOutside: target bounds) do:						[:r | self invalidRect: r]].				self submorphsDo: [:m | m changed]]		ifFalse: [super changed].! !