'From Squeak 2.3 beta of Nov 25, 1998 on 5 December 1998 at 12:51:10 pm'!"Change Set:		PrimitiveTweaksDate:			4 December 1998Author:			Dan IngallsA couple of simple tweaks to shave cycles off primtive execution.One is to set primitiveIndex to zero if it is out of range BEFORE putting it in the cache.  Therefore it never needs to be checked in primitiveResponse.The other is to factor the code so that only one check needs to be made for nextWakeupTick being zero.Soon we should get all the interrupt checking out of primitiveResponse and into ony those primitives that tend to take a long time.NOTE: These changes were developed together with several others and so may not work in isolation."!!Interpreter methodsFor: 'message sending' stamp: 'di 12/4/1998 03:15'!internalExecuteNewMethod	self inline: true.	primitiveIndex > 0		ifTrue: [(primitiveIndex > 255 and: [primitiveIndex < 520])				ifTrue: ["Internal return instvars"						primitiveIndex >= 264						ifTrue:						[^ self internalPop: 1 thenPush:								(self fetchPointer: primitiveIndex-264										ofObject: self internalStackTop)]						ifFalse:						["Internal return constants"						primitiveIndex = 256 ifTrue: [^ nil "^ self"].						primitiveIndex = 257 ifTrue: [^ self internalPop: 1 thenPush: trueObj].						primitiveIndex = 258 ifTrue: [^ self internalPop: 1 thenPush: falseObj].						primitiveIndex = 259 ifTrue: [^ self internalPop: 1 thenPush: nilObj].						^ self internalPop: 1 thenPush: (self integerObjectOf: primitiveIndex-261)]]				ifFalse: 	[self externalizeIPandSP.						self primitiveResponse ifTrue: [self internalizeIPandSP. ^ nil].						self internalizeIPandSP]].	"if not primitive, or primitive failed, activate the method"	self internalActivateNewMethod.	"check for possible interrupts at each real send"	self internalQuickCheckForInterrupts.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/4/1998 15:02'!lookupMethodInDictionary: dictionary	"This method lookup tolerates integers as Dictionary keys to support	execution of images in which Symbols have been compacted out" 	| length index mask wrapAround nextSelector methodArray |	self inline: true.	length _ self fetchWordLengthOf: dictionary.	mask _ length - SelectorStart - 1.	(self isIntegerObject: messageSelector)		ifTrue:		[index _ (mask bitAnd: (self integerValueOf: messageSelector)) + SelectorStart]		ifFalse:		[index _ (mask bitAnd: (self hashBitsOf: messageSelector)) + SelectorStart].	"It is assumed that there are some nils in this dictionary, and search will	stop when one is encountered.  However, if there are no nils, then wrapAround	will be detected the second time the loop gets to the end of the table."	wrapAround _ false.	[true] whileTrue:		[nextSelector _ self fetchPointer: index					ofObject: dictionary.		nextSelector=nilObj ifTrue: [^false].		nextSelector=messageSelector			ifTrue: [methodArray _ self fetchPointer: MethodArrayIndex							ofObject: dictionary.				newMethod _ self fetchPointer:  index - SelectorStart							ofObject: methodArray.				primitiveIndex _ self primitiveIndexOf: newMethod.				primitiveIndex > MaxPrimitiveIndex ifTrue:					["If primitiveIndex is out of range, set to zero before putting in cache.						This is equiv to primFail, and avoids the need to check on every send."					primitiveIndex _ 0].				^ true].		index _ index + 1.		index = length			ifTrue: [wrapAround ifTrue: [^false].				wrapAround _ true.				index _ SelectorStart]]! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/4/1998 03:54'!bytecodePrimValue	| block |	block _ self internalStackTop.	argumentCount _ 0.	successFlag _ true.	self assertClassOf: block is: (self splObj: ClassBlockContext).	successFlag ifTrue: [self internalPrimitiveValue].	successFlag ifFalse:		[messageSelector _ self specialSelector: 25.		self normalSend].! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/4/1998 03:54'!bytecodePrimValueWithArg	| block |	block _ self internalStackTop.	argumentCount _ 1.	successFlag _ true.	self assertClassOf: block is: (self splObj: ClassBlockContext).	successFlag ifTrue: [self internalPrimitiveValue].	successFlag ifFalse:		[messageSelector _ self specialSelector: 26.		self normalSend].! !!Interpreter methodsFor: 'primitive support' stamp: 'di 12/5/1998 12:09'!primitiveResponse	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| startTime |	successFlag _ true.	nextWakeupTick = 0 ifTrue:		[self dispatchOn: primitiveIndex in: PrimitiveTable.		^ successFlag].	startTime _ self ioLowResMSecs.	self dispatchOn: primitiveIndex in: PrimitiveTable.	self ioLowResMSecs ~= startTime ifTrue:		["primitive ran for more than a tick; check for possible timer interrupts"		((self ioMSecs bitAnd: 16r1FFFFFFF) >= nextWakeupTick) ifTrue: [			successFlag				ifTrue: ["process the interrupt now"						self checkForInterrupts]				ifFalse: ["process the interrupt in primtive failure code"						interruptCheckCounter _ 0]]].	^ successFlag! !!Interpreter methodsFor: 'control primitives' stamp: 'di 12/4/1998 04:07'!internalPrimitiveValue	| blockContext blockArgumentCount initialIP |	self inline: true.	blockContext _ self internalStackValue: argumentCount.	blockArgumentCount _ self argumentCountOfBlock: blockContext.	self success: (argumentCount = blockArgumentCount			and: [(self fetchPointer: CallerIndex ofObject: blockContext) = nilObj]).	successFlag ifTrue:		["This code assumes argCount can only = 0 or 1"		argumentCount = 1 ifTrue:			[self storePointer: TempFrameStart ofObject: blockContext				withValue: self internalStackTop].		self internalPop: argumentCount + 1.		initialIP _ self fetchPointer: InitialIPIndex	ofObject: blockContext.		self storePointerUnchecked: InstructionPointerIndex ofObject: blockContext			withValue: initialIP.		self storeStackPointerValue: argumentCount	inContext: blockContext.		self storePointerUnchecked: CallerIndex		ofObject: blockContext			withValue: activeContext.		self internalNewActiveContext: blockContext]! !