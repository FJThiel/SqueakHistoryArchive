'From Squeak 2.4b of April 23, 1999 on 25 June 1999 at 12:22:32 pm'!"Change Set:		MorphicFillStyles-arDate:			18 June 1999Author:			Andreas RaabThis change set replaces colors by fill styles in the basic morphs:* Morph/BorderedMorph/RectangleMorph* EllipseMorph* PolygonMorph/CurveMorphAfter you have filed in this change set, create any of the above guys and start playing with the 'fill style' submenu (replacing the old 'change color').Notes:1) There is still a lot of cleanup pending - most subclasses silently ignore the inherited drawing methods.2) For now, the fill styles are stored in the properties (in parallel to the color inst var). This is because the change set does not clean up the accesses to color (for keeping it smaller and more focused).3) The menu items for colors/fill styles are now added by using a method in class morph (there are two ways of creating the menu for morphs).4) HandleMorph has been extended for keyboard input (useful if you try to align the origin/orientation of a fill style)"!AlignmentMorph subclass: #GraphicalMenu	instanceVariableNames: 'target selector argument currentIndex formChoices formDisplayMorph coexistWithOriginal '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Menus'!SketchMorph subclass: #ColorPickerMorph	instanceVariableNames: 'selectedColor sourceHand deleteOnMouseUp updateContinuously selector target argument '	classVariableNames: 'ColorChart FeedbackBox TransparentBox '	poolDictionaries: ''	category: 'Morphic-Widgets'!!BitmapFillStyle class methodsFor: 'instance creation' stamp: 'ar 6/25/1999 12:01'!fromForm: aForm	| fs |	fs _ self form: aForm.	fs direction: aForm width @ 0.	fs normal: 0 @ aForm height.	fs tileFlag: true.	^fs! !!BitmapFillStyle class methodsFor: 'instance creation' stamp: 'ar 6/18/1999 07:09'!fromUser	| fill |	fill _ self form: Form fromUser.	fill origin: 0@0.	fill direction: fill form width @ 0.	fill normal: 0 @ fill form height.	fill tileFlag: true. "So that we can fill arbitrary objects"	^fill! !!Canvas commentStamp: 'ar 6/25/1999 12:18' prior: 0!A canvas is a two-dimensional medium on which morphs are drawn in a device-independent manner. Canvases keep track of the origin and clipping rectangle, as well as the underlying drawing medium (such as a window, pixmap, or postscript script).Subclasses must implement (at least) the following methods:	* Drawing:		#fillOval:color:borderWidth:borderColor:		#frameAndFillRectangle:fillColor:borderWidth:borderColor:		#drawPolygon:color:borderWidth:borderColor:		#image:at:sourceRect:rule:		#stencil:at:sourceRect:rule:		#line:to:width:color:		#paragraph:bounds:color:		#text:bounds:font:color:	* Support		#clipBy:during:		#translateBy:during:		#translateBy:clippingTo:during:		#transformBy:clippingTo:during:!!Canvas reorganize!('initialization' flush reset)('copying' copy)('accessing' clipRect depth extent form origin)('testing' isBalloonCanvas isShadowDrawing isVisible:)('drawing' fillColor: line:to:brushForm: line:to:color: line:to:width:color: paragraph:bounds:color: point:color: render: text:at:font:color: text:bounds:font:color:)('private')('drawing-general' draw: drawMorph: fullDraw: fullDrawMorph:)('drawing-support' cache:using:during: clipBy:during: preserveStateDuring: transformBy:clippingTo:during: translateBy:clippingTo:during: translateBy:during: translateTo:clippingTo:during:)('drawing-rectangles' fillRectangle:color: fillRectangle:fillStyle: frameAndFillRectangle:fillColor:borderWidth:borderColor: frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor: frameRectangle:color: frameRectangle:width:color:)('drawing-ovals' fillOval:color: fillOval:color:borderWidth:borderColor: fillOval:fillStyle: fillOval:fillStyle:borderWidth:borderColor: frameOval:color: frameOval:width:color:)('drawing-polygons' drawPolygon:color:borderWidth:borderColor: drawPolygon:fillStyle: drawPolygon:fillStyle:borderWidth:borderColor:)('drawing-images' image:at: image:at:rule: image:at:sourceRect:rule: imageWithOpaqueWhite:at: stencil:at:color: stencil:at:sourceRect:color:)('converting' asShadowDrawingCanvas asShadowDrawingCanvas:)!!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:32'!fillRectangle: r color: c	"Fill the rectangle using the given color"	^self 		frameAndFillRectangle: r		fillColor: c		borderWidth: 0		borderColor: Color transparent! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:34'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle.	Note: The default implementation does not recognize any enhanced fill styles"	self fillRectangle: aRectangle color: aFillStyle asColor.! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:32'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	"Draw the rectangle using the given attributes"	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:32'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	"Draw the rectangle using the given attributes.	Note: This is a *very* simple implementation"	| bw pt |	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: bottomRightColor.	bw _ borderWidth asPoint.	pt _ r topLeft + (bw // 2).	self line: pt to: pt + ((r extent x - bw x)@0) width: borderWidth color: topLeftColor.	self line: pt to: pt + (0@(r extent y - bw y)) width: borderWidth color: topLeftColor.! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:33'!frameRectangle: r color: c	self frameRectangle: r width: 1 color: c.! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:33'!frameRectangle: r width: w color: c	^self frameAndFillRectangle: r fillColor: Color transparent borderWidth: w borderColor: c.! !!Canvas methodsFor: 'drawing-ovals' stamp: 'ar 6/18/1999 08:45'!fillOval: r color: c	self fillOval: r color: c borderWidth: 0 borderColor: Color transparent.! !!Canvas methodsFor: 'drawing-ovals' stamp: 'ar 6/18/1999 08:45'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Fill the given oval."	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-ovals' stamp: 'ar 6/18/1999 08:51'!fillOval: aRectangle fillStyle: aFillStyle	"Fill the given oval."	^self fillOval: aRectangle fillStyle: aFillStyle borderWidth: 0 borderColor: Color transparent! !!Canvas methodsFor: 'drawing-ovals' stamp: 'ar 6/18/1999 08:50'!fillOval: aRectangle fillStyle: aFillStyle borderWidth: bw borderColor: bc	"Fill the given oval.	Note: The default implementation does not recognize any enhanced fill styles"	self fillOval: aRectangle color: aFillStyle asColor borderWidth: bw borderColor: bc! !!Canvas methodsFor: 'drawing-ovals' stamp: 'ar 6/18/1999 08:45'!frameOval: r color: c	self fillOval: r color: Color transparent borderWidth: 1 borderColor: c.! !!Canvas methodsFor: 'drawing-ovals' stamp: 'ar 6/18/1999 08:45'!frameOval: r width: w color: c	self fillOval: r color: Color transparent borderWidth: w borderColor: c.! !!Canvas methodsFor: 'drawing-polygons' stamp: 'ar 6/18/1999 08:56'!drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc	"Draw the given polygon."	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-polygons' stamp: 'ar 6/25/1999 12:18'!drawPolygon: vertices fillStyle: aFillStyle	"Fill the given polygon."	self drawPolygon: vertices fillStyle: aFillStyle borderWidth: 0 borderColor: Color transparent! !!Canvas methodsFor: 'drawing-polygons' stamp: 'ar 6/18/1999 08:58'!drawPolygon: vertices fillStyle: aFillStyle borderWidth: bw borderColor: bc	"Fill the given polygon.	Note: The default implementation does not recognize any enhanced fill styles"	self drawPolygon: vertices color: aFillStyle asColor borderWidth: bw borderColor: bc! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 6/25/1999 12:17'!image: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self image: aForm		at: aPoint		sourceRect: aForm boundingBox		rule: Form paint.! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 6/25/1999 12:17'!image: aForm at: aPoint rule: combinationRule	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self image: aForm		at: aPoint		sourceRect: aForm boundingBox		rule: combinationRule.! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 6/25/1999 12:17'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the given form."	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 6/25/1999 12:17'!imageWithOpaqueWhite: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm but with the convention that zero represents opaque white."	self image: aForm		at: aPoint		sourceRect: (0@0 extent: aForm extent)		rule: Form over.! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 6/25/1999 12:17'!stencil: stencilForm at: aPoint color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	^self stencil: stencilForm		at: aPoint		sourceRect: stencilForm boundingBox		color: aColor! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 6/25/1999 12:17'!stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	^self subclassResponsibility! !!Color methodsFor: 'queries' stamp: 'ar 6/18/1999 06:58'!isGradientFill	^false! !!Color methodsFor: 'queries' stamp: 'ar 6/18/1999 07:57'!isOrientedFill	"Return true if the receiver keeps an orientation (e.g., origin, direction, and normal)"	^false! !!Color methodsFor: 'transformations' stamp: 'ar 6/18/1999 08:42'!alphaMixed: proportion with: aColor	"The same as #mixed:with: but including alpha interpolation.	Note: This is a separate method since I don't know if there could be any side effects"	| frac1 frac2 baseColor alpha |	frac1 _ proportion asFloat min: 1.0 max: 0.0.	frac2 _ 1.0 - frac1.	baseColor _ Color		r: (self    red * frac1) + (aColor    red * frac2) 		g: (self green * frac1) + (aColor green * frac2) 		b: (self   blue * frac1) + (aColor  blue * frac2).	alpha _ (self alpha * frac1) + (aColor alpha * frac2).	alpha > 0.99 		ifTrue:[^baseColor]		ifFalse:[^baseColor alpha: alpha]! !!Color methodsFor: 'transformations' stamp: 'ar 6/19/1999 00:36'!negated	"Return an RGB inverted color"	^Color		r: 1.0 - self red		g: 1.0 - self green		b: 1.0 - self blue! !!Color methodsFor: 'Morphic menu' stamp: 'ar 6/18/1999 08:35'!addFillStyleMenuItems: aMenu hand: aHand from: aMorph	"Add the items for changing the current fill style of the receiver"	aMenu add: 'change color...' target: self selector: #changeColorIn:event: argument: aMorph! !!Color methodsFor: 'Morphic menu' stamp: 'ar 6/18/1999 08:36'!changeColorIn: aMorph event: evt	"Note: This is just a workaround to make sure we don't use the old color inst var"	evt hand changeColorTarget: aMorph selector: #fillStyle:.! !!FillStyle methodsFor: 'testing' stamp: 'ar 6/18/1999 07:57'!isOrientedFill	"Return true if the receiver keeps an orientation (e.g., origin, direction, and normal)"	^false! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:35'!fillRectangle: r color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port fillRect: r color: (self drawColor: c) offset: origin].! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:36'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	aFillStyle isSolidFill ifTrue:[^self fillRectangle: aRectangle color: aFillStyle asColor].	"Use a BalloonCanvas instead"	self asBalloonCanvas fillRectangle: aRectangle fillStyle: aFillStyle.! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:34'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	"draw the border of the rectangle"	borderColor isTransparent ifFalse:		[port combinationRule: (self drawRule: Form over color: borderColor).		(r area > 10000 or: [fillColor isTranslucent])			ifTrue: [port frameRect: (r translateBy: origin)						borderWidth: borderWidth						borderColor: (self drawColor: borderColor)]			ifFalse: ["for small rectangles, it's faster to fill the entire outer rectangle						than to compute and fill the border rects"					port fillRect: r						color: (self drawColor: borderColor)						offset: origin]].	"fill the inside"	fillColor isTransparent ifFalse:		[port combinationRule: (self drawRule: Form over color: fillColor).		port fillRect: (r insetBy: borderWidth)			color: (self drawColor: fillColor)			offset: origin].! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:35'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| w h rect |	"First use quick code for top and left borders and fill"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now use slow code for bevelled bottom and right borders"	bottomRightColor isTransparent ifFalse: [		borderWidth isNumber			ifTrue: [w _ h _ borderWidth]			ifFalse: [w _ borderWidth x.   h _ borderWidth y].		rect _ r translateBy: origin.		port fillColor: (self drawColor: bottomRightColor);			 frameRectRight: rect width: w;			 frameRectBottom: rect height: h].! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:35'!frameRectangle: r width: w color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port frameRect: (r translateBy: origin)			borderWidth: w			borderColor: (self drawColor: c)].! !!FormCanvas methodsFor: 'drawing-ovals' stamp: 'ar 6/18/1999 08:46'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	| rect fillC borderC borderRule |	(borderColor isColor and: [borderColor isTranslucentColor])		ifTrue: ["Translucent border requires use of temporary forms"				^self fillTranslucentOval: r color: c borderWidth: borderWidth borderColor: borderColor].	rect _ r.	c isTransparent		ifTrue: [fillC _ nil]		ifFalse: [fillC _ self drawColor: c].	borderColor isTransparent		ifTrue: [fillC == nil ifTrue: [^ self].  "both border and fill are transparent"				borderC _ nil.				rect _ rect insetBy: borderWidth]		ifFalse: [borderC _ self drawColor: borderColor.				borderRule _ self drawRule: Form over color: borderColor].	port combinationRule: (self drawRule: Form over color: c).	port fillOval: (rect translateBy: origin)		color: fillC		borderWidth: borderWidth		borderColor: borderC		borderRule: borderRule.! !!FormCanvas methodsFor: 'drawing-ovals' stamp: 'ar 6/18/1999 08:52'!fillOval: aRectangle fillStyle: aFillStyle borderWidth: bw borderColor: bc	"Fill the given oval."	aFillStyle isSolidFill ifTrue:[		^self fillOval: aRectangle color: aFillStyle asColor borderWidth: bw borderColor: bc].	"Use a BalloonCanvas instead"	self asBalloonCanvas fillOval: aRectangle fillStyle: aFillStyle borderWidth: bw borderColor: bc! !!FormCanvas methodsFor: 'drawing-polygons' stamp: 'ar 6/18/1999 08:57'!drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc	"Generalize for the BalloonCanvas"	^self drawPolygon: vertices fillStyle: aColor borderWidth: bw borderColor: bc! !!FormCanvas methodsFor: 'drawing-polygons' stamp: 'ar 6/18/1999 09:32'!drawPolygon: vertices fillStyle: aFillStyle borderWidth: bw borderColor: bc	"Use a BalloonCanvas"	self asBalloonCanvas drawPolygon: vertices fillStyle: aFillStyle borderWidth: bw borderColor: bc! !!BalloonCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 08:48'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	^self drawRectangle: aRectangle			color: aFillStyle "@@: Name confusion!!!!!!"			borderWidth: 0			borderColor: nil! !!BalloonCanvas methodsFor: 'drawing-ovals' stamp: 'ar 6/18/1999 08:50'!fillOval: aRectangle fillStyle: aFillStyle borderWidth: bw borderColor: bc	"Fill the given rectangle."	^self drawOval: (aRectangle insetBy: bw // 2)			color: aFillStyle "@@: Name confusion!!!!!!"			borderWidth: bw			borderColor: bc! !!BalloonCanvas methodsFor: 'drawing-polygons' stamp: 'ar 6/18/1999 09:00'!drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc	"Generalize for the BalloonCanvas"	^self drawPolygon: vertices fillStyle: aColor borderWidth: bw borderColor: bc! !!BalloonCanvas methodsFor: 'drawing-polygons' stamp: 'ar 6/18/1999 09:32'!drawPolygon: vertices fillStyle: aFillStyle borderWidth: borderWidth borderColor: borderColor	"Draw a simple polygon defined by the list of vertices."	| fillC borderC |	fillC _ self drawColor: aFillStyle.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawPolygon: (vertices copyWith: vertices first)		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!ImageMorph class methodsFor: 'accessing' stamp: 'ar 6/25/1999 11:59'!defaultForm	^DefaultForm! !!Morph methodsFor: 'initialization' stamp: 'ar 6/25/1999 11:12'!initialize	bounds _ 0@0 corner: 50@40.	owner _ nil.	submorphs _ EmptyArray.	color _ self defaultColor.! !!Morph methodsFor: 'drawing' stamp: 'ar 6/18/1999 07:38'!drawOn: aCanvas	aCanvas fillRectangle: self bounds fillStyle: self fillStyle.! !!Morph methodsFor: 'menus' stamp: 'ar 6/18/1999 06:45'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	self player ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	"aMenu add: 'open viewer' action: #openViewerForArgument.	(self isKindOf: MorphThumbnail) ifFalse:		[aMenu add: 'make alias' action: #makeAliasForArgument]."	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	"Add the fill style items"	self addFillStyleMenuItems: aMenu hand: aHandMorph.	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!Morph methodsFor: 'menus' stamp: 'ar 6/25/1999 11:09'!addFillStyleMenuItems: aMenu hand: aHand	"Add the items for changing the current fill style of the Morph"	| menu |	self canHaveFillStyles ifFalse:[^aMenu add: 'change color...' action: #changeColor].	menu _ MenuMorph new defaultTarget: self.	self fillStyle addFillStyleMenuItems: menu hand: aHand from: self.	menu addLine.	menu add: 'solid fill' action: #useSolidFill.	menu add: 'gradient fill' action: #useGradientFill.	menu add: 'bitmap fill' action: #useBitmapFill.	menu add: 'default fill' action: #useDefaultFill.	aMenu add: 'fill style' subMenu: menu.	"aMenu add: 'change color...' action: #changeColor"! !!Morph methodsFor: 'private' stamp: 'ar 6/18/1999 07:58'!privateMoveBy: delta	"Private!! Use 'position:' instead."	| trailMorph start fill |	(extension == nil or: [extension player == nil]) ifFalse:		["Most cases eliminated fast by above test"		self getPenDown ifTrue:			["If this is a costume for a player with its pen down, draw a line."			(trailMorph _ self trailMorph) ifNotNil:				[start _ self referencePosition.				trailMorph drawPenTrailFor: self from: start to: start + delta]]].	fullBounds == bounds		ifTrue: ["optimization: avoids recomputing fullBounds"				fullBounds _ bounds _ bounds translateBy: delta]		ifFalse: [bounds _ bounds translateBy: delta.				fullBounds _ nil].	fill _ self fillStyle.	fill isOrientedFill ifTrue:[fill origin: fill origin + delta].! !!Morph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:11'!canHaveFillStyles	"Return true if the receiver can have general fill styles; not just colors.	This method is for gradually converting old morphs."	^self class == Morph "no subclasses"! !!Morph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:11'!defaultColor	"Return the default fill style for the receiver"	^Color blue! !!Morph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:11'!fillStyle	"Return the current fillStyle of the receiver."	^self valueOfProperty: #fillStyle ifAbsent:[		"Workaround already converted morphs"		color ifNil:[self defaultColor]].! !!Morph methodsFor: 'visual properties' stamp: 'ar 6/18/1999 07:05'!fillStyle: aFillStyle	"Set the current fillStyle of the receiver."	self setProperty: #fillStyle toValue: aFillStyle.	"Workaround for Morphs not yet converted"	color _ aFillStyle asColor.	self changed.! !!Morph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 12:00'!useBitmapFill	"Make receiver use a solid fill style (e.g., a simple color)"	| fill |	self fillStyle isBitmapFill ifTrue:[^self]. "Already done"	fill _ BitmapFillStyle fromForm: ImageMorph defaultForm.	"Note: Must fix the origin due to global coordinates"	fill origin: self bounds origin.	self fillStyle: fill.! !!Morph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:11'!useDefaultFill	"Make receiver use a solid fill style (e.g., a simple color)"	self fillStyle: self defaultColor.! !!Morph methodsFor: 'visual properties' stamp: 'ar 6/19/1999 00:36'!useGradientFill	"Make receiver use a solid fill style (e.g., a simple color)"	| fill color1 color2 |	self fillStyle isGradientFill ifTrue:[^self]. "Already done"	color1 _ self color.	color2 _ color1 negated.	fill _ GradientFillStyle ramp: {0.0 -> color1. 1.0 -> color2}.	fill origin: self topLeft.	fill direction: 0 @ self bounds extent y.	fill normal: self bounds extent x @ 0.	fill radial: false.	self fillStyle: fill.! !!Morph methodsFor: 'visual properties' stamp: 'ar 6/18/1999 06:57'!useSolidFill	"Make receiver use a solid fill style (e.g., a simple color)"	self fillStyle isSolidFill ifTrue:[^self]. "Already done"	self fillStyle: self fillStyle asColor. "Try minimizing changes"! !!BorderedMorph methodsFor: 'drawing' stamp: 'ar 6/18/1999 08:28'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color is generated from the receiver's own color,	while the inset border color is generated from the color of its owner.	This behavior is visually more consistent. Thanks to Hans-Martin Mosner."	| insetColor |	borderWidth = 0 ifTrue: [  "no border"		"Note: This is the hook for border styles.			When converting to the new borders we'll just put 0 into the borderWidth"		super drawOn: aCanvas.		^ self].	borderColor == #raised ifTrue: [		"Use a hack for now"		aCanvas fillRectangle: self bounds fillStyle: self fillStyle.		^ aCanvas frameAndFillRectangle: bounds			fillColor: Color transparent			borderWidth: borderWidth			topLeftColor: color lighter			bottomRightColor: color darker].	borderColor == #inset ifTrue: [		insetColor _ owner colorForInsets.		aCanvas fillRectangle: self bounds fillStyle: self fillStyle.		^ aCanvas frameAndFillRectangle: bounds			fillColor: Color transparent			borderWidth: borderWidth			topLeftColor: insetColor darker			bottomRightColor: insetColor lighter].	"solid color border"	aCanvas fillRectangle: self bounds fillStyle: self fillStyle.	aCanvas frameAndFillRectangle: bounds		fillColor: Color transparent		borderWidth: borderWidth		borderColor: borderColor.! !!EllipseMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/18/1999 08:52'!drawOn: aCanvas 	aCanvas fillOval: bounds fillStyle: self fillStyle borderWidth: borderWidth borderColor: borderColor! !!EllipseMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:14'!initialize	super initialize.	borderColor _ Color black.	borderWidth _ 1.! !!EllipseMorph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:14'!canHaveFillStyles	"Return true if the receiver can have general fill styles; not just colors.	This method is for gradually converting old morphs."	^true! !!EllipseMorph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:14'!defaultColor	"Return the default fill style for the receiver"	^Color yellow! !!FlasherMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:16'!canHaveFillStyles	^false! !!HandMorph methodsFor: 'world menu commands' stamp: 'ar 6/18/1999 06:38'!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #maybeDuplicateMorph.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	"Give the argument control over what should be done about fill styles"	argMorph addFillStyleMenuItems: menu hand: self.	(argMorph morphsAt: targetOffset) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	World ifNil:		[menu add: 'inspect (in MVC)' action: #inspectMorph.		menu add: 'inspect' action: #inspectMorphInMorphic]		ifNotNil:		[menu add: 'inspect' action: #inspectMorph].	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'set variable name...' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandleMorph methodsFor: 'stepping' stamp: 'ar 6/18/1999 07:44'!startStepping	"Make the receiver the keyboard focus for editing"	super startStepping.	owner isHandMorph ifTrue:[owner newKeyboardFocus: self].! !!HandleMorph methodsFor: 'termination' stamp: 'ar 6/18/1999 07:51'!justDroppedInto: aMorph event: anEvent	"So that when the hand drops me (into the world) I go away"	anEvent hand keyboardFocus == self		ifTrue:[anEvent hand newKeyboardFocus: nil].	self changed.	self delete.! !!HandleMorph methodsFor: 'events' stamp: 'ar 6/18/1999 08:10'!keyStroke: evt	"Check for cursor keys"	| keyValue |	owner isHandMorph ifFalse:[^self].	keyValue _ evt keyValue.	keyValue = 28 ifTrue:[^self position: self position - (1@0)].	keyValue = 29 ifTrue:[^self position: self position + (1@0)].	keyValue = 30 ifTrue:[^self position: self position - (0@1)].	keyValue = 31 ifTrue:[^self position: self position + (0@1)].	"Special case for return"	keyValue = 13 ifTrue:[		"Drop the receiver and be done"		owner newKeyboardFocus: nil.		self delete].! !!OrientedFillStyle methodsFor: 'testing' stamp: 'ar 6/18/1999 07:57'!isOrientedFill	"Return true if the receiver keeps an orientation (e.g., origin, direction, and normal)"	^true! !!OrientedFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/18/1999 07:41'!addFillStyleMenuItems: aMenu hand: aHand from: aMorph	"Add the items for changing the current fill style of the receiver"	aMenu add: 'change origin' target: self selector: #changeOriginIn:event: argument: aMorph.	aMenu add: 'change orientation' target: self selector: #changeOrientationIn:event: argument: aMorph.! !!OrientedFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/18/1999 07:41'!changeOrientationIn: aMorph event: evt	"Interactively change the origin of the receiver"	| handle |	handle _ HandleMorph new forEachPointDo:[:pt|		self direction: pt - self origin.		self normal: nil.		aMorph changed].	evt hand attachMorph: handle.	handle startStepping.! !!OrientedFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/18/1999 07:28'!changeOriginIn: aMorph event: evt	"Interactively change the origin of the receiver"	| handle |	handle _ HandleMorph new forEachPointDo:[:pt|		self origin: pt.		aMorph changed].	evt hand attachMorph: handle.	handle startStepping.! !!BitmapFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/25/1999 12:05'!addFillStyleMenuItems: aMenu hand: aHand from: aMorph	"Add the items for changing the current fill style of the receiver"	aMenu add: 'choose new graphic' target: self selector: #chooseNewGraphicIn:event: argument: aMorph.	aMenu add: 'grab new graphic' target: self selector: #grabNewGraphicIn:event: argument: aMorph.	super addFillStyleMenuItems: aMenu hand: aHand from: aMorph.! !!BitmapFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/25/1999 11:55'!chooseNewGraphicIn: aMorph event: evt	"Used by any morph that can be represented by a graphic"	| reasonableForms aGraphicalMenu myGraphic |	reasonableForms _ (SketchMorph allSubInstances collect: [:m | m form]) asOrderedCollection.	reasonableForms addAll: (Smalltalk imageImports collect: [:f | f]).	reasonableForms addAll: (BitmapFillStyle allSubInstances collect:[:f| f form]).	reasonableForms _ reasonableForms asSet asOrderedCollection.	(reasonableForms includes: (myGraphic _ self form))		ifTrue:			[reasonableForms remove: myGraphic].	reasonableForms addFirst: myGraphic.	aGraphicalMenu _ GraphicalMenu new initializeFor: self withForms: reasonableForms coexist: true.	aGraphicalMenu selector: #newForm:forMorph:; argument: aMorph.	evt hand attachMorph: aGraphicalMenu.! !!BitmapFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/25/1999 12:06'!grabNewGraphicIn: aMorph event: evt	"Used by any morph that can be represented by a graphic"	self form: Form fromUser.	self direction: self form width @ 0.	self normal: 0 @ self form height.	aMorph changed.! !!BitmapFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/25/1999 11:57'!newForm: aForm forMorph: aMorph	self form: aForm.	self direction: (aForm width @ 0).	self normal: (0 @ aForm height).	aMorph changed.! !!GradientFillStyle methodsFor: 'private' stamp: 'ar 6/18/1999 08:42'!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver"	| bits lastColor lastIndex nextIndex nextColor distance theta color lastValue ramp |	ramp _ colorRamp asSortedCollection:[:a1 :a2| a1 key < a2 key].	bits _ Bitmap new: length.	lastColor _ ramp first value.	lastIndex _ 0.	ramp do:[:assoc|		nextIndex _ (assoc key * length) rounded.		nextColor _ assoc value.		distance _ (nextIndex - lastIndex).		distance = 0 ifTrue:[distance _ 1].		lastIndex+1 to: nextIndex do:[:i|			theta _ (i - lastIndex) asFloat / distance asFloat.			color _ nextColor alphaMixed: theta with: lastColor.			bits at: i put: (color pixelWordForDepth: 32).		].		lastIndex _ nextIndex.		lastColor _ nextColor.	].	lastValue _ lastColor pixelWordForDepth: 32.	lastIndex+1 to: length do:[:i| bits at: i put: lastValue].	^bits! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/25/1999 11:42'!addFillStyleMenuItems: aMenu hand: aHand from: aMorph	"Add the items for changing the current fill style of the receiver"	self isRadialFill ifTrue:[		aMenu add: 'linear gradient' target: self selector: #beLinearGradientIn: argument: aMorph.	] ifFalse:[		aMenu add: 'radial gradient' target: self selector: #beRadialGradientIn: argument: aMorph.	].	aMenu addLine.	aMenu add: 'change first color' target: self selector: #changeFirstColorIn:event: argument: aMorph.	aMenu add: 'change second color' target: self selector: #changeSecondColorIn:event: argument: aMorph.	aMenu addLine.	super addFillStyleMenuItems: aMenu hand: aHand from: aMorph.! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/18/1999 09:49'!addNewColorIn: aMorph event: evt	^self inform:'not yet implemented'! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/18/1999 07:25'!beLinearGradientIn: aMorph	self radial: false.	aMorph changed.! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/18/1999 07:25'!beRadialGradientIn: aMorph	self radial: true.	aMorph changed.! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/25/1999 11:38'!changeColorSelector: aSymbol hand: aHand morph: aMorph	| m box points b |	m _ ColorPickerMorph new		sourceHand: aHand;		target: self;		selector: aSymbol;		argument: aMorph.	box _ aMorph fullBounds.	points _ #(topCenter rightCenter bottomCenter leftCenter).  "possible anchors"	1 to: 4 do: [:i |  "Try the four obvious anchor points"		b _ m bounds				align: (m bounds perform: (points at: i))				with: (box perform: (points atWrap: i + 2)).		(aMorph worldBounds containsRect: b) ifTrue: [  "Yes, it fits"			m position: b topLeft.			aMorph world addMorphFront: m.			m changed.		^ m]].	"when all else fails..."	m position: 20@20.	aMorph currentWorld addMorphFront: m.	m changed.	^ m! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/25/1999 11:40'!changeFirstColorIn: aMorph event: evt	^self changeColorSelector: #firstColor:forMorph:hand: hand: evt hand morph: aMorph! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/25/1999 11:40'!changeSecondColorIn: aMorph event: evt	^self changeColorSelector: #lastColor:forMorph:hand: hand: evt hand morph: aMorph! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/25/1999 11:39'!firstColor: aColor forMorph: aMorph hand: aHand	colorRamp first value: aColor.	pixelRamp _ nil.	aMorph changed.! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'ar 6/25/1999 11:40'!lastColor: aColor forMorph: aMorph hand: aHand	colorRamp last value: aColor.	pixelRamp _ nil.	aMorph changed.! !!PolygonMorph methodsFor: 'initialization' stamp: 'ar 6/25/1999 11:17'!initialize	super initialize.	vertices _ Array with: 20@20 with: 40@30 with: 20@40.	borderWidth _ 2.	borderColor _ Color magenta.	closed _ true.	quickFill _ true.	arrows _ #none.	self computeBounds.! !!PolygonMorph methodsFor: 'drawing' stamp: 'ar 6/18/1999 09:14'!drawArrowOn: aCanvas at: endPoint from: priorPoint	"Draw a triangle oriented along the line from priorPoint to endPoint."	| d v pts angle |	d _ borderWidth max: 1.	v _ endPoint - priorPoint.	angle _ v theta radiansToDegrees.	pts _ Array with: (endPoint + (borderWidth//2) + (Point r: d*5 degrees: angle))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle + 135.0))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle - 135.0)).	aCanvas drawPolygon: pts fillStyle: borderColor.! !!PolygonMorph methodsFor: 'drawing' stamp: 'ar 6/18/1999 09:17'!drawArrowsOn: aCanvas	"ArrowForms are computed only upon demand"	(closed or: [arrows == #none or: [vertices size < 2]]) ifTrue:		[^ self]. "Nothing to do"	borderColor isColor ifFalse:[^self]. "Prevent crashes for #raised or #inset borders"	(arrows == #forward or: [arrows == #both]) 		ifTrue:[self drawArrowOn: aCanvas at: vertices last from: self nextToLastPoint].	(arrows == #back or: [arrows == #both])		ifTrue:[self drawArrowOn: aCanvas at: vertices first from: self nextToFirstPoint].! !!PolygonMorph methodsFor: 'drawing' stamp: 'ar 6/18/1999 09:35'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed ifTrue:[		quickFill			ifTrue:[aCanvas drawPolygon: self getVertices fillStyle: self fillStyle]			ifFalse:[aCanvas stencil: self filledForm at: bounds topLeft - 1 color: color]].	self drawBorderOn: aCanvas.	self drawArrowsOn: aCanvas.	"Old code:	closed & color isTransparent not		ifTrue: [aCanvas stencil: self filledForm at: bounds topLeft - 1 color: color].	(borderColor isColor and: [borderColor isTranslucentColor])		ifTrue: [aCanvas stencil: self borderForm at: bounds topLeft						color: borderColor]		ifFalse: [self drawBorderOn: aCanvas].	self arrowForms do:		[:f | aCanvas stencil: f at: f offset			color: (borderColor isColor ifTrue: [borderColor] ifFalse: [color])]	"! !!PolygonMorph methodsFor: 'private' stamp: 'ar 6/18/1999 09:35'!getVertices	^vertices! !!PolygonMorph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:18'!canHaveFillStyles	"Return true if the receiver can have general fill styles; not just colors.	This method is for gradually converting old morphs."	^true! !!PolygonMorph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:17'!defaultColor	"Return the default fill style for the receiver"	^Color orange! !!CurveMorph methodsFor: 'private' stamp: 'ar 6/18/1999 09:36'!getVertices	| vtx |	vtx _ WriteStream on: Array new.	self lineSegmentsDo:[:pt1 :pt2| vtx nextPut: pt1].	^vtx contents! !!RectangleMorph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:13'!canHaveFillStyles	"Return true if the receiver can have general fill styles; not just colors.	This method is for gradually converting old morphs."	^self class == RectangleMorph "no subclasses"! !!RectangleMorph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:13'!defaultColor	"Return the default fill style for the receiver"	^Color gray! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:54'!argument	^argument! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:54'!argument: anObject	argument _ anObject! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:53'!initialize	super initialize.	selector _ #newForm:.! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:54'!okay	| nArgs |	target ifNotNil:[		nArgs _ selector numArgs.		nArgs = 1 ifTrue:[target perform: selector with: (formChoices at: currentIndex)].		nArgs = 2 ifTrue:[target perform: selector with: (formChoices at: currentIndex) with: argument]].	coexistWithOriginal		ifTrue:			[self delete]		ifFalse:			[owner replaceSubmorph: self topRendererOrSelf by: target]! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:54'!selector	^selector! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:54'!selector: aSymbol	selector _ aSymbol! !!SketchMorph methodsFor: 'menu' stamp: 'ar 6/18/1999 06:40'!addFillStyleMenuItems: aMenu hand: aHand	"Do nothing here - we do not allow changing the fill style of a SketchMorph yet."! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'ar 6/25/1999 11:33'!argument	^argument! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'ar 6/25/1999 11:33'!argument: anObject	argument _ anObject! !!ColorPickerMorph methodsFor: 'private' stamp: 'ar 6/25/1999 11:33'!updateTargetColor	| nArgs |	(target ~~ nil and: [selector ~~ nil]) ifTrue:		[nArgs _ selector numArgs.		nArgs = 1 ifTrue:[^target perform: selector with: selectedColor].		nArgs = 2 ifTrue:[^target perform: selector with: selectedColor with: sourceHand].		nArgs = 3 ifTrue:[^target perform: selector with: selectedColor with: argument with: sourceHand]].! !!StarMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:18'!defaultColor	"Return the default fill style for the receiver"	^Color lightBlue! !!StarMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:19'!initialize	| pt ext oldR points |	super initialize.	borderWidth _ 1.	borderColor _ Color black.	pt _ 10@10.	ext _ pt r.	oldR _ ext.	points _ 5.	vertices _ (0 to: 359 by: (360//points//2)) collect: [:angle |		(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse:[ext]) degrees: angle + pt degrees)			+ (45@45)].	self computeBounds! !Morph removeSelector: #defaultFillStyle!BitmapFillStyle removeSelector: #chooseNewFormIn:!BitmapFillStyle removeSelector: #paintFormIn:!RectangleMorph removeSelector: #initialize!