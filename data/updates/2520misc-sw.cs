'From Squeak2.9alpha of 26 July 2000 [latest update: #2518] on 18 August 2000 at 2:53:43 pm'!"Change Set:		misc-swDate:			18 August 2000Author:			Scott Wallace(1)  Fixes the long-standing bug that a pluggableListMorph did not relinquish the keyboard focus on mouse leave.(2)  Spruces up the 'choose new graphic...' command for sketch morphs -- the set of alternatives offered is now very much more restricted and no longer includes duplicates; this is the command that users should use to regain earlier sketches that they may have lost through inadvertent costume changes, for example.(3)  Improves the balloon help for make-sibling-instance.(4)  Adds a menu item for user-written scripts in a viewer that allows direct launch of a standalone code pane from there.(5)	Decouples noviceMode preference from the eToyFriendly one.(6)	Also decouples  from the #noviceMode preference the decision about whether or not to offer the meta-menu preference.  The allow-meta-menu choice is now governed by a hard-coded preference, #metaMenuDisabled, intended to be recompiled programmatically by code needing to bulletproof the ui prior, for example, to use in a game."!!Morph methodsFor: 'menus' stamp: 'sw 8/16/2000 13:50'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	self maybeAddCollapseItemTo: aMenu.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	aMenu add: 'copy Postscript' action: #clipPostscript.	aMenu add: 'print PS to file...' target: self selector: #printPSToFile.	self player ifNotNil:		[aMenu addLine.		aMenu add: 'make a sibling instance' action: #makeNewPlayerInstance.		aMenu balloonTextForLastItem: 'Makes another morph whose player is of the same class as this one.  Both siblings will share the same scripts'].	aMenu addLine.	self addFillStyleMenuItems: aMenu hand: aHandMorph.	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu		defaultTarget: self;		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction.	aMenu addLine.	aMenu defaultTarget: self topRendererOrSelf.	aMenu add: 'draw new path' action: #definePath.	(self hasProperty: #pathPoints) ifTrue:		[aMenu add: 'follow path' action: #followPath.		aMenu add: 'delete path' action: #deletePath].	(owner == nil) ifFalse:		[aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'sw 8/18/2000 09:34'!chooseNewGraphicCoexisting: aBoolean	"Allow the user to choose a different form for her form-based morph"	| reasonableForms replacee aGraphicalMenu myGraphic |	reasonableForms _ (SketchMorph allInstances		select:			[:m | ((m owner isKindOf: SketchEditorMorph) or: [m owner isKindOf: IconicButton]) not]		thenCollect:			 [:m | m form]) asSet "eliminate duplicates" asOrderedCollection.	reasonableForms addAll: (Smalltalk imageImports collect: [:f | f]).	reasonableForms _ reasonableForms asSet asOrderedCollection.	(reasonableForms includes: (myGraphic _ self form))		ifTrue:			[reasonableForms remove: myGraphic].	reasonableForms addFirst: myGraphic.	aGraphicalMenu _ GraphicalMenu new initializeFor: self withForms: reasonableForms coexist: aBoolean.	aBoolean		ifFalse:			[replacee _ self topRendererOrSelf.			replacee owner replaceSubmorph: replacee by: aGraphicalMenu]		ifTrue:			[self primaryHand attachMorph: aGraphicalMenu]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/18/2000 13:26'!invokeMetaMenu: evt	"Invoke the meta menu. If the hand is over the background, the world menu is presented. If it is over a morph, a menu of operations for that morph is presented. Each menu entry contains a string to be presented in the menu and a selector. If the selector takes an argument, the mouse-down event that invoked the menu is passed as an argument. This lets the command know which hand invoked it in order to do things like attaching the result of the command to that hand.If the hand is over the background and the shift key is pressed, the find-window menu is immediately put up.If the hand is over the background but the yellow button was pressed, an alternate menu, which individual users are encouraged to personalize, is put up -- see HandMorph.yellowButtonClickOnDesktopWithEvent:"	| menu |	Preferences metaMenuDisabled ifTrue: [^ self].	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	self flag: #bob.		"do we need this?"	targetOffset _ menuTargetOffset _ self worldUnderCursor globalPointToLocal: self position.	argument _ self argumentOrNil.	argument == nil		ifTrue:			[Utilities bringFlapsToFront.			evt yellowButtonPressed				ifTrue: [^ self yellowButtonClickOnDesktopWithEvent: evt].			evt shiftPressed				ifFalse:					["put put screen menu"					menu _ self buildWorldMenu.					menu addTitle: 'World']				ifTrue:					[^ self findWindow]]		ifFalse:			[menu _ self buildMorphMenuFor: argument.			menu addTitle: argument class name].	menu popUpEvent: evt.! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/17/2000 12:59'!infoFor: anElement inViewer: aViewer	"The user made a gesture asking for info/menu relating"	| aMenu selector reply elementType |	elementType _ self elementTypeFor: anElement.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement inViewer: aViewer].		self flag: #deferred.  "Use a traditional MenuMorph, and reinstate the pacify thing"	aMenu _ MVCMenuMorph new.	(elementType == #userScript)		ifTrue: 			[aMenu add: 'destroy "', anElement, '"' action: #removeScript.			aMenu add: 'rename  "', anElement, '"' action: #renameScript.			aMenu add: 'textual scripting pane' action: #makeIsolatedCodePaneFor.			"aMenu add: 'pacify "', anElement, '"' action: #pacifyScript"].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: anElement asString, ' (', elementType, ')'.	selector _ anElement asSymbol.	reply _  aMenu invokeAt: aViewer primaryHand position in: aViewer world.	reply == nil ifTrue: [^ self].	reply == #removeScript ifTrue: [^ self removeScript: selector fromWorld: aViewer world].	reply == #renameScript ifTrue: [^ self renameScript:  selector].	reply == #makeIsolatedCodePaneFor ifTrue: 		[MethodHolder makeIsolatedCodePaneForClass: self class selector: selector].	reply == #pacifyScript ifTrue: [^ self pacifyScript: selector]! !!PluggableListMorph methodsFor: 'events' stamp: 'sw 8/16/2000 12:40'!mouseLeave: event	super mouseLeave: event.	event hand newKeyboardFocus: nil! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'sw 8/18/2000 13:26'!metaMenuDisabled	"If true, then click/cmd-click on the desktop will not bring up the World menu.  Can be changed manually right here, and can be programattically changed via a call of the following form:	Preferences compileHardCodedPref: #metaMenuDisabled enable: true"	^ false! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 8/16/2000 19:10'!customizeForEToyUsers: aBoolean	"If aBoolean is true, set things up for etoy users.  If it's false, unset some of those things.  Some things are set when switching into etoy mode but not reversed when switching out of etoy mode" 	#(			(balloonHelpEnabled			yes		dontReverse)		(debugHaloHandle			no		reverse)		(modalColorPickers			yes		dontReverse)		(roundCornersWherePossible	yes		dontReverse)		(uniqueNamesInHalos		yes		reverse)		(useUndo					yes		dontReverse)		(warnIfNoChangesFile		no		reverse)		(warnIfNoSourcesFile		no		reverse)) do:			[:trip |				(aBoolean or: [trip third == #reverse]) ifTrue:					[Preferences enableOrDisable: trip first asPer:						((trip second == #yes) & aBoolean) | ((trip second == #no) & aBoolean not)]]! !"Postscript:"Preferences disable: #noviceMode.!