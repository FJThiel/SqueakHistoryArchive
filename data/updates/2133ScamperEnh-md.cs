'From Squeak2.8alpha of 4 February 2000 [latest update: #2098] on 12 May 2000 at 10:41:42 am'!"Change Set:		056ScamperEnh-mdDate:			January & February 2000Author:			Bolot Kerimbaev, Marcus Denker, AKzMost code was written by Bolot but I decided that Marcus is the one to blaim in case that something break as he (re)posted everything to the list, assuring that he tested everything  :-)  --smaThis changeset removes the top-pane of Scamper (used for displaying the pagetitle). The page title is now shown in the SystemWindow title instead.   The change set also adds support for background color and/or image for Scamper. It includes code by AKz@phaidros.com, who fixed background image handling.Known issues (2/27/2000 21:24):- background image doesn't scroll with text  (in some cases, this is a desired behavior,  but those cases are rare)Enhances Scamper to support:- client side image maps- image buttons (form inputs)"!Morph subclass: #DownloadingImageMorph	instanceVariableNames: 'url altText defaultExtent image downloadQueue imageMapName formatter '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-HTML Formatter'!HtmlEntity subclass: #HtmlArea	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-HTML Parser Entities'!Object subclass: #HtmlFormatter	instanceVariableNames: 'browser baseUrl formDatas outputStream preformattedLevel indentLevel boldLevel italicsLevel underlineLevel strikeLevel centerLevel urlLink listLengths listTypes precedingSpaces precedingNewlines morphsToEmbed incompleteMorphs anchorLocations imageMaps '	classVariableNames: 'CSNonSeparators CSSeparators '	poolDictionaries: ''	category: 'Network-HTML Formatter'!HtmlEntity subclass: #HtmlMap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-HTML Parser Entities'!Model subclass: #Scamper	instanceVariableNames: 'status currentUrl pageSource document formattedPage downloadingProcess documentQueue recentDocuments currentAnchorLocation currentUrlIndex backgroundColor '	classVariableNames: 'StartUrl '	poolDictionaries: ''	category: 'Network-Web Browser'!PluggableTextMorph subclass: #WebPageMorph	instanceVariableNames: 'getBgSelector asColor image '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!Color class methodsFor: 'instance creation' stamp: 'bolot 12/1/1999 02:42'!fromString: aString	"for HTML color spec: #FFCCAA or white/black"	"Color fromString: '#FFCCAA'.	 Color fromString: 'white'.	 Color fromString: 'orange'"	| aColorHex red green blue |	aString ifNil: [^Color white].	aString first = $#		ifTrue: [aColorHex _ aString copyFrom: 2 to: aString size]		ifFalse: [aColorHex _ aString].	[aColorHex size = 6		ifTrue: [aColorHex _ aColorHex asUppercase.			red _ ('16r', (aColorHex copyFrom: 1 to: 2)) asNumber/255.			green _ ('16r', (aColorHex copyFrom: 3 to: 4)) asNumber/255.			blue _ ('16r', (aColorHex copyFrom: 5 to: 6)) asNumber/255.			^ self r: red g: green b: blue]]	ifError: [:err :rcvr | "not a hex color triplet" ].		"try to match aColorHex with known named colors"	aColorHex _ aColorHex asLowercase.	^self perform: (ColorNames detect: [:i | i asString asLowercase = aColorHex]		ifNone: [#white])	! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'bolot 11/2/1999 14:30'!altText: aString	"set the text to be displayed while downloading"	altText _ aString.	aString ifNotNil: [self setBalloonText: aString].	self setContents! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'bolot 2/27/2000 23:54'!setContents	"set up our morphic contents"	| imageMorph imageMap |	self removeAllMorphs.	image ifNil: [^self setNoImageContents].	imageMorph _ ImageMorph new.	(imageMapName notNil	and: [formatter notNil	and: [(imageMap _ formatter imageMapNamed: imageMapName) notNil]])		ifTrue: [imageMap buildImageMapForImage: imageMorph andBrowser: formatter browser].	imageMorph image: image.	imageMorph position: self position.	self addMorph: imageMorph.	imageMorph extent ~= self extent		ifTrue: [self extent: imageMorph extent].! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'bolot 2/28/2000 00:14'!setNoImageContents	"set up our morphic contents in case image download/decoding failed"	| stringMorph outlineMorph extent |	altText isEmptyOrNil		ifTrue: [ self extent: 0@0. "don't display anything..." ^self ].	stringMorph _ StringMorph new.	stringMorph contents: altText.	stringMorph position: self position+(2@2).	self addMorph: stringMorph.	outlineMorph _ RectangleMorph new.	outlineMorph borderWidth: 1.	outlineMorph color: Color transparent.	outlineMorph position: self position.	"figure out how big to make the box"	extent _ defaultExtent ifNil: [ 0 @ 0 ].	stringMorph width + 4 > extent x ifTrue: [		extent _ (stringMorph width + 4) @ extent y ].	stringMorph height + 4 > extent y ifTrue: [		extent _ extent x @ (stringMorph height + 4) ].	outlineMorph extent: extent.	self addMorph: outlineMorph.	self extent: outlineMorph extent! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'bolot 11/30/1999 23:22'!step	| doc |	downloadQueue size > 0 ifTrue: [		doc _ downloadQueue next.		doc mainType = 'image' 		ifTrue: [			[image _ ImageReadWriter  formFromStream: doc contentStream binary]				ifError: [:err :rcvr | "ignore" image _ nil].			self setContents ] ].! !!DownloadingImageMorph methodsFor: 'accessing' stamp: 'bolot 2/27/2000 23:38'!formatter	^formatter! !!DownloadingImageMorph methodsFor: 'accessing' stamp: 'bolot 2/27/2000 23:38'!formatter: aFormatter	formatter _ aFormatter! !!DownloadingImageMorph methodsFor: 'accessing' stamp: 'bolot 2/27/2000 23:34'!imageMapName	^imageMapName! !!DownloadingImageMorph methodsFor: 'accessing' stamp: 'bolot 2/27/2000 23:35'!imageMapName: aString	imageMapName _ aString! !!HtmlEntity methodsFor: 'testing' stamp: 'bolot 11/4/1999 04:42'!isArea	^false! !!HtmlArea methodsFor: 'accessing' stamp: 'bolot 11/3/1999 17:48'!coords	^self getAttribute: 'coords'! !!HtmlArea methodsFor: 'accessing' stamp: 'bolot 11/3/1999 17:48'!href	^self getAttribute: 'href'! !!HtmlArea methodsFor: 'accessing' stamp: 'bolot 11/3/1999 17:48'!shape	^self getAttribute: 'shape'! !!HtmlArea methodsFor: 'testing' stamp: 'bolot 11/4/1999 04:43'!isArea	^true! !!HtmlArea methodsFor: 'testing' stamp: 'bolot 11/3/1999 18:06'!mayContain: anEntity	^false! !!HtmlArea methodsFor: 'testing' stamp: 'bolot 11/3/1999 17:47'!tagName	^'area'! !!HtmlArea methodsFor: 'formatting' stamp: 'bolot 2/27/2000 22:18'!buildMorph	"construct a hot-spot morph"	| coords vertices radiusX radiusY |	coords _ (self coords findTokens: ', ') collect: [:elem | elem asNumber asInteger].	self shape isEmptyOrNil		ifTrue: [^nil].	(self shape asLowercase beginsWith: 'poly')		ifTrue: [coords size even ifFalse: [^nil].			vertices _ OrderedCollection new.			coords pairsDo: [:x :y |				vertices add: x @ y].			^(PolygonMorph vertices: vertices color: Color transparent				borderWidth: 1 borderColor: Color transparent) quickFill: false; makeClosed].	(coords size > 4 or: [coords size < 3])		ifTrue: [^nil].	self shape asLowercase = 'circle'		ifTrue: [radiusX _ coords third.			radiusY _ coords last.			^(EllipseMorph newBounds:				(((coords first - radiusX) @ (coords second - radiusY))				extent:				((2 * radiusX) @ (2 * radiusY)))			color: Color transparent) borderColor: Color transparent].	coords size = 4		ifFalse: [^nil].	(self shape asLowercase beginsWith: 'rect')		ifTrue: [^(RectangleMorph newBounds:				(Rectangle origin: (coords first @ coords second)				corner: (coords third @ coords last))			color: Color transparent) borderColor: Color transparent].	^nil! !!HtmlArea methodsFor: 'formatting' stamp: 'bolot 2/28/2000 00:30'!linkMorphForMap: map andBrowser: browser	| m |	(m _ self buildMorph) ifNil: [^nil].	m color: (Color random alpha: 0.1). "hack to ensure the morph is clickable"	m		on: #mouseUp		send: #mouseUpEvent:linkMorph:browserAndUrl:		to: map		withValue: {browser. self href}.	^m! !!HtmlBody methodsFor: 'attributes' stamp: 'bolot 12/8/1999 01:40'!background	^self getAttribute: 'background' default: nil! !!HtmlBody methodsFor: 'attributes' stamp: 'bolot 12/8/1999 01:41'!bgcolor	^self getAttribute: 'bgcolor' default: 'white'! !!HtmlFormatter methodsFor: 'private-initialization' stamp: 'bolot 11/4/1999 00:36'!initialize	outputStream _ AttributedTextStream new.	preformattedLevel _ 0.	indentLevel _ boldLevel _ italicsLevel _ underlineLevel _ strikeLevel _ centerLevel _ 0.	listLengths _ OrderedCollection new.	listTypes _ OrderedCollection new.	formDatas _ OrderedCollection new.	precedingSpaces _ 0.	precedingNewlines _ 1000.   "more than will ever be asked for"	morphsToEmbed _ OrderedCollection new.	incompleteMorphs _ OrderedCollection new.	anchorLocations _ Dictionary new.	imageMaps _ OrderedCollection new.	outputStream nextPut: Character cr.! !!HtmlFormatter methodsFor: 'image maps' stamp: 'bolot 11/4/1999 00:36'!addImageMap: anImageMap	imageMaps addLast: anImageMap! !!HtmlFormatter methodsFor: 'image maps' stamp: 'bolot 11/4/1999 00:37'!imageMapNamed: imageMapName	^imageMaps detect: [:im | im name asLowercase = imageMapName asLowercase] ifNone: []! !!HtmlImage methodsFor: 'attributes' stamp: 'bolot 11/30/1999 00:42'!imageMapName	| imageMapName |	(imageMapName _ self getAttribute: 'usemap')		ifNil: [^nil].	imageMapName first = $#		ifTrue: [imageMapName _ imageMapName copyFrom: 2 to: imageMapName size].	^imageMapName! !!HtmlImage methodsFor: 'formatting' stamp: 'bolot 2/27/2000 23:45'!addToFormatter: formatter	| morph url |	self src isNil ifTrue: [ ^self ].	url _ self src.	formatter baseUrl ifNotNil: [ 		url _ url asUrlRelativeTo: formatter baseUrl ].	morph _ DownloadingImageMorph new.	morph defaultExtent: self imageExtent.	morph altText: self alt.	morph url: url.	self imageMapName		ifNotNil:			[morph imageMapName: self imageMapName.			morph formatter: formatter].	formatter addIncompleteMorph: morph.! !!HtmlInput methodsFor: 'formatting' stamp: 'bolot 2/28/2000 00:00'!addImageButtonToFormatter: formatter	"is it a submit button?"	| formData imageUrl morph |	(imageUrl _ self getAttribute: 'src') ifNil: [^self].	formatter baseUrl		ifNotNil: [imageUrl _ imageUrl asUrlRelativeTo: formatter baseUrl].	morph _ DownloadingImageMorph new.	morph defaultExtent: self imageExtent.	morph altText: self alt.	morph url: imageUrl.	value _ self getAttribute: 'name' default: 'Submit'.	formData _ formatter currentFormData.	morph		on: #mouseUp		send: #mouseUpEvent:linkMorph:formData:		to: self		withValue: formData.	formatter addIncompleteMorph: morph! !!HtmlInput methodsFor: 'morphic' stamp: 'bolot 2/27/2000 23:18'!mouseUpEvent: event linkMorph: linkMorph formData: formData	| aPoint |	aPoint _ event cursorPoint - linkMorph topLeft.	formData addInput: (HiddenInput name: (value, '.x') value: aPoint x asInteger asString).	formData addInput: (HiddenInput name: (value, '.y') value: aPoint y asInteger asString).	formData submit! !!HtmlMap methodsFor: 'formatting' stamp: 'bolot 11/4/1999 00:37'!addToFormatter: formatter	super addToFormatter: formatter.	formatter addImageMap: self! !!HtmlMap methodsFor: 'accessing' stamp: 'bolot 11/3/1999 17:55'!name	^self getAttribute: 'name'! !!HtmlMap methodsFor: 'testing' stamp: 'bolot 11/4/1999 04:42'!mayContain: anEntity	^anEntity isArea! !!HtmlMap methodsFor: 'testing' stamp: 'bolot 11/3/1999 17:47'!tagName	^'map'! !!HtmlMap methodsFor: 'morphic' stamp: 'bolot 2/27/2000 23:42'!buildImageMapForImage: imageMorph andBrowser: browser	| areaMorph |	contents do: [:area |		(area isArea		and: [(areaMorph _ area linkMorphForMap: self andBrowser: browser) isNil not])			ifTrue: [imageMorph addMorph: areaMorph]].	^imageMorph! !!HtmlMap methodsFor: 'morphic' stamp: 'bolot 2/27/2000 23:07'!mouseUpEvent: event linkMorph: linkMorph browserAndUrl: browserAndUrl	"this is an image map area, just follow the link"	| browser url |	browser _ browserAndUrl first.	url _ browserAndUrl second.	browser jumpToUrl: url! !!HtmlParser class methodsFor: 'parsing' stamp: 'bolot 12/1/1999 02:46'!parseTokens: tokenStream	|  entityStack document head token matchesAnything entity body |	entityStack _ OrderedCollection new.	"set up initial stack"	document _ HtmlDocument new.	entityStack add: document.		head _ HtmlHead new.	document addEntity: head.	entityStack add: head.	"go through the tokens, one by one"	[ token _ tokenStream next.  token = nil ] whileFalse: [		(token isTag and: [ token isNegated ]) ifTrue: [			"a negated token"			(token name ~= 'html' and: [ token name ~= 'body' ]) ifTrue: [				"see if it matches anything in the stack"				matchesAnything _ (entityStack detect: [ :e | e tagName = token name ] ifNone: [ nil ]) isNil not.				matchesAnything ifTrue: [					"pop the stack until we find the right one"					[ entityStack last tagName ~= token name ] whileTrue: [ entityStack removeLast ].					entityStack removeLast.				]. ] ]		ifFalse: [			"not a negated token.  it makes its own entity"			token isComment ifTrue: [				entity _ HtmlCommentEntity new initializeWithText: token source.			].			token isText ifTrue: [				entity _ HtmlTextEntity new text: token text.				(((entityStack last shouldContain: entity) not) and: 					[ token source isAllSeparators ]) ifTrue: [					"blank text may never cause the stack to back up"					entity _ HtmlCommentEntity new initializeWithText: token source ].			].			token isTag ifTrue: [				entity _ token entityFor.				entity = nil ifTrue: [ entity _ HtmlCommentEntity new initializeWithText: token source ] ].			(token name = 'body')				ifTrue: [body ifNotNil: [document removeEntity: body].					body _ HtmlBody new initialize: token.					document addEntity: body.					entityStack add: body].			entity = nil ifTrue: [ self error: 'could not deal with this token' ].			entity isComment ifTrue: [				"just stick it anywhere"				entityStack last addEntity: entity ]			ifFalse: [				"only put it in something that is valid"				[ entityStack last mayContain: entity ] 					whileFalse: [ entityStack removeLast ].				"if we have left the head, create a body"									(entityStack size < 2 and: [body isNil]) ifTrue: [					body _ HtmlBody new.					document addEntity: body.					entityStack add: body  ].				"add the entity"				entityStack last addEntity: entity.				entityStack addLast: entity.			].		]].	body == nil ifTrue: [		"add an empty body"		body _ HtmlBody new.		document addEntity: body ].	document parsingFinished.	^document! !!HtmlTag class methodsFor: 'parser support' stamp: 'bolot 11/3/1999 17:52'!entityClasses	"a Dictionary mapping tag names into the correct entity class"	"EntityClasses _ nil"	EntityClasses isNil ifFalse: [ ^EntityClasses ].	EntityClasses _ Dictionary new.	#( 		frameset	HtmlFrame		frame	HtmlFrame		title		HtmlTitle		style	HtmlStyle		meta	HtmlMeta		p		HtmlParagraph		form	HtmlForm		blockquote	HtmlBlockQuote		input	HtmlInput		textarea	HtmlTextArea		select	HtmlSelect		optgroup	HtmlOptionGroup		option		HtmlOption		img		HtmlImage		embed	HtmlEmbedded		noembed	HtmlNoEmbed		a		HtmlAnchor		br		HtmlBreak		map	HtmlMap		area	HtmlArea		li		HtmlListItem		dd		HtmlDefinitionDefinition		dt		HtmlDefinitionTerm		ol		HtmlOrderedList		ul		HtmlUnorderedList		dl		HtmlDefinitionList		h1		HtmlHeader		h2		HtmlHeader		h3		HtmlHeader		h4		HtmlHeader		h5		HtmlHeader		h6		HtmlHeader		hr		HtmlHorizontalRule		strong	HtmlBoldEntity		b		HtmlBoldEntity		em		HtmlItalicsEntity		i		HtmlItalicsEntity		dfn 	HtmlItalicsEntity		u		HtmlUnderlineEntity 		tt		HtmlFixedWidthEntity		kbd		HtmlFixedWidthEntity				strike	HtmlStrikeEntity		big		HtmlBiggerFontEntity		small	HtmlSmallerFontEntity		sub		HtmlSubscript		sup		HtmlSuperscript		font	HtmlFontEntity		pre		HtmlPreformattedRegion 		table	HtmlTable		tr		HtmlTableRow		td		HtmlTableDataItem 		th		HtmlTableHeader		) pairsDo: [ 			:tagName :className |			EntityClasses at: tagName asString put: (Smalltalk at: className) ].	^EntityClasses ! !!Scamper methodsFor: 'access' stamp: 'bolot 2/27/2000 20:59'!backgroundColor	^backgroundColor ifNil:		[self defaultBackgroundColor]! !!Scamper methodsFor: 'access' stamp: 'bolot 2/27/2000 20:59'!defaultBackgroundColor	^Color white! !!Scamper methodsFor: 'access' stamp: 'md 10/7/1999 09:04'!labelString	"return the title of the current page, or nil if there is none"	document == nil		ifTrue: [ ^'Scamper' ]		ifFalse: [ ^'Scamper: ' , self document head title ifNil: ['Scamper: (untitled)'] ]! !!Scamper methodsFor: 'stepping' stamp: 'bolot 2/27/2000 21:06'!step	"check if a new document has arrived"	| results |	[documentQueue isEmpty] whileFalse: [		results _ documentQueue next.		results == #stateDownloaded ifTrue: [ 			"images and such have been downloaded; update the page"			self status: 'reformatting page...'.			formattedPage _ document formattedTextForBrowser: self defaultBaseUrl: currentUrl.			backgroundColor _ Color fromString: document body bgcolor.			self changeAll: #(backgroundColor formattedPage).			self status: 'sittin'. ]		 ifFalse: [					self displayDocument: results 			] ]! !!Scamper methodsFor: 'user interface' stamp: 'md 5/11/2000 19:20'!openAsMorph	"open a set of windows for viewing this browser"	|win urlMorph |	"create a window for it"	win _ SystemWindow labelled: 'Scamper'.	win model: self.	win setProperty: #webBrowserView toValue: true.	"create a view of the current url"	"win addMorph: (RectangleMorph new) frame: (0@0 extent: 0.3@0.1)."	urlMorph _  PluggableTextMorph on: self text: #currentUrl accept: #jumpToAbsoluteUrl:.	urlMorph acceptOnCR: true.	win addMorph: urlMorph frame: (0@0 extent: 1@0.1).	"create a status view"	win addMorph: (PluggableTextMorph on: self text: #status accept: nil) frame: (0@0.9 extent: 1.0@0.1).	"create the text area"	win addMorph: (WebPageMorph on: self bg: #backgroundColor text: #formattedPage readSelection: #formattedPageSelection menu: #menu:shifted:)		frame: (0@0.1 extent: 1@0.8).		win openInWorld.	^win! !!Scamper methodsFor: 'document handling' stamp: 'md 5/11/2000 19:12'!displayFlashPage: newSource	"A shockwave flash document -- embed it in a text"	| attrib stream player |	stream _ (RWBinaryOrTextStream with: newSource content) binary reset.	(FlashFileReader canRead: stream) ifFalse:[^false]. "Not a flash file"	player _ (FlashMorphReader on: stream) processFileAsync.	player sourceUrl: newSource url.	player startPlaying.	attrib _ TextAnchor new anchoredMorph: player.	formattedPage _ ' * ' asText.	backgroundColor _ self defaultBackgroundColor.	formattedPage addAttribute: attrib from: 2 to: 2.	currentUrl _ newSource url.	pageSource _ newSource content.	"remove it from the history--these thigns are too big!!"	"ideally, there would be a smarter history mechanism that can do things like remove items when memory consumption gets too high....""	recentDocuments removeLast."	self changeAll: 	#(currentUrl relabel hasLint lint backgroundColor formattedPage formattedPageSelection).	self status: 'sittin'.	^true! !!Scamper methodsFor: 'document handling' stamp: 'md 5/11/2000 19:14'!displayImagePage: newSource	"an image--embed it in a text"	| image imageMorph attrib text handled |	handled _ true.	backgroundColor _ self defaultBackgroundColor.	formattedPage _ [		image _ ImageReadWriter formFromStream: (RWBinaryOrTextStream with: newSource content) binary reset.		imageMorph _ ImageMorph new image: image.		attrib _ TextAnchor new anchoredMorph: imageMorph.		text _ ' * ' asText.		text addAttribute: attrib from: 2 to: 2.		text] ifError: [ :msg :ctx | handled _ false ].	currentUrl _ newSource url.	pageSource _ newSource content.	"remove it from the history--these thigns are too big!!"	"ideally, there would be a smarter history mechanism that can do things like remove items when memory consumption gets too high....""	recentDocuments removeLast."	self changeAll: 	#(currentUrl relabel hasLint lint backgroundColor formattedPage formattedPageSelection).	self status: 'sittin'.	^handled! !!Scamper methodsFor: 'document handling' stamp: 'md 5/11/2000 19:15'!displayPlainTextPage: newSource	"treat as plain text"	pageSource _ newSource content.	document _ nil.	formattedPage _ pageSource withSqueakLineEndings.	backgroundColor _ self defaultBackgroundColor.	currentUrl _ newSource url.	self status: 'sittin'.	self changeAll: 	#(currentUrl relabel hasLint lint formattedPage formattedPageformattedPageSelection).	^true! !!Scamper methodsFor: 'document handling' stamp: 'md 5/11/2000 19:17'!displayTextHtmlPage: newSource	"HTML page--format it"	| formatter bgimageUrl bgimageDoc bgimage |	currentUrl _ newSource url.	pageSource _ newSource content isoToSqueak.	self status: 'parsing...'.	document _ (HtmlParser parse: (ReadStream on: pageSource)).	self status: 'laying out...'.	formatter _ HtmlFormatter new.	formatter browser: self.	formatter baseUrl: currentUrl.	document addToFormatter: formatter.	formattedPage _ formatter text.	(bgimageUrl _ document body background)		ifNotNil:			[bgimageDoc _ (bgimageUrl asUrlRelativeTo: currentUrl) retrieveContents.			[bgimage _ ImageReadWriter formFromStream: bgimageDoc contentStream binary]				ifError: [:err :rcvr | "ignore" bgimage _ nil]].	bgimage		ifNotNil: [backgroundColor _ bgimage]		ifNil: [backgroundColor _ Color fromString: document body bgcolor].	currentUrl fragment		ifNil: [ currentAnchorLocation _ nil ]		ifNotNil: [ currentAnchorLocation _				formatter anchorLocations 					at: currentUrl fragment asLowercase					ifAbsent: [ nil ] ].	self startDownloadingMorphState: (formatter incompleteMorphs).	self changeAll: 	#(currentUrl relabel hasLint lint backgroundColor formattedPage formattedPageSelection).	^true! !!Scamper methodsFor: 'change/update' stamp: 'bolot 2/27/2000 21:05'!invalidateLayout	self changeAll: #( backgroundColor formattedPage formattedPageSelection ).! !!WebPageMorph methodsFor: 'change reporting' stamp: 'AK 12/7/1999 01:31'!layoutChanged		"Udate the image and compute new bounds"		self changed.		self update: getBgSelector.		super layoutChanged.		self changed.! !!WebPageMorph methodsFor: 'model access' stamp: 'AK 12/4/1999 01:27'!getBg	"Retrieve the current model background color/image"	getBgSelector == nil ifTrue: [^Color white].	^ (model perform: getBgSelector) ifNil: [Color white]	! !!WebPageMorph methodsFor: 'updating' stamp: 'AK 12/7/1999 01:34'!update: aSymbol	super update: aSymbol.	aSymbol == getBgSelector ifTrue:		[ (self isImage: self getBg) ifTrue:[image _ self drawImage: self getBg]								ifFalse:[ image _ nil.										self color: self getBg]]! !!WebPageMorph methodsFor: 'other' stamp: 'AK 12/7/1999 01:10'!drawImage: aForm 	| aImage patternBox targetBox map |	aImage _ Form extent: self extent depth: Display depth.	patternBox _ aForm boundingBox.	targetBox _ aImage boundingBox.	map _ aForm colormapIfNeededForDepth: aImage depth.	targetBox left to: targetBox right - 1 by: patternBox width do:		[:x |		targetBox top to: targetBox bottom - 1 by: patternBox height do:			[:y | aImage copyBits: patternBox from: aForm at: x @ y colorMap: map ]].	^aImage! !!WebPageMorph methodsFor: 'other' stamp: 'AK 12/4/1999 02:24'!isImage: aForm		(aForm isKindOf: Form) ifFalse:[^false].		^true! !!WebPageMorph methodsFor: 'initialization' stamp: 'AK 12/7/1999 01:25'!on: aModel bg: getBgSel text: getTextSel readSelection: getSelectionSel menu: getMenuSel		self on: aModel text: getTextSel accept: nil readSelection: getSelectionSel menu: getMenuSel.	getBgSelector _ getBgSel.		! !!WebPageMorph methodsFor: 'drawing' stamp: 'AK 12/4/1999 02:37'!drawOn: aCanvas		super drawOn: aCanvas.			image = nil ifFalse:[aCanvas image: image at: bounds origin].! !!WebPageMorph class methodsFor: 'instance creation' stamp: 'AK 12/4/1999 02:50'!on: model bg: getBgSel text: getTextSel readSelection: getSelectionSel menu: getMenuSel	^self new on: model		bg: getBgSel		text: getTextSel		readSelection: getSelectionSel		menu: getMenuSel! !Scamper removeSelector: #title!"Postscript:Initialize the HtmlTag's class variable, EntityClasses.EntityClasses maps tag names to classes that handle them.Additions: HtmlMap and HtmlArea."HtmlTag initialize.!