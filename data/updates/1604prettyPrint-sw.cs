'From Squeak2.6 of 11 October 1999 [latest update: #1595] on 9 November 1999 at 9:15:32 pm'!"Change Set:		prettyPrint-swDate:			9 November 1999Author:			Scott WallaceAdds a new preference, colorWhenPrettyPrinting, which, if true, dictates that when pretty-printing, the color option should be used,Makes it possible directly to request, for any code being viewed,  immediate display of pretty-print in either classic (monochrome) or fancy (polychrome) form, via two menu items in the code-pane menu.When submitting code in polychrome pretty-print mode, bypass the prompt warning about first use of style, provided that the only text attributes used are cosmetic.For the FileContentsBrowser, adds a way (in morphic) that the showing of diffs can be turned off, allowing pretty-printing to show through."!!Browser methodsFor: 'message list' stamp: 'sw 11/6/1999 22:57'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector method tempNames |	contents == nil ifFalse: [^ contents copy].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector ifAbsent: [nil].	currentCompiledMethod _ method.	(Sensor controlKeyPressed		or: [method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil]])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents _ (class decompilerClass new decompile: selector in: class method: method)			decompileString.		^ contents copy].	Sensor leftShiftDown ifTrue:		["Special request to decompile -- get temps from source file"		tempNames _ (class compilerClass new						parse: method getSourceFromFile asString in: class notifying: nil)						tempNames.		contents _ ((class decompilerClass new withTempNames: tempNames)				decompile: selector in: class method: method) decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	contents _ class sourceCodeAt: selector.	Preferences browseWithPrettyPrint ifTrue:		[contents _ class compilerClass new			format: contents in: class notifying: nil decorated: Preferences colorWhenPrettyPrinting].	self showDiffs ifTrue:		[contents _ self diffFromPriorSourceFor: contents].	contents _ contents asText makeSelectorBoldIn: class.	^ contents copy! !!ChangeSorter methodsFor: 'code pane' stamp: 'sw 11/6/1999 23:07'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ contents _ myChangeSet preambleString ifNil: ['']].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents _ 'Added then removed (see versions)'].			class ifNil: [^ contents _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents _ 'Method was added, but cannot be found!!'].			contents _ class sourceCodeAt: sel.			Preferences browseWithPrettyPrint ifTrue:				[contents _ class compilerClass new					format: contents in: class notifying: nil decorated: Preferences colorWhenPrettyPrinting].			^ contents _ contents asText makeSelectorBoldIn: class]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do: [:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was added or changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				"each = #add ifTrue: [strm nextPutAll: 'Entire class was added.'; cr].					...this last a disused branch... #add not produced by change-mgt system any more,"]].			^ contents _ strm contents].! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 11/6/1999 23:08'!reformatMethodAt: selector 	| newCodeString method | 	newCodeString _ (self compilerClass new)		format: (self sourceCodeAt: selector)		in: self		notifying: nil		decorated: false.	method _ self compiledMethodAt: selector.	method		putSource: newCodeString		fromParseNode: nil		class: self		category: (self organization categoryOfElement: selector)		inFile: 2 priorMethod: method! !!Compiler methodsFor: 'public access' stamp: 'sw 11/7/1999 00:11'!format: textOrStream in: aClass notifying: aRequestor decorated: aBoolean	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^ nil].	^ aBoolean		ifTrue: [aNode decompileText]		ifFalse: [aNode decompileString]! !!Debugger methodsFor: 'context stack (message list)' stamp: 'sw 11/6/1999 22:58'!selectedMessage	"Answer the source code of the currently selected context."	contents _ [self selectedContext sourceCode] ifError: [ :err :rcvr |		'ERROR"',(err reject: [ :each | each == $"]),'"'	].	Preferences browseWithPrettyPrint ifTrue: [contents _ self selectedClass compilerClass new					format: contents					in: self selectedClass					notifying: nil					decorated: Preferences colorWhenPrettyPrinting].	^ contents _ contents asText makeSelectorBoldIn: self selectedClass! !!FileContentsBrowser methodsFor: 'edit pane' stamp: 'sw 11/9/1999 19:26'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	contents _ class sourceCodeAt: selector.	Preferences browseWithPrettyPrint ifTrue: [contents _ Compiler new					format: contents					in: class					notifying: nil					decorated: Preferences colorWhenPrettyPrinting].	self showDiffs ifTrue:		[contents _ self			methodDiffFor: contents			class: self selectedClass			selector: self selectedMessageName			meta: self metaClassIndicated].	^ contents asText makeSelectorBoldIn: class! !!FileContentsBrowser methodsFor: 'creation' stamp: 'sw 11/9/1999 18:21'!createViews	"Create a pluggable version of all the views for a Browser, including views and controllers."	| hasSingleFile width topView packageListView classListView switchView messageCategoryListView messageListView browserCodeView infoView |	showDiffs _ true.	Smalltalk isMorphic ifTrue: [^ self openAsMorph].	(hasSingleFile _ self packages size = 1)		ifTrue: [width _ 150]		ifFalse: [width _ 200].	(topView _ StandardSystemView new) 		model: self;		borderWidth: 1.		"label and minSize taken care of by caller"		hasSingleFile 		ifTrue: [			self systemCategoryListIndex: 1.			packageListView _ PluggableListView on: self				list: #systemCategorySingleton				selected: #indexIsOne 				changeSelected: #indexIsOne:				menu: #packageListMenu:.			packageListView window: (0 @ 0 extent: width @ 12)]		ifFalse: [			packageListView _ PluggableListView on: self				list: #systemCategoryList				selected: #systemCategoryListIndex				changeSelected: #systemCategoryListIndex:				menu: #packageListMenu:.			packageListView window: (0 @ 0 extent: 50 @ 70)].	topView addSubView: packageListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 50 @ 62).	hasSingleFile 		ifTrue: [topView addSubView: classListView below: packageListView]		ifFalse: [topView addSubView: classListView toRightOf: packageListView].	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: width@110).	topView 		addSubView: browserCodeView 		below: (hasSingleFile 			ifTrue: [switchView]			ifFalse: [packageListView]).	infoView _ StringHolderView new		model: self infoString;		window: (0@0 extent: width@12);		borderWidth: 1.	topView addSubView: infoView below: browserCodeView.	^ topView! !!FileContentsBrowser methodsFor: 'menus' stamp: 'sw 11/9/1999 18:26'!addModelItemsToWindowMenu: aMenu	aMenu addLine.	aMenu add: 		(self showDiffs ifTrue: ['stop showing diffs'] ifFalse: ['start showing diffs'])			  target: self action: #toggleDiffing ! !!MessageSet methodsFor: 'contents' stamp: 'sw 11/6/1999 22:53'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		source _ class sourceMethodAt: selector ifAbsent:			[currentCompiledMethod _ nil.			^ 'Missing'].		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil decorated: Preferences colorWhenPrettyPrinting].		self showDiffs ifTrue:			[source _ self diffFromPriorSourceFor: source].		^ source asText makeSelectorBoldIn: class]! !!LinkedMessageSet methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 18:15'!selectedMessage	"Answer the source method for the currently selected message.  Allow class comment, definition, and hierarchy."	| source |	self setClassAndSelectorIn: [:class :selector | 		selector first isUppercase ifFalse:			[source _ class sourceMethodAt: selector.			currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil]..			^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass].		selector = #Comment ifTrue: [^ class comment].		selector = #Definition ifTrue: [^ class definition].		selector = #Hierarchy ifTrue: [^ class printHierarchy].		source _ class sourceMethodAt: selector.		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil decorated: Preferences colorWhenPrettyPrinting].		^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 11/7/1999 00:07'!prettyPrint	"Reformat the contents of the receiver's view, formatted, if the view is unlocked. "	| selectedClass aCompiler newText |	model selectedMessageName ifNil: [^ view flash].	model okToChange ifFalse: [^ view flash].	selectedClass _ model selectedClassOrMetaClass.		aCompiler _ selectedClass compilerClass new.		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		newText _ aCompiler			format: model contents			in: selectedClass			notifying: nil			decorated: false.		newText == nil ifFalse: 			[self replaceSelectionWith:				(newText asText makeSelectorBoldIn: selectedClass).			self selectAt: 1].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 11/7/1999 00:07'!prettyPrintWithColor	"Reformat the contents of the receiver's view, formatted, if the view is unlocked. "	| selectedClass aCompiler newText |	model selectedMessageName ifNil: [^ view flash].	model okToChange ifFalse: [^ view flash].	selectedClass _ model selectedClassOrMetaClass.		aCompiler _ selectedClass compilerClass new.		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		newText _ aCompiler			format: model contents			in: selectedClass			notifying: nil			decorated: true.		newText == nil ifFalse: 			[self replaceSelectionWith:				(newText asText makeSelectorBoldIn: selectedClass).			self selectAt: 1].! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'sw 11/8/1999 17:19'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down"	^ SelectionMenu fromArray: #(		('set font... (k)'					offerFontMenu)		('set style... (K)'					changeStyle)		('set alignment...'				chooseAlignment)		-		('explain'						explain)		('pretty print'					prettyPrint)		('pretty print with color'		prettyPrintWithColor)		('file it in'						fileItIn)		('recognizer (r)'					recognizeCharacters)		('spawn (o)'						spawn)		-		('browse it (b)'					browseIt)		('senders of it (n)'				sendersOfIt)		('implementors of it (m)'		implementorsOfIt)		('references to it (N)'			referencesToIt)		('selectors containing it (W)'		methodNamesContainingIt)		('method strings with it (E)'		methodStringsContainingit)		('method source with it'			methodSourceContainingIt)		-		('special menu...'				presentSpecialMenu)		('more...'						yellowButtonActivity))! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 11/7/1999 00:01'!prettyPrint	self handleEdit: [textMorph editor prettyPrint]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 11/7/1999 00:01'!prettyPrintWithColor	self handleEdit: [textMorph editor prettyPrintWithColor]! !!Preferences class methodsFor: 'help' stamp: 'sw 11/6/1999 22:38'!initHelpMsgsC	"Automatically called whenever you call   	Preferences initializeHelpMessages		or	Preferences callHelpMessageInitializersby virtue of its being in the 'help' category of Preferences class"	#(	(allowMVCprojects			'If true, the open... menu will offer you the chance to open an mvc project.')		(autoAccessors			'If true, an attempt to call a message which is not understood by an object but whose selector is the same as an inst var of the object will result in automatic compilation of an accessor method for that object''s class')		(caseSensitiveFinds			'If true, then the "find" command in text will always make its searches in a case-sensitive fashion')		(colorWhenPrettyPrinting			'If true, then when browseWithPrettyPrint is in effect, the pretty-printing will be presented in color')		(compressFlashImages			'If true, flash images will automatically be reduced to 8-bit color depth upon being read')		(conversionMethodsAtFileOut			'Governs whether at fileout time you should be prompted to define conversion methods where deemed appropriate.')		(extractFlashInHighQuality			'Whether flash graphics should be extracted in high quality.')		(extractFlashInHighestQuality			'Whether flash graphics should be extracted in highest possible quality.')		(preserveTrash			'Whether morphs dismissed via halo or dragged into the Trash should be preserved in the TrashCan for possible future retrieval.  If false, they are not preserved.')		(smartUpdating			'If true, then morphic tools such as browsers and inspectors will keep their contents up to date automatically, so that if something changes anywhere, the change will be reflected everywhere.')			) do:		[:pair | HelpDictionary at: pair first put: 			(pair first, ':', pair last)]! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 11/6/1999 22:54'!colorWhenPrettyPrinting	^ self valueOfFlag: #colorWhenPrettyPrinting! !!Preferences class methodsFor: 'initial values' stamp: 'sw 11/8/1999 14:42'!initialValuesA	"Another lot of initial values for prefs.  Simply placing methods of this sort here will assure that the initial values provided are ascribed to the preference when prefs are initialized"	^#(	(conversionMethodsAtFileOut			false)		(menuColorFromWorld				false)		(viewersInFlaps						true)		(oneViewerFlapAtATime				true)		(optionalMorphicButtons				false)		(preserveTrash						true)		(caseSensitiveFinds					false)		(smartUpdating						true)		(colorWhenPrettyPrinting			false))! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'sw 11/9/1999 17:56'!testFormatter    "Smalltalk testFormatter"	"Reformats the source for every method in the system, and then compiles that source and verifies that it generates identical code.   The formatting used will be either classic monochrome or fancy polychrome, depending on the setting of the preference #colorWhenPrettyPrinting."	 | newCodeString methodNode oldMethod newMethod badOnes n |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Formatting all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			newCodeString _ (cls compilerClass new)				format: (cls sourceCodeAt: selector)				in: cls notifying: nil decorated: Preferences colorWhenPrettyPrinting.			methodNode _ cls compilerClass new						compile: newCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldMethod _ cls compiledMethodAt: selector.			oldMethod = newMethod ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Formatter Discrepancies'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'sw 11/9/1999 17:56'!testFormatter2    "Smalltalk testFormatter2"	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.  The formatting used will be either classic monochrome or fancy polychrome, depending on the setting of the preference #colorWhenPrettyPrinting."	 | newCodeString badOnes n oldCodeString oldTokens newTokens |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Formatting all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			oldCodeString _ (cls sourceCodeAt: selector) asString.			newCodeString _ (cls compilerClass new)				format: oldCodeString				in: cls notifying: nil decorated: Preferences colorWhenPrettyPrinting.			oldTokens _ oldCodeString findTokens: Character separators.			newTokens _ newCodeString findTokens: Character separators.			oldTokens = newTokens ifFalse:					[Transcript cr; show: '***' , cls name , ' ' , selector.					badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Formatter Discrepancies'! !!Text methodsFor: 'attributes' stamp: 'sw 11/9/1999 17:24'!askIfAddStyle: priorMethod req: requestor	"Ask the user if we have a complex style (i.e. bold) for the first time"	| tell answ old |	(Preferences browseWithPrettyPrint and: [Preferences colorWhenPrettyPrinting])		ifTrue: [self couldDeriveFromPrettyPrinting ifTrue: [^ self asString]].	self runs coalesce.	self unembellished ifTrue: [^ self asString].	priorMethod ifNotNil: [old _ priorMethod getSourceFromFile].	(old == nil or: [old unembellished])		ifTrue:			[tell _ 'This method contains style (e.g. bold) for the first time.Do you really want to save the style info?'.			answ _ (PopUpMenu labels: 'Save method with styleSave method simply')						startUpWithCaption: tell.			answ = 2 ifTrue: [^ self asString]]! !!Text methodsFor: 'attributes' stamp: 'sw 11/9/1999 17:23'!couldDeriveFromPrettyPrinting	"Return true if the receiver has any TextAttributes that are functional rather than simply appearance-related"	runs values do:		[:emphArray | emphArray do:			[:emph | emph couldDeriveFromPrettyPrinting ifFalse: [^ true]]].	^ false! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:25'!couldDeriveFromPrettyPrinting	"Answer whether the receiver is a kind of attribute that could have been generated by doing polychrome pretty-printing of a method without functional text attributes."	^ true! !!TextAction methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:21'!couldDeriveFromPrettyPrinting	^ false! !!TextAnchor methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:21'!couldDeriveFromPrettyPrinting	^ false! !!TextFontReference methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:22'!couldDeriveFromPrettyPrinting	^ false! !!TextKern methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:21'!couldDeriveFromPrettyPrinting	^ false! !Browser removeSelector: #prettyPrint!ChangeSorter removeSelector: #prettyPrint!Compiler removeSelector: #format:in:notifying:!ParagraphEditor removeSelector: #shiftedYellowButtonMessages!"Postscript:"Preferences initializeAddedPreferences.Preferences initializeHelpMessages.!