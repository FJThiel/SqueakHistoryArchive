'From Squeak2.8alpha of 13 January 2000 [latest update: #1851] on 10 February 2000 at 1:23:46 pm'!!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 2/10/2000 13:20'!copyFromRoots: aRootArray sizeHint: segSizeHint	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize rootSet uniqueRoots |	aRootArray ifNil: [self errorWrongState].	rootSet _ IdentitySet new: 150.	uniqueRoots _ OrderedCollection new.	1 to: aRootArray size do: [:ii |	"Don't include any roots twice"		(rootSet includes: (aRootArray at: ii)) 			ifFalse: [				uniqueRoots addLast: (aRootArray at: ii).				rootSet add: (aRootArray at: ii)]			ifTrue: [userRootCnt ifNotNil: ["adjust the count"						ii <= userRootCnt ifTrue: [userRootCnt _ userRootCnt - 1]]]].	arrayOfRoots _ uniqueRoots asArray.	rootSet _ uniqueRoots _ nil.	"be clean"	userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].	arrayOfRoots do: [:aRoot | (aRoot respondsTo: #indexIfCompact) ifTrue: [		aRoot indexIfCompact > 0 ifTrue: [			self error: 'Compact class ', aRoot name, ' cannot be a root']].		aRoot _ nil].	"clean up"	outPointers _ nil.	"may have used this instance before"	segSize _ segSizeHint > 0 ifTrue: [segSizeHint *3 //2] ifFalse: [50000].	["Guess a reasonable segment size"	segmentWordArray _ WordArrayForSegment new: segSize.	[outPointerArray _ Array new: segSize // 20] ifError: [		state _ #tooBig.  ^ self].	Smalltalk garbageCollect.	"Remove this when everyone is using the new VM"	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 2/10/2000 13:22'!copyFromRootsForExport: rootArray 	"Add to roots:  Any methods pointed to from the outside by blocks."	| newRoots list segSize symbolHolder |	arrayOfRoots _ rootArray.	Smalltalk forgetDoIts.  	symbolHolder _ Symbol allInstances.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	(newRoots _ self rootsIncludingPlayers) ifNotNil: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	"Creation of the segment happens here"	self copyFromRoots: arrayOfRoots sizeHint: 0.	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods, blocks from outPointers"	list _ self compactClassesArray.	outPointers _ outPointers, (list select: [:cls | cls ~~ nil]),		(Array with: 1717 with: list).	"Zap sender of a homeContext. Can't send live stacks out."	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil]].	symbolHolder.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 2/8/2000 13:34'!copyFromRootsLocalFileFor: rootArray sizeHint: segSize	"If the roots include a World, add its Player classes to the roots."	| newRoots |	arrayOfRoots _ rootArray.	[(newRoots _ self rootsIncludingPlayers) == nil] whileFalse: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	Smalltalk forgetDoIts.  	self copyFromRoots: arrayOfRoots sizeHint: segSize.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 2/8/2000 13:37'!rootsIncludingPlayers	"Return a new roots array with more objects.  (Caller should store into rootArray.) Player (non-systemDefined) gets its class and metaclass put into the Roots array.  Then ask for the segment again."| extras havePresenter players morphs |userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].extras _ OrderedCollection new.arrayOfRoots do: [:root | 	(root isKindOf: Presenter) ifTrue: [havePresenter _ root].	(root isKindOf: PasteUpMorph) ifTrue: [			root isWorldMorph ifTrue: [havePresenter _ root presenter]].	(root isKindOf: Project) ifTrue: [havePresenter _ root world presenter]].havePresenter ifNotNil: [	havePresenter flushPlayerListCache.		"old and outside guys"	morphs _ IdentitySet new: 400.	havePresenter associatedMorph allMorphsAndBookPagesInto: morphs.	players _ (morphs select: [:m | m player ~~ nil] 				thenCollect: [:m | m player]) asArray.	players _ players select: [:ap | (arrayOfRoots includes: ap class) not		& (ap class isSystemDefined not)].	extras addAll: (players collect: [:each | each class]).	extras addAll: (players collect: [:each | each class class]).	].havePresenter _ players _ morphs _ nil.extras isEmpty ifTrue: [^ nil].	"no change"^ arrayOfRoots, extras	"will contain multiples of some, but reduced later"! !!Interpreter methodsFor: 'image segment in/out' stamp: 'tk 2/9/2000 16:51'!primitiveStoreImageSegment	"This primitive is called from Squeak as...		<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers: anArray.""This primitive will store a binary image segment (in the same format as the Squeak image file) of the receiver and every object in its proper tree of subParts (ie, that is not refered to from anywhere else outside the tree).  All pointers from within the tree to objects outside the tree will be copied into the array of outpointers.  In their place in the image segment will be an oop equal to the offset in the outPointer array (the first would be 4). but with the high bit set.""The primitive expects the array and wordArray to be more than adequately long.  In this case it returns normally, and truncates the two arrays to exactly the right size.  To simplify truncation, both incoming arrays are required to be 256 bytes or more long (ie with 3-word headers).  If either array is too small, the primitive will fail, but in no other case.During operation of the primitive, it is necessary to convert from both internal and external oops to their mapped values.  To make this fast, the headers of the original objects in question are replaced by the mapped values (and this is noted by adding the forbidden XX header type).  Tables are kept of both kinds of oops, as well as of the original headers for restoration.To be specific, there are two similar two-part tables, the outpointer array, and one in the upper fifth of the segmentWordArray.  Each grows oops from the bottom up, and preserved headers from halfway up.In case of either success or failure, the headers must be restored.  In the event of primitive failure, the table of outpointers must also be nilled out (since the garbage in the high half will not have been discarded."	| outPointerArray segmentWordArray savedYoungStart lastOut lastIn firstIn lastSeg endSeg segOop fieldPtr fieldOop mapOop doingClass lastPtr extraSize hdrTypeBits arrayOfRoots hdrBaseIn hdrBaseOut header firstOut versionOffset |	outPointerArray _ self stackValue: 0.	segmentWordArray _ self stackValue: 1.	arrayOfRoots _ self stackValue: 2.	"Essential type checks"	((self formatOf: arrayOfRoots) = 2				"Must be indexable pointers"		and: [(self formatOf: outPointerArray) = 2				"Must be indexable pointers"		and: [(self formatOf: segmentWordArray) = 6]])	"Must be indexable words"		ifFalse: [^ self primitiveFail].	((self headerType: outPointerArray) = HeaderTypeSizeAndClass	"Must be 3-word header"		and: [(self headerType: segmentWordArray) = HeaderTypeSizeAndClass])	"Must be 3-word header"		ifFalse: [^ self primitiveFail].	DoAssertionChecks ifTrue: [self verifyCleanHeaders].	"Use the top half of outPointers for saved headers."	firstOut _ outPointerArray + BaseHeaderSize.	lastOut _ firstOut - 4.	hdrBaseOut _ outPointerArray + ((self lastPointerOf: outPointerArray) // 8 * 4). "top half"	lastSeg _ segmentWordArray.	endSeg _ segmentWordArray + (self sizeBitsOf: segmentWordArray) - 4.	"Write a version number for byte order and version check"	versionOffset _ 4.	lastSeg _ lastSeg + versionOffset.	lastSeg > endSeg ifTrue: [^ self primitiveFail].	self longAt: lastSeg put: self imageSegmentVersion.	"Allocate top 1/8 of segment for table of internal oops and saved headers"	firstIn _ endSeg - ((self sizeBitsOf: segmentWordArray) // 32 * 4).  "Take 1/8 of seg"	lastIn _ firstIn - 4.	hdrBaseIn _ firstIn + ((self sizeBitsOf: segmentWordArray) // 64 * 4). "top half"	"First mark the rootArray and all root objects."	self longAt: arrayOfRoots put: ((self longAt: arrayOfRoots) bitOr: MarkBit).	lastPtr _ arrayOfRoots + (self lastPointerOf: arrayOfRoots).	fieldPtr _ arrayOfRoots + BaseHeaderSize.	[fieldPtr <= lastPtr] whileTrue:		[fieldOop _ self longAt: fieldPtr.		(self isIntegerObject: fieldOop) ifFalse:			[self longAt: fieldOop put: ((self longAt: fieldOop) bitOr: MarkBit)].		fieldPtr _ fieldPtr + 4].	"Then do a mark pass over all objects.  This will stop at our marked roots,	thus leaving our segment unmarked in their shadow."	savedYoungStart _ youngStart.	youngStart _ self startOfMemory.  "process all of memory"		"clear the recycled context lists"		freeContexts _ NilContext.		freeLargeContexts _ NilContext.	self markAndTraceInterpreterOops.	"and special objects array"	youngStart _ savedYoungStart.		"Finally unmark the rootArray and all root objects."	self longAt: arrayOfRoots put: ((self longAt: arrayOfRoots) bitAnd: AllButMarkBit).	fieldPtr _ arrayOfRoots + BaseHeaderSize.	[fieldPtr <= lastPtr] whileTrue:		[fieldOop _ self longAt: fieldPtr.		(self isIntegerObject: fieldOop) ifFalse:			[self longAt: fieldOop put: ((self longAt: fieldOop) bitAnd: AllButMarkBit)].		fieldPtr _ fieldPtr + 4].	"All external objects, and only they, are now marked.	Copy the array of roots into the segment, and forward its oop."	lastIn _ lastIn + 4.	lastIn >= hdrBaseIn ifTrue: [successFlag _ false].	lastSeg _ self copyObj: arrayOfRoots toSegment: segmentWordArray addr: lastSeg stopAt: firstIn saveOopAt: lastIn headerAt: hdrBaseIn + (lastIn - firstIn).	successFlag ifFalse:		[lastIn _ lastIn - 4.		self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.		^ self primitiveFailAfterCleanup: outPointerArray].	"Now run through the segment fixing up all the pointers.	Note that more objects will be added to the segment as we make our way along."	segOop _ self oopFromChunk: segmentWordArray + versionOffset + BaseHeaderSize.	[segOop <= lastSeg] whileTrue:		[(self headerType: segOop) <= 1			ifTrue: ["This object has a class field (type=0 or 1) -- start with that."					fieldPtr _ segOop - 4.  doingClass _ true]			ifFalse: ["No class field -- start with first data field"					fieldPtr _ segOop + BaseHeaderSize.  doingClass _ false].		lastPtr _ segOop + (self lastPointerOf: segOop).	"last field"		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop _ self longAt: fieldPtr.			doingClass ifTrue:				[hdrTypeBits _ fieldOop bitAnd: TypeMask.				fieldOop _ fieldOop - hdrTypeBits].			(self isIntegerObject: fieldOop)				ifTrue: ["Just an integer -- nothing to do"						fieldPtr _ fieldPtr + 4]				ifFalse:				[header _ self longAt: fieldOop.				(header bitAnd: TypeMask) = HeaderTypeFree					ifTrue: ["Has already been forwarded -- this is the link"							mapOop _ header bitAnd: AllButTypeMask]					ifFalse:					[((self longAt: fieldOop) bitAnd: MarkBit) = 0						ifTrue:							["Points to an unmarked obj -- an internal pointer.							Copy the object into the segment, and forward its oop."							lastIn _ lastIn + 4.							lastIn >= hdrBaseIn ifTrue: [successFlag _ false].							lastSeg _ self copyObj: fieldOop toSegment: segmentWordArray addr: lastSeg stopAt: firstIn saveOopAt: lastIn headerAt: hdrBaseIn + (lastIn - firstIn).							successFlag ifFalse:								["Out of space in segment"								lastIn _ lastIn - 4.								self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.								^ self primitiveFailAfterCleanup: outPointerArray].							mapOop _ (self longAt: fieldOop) bitAnd: AllButTypeMask]						ifFalse:							["Points to a marked obj -- an external pointer.							Map it as a tagged index in outPointers, and forward its oop."							lastOut _ lastOut + 4.							lastOut >= hdrBaseOut ifTrue:								["Out of space in outPointerArray"								lastOut _ lastOut - 4.								self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.								^ self primitiveFailAfterCleanup: outPointerArray]..							mapOop _ lastOut - outPointerArray bitOr: 16r80000000.							self forward: fieldOop to: mapOop								savingOopAt: lastOut andHeaderAt: hdrBaseOut + (lastOut - firstOut)]].					"Replace the oop by its mapped value"					doingClass						ifTrue: [self longAt: fieldPtr put: mapOop + hdrTypeBits.								fieldPtr _ fieldPtr + 8.								doingClass _ false]						ifFalse: [self longAt: fieldPtr put: mapOop.								fieldPtr _ fieldPtr + 4].]].		segOop _ self objectAfter: segOop].	self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.	"Truncate the outPointerArray..."	((outPointerArray + (self lastPointerOf: outPointerArray) - lastOut) < 12		or: [(endSeg - lastSeg) < 12]) ifTrue:			["Not enough room to insert simple 3-word headers"			^ self primitiveFailAfterCleanup: outPointerArray].	extraSize _ self extraHeaderBytes: segmentWordArray.	hdrTypeBits _ self headerType: segmentWordArray.	"Copy the 3-word wordArray header to establish a free chunk."	self transfer: 3		from: segmentWordArray - extraSize		to: lastOut+4.	"Adjust the size of the original as well as the free chunk."	self longAt: lastOut+4		put: outPointerArray + (self lastPointerOf: outPointerArray) - lastOut - extraSize + hdrTypeBits.	self longAt: outPointerArray-extraSize		put: lastOut - firstOut + 8 + hdrTypeBits.	"Note that pointers have been stored into roots table"	self beRootIfOld: outPointerArray.	"Truncate the image segment..."	"Copy the 3-word wordArray header to establish a free chunk."	self transfer: 3		from: segmentWordArray - extraSize		to: lastSeg+4.	"Adjust the size of the original as well as the free chunk."	self longAt: segmentWordArray-extraSize		put: lastSeg - segmentWordArray + BaseHeaderSize + hdrTypeBits.	self longAt: lastSeg+4		put: endSeg - lastSeg - extraSize + hdrTypeBits.	DoAssertionChecks ifTrue: [self verifyCleanHeaders].	self pop: 3.  "...leaving the reciever on the stack as return value"! !!Project commentStamp: 'tk 2/8/2000 02:15' prior: 0!A Project stores the state of a complete Squeak desktop, including the windows, and the currently active changeSet.  A project knows who its parent project is.  When you change projects, whether by entering or exiting, all the global state is saved into the project being exited, and loaded from the one being entered.A project is retained by its view in the parent world.  It is effectively named by the name of its changeSet, which can be changed either by renaming in a changeSorter, or by editing the label of its view from the parent project.As the site of major context switch, Projects are the locus of swapping between the old MVC and the new Morphic worlds.  The distinction is based on whether the variable 'world' contains a WorldMorph or a ControlManager.When you accept a method, the entire system feels the change, except projects that are "isolated".  In an "isolated" project, changes are revoked when you leave the project.  When you enter another project, that project's changes are installed.  (To make a project be isolated, choose "isolate changes of this project" from the "changes..." section of the screen menu.)  You can use an isolated project for making dangerous change to a system, and you can get out if it crashes.  A foreign application can have the separate environment it wants.  Also, you can freeze part of the system for a demo that you don't want to disturb.	An isolated project shares methods with all subprojects inside it, unless they are isolated themselves.   Each isolated project is the head of a tree of projects it shares all methods with.	You may 'assert' all changes ever made in the current project to take effect everywhere.  You are first informed if there are any direct method conflicts with other projects.  The conflicts are presented in a ChangeList Browser.	[Later: A project may be 'frozen'.  Asserts do not apply to it after that.  (Great for demos.)  You should be informed when an assert was blocked in a frozen project.]	Class definitions are global.  If you add an instance variable, it happens in all projects.  All versions of the methods are recompiled, in all projects.  If you remove an inst var that is in use in another isolated project, it will become an Undeclared global.  It is best not to remove an inst var when it is being used in another isolated project.   	Senders and Implementors do not see other versions of a method in other isolated projects.	When you ask for versions of a method, you will not get the history in other isolated projects.	Moving methods and classes between changeSets, and merging changeSets has no effect on which methods are in force.  But, when you look at a changeSet from a different isolated project, the methods will contain the 'wrong' code.  A changeSet is just a list of method names, and does not keep separate copies of any code.	When finer grained assertion is needed, use the method (aProject assertClass: aClass from: thisProject warn: warnConflicts).	How isolated changes work: The first time a class changes, store its MethodDictionary object.  Keep parallel arrays of associations to Classes and MethodDictionaries.  Traverse these and install them when you enter an "ioslated project".  When you leave, store this project's own MethodDictionaries there.	To do an assert, we must discover which methods changed here, and which changed only in the project we are asserting into.  There is one copy of the 'virgin' method dictionaries in the system.  It is always being temporarily stored by the currently inForce isolated project.isolatedHead - true for the "top project", and the origin of each "isolated project".  false or nil for any subproject that shares all methods with its parent project.inForce -  true if my methods are installed now.  false if I am dormant.classArray - list of associations to classes methodDictArray - the method dictionaries of those classes before we started changing methods.  They hang onto the original compiledMethods.  (If this project is dormant, it contains the method dictionaries of those classes as they will be here, in this project).orgArray - the class organizations of the classes in classArray.UsingIsolation (class variable) - true when more than one isolated project exists.  When false, only top project has (isolatedHead = true), and no project records any method dictionaries.  This is to save space when not using Isolated Projects.!!Project methodsFor: 'file in/out' stamp: 'tk 2/8/2000 13:55'!exportSegmentWithCatagories: catList classes: classList	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."| is response str ans revertSeg roots |world == World ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer]].world fullReleaseCachedState. "Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ (Array with: self) asOrderedCollection, classList, (classList collect: [:cls | cls class]).catList do: [:sysCat | 	(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |		roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].is _ ImageSegment new copyFromRootsForExport: roots asArray.	"world, and all Players"is state = #tooBig ifTrue: [^ false].str _ ''.is segment size < 3000 ifTrue: [	str _ 'Segment is only ', is segment size printString, ' long.'].(is outPointers detect: [:out | out isMorph] ifNone: [nil]) ifNotNil: [	str _ str, '\Morphs are pointed at from the outside.' withCRs].(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		^ false].	ans = 3 ifTrue: [self halt: 'Segment not written']].is writeForExportWithSources: self name.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].^ true! !