'From Squeak2.9alpha of 16 June 2000 [latest update: #2803] on 4 October 2000 at 4:08:27 pm'!"Change Set:		ProjStore2-tkDate:			4 October 2000Author:			Ted KaehlerControllable ImageSegment Storage (CISS) for storing projects on the disk.CISS uses a SmartRefStream to enumerate the objects.  It puts an ImageSegment on the disk.  Not optimized for speed yet.  The dreaded message 'Morphs pointed from the outside' has been removed from the system.  	Currently only hooked up for Projects.  Individual morphs are stored the old way.The switch to turn it off again is in (Project exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory).  Just change false to true in the middle of the method."!DataStream subclass: #ReferenceStream	instanceVariableNames: 'references objects currentReference fwdRefEnds blockers skipping insideASegment '	classVariableNames: 'RefTypes '	poolDictionaries: ''	category: 'System-Object Storage'!!ReferenceStream commentStamp: 'tk 9/27/2000 11:35' prior: 0!This is a way of serializing a tree of objects into disk file. A ReferenceStream can storeone or more objects in a persistent form, including sharing and cycles.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: 'test.obj'.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: 'test.obj'.	<your object> _ rr next.	rr close.ReferenceStreams can now write "weak" references. nextPutWeak:writes a "weak" reference to an object, which refers to that object*if* it also gets written to the stream by a normal nextPut:.A ReferenceStream should be treated as a read-stream *or* as a write-stream, *not* as a read/write-stream. The reference-remembering mechanism would probably do bad things if you tried to read and write from the same ReferenceStream.[TBD] Should we override "close" to do (self forgetReferences)?Instance variables references -- an IdentityDictionary mapping objects already written	to their byteStream positions. If asked to write any object a	second time, we just write a reference to its stream position.	This handles shared objects and reference cycles between objects.	To implement "weak references" (for Aliases), the references	dictionary also maps objects not (yet?) written to a Collection	of byteStream positions with hopeful weak-references to it. If	asked to definitely write one of these objects, we'll fixup those	weak references. objects -- an IdentityDictionary mapping relative byte stream positions to	objects already read in. If asked to follow a reference, we	return the object already read.	This handles shared objects and reference cycles between objects. currentReference -- the current reference position. Positon relative to the 	start of object data in this file.  (Allows user to cut and paste smalltalk 	code from the front of the file without effecting the reference values.)  	This variable is used to help install each new object in "objects" as soon	as it's created, **before** we start reading its contents, in	case any of its content objects reference it. fwdRefEnds -- A weak reference can be a forward reference, which	requires advance-reading the referrent. When we later come to the	object, we must get its value from "objects" and not re-read it so	refs to it don't become refs to copies. fwdRefEnds remembers the	ending byte stream position of advance-read objects. skipping -- true if <what?> insideASegment -- true if we are being used to collect objects that will be 	included in an ImageSegment.  If so, UniClasses must be noted and traced.If the object is referenced before it is done being created, it might get created twice.  Just store the object the moment it is created in the 'objects' dictionary.  If at the end, comeFullyUpOnReload returns a different object, some refs will have the temporary object (this is an unlikely case).  At the moment, no implementor of comeFullyUpOnReload returns a different object except DiskProxy, and that is OK.!!Array methodsFor: 'file in/out' stamp: 'tk 9/28/2000 15:35'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  If I am one of two shared global arrays, write a proxy instead."self == (TextConstants at: #DefaultTabsArray) ifTrue: [	dp _ DiskProxy global: #TextConstants selector: #at: args: #(DefaultTabsArray).	refStrm replace: self with: dp.	^ dp].self == (TextConstants at: #DefaultMarginTabsArray) ifTrue: [	dp _ DiskProxy global: #TextConstants selector: #at: args: #(DefaultMarginTabsArray).	refStrm replace: self with: dp.	^ dp].^ super objectForDataStream: refStrm! !!Association methodsFor: 'objects from disk' stamp: 'tk 10/3/2000 13:03'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  If I am a known global, write a proxy that will hook up with the same resource in the destination system."	^ (Smalltalk associationAt: key ifAbsent: [nil]) == self 		ifTrue: [dp _ DiskProxy global: #Smalltalk selector: #associationOrUndeclaredAt: 							args: (Array with: key).			refStrm replace: self with: dp.			dp]		ifFalse: [self]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'tk 9/26/2000 11:51'!fileOut	"File out the receiver, to a file whose name is a function of the change-set name and either of the date & time or chosen to have a unique numeric tag, depending on the preference 'sequentialChangeSetRevertableFileNames'"	| file slips nameToUse |	self checkForConversionMethods.	nameToUse _ Preferences changeSetVersionNumbers		ifTrue:			[FileDirectory default nextNameFor: self name extension: 'cs']		ifFalse:			[(self name, FileDirectory dot, Utilities dateTimeSuffix, 				FileDirectory dot, 'cs') asFileName].	Cursor write showWhile:		[[file _ FileStream newFileNamed: nameToUse.		file header; timeStamp.		self fileOutPreambleOn: file.		self fileOutOn: file.		self fileOutPostscriptOn: file.		file trailer] ensure: [file close]].	Preferences checkForSlips ifFalse: [^ self].	slips _ self checkForSlips.	(slips size > 0 and: [(PopUpMenu withCaption: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?' chooseFrom: 'Ignore\Browser them') = 2])		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'tk 9/28/2000 15:37'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."	refStrm projectChangeSet == self ifTrue: [^ self].	"Later may want to put out a Proxy that looks it up.  For now, ChangeSet cannot be written except as part of a Project.	^ DiskProxy global: #ChangeSet selector: #named: args: (Array with: self name)"	refStrm replace: self with: nil.	^ nil! !!Class methodsFor: 'fileIn/Out' stamp: 'tk 9/28/2000 15:38'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a class in Smalltalk instead."	(refStrm insideASegment and: [self isSystemDefined not]) ifTrue: [		^ self].	"do trace me"	dp _ DiskProxy global: self theNonMetaClass name selector: #yourself			args: #().	refStrm replace: self with: dp.	^ dp! !!Class methodsFor: 'fileIn/Out' stamp: 'tk 9/27/2000 11:40'!storeDataOn: aDataStream	"I don't get stored.  Use a DiskProxy"	(aDataStream insideASegment and: [self isSystemDefined not]) ifTrue: [		^ super storeDataOn: aDataStream].	"do trace me"	self error: 'use a DiskProxy to store a Class'! !!ClassOrganizer methodsFor: 'fileIn/Out' stamp: 'tk 9/28/2000 15:39'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."Smalltalk allBehaviorsDo: [:aClass | 	aClass organization == self ifTrue: [		(refStrm insideASegment and: [aClass isSystemDefined not]) ifTrue: [			^ self].	"do trace me"		(aClass isKindOf: Class) ifTrue: [			dp _ DiskProxy global: aClass name selector: #organization args: #().			refStrm replace: self with: dp.			^ dp]]].^ self	"in desparation"! !!ContextPart methodsFor: 'objects from disk' stamp: 'tk 9/28/2000 22:54'!storeDataOn: aDataStream	"Contexts are not allowed go to out in DataStreams.  They must be included inside an ImageSegment."	aDataStream insideASegment ifTrue: [^ super storeDataOn: aDataStream].	self error: 'This Context was not included in the ImageSegment'.		"or perhaps ImageSegments were not used at all"	^ nil! !!DataStream methodsFor: 'write and read' stamp: 'tk 9/24/2000 15:39'!replace: original with: proxy	"We may wish to remember that in some field, the original object is being replaced by the proxy.  For the hybred scheme that collects with a DummyStream and writes an ImageSegment, it needs to hold onto the originals so they will appear in outPointers, and be replaced."	"do nothing"! !!DisplayScreen methodsFor: 'disk I/O' stamp: 'tk 9/28/2000 15:41'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to the Display in the other system instead.  "	"A path to me"	dp _ DiskProxy global: #Display selector: #yourself args: #().	refStrm replace: self with: dp.	^ dp! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/2/2000 14:05'!copyFromRoots: aRootArray sizeHint: segSizeHint	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize rootSet uniqueRoots |	aRootArray ifNil: [self errorWrongState].	(Symbol classPool at: #SelectorTables) first first class == WeakArray ifTrue: [		Symbol useArrayTables].	"Hold onto Symbols.  Done only once."	rootSet _ IdentitySet new: aRootArray size * 3.	uniqueRoots _ OrderedCollection new.	1 to: aRootArray size do: [:ii |	"Don't include any roots twice"		(rootSet includes: (aRootArray at: ii)) 			ifFalse: [				uniqueRoots addLast: (aRootArray at: ii).				rootSet add: (aRootArray at: ii)]			ifTrue: [userRootCnt ifNotNil: ["adjust the count"						ii <= userRootCnt ifTrue: [userRootCnt _ userRootCnt - 1]]]].	arrayOfRoots _ uniqueRoots asArray.	rootSet _ uniqueRoots _ nil.	"be clean"	userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].	arrayOfRoots do: [:aRoot | (aRoot respondsTo: #indexIfCompact) ifTrue: [		aRoot indexIfCompact > 0 ifTrue: [			self error: 'Compact class ', aRoot name, ' cannot be a root']].		aRoot _ nil].	"clean up"	outPointers _ nil.	"may have used this instance before"	segSize _ segSizeHint > 0 ifTrue: [segSizeHint *3 //2] ifFalse: [50000].	["Guess a reasonable segment size"	segmentWordArray _ WordArrayForSegment new: segSize.	[outPointerArray _ Array new: segSize // 20] ifError: [		state _ #tooBig.  ^ self].	Smalltalk garbageCollect.	"Remove this when everyone is using the new VM"	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/27/2000 11:38'!copySmartRootsExport: rootArray 	"Use SmartRefStream to find the object.  Make them all roots.  Create the segment in memory.  Project should be in first five objects in rootArray."	| newRoots list segSize symbolHolder dummy replacements |	Smalltalk forgetDoIts.  	symbolHolder _ Symbol allInstances.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy insideASegment: true.	"So Uniclasses will be traced"	dummy rootObject: rootArray.	"inform him about the root"	dummy nextPut: rootArray.	SmartRefStream new uniClassInstVarsRefs: dummy.		"catalog the extra objects in UniClass inst vars.  Put into dummy"	"refs _ dummy references."	arrayOfRoots _ self smartFillRoots: dummy.	replacements _ dummy blockers.	dummy project ifNil: [self error: 'lost the project!!'].	dummy project class == DiskProxy ifTrue: [self error: 'saving the wrong project'].	dummy _ nil.	"force GC?"		"Creation of the segment happens here"	self copyFromRoots: arrayOfRoots sizeHint: 0.	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods, blocks from outPointers"	list _ self compactClassesArray.	outPointers _ outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil].		"substitute new object in outPointers"		(replacements includesKey: (outPointers at: ii)) ifTrue: [			outPointers at: ii put: (replacements at: (outPointers at: ii))]].	symbolHolder.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/26/2000 15:59'!smartFillRoots: dummy	| refs known ours ww blockers |	"Put all traced objects into my arrayOfRoots.  Remove some that want to be in outPointers.  Return blockers, an IdentityDictionary of objects to replace in outPointers."	blockers _ dummy blockers.	known _ (refs _ dummy references) size.	refs keys do: [:obj | "copy keys to be OK with removing items"		(obj class == Symbol) ifTrue: [refs removeKey: obj.  known _ known-1].		(obj class == PasteUpMorph) ifTrue: [			obj isWorldMorph & (obj owner == nil) ifTrue: [				obj == dummy project world ifFalse: [					refs removeKey: obj.  known _ known-1.					blockers at: obj put: 						(StringMorph contents: 'The worldMorph of a different world')]]].					"Make a ProjectViewMorph here"		"obj class == Project ifTrue: [Transcript show: obj; cr]."		(blockers includesKey: obj) ifTrue: [			refs removeKey: obj ifAbsent: [known _ known+1].  known _ known-1].		].	ours _ dummy project world.	refs keysDo: [:obj |			obj isMorph ifTrue: [				ww _ obj world. 				(ww == ours) | (ww == nil) ifFalse: [					refs removeKey: obj.  known _ known-1.					blockers at: obj put: (StringMorph new string: 								obj printString, ' from another world')]]].	"keep original roots on the front of the list"	(dummy rootObject) do: [:rr | refs removeKey: rr ifAbsent: []].	^ dummy rootObject, refs keys asArray.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 9/26/2000 15:58'!prepareToBeSaved	"Prepare objects in outPointers to be written on the disk.  They must be able to match up with existing objects in their new system.  outPointers is already a copy.	Classes are already converted to a DiskProxy.  	Associations in outPointers:1) in Smalltalk.2) in a classPool.3) in a shared pool.4) A pool dict pointed at directly"| left pool myClasses outIndexes key |myClasses _ Set new.arrayOfRoots do: [:aRoot | aRoot class class == Metaclass ifTrue: [myClasses add: aRoot]].outIndexes _ IdentityDictionary new.outPointers withIndexDo: [:anOut :ind | 	anOut class == Association ifTrue: [		(myClasses includes: anOut value)			ifFalse: [outIndexes at: anOut put: ind]			ifTrue: [(Smalltalk associationAt: anOut key ifAbsent: [3]) == anOut 				ifTrue: [outPointers at: ind put: 					(DiskProxy global: #Smalltalk selector: #associationDeclareAt: 						args: (Array with: anOut key))]				ifFalse: [outIndexes at: anOut put: ind]				]].	(anOut isKindOf: Dictionary) ifTrue: ["Pools pointed at directly"		(key _ Smalltalk keyAtIdentityValue: anOut ifAbsent: [nil]) ifNotNil: [			outPointers at: ind put: 				(DiskProxy global: key selector: #yourself args: #())]].	anOut isMorph ifTrue: [outPointers at: ind put: 		(StringMorph contents: anOut printString, ' that was not counted')]	].left _ outIndexes keys asSet.left size > 0 ifTrue: ["Globals"	(left copy) do: [:assoc |	"stay stable while delete items"		(Smalltalk associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [			outPointers at: (outIndexes at: assoc) put: 				(DiskProxy global: #Smalltalk selector: #associationAt: 					args: (Array with: assoc key)).			left remove: assoc]]].left size > 0 ifTrue: ["Class variables"	Smalltalk allClassesDo: [:cls | cls classPool size > 0 ifTrue: [		(left copy) do: [:assoc |	"stay stable while delete items"			(cls classPool associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [				outPointers at: (outIndexes at: assoc) put: 					(DiskProxy new global: cls name						preSelector: #classPool						selector: #associationAt: 						args: (Array with: assoc key)).				left remove: assoc]]]]].left size > 0 ifTrue: ["Pool variables"	Smalltalk associationsDo: [:poolAssoc |		poolAssoc value class == Dictionary ifTrue: ["a pool"			pool _ poolAssoc value.			(left copy) do: [:assoc |	"stay stable while delete items"				(pool associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [					outPointers at: (outIndexes at: assoc) put: 						(DiskProxy global: poolAssoc key selector: #associationAt: 							args: (Array with: assoc key)).					left remove: assoc]]]]].left size > 0 ifTrue: [	"If points to class in arrayOfRoots, must deal with it separately"	"OK to have obsolete associations that just get moved to the new system"	self inform: 'extra associations'.	left inspect].! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'tk 9/25/2000 12:06'!objectForDataStream: refStrm    "Answer an object to store on a data stream, a copy of myself whose SampleBuffers have been converted into ByteArrays."	refStrm replace: leftSamples with: leftSamples asByteArray.	refStrm replace: rightSamples with: rightSamples asByteArray.	"substitution will be made in DataStream nextPut:"	^ self! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'tk 9/28/2000 15:44'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a class in Smalltalk instead."	(refStrm insideASegment and: [self isSystemDefined not]) ifTrue: [		^ self].	"do trace me"	dp _ DiskProxy global: self theNonMetaClass name selector: #class			args: (Array new).	refStrm replace: self with: dp.	^ dp! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'tk 9/27/2000 11:39'!storeDataOn: aDataStream	"I don't get stored.  Use a DiskProxy"	(aDataStream insideASegment and: [self isSystemDefined not]) ifTrue: [		^ super storeDataOn: aDataStream].	"do trace me"	self error: 'use a DiskProxy to store a Class'! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 9/28/2000 15:45'!objectForDataStream: refStrm	| dp |	"I am being written out on an object file"	self sqkPage ifNotNil: [		(refStrm rootObject == self) | (refStrm rootObject == self sqkPage) ifFalse: [			self url size > 0 ifTrue: [				dp _ self sqkPage copyForSaving.	"be careful touching this object!!"				refStrm replace: self with: dp.				^ dp]]].	self prepareToBeSaved.		"Amen"	^ self! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'tk 9/28/2000 15:37'!objectForDataStream: refStrm	"I am about to be written on an object file.  It would be bad to write a whole BookMorph out.  Store a string that is the url of the book or page in my inst var."	| clone bookUrl bb stem ind |	(bookMorph class == String) & (page class == String) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph == nil) & (page class == String) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph == nil) & (page url ~~ nil) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph == nil) & (page url == nil) ifTrue: [		self error: 'page should already have a url'.		"find page's book, and remember it"		"bookMorph _ "].		clone _ self clone.	(bookUrl _ bookMorph url)		ifNil: [bookUrl _ self valueOfProperty: #futureUrl].	bookUrl 		ifNil: [	bb _ RectangleMorph new.	"write out a dummy"			bb bounds: bounds.			refStrm replace: self with: bb.			^ bb]		ifNotNil: [clone instVarNamed: 'bookMorph' put: bookUrl].	page url ifNil: [			"Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."		stem _ SqueakPage stemUrl: bookUrl.		ind _ bookMorph pages identityIndexOf: page.		page reserveUrl: stem,(ind printString),'.sp'].	clone instVarNamed: 'page' put: page url.	refStrm replace: self with: clone.	^ clone! !!FlapTab methodsFor: 'fileIn/out' stamp: 'tk 9/28/2000 15:42'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  If I am a global flap, write a proxy instead."	(Utilities globalFlapTabsIfAny includes: self) ifTrue: [		dp _ DiskProxy global: #Utilities selector: #globalFlapTabOrDummy: 					args: {self flapMenuTitle}.		refStrm replace: self with: dp.		^ dp].	^ super objectForDataStream: refStrm! !!HandMorph methodsFor: 'file in/out' stamp: 'tk 9/28/2000 22:37'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	(refStrm project world hands includes: self) ifTrue: [		^ self].	"owned by the project"	dp _ DiskProxy global: #World selector: #primaryHand args: #().	refStrm replace: self with: dp.	^ dp	"Note, when this file is loaded in an MVC project, this will return nil.  The MenuItemMorph that has this in a field will have that item not work.  Maybe warn the user at load time?"! !!Process methodsFor: 'objects from disk' stamp: 'tk 9/28/2000 15:46'!objectForDataStream: refStrm	"I am not allowed to be written on an object file."	refStrm replace: self with: nil.	^ nil! !!ProcessorScheduler methodsFor: 'objects from disk' stamp: 'tk 9/28/2000 15:46'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	dp _ DiskProxy global: #Processor selector: #yourself args: #().	refStrm replace: self with: dp.	^ dp! !!Project methodsFor: 'file in/out' stamp: 'tk 9/29/2000 12:33'!ensureChangeSetNameUnique	| myName |	myName _ self name.	Project allProjects do: [:pp | 		pp == self ifFalse: [			pp name = myName ifTrue: [				self projectChangeSet ifNil: [^ changeSet _ ChangeSet new].				^self projectChangeSet name: (ChangeSet uniqueNameLike: myName)			]		]	]! !!Project methodsFor: 'file in/out' stamp: 'tk 9/29/2000 12:36'!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."| is str ans revertSeg roots holder |"world == World ifTrue: [^ false]."	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World currentHand clearPasteBuffer.	"don't ask"	"Display checkCurrentHandForObjectToPaste."Command initialize.world clearCommandHistory.world fullReleaseCachedState. world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages.holder _ Project allProjects.	"force them in to outPointers, where DiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ OrderedCollection new.roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).catList do: [:sysCat | 	(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |		roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].false ifTrue: [		is _ ImageSegment new copyFromRootsForExport: roots asArray]	"world, and all Players"	ifFalse: [is _ ImageSegment new copySmartRootsExport: roots asArray].is state = #tooBig ifTrue: [^ false].str _ ''.is segment size < 3000 ifTrue: [	str _ 'Segment is only ', is segment size printString, ' long.']."(is outPointers detect: [:out | out isMorph] ifNone: [nil]) ifNotNil: [	str _ str, '\Morphs are pointed at from the outside.' withCRs]."(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		^ false].	ans = 3 ifTrue: [self halt: 'Segment not written']].is writeForExportWithSources: aFileName inDirectory: aDirectory.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.^ true! !!Project methodsFor: 'file in/out' stamp: 'tk 9/28/2000 15:47'!objectForDataStream: refStrm	| uu dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	refStrm project == self ifTrue: [^ self].	(uu _ self url) size > 0 ifTrue: [		dp _ DiskProxy global: #Project selector: #namedUrl: 			args: (Array with: uu).		refStrm replace: self with: dp.		^ dp].	^ DiskProxy global: #Project selector: #named: args: (Array with: self name)! !!Project class methodsFor: 'squeaklet on server' stamp: 'tk 10/3/2000 15:31'!parseProjectFileName: aString"it was formerly possible to have periods in projct names and this messed up some parsing methods. Try to handle that more gracefully and allow for a change in scheme at a later time"	| suffix baseName version versionAndSuffix |	"answer an array with: 		1 = basic project name		2 = version string		3 = suffix (pr)""----Project parseProjectFileName: 'aa.bb.cc|vv.ss'--degenerate forms--Project parseProjectFileName: 'aa.bb.cc|.ss'Project parseProjectFileName: 'aa.bb.cc|vv.'Project parseProjectFileName: 'aa.bb.cc|.'---"	baseName _ version _ suffix _ ''.	baseName _ aString copyUpToLast: $|.	baseName = aString ifTrue: [		(aString occurrencesOf: $.) > 1 ifTrue: [			baseName _ aString copyUpToLast: $..			suffix _ baseName allButFirst: baseName size + 1.		].	] ifFalse: [		versionAndSuffix _ aString allButFirst: baseName size + 1.		(versionAndSuffix occurrencesOf: $.) = 0 ifTrue: [^ #('no suffix')].		version _ versionAndSuffix copyUpTo: $..		suffix _ versionAndSuffix allButFirst: version size + 1.	].	^{baseName. version. suffix}! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'tk 9/28/2000 15:58'!openFromFile: preStream fromDirectory: aDirectoryOrNil	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world." 	| morphOrList window proj |	ProgressNotification signal: '2:fileSizeDetermined ',preStream size printString.	morphOrList _ preStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	morphOrList _ morphOrList fileInObjectAndCode.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		"first project in roots is the main one"		proj _ morphOrList arrayOfRoots detect: [:mm | mm class == Project] 					ifNone: [nil].		"rename the project if it conflicts?"		proj ifNotNil: [			proj versionFrom: preStream.			proj lastDirectory: aDirectoryOrNil.			CurrentProjectRefactoring currentBeParentTo: proj.			Smalltalk isMorphic ifTrue: [				ProjectViewOpenNotification signal ifTrue: [					window _ (SystemWindow labelled: proj name) model: proj.					window						addMorph: (self on: proj)						frame: (0@0 corner: 1.0@1.0).					window openInWorld				].			] ifFalse: [				ProjectView openAndEnter: proj.				"Note: in MVC we get no further than the above"			].			^ ProjectEntryNotification signal: proj		]	].	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph	].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'	].	window _ self newMorphicProjectOn: morphOrList.	ProjectViewOpenNotification signal ifTrue: [window openInWorld].	window model enter! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 10/2/2000 18:16'!beginInstance: aClass size: anInteger	"This is for use by storeDataOn: methods.  Cf. Object>>storeDataOn:."	"Addition of 1 seems to make extra work, since readInstance has to compensate.  Here for historical reasons dating back to Kent Beck's original implementation in late 1988.	In ReferenceStream, class is just 5 bytes for shared symbol.	SmartRefStream puts out the names and number of class's instances variables for checking.6/10/97 16:09 tk: See if we can put on a short header. Type = 16. "	| short ref |	short _ true.	"All tests for object header that can be written in 4 bytes"	anInteger <= 254 ifFalse: [short _ false].	"one byte size"	ref _ references at: aClass name ifAbsent: [short _ false. nil].	ref isInteger ifFalse: [short _ false].	short ifTrue: [short _ (ref < 65536) & (ref > 0) "& (ref ~= self vacantRef)"].  "vacantRef is big"	short ifTrue: [		byteStream skip: -1.		short _ byteStream next = 9.		byteStream skip: 0].	"ugly workaround"	short 		ifTrue: ["passed all the tests!!"			byteStream skip: -1; nextPut: 16; "type = short header"				nextPut: anInteger + 1;	"size is short"				nextNumber: 2 put: ref]		ifFalse: [			"default to normal longer object header"			byteStream nextNumber: 4 put: anInteger + 1.			self nextPut: aClass name].	insideASegment ifTrue: [		aClass isSystemDefined ifFalse: [self nextPut: aClass]].			"just record it to put it into roots"! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 9/27/2000 11:37'!insideASegment	^ insideASegment! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 9/27/2000 11:36'!insideASegment: aBoolean	insideASegment _ aBoolean! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 9/24/2000 09:18'!objectIfBlocked: anObject	"See if this object is blocked -- not written out and another object substituted."	^ blockers at: anObject ifAbsent: [anObject]! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 9/23/2000 08:41'!project	"Return the project we are writing or nil"	(topCall respondsTo: #isCurrentProject) ifTrue: [^ topCall].	(topCall respondsTo: #do:) ifTrue: [1 to: 5 do: [:ii | 		((topCall at: ii) respondsTo: #isCurrentProject) ifTrue: [^ topCall at: ii]]].	^ nil! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 9/23/2000 08:40'!projectChangeSet	| pr |	"The changeSet of the project we are writing"	(pr _ self project) ifNil: [^ nil].	^ pr projectChangeSet! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 9/24/2000 16:44'!replace: original with: proxy	"We may wish to remember that in some field, the original object is being replaced by the proxy.  For the hybred scheme that collects with a DummyStream and writes an ImageSegment, it needs to hold onto the originals so they will appear in outPointers, and be replaced."	blockers at: original put: proxy! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 9/27/2000 13:35'!setStream: aStream	"PRIVATE -- Initialization method."	super setStream: aStream.	references _ IdentityDictionary new: 4096 * 5.	objects _ IdentityDictionary new: 4096 * 5.	fwdRefEnds _ IdentityDictionary new.	skipping _ insideASegment _ false.	blockers ifNil: [blockers _ IdentityDictionary new].	"keep blockers we just passed in"! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 9/27/2000 13:35'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	super setStream: aStream reading: isReading.	"isReading ifFalse: [  when we are sure"	references _ IdentityDictionary new: 4096 * 5.	isReading ifTrue: [		objects _ IdentityDictionary new: 4096 * 5.		skipping _ insideASegment _ false.		fwdRefEnds _ IdentityDictionary new].	blockers ifNil: [blockers _ IdentityDictionary new].	"keep blockers we just passed in"! !!ScreenController methodsFor: 'file in/out' stamp: 'tk 9/28/2000 15:47'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	dp _ DiskProxy global: #ScheduledControllers selector: #screenController args: #().	refStrm replace: self with: dp.	^ dp! !!SimpleButtonMorph methodsFor: 'fileIn/Out' stamp: 'tk 9/28/2000 15:49'!objectForDataStream: refStrm	"I am about to be written on an object file.  If I send a message to a BookMorph, it would be bad to write that object out.  Create and write out a URLMorph instead."	| bb thatPage um stem ind sqPg |	(actionSelector == #goToPageMorph:fromBookmark:) | 		(actionSelector == #goToPageMorph:) ifFalse: [			^ super objectForDataStream: refStrm].	"normal case"	target url ifNil: ["Later force target book to get a url."		bb _ SimpleButtonMorph new.	"write out a dummy"		bb label: self label.		bb bounds: bounds.		refStrm replace: self with: bb.		^ bb].	(thatPage _ arguments first) url ifNil: [			"Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."		stem _ target getStemUrl.	"know it has one"		ind _ target pages identityIndexOf: thatPage.		thatPage reserveUrl: stem,(ind printString),'.sp'].	um _ URLMorph newForURL: thatPage url.	sqPg _ thatPage sqkPage clone.	sqPg contentsMorph: nil.	um setURL: thatPage url page: sqPg.	(SqueakPage stemUrl: target url) = (SqueakPage stemUrl: thatPage url) 		ifTrue: [um book: true]		ifFalse: [um book: target url].  	"remember which book"	um privateOwner: owner.	um bounds: bounds.	um isBookmark: true; label: self label.	um borderWidth: borderWidth; borderColor: borderColor.	um color: color.	refStrm replace: self with: um.	^ um! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 10/4/2000 15:45'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	structures _ Dictionary new.	superclasses _ Dictionary new.	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	(refs includesKey: #AnImageSegment) 		ifFalse: [			self uniClassInstVarsRefs: dummy.	"catalog the extra objects in UniClass inst vars"			refs keysDo: [:each | 				cls _ each class.				"cls isObsolete ifTrue: [self error: 'Trying to write ', cls name]."				(cls class ~~ Metaclass) & (cls isObsolete not) ifTrue: [					structures at: cls name put: false]]]		ifTrue: [self recordImageSegment: refs].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures at: #Point put: false.	"writeRectangle: does not put out class pointer"	structures at: #Rectangle put: false.	structures keysDo: [:nm | 		cls _ (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	(refs includesKey: #AnImageSegment) 		ifTrue: [classInstVars _ #()]		ifFalse: [self saveClassInstVars].	"of UniClassses"	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 10/4/2000 15:40'!recordImageSegment: refs	"Besides the objects being written out, record the structure of instances inside the image segment we are writing out."	| cls list |	"Do not record Player class inst vars.  They are in the segement."	refs keysDo: [:each | 		cls _ each class.		cls isObsolete ifTrue: [self error: 'Trying to write ', cls name].		cls class == Metaclass 			ifFalse: [structures at: cls name put: false.				(each isKindOf: ImageSegment) ifTrue: [					each outPointers do: [:out | "Why necessary??"						(out isKindOf: Class) ifTrue: [							structures at: out theNonMetaClass name put: false]].					each arrayOfRoots do: [:rr | (rr isKindOf: Class) ifTrue: [							structures at: rr theNonMetaClass name put: false]]]]		].	list _ refs at: #BlockReceiverClasses ifAbsent: [^ self].	list do: [:meta | structures at: meta name put: false].		"Just the metaclasses whose instances are block receivers.  Otherwise metaclasses are not allowed."! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 9/28/2000 15:50'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	dp _ DiskProxy global: #StrikeFont selector: #familyName:size:emphasized:			args: (Array with: self familyName   with: self height					with: self emphasis).	refStrm replace: self with: dp.	^ dp! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'tk 10/3/2000 13:01'!associationOrUndeclaredAt: key 	"return an association or install in undeclared.  Used for mating up ImageSegments."	^ self associationAtOrAbove: key ifAbsent: [		Undeclared at: key put: nil.		Undeclared associationAt: key]! !!SystemDictionary methodsFor: 'objects from disk' stamp: 'tk 9/28/2000 15:50'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to Smalltalk instead."	dp _ DiskProxy global: #Smalltalk selector: #yourself			args: #().	refStrm replace: self with: dp.	^ dp! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'tk 9/28/2000 15:50'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."self == SystemOrganization ifTrue: [	dp _ DiskProxy global: #SystemOrganization selector: #yourself args: #().	refStrm replace: self with: dp.	^ dp].^ self! !!TextStyle methodsFor: 'Disk I/O' stamp: 'tk 9/25/2000 10:10'!storeDataOn: aDataStream	"The shared arrays in tabsArray and marginTabsArray are the globals DefaultTabsArray and DefaultMarginTabsArray.  DiskProxies will be substituted for these in (Array objectForDataStream:)."	^ super storeDataOn: aDataStream! !!Utilities class methodsFor: 'flaps' stamp: 'tk 9/25/2000 10:57'!globalFlapTab: aName	| nn |	"Find a global flap tab by name.  May be either 'flap: Tools' or 'Tools'. "	nn _ (aName beginsWith: 'flap: ') ifTrue: [aName] ifFalse: ['flap: ', aName].	^ self globalFlapTabsIfAny detect: [:ft | ft flapMenuTitle = nn] ifNone: [nil]! !!Utilities class methodsFor: 'flaps' stamp: 'tk 9/25/2000 11:14'!globalFlapTabOrDummy: aName	| gg |	"Find a global flap tab by name.  May be either 'flap: Tools' or 'Tools'.  Be sure to supply a "	(gg _ self globalFlapTab: aName) ifNil: [		^ StringMorph new string: aName, ' can''t be found'].	^ gg! !WorldState removeSelector: #objectForDataStream:!TranscriptStream removeSelector: #objectForDataStream:!ProjectViewMorph removeSelector: #exportSegment!Project removeSelector: #exportSegment!Project removeSelector: #exportSegmentWithCatagories:classes:!PasteUpMorph removeSelector: #storeDataOn:!