'From Squeak 2.3 beta of Nov 25, 1998 on 20 December 1998 at 11:11:21 pm'!"Change Set:		TransitionsDate:			20 December 1998Author:			Dan IngallsThis changeSet defines TransitionMorph, and uses it in BookMorph>>goToPage:.The facility has been integrated in several ways.  In the control menu of BookMorphs, under the book... entry, you will now find items for setting the visual or sound effect for all pages or for the current page.  Similar items can also be found now in the control menus for bookmarks and thumbnails.  The bookmark setting override the page settings, and these override the book settings, and these override the default found in BookMorph>>transitionSpec.The transitions currently implemented include...	slideOver	new image slides over old	slideAway	old image slides away over old	slideBoth	newimage slides in as old slides out	slideBorder	border slides (wipes) from old to new	...these are available as (right downRight down downLeft left upLeft up upRight)	pageForward	old shrinks away revealing new	pageBack	new grows out covering old	...these are available as (right down left up)	zoomFrame	new frame grows or old frame shrinks	zoom		new image grows or old image shrinks	...these are available as (in out)	dissolvepageForward, pageBack, zoom and dissolve are pretty slow, but I haven't really worked on performance yet."!Morph subclass: #TransitionMorph	instanceVariableNames: 'startMorph endMorph startBlock completionBlock stepNumber nSteps stepTime startForm endForm effect direction '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 12/20/1998 17:19'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	(bookMorph isKindOf: BookMorph)		ifTrue:			[aCustomMenu add: 'set page sound' action: #setPageSound:.			aCustomMenu add: 'set page visual' action: #setPageVisual:]! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 12/20/1998 17:26'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"Flip to this page with no extra sound"	| tSpec |	tSpec _ self valueOfProperty: #transitionSpec.	tSpec ifNil: [BookMorph turnOffSoundWhile:					[bookMorph goToPage: pageNumber]]		ifNotNil: [bookMorph goToPage: pageNumber transitionSpec: tSpec]! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 12/20/1998 17:29'!setPageSound: event	^ bookMorph menuPageSoundFor: self event: event! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 12/20/1998 17:29'!setPageVisual: event	^ bookMorph menuPageVisualFor: self event: event! !!BooklikeMorph methodsFor: 'misc' stamp: 'di 12/20/1998 09:49'!playPageFlipSound	^ self playPageFlipSound: 'camera'! !!BooklikeMorph methodsFor: 'misc' stamp: 'di 12/20/1998 13:19'!playPageFlipSound: soundName	(self presenter soundsEnabled "user-controllable" and:		[PageFlipSoundOn])  "mechanism to suppress sounds at init time"			ifTrue: [self playSoundNamed: soundName].! !!BookMorph methodsFor: 'navigation' stamp: 'di 12/20/1998 10:18'!goToPage: pageNumber	^ self goToPage: pageNumber transitionSpec: nil! !!BookMorph methodsFor: 'navigation' stamp: 'di 12/20/1998 16:24'!goToPage: pageNumber transitionSpec: transitionSpec	| pageIndex  aWorld oldPageNumber ascending newPage tSpec |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	tSpec _ transitionSpec ifNil:  "If transition not specified by requestor..."		[newPage valueOfProperty: #transitionSpec  " ... then consult new page"			ifAbsent: [self transitionSpecFor: self  " ... otherwise this is the default"]].	oldPageNumber _ pages indexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue: [nil]			ifFalse: [oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	currentPage ifNotNil:		[(currentPage owner isKindOf: TransitionMorph) ifTrue: [^ self]].	self currentPage ~~ nil		ifTrue:		[(currentPage owner isKindOf: TransitionMorph) ifTrue:			["Means we are currently in the process of a prior pageTurn"			"^ self"].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		ascending ifNotNil:			["Show appropriate page transition and start new page when done"			^ (TransitionMorph					effect: tSpec second					direction: tSpec third					inverse: ascending not)				replace: currentPage andRelease: true				by: (pages at: pageIndex)				whenStart:					[self playPageFlipSound: tSpec first]				whenDone:					[currentPage _ pages at: pageIndex.					self snapToEdgeIfAppropriate.					aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].					self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].					(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld]]].		"No transition, but at least decommission current page"		currentPage delete; fullReleaseCachedState].	self addMorphBack: (currentPage _ pages at: pageIndex).	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld].! !!BookMorph methodsFor: 'navigation' stamp: 'di 12/20/1998 16:40'!goToPageMorph: aMorph fromBookmark: aBookmark	"This protocol enables sensitivity to a transitionSpec on the bookmark"	| ii |	ii _ self pageNumberOf: aMorph.	ii = 0 ifFalse:		[self goToPage: ii				transitionSpec: (aBookmark valueOfProperty: #transitionSpec)].! !!BookMorph methodsFor: 'navigation' stamp: 'di 12/20/1998 14:00'!transitionSpecFor: aMorph	^ aMorph valueOfProperty: #transitionSpec  " check for special propety"		ifAbsent: [Array with: 'camera'  " ... otherwise this is the default"						with: #pageForward						with: #left]! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 13:54'!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu add: 'set page sound for all' action: #menuPageSoundForAll:.	subMenu add: 'set page visual for all' action: #menuPageVisualForAll:.	subMenu add: 'set sound for this page' action: #menuPageSoundForThisPage:.	subMenu add: 'set visual for this page' action: #menuPageVisualForThisPage:.	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	subMenu add: 'send other pages to server' action: #savePagesOnURL.	aMenu add: 'book...' subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 16:59'!bookmarkForThisPage	| b |	b _ SimpleButtonMorph new target: self.	b actionSelector: #goToPageMorph:fromBookmark:.	b label: 'Bookmark'.	b arguments: (Array with: currentPage with: b).	self primaryHand attachMorph: b! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 14:11'!menuPageSoundFor: target event: evt	| tSpec menu |	tSpec _ self transitionSpecFor: target.	menu _ (MenuMorph entitled: 'Choose a sound(it is now ' , tSpec first , ')') defaultTarget: target.	SampledSound soundNames do:		[:soundName |		menu add: soundName target: target			selector: #setProperty:toValue:			argumentList: (Array with: #transitionSpec								with: (tSpec copyAt: 1 put: soundName))].	menu popUpAt: evt hand position forHand: evt hand.! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 13:53'!menuPageSoundForAll: evt	^ self menuPageSoundFor: self event: evt! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 13:55'!menuPageSoundForThisPage: evt	currentPage ifNotNil:		[^ self menuPageSoundFor: currentPage event: evt]! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 17:12'!menuPageVisualFor: target event: evt	| tSpec menu subMenu directionChoices |	tSpec _ self transitionSpecFor: target.	menu _ (MenuMorph entitled: 'Choose an effect(it is now ' , tSpec second , ')') defaultTarget: target.	TransitionMorph allEffects do:		[:effect |		directionChoices _ TransitionMorph directionsForEffect: effect.		directionChoices isEmpty		ifTrue: [menu add: effect target: target					selector: #setProperty:toValue:					argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: #none))]		ifFalse: [subMenu _ MenuMorph new.				directionChoices do:					[:dir |					subMenu add: dir target: target						selector: #setProperty:toValue:						argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: dir))].				menu add: effect subMenu: subMenu]].	menu popUpAt: evt hand position forHand: evt hand.! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 17:16'!menuPageVisualForAll: evt	^ self menuPageVisualFor: self event: evt! !!BookMorph methodsFor: 'menu' stamp: 'di 12/20/1998 13:55'!menuPageVisualForThisPage: evt	currentPage ifNotNil:		[^ self menuPageVisualFor: currentPage event: evt]! !!Canvas methodsFor: 'drawing' stamp: 'di 12/14/1998 13:07'!image: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self image: aForm		at: aPoint		sourceRect: aForm boundingBox		rule: Form paint.! !!Canvas methodsFor: 'drawing' stamp: 'di 12/14/1998 13:06'!image: aForm at: aPoint rule: combinationRule	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self image: aForm		at: aPoint		sourceRect: aForm boundingBox		rule: combinationRule.! !!Form methodsFor: 'other' stamp: 'di 11/11/1998 13:17'!asGrayScale	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)"	| f32 srcForm result map bb grays |	depth = 32 ifFalse: [		f32 _ Form extent: width@height depth: 32.		self displayOn: f32.		^ f32 asGrayScale].	self unhibernate.	srcForm _ Form extent: (width * 4)@height depth: 8.	srcForm bits: bits.	result _ ColorForm extent: width@height depth: 8.	map _ Bitmap new: 256.	2 to: 256 do: [:i | map at: i put: i - 1].	map at: 1 put: 1.  "map zero pixel values to near-black"	bb _ (BitBlt toForm: result)		sourceForm: srcForm;		combinationRule: Form over;		colorMap: map.	0 to: width - 1 do: [:dstX |		bb  sourceRect: (((dstX * 4) + 2)@0 extent: 1@height);			destOrigin: dstX@0;			copyBits].	"final BitBlt to zero-out pixels that were truely transparent in the original"	map _ Bitmap new: 512.	map at: 1 put: 16rFF.	(BitBlt toForm: result)		sourceForm: self;		sourceRect: self boundingBox;		destOrigin: 0@0;		combinationRule: Form erase;		colorMap: map;		copyBits.		grays _ (0 to: 255) collect: [:brightness | Color gray: brightness asFloat / 255.0].	grays at: 1 put: Color transparent.	result colors: grays.	^ result! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 11/11/1998 13:20'!asGrayScale	"Return a grayscale ColorForm computed by mapping each color into its grayscale equivalent"	^ self copy colors:		(colors collect:			[:c | c isTransparent ifTrue: [c]						ifFalse: [Color gray: c luminance]])! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'di 12/20/1998 16:52'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label' action: #setLabel.	(target isKindOf: BookMorph)		ifTrue:			[aCustomMenu add: 'set page sound' action: #setPageSound:.			aCustomMenu add: 'set page visual' action: #setPageVisual:]		ifFalse:			[aCustomMenu add: 'change action selector' action: #setActionSelector.			aCustomMenu add: 'change arguments' action: #setArguments.			aCustomMenu add: 'change when to act' action: #setActWhen.			((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue:				[aCustomMenu add: 'set target' action: #setTarget:]].! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'di 12/20/1998 16:55'!setPageSound: event	^ target menuPageSoundFor: self event: event! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'di 12/20/1998 16:55'!setPageVisual: event	^ target menuPageVisualFor: self event: event! !!TransitionMorph commentStamp: '<historical>' prior: 0!A transitionMorph inserts itself in the morphic object structure during a visual transition.  It has a stepNumber that runs from 1 to nSteps.  This class handles a large family of wipe-like transitions by itself.  Subclasses may implement other transitions such as dissolves and zooms.!!TransitionMorph reorganize!('initialization' completeReplacement initiateReplacement: nSteps:stepTime: replace:andRelease:by:whenStart:whenDone: startMorph:endMorph:startBlock:completionBlock:)('drawing' areasRemainingToFill: drawDissolveOn: drawOn: drawPageBackOn: drawPageForwardOn: drawSlideAwayOn: drawSlideBorderOn: drawSlideBothOn: drawSlideOverOn: drawZoomFrameOn: drawZoomOn: imageForm)('change reporting' changed)('stepping' step stepTime)('private' effect:direction: prevStepFrom:to: stepFrom:to:)!!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/20/1998 12:39'!completeReplacement	owner replaceSubmorph: self by: endMorph.	startMorph privateOwner: nil.	completionBlock value! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/20/1998 21:48'!initiateReplacement: doRelease	| n |	startMorph owner ifNil: [self error: 'no owner'].	stepNumber _ 0.	"Later we may want to merge bounds."	self bounds: (startMorph bounds merge: endMorph bounds).	startForm _ startMorph imageForm offset: 0@0.	doRelease ifTrue: [startMorph fullReleaseCachedState].	endForm _ endMorph imageForm offset: 0@0.	nSteps == nil ifTrue:		[self nSteps: 20 stepTime: 30.		(#(zoom pageForward pageBack) includes: effect) ifTrue:			[n _ 20 * 100000 // self bounds area min: 20 max: 4.			self nSteps: n stepTime: 30].		(#dissolve = effect) ifTrue:			[n _ 20 * 50000 // self bounds area min: 20 max: 4.			self nSteps: n stepTime: 30]].	startMorph owner replaceSubmorph: startMorph by: self.	startBlock value.  "with forms in place there should b no further delay."	"Now we point startMorph's owner field at self.  This allows testing elsewhere if there is a transition in progress.  Doing this without a proper self addMorph: is a mild violation of morphic structure.  However a full addMorph: would cause invalidation and redisplay of startMorph, thus bringin startMorph back out of hibernation, and all."	startMorph privateOwner: self.  ! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/14/1998 12:25'!nSteps: n stepTime: msPerStep	nSteps _ n.	stepTime _ msPerStep! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/20/1998 10:44'!replace: oneMorph andRelease: doRelease by: otherMorph	whenStart: firstBlock whenDone: doneBlock	effect == #none ifTrue:		[oneMorph owner replaceSubmorph: oneMorph by: otherMorph.		doRelease ifTrue: [oneMorph fullReleaseCachedState].		firstBlock value.		^ doneBlock value].	self startMorph: oneMorph endMorph: otherMorph		startBlock: firstBlock completionBlock: doneBlock.	self initiateReplacement: doRelease! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/20/1998 10:46'!startMorph: start endMorph: end startBlock: firstBlock completionBlock: aBlock	startMorph _ start.	endMorph _ end.	startBlock _ firstBlock.	completionBlock _ aBlock! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/15/1998 14:04'!areasRemainingToFill: aRectangle	"May be overridden by any subclasses with opaque regions"	^ Array new! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/15/1998 15:36'!drawDissolveOn: aCanvas	"startForm and endFrom are both fixed, but the dissolve ration changes."	| buffer |	buffer _ Form extent: self extent depth: 16.	startForm displayOn: buffer.	buffer copyBits: endForm at: 0@0 translucent: stepNumber asFloat / nSteps.	aCanvas image: buffer at: self position rule: Form over.! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/15/1998 15:30'!drawOn: aCanvas	"During the transition process, the reveal and obscure areas will be invalidated,	so we should be drawing on a canvas that clips to only the changing region."	(stepNumber between: 1 and: nSteps) ifFalse: [^ self].	effect = #slideOver ifTrue: [^ self drawSlideOverOn: aCanvas].	effect = #slideBoth ifTrue: [^ self drawSlideBothOn: aCanvas].	effect = #slideAway ifTrue: [^ self drawSlideAwayOn: aCanvas].	effect = #slideBorder ifTrue: [^ self drawSlideBorderOn: aCanvas].	effect = #pageForward ifTrue: [^ self drawPageForwardOn: aCanvas].	effect = #pageBack ifTrue: [^ self drawPageBackOn: aCanvas].	effect = #zoomFrame ifTrue: [^ self drawZoomFrameOn: aCanvas].	effect = #zoom ifTrue: [^ self drawZoomOn: aCanvas].	effect = #dissolve ifTrue: [^ self drawDissolveOn: aCanvas].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/14/1998 15:43'!drawPageBackOn: aCanvas	"endForm grows in the given direction, overlaying endForm."	| offset growRect scale |	aCanvas image: startForm at: self position rule: Form over.	offset _ self stepFrom: self extent * direction negated to: 0@0.	growRect _ (bounds translateBy: offset) intersect: bounds.	scale _ growRect extent asFloatPoint / bounds extent.	aCanvas image: (endForm magnify: endForm boundingBox by: scale smoothing: 1)		at: growRect topLeft rule: Form over.	((growRect translateBy: direction) areasOutside: growRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/14/1998 15:37'!drawPageForwardOn: aCanvas	"startForm shrinks in the given direction, revealing endForm."	| offset shrinkRect scale |	aCanvas image: endForm at: self position rule: Form over.	offset _ self stepFrom: 0@0 to: self extent * direction.	shrinkRect _ (bounds translateBy: offset) intersect: bounds.	scale _ shrinkRect extent asFloatPoint / bounds extent.	aCanvas image: (startForm magnify: startForm boundingBox by: scale smoothing: 1)		at: shrinkRect topLeft rule: Form over.	((shrinkRect translateBy: direction negated) areasOutside: shrinkRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/15/1998 14:58'!drawSlideAwayOn: aCanvas	"startMorph slides away in the given direction, revealing up the endMorph."	| startLoc moveRect |	startLoc _ self stepFrom: self position to: self position + (self extent * direction).	moveRect _ startForm boundingBox translateBy: startLoc.	aCanvas image: endForm at: self position rule: Form over.	aCanvas image: startForm at: startLoc rule: Form over.	((moveRect translateBy: direction negated) areasOutside: moveRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/15/1998 14:50'!drawSlideBorderOn: aCanvas	"startForm and endFrom are both fixed, but a border slides in the given direction, revealing endForm.  (It's like opening a can of sardines ;-)."	| endRect box sourceRect boxLoc |	box _ endForm boundingBox.	boxLoc _ self stepFrom: box topLeft - (box extent * direction) to: box topLeft.	sourceRect _ box translateBy: boxLoc.	endRect _ sourceRect translateBy: self position.	((endRect expandBy: 1) containsRect: aCanvas clipRect) ifFalse:		[aCanvas image: startForm at: self position rule: Form over].	aCanvas image: endForm at: self position + boxLoc sourceRect: sourceRect rule: Form over.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/14/1998 14:36'!drawSlideBothOn: aCanvas	"endMorph slides in the given direction, as startMorph slides out of its way."	| endLoc endRect startLoc |	startLoc _ self stepFrom: self position to: self position + (self extent * direction).	aCanvas image: startForm at: startLoc rule: Form over.	endLoc _ self stepFrom: self position - (self extent * direction) to: self position.	aCanvas image: endForm at: endLoc rule: Form over.	endRect _ endForm boundingBox translateBy: endLoc.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/15/1998 14:48'!drawSlideOverOn: aCanvas	"endMorph slides in the given direction, covering up the startMorph."	| endLoc endRect |	endLoc _ self stepFrom: self position - (self extent * direction) to: self position.	endRect _ endForm boundingBox translateBy: endLoc.	((endRect expandBy: 1) containsRect: aCanvas clipRect) ifFalse:		[aCanvas image: startForm at: self position rule: Form over].	aCanvas image: endForm at: endLoc rule: Form over.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/20/1998 15:32'!drawZoomFrameOn: aCanvas	"startForm and endFrom are both fixed, but a border expands in or out, revealing endForm.	It's like passing through a doorway."	| box innerForm outerForm boxExtent |	direction = #in		ifTrue: [innerForm _ endForm.  outerForm _ startForm.				boxExtent _ self stepFrom: 0@0 to: self extent]		ifFalse: [innerForm _ startForm.  outerForm _ endForm.				boxExtent _ self stepFrom: self extent to: 0@0].			aCanvas image: outerForm at: self position rule: Form over.	box _ Rectangle center: self center extent: boxExtent.	aCanvas image: innerForm at: box topLeft sourceRect: (box translateBy: self position negated) rule: Form over.	((box expandBy: 1) areasOutside: box) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/14/1998 17:50'!drawZoomOn: aCanvas	"Zoom in: endForm expands overlaying startForm.	Zoom out: startForm contracts revealing endForm."	| box innerForm outerForm boxExtent scale |	direction = #in		ifTrue: [innerForm _ endForm.  outerForm _ startForm.				boxExtent _ self stepFrom: 0@0 to: self extent]		ifFalse: [innerForm _ startForm.  outerForm _ endForm.				boxExtent _ self stepFrom: self extent to: 0@0].	aCanvas image: outerForm at: self position rule: Form over.	box _ Rectangle center: self center extent: boxExtent.	scale _ box extent asFloatPoint / bounds extent.	aCanvas image: (innerForm magnify: innerForm boundingBox by: scale smoothing: 1)		at: box topLeft rule: Form over.	((box expandBy: 1) areasOutside: box) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'di 12/18/1998 00:15'!imageForm	startForm ifNotNil: [^ startForm].	startMorph ifNotNil: [^ startMorph imageForm].	^ Form new! !!TransitionMorph methodsFor: 'change reporting' stamp: 'di 12/20/1998 15:32'!changed	"The default (super) method is, generally much slower than need be, since many transitions only change part of the screen on any given step of the animation.  The purpose of this method is to effect some of those savings."	| loc box boxPrev |	(stepNumber between: 1 and: nSteps) ifFalse: [^ super changed].	effect = #slideBoth ifTrue: [^ super changed].	effect = #slideOver ifTrue:		[loc _ self stepFrom: self position - (self extent * direction) to: self position.		^ self invalidRect: (((loc extent: self extent) expandBy: 1) intersect: bounds)].	effect = #slideAway ifTrue:		[loc _ self prevStepFrom: self position to: self position + (self extent * direction).		^ self invalidRect: (((loc extent: self extent) expandBy: 1) intersect: bounds)].	effect = #slideBorder ifTrue:		[box _ endForm boundingBox translateBy:				(self stepFrom: self topLeft - (self extent * direction) to: self topLeft).		boxPrev _ endForm boundingBox translateBy:				(self prevStepFrom: self topLeft - (self extent * direction) to: self topLeft).		(((box expandBy: 1) intersect: bounds)			areasOutside: (boxPrev intersect: bounds))			do: [:r | self invalidRect: r].		^ self].	effect = #pageForward ifTrue:		[loc _ self prevStepFrom: 0@0 to: self extent * direction.		^ self invalidRect: (((bounds translateBy: loc) expandBy: 1) intersect: bounds)].	effect = #pageBack ifTrue:		[loc _ self stepFrom: self extent * direction negated to: 0@0.		^ self invalidRect: (((bounds translateBy: loc) expandBy: 1) intersect: bounds)].	effect = #zoomFrame ifTrue:		[direction = #in		ifTrue: [box _ Rectangle center: self center						extent: (self stepFrom: 0@0 to: self extent).				boxPrev _ Rectangle center: self center						extent: (self prevStepFrom: 0@0 to: self extent).				(((box expandBy: 1) intersect: bounds) areasOutside: boxPrev)					do: [:r | self invalidRect: r]]		ifFalse: [box _ Rectangle center: self center						extent: (self stepFrom: self extent to: 0@0).				boxPrev _ Rectangle center: self center						extent: (self prevStepFrom: self extent to: 0@0).				(((boxPrev expandBy: 1) intersect: bounds) areasOutside: box)					do: [:r | self invalidRect: r]].		^ self].	effect = #zoom ifTrue:		[box _ Rectangle center: self center extent:			(direction = #in				ifTrue: [self stepFrom: 0@0 to: self extent]				ifFalse: [self prevStepFrom: self extent to: 0@0]).		^ self invalidRect: ((box expandBy: 1) intersect: bounds)].	^ super changed! !!TransitionMorph methodsFor: 'stepping' stamp: 'di 12/14/1998 12:30'!step	(stepNumber _ stepNumber + 1) <= nSteps		ifTrue: [self changed]		ifFalse: [self completeReplacement]! !!TransitionMorph methodsFor: 'stepping' stamp: 'di 12/15/1998 13:52'!stepTime	^ stepTime! !!TransitionMorph methodsFor: 'private' stamp: 'di 12/20/1998 22:03'!effect: effectSymbol direction: dirSymbol	| i |	effect _ effectSymbol.	"Default directions"	(#(zoom zoomFrame) includes: effectSymbol)		ifTrue: [(#(in out) includes: dirSymbol)					ifTrue: [direction _ dirSymbol]					ifFalse: [direction _ #in]]		ifFalse: [i _ #(right downRight down downLeft left upLeft up upRight)						indexOf: dirSymbol ifAbsent: [5].				direction _ (0@0) eightNeighbors at: i].! !!TransitionMorph methodsFor: 'private' stamp: 'di 12/15/1998 11:42'!prevStepFrom: p1 to: p2	"Used for recalling dimensions from previous step."	^ (p2-p1) * (stepNumber-1) // nSteps + p1! !!TransitionMorph methodsFor: 'private' stamp: 'di 12/14/1998 12:43'!stepFrom: p1 to: p2	"This gives p1 for stepCount = 0, moving to p2 for stepCount = nSteps"	^ (p2-p1) * stepNumber // nSteps + p1! !!TransitionMorph class reorganize!('initialization' effect:direction: effect:direction:inverse: includeInNewMorphMenu)('available effects' allEffects directionsForEffect:)!!TransitionMorph class methodsFor: 'initialization' stamp: 'di 12/20/1998 22:01'!effect: effectSymbol direction: dirSymbol	^ self new effect: effectSymbol direction: dirSymbol! !!TransitionMorph class methodsFor: 'initialization' stamp: 'di 12/20/1998 21:37'!effect: effectSymbol direction: dirSymbol inverse: inverse	| invEffect invDir i dirSet |	inverse ifFalse: [^ self effect: effectSymbol direction: dirSymbol].	invEffect _ effectSymbol.	effectSymbol = #pageForward ifTrue: [invEffect _ #pageBack].	effectSymbol = #pageBack ifTrue: [invEffect _ #pageForward].	effectSymbol = #slideOver ifTrue: [invEffect _ #slideAway].	effectSymbol = #slideAway ifTrue: [invEffect _ #slideOver].	invDir _ dirSymbol.	dirSet _ self directionsForEffect: effectSymbol.	(i _ dirSet indexOf: dirSymbol) > 0		ifTrue: [invDir _ dirSet atWrap: i + (dirSet size // 2)].	^ self effect: invEffect direction: invDir! !!TransitionMorph class methodsFor: 'initialization' stamp: 'di 11/16/1998 15:37'!includeInNewMorphMenu	"Transitions aren't meaningful without initializations"	^ false! !!TransitionMorph class methodsFor: 'available effects' stamp: 'di 12/20/1998 10:22'!allEffects	^ #(slideOver slideBoth slideAway slideBorder pageForward pageBack 		zoomFrame zoom		dissolve)! !!TransitionMorph class methodsFor: 'available effects' stamp: 'di 12/20/1998 23:08'!directionsForEffect: eff	(#(slideOver slideBoth slideAway slideBorder) includes: eff)		ifTrue: [^ #(right downRight down downLeft left upLeft up upRight)].	(#(pageForward pageBack) includes: eff)		ifTrue: [^ #(right down left up)].	(#(zoomFrame zoom) includes: eff)		ifTrue: [^ #(in out)].	^ Array new! !BookMorph removeSelector: #transitionSpec!BookMorph removeSelector: #setPageVisualForAll!BookMorph removeSelector: #setPageVisualFor:event:!BookMorph removeSelector: #setPageSoundForAll!Form removeSelector: #xmagnify:by:smoothing:!TransitionMorph removeSelector: #effect:direction:inverse:!