'From Squeak 2.1 of June 30, 1998 on 9 September 1998 at 2:06:38 am'!BitBlt subclass: #CharacterScanner	instanceVariableNames: 'lastIndex xTable stopConditions text textStyle alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth emphasisCode kern indentationLevel '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!TextAttribute subclass: #TextIndent	instanceVariableNames: 'amount '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!Model subclass: #ValueHolder	instanceVariableNames: 'contents '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Support'!!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 7/21/1998 01:34'!nbsp	"non-breakable space.  It looks like a space, but it's not considered a separator"	#xxx. "this is correct for ISO 8859-1.  However, Squeak seems to use something different internally..."	^Character value: 160! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 18:55'!indentationLevel	"return the number of tabs that are currently being placed at the beginning of each line"	^indentationLevel isNil ifTrue: [ 0 ] ifFalse: [ indentationLevel ]! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 18:54'!indentationLevel: anInteger	"set the number of tabs to put at the beginning of each line"	indentationLevel _ anInteger! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 19:45'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta displaying: display 	"This method will perform text scanning with non-zero kerning.	It calls the faster primitive method, if the kern delta is zero.	Some day we may want to put kerning into the primitive."	| ascii nextDestX maxAscii fillBlt |	line first = startIndex ifTrue: [		"handle indentation"		self indentationLevel timesRepeat: [ self tab ] ].		kernDelta = 0 ifTrue:		[^ self scanCharactersFrom: startIndex to: stopIndex in: sourceString				rightX: rightX stopConditions: stops displaying: display].	display ifTrue: [fillBlt _ self fillBlt].	maxAscii _ xTable size-2.	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			ascii > maxAscii ifTrue: [ascii _ maxAscii].			(stopConditions at: ascii + 1) == nil				ifFalse: [^stops at: ascii + 1].			sourceX _ xTable at: ascii + 1.			nextDestX _ destX + (width _ (xTable at: ascii + 2) - sourceX).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			display ifTrue:				[self copyBits				fillBlt == nil ifFalse:					[fillBlt destX: nextDestX destY: destY							width: kernDelta height: height;							copyBits]].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CharacterScanner methodsFor: 'private' stamp: 'ls 7/16/1998 01:39'!setFont	"Set the font and other emphasis."	self setFont: 1.	emphasisCode _ 0.	kern _ 0.	indentationLevel _ 0.	alignment _ textStyle alignment.	(text attributesAt: lastIndex) do: 		[:att | att emphasizeScanner: self].	font _ font emphasized: emphasisCode.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.  "Should only be needed in DisplayScanner"	height _ font height.			" ditto "	xTable _ font xTable.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: #space.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX! !!Stream methodsFor: 'printing' stamp: 'djp 7/21/1998 11:40'!print: anObject	anObject printOn: self! !!Stream methodsFor: 'printing' stamp: 'djp 7/21/1998 17:13'!printHtml: anObject	anObject printHtmlOn: self! !!String methodsFor: 'testing' stamp: 'ls 7/4/1998 19:17'!isAllSeparators	"whether the receiver is composed entirely of separators"	self do: [ :c | c isSeparator ifFalse: [ ^false ] ].	^true! !!String methodsFor: 'internet' stamp: 'ls 9/5/1998 18:59'!replaceHtmlCharRefs        | pos ampIndex scIndex special specialValue outString outPos newOutPos |        outString _ String new: self size.        outPos _ 0.        pos _ 1.                [ pos <= self size ] whileTrue: [                 "read up to the next ampersand"                ampIndex _ self indexOf: $& startingAt: pos ifAbsent: [0].                                ampIndex = 0 ifTrue: [                        pos = 1 ifTrue: [ ^self ] ifFalse: [ ampIndex _ self size + 1 ] ].                newOutPos _ outPos + ampIndex - pos.                outString                        replaceFrom: outPos + 1                        to: newOutPos                        with: self                        startingAt: pos.                outPos _ newOutPos.                pos _ ampIndex.                ampIndex <= self size ifTrue: [                        "find the $;"                        scIndex _ self indexOf: $; startingAt: ampIndex ifAbsent: [ self size ].                        special _ self copyFrom: ampIndex+1 to: scIndex-1.                                specialValue _ String valueOfHtmlEntity: special.                        specialValue                                ifNil: [                                        "not a recognized entity.  wite it back"                                        newOutPos _ outPos + scIndex - ampIndex + 1.                                        outString                                                replaceFrom: outPos+1                                                to: newOutPos                                                with: self                                                startingAt: ampIndex.                                        outPos _ newOutPos.]                                ifNotNil: [                                        outPos _ outPos + 1.                                        outString at: outPos put: specialValue.].                                                pos _ scIndex + 1. ]. ].        ^outString copyFrom: 1 to: outPos! !!String methodsFor: 'internet' stamp: 'ls 7/27/1998 23:17'!withInternetLineEndings	"change line endings from CR's to CRLF's.  This is probably in prepration for sending a string over the Internet"	| cr lf |	cr _ Character cr.	lf _ Character linefeed.	^self class streamContents: [ :stream |		self do: [ :c |			stream nextPut: c.			c = cr ifTrue:[ stream nextPut: lf ]. ] ].! !!String methodsFor: 'internet' stamp: 'ls 8/20/1998 05:50'!withSqueakLineEndings	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings.  Replace each occurence with a single CR"	| cr lf lineStart lineEnd out outPos newOutPos  |	self = String cr ifTrue: [ ^self ].	out _ String new: self size.	outPos _ 1.	cr _ Character cr.	lf _ Character linefeed.	"process one line each time through this loop"	lineStart _ 1.	[ true ] whileTrue: [		lineEnd _ self indexOfAnyOf: CSLineEnders startingAt: lineStart.		lineEnd = 0 ifTrue: [			"no end-of-line found--we've reached the end of the string"			newOutPos _ outPos + self size - lineStart + 1.			out				replaceFrom: outPos				to: newOutPos - 1				with: self 				startingAt: lineStart.			^out copyFrom: 1 to: newOutPos-1 ].		"add the line"		lineEnd _ lineEnd - 1.		newOutPos _ outPos + lineEnd - lineStart + 2.		out			replaceFrom: outPos			to: newOutPos - 2			with: self			startingAt: lineStart.		outPos _ newOutPos.		"add a Squeaky terminator"		out at: outPos-1 put: cr.		"skip two characters if CRLF, otherwise just skip one"		((self at: (lineEnd+1)) = cr 			and: [ lineEnd + 2 <= self size 			and: [ (self at: lineEnd+1) = lf ] ])		ifTrue: [ lineStart _ lineEnd + 3 ]		ifFalse: [ lineStart _ lineEnd + 2 ].	].! !!String methodsFor: 'internet' stamp: 'ls 7/1/1998 02:26'!withoutQuoting	"remove the initial and final quote marks, if present"	"'''h''' withoutQuoting"	| quote |	self size < 2 ifTrue: [ ^self ].	quote _ self first.	(quote = $' or: [ quote = $" ])		ifTrue: [ ^self copyFrom: 2 to: self size - 1 ]		ifFalse: [ ^self ].! !!String methodsFor: 'converting' stamp: 'ls 8/20/1998 10:43'!withSeparatorsCompacted	"replace each sequences of whitespace by a single space character"	| out pos textEnd |	self isEmpty ifTrue: [ ^self ].	out _ WriteStream on: (String new: self size).	pos _ 1.   "current position in a scan through aString"	"handle the case of initial separators"	self first isSeparator ifTrue: [		out nextPut: Character space.		pos _ self indexOfAnyOf: CSNonSeparators ifAbsent: [ self size + 1 ] ].	"central loop: handle a segment of text, followed possibly by a segment of whitespace"	[ pos <= self size ] whileTrue: [ 		"handle a segment of text..."		textEnd _ self 			indexOfAnyOf: CSSeparators			startingAt: pos 			ifAbsent: [ self size + 1 ].		textEnd _ textEnd - 1.		out nextPutAll: (self copyFrom: pos to: textEnd).		pos _ textEnd + 1.		pos <= self size ifTrue: [			pos _ self 				indexOfAnyOf: CSNonSeparators				startingAt: pos				ifAbsent: [ self size + 1 ].			out nextPut: Character space  ] ].	^out contents! !!String class methodsFor: 'internet' stamp: 'ls 8/15/1998 20:22'!valueOfHtmlEntity: specialEntity	specialEntity = 'quot' ifTrue: [ ^$" ].	specialEntity = 'lt' ifTrue: [ ^$< ].	specialEntity = 'amp' ifTrue: [ ^$& ].	specialEntity = 'gt' ifTrue: [ ^ $>].	specialEntity = 'nbsp' ifTrue: [ ^ Character nbsp ].	(specialEntity beginsWith: '#') ifTrue: [		^Character value: (specialEntity copyFrom: 2 to: specialEntity size) asNumber ].	^nil ! !!TextIndent commentStamp: 'ls 9/9/1998 02:06' prior: 0!create a hanging indent. !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount	"number of tab spaces to indent by"	^amount! !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount: anInteger	"change the number of tabs to indent by"	amount _ anInteger! !!TextIndent methodsFor: 'printing' stamp: 'ls 6/22/1998 18:03'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' amount: '.	amount printOn: aStream! !!TextIndent methodsFor: 'setting indentation' stamp: 'ls 6/22/1998 18:56'!emphasizeScanner: scanner	scanner indentationLevel: amount! !!TextIndent methodsFor: 'condensing' stamp: 'ls 6/22/1998 19:27'!dominates: anAttribute	^(self class == anAttribute class)! !!TextIndent class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:55'!amount: amount	"create a TextIndent which will indent by the given amount.  Currently this is a number of tabs, but may change in the futur"	^super new amount: amount! !!TextIndent class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:54'!tabs: numTabs	"create an indentation by the given number of tabs"	^self amount: numTabs! !!TextIndent class methodsFor: 'example' stamp: 'ls 6/24/1998 18:06'!example	"TextIndent example"	| text pg |	"create an example text with some indentation"	text _ 'abcdao euoaeuo aeuo aeuoaeu o aeuoeauefgh bcd efghi'  asText.	text addAttribute: (TextColor red)  from: 3 to: 8.	text addAttribute: (TextIndent amount: 1) from: 1 to: 2.	text addAttribute: (TextIndent amount: 2) from: 20 to: 35.	"stick it in a paragraph and display it"	pg _ text asParagraph.	pg compositionRectangle: (0@0 extent: 100@200).	pg textStyle alignment: 2.	pg displayAt: 0@0.! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'ls 8/5/1998 07:49'!contents	^contents! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'ls 8/5/1998 07:49'!contents: newContents	contents _ newContents.	self changed: #contents! !