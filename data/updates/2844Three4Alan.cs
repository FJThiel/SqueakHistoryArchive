'From Squeak2.9alpha of 13 June 2000 [latest update: #2891] on 25 October 2000 at 4:36:46 pm'!"Change Set:		Three4AlanDate:			25 October 2000Author:			Andreas RaabThree fixes for Alan plus some cleanup.#1: Some scripts didn't start stepping. Now they will.#2: Grabbing morphs from flexed environments led to strange offsets.#3: Dropping flexed morphs in translated environments left the morphs somewhere far outside."!!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:04'!bounds: aRectangle from: referenceMorph	"Return the receiver's bounds as seen by aMorphs coordinate frame"	owner ifNil: [^ aRectangle].	^(owner transformFrom: referenceMorph) globalBoundsToLocal: aRectangle! !!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:04'!bounds: aRectangle in: referenceMorph	"Return the receiver's bounds as seen by aMorphs coordinate frame"	owner ifNil: [^ aRectangle].	^(owner transformFrom: referenceMorph) localBoundsToGlobal: aRectangle! !!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:04'!boundsIn: referenceMorph	"Return the receiver's bounds as seen by aMorphs coordinate frame"	^self bounds: self bounds in: referenceMorph! !!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:05'!boundsInWorld	^self bounds: self bounds in: self world! !!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:06'!fullBoundsInWorld	^self bounds: self fullBounds in: self world! !!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:06'!globalPointToLocal: aPoint	^self point: aPoint from: nil! !!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:07'!localPointToGlobal: aPoint	^self point: aPoint in: nil! !!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:01'!point: aPoint from: aReferenceMorph	owner ifNil: [^ aPoint].	^ (owner transformFrom: aReferenceMorph) globalPointToLocal: aPoint.! !!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:01'!point: aPoint in: aReferenceMorph	owner ifNil: [^ aPoint].	^ (owner transformFrom: aReferenceMorph) localPointToGlobal: aPoint.! !!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:02'!pointFromWorld: aPoint	^self point: aPoint from: self world! !!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:03'!pointInWorld: aPoint	^self point: aPoint in: self world! !!Morph methodsFor: 'geometry' stamp: 'ar 10/25/2000 15:15'!setConstrainedPositionFrom: aPoint	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds."	| trialRect delta boundingMorph |	owner ifNil:[^self].	trialRect _ aPoint extent: self bounds extent.	boundingMorph _ self topRendererOrSelf owner.	delta _ boundingMorph			ifNil:    [0@0]			ifNotNil: [trialRect amountToTranslateWithin: boundingMorph bounds].	self position: aPoint + delta.	self layoutChanged  "So that, eg, surrounding text will readjust"! !!HaloMorph methodsFor: 'events' stamp: 'ar 10/25/2000 15:10'!blueButtonDown: event	"Transfer the halo to the next likely recipient"	target ifNil:[^self delete].	event hand obtainHalo: self.	positionOffset _ event position - (target point: target position in: owner).	"wait for drags or transfer"	event hand 		waitForClicksOrDrag: self 		event: event		selectors: { #transferHalo:. nil. #dragTarget:. }		threshold: 5.! !!HaloMorph methodsFor: 'events' stamp: 'ar 10/25/2000 15:13'!dragTarget: event	"Begin dragging the target"	| thePoint |	thePoint _ target point: event position - positionOffset from: owner.	target setConstrainedPositionFrom: thePoint.	event hand newMouseFocus: self.! !!HaloMorph methodsFor: 'events' stamp: 'ar 10/25/2000 15:12'!mouseMove: evt	"Drag our target around"	| thePoint |	thePoint _ target point: (evt position - positionOffset) from: owner.	target setConstrainedPositionFrom: thePoint.! !!HaloMorph methodsFor: 'events' stamp: 'ar 10/25/2000 15:11'!popUpFor: aMorph event: evt	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."	| hand anEvent |	self flag: #workAround. "We should really have some event/hand here..."	evt isNil		ifTrue:[	hand _ aMorph world activeHand.				hand ifNil:[hand _ aMorph world primaryHand].				anEvent _ hand lastEvent transformedBy: (aMorph transformedFrom: nil)]		 ifFalse:[hand _ evt hand.				anEvent _ evt].	self target: aMorph.	hand halo: self.	hand world addMorphFront: self.	positionOffset _ anEvent position - (aMorph point: aMorph position in: owner).	self startStepping.! !!HaloMorph methodsFor: 'events' stamp: 'ar 10/25/2000 15:11'!popUpFor: aMorph hand: aHand	"Programatically pop up a halo for a given hand."	self target: aMorph.	aHand halo: self.	aHand world addMorphFront: self.	positionOffset _ aHand position - (aMorph point: aMorph position in: owner).	self startStepping.! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/25/2000 15:14'!doDrag: evt with: dragHandle	| thePoint |	evt hand obtainHalo: self.	thePoint _ target point: evt position - positionOffset from: owner.	target setConstrainedPositionFrom:(target griddedPoint: thePoint).! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/25/2000 15:10'!startDrag: evt with: dragHandle	| itsOwner |	"Drag my target without removing it from its owner."	evt hand obtainHalo: self.	self removeAllHandlesBut: dragHandle.	positionOffset _ dragHandle center - (target point: target position in: owner).	 ((itsOwner _ target topRendererOrSelf owner) notNil and:			[itsOwner automaticViewing]) ifTrue:				[target openViewerForArgument]"Smalltalk at: #Q put: OrderedCollection new"! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/25/2000 15:10'!startGrow: evt with: growHandle	| botRt |	"Initialize resizing of my target.  Launch a command representing it, to support Undo"	evt hand obtainHalo: self.	growingOrRotating _ true.	self removeAllHandlesBut: growHandle.  "remove all other handles"	botRt _ target point: target bottomRight in: owner.	(self world viewBox containsPoint: botRt)		ifTrue: [positionOffset _ evt cursorPoint - botRt]		ifFalse: [positionOffset _ 0@0].	self setProperty: #commandInProgress toValue:		(Command new			cmdWording: 'resizing';			undoTarget: target selector: #extent: argument: target extent)! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/25/2000 14:50'!grabMorph: aMorph	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| grabbed |	self releaseMouseFocus. "Break focus"	grabbed _ aMorph aboutToBeGrabbedBy: self.	grabbed ifNil:[^self].	grabbed _ grabbed topRendererOrSelf.	^self grabMorph: grabbed from: grabbed owner! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/25/2000 16:01'!grabMorph: aMorph from: formerOwner	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| grabbed tfm offset tfm2 targetPoint |	self releaseMouseFocus. "Break focus"	grabbed _ aMorph.	tfm _ formerOwner ifNil:[IdentityTransform new] ifNotNil:[formerOwner grabTransform].	tfm2 _ formerOwner ifNil:[IdentityTransform new] ifNotNil:[formerOwner transformFrom: owner].	targetPoint _ tfm2 globalPointToLocal: self position.	offset _ targetPoint - (tfm globalPointToLocal: self position).	grabbed _ grabbed transformedBy: tfm.	grabbed position: grabbed position - offset asIntegerPoint.	targetOffset _ grabbed position - self position.	self addMorphBack: grabbed.! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 14:52'!mouseDown: evt	"Handle a mouse down event."	| grabbedMorph |	grabbedMorph _ self morphToGrab: evt.	grabbedMorph ifNotNil:[		grabbedMorph isSticky ifTrue:[^self].		self isPartsBin ifFalse:[^evt hand grabMorph: grabbedMorph].		grabbedMorph _ grabbedMorph partRepresented duplicate.		(grabbedMorph fullBounds containsPoint: evt position) 			ifFalse:[grabbedMorph position: evt position].		"Note: grabbedMorph is ownerless after duplicate so use #grabMorph:from: instead"		^evt hand grabMorph: grabbedMorph from: self].	(super handlesMouseDown: evt)		ifTrue:[^super mouseDown: evt].	evt hand halo: nil. "shake off halos"	evt hand releaseKeyboardFocus. "shake of keyboard foci"	evt shiftPressed ifTrue:[		^evt hand 			waitForClicksOrDrag: self 			event: evt 			selectors: { #findWindow:. nil. #dragThroughOnDesktop:}			threshold: 5].	self isWorldMorph ifTrue:[self addAlarm: #invokeWorldMenu: with: evt after: 200].! !!ScriptInstantiation methodsFor: 'status control' stamp: 'ar 10/25/2000 14:53'!chooseTriggerFrom: aMorph	"Put up a menu of status alternatives and carry out the request"	| aMenu reply standardStati  m |	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging opening closing "keyStroke").	aMenu _ SelectionMenu labelList:  #(		'normal'		" -- run when called"				'paused' 		"ready to run all the time"		'ticking'		"run all the time"		'mouseDown'	"run when mouse goes down on me"		'mouseStillDown'	"while mouse still down"		'mouseUp'		"when mouse comes back up"		'mouseEnter'	"when mouse enters my bounds, button up"		'mouseLeave'	"when mouse exits my bounds, button up"		'mouseEnterDragging'	"when mouse enters my bounds, button down"		'mouseLeaveDragging'	"when mouse exits my bounds, button down"		'opening'	"when I am being opened"		'closing'	"when I am being closed"	"	'keyStroke'	run when user hits a key"		'what do these mean?'		)		lines: #(1 3 6 10 12)		selections: (standardStati, #(explainStatusAlternatives)).	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply == #explainStatusAlternatives ifTrue: [^ self explainStatusAlternatives].	reply ifNotNil: 		[self status: reply.  "Gets event handlers fixed up"		reply == #paused ifTrue:			[m _ player costume.			(m isKindOf: SpeakerMorph) ifTrue: [m stopSound]].		self updateAllStatusMorphs]! !!ScriptInstantiation methodsFor: 'status control' stamp: 'ar 10/25/2000 14:55'!status: newStatus	| stati actualMorph |	actualMorph _ player costume renderedMorph.	((stati _ ScriptingSystem standardEventStati) includes: status)		ifTrue:			[actualMorph on: status send: nil to: nil].  			"remove old link in event handler"	(stati includes: newStatus)		ifTrue:			[actualMorph on: newStatus send: selector to: player].  "establish new link in evt handler"	status _ newStatus.	self flag: #arNote.	self flag: #workaround. "Code below was in #chooseTriggerFrom: which did not reflect status changes from other places (e.g., the stepping/pause buttons). It is not clear why this is necessary though - theoretically, any morph should step when it has a player but alas!! something is broken and I have no idea why and where."	status == #ticking ifTrue: [player costume arrangeToStartStepping].! !!SystemWindow methodsFor: 'events' stamp: 'ar 10/25/2000 15:05'!doFastFrameDrag	| offset newBounds outerWorldBounds |	outerWorldBounds _ self boundsIn: nil.	offset _ outerWorldBounds origin - Sensor cursorPoint.	newBounds _ outerWorldBounds newRectFrom: [:f | 		Sensor cursorPoint + offset extent: outerWorldBounds extent	].	^ self position: (self globalPointToLocal: newBounds topLeft) ! !!TransformationMorph methodsFor: 'change reporting' stamp: 'ar 10/25/2000 16:21'!layoutChanged	"Recompute bounds as a result of change"	self computeBounds.	super layoutChanged! !!TransformationMorph methodsFor: 'geometry' stamp: 'ar 10/25/2000 16:20'!computeBounds	self hasSubmorphs ifTrue:		[bounds _ (transform localBoundsToGlobal:					(Rectangle merging:						(self submorphs collect: [:m | m fullBounds]))) truncated				expandBy: 1].! !!TransformationMorph methodsFor: 'geometry' stamp: 'ar 10/25/2000 16:24'!transformedBy: aTransform	self changed.	self transform: (self transform composedWithGlobal: aTransform).	self computeBounds.	self changed.! !Morph removeSelector: #boundsInOutermostWorld!Morph removeSelector: #transformFromNearestWorld!