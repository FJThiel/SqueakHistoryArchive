'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5623] on 30 January 2004 at 3:25:03 pm'!"Change Set:		KCP-185-RespondsToCleansDate:			30 January 2004Author:			stephane ducasseremove some unnecessary respondsTo invocations.(merged PNGReadWriter>>nextImage with 5810 -dew)"!!CodeLoader methodsFor: 'installing' stamp: 'sd 1/30/2004 15:16'!installSegment: reqEntry	"Install the previously loaded segment"	| contentStream contents trusted |	contentStream _ reqEntry value contentStream.	contentStream ifNil:[^self error:'No content to install: ', reqEntry key printString].	trusted _ SecurityManager default positionToSecureContentsOf: contentStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		contentStream close.		^self error:'Insecure content encountered: ', reqEntry key printString]].	contents _ contentStream ascii upToEnd unzipped.	(contentStream respondsTo: #close) ifTrue:[contentStream close].	^(RWBinaryOrTextStream with: contents) reset fileInObjectAndCode install.! !!CodeLoader methodsFor: 'installing' stamp: 'sd 1/30/2004 15:16'!installSourceFile: aStream	"Install the previously loaded source file"	| contents trusted |	aStream ifNil:[^self error:'No content to install'].	trusted _ SecurityManager default positionToSecureContentsOf: aStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) 					ifFalse:[ aStream close.							^ self error:'Insecure content encountered']].	contents _ aStream ascii upToEnd unzipped.	(aStream respondsTo: #close) ifTrue:[aStream close].	^(RWBinaryOrTextStream with: contents) reset fileIn! !!FlashFileReader methodsFor: 'reading' stamp: 'sd 1/30/2004 15:17'!processFileContents	"Process the contents of the flash file.	Assume that the header has been read before."	| time |	time _ Time millisecondsToRun:[	self isStreaming ifTrue:[		"Don't show progress for a streaming connection.		Note: Yielding is done someplace else."		[self processTagFrom: stream] whileTrue.	] ifFalse:[		'Reading file' displayProgressAt: Sensor cursorPoint			from: 1 to: 100			during:[:theBar|		[self processTagFrom: stream] whileTrue:[			theBar value: (stream position * 100 // stream size).			stream atEnd ifTrue:[				log ifNotNil:[					log cr; nextPutAll:'Unexpected end of data (no end tag)'.					self flushLog].				^self]].		].	].	stream close.	].	Transcript cr; print: time / 1000.0; show:' secs to read file'! !!ImageReadWriter methodsFor: 'stream access' stamp: 'sd 1/30/2004 15:18'!close		stream close! !!ImageReadWriter methodsFor: 'private' stamp: 'sd 1/30/2004 15:18'!on: aStream	(stream _ aStream) reset.	stream binary.	"Note that 'reset' makes a file be text.  Must do this after."! !!GIFReadWriter methodsFor: 'accessing' stamp: 'sd 1/30/2004 15:18'!nextImage	"Read in the next GIF image from the stream. Read it all intomemory first for speed."	| f thisImageColorTable |	stream class == ReadWriteStream ifFalse: [		stream binary.		self on: (ReadWriteStream with: (stream contentsOfEntireFile))].	localColorTable _ nil.	self readHeader.	f _ self readBody.	self close.	f == nil ifTrue: [^ self error: 'corrupt GIF file'].	thisImageColorTable _ localColorTable ifNil: [colorPalette].	transparentIndex ifNotNil: [		transparentIndex + 1 > thisImageColorTable size ifTrue: [			thisImageColorTable _ thisImageColorTable 				forceTo: transparentIndex + 1 				paddingWith: Color white		].		thisImageColorTable at: transparentIndex + 1 put: Color transparent	].	f colors: thisImageColorTable.	^ f! !!AnimatedGIFReadWriter methodsFor: 'accessing' stamp: 'sd 1/30/2004 15:15'!allImages	| body colorTable offset |	stream class == ReadWriteStream ifFalse: [		stream binary.		self on: (ReadWriteStream with: (stream contentsOfEntireFile))].	localColorTable _ nil.	forms _ OrderedCollection new.	offsets _ OrderedCollection new.	delays _ OrderedCollection new.	comments _ OrderedCollection new.	self readHeader.	[(body _ self readBody) == nil]		whileFalse: [colorTable _ localColorTable						ifNil: [colorPalette].			transparentIndex				ifNotNil: [transparentIndex + 1 > colorTable size						ifTrue: [colorTable _ colorTable forceTo: transparentIndex + 1 paddingWith: Color white].					colorTable at: transparentIndex + 1 put: Color transparent].			body colors: colorTable.			forms add: body.			offsets add: offset.			delays add: delay].	^ forms! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'sd 1/30/2004 15:18'!formFromStream: aBinaryStream	"Answer a ColorForm stored on the given stream.  closes the stream"	| reader readerClass form  |	readerClass _ self withAllSubclasses		detect: [:subclass | subclass understandsImageFormat: aBinaryStream]		ifNone: [			aBinaryStream close.			^self error: 'image format not recognized'].	reader _ readerClass new on: aBinaryStream reset.	Cursor read showWhile: [		form _ reader nextImage.		reader close].	^ form! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'sd 1/30/2004 15:19'!nextImageSuggestedDepth: depth	"Decode and answer a Form of the given depth from my stream. Close the stream if it is a file stream. Possible depths are 16-bit and 32-bit."	| bytes width height form jpegDecompressStruct jpegErrorMgr2Struct depthToUse |	bytes _ stream upToEnd.	stream close.	jpegDecompressStruct _ ByteArray new: self primJPEGDecompressStructSize.	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.	self 		primJPEGReadHeader: jpegDecompressStruct 		fromByteArray: bytes		errorMgr: jpegErrorMgr2Struct.	width _ self primImageWidth: jpegDecompressStruct.	height _ self primImageHeight: jpegDecompressStruct.	"Odd width images of depth 16 gave problems. Avoid them (or check carefully!!)"	depthToUse _ ((depth = 32) | width odd) ifTrue: [32] ifFalse: [16].	form _ Form extent: width@height depth: depthToUse.	(width = 0 or: [height = 0]) ifTrue: [^ form].	self		primJPEGReadImage: jpegDecompressStruct		fromByteArray: bytes		onForm: form		doDithering: true		errorMgr: jpegErrorMgr2Struct.	^ form! !!PNGReadWriter methodsFor: 'accessing' stamp: 'sd 1/30/2004 15:20'!nextImage	bigEndian := Smalltalk isBigEndian.	filtersSeen _ Bag new.	globalDataChunk _ nil.	transparentPixelValue _ nil.	unknownChunks _ Set new.	stream reset.	stream binary.	stream skip: 8.	[stream atEnd] whileFalse: [self processNextChunk].	"Set up our form"	palette ifNotNil:[		"Dump the palette if it's the same as our standard palette"		palette = (StandardColors copyFrom: 1 to: palette size) 			ifTrue:[palette := nil]].	(depth <= 8 and:[palette notNil]) ifTrue:[		form := ColorForm extent: width@height depth: depth.		form colors: palette.	] ifFalse:[		form := Form extent: width@height depth: depth.	].	backColor ifNotNil:[form fillColor: backColor].	chunk _ globalDataChunk ifNil:[self error: 'image data is missing'].	chunk ifNotNil: [self processIDATChunk].	unknownChunks isEmpty ifFalse: [		"Transcript show: ' ',unknownChunks asSortedCollection asArray printString."	].	self debugging ifTrue: [		Transcript cr; show: 'form = ',form printString.		Transcript cr; show: 'colorType = ',colorType printString.		Transcript cr; show: 'interlaceMethod = ',interlaceMethod printString.		Transcript cr; show: 'filters = ',filtersSeen sortedCounts asArray printString.	].	^ form! !!PluginHTTPRequest methodsFor: 'accessing' stamp: 'sd 1/30/2004 15:21'!contents	| |	semaphore wait.	(content isNil and:[fileStream notNil]) ifTrue:["		pos _ fileStream position."		fileStream position: 0.		content _ MIMEDocument content: fileStream upToEnd.		fileStream close.	].	^content! !!PluginHTTPRequest methodsFor: 'accessing' stamp: 'sd 1/30/2004 15:21'!signalAbort	fileStream ifNotNil: [		fileStream close].	fileStream _ nil.	super signalAbort.! !!ResourceManager class methodsFor: 'resource caching' stamp: 'sd 1/30/2004 15:21'!reloadCachedResources	"ResourceManager reloadCachedResources"	"Reload cached resources from the disk"	| fd files stream url localName storeBack archiveName |	CachedResources _ Dictionary new.	LocalizedExternalResources _ nil.	fd _ Project squeakletDirectory.	files _ fd fileNames asSet.	stream _ [fd readOnlyFileNamed: self resourceCacheName]				on: FileDoesNotExistException 				do:[:ex| fd forceNewFileNamed: self resourceCacheName].	stream size < 50000 ifTrue:[stream _ ReadStream on: stream contentsOfEntireFile].	storeBack _ false.	[stream atEnd] whileFalse:[		url _ stream upTo: Character cr.			localName _ stream upTo: Character cr.		(localName beginsWith: 'zip://') ifTrue:[			archiveName _ localName copyFrom: 7 to: localName size.			(files includes: archiveName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack _ true].		] ifFalse:[			(files includes: localName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack _ true]		].	].	stream close.	storeBack ifTrue:[		stream _ fd forceNewFileNamed: self resourceCacheName.		CachedResources keysAndValuesDo:[:urlString :cacheLocs|			cacheLocs do:[:cacheLoc|				stream nextPutAll: urlString; cr.				stream nextPutAll: cacheLoc; cr].		].		stream close.	].! !!SecurityManager methodsFor: 'security operations' stamp: 'sd 1/30/2004 15:22'!fileInObjectAndCode: aStream	| trusted |	trusted _ self positionToSecureContentsOf: aStream.	trusted ifFalse:[self enterRestrictedMode ifFalse:[		aStream close.		^nil]].	^aStream fileInObjectAndCode! !!SunAudioFileWriter methodsFor: 'other' stamp: 'sd 1/30/2004 15:23'!ensureOpen	"Ensure that my stream is open."	stream closed ifTrue: [stream reopen; binary].! !!TTFontReader methodsFor: 'public' stamp: 'sd 1/30/2004 15:24'!readFrom: aStream	| fontData headerEntry maxProfileEntry nameEntry indexLocEntry charMapEntry glyphEntry horzHeaderEntry horzMetricsEntry kerningEntry glyphOffset cmap numHMetrics indexToLocFormat |	"Read the raw font byte data"	aStream binary.	fontData _ aStream contents asByteArray.	fontDescription _ TTFontDescription new.	"Search the tables required to build the font"	(headerEntry _ self getTableDirEntry: 'head' from: fontData) == nil ifTrue:[		^self error:'This font does not have a header table'].	(maxProfileEntry _ self getTableDirEntry: 'maxp' from: fontData) == nil ifTrue:[		^self error:'This font does not have a maximum profile table'].	(nameEntry _ self getTableDirEntry: 'name' from: fontData) == nil ifTrue:[		^self error:'This font does not have a name table'].	(indexLocEntry _ self getTableDirEntry: 'loca' from: fontData) == nil ifTrue:[		^self error:'This font does not have a relocation table'].	(charMapEntry _ self getTableDirEntry: 'cmap' from: fontData) == nil ifTrue:[		^self error:'This font does not have a character map table'].	(glyphEntry _ self getTableDirEntry: 'glyf' from: fontData) == nil ifTrue:[		^self error:'This font does not have a glyph table'].	(horzHeaderEntry _ self getTableDirEntry: 'hhea' from: fontData) == nil ifTrue:[		^self error:'This font does not have a horizontal header table'].	(horzMetricsEntry _ self getTableDirEntry: 'hmtx' from: fontData) == nil ifTrue:[		^self error:'This font does not have a horizontal metrics table'].	(kerningEntry _ self getTableDirEntry: 'kern' from: fontData) == nil ifTrue:[		Transcript cr; show:'This font does not have a kerning table';endEntry].	"Process the data"	indexToLocFormat _ self processFontHeaderTable: headerEntry.	self processMaximumProfileTable: maxProfileEntry.	self processNamingTable: nameEntry.	glyphOffset _ self processIndexToLocationTable: indexLocEntry format: indexToLocFormat.	cmap _ self processCharacterMappingTable: charMapEntry.	(cmap == nil or:[cmap value == nil])		ifTrue:[^self error:'This font has no suitable character mappings'].	self processGlyphDataTable: glyphEntry offsets: glyphOffset.	numHMetrics _ self processHorizontalHeaderTable: horzHeaderEntry.	self processHorizontalMetricsTable: horzMetricsEntry length: numHMetrics.	kerningEntry isNil 		ifTrue:[kernPairs _ #()]		ifFalse:[self processKerningTable: kerningEntry].	charMap _ self processCharMap: cmap.	fontDescription setGlyphs: glyphs mapping: charMap.	fontDescription setKernPairs: kernPairs.	^fontDescription! !!ZipEncoder methodsFor: 'initialize-release' stamp: 'sd 1/30/2004 15:24'!close	self flush.	encodedStream close.! !