'From Squeak 2.1 of June 30, 1998 on 21 August 1998 at 9:53:17 pm'!"Change Set:		DragOverEvts-diDate:			21 August 1998Author:			Dan IngallsExtends support for dragOver events to the EventHandler mechanism.  [DragOver refers to mouseOver entry and exit events where either the hand is carrying something already, or has the button down, but with no recipient for mouseDown events].Modifies ScriptInstantiation>>status: to replicate its eventHandler setup so that mouseEnter is triggered by either mouseEnter or mouseEnterLaden (dragOver), with the intended result that mouseEnter scripts should again work the way they did before the dragOver distinction was introduced in May.Finally removes a number of unused methods from EventHandler."!Object subclass: #EventHandler	instanceVariableNames: 'mouseDownRecipient mouseDownSelector mouseStillDownRecipient mouseStillDownSelector mouseUpRecipient mouseUpSelector mouseEnterRecipient mouseEnterSelector mouseLeaveRecipient mouseLeaveSelector mouseEnterLadenRecipient mouseEnterLadenSelector mouseLeaveLadenRecipient mouseLeaveLadenSelector keyStrokeRecipient keyStrokeSelector valueParameter '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!EventHandler methodsFor: 'initialization' stamp: 'di 8/21/1998 14:24'!forgetDispatchesTo: aSelector	"aSelector is no longer implemented by my corresponding Player, so don't call it any more"	mouseDownSelector == aSelector		ifTrue:			[mouseDownRecipient _ mouseDownSelector _ nil].	mouseStillDownSelector == aSelector		ifTrue:			[mouseStillDownRecipient _ mouseStillDownSelector _ nil].	mouseUpSelector == aSelector		ifTrue:			[mouseUpRecipient _ mouseUpSelector _ nil].	mouseEnterSelector == aSelector		ifTrue:			[mouseEnterRecipient _ mouseEnterSelector _ nil].	mouseLeaveSelector == aSelector		ifTrue:			[mouseLeaveRecipient _ mouseLeaveSelector _ nil].	mouseEnterLadenSelector == aSelector		ifTrue:			[mouseEnterLadenRecipient _ mouseEnterLadenSelector _ nil].	mouseLeaveLadenSelector == aSelector		ifTrue:			[mouseLeaveLadenRecipient _ mouseLeaveLadenSelector _ nil].	keyStrokeSelector == aSelector		ifTrue:			[keyStrokeRecipient _ keyStrokeSelector _ nil].! !!EventHandler methodsFor: 'initialization' stamp: 'di 8/21/1998 14:24'!on: eventName send: selector to: recipient	eventName = #mouseDown ifTrue:		[mouseDownRecipient _ recipient.  mouseDownSelector _ selector. ^ self].	eventName = #mouseStillDown ifTrue:		[mouseStillDownRecipient _ recipient.  mouseStillDownSelector _ selector. ^ self].	eventName = #mouseUp ifTrue:		[mouseUpRecipient _ recipient.  mouseUpSelector _ selector. ^ self].	eventName = #mouseEnter ifTrue:		[mouseEnterRecipient _ recipient.  mouseEnterSelector _ selector. ^ self].	eventName = #mouseLeave ifTrue:		[mouseLeaveRecipient _ recipient.  mouseLeaveSelector _ selector. ^ self].	eventName = #mouseEnterLaden ifTrue:		[mouseEnterLadenRecipient _ recipient.  mouseEnterLadenSelector _ selector. ^ self].	eventName = #mouseLeaveLaden ifTrue:		[mouseLeaveLadenRecipient _ recipient.  mouseLeaveLadenSelector _ selector. ^ self].	eventName = #keyStroke ifTrue:		[keyStrokeRecipient _ recipient.  keyStrokeSelector _ selector. ^ self].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!EventHandler methodsFor: 'testing' stamp: 'di 8/21/1998 14:25'!handlesDragOver: evt	mouseEnterLadenRecipient ifNotNil: [^ true].	mouseLeaveLadenRecipient ifNotNil: [^ true].	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 8/21/1998 21:31'!handlesDragOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the hand drags something over me (button up or button down), or when the mouse button is down but there is no mouseDown recipient?.  The default response is false, except if you have added sensitivity to mouseEnterLaden: or mouseLeaveLaden:, using the on:send:to: mechanism."	"NOTE:  By simply returning true to dragOver: or mouseOver: a morph can cause mouseEnter: and mouseLeave: events to be sent to itself.  However if the hand state matters in these cases, it must be subsequently determined by a construct such as		event hand hand submorphCount > 0.If, instead, one uses the eventHandling mechanism as follows		morph1 on: #mouseEnter send: #mouseOver:from: to: self.		morph1 on: #mouseEnterLaden send: #dragOver:from: to: self.then the normal event dispatch will separate the cases of mouseOver entry and dragOver entry."	self eventHandler ifNotNil: [^ self eventHandler handlesDragOver: evt].	^ false! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'di 8/21/1998 21:43'!status: newStatus	| stati actualMorph |	actualMorph _ player costume renderedMorph.	((stati _ ScriptingSystem standardEventStati) includes: status)		ifTrue:			["remove old link in event handler"			actualMorph on: status send: nil to: nil.			status == #mouseEnter ifTrue:				["Etoy entry triggered by both entry cases"				actualMorph on: #mouseEnterLaden send: nil to: nil].			status == #mouseLeave ifTrue:				["Etoy leave triggered by both leave cases"				actualMorph on: #mouseLeaveLaden send: nil to: nil]].	(stati includes: newStatus)		ifTrue:			["establish new link in evt handler"			actualMorph on: newStatus send: selector to: player.			newStatus == #mouseEnter ifTrue:				["Etoy entry triggered by both entry cases"				actualMorph on: #mouseEnterLaden send: selector to: player].			newStatus == #mouseLeave ifTrue:				["Etoy leave triggered by both leave cases"				actualMorph on: #mouseLeaveLaden send: selector to: player]].  	status _ newStatus! !EventHandler removeSelector: #handleEvent:fromMorph:!EventHandler removeSelector: #actionsForwarded!EventHandler removeSelector: #valueParameter:!EventHandler removeSelector: #mouseDownRecipient!Morph removeSelector: #passToEventHandler:!