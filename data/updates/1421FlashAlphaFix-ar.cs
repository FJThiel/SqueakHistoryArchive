'From Squeak 2.5 of August 6, 1999 on 5 September 1999 at 2:14:01 pm'!"Change Set:		FlashAlphaFix-arDate:			5 September 1999Author:			Andreas RaabFixes related to alpha transforms (deep down the engine). Requires a new VM to take effect. [Note to Michael: Targeted at the rusty spots]"!!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 9/5/1999 14:13'!transformColor: fillIndex	| r g b a transform alphaScale |	self var: #transform declareC:'float *transform'.	self var: #alphaScale declareC:'double alphaScale'.	(fillIndex = 0 or:[self isFillColor: fillIndex]) ifFalse:[^fillIndex].	b _ fillIndex bitAnd: 255.	g _ (fillIndex >> 8) bitAnd: 255.	r _ (fillIndex >> 16) bitAnd: 255.	a _ (fillIndex >> 24) bitAnd: 255.	(self hasColorTransform) ifTrue:[		transform _ self colorTransform.		alphaScale _ (a * (transform at: 6) + (transform at: 7)) / a.		r _ (r * (transform at: 0) + (transform at: 1) * alphaScale) asInteger.		g _ (g * (transform at: 2) + (transform at: 3) * alphaScale) asInteger.		b _ (b * (transform at: 4) + (transform at: 5) * alphaScale) asInteger.		a _ a * alphaScale.		r _ r max: 0. r _ r min: 255.		g _ g max: 0. g _ g min: 255.		b _ b max: 0. b _ b min: 255.		a _ a max: 0. a _ a min: 255.	].	a < 1 ifTrue:[^0]."ALWAYS return zero for transparent fills"	"If alpha is not 255 (or close thereto) then we need to flush the engine before proceeding"	(a < 255 and:[self needsFlush]) 		ifTrue:[self stopBecauseOf: GErrorNeedFlush].	^b + (g << 8) + (r << 16) + (a << 24)! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 9/5/1999 13:49'!alphaSourceBlendBits16	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 16		sourceForm ~= destForm.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift ditherBase ditherIndex ditherThreshold |	self inline: false. "This particular method should be optimized in itself"	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	(dx bitAnd: 1) = 0 		ifTrue:[	mask1 _ 16r0000FFFF.				srcShift _ 16]		ifFalse:[mask1 _ 16rFFFF0000.				srcShift _ 0].	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		srcIndex _ (sourceBits + 4) + ((srcY * sourceRaster + sx) * 4).		dstIndex _ (destBits + 4) + ((dstY * destRaster + (dx // 2)) * 4).		ditherBase _ (dstY bitAnd: 3) * 4.		ditherIndex _ (sx bitAnd: 3) - 1. "For pre-increment"		deltaX _ bbW + 1. "So we can pre-decrement"		dstMask _ mask1.		dstMask = 16rFFFF ifTrue:[srcShift _ 16] ifFalse:[srcShift _ 0].		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			ditherThreshold _ ditherMatrix4x4 at: ditherBase + (ditherIndex _ ditherIndex + 1 bitAnd: 3).			sourceWord _ interpreterProxy longAt: srcIndex.			srcAlpha _ sourceWord >> 24.			srcAlpha = 255 ifTrue:[				"Dither from 32 to 16 bit"				sourceWord _ self dither32To16: sourceWord threshold: ditherThreshold.				sourceWord = 0 ifTrue:[sourceWord _ 1].				sourceWord _ sourceWord << srcShift.				destWord _ interpreterProxy longAt: dstIndex.				destWord _ destWord bitAnd: dstMask.				interpreterProxy longAt: dstIndex put: (sourceWord bitOr: destWord).			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifTrue:[				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord _ interpreterProxy longAt: dstIndex.					destWord _ destWord bitAnd: dstMask bitInvert32.					destWord _ destWord >> srcShift.					"Expand from 16 to 32 bit by adding zero bits"					destWord _ (((destWord bitAnd: 16r7C00) bitShift: 9) bitOr:									((destWord bitAnd: 16r3E0) bitShift: 6)) bitOr:								(((destWord bitAnd: 16r1F) bitShift: 3) bitOr:									16rFF000000).					"Mix colors"					sourceWord _ self alphaBlendScaled: sourceWord with: destWord.					"And dither"					sourceWord _ self dither32To16: sourceWord threshold: ditherThreshold.					sourceWord = 0 ifTrue:[sourceWord _ 1].					sourceWord _ sourceWord << srcShift.					destWord _ interpreterProxy longAt: dstIndex.					destWord _ destWord bitAnd: dstMask.					interpreterProxy longAt: dstIndex put: (sourceWord bitOr: destWord).				].			].			srcIndex _ srcIndex + 4.			srcShift = 0 ifTrue:[dstIndex _ dstIndex + 4].			srcShift _ srcShift bitXor: 16. "Toggle between 0 and 16"			dstMask _ dstMask bitInvert32. "Mask other half word"		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !