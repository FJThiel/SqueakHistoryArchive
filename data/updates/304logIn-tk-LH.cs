'From Squeak 2.2beta of Sept 16, 1998 on 22 September 1998 at 11:33:13 pm'!HierarchicalUrl subclass: #HttpUrl	instanceVariableNames: 'realm '	classVariableNames: 'Passwords '	poolDictionaries: ''	category: 'Network-Url'!!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:25'!httpGetDocument: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGetDocument: url args: nil accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:26'!httpGetDocument: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	^self httpGetDocument: url args: nil accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:26'!httpGetDocument: url args: args	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	^self httpGetDocument: url args: args accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 17:48'!httpGetDocument: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	^ self httpGetDocument: url args: args accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 19:01'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index connectToHost connectToPort type newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ self defaultPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [page _ page, self argString: args ].	HTTPProxyServer isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxyServer.			connectToPort _ HTTPProxyPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr; show: connectToHost; cr.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: header; cr.	firstData _ list at: 3.	header isEmpty 		ifTrue: [aStream _ 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length _ sock getHeader: 'content-length'.			length ifNotNil: [ length _ length asNumber ].			type _ sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl _ sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].			aStream _ sock getRestOfBuffer: firstData totalLength: length.			sock responseCode = '401' ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifFalse: [		]	].! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:27'!httpPost: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| document |	document _ self httpPostDocument: url  args: argsDict  accept: mimeType  request: ''.	(document isKindOf: String) ifTrue: [ 		"strings indicate errors"		^document ].		^RWBinaryOrTextStream with: document content! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:27'!httpPostDocument: url  args: argsDict	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^self httpPostDocument: url args: argsDict accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 20:16'!httpPostDocument: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^ self httpPostDocument: url args: argsDict accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 20:16'!httpPostDocument: url  args: argsDict accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| serverName serverAddr s header length bare page list firstData aStream port argsStream first specifiedServer type newUrl |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxy ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	first _ true.	argsDict associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsStream nextPut: $& ].			argsStream nextPutAll: assoc key encodeForHTTP.			argsStream nextPut: $=.			argsStream nextPutAll: value encodeForHTTP.	] ].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: application/x-www-form-urlencoded', CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: argsStream contents; cr; show: header; cr.	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpPostDocument: newUrl  args: argsDict  accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HTTPSocket class methodsFor: 'utilities' stamp: 'tk 9/22/1998 17:46'!argString: args	"Return the args in a long string, as encoded in a url"	| argsString first |	argsString _ WriteStream on: String new.	argsString nextPut: $?.	first _ true.	args associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsString nextPut: $& ].			argsString nextPutAll: assoc key encodeForHTTP.			argsString nextPut: $=.			argsString nextPutAll: value encodeForHTTP. ] ].	^ argsString contents! !!HttpUrl commentStamp: 'tk 9/22/1998 17:18' prior: 0!A URL that can be accessed via the Hypertext Transfer Protocol (HTTP), ie, a standard Web URLrealm = the name of the security realm that has been discovered for this URL.   Look it up in Passwords.Passwords = a Dictionary of (realm -> encoded user&password)!!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 23:08'!askNamePassword	"Authorization is required by the host site.  Ask the user for a userName and password.  Encode them and store under this realm.  Return false if the user wants to give up."	| user password |	(self confirm: 'Host ', self toText, 'wants a different user and password.  Type them now?' orCancel: [false])		ifFalse: [^ false].	"Note: When Scamper is converted to run under MVC, we'll have to pass in topView in order to decide which FillInTheBlank to call."	user _ FillInTheBlank request: 'User account name?' initialAnswer: '' 				centerAt: Sensor cursorPoint - (50@0).	password _ FillInTheBlank request: 'Password?'.	Passwords at: realm put: (Authorizer new encode: user password: password).	^ true! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:25'!postFormArgs: args	| contents request std oldRealm encoded |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpPostDocument: self toText args: args				accept: 'application/octet-stream' request: request).	(contents isKindOf: String) ifTrue: [		(contents beginsWith: 'HTTP/1.0 401 Unauthorized') ifTrue: [			std _ (PWS unauthorizedFor: '') findTokens: '"'.			(contents beginsWith: (std at: 1)) ifTrue: [				oldRealm _ realm.				realm _ (contents findTokens: '"') at: 2.				Passwords ifNil: [Passwords _ Dictionary new].				encoded _ Passwords at: realm ifAbsent: [nil].				(oldRealm ~= realm) & (encoded ~~ nil) 					ifTrue: [^ self postFormArgs: args]					ifFalse: ["ask the user"						self askNamePassword ifTrue: [^ self postFormArgs: args]]				]].		^MIMEDocument contentType: 'text/plain' content: 'error occured retrieving ', self toText, ': ', contents].	contents contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: contents content url: contents url ].	^contents! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 19:49'!privateInitializeFromText: aString relativeTo: aUrl	super privateInitializeFromText: aString relativeTo: aUrl.	realm _ aUrl realm.! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 19:47'!realm	^ realm! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:21'!retrieveContents	^ self retrieveContentsArgs: nil! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:21'!retrieveContentsArgs: args	| contents request std oldRealm encoded |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpGetDocument: self toText args: args				accept: 'application/octet-stream' request: request).	(contents isKindOf: String) ifTrue: [		(contents beginsWith: 'HTTP/1.0 401 Unauthorized') ifTrue: [			std _ (PWS unauthorizedFor: '') findTokens: '"'.			(contents beginsWith: (std at: 1)) ifTrue: [				oldRealm _ realm.				realm _ (contents findTokens: '"') at: 2.				Passwords ifNil: [Passwords _ Dictionary new].				encoded _ Passwords at: realm ifAbsent: [nil].				(oldRealm ~= realm) & (encoded ~~ nil) 					ifTrue: [^ self retrieveContentsArgs: args]					ifFalse: ["ask the user"						self askNamePassword ifTrue: [^ self retrieveContentsArgs: args]]				]].		^MIMEDocument contentType: 'text/plain' content: 'error occured retrieving ', self toText, ': ', contents].	contents contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: contents content url: contents url ].	^contents! !!HttpUrl class methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 23:13'!shutDown	"Forget all cached passwords, so they won't stay in the image"	Passwords _ nil.! !!Scamper methodsFor: 'changing page' stamp: 'tk 9/22/1998 20:26'!submitFormWithInputs: inputs  url: url  method: method	| newUrl newSource | 	self stopEverything.	(method asLowercase ~= 'get' and: [ method asLowercase ~= 'post' ]) ifTrue: [		self notify: 'unkown FORM method: ', method.		^false ].	newUrl _ url asUrlRelativeTo: currentUrl.		newUrl schemeName ~= 'http' ifTrue: [		self notify: 'I can only submit forms via HTTP'.		^false ].	self status: 'submitting form...'.	downloadingProcess _ [			method asLowercase = 'get' 				ifTrue: [newSource _ newUrl retrieveContentsArgs: inputs] 				ifFalse: [newSource _ newUrl postFormArgs: inputs].			documentQueue nextPut:  newSource.			downloadingProcess _ nil.		] newProcess.		downloadingProcess resume.		^true! !!Socket methodsFor: 'waiting' stamp: 'tk 9/22/1998 15:18'!waitForDataUntil: deadline	"Wait up until the given deadline for data to arrive. Return true if data arrives by the deadline, false if not."	| dataArrived |	[self isConnected & 	 (dataArrived _ self primSocketReceiveDataAvailable: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ dataArrived! !!Socket methodsFor: 'waiting' stamp: 'tk 9/22/1998 15:18'!waitForSendDoneUntil: deadline	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone |	[self isConnected & (sendDone _ self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ sendDone! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 15:03'!getAllDataWhileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 15:05'!getDataTo: dataStream whileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Don't know how much is coming.  Put the data on the stream."	| buf bytesRead |	buf _ String new: 4000.	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | dataStream nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	dataStream reset.	"position: 0."	^ dataStream! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'tk 9/22/1998 23:15'!processShutDownList	"Call the shutDown method on each object that needs to gracefully shut itself down before a snapshot."	Smalltalk at: #MailDB ifPresent: [:mailDB |		mailDB allInstancesDo: [:db | db saveDB]].  "snapshot all mail databases to disk"	Smalltalk at: #PWS ifPresent: [:pws | pws stopServer].	Smalltalk at: #Password ifPresent: [:password | password shutDown].	Smalltalk at: #HttpUrl ifPresent: [:urlClass | urlClass shutDown].	self shutDownSound.	Delay shutDown.	Smalltalk shutDown.	Color shutDown.	StrikeFont shutDown.	Smalltalk isMorphic ifFalse: [ControlManager shutDown].	Form shutDown.	DisplayScreen shutDown.! !