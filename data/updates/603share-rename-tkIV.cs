'From Squeak 2.3 of January 14, 1999 on 25 January 1999 at 3:30:01 pm'!!BookMorph commentStamp: 'tk 1/25/1999 11:52' prior: 0!A collection of pages, each of which is a place to put morphs.  Allows one or another page to show; orchestrates the page transitions; offers control panel for navigating among pages and for adding and deleting pages.To write a book out to the disk or to a file server, decide what folder it goes in.  Construct a url to a typical page:	file://myDisk/folder/myBook1.spor	ftp://aServer/folder/myBook1.spChoose "send all pages to server" from the book's menu (press the <> part of the controls).  Choose "use page numbers".  Paste in the url.To load an existing book, find its ".bo" file in the file list browser.  Choose "load as book".To load an existing book from its url, execute:Ã(URLMorph grabURL: 'ftp://aServer/folder/myBook1.sp') book: true.Multiple people may modify a book.  If other people may have changed a book you have on your screen, choose "reload all from server".Add or modify a page, and choose "send this page to server".The polite thing to do is to reload before changing a book.  Then write one or all pages soon after making your changes.  If you store a stale book, it will wipe out changes that other people made in the mean time.Pages may be linked to each other.  To create a named link to a new page, type the name of the page in a text area in a page.  Select it and do Cmd-6.  Choose 'link to'.  A new page of that name will be added at the back of the book.  Clicking on the blue text flips to that page.  	To create a link to an existing page, first name the page.  Go to that page and Cmd-click on it.  The name of the page is below the page.  Click in it and backspace and type.  Return to the page you are linking from.  Type the name. Cmd-6, 'link to'.  Text search:  Search for a set of fragments.  allStrings collects text of fields.  Turn to page with all fragments on it and highlight the first one.  Save the container and offset in properties: #searchContainer, #searchOffset, #searchKey.  Search again from there.  Clear those at each page turn, or change of search key.  [rules about book indexes and pages:  Index and pages must live in the same directory. They have the same file prefix, followed by .bo for the index or 4.sp for a page (or x4.sp).  When a book is moved to a new directory, the load routine gets the new urls for all pages and saves those in the index.  Book stores index url in property #url.      Allow mulitple indexes (books) on the same shared set of pages.  If book has a url in same directory as pages, allow them to have different prefixes.	save all pages first time, save one page first time, fromRemoteStream: (first time)	save all pages normal , save one page normal, reload	where I check if same dir][When URL morph says a specific page, it conflicts with book and page being unrelated.  book inst var has true if page in same book, url of book if different names.  nil or false if not for a book page at all.]!!BookMorph methodsFor: 'initialization' stamp: 'tk 1/24/1999 15:29'!fromRemoteStream: strm	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!  Index and pages must live in the same directory.  If the book has moved, save the current correct urls for each of the pages.  Self must already have a url stored in property #url."	| remote dict bookUrl oldStem stem oldUrl endPart |	remote _ strm fileInObjectAndCode.	bookUrl _ (SqueakPage new) url: (self valueOfProperty: #url); url.		"expand a relative url"	oldStem _ SqueakPage stemUrl: (remote at: 2) url.	oldStem _ oldStem copyUpToLast: $/.	stem _ SqueakPage stemUrl: bookUrl.	stem _ stem copyUpToLast: $/.	oldStem = stem ifFalse: [		"Book is in new directory, fix page urls"		2 to: remote size do: [:ii | 			oldUrl _ (remote at: ii) url.			endPart _ oldUrl copyFrom: oldStem size+1 to: oldUrl size.			(remote at: ii) url: stem, endPart]].	self initialize.	pages _ OrderedCollection new.	2 to: remote size do: [:ii | pages add: (remote at: ii)].	currentPage fullReleaseCachedState; delete.	"the blank one"	currentPage _ remote at: 2.	dict _ remote at: 1.	self setProperty: #modTime toValue: (dict at: #modTime).	dict at: #allText ifPresent: [:val |		self setProperty: #allText toValue: val].	dict at: #allTextUrls ifPresent: [:val |		self setProperty: #allTextUrls toValue: val].	#(color borderWidth borderColor pageSize) with: 		#(color: borderWidth: borderColor: pageSize:) do: [:key :sel |			dict at: key ifPresent: [:val | 			 	self perform: sel with: val]].	^ self! !!BookMorph methodsFor: 'initialization' stamp: 'tk 1/15/1999 08:02'!fromURL: url	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!"	| strm |	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	self setProperty: #url toValue: url.	self fromRemoteStream: strm.	^ self! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/15/1999 08:13'!getStemUrl	"Try to find the old place where this book was stored.  Confirm with the user.  Else ask for new place."| initial pg url knownURL |initial _ ''.(pg _ currentPage valueOfProperty: #SqueakPage) ifNotNil: [	pg contentsMorph == currentPage ifTrue: [		initial _ pg url.		knownURL _ true]].	"If this page has a url"pages doWithIndex: [:aPage :ind |	initial size = 0 ifTrue: [		aPage isInMemory ifTrue: [			(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [				initial _ pg url]]]].	"any page with a url"initial size = 0 ifTrue: [initial _ ServerDirectory defaultStemUrl, '1.sp'].	"A new legal place"knownURL ifNil: [	url _ FillInTheBlank 			request: 'url of the place to store a typical page in this book.	Must begin with file:// or ftp://' 			initialAnswer: initial].knownURL ifNotNil: [url _ initial].^ SqueakPage stemUrl: url! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/25/1999 15:29'!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| stem list firstTime bookUrl |stem _ self getStemUrl.	"user must approve"stem size = 0 ifTrue: [^ self].pages doWithIndex: [:aPage :ind | 	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage saveOnURL: stem,(ind printString),'.sp'.		self presenter ifNotNil: [self presenter flushPlayerListCache].		]].list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).firstTime _ (self valueOfProperty: #url) == nil.self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	bookUrl _ self valueOfProperty: #url.	(SqueakPage stemUrl: bookUrl) = (SqueakPage stemUrl: currentPage url) ifTrue: [		bookUrl _ true].		"not a shared book"	(URLMorph grabURL: currentPage url) book: bookUrl].! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/25/1999 14:23'!saveOnUrlPage: pageMorph	"Write out this single page in this book onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	| stem ind response rand newPlace dir |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.		^ self].	"Don't give the chance to put in a different place.  Assume named by number"	((self valueOfProperty: #url) == nil and: [pages first url ~~ nil]) ifTrue: [		response _ (PopUpMenu labels: 'New book\New book sharing old pages' 					withCRs)				startUpWithCaption: 'Modify the old book, or make a new\book sharing its pages?' withCRs.		response = 2 ifTrue: [			"Make up new url for .bo file and confirm with user."  "Mark as shared"			[rand _ String new: 4.			1 to: rand size do: [:ii |				rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].			newPlace _ ((self getStemUrl) copyUpToLast: $/), '/BK', rand, '.bo'.			dir _ ServerFile new fullPath: newPlace.			(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"			self setProperty: #url toValue: newPlace].		response = 0 ifTrue: [^ self]].	stem _ self getStemUrl.	"user must approve"	stem size = 0 ifTrue: [^ self].	ind _ pages identityIndexOf: pageMorph ifAbsent: [self error: 'where is the page?'].	pageMorph isInMemory ifTrue: ["not out now"			pageMorph saveOnURL: stem,(ind printString),'.sp'].	self saveIndexOfOnly: pageMorph.! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/25/1999 15:29'!savePagesOnURL	"Write out all pages in this book onto a server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are not in memory will stay that way.  The local disk could be the server."	| response list firstTime newPlace rand dir bookUrl |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.		^ self].	self getAllText.	"stored with index later"	response _ (PopUpMenu labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)\Save new book sharing old pages' withCRs)			startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' withCRs.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 5 ifTrue: [		"Make up new url for .bo file and confirm with user."  "Mark as shared"		[rand _ String new: 4.		1 to: rand size do: [:ii |			rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].		newPlace _ ((self getStemUrl) copyUpToLast: $/), '/BK', rand, '.bo'.		dir _ ServerFile new fullPath: newPlace.		(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"		self setProperty: #url toValue: newPlace.		self saveAsNumberedURLs. 		bookUrl _ self valueOfProperty: #url.		(SqueakPage stemUrl: bookUrl) = 			(SqueakPage stemUrl: currentPage url) ifTrue: [				bookUrl _ true].		"not a shared book"		(URLMorph grabURL: currentPage url) book: bookUrl.		^ self].	response = 0 ifTrue: [^ self].pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage saveOnURLbasic.		self presenter ifNotNil: [self presenter flushPlayerListCache].		]].	"ask user if no url"list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).firstTime _ (self valueOfProperty: #url) == nil.self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	(URLMorph grabURL: (self valueOfProperty: #url)) book: true].! !!FileList methodsFor: 'file list menu' stamp: 'tk 1/15/1999 08:36'!openBookFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| book aFileStream |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ directory oldFileNamed: self fullName.	book _ BookMorph new.	book setProperty: #url toValue: (aFileStream url).	book fromRemoteStream: aFileStream.	World		ifNotNil:			[World addMorphsAndModel: book]		ifNil:			[(book isKindOf: Morph)				ifFalse:					[^ self inform: 'can only load a single morph into an MVC project via this mechanism'].				book openInWorld].	book goToPage: 1.! !!FileStream methodsFor: 'file accessing' stamp: 'tk 1/15/1999 11:38'!url	"Convert my path into a file:// type url.  Use slash instead of the local delimiter (:), and convert odd characters to %32 notation."	"If / is not the file system delimiter, encode / before converting."	| list |	list _ self directory pathParts.	^ String streamContents: [:strm |		strm nextPutAll: 'file:/'.		list do: [:each | strm nextPut: $/; nextPutAll: each encodeForHTTP].		strm nextPut: $/; nextPutAll: self localName encodeForHTTP]! !!ObjectOut methodsFor: 'access' stamp: 'tk 1/15/1999 11:43'!url: aString	url _ aString! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 1/25/1999 15:16'!url	^ remoteFile url! !!SequenceableCollection methodsFor: 'copying' stamp: 'tk 1/23/1999 12:49'!copyUpTo: anElement 	"Answer a copy of the receiver from index 1 to the first occurrence of 	anElement, not including anElement."	| index |	index _ self indexOf: anElement ifAbsent: [^self].	^self copyFrom: 1 to: index-1! !!SequenceableCollection methodsFor: 'copying' stamp: 'tk 1/23/1999 12:56'!copyUpToLast: anElement 	"Answer a copy of the receiver from index 1 to the last occurrence of anElement, not including anElement."	self size to: 1 by: -1 do: [:index | 		(self at: index) = anElement ifTrue: [			^ self copyFrom: 1 to: index-1]].	"^ self    if not found, return entire collection.  Note: it is not a copy"! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/25/1999 15:12'!url	"This was mis-named at the beginning.  Eventually convert over to altUrl and use this for the real url."	^ self realUrl! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 1/16/1999 14:48'!realUrl	"a fully expanded version of the url we represent.  Prefix the path with http: or ftp: or file:"	type = #file ifTrue: [self fileNameRelativeTo: self.				^ urlObject toText].	^ type asString, '://', self pathName, '/', fileName	"note difference!!"	! !!SqueakPage methodsFor: 'saving' stamp: 'tk 1/23/1999 13:19'!urlNoOverwrite: suggested	"Look in the directory.  If there is a file of this name, create a new name.  Keep track of highest numbers used as a hint."	| dir ll stem num local trial suffix |	(suggested endsWith: '.sp') ifTrue: [suffix _ '.sp'].	(suggested endsWith: '.bo') ifTrue: [suffix _ '.bo'].	suffix ifNil: [self error: 'unknown suffix'].	dir _ ServerFile new fullPath: suggested.	(dir includesKey: dir fileName) ifFalse: [^ url _ suggested].	"File already exists!!  Create a new name"	"Find the stem file name"	stem _ SqueakPage stemUrl: suggested.	num _ stem = RecentStem ifTrue: [RecentMaxNum+1] ifFalse: [1].	local _ dir fileName.	"ugh, take stem again..."	ll _ local findLast: [:char | char == $.].	ll = 0 ifFalse: [local _ local copyFrom: 1 to: ll-1].	"remove .sp"	local _ (local splitInteger) at: 1.		"remove trailing number"	local last == $x ifFalse: [local _ local , 'x'].	[trial _ local, num printString, suffix.		dir includesKey: trial] whileTrue: [num _ num + 1].	RecentStem _ stem.  RecentMaxNum _ num.	^ url _ stem, 'x', num printString, suffix! !!SqueakPage class methodsFor: 'all' stamp: 'tk 1/15/1999 08:13'!stemUrl: aUrlString	"Peel off the 'x5.sp'  or '.bo' from the end of a url of a SqueakPage or a BookMorph index file"	| ll aUrl |	ll _ aUrlString findLast: [:char | char == $.].	ll = 0 		ifTrue: [aUrl _ aUrlString]		ifFalse: [aUrl _ aUrlString copyFrom: 1 to: ll-1].	"remove .sp"	aUrl _ (aUrl stemAndNumericSuffix) at: 1.			"remove trailing number"	aUrl size = 0 ifTrue: [^ aUrl].	"empty"	[aUrl last == $x] whileTrue: [aUrl _ aUrl allButLast].	^ aUrl! !!URLMorph methodsFor: 'event handling' stamp: 'tk 1/25/1999 14:44'!mouseUp: evt	| pg ow newPage mm bookUrl bk |	"If url of a book, bring in book with first page and grab it."	book ifNotNil: [book == false ifFalse: [		(bookUrl _ book) class == String ifFalse: [			bookUrl _ (SqueakPage stemUrl: url), '.bo'].		(BookMorph alreadyInFromUrl: bookUrl) ifTrue: [^ self].			"If this book is already in, we would steal the pages out of it!!"		(bk _ BookMorph new fromURL: bookUrl) ifNil: [^ self].		bk goToPageUrl: url.	"turn to the page"		^ World primaryHand attachMorph: bk]].	"If inside a SqueakPage, replace it!!"	pg _ self enclosingPage.	pg ifNotNil: [		(ow _ pg contentsMorph owner) ifNotNil: [			pg contentsMorph delete.	"from its owner"			newPage _ SqueakPageCache atURL: url.			mm _ newPage fetchContents.			mm ifNotNil: [ow addMorph: mm.				page _ newPage].			^ self]].	"If I am a project, jump  -- not done yet"	"For now, just put new page on the hand"	newPage _ SqueakPageCache atURL: url.	mm _ newPage fetchInformIfError.	mm ifNotNil: [self primaryHand attachMorph: mm.		page _ newPage].! !SqueakPage class removeSelector: #getStemUrl:!SqueakPage class removeSelector: #getStrmUrl:!String removeSelector: #copyUpTo:!String removeSelector: #copyUpToLast:!