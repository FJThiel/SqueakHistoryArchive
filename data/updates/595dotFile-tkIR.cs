'From Squeak 2.3 of January 14, 1999 on 14 January 1999 at 11:52:25 pm'!!FileUrl methodsFor: 'printing' stamp: 'tk 1/14/1999 21:22'!toText	| s |	s _ WriteStream on: String new.	s nextPutAll: self schemeName.	s nextPut: $:.	isAbsolute ifTrue:[ s nextPut: $/ ].	"the extra one"	s nextPutAll: self pathString.	fragment ifNotNil: [ s nextPut: $#.  s nextPutAll: fragment encodeForHTTP ].	^s contents! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 1/14/1999 20:16'!padToEndWith: aChar	"We don't have pages, so we are at the end, and don't need to pad."! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 1/14/1999 21:54'!checkServers	"Check that all servers are up and have the latest Updates.list.  Warn user when can't write to a server that can still be read."	| final fileSize this serverList theUpdates decided myUpdates abort strm res |	serverList _ group 			ifNil: [Array with: self] 			ifNotNil: [group value].	final _ OrderedCollection new.	fileSize _ 0.  theUpdates _ ''.	"list of updates"	abort _ false.	serverList do: [:aServer |		decided _ false.		this _ aServer getFileNamed: 'updates.list'.		(this class == String) & (aServer altUrl size > 0) ifTrue: ["no ftp"			strm _ HTTPSocket httpGet: aServer altUrl, 'updates/updates.list' 						accept: 'application/octet-stream'.			strm class == String 				ifTrue: [res _ (PopUpMenu  						labels: 'Install even though not visible\Cancel entire update' withCRs)						startUpWithCaption: 'Server ', aServer moniker, 						' is a weird state.\You cannot store, but users can get updates.\If you store on other servers, the file will not be visible.\Strongly advise that you Cancel.' withCRs]				ifFalse: [					res _ (PopUpMenu labels: 'Install on others\Cancel entire update' withCRs)							startUpWithCaption: 'Server ', aServer moniker, 							' is unavailable\' withCRs, this].			abort _ res ~= 1.			decided _ true].		decided not & (this size > fileSize) ifTrue: ["new has a longer update.list"			fileSize _ this size.			final do: [:each | abort _ self outOfDate: each].			(final _ OrderedCollection new) add: aServer.			theUpdates _ this contentsOfEntireFile. 			decided _ true].		decided not & (this size < fileSize) ifTrue: [abort _ self outOfDate: aServer.  decided _ true].		decided not ifTrue: [myUpdates _ this contentsOfEntireFile.			myUpdates = theUpdates 				ifTrue: [final add: aServer]				ifFalse: [abort _ self outOfDate: this]].		abort ifTrue: [^ Array new].		].	^ final! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/14/1999 21:01'!altUrl	"When a ftp server also has http access, use this to store the http url"	^ altURL! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/14/1999 20:56'!altUrl: aString	altURL _ aString! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/14/1999 21:25'!realUrl	"a fully expanded version of the url we represent.  Prefix the path with http: or ftp: or file:"	type = #file ifTrue: [self fileNameRelativeTo: self.				^ urlObject toText].	^ type asString, '://', self pathName	! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/14/1999 21:01'!url	"This was mis-named at the beginning.  Eventually convert over to altUrl and use this for the real url."	^ altURL! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 1/14/1999 20:54'!pathName	"Path name as used in reading the file.  with slashes for ftp, with local file delimiter (:) for a file: url"	urlObject ifNotNil: [^ urlObject pathForFile].	directory size = 0 ifTrue: [^ server].	^ (directory at: 1) = self pathNameDelimiter		ifTrue: [server, directory]		ifFalse: [user, '@', server, self pathNameDelimiter asString, directory]! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 1/14/1999 23:40'!readShortInst	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.1/7/97 tk	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| instSize className refPosn anObject newName newClass dict oldInstVars sel supers this |	instSize _ (byteStream next) - 1.	"one byte of size"	refPosn _ self getCurrentReference.	className _ self readShortRef.	"class symbol in two bytes of file pos"	self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	newName _ renamed at: className ifAbsent: [className].	newClass _ Smalltalk at: newName.	(steady includes: newClass) ifTrue: [	 	anObject _ newClass isVariable "Create it here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].		anObject _ anObject readDataFrom: self size: instSize.		self setCurrentReference: refPosn.  "before returning to next"		^ anObject].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	supers _ OrderedCollection with: className.	this _ className.	[(this _ superclasses at: this) = 'nil'] whileFalse: [		supers addFirst: this].	supers do: [:aName |			sel _ reshaped at: aName ifAbsent: [nil].		sel ifNotNil: [			anObject _ anObject perform: sel with: dict with: self]].	"exceptions"	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 1/14/1999 23:50'!url: aString	| sd |	aString isEmpty ifTrue: [url _ nil. ^ self].	"Expand ./ and store as an absolute url"	sd _ ServerFile new.	sd fullPath: aString.	url _ sd realUrl.! !ServerDirectory removeSelector: #pathWithScheme!"Postscript:Make all SqueakPages store absolute urls."SqueakPage allInstancesDo: [:sqkPage | 		sqkPage url ifNotNil: [sqkPage url: sqkPage url]].(ServerDirectory serverNames includes: 'UpdatesExtUIUC') ifTrue: [	(ServerDirectory serverNamed: 'UpdatesExtUIUC') altUrl: 			'http://squeak.cs.uiuc.edu/Squeak2.0/'].(ServerDirectory serverNames includes: 'UpdatesExtWebPage') ifTrue: [	(ServerDirectory serverNamed: 'UpdatesExtWebPage') altUrl: 		'http://www.webpage.com/~kaehler2/Squeak2.0/'].(Smalltalk includesKey: #EToySystem) ifTrue: [(ServerDirectory serverNames includes: 'UpdatesAtDOL') ifTrue: [	(ServerDirectory serverNamed: 'UpdatesAtDOL') altUrl: 		'http://',(EToySystem serverUrls detect: [:each | each first = $d])].(ServerDirectory serverNames includes: 'UpdatesAtWebPage') ifTrue: [	(ServerDirectory serverNamed: 'UpdatesAtWebPage') altUrl: 		'http://',(EToySystem serverUrls detect: [:each | each first = $w])].	]!