'From Squeak 2.3 beta of Nov 25, 1998 on 14 December 1998 at 3:22:46 pm'!"Change Set:		sendHackingDate:			14 December 1998Author:			John MaloneyMinor tweaks to send code:  1. fold +1 into method cache offset constants  2. use global lkupClass rather than parameters     to internalExecutNewMethod et al."!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP localHomeContext messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache atCache lkupClass reclaimableContextCount nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals '	classVariableNames: 'ActiveProcessIndex AtCacheEntries AtCacheFixedFields AtCacheFmt AtCacheMask AtCacheOop AtCacheSize AtCacheTotalSize AtPutBase BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex DirBadPath DirEntryFound DirNoMoreEntries ExcessSignalsIndex FirstLinkIndex HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageSelectorIndex MessageSize MethodArrayIndex MethodCacheClass MethodCacheEntries MethodCacheEntrySize MethodCacheMask MethodCacheMethod MethodCachePrim MethodCacheSelector MethodCacheSize MethodIndex MyListIndex NextLinkIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!Interpreter methodsFor: 'message sending' stamp: 'jm 12/14/1998 09:52'!executeNewMethod: lookupClass	primitiveIndex > 0 ifTrue: [		self primitiveResponse.		successFlag ifTrue: [^ nil]].	"if not primitive, or primitive failed, activate the method"	self activateNewMethod.	"check for possible interrupts at each real send"	self quickCheckForInterrupts.! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/14/1998 14:24'!internalActivateNewMethod	| tmp newContext tempCount argCount |	self inline: true.	tmp _ self headerOf: newMethod.	freeContexts ~= NilContext ifTrue: [		newContext _ freeContexts.		freeContexts _ self fetchPointer: 0 ofObject: newContext.	] ifFalse: [		self externalizeIPandSP.		newContext _ self			instantiateSmallClass: (self splObj: ClassMethodContext)			sizeInBytes: LargeContextSize fill: nilObj.		self internalizeIPandSP.	].	tempCount _ (tmp >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf:			(((LiteralStart + (self literalCountOfHeader: tmp)) * 4) + 1)).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	argCount _ argumentCount.	0 to: argCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self internalStackValue: argCount-i)].	"clear remaining temps to nil in case it has been recycled"	tmp _ nilObj.	argCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: tmp].	self internalPop: argCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self internalNewActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/14/1998 14:22'!internalExecuteNewMethod	| primIndex |	self inline: true.	primIndex _ primitiveIndex.	primIndex > 0		ifTrue: [(primIndex > 255 and: [primIndex < 520])				ifTrue: ["Internal return instvars"						primIndex >= 264						ifTrue:						[^ self internalPop: 1 thenPush:								(self fetchPointer: primIndex-264										ofObject: self internalStackTop)]						ifFalse:						["Internal return constants"						primIndex = 256 ifTrue: [^ nil "^ self"].						primIndex = 257 ifTrue: [^ self internalPop: 1 thenPush: trueObj].						primIndex = 258 ifTrue: [^ self internalPop: 1 thenPush: falseObj].						primIndex = 259 ifTrue: [^ self internalPop: 1 thenPush: nilObj].						^ self internalPop: 1 thenPush: (self integerObjectOf: primIndex-261)]]				ifFalse: 	[self externalizeIPandSP.						self primitiveResponse.						self internalizeIPandSP.						successFlag ifTrue: [^ nil]]].	"if not primitive, or primitive failed, activate the method"	self internalActivateNewMethod.	"check for possible interrupts at each real send"	self internalQuickCheckForInterrupts.! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/14/1998 09:49'!internalFindNewMethod	"Find the compiled method to be run when the current messageSelector is sent to the class 'lkupClass', setting the values of 'newMethod' and 'primitiveIndex'."	| ok |	self inline: true.	ok _ self lookupInMethodCacheSel: messageSelector class: lkupClass.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self externalizeIPandSP.		self lookupMethodInClass: lkupClass.		self internalizeIPandSP.		primitiveIndex _ self primitiveIndexOf: newMethod.		self addToMethodCacheSel: messageSelector			class: lkupClass			method: newMethod			primIndex: primitiveIndex].! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/14/1998 10:26'!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| rcvr |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: 131.	rcvr _ self internalStackValue: argumentCount.	lkupClass _ self fetchClassOf: rcvr.	self internalFindNewMethod.	self internalExecuteNewMethod.	self fetchNextBytecode.! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/14/1998 10:25'!superclassSend	"Send a message to self, starting lookup with the superclass of the class containing the currently executing method."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	self inline: true.	self sharedCodeNamed: 'commonSupersend' inCase: 133.	lkupClass _ self superclassOf: (self methodClassOf: method).	self internalFindNewMethod.	self internalExecuteNewMethod.	self fetchNextBytecode.! !!Interpreter methodsFor: 'method lookup cache' stamp: 'jm 12/14/1998 14:31'!addToMethodCacheSel: selector class: class method: meth primIndex: primIndex	"Add the given entry to the method cache.	The policy is as follows:		Look for an empty entry anywhere in the reprobe chain.		If found, install the new entry there.		If not found, then install the new entry at the first probe position			and delete the entries in the rest of the reprobe chain.		This has two useful purposes:			If there is active contention over the first slot, the second				or third will likely be free for reentry after ejection.			Also, flushing is good when reprobe chains are getting full."	| probe hash |	self inline: false.	hash _ selector bitXor: class.  "drop low-order zeros from addresses"	0 to: CacheProbeMax-1 do:		[:p | probe _ (hash >> p) bitAnd: MethodCacheMask.		(methodCache at: probe + MethodCacheSelector) = 0 ifTrue:				["Found an empty entry -- use it"				methodCache at: probe + MethodCacheSelector put: selector.				methodCache at: probe + MethodCacheClass put: class.				methodCache at: probe + MethodCacheMethod put: meth.				methodCache at: probe + MethodCachePrim put: primIndex.				^ nil]].	"OK, we failed to find an entry -- install at the first slot..."	probe _ hash bitAnd: MethodCacheMask.  "first probe"	methodCache at: probe + MethodCacheSelector put: selector.	methodCache at: probe + MethodCacheClass put: class.	methodCache at: probe + MethodCacheMethod put: meth.	methodCache at: probe + MethodCachePrim put: primIndex.	"...and zap the following entries"	1 to: CacheProbeMax-1 do:		[:p | probe _ (hash >> p) bitAnd: MethodCacheMask.		methodCache at: probe + MethodCacheSelector put: 0].! !!Interpreter methodsFor: 'method lookup cache' stamp: 'jm 12/14/1998 14:29'!lookupInMethodCacheSel: selector class: class	"This method implements a simple method lookup cache. If an entry for the given selector and class is found in the cache, set the values of 'newMethod' and 'primitiveIndex' and return true. Otherwise, return false."	"About the re-probe scheme: The hash is the low bits of the XOR of two large addresses, minus their useless lowest two bits. If a probe doesn't get a hit, the hash is shifted right one bit to compute the next probe, introducing a new randomish bit. The cache is probed CacheProbeMax times before giving up."	"WARNING: Since the hash computation is based on the object addresses of the class and selector, we must rehash or flush when compacting storage. We've chosen to flush, since that also saves the trouble of updating the addresses of the objects in the cache."	| hash probe |	self inline: true.	hash _ selector bitXor: class.  "shift drops two low-order zeros from addresses"	probe _ hash bitAnd: MethodCacheMask.  "first probe"	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			^ true	"found entry in cache; done"].	probe _ (hash >> 1) bitAnd: MethodCacheMask.  "second probe"	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			^ true	"found entry in cache; done"].	probe _ (hash >> 2) bitAnd: MethodCacheMask.	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			^ true	"found entry in cache; done"].	^ false! !!Interpreter methodsFor: 'primitive support' stamp: 'jm 12/14/1998 09:51'!primitiveResponse	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| timerPending startTime |	timerPending _ nextWakeupTick ~= 0.	timerPending ifTrue: [startTime _ self ioLowResMSecs].	successFlag _ true.	self dispatchOn: primitiveIndex in: PrimitiveTable.	timerPending ifTrue: [		(self ioLowResMSecs ~= startTime) ifTrue: [			"primitive ran for more than a tick; check for possible timer interrupts"			((self ioMSecs bitAnd: 16r1FFFFFFF) >= nextWakeupTick) ifTrue: [				successFlag					ifTrue: ["process the interrupt now"							self checkForInterrupts]					ifFalse: ["process the interrupt in primtive failure code"							interruptCheckCounter _ 0]]]].	^ successFlag! !!Interpreter methodsFor: 'control primitives' stamp: 'jm 12/14/1998 09:53'!primitiveDoPrimitiveWithArgs	| argumentArray arraySize index cntxSize primIdx |	argumentArray _ self stackTop.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ self fetchWordLengthOf: activeContext.	self success: (self stackPointerIndex + arraySize) < cntxSize.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	primIdx _ self stackIntegerValue: 1.	successFlag ifFalse: [^ self primitiveFail].  "invalid args"	"Pop primIndex and argArray, then push args in place..."	self pop: 2.	primitiveIndex _ primIdx.	argumentCount _ arraySize.	index _ 1.	[index <= argumentCount]		whileTrue:		[self push: (self fetchPointer: index - 1 ofObject: argumentArray).		index _ index + 1].	"Run the primitive (sets successFlag)"	self pushRemappableOop: argumentArray.	"prim might alloc/gc"	lkupClass _ nilObj.	self primitiveResponse.	argumentArray _ self popRemappableOop.	successFlag ifFalse:		["If primitive failed, then restore state for failure code"		self pop: arraySize.		self pushInteger: primIdx.		self push: argumentArray.		argumentCount _ 2.		"... caller (execNewMeth) will run failure code"]! !!Interpreter methodsFor: 'other primitives' stamp: 'jm 12/14/1998 14:32'!primitiveFlushCacheSelective	"The receiver is a message selector.  Clear all entries in the method lookup cache with this selector, presumably because an associated method has been redefined."	| selector probe |	selector _ self stackTop.	probe _ 0.	1 to: MethodCacheEntries do:		[:i | (methodCache at: probe + MethodCacheSelector) = selector ifTrue:			[methodCache at: probe + MethodCacheSelector put: 0].		probe _ probe + MethodCacheEntrySize]! !!Interpreter class methodsFor: 'initialization' stamp: 'jm 12/14/1998 14:28'!initializeCaches 	| atCacheEntrySize |	MethodCacheEntries _ 512. 	MethodCacheSelector _ 1.	MethodCacheClass _ 2.	MethodCacheMethod _ 3.	MethodCachePrim _ 4.	MethodCacheEntrySize _ 4.  "Must be power of two for masking scheme."	MethodCacheMask _ (MethodCacheEntries - 1) * MethodCacheEntrySize.	MethodCacheSize _ MethodCacheEntries * MethodCacheEntrySize.	CacheProbeMax _ 3.	AtCacheEntries _ 8.  "Must be power of two"	AtCacheOop _ 0.	AtCacheSize _ 1.	AtCacheFmt _ 2.	AtCacheFixedFields _ 3.	atCacheEntrySize _ 4.  "Must be power of two for masking scheme."	AtCacheMask _ (AtCacheEntries-1) * atCacheEntrySize.	AtPutBase _ AtCacheEntries * atCacheEntrySize.	AtCacheTotalSize _ AtCacheEntries * atCacheEntrySize * 2.! !Interpreter removeSelector: #internalExecuteNewMethod:!Interpreter removeSelector: #internalFindNewMethodInClass:!Interpreter removeSelector: #primitiveResponse:!