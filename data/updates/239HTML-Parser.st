Dictionary subclass: #HtmlAttributes	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser'!!HtmlAttributes methodsFor: 'printing' stamp: 'ls 7/23/1998 19:05'!printHtmlOn: aStream	self associationsDo: 		[:element | 		aStream 			space;			nextPutAll: element key asUppercase.		element value ifNotNil: [  				aStream nextPut: $=.				aStream print: element value withoutQuoting]. ]! !Inspector subclass: #HtmlEntityInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser'!!HtmlEntityInspector methodsFor: 'accessing' stamp: 'djp 7/21/1998 17:21'!fieldList	^ super fieldList, (Array with: 'asHtml')! !!HtmlEntityInspector methodsFor: 'accessing' stamp: 'ls 7/24/1998 01:40'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  "	^ 300 @ 300! !!HtmlEntityInspector methodsFor: 'selecting' stamp: 'ls 7/23/1998 07:37'!selection	selectionIndex = self fieldList size 		ifTrue: [^object asHtml]		ifFalse: [^super selection]! !Object subclass: #HtmlParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser'!!HtmlParser commentStamp: 'ls 9/8/1998 21:39' prior: 0!parses a stream of HtmlToken's into an HtmlDocument.  All token become an entity of some sort in the resulting document; some things are left only as comments, though.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HtmlParser class	instanceVariableNames: ''!!HtmlParser class methodsFor: 'parsing' stamp: 'ls 7/28/1998 02:02'!parse: aStream	^self parseTokens: (HtmlTokenizer on: aStream)! !!HtmlParser class methodsFor: 'parsing' stamp: 'ls 7/29/1998 03:13'!parseTokens: tokenStream	|  entityStack document head token matchesAnything entity body |	entityStack _ OrderedCollection new.	"set up initial stack"	document _ HtmlDocument new.	entityStack add: document.		head _ HtmlHead new.	document addEntity: head.	entityStack add: head.	"go through the tokens, one by one"	[ token _ tokenStream next.  token = nil ] whileFalse: [		(token isTag and: [ token isNegated ]) ifTrue: [			"a negated token"			(token name ~= 'html' and: [ token name ~= 'body' ]) ifTrue: [				"see if it matches anything in the stack"				matchesAnything _ (entityStack detect: [ :e | e tagName = token name ] ifNone: [ nil ]) isNil not.				matchesAnything ifTrue: [					"pop the stack until we find the right one"					[ entityStack last tagName ~= token name ] whileTrue: [ entityStack removeLast ].					entityStack removeLast.				]. ] ]		ifFalse: [			"not a negated token.  it makes its own entity"			token isComment ifTrue: [				entity _ HtmlCommentEntity new initializeWithText: token source.			].			token isText ifTrue: [				entity _ HtmlTextEntity new text: token text.				(((entityStack last shouldContain: entity) not) and: 					[ token source isAllSeparators ]) ifTrue: [					"blank text may never cause the stack to back up"					entity _ HtmlCommentEntity new initializeWithText: token source ].			].			token isTag ifTrue: [				entity _ token entityFor.				entity = nil ifTrue: [ entity _ HtmlCommentEntity new initializeWithText: token source ] ].			entity = nil ifTrue: [ self error: 'could not deal with this token' ].			entity isComment ifTrue: [				"just stick it anywhere"				entityStack last addEntity: entity ]			ifFalse: [				"only put it in something that is valid"				[ entityStack last mayContain: entity ] 					whileFalse: [ entityStack removeLast ].				"if we have left the head, create a body"									entityStack size < 2 ifTrue: [ 					body _ HtmlBody new.					document addEntity: body.					entityStack add: body  ].				"add the entity"				entityStack last addEntity: entity.				entityStack addLast: entity.			].		]].	body == nil ifTrue: [		"add an empty body"		body _ HtmlBody new.		document addEntity: body ].	document parsingFinished.	^document! !!HtmlParser class methodsFor: 'example' stamp: 'ls 6/27/1998 15:32'!example1	"HtmlParser example1"	| input |	input _ ReadStream on: '<html><head><title>The Gate of Chaos</title></head><body><h1>Chaos</h1><h2>Into the Maelstrom</h2>Direction is useless in the ever-changing Maelstrom.  However,if you wander with purpose, you might be able to find....<ul><li><a href="/cgi-bin/w">see who''s logged in</a><li><a href="/Telnet/connect.html">log in, if you (oooh) have an account</a><li><a href="http://chaos.resnet.gatech.edu:9000/sw">The Chaos Swiki</a>--scribble on chaos<li>the original <a href="/cgi-bin/guestlog-print">Visitor Sands</a><li>my old <a href="rant.html">Rant Page</a><li>neverending <a href="/cgi-bin/bread">poll</a>: do you have an opinion on bread?<li>a <a href="http://www.cc.gatech.edu/~lex/linux.html">Linux page</a>-- free UNIX for PC''s!!<li><a href="english.au">Hear Linus Himself speak!!!!</a><li><a href="/doc/">some docs on all kinds of computer stuff</a></ul><hr><h2>Paths of Retreat</h2>Several commonly travelled ways have left paths leading <em>away</em> from the maelstrom, too:<p><ul><li><a href="friends.html">Friends of Chaos</a><li><a href="http://www.apache.org/">The <em>Apache</em> home page</a> --         <em>Chaos</em>''s WWW server!!<li><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html">Notscape</a>the <a href="http://www.eskimo.com/%7Eirving/anti-ns/">Anti-NetscapePage</a> -- fight the tyranny!!</ul><hr><a href="/analog/usage.html">usage stats</a> for this server<hr><a href="http://www.eff.org/blueribbon.html"><img src="blueribbon.gif" alt="[blue ribbon campaign]"></a><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html"><img src="notscape.gif" alt="[NOTscape]"></a><a href="http://www.anybrowser.org/campaign/"><img src="anybrowser3.gif" alt="[Best Viewed With Any Browser]"></a></body></html>'.	^HtmlParser parse: input! !