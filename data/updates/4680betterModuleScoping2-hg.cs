'From Squeak3.2alpha of 1 November 2001 [latest update: #4554] on 7 December 2001 at 11:12:46 am'!"Change Set:		betterModuleScoping2-hgDate:			28 November 2001Author:			Henrik GedenrydMake the sensitive switch to the new scoping methods."!!Class methodsFor: 'compiling' stamp: 'hg 11/29/2001 12:54'!scopeHas: varName ifTrue: assocBlock	^(self definesName: varName lookInSuper: true ifTrue: [:a | assocBlock value: a])		or: [self scopeModule definesName: varName ifTrue: assocBlock]! !!Compiler methodsFor: 'public access' stamp: 'hg 11/29/2001 14:50'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method value providedReceiver scopedReceiver |	providedReceiver _ aContext ifNotNil: [aContext receiver] ifNil: [receiver].	"the only straightforward way to get the compiler to use a certain module for name lookup is by giving the module via the class, here an ad hoc one"	scopedReceiver _ providedReceiver ifNil: [(Object copy module: Module default) new].	class _ scopedReceiver class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method _ methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method _ method copyWithTempNames: methodNode tempNames].	context == nil		ifTrue: [class addSelector: #DoIt withMethod: method.				value _ scopedReceiver DoIt.				InMidstOfFileinNotification signal ifFalse: [					class removeSelectorSimply: #DoIt.				].				^value]		ifFalse: [class addSelector: #DoItIn: withMethod: method.				value _ scopedReceiver DoItIn: context.				InMidstOfFileinNotification signal ifFalse: [					class removeSelectorSimply: #DoItIn:.				].				^value]! !DeltaClass removeSelector: #lenientScopeHas:ifTrue:!DeltaClass removeSelector: #strongScopeHas:ifTrue:!DeltaClass removeSelector: #weakScopeHas:ifTrue:!Class removeSelector: #lenientScopeHas:ifTrue:!Class removeSelector: #strongScopeHas:ifTrue:!Class removeSelector: #weakScopeHas:ifTrue:!