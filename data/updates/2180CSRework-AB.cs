'From Squeak2.8alpha of 16 February 2000 [latest update: #2176] on 23 May 2000 at 1:02:57 pm'!"Change Set:		CSRework-ABDate:			23 May 2000Author:			Andreas RaabCharacter scanner rework part2. Activate the new character scanner classes."!!FormCanvas methodsFor: 'drawing' stamp: 'ar 5/17/2000 19:23'!text: s bounds: boundsRect font: fontOrNil color: c	| scanner |	scanner _ NewDisplayScanner quickPrintOn: form				box: ((boundsRect translateBy: origin) intersect: clipRect) truncated				font: fontOrNil				color: (self shadowColor ifNil:[c]).	scanner drawString: s at: boundsRect topLeft + origin! !!GrafPort methodsFor: 'accessing' stamp: 'ar 5/17/2000 20:26'!displayScannerFor: para foreground: foreColor background: backColor ignoreColorChanges: shadowMode	^ (NewDisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self			ignoreColorChanges: shadowMode)		setPort: self clone! !!HandMorph methodsFor: 'geometry' stamp: 'ar 5/17/2000 19:23'!userInitials: aString	| qp cb |	userInitials _ aString.	userInitials isEmpty ifFalse:		[qp _ NewDisplayScanner quickPrintOn: Display.		cb _ self cursorBounds.		self bounds: (cb merge: (cb topRight + (0@4)					extent: (qp stringWidth: userInitials)@(qp lineHeight)))]! !!NewParagraph methodsFor: 'composition' stamp: 'ar 5/17/2000 19:17'!composeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines	atY: startingY	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| charIndex lineY lineHeight scanner line row firstLine lineHeightGuess saveCharIndex hitCR maybeSlide sliding bottom priorIndex priorLine |	charIndex _ start.	lines _ lineColl.	lineY _ startingY.	lineHeightGuess _ textStyle lineGrid.	maxRightX _ container left.	maybeSlide _ stop < text size and: [container isMemberOf: Rectangle].	sliding _ false.	priorIndex _ 1.	bottom _ container bottom.	scanner _ NewCompositionScanner new text: text textStyle: textStyle.	firstLine _ true.	[charIndex <= text size and: [(lineY + lineHeightGuess) <= bottom]]		whileTrue:		[sliding			ifTrue:			["Having detected the end of rippling recoposition, we are only sliding old lines"			priorIndex < priorLines size				ifTrue: ["Adjust and re-use previously composed line"						priorIndex _ priorIndex + 1.						priorLine _ (priorLines at: priorIndex)									slideIndexBy: delta andMoveTopTo: lineY.						lineColl addLast: priorLine.						lineY _ priorLine bottom.						charIndex _ priorLine last + 1]				ifFalse: ["There are no more priorLines to slide."						sliding _ maybeSlide _ false]]			ifFalse:			[lineHeight _ lineHeightGuess.			saveCharIndex _ charIndex.			hitCR _ false.			row _ container rectanglesAt: lineY height: lineHeight.			1 to: row size do:				[:i | (charIndex <= text size and: [hitCR not]) ifTrue:						[line _ scanner composeFrom: charIndex inRectangle: (row at: i)								firstLine: firstLine leftSide: i=1 rightSide: i=row size.					lines addLast: line.					(text at: line last) = Character cr ifTrue: [hitCR _ true].					lineHeight _ lineHeight max: line lineHeight.  "includes font changes"					charIndex _ line last + 1]].			row size >= 1 ifTrue:			[lineY _ lineY + lineHeight.			lineY > bottom				ifTrue: ["Oops -- the line is really too high to fit -- back out"						charIndex _ saveCharIndex.						row do: [:r | lines removeLast]]				ifFalse: ["It's OK -- the line still fits."						maxRightX _ maxRightX max: scanner rightX.						1 to: row size - 1 do:  "Adjust heights across row if necess"							[:i | (lines at: lines size - row size + i)									lineHeight: lines last lineHeight									baseline: lines last baseline].						charIndex > text size ifTrue:							["end of text"							hitCR ifTrue:								["If text ends with CR, add a null line at the end"								((lineY + lineHeightGuess) <= container bottom) ifTrue:									[row _ container rectanglesAt: lineY height: lineHeightGuess.									row size > 0 ifTrue:										[line _ (TextLine start: charIndex stop: charIndex-1											internalSpaces: 0 paddingWidth: 0)										rectangle: row first;										lineHeight: lineHeightGuess baseline: textStyle baseline.										lines addLast: line]]].							lines _ lines asArray.							^ maxRightX].						firstLine _ false]]				ifFalse:				[lineY _ lineY + lineHeight].			(maybeSlide and: [charIndex > stop]) ifTrue:				["Check whether we are now in sync with previously composed lines"				 [priorIndex < priorLines size					and: [(priorLines at: priorIndex) first < (charIndex - delta)]]						whileTrue: [priorIndex _ priorIndex + 1].				(priorLines at: priorIndex) first = (charIndex - delta)					ifTrue: ["Yes -- next line will have same start as prior line."							priorIndex _ priorIndex - 1.							maybeSlide _ false.							sliding _ true]					ifFalse: [priorIndex = priorLines size ifTrue:								["Weve reached the end of priorLines,								so no use to keep looking for lines to slide."								maybeSlide _ false]]]]].	firstLine ifTrue:		["No space in container or empty text"		line _ (TextLine start: start stop: start-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (container topLeft extent: 0@lineHeightGuess);				lineHeight: lineHeightGuess baseline: textStyle baseline.		lines _ Array with: line].	"end of container"	lines _ lines asArray.	^ maxRightX! !!NewParagraph methodsFor: 'selection' stamp: 'ar 5/17/2000 19:18'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (NewCharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: aPoint index: nil		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'ar 5/17/2000 19:18'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line |	line _ lines at: (self lineIndexForCharacter: index).	^ (NewCharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: nil index: ((index max: line first) min: text size+1)		in: line! !!Paragraph methodsFor: 'accessing' stamp: 'ar 5/17/2000 19:18'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle _ compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ NewCompositionScanner new forParagraph: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + 1.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'composition' stamp: 'ar 5/17/2000 19:17'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines _ Array new: 32.	lastLine _ 0.	maximumRightX _ 0.	text size = 0		ifTrue:			[compositionRectangle _ compositionRectangle withHeight: 0.			^maximumRightX].	startIndex _ lineIndex _ 1.	stopIndex _ text size.	compositionScanner _ NewCompositionScanner new forParagraph: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX _ compositionScanner rightX max: maximumRightX.		 startIndex _ (lines at: lineIndex) last + 1.		 lineIndex _ lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'character location' stamp: 'ar 5/17/2000 19:18'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for characters in the text at point aPoint. It is 	assumed that aPoint has been transformed into coordinates appropriate to 	the receiver's destinationForm rectangle and the compositionRectangle."	^NewCharacterBlockScanner new characterBlockAtPoint: aPoint in: self! !!Paragraph methodsFor: 'character location' stamp: 'ar 5/17/2000 19:18'!characterBlockForIndex: targetIndex 	"Answer a CharacterBlock for character in the text at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destinationForm rectangle and the compositionRectangle."	^NewCharacterBlockScanner new characterBlockForIndex: targetIndex in: self! !!Paragraph methodsFor: 'private' stamp: 'ar 5/17/2000 19:17'!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	"Save some time by only displaying visible lines"	firstLineIndex _ self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex _ linesInterval first].	lastLineIndex _ self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex _ lastLine]		  		ifFalse: [lastLineIndex _ linesInterval last]].	lastLineIndexBottom _ (self bottomAtLineIndex: lastLineIndex).	((Rectangle 		origin: affectedRectangle left @ (topY _ self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ lastLineIndexBottom)	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"				NewDisplayScanner new					displayLines: (firstLineIndex to: lastLineIndex)					in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]! !!StringMorph methodsFor: 'accessing' stamp: 'ar 5/17/2000 19:23'!fitContents	| scanner |	scanner _ NewDisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.	self extent: (((scanner stringWidth: contents) max: self minimumWidth)  @ scanner lineHeight).	self changed! !!DropDownChoiceMorph methodsFor: 'drawing' stamp: 'ar 5/17/2000 19:22'!maxExtent: listOfStrings	| scanner h w maxW |	maxW _ 0.	listOfStrings do: [:str |		scanner _ NewDisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.		w _ (scanner stringWidth: str).		h _ scanner lineHeight.		maxW _ maxW max: w].	self extent: (maxW + 4 + h) @ (h + 4).	self changed! !!MenuItemMorph methodsFor: 'layout' stamp: 'ar 5/17/2000 19:23'!layoutInWidth: w height: h	| scanner |	scanner _ NewDisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.	self extent: ((scanner stringWidth: contents) @ (scanner lineHeight) max: w@h).! !!MenuItemMorph methodsFor: 'layout' stamp: 'ar 5/17/2000 19:23'!minWidth	| scanner |	scanner _ NewDisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.	^ (scanner stringWidth: contents) + (subMenu == nil ifTrue: [0] ifFalse: [10])! !!SystemWindow methodsFor: 'label' stamp: 'ar 5/17/2000 19:23'!widthOfFullLabelText	^ (NewDisplayScanner quickPrintOn: Display box: Display boundingBox font: (Preferences windowTitleFont emphasized: 1)) stringWidth: labelString! !!TextOnCurve methodsFor: 'as yet unclassified' stamp: 'ar 5/17/2000 19:18'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| sourcePoint cb curvePoint |	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(destRect containsPoint: aPoint) ifTrue:			["It's in the destRect; now convert to source coords"			sourcePoint _ self pointInLine: line forDestPoint: aPoint							segStart: segStart segAngle: segAngle.			cb _ (NewCharacterBlockScanner new text: text textStyle: textStyle)				characterBlockAtPoint: (sourcePoint adhereTo: line rectangle)				index: nil in: line.			(sourcePoint x between: line left and: line right) ifTrue:				["Definitely in this segment"				^ cb]]].	"Point is off curve -- try again with closest point on curve"	curvePoint _ curve closestPointTo: aPoint.	curvePoint = aPoint ifFalse:		[^ self characterBlockAtPoint: curvePoint].	"If all else fails, at least return something acceptable."	^ cb ifNil: [self defaultCharacterBlock]! !!TextOnCurve methodsFor: 'as yet unclassified' stamp: 'ar 5/17/2000 19:20'!composeLinesFrom: startingIndex withLines: startingLines atY: startingY	"Here we determine the 'lines' of text that will fit along each segment of the curve. For each line, we determine its rectangle, then the dest wuadrilateral that it willbe rotated to.  Then, we take the outer hull to determine a dest rectangle for WarpBlt.  In addition we need the segment pivot point and angle, from which the source quadrilateral may be computed."	| charIndex scanner line firstLine curveSegments segIndex pa pb segLen lineRect textSegments segDelta segAngle destRect destQuad i oldBounds |	(oldBounds _ container bounds) ifNotNil:		[curve invalidRect: oldBounds].	charIndex _ startingIndex.	lines _ startingLines.	curveSegments _ curve lineSegments.	container textDirection < 0 ifTrue:		[curveSegments _ curveSegments reversed collect:				[:seg | Array with: (seg at: 2) with: (seg at: 1)]].	textSegments _ OrderedCollection new.	scanner _ NewSegmentScanner new text: text textStyle: textStyle.	segIndex _ 1.  "For curves, segIndex is just an index."	firstLine _ true.	pa _ curveSegments first first.	[charIndex <= text size and: [segIndex <= curveSegments size]]		whileTrue:		[curve isCurve ifFalse: [pa _ (curveSegments at: segIndex) first].		pb _ (curveSegments at: segIndex) last.		segDelta _ pb - pa.  "Direction of this segment"		segLen _ segDelta r.		lineRect _ 0@0 extent: segLen asInteger@textStyle lineGrid.		line _ scanner composeFrom: charIndex inRectangle: lineRect						firstLine: firstLine leftSide: true rightSide: true.		line setRight: scanner rightX.		line width > 0 ifTrue:			[lines addLast: line.			segAngle _ segDelta theta.			destQuad _ line rectangle corners collect:						[:p | (p translateBy: pa - (0@(line baseline + container baseline)))								rotateBy: segAngle negated about: pa].			destRect _ Rectangle encompassing: destQuad.			textSegments addLast: (Array with: destRect truncated with: pa with: segAngle).			pa _ pa + ((pb-pa) * line width / segLen).			charIndex _ line last + 1].		segIndex _ segIndex + 1.		firstLine _ false].	lines size = 0 ifTrue:		["No space in container or empty text"		line _ (TextLine start: startingIndex stop: startingIndex-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (0@0 extent: 10@textStyle lineGrid);				lineHeight: textStyle lineGrid baseline: textStyle baseline.		lines _ Array with: line.		textSegments addLast:			(Array with: (curve vertices first extent: line rectangle extent) 					with: curve vertices first with: 0.0).].	"end of segments, now attempt word break."	lines last last < text size ifTrue:		[[lines size > 1 and: [(text at: (i _ lines last last)+1) ~= Character space]]			whileTrue:			[i = lines last first				ifTrue: [lines removeLast.  textSegments removeLast]				ifFalse: [lines last stop: i-1]]].	lines _ lines asArray.	container textSegments: textSegments asArray.	curve invalidRect: container bounds.	^ maxRightX! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'ar 5/17/2000 19:23'!fitContents	| scanner newExtent |	scanner _ NewDisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.	newExtent _ (((scanner stringWidth: contents) max: self minimumWidth) min: self maximumWidth)  @ scanner lineHeight.	(self extent = newExtent) ifFalse:		[self extent: newExtent.		self changed.		(owner isKindOf: TileMorph) ifTrue: [owner resizeToFitLabel]]! !