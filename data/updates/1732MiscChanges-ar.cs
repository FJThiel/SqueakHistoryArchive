'From Squeak2.6 of 13 October 1999 [latest update: #1731] on 27 December 1999 at 1:51:45 pm'!"Change Set:		MiscChanges-arDate:			27 December 1999Author:			Andreas RaabA set of (partly unrelated) changes throughout the system. Mainly compression related but also some minor fixes."!!InflateStream methodsFor: 'testing' stamp: 'ar 12/27/1999 13:43'!atEnd	"Note: It is possible that we have a few bits left,	representing just the EOB marker. To check for	this we must force decompression of the next	block if at end of data."	super atEnd ifFalse:[^false]. "Primitive test"	(position >= readLimit and:[state = StateNoMoreData]) ifTrue:[^true].	"Force decompression, by calling #next. Since #moveContentsToFront	will never move data to the beginning of the buffer it is safe to	skip back the read position afterwards"	self next == nil ifTrue:[^true].	position _ position - 1.	^false! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/27/1999 13:49'!proceedStoredBlock	"Proceed decompressing a stored (e.g., uncompressed) block"	| length decoded |	"Literal table must be nil for a stored block"	litTable == nil ifFalse:[^self error:'Bad state'].	length _ distTable.	[length > 0 and:[readLimit < collection size and:[sourcePos < sourceLimit]]] 		whileTrue:[			collection at: (readLimit _ readLimit + 1) put: 				(source at: (sourcePos _ sourcePos + 1)).			length _ length - 1].	length = 0 ifTrue:[state _ state bitAnd: StateNoMoreData].	decoded _ length - distTable.	distTable _ length.	^decoded! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/27/1999 13:49'!processStoredBlock	| chkSum length |	"Skip to byte boundary"	self nextBits: (bitPos bitAnd: 7).	length _ self nextBits: 16.	chkSum _ self nextBits: 16.	(chkSum bitXor: 16rFFFF) = length		ifFalse:[^self error:'Bad block length'].	litTable _ nil.	distTable _ length.	state _ state bitOr: BlockProceedBit.	^self proceedStoredBlock! !!InflateStream methodsFor: 'private' stamp: 'ar 12/27/1999 13:48'!pastEndRead	"A client has attempted to read beyond the read limit.	Check in what state we currently are and perform	the appropriate action"	| blockType |	state = StateNoMoreData ifTrue:[^nil]. "Get out early if possible"	"Check if we can move decoded data to front"	self moveContentsToFront.	"Check if we can fetch more source data"	self moveSourceToFront.	state = StateNewBlock ifTrue:[state _ self getNextBlock].	blockType _ state bitShift: -1.	self perform: (BlockTypes at: blockType+1).	^collection at: (position _ position + 1)! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/27/1999 13:47'!createHuffmanTables: values counts: counts from: minBits to: maxBits	"Create the actual tables"	| table tableStart tableSize tableEnd 	valueIndex tableStack numValues deltaBits maxEntries	lastTable lastTableStart tableIndex lastTableIndex |	table _ WordArray new: ((4 bitShift: minBits) max: 16).	"Create the first entry - this is a dummy.	It gives us information about how many bits to fetch initially."	table at: 1 put: (minBits bitShift: 24) + 2. "First actual table starts at index 2"	"Create the first table from scratch."	tableStart _ 2. "See above"	tableSize _ 1 bitShift: minBits.	tableEnd _ tableStart + tableSize.	"Store the terminal symbols"	valueIndex _ (counts at: minBits+1).	tableIndex _ 0.	1 to: valueIndex do:[:i|		table at: tableStart + tableIndex put: (values at: i).		tableIndex _ self increment: tableIndex bits: minBits].	"Fill up remaining entries with invalid entries"	tableStack _ OrderedCollection new: 10. "Should be more than enough"	tableStack addLast: 		(Array 			with: minBits	"Number of bits (e.g., depth) for this table"			with: tableStart	"Start of table"			with: tableIndex "Next index in table"			with: minBits	"Number of delta bits encoded in table"			with: tableSize - valueIndex "Entries remaining in table").	"Go to next value index"	valueIndex _ valueIndex + 1.	"Walk over remaining bit lengths and create new subtables"	minBits+1 to: maxBits do:[:bits|		numValues _ counts at: bits+1.		[numValues > 0] whileTrue:["Create a new subtable"			lastTable _ tableStack last.			lastTableStart _ lastTable at: 2.			lastTableIndex _ lastTable at: 3.			deltaBits _ bits - (lastTable at: 1).			"Make up a table of deltaBits size"			tableSize _ 1 bitShift: deltaBits.			tableStart _ tableEnd.			tableEnd _ tableEnd + tableSize.			[tableEnd > table size ]				whileTrue:[table _ self growHuffmanTable: table].			"Connect to last table"			self assert:[(table at: lastTableStart + lastTableIndex) isNil]."Entry must be unused"			table at: lastTableStart + lastTableIndex put: (deltaBits bitShift: 24) + tableStart.			lastTable at: 3 put: (self increment: lastTableIndex bits: (lastTable at: 4)).			lastTable at: 5 put: (lastTable at: 5) - 1.			self assert:[(lastTable at: 5) >= 0]. "Don't exceed tableSize"			"Store terminal values"			maxEntries _ numValues min: tableSize.			tableIndex _ 0.			1 to: maxEntries do:[:i|				table at: tableStart + tableIndex put: (values at: valueIndex).				valueIndex _ valueIndex + 1.				numValues _ numValues - 1.				tableIndex _ self increment: tableIndex bits: deltaBits].			"Check if we have filled up the current table completely"			maxEntries = tableSize ifTrue:[				"Table has been filled. Back up to the last table with space left."				[tableStack isEmpty not and:[(tableStack last at: 5) = 0]]						whileTrue:[tableStack removeLast].			] ifFalse:[				"Table not yet filled. Put it back on the stack."				tableStack addLast:					(Array						with: bits		"Nr. of bits in this table"						with: tableStart	"Start of table"						with: tableIndex "Index in table"						with: deltaBits	"delta bits of table"						with: tableSize - maxEntries "Unused entries in table").			].		].	].	 ^table copyFrom: 1 to: tableEnd-1! !!InflateStream methodsFor: 'bit access' stamp: 'ar 12/27/1999 13:47'!bitPosition	"Return the current bit position of the source"	sourceStream == nil		ifTrue:[^sourcePos * 8 + bitPos]		ifFalse:[^sourceStream position + sourcePos * 8 + bitPos]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 12/27/1999 13:44'!collect: aBlock from: firstIndex to: lastIndex	"Refer to the comment in Collection|collect:."	| result |	result _ self species new: lastIndex - firstIndex + 1.	firstIndex to: lastIndex do:		[:index | result at: index put: (aBlock value: (self at: index))].	^ result! !!RunArray methodsFor: 'enumerating' stamp: 'ar 12/27/1999 13:43'!runsAndValuesDo: aBlock	"Evaluate aBlock with run lengths and values from the receiver"	^runs with: values do: aBlock.! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 12/27/1999 13:44'!lengthsAndValuesDo: aBlock	"Evaluate aBlock with the length and value of each run in the receiver"	^self runsAndValuesDo: aBlock! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 12/27/1999 13:44'!runsAndValuesDo: aBlock	"Evaluate aBlock with the length and value of each run in the receiver"	| basicValue length value |	1 to: self basicSize do:[:i|		basicValue _ self basicAt: i.		length _ basicValue bitShift: -16.		value _ basicValue bitAnd: 16rFFFF.		value _ (value bitAnd: 16r7FFF) - (value bitAnd: 16r8000).		aBlock value: length value: value.	].! !!String methodsFor: 'accessing' stamp: 'ar 12/27/1999 13:44'!byteAt: index	<primitive: 60>	^(self at: index) asciiValue! !!String methodsFor: 'accessing' stamp: 'ar 12/27/1999 13:44'!byteAt: index put: value	<primitive: 61>	self at: index put: value asCharacter.	^value! !