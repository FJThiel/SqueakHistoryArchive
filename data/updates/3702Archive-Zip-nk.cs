'From Squeak3.1alpha of 4 February 2001 [latest update: #3710] on 24 February 2001 at 5:40:54 pm'!"Change Set:		Archive-Zip-nkDate:			23 February 2001Author:			Ned KonzThis is a Smalltalk port of my Perl Archive::Zip module.It allows for full-featured creation and manipulationof Zip archives.It also contains some framework (currently unused)for adding Tar or other archives."(Smalltalk includesKey: #ZipFileConstants) ifFalse:[	Smalltalk at: #ZipFileConstants put: Dictionary new.].!Object subclass: #Archive	instanceVariableNames: 'members '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Archives'!Object subclass: #ArchiveMember	instanceVariableNames: 'fileName '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Archives'!GZipWriteStream subclass: #ArchiveZipWriteStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Archives'!Archive subclass: #TarArchive	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Archives'!ArchiveMember subclass: #TarArchiveMember	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Archives'!Archive subclass: #ZipArchive	instanceVariableNames: 'centralDirectorySize centralDirectoryOffsetWRTStartingDiskNumber zipFileComment writeCentralDirectoryOffset writeEOCDOffset '	classVariableNames: ''	poolDictionaries: 'ZipFileConstants '	category: 'System-Archives'!ArchiveMember subclass: #ZipArchiveMember	instanceVariableNames: 'lastModFileDateTime fileAttributeFormat versionMadeBy versionNeededToExtract bitFlag compressionMethod desiredCompressionMethod desiredCompressionLevel internalFileAttributes externalFileAttributes cdExtraField localExtraField fileComment crc32 compressedSize uncompressedSize writeLocalHeaderRelativeOffset readDataRemaining '	classVariableNames: ''	poolDictionaries: 'ZipFileConstants '	category: 'System-Archives'!!ZipArchiveMember commentStamp: '<historical>' prior: 0!Subinstances of me are members in a ZipArchive.They represent different data sources:	* ZipDirectoryMember -- a directory to be added to a zip file	* ZipFileMember -- a file or directory that is already in a zip file	* ZipNewFilemember -- a file that is to be added to a zip file	* ZipStringMember -- a string that is to be added to a zip fileThey can write their data to another stream either copying, compressing,or decompressing as desired.!ZipArchiveMember subclass: #ZipDirectoryMember	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Archives'!ZipArchiveMember subclass: #ZipFileMember	instanceVariableNames: 'externalFileName stream localHeaderRelativeOffset dataOffset '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Archives'!ZipArchiveMember subclass: #ZipNewFileMember	instanceVariableNames: 'externalFileName stream '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Archives'!ZipArchiveMember subclass: #ZipStringMember	instanceVariableNames: 'contents stream '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Archives'!!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 19:09'!addDirectory: aFileName	^self addDirectory: aFileName as: aFileName! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 20:45'!addDirectory: aFileName as: anotherFileName	| newMember |	newMember _ self memberClass newFromDirectory: aFileName.	self addMember: newMember.	newMember fileName: anotherFileName.	^newMember! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 18:29'!addFile: aFileName	^self addFile: aFileName as: aFileName! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 18:30'!addFile: aFileName as: anotherFileName	| newMember |	newMember _ self memberClass newFromFile: aFileName.	self addMember: newMember.	newMember fileName: anotherFileName.	^newMember! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 19:09'!addMember: aMember	^members addLast: aMember! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 17:24'!addString: aString as: aFileName	| newMember |	newMember _ self memberClass newFromString: aString named: aFileName.	self addMember: newMember.	newMember fileName: aFileName.	^newMember! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/24/2001 14:12'!canWriteToFileNamed: aFileName	"Catch attempts to overwrite existing zip file"	^(members anySatisfy: [ :ea | ea usesFileNamed: aFileName ]) not.! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 07:57'!contentsOf: aMemberOrName	| member |	member _ self member: aMemberOrName.	member ifNil: [ ^nil ].	^member contents! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 07:57'!extractMember: aMemberOrName	| member |	member _ self member: aMemberOrName.	member ifNil: [ ^nil ].	member extractToFileNamed: member fileName! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 07:57'!extractMember: aMemberOrName toFileNamed: aFileName	| member |	member _ self member: aMemberOrName.	member ifNil: [ ^nil ].	member extractToFileNamed: aFileName! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 07:57'!extractMemberWithoutPath: aMemberOrName	| member |	member _ self member: aMemberOrName.	member ifNil: [ ^nil ].	member extractToFileNamed: (FileDirectory localNameFor: member fileName)! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 18:00'!memberNamed: aString	^members detect: [ :ea | ea fileName = aString ] ifNone: [ ]! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 18:00'!memberNames	^members collect: [ :ea | ea fileName ]! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 17:58'!members	^members! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 18:01'!membersMatching: aString	^members select: [ :ea | aString match: ea fileName ]! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 17:59'!numberOfMembers	^members size! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 07:57'!removeMember: aMemberOrName	| member |	member _ self member: aMemberOrName.	member ifNotNil: [ members remove: member ].	^member! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 07:57'!replaceMember: aMemberOrName with: newMember	| member |	member _ self member: aMemberOrName.	member ifNotNil: [ members replaceAll: member with: newMember ].	^member! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 17:24'!setContentsOf: aMemberOrName to: aString	| newMember oldMember |	oldMember _ self member: aMemberOrName.	newMember _ (self memberClass newFromString: aString named: oldMember fileName)		copyFrom: oldMember.	self replaceMember: oldMember with: newMember.! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 20:58'!writeTo: aStream	self subclassResponsibility! !!Archive methodsFor: 'archive operations' stamp: 'nk 2/24/2001 14:15'!writeToFileNamed: aFileName	| stream |	"Catch attempts to overwrite existing zip file"	(self canWriteToFileNamed: aFileName)		ifFalse: [ ^self error: (aFileName, ' is needed by one or more members in this archive') ].	stream _ StandardFileStream forceNewFileNamed: aFileName.	self writeTo: stream.	stream close.! !!Archive methodsFor: 'initialization' stamp: 'nk 2/21/2001 17:58'!initialize	members _ OrderedCollection new.! !!Archive methodsFor: 'private' stamp: 'nk 2/22/2001 07:56'!member: aMemberOrName	^(members includes: aMemberOrName)		ifTrue: [ aMemberOrName ]		ifFalse: [ self memberNamed: aMemberOrName ].! !!Archive methodsFor: 'private' stamp: 'nk 2/21/2001 18:14'!memberClass	self subclassResponsibility! !!Archive class methodsFor: 'instance creation' stamp: 'nk 2/21/2001 17:59'!new	^super new initialize! !!ArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 16:00'!fileName	^fileName! !!ArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 16:00'!fileName: aName	fileName _ aName! !!ArchiveMember methodsFor: 'testing' stamp: 'nk 2/21/2001 19:43'!usesFileNamed: aFileName	"Do I require aFileName? That is, do I care if it's clobbered?"	^false! !!ArchiveMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 16:00'!initialize	fileName _ ''! !!ArchiveMember methodsFor: 'printing' stamp: 'nk 2/22/2001 16:07'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(;		nextPutAll: self fileName;		nextPut: $)! !!ArchiveMember class methodsFor: 'as yet unclassified' stamp: 'nk 2/21/2001 18:33'!newDirectoryNamed: aString	self subclassResponsibility! !!ArchiveMember class methodsFor: 'as yet unclassified' stamp: 'nk 2/21/2001 18:32'!newFromFile: aFileName	self subclassResponsibility! !!ArchiveMember class methodsFor: 'as yet unclassified' stamp: 'nk 2/21/2001 18:32'!newFromString: aString	self subclassResponsibility! !!FileDirectory methodsFor: 'enumeration' stamp: 'nk 2/23/2001 11:35'!directoryEntry	^self containingDirectory entryAt: self localName! !!Stream methodsFor: 'accessing' stamp: 'nk 2/24/2001 17:31'!binary! !!ArchiveZipWriteStream methodsFor: 'initialize-release' stamp: 'nk 2/23/2001 08:27'!writeFooter! !!ArchiveZipWriteStream methodsFor: 'initialize-release' stamp: 'nk 2/23/2001 08:28'!writeHeader! !!ArchiveZipWriteStream methodsFor: 'file open/close' stamp: 'nk 2/23/2001 08:30'!close	self deflateBlock.	self flushBlock: true.	encoder flush.! !!FileStream methodsFor: 'accessing' stamp: 'nk 2/22/2001 17:07'!directoryEntry	^self directory entryAt: self localName! !!String methodsFor: 'accessing' stamp: 'nk 2/21/2001 21:26'!lastIndexOfPKSignature: aSignature	"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found"	| a b c d |	a _ aSignature first.	b _ aSignature second.	c _ aSignature third.	d _ aSignature fourth.	(self size - 3) to: 1 by: -1 do: [ :i |		(((self at: i) = a)			and: [ ((self at: i + 1) = b)				and: [ ((self at: i + 2) = c)					and: [ ((self at: i + 3) = d) ]]])						ifTrue: [ ^i ]	].	^0! !!String methodsFor: 'converting' stamp: 'nk 2/21/2001 20:06'!asHex	| stream |	stream _ WriteStream on: (String new: self size * 2).	self do: [ :ch | stream nextPutAll: ch hex ].	^stream contents! !!TarArchive methodsFor: 'private' stamp: 'nk 2/21/2001 18:27'!memberClass	^TarArchiveMember! !!ZipArchive methodsFor: 'archive operations' stamp: 'nk 2/23/2001 08:35'!readFrom: aStreamOrFileName	| stream name eocdPosition |	stream _ aStreamOrFileName isStream ifTrue: [ name _ aStreamOrFileName name. aStreamOrFileName ]		ifFalse: [ StandardFileStream oldFileNamed: (name _ aStreamOrFileName) ].	stream binary.	self findEndOfCentralDirectoryFrom: stream.	eocdPosition _ stream position.	self readEndOfCentralDirectoryFrom: stream.	stream position: eocdPosition - centralDirectorySize.	self readMembersFrom: stream named: name.! !!ZipArchive methodsFor: 'archive operations' stamp: 'nk 2/23/2001 10:29'!writeTo: stream	stream binary.	members do: [ :member |		member writeTo: stream.		member endRead.	].	writeCentralDirectoryOffset _ stream position.	self writeCentralDirectoryTo: stream.	! !!ZipArchive methodsFor: 'initialization' stamp: 'nk 2/22/2001 17:20'!initialize	super initialize.	writeEOCDOffset _ writeCentralDirectoryOffset _ 0.	zipFileComment _ ''.! !!ZipArchive methodsFor: 'private' stamp: 'nk 2/22/2001 15:40'!findEndOfCentralDirectoryFrom: stream	"Seek in my file to the end, then read backwards until we find the	signature of the central directory record. Leave the file positioned right	before the signature."	| data fileLength seekOffset pos |	stream setToEnd.	fileLength _ stream position.	"If the file length is less than 18 for the EOCD length plus 4 for the signature, we have a problem"	fileLength < 22 ifTrue: [ ^self error: 'file is too short' ].		seekOffset _ 0.	pos _ 0.	data _ String new: 4100.	[		seekOffset _ (seekOffset + 4096) min: fileLength.		stream position: fileLength - seekOffset.		data _ stream next: (4100 min: seekOffset) into: data startingAt: 1.		pos _ data lastIndexOfPKSignature: EndOfCentralDirectorySignature.		pos > 0 or: [ seekOffset = fileLength ]	] whileFalse.	pos > 0		ifTrue: [ stream position: (stream position + pos - seekOffset - 1) ]		ifFalse: [ self error: 'can''t find EOCD signature' ].! !!ZipArchive methodsFor: 'private' stamp: 'nk 2/21/2001 18:26'!memberClass	^ZipArchiveMember! !!ZipArchive methodsFor: 'private' stamp: 'nk 2/22/2001 17:19'!readEndOfCentralDirectoryFrom: aStream	"Read EOCD, starting from position before signature."	| signature zipFileCommentLength |	signature _ self readSignatureFrom: aStream.	signature = EndOfCentralDirectorySignature ifFalse: [ ^self error: 'bad signature at ', aStream position printString ].	aStream nextLittleEndianNumber: 2. "# of this disk"	aStream nextLittleEndianNumber: 2. "# of disk with central dir start"	aStream nextLittleEndianNumber: 2. "# of entries in central dir on this disk"	aStream nextLittleEndianNumber: 2. "total # of entries in central dir"	centralDirectorySize _ aStream nextLittleEndianNumber: 4. "size of central directory"	centralDirectoryOffsetWRTStartingDiskNumber _ aStream nextLittleEndianNumber: 4. "offset of start of central directory"	zipFileCommentLength _ aStream nextLittleEndianNumber: 2. "zip file comment"	zipFileComment _ aStream next: zipFileCommentLength.! !!ZipArchive methodsFor: 'private' stamp: 'nk 2/23/2001 09:19'!readMembersFrom: stream named: fileName	| newMember signature |	[		newMember _ self memberClass newFromZipFile: stream named: fileName.		signature _ self readSignatureFrom: stream.		signature = EndOfCentralDirectorySignature ifTrue: [ ^self ].		signature = CentralDirectoryFileHeaderSignature			ifFalse: [ self error: 'bad CD signature at ', (stream position - 4) hex ].		newMember readFrom: stream.		newMember looksLikeDirectory ifTrue: [ newMember _ newMember asDirectory ].		self addMember: newMember.	] repeat.! !!ZipArchive methodsFor: 'private' stamp: 'nk 2/21/2001 20:09'!readSignatureFrom: stream	"Returns next signature from given stream, leaves stream positioned afterwards."	| signatureData | 	signatureData _ String new: 4.	stream next: 4 into: signatureData.	({ CentralDirectoryFileHeaderSignature . LocalFileHeaderSignature . EndOfCentralDirectorySignature }		includes: signatureData)			ifFalse: [ ^self error: 'bad signature ', signatureData asHex, ' at position ', (stream position - 4) asString ].	^signatureData! !!ZipArchive methodsFor: 'private' stamp: 'nk 2/21/2001 20:19'!writeCentralDirectoryTo: aStream	| offset |	offset _ writeCentralDirectoryOffset.	members do: [ :member |		member writeCentralDirectoryFileHeaderTo: aStream.		offset _ offset + member centralDirectoryHeaderSize.	].	writeEOCDOffset _ offset.	self writeEndOfCentralDirectoryTo: aStream.! !!ZipArchive methodsFor: 'private' stamp: 'nk 2/21/2001 21:02'!writeEndOfCentralDirectoryTo: aStream	aStream nextPutAll: EndOfCentralDirectorySignature.	aStream nextLittleEndianNumber: 2 put: 0. "diskNumber"	aStream nextLittleEndianNumber: 2 put: 0. "diskNumberWithStartOfCentralDirectory"	aStream nextLittleEndianNumber: 2 put: members size. "numberOfCentralDirectoriesOnThisDisk"	aStream nextLittleEndianNumber: 2 put: members size. "numberOfCentralDirectories"	aStream nextLittleEndianNumber: 4 put: writeEOCDOffset - writeCentralDirectoryOffset. "size of central dir"	aStream nextLittleEndianNumber: 4 put: writeCentralDirectoryOffset. "offset of central dir"	aStream nextLittleEndianNumber: 2 put: zipFileComment size. "zip file comment"	zipFileComment isEmpty ifFalse: [ aStream nextPutAll: zipFileComment ].! !!ZipArchive methodsFor: 'accessing' stamp: 'nk 2/24/2001 13:44'!zipFileComment	^zipFileComment asString! !!ZipArchive methodsFor: 'accessing' stamp: 'nk 2/24/2001 13:43'!zipFileComment: aString	zipFileComment _ aString! !!ZipArchive class methodsFor: 'class variables' stamp: 'nk 2/21/2001 17:40'!initialize	"ZipArchive initialize"	self initializeZipFileConstants.! !!ZipArchive class methodsFor: 'constants' stamp: 'nk 2/22/2001 14:13'!compressionDeflated	^CompressionDeflated! !!ZipArchive class methodsFor: 'constants' stamp: 'nk 2/22/2001 14:12'!compressionLevelDefault	^CompressionLevelDefault! !!ZipArchive class methodsFor: 'constants' stamp: 'nk 2/22/2001 14:12'!compressionLevelNone	^CompressionLevelNone ! !!ZipArchive class methodsFor: 'constants' stamp: 'nk 2/22/2001 14:13'!compressionStored	^CompressionStored! !!ZipArchive class methodsFor: 'constants' stamp: 'ar 2/24/2001 16:37'!initializeZipFileConstants	"ZipArchive initializeZipFileConstants"	(Smalltalk includesKey: #ZipFileConstants) ifFalse:[		Smalltalk at: #ZipFileConstants put: Dictionary new.	].	#(			(FaMsdos	0)			(FaUnix		3)			(DeflatingCompressionNormal	0)			(DeflatingCompressionMaximum	2)			(DeflatingCompressionFast		4)			(DeflatingCompressionSuperFast	6)			(CompressionStored				0)			(CompressionDeflated			8)			(CompressionLevelNone			0)			(CompressionLevelDefault		6)			(IfaTextFile		1)			(IfaBinaryFile	0)			(CentralDirectoryFileHeaderSignature		0)			(LocalFileHeaderSignature 				0)			(EndOfCentralDirectorySignature 		0)			(DataDescriptorLength 	12)			"Unix permission bits"			(DefaultDirectoryPermissions		8r040755)			(DefaultFilePermissions			8r0100666)			(DirectoryAttrib 				8r040000)			(FileAttrib 						8r0100000)	) do:[:spec|		ZipFileConstants declare: spec first from: Undeclared.		ZipFileConstants at: spec first put: spec last.	].	CentralDirectoryFileHeaderSignature _ 		(ByteArray with: 16r50 with: 16r4B with: 16r01 with: 16r02) asString.	LocalFileHeaderSignature _		(ByteArray with: 16r50 with: 16r4B with: 16r03 with: 16r04) asString.	EndOfCentralDirectorySignature _		(ByteArray with: 16r50 with: 16r4B with: 16r05 with: 16r06) asString.! !!ZipArchiveMember methodsFor: 'TODO' stamp: 'nk 2/23/2001 11:02'!compressDataTo: aStream	"Copy my deflated data to the given stream."	| encoder startPos endPos |	encoder _ ArchiveZipWriteStream on: aStream.	startPos _ aStream position.	[ readDataRemaining > 0 ] whileTrue: [ | data |		data _ self readRawChunk: (4096 min: readDataRemaining).		encoder nextPutAll: data asByteArray.		readDataRemaining _ readDataRemaining - data size.	].	encoder close.	endPos _ aStream position.	compressedSize _ endPos - startPos.	crc32 _ encoder crc.! !!ZipArchiveMember methodsFor: 'TODO' stamp: 'nk 2/23/2001 11:04'!copyDataTo: aStream	compressionMethod = CompressionStored ifTrue: [ ^self copyDataWithCRCTo: aStream ].	self copyRawDataTo: aStream.! !!ZipArchiveMember methodsFor: 'TODO' stamp: 'nk 2/23/2001 11:11'!copyDataWithCRCTo: aStream	"only used when compressionMethod = desiredCompressionMethod = CompressionStored"	| encoder |	uncompressedSize _ compressedSize _ readDataRemaining.	encoder _ GZipWriteStream on: (ByteArray new: 20).	crc32 _ 16rFFFFFFFF.	[ readDataRemaining > 0 ] whileTrue: [ | data |		data _ self readRawChunk: (4096 min: readDataRemaining).		aStream nextPutAll: data.		crc32 _ encoder updateCrc: crc32 from: 1 to: data size in: data.		readDataRemaining _ readDataRemaining - data size.	].	crc32 _ crc32 bitXor: 16rFFFFFFFF.! !!ZipArchiveMember methodsFor: 'TODO' stamp: 'nk 2/23/2001 11:04'!copyRawDataTo: aStream	[ readDataRemaining > 0 ] whileTrue: [ | data |		data _ self readRawChunk: (4096 min: readDataRemaining).		aStream nextPutAll: data.		readDataRemaining _ readDataRemaining - data size.	].! !!ZipArchiveMember methodsFor: 'TODO' stamp: 'nk 2/22/2001 20:42'!readRawChunk: n	self subclassResponsibility! !!ZipArchiveMember methodsFor: 'TODO' stamp: 'nk 2/22/2001 20:41'!writeDataTo: aStream	"Copy my (possibly inflated or deflated) data to the given stream.	This might do compression, decompression, or straight copying, depending	on the values of compressionMethod and desiredCompressionMethod"	uncompressedSize = 0 ifTrue: [ ^self ].	"nothing to do because no data"	(compressionMethod = CompressionStored and: [ desiredCompressionMethod = CompressionDeflated ])		ifTrue: [ ^self compressDataTo: aStream ].	(compressionMethod = CompressionDeflated and: [ desiredCompressionMethod = CompressionStored ])		ifTrue: [ ^self uncompressDataTo: aStream ].	self copyDataTo: aStream.! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 09:44'!centralDirectoryHeaderSize	^ 46 + fileName size + cdExtraField size + fileComment size! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/23/2001 08:00'!clearExtraFields	cdExtraField _ ''.	localExtraField _ ''.! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:38'!compressedSize	"Return the compressed size for this member.	This will not be set for members that were constructed from strings	or external files until after the member has been written."	^compressedSize! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/21/2001 22:02'!compressionMethod	"Returns my compression method. This is the method that is	currently being used to compress my data.	This will be CompressionStored for added string or file members,	or CompressionStored or CompressionDeflated (others are possible but not handled)"	^compressionMethod! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/24/2001 17:33'!contents	"Answer my contents as a string."	| s |	s _ ReadWriteStream on: (ByteArray new: self uncompressedSize).	self extractTo: s.	^s contents asString! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:28'!crc32	^crc32! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:35'!crc32String	| hexString |	hexString _ crc32 hex.	^('00000000' copyFrom: 1 to: 11 - (hexString size)) , (hexString copyFrom: 4 to: hexString size)! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/21/2001 22:10'!desiredCompressionLevel	^desiredCompressionLevel! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/21/2001 22:14'!desiredCompressionLevel: aNumber	"Set my desiredCompressionLevel	This is the method that will be used to write.	Returns prior desiredCompressionLevel.	Valid arguments are 0 (CompressionLevelNone) through 9,	including 6 (CompressionLevelDefault).	0 (CompressionLevelNone) will change the desiredCompressionMethod	to CompressionStored. All other arguments will change the	desiredCompressionMethod to CompressionDeflated."	| old |	old _ desiredCompressionLevel.	desiredCompressionLevel _ aNumber.	desiredCompressionMethod _ (aNumber > 0)		ifTrue: [ CompressionDeflated ]		ifFalse: [ CompressionStored ].	^old! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/21/2001 22:03'!desiredCompressionMethod	"Get my desiredCompressionMethod.	This is the method that will be used to write"	^desiredCompressionMethod! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/23/2001 11:25'!desiredCompressionMethod: aNumber	"Set my desiredCompressionMethod	This is the method that will be used to write.	Answers prior desiredCompressionMethod.	Only CompressionDeflated or CompressionStored are valid arguments.	Changing to CompressionStored will change my desiredCompressionLevel	to CompressionLevelNone; changing to CompressionDeflated will change my	desiredCompressionLevel to CompressionLevelDefault."	| old |	old _ desiredCompressionMethod.	desiredCompressionMethod _ aNumber.	desiredCompressionLevel _ (aNumber = CompressionDeflated)			ifTrue: [ CompressionLevelDefault ]			ifFalse: [ CompressionLevelNone ].	compressionMethod = CompressionStored ifTrue: [ compressedSize _ uncompressedSize ].	^old.! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 09:35'!extractToFileNamed: aFileName	| stream |	self isEncrypted ifTrue: [ ^self error: 'encryption unsupported' ].	stream _ StandardFileStream forceNewFileNamed: aFileName.	self extractTo: stream.	stream close.		! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:25'!fileComment	^fileComment! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:25'!fileComment: aString	fileComment _ aString! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/21/2001 22:14'!fileName	^fileName! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/21/2001 23:02'!fileName: aString	"Set my internal filename.	Returns the (possibly new) filename.	MUST BE IN UNIX FORM (slashes as separators, etc.)"	| newName |	newName _ aString.	^fileName _ newName.! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/24/2001 14:34'!lastModTime	"Return my last modification date/time stamp,	converted to Squeak seconds"	^self unixToSqueakTime: (self dosToUnixTime: lastModFileDateTime)! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/21/2001 23:39'!setLastModFileDateTimeFrom: aSmalltalkTime	| unixTime |	unixTime _ aSmalltalkTime -  2177424000.		"PST?"	lastModFileDateTime _ self unixToDosTime: unixTime! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:38'!uncompressedSize	"Return the uncompressed size for this member."	^uncompressedSize! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:18'!unixFileAttributes	^self mapPermissionsToUnix: externalFileAttributes.! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:24'!unixFileAttributes: perms	| oldPerms newPerms |	oldPerms _ self mapPermissionsToUnix: externalFileAttributes.	newPerms _  self isDirectory			ifTrue: [ (perms bitAnd: FileAttrib bitInvert) bitOr: DirectoryAttrib ]			ifFalse: [ (perms bitAnd: DirectoryAttrib bitInvert) bitOr: FileAttrib ].	externalFileAttributes _ self mapPermissionsFromUnix: newPerms.	^oldPerms.! !!ZipArchiveMember methodsFor: 'initialization' stamp: 'nk 2/24/2001 16:16'!initialize	super initialize.	lastModFileDateTime _ 0.	fileAttributeFormat _ FaUnix.	versionMadeBy _ 20.	versionNeededToExtract _ 20.	bitFlag _ 0.	compressionMethod _ CompressionStored.	desiredCompressionMethod _ CompressionDeflated.	desiredCompressionLevel _ CompressionLevelDefault.	internalFileAttributes _ 0.	externalFileAttributes _ 0.	fileName _ ''.	cdExtraField _ ''.	localExtraField _ ''.	fileComment _ ''.	crc32 _ 0.	compressedSize _ 0.	uncompressedSize _ 0.	self unixFileAttributes: DefaultFilePermissions.! !!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:40'!hasDataDescriptor	^ (bitFlag bitAnd: 8)	~= 0 "GPBF_HAS_DATA_DESCRIPTOR_MASK"! !!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:00'!isDirectory	^false! !!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:39'!isEncrypted	"Return true if this member is encrypted (this is unsupported)"	^ (bitFlag bitAnd: 1) ~= 0! !!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:41'!isTextFile	"Returns true if I am a text file.	Note that this module does not currently do anything with this flag	upon extraction or storage.	That is, bytes are stored in native format whether or not they came	from a text file."	^ (internalFileAttributes bitAnd: 1) ~= 0! !!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:43'!isTextFile: aBoolean	"Set whether I am a text file.	Note that this module does not currently do anything with this flag	upon extraction or storage.	That is, bytes are stored in native format whether or not they came	from a text file."	internalFileAttributes _ aBoolean		ifTrue: [ internalFileAttributes bitOr: 1 ]		ifFalse: [ internalFileAttributes bitAnd: 1 bitInvert ]! !!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/21/2001 20:38'!looksLikeDirectory	^false! !!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/21/2001 21:55'!asDirectory	^ZipDirectoryMember new copyFrom: self! !!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/21/2001 23:54'!dosToUnixTime: dt	"DOS years start at 1980, Unix at 1970, and Smalltalk at 1901.	So the Smalltalk seconds will be high by 69 years when used as Unix time_t values.	So shift 1980 back to 1911..."	| year mon mday hour min sec date time |	year _ (( dt bitShift: -25 ) bitAnd: 16r7F ) + 1911.	mon _ (( dt bitShift: -21 ) bitAnd: 16r0F ).	mday _ (( dt bitShift: -16 ) bitAnd: 16r1F ).	date _ Date newDay: mday month: mon year: year.	hour _ (( dt bitShift: -11 ) bitAnd: 16r1F ).	min _ (( dt bitShift: -5 ) bitAnd: 16r3F ).	sec _ (( dt bitShift: 1 ) bitAnd: 16r3E ).	time _ ((( hour * 60 ) + min ) * 60 ) + sec.	^date asSeconds + time	! !!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/23/2001 08:24'!endRead	readDataRemaining _ 0.! !!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/21/2001 23:57'!mapPermissionsFromUnix: unixPerms	^ unixPerms bitShift: 16.! !!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/21/2001 23:58'!mapPermissionsToUnix: dosPerms	^ dosPerms bitShift: -16.! !!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/22/2001 17:13'!unixToDosTime: unixTime	| dosTime dateTime secs |	secs _ self unixToSqueakTime: unixTime.	"Squeak time (PST?)"	dateTime _ Time dateAndTimeFromSeconds: secs.	dosTime _ (dateTime second seconds) bitShift: -1.	dosTime _ dosTime + ((dateTime second minutes) bitShift: 5).	dosTime _ dosTime + ((dateTime second hours) bitShift: 11).	dosTime _ dosTime + ((dateTime first dayOfMonth) bitShift: 16).	dosTime _ dosTime + ((dateTime first monthIndex) bitShift: 21).	dosTime _ dosTime + (((dateTime first year) - 1980) bitShift: 25).	^dosTime! !!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/22/2001 13:22'!unixToSqueakTime: unixTime	^unixTime +  2177424000.		"Squeak time (PST?)"! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 2/22/2001 18:03'!extractTo: aStream	| oldCompression |	self isEncrypted ifTrue: [ self error: 'encryption is unsupported' ].	aStream binary.	oldCompression _ self desiredCompressionMethod: CompressionStored.	self rewindData.	self writeDataTo: aStream.	self desiredCompressionMethod: oldCompression.	self endRead.! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 12:22'!refreshLocalFileHeaderTo: aStream	"Re-writes my local header to the given stream.	To be called after writing the data stream.	Assumes that fileName and localExtraField sizes didn't change since last written."	| here |	here _ aStream position.	aStream position: writeLocalHeaderRelativeOffset.	aStream nextPutAll: LocalFileHeaderSignature.	aStream nextLittleEndianNumber: 2 put: versionNeededToExtract.	aStream nextLittleEndianNumber: 2 put: bitFlag.	aStream nextLittleEndianNumber: 2 put: desiredCompressionMethod.	aStream nextLittleEndianNumber: 4 put: lastModFileDateTime.	aStream nextLittleEndianNumber: 4 put: crc32.	aStream nextLittleEndianNumber: 4 put: (desiredCompressionMethod = CompressionStored												ifTrue: [ uncompressedSize ] ifFalse: [ compressedSize ]).	aStream nextLittleEndianNumber: 4 put: uncompressedSize.	aStream nextLittleEndianNumber: 2 put: fileName size.	aStream nextLittleEndianNumber: 2 put: localExtraField size.	aStream position: here.! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 12:06'!rewindData	readDataRemaining _  uncompressedSize.! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 12:18'!writeCentralDirectoryFileHeaderTo: aStream	"C2 v3 V4 v5 V2"	aStream nextPutAll: CentralDirectoryFileHeaderSignature.	aStream nextLittleEndianNumber: 1 put: versionMadeBy.	aStream nextLittleEndianNumber: 1 put: fileAttributeFormat.	aStream nextLittleEndianNumber: 2 put: versionNeededToExtract.	aStream nextLittleEndianNumber: 2 put: bitFlag.	aStream nextLittleEndianNumber: 2 put: desiredCompressionMethod.	aStream nextLittleEndianNumber: 4 put: lastModFileDateTime.	"These next 3 should have been updated during the write of the data"	aStream nextLittleEndianNumber: 4 put: crc32.	aStream nextLittleEndianNumber: 4 put: (desiredCompressionMethod = CompressionStored												ifTrue: [ uncompressedSize ] ifFalse: [ compressedSize ]).	aStream nextLittleEndianNumber: 4 put: uncompressedSize.	aStream nextLittleEndianNumber: 2 put: fileName size.	aStream nextLittleEndianNumber: 2 put: cdExtraField size.	aStream nextLittleEndianNumber: 2 put: fileComment size.	aStream nextLittleEndianNumber: 2 put: 0.		"diskNumberStart"	aStream nextLittleEndianNumber: 2 put: internalFileAttributes.	aStream nextLittleEndianNumber: 4 put: externalFileAttributes.	aStream nextLittleEndianNumber: 4 put: writeLocalHeaderRelativeOffset.	aStream nextPutAll: fileName asByteArray.	aStream nextPutAll: cdExtraField asByteArray.	aStream nextPutAll: fileComment asByteArray.! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 2/22/2001 21:53'!writeDataDescriptorTo: aStream	"This writes a data descriptor to the given stream.	Assumes that crc32, writeOffset, and uncompressedSize are	set correctly (they should be after a write).	Further, the local file header should have the	GPBF_HAS_DATA_DESCRIPTOR_MASK (8) bit set."	aStream nextLittleEndianNumber: 4 put: crc32.	aStream nextLittleEndianNumber: 4 put: compressedSize.	aStream nextLittleEndianNumber: 4 put: uncompressedSize.! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 12:18'!writeLocalFileHeaderTo: aStream	"Write my local header to a file handle.	Stores the offset to the start of the header in my	writeLocalHeaderRelativeOffset member."	aStream nextPutAll: LocalFileHeaderSignature.	aStream nextLittleEndianNumber: 2 put: versionNeededToExtract.	aStream nextLittleEndianNumber: 2 put: bitFlag.	aStream nextLittleEndianNumber: 2 put: desiredCompressionMethod.	aStream nextLittleEndianNumber: 4 put: lastModFileDateTime.	aStream nextLittleEndianNumber: 4 put: crc32.	aStream nextLittleEndianNumber: 4 put: (desiredCompressionMethod = CompressionStored												ifTrue: [ uncompressedSize ] ifFalse: [ compressedSize ]).	aStream nextLittleEndianNumber: 4 put: uncompressedSize.	aStream nextLittleEndianNumber: 2 put: fileName size.	aStream nextLittleEndianNumber: 2 put: localExtraField size.	aStream nextPutAll: fileName asByteArray.	aStream nextPutAll: localExtraField asByteArray.! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 11:28'!writeTo: aStream	self rewindData.	writeLocalHeaderRelativeOffset _ aStream position.	self writeLocalFileHeaderTo: aStream.	self writeDataTo: aStream.	self refreshLocalFileHeaderTo: aStream.! !!ZipArchiveMember class methodsFor: 'instance creation' stamp: 'nk 2/21/2001 21:45'!new	^super new initialize! !!ZipArchiveMember class methodsFor: 'instance creation' stamp: 'nk 2/22/2001 17:27'!newFromDirectory: aFileName	^ZipDirectoryMember newNamed: aFileName! !!ZipArchiveMember class methodsFor: 'instance creation' stamp: 'nk 2/22/2001 17:27'!newFromFile: aFileName	^ZipNewFileMember newNamed: aFileName! !!ZipArchiveMember class methodsFor: 'instance creation' stamp: 'nk 2/22/2001 17:25'!newFromString: aString named: aFileName	^ZipStringMember newFrom: aString named: aFileName! !!ZipArchiveMember class methodsFor: 'instance creation' stamp: 'nk 2/21/2001 20:40'!newFromZipFile: stream named: fileName	^ZipFileMember newFrom: stream named: fileName! !!ZipDirectoryMember methodsFor: 'initialization' stamp: 'nk 2/23/2001 10:01'!initialize	super initialize.	super desiredCompressionMethod: CompressionStored.! !!ZipDirectoryMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:00'!isDirectory	^true! !!ZipDirectoryMember methodsFor: 'private' stamp: 'nk 2/21/2001 21:55'!asDirectory	^self! !!ZipDirectoryMember methodsFor: 'accessing' stamp: 'nk 2/23/2001 10:00'!desiredCompressionMethod: aNumber! !!ZipDirectoryMember methodsFor: 'accessing' stamp: 'nk 2/23/2001 11:44'!fileName: aString	| stream entry |	super fileName: aString.	fileName last = $/ ifFalse: [ fileName _ fileName, '/' ].	stream _ FileDirectory on: (FileDirectory default fullNameFor: fileName).	entry _ stream directoryEntry.	self setLastModFileDateTimeFrom: entry modificationTime! !!ZipDirectoryMember class methodsFor: 'as yet unclassified' stamp: 'nk 2/22/2001 17:37'!newNamed: aFileName	^(self new) fileName: aFileName; yourself! !!ZipFileMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 16:52'!initialize	super initialize.	crc32 _ 0.	localHeaderRelativeOffset _ 0.	dataOffset _ 0.! !!ZipFileMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 16:51'!stream: aStream externalFileName: aFileName	stream _ aStream.	externalFileName _ aFileName.! !!ZipFileMember methodsFor: 'testing' stamp: 'nk 2/21/2001 21:52'!looksLikeDirectory	^fileName last = $/		and: [ uncompressedSize = 0 ]! !!ZipFileMember methodsFor: 'testing' stamp: 'nk 2/24/2001 14:07'!usesFileNamed: aFileName	"Do I require aFileName? That is, do I care if it's clobbered?"	^(FileDirectory default fullNameFor: externalFileName) = (FileDirectory default fullNameFor: aFileName)! !!ZipFileMember methodsFor: 'private' stamp: 'nk 2/21/2001 21:55'!asDirectory	^ZipDirectoryMember new copyFrom: self! !!ZipFileMember methodsFor: 'private-reading' stamp: 'nk 2/23/2001 09:12'!readCentralDirectoryFileHeaderFrom: aStream	"Assumes aStream positioned after signature"	| fileNameLength extraFieldLength fileCommentLength |	versionMadeBy _ aStream nextLittleEndianNumber: 1.	fileAttributeFormat _ aStream nextLittleEndianNumber: 1.	versionNeededToExtract _ aStream nextLittleEndianNumber: 2.	bitFlag _ aStream nextLittleEndianNumber: 2.	compressionMethod _ aStream nextLittleEndianNumber: 2.	lastModFileDateTime _ aStream nextLittleEndianNumber: 4.	crc32 _ aStream nextLittleEndianNumber: 4.	compressedSize _ aStream nextLittleEndianNumber: 4.	uncompressedSize _ aStream nextLittleEndianNumber: 4.	fileNameLength _ aStream nextLittleEndianNumber: 2.	extraFieldLength _ aStream nextLittleEndianNumber: 2.	fileCommentLength _ aStream nextLittleEndianNumber: 2.	aStream nextLittleEndianNumber: 2. 	"disk number start"	internalFileAttributes _ aStream nextLittleEndianNumber: 2.	externalFileAttributes _ aStream nextLittleEndianNumber: 4.	localHeaderRelativeOffset _ aStream nextLittleEndianNumber: 4.	fileName _ (aStream next: fileNameLength) asString.	cdExtraField _ (aStream next: extraFieldLength) asByteArray.	fileComment _ (aStream next: fileCommentLength) asString.	self desiredCompressionMethod: compressionMethod! !!ZipFileMember methodsFor: 'private-reading' stamp: 'nk 2/23/2001 09:21'!readFrom: aStream	"assumes aStream positioned after CD header; leaves stream positioned after my CD entry"	self readCentralDirectoryFileHeaderFrom: aStream.	self readLocalDirectoryFileHeaderFrom: aStream.	self endRead.! !!ZipFileMember methodsFor: 'private-reading' stamp: 'nk 2/23/2001 09:25'!readLocalDirectoryFileHeaderFrom: aStream 	"Positions stream as necessary. Will return stream to its original position"	| fileNameLength extraFieldLength xcrc32 xcompressedSize xuncompressedSize sig oldPos |	oldPos _ aStream position.	aStream position: localHeaderRelativeOffset.	sig _ aStream next: 4.	sig = LocalFileHeaderSignature asByteArray		ifFalse: [ aStream position: oldPos.				^self error: 'bad LH signature at ', localHeaderRelativeOffset hex ].	versionNeededToExtract _ aStream nextLittleEndianNumber: 2.	bitFlag _ aStream nextLittleEndianNumber: 2.	compressionMethod _ aStream nextLittleEndianNumber: 2.	lastModFileDateTime _ aStream nextLittleEndianNumber: 4.	xcrc32 _ aStream nextLittleEndianNumber: 4.	xcompressedSize _ aStream nextLittleEndianNumber: 4.	xuncompressedSize _ aStream nextLittleEndianNumber: 4.	fileNameLength _ aStream nextLittleEndianNumber: 2.	extraFieldLength _ aStream nextLittleEndianNumber: 2.	fileName _ (aStream next: fileNameLength) asString.	localExtraField _ (aStream next: extraFieldLength) asByteArray.	dataOffset _ aStream position.	"Don't trash these fields if we already got them from the central directory"	self hasDataDescriptor ifFalse: [		crc32 _ xcrc32.		compressedSize _ xcompressedSize.		uncompressedSize _ xuncompressedSize.	].	aStream position: oldPos.! !!ZipFileMember methodsFor: 'private-reading' stamp: 'nk 2/22/2001 20:46'!readRawChunk: n	^stream next: n! !!ZipFileMember methodsFor: 'private-reading' stamp: 'nk 2/23/2001 09:56'!rewindData	super rewindData.	(stream isNil or: [ stream closed ])		ifTrue: [ self error: 'stream missing or closed' ].	stream position: (localHeaderRelativeOffset + 4).	self skipLocalDirectoryFileHeaderFrom: stream.! !!ZipFileMember methodsFor: 'private-reading' stamp: 'nk 2/23/2001 09:56'!skipLocalDirectoryFileHeaderFrom: aStream 	"Assumes that stream is positioned after signature."	|  extraFieldLength fileNameLength |	aStream next: 22.	fileNameLength _ aStream nextLittleEndianNumber: 2.	extraFieldLength _ aStream nextLittleEndianNumber: 2.	aStream next: fileNameLength.	aStream next: extraFieldLength.	dataOffset _ aStream position.! !!ZipFileMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 11:04'!copyDataTo: aStream	self copyRawDataTo: aStream.! !!ZipFileMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 12:16'!uncompressDataTo: aStream	| decoder buffer chunkSize |	decoder _ FastInflateStream on: stream.	buffer _ ByteArray new: (32768 min: readDataRemaining).	[ readDataRemaining > 0 ] whileTrue: [		chunkSize _ 32768 min: readDataRemaining.		buffer _ decoder next: chunkSize into: buffer startingAt: 1.		aStream next: chunkSize putAll: buffer startingAt: 1.		readDataRemaining _ readDataRemaining - chunkSize.	].! !!ZipFileMember class methodsFor: 'as yet unclassified' stamp: 'nk 2/22/2001 17:31'!newFrom: stream named: fileName	^(self new) stream: stream externalFileName: fileName! !!ZipNewFileMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 21:18'!from: aFileName	| entry |	compressionMethod _ CompressionStored.	"Now get the size, attributes, and timestamps, and see if the file exists"	stream _ StandardFileStream oldFileNamed: aFileName.	externalFileName _ fileName _ stream name.	entry _ stream directoryEntry.	compressedSize _ uncompressedSize _ entry fileSize.	desiredCompressionMethod _ compressedSize > 0 ifTrue: [ CompressionDeflated ] ifFalse: [ CompressionStored ].	self setLastModFileDateTimeFrom: entry modificationTime! !!ZipNewFileMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 16:56'!initialize	super initialize.	externalFileName _ ''.! !!ZipNewFileMember methodsFor: 'TODO' stamp: 'nk 2/22/2001 20:48'!readRawChunk: n	^stream next: n! !!ZipNewFileMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 09:58'!rewindData	super rewindData.	readDataRemaining _ stream size.	stream position: 0.! !!ZipNewFileMember methodsFor: 'testing' stamp: 'nk 2/24/2001 15:03'!usesFileNamed: aFileName	"Do I require aFileName? That is, do I care if it's clobbered?"	^(FileDirectory default fullNameFor: externalFileName) = (FileDirectory default fullNameFor: aFileName)! !!ZipNewFileMember class methodsFor: 'instance creation' stamp: 'nk 2/22/2001 17:27'!newNamed: aFileName	^(self new) from: aFileName! !!ZipStringMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 16:47'!contents	^contents! !!ZipStringMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 20:50'!contents: aString	contents _ aString.	compressedSize _ uncompressedSize _ aString size.	"set the file date to now"	self setLastModFileDateTimeFrom: Time totalSeconds! !!ZipStringMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 20:50'!initialize	super initialize.	self contents: ''.	compressionMethod _ desiredCompressionMethod _ CompressionStored.! !!ZipStringMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 10:28'!rewindData	super rewindData.	stream _ ReadStream on: contents.	readDataRemaining _ contents size.! !!ZipStringMember methodsFor: 'TODO' stamp: 'nk 2/22/2001 20:51'!readRawChunk: n	^stream next: n! !!ZipStringMember class methodsFor: 'as yet unclassified' stamp: 'nk 2/22/2001 17:30'!newFrom: aString named: aFileName	^(self new) contents: aString; fileName: aFileName; yourself! !!ZipStringMember class reorganize!('as yet unclassified' newFrom:named:)!!ZipFileMember class reorganize!('as yet unclassified' newFrom:named:)!!ZipArchiveMember class reorganize!('instance creation' new newFromDirectory: newFromFile: newFromString:named: newFromZipFile:named:)!ZipArchive initialize!