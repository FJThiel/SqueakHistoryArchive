'From Squeak2.8alpha of 16 February 2000 [latest update: #2158] on 17 May 2000 at 4:13:15 pm'!"Change Set:		Install_LargeIntegers_moduleDate:			9 April 2000Author:			Stephan Rudlof (sr@evolgo.de)Special thanks to:	Andrew C. GreenbergThis change set binds the Integer classes with the LargeIntegers module (compiled plugin).Preconditions:- VM 2.8 or later;- LargeIntegers module corresponding to your platform (it is called 'LargeIntegers.so' under Linux, for other platforms the name can differ).ToDo:- *First*: put the LargeIntegers module to the same directory where your 'squeak', '*.image' and '*.changes' are located;- Second: file in this change set.That's it!!If something goes wrong you will be notified.Functionality:It changes the following methods:Arithmetic Integer methods#digitAdd:, #digitSubtract:,#digitMultiply:neg:, #digitDiv:neg:,#bitShift:,and Large(Positive/Negative)Integer methods #normalize.Bit logic Integer methods #bitAnd:, #bitOr: and #bitXor:; they are speeded up, but for positive Integers only!!All methods are calling corresponding methods in the module now.All methods are changed as follows:The module will be called automatically, if it is existent.If it is not there or fails, the standard ST methods are applied.Note: If the module isn't reachable for any reason at startup, the standard ST methods are called automatically. So there is *no* crash risk for installing this change set.Note to 2.8:Integer changes are permanent: Installing/Deinstalling of the LargeIntegers module will be realized by just putting it in/out the search path for modules."!(self confirm: 'WARNING.  If you proceed to update beyond this point,your system will slow down by about 80% unless you have a VMthat is more recent than 2.7 (specifically it must include support forfast failure from missing primitives).Do you really wish to press on?If not, choose ''no'' and close the ensuing error window.')	ifFalse: [self halt]!!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitAnd: n 	"Answer an Integer whose bits are the logical AND of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitAnd' module:'LargeIntegers'>	norm _ n normalize.	^ self		digitLogic: norm		op: #bitAnd:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitOr: n 	"Answer an Integer whose bits are the logical OR of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitOr' module:'LargeIntegers'>	norm _ n normalize.	^ self		digitLogic: norm		op: #bitOr:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 1/23/2000 05:43'!bitShift: shiftCount 	"Answer an Integer whose value (in twos-complement representation) is  	the receiver's value (in twos-complement representation) shifted left by 	 the number of bits indicated by the argument. Negative arguments  	shift right. Zeros are shifted in from the right in left shifts."	| rShift |	<primitive: 'primDigitBitShift' module:'LargeIntegers'>	shiftCount >= 0 ifTrue: [^ self digitLshift: shiftCount].	rShift _ 0 - shiftCount.	^ (self		digitRshift: (rShift bitAnd: 7)		bytes: (rShift bitShift: -3)		lookfirst: self digitLength) normalize! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitXor: n 	"Answer an Integer whose bits are the logical XOR of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitXor' module:'LargeIntegers'>	norm _ n normalize.	^ self		digitLogic: norm		op: #bitXor:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:41'!digitAdd: arg 	| len arglen accum sum |	<primitive: 'primDigitAdd' module:'LargeIntegers'>	accum _ 0.	(len _ self digitLength) < (arglen _ arg digitLength) ifTrue: [len _ arglen].	"Open code max: for speed"	sum _ Integer new: len neg: self negative.	1 to: len do: 		[:i | 		accum _ (accum bitShift: -8)					+ (self digitAt: i) + (arg digitAt: i).		sum digitAt: i put: (accum bitAnd: 255)].	accum > 255		ifTrue: 			[sum _ sum growby: 1.			sum at: sum digitLength put: (accum bitShift: -8)].	^ sum! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:43'!digitCompare: arg 	"Compare the magnitude of self with that of arg.   	Return a code of 1, 0, -1 for self >, = , < arg"	| len arglen argDigit selfDigit |	<primitive: 'primDigitCompare' module:'LargeIntegers'>	len _ self digitLength.	(arglen _ arg digitLength) ~= len		ifTrue: [arglen > len				ifTrue: [^ -1]				ifFalse: [^ 1]].	[len > 0]		whileTrue: 			[(argDigit _ arg digitAt: len) ~= (selfDigit _ self digitAt: len)				ifTrue: [argDigit < selfDigit						ifTrue: [^ 1]						ifFalse: [^ -1]].			len _ len - 1].	^ 0! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:45'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	<primitive: 'primDigitDivNegative' module:'LargeIntegers'>	arg = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	"TFEI added this line"	l _ self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^ Array with: 0 with: self].	d _ 8 - arg lastDigit highBit.	div _ arg digitLshift: d.	div _ div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem _ self digitLshift: d.	rem digitLength = self digitLength ifTrue: [rem _ rem growto: self digitLength + 1].	"makes a copy and shifts"	quo _ Integer new: l neg: ng.	dl _ div digitLength - 1.	"Last actual byte of data"	ql _ l.	dh _ div digitAt: dl.	dnh _ dl = 1				ifTrue: [0]				ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ rem digitLength + 1 - k.		"r1 _ rem digitAt: j."		(rem digitAt: j)			= dh			ifTrue: [qhi _ qlo _ 15				"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.      				Note that r1,r2 are bytes, not nibbles.      				Be careful not to generate intermediate results exceeding 13  				  bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((rem digitAt: j)							bitShift: 4)							+ ((rem digitAt: j - 1)									bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4)							+ ((rem digitAt: j - 1)									bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15)								bitShift: 4).				hi _ (hi bitShift: -4)							+ (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.      				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 _ j < 3							ifTrue: [0]							ifFalse: [rem digitAt: j - 2].				[(t < hi					or: [t = hi and: [r3 < lo]])					and: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0							ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						hi >= dh]]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: div digitLength do: 			[:i | 			hi _ (div digitAt: i)						* qhi.			lo _ a + (rem digitAt: l) - ((hi bitAnd: 15)							bitShift: 4) - ((div digitAt: i)							* qlo).			rem digitAt: l put: lo - (lo // 256 * 256).			"sign-tolerant form of (lo bitAnd: 255)"			a _ lo // 256 - (hi bitShift: -4).			l _ l + 1].		a < 0			ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: div digitLength do: 					[:i | 					a _ (a bitShift: -8)								+ (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l _ l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4)				+ qlo].	rem _ rem				digitRshift: d				bytes: 0				lookfirst: dl.	^ Array with: quo with: rem! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:46'!digitMultiply: arg neg: ng 	| prod prodLen carry digit k ab |	<primitive: 'primDigitMultiplyNegative' module:'LargeIntegers'>	(arg digitLength = 1 and: [(arg digitAt: 1)			= 0])		ifTrue: [^ 0].	(self digitLength = 1 and: [(self digitAt: 1)			= 0])		ifTrue: [^ 0].	prodLen _ self digitLength + arg digitLength.	prod _ Integer new: prodLen neg: ng.	"prod starts out all zero"	1 to: self digitLength do: [:i | (digit _ self digitAt: i) ~= 0			ifTrue: 				[k _ i.				carry _ 0.				"Loop invariant: 0<=carry<=0377, k=i+j-1"				1 to: arg digitLength do: 					[:j | 					ab _ (arg digitAt: j)								* digit + carry + (prod digitAt: k).					carry _ ab bitShift: -8.					prod digitAt: k put: (ab bitAnd: 255).					k _ k + 1].				prod digitAt: k put: carry]].	^ prod normalize! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:46'!digitSubtract: arg 	| smaller larger z sum sl al ng |	<primitive: 'primDigitSubtract' module:'LargeIntegers'>	sl _ self digitLength.	al _ arg digitLength.	(sl = al		ifTrue: 			[[(self digitAt: sl)				= (arg digitAt: sl) and: [sl > 1]]				whileTrue: [sl _ sl - 1].			al _ sl.			(self digitAt: sl)				< (arg digitAt: sl)]		ifFalse: [sl < al])		ifTrue: 			[larger _ arg.			smaller _ self.			ng _ self negative == false.			sl _ al]		ifFalse: 			[larger _ self.			smaller _ arg.			ng _ self negative].	sum _ Integer new: sl neg: ng.	z _ 0.	"Loop invariant is -1<=z<=1"	1 to: sl do: 		[:i | 		z _ z + (larger digitAt: i) - (smaller digitAt: i).		sum digitAt: i put: z - (z // 256 * 256).		"sign-tolerant form of (z bitAnd: 255)"		z _ z // 256].	^ sum normalize! !!LargeIntegersPlugin class methodsFor: 'translation' stamp: 'ar 5/17/2000 16:08'!moduleName	^'LargeIntegers'! !!LargeIntegersTest class methodsFor: 'private' stamp: 'ar 5/17/2000 16:06'!checkIfCModuleExists	"If primitive fails, module isn't reachable."	<primitive: 'primCheckIfCModuleExists' module:'LargeIntegers'>	^ false! !!LargeIntegersTest class methodsFor: 'private' stamp: 'ar 5/17/2000 16:06'!doItOn: stream withModule: withModuleFlag 	"Make LargeIntegers computations with logging onto stream."	| tester |	withModuleFlag		ifTrue: [self checkIfCModuleExists				ifFalse: 					[self inform: self name , ': Test *with* module impossible!!' , Character cr asString , self moduleName , ' plugin module isn''t installed properly.'.					^ false]]		ifFalse: [self checkIfCModuleExists				ifTrue: 					[self inform: self name , ': Test *without* module impossible!!' , Character cr asString , self moduleName , ' plugin module has to be renamed or removed from reachable modules path.'.					^ false]].	tester _ self new.	tester stream: (stream notNil			ifTrue: [stream]			ifFalse: [Transcript]).	tester stream cr; nextPutAll: self class name , ': creating test data...'.	tester createTestData.	tester test.	^ true! !!LargeIntegersTest class methodsFor: 'private' stamp: 'ar 5/17/2000 16:06'!moduleName	^ 'LargeIntegers'! !!LargePositiveInteger methodsFor: 'converting' stamp: 'ar 5/17/2000 16:09'!normalize	"Check for leading zeroes and return shortened copy if so"	| sLen val len oldLen |	<primitive: 'primNormalizePositive' module:'LargeIntegers'>	"First establish len = significant length"	len _ oldLen _ self digitLength.	[len = 0 ifTrue: [^0].	(self digitAt: len) = 0]		whileTrue: [len _ len - 1].	"Now check if in SmallInteger range"	sLen _ SmallInteger maxVal digitLength.	(len <= sLen		and: [(self digitAt: sLen) <= (SmallInteger maxVal digitAt: sLen)])		ifTrue: ["If so, return its SmallInt value"				val _ 0.				len to: 1 by: -1 do:					[:i | val _ (val *256) + (self digitAt: i)].				^ val].	"Return self, or a shortened copy"	len < oldLen		ifTrue: [^ self growto: len]		ifFalse: [^ self]! !!LargeNegativeInteger methodsFor: 'converting' stamp: 'ar 5/17/2000 16:10'!normalize	"Check for leading zeroes and return shortened copy if so"	| sLen val len oldLen minVal |	<primitive: 'primNormalizeNegative' module:'LargeIntegers'>	"First establish len = significant length"	len _ oldLen _ self digitLength.	[len = 0 ifTrue: [^0].	(self digitAt: len) = 0]		whileTrue: [len _ len - 1].	"Now check if in SmallInteger range"	sLen _ 4  "SmallInteger minVal digitLength".	len <= sLen ifTrue:		[minVal _ SmallInteger minVal.		(len < sLen			or: [(self digitAt: sLen) < minVal lastDigit])			ifTrue: ["If high digit less, then can be small"					val _ 0.					len to: 1 by: -1 do:						[:i | val _ (val *256) - (self digitAt: i)].					^ val].		1 to: sLen do:  "If all digits same, then = minVal"			[:i | (self digitAt: i) = (minVal digitAt: i)					ifFalse: ["Not so; return self shortened"							len < oldLen								ifTrue: [^ self growto: len]								ifFalse: [^ self]]].		^ minVal].	"Return self, or a shortened copy"	len < oldLen		ifTrue: [^ self growto: len]		ifFalse: [^ self]! !!LargeIntegersPlugin class reorganize!('translation' declareCVarsIn: moduleName)('instance creation' new)!!Integer reorganize!('testing' even isInteger isPowerOfTwo)('arithmetic' * + - / // alignedTo: quo:)('comparing' < = > hash)('truncation and round off' atRandom atRandom: ceiling floor normalize rounded truncated)('enumerating' timesRepeat:)('mathematical functions' degreeCos degreeSin factorial gcd: lcm: take:)('bit manipulation' << >> allMask: anyMask: bitAnd: bitClear: bitInvert bitInvert32 bitOr: bitShift: bitXor: lowBit noMask:)('converting' adaptToFraction:andSend: asCharacter asColorOfDepth: asFloat asFraction asHexDigit asInteger)('printing' asStringWithCommas asTwoCharacterString byteEncode:base: destinationBuffer: digitBuffer: hex hex8 isLiteral printOn:base: radix:)('system primitives' lastDigit replaceFrom:to:with:startingAt:)('private' copyto: digitAdd: digitCompare: digitDiv:neg: digitLogic:op:length: digitLshift: digitMultiply:neg: digitRshift:bytes:lookfirst: digitSubtract: growby: growto:)('benchmarks' benchFib benchmark tinyBenchmarks)!