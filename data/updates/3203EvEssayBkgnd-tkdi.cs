'From Squeak2.9alpha of 12 June 2000 [latest update: #3266] on 15 January 2001 at 4:47:04 pm'!!Player commentStamp: '<historical>' prior: 0!The fundamental user-scriptable entity.  Always represented by auser-specific subclass of Player; instance vars and methods relate touser-defined structures.costume  is a Morph, the primary morph I am currently wearing for graphicaldisplay.Scripts are defined in subclasses of Player.  These are UniClasses.Messages in scripts are sent to Players.  A Player may delegate to itscostume, or to an object the costume suggests.  Or, a Player may designatesome other object to receive the script messages it does not understand.(see doesNotUnderstand:) !!Object methodsFor: 'copying' stamp: 'tk 1/8/2001 10:36'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object inthe tree twice is copied once, and both references point to him.deepCopier holds a dictionary of objects we have seen.  Some classes refuseto be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new uc sup has mine |	deepCopier references at: self ifPresent: [:newer | ^ newer].	"already did him"	class _ self class.	class isMeta ifTrue: [^ self].		"a class"	new _ self clone.	class isSystemDefined ifFalse: [		uc _ deepCopier uniClasses at: class ifAbsent: [nil].		uc ifNil: [deepCopier uniClasses at: class put: (uc _ selfcopyUniClassWith: deepCopier)].		new _ uc new].	deepCopier references at: self put: new.	"remember"	(class isVariable and: [class isPointers]) ifTrue:		[index _ self basicSize.		[index > 0] whileTrue:			[sub _ self basicAt: index.			(subAss _ deepCopier references associationAt: subifAbsent: [nil])				ifNil: [new basicAt: index put: (subveryDeepCopyWith: deepCopier)]				ifNotNil: [new basicAt: index put: subAssvalue].			index _ index - 1]].	"Ask each superclass if it wants to share (weak copy) any inst vars"	new veryDeepInner: deepCopier.		"does super a lot"	"other superclasses want all inst vars deep copied"	sup _ class.  index _ class instSize.	[has _ sup compiledMethodAt: #veryDeepInner: ifAbsent: [nil].	mine _ sup instVarNames.	has ifNotNil: [index _ index - mine size]		ifNil: [1 to: mine size do: [:xx |				sub _ self instVarAt: index.				(subAss _ deepCopier referencesassociationAt: sub ifAbsent: [nil])						"use association, notvalue, so nil is an exceptional value"					ifNil: [new instVarAt: index put:								(subveryDeepCopyWith: deepCopier)]					ifNotNil: [new instVarAt: indexput: subAss value].				index _ index - 1]].	(sup _ sup superclass) == nil] whileFalse.	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!CascadeNode methodsFor: 'tiles' stamp: 'tk 1/15/2001 10:49'!asMorphicSyntaxIn: parent	| cascadeMorph row node2 |	row _ parent addRow: #cascade on: self.	receiver asMorphicSyntaxIn: row.	(node2 _ self copy) receiver: nil messages: messages.	cascadeMorph _ row addColumn: #cascade2 on: node2.	messages do: [ :m | m asMorphicSyntaxIn: cascadeMorph].	^row! !!MessageNode methodsFor: 'tiles' stamp: 'tk 1/15/2001 15:43'!morphFromKeywords: key arguments: args on: parent indent: ignored	| keywords column row receiverMorph firstArgMorph receiverWidthmessageWidth onlyOne selfWithNilReceiver |	receiver ifNotNil: ["i.e. not a cascade"			receiverMorph _ receiver asMorphicSyntaxIn: parent].	keywords _ key keywords.	args size = 0 ifTrue:			[row _ (parent addTextRow: key) layoutInset: 1.			^ row parseNode: selector].	receiverWidth _ receiver				ifNil: [0]				ifNotNil: [receiverMorph fullBounds width].	onlyOne _ args size = 1.	(receiverWidth <= 80 and: [onlyOne])		ifTrue: [row _ (parent addTextRow: keywords first)layoutInset: 1.			row parseNode: selector.			firstArgMorph _ args first asMorphicSyntaxIn: parent.			receiver ifNil: [^ self].			(firstArgMorph fullBounds height > 100					or: [firstArgMorph fullBounds width> 250])				ifTrue: [parent foldMessageOneArg].			^ self].	selfWithNilReceiver _ self copy receiver: nil.	column _ parent addColumn: #keyword1 on: selfWithNilReceiver.	messageWidth _ 0.	keywords		with: (args copyFrom: 1 to: keywords size)		do: [:kwd :arg |			(row _ column addRow: #keyword2 on:selfWithNilReceiver) borderWidth: 1;				parseNode: (selfWithNilReceiver as:						(onlyOne ifTrue:[MessageNode] ifFalse: [MessagePartNode]));				 borderColor: row stdBorderColor.			row addToken: kwd				type: #keyword2				on: (onlyOne ifTrue: [SelectorNode new key:kwd code: nil "fill this in?"]								ifFalse:[KeyWordNode new]).			arg asMorphicSyntaxIn: row.			messageWidth _ messageWidth + row fullBounds width].	receiverMorph ifNotNil:		[receiverWidth + messageWidth < 350 ifTrue: [^ parentunfoldMessage].			((receiverWidth > 200						or: [receiverWidth > 80								and:[column fullBounds height > 20]])					or: [receiverMorph fullBounds width> 30							and: [columnfullBounds height > 100									or:[column fullBounds width > 250]]])				ifTrue: [^ parent foldMessage]]! !!Morph methodsFor: 'structure' stamp: 'tk 1/13/2001 21:09'!bestGuessOfCurrentWorld	"Return world I am in, or current world if none."	^ self world ifNil: [Display bestGuessOfCurrentWorld]	! !!Player methodsFor: 'clone' stamp: 'tk 1/8/2001 10:38'!copyUniClassWith: deepCopier	"my class is a subclass of Player.  Return another class just likemy class.  Share the costume list."	| newCls |	newCls _ self class officialClass		newUniqueClassInstVars: self class instanceVariablesString		classInstVars: self class class instanceVariablesString.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	newCls scripts: self class privateScripts.	"duplicate this inmapUniClasses"	newCls slotInfo: (self class privateSlotInfo veryDeepCopyWith:deepCopier).	newCls copyAddedStateFrom: self class.  "All class inst vars forinter Player refs"	^ newCls! !!Player methodsFor: 'scripts-standard' stamp: 'tk 1/14/2001 06:27'!contents	^ costume contents! !!Player methodsFor: 'scripts-standard' stamp: 'tk 1/14/2001 06:27'!contents: stuff	^ costume contents: stuff! !!Player methodsFor: 'misc' stamp: 'tk 1/13/2001 21:37'!tileReferringToSelf	| aTile ww nn tile |	"universal tiles"	ww _ costume bestGuessOfCurrentWorld.	(ww valueOfProperty: #universalTiles ifAbsent: [false]) ifTrue: [		nn _ self externalName. 	"name it, if necessary, andput in References"		(References includesKey: nn asSymbol) ifFalse: [			 References at: nn asSymbol put: self].		tile _ SyntaxMorph new parseNode:			(VariableNode new name: nn key: nn code: nil).		tile layoutInset: 1; addMorph: (tile addString: nn).		tile color: (SyntaxMorph translateColor: #variable).		tile extent: tile firstSubmorph extent + (2@2).		^ tile].	aTile _ TileMorph new		setObjectRef: nil "disused parm" actualObject: self;		typeColor: (ScriptingSystem colorForType: #player).	aTile enforceTileColorPolicy.	^ aTile! !!Presenter methodsFor: 'misc' stamp: 'tk 1/8/2001 10:58'!currentlyViewing: aPlayer	"Only detects viewers in tabs"	aPlayer ifNil: [^ false].	^ aPlayer viewerFlapTab ~~ nil! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'tk 1/13/2001 21:10'!useNewTiles	| ww |	"At the next request for textual script, use new tiles instead.Make that request."	ww _ self bestGuessOfCurrentWorld.	(ww valueOfProperty: #universalTiles ifAbsent: [false]) ifFalse: [		ww setProperty: #universalTiles toValue: true.	 		"for all scriptors and viewers in this world"		"force viewers to be recreated"		ww flapTabs do: [:ff | (ff isMemberOf: ViewerFlapTab) ifTrue: [							ff referent delete.ff delete]].		Utilities clobberFlapTabList].	Preferences enable: #capitalizedReferences.	self showSourceInScriptor.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 1/12/2001 19:48'!renameScript	"Invoked at user menu request"	| reply aPosition oldSelector dflt oldStatus oldOwner newSelectoraUserScript methodNode |	oldSelector _ self scriptName.	aUserScript _ playerScripted class userScriptForPlayer: selfselector: oldSelector.	oldStatus _ self scriptInstantiation status.	dflt _ self isAnonymous ifTrue: [''] ifFalse: [self scriptTitle].	reply _   FillInTheBlank request: 'Script Name' initialAnswer: dflt. 	reply size == 0 ifTrue: [^ self].	newSelector _ ScriptingSystem acceptableScriptNameFrom: reply		forScriptCurrentlyNamed: oldSelector		asScriptNameIn: self playerScripted		world: self world.	self titleMorph borderColor: Color black.	scriptName _ newSelector.	"aUserScript isTextuallyCoded ifFalse: ["		playerScripted class atSelector: newSelectorputScriptEditor: self  "]"  .	self scriptInstantiation status: oldStatus.	playerScripted class removeScriptNamed: oldSelector.	playerScripted actorState instantiatedUserScriptsDictionaryremoveKey: oldSelector.	submorphs first delete.  "the button row"	self addMorphFront: self buttonRowForEditor.  "up to date"	aUserScript isTextuallyCoded ifTrue: [		(submorphs atPin: 2) class = TwoWayScrollPane ifTrue: ["newtiles"			methodNode _ submorphs second scroller "transform"submorphs first.			methodNode rename: newSelector; accept.			"self refresh"]].	self install.	aPosition _ self position.	oldOwner _ self topRendererOrSelf owner.	self delete.	playerScripted costume viewAfreshIn: oldOwner		showingScript: scriptName at: aPosition.! !!StackMorph methodsFor: 'card access' stamp: 'tk 1/8/2001 12:56'!deleteCard	"Delete the current card from the stack"	| aCard |	aCard _ self currentCard.	cards size = 1 ifTrue: [^ self beep].	(self confirm: 'Really delete this card and all of its data?')ifTrue: [		self goToNextCardInStack.		cards remove: aCard].! !!SyntaxMorph methodsFor: 'initialization' stamp: 'tk 1/15/2001 15:32'!aJunkMethod: aMorph event: evt	"For the moment, you edited 1 have to drop it the right place. Wedo not look at 	enclosing morphs"	| itNoun |	itNoun  _  (aMorph isNoun ) .	self withAllOwnersDo: [:m |		 (m isSyntaxMorph  and: [m isBlockNode])   ifTrue: [mstopStepping  hideCaret   .			]    .		] .	1 abs; + itNoun.	(6 + 5; - 6) abs; - 5.	! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 1/13/2001 20:08'!rename: newSelector	| keywords mainSel list last |	"Attempt to change the name as listed in my tiles.  Can change thenumber of argumtents.  MethodNode (SelectorNode (SelectorNode (string))) orMethodNode (SelectorNode (SelectorNode (string) TempVarNode() SelectorNode(string) TempVarNode()))"	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ self].  "not in a script"		^ self rootTile rename: newSelector  "always do at the root"].	keywords _ newSelector keywords.	mainSel _ self findA: SelectorNode.	list _ mainSel submorphs select: [:mm |		mm isSyntaxMorph and: [mm parseNode class == SelectorNode]].	1 to: (list size min: keywords size) do: [:ind |		((list at: ind) findA: UpdatingStringMorph) contents:(keywords at: ind)].	keywords size + 1 to: list size do: [:ind | "removing keywords"		[last _ mainSel submorphs last.		 (last isSyntaxMorph and: [last parseNode class ==TempVariableNode])] whileFalse: [				last delete].		[last _ mainSel submorphs last.		 (last isSyntaxMorph and: [last parseNode class ==SelectorNode])] whileFalse: [				last delete].	"the TempVariableNode andothers"		mainSel submorphs last delete.	"the SelectorNode"		].	list size + 1 to: keywords size do: [:ind | "adding keywords"		"add a SelectorNode, add a spacer, add a TempVarNode"		mainSel addToken: (keywords at: ind) type: #keyword1			on: (SelectorNode new key: (keywords at: ind) code:nil).		mainSel addMorphBack: (mainSel transparentSpacerOfSize: 4@4).		(TempVariableNode new name: 'arg', ind printString index:ind type: nil scope: nil)			 asMorphicSyntaxIn: mainSel].! !!SyntaxMorph methodsFor: 'node types' stamp: 'tk 1/13/2001 20:41'!findA: aClass	| ans |	"Allow finding on the class of the parseNode"	(ans _ super findA: aClass) ifNotNil: [^ ans].	submorphs do: [:ss |		ss isSyntaxMorph ifTrue: [			ss parseNode class == aClass ifTrue: [^ ss]]].	^ nil! !!SyntaxMorph methodsFor: 'node types' stamp: 'di 1/15/2001 15:11'!isCascadePart	^ parseNode isMessage: nil receiver: [:r | r == nil] arguments: nil! !!SyntaxMorph methodsFor: 'node types' stamp: 'tk 1/15/2001 11:04'!isNoun	"Consider these to be nouns:  TempVariableNode, LiteralNode,VariableNode, (MessageNode or CascadeNode with receiver), AssignmentNode"	(#(TempVariableNode LiteralNode VariableNode AssignmentNode) includes:		(parseNode class name)) ifTrue: [^ true].	(self nodeClassIs: MessageNode) ifTrue: [^ parseNode receiver notNil].	(self nodeClassIs: CascadeNode) ifTrue: [^ parseNode receiver notNil].	^ false! !!SyntaxMorph methodsFor: 'selection' stamp: 'tk 1/15/2001 16:12'!isSelectable	| ss |	"Spacer morphs enclose other morphs with the same parseNode"	self submorphs size > 1 ifTrue: [		ss _ self submorphs second.		ss isSyntaxMorph ifTrue: [			ss parseNode == parseNode ifTrue: [^ false]]]."	(self nodeClassIs: SelectorNode) ifTrue: [^ false].	(self nodeClassIs: KeyWordNode) ifTrue: [^ false]."	self isMethodNode ifTrue: [^ false].	parseNode ifNil: [^ false].	^ true! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 1/15/2001 11:15'!foldMessage	"I am a message whose receiver is wide, and whose message part is acolumn.	Rearrange me so that the message part appears indented under thereceiver part."	| messageRow node2 |	node2 _ parseNode copy receiver: nil.	messageRow _ SyntaxMorph row: #keyword1 on: node2.	messageRow addMorph: (self transparentSpacerOfSize: 20@10);			addMorphBack: submorphs second.	self listDirection: #topToBottom;		wrapCentering: #topLeft;		addMorphBack: messageRow.! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 1/15/2001 11:15'!foldMessageOneArg	"I am a message that is wide, a row with receiver and a row withselector and arg.	Rearrange me so that the message part appears indented under thereceiver part."	| messageRow node2 |	node2 _ parseNode copy receiver: nil.	messageRow _ SyntaxMorph row: #keyword1 on: node2.	messageRow addMorph: (self transparentSpacerOfSize: 20@10);			addMorphBack: submorphs second;			addMorphBack: submorphs second.  "was the third"	self listDirection: #topToBottom;		wrapCentering: #topLeft;		addMorphBack: messageRow.! !!SyntaxMorph methodsFor: 'printing' stamp: 'di 1/15/2001 16:44'!printOn: strm indent: level	| lev nodeClass first |	"Tree walk and produce text of the code.  #ST80.  Just do it in onebig ugly method."	lev _ level.	(nodeClass _ parseNode class) == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner isMethodNode ifFalse: [strm nextPut: $[.  lev_ lev+1]]].				"normal block has []"	nodeClass == MessageNode ifTrue: [		parseNode receiver ifNotNil: [strm nextPut: $( ]].	"has a receiver"	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; space].	first _ true.	submorphs do: [:sub |		sub isSyntaxMorph ifTrue: [			(nodeClass == CascadeNode and: [sub isCascadePart]) ifTrue:				[first ifTrue: [first _ false]					ifFalse: [strm nextPutAll: '; ']].			nodeClass == BlockArgsNode ifTrue: [strm nextPut: $:].			sub printOn: strm indent: lev.			(nodeClass == BlockNode) & (sub parseNode class ==BlockArgsNode) not	&				(sub parseNode class == ReturnNode) not					ifTrue: [strm nextPut: $.].			(nodeClass == BlockNode) & (sub parseNode class ==BlockArgsNode) not				ifTrue: [strm crtab: lev]				ifFalse: [self isMethodNode ifTrue: [strmcrtab: lev] ifFalse: [strm space]].			first _ false].		(sub isKindOf: StringMorph) ifTrue: [strm nextPutAll: subcontents].		"return indent for ifTrue: ifFalse:"].	nodeClass == MessageNode ifTrue: [		parseNode receiver ifNotNil: [strm nextPut: $) ]].	"has a receiver"	nodeClass  == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner isMethodNode ifFalse: [strm nextPut: $] ]]].				"normal block has []"	nodeClass == BlockArgsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodNode ifTrue: [		strm contents last "ugh!!" == $. ifTrue: [strm skip: -1]].	"erase last period"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 1/15/2001 11:02'!offerPopUp	"Put up a halo to allow user to change		Literals (Integer, true),		Selector (beep: sound, +,-,*,//,\\, r:g:b:, setX: incX:decX: for any X,),		Variable (Color),		not AssignmentNode (_ inc dec),	Extend arrows on each literal, variable, and message, (block thatis by itself).	Retract arrows on each literal or variable, or message or blockthat is an argument.	Any literal can be changed by Shift-clicking and typing."	| panel any upDown retract extend colorPatch edge outside |	(self hasProperty: #myPopup) ifTrue: [^ self].  "already has one"	((outside _ self rootTile owner) isKindOf: AlignmentMorph) ifTrue:[^ self].	  "can't put panel in right place"	any _ false.	(upDown _ self upDownArrows) ifNotNil: [any _ true].	(retract _ self retractArrow) ifNotNil: [any _ true].	(extend _ self extendArrow) ifNotNil: [any _ true].	(colorPatch _ self colorPatch) ifNotNil: [any _ true].	any ifFalse: [^ self].	"Transcript cr; print: parseNode class; space;		print: (self hasProperty: #myPopup); endEntry."	panel _ RectangleMorph new color: Color transparent; borderWidth: 0.	upDown ifNotNil: [		panel addMorphBack: upDown first.		upDown first align: upDown first topLeft with: panel topLeft.		panel addMorphBack: upDown second.		upDown second align: upDown second topLeft with: upDownfirst bottomLeft].	colorPatch ifNotNil: [		panel addMorphBack: colorPatch.		colorPatch align: colorPatch topLeft					with: panel topLeft].	retract ifNotNil: [		edge _ panel submorphs size = 0			ifTrue: [panel left]			ifFalse: [panel submorphs last right].		panel addMorphBack: retract.		retract align: retract topLeft with: (edge+2) @ (panel top+ 3)].	extend ifNotNil: [		edge _ panel submorphs size = 0			ifTrue: [panel left]			ifFalse: [panel submorphs last right].		panel addMorphBack: extend.		extend align: extend topLeft with: (edge+2) @ (panel top + 3)].	panel align: panel topLeft with: self topRight.	panel extent: panel submorphs last bottomRight - panel topLeft.	self setProperty: #myPopup toValue: panel.	outside addMorphFront: panel.! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 1/14/200107:02'!translateColor: aColorOrSymbol	aColorOrSymbol == #comment  ifTrue: [^ Color blue lighter].	aColorOrSymbol == #block  ifTrue: [^ Color transparent].	aColorOrSymbol == #text  ifTrue: [^ Color transparent].	aColorOrSymbol isColor  ifTrue: [^ aColorOrSymbol].	self noTileColor ifTrue: [^ Color paleOrange].	"override"	aColorOrSymbol == #assignment  ifTrue: [^ Color paleGreen].	aColorOrSymbol == #keyword1  ifTrue: [^ Color paleBuff].	"binary"	aColorOrSymbol == #keyword2  ifTrue: [^ Color paleBuff lighter].	"multipart"	aColorOrSymbol == #cascade  ifTrue: [^ Color paleYellow darker].	"has receiver"	aColorOrSymbol == #cascade2  ifTrue: [^ Color paleOrange].	"one send in the cascade"	aColorOrSymbol == #literal  ifTrue: [^ Color paleMagenta].	aColorOrSymbol == #message  ifTrue: [^ Color paleYellow].	aColorOrSymbol == #method  ifTrue: [^ Color white].	aColorOrSymbol == #error  ifTrue: [^ Color red].	aColorOrSymbol == #return  ifTrue: [^ Color lightGray].	aColorOrSymbol == #variable  ifTrue: [^ Color paleTan].	aColorOrSymbol == #brace  ifTrue: [^ Color paleOrange].	aColorOrSymbol == #tempVariable  ifTrue: [^ Color paleYellow mixed:0.75 with: Color paleGreen		"Color yellow lighter lighter"].	aColorOrSymbol == #blockarg2  ifTrue: [			^ Color paleYellow mixed: 0.75 with: ColorpaleGreen].	"arg itself"	aColorOrSymbol == #blockarg1  ifTrue: [^ Color paleRed].	"container"		"yellow mixed: 0.5 with: Color white"	^aColorOrSymbol! !!TextFieldMorph methodsFor: 'card & stack' stamp: 'tk 1/6/2001 14:20'!couldHoldSeparateDataForEachInstance	"Answer whether this type of morph is inherently capable of holdingseparate data for each instance ('card data')"	^ true! !!TextFieldMorph methodsFor: 'card & stack' stamp: 'tk 1/6/2001 14:15'!setNewContentsFrom: textOrString	"talk to my text"	| tm |	(tm _ self findA: TextMorph) ifNil: [^ nil].	tm valueOfProperty: #cardInstance ifAbsent: ["move it down"		tm setProperty: #cardInstance toValue: (selfvalueOfProperty: #cardInstance)].	tm valueOfProperty: #holdsSeparateDataForEachInstance ifAbsent: ["move itdown"		tm setProperty: #holdsSeparateDataForEachInstance toValue:			(self valueOfProperty:#holdsSeparateDataForEachInstance)].	^ tm setNewContentsFrom: textOrString! !!TextFieldMorph methodsFor: 'card & stack' stamp: 'tk 1/6/2001 13:58'!variableDocks	"Answer a list of VariableDock objects for docking up my data withan instance held in my containing playfield"	^ Array with: (VariableDock new variableName: selfdefaultVariableName type: #text definingMorph: self morphGetSelector:#contents morphPutSelector: #setNewContentsFrom:)! !!TextMorph methodsFor: 'accessing' stamp: 'tk 1/10/2001 14:09'!newContents: stringOrText	"Accept new text contents."	| newText embeddedMorphs |	newText _ stringOrText copy asText.	"should be veryDeepCopy?"	text = newText ifTrue: [^ self].	"No substantive change"	text ifNotNil: [(embeddedMorphs _ text embeddedMorphs)			ifNotNil:				[self removeAllMorphsIn: embeddedMorphs.				embeddedMorphs do: [:m | m delete]]].	text _ newText.	"add all morphs off the visible region; they'll be moved into theright	place when they become visible. (this can make the scrollable area too	large, though)"	newText embeddedMorphs do:		[:m |		self addMorph: m.		m position: -1000 @ 0].	self releaseParagraph.	"update the paragraph cache"	self paragraph.	"re-instantiate to set bounds"	self world ifNotNil: [self world startSteppingSubmorphsOf: self]! !!TextMorph methodsFor: 'accessing' stamp: 'tk 1/10/2001 13:52'!text	^ text! !!TextMorph methodsFor: 'card & stack' stamp: 'tk 1/8/2001 13:14'!setNewContentsFrom: stringOrTextOrNil	"Using stringOrTextOrNil as a guide, set the receiver's contentsafresh.  If the input parameter is nil, the a default value stored in aproperty of the receiver, if any, will supply the new initial content.This method is only called when a VariableDock is attempting to put a newvalue.  This is still messy and ill-understood and not ready for primetime."	| defaultValue tt atts |	stringOrTextOrNil ifNotNil: [^ self newContents: stringOrTextOrNil		fromCard: (self valueOfProperty: #cardInstance)].		   "Well, totally yuk -- emergency measure late on eve of demo"	defaultValue _ self valueOfProperty: #defaultValue					ifAbsent: [atts _ textattributesAt: 1.	"Preserve size, emphasis"						tt _ text copyReplaceFrom:1 to: text size								with:'blankText'.						atts do: [:anAtt | ttaddAttribute: anAtt].						tt].	self contents: defaultValue deepCopy wrappedTo: self width.! !!Utilities class methodsFor: 'flaps' stamp: 'tk 1/8/2001 10:41'!addStackToolsFlap	"Add a flap with stack tools in it"	| aFlap aFlapTab aTextMorph aSketch  aMorph |	"Utilities reinstateDefaultFlaps. Utilities addStackToolsFlap"	(ScriptingSystem formAtKey: #CedarPic) ifNil:		[^ self notYetImplemented].	aFlap _ self newPartsFlapPage beSticky.	aFlap setProperty: #maximumThumbnailWidth toValue: 80.	aFlap setProperty: #flap toValue: true.	aFlap color: (Color green muchLighter lighter alpha: 0.3).	aFlapTab _ FlapTab new referent: aFlap.	aFlapTab assumeString: 'Stack Tools' font: PreferencesstandardFlapFont orientation: #horizontal color: Color brown lighterlighter.	aFlapTab edgeToAdhereTo: #bottom; inboard: false.	aFlapTab setToPopOutOnDragOver: false.	aFlapTab setToPopOutOnMouseOver: false.	aFlap addMorphBack: StackMorph authoringPrototype.	aTextMorph _ TextMorph authoringPrototype.	aTextMorph contents: 'backgroundlabel' asText.	aTextMorph beAllFont: (StrikeFont familyName: #NewYork size: 18).	aTextMorph color: Color brown.	aTextMorph setProperty: #shared toValue: true.	aFlap addMorphBack: aTextMorph.	"Ted's fields, maybe good point of departure...	aTextMorph _ TextFieldMorph authoringPrototype.	aTextMorph setProperty: #shared toValue: true.	aFlap addMorphBack: aTextMorph."	aFlap addMorphBack: ScriptableButton authoringPrototypemarkAsPartsDonor beSticky.	"NB: Here is where we will put the prototype(s) forbackground/foreground fields; for the moment, vanilla TextMorphs are used,with the scrolling PTMWM temporarily commented out pending some more work.A successor to Ted's TextFieldMorph, or some new kind ofcarefully-thought-through morph that will generally serve the community asthe archetypal 'Field', is ultimately needed"	#(TextMorph "PluggableTextMorphWithModel" TextFieldMorph ) do:		[:sym |			aMorph _ (Smalltalk at: sym) authoringPrototype.			aMorph contents: 'background field' asText allBold.			aMorph setProperty: #shared toValue: true.			aMorph setNameTo: (sym == #TextMorph ifTrue:['field1'] ifFalse: ['scrollingField1']).			aMorph setProperty:#holdsSeparateDataForEachInstance toValue: true.			aFlap addMorphBack: aMorph].	"aFlap addMorphBack: ScriptableListMorph authoringPrototypebeSticky -- SOON!!"	#(CedarPic) do:		[:sym |			aSketch _ SketchMorph newSticky form:((ScriptingSystem formAtKey: sym) ifNil: [ScriptingSystem formAtKey:#squeakyMouse]).			aSketch setProperty: #shared toValue: true.			aSketch setProperty:#holdsSeparateDataForEachInstance toValue: true.			aFlap addMorphBack: aSketch].	"aCardReference _ CardReference authoringProtoype beSticky.	aCardReference card: Card new.  "	aFlap addMorphBack: StackMorph previousCardButton markAsPartsDonor.	aFlap addMorphBack: StackMorph nextCardButton markAsPartsDonor.	#( PaintInvokingMorph "ImageMorph  RectangleMorph EllipseMorphStarMorph  CurveMorph PolygonMorph SimpleSliderMorph") do:		[:sym | aFlap addMorphBack: (Smalltalk at: sym)authoringPrototype].	aFlap addMorphBack: TrashCanMorph new markAsPartsDonor.	aFlap addMorphBack: ScriptingSystem scriptControlButtonsmarkAsPartsDonor.	aFlap replaceTallSubmorphsByThumbnails.	aFlapTab position: ((2 * (self currentWorld width // 3)) @ (selfcurrentWorld height - aFlapTab height)).	aFlap setProperty: #flap toValue: true.	aFlap color: (Color red muchLighter "alpha: 0.2").	aFlap extent: self currentWorld width @ 100.	self currentWorld addMorphFront: aFlapTab.	"a local flap, but we could as easily make it global by:		self addGlobalFlap: aFlapTab.  self currentWorldaddGlobalFlaps"! !!TextMorph reorganize!('initialization' beAllFont: configureForKids copy initialize releaseCachedState string:fontName:size: string:fontName:size:wrap:)('accessing' asText contents contents: contents:wrappedTo: contentsAsIs: contentsWrapped: copyRecordingIn: currentDataValue editor fontName:size: getCharacters getFirstCharacter newContents: setCharacters: setFirstCharacter: setNumericValue: text textStyle userString)('alignment' centered justified leftFlush rightFlush)('drawing' drawBoundsOn: drawNullTextOn: drawOn:)('editing' acceptContents cancelEdits chooseAlignment chooseEmphasis chooseEmphasisOrAlignment chooseFont chooseStyle clearTypeIn cornerStyle: handleEdit: handleInteraction:fromEvent: handleKeystroke: handlesKeyboard: handlesMouseDown: hasFocus hasUnacceptedEdits: keyStroke: keyboardFocusChange: mouseDown: mouseMove: mouseUp: passKeyboardFocusTo: xeqLinkText:withParameter:)('printing' fullPrintOn:)('geometry' bounds container containsPoint: defaultLineHeight extent: goBehind layoutChanged privateMoveBy: textBounds)('menu' addCustomMenuItems:hand: followCurve reverseCurveDirection setCurveBaseline: shiftedYellowButtonActivity yellowButtonActivity)('linked frames' addPredecessor: addSuccessor: firstCharacterIndex firstInChain isLinkedTo: lastCharacterIndex predecessor recomposeChain startingIndex successor withSuccessorsDo:)('private' adjustLineIndicesBy: composeToBounds delete fit installEditor installEditorToReplace: loadCachedState paragraph paragraphClass predecessorChanged releaseEditor releaseParagraph selectionChanged setDefaultContentsIfNil setPredecessor: setSuccessor: text:textStyle: text:textStyle:wrap:color:predecessor:successor: updateFromParagraph updateReferencesUsing: wouldAcceptKeyboardFocusUponTab)('object fileIn')('containment' fillingOnOff occlusionsOnOff ownerChanged privateOwner: recognizerArena setContainer:)('anchors' acceptDroppingMorph:event: addMorphFront:fromWorldPosition: privateRemoveMorph:)('copying' veryDeepFixupWith: veryDeepInner:)('scripting access' getAllButFirstCharacter getNumericValue setAllButFirstCharacter:)('card & stack' couldHoldSeparateDataForEachInstance newContents:fromCard: setNewContentsFrom: variableDocks)!!TextFieldMorph reorganize!('just like textMorph' append: contents contents: currentDataValue fit fontName:size: initialize lineCount)('card & stack' couldHoldSeparateDataForEachInstance setNewContentsFrom: variableDocks)!Player removeSelector: #copyUniClass!