'From Squeak3.1alpha of 28 February 2001 [latest update: #4054] on 22 May 2001 at 6:32:06 pm'!"Change Set:		contentsSymbol-swDate:			22 May 2001Author:			Scott WallaceConsolidates the various ways that different representations of source code can be shown in a code pane.  The old #showDiffs inst var of codeHolder is disenfranchised.  The #sourceSymbol varies across the (presently) ten different settings, and a control is added to the button pane of code-bearing tools letting you swiftly move among the choices.  For those who do not use button panes, the control is often available in window-title menus.  MVC is mostly neglected in this work -- I presume interested parties will make appropriate changes."!TextStream subclass: #DialectStream	instanceVariableNames: 'dialect colorTable '	classVariableNames: 'ST80ColorTable Sq00ColorTable '	poolDictionaries: ''	category: 'System-Compiler'!!Object methodsFor: 'macpal' stamp: 'sw 5/22/2001 18:31'!refusesToAcceptCode	"Answer whether the receiver is a code-bearing instrument which at the moment refuses to allow its contents to be submitted"	^ false	! !!Object methodsFor: 'testing' stamp: 'sw 5/19/2001 02:15'!wantsDiffFeedback	"Answer whether the receiver, serving as the model of a text-bearing entity, would like for 'diffs' green pane-border feedback to be shown"	^ self showDiffs! !!Compiler methodsFor: 'public access' stamp: 'sw 5/20/2001 10:01'!format: textOrStream in: aClass notifying: aRequestor contentsSymbol: aSymbol	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^ nil].	aSymbol == #colorPrint		ifTrue: [^ aNode asColorizedSmalltalk80Text].	aSymbol == #altSyntax  "Alan's current explorations for alternate syntax - 2000/2001"		ifTrue:			[^ aNode asAltSyntaxText].	^ aNode decompileString! !!DialectStream methodsFor: 'color/style' stamp: 'sw 5/20/2001 11:20'!colorTable	"Answer the table to use to determine colors"	^ colorTable ifNil:		[colorTable _ dialect == #SQ00			ifTrue:				[Sq00ColorTable]			ifFalse:				[ST80ColorTable]]! !!DialectStream methodsFor: 'color/style' stamp: 'sw 5/20/2001 21:05'!withColor: colorSymbol emphasis: emphasisSymbol do: aBlock	"Evaluate the given block with the given color and style text attribute"	^ self withAttributes: {TextColor color: (Color perform: colorSymbol).							TextEmphasis perform: emphasisSymbol}		do: aBlock! !!DialectStream methodsFor: 'color/style' stamp: 'sw 5/20/2001 11:30'!withStyleFor: elementType do: aBlock	"Evaluate aBlock with appropriate emphasis and color for the given elementType"	| colorAndStyle |	colorAndStyle _ self colorTable at: elementType.	^ self withColor: colorAndStyle first emphasis: colorAndStyle second do: aBlock! !!DialectStream class methodsFor: 'class initialization' stamp: 'sw 5/20/2001 11:27'!initialize	"Initialize the color tables"	self initializeST80ColorTable.	self initializeSq00ColorTable."DialectStream initialize"! !!DialectStream class methodsFor: 'class initialization' stamp: 'sw 5/20/2001 21:09'!initializeST80ColorTable	"Initiialize the colors that characterize the ST80 dialect"	ST80ColorTable _ IdentityDictionary new.	#(	(temporaryVariable blue italic)		(methodArgument blue normal)		(methodSelector black bold)		(blockArgument red normal)		(comment brown normal)		(variable magenta normal)		(literal	tan normal)		(keyword darkGray bold)		(prefixKeyword veryDarkGray bold)		(setOrReturn black bold)) do:			[:aTriplet |				ST80ColorTable at: aTriplet first put: aTriplet allButFirst]"DialectStream initialize"! !!DialectStream class methodsFor: 'class initialization' stamp: 'sw 5/20/2001 11:25'!initializeSq00ColorTable	"Initiialize the colors that characterize the Sq00 dialect"	Sq00ColorTable _ IdentityDictionary new.	#(	(temporaryVariable black normal)		(methodArgument black normal)		(methodSelector black bold)		(blockArgument black normal)		(comment brown normal)		(variable black normal)		(literal	 blue normal)		(keyword darkGray bold)		(prefixKeyword veryDarkGray bold)		(setOrReturn black bold)) do:			[:aTriplet |				Sq00ColorTable at: aTriplet first put: aTriplet allButFirst]! !!DialectStream class methodsFor: 'instance creation' stamp: 'sw 5/20/2001 21:07'!dialect: dialectSymbol contents: blockWithArg 	"Evaluate blockWithArg on a DialectStream of the given description"	| stream |	stream _ self on: (Text new: 400).	stream setDialect: dialectSymbol.	blockWithArg value: stream.	^ stream contents! !!MethodNode methodsFor: 'converting' stamp: 'sw 5/20/2001 10:01'!asAltSyntaxText 	"Answer a string description of the parse tree whose root is the receiver, using the alternative syntax"	^ DialectStream		dialect: #SQ00		contents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'converting' stamp: 'sw 5/20/2001 10:00'!asColorizedSmalltalk80Text	"Answer a colorized Smalltalk-80-syntax string description of the parse tree whose root is the receiver."	^ DialectStream		dialect: #ST80		contents: [:strm | self printOn: strm]! !!PluggableTextMorph methodsFor: 'drawing' stamp: 'sw 5/22/2001 16:43'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	super drawOn: aCanvas. 	self wantsFrameAdornments ifTrue:		[(model notNil and: [model refusesToAcceptCode])			ifTrue:  "Put up feedback showing that code cannot be submitted in this state"				[aCanvas frameRectangle: self innerBounds width: 2 color: Color tan]			ifFalse:				[self hasEditingConflicts					ifTrue:						[aCanvas frameRectangle: self innerBounds width: 3 color: Color red] 					ifFalse:						[self hasUnacceptedEdits							ifTrue:								[model wantsDiffFeedback									ifTrue:										[aCanvas frameRectangle: self innerBounds width: 3 color: Color green]									ifFalse:										[aCanvas frameRectangle: self innerBounds width: 1 color: Color red]]							ifFalse:								[model wantsDiffFeedback									ifTrue:										[aCanvas frameRectangle: self innerBounds width: 1 color: Color green]]]]]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 5/22/2001 16:17'!offerDurableMenuFrom: menuRetriever shifted: aBoolean	"Pop up (morphic only) a menu whose target is the receiver and whose contents are provided by sending the menuRetriever to the receiver.  The menuRetriever takes two arguments: a menu, and a boolean representing the shift state; put a stay-up item at the top of the menu."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	self perform: menuRetriever with: aMenu with: aBoolean.		aMenu popUpInWorld! !!CodeHolder methodsFor: 'contents' stamp: 'sw 5/22/2001 18:04'!contents	"Answer the source code or documentation for the selected method"	| aClass aSelector aMethod |	self showingByteCodes ifTrue:		[((aClass _ self selectedClassOrMetaClass) notNil and:			[(aSelector _ self selectedMessageName) notNil])				ifTrue:					[aMethod _ aClass compiledMethodAt: aSelector ifAbsent: [nil].					aMethod ifNotNil: [^ aMethod symbolic asText]]].	self showingDocumentation ifTrue:		[^ self commentContents].	^ self selectedMessage! !!CodeHolder methodsFor: 'contents' stamp: 'sw 5/20/2001 10:21'!contentsSymbol	"Answer a symbol indicating what kind of content should be shown for the method; for normal showing of source code, this symbol is #source.  A nil value in the contentsSymbol slot will be set to #source by this method"	^ contentsSymbol ifNil: [contentsSymbol _ 		Preferences printAlternateSyntax			ifTrue:				[#altSyntax]			ifFalse:				[Preferences browseWithPrettyPrint					ifTrue:						[Preferences colorWhenPrettyPrinting							ifTrue:	[#colorPrint]							ifFalse:	[#prettyPrint]]					ifFalse:						[#source]]]! !!CodeHolder methodsFor: 'commands' stamp: 'sw 5/18/2001 17:51'!offerMenu	"Offer a menu to the user from the bar of tool buttons"	self offerDurableMenuFrom: #messageListMenu:shifted: shifted: false! !!CodeHolder methodsFor: 'controls' stamp: 'sw 5/22/2001 15:05'!codePaneProvenanceButton	"Answer a button that reports on, and allow the user to modify, the code-pane-provenance setting"	| aButton aWrapper |	aButton _ UpdatingSimpleButtonMorph newWithLabel: 'source'.	aButton setNameTo: 'codeProvenance'.	aButton useSquareCorners.	aButton target: self;		 wordingSelector: #codePaneProvenanceString;		 actionSelector: #offerWhatToShowMenu.	aButton setBalloonText: 'Governs what view shown in the code pane.  Click here to change the view'.	aButton actWhen: #buttonDown.	aButton color: self defaultBackgroundColor lighter.	aButton borderColor: Color blue lighter.	aWrapper _ AlignmentMorph newRow beTransparent.	aWrapper hResizing: #rigid; vResizing: #rigid.	aWrapper height: 20.	aWrapper addMorphBack: aButton.	"aWrapper cellPositioning: #leftCenter."	aButton cellPositioning: #topCenter.	aButton center: aWrapper center.	aWrapper cellPositioning: #topCenter.	^ aWrapper! !!CodeHolder methodsFor: 'controls' stamp: 'sw 5/19/2001 01:12'!codePaneProvenanceString	"Answer a string that reports on code-pane-provenance"	| symsAndWordings |	(symsAndWordings _ self contentsSymbolQuints) do:		[:aQuad |			contentsSymbol == aQuad first ifTrue: [^ aQuad fourth]].	^ symsAndWordings first fourth "default to plain source, for example if nil as initially"! !!CodeHolder methodsFor: 'controls' stamp: 'sw 5/22/2001 16:35'!contentsSymbolQuints	"Answer a list of quintuplets representing information on the alternative views available in the code pane		first element:	the contentsSymbol used		second element:	the selector to call when this item is chosen.		third element:	the selector to call to obtain the wording of the menu item.		fourth element:	the wording to represent this view		fifth element:	balloon help	A hypen indicates a need for a seperator line in a menu of such choices"	^ #((source			togglePlainSource 			showingPlainSourceString	'source'		'the textual source code as writen')(documentation	toggleShowDocumentation	showingDocumentationString	'documentation'		'the first comment in the method')-(prettyPrint		togglePrettyPrint 			prettyPrintString			'prettyPrint'			'the method source presented in a standard text format')(colorPrint		toggleColorPrint				colorPrintString				'colorPrint'			'the method source in a standard text format with colors to distinguish structural parts') (altSyntax		toggleAltSyntax				showingAltSyntaxString		'altSyntax'			'alternative syntax')-(showDiffs		toggleDiffing				showingDiffsString			'showDiffs'				'the textual source diffed from its prior version')(prettyDiffs		togglePrettyDiffing			showingPrettyDiffsString	'prettyDiffs'		'formatted textual source diffed from formatted form of prior version')-(decompile		toggleDecompile				showingDecompileString		'decompile'			'source code decompiled from byteCodes')(byteCodes		toggleShowingByteCodes		showingByteCodesString		'byteCodes'			'the bytecodes that comprise the compiled method')-(tiles			toggleShowingTiles 			showingTilesString			'tiles'				'universal tiles representing the method'))! !!CodeHolder methodsFor: 'controls' stamp: 'sw 5/19/2001 03:33'!optionalButtonRow	"Answer a row of control buttons"	| aRow aButton aLabel |	aRow _ AlignmentMorph newRow.	aRow setNameTo: 'buttonPane'.	aRow beSticky.	aRow hResizing: #spaceFill.	aRow wrapCentering: #center; cellPositioning: #leftCenter.	aRow clipSubmorphs: true.	Preferences menuButtonInToolPane		ifTrue:			[aRow addMorphFront: self menuButton].	self optionalButtonPairs  do:		[:tuple |			aButton _ PluggableButtonMorph				on: self				getState: nil				action: tuple second.			aButton 				useRoundedCorners;				hResizing: #spaceFill;				vResizing: #spaceFill;				onColor: Color transparent offColor: Color transparent.			aLabel _ Preferences abbreviatedBrowserButtons 				ifTrue: [self abbreviatedWordingFor: tuple second]				ifFalse: [nil].			aButton label: (aLabel ifNil: [tuple first asString]).			tuple size > 2 ifTrue: [aButton setBalloonText: tuple third].			aRow addMorphBack: aButton.			aRow addTransparentSpacerOfSize: (3 @ 0)].	aRow addMorphBack: self codePaneProvenanceButton.	^ aRow! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/20/2001 21:14'!diffFromPriorSourceFor: sourceCode 	"If there is a prior version of source for the selected method, return a diff, else just return the source code"	| prior |	^ (prior _ self priorSourceOrNil)		ifNil: [sourceCode]		ifNotNil: [TextDiffBuilder buildDisplayPatchFrom: prior to: sourceCode inClass: self selectedClass prettyDiffs: self showingPrettyDiffs]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/18/2001 19:54'!restoreTextualCodingPane	"If the receiver is showing tiles, restore the textual coding pane"	self showingTiles ifTrue:		[contentsSymbol _ #source.		self installTextualCodingPane]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/18/2001 19:37'!showDiffs	"Answer whether the receiver is showing diffs of source code"	^ contentsSymbol == #showDiffs! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/18/2001 19:42'!showDiffs: aBoolean	"Set whether I'm showing diffs as indicated"	contentsSymbol == #showDiffs		ifFalse:			[aBoolean ifTrue:				[contentsSymbol _ #showDiffs]]		ifTrue:			[aBoolean ifFalse:				[contentsSymbol _ #source]].	self setContentsToForceRefetch.	self contentsChanged! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/22/2001 18:25'!showPrettyDiffs: aBoolean	"Set whether I'm showing pretty diffs as indicated"	self showingPrettyDiffs		ifFalse:			[aBoolean ifTrue:				[contentsSymbol _ #prettyDiffs]]		ifTrue:			[aBoolean ifFalse:				[contentsSymbol _ #source]].	self setContentsToForceRefetch.	self contentsChanged! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/22/2001 16:40'!showingDiffsString	"Answer a string representing whether I'm showing diffs"	^ (self showDiffs		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'showDiffs'! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/19/2001 00:07'!showingPrettyDiffs	"Answer whether the receiver is showing pretty diffs of source code"	^ contentsSymbol == #prettyDiffs! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/22/2001 16:41'!showingPrettyDiffsString	"Answer a string representing whether I'm showing pretty diffs"	^ (self showingPrettyDiffs		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'prettyDiffs'! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/18/2001 23:50'!toggleColorPrint	"Toggle whether color-print is in effect in the code pane"	self restoreTextualCodingPane.	self okToChange ifTrue:		[self showingColorPrint			ifTrue:				[contentsSymbol _ #source]			ifFalse:				[contentsSymbol _ #colorPrint].		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/18/2001 20:10'!toggleDiffing	"Toggle whether diffs should be shown in the code pane"	| wasShowingDiffs |	self okToChange ifTrue:		[wasShowingDiffs _ self showDiffs.		self restoreTextualCodingPane.		self showDiffs: wasShowingDiffs not.		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/18/2001 19:57'!togglePlainSource	"Toggle whether plain source shown in the code pane"		| wasShowingPlainSource |	self okToChange ifTrue:		[wasShowingPlainSource _ self showingPlainSource.		self restoreTextualCodingPane.		wasShowingPlainSource			ifTrue:				[self showDocumentation: true]			ifFalse:				[contentsSymbol _ #source].		self setContentsToForceRefetch.		self changed: #contents]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/19/2001 00:02'!togglePrettyDiffing	"Toggle whether pretty-diffing should be shown in the code pane"	| wasShowingDiffs |	self okToChange ifTrue:		[wasShowingDiffs _ self showingPrettyDiffs.		self restoreTextualCodingPane.		self showPrettyDiffs: wasShowingDiffs not.		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/18/2001 19:54'!togglePrettyPrint	"Toggle whether pretty-print is in effectin the code pane"	self restoreTextualCodingPane.	self okToChange ifTrue:		[self showingPrettyPrint			ifTrue:				[contentsSymbol _ #source]			ifFalse:				[contentsSymbol _ #prettyPrint].		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 5/19/2001 02:16'!wantsDiffFeedback	"Answer whether the receiver is showing diffs of source code"	^ #(showDiffs prettyDiffs) includes: contentsSymbol! !!CodeHolder methodsFor: 'misc' stamp: 'sw 5/22/2001 18:21'!okayToAccept	"Answer whether it is okay to accept the receiver's input"	self showingDocumentation ifTrue:		[self inform: 'Sorry, for the moment you canonly submit changes here whenyou are showing source.  Later, youwill be able to edit the isolated commenthere and save it back, but only if YOUimplement it!!.'.		^ false].	self showDiffs ifFalse:		[^ true]. 	^ SelectionMenu confirm: 'Caution!!  You are "showing diffs" here, so there is a danger that some of the text in thecode pane is contaminated by the "diff" display'	trueChoice: 'accept anyway -- I''ll take my chances' falseChoice: 'um, let me reconsider'! !!CodeHolder methodsFor: 'misc' stamp: 'sw 5/22/2001 16:47'!refusesToAcceptCode	"Answer whether receiver, given its current contentsSymbol, could accept code happily if asked to"	^ (#(byteCodes documentation altSyntax tiles) includes: self contentsSymbol)! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 23:35'!addContentsTogglesTo: aMenu	"Add updating menu toggles governing contents to aMenu."	self contentsSymbolQuints do:		[:aQuint |			aQuint == #-				ifTrue:					[aMenu addLine]				ifFalse:					[aMenu addUpdating: aQuint third target: self action: aQuint second.					aMenu balloonTextForLastItem: aQuint fifth]]! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/22/2001 16:36'!colorPrintString	"Answer whether the receiver is showing colorPrint"	^ (self showingColorPrint		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'colorPrint'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/19/2001 00:09'!offerWhatToShowMenu	"Offer a menu governing what to show"	 | aMenu  |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'What to view'.	aMenu addStayUpItem.	self addContentsTogglesTo: aMenu.	aMenu popUpInWorld ! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/22/2001 16:36'!prettyPrintString	"Answer whether the receiver is showing pretty-print"	^ ((contentsSymbol == #prettyPrint)		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'prettyPrint'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 09:26'!showAltSyntax: aBoolean	"Set the decompile toggle as indicated"	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#altSyntax])! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 21:13'!showByteCodes: aBoolean	"Get into or out of bytecode-showoing mode"	self okToChange ifFalse: [^ self changed: #flash].	aBoolean		ifTrue:			[contentsSymbol _ #byteCodes]		ifFalse:			[contentsSymbol == #byteCodes ifTrue: [contentsSymbol _ #source]].	self contentsChanged! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 09:14'!showDecompile: aBoolean	"Set the decompile toggle as indicated"	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#decompile])! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 09:27'!showingAltSyntax	"Answer whether the receiver should show alt syntax rather than, say, source code"	^ self contentsSymbol == #altSyntax! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/22/2001 16:37'!showingAltSyntaxString	"Answer a string characerizing whether altSyntax is showing"	^ (self showingAltSyntax		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'altSyntax'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 18:05'!showingByteCodes	"Answer whether the receiver is showing bytecodes"	^ contentsSymbol == #byteCodes! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/22/2001 18:28'!showingByteCodesString	"Answer whether the receiver is showing bytecodes"	^ (self showingByteCodes		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'byteCodes'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 23:50'!showingColorPrint	"Answer whether the receiver is showing color-pretty-print"	^ contentsSymbol == #colorPrint! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 06:52'!showingDecompile	"Answer whether the receiver should show decompile rather than, say, source code"	^ self contentsSymbol == #decompile! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 06:50'!showingDecompileString	"Answer a string characerizing whether decompilation is showing"	^ (self showingDecompile		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'decompile'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 20:05'!showingDocumentationString	"Answer a string characerizing whether documentation is showing"	^ (self showingDocumentation		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'documentation'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 19:43'!showingPlainSource	"Answer whether the receiver is showing plain source"	^ contentsSymbol == #source! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/22/2001 09:31'!showingPlainSourceString	"Answer a string telling whether the receiver is showing plain source"	^ (self showingPlainSource		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'source'! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 18:36'!showingPrettyPrint	"Answer whether the receiver is showing pretty-print"	^ contentsSymbol == #prettyPrint! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 09:28'!toggleAltSyntax	"Toggle the setting of the showingAltSyntax flag, unless there are unsubmitted edits that the user declines to discard"	| wasShowing |	self okToChange ifTrue:		[wasShowing _ self showingAltSyntax.		self restoreTextualCodingPane.		self showAltSyntax: wasShowing not.		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/20/2001 06:48'!toggleDecompile	"Toggle the setting of the showingDecompile flag, unless there are unsubmitted edits that the user declines to discard"	| wasShowing |	self okToChange ifTrue:		[wasShowing _ self showingDecompile.		self restoreTextualCodingPane.		self showDecompile: wasShowing not.		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 20:15'!toggleShowDocumentation	"Toggle the setting of the showingDocumentation flag, unless there are unsubmitted edits that the user declines to discard"	| wasShowing |	self okToChange ifTrue:		[wasShowing _ self showingDocumentation.		self restoreTextualCodingPane.		self showDocumentation: wasShowing not.		self setContentsToForceRefetch.		self contentsChanged]! !!CodeHolder methodsFor: 'what to show' stamp: 'sw 5/18/2001 20:09'!toggleShowingByteCodes	"Toggle whether the receiver is showing bytecodes"	self restoreTextualCodingPane.	self showByteCodes: self showingByteCodes not.	self setContentsToForceRefetch.	self contentsChanged! !!CodeHolder methodsFor: 'tiles' stamp: 'sw 5/18/2001 23:04'!addModelItemsToWindowMenu: aMenu	"Add model-related item to the window menu"	super addModelItemsToWindowMenu: aMenu. 	Smalltalk isMorphic ifTrue:		[aMenu addLine.		self addContentsTogglesTo: aMenu]! !!CodeHolder methodsFor: 'tiles' stamp: 'sw 5/19/2001 13:02'!installTilesForSelection	"Install universal tiles into the code pane."	| source aSelector aClass tree syn tileScriptor aWindow codePane |	(aWindow _ self containingWindow) ifNil: [self error: 'hamna dirisha'].	tileScriptor _  (aSelector _ self selectedMessageName)		ifNil:			[PluggableTileScriptorMorph new]		ifNotNil:			[aClass _ self selectedClassOrMetaClass classThatUnderstands:  aSelector.			source _ aClass sourceCodeAt: aSelector.    			tree _ Compiler new 				parse: source 				in: aClass 				notifying: nil.			(syn _ tree asMorphicSyntaxUsing: SyntaxMorph)				parsedInClass: aClass.			syn inAPluggableScrollPane].	codePane _ aWindow findDeepSubmorphThat:   		[:m | (m isKindOf: PluggableTextMorph) and: [m getTextSelector == #contents]] ifAbsent: [nil].	codePane ifNotNil: [codePane hideScrollBar].	codePane ifNil: [codePane  _ aWindow findDeepSubmorphThat:   		[:m | m isKindOf: PluggableTileScriptorMorph] ifAbsent: [self error: 'no code pane']].	tileScriptor color: aWindow paneColorToUse;		setProperty: #hideUnneededScrollbars toValue: true.	aWindow replacePane: codePane with: tileScriptor.	currentCompiledMethod _ aClass ifNotNil: [aClass compiledMethodAt: aSelector].	tileScriptor owner clipSubmorphs: true.	tileScriptor extent: codePane extent.! !!CodeHolder methodsFor: 'tiles' stamp: 'sw 5/22/2001 15:18'!showTiles: aBoolean	"Set the showingTiles as indicated.  The fact that there are initially no senders of this reflects that fact that initially this trait is only directly settable through the UI; later there may be senders, such as if one wanted to set a system up so that all newly-opened browsers showed tiles rather than text."	aBoolean		ifTrue:			[contentsSymbol _ #tiles]		ifFalse:			[contentsSymbol == #tiles ifTrue: [contentsSymbol _ #source]].	self setContentsToForceRefetch.	self changed: contents! !!CodeHolder methodsFor: 'tiles' stamp: 'sw 5/20/2001 21:12'!showingTilesString	"Answer a string characterizing whether tiles are currently showing or not"	^ (self showingTiles		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'tiles'! !!CodeHolder methodsFor: 'message list' stamp: 'sw 5/20/2001 06:57'!decompiledSourceIntoContents	"Obtain a source string by decompiling the method's code, and place that source string into my contents.  Get temps from source file"	| tempNames class selector method |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	tempNames _ (class compilerClass new					parse: method getSourceFromFile asString in: class notifying: nil)					tempNames.	contents _ ((class decompilerClass new withTempNames: tempNames)			decompile: selector in: class method: method) decompileString.	contents _ contents asText makeSelectorBoldIn: class.	^ contents copy! !!CodeHolder methodsFor: 'message list' stamp: 'sw 5/22/2001 18:18'!selectedMessage	"Answer a copy of the source code for the selected message."	| class selector method tempNames |	contents == nil ifFalse: [^ contents copy].	self showingDecompile ifTrue:		[^ self decompiledSourceIntoContents].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	(Sensor controlKeyPressed		or: [method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil]])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents _ (class decompilerClass new decompile: selector in: class method: method)			decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	Sensor leftShiftDown ifTrue:		["Special request to decompile -- get temps from source file"		tempNames _ (class compilerClass new						parse: method getSourceFromFile asString in: class notifying: nil)						tempNames.		contents _ ((class decompilerClass new withTempNames: tempNames)				decompile: selector in: class method: method) decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	self showComment		ifFalse:			[contents _ self sourceStringPrettifiedAndDiffed]		ifTrue:			[contents _ self commentContents].	^ contents copy! !!CodeHolder methodsFor: 'message list' stamp: 'sw 5/20/2001 13:39'!sourceStringPrettifiedAndDiffed	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"	| class selector sourceString |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	(class isNil or: [selector isNil]) ifTrue: [^ 'missing'].	sourceString _ class sourceCodeAt: selector.	self validateMessageSource: sourceString forSelector: selector.	(#(prettyPrint colorPrint prettyDiffs altSyntax) includes: contentsSymbol) ifTrue:		[sourceString _ class compilerClass new			format: sourceString in: class notifying: nil contentsSymbol: contentsSymbol].	self wantsDiffFeedback ifTrue:		[sourceString _ self diffFromPriorSourceFor: sourceString].	^ sourceString! !!CodeHolder methodsFor: 'message list' stamp: 'sw 5/20/2001 13:38'!validateMessageSource: sourceString forSelector: aSelector	"Check whether there is evidence that method source is invalid"	| sourcesName |	(self selectedClass compilerClass == Object compilerClass 			and: [(sourceString asString findString: aSelector keywords first ) ~= 1])		ifTrue: [sourcesName _ FileDirectory localNameFor: Smalltalk sourcesName.			PopUpMenu notify: 'There may be a problem with your sources file!!The source code for every method should start with the methodselector but this is not the case!! You may proceed with caution but it is recommended that you get a new source file.This can happen if you download the "' , sourcesName  , '" file, or the ".changes" file you use, as TEXT. It must be transfered in BINARY mode, even if it looks like a text file, to preserve the CR line ends.Mac users: This may have been caused by Stuffit Expander. To prevent the files above to be converted to Mac line ends when they are expanded, do this: Start the program, then from Preferences... in the File menu, choose the Cross Platform panel, then select "Never" and press OK. Then expand the compressed archive again.'].! !!Browser methodsFor: 'accessing' stamp: 'sw 5/22/2001 18:28'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass _ self selectedClass)			ifNil:				[Class template: self selectedSystemCategoryName]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue: [^ self selectedClassOrMetaClass definitionST80: Preferences printAlternateSyntax not].	editSelection == #editComment 		ifTrue: [(theClass _ self selectedClass) ifNil: [^ ''].				comment _ theClass comment.				comment size = 0				ifTrue: [^ 'This class has not yet been commented.']				ifFalse: [^ comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue: [^ self selectedClassOrMetaClass sourceCodeTemplate].	editSelection == #editMessage		ifTrue:			[self showingByteCodes ifTrue:				[^ (self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName) symbolic asText].			currentCompiledMethod _ latestCompiledMethod.			^ self selectedMessage].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'code pane' stamp: 'sw 5/18/2001 20:55'!showBytecodes	"Show or hide the bytecodes of the selected method -- an older protocol now mostly not relevant."	self toggleShowingByteCodes! !!Browser methodsFor: 'message functions' stamp: 'sw 5/18/2001 23:01'!messageListMenu: aMenu shifted: shifted	"Answer the message-list menu"	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList:#(			('what to show...'						offerWhatToShowMenu)			-			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut'								fileOutMessage)			('printOut'								printOutMessage)			-			('senders of... (n)'						browseSendersOfMessages)			('implementors of... (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('tile scriptor'							openSyntaxView)			('versions (v)'							browseVersions)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class variables'						browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('remove method (x)'					removeMessage)			-			('more...'								shiftedYellowButtonActivity)).	^ aMenu! !!Browser methodsFor: 'message list' stamp: 'sw 5/22/2001 18:21'!selectedMessage	"Answer a copy of the source code for the selected message."	| class selector method |	contents == nil ifFalse: [^ contents copy].	self showingDecompile ifTrue:		[^ self decompiledSourceIntoContents].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	(Sensor controlKeyPressed		or: [method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil]])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents _ (class decompilerClass new decompile: selector in: class method: method)			decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	Sensor leftShiftDown ifTrue:		["Special request to decompile, old and dubious interface"		^ self decompiledSourceIntoContents].	self showingDocumentation		ifFalse:			[contents _ self sourceStringPrettifiedAndDiffed]		ifTrue:			[contents _ self commentContents].	^ contents copy! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 5/18/2001 22:16'!initialize	"Initialize a blank ChangeList.  Set the contentsSymbol to reflect whether diffs will initally be shown or not"	contentsSymbol _ Preferences diffsInChangeList		ifTrue:			[#showDiffs]		ifFalse:			[#source].	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	super initialize! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 5/20/2001 21:18'!compareToCurrentVersion	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"	| change class s1 s2 |	listIndex = 0		ifTrue: [^ self].	change _ changeList at: listIndex.	((class _ change methodClass) notNil			and: [class includesSelector: change methodSelector])		ifTrue: [s1 _ (class sourceCodeAt: change methodSelector) asString.			s2 _ change string.			s1 = s2				ifTrue: [^ self inform: 'Exact Match'].			(StringHolder new				textContents: (TextDiffBuilder buildDisplayPatchFrom: s1 to: s2 inClass: class  prettyDiffs: self showingPrettyDiffs))				openLabel: 'Comparison to Current Version']		ifFalse: [self flash]! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 5/19/2001 10:59'!contentsDiffedFromCurrent	"Answer the contents diffed forward from current (in-memory) method version"	| aChange aClass |	listIndex = 0		ifTrue: [^ ''].	aChange _ changeList at: listIndex.	^ ((aChange type == #method and: [(aClass _ aChange methodClass) notNil]) and: [aClass includesSelector: aChange methodSelector])		ifTrue:			 [Utilities methodDiffFor: aChange text class: aClass selector: aChange methodSelector prettyDiffs: self showingPrettyDiffs]		ifFalse:			[(changeList at: listIndex) text]! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 5/19/2001 11:07'!diffedVersionContents	"Answer diffed version contents"	| thisText change class |	(listIndex = 0			or: [changeList size < listIndex])		ifTrue: [^ ''].	change _ changeList at: listIndex.	thisText _ change text.	class _ change methodClass.	^ listIndex == changeList size		ifTrue: [thisText]		ifFalse: [TextDiffBuilder buildDisplayPatchFrom: (changeList at: listIndex + 1) text to: thisText inClass: class prettyDiffs: self showingPrettyDiffs]! !!ChangeListForProjects methodsFor: 'contents' stamp: 'sw 5/19/2001 11:06'!currentDiffedFromContents	"Answer the current in-memory method diffed from the current contents"	| aChange aClass |	listIndex = 0		ifTrue: [^ ''].	aChange _ changeList at: listIndex.	^ ((aChange type == #method				and: [(aClass _ aChange methodClass) notNil])			and: [aClass includesSelector: aChange methodSelector])		ifTrue: [TextDiffBuilder				buildDisplayPatchFrom: aChange text				to: (aClass sourceCodeAt: aChange methodSelector)				inClass: aClass				prettyDiffs: self showingPrettyDiffs]		ifFalse: [(changeList at: listIndex) text]! !!ChangeSorter methodsFor: 'code pane' stamp: 'sw 5/20/2001 21:17'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ contents _ myChangeSet preambleString ifNil: ['']].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents _ 'Added then removed (see versions)'].			class ifNil: [^ contents _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents _ 'Method was added, but cannot be found!!'].			contents _ class sourceCodeAt: sel.			(#(prettyPrint colorPrint prettyDiffs altSyntax) includes: contentsSymbol) ifTrue:				[contents _ class compilerClass new					format: contents in: class notifying: nil contentsSymbol: contentsSymbol].			self showDiffs				ifTrue: [contents _ self diffFromPriorSourceFor: contents].			^ contents _ contents asText makeSelectorBoldIn: class]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ contents _ strm contents].! !!ChangeSetBrowser methodsFor: 'initialization' stamp: 'sw 5/19/2001 01:15'!addModelItemsToWindowMenu: aMenu	"Add model-related items to the given window menu"	| oldTarget |	oldTarget _ aMenu defaultTarget.	aMenu defaultTarget: self.	aMenu addLine.	aMenu add: 'rename change set' action: #rename.	aMenu add: 'make changes go to me' action: #newCurrent.	aMenu addLine.	aMenu add: 'file out' action: #fileOut.	aMenu add: 'browse methods' action: #browseChangeSet.	aMenu addLine.	myChangeSet hasPreamble		ifTrue:			[aMenu add: 'edit preamble' action: #addPreamble.			aMenu add: 'remove preamble' action: #removePreamble]		ifFalse:			[aMenu add: 'add preamble' action: #addPreamble].	myChangeSet hasPostscript		ifTrue:			[aMenu add: 'edit postscript...' action: #editPostscript.			aMenu add: 'remove postscript' action: #removePostscript]		ifFalse:			[aMenu add: 'add postscript...' action: #editPostscript].	aMenu addLine.		aMenu add: 'destroy change set' action: #remove.	aMenu addLine.	self addContentsTogglesTo: aMenu.	aMenu add: 'more...' action: #offerShiftedChangeSetMenu.	aMenu defaultTarget: oldTarget.	^ aMenu! !!FileContentsBrowser methodsFor: 'diffs' stamp: 'sw 5/20/2001 21:03'!methodDiffFor: aString class: aPseudoClass selector: selector meta: meta 	"Answer the diff between the current copy of the given class/selector/meta for the string provided"	| theClass source |	theClass _ Smalltalk				at: aPseudoClass name				ifAbsent: [^ aString copy].	meta		ifTrue: [theClass _ theClass class].	(theClass includesSelector: selector)		ifFalse: [^ aString copy].	source _ theClass sourceCodeAt: selector.	^ Cursor wait		showWhile: [TextDiffBuilder buildDisplayPatchFrom: source to: aString inClass: theClass prettyDiffs: self showingPrettyDiffs]! !!FileContentsBrowser methodsFor: 'creation' stamp: 'sw 5/20/2001 21:04'!createViews	"Create a pluggable version of all the views for a Browser, including views and controllers."	| hasSingleFile width topView packageListView classListView switchView messageCategoryListView messageListView browserCodeView infoView |	contentsSymbol _ #showDiffs.	Smalltalk isMorphic ifTrue: [^ self openAsMorph].	(hasSingleFile _ self packages size = 1)		ifTrue: [width _ 150]		ifFalse: [width _ 200].	(topView _ StandardSystemView new) 		model: self;		borderWidth: 1.		"label and minSize taken care of by caller"		hasSingleFile 		ifTrue: [			self systemCategoryListIndex: 1.			packageListView _ PluggableListView on: self				list: #systemCategorySingleton				selected: #indexIsOne 				changeSelected: #indexIsOne:				menu: #packageListMenu:				keystroke: #packageListKey:from:.			packageListView window: (0 @ 0 extent: width @ 12)]		ifFalse: [			packageListView _ PluggableListView on: self				list: #systemCategoryList				selected: #systemCategoryListIndex				changeSelected: #systemCategoryListIndex:				menu: #packageListMenu:				keystroke: #packageListKey:from:.			packageListView window: (0 @ 0 extent: 50 @ 70)].	topView addSubView: packageListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:		keystroke: #classListKey:from:.	classListView window: (0 @ 0 extent: 50 @ 62).	hasSingleFile 		ifTrue: [topView addSubView: classListView below: packageListView]		ifFalse: [topView addSubView: classListView toRightOf: packageListView].	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: width@110).	topView 		addSubView: browserCodeView 		below: (hasSingleFile 			ifTrue: [switchView]			ifFalse: [packageListView]).	infoView _ StringHolderView new		model: self infoString;		window: (0@0 extent: width@12);		borderWidth: 1.	topView addSubView: infoView below: browserCodeView.	^ topView! !!MessageSet methodsFor: 'contents' stamp: 'sw 5/22/2001 18:29'!contents	"Answer the contents of the receiver"	^ contents == nil		ifTrue: [currentCompiledMethod _ nil. '']		ifFalse: [messageListIndex = 0 			ifTrue: [currentCompiledMethod _ nil. contents]			ifFalse: [self showingByteCodes				ifTrue: [(self selectedClassOrMetaClass							compiledMethodAt: self selectedMessageName) symbolic]				ifFalse: [self selectedMessage]]]! !!MessageSet methodsFor: 'contents' stamp: 'sw 5/22/2001 18:20'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		class ifNil: [^ 'Class vanished'].		selector first isUppercase ifTrue: [			selector == #Comment ifTrue: [^ class comment].			selector == #Definition ifTrue: [				^ class definitionST80: Preferences printAlternateSyntax not].			selector == #Hierarchy ifTrue: [^ class printHierarchy]].		source _ class sourceMethodAt: selector ifAbsent:			[currentCompiledMethod _ nil.			^ 'Missing'].		self showingDecompile ifTrue:			[^ self decompiledSourceIntoContents].		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		self showingDocumentation ifTrue:			[^ self commentContents].	source _ self sourceStringPrettifiedAndDiffed.	^ source asText makeSelectorBoldIn: class]! !!Lexicon methodsFor: 'selection' stamp: 'sw 5/22/2001 18:20'!selectedMessage	"Answer the source method for the currently selected message."	(categoryList notNil and: [(categoryListIndex isNil or: [categoryListIndex == 0])])		ifTrue:			[^ '---'].	self setClassAndSelectorIn: [:class :selector | 		class ifNil: [^ 'here would go the documentation for the protocol category, if any.'].		self showingDecompile ifTrue:			[^ self decompiledSourceIntoContents].		self showingDocumentation ifTrue:			[^ self commentContents].		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		^ self sourceStringPrettifiedAndDiffed asText makeSelectorBoldIn: class]! !!MethodHolder methodsFor: 'contents' stamp: 'sw 5/22/2001 18:20'!contents	"Answer the contents, with due respect for my contentsSymbol"	contents _ methodClass sourceCodeAt: methodSelector ifAbsent: [''].	currentCompiledMethod _ methodClass compiledMethodAt: methodSelector ifAbsent: [nil].	self showingDecompile ifTrue:		[^ self decompiledSourceIntoContents].	self showingDocumentation ifTrue:		[^ self commentContents].	^ contents _ self sourceStringPrettifiedAndDiffed asText makeSelectorBoldIn: methodClass! !!TextDiffBuilder class methodsFor: 'instance creation' stamp: 'sw 5/19/2001 10:52'!buildDisplayPatchFrom: srcString to: dstString inClass: srcClass prettyDiffs: prettyBoolean	"Build a display patch for mapping via diffs from srcString to dstString in the given class.  If prettyBoolean is true, do the diffing for pretty-printed forms"	^ ((srcClass notNil and: [prettyBoolean])		ifTrue: [PrettyTextDiffBuilder				from: srcString				to: dstString				inClass: srcClass]		ifFalse: [self from: srcString to: dstString]) buildDisplayPatch! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 5/19/2001 10:58'!methodDiffFor: aString class: aClass selector: aSelector prettyDiffs: prettyDiffBoolean.	"Return a string comprising a source-code diff between an existing method and the source-code in aString.  DO prettyDiff if prettyDiffBoolean is true."	^ (aClass notNil and: [aClass includesSelector: aSelector])		ifTrue: [TextDiffBuilder				buildDisplayPatchFrom: (aClass sourceCodeAt: aSelector)				to: aStringinClass: aClass]		ifFalse: [aString copy]! !Utilities class removeSelector: #methodDiffFor:class:selector:!!MethodHolder reorganize!('menu' addModelMenuItemsTo:forMorph:hand:)('miscellaneous' compiledMethod doItReceiver identifyScript methodClass:methodSelector: versions)('contents' contents contents:notifying:)('selection' selectedClass selectedClassOrMetaClass selectedMessageCategoryName selectedMessageName)!MessageSet removeSelector: #toggleDiffing!MessageSet removeSelector: #toggleShowDocumentation!ChangeSorter removeSelector: #selectedMessage!!ChangeListForProjects reorganize!('contents' contents currentDiffedFromContents)!Browser removeSelector: #validateMessageSource:!CodeHolder removeSelector: #addSourceTogglesTo:!CodeHolder removeSelector: #validateMessageSource:!!CodeHolder reorganize!('annotation' addOptionalAnnotationsTo:at:plus: addPriorVersionsCountForSelector:ofClass:to: annotation annotationForSelector:ofClass: annotationPaneMenu:shifted: annotationRequests annotationSeparator defaultAnnotationPaneHeight defaultButtonPaneHeight)('categories' categoryOfCurrentMethod changeCategory methodCategoryChanged selectedMessageCategoryName)('contents' commentContents contents contentsChanged contentsSymbol contentsSymbol:)('commands' abbreviatedWordingFor: adoptMessageInCurrentChangeset browseImplementors browseSenders copyUpOrCopyDown makeSampleInstance offerMenu offerShiftedClassListMenu offerUnshiftedClassListMenu removeClass shiftedYellowButtonActivity showUnreferencedInstVars spawn: spawnFullProtocol spawnHierarchy spawnProtocol spawnToClass: spawnToCollidingClass: unshiftedYellowButtonActivity)('construction' addLowerPanesTo:at:with: buildClassBrowserEditString: buildMorphicCodePaneWith:)('controls' addOptionalButtonsTo:at:plus: buttonWithSelector: codePaneProvenanceButton codePaneProvenanceString contentsSymbolQuints decorateButtons decorateForInheritance inheritanceButton optionalButtonPairs optionalButtonRow)('diffs' diffButton diffFromPriorSourceFor: restoreTextualCodingPane showDiffs showDiffs: showPrettyDiffs: showingDiffsString showingPrettyDiffs showingPrettyDiffsString toggleColorPrint toggleDiff toggleDiffing togglePlainSource togglePrettyDiffing togglePrettyPrint wantsDiffFeedback)('misc' getSelectorAndSendQuery:to: isThereAnOverride menuButton modelWakeUpIn: okayToAccept priorSourceOrNil refusesToAcceptCode releaseCachedState sampleInstanceOfSelectedClass sendQuery:to: setClassAndSelectorIn: suggestCategoryToSpawnedBrowser: useSelector:orGetSelectorAndSendQuery:to:)('self-updating' didCodeChangeElsewhere stepIn: updateCodePaneIfNeeded updateListsAndCodeIn: wantsStepsIn:)('what to show' addContentsTogglesTo: colorPrintString offerWhatToShowMenu prettyPrintString setContentsToForceRefetch showAltSyntax: showByteCodes: showComment showDecompile: showDocumentation: showingAltSyntax showingAltSyntaxString showingByteCodes showingByteCodesString showingColorPrint showingDecompile showingDecompileString showingDocumentation showingDocumentationString showingPlainSource showingPlainSourceString showingPrettyPrint showingSource sourceOrInfoButton toggleAltSyntax toggleDecompile toggleShowDocumentation toggleShowingByteCodes)('tiles' addModelItemsToWindowMenu: installTextualCodingPane installTilesForSelection showTiles: showingTiles showingTilesString tilesToggleButton toggleShowingTiles)('categories & search pane' listPaneWithSelector: newSearchPane searchPane textPaneWithSelector:)('message list' decompiledSourceIntoContents selectedMessage sourceStringPrettifiedAndDiffed validateMessageSource:forSelector:)!StringHolder removeSelector: #showDiffs!!StringHolder reorganize!('initialize-release' defaultContents embeddedInMorphicWindowLabeled: initialize openAsMorphLabel: openAsMorphLabel:inWorld: openLabel: openLabel:andTerminate:)('accessing' acceptContents: contents contents: contentsChanged contentsSelection noteAcceptanceOfCodeFor: reformulateList reformulateListNoting: selectedClassName selectedClassOrMetaClass selectedMessageName textContents:)('code pane menu' codePaneMenu:shifted: perform:orSendTo: showBytecodes spawn:)('evaluation' doItContext doItReceiver)('message list menu' browseAllMessages browseClass browseClassRefs browseClassVarRefs browseClassVariables browseFullProtocol browseInstVarDefs browseInstVarRefs browseMessages browseMethodFull browseSendersOfMessages browseUnusedMethods browseVersions buildMessageBrowser classHierarchy classListKey:from: copyName fetchDocPane fileOutMessage findMethodInChangeSets inspectInstances inspectSubInstances makeIsolatedCodePane messageListKey:from: messageListSelectorTitle methodHierarchy offerDurableMenuFrom:shifted: offerMenuFrom:shifted: openSingleMessageBrowser packageListKey:from: printOutMessage removeFromCurrentChanges revertAndForget revertToPreviousVersion selectMessageAndEvaluate: systemCatListKey:from: timeStamp)('optional panes' wantsAnnotationPane wantsOptionalButtons)('tiles' openSyntaxView)('user edits' clearUserEditFlag okToChange)!Preferences class removeSelector: #tilesToggleInBrowsers!MethodNode removeSelector: #decompileAltSyntaxText!MethodNode removeSelector: #decompileST80Text!DialectStream initialize!!DialectStream class reorganize!('class initialization' initialize initializeST80ColorTable initializeSq00ColorTable)('instance creation' dialect:contents:)!!DialectStream reorganize!('color/style' colorTable withColor:emphasis:do: withStyleFor:do:)('access' dialect setDialect:)!"Postscript:"Preferences expungePreferenceNamed: #tilesToggleInBrowsers.Preferences expungePreferenceNamed: #deployDiffToggles.Preferences expungePreferenceNamed: #sourceCommentToggleInBrowsers.Flaps replaceBrowserInToolsFlap .!