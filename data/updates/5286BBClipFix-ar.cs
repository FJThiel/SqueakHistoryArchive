'From TeaSqueak3.2 of 19 September 2002 [latest update: #374] on 8 March 2003 at 12:36:14 am'!"Change Set:		BBClipFixDate:			8 March 2003Author:			Andreas RaabThe CS fixes a problem encountered when drawing morphs with huge positions/sizes. In this case a BitBlt primitive can fail as it is unable to handle the resulting large integer arithmetic. The problem is corrected by clipping manually if the primitive fails and (if successful) retrying with the reduced size."!!BitBlt methodsFor: 'copying' stamp: 'ar 3/7/2003 23:57'!copyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	"Check if BitBlt doesn't support full color maps"	(colorMap notNil and:[colorMap isColormap]) ifTrue:[		colorMap _ colorMap colors.		^self copyBits].	"Check if clipping gots us way out of range"	self clipRange ifTrue:[^self copyBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'private' stamp: 'ar 3/8/2003 00:34'!clipRange	"clip and adjust source origin and extent appropriately"	"first in x"	| sx sy dx dy bbW bbH |	"fill in the lazy state if needed"	destX ifNil:[destX := 0].	destY ifNil:[destY := 0].	width ifNil:[width := destForm width].	height ifNil:[height := destForm height].	sourceX ifNil:[sourceX := 0].	sourceY ifNil:[sourceY := 0].	clipX ifNil:[clipX := 0].	clipY ifNil:[clipY := 0].	clipWidth ifNil:[clipWidth := destForm width].	clipHeight ifNil:[clipHeight := destForm height].	destX >= clipX		ifTrue: [sx _ sourceX.				dx _ destX.				bbW _ width]		ifFalse: [sx _ sourceX + (clipX - destX).				bbW _ width - (clipX - destX).				dx _ clipX].	(dx + bbW) > (clipX + clipWidth)		ifTrue: [bbW _ bbW - ((dx + bbW) - (clipX + clipWidth))].	"then in y"	destY >= clipY		ifTrue: [sy _ sourceY.				dy _ destY.				bbH _ height]		ifFalse: [sy _ sourceY + clipY - destY.				bbH _ height - (clipY - destY).				dy _ clipY].	(dy + bbH) > (clipY + clipHeight)		ifTrue: [bbH _ bbH - ((dy + bbH) - (clipY + clipHeight))].	sourceForm ifNotNil:[		sx < 0			ifTrue: [dx _ dx - sx.					bbW _ bbW + sx.					sx _ 0].		sx + bbW > sourceForm width			ifTrue: [bbW _ bbW - (sx + bbW - sourceForm width)].		sy < 0			ifTrue: [dy _ dy - sy.					bbH _ bbH + sy.					sy _ 0].		sy + bbH > sourceForm height			ifTrue: [bbH _ bbH - (sy + bbH - sourceForm height)].	].	(bbW <= 0 or:[bbH <= 0]) ifTrue:[		sourceX := sourceY := destX := destY := clipX := clipY := width := height := 0.		^true].	(sx = sourceX 		and:[sy = sourceY 		and:[dx = destX 		and:[dy = destY 		and:[bbW = width 		and:[bbH = height]]]]]) ifTrue:[^false].	sourceX := sx.	sourceY := sy.	destX := dx.	destY := dy.	width := bbW.	height := bbH.	^true! !