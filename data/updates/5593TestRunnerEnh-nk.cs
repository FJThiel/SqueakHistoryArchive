'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5566] on 1 December 2003 at 1:30:17 pm'!"Change Set:		TestRunnerEnh-nkDate:				6 August 2003Author:			Ned Konz6 August 03 (1.9):3.6 compatibility.Made into a Model subclass.Made debugger step to beginning of failed test case.Added window colors.Added to flaps registry.Fixed browsing.1 May '03 (1.8):Fixed behavior of progress morph when collapsed and re-expanded.23 Dec (1.7):Fixed for compatibility with TestBrowser.19 Dec:Added fixes for abstract classes from Magistrello Alejandro.19 Dec:Added to World menu.Made top divider work right.Added button spacing.Made it respect window color choice.Kept select/deselect all from scrolling list.15 Dec: kept it from scrolling back to the beginningwhen you deselect a test.I didn't like the TestRunner tying up the UI.So this version runs tests in the background; I'm goingto post a TestCase subclass for UI testing soon.Also:* adds progress notification* adds a stop button* You can select which tests you want to run.* It sorts the test cases by name.* It works in a MVC project.* It has a context menu for the selection list* It allows you to select test cases by patternThis includes changes by Stephan Wessels:The most obvious changes will be related to the buttons having fixed widths, and the small text panes having fixed heights regardless of resizing.  The buttons use rounded corners and all the panes use window existing preference settings for border shape and colors.  If the optional buttons preference is turned on, the tests list pane includes the main menu items as optional buttons."!Model subclass: #TestRunner	instanceVariableNames: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite totalTests progress running selectedSuites filter completedTests runSemaphore '	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-UI'!!TestRunner commentStamp: 'nk 8/6/2003 10:02' prior: 0!This is a user interface for the SUnit TestCase and TestSuite classes.It lets you run tests in the background, and you can select subsets to run.!!ProgressMorph methodsFor: 'initialization' stamp: 'nk 4/21/2002 20:06'!setupMorphs	|  |	self initProgressMorph.	self			layoutPolicy: TableLayout new;		listDirection: #topToBottom;		cellPositioning: #topCenter;		listCentering: #center;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent.	self addMorphBack: self labelMorph.	self addMorphBack: self subLabelMorph.	self addMorphBack: self progress.	self borderWidth: 2.	self borderColor: Color black.	self color: Color veryLightGray.	self align: self fullBounds center with: Display boundingBox center! !!SystemWindow methodsFor: 'top window' stamp: 'nk 8/6/2003 10:53'!updatePanesFromSubmorphs	"Having removed some submorphs, make sure this is reflected in my paneMorphs."	paneMorphs _ paneMorphs select: [ :pane | submorphs includes: pane ].! !!TestCase methodsFor: 'Running' stamp: 'nk 8/6/2003 08:45'!openDebuggerOnFailingTestMethod	| guineaPig context compiledMethod debugger |	compiledMethod _ self class compiledMethodAt: self selector.	guineaPig _ [ self performTest ] newProcess.	context _ guineaPig suspendedContext.	debugger _ Debugger new		process: guineaPig		controller: ((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: context		isolationHead: nil.	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.	[debugger interruptedContext method == compiledMethod]		whileFalse: [debugger send].! !!TestCase class methodsFor: 'Building Suites' stamp: 'nk 4/21/2002 10:59'!addTestsFor: classNameString toSuite: suite	| cls  |	cls _ Smalltalk at: classNameString ifAbsent: [ ^suite ].	^cls isAbstract 		ifTrue:  [			cls allSubclasses do: [ :each |				each isAbstract ifFalse: [					each addToSuiteFromSelectors: suite ] ].			suite]		ifFalse: [ cls addToSuiteFromSelectors: suite ]! !!TestCase class methodsFor: 'Building Suites' stamp: 'nk 4/21/2002 10:51'!addToSuite: suite fromMethods: testMethods 	testMethods do:  [ :selector | 			suite addTest: (self selector: selector) ].	^suite! !!TestCase class methodsFor: 'Building Suites' stamp: 'nk 4/21/2002 16:37'!addToSuiteFromSelectors: suite	^self addToSuite: suite fromMethods: (self shouldInheritSelectors		ifTrue: [ self allTestSelectors ]		ifFalse: [self testSelectors ])! !!TestCase class methodsFor: 'Building Suites' stamp: 'nk 12/23/2002 07:40'!buildSuite	| suite |	suite _ TestSuite new.	^ self isAbstract		ifTrue: [			suite name: self name asString.			self allSubclasses				do: [:each | each isAbstract						ifFalse: [each addToSuiteFromSelectors: suite]].			suite]		ifFalse: [self addToSuiteFromSelectors: suite]! !!TestCase class methodsFor: 'Building Suites' stamp: 'nk 4/21/2002 10:52'!buildSuiteFromMethods: testMethods 	| suite |	suite _ (TestSuite new)				name: self name asString;				yourself.	^self addToSuite: suite fromMethods: testMethods! !!TestRunner methodsFor: 'accessing' stamp: 'Sames 4/11/2000 17:25'!details        ^details! !!TestRunner methodsFor: 'accessing' stamp: 'jp 3/17/2003 13:49'!errors        ^errors! !!TestRunner methodsFor: 'accessing' stamp: 'jp 3/17/2003 13:48'!errorsList        ^self errors collect: [:error | error printString]! !!TestRunner methodsFor: 'accessing' stamp: 'Sames 4/11/2000 17:26'!failures        ^failures! !!TestRunner methodsFor: 'accessing' stamp: 'nk 8/6/2003 08:36'!failuresList        ^self failures collect: [:failure | failure printString]! !!TestRunner methodsFor: 'accessing' stamp: 'Sames 4/12/2000 18:12'!formatTime: aTime        aTime hours > 0 ifTrue: [^aTime hours printString , 'h'].        aTime minutes > 0 ifTrue: [^aTime minutes printString , 'min'].        ^aTime seconds printString , ' sec'! !!TestRunner methodsFor: 'accessing' stamp: 'nk 4/21/2002 09:36'!listSelectionAt: index	^selectedSuites at: index! !!TestRunner methodsFor: 'accessing' stamp: 'nk 4/21/2002 11:14'!listSelectionAt: index put: aBoolean	^selectedSuites at: index put: aBoolean! !!TestRunner methodsFor: 'accessing' stamp: 'Sames 4/11/2000 17:26'!passFail        ^passFail! !!TestRunner methodsFor: 'accessing' stamp: 'nk 4/22/2002 10:52'!result	^result! !!TestRunner methodsFor: 'accessing' stamp: 'nk 12/8/2002 11:44'!runSemaphore	^runSemaphore! !!TestRunner methodsFor: 'accessing' stamp: 'nk 4/21/2002 10:09'!selectedTests	| retval |	retval _ OrderedCollection new.	tests with: selectedSuites do: [ :str :sel | sel ifTrue: [ retval add: str ]].	^retval! !!TestRunner methodsFor: 'accessing' stamp: 'Sames 2/22/2001 10:14'!suite        ^TestCase buildSuite! !!TestRunner methodsFor: 'accessing' stamp: 'Sames 4/11/2000 18:39'!tests        ^ tests! !!TestRunner methodsFor: 'accessing' stamp: 'Sames 4/12/2000 18:19'!timeSinceLastPassAsString: aResult        (lastPass isNil or: [aResult hasPassed not]) ifTrue: [^ ''].        ^ ', ' , (self formatTime: (Time now subtractTime: lastPass)) , 'since last Pass'! !!TestRunner methodsFor: 'constants' stamp: 'nk 4/21/2002 15:40'!debugButtonLabel        ^ 'Debug'! !!TestRunner methodsFor: 'constants' stamp: 'SSS 7/5/2000 14:08'!debugState        ^true! !!TestRunner methodsFor: 'constants' stamp: 'sbw 9/26/2002 19:31'!errorColor	^ Color red lighter! !!TestRunner methodsFor: 'constants' stamp: 'sbw 9/26/2002 19:31'!failColor	^ Color yellow lighter! !!TestRunner methodsFor: 'constants' stamp: 'nk 4/22/2002 10:53'!failureMessage	^'failed'! !!TestRunner methodsFor: 'constants' stamp: 'nk 4/21/2002 15:40'!filterButtonLabel	^'Filter'! !!TestRunner methodsFor: 'constants' stamp: 'sbw 9/26/2002 19:30'!passColor	^ Color green lighter! !!TestRunner methodsFor: 'constants' stamp: 'nk 4/21/2002 15:41'!refreshButtonLabel        ^ 'Refresh'! !!TestRunner methodsFor: 'constants' stamp: 'SSS 7/5/2000 13:59'!refreshButtonState        ^true! !!TestRunner methodsFor: 'constants' stamp: 'sbw 9/26/2002 19:29'!runButtonColor	^ Color green lighter! !!TestRunner methodsFor: 'constants' stamp: 'nk 4/21/2002 15:41'!runButtonLabel        ^ 'Run All'! !!TestRunner methodsFor: 'constants' stamp: 'sbw 9/26/2002 19:29'!runButtonOffColor	^ Color yellow lighter! !!TestRunner methodsFor: 'constants' stamp: 'nk 4/21/2002 17:50'!runButtonState        ^running isNil! !!TestRunner methodsFor: 'constants' stamp: 'nk 4/21/2002 15:41'!runOneButtonLabel        ^ 'Run One'! !!TestRunner methodsFor: 'constants' stamp: 'nk 4/21/2002 20:18'!stopButtonLabel	^'Stop'! !!TestRunner methodsFor: 'constants' stamp: 'nk 4/21/2002 20:18'!stopButtonState	^self runButtonState not! !!TestRunner methodsFor: 'constants' stamp: 'nk 4/22/2002 10:53'!successMessage	^'succeeded'! !!TestRunner methodsFor: 'constants' stamp: 'sbw 9/26/2002 19:57'!windowLabel	^ 'SUnit Test Runner'! !!TestRunner methodsFor: 'initialize' stamp: 'nk 8/6/2003 10:51'!gatherTestNames	| theNames |	theNames _ (TestCase allSubclasses collect: [:each | each name]) asSortedCollection.	theNames remove: #TestViaMethodCall ifAbsent: [^ theNames].	Smalltalk at: #TestViaMethodCall ifPresent: [ :tvmc | tvmc addClassesTo: theNames ].	^ theNames! !!TestRunner methodsFor: 'initialize' stamp: 'nk 8/6/2003 09:02'!initialize	result := TestResult new.	passFail := 'N/A'.	details := '...'.	failures := OrderedCollection new.	errors := OrderedCollection new.	tests := self gatherTestNames.	selectedSuite := 0.	selectedFailureTest := 0.	selectedErrorTest := 0.	selectedSuites := tests collect: [:ea | true].	running := nil.	runSemaphore := Semaphore new! !!TestRunner methodsFor: 'interface opening' stamp: 'nk 8/6/2003 09:40'!buildDetailsText	detailsText _ PluggableTextMorph				on: self				text: #details				accept: nil.	detailsText hideScrollBarIndefinitely.	^detailsText! !!TestRunner methodsFor: 'interface opening' stamp: 'nk 8/6/2003 08:36'!buildErrorsList	^PluggableListMorph				on: self				list: #errorsList				selected: #selectedErrorTest				changeSelected: #debugErrorTest:.! !!TestRunner methodsFor: 'interface opening' stamp: 'nk 8/6/2003 08:36'!buildFailuresList	^PluggableListMorph				on: self				list: #failuresList				selected: #selectedFailureTest				changeSelected: #debugFailureTest:.! !!TestRunner methodsFor: 'interface opening' stamp: 'sbw 9/26/2002 20:04'!buildFilterButton	| filterButton |	filterButton _ PluggableButtonMorph				on: self				getState: nil				action: #setFilter				label: #filterButtonLabel.	filterButton 		 hResizing: #spaceFill;		 vResizing: #spaceFill;		 useRoundedCorners.	filterButton onColor: self runButtonColor offColor: self runButtonColor.	^ filterButton! !!TestRunner methodsFor: 'interface opening' stamp: 'sbw 9/26/2002 19:54'!buildLowerPanes	| failuresList errorsList row tHeight divider |	row _ AlignmentMorph newColumn hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 1;				 borderColor: Color black;				 layoutPolicy: ProportionalLayout new.	self buildPassFailText.	self buildDetailsText.	self buildTestsList.	failuresList _ self buildFailuresList.	errorsList _ self buildErrorsList.	tHeight _ 26.	divider _ Array new: 3.	1		to: divider size		do: [:index | 			divider at: index put: BorderedSubpaneDividerMorph forBottomEdge.			Preferences alternativeWindowLook				ifTrue: [(divider at: index) extent: 4 @ 4;						 color: Color transparent;						 borderColor: #raised;						 borderWidth: 2]].	row		addMorph: (passFailText borderWidth: 0)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (0 @ 0 corner: 0 @ tHeight - 1)).	row		addMorph: (divider at: 1)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (0 @ (tHeight - 1) corner: 0 @ tHeight)).	row		addMorph: (detailsText borderWidth: 0)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (0 @ tHeight corner: 0 @ (2 * tHeight - 1))).	row		addMorph: (divider at: 2)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (0 @ (2 * tHeight - 1) corner: 0 @ (2 * tHeight))).	row		addMorph: (failuresList borderWidth: 0)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0.6)				offsets: (0 @ (2 * tHeight) corner: 0 @ -1)).	row		addMorph: (divider at: 3)		fullFrame: (LayoutFrame				fractions: (0 @ 0.6 corner: 1 @ 0.6)				offsets: (0 @ - 1 corner: 0 @ 0)).	row		addMorph: (errorsList borderWidth: 0)		fullFrame: (LayoutFrame				fractions: (0 @ 0.6 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ 0)).	^ row! !!TestRunner methodsFor: 'interface opening' stamp: 'nk 8/6/2003 09:39'!buildPassFailText	passFailText _ PluggableTextMorph				on: self				text: #passFail				accept: nil.	passFailText hideScrollBarIndefinitely.	^ passFailText! !!TestRunner methodsFor: 'interface opening' stamp: 'sbw 9/26/2002 19:28'!buildRefreshButton	| refreshButton |	refreshButton _ PluggableButtonMorph				on: self				getState: #refreshButtonState				action: #refreshTests				label: #refreshButtonLabel.	refreshButton color: self runButtonColor;		 hResizing: #spaceFill;		 vResizing: #spaceFill;		 useRoundedCorners.	refreshButton onColor: self runButtonColor offColor: self runButtonColor.	^ refreshButton! !!TestRunner methodsFor: 'interface opening' stamp: 'sbw 9/26/2002 19:28'!buildRunButton	| runButton |	runButton _ PluggableButtonMorph				on: self				getState: #runButtonState				action: #runTests				label: #runButtonLabel.	runButton color: self runButtonColor;		 hResizing: #spaceFill;		 vResizing: #spaceFill;		 useRoundedCorners.	runButton onColor: self runButtonColor offColor: self runButtonOffColor.	^ runButton! !!TestRunner methodsFor: 'interface opening' stamp: 'sbw 9/26/2002 19:28'!buildRunOneButton	| runOneButton |	runOneButton _ PluggableButtonMorph				on: self				getState: #runButtonState				action: #runOneTest				label: #runOneButtonLabel.	runOneButton color: self runButtonColor;		 hResizing: #spaceFill;		 vResizing: #spaceFill;		 useRoundedCorners.	runOneButton onColor: self runButtonColor offColor: self runButtonOffColor.	^ runOneButton! !!TestRunner methodsFor: 'interface opening' stamp: 'sbw 9/26/2002 19:27'!buildStopButton	| stopButton |	stopButton _ PluggableButtonMorph				on: self				getState: #stopButtonState				action: #terminateRun				label: #stopButtonLabel.	stopButton color: self runButtonColor;		hResizing: #spaceFill; vResizing: #spaceFill;		 useRoundedCorners.	stopButton onColor: self runButtonColor offColor: self runButtonOffColor.	^ stopButton! !!TestRunner methodsFor: 'interface opening' stamp: 'nk 12/19/2002 09:15'!buildTestsList	| column offset buttonRow |	column _ AlignmentMorph newColumn hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 0;				 borderColor: Color black;				color: Color transparent;				 layoutPolicy: ProportionalLayout new.	testsList _ PluggableListMorphOfMany				on: self				list: #tests				primarySelection: #selectedSuite				changePrimarySelection: #selectedSuite:				listSelection: #listSelectionAt:				changeListSelection: #listSelectionAt:put:				menu: #listMenu:shifted:.	testsList autoDeselect: false.	offset _ 0.	self wantsOptionalButtons		ifTrue: [offset _ TextStyle default lineGrid + 14 ].	column		addMorph: testsList		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ offset negated)).	self wantsOptionalButtons		ifTrue: [buttonRow _ self optionalButtonRow.			buttonRow				color: (Display depth <= 8						ifTrue: [Color transparent]						ifFalse: [Color gray alpha: 0.2]);				 borderWidth: 0.			Preferences alternativeWindowLook				ifTrue: [buttonRow color: Color transparent.					buttonRow						submorphsDo: [:m | m borderWidth: 1;								 borderColor: #raised]].			column				addMorph: buttonRow				fullFrame: (LayoutFrame						fractions: (0 @ 1 corner: 1 @ 1)						offsets: (0 @ (offset - 1) negated corner: 0 @ 0))].	^ column! !!TestRunner methodsFor: 'interface opening' stamp: 'nk 12/19/2002 09:11'!buildUpperControls	| refreshButton filterButton stopButton runOneButton runButton row bWidth listsMorph |	row _ BorderedMorph new				hResizing: #spaceFill;				 vResizing: #spaceFill;				 borderWidth: 1;				 borderColor: Color black;				 layoutPolicy: ProportionalLayout new.	row		color: (Display depth <= 8				ifTrue: [Color transparent]				ifFalse: [Color gray alpha: 0.2]);		 clipSubmorphs: true;		 cellInset: 3;		 borderWidth: 0.	refreshButton _ self buildRefreshButton.	filterButton _ self buildFilterButton.	stopButton _ self buildStopButton.	runOneButton _ self buildRunOneButton.	runButton _ self buildRunButton.	listsMorph _ self buildTestsList.	bWidth _ 90.	row		addMorph: refreshButton		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 0 @ 0.33)				offsets: (4 @ 2 corner: bWidth - 4 @ -2)).	row		addMorph: filterButton		fullFrame: (LayoutFrame				fractions: (0 @ 0.33 corner: 0 @ 0.66)				offsets: (4 @ 2 corner: bWidth - 4 @ -2)).	row		addMorph: stopButton		fullFrame: (LayoutFrame				fractions: (0 @ 0.66 corner: 0 @ 1)				offsets: (4 @ 2 corner: bWidth - 4 @ -2)).	row		addMorph: listsMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (bWidth  @ 0 corner: bWidth negated @ 0)).	row		addMorph: runOneButton		fullFrame: (LayoutFrame				fractions: (1 @ 0 corner: 1 @ 0.5)				offsets: (bWidth negated + 4 @ 2 corner: -4 @ -2)).	row		addMorph: runButton		fullFrame: (LayoutFrame				fractions: (1 @ 0.5 corner: 1 @ 1)				offsets: (bWidth negated + 4 @ 2 corner: -4 @ -2)).	Preferences alternativeWindowLook		ifTrue: [row color: Color transparent.			row				submorphsDo: [:m | m borderWidth: 2;						 borderColor: #raised]].	^ row! !!TestRunner methodsFor: 'interface opening' stamp: 'nk 8/6/2003 09:57'!morphicWindow	"TestRunner new openAsMorph"	| upperRow lowerPanes fracYRatio divider window |	window _ SystemWindow labelled: self windowLabel.	window model: self.	upperRow _ self buildUpperControls.	lowerPanes _ self buildLowerPanes.	fracYRatio _ 0.25.	window		addMorph: upperRow		fullFrame: (LayoutFrame fractions: (0 @ 0 extent: 1 @ fracYRatio) offsets: (0@0 corner: 0@0)).	divider _ BorderedSubpaneDividerMorph forBottomEdge.	Preferences alternativeWindowLook		ifTrue: [divider hResizing: #spaceFill;				 color: Color transparent;				 borderColor: #raised;				 borderWidth: 1].	window		addMorph: divider		fullFrame: (LayoutFrame				fractions: (0 @ fracYRatio corner: 1 @ fracYRatio)				offsets: (0 @ 0 corner: 0 @ 2)).	window		addMorph: lowerPanes		fullFrame: (LayoutFrame fractions: (0 @ fracYRatio extent: 1 @ (1 - fracYRatio)) offsets: (0@0 corner: 0@0)).	self refreshWindow.	window extent: 460 @ 400.	^window! !!TestRunner methodsFor: 'interface opening' stamp: 'nk 4/21/2002 16:49'!openAsMorph	"TestRunner new openAsMorph"	^self morphicWindow openInWorld.! !!TestRunner methodsFor: 'interface opening' stamp: 'sbw 9/26/2002 22:22'!optionalButtonRow	| row btn |	row _ AlignmentMorph newRow.	row beSticky.	row hResizing: #spaceFill.	row wrapCentering: #center;		 cellPositioning: #leftCenter.	row clipSubmorphs: true.	row cellInset: 3.	self optionalButtonPairs		do: [:pair | 		btn _ PluggableButtonMorph on: self getState: nil action: pair second.		btn useRoundedCorners; hResizing: #spaceFill; vResizing: #spaceFill; onColor: Color transparent offColor: Color transparent;		label: pair first.		row addMorphBack: btn		].	^ row! !!TestRunner methodsFor: 'interface opening' stamp: 'nk 8/6/2003 10:54'!removeProgressWatcher	progress ifNil: [ ^self ].	progress delete.	self dependents first updatePanesFromSubmorphs.	progress _ nil! !!TestRunner methodsFor: 'interface opening' stamp: 'nk 4/21/2002 19:08'!updateProgressWatcher: text	progress subLabel:  text.	progress done: (completedTests / totalTests) asFloat.! !!TestRunner methodsFor: 'interface opening' stamp: 'sbw 9/26/2002 22:10'!wantsOptionalButtons	^ Preferences optionalButtons! !!TestRunner methodsFor: 'menus' stamp: 'nk 4/22/2002 10:50'!addModelItemsToWindowMenu: aMenu	aMenu addLine.	self listMenu: aMenu shifted: false.	aMenu addLine.	aMenu add: 'log to Transcript' target: self selector: #showResult.	^aMenu.! !!TestRunner methodsFor: 'menus' stamp: 'nk 8/6/2003 10:13'!browse: aClass	Browser fullOnClass: aClass selector: nil.! !!TestRunner methodsFor: 'menus' stamp: 'nk 12/19/2002 08:41'!deselectAll	selectedSuites _ tests collect: [ :ea | false ].	selectedSuite _ 0.      self changed: #allSelections. ! !!TestRunner methodsFor: 'menus' stamp: 'nk 8/6/2003 09:08'!installProgressWatcher	| win host |	win _ self dependents first.	host _ win submorphs first.	progress _ ProgressMorph label: 'Test progress'.	progress		borderWidth: 0;		position: host position;		extent: host extent;		color: Color transparent;		wrapCentering: #center;		hResizing: #spaceFill;		vResizing: #spaceFill.	win		addMorph: progress 		frame: (0.0 @ 0.7 extent: 1.0 @ 0.3).! !!TestRunner methodsFor: 'menus' stamp: 'nk 4/25/2002 14:05'!listMenu: aMenu shifted: shiftState	aMenu title: 'Test Cases'.	aMenu add: 'select all' target: self selector: #selectAll.	aMenu add: 'deselect all' target: self selector: #deselectAll.	aMenu add: 'toggle selections' target: self selector: #toggleSelections.	aMenu add: 'filter' target: self selector: #setFilter.	running ifNotNil: [		aMenu add: 'stop' target: self selector: #terminateRun		].	selectedSuite > 0 ifTrue: [ | cls |		cls _ (tests at: selectedSuite ifAbsent: ['']) copyUpTo: Character space.		cls _ cls asSymbol.		cls _ (Smalltalk at: cls ifAbsent: []).		cls ifNotNil: [ | mtc |			aMenu addLine.			aMenu add: 'browse' target: self selector: #browse: argument: cls.			mtc _ Smalltalk at: #MorphicTestCase ifAbsent: [ ].			(mtc notNil and: [ cls inheritsFrom: mtc ]) ifTrue: [				aMenu add: 'record interaction' target: self selector: #recordInteractionFor: argument: cls.			].		].	].	shiftState ifTrue: [		aMenu addLine.		testsList addCustomMenuItems: aMenu hand: ActiveHand.	].	^aMenu! !!TestRunner methodsFor: 'menus' stamp: 'sbw 9/26/2002 22:18'!optionalButtonPairs	^#(#('select all' #selectAll) #('deselect all' #deselectAll) #('toggle selections' #toggleSelections))! !!TestRunner methodsFor: 'menus' stamp: 'nk 4/21/2002 12:17'!perform: aSelector orSendTo: otherTarget	^((self respondsTo: aSelector) ifTrue: [ self ] ifFalse: [ otherTarget ]) perform: aSelector! !!TestRunner methodsFor: 'menus' stamp: 'nk 12/19/2002 08:42'!selectAll	| sel |	sel _ self selectedSuite.	selectedSuites _ selectedSuites collect: [ :ea | true ].	sel isZero ifTrue: [ self selectedSuite: 1 ]		ifFalse: [ self changed: #allSelections ].! !!TestRunner methodsFor: 'menus' stamp: 'nk 12/19/2002 08:42'!setFilter	filter _ FillInTheBlank request: 'Pattern for added test cases (#* OK)' initialAnswer: '*'.	(filter endsWith: '*') ifFalse: [ filter _ filter, '*' ].	selectedSuites _ (tests asOrderedCollection with: selectedSuites collect: [ :ea :sel |		sel or: [ filter match: ea asString ]	]).	selectedSuite _ selectedSuites indexOf: true ifAbsent: [0].	self changed: #allSelections.! !!TestRunner methodsFor: 'menus' stamp: 'nk 4/21/2002 17:53'!terminateRun	running ifNotNil: [ running terminate. running _ nil ].! !!TestRunner methodsFor: 'menus' stamp: 'nk 12/19/2002 08:42'!toggleSelections	selectedSuites _ selectedSuites collect: [ :ea | ea not ].	selectedSuite _ selectedSuites indexOf: true ifAbsent: [0].	self changed: #allSelections .! !!TestRunner methodsFor: 'processing' stamp: 'nk 8/6/2003 10:51'!addTestsFor: testName toSuite: suite 	| cls |	(testName indexOf: $() > 0		ifTrue: [ Smalltalk at: #TestViaMethodCall ifPresent: [ :tvmc | tvmc addTestsFor: testName toSuite: suite] ]		ifFalse: [cls _ testName asSymbol sunitAsClass.			cls isAbstract				ifTrue: [cls allSubclasses						do: [:each | each isAbstract								ifFalse: [each addToSuiteFromSelectors: suite]]]				ifFalse: [cls addToSuiteFromSelectors: suite]].	^ suite! !!TestRunner methodsFor: 'processing' stamp: 'rew 8/23/2000 20:44'!debugErrorTest: anInteger        selectedErrorTest _ anInteger.  "added rew"        selectedFailureTest _ 0.                        "added rew"        self changed: #selectedFailureTest.             "added rew"        self changed: #selectedErrorTest.               "added rew"        (anInteger ~= 0)                ifTrue: [(result errors at: anInteger) debug]! !!TestRunner methodsFor: 'processing' stamp: 'jp 3/17/2003 10:46'!debugFailureTest: anInteger        (anInteger ~= 0)                ifTrue: [(self failures at: anInteger) debugAsFailure].        selectedFailureTest _ anInteger.        selectedErrorTest _ 0.        self changed: #selectedErrorTest.        self changed: #selectedFailureTest.! !!TestRunner methodsFor: 'processing' stamp: 'SSS 7/5/2000 13:59'!debugTest! !!TestRunner methodsFor: 'processing' stamp: 'nk 4/22/2002 07:40'!refreshTests	| preselected |         selectedSuite _ 0.        selectedFailureTest _ 0.        selectedErrorTest _ 0.	preselected _ Set new.	tests with: selectedSuites do: [ :t :f | f ifTrue: [ preselected add: t ]].       tests _ self gatherTestNames.	selectedSuites _ tests collect: [ :ea | preselected includes: ea ].        self changed: #tests.        self changed: #selectedFailureTest.             "added rew"        self changed: #selectedErrorTest.               "added rew"        self changed: #selectedSuite.        self refreshWindow! !!TestRunner methodsFor: 'processing' stamp: 'nk 4/21/2002 20:41'!runOneTest	| testSuite |	Cursor execute showWhile: [		self runWindow.		selectedSuite isZero ifTrue: [ ^ self displayPassFail: 'No Test Suite Selected' ].		testSuite _  TestSuite new name: 'TestRunner Suite'.		self addTestsFor: (tests at: selectedSuite) toSuite: testSuite.		self runSuite: testSuite.	]! !!TestRunner methodsFor: 'processing' stamp: 'nk 12/8/2002 11:46'!runSuite: suite	running ifNotNil: [ ^self inform: 'already running' ].	suite addDependent: self.	totalTests _ suite tests size.	completedTests _ 0.	self installProgressWatcher.	runSemaphore initSignals.	running _ [            [ result _ suite run ]	            ensure: [		            running _ nil.				suite removeDependent: self.				runSemaphore signal.				WorldState addDeferredUIMessage: [					self removeProgressWatcher.					self updateWindow: result.			      	self changed: #runTests.			      	self changed: #runOneTest.				].	            ].     ] newProcess.	self runWindow.      self changed: #runTests.      self changed: #runOneTest.      running	      priority: Processor userBackgroundPriority;	      resume.! !!TestRunner methodsFor: 'processing' stamp: 'nk 4/21/2002 20:41'!runTests	| suite |	Cursor execute showWhile: [		suite _ TestSuite new name: 'TestRunner Suite'.		self selectedTests do: [ :ea | self addTestsFor: ea toSuite: suite ].		self runSuite: suite.	]! !!TestRunner methodsFor: 'processing' stamp: 'rew 5/15/2000 21:08'!selectedErrorTest        ^selectedErrorTest! !!TestRunner methodsFor: 'processing' stamp: 'rew 8/23/2000 21:01'!selectedFailureTest        ^selectedFailureTest! !!TestRunner methodsFor: 'processing' stamp: 'rew 5/15/2000 21:08'!selectedSuite        ^selectedSuite! !!TestRunner methodsFor: 'processing' stamp: 'nk 12/15/2002 09:46'!selectedSuite: anInteger	anInteger > 0 ifTrue: [ | selected |		selected _ selectedSuite ~= anInteger.		selectedSuites at: anInteger put: selected.	] ifFalse: [		"selectedSuite > 0 ifTrue: [ selectedSuites at: selectedSuite put: false ]."	].	selectedSuite _ anInteger.	selectedFailureTest _ 0.	selectedErrorTest _ 0.	self changed: #selectedFailureTest.             "added rew"	self changed: #selectedErrorTest.               "added rew" 	self changed: #selectedSuite.	self changed: #allSelections.! !!TestRunner methodsFor: 'recording' stamp: 'nk 4/22/2002 19:49'!recordInteractionFor: aClass	aClass recordInteraction.! !!TestRunner methodsFor: 'test processing' stamp: 'jp 3/17/2003 14:00'!errorLog	^SUnitNameResolver defaultLogDevice! !!TestRunner methodsFor: 'test processing' stamp: 'jp 3/17/2003 14:00'!showResult	self errorLog cr;cr; show: '==== SUnit ======== Start ===='.	self		showResultSummary;		showResultDefects.	self errorLog cr; show: '==== SUnit ========== End ===='; cr.! !!TestRunner methodsFor: 'test processing' stamp: 'jp 3/17/2003 14:00'!showResultDefects	(self result failureCount > 0)		ifTrue: [			self errorLog cr; show: '---- SUnit ----- Failures ----'.			self result failures do: [:failure |				self errorLog crtab; show: failure printString]].	(self result errorCount > 0)		ifTrue: [			self errorLog cr; show: '---- SUnit ------- Errors ----'.			self result errors do: [:error |				self errorLog crtab; show: error printString]].! !!TestRunner methodsFor: 'test processing' stamp: 'nk 4/22/2002 10:54'!showResultSummary	| message summary |	message := (self result runCount = self result correctCount)		ifTrue: [self successMessage]		ifFalse: [self failureMessage].	Transcript crtab; show: message.	summary :=		self result runCount printString, ' run, ',		self result failureCount printString, ' failed, ',		self result errorCount printString, ' errors'.	Transcript crtab; show: summary.! !!TestRunner methodsFor: 'updating' stamp: 'Sames 4/11/2000 17:38'!displayDetails: aString        details := aString.        self changed: #details! !!TestRunner methodsFor: 'updating' stamp: 'jp 3/17/2003 13:49'!displayErrors: anOrderedCollection        errors := anOrderedCollection.        self changed: #errorsList! !!TestRunner methodsFor: 'updating' stamp: 'jp 3/17/2003 10:51'!displayFailures: anOrderedCollection        failures := anOrderedCollection.        self changed: #failuresList! !!TestRunner methodsFor: 'updating' stamp: 'Sames 4/11/2000 17:36'!displayPassFail: aString        passFail := aString.        self changed: #passFail! !!TestRunner methodsFor: 'updating' stamp: 'nk 8/6/2003 09:13'!refreshWindow	| pc |	pc _ self defaultBackgroundColor.	passFailText isMorph		ifTrue: [passFailText color: pc.			detailsText color: pc]		ifFalse: [passFailText insideColor: pc.			detailsText insideColor: pc].	self updateErrors: TestResult new.	self updateFailures: TestResult new.	self displayPassFail: 'N/A'.	self displayDetails: '...'! !!TestRunner methodsFor: 'updating' stamp: 'nk 8/6/2003 09:07'!runWindow	| pc |	pc _ self defaultBackgroundColor.	passFailText isMorph		ifTrue: [passFailText color: pc.			detailsText color: pc]		ifFalse: [passFailText insideColor: pc.			detailsText insideColor: pc].	self updateErrors: TestResult new.	self updateFailures: TestResult new.	self displayPassFail: 'Running...'.	self displayDetails: '...'! !!TestRunner methodsFor: 'updating' stamp: 'nk 8/6/2003 09:15'!update: aParameter 	"updates come in from another thread"	(aParameter isKindOf: TestCase)		ifTrue: [WorldState				addDeferredUIMessage: [completedTests _ completedTests + 1.					self updateProgressWatcher: aParameter printString]]		ifFalse: [ super update: aParameter ]! !!TestRunner methodsFor: 'updating' stamp: 'nk 8/6/2003 09:15'!updateDetails: aTestResult 	self displayDetails: aTestResult printString			, (self timeSinceLastPassAsString: aTestResult).	aTestResult hasPassed		ifTrue: [lastPass _ Time now]! !!TestRunner methodsFor: 'updating' stamp: 'jp 3/17/2003 13:49'!updateErrors: aTestResult        self displayErrors: aTestResult errors! !!TestRunner methodsFor: 'updating' stamp: 'jp 3/17/2003 10:52'!updateFailures: aTestResult        self displayFailures: aTestResult failures asOrderedCollection! !!TestRunner methodsFor: 'updating' stamp: 'Sames 4/12/2000 18:57'!updatePartColors: aColor        passFailText isMorph                ifTrue:                        [passFailText color: aColor.                        detailsText color: aColor]                ifFalse:                        [passFailText insideColor: aColor.                        detailsText insideColor: aColor]! !!TestRunner methodsFor: 'updating' stamp: 'Sames 4/11/2000 18:27'!updatePassFail: aTestResult        | message |        message _ aTestResult hasPassed                                ifTrue: ['Pass']                                ifFalse: ['Fail'].        self displayPassFail: message! !!TestRunner methodsFor: 'updating' stamp: 'Sames 4/12/2000 18:54'!updateWindow: aTestResult        aTestResult errors size + aTestResult failures size = 0                ifTrue: [self updatePartColors: self passColor]                ifFalse: [aTestResult errors size > 0                                ifTrue: [self updatePartColors: selferrorColor]                                ifFalse: [self updatePartColors: selffailColor]].        self updatePassFail: aTestResult.        self updateDetails: aTestResult.        self updateFailures: aTestResult.        self updateErrors: aTestResult! !!TestRunner class methodsFor: 'class initialization' stamp: 'nk 8/6/2003 10:21'!initialize	"TestRunner initialize"	self registerInFlapsRegistry.	(Preferences windowColorFor: #TestRunner) = Color white		ifTrue: [ Preferences setWindowColorFor: #TestRunner to: (Color colorFrom: self windowColorSpecification pastelColor) ].	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: [		TheWorldMenu unregisterOpenCommand: 'Test Runner'.		TheWorldMenu registerOpenCommand: {'SUnit Test Runner'. {self. #open}}].
! !!TestRunner class methodsFor: 'class initialization' stamp: 'nk 8/6/2003 09:51'!unload	 (TheWorldMenu respondsTo: #registerOpenCommand:)
         ifTrue: [TheWorldMenu unregisterOpenCommand: 'SUnit Test Runner'].
! !!TestRunner class methodsFor: 'instance creation' stamp: 'nk 8/6/2003 10:38'!new	^ super new initialize! !!TestRunner class methodsFor: 'instance creation' stamp: 'nk 8/6/2003 09:42'!open	"TestRunner open"	^self new openAsMorph! !!TestRunner class methodsFor: 'instance creation' stamp: 'nk 8/6/2003 10:40'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec		classSymbol: self name		wording: 'TestRunner'		brightColor: (Color r: 0.650 g: 0.753 b: 0.976)		pastelColor: (Color r: 0.780 g: 0.860 b: 1.0)		helpMessage: 'The Camp Smalltalk SUnit test tool'! !!TestRunner class methodsFor: 'new-morph participation' stamp: 'nk 4/26/2002 08:57'!initializedInstance	^self new morphicWindow extent: 400@400! !!TestRunner class methodsFor: 'new-morph participation' stamp: 'nk 4/26/2002 08:57'!newStandAlone	^self new morphicWindow! !!TestRunner class methodsFor: 'new-morph participation' stamp: 'nk 8/6/2003 09:54'!prototypicalToolWindow	^self new morphicWindow! !!TestRunner class methodsFor: 'new-morph participation' stamp: 'nk 8/6/2003 10:56'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | (cl respondsTo: #registerQuad:forFlapNamed:)				ifTrue: [cl registerQuad: #(#TestRunner #prototypicalToolWindow 'Test Runner' 'The SUnit Test Runner' ) forFlapNamed: 'Tools']]! !!TestRunner class methodsFor: 'parts bin' stamp: 'nk 8/6/2003 09:47'!descriptionForPartsBin	^self partName: 'Test Runner'		categories: #(Tools)		documentation: 'SUnit Test UI'! !TestRunner initialize!!TestRunner class reorganize!('class initialization' initialize unload)('instance creation' new open windowColorSpecification)('new-morph participation' initializedInstance newStandAlone prototypicalToolWindow registerInFlapsRegistry)('parts bin' descriptionForPartsBin)('window color')!TestRunner removeSelector: #resetColor!Model subclass: #TestRunner	instanceVariableNames: 'result details passFail failures errors tests passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite filter selectedSuites running runSemaphore completedTests totalTests progress '	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-UI'!!TestRunner reorganize!('accessing' details errors errorsList failures failuresList formatTime: listSelectionAt: listSelectionAt:put: passFail result runSemaphore selectedTests suite tests timeSinceLastPassAsString:)('constants' debugButtonLabel debugState errorColor failColor failureMessage filterButtonLabel passColor refreshButtonLabel refreshButtonState runButtonColor runButtonLabel runButtonOffColor runButtonState runOneButtonLabel stopButtonLabel stopButtonState successMessage windowLabel)('initialize' gatherTestNames initialize)('interface opening' buildDetailsText buildErrorsList buildFailuresList buildFilterButton buildLowerPanes buildPassFailText buildRefreshButton buildRunButton buildRunOneButton buildStopButton buildTestsList buildUpperControls morphicWindow openAsMorph optionalButtonRow removeProgressWatcher updateProgressWatcher: wantsOptionalButtons)('menus' addModelItemsToWindowMenu: browse: deselectAll installProgressWatcher listMenu:shifted: optionalButtonPairs perform:orSendTo: selectAll setFilter terminateRun toggleSelections)('processing' addTestsFor:toSuite: debugErrorTest: debugFailureTest: debugTest refreshTests runOneTest runSuite: runTests selectedErrorTest selectedFailureTest selectedSuite selectedSuite:)('recording' recordInteractionFor:)('test processing' errorLog showResult showResultDefects showResultSummary)('updating' displayDetails: displayErrors: displayFailures: displayPassFail: refreshWindow runWindow update: updateDetails: updateErrors: updateFailures: updatePartColors: updatePassFail: updateWindow:)!