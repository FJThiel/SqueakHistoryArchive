'From Squeak 2.2 of Sept 23, 1998 on 7 October 1998 at 1:06:06 pm'!"Change Set:		TwoFixes-arDate:			7 October 1998Author:			Andreas RaabFix1: Clear all RootBits when the image is loaded.Fix2: Correct a 32bit shift in BBSimulation>>alphaBlendConst:with:paint:"!!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 10/7/1998 13:04'!alphaBlendConst: sourceWord with: destinationWord paintMode: paintMode	"Blend sourceWord with destinationWord using a constant alpha.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	The blend produced is alpha*source + (1.0-alpha)*dest, with the	computation being performed independently on each color component.	This function could eventually blend into any depth destination,	using the same color averaging and mapping as warpBlt.	paintMode = true means do nothing if the source pixel value is zero."	"This first implementation works with dest depths of 16 and 32 bits only.	Normal color mapping will allow sources of lower depths in this case,	and results can be mapped directly by truncation, so no extra color maps are needed.	To allow storing into any depth will require subsequent addition of two other	colormaps, as is the case with WarpBlt."	| pixMask destShifted sourceShifted destPixVal rgbMask sourcePixVal unAlpha result pixBlend shift blend maskShifted bitsPerColor |	self inline: false.	destPixSize < 16 ifTrue: [^ destinationWord "no-op"].	unAlpha _ 255 - sourceAlpha.	"Moved into next state for checking degenerate shifts -- ar 10/4/1998"	"pixMask _ (1<<destPixSize) - 1."	destPixSize = 16 ifTrue: [		bitsPerColor _ 5.		pixMask _ 65535.	] ifFalse: [		bitsPerColor _ 8.		pixMask _ -1.	].	rgbMask _ (1<<bitsPerColor) - 1.	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	result _ destinationWord.	1 to: pixPerWord do:		[:j |		sourcePixVal _ sourceShifted bitAnd: pixMask.		((maskShifted bitAnd: pixMask) = 0  "no effect if outside of dest rectangle"			or: [paintMode & (sourcePixVal = 0)  "or painting a transparent pixel"])		ifFalse:			[destPixVal _ destShifted bitAnd: pixMask.			pixBlend _ 0.			1 to: 3 do:				[:i | shift _ (i-1)*bitsPerColor.				blend _ (((sourcePixVal>>shift bitAnd: rgbMask) * sourceAlpha)							+ ((destPixVal>>shift bitAnd: rgbMask) * unAlpha))					 	+ 254 // 255 bitAnd: rgbMask.				pixBlend _ pixBlend bitOr: blend<<shift].			destPixSize = 16				ifTrue: [result _ (result bitAnd: (pixMask << (j-1*16)) bitInvert32)									bitOr: pixBlend << (j-1*16)]				ifFalse: [result _ pixBlend]].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ result! !!ObjectMemory methodsFor: 'initialization' stamp: 'ar 10/7/1998 13:01'!adjustAllOopsBy: bytesToShift	"Adjust all oop references by the given number of bytes. This is done just after reading in an image when the new base address of the object heap is different from the base address in the image."	"ar 10/7/1998 - Clear the RootBit of all objects"	| oop last header |	bytesToShift = 0 ifTrue: [ ^ nil ].	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			(self isIntegerObject: oop) ifFalse:[				header _ self longAt: oop.				self longAt: oop put: (header bitAnd: AllButRootBit)].			self adjustFieldsAndClassOf: oop by: bytesToShift. 		].		last _ oop.		oop _ self objectAfter: oop.	].! !