'From Squeak 2.3 beta of Nov 25, 1998 on 13 December 1998 at 3:02:21 pm'!"Change Set:		jhmFasterVMDate:			13 December 1998Author:			John MaloneyIncludes a number of changes to speedup the virtual machine:  1. conditional assemble (allows compiling without assertion checks)  2. put homeContext into a register  3. small tweaks to send code  4. move fetch of next bytecode into bytecode operations  5. change image version number but allow reading old format  6. increase the size of roots table to avoid overflows during ST-to-C translation  7. removed a few obsolete instance vars from ObjectMemory and Interpreter"!!CCodeGenerator methodsFor: 'inlining' stamp: 'jm 12/10/1998 16:18'!doInlining: inlineFlag	"Inline the bodies of all methods that are suitable for inlining."	"Modified slightly for the translator, since the first level of inlining for the interpret loop must be performed in order that the instruction implementations can easily discover their addresses."	| pass progress |	inlineFlag ifFalse: [		self inlineDispatchesInMethodNamed: #interpret localizingVars: #().		^ self].	self collectInlineList.	pass _ 0.	progress _ true.	[progress] whileTrue: [		"repeatedly attempt to inline methods until no further progress is made"		progress _ false.		('Inlining pass ', (pass _ pass + 1) printString, '...')			displayProgressAt: Sensor cursorPoint			from: 0 to: methods size			during: [:bar |				methods doWithIndex: [:m :i |					bar value: i.					(m tryToInlineMethodsIn: self)						ifTrue: [progress _ true]]]].	'Inlining bytecodes'		displayProgressAt: Sensor cursorPoint		from: 1 to: 2		during: [:bar |			self inlineDispatchesInMethodNamed: #interpret				localizingVars: #(currentBytecode localIP localSP localHomeContext localCP localTP).			bar value: 1.			self removeMethodsReferingToGlobals: #(					currentBytecode localIP localSP localHomeContext localCP localTP)				except: #interpret.			bar value: 2].! !!CCodeGenerator methodsFor: 'utilities' stamp: 'jm 11/25/1998 19:02'!nilOrBooleanConstantReceiverOf: sendNode	"Answer nil or the boolean constant that is the receiver of the given message send. Used to suppress conditional code when the condition is a translation-time constant."	| rcvr val |	rcvr _ sendNode receiver.	rcvr isConstant ifTrue: [		val _ rcvr value.		((val == true) or: [val == false]) ifTrue: [^ val]].	^ nil! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 11/25/1998 19:04'!generateIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler produces two arguments for ifFalse:, presumably	 to help with inlining later. Taking the last agument should do the correct	 thing even if your compiler is different."	| const |	const _ self nilOrBooleanConstantReceiverOf: msgNode.	const ifNotNil: [		const ifFalse: [msgNode args first emitCCodeOn: aStream level: level generator: self].		^ self].	aStream nextPutAll: 'if (!!('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ')) {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 11/25/1998 19:06'!generateIfFalseIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler reverses the argument blocks for ifFalse:ifTrue:,       presumably to help with inlining later. That is, the first argument       is the block to be evaluated if the condition is true. Squeak's compiler	  does not reverse the blocks, but you may need to fix this method if	  you wish to cross-compile using VisualWorks."	| const |	const _ self nilOrBooleanConstantReceiverOf: msgNode.	const ifNotNil: [		const			ifTrue: [msgNode args last emitCCodeOn: aStream level: level generator: self]			ifFalse: [msgNode args first emitCCodeOn: aStream level: level generator: self].		^ self].	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} else {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 11/25/1998 19:04'!generateIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| const |	const _ self nilOrBooleanConstantReceiverOf: msgNode.	const ifNotNil: [		const ifTrue: [msgNode args first emitCCodeOn: aStream level: level generator: self].		^ self].	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 11/25/1998 19:04'!generateIfTrueIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| const |	const _ self nilOrBooleanConstantReceiverOf: msgNode.	const ifNotNil: [		const			ifTrue: [msgNode args first emitCCodeOn: aStream level: level generator: self]			ifFalse: [msgNode args last emitCCodeOn: aStream level: level generator: self].		^ self].	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} else {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!ObjectMemory methodsFor: 'initialization' stamp: 'jm 11/25/1998 16:35'!initializeMemoryFirstFree: firstFree 	"Initialize endOfMemory to the top of oop storage space, reserving some space for forwarding blocks, and create the freeBlock from which space is allocated. Also create a fake free chunk at endOfMemory to act as a sentinal for memory scans."	"Note: The amount of space reserved for forwarding blocks should be chosen to ensure that incremental compactions can usually be done in a single pass. However, there should be enough forwarding blocks so a full compaction can be done in a reasonable number of passes, say ten. (A full compaction requires N object-moving passes, where N = number of non-garbage objects / number of forwarding blocks)."	| fwdBlockBytes |	"reserve space for forwarding blocks"	fwdBlockBytes _ MinimumForwardTableBytes.	(memoryLimit - fwdBlockBytes) >= (firstFree + BaseHeaderSize) ifFalse: [		"reserve enough space for a minimal free block of BaseHeaderSize bytes"		fwdBlockBytes _ memoryLimit - (firstFree + BaseHeaderSize).	].	"set endOfMemory and initialize freeBlock"	endOfMemory _ memoryLimit - fwdBlockBytes.	freeBlock _ firstFree.	self setSizeOfFree: freeBlock to: (endOfMemory - firstFree).  "bytes available for oops"	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	DoAssertionChecks ifTrue: [		((freeBlock < endOfMemory) and: [endOfMemory < memoryLimit])			ifFalse: [ self error: 'error in free space computation' ].			(self oopFromChunk: endOfMemory) = endOfMemory			ifFalse: [ self error: 'header format must have changed' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'free block not properly initialized' ].	].! !!ObjectMemory methodsFor: 'initialization' stamp: 'jm 12/6/1998 17:26'!initializeObjectMemory: bytesToShift	"Initialize object memory variables at startup time. Assume endOfMemory is initially set (by the image-reading code) to the end of the last object in the image. Initialization redefines endOfMemory to be the end of the object allocation area based on the total available memory, but reserving some space for forwarding blocks."	"Assume: image reader initializes the following variables:		memory		endOfMemory		memoryLimit		specialObjectsOop		lastHash	"	self inline: false.	"set the start of the young object space"	youngStart _ endOfMemory.	self initializeMemoryFirstFree: endOfMemory.		"initializes endOfMemory, freeBlock"	"image may be at a different address; adjust oops for new location"	self adjustAllOopsBy: bytesToShift.	specialObjectsOop _ specialObjectsOop + bytesToShift.	"heavily used special objects"	nilObj	_ self splObj: NilObject.	falseObj	_ self splObj: FalseObject.	trueObj	_ self splObj: TrueObject.	rootTableCount _ 0.	child _ 0.	field _ 0.	parentField _ 0.	freeContexts _ NilContext.	allocationCount _ 0.	lowSpaceThreshold _ 0.	signalLowSpace _ false.	compStart _ 0.	compEnd _ 0.	fwdTableNext _ 0.	fwdTableLast _ 0.	remapBufferCount _ 0.	allocationsBetweenGCs _ 4000.  "do incremental GC after this many allocations"	tenuringThreshold _ 2000.  "tenure all suriving objects if count is over this threshold"	"garbage collection statistics"	statFullGCs _ 0.	statFullGCMSecs _ 0.	statIncrGCs _ 0.	statIncrGCMSecs _ 0.	statTenures _ 0.	statRootTableOverflows _ 0.	displayBits _ 0.  "support for the Acorn VM; ignored if zero"! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'jm 12/6/1998 17:12'!instantiateClass: classPointer indexableSize: size	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj sizeHiBits |"	NOTE: This method supports the backward-compatible split instSize field of the	class format word.  The sizeHiBits will go away and other shifts change by 2	when the split fields get merged in an (incompatible) image change."	self inline: false.	DoAssertionChecks ifTrue: [		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ]].	hash _ self newObjectHash.	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"	sizeHiBits _ (header1 bitAnd: 16r60000) >> 9.	header1 _ (header1 bitAnd: 16r1FFFF) bitOr: ((hash << HashBitsOffset) bitAnd: HashBits).	header2 _ classPointer.	header3 _ 0.	cClass _ header1 bitAnd: CompactClassMask. "compact class field from format word"	byteSize _ (header1 bitAnd: SizeMask) + sizeHiBits. "size in bytes -- low 2 bits are 0"	format _ (header1 >> 8) bitAnd: 16rF.	format < 8 ifTrue: [		"Bitmaps and Arrays"		inc _ size * 4.	] ifFalse: [		"Strings and Methods"		inc _ (size + 3) bitAnd: AllButTypeMask. "round up"		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"		"low bits of byte size go in format field"		header1 _ header1 bitOr: (binc << 8).	].	(byteSize + inc) > 255 ifTrue: [		"requires size header word"		header3 _ byteSize + inc.		header1 _ header1 - (byteSize bitAnd: 16rFF).  "Clear qsize field"	] ifFalse: [		header1 _ header1 + inc.	].	byteSize _ byteSize + inc.	header3 > 0 ifTrue: [		"requires full header"		hdrSize _ 3.	] ifFalse: [		cClass = 0			ifTrue: [ hdrSize _ 2 ]			ifFalse: [ hdrSize _ 1 ].	].	format <= 4  "if pointers, fill with nil oop"		ifTrue: [ fillWord _ nilObj ]		ifFalse: [ fillWord _ 0 ].	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 doFill: true with: fillWord.	^ newObj! !!ObjectMemory methodsFor: 'object enumeration' stamp: 'jm 11/25/1998 16:34'!objectAfter: oop	"Return the object or free chunk immediately following the given object or free chunk in memory. Return endOfMemory when enumeration is complete."	| sz |	self inline: true.	DoAssertionChecks ifTrue: [		oop >= endOfMemory ifTrue: [ self error: 'no objects after the end of memory' ].	].	(self isFreeObject: oop)		ifTrue: [ sz _ self sizeOfFree: oop ]		ifFalse: [ sz _ self sizeBitsOf: oop ].	^ self oopFromChunk: (oop + sz)! !!ObjectMemory methodsFor: 'allocation' stamp: 'jm 12/6/1998 17:12'!allocate: byteSize headerSize: hdrSize h1: baseHeader h2: classOop h3: extendedSize doFill: doFill with: fillWord	"Allocate a new object of the given size and number of header words. (Note: byteSize already includes space for the base header word.) Initialize the header fields of the new object and fill the remainder of the object with the given value."	| newObj remappedClassOop end i |	self inline: true.	"remap classOop in case GC happens during allocation"	hdrSize > 1 ifTrue: [ self pushRemappableOop: classOop ].  	newObj _ self allocateChunk: byteSize + ((hdrSize - 1) * 4).	hdrSize > 1 ifTrue: [ remappedClassOop _ self popRemappableOop ].	hdrSize = 3 ifTrue: [		self longAt: newObj      put: (extendedSize bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 4 put: (remappedClassOop bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 8 put: (baseHeader bitOr: HeaderTypeSizeAndClass).		newObj _ newObj + 8.	].	hdrSize = 2 ifTrue: [		self longAt: newObj      put: (remappedClassOop bitOr: HeaderTypeClass).		self longAt: newObj + 4 put: (baseHeader bitOr: HeaderTypeClass).		newObj _ newObj + 4.	].	hdrSize = 1 ifTrue: [		self longAt: newObj put: (baseHeader bitOr: HeaderTypeShort).	].	"clear new object"	doFill ifTrue:		[end _ newObj + byteSize.		i _ newObj + 4.		[i < end] whileTrue:			[self longAt: i put: fillWord.			i _ i + 4]].	DoAssertionChecks ifTrue: [		self okayOop: newObj.		self oopHasOkayClass: newObj.		(self objectAfter: newObj) = freeBlock			ifFalse: [ self error: 'allocate bug: did not set header of new oop correctly' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'allocate bug: did not set header of freeBlock correctly' ].	].	^ newObj! !!ObjectMemory methodsFor: 'allocation' stamp: 'jm 12/6/1998 17:26'!allocateOrRecycleContext	"Return a recycled context or a newly allocated one if none is available for recycling."	| cntxt |	self inline: true.		freeContexts ~= NilContext ifTrue: [			cntxt _ freeContexts.			freeContexts _ self fetchPointer: 0 ofObject: cntxt.		] ifFalse: [			cntxt _ self instantiateContext: (self splObj: ClassMethodContext)								sizeInBytes: LargeContextSize.			"Required init -- above does not fill w/nil.  All others get written."			self storePointerUnchecked: 4 "InitialIPIndex" ofObject: cntxt								withValue: nilObj.		].	^ cntxt! !!ObjectMemory methodsFor: 'allocation' stamp: 'jm 12/6/1998 17:25'!internalAllocateOrRecycleContext	"Return a recycled context or a newly allocated one if none is available for recycling. The argument indicates that a small context is wanted."	| cntxt |	self inline: true.	freeContexts ~= NilContext ifTrue: [		cntxt _ freeContexts.		freeContexts _ self fetchPointer: 0 ofObject: cntxt.	] ifFalse: [		self externalizeIPandSP.		cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)							sizeInBytes: LargeContextSize fill: nilObj.		self internalizeIPandSP.	].	^ cntxt! !!ObjectMemory methodsFor: 'allocation' stamp: 'jm 12/6/1998 17:33'!recycleContextIfPossible: cntxOop	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss. It's fields are nil-ed out when it is re-used. The recycled context lists are cleared at every garbage collect."	"Note: This code was found to be critical to good send/return speed, so it has been ruthlessly hand-tuned."	| cntxHeader |	self inline: true.	"only recycle young contexts (which should be most of them)"	cntxOop >= youngStart ifTrue: [		"is the context of class methodCntxClass?"		cntxHeader _ self baseHeader: cntxOop.		(self isMethodContext: cntxOop header: cntxHeader) ifTrue: [			self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeContexts.			freeContexts _ cntxOop.			].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'jm 12/6/1998 17:26'!markPhase	"Mark phase of the mark and sweep garbage collector. Set the mark bits of all reachable objects. Free chunks are untouched by this process."	"Assume: All non-free objects are initially unmarked. Root objects were unmarked when they were made roots. (Make sure this stays true!!!!)."	| oop |	self inline: false.	"clear the recycled context lists"	freeContexts _ NilContext.	"trace the interpreter's objects, including the active stack and special objects array"	self markAndTraceInterpreterOops.	"trace the roots"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		(self isIntegerObject: oop) ifFalse: [ self markAndTrace: oop ].	].! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 19:41'!beRootWhileForwarding: oop	"Record that the given oop in the old object area points to an object in the young area when oop may be forwarded. Like beRoot:"	"Warning: No young objects should be recorded as roots. Callers are responsible for ensuring this constraint is not violated."	| header forwarding fwdBlock newHeader |	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		forwarding _ true.		fwdBlock _ (header bitAnd: AllButMarkBitAndTypeMask) << 1.		DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	] ifFalse: [		forwarding _ false.	].	(header bitAnd: RootBit) = 0 ifTrue: [		"record oop as root only if not already recorded"		rootTableCount < RootTableSize ifTrue: [			"record root only if there is room in the roots table"			rootTableCount _ rootTableCount + 1.			rootTable at: rootTableCount put: oop.			newHeader _ header bitOr: RootBit.			forwarding				ifTrue: [ self longAt: (fwdBlock + 4) put: newHeader ]				ifFalse: [ self longAt: oop put: newHeader ].		].	].! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 19:58'!fwdTableInit	"Set the limits for a table of two-word forwarding blocks above the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used for compaction of memory and become-ing objects. Returns the number of forwarding blocks available."	self inline: false.	"set endOfMemory to just after a minimum-sized free block"	self setSizeOfFree: freeBlock to: BaseHeaderSize.	endOfMemory _ freeBlock + BaseHeaderSize.	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	"use all memory free between freeBlock and memoryLimit for forwarding table"	"  (use quadword alignment for better cache performance)"	fwdTableNext _ (endOfMemory + BaseHeaderSize + 7) bitAnd: 16rFFFFFFF8.	fwdTableLast _ memoryLimit - 8.  "last forwarding table entry"	"return the number of forwarding blocks available"	^ (fwdTableLast - fwdTableNext) // 8  "round down"! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 19:45'!incCompMove: bytesFreed	"Move all non-free objects between compStart and compEnd to their new locations, restoring their headers in the process. Create a new free block at the end of memory. Return the newly created free chunk."	"Note: The free block used by the allocator always must be the last free block in memory. It may take several compaction passes to make all free space bubble up to the end of memory."	| oop next fwdBlock newOop header bytesToMove firstWord lastWord newFreeChunk sz |	newOop _ nil.	oop _ self oopFromChunk: compStart.	[oop < compEnd] whileTrue: [		next _ self objectAfterWhileForwarding: oop.		(self isFreeObject: oop) ifFalse: [			"a moving object; unwind its forwarding block"			fwdBlock _ ((self longAt: oop) bitAnd: AllButMarkBitAndTypeMask) << 1.			DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			header _ self longAt: fwdBlock + 4.			self longAt: oop put: header.  "restore the original header"			bytesToMove _ oop - newOop.			"move the oop (including any extra header words)"			sz _ self sizeBitsOf: oop.			firstWord _ oop - (self extraHeaderBytes: oop).			lastWord _ (oop + sz) - BaseHeaderSize.			firstWord to: lastWord by: 4 do: [ :w |				self longAt: (w - bytesToMove) put: (self longAt: w).			].		].		oop _ next.	].	newOop = nil ifTrue: [		"no objects moved"		oop _ self oopFromChunk: compStart.		((self isFreeObject: oop) and: [(self objectAfter: oop) = (self oopFromChunk: compEnd)])			ifTrue: [ newFreeChunk _ oop ]			ifFalse: [ newFreeChunk _ freeBlock ].	] ifFalse: [		"initialize the newly freed memory chunk"		"newOop is the last object moved; free chunk starts right after it"		newFreeChunk _ newOop + (self sizeBitsOf: newOop).		self setSizeOfFree: newFreeChunk to: bytesFreed.	].	DoAssertionChecks ifTrue: [		(self objectAfter: newFreeChunk) = (self oopFromChunk: compEnd)			ifFalse: [ self error: 'problem creating free chunk after compaction' ].	].	(self objectAfter: newFreeChunk) = endOfMemory ifTrue: [		self initializeMemoryFirstFree: newFreeChunk.	] ifFalse: [		"newFreeChunk is not at end of memory; re-install freeBlock"		self initializeMemoryFirstFree: freeBlock.	].	^ newFreeChunk! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 19:56'!initForwardBlock: fwdBlock mapping: oop to: newOop	"Initialize the given forwarding block to map oop to newOop, and replace oop's header with a pointer to the fowarding block."	"Details: The mark bit is used to indicate that an oop is forwarded. When an oop is forwarded, its header (minus the mark bit) contains the address of its forwarding block. (The forwarding block address is actually shifted right by one bit so that its top-most bit does not conflict with the header's mark bit; since fowarding blocks are stored on word boundaries, the low two bits of the address are always zero.) The first word of the forwarding block is the new oop; the second word is the oop's orginal header. The type bits of the forwarding header are the same as those of the original header."	| originalHeader originalHeaderType |	self inline: true.	originalHeader _ self longAt: oop.	DoAssertionChecks ifTrue: [		fwdBlock = nil			ifTrue: [ self error: 'ran out of forwarding blocks in become' ].		(originalHeader bitAnd: MarkBit) ~= 0			ifTrue: [ self error: 'object already has a forwarding table entry' ].	].	originalHeaderType _ originalHeader bitAnd: TypeMask.	self longAt: fwdBlock put: newOop.	self longAt: fwdBlock + 4 put: originalHeader.	self longAt: oop put: (fwdBlock >> 1 bitOr: (MarkBit bitOr: originalHeaderType)).! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 12/6/1998 16:19'!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ (header bitAnd: AllButMarkBitAndTypeMask) << 1.		DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt <= 4 ifTrue:		[(fmt = 3 and: [self isContextHeader: header]) ifTrue:			["contexts end at the stack pointer"			" 6 fixed fields in MethodContexts and BlockContexts ***"			^ (6 + (self fetchStackPointerOf: oop)) * 4].		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]			ifFalse: [ size _ header bitAnd: SizeMask ].		^ size - BaseHeaderSize].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 19:59'!objectAfterWhileForwarding: oop	"Return the oop of the object after the given oop when the actual header of the oop may be in the forwarding table."	| header fwdBlock realHeader sz |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [ ^ self objectAfter: oop ].  "oop not forwarded"	"Assume: mark bit cannot be set on a free chunk, so if we get here,	 oop is not free and it has a forwarding table entry"	fwdBlock _ (header bitAnd: AllButMarkBitAndTypeMask) << 1.	DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].	realHeader _ self longAt: fwdBlock + 4.	"following code is like sizeBitsOf:"	(realHeader bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ realHeader bitAnd: SizeMask ].	^ self oopFromChunk: (oop + sz)! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 20:00'!remap: oop	"Map the given oop to its new value during a compaction or become: operation. If it has no forwarding table entry, return the oop itself."	| fwdBlock |	self inline: false.	(self isObjectForwarded: oop) ifTrue: [		"get the new value for oop from its forwarding block"		fwdBlock _ ((self longAt: oop) bitAnd: AllButMarkBitAndTypeMask) << 1.		DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].		^ self longAt: fwdBlock	].	^ oop! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 20:00'!remapClassOf: oop	"Update the class of the given object, if necessary, using its forwarding table entry."	"Note: Compact classes need not be remapped since the compact class field is just an index into the compact class table. The header type bits show if this object has a compact class; we needn't look up the oop's real header."	| classHeader classOop fwdBlock newClassOop newClassHeader |	(self headerType: oop) = HeaderTypeShort ifTrue: [ ^nil ].  "compact classes needn't be mapped"	classHeader _ self longAt: (oop - 4).	classOop _ classHeader bitAnd: AllButTypeMask.	(self isObjectForwarded: classOop) ifTrue: [		fwdBlock _ ((self longAt: classOop) bitAnd: AllButMarkBitAndTypeMask) << 1.		DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].		newClassOop _ self longAt: fwdBlock.		newClassHeader _ newClassOop bitOr: (classHeader bitAnd: TypeMask).		self longAt: (oop - 4) put: newClassHeader.		"The following ensures that become: into an old object's class makes it a root.		  It does nothing during either incremental or full compaction because		  oop will never be < youngStart."		((oop < youngStart) and: [newClassOop >= youngStart])			ifTrue: [ self beRootWhileForwarding: oop ].	].! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'jm 11/25/1998 20:01'!remapFieldsAndClassOf: oop	"Replace all forwarded pointers in this object with their new oops, using the forwarding table. Remap its class as well, if necessary."	"Note: The given oop may be forwarded itself, which means that its real header is in its forwarding table entry."	| fieldOffset fieldOop fwdBlock newOop |	self inline: true.	fieldOffset _ self lastPointerWhileForwarding: oop.	[fieldOffset >= BaseHeaderSize] whileTrue: [		fieldOop _ self longAt: (oop + fieldOffset).		(self isObjectForwarded: fieldOop) ifTrue: [			"update this oop from its forwarding block"			fwdBlock _ ((self longAt: fieldOop) bitAnd: AllButMarkBitAndTypeMask) << 1.			DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			self longAt: (oop + fieldOffset) put: newOop.			"The following ensures that become: into old object makes it a root.			  It does nothing during either incremental or full compaction because			  oop will never be < youngStart."			((oop < youngStart) and: [newOop >= youngStart])				ifTrue: [ self beRootWhileForwarding: oop ].		].		fieldOffset _ fieldOffset - 4.	].	self remapClassOf: oop.! !!ObjectMemory methodsFor: 'become' stamp: 'jm 11/25/1998 19:41'!restoreHeaderOf: oop	"Restore the original header of the given oop from its forwarding block."	| fwdHeader fwdBlock |	fwdHeader _ self longAt: oop.	fwdBlock _ (fwdHeader bitAnd: AllButMarkBitAndTypeMask) << 1.	DoAssertionChecks ifTrue: [		(fwdHeader bitAnd: MarkBit) = 0 ifTrue: [			self error: 'attempting to restore the header of an object that has no forwarding block'.		].		self fwdBlockValidate: fwdBlock.	].	self longAt: oop put: (self longAt: fwdBlock + 4).  "restore orginal header"! !!DynamicContextCache methodsFor: 'object memory support' stamp: 'jm 11/25/1998 16:39'!markAndTraceContextCache	"Assumes: SP and IP are external and valid for the activeCachedContext."	| ctx tmp acc |	self inline: true.	acc _ activeCachedContext.	acc = 0 ifFalse: [		self assertStackPointerIsExternal.		DoAssertionChecks ifTrue: [self verifyStack].		ctx _ lowestCachedContext.		self assertIsCachedContext: ctx.		tmp _ self cachedSenderAt: ctx.		self assertIsStableContextOrNil: tmp.		self markAndTrace: tmp.			"Mark the stable section of the stack".		[ctx = 0] whileFalse: [			self markAndTraceCachedContext: ctx.			ctx = acc				ifTrue: [ctx _ 0]				ifFalse: [ctx _ self cachedContextAfter: ctx].		].	].! !!DynamicInterpreter methodsFor: 'object memory support' stamp: 'jm 11/25/1998 16:35'!postGCAction	| acc |"	self mapCachedTemporaryPointers."	acc _ activeCachedContext.	acc = 0 ifFalse: [		self addRootsForCachedContext: acc.		self setTemporaryPointer: (self temporaryPointerForCachedContext: acc).		DoAssertionChecks ifTrue:			[self verifyStack.			 self verifyMethodCache].	].! !!DynamicInterpreter methodsFor: 'interpreter shell' stamp: 'jm 11/25/1998 16:35'!interpret	"If newTranslatedMethod = nilObj then the interpreter is initialising: dispatch on opcodeIndex	to store the address of the opcode in opcodeAddress, then return.	If newTranslatedMethod ~= nilObj then the interpreter is starting execution: dispatch to the	first instruction to begin execution."	"Note: the current instruction is called currentBytecode for historical reasons (and is hard	to change without breaking compatibility with the original Interpreter in the CCodeGenerator)."	"Note: in the simulator this code is only executed for initialisation, never for execution."	self inline: false.	self interpreterInitializing ifFalse: [		DoAssertionChecks ifTrue: [self print: 'Warning: assertions are enabled'; cr].		self internalizeIPandSP.		self nextOp.		"dispatches to first instruction"	].	currentBytecode _ opcodeIndex.	opcodeAddress _ 0.	"the following loop is executed exactly once, but is needed to defeat dead code elimination	in some C compilers"	[opcodeAddress = 0] whileTrue: [self dispatchOn: currentBytecode in: OpcodeTable].	^opcodeAddress! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'jm 11/25/1998 16:47'!verifyStack	| t1 t2 t3 |	(t1 _ activeCachedContext) = 0		ifTrue: [self print: 'Warning: no active context in #verifyStack'; cr]		ifFalse: [			t2 _ 0.			[t2 = 0] whileTrue: [				self verifyCachedContext: t1.				t1 = lowestCachedContext ifTrue: [t2 _ self cachedSenderAt: t1].				t1 _ self cachedContextBefore: t1].			t2 = nilObj ifTrue: [self assertIsCachedBaseContext: lowestCachedContext].			[t2 = nilObj] whileFalse: [				self verifyStableContext: t2.				t3 _ self fetchPointer: SenderIndex ofObject: t2.				t3 = nilObj ifTrue: [self assertIsStableBaseContext: t2].				t2 _ t3].			nil].! !!DynamicInterpreterSimulator methodsFor: 'initialization' stamp: 'jm 11/25/1998 16:37'!openOn: fileName extraMemory: extraBytes	"InterpreterSimulator new openOn: 'clone.im' extraMemory: 100000"	| f version headerSize count oldBaseAddr bytesToShift swapBytes totalMemory |	"open image file and read the header"	f _ FileStream oldFileNamed: fileName.	imageName _ f fullName.	f binary; readOnly.	version _ self nextLongFrom: f.  "current version: 16r1966 (=6502)"	version = self imageFormatVersion		ifTrue: [swapBytes _ false]		ifFalse: [(version _ self byteSwapped: version) = self imageFormatVersion					ifTrue: [swapBytes _ true]					ifFalse: [self error: 'incomaptible image format']].	headerSize _ self nextLongFrom: f swap: swapBytes.	endOfMemory _ self nextLongFrom: f swap: swapBytes.  "first unused location in heap"	oldBaseAddr _ self nextLongFrom: f swap: swapBytes.  "object memory base address of image"	specialObjectsOop _ self nextLongFrom: f swap: swapBytes.	lastHash _ self nextLongFrom: f swap: swapBytes.  "Should be loaded from, and saved to the image header"	savedWindowSize _ self nextLongFrom: f swap: swapBytes.	lastHash = 0 ifTrue: [lastHash _ 999].	"allocate interpreter memory"	contextCacheEntries = nil ifTrue: [contextCacheEntries _ ContextCacheEntries].	stackCacheEntries = nil ifTrue: [stackCacheEntries _ StackCacheEntries].	memoryLimit _ endOfMemory + extraBytes.	totalMemory _ memoryLimit + self cacheSize.	"read in the image in bulk, then swap the bytes if necessary"	f position: headerSize.	memory _ Bitmap new: totalMemory // 4.	count _ f readInto: memory startingAt: 1 count: endOfMemory // 4.	count ~= (endOfMemory // 4) ifTrue: [self halt].	f close.	swapBytes ifTrue: [Utilities informUser: 'Swapping bytes of foreign image...'								during: [self reverseBytesInImage]].	self initialize.	bytesToShift _ 0 - oldBaseAddr.  "adjust pointers for zero base address"	endOfMemory _ endOfMemory.	self initializeCache: memoryLimit.	Utilities informUser: 'Relocating object pointers...'				during: [self initializeInterpreter: bytesToShift].! !!Interpreter methodsFor: 'utilities' stamp: 'jm 12/10/1998 19:18'!booleanCheat: cond	| bytecode offset |	self inline: true.	bytecode _ self fetchByte.  "assume next bytecode is jumpIfFalse (99%)"	self internalPop: 2.	(bytecode < 160 and: [bytecode > 151]) ifTrue: [  "short jumpIfFalse"		cond			ifTrue: [^ self fetchNextBytecode]			ifFalse: [^ self jump: bytecode - 151]].	bytecode = 172 ifTrue: [  "long jumpIfFalse"		offset _ self fetchByte.		cond			ifTrue: [^ self fetchNextBytecode]			ifFalse: [^ self jump: offset]].	"not followed by a jumpIfFalse; undo instruction fetch and push boolean result"	localIP _ localIP - 1.	self fetchNextBytecode.	cond		ifTrue: [self internalPush: trueObj]		ifFalse: [self internalPush: falseObj].! !!Interpreter methodsFor: 'utilities' stamp: 'jm 12/7/1998 07:35'!externalizeIPandSP	"Copy the local instruction and stack pointer to global variables for use in primitives and other functions outside the interpret loop."	instructionPointer _ self cCoerce: localIP to: 'int'.	stackPointer _ self cCoerce: localSP to: 'int'.	theHomeContext _ localHomeContext.! !!Interpreter methodsFor: 'utilities' stamp: 'jm 12/7/1998 07:35'!internalizeIPandSP	"Copy the local instruction and stack pointer to local variables for rapid access within the interpret loop."	localIP _ self cCoerce: instructionPointer to: 'char *'.	localSP _ self cCoerce: stackPointer to: 'char *'.	localHomeContext _ theHomeContext.! !!Interpreter methodsFor: 'contexts' stamp: 'jm 12/7/1998 08:37'!internalFetchContextRegisters: activeCntx	"Inlined into return bytecodes. The only difference between this method and fetchContextRegisters: is that this method sets the local IP and SP."	| tmp |	self inline: true.	tmp _ self fetchPointer: MethodIndex ofObject: activeCntx.	(self isIntegerObject: tmp) ifTrue: [		"if the MethodIndex field is an integer, activeCntx is a block context"		tmp _ self fetchPointer: HomeIndex ofObject: activeCntx.		(tmp < youngStart) ifTrue: [ self beRootIfOld: tmp ].	] ifFalse: [		"otherwise, it is a method context and is its own home context"		tmp _ activeCntx.	].	localHomeContext _ tmp.	receiver _ self fetchPointer: ReceiverIndex ofObject: tmp.	method _ self fetchPointer: MethodIndex ofObject: tmp.	"the instruction pointer is a pointer variable equal to		method oop + ip + BaseHeaderSize		  -1 for 0-based addressing of fetchByte		  -1 because it gets incremented BEFORE fetching currentByte"	tmp _ self quickFetchInteger: InstructionPointerIndex ofObject: activeCntx.	localIP _ self cCoerce: method + tmp + BaseHeaderSize - 2 to: 'char *'.	"the stack pointer is a pointer variable also..."	tmp _ self quickFetchInteger: StackPointerIndex ofObject: activeCntx.	localSP _ self cCoerce: activeCntx + BaseHeaderSize + ((TempFrameStart + tmp - 1) * 4) to: 'char *'.! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/3/1998 15:55'!internalNewActiveContext: aContext	"The only difference between this method and newActiveContext: is that this method uses internal context registers."	self inline: true.	self internalStoreContextRegisters: activeContext.	(aContext < youngStart) ifTrue: [ self beRootIfOld: aContext ].	activeContext _ aContext.	self internalFetchContextRegisters: aContext.! !!Interpreter methodsFor: 'contexts' stamp: 'jm 12/7/1998 07:41'!sender	^ self fetchPointer: SenderIndex ofObject: localHomeContext! !!Interpreter methodsFor: 'contexts' stamp: 'jm 12/7/1998 07:42'!temporary: offset	^ self fetchPointer: offset + TempFrameStart ofObject: localHomeContext! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/7/1998 12:28'!internalActivateNewMethod	| tmp newContext tempCount |	self inline: true.	tmp _ self headerOf: newMethod.	freeContexts ~= NilContext ifTrue: [		newContext _ freeContexts.		freeContexts _ self fetchPointer: 0 ofObject: newContext.	] ifFalse: [		self externalizeIPandSP.		newContext _ self			instantiateSmallClass: (self splObj: ClassMethodContext)			sizeInBytes: LargeContextSize fill: nilObj.		self internalizeIPandSP.	].	tempCount _ (tmp >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf:			(((LiteralStart + (self literalCountOfHeader: tmp)) * 4) + 1)).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	0 to: argumentCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self internalStackValue: argumentCount-i)].	"clear remaining temps to nil in case it has been recycled"	tmp _ nilObj.	argumentCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: tmp].	self internalPop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self internalNewActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/7/1998 09:05'!lookupMethodInClass: class	| currentClass dictionary found rclass |	self inline: false.	currentClass _ class.	[currentClass ~= nilObj]		whileTrue:		[dictionary _ self fetchPointer: MessageDictionaryIndex ofObject: currentClass.		found _ self lookupMethodInDictionary: dictionary.		found ifTrue: [^ currentClass].		currentClass _ self superclassOf: currentClass].	messageSelector = (self splObj: SelectorDoesNotUnderstand) ifTrue:		[self error: 'Recursive not understood error encountered'].	self pushRemappableOop: class.	self createActualMessage.  "may cause GC!!"	rclass _ self popRemappableOop.	messageSelector _ self splObj: SelectorDoesNotUnderstand.	^ self lookupMethodInClass: rclass! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/13/1998 13:03'!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| rcvr lkupClass |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: 131.	rcvr _ self internalStackValue: argumentCount.	lkupClass _ self fetchClassOf: rcvr.	self internalFindNewMethodInClass: lkupClass.	self internalExecuteNewMethod.	self fetchNextBytecode.! !!Interpreter methodsFor: 'message sending' stamp: 'jm 12/10/1998 17:47'!superclassSend	"Send a message to self, starting lookup with the superclass of the class containing the currently executing method."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| lkupClass |	self inline: true.	self sharedCodeNamed: 'commonSupersend' inCase: 133.	lkupClass _ self superclassOf: (self methodClassOf: method).	self internalFindNewMethodInClass: lkupClass.	self internalExecuteNewMethod.	self fetchNextBytecode.! !!Interpreter methodsFor: 'method lookup cache' stamp: 'jm 12/10/1998 15:07'!flushMethodCache	"Flush the method cache. The method cache is flushed on every programming change and garbage collect."	1 to: MethodCacheSize do: [:i | methodCache at: i put: 0].! !!Interpreter methodsFor: 'method lookup cache' stamp: 'jm 12/13/1998 12:58'!lookupInMethodCacheSel: selector class: class	"This method implements a simple method lookup cache. If an entry for the given selector and class is found in the cache, set the values of 'newMethod' and 'primitiveIndex' and return true. Otherwise, return false."	"About the re-probe scheme: The hash is the low bits of the XOR of two large addresses, minus their useless lowest two bits. If a probe doesn't get a hit, the hash is shifted right one bit to compute the next probe, introducing a new randomish bit. The cache is probed CacheProbeMax times before giving up."	"WARNING: Since the hash computation is based on the object addresses of the class and selector, we must rehash or flush when compacting storage. We've chosen to flush, since that also saves the trouble of updating the addresses of the objects in the cache."	| hash probe |	self inline: false.	hash _ (selector bitXor: class) >> 2.  "shift drops two low-order zeros from addresses"	probe _ (hash bitAnd: MethodCacheMask) + 1.  "first probe"	(((methodCache at: probe) = selector) and:		 [(methodCache at: probe + MethodCacheEntries) = class]) ifTrue:			[newMethod _ methodCache at: probe + (MethodCacheEntries * 2).			primitiveIndex _ methodCache at: probe + (MethodCacheEntries * 3).			^ true	"found entry in cache; done"].	probe _ ((hash >> 1) bitAnd: MethodCacheMask) + 1.  "second probe"	(((methodCache at: probe) = selector) and:		 [(methodCache at: probe + MethodCacheEntries) = class]) ifTrue:			[newMethod _ methodCache at: probe + (MethodCacheEntries * 2).			primitiveIndex _ methodCache at: probe + (MethodCacheEntries * 3).			^ true	"found entry in cache; done"].	probe _ ((hash >> 2) bitAnd: MethodCacheMask) + 1.	(((methodCache at: probe) = selector) and:		 [(methodCache at: probe + MethodCacheEntries) = class]) ifTrue:			[newMethod _ methodCache at: probe + (MethodCacheEntries * 2).			primitiveIndex _ methodCache at: probe + (MethodCacheEntries * 3).			^ true].	^ false! !!Interpreter methodsFor: 'interpreter shell' stamp: 'jm 12/10/1998 16:44'!fetchNextBytecode	"This method fetches the next instruction (bytecode). Each bytecode method is responsible for fetching the next bytecode, preferably as early as possible to allow the memory system time to process the request before the next dispatch."	currentBytecode _ self fetchByte.! !!Interpreter methodsFor: 'interpreter shell' stamp: 'jm 12/10/1998 17:00'!interpret	self internalizeIPandSP.	self fetchNextBytecode.	[true] whileTrue: [self dispatchOn: currentBytecode in: BytecodeTable].	self externalizeIPandSP.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:42'!duplicateTopBytecode	self fetchNextBytecode.	self internalPush: self internalStackTop.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:46'!experimentalBytecode	"Note: This bytecode is not currently generated by the compiler."	"This range of six bytecodes can replace the pushTemporaryVariable[0..5] bytecode at the beginning of a sequence of either the form:		pushTemp		pushTemp | pushConstantOne | pushLiteralConstant		<=		longJumpIfFalseor the form:		pushTemp		pushTemp | pushConstantOne | pushLiteralConstant		+		popIntoTemp (optional)If two values pushed are not small integers, this bytecode acts like the pushTemp bytecode it replaces. However, if they are small integers, then the given arithmetic or comparison operation is performed. The result of that operation is either pushed onto the stack or, if one of the expected bytecodes follows it, then that bytecode is performed immediately. In such cases, the entire four instruction sequence is performed without doing any stack operations."	| arg1 byte2 byte3 byte4 arg1Val arg2Val result offset |	arg1 _ self temporary: currentBytecode - 138.	byte2 _ self byteAt: localIP + 1.  "fetch ahead"	byte3 _ self byteAt: localIP + 2.  "fetch ahead"	byte4 _ self byteAt: localIP + 3.  "fetch ahead"	"check first arg"	(self isIntegerObject: arg1) ifTrue: [		arg1Val _ self integerValueOf: arg1.	] ifFalse: [		self fetchNextBytecode.		^ self internalPush: arg1.  "abort; first arg is not an integer"	].	"get and check second arg"	byte2 < 32 ifTrue: [		arg2Val _ self temporary: (byte2 bitAnd: 16rF).		(self isIntegerObject: arg2Val) ifTrue: [			arg2Val _ self integerValueOf: arg2Val.		] ifFalse: [			self fetchNextBytecode.			^ self internalPush: arg1.  "abort; second arg is not an integer"		].	] ifFalse: [		byte2 > 64 ifTrue: [			arg2Val _ 1.		] ifFalse: [			arg2Val _ self literal: (byte2 bitAnd: 16r1F).			(self isIntegerObject: arg2Val) ifTrue: [				arg2Val _ self integerValueOf: arg2Val.			] ifFalse: [				self fetchNextBytecode.				^ self internalPush: arg1.  "abort; second arg is not an integer"			].		].	].	byte3 < 178 ifTrue: [		"do addition, possibly followed by a storeAndPopTemp"		result _ arg1Val + arg2Val.		(self isIntegerValue: result) ifTrue: [			((byte4 > 103) and: [byte4 < 112]) ifTrue: [				"next instruction is a storeAndPopTemp"				localIP _ localIP + 3.				self storePointerUnchecked: (byte4 bitAnd: 7) + TempFrameStart					ofObject: localHomeContext					withValue: (self integerObjectOf: result).			] ifFalse: [				localIP _ localIP + 2.				self internalPush: (self integerObjectOf: result).			].		] ifFalse: [			self fetchNextBytecode.			^ self internalPush: arg1.  "abort; result is not an integer"		].	] ifFalse: [		"do comparison operation, followed by a longJumpIfFalse"		offset _ self byteAt: localIP + 4.		arg1Val <= arg2Val			ifTrue: [localIP _ localIP + 3 + 1]  "jump not taken; skip extra instruction byte"			ifFalse: [localIP _ localIP + 3 + 1 + offset].			self fetchNextBytecode.	].! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:46'!extendedPushBytecode	| descriptor variableType variableIndex |	descriptor _ self fetchByte.	self fetchNextBytecode.	variableType _ (descriptor >> 6) bitAnd: 16r3.	variableIndex _ descriptor bitAnd: 16r3F.	variableType=0 ifTrue: [^self pushReceiverVariable: variableIndex].	variableType=1 ifTrue: [^self pushTemporaryVariable: variableIndex].	variableType=2 ifTrue: [^self pushLiteralConstant: variableIndex].	variableType=3 ifTrue: [^self pushLiteralVariable: variableIndex].! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:47'!extendedStoreAndPopBytecode	self extendedStoreBytecode.	self internalPop: 1.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:47'!extendedStoreBytecode	| descriptor variableType variableIndex association |	self inline: true.	descriptor _ self fetchByte.	self fetchNextBytecode.	variableType _ (descriptor >> 6) bitAnd: 16r3.	variableIndex _ descriptor bitAnd: 16r3F.	variableType = 0 ifTrue:		[^self storePointer: variableIndex			ofObject: receiver			withValue: self internalStackTop].	variableType = 1 ifTrue:		[^self storePointerUnchecked: variableIndex + TempFrameStart			ofObject: localHomeContext			withValue: self internalStackTop].	variableType = 2 ifTrue:		[self error: 'illegal store'].	variableType = 3 ifTrue:		[association _ self literal: variableIndex.		^self storePointer: ValueIndex			ofObject: association			withValue: self internalStackTop].! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:47'!popStackBytecode	self fetchNextBytecode.	self internalPop: 1.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushActiveContextBytecode	"Puts reclaimability of this context in question."	self fetchNextBytecode.	reclaimableContextCount _ 0.	self internalPush: activeContext.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantFalseBytecode	self fetchNextBytecode.	self internalPush: falseObj.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantMinusOneBytecode	self fetchNextBytecode.	self internalPush: ConstMinusOne.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantNilBytecode	self fetchNextBytecode.	self internalPush: nilObj.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantOneBytecode	self fetchNextBytecode.	self internalPush: ConstOne.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantTrueBytecode	self fetchNextBytecode.	self internalPush: trueObj.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantTwoBytecode	self fetchNextBytecode.	self internalPush: ConstTwo.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushConstantZeroBytecode	self fetchNextBytecode.	self internalPush: ConstZero.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:56'!pushLiteralConstantBytecode	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	self pushLiteralConstant: (currentBytecode bitAnd: 16r1F).! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:56'!pushLiteralVariableBytecode	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	self pushLiteralVariable: (currentBytecode bitAnd: 16r1F).! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/10/1998 16:48'!pushReceiverBytecode	self fetchNextBytecode.	self internalPush: receiver.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:57'!pushReceiverVariableBytecode	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	self pushReceiverVariable: (currentBytecode bitAnd: 16rF).! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:57'!pushTemporaryVariableBytecode	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	self pushTemporaryVariable: (currentBytecode bitAnd: 16rF).! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:58'!storeAndPopReceiverVariableBytecode	"Note: This code uses storePointerUnchecked:ofObject:withValue: and does the store check explicitely in order to help the translator produce better code."	| rcvr top |	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	rcvr _ receiver.	top _ self internalStackTop.	(rcvr < youngStart) ifTrue: [		self possibleRootStoreInto: rcvr value: top.	].	self storePointerUnchecked: (currentBytecode bitAnd: 7)		ofObject: rcvr		withValue: top.	self internalPop: 1.! !!Interpreter methodsFor: 'stack bytecodes' stamp: 'jm 12/11/1998 07:59'!storeAndPopTemporaryVariableBytecode	self fetchNextBytecode.	"this bytecode will be expanded so that refs to currentBytecode below will be constant"	self storePointerUnchecked: (currentBytecode bitAnd: 7) + TempFrameStart		ofObject: localHomeContext		withValue: self internalStackTop.	self internalPop: 1.! !!Interpreter methodsFor: 'jump bytecodes' stamp: 'jm 12/10/1998 17:11'!jump: offset	localIP _ localIP + offset + 1.	currentBytecode _ self byteAt: localIP.! !!Interpreter methodsFor: 'jump bytecodes' stamp: 'jm 12/11/1998 07:24'!jumplfFalseBy: offset	| boolean |	boolean _ self internalStackTop.	boolean = falseObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = trueObj ifFalse: [			messageSelector _ self splObj: SelectorMustBeBoolean.			argumentCount _ 0.			^ self normalSend		].		self fetchNextBytecode.	].	self internalPop: 1.! !!Interpreter methodsFor: 'jump bytecodes' stamp: 'jm 12/11/1998 07:24'!jumplfTrueBy: offset	| boolean |	boolean _ self internalStackTop.	boolean = trueObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = falseObj ifFalse: [			messageSelector _ self splObj: SelectorMustBeBoolean.			argumentCount _ 0.			^ self normalSend		].		self fetchNextBytecode.	].	self internalPop: 1.! !!Interpreter methodsFor: 'jump bytecodes' stamp: 'jm 12/13/1998 11:20'!longUnconditionalJump	| offset |	offset _ (((currentBytecode bitAnd: 7) - 4) * 256) + self fetchByte.	localIP _ localIP + offset.	offset < 0 ifTrue: [		"backward jump means we're in a loop; check for possible interrupts"		self internalQuickCheckForInterrupts.	].	self fetchNextBytecode.! !!Interpreter methodsFor: 'send bytecodes' stamp: 'jm 12/10/1998 17:20'!doubleExtendedDoAnythingBytecode	"Replaces the Blue Book double-extended send [132], in which	the first byte was wasted on 8 bits of argument count.	Here we use 3 bits for the operation sub-type (opType),	and the remaining 5 bits for argument count where needed.	The last byte give access to 256 instVars or literals.	See also secondExtendedSendBytecode"	| byte2 byte3 opType top |	byte2 _ self fetchByte.	byte3 _ self fetchByte.	opType _ byte2 >> 5.	opType = 0 ifTrue: [		messageSelector _ self literal: byte3.		argumentCount _ byte2 bitAnd: 16r1F.		^ self normalSend	].	opType = 1 ifTrue: [		messageSelector _ self literal: byte3.		argumentCount _ byte2 bitAnd: 16r1F.		^ self superclassSend	].	self fetchNextBytecode.	opType = 2 ifTrue: [^ self pushReceiverVariable: byte3].	opType = 3 ifTrue: [^ self pushLiteralConstant: byte3].	opType = 4 ifTrue: [^ self pushLiteralVariable: byte3].	opType = 5 ifTrue: [		top _ self internalStackTop.		^ self storePointer: byte3 ofObject: receiver withValue: top	].	opType = 6 ifTrue: [		top _ self internalStackTop.		self internalPop: 1.		^ self storePointer: byte3 ofObject: receiver withValue: top	].	opType = 7 ifTrue: [		top _ self internalStackTop.		^ self storePointer: ValueIndex ofObject: (self literal: byte3) withValue: top	].! !!Interpreter methodsFor: 'return bytecodes' stamp: 'jm 12/10/1998 17:22'!returnValue: resultObj to: returnContext	"Note: Assumed to be inlined into the dispatch loop."	| nilOop thisCntx contextOfCaller |	self inline: true.	self sharedCodeNamed: 'commonReturn' inCase: 120.	nilOop _ nilObj. "keep in a register"	thisCntx _ activeContext.	"make sure we can return to the given context"	((returnContext = nilOop) or:	 [(self fetchPointer: InstructionPointerIndex ofObject: returnContext) = nilOop]) ifTrue: [		"error: sender's instruction pointer or context is nil; cannot return"		self internalPush: activeContext.		self internalPush: resultObj.		messageSelector _ self splObj: SelectorCannotReturn.		argumentCount _ 1.		^ self normalSend	].	[thisCntx = returnContext] whileFalse: [		"climb up stack to returnContext"		contextOfCaller _ self fetchPointer: SenderIndex ofObject: thisCntx.		"zap exited contexts so any future attempted use will be caught"		self storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.		self storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.		reclaimableContextCount > 0 ifTrue: [			"try to recycle this context"			reclaimableContextCount _ reclaimableContextCount - 1.			self recycleContextIfPossible: thisCntx.		].		thisCntx _ contextOfCaller.	].	activeContext _ thisCntx.	(thisCntx < youngStart) ifTrue: [ self beRootIfOld: thisCntx ].	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"	self fetchNextBytecode.	self internalPush: resultObj.! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:28'!bytecodePrimAdd	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).				(self isIntegerValue: result) ifTrue:					[self internalPop: 2						thenPush: (self integerObjectOf: result).					^ self fetchNextBytecode "success"]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatAdd: rcvr toArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ self fetchNextBytecode "success"]].	messageSelector _ self specialSelector: 0.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 21:44'!bytecodePrimAt	| index rcvr result rcvrClass |	index _ self internalStackTop.	rcvr _ self internalStackValue: 1.	successFlag _ self isIntegerObject: index.	successFlag ifTrue: [		self fetchNextBytecode.		rcvrClass _ self fetchClassOf: rcvr.  "assume class will be okay"		index _ self integerValueOf: index.		rcvrClass = (self splObj: ClassString) ifTrue:			[result _ self splObject: rcvr at: index.			successFlag ifTrue: [^ self internalPop: 2 thenPush: (self characterForAscii: result)]].		rcvrClass = (self splObj: ClassArray) ifTrue:			[result _ self splObject: rcvr at: index.			successFlag ifTrue: [^ self internalPop: 2 thenPush: result]].		rcvrClass = (self splObj: ClassBitmap) ifTrue:			[self externalizeIPandSP.			result _ self splObject: rcvr at: index.			self internalizeIPandSP.			successFlag ifTrue: [^ self internalPop: 2 thenPush: result]].		rcvrClass = (self splObj: ClassByteArray) ifTrue:			[result _ self splObject: rcvr at: index.			successFlag ifTrue: [^ self internalPop: 2 thenPush: result]].		"unknown class; back up IP before doing real send"		localIP _ localIP - 1].		messageSelector _ self specialSelector: 16.		argumentCount _ 1.		self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/11/1998 07:19'!bytecodePrimAtPut	| value index rcvr rcvrClass ascii |	value _ self internalStackTop.	index _ self internalStackValue: 1.	rcvr _ self internalStackValue: 2.	successFlag _ self isIntegerObject: index.	successFlag ifTrue: [		self fetchNextBytecode.  "assume class will be okay"		rcvrClass _ self fetchClassOf: rcvr.		index _ self integerValueOf: index.		rcvrClass = (self splObj: ClassString) ifTrue:			[ascii _ self asciiOfCharacter: value.			successFlag ifTrue: [self splObject: rcvr at: index put: ascii].			successFlag ifTrue: [^ self internalPop: 3 thenPush: value]].		rcvrClass = (self splObj: ClassArray) ifTrue:			[self splObject: rcvr at: index put: value.			successFlag ifTrue: [^ self internalPop: 3 thenPush: value]].		rcvrClass = (self splObj: ClassBitmap) ifTrue:			[self splObject: rcvr at: index put: value.			successFlag ifTrue: [^ self internalPop: 3 thenPush: value]].		rcvrClass = (self splObj: ClassByteArray) ifTrue:			[self splObject: rcvr at: index put: value.			successFlag ifTrue: [^ self internalPop: 3 thenPush: value]].		"unknown class; back up IP before doing real send"		localIP _ localIP - 1].	messageSelector _ self specialSelector: 17.	argumentCount _ 2.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:29'!bytecodePrimBitAnd	successFlag _ true.	self externalizeIPandSP.	self primitiveBitAnd.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 14.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:29'!bytecodePrimBitOr	successFlag _ true.	self externalizeIPandSP.	self primitiveBitOr.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 15.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:29'!bytecodePrimBitShift	successFlag _ true.	self externalizeIPandSP.	self primitiveBitShift.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 12.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:29'!bytecodePrimBlockCopy	| rcvrClass |	rcvrClass _ self fetchClassOf: (self internalStackValue: 1).	successFlag _ true.	self success:		((rcvrClass = (self splObj: ClassBlockContext)) or:		 [rcvrClass = (self splObj: ClassMethodContext)]).	successFlag ifTrue: [		self externalizeIPandSP.		self primitiveBlockCopy.		self internalizeIPandSP.	].	successFlag ifFalse: [		messageSelector _ self specialSelector: 24.		argumentCount _ 1.		^ self normalSend	].	self fetchNextBytecode.! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:23'!bytecodePrimClass	self externalizeIPandSP.	self primitiveClass.	self internalizeIPandSP.	self fetchNextBytecode.! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:35'!bytecodePrimDiv	| quotient |	successFlag _ true.	quotient _ self doPrimitiveDiv: (self internalStackValue: 1)							by: (self internalStackValue: 0).	successFlag ifTrue:		[self internalPop: 2 thenPush: (self integerObjectOf: quotient).		^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 13.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:30'!bytecodePrimDivide	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [rcvr _ self integerValueOf: rcvr.				arg _ self integerValueOf: arg.				((arg ~= 0) and: [(rcvr \\ arg) = 0]) ifTrue:					[result _ rcvr // arg.  "generates C / operation"					(self isIntegerValue: result) ifTrue:						[self internalPop: 2						thenPush: (self integerObjectOf: result).					^ self fetchNextBytecode "success"]]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatDivide: rcvr byArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ self fetchNextBytecode "success"]].	messageSelector _ self specialSelector: 9.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:31'!bytecodePrimMakePoint	successFlag _ true.	self externalizeIPandSP.	self primitiveMakePoint.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 11.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:31'!bytecodePrimMod	| mod |	successFlag _ true.	mod _ self doPrimitiveMod: (self internalStackValue: 1)							by: (self internalStackValue: 0).	successFlag ifTrue:		[self internalPop: 2 thenPush: (self integerObjectOf: mod).		^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 10.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:31'!bytecodePrimMultiply	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [rcvr _ self integerValueOf: rcvr.				arg _ self integerValueOf: arg.				result _ rcvr * arg.				((arg = 0 or: [(result // arg) = rcvr])					and: [self isIntegerValue: result])					ifTrue: [self internalPop: 2 thenPush: (self integerObjectOf: result).							^ self fetchNextBytecode "success"]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatMultiply: rcvr byArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ self fetchNextBytecode "success"]].	messageSelector _ self specialSelector: 8.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:34'!bytecodePrimPointX	successFlag _ true.	self externalizeIPandSP.	self primitivePointX.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 30.	argumentCount _ 0.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:34'!bytecodePrimPointY	successFlag _ true.	self externalizeIPandSP.	self primitivePointY.	self internalizeIPandSP.	successFlag ifTrue: [^ self fetchNextBytecode "success"].	messageSelector _ self specialSelector: 31.	argumentCount _ 0.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:34'!bytecodePrimSize	"See the comment in bytePrimitiveAt"	| sz rcvr |	rcvr _ self internalStackValue: 0.	(self okStreamArrayClass: (self fetchClassOf: rcvr)) ifTrue:		[sz _ self stSizeOf: rcvr.		successFlag ifTrue:			[(self isIntegerValue: sz)				ifTrue: [self internalPop: 1 thenPush: (self integerObjectOf: sz)]				ifFalse: [self externalizeIPandSP.						self pop: 1 thenPush: (self positive32BitIntegerFor: sz).						self internalizeIPandSP].			^ self fetchNextBytecode "success"]].	messageSelector _ self specialSelector: 18.	argumentCount _ 0.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 18:44'!bytecodePrimSubtract	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [result _ (self integerValueOf: rcvr) - (self integerValueOf: arg).				(self isIntegerValue: result) ifTrue:					[self internalPop: 2						thenPush: (self integerObjectOf: result).					^ self fetchNextBytecode "success"]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatSubtract: rcvr fromArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ self fetchNextBytecode "success"]].	messageSelector _ self specialSelector: 1.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:33'!bytecodePrimValue	| block |	block _ self internalStackTop.	successFlag _ true.	argumentCount _ 0.	self assertClassOf: block is: (self splObj: ClassBlockContext).	successFlag ifTrue: [		self externalizeIPandSP.		self primitiveValue.		self internalizeIPandSP.	].	successFlag ifFalse: [		messageSelector _ self specialSelector: 25.		argumentCount _ 0.		^ self normalSend	].	self fetchNextBytecode.! !!Interpreter methodsFor: 'common selector sends' stamp: 'jm 12/10/1998 17:33'!bytecodePrimValueWithArg	| block |	block _ self internalStackValue: 1.	successFlag _ true.	argumentCount _ 1.	self assertClassOf: block is: (self splObj: ClassBlockContext).	successFlag ifTrue: [		self externalizeIPandSP.		self primitiveValue.		self internalizeIPandSP.	].	successFlag ifFalse: [		messageSelector _ self specialSelector: 26.		argumentCount _ 1.		^ self normalSend	].	self fetchNextBytecode.! !!Interpreter methodsFor: 'primitive support' stamp: 'jm 12/10/1998 16:14'!primitiveResponse	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| timerPending startTime |	timerPending _ nextWakeupTick ~= 0.	timerPending ifTrue: [startTime _ self ioLowResMSecs].	successFlag _ true.	self dispatchOn: primitiveIndex in: PrimitiveTable.	timerPending ifTrue: [		(self ioLowResMSecs ~= startTime) ifTrue: [			"primitive ran for more than a tick; check for possible timer interrupts"			((self ioMSecs bitAnd: 16r1FFFFFFF) >= nextWakeupTick) ifTrue: [				successFlag					ifTrue: ["process the interrupt now"							self checkForInterrupts]					ifFalse: ["process the interrupt in primtive failure code"							interruptCheckCounter _ 0]]]].	^ successFlag! !!Interpreter methodsFor: 'object access primitives' stamp: 'jm 12/10/1998 18:49'!primitivePointX	| rcvr | 	self inline: false.	rcvr _ self popStack.	self assertClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: XIndex ofObject: rcvr)]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'object access primitives' stamp: 'jm 12/10/1998 18:50'!primitivePointY	| rcvr | 	self inline: false.	rcvr _ self popStack.	self assertClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: YIndex ofObject: rcvr)]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'image save/restore' stamp: 'jm 12/13/1998 14:31'!checkImageVersionFrom: f	"Read and verify the image file version number and return true if the the given image file needs to be byte-swapped. As a side effect, position the file stream just after the version number of the image header. This code prints a warning and does a hard-exit if it cannot find a valid version number."	"This code is based on C code by Ian Piumarta."	| version firstVersion |	self var: #f declareC: 'sqImageFile f'.	"check the version number"	self sqImageFile: f Seek: 0.	version _ firstVersion _ self getLongFromFile: f swap: false.	(self readableFormat: version) ifTrue: [^ false].	"try with bytes reversed"	self sqImageFile: f Seek: 0.	version _ self getLongFromFile: f swap: true.	(self readableFormat: version) ifTrue: [^ true].	"try skipping the first 512 bytes (prepended by certain Mac file transfer utilities)"	self sqImageFile: f Seek: 512.	version _ self getLongFromFile: f swap: false.	(self readableFormat: version) ifTrue: [^ false].	"try skipping the first 512 bytes with bytes reversed"	self sqImageFile: f Seek: 512.	version _ self getLongFromFile: f swap: true.	(self readableFormat: version) ifTrue: [^ true].	"hard failure; abort"	self print: 'This interpreter (vers. '.	self printNum: self imageFormatVersion.	self print: ' cannot read image file (vers. '.	self printNum: firstVersion.	self cr.	self print: 'Hit CR to quit'.	self getchar.	self ioExit.! !!Interpreter methodsFor: 'image save/restore' stamp: 'jm 12/6/1998 18:06'!imageFormatVersion	"Return a magic constant that changes when the image format changes. Since the image reading code uses this to detect byte ordering, one must avoid version numbers that are invariant under byte reversal."	^ 6504! !!Interpreter methodsFor: 'image save/restore' stamp: 'jm 12/6/1998 17:58'!readableFormat: imageVersion	"Anwer true if images of the given format are readable by this interpreter. Allows a virtual machine to accept selected older image formats."	^ (imageVersion = self imageFormatVersion) or: [imageVersion = 6502]! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'jm 12/6/1998 17:59'!openOn: fileName extraMemory: extraBytes	"InterpreterSimulator new openOn: 'clone.im' extraMemory: 100000"	| f version headerSize count oldBaseAddr bytesToShift swapBytes |	"open image file and read the header"	f _ FileStream oldFileNamed: fileName.	imageName _ f fullName.	f binary; readOnly.	version _ self nextLongFrom: f.  "current version: 16r1966 (=6502)"	(self readableFormat: version)		ifTrue: [swapBytes _ false]		ifFalse: [(version _ self byteSwapped: version) = self imageFormatVersion					ifTrue: [swapBytes _ true]					ifFalse: [self error: 'incomaptible image format']].	headerSize _ self nextLongFrom: f swap: swapBytes.	endOfMemory _ self nextLongFrom: f swap: swapBytes.  "first unused location in heap"	oldBaseAddr _ self nextLongFrom: f swap: swapBytes.  "object memory base address of image"	specialObjectsOop _ self nextLongFrom: f swap: swapBytes.	lastHash _ self nextLongFrom: f swap: swapBytes.  "Should be loaded from, and saved to the image header"	savedWindowSize _ self nextLongFrom: f swap: swapBytes.	lastHash = 0 ifTrue: [lastHash _ 999].	"allocate interpreter memory"	memoryLimit _ endOfMemory + extraBytes.	"read in the image in bulk, then swap the bytes if necessary"	f position: headerSize.	memory _ Bitmap new: memoryLimit // 4.	count _ f readInto: memory startingAt: 1 count: endOfMemory // 4.	count ~= (endOfMemory // 4) ifTrue: [self halt].	f close.	swapBytes ifTrue: [Utilities informUser: 'Swapping bytes of foreign image...'								during: [self reverseBytesInImage]].	self initialize.	bytesToShift _ 0 - oldBaseAddr.  "adjust pointers for zero base address"	endOfMemory _ endOfMemory.	Utilities informUser: 'Relocating object pointers...'				during: [self initializeInterpreter: bytesToShift].! !!ObjectMemory class methodsFor: 'initialization' stamp: 'jm 12/13/1998 13:08'!initialize	"ObjectMemory initialize"	"Translation flags (booleans that control code generation via conditional translation):"	DoAssertionChecks _ false.  "generate assertion checks"	self initializeSpecialObjectIndices.	self initializeObjectHeaderConstants.	LargeContextSize _ 156.	SmallContextSize _ 76.	NilContext _ 1.  "the oop for the integer 0; used to mark the end of context lists"	MinimumForwardTableBytes _ 16000.  "bytes reserved for forwarding table (8 bytes/entry)"	RemapBufferSize _ 25.	RootTableSize _ 2500.  "number of root table entries (4 bytes/entry)"	"tracer actions"	StartField _ 1.	StartObj _ 2.	Upward _ 3.	Done _ 4.! !!TParseNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:13'!bindVariableUsesIn: aDictionary	"Bind uses of all variables in the given dictionary, but do not change variables that appear on the left-hand-side of an assignment statement."	^ self! !!TAssignmentNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:14'!bindVariableUsesIn: aDictionary	"Do NOT bind the variable on the left-hand-side of an assignment statement."	expression _ expression bindVariablesIn: aDictionary.! !!TCaseStmtNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:26'!bindVariableUsesIn: aDictionary	expression _ expression bindVariableUsesIn: aDictionary.	cases _ cases collect: [ :c | c bindVariableUsesIn: aDictionary ].! !!TCaseStmtNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:27'!customizeCase: caseParseTree forVar: varName from: firstIndex to: lastIndex	"Return a collection of copies of the given parse tree, each of which has the value of the case index substituted for the given variable."	| newCases dict newCase |	newCases _ OrderedCollection new.	firstIndex to: lastIndex do: [ :caseIndex |		dict _ Dictionary new.		dict at: varName put: (TConstantNode new setValue: caseIndex).		newCase _ caseParseTree copyTree bindVariableUsesIn: dict.		self fixSharedCodeBlocksForCase: caseIndex in: newCase.		newCases addLast: newCase.	].	^ newCases! !!TCaseStmtNode methodsFor: 'all' stamp: 'jm 12/11/1998 07:49'!customizeShortCasesForDispatchVar: varName	"Make customized versions of a short bytecode methods, substituting a constant having the case index value for the given variable. This produces better code for short bytecodes such as instance variable pushes that encode the index of the instance variable in the bytecode."	| newFirsts newLasts newCases l f case expanded |	newFirsts _ OrderedCollection new.	newLasts _ OrderedCollection new.	newCases _ OrderedCollection new.	1 to: cases size do: [ :i |		l _ lasts at: i.		f _ firsts at: i.		case _ cases at: i.		expanded _ false.		(l - f) > 1 ifTrue: [  "case code covers multiple cases"			case nodeCount < 60 ifTrue: [				newFirsts addAll: (f to: l) asArray.				newLasts addAll: (f to: l) asArray.				newCases addAll: (self customizeCase: case forVar: varName from: f to: l).				expanded _ true.			].		].		expanded ifFalse: [			self fixSharedCodeBlocksForCase: f in: case.			newFirsts addLast: f.			newLasts addLast: l.			newCases addLast: case.		].	].	firsts _ newFirsts asArray.	lasts _ newLasts asArray.	cases _ newCases asArray.! !!TReturnNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:26'!bindVariableUsesIn: aDictionary	expression _ expression bindVariableUsesIn: aDictionary.! !!TSendNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:26'!bindVariableUsesIn: aDictionary	receiver _ receiver bindVariableUsesIn: aDictionary.	arguments _ arguments collect: [ :a | a bindVariableUsesIn: aDictionary ].! !!TStmtListNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:26'!bindVariableUsesIn: aDictionary	statements _ statements collect: [ :s | s bindVariableUsesIn: aDictionary ].! !!TStmtListNode methodsFor: 'all' stamp: 'jm 11/25/1998 16:27'!emitCCodeOn: aStream level: level generator: aCodeGen	statements do: [:s |		level timesRepeat: [aStream tab].		s emitCCodeOn: aStream level: level generator: aCodeGen.		((self endsWithCloseBracket: aStream) or:		 [s isComment])			ifFalse: [aStream nextPut: $;].		aStream cr].! !!TStmtListNode methodsFor: 'all' stamp: 'jm 11/25/1998 16:26'!endsWithCloseBracket: aStream	"Answer true if the given stream ends in a $} character."	| ch pos |	(pos _ aStream position) > 0 ifTrue: [		aStream position: pos - 1.		ch _ aStream next].	^ ch = $}! !!TVariableNode methodsFor: 'all' stamp: 'jm 12/10/1998 18:09'!bindVariableUsesIn: aDictionary	| newNode |	newNode _ aDictionary at: name asSymbol ifAbsent: [ ^self ].	^ newNode copyTree! !!TestCClass1 methodsFor: 'all' stamp: 'jm 11/25/1998 18:09'!method9	"Test conditional code generation."	true ifTrue: [^ 1].	false ifTrue: [^ 'should not be generated'].	true ifFalse: [^ 'should not be generated'].	false ifFalse: [^ 2].	true ifTrue: [^ 3] ifFalse: [^ 'should not be generated'].	false ifTrue: [^ 'should not be generated'] ifFalse: [^ 4].	true ifFalse: [^ 'should not be generated'] ifTrue: [^ 5].	false ifFalse: [^ 6] ifTrue: [^ 'should not be generated'].! !!VariableNode methodsFor: 'C translation' stamp: 'jm 11/25/1998 18:44'!asTranslatorNode	name = 'true' ifTrue: [^ TConstantNode new setValue: true].	name = 'false' ifTrue: [^ TConstantNode new setValue: false].	^ TVariableNode new setName: name! !CCodeGenerator removeSelector: #doInlining!ObjectMemory removeSelector: #recycleContextIfPossible:methodContextClass:!DynamicInterpreter removeSelector: #reportContexts!Interpreter removeSelector: #internalSendSelectorToClass:!Interpreter removeSelector: #reportContexts!Interpreter removeSelector: #sendSelectorToClass:!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows freeContexts interruptCheckCounter displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClassMask CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero DoAssertionChecks Done ExternalObjectsArray FalseObject FloatProto GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextSize MarkBit MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SizeMask SmallBlockContext SmallContextSize SmallMethodContext SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP localHomeContext localReceiver messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache reclaimableContextCount nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals '	classVariableNames: 'ActiveProcessIndex BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex DirBadPath DirEntryFound DirNoMoreEntries ExcessSignalsIndex FirstLinkIndex HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageSelectorIndex MessageSize MethodArrayIndex MethodCacheEntries MethodCacheMask MethodCacheSize MethodIndex MyListIndex NextLinkIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'Squeak-Interpreter'!Object subclass: #TestCClass1	instanceVariableNames: 'x y '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!ObjectMemory initialize!