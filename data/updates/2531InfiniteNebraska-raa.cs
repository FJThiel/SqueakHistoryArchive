'From Squeak2.9alpha of 17 July 2000 [latest update: #2530] on 29 August 2000 at 12:18:40 pm'!"Change Set:		InfiniteNebraskaDate:			28 August 2000Author:			Bob Arning- support for drawing InfiniteForms through Nebraska- reduced memory requirements on client side"!TransformationMorph subclass: #BOBTransformationMorph	instanceVariableNames: 'worldBoundsToShow useRegularWarpBlt '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/28/2000 11:45'!drawSubmorphsOn: aCanvas	(self innerBounds intersects: aCanvas clipRect) ifFalse: [^self].	useRegularWarpBlt == true ifTrue: [		^aCanvas 			transformBy: transform			clippingTo: ((self innerBounds intersect: aCanvas clipRect) expandBy: 1) rounded			during: [:myCanvas |				submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]			]			smoothing: smoothing	].	aCanvas 		transform2By: transform		"#transformBy: for pure WarpBlt"		clippingTo: ((self innerBounds intersect: aCanvas clipRect) expandBy: 1) truncated		during: [:myCanvas |			submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]		]		smoothing: smoothing! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/28/2000 11:26'!useRegularWarpBlt: aBoolean	useRegularWarpBlt _ aBoolean! !!CanvasDecoder methodsFor: 'decoding' stamp: 'RAA 8/28/2000 11:51'!drawImage: command	| image point sourceRect rule cacheID cacheNew previousImage |	image := self class decodeImage: (command at: 2).	point := self class decodePoint: (command at: 3).	sourceRect := self class decodeRectangle: (command at: 4).	rule := self class decodeInteger: (command at: 5).	command size >= 7 ifTrue: [		false ifTrue: [self showSpaceUsed].		"debugging"		cacheID _ self class decodeInteger: (command at: 6).		cacheNew _ (self class decodeInteger: (command at: 7)) = 1.		cacheID > 0 ifTrue: [			CachedForms ifNil: [CachedForms _ Array new: 100].			cacheNew ifTrue: [				CachedForms at: cacheID put: image			] ifFalse: [				previousImage _ CachedForms at: cacheID.				image ifNil: [					image _ previousImage				] ifNotNil: [					previousImage ifNotNil: [						image _ previousImage addDeltasFrom: image.					].					CachedForms at: cacheID put: image				].			].		].	].	self drawCommand: [ :c |		c image: image  at: point  sourceRect: sourceRect rule: rule	]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'RAA 8/25/2000 13:37'!drawInfiniteFill: command	| aRectangle aFillStyle |	aRectangle _ self class decodeRectangle: (command at: 2).	aFillStyle _ InfiniteForm with: (self class decodeImage: (command at: 3)).	self drawCommand: [ :c |		c asBalloonCanvas 			fillRectangle: aRectangle 			fillStyle: aFillStyle.	].! !!CanvasDecoder methodsFor: 'decoding' stamp: 'RAA 8/25/2000 13:34'!processCommand: command  onForceDo: forceBlock	| verb verbCode |	command isEmpty ifTrue: [ ^self ].	verb _ command first.	verbCode := verb at: 1.	verbCode = CanvasEncoder codeClip ifTrue: [ ^self setClip: command ].	verbCode = CanvasEncoder codeTransform ifTrue: [ ^self setTransform: command ].	verbCode = CanvasEncoder codeText ifTrue: [ ^self drawText: command ].	verbCode = CanvasEncoder codeLine ifTrue: [ ^self drawLine: command ].	verbCode = CanvasEncoder codeRect ifTrue: [ ^self drawRect: command ].	verbCode = CanvasEncoder codeBalloonRect ifTrue: [ ^self drawBalloonRect: command ].	verbCode = CanvasEncoder codeInfiniteFill ifTrue: [ ^self drawInfiniteFill: command ].	verbCode = CanvasEncoder codeOval ifTrue: [ ^self drawOval: command ].	verbCode = CanvasEncoder codeImage ifTrue: [ ^self drawImage: command ].	verbCode = CanvasEncoder codeReleaseCache ifTrue: [ ^self releaseImage: command ].	verbCode = CanvasEncoder codePoly ifTrue: [ ^self drawPoly: command ].	verbCode = CanvasEncoder codeStencil ifTrue: [ ^self drawStencil: command ].	verbCode = CanvasEncoder codeForce ifTrue: [ ^self forceToScreen: command withBlock: forceBlock ].	verbCode = CanvasEncoder codeFont ifTrue: [ ^self addFontToCache: command ].	verbCode = CanvasEncoder codeExtentDepth ifTrue: [ ^self extentDepth: command ].self error: 'unknown command: ', command first.! !!CanvasDecoder methodsFor: 'decoding' stamp: 'RAA 8/28/2000 11:46'!showSpaceUsed	| total |	CachedForms ifNil: [^self].	total _ 0.	CachedForms do: [ :each |		each ifNotNil: [			total _ total + (each depth * each width * each height // 8).		].	].	(total // 1024) printString,'     ',	(Smalltalk garbageCollectMost // 1024) printString,'     ' displayAt: 0@0! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 8/25/2000 13:30'!balloonFillRectangle: aRectangle fillStyle: aFillStyle	self sendCommand: {		String with: CanvasEncoder codeBalloonRect.		self class encodeRectangle: aRectangle.		aFillStyle encodeForRemoteCanvas	}! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 8/25/2000 13:12'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	self sendCommand: {		String with: CanvasEncoder codeRect.		self class encodeRectangle: r.		fillColor encodeForRemoteCanvas.		self class encodeInteger: borderWidth.		self class encodeColor: borderColor	}! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 8/25/2000 13:32'!infiniteFillRectangle: aRectangle fillStyle: aFillStyle	self sendCommand: {		String with: CanvasEncoder codeInfiniteFill.		self class encodeRectangle: aRectangle.		aFillStyle encodeForRemoteCanvas	}! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 8/28/2000 11:52'!purgeCache	| spaceUsed spaceBefore s | 	spaceBefore _ spaceUsed _ self purgeCacheInner.	spaceBefore > 8000000 ifTrue: [		Smalltalk garbageCollect.		spaceUsed _ self purgeCacheInner.	].	false ifTrue: [		s _ (spaceBefore // 1024) printString,'  ',(spaceUsed // 1024) printString,'  ',			Time now printString,'     '.		WorldState addDeferredUIMessage: [s displayAt: 0@0.] fixTemps.	].	^spaceUsed! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 8/25/2000 17:27'!purgeCacheInner	| cachedObject totalSize thisSize |	cachedObjects ifNil: [^0].	totalSize _ 0.	cachedObjects withIndexDo: [ :each :index |		cachedObject _ each first first.		cachedObject ifNil: [			each second ifNotNil: [				2 to: each size do: [ :j | each at: j put: nil].				self sendCommand: {					String with: CanvasEncoder codeReleaseCache.					self class encodeInteger: index.				}.			].		] ifNotNil: [			thisSize _ cachedObject depth * cachedObject width * cachedObject height // 8.			totalSize _ totalSize + thisSize.		].	].	^totalSize	"---	newEntry _ {		WeakArray with: anObject.		1.		Time millisecondClockValue.		nil.	}.	---"! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 8/25/2000 15:02'!testCache: anObject	| firstFree cachedObject newEntry |	CachingEnabled ifFalse: [		cachedObjects _ nil.		^nil	].	cachedObjects ifNil: [		cachedObjects _ (1 to: 100) collect: [ :x | {WeakArray new: 1. nil. nil. nil}].	].	self purgeCache.	firstFree _ nil.	cachedObjects withIndexDo: [ :each :index |		cachedObject _ each first first.		firstFree ifNil: [cachedObject ifNil: [firstFree _ index]].		cachedObject == anObject ifTrue: [			each at: 2 put: (each at: 2) + 1.			^{index. false. each}		].	].	firstFree ifNil: [^nil].	newEntry _ {		WeakArray with: anObject.		1.		Time millisecondClockValue.		nil.	}.	cachedObjects at: firstFree put: newEntry.	^{firstFree. true. newEntry}! !!CanvasEncoder class methodsFor: 'codes' stamp: 'RAA 8/25/2000 13:31'!codeInfiniteFill	^$i! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 8/25/2000 13:31'!nameForCode: aStringOrChar	| ch |	ch _ (aStringOrChar isKindOf: String) ifTrue: [aStringOrChar first] ifFalse: [aStringOrChar].	ch == self codeBalloonRect ifTrue: [^'balloon rectangle'].	ch == self codeClip ifTrue: [^'clip'].	ch == self codeExtentDepth ifTrue: [^'codeExtentDepth'].	ch == self codeFont ifTrue: [^'codeFont'].	ch == self codeForce ifTrue: [^'codeForce'].	ch == self codeImage ifTrue: [^'codeImage'].	ch == self codeLine ifTrue: [^'codeLine'].	ch == self codeOval ifTrue: [^'codeOval'].	ch == self codePoly ifTrue: [^'codePoly'].	ch == self codeRect ifTrue: [^'codeRect'].	ch == self codeReleaseCache ifTrue: [^'codeReleaseCache'].	ch == self codeStencil ifTrue: [^'codeStencil'].	ch == self codeText ifTrue: [^'codeText'].	ch == self codeTransform ifTrue: [^'codeTransform'].	ch == self codeInfiniteFill ifTrue: [^'codeInfiniteFill'].	^'????'! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'RAA 8/25/2000 14:42'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	| pattern |	self shadowColor ifNotNil:		[^self fillRectangle: aRectangle color: self shadowColor].	(aFillStyle isKindOf: InfiniteForm) ifTrue: [		^self infiniteFillRectangle: aRectangle fillStyle: aFillStyle	].	(aFillStyle isSolidFill) 		ifTrue:[^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern _ aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead"	self balloonFillRectangle: aRectangle fillStyle: aFillStyle.! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'RAA 8/25/2000 14:42'!infiniteFillRectangle: aRectangle fillStyle: aFillStyle	^aFillStyle displayOnPort: (port clippedBy: aRectangle) at: aRectangle origin - origin! !!InfiniteForm methodsFor: 'as yet unclassified' stamp: 'RAA 8/28/2000 10:27'!encodeForRemoteCanvas	^patternForm encodeForRemoteCanvas! !!NetworkTerminalMorph methodsFor: 'initialization' stamp: 'RAA 8/29/2000 12:17'!openScaled	| window tm |	window _ NetworkTerminalBorderMorph new		minWidth: 100;		minHeight: 100;		borderWidth: 8;		borderColor: Color orange;		bounds: (0@0 extent: Display extent * 3 // 4).	tm _ BOBTransformationMorph new.	tm useRegularWarpBlt: true.		"try to reduce memory used"	window addMorph: tm.	tm addMorph: self.	window openInWorld.! !!NetworkTerminalMorph methodsFor: 'drawing' stamp: 'RAA 8/28/2000 12:06'!forceToFront: aRegion	| highQuality |	"force the given region from the drawing form onto the background form"	highQuality _ false.		"highQuality is slower"	self updateBackgroundForm.	backgroundForm		copy: aRegion		from: aRegion topLeft		in: decoder drawingForm		rule: Form over.	self invalidRect: (		highQuality ifTrue: [			bounds		] ifFalse: [			(aRegion expandBy: 4) translateBy: bounds topLeft	"try to remove gribblys"		]	)! !!NetworkTerminalMorph methodsFor: 'drawing' stamp: 'RAA 8/28/2000 11:28'!updateBackgroundForm	"make sure that our background form matches what the server has most recently requested"	| drawingForm |	drawingForm _ decoder drawingForm.	(drawingForm extent = backgroundForm extent and: [		drawingForm depth = backgroundForm depth ]) ifTrue: [			"they match just fine"			^self ].	backgroundForm _ drawingForm deepCopy.		"need copy to capture the moment"	self extent: backgroundForm extent.! !!NetworkTerminalMorph methodsFor: 'stepping and presenter' stamp: 'RAA 8/28/2000 11:27'!step	decoder ifNil: [ ^self ].	decoder processIOOnForce: [ :rectangle | self forceToFront: rectangle ].	enteringHand ifNotNil: [		self sendEvent: (			MorphicEvent new				setType: #mouseMove				cursorPoint: (self globalPointToLocal: Sensor cursorPoint)				buttons: Sensor primMouseButtons 				keyValue: 0		)	].! !!NetworkTerminalMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/29/2000 12:13'!addScalingMenuItems: menu hand: aHandMorph	"for comaptibility when in scaled frame"! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'RAA 8/25/2000 14:40'!fillRectangle: aRectangle fillStyle: aFillStyle	| pattern |	self shadowColor ifNotNil: [^self fillRectangle: aRectangle color: self shadowColor].	(aFillStyle isKindOf: InfiniteForm) ifTrue: [		^self infiniteFillRectangle: aRectangle fillStyle: aFillStyle	].	aFillStyle isSolidFill ifTrue:[ ^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern _ aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead"	self balloonFillRectangle: aRectangle fillStyle: aFillStyle.! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'RAA 8/25/2000 13:34'!infiniteFillRectangle: aRectangle fillStyle: aFillStyle	self apply: [ :c | c infiniteFillRectangle: aRectangle fillStyle: aFillStyle ]! !!RemoteCanvas methodsFor: 'drawing' stamp: 'RAA 8/25/2000 14:49'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	| pattern |	self shadowColor ifNotNil:		[^self fillRectangle: aRectangle color: self shadowColor].	(aFillStyle isKindOf: InfiniteForm) ifTrue: [		^self infiniteFillRectangle: aRectangle fillStyle: aFillStyle	].	(aFillStyle isSolidFill) 		ifTrue:[^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern _ aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead"	self balloonFillRectangle: aRectangle fillStyle: aFillStyle.! !!RemoteCanvas methodsFor: 'drawing' stamp: 'RAA 8/25/2000 13:13'!frameAndFillRectangle: bounds fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	"Draw the rectangle using the given attributes"	self drawCommand: [ :executor |		executor 			frameAndFillRectangle: bounds 			fillColor: fillColor 			borderWidth: borderWidth 			borderColor: borderColor	].! !!RemoteCanvas methodsFor: 'drawing' stamp: 'RAA 8/25/2000 14:49'!infiniteFillRectangle: aRectangle fillStyle: aFillStyle	self drawCommand: [ :c |		c infiniteFillRectangle: aRectangle fillStyle: aFillStyle	]! !