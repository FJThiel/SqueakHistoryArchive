'From Squeak 2.3 beta of Nov 25, 1998 on 12 January 1999 at 11:21:12 am'!InterpreterPlugin subclass: #BalloonEngineBase	instanceVariableNames: 'workBuffer objBuffer getBuffer aetBuffer spanBuffer engine formArray engineStopped geProfileTime dispatchedValue dispatchReturnValue objUsed doProfileStats '	classVariableNames: 'EdgeInitTable EdgeStepTable FillTable WideLineFillTable WideLineWidthTable '	poolDictionaries: 'BalloonEngineConstants '	category: 'Balloon-Engine'!!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 1/12/1999 11:17'!doProfileStats: aBool	"Note: On Macintosh systems turning on profiling can significantly	degrade the performance of Balloon since we're using the high	accuracy timer for measuring."	"BalloonEngine doProfileStats: true"	"BalloonEngine doProfileStats: false"	<primitive: 'gePrimitiveDoProfileStats'>	^false! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 1/12/1999 10:52'!printStats	"BalloonEngine doProfileStats: true"	"BalloonEngine printStats"	"BalloonEngine resetStats"	Transcript cr; nextPutAll:'/************** BalloonEngine statistics ****************/'.	self printStat: (Times at: 1) count: (Counts at: 1) string: 'Initialization'.	self printStat: (Times at: 2) count: (Counts at: 2) string: 'Finish test'.	self printStat: (Times at: 3) count: (Counts at: 3) string: 'Fetching/Adding GET entries'.	self printStat: (Times at: 4) count: (Counts at: 4) string: 'Adding AET entries'.	self printStat: (Times at: 5) count: (Counts at: 5) string: 'Fetching/Computing fills'.	self printStat: (Times at: 6) count: (Counts at: 6) string: 'Merging fills'.	self printStat: (Times at: 7) count: (Counts at: 7) string: 'Displaying span buffer'.	self printStat: (Times at: 8) count: (Counts at: 8) string: 'Fetching/Updating AET entries'.	self printStat: (Times at: 9) count: (Counts at: 9) string: 'Changing AET entries'.	Transcript cr; print: Times sum; nextPutAll:' mSecs for all operations'.	Transcript cr; print: Counts sum; nextPutAll: ' overall operations'.	Transcript endEntry.! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:38'!gePrimitiveAddActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingForEdge)		ifFalse:[^interpreterProxy primitiveFail].	edge _ self loadEdgeStateFrom: edgeOop.	interpreterProxy failed ifTrue:[^nil].	(self needAvailableSpace: 1) 		ifFalse:[^interpreterProxy primitiveFail].	(self edgeNumLinesOf: edge) > 0 ifTrue:[		self insertEdgeIntoAET: edge.	].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	self statePut: GEStateAddingFromGET. "Back to adding edges from GET"	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"	doProfileStats ifTrue:[		self incrementStat: GWCountAddAETEntry by: 1.		self incrementStat: GWTimeAddAETEntry by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:39'!gePrimitiveChangedActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingChange)		ifFalse:[^interpreterProxy primitiveFail].	edge _ self loadEdgeStateFrom: edgeOop.	interpreterProxy failed ifTrue:[^nil].	(self edgeNumLinesOf: edge) = 0 		ifTrue:[	self removeFirstAETEntry]		ifFalse:[	self resortFirstAETEntry.				self aetStartPut: self aetStartGet + 1].	self statePut: GEStateUpdateEdges. "Back to updating edges"	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"	doProfileStats ifTrue:[		self incrementStat: GWCountChangeAETEntry by: 1.		self incrementStat: GWTimeChangeAETEntry by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:39'!gePrimitiveDisplaySpanBuffer	"Note: Must load bitBlt and spanBuffer"	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateBlitBuffer)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer and bitBlt"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self loadBitBltFrom: 		(interpreterProxy fetchPointer: BEBitBltIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[		self displaySpanBufferAt: self currentYGet.		self postDisplayAction.	].	self finishedProcessing ifFalse:[		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.		self statePut: GEStateUpdateEdges].	self storeEngineStateInto: engine.	doProfileStats ifTrue:[		self incrementStat: GWCountDisplaySpan by: 1.		self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:40'!gePrimitiveInitializeProcessing	"Note: No need to load bitBlt but must load spanBuffer"	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked) 		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for clear operation"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	self initializeGETProcessing.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	self statePut: GEStateAddingFromGET. "Initialized"	interpreterProxy failed ifFalse:[self storeEngineStateInto: engine].	doProfileStats ifTrue:[		self incrementStat: GWCountInitializing by: 1.		self incrementStat: GWTimeInitializing by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:40'!gePrimitiveMergeFillFrom	"Note: No need to load bitBlt but must load spanBuffer"	| fillOop bitsOop value |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	bitsOop _ interpreterProxy stackObjectValue: 1.	engine _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingForFill)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for merging the fill"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	"Check bitmap"	(interpreterProxy fetchClassOf: bitsOop) = interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	"Check fillOop"	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize		ifTrue:[^interpreterProxy primitiveFail].	"Check if this was the fill we have exported"	value _ interpreterProxy fetchInteger: FTIndexIndex ofObject: fillOop.	(self objectIndexOf: self lastExportedFillGet) = value		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchInteger: FTMinXIndex ofObject: fillOop.	self lastExportedLeftXGet = value		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchInteger: FTMaxXIndex ofObject: fillOop.	self lastExportedRightXGet = value		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: bitsOop) < (self lastExportedRightXGet - self lastExportedLeftXGet)		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifTrue:[^nil].	self fillBitmapSpan: (interpreterProxy firstIndexableField: bitsOop)		from: self lastExportedLeftXGet		to: self lastExportedRightXGet.	self statePut: GEStateScanningAET. "Back to scanning AET"	self storeEngineStateInto: engine.	interpreterProxy pop: 2. "Leave rcvr on stack"	doProfileStats ifTrue:[		self incrementStat: GWCountMergeFill by: 1.		self incrementStat: GWTimeMergeFill by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:41'!gePrimitiveNextActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop hasEdge edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUpdateEdges or: GEStateCompleted)		ifFalse:[^interpreterProxy primitiveFail].	hasEdge _ false.	self stateGet = GEStateCompleted ifFalse:[		hasEdge _ self findNextExternalUpdateFromAET.		hasEdge ifTrue:[			edge _ aetBuffer at: self aetStartGet.			self storeEdgeStateFrom: edge into: edgeOop.			"Do not advance to the next aet entry yet"			"self aetStartPut: self aetStartGet + 1."			self statePut: GEStateWaitingChange. "Wait for changed edge"		] ifFalse:[self statePut: GEStateAddingFromGET]. "Start over"	].	interpreterProxy failed ifTrue:[^nil].	self storeEngineStateInto: engine.	interpreterProxy pop: 2.	interpreterProxy pushBool: hasEdge not.	doProfileStats ifTrue:[		self incrementStat: GWCountNextAETEntry by: 1.		self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:41'!gePrimitiveNextFillEntry	"Note: No need to load bitBlt but must load spanBuffer"	| fillOop hasFill |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateScanningAET)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for internal handling of fills"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self loadFormsFrom:		(interpreterProxy fetchPointer: BEFormsIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	"Check if we have to clear the span buffer before proceeding"	(self clearSpanBufferGet = 0) ifFalse:[		(self currentYGet bitAnd: self aaScanMaskGet) = 0			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0].	hasFill _ self findNextExternalFillFromAET.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	hasFill ifTrue:[self storeFillStateInto: fillOop].	interpreterProxy failed ifFalse:[		hasFill			ifTrue:[	self statePut: GEStateWaitingForFill]			ifFalse:[	self wbStackClear.					self spanEndAAPut: 0.					self statePut: GEStateBlitBuffer].		self storeEngineStateInto: engine.		interpreterProxy pop: 2.		interpreterProxy pushBool: hasFill not.		doProfileStats ifTrue:[			self incrementStat: GWCountNextFillEntry by: 1.			self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime)].	].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 1/12/1999 10:41'!gePrimitiveNextGlobalEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop hasEdge edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateAddingFromGET)		ifFalse:[^interpreterProxy primitiveFail].	hasEdge _ self findNextExternalEntryFromGET.	hasEdge ifTrue:[		edge _ getBuffer at: self getStartGet.		self storeEdgeStateFrom: edge into: edgeOop.		self getStartPut: self getStartGet + 1].	interpreterProxy failed ifTrue:[^nil].	hasEdge		ifTrue:[	self statePut: GEStateWaitingForEdge] "Wait for adding edges"		ifFalse:[ "Start scanning the AET"				self statePut: GEStateScanningAET.				self clearSpanBufferPut: 1. "Clear span buffer at next entry"				self aetStartPut: 0.				self wbStackClear].	self storeEngineStateInto: engine.	interpreterProxy pop: 2.	interpreterProxy pushBool: hasEdge not.	doProfileStats ifTrue:[		self incrementStat: GWCountNextGETEntry by: 1.		self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 1/12/1999 10:43'!proceedRenderingImage	"This is the main rendering entry"	| external |	self inline: false.	[self finishedProcessing] whileFalse:[		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		external _ self findNextExternalEntryFromGET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextGETEntry by: 1.			self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self statePut: GEStateWaitingForEdge.			^self stopBecauseOf: GErrorGETEntry.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextFillEntry by: 1.			self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self statePut: GEStateWaitingForFill.			^self stopBecauseOf: GErrorFillEntry.		].		self wbStackClear.		self spanEndAAPut: 0.		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		doProfileStats ifTrue:[			self incrementStat: GWCountDisplaySpan by: 1.			self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		external _ self findNextExternalUpdateFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextAETEntry by: 1.			self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self statePut: GEStateWaitingChange.			^self stopBecauseOf: GErrorAETEntry.		].	].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 1/12/1999 10:45'!proceedRenderingScanline	"Proceed rendering the current scan line.	This method may be called after some Smalltalk code has been executed inbetween."	"This is the main rendering entry"	| external state |	self inline: false.	state _ self stateGet.	state = GEStateUnlocked ifTrue:[		self initializeGETProcessing.		engineStopped ifTrue:[^0].		state _ GEStateAddingFromGET.	]. 	state = GEStateAddingFromGET ifTrue:[		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		external _ self findNextExternalEntryFromGET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextGETEntry by: 1.			self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self statePut: GEStateWaitingForEdge.			^self stopBecauseOf: GErrorGETEntry.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		state _ GEStateScanningAET.	].	state = GEStateScanningAET ifTrue:[		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextFillEntry by: 1.			self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self statePut: GEStateWaitingForFill.			^self stopBecauseOf: GErrorFillEntry.		].		state _ GEStateBlitBuffer.		self wbStackClear.		self spanEndAAPut: 0.	].	state = GEStateBlitBuffer ifTrue:[		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		doProfileStats ifTrue:[			self incrementStat: GWCountDisplaySpan by: 1.			self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		state _ GEStateUpdateEdges.		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.	].	state = GEStateUpdateEdges ifTrue:[		doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].		external _ self findNextExternalUpdateFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextAETEntry by: 1.			self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self statePut: GEStateWaitingChange.			^self stopBecauseOf: GErrorAETEntry.		].		self statePut: GEStateAddingFromGET.	].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 1/12/1999 11:16'!gePrimitiveDoProfileStats	"Turn on/off profiling. Return the old value of the flag."	| oldValue newValue |	self inline: false.	self export: true.	oldValue _ doProfileStats.	newValue _ interpreterProxy stackObjectValue: 0.	newValue _ interpreterProxy booleanValueOf: newValue.	interpreterProxy failed ifFalse:[		doProfileStats _ newValue.		interpreterProxy pop: 2. "Pop rcvr, arg"		interpreterProxy pushBool: oldValue.	].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 1/12/1999 10:39'!gePrimitiveFinishedProcessing	| finished |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ self ioMicroMSecs].	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	finished _ self finishedProcessing.	self storeEngineStateInto: engine.	interpreterProxy pop: 1.	interpreterProxy pushBool: finished.	doProfileStats ifTrue:[		self incrementStat: GWCountFinishTest by: 1.		self incrementStat: GWTimeFinishTest by: (self ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 1/12/1999 10:47'!declareCVarsIn: cg	"Buffers"	cg var: 'workBuffer' declareC:'int *workBuffer'.	cg var: 'objBuffer' declareC:'int *objBuffer'.	cg var: 'getBuffer' declareC:'int *getBuffer'.	cg var: 'aetBuffer' declareC:'int *aetBuffer'.	cg var: 'spanBuffer' declareC:'unsigned int *spanBuffer'.	cg var: 'edgeTransform' declareC: 'float edgeTransform[6]'.	cg var: 'doProfileStats' declareC:'int doProfileStats = 0'.! !!BalloonEngineSimulation methodsFor: 'initialize' stamp: 'ar 1/12/1999 10:38'!initialize	doProfileStats _ false.! !