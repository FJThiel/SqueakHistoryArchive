'From Squeak 2.1 of June 30, 1998 on 8 September 1998 at 12:51:15 pm'!Object subclass: #ServerDirectory	instanceVariableNames: 'server directory type user passwordHolder group moniker altURL urlObject '	classVariableNames: 'Servers '	poolDictionaries: ''	category: 'System-Network'!!ChangeSet methodsFor: 'fileIn/Out' stamp: 'tk 9/2/1998 12:02'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript == nil ifTrue: [postscript _ StringHolder new contents: '"Postscript:Be sure to put comments in double-quotes, as this one is.Put executable statements outside the comment.  Do not put any exclamation points (!!) after them."']! !!FileUrl commentStamp: 'tk 9/8/1998 12:51' prior: 0!A reference to a local file.  The url itself uses the UNIX notation of %20 for space.  path has the tokens translated to ascii, except if we have a UNIX file system. path is OC of path parts.  If last is empty string, then referring to a directory.!!FileUrl methodsFor: 'parsing' stamp: 'tk 9/6/1998 13:05'!privateInitializeFromText: text	| bare schemeName pathString |	bare _ text withBlanksTrimmed.	schemeName _ Url schemeNameForString: bare.	schemeName		ifNil: [ pathString _ bare ]		ifNotNil: [ pathString _ bare copyFrom: (schemeName size + 2) to: bare size ].	path _ pathString findTokens: '/'.	path _ path collect: [:token | token unescapePercents].	(pathString endsWith: '/') ifTrue: [ path addLast: '' ].	isAbsolute _ pathString beginsWith: '/'.! !!FileUrl methodsFor: 'parsing' stamp: 'tk 9/6/1998 16:40'!privateInitializeFromText: aString relativeTo: aUrl	| bare |	bare _ aString.	(bare beginsWith: (self schemeName, ':')) ifTrue: [		bare _ bare copyFrom: (self schemeName size + 2) to: bare size ].	(bare beginsWith: '/') ifTrue: [ ^self privateInitializeFromText: aString ].	isAbsolute _ aUrl isAbsolute.	path _ aUrl path copy.	path removeLast.	"empty string that says its a directory"	(bare findTokens: '/') do: [ :token |		((token ~= '..') and: [token ~= '.']) ifTrue: [ 			path addLast: token unescapePercents ].		token = '..' ifTrue: [ 			path isEmpty ifFalse: [ 				path last = '..' ifFalse: [ path removeLast ] ] ].		"token = '.' do nothing" ].	(bare endsWith: '/') ifTrue: [ path add: '' ].! !!FileUrl methodsFor: 'printing' stamp: 'tk 9/6/1998 13:08'!toText	| s |	s _ WriteStream on: String new.	s nextPutAll: self schemeName.	s nextPut: $:.	s nextPutAll: self pathString.	fragment ifNotNil: [ s nextPut: $#.  s nextPutAll: fragment encodeForHTTP ].	^s contents! !!FileUrl methodsFor: 'access' stamp: 'tk 9/6/1998 00:35'!pathForFile	"Path using local file system's delimiter.  $\ or $:"	| first |	^String streamContents: [ :s |		first _ true.		self path do: [ :p |			first ifFalse: [ s nextPut: FileDirectory default pathNameDelimiter ].			first _ false.			s nextPutAll: p ] ]! !!FileUrl methodsFor: 'access' stamp: 'tk 9/6/1998 13:03'!pathString	"Path as it appears in a URL with $/ as delimiter"	| first |	^String streamContents: [ :s |		isAbsolute ifTrue:[ s nextPut: $/ ].		first _ true.		self path do: [ :p |			first ifFalse: [ s nextPut: $/ ].			first _ false.			s nextPutAll: p encodeForHTTP ] ]! !!FileUrl methodsFor: 'downloading' stamp: 'tk 9/6/1998 00:36'!default	"Use the default local Squeak file directory"	| local |	local _ FileUrl new path: (FileDirectory default pathParts), #('')		isAbsolute: true.	self privateInitializeFromText: self pathString relativeTo: local.		"sets absolute also"! !!FileUrl methodsFor: 'downloading' stamp: 'tk 9/5/1998 20:42'!retrieveContents	| file pathString s dir |		pathString _ self pathForFile.	path last size > 0 ifTrue: [		file _ FileStream oldFileOrNoneNamed: pathString.		file ifNotNil: [ 			^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) content: file contentsOfEntireFile ] ].	"assume it's a directory..."	s _ WriteStream on: String new.	dir _ FileDirectory on: pathString.	(pathString endsWith: '/') ifFalse: [ pathString _ pathString, '/' ].	s nextPutAll: '<title>Directory Listing for ', pathString, '</title>'.	s nextPutAll: '<h1>Directory Listing for ', pathString, '</h1>'.	s nextPutAll: '<ul>'.	s cr.	dir entries do: [ :entry |		s nextPutAll: '<li><a href="'.		s nextPutAll: entry name.		s nextPutAll: '">'.		s nextPutAll: entry name.		s nextPutAll: '</a>'.		s cr. ].	s nextPutAll: '</ul>'.	^MIMEDocument  contentType: 'text/html'  content: s contents  url: ('file:', pathString)! !!FileUrl class methodsFor: 'parsing' stamp: 'tk 9/6/1998 22:48'!absoluteFromText: text	"(how does this method fit with FileUrl|privateInitializeFromText:?)"	| schemeName pathString bare thePath |	bare _ text withBlanksTrimmed.	schemeName _ Url schemeNameForString: bare.	schemeName		ifNil: [ pathString _ bare ]		ifNotNil: [ pathString _ bare copyFrom: (schemeName size + 2) to: bare size ].	thePath _ (pathString findTokens: '/') collect: [:token | token unescapePercents].	(pathString endsWith: '/') ifTrue: [ thePath add: '' ].	^self new path: thePath isAbsolute: (pathString beginsWith: '/')! !!HierarchicalUrl methodsFor: 'access' stamp: 'tk 9/6/1998 12:45'!isAbsolute		path size > 0 ifFalse: [^ false].	(path at: 1) size > 0 ifFalse: [^ false].	^ ((path at: 1) at: 1) ~~ $.! !!ServerDirectory commentStamp: 'tk 9/8/1998 12:51' prior: 0!Holds all the information needed to read or write on a directory of an internet server.  I am used for FTP and HTTP (and STMP?  NNTP?).  The password policy is: unless it is a public password (like annomyous), clear all passwords before any snapshot.  There is a way to store passwords on the disk.server 		'www.disney.com'  or '123.34.56.08' or the ServerDirectory above me 			(if I am a subdirectory sharing the info in a master directory)directory 	'ftp/pubs/'  name of my directory within the server or superdirectory.			(for file://, directory is converted to local delimiters.)type 		#ftp	what you can do in this directoryuser 		'Jones45'password 	an instance of Password.  group 		an Association ('group name' -> an array of ServerDirectorys)			If this first one is down, try the next one.  Store on all of them.  I am in the list.moniker 	'Main Squeak Directory'  Description of this directory.altURL		When a FTP server holds some web pages, the altURL of those pages is often			different from the FTP directory.  Put the altURL here.  If the directory is 			'public_html/Squeak/', the altURL might be 'www.webPage.com/~kaehler2/			Squeak/'.urlObject	An instance of a subclass of Url.  It is very good at parsing complex urls.			Relative references.  file:// uses this.  Use this in the future instead of 			server and directory inst vars.			!]style[(677 8 685)f1,f1LPassword Comment;,f1!!ServerDirectory reorganize!('do ftp' fileExists: getDirectory getFileList getFileNamed: getFileNamed:into: openFTP putFile:named:)('updates' checkNames: checkServers outOfDate: putUpdate: putUpdateMulti:)('accessing' directory: fullPath: groupName moniker moniker: password password: printOn: server: type url url: urlObject urlObject: user:)('file directory' deleteFileNamed: directoryNamed: entries fullNameFor: newFileNamed: oldFileNamed: oldFileOrNoneNamed: on: pathName pathNameDelimiter pathParts rename:toBe: serverDelimiter)('server groups' group group: removeFromGroup)!!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 9/3/1998 12:53'!getFileNamed: fileNameOnServer into: dataStream	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	type == #file ifTrue: [		dataStream nextPutAll: (resp _			FileStream oldFileNamed: server,(self serverDelimiter asString),directory,				(self serverDelimiter asString),fileNameOnServer) contentsOfEntireFile.		^ resp].	type == #http ifTrue: [].	type ifNil: [type _ #ftp].	"type == #ftp"	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; cr.	resp _ dd getDataTo: dataStream whileWatching: so.		"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 9/5/1998 17:20'!checkServers	"Check that all servers are up and have the latest Updates.list.  Return the servers that ready to receiver this update"	| final fileSize this serverList theUpdates decided myUpdates abort strm res |	serverList _ group 			ifNil: [Array with: self] 			ifNotNil: [group value].	final _ OrderedCollection new.	fileSize _ 0.  theUpdates _ ''.	"list of updates"	abort _ false.	serverList do: [:aServer |		decided _ false.		this _ aServer getFileNamed: 'updates.list'.		(this class == String) & (altURL size > 0) ifTrue: [			strm _ HTTPSocket httpGet: altURL accept: 'application/octet-stream'.			strm class == String 				ifTrue: [res _ (PopUpMenu  						labels: 'Install even though not visible\Cancel entire update' withCRs)						startUpWithCaption: 'Server ', aServer moniker, 						' is a weird state.\You cannot store, but users can get updates.\If you store on other servers, the file will not be visible.\Strongly advise that you Cancel.' withCRs]				ifFalse: [					res _ (PopUpMenu labels: 'Install on others\Cancel entire update' withCRs)							startUpWithCaption: 'Server ', aServer moniker, 							' is unavailable\' withCRs, this].			abort _ res ~= 1.			decided _ true].		decided not & (this size > fileSize) ifTrue: ["new has a longer update.list"			fileSize _ this size.			final do: [:each | abort _ self outOfDate: each].			(final _ OrderedCollection new) add: aServer.			theUpdates _ this contentsOfEntireFile. 			decided _ true].		decided not & (this size < fileSize) ifTrue: [abort _ self outOfDate: aServer.  decided _ true].		decided not ifTrue: [myUpdates _ this contentsOfEntireFile.			myUpdates = theUpdates 				ifTrue: [final add: aServer]				ifFalse: [abort _ self outOfDate: this]].		abort ifTrue: [^ Array new].		].	^ final! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/8/1998 11:15'!fullPath: serverAndDirectory	"Parse and save a full path"	| start bare sz |	bare _ serverAndDirectory.	sz _ serverAndDirectory size.	bare size > 0 ifTrue: [ 		start _ (bare copyFrom: 1 to: (8 min: sz)) asLowercase.		(start beginsWith: 'ftp:') 			ifTrue: [type _ #ftp.				bare _ bare copyFrom: (7 min: sz) to: bare size].		(start beginsWith: 'http:') 			ifTrue: [type _ #http.				bare _ bare copyFrom: (8 min: sz) to: serverAndDirectory size].		((start beginsWith: 'file:') or: [type == #file])			ifTrue: [type _ #file.				urlObject _ FileUrl absoluteFromText: serverAndDirectory.				^ self]].	server _ bare copyUpTo: self pathNameDelimiter.	bare size > (server size + 1) 		ifTrue: [directory _ bare copyFrom: server size + 1 to: bare size]		ifFalse: [directory _ ''].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/6/1998 17:09'!moniker	"a plain language name for this directory"	moniker ifNotNil: [^ moniker].	directory ifNotNil: [		^ directory first == $/ 			ifTrue: [server, directory]			ifFalse: [server, '/', directory]].	urlObject ifNotNil: [		^ urlObject toText].	^ ''! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/6/1998 00:43'!type	^ type! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/5/1998 17:20'!url	^ altURL! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/5/1998 17:20'!url: aString	altURL _ aString! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/6/1998 00:44'!urlObject	^ urlObject! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/8/1998 11:56'!urlObject: aUrl	urlObject _ aUrl! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/8/1998 12:45'!directoryNamed: localFileName	"Return a copy of me pointing at this directory below me"	| new |	new _ self deepCopy.	urlObject ifNotNil: [		(new urlObject path) removeLast; addLast: localFileName; addLast: ''.		^ new].	new directory: directory, self pathNameDelimiter asString, localFileName.	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:44'!entries	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name> <creationTime> <modificationTime> <dirFlag> <fileSize>)."	| ftpEntries thisYear tokens dateInSeconds longy |	"We start with ftp directory entries of the form...d---------   1 owner    group               0 Apr 27 22:01 blasttest----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM    1        2   3           4                 5    6  7    8       9   -- token index"	type == #file ifTrue: [		urlObject isAbsolute ifFalse: [urlObject default].		^ (FileDirectory on: urlObject pathForFile) entries].	ftpEntries _ self getDirectory contentsOfEntireFile findTokens: FTPSocket crLf.	thisYear _ Date today year.	^ ftpEntries collect:		[:ftpEntry | tokens _ ftpEntry findTokens: ' '.		tokens size >= 9		ifTrue:		[tokens size > 9 ifTrue:			[longy _ tokens at: 9.			10 to: tokens size do: [:i | longy _ longy , ' ' , (tokens at: i)].			tokens at: 9 put: longy].		dateInSeconds _ ((tokens at: 8) includes: $:)			ifTrue: ["Date has no year -- assume this year"					(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: thisYear) asSeconds +					(Time readFrom: (ReadStream on: (tokens at: 8))) asSeconds]			ifFalse: [(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: (tokens at: 8) asNumber) asSeconds].		DirectoryEntry name: (tokens at: 9)  "file name"			creationTime: dateInSeconds "creation date"			modificationTime: dateInSeconds "modification time"			isDirectory: tokens first first = $d "is-a-directory flag"			fileSize: tokens fifth asNumber "file size"]		ifFalse:		[nil]]		thenSelect: [:entry | entry notNil]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/8/1998 12:36'!fullNameFor: aFileName	urlObject ifNotNil: [^ urlObject pathString, aFileName].	(aFileName includes: self pathNameDelimiter)		ifTrue: [^ aFileName].	^ server, self pathNameDelimiter asString, directory, 		self pathNameDelimiter asString, aFileName! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:27'!newFileNamed: fullName	"Create a RemoteFileStream.  If the file exists, and complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm selection |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file readWrite.	file type == #file ifTrue: [		^ FileStream newFileNamed: (file fileNameRelativeTo: self)].	file exists 		ifTrue: [			selection _ (PopUpMenu labels: 'overwrite that filechoose another namecancel')				startUpWithCaption: (file fullNameFor: file fileName) , 'already exists.']		ifFalse: [selection _ 1].	selection = 1 ifTrue:		[remoteStrm _ RemoteFileStream on: (String new: 2000).		remoteStrm remoteFile: file.		^ remoteStrm].	"no actual writing till close"	selection = 2 ifTrue: [		^ self newFileNamed:			(FillInTheBlank request: 'Enter a new file name'				initialAnswer: file fileName)].	^ nil	"cancel"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:19'!oldFileNamed: aName	"If the file exists, answer a read-only RemoteFileStream on it.  aName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| rFile remoteStrm |	rFile _ self as: ServerFile.	(aName includes: self pathNameDelimiter)		ifTrue: [rFile fullPath: aName]			"sets server, directory(path), fileName.  If relative, merge with self."		ifFalse: [rFile fileName: aName].	"JUST a single NAME, already have the rest"			"Mac files that include / in name, must encode it as %2F "	rFile readOnly.	rFile type == #file ifTrue: [		^ FileStream oldFileNamed: (rFile fileNameRelativeTo: self)].	false ifTrue: [		rFile urlObject isAbsolute ifFalse: [			urlObject isAbsolute 				ifTrue: [rFile urlObject 					privateInitializeFromText: rFile urlObject pathString 					relativeTo: urlObject]				ifFalse: [rFile urlObject default]].	"relative to Squeak directory"		^ FileStream oldFileNamed: rFile urlObject pathForFile, rFile fileName].	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: rFile.	rFile getFileNamed: rFile fileName into: remoteStrm.	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:25'!oldFileOrNoneNamed: fullName	"If the file exists, answer a read-only RemoteFileStream on it. If it doesn't, answer nil.  fullName is directory path, and does include name of the server.  Or just a simple fileName.  Do prefetch the data."	| file remoteStrm |Cursor wait showWhile: 	[type ifNil: [type _ #ftp].	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file readOnly.	file type == #file ifTrue: [		^ FileStream oldFileOrNoneNamed: (file fileNameRelativeTo: self)].	file exists ifFalse: [^ nil].		"on the server"	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	file getFileNamed: file fileName into: remoteStrm].	"prefetch data"	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/8/1998 11:52'!on: fullName	"Answer another ServerDirectory on the partial path name.  fullName is directory path, and does include the name of the server."	| new |	new _ self deepCopy.	new fullPath: fullName.		"sets server, directory(path)"	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/8/1998 12:14'!pathName	urlObject ifNotNil: [^ urlObject pathForFile].	directory size = 0 ifTrue: [^ server].	^ (directory at: 1) = self pathNameDelimiter		ifTrue: [server, directory]		ifFalse: [server, self pathNameDelimiter asString, directory]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/3/1998 12:34'!pathNameDelimiter	"the separator that is used in URLs"	^ $/! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/8/1998 12:12'!pathParts	"Return the path from the root of the file system to this directory as an array of directory names.  On a remote server."	urlObject ifNotNil: [^ (urlObject path copy) removeLast; yourself].	^ (OrderedCollection with: server) addAll: 		(directory findTokens: self pathNameDelimiter asString);			yourself.! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/3/1998 12:36'!serverDelimiter	"the separator that is used in the place where the file actually is.  ftp server or local disk."	^ type == #file: ifTrue: [FileDirectory default pathNameDelimiter]		ifFalse: [^ $/]	"for ftp, http"! !!ServerDirectory class reorganize!('misc' newFrom:)('available servers' addGroup:named: addServer:named: groupNamed: groupNames removeServerNamed: serverNamed: serverNames)!!ServerDirectory class methodsFor: 'misc' stamp: 'tk 9/8/1998 11:57'!newFrom: aSimilarObject	"Must copy the urlObject, so they won't be shared"	| inst |	inst _ super newFrom: aSimilarObject.	inst urlObject: aSimilarObject urlObject copy.	^ inst! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 9/8/1998 10:59'!fileNameRelativeTo: aServerDir	"Produce an absolute fileName from me and an absolute directory"	urlObject isAbsolute ifFalse: [		(aServerDir urlObject ~~ nil and: [aServerDir urlObject isAbsolute]) 			ifTrue: [urlObject 				privateInitializeFromText: urlObject pathString 				relativeTo: aServerDir urlObject]			ifFalse: [urlObject default]].	"relative to Squeak directory"	^ urlObject pathForFile, fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 9/6/1998 17:29'!fullPath: serverAndDirectory	"Parse and save a full path.  Separate out fileName at the end."	| delim ii |	super fullPath: serverAndDirectory.		"set server and directory"	type == #file ifTrue: [fileName _  ''. ^ self].	delim _ self pathNameDelimiter.	ii _ directory findLast: [:c | c = delim].	ii = 0		ifTrue: [self error: 'expecting directory and fileName']		ifFalse: [fileName _ directory copyFrom: ii+1 to: directory size.			directory _ (directory copyFrom: 1 to: directory size - fileName size - 1)].! !!StandardFileStream reorganize!('open/close' close open open:forWrite: openReadOnly reopen reopenGently)('properties-setting' asHtml ascii binary insertLineFeeds isBinary readOnly readWrite readWriteShorten setFileTypeToObject writeShorten writing)('access' containingDirectory directory file fileID fullName isDirectory name peekFor: printOn: reset size)('read, write, position' atEnd flush next next: nextInto: nextPut: nextPutAll: peek position position: readInto:startingAt:count: readOnlyCopy setToEnd skip: upTo: verbatim:)('primitives' primAtEnd: primClose: primCloseGentle: primGetPosition: primOpen:writable: primRead:into:startingAt:count: primSetPosition:to: primSize: primWrite:from:startingAt:count:)!!StandardFileStream methodsFor: 'properties-setting' stamp: 'tk 9/8/1998 11:30'!readWrite	"Set the receiver's mode so that pages are flushed, end of file can be 	extended by writing, and closing does not truncate file."	rwmode _ true! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'tk 9/8/1998 11:31'!readWriteShorten	"Same as readWrite except close truncates file at current position."	self inform: 'Sorry, we do not shorten files.  Delete the file first and then write it.'! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'tk 9/8/1998 11:32'!writeShorten	"Allow write and shorten the receiver's file upon closing."	self inform: 'Sorry, we do not shorten files.  Delete the file first and then write it.'! !"Postscript:Be sure to put comments in double-quotes (""), as this one is.Put executable statements outside the comment.  Do not put any exclamation points (!!) after them."!