'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 28 February 2004 at 2:40:47 pm'!"Change Set:		PNGReadWriterDate:			10 February 2004Author:			Andreas Raab & Ned KonzProvide PNGReadWriter with the ability to write files. In addition, fix some issues with transparency in PNGs which was not handled correctly.v2: Vastly improved version. Includes a test suite which ensures that we can use PNG consistently to save and load Squeak forms.v3: 2/12/2004- Fixed CRC storage- Added CRC validation for reading- Provide logging for test images- Attempt to fix byte-sex problemv4: Some fixes for the PNG reading and writing:* don't crash Squeak when performing tests (fixed in Zlib writer).* generate Adler32 checksum in compressed image chunks so other programs can read Squeak's PNG files.* verify Adler32 checksum in compressed image chunks to detect corruption.* modify test suite so that if you have the PngSuite.zip installed we also check for detection of corrupted files.v5:* Fixed big endian color problems (thanks to Avi)* Added more testsv6: * Fixed final swizzle problems for big endian machinesv7 (NK):* Fixed gzip CRC generation."!ImageReadWriter subclass: #PNGReadWriter	instanceVariableNames: 'chunk form width height depth bitsPerChannel colorType interlaceMethod bitsPerPixel bytesPerScanline thisScanline prevScanline rowSize globalDataChunk unknownChunks palette transparentPixelValue filtersSeen swizzleMap bigEndian backColor cachedDecoderMap '	classVariableNames: 'BPP BlockHeight BlockWidth Debugging StandardColors StandardSwizzleMaps '	poolDictionaries: ''	category: 'Graphics-Files'!TestCase subclass: #PNGReadWriterTest	instanceVariableNames: 'fileName '	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Graphics-Files'!FastInflateStream subclass: #ZLibReadStream	instanceVariableNames: 'adler32 '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compression'!!DeflateStream methodsFor: 'accessing' stamp: 'ar 2/19/2004 00:34'!next: bytes putAll: aCollection startingAt: startPos	(startPos = 1 and:[bytes = aCollection size]) 		ifTrue:[^self nextPutAll: aCollection].	^self nextPutAll: (aCollection copyFrom: startPos to: startPos + bytes - 1)! !!Form methodsFor: '*Croquet-other' stamp: 'ar 12/12/2003 18:24'!fixAlpha	"Fix the alpha channel if the receiver is 32bit"	| bb |	self depth = 32 ifFalse:[^self].	bb := BitBlt toForm: self.	bb combinationRule: 40 "fixAlpha:with:".	bb copyBits.! !!PNGReadWriter methodsFor: 'accessing' stamp: 'ar 2/12/2004 22:40'!nextImage	bigEndian := Smalltalk isBigEndian.	filtersSeen _ Bag new.	globalDataChunk _ nil.	transparentPixelValue _ nil.	unknownChunks _ Set new.	stream reset.	(stream respondsTo: #binary) ifTrue: [ stream binary] .	stream skip: 8.	[stream atEnd] whileFalse: [self processNextChunk].	"Set up our form"	palette ifNotNil:[		"Dump the palette if it's the same as our standard palette"		palette = (StandardColors copyFrom: 1 to: palette size) 			ifTrue:[palette := nil]].	(depth <= 8 and:[palette notNil]) ifTrue:[		form := ColorForm extent: width@height depth: depth.		form colors: palette.	] ifFalse:[		form := Form extent: width@height depth: depth.	].	backColor ifNotNil:[form fillColor: backColor].	chunk _ globalDataChunk.	chunk ifNotNil: [self processIDATChunk].	unknownChunks isEmpty ifFalse: [		"Transcript show: ' ',unknownChunks asSortedCollection asArray printString."	].	self debugging ifTrue: [		Transcript cr; show: 'form = ',form printString.		Transcript cr; show: 'colorType = ',colorType printString.		Transcript cr; show: 'interlaceMethod = ',interlaceMethod printString.		Transcript cr; show: 'filters = ',filtersSeen sortedCounts asArray printString.	].	^ form! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/10/2004 23:55'!processBackgroundChunk	| val red green blue max |	"Transcript show: '  BACKGROUND: ',chunk printString."	colorType = 3 ifTrue: [		backColor := palette at: chunk first + 1.		^self	].	max _ (2 raisedTo: bitsPerChannel) - 1.	(colorType = 0 or: [colorType = 4]) ifTrue: [		val _ chunk unsignedShortAt: 1 bigEndian: true.		backColor := Color gray: val / max.		^self	].	(colorType = 2 or: [colorType = 6]) ifTrue: [		red _ chunk unsignedShortAt: 1 bigEndian: true.		green _ chunk unsignedShortAt: 3 bigEndian: true.		blue _ chunk unsignedShortAt: 5 bigEndian: true.		backColor := Color r: red/max g: green/max b: blue/max.		^self	]."self halt.""====The bKGD chunk specifies a default background color to present the image against. Note that viewers are not bound to honor this chunk; a viewer can choose to use a different background. For color type 3 (indexed color), the bKGD chunk contains:    Palette index:  1 byteThe value is the palette index of the color to be used as background. For color types 0 and 4 (grayscale, with or without alpha), bKGD contains:    Gray:  2 bytes, range 0 .. (2^bitdepth)-1(For consistency, 2 bytes are used regardless of the image bit depth.) The value is the gray level to be used as background. For color types 2 and 6 (truecolor, with or without alpha), bKGD contains:    Red:   2 bytes, range 0 .. (2^bitdepth)-1   Green: 2 bytes, range 0 .. (2^bitdepth)-1   Blue:  2 bytes, range 0 .. (2^bitdepth)-1(For consistency, 2 bytes per sample are used regardless of the image bit depth.) This is the RGB color to be used as background. When present, the bKGD chunk must precede the first IDAT chunk, and must follow the PLTE chunk, if any. ==="! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/10/2004 23:55'!processIHDRChunk	width _ chunk longAt: 1 bigEndian: true.	height _ chunk longAt: 5 bigEndian: true.	bitsPerChannel _ chunk at: 9.	colorType _ chunk at: 10.	"compression _ chunk at: 11." "TODO - validate compression"	"filterMethod _ chunk at: 12." "TODO - validate filterMethod"	interlaceMethod _ chunk at: 13. "TODO - validate interlace method"	(#(2 4 6) includes: colorType)		ifTrue: [depth _ 32].	(#(0 3) includes: colorType) ifTrue: [		depth _ bitsPerChannel min: 8.		colorType = 0 ifTrue: [ "grayscale"			palette := self grayColorsFor: depth.		].	].	bitsPerPixel _ (BPP at: colorType+1) at: bitsPerChannel highBit.	bytesPerScanline _ width * bitsPerPixel + 7 // 8.	rowSize _ width * depth + 31 >> 5.! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/28/2004 14:40'!processInterlaced	| z filter bytesPerPass startingCol colIncrement rowIncrement startingRow cx sc temp |	startingCol _ #(0 4 0 2 0 1 0 ).	colIncrement _ #(8 8 4 4 2 2 1 ).	rowIncrement _ #(8 8 8 4 4 2 2 ).	startingRow _ #(0 0 4 0 2 0 1 ).	z _ ZLibReadStream on: chunk from: 1 to: chunk size.	1 to: 7 do: [:pass |		(self doPass: pass)			ifTrue:				[cx _ colIncrement at: pass.				sc _ startingCol at: pass.				bytesPerPass _ width - sc + cx - 1 // cx * bitsPerPixel + 7 // 8.				prevScanline _ ByteArray new: bytesPerPass.				thisScanline _ ByteArray new: bytesPerScanline.				(startingRow at: pass)					to: height - 1					by: (rowIncrement at: pass)					do: [:y |						filter _ z next.						filtersSeen add: filter.						(filter isNil or: [(filter between: 0 and: 4) not])							ifTrue: [^ self].						thisScanline _ z next: bytesPerPass into: thisScanline startingAt: 1.						self filterScanline: filter count: bytesPerPass.						self copyPixels: y at: sc by: cx.						temp := prevScanline.						prevScanline := thisScanline.						thisScanline := temp.					]				]	].	z verifyAdler32.! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/11/2004 12:14'!processNextChunk	| length chunkType crc chunkCrc |	length _ self nextLong.	chunkType _ (self next: 4) asString.	chunk _ self next: length.	chunkCrc := self nextLong bitXor: 16rFFFFFFFF.	crc := self updateCrc: 16rFFFFFFFF from: 1 to: 4 in: chunkType.	crc := self updateCrc: crc from: 1 to: length in: chunk.	crc = chunkCrc ifFalse:[		self error: 'PNGReadWriter crc error in chunk ', chunkType.	].	chunkType = 'IEND' ifTrue: [^self	"*should* be the last chunk"].	chunkType = 'sBIT' ifTrue: [^self processSBITChunk "could indicate unusual sample depth in original"].	chunkType = 'gAMA' ifTrue: [^self 	"indicates gamma correction value"].	chunkType = 'bKGD' ifTrue: [^self processBackgroundChunk].	chunkType = 'pHYs' ifTrue: [^self processPhysicalPixelChunk].	chunkType = 'tRNS' ifTrue: [^self processTransparencyChunk].	chunkType = 'IHDR' ifTrue: [^self processIHDRChunk].	chunkType = 'PLTE' ifTrue: [^self processPLTEChunk].	chunkType = 'IDAT' ifTrue: [		"---since the compressed data can span multiple		chunks, stitch them all together first. later,		if memory is an issue, we need to figure out how		to do this on the fly---"		globalDataChunk _ globalDataChunk ifNil: [chunk] ifNotNil:			[globalDataChunk,chunk].		^self	].	unknownChunks add: chunkType.! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/28/2004 14:40'!processNonInterlaced	| z filter temp copyMethod debug |	debug := self debugging.	copyMethod _ #(copyPixelsGray: nil copyPixelsRGB: copyPixelsIndexed:		  copyPixelsGrayAlpha: nil copyPixelsRGBA:) at: colorType+1.	debug ifTrue: [ Transcript cr; nextPutAll: 'NI chunk size='; print: chunk size ].	z _ ZLibReadStream on: chunk from: 1 to: chunk size.	prevScanline _ ByteArray new: bytesPerScanline.	thisScanline := ByteArray new: bytesPerScanline.	0 to: height-1 do: [ :y |		filter _ (z next: 1) first.		debug ifTrue:[filtersSeen add: filter].		thisScanline _ z next: bytesPerScanline into: thisScanline startingAt: 1.		(debug and: [ thisScanline size < bytesPerScanline ]) ifTrue: [ Transcript nextPutAll: ('wanted {1} but only got {2}' format: { bytesPerScanline. thisScanline size }); cr ].		filter = 0 ifFalse:[self filterScanline: filter count: bytesPerScanline].		self perform: copyMethod with: y.		temp := prevScanline.		prevScanline := thisScanline.		thisScanline := temp.		].	z verifyAdler32.	debug ifTrue: [Transcript  nextPutAll: ' compressed size='; print: z position  ].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/11/2004 01:02'!processPLTEChunk	| colorCount i |	colorCount _ chunk size // 3. "TODO - validate colorCount against depth"	palette _ Array new: colorCount.	0 to: colorCount-1 do: [ :index |		i _ index * 3 + 1.		palette at: index+1 put:			(Color r: (chunk at: i)/255.0 g: (chunk at: i+1)/255.0 b: (chunk at: i+2)/255.0)		].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 12/12/2003 18:33'!processSBITChunk	| rBits gBits bBits aBits |	colorType = 6 ifFalse:[^self].	rBits := chunk at: 1.	gBits := chunk at: 2.	bBits := chunk at: 3.	aBits := chunk at: 4.	(rBits = 5 and:[gBits = 5 and:[bBits = 5 and:[aBits = 1]]]) ifTrue:[		depth := 16.	].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 1/1/1970 21:00'!copyPixelsIndexed: y	"Handle non-interlaced indexed color mode (colorType = 3)"	| hack hackBlt swizzleHack swizzleBlt scanline hackDepth |	scanline := ByteArray new: bytesPerScanline + 3 // 4 * 4.	scanline replaceFrom: 1 to: thisScanline size with: thisScanline startingAt: 1.	hackDepth := bigEndian ifTrue:[form depth] ifFalse:[form depth negated].	hack := Form extent: width@1 depth: hackDepth bits: scanline.	hackBlt := BitBlt toForm: form.	hackBlt sourceForm: hack.	hackBlt combinationRule: Form over.	hackBlt destOrigin: 0@y.	hackBlt width: width; height: 1.	(form depth < 8 and:[bigEndian not]) ifTrue:[		swizzleHack := Form new hackBits: scanline.		swizzleBlt := BitBlt toForm: swizzleHack.		swizzleBlt sourceForm: swizzleHack.		swizzleBlt combinationRule: Form over.		swizzleBlt colorMap: (StandardSwizzleMaps at: form depth).		swizzleBlt copyBits.	].	hackBlt copyBits.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 10/7/2003 17:31'!copyPixelsRGB: y at: startX by: incX	"Handle interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits xx loopsToDo |	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	loopsToDo _ width - startX + incX - 1 // incX.	bitsPerChannel = 8 ifTrue: [		i _ (startX // incX * 3) + 1.		xx _ startX+1.		1 to: loopsToDo do: [ :j |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: xx put: pixel.			i _ i + 3.			xx _ xx + incX.		]	] ifFalse: [		i _ (startX // incX * 6) + 1.		xx _ startX+1.		1 to: loopsToDo do: [ :j |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: xx put: pixel.			i _ i + 6.			xx _ xx + incX.		].	].	transparentPixelValue ifNotNil: [		startX to: width-1 by: incX do: [ :x |			(tempBits at: x+1) = transparentPixelValue ifTrue: [				tempBits at: x+1 put: 0.			].		].	].	tempForm displayOn: form at: 0@y rule: Form over.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 2/18/2004 23:58'!copyPixelsRGBA: y	"Handle non-interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits ff |	bitsPerChannel = 8 ifTrue: [		ff := Form extent: width@1 depth: 32 bits: thisScanline.		cachedDecoderMap 			ifNil:[cachedDecoderMap := self rgbaDecoderMapForDepth: depth].		(BitBlt toForm: form)			sourceForm: ff;			destOrigin: 0@y;			combinationRule: Form over;			colorMap: cachedDecoderMap;			copyBits.		^self.	].	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	i := -7.	0 to: width-1 do: [ :x |			i := i + 8.			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel.	].	tempForm displayOn: form at: 0@y rule: Form over.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 10/7/2003 17:30'!copyPixelsRGBA: y at: startX by: incX	"Handle interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits |	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	bitsPerChannel = 8 ifTrue: [		i _ (startX // incX << 2) + 1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+3);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x+1 put: pixel.			i _ i + 4.		]	] ifFalse: [		i _ (startX // incX << 3) +1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel.			i _ i + 8.		].	].	tempForm displayOn: form at: 0@y rule: Form over.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 2/19/2004 00:10'!rgbaDecoderMapForDepth: decoderDepth	bigEndian ifTrue:[		depth = 16 ifTrue:[			"Big endian, 32 -> 16 color mapping."			^ColorMap				shifts: #(-17 -14 -11 0)				masks: #(16rF8000000 16rF80000 16rF800 16r00)		] ifFalse:[			"Big endian, 32 -> 32 color mapping"			^ColorMap 				shifts: #(-8 -8 -8 24) 				masks: #(16rFF000000 16rFF0000 16rFF00 16rFF).		].	].	depth = 16 ifTrue:[		"Little endian, 32 -> 16 color mapping."		^ColorMap			shifts: #(7 -6 -19 0)			masks: #(16rF8 16rF800 16rF80000 0)	] ifFalse:[		"Little endian, 32 -> 32 color mapping"		^ColorMap 			shifts: #(-16 0 16 0) 			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000).	].! !!PNGReadWriter methodsFor: 'miscellaneous' stamp: 'ar 2/11/2004 01:27'!grayColorsFor: d	"return a color table for a gray image"	palette _ Array new: 1<<d.	d = 1 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: Color white.		^ palette,{Color transparent}		].	d = 2 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: (Color gray: 85.0 / 255.0).		palette at: 3 put: (Color gray: 170.0 / 255.0).		palette at: 4 put: Color white.		^ palette,{Color transparent}.		].	d = 4 ifTrue: [		0 to: 15 do: [ :g |			palette at: g+1 put: (Color gray: (g/15) asFloat) ].		^ palette,{Color transparent}		].	d = 8 ifTrue: [		0 to: 255 do: [ :g |			palette at: g+1 put: (Color gray: (g/255) asFloat) ].		^ palette		"??transparent??"		].! !!PNGReadWriter methodsFor: 'writing' stamp: 'ar 12/12/2003 16:37'!nextPutImage: aForm	"Write out the given form. We're keeping it simple here, no interlacing, no filters."	^self nextPutImage: aForm interlace: 0 filter: 0. "no filtering"! !!PNGReadWriter methodsFor: 'writing' stamp: 'ar 2/12/2004 22:40'!nextPutImage: aForm interlace: aMethod filter: aFilterType	"Note: For now we keep it simple - interlace and filtering are simply ignored"	| crcStream |	bigEndian := Smalltalk isBigEndian.	form := aForm.	width := aForm width.	height := aForm height.	aForm depth <= 8 ifTrue:[		bitsPerChannel := aForm depth.		colorType := 3.		bytesPerScanline _ width * aForm depth + 7 // 8.	] ifFalse:[		bitsPerChannel := 8.		colorType := 6.		bytesPerScanline _ width * 4.	].	self writeFileSignature.	crcStream := WriteStream on: (ByteArray new: 1000).	crcStream resetToStart.	self writeIHDRChunkOn: crcStream.	self writeChunk: crcStream.	(form depth <= 8) ifTrue:[		crcStream resetToStart.		self writePLTEChunkOn: crcStream.		self writeChunk: crcStream.		(form isKindOf: ColorForm) ifTrue:[			crcStream resetToStart.			self writeTRNSChunkOn: crcStream.			self writeChunk: crcStream.		].	].	form depth = 16 ifTrue:[		crcStream resetToStart.		self writeSBITChunkOn: crcStream.		self writeChunk: crcStream.	].	crcStream resetToStart.	self writeIDATChunkOn: crcStream.	self writeChunk: crcStream.	crcStream resetToStart.	self writeIENDChunkOn: crcStream.	self writeChunk: crcStream.! !!PNGReadWriter methodsFor: 'writing' stamp: 'nk 2/17/2004 16:51'!updateCrc: oldCrc from: start to: stop in: aCollection	^ZipWriteStream updateCrc: oldCrc from: start to: stop in: aCollection! !!PNGReadWriter methodsFor: 'writing' stamp: 'nk 2/17/2004 16:04'!writeChunk: crcStream	| bytes length crc debug |	debug _ self debugging.	bytes := crcStream originalContents.	length := crcStream position.	crc := self updateCrc: 16rFFFFFFFF from: 1 to: length in: bytes.	crc := crc bitXor: 16rFFFFFFFF.	debug ifTrue: [ Transcript cr;		print: stream position; space;		nextPutAll: (bytes copyFrom: 1 to: 4) asString;		nextPutAll: ' len='; print: length;		nextPutAll: ' crc=0x'; nextPutAll: crc hex  ].	stream nextNumber: 4 put: length-4. "exclude chunk name"	stream next: length putAll: bytes startingAt: 1.	stream nextNumber: 4 put: crc.	debug ifTrue: [ Transcript nextPutAll: ' afterPos='; print: stream position ].	crcStream resetToStart.! !!PNGReadWriter methodsFor: 'writing' stamp: 'ar 12/12/2003 16:40'!writeFileSignature	stream nextPutAll: #(16r89 16r50 16r4E  16r47 16r0D 16r0A 16r1A 16r0A) asByteArray! !!PNGReadWriter methodsFor: 'writing' stamp: 'nk 2/17/2004 14:57'!writeIDATChunkOn: aStream	"Write the IDAT chunk"	| z |	aStream nextPutAll: 'IDAT' asByteArray.	z _ ZLibWriteStream on: aStream.	form depth <= 8 		ifTrue:[self writeType3DataOn: z]		ifFalse:[ self writeType6DataOn: z].	self debugging ifTrue: [		Transcript cr;			nextPutAll: 'compressed size=';			print: aStream position;			nextPutAll: ' uncompressed size=';			print: z position  ]! !!PNGReadWriter methodsFor: 'writing' stamp: 'ar 12/12/2003 17:08'!writeIENDChunkOn: aStream	"Write the IEND chunk"	aStream nextPutAll: 'IEND' asByteArray.! !!PNGReadWriter methodsFor: 'writing' stamp: 'ar 12/12/2003 17:21'!writeIHDRChunkOn: aStream	"Write the IHDR chunk"	aStream nextPutAll: 'IHDR' asByteArray.	aStream nextInt32Put: width.	aStream nextInt32Put: height.	aStream nextNumber: 1 put: bitsPerChannel.	aStream nextNumber: 1 put: colorType.	aStream nextNumber: 1 put: 0. "compression"	aStream nextNumber: 1 put: 0. "filter method"	aStream nextNumber: 1 put: 0. "interlace method"! !!PNGReadWriter methodsFor: 'writing' stamp: 'ar 12/12/2003 17:36'!writePLTEChunkOn: aStream	"Write the PLTE chunk"	| r g b colors |	aStream nextPutAll: 'PLTE' asByteArray.	(form isKindOf: ColorForm) 		ifTrue:[colors := form colors]		ifFalse:[colors := Color indexedColors copyFrom: 1 to: (1 bitShift: form depth)].	colors do:[:aColor|		r := (aColor red * 255) truncated.		g := (aColor green * 255) truncated.		b := (aColor blue * 255) truncated.		aStream nextPut: r; nextPut: g; nextPut: b.	].! !!PNGReadWriter methodsFor: 'writing' stamp: 'ar 12/12/2003 18:29'!writeSBITChunkOn: aStream	"Write the IDAT chunk"	aStream nextPutAll: 'sBIT' asByteArray.	form depth = 16 ifFalse:[self error: 'Unimplemented feature'].	aStream nextPut: 5.	aStream nextPut: 5.	aStream nextPut: 5.	aStream nextPut: 1.! !!PNGReadWriter methodsFor: 'writing' stamp: 'ar 12/12/2003 17:34'!writeTRNSChunkOn: aStream	"Write out tRNS chunk"	aStream nextPutAll: 'tRNS' asByteArray.	form colors do:[:aColor|		aStream nextPut: (aColor alpha * 255) truncated.	].! !!PNGReadWriter methodsFor: 'writing' stamp: 'ar 1/1/1970 20:58'!writeType3DataOn: zStream	"Write color indexed data."	| scanline hack hackBlt swizzleBlt swizzleHack hackDepth |	scanline := ByteArray new: bytesPerScanline + 3 // 4 * 4.	hackDepth := bigEndian ifTrue:[form depth] ifFalse:[form depth negated].	hack := Form extent: width@1 depth: hackDepth bits: scanline.	hackBlt := BitBlt toForm: hack.	hackBlt sourceForm: form.	hackBlt combinationRule: Form over.	hackBlt destOrigin: 0@0.	hackBlt width: width; height: 1.	(form depth < 8 and:[bigEndian not]) ifTrue:[		swizzleHack := Form new hackBits: scanline.		swizzleBlt := BitBlt toForm: swizzleHack.		swizzleBlt sourceForm: swizzleHack.		swizzleBlt combinationRule: Form over.		swizzleBlt colorMap: (StandardSwizzleMaps at: form depth).	].	0 to: height-1 do:[:i|		hackBlt sourceOrigin: 0@i; copyBits.		swizzleBlt ifNotNil:[swizzleBlt copyBits].		zStream nextPut: 0. "filterType"		zStream next: bytesPerScanline putAll: scanline startingAt: 1.	].	zStream close.! !!PNGReadWriter methodsFor: 'writing' stamp: 'ar 2/19/2004 00:10'!writeType6DataOn: zStream	"Write RGBA data."	| scanline hack hackBlt cm miscBlt |	scanline := ByteArray new: bytesPerScanline.	hack := Form extent: width@1 depth: 32 bits: scanline.	form depth = 16 ifTrue:[		"Expand 16 -> 32"		miscBlt := BitBlt toForm: hack.		miscBlt sourceForm: form.		miscBlt combinationRule: Form over.		miscBlt destOrigin: 0@0.		miscBlt width: width; height: 1.	].	hackBlt := BitBlt toForm: hack.	hackBlt sourceForm: (miscBlt ifNil:[form] ifNotNil:[hack]).	hackBlt combinationRule: Form over.	hackBlt destOrigin: 0@0.	hackBlt width: width; height: 1.	bigEndian ifTrue:[		cm := ColorMap 			shifts: #(8 8 8 -24) 			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000).	] ifFalse:[		cm := ColorMap 			shifts: #(-16 0 16 0) 			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000).	].	hackBlt colorMap: cm.	0 to: height-1 do:[:i|		miscBlt ifNil:[			hackBlt sourceOrigin: 0@i; copyBits.		] ifNotNil:[			miscBlt sourceOrigin: 0@i; copyBits.			hack fixAlpha.			hackBlt copyBits.		].		zStream nextPut: 0. "filterType"		zStream nextPutAll: scanline.	].	zStream close.! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'ar 2/11/2004 00:54'!computeSwizzleMapForDepth: depth	"Answer a map that maps pixels in a word to their opposite location. Used for 'middle-endian' forms where the byte-order is different from the bit order (good joke, eh?)."	| map swizzled |	map := Bitmap new: 256.	depth = 4 ifTrue:[		0 to: 255 do:[:pix|			swizzled := 0.			swizzled := swizzled bitOr: (((pix bitShift: 0) bitAnd: 15) bitShift: 4).			swizzled := swizzled bitOr: (((pix bitShift: -4) bitAnd: 15) bitShift: 0).			map at: pix+1 put: swizzled.		].		^ColorMap colors: map	].	depth = 2 ifTrue:[		0 to: 255 do:[:pix|			swizzled := 0.			swizzled := swizzled bitOr: (((pix bitShift: 0) bitAnd: 3) bitShift: 6).			swizzled := swizzled bitOr: (((pix bitShift: -2) bitAnd: 3) bitShift: 4).			swizzled := swizzled bitOr: (((pix bitShift: -4) bitAnd: 3) bitShift: 2).			swizzled := swizzled bitOr: (((pix bitShift: -6) bitAnd: 3) bitShift: 0).			map at: pix+1 put: swizzled.		].		^ColorMap colors: map	].	depth = 1 ifTrue:[		0 to: 255 do:[:pix|			swizzled := 0.			swizzled := swizzled bitOr: (((pix bitShift: 0) bitAnd: 1) bitShift: 7).			swizzled := swizzled bitOr: (((pix bitShift: -1) bitAnd: 1) bitShift: 6).			swizzled := swizzled bitOr: (((pix bitShift: -2) bitAnd: 1) bitShift: 5).			swizzled := swizzled bitOr: (((pix bitShift: -3) bitAnd: 1) bitShift: 4).			swizzled := swizzled bitOr: (((pix bitShift: -4) bitAnd: 1) bitShift: 3).			swizzled := swizzled bitOr: (((pix bitShift: -5) bitAnd: 1) bitShift: 2).			swizzled := swizzled bitOr: (((pix bitShift: -6) bitAnd: 1) bitShift: 1).			swizzled := swizzled bitOr: (((pix bitShift: -7) bitAnd: 1) bitShift: 0).			map at: pix+1 put: swizzled.		].		^ColorMap colors: map	].	self error: 'Unrecognized depth'! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'ar 2/11/2004 00:55'!initialize	"	PNGReadWriter initialize	"	BPP _ {	#(1 2 4 8 16).			#(0 0 0 0 0).			#(0 0 0 24 48).			#(1 2 4 8 0).			#(0 0 0 16 32).			#(0 0 0 0 0).			#(0 0 0 32 64).			#(0 0 0 0 0) }.	BlockHeight _ #(8 8 4 4 2 2 1).	BlockWidth _ #(8 4 4 2 2 1 1).	StandardColors := Color indexedColors collect:[:aColor|		Color 			r: (aColor red * 255) truncated / 255			g: (aColor green * 255) truncated / 255			b: (aColor blue * 255) truncated / 255.	].	StandardSwizzleMaps := Array new: 4.	#(1 2 4) do:[:i| StandardSwizzleMaps at: i put: (self computeSwizzleMapForDepth: i)].! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/12/2004 22:50'!test16Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 16))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 00:39'!test16BitDisplay	self encodeAndDecodeDisplay: 16! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 01:57'!test16BitReversed	self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 16))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/12/2004 22:50'!test1Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 1))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 00:43'!test1BitColors	self encodeAndDecodeWithColors: (self drawStuffOn: (Form extent: 33@33 depth: 1))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 00:39'!test1BitDisplay	self encodeAndDecodeDisplay: 1! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 01:56'!test1BitReversed	self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 1))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/12/2004 22:50'!test2Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 2))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 00:43'!test2BitColors	self encodeAndDecodeWithColors: (self drawStuffOn: (Form extent: 33@33 depth: 2))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 00:39'!test2BitDisplay	self encodeAndDecodeDisplay: 2! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 01:56'!test2BitReversed	self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 2))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/12/2004 22:50'!test32Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 32))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 00:39'!test32BitDisplay	self encodeAndDecodeDisplay: 32! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 01:57'!test32BitReversed	self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 32))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/12/2004 22:50'!test4Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 4))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 00:44'!test4BitColors	self encodeAndDecodeWithColors: (self drawStuffOn: (Form extent: 33@33 depth: 4))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 00:39'!test4BitDisplay	self encodeAndDecodeDisplay: 4! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 01:56'!test4BitReversed	self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 4))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/12/2004 22:50'!test8Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 8))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 00:44'!test8BitColors	self encodeAndDecodeWithColors: (self drawStuffOn: (Form extent: 33@33 depth: 8))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 00:39'!test8BitDisplay	self encodeAndDecodeDisplay: 8! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/11/2004 01:57'!test8BitReversed	self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 8))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/12/2004 22:49'!testAlphaCoding	self encodeAndDecodeAlpha: (self drawTransparentStuffOn: (Form extent: 33@33 depth: 32))! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'nk 2/17/2004 18:14'!testPngSuite	"Requires the suite from 		ftp://swrinde.nde.swri.edu/pub/png/images/suite/PngSuite.zip	to be present as PngSuite.zip"	| file zip entries |	[file := FileStream readOnlyFileNamed: 'PngSuite.zip'] on: Error do:[:ex| ex return].	file ifNil:[^self].	[zip := ZipArchive new readFrom: file.	entries := zip members select:[:mbr| mbr fileName asLowercase endsWith: '.png'].	entries do:[:mbr| 		(mbr fileName asLowercase first = $x)			ifTrue: [ self should: [ self encodeAndDecodeStream: mbr contentStream ] raise: Error ]			ifFalse: [	self encodeAndDecodeStream: mbr contentStream ] ].	] ensure:[file close].! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:50'!testBlack16	self encodeAndDecodeColor: Color blue depth: 16! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:50'!testBlack32	self encodeAndDecodeColor: Color blue depth: 32! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:50'!testBlack8	self encodeAndDecodeColor: Color blue depth: 8! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:50'!testBlue16	self encodeAndDecodeColor: Color blue depth: 16! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:50'!testBlue32	self encodeAndDecodeColor: Color blue depth: 32! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:50'!testBlue8	self encodeAndDecodeColor: Color blue depth: 8! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:50'!testGreen16	self encodeAndDecodeColor: Color green depth: 16! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:50'!testGreen32	self encodeAndDecodeColor: Color green depth: 32! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:49'!testGreen8	self encodeAndDecodeColor: Color green depth: 8! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:49'!testRed16	self encodeAndDecodeColor: Color red depth: 16! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:48'!testRed32	self encodeAndDecodeColor: Color red depth: 32! !!PNGReadWriterTest methodsFor: 'colors' stamp: 'ar 2/18/2004 23:49'!testRed8	self encodeAndDecodeColor: Color red depth: 8! !!PNGReadWriterTest methodsFor: 'decoding' stamp: 'ar 2/19/2004 00:25'!coloredFiles16	"Created by		{Color red. Color green. Color blue. Color black} collect:[:fillC|			| ff bytes |			ff := Form extent: 32@32 depth: 16.			ff fillColor: fillC.			bytes := WriteStream on: ByteArray new.			PNGReadWriter putForm: ff onStream: bytes.			fillC ->				(Base64MimeConverter mimeEncode: (bytes contents readStream)) contents		].	"	^{Color red-> 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQFBQUBSsjp7wAAADZJREFUeF7lziEBAAAMAjD6J8b9MRAT80uT65Af8AN+wA/4AT/gB/yAH/ADfsAP+AE/4AfmgQdcz9xqBS2pdAAAAABJRU5ErkJggg=='.	Color green->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQFBQUBSsjp7wAAADVJREFUeF7lziEBAAAMAjD6J77jMRAT80sunfIDfsAP+AE/4Af8gB/wA37AD/gBP+AH/MA68HyT3Gqf2I6NAAAAAElFTkSuQmCC'.		Color blue->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQFBQUBSsjp7wAAADVJREFUeF7lziEBAAAMAjD6J77jMRAT80ty3fIDfsAP+AE/4Af8gB/wA37AD/gBP+AH/MA48JxX3GpYhihrAAAAAElFTkSuQmCC'.	Color black->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQFBQUBSsjp7wAAADVJREFUeF7lziEBAAAMAjDk+xfmMRAT80ty3fIDfsAP+AE/4Af8gB/wA37AD/gBP+AH/MA48LbTHD3MKH3GAAAAAElFTkSuQmCC'}! !!PNGReadWriterTest methodsFor: 'decoding' stamp: 'ar 2/19/2004 00:24'!coloredFiles32	"Created by		{Color red. Color green. Color blue. Color black} collect:[:fillC|			| ff bytes |			ff := Form extent: 32@32 depth: 32.			ff fillColor: fillC.			bytes := WriteStream on: ByteArray new.			PNGReadWriter putForm: ff onStream: bytes.			fillC ->				(Base64MimeConverter mimeEncode: (bytes contents readStream)) contents		].	"	^{		Color red -> 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAANUlEQVR4XuXOIQEAAAwEoe9f+hZjAoFnbfVo+QE/4Af8gB/wA37AD/gBP+AH/IAf8AN+4DlwVA34ajP6EEoAAAAASUVORK5CYII='.		Color green -> 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAM0lEQVR4XuXOMQ0AAAACIPuX1hgejAIkPfMDfsAP+AE/4Af8gB/wA37AD/gBP+AH/MA7MFfR+Grvv2BdAAAAAElFTkSuQmCC'.	Color blue->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAANElEQVR4XuXOIQEAAAACIP+f1hkGAp0k7Zcf8AN+wA/4AT/gB/yAH/ADfsAP+AE/4AfOgQFblfhqnnPWHAAAAABJRU5ErkJggg=='.		Color black -> 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAANUlEQVR4XuXOMQEAAAwCINc/tIvhwcFPkuuWH/ADfsAP+AE/4Af8gB/wA37AD/gBP+AHxoEH95UAPU59TTMAAAAASUVORK5CYII='}! !!PNGReadWriterTest methodsFor: 'decoding' stamp: 'ar 2/19/2004 00:19'!coloredFiles8	"Created by		{Color red. Color green. Color blue. Color black} collect:[:fillC|			| ff bytes |			ff := Form extent: 32@32 depth: 8.			ff fillColor: fillC.			bytes := WriteStream on: ByteArray new.			PNGReadWriter putForm: ff onStream: bytes.			fillC ->				(Base64MimeConverter mimeEncode: (bytes contents readStream)) contents		].	"	^{Color red->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAADAFBMVEX///8AAAD///9/f3//AAAA/wAAAP8A/////wD/AP8fHx8/Pz9fX1+fn5+/v7/f398HBwcPDw8XFxcnJycvLy83NzdHR0dPT09XV1dnZ2dvb293d3eHh4ePj4+Xl5enp6evr6+3t7fHx8fPz8/X19fn5+fv7+/39/cAAAAAMgAAZQAAmAAAywAA/wAAADIAMjIAZTIAmDIAyzIA/zIAAGUAMmUAZWUAmGUAy2UA/2UAAJgAMpgAZZgAmJgAy5gA/5gAAMsAMssAZcsAmMsAy8sA/8sAAP8AMv8AZf8AmP8Ay/8A//8yAAAyMgAyZQAymAAyywAy/wAyADIyMjIyZTIymDIyyzIy/zIyAGUyMmUyZWUymGUyy2Uy/2UyAJgyMpgyZZgymJgyy5gy/5gyAMsyMssyZcsymMsyy8sy/8syAP8yMv8yZf8ymP8yy/8y//9lAABlMgBlZQBlmABlywBl/wBlADJlMjJlZTJlmDJlyzJl/zJlAGVlMmVlZWVlmGVly2Vl/2VlAJhlMphlZZhlmJhly5hl/5hlAMtlMstlZctlmMtly8tl/8tlAP9lMv9lZf9lmP9ly/9l//+YAACYMgCYZQCYmACYywCY/wCYADKYMjKYZTKYmDKYyzKY/zKYAGWYMmWYZWWYmGWYy2WY/2WYAJiYMpiYZZiYmJiYy5iY/5iYAMuYMsuYZcuYmMuYy8uY/8uYAP+YMv+YZf+YmP+Yy/+Y///LAADLMgDLZQDLmADLywDL/wDLADLLMjLLZTLLmDLLyzLL/zLLAGXLMmXLZWXLmGXLy2XL/2XLAJjLMpjLZZjLmJjLy5jL/5jLAMvLMsvLZcvLmMvLy8vL/8vLAP/LMv/LZf/LmP/Ly//L////AAD/MgD/ZQD/mAD/ywD//wD/ADL/MjL/ZTL/mDL/yzL//zL/AGX/MmX/ZWX/mGX/y2X//2X/AJj/Mpj/ZZj/mJj/y5j//5j/AMv/Msv/Zcv/mMv/y8v//8v/AP//Mv//Zf//mP//y/////9ECiHUAAAAGklEQVR4XmO4cwc/YLgz8hWMfAUjX8EIVQAAbnlwLukXXkcAAAAASUVORK5CYII='.	Color green->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAADAFBMVEX///8AAAD///9/f3//AAAA/wAAAP8A/////wD/AP8fHx8/Pz9fX1+fn5+/v7/f398HBwcPDw8XFxcnJycvLy83NzdHR0dPT09XV1dnZ2dvb293d3eHh4ePj4+Xl5enp6evr6+3t7fHx8fPz8/X19fn5+fv7+/39/cAAAAAMgAAZQAAmAAAywAA/wAAADIAMjIAZTIAmDIAyzIA/zIAAGUAMmUAZWUAmGUAy2UA/2UAAJgAMpgAZZgAmJgAy5gA/5gAAMsAMssAZcsAmMsAy8sA/8sAAP8AMv8AZf8AmP8Ay/8A//8yAAAyMgAyZQAymAAyywAy/wAyADIyMjIyZTIymDIyyzIy/zIyAGUyMmUyZWUymGUyy2Uy/2UyAJgyMpgyZZgymJgyy5gy/5gyAMsyMssyZcsymMsyy8sy/8syAP8yMv8yZf8ymP8yy/8y//9lAABlMgBlZQBlmABlywBl/wBlADJlMjJlZTJlmDJlyzJl/zJlAGVlMmVlZWVlmGVly2Vl/2VlAJhlMphlZZhlmJhly5hl/5hlAMtlMstlZctlmMtly8tl/8tlAP9lMv9lZf9lmP9ly/9l//+YAACYMgCYZQCYmACYywCY/wCYADKYMjKYZTKYmDKYyzKY/zKYAGWYMmWYZWWYmGWYy2WY/2WYAJiYMpiYZZiYmJiYy5iY/5iYAMuYMsuYZcuYmMuYy8uY/8uYAP+YMv+YZf+YmP+Yy/+Y///LAADLMgDLZQDLmADLywDL/wDLADLLMjLLZTLLmDLLyzLL/zLLAGXLMmXLZWXLmGXLy2XL/2XLAJjLMpjLZZjLmJjLy5jL/5jLAMvLMsvLZcvLmMvLy8vL/8vLAP/LMv/LZf/LmP/Ly//L////AAD/MgD/ZQD/mAD/ywD//wD/ADL/MjL/ZTL/mDL/yzL//zL/AGX/MmX/ZWX/mGX/y2X//2X/AJj/Mpj/ZZj/mJj/y5j//5j/AMv/Msv/Zcv/mMv/y8v//8v/AP//Mv//Zf//mP//y/////9ECiHUAAAAGUlEQVR4XmPQ1cUPGHRHvoKRr2DkKxihCgBZ3bQBCq5u/AAAAABJRU5ErkJggg=='.	Color blue->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAADAFBMVEX///8AAAD///9/f3//AAAA/wAAAP8A/////wD/AP8fHx8/Pz9fX1+fn5+/v7/f398HBwcPDw8XFxcnJycvLy83NzdHR0dPT09XV1dnZ2dvb293d3eHh4ePj4+Xl5enp6evr6+3t7fHx8fPz8/X19fn5+fv7+/39/cAAAAAMgAAZQAAmAAAywAA/wAAADIAMjIAZTIAmDIAyzIA/zIAAGUAMmUAZWUAmGUAy2UA/2UAAJgAMpgAZZgAmJgAy5gA/5gAAMsAMssAZcsAmMsAy8sA/8sAAP8AMv8AZf8AmP8Ay/8A//8yAAAyMgAyZQAymAAyywAy/wAyADIyMjIyZTIymDIyyzIy/zIyAGUyMmUyZWUymGUyy2Uy/2UyAJgyMpgyZZgymJgyy5gy/5gyAMsyMssyZcsymMsyy8sy/8syAP8yMv8yZf8ymP8yy/8y//9lAABlMgBlZQBlmABlywBl/wBlADJlMjJlZTJlmDJlyzJl/zJlAGVlMmVlZWVlmGVly2Vl/2VlAJhlMphlZZhlmJhly5hl/5hlAMtlMstlZctlmMtly8tl/8tlAP9lMv9lZf9lmP9ly/9l//+YAACYMgCYZQCYmACYywCY/wCYADKYMjKYZTKYmDKYyzKY/zKYAGWYMmWYZWWYmGWYy2WY/2WYAJiYMpiYZZiYmJiYy5iY/5iYAMuYMsuYZcuYmMuYy8uY/8uYAP+YMv+YZf+YmP+Yy/+Y///LAADLMgDLZQDLmADLywDL/wDLADLLMjLLZTLLmDLLyzLL/zLLAGXLMmXLZWXLmGXLy2XL/2XLAJjLMpjLZZjLmJjLy5jL/5jLAMvLMsvLZcvLmMvLy8vL/8vLAP/LMv/LZf/LmP/Ly//L////AAD/MgD/ZQD/mAD/ywD//wD/ADL/MjL/ZTL/mDL/yzL//zL/AGX/MmX/ZWX/mGX/y2X//2X/AJj/Mpj/ZZj/mJj/y5j//5j/AMv/Msv/Zcv/mMv/y8v//8v/AP//Mv//Zf//mP//y/////9ECiHUAAAAGUlEQVR4XmNwc8MPGNxGvoKRr2DkKxihCgCl7xgQRbPxcwAAAABJRU5ErkJggg=='.	Color black->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAADAFBMVEX///8AAAD///9/f3//AAAA/wAAAP8A/////wD/AP8fHx8/Pz9fX1+fn5+/v7/f398HBwcPDw8XFxcnJycvLy83NzdHR0dPT09XV1dnZ2dvb293d3eHh4ePj4+Xl5enp6evr6+3t7fHx8fPz8/X19fn5+fv7+/39/cAAAAAMgAAZQAAmAAAywAA/wAAADIAMjIAZTIAmDIAyzIA/zIAAGUAMmUAZWUAmGUAy2UA/2UAAJgAMpgAZZgAmJgAy5gA/5gAAMsAMssAZcsAmMsAy8sA/8sAAP8AMv8AZf8AmP8Ay/8A//8yAAAyMgAyZQAymAAyywAy/wAyADIyMjIyZTIymDIyyzIy/zIyAGUyMmUyZWUymGUyy2Uy/2UyAJgyMpgyZZgymJgyy5gy/5gyAMsyMssyZcsymMsyy8sy/8syAP8yMv8yZf8ymP8yy/8y//9lAABlMgBlZQBlmABlywBl/wBlADJlMjJlZTJlmDJlyzJl/zJlAGVlMmVlZWVlmGVly2Vl/2VlAJhlMphlZZhlmJhly5hl/5hlAMtlMstlZctlmMtly8tl/8tlAP9lMv9lZf9lmP9ly/9l//+YAACYMgCYZQCYmACYywCY/wCYADKYMjKYZTKYmDKYyzKY/zKYAGWYMmWYZWWYmGWYy2WY/2WYAJiYMpiYZZiYmJiYy5iY/5iYAMuYMsuYZcuYmMuYy8uY/8uYAP+YMv+YZf+YmP+Yy/+Y///LAADLMgDLZQDLmADLywDL/wDLADLLMjLLZTLLmDLLyzLL/zLLAGXLMmXLZWXLmGXLy2XL/2XLAJjLMpjLZZjLmJjLy5jL/5jLAMvLMsvLZcvLmMvLy8vL/8vLAP/LMv/LZf/LmP/Ly//L////AAD/MgD/ZQD/mAD/ywD//wD/ADL/MjL/ZTL/mDL/yzL//zL/AGX/MmX/ZWX/mGX/y2X//2X/AJj/Mpj/ZZj/mJj/y5j//5j/AMv/Msv/Zcv/mMv/y8v//8v/AP//Mv//Zf//mP//y/////9ECiHUAAAAGUlEQVR4XmNgZMQPGBhHvoKRr2DkKxihCgBEmAQBphO0cAAAAABJRU5ErkJggg=='}! !!PNGReadWriterTest methodsFor: 'decoding' stamp: 'ar 2/19/2004 00:25'!decodeColors: colorsAndFiles depth: requiredDepth	| color bytes form |	colorsAndFiles do:[:assoc|		color := assoc key.		bytes := Base64MimeConverter mimeDecodeToBytes: assoc value readStream.		form := PNGReadWriter formFromStream: bytes.		self assert: form depth = requiredDepth.		self assert: (form pixelValueAt: 1@1) = (color pixelValueForDepth: requiredDepth).	].! !!PNGReadWriterTest methodsFor: 'decoding' stamp: 'ar 2/19/2004 00:30'!encodeColors: colorsAndFiles depth: requiredDepth	| color original ff encoded |	colorsAndFiles do:[:assoc|		color := assoc key.		original := Base64MimeConverter mimeDecodeToBytes: assoc value readStream.		ff := Form extent: 32@32 depth: requiredDepth.		ff fillColor: color.		encoded := WriteStream on: ByteArray new.		PNGReadWriter putForm: ff onStream: encoded.		self assert: (encoded contents = original contents).	].! !!PNGReadWriterTest methodsFor: 'decoding' stamp: 'ar 2/19/2004 00:20'!testPngDecodingColors16	self decodeColors: self coloredFiles16 depth: 16.! !!PNGReadWriterTest methodsFor: 'decoding' stamp: 'ar 2/19/2004 00:20'!testPngDecodingColors32	self decodeColors: self coloredFiles32 depth: 32.! !!PNGReadWriterTest methodsFor: 'decoding' stamp: 'ar 2/19/2004 00:20'!testPngDecodingColors8	self decodeColors: self coloredFiles8 depth: 8.! !!PNGReadWriterTest methodsFor: 'decoding' stamp: 'ar 2/19/2004 00:28'!testPngEncodingColors16	self encodeColors: self coloredFiles16 depth: 16.! !!PNGReadWriterTest methodsFor: 'decoding' stamp: 'ar 2/19/2004 00:28'!testPngEncodingColors32	self encodeColors: self coloredFiles32 depth: 32.! !!PNGReadWriterTest methodsFor: 'decoding' stamp: 'ar 2/19/2004 00:28'!testPngEncodingColors8	self encodeColors: self coloredFiles8 depth: 8.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/11/2004 00:42'!drawStuffOn: aForm	"Draw stuff on aForm. Avoid any symmetry."	| canvas |	canvas := FormCanvas on: aForm.	canvas frameAndFillRectangle: (1@1 corner: aForm extent - 15) fillColor: Color red borderWidth: 3 borderColor: Color green.	canvas fillOval: (aForm boundingBox topRight - (15@-5) extent: 20@20) color: Color blue borderWidth: 1 borderColor: Color white.	^aForm	"(PNGReadWriterTest new drawStuffOn: (Form extent: 32@32 depth: 16)) display"! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/11/2004 00:42'!drawTransparentStuffOn: aForm	"Draw stuff on aForm. Avoid any symmetry."	| canvas |	canvas := FormCanvas on: aForm.	canvas frameAndFillRectangle: (1@1 corner: aForm extent - 15) fillColor: (Color red alpha: 0.25) borderWidth: 3 borderColor: (Color green alpha: 0.5).	canvas fillOval: (aForm boundingBox topRight - (15@-5) extent: 20@20) color: (Color white alpha: 0.75) borderWidth: 1 borderColor: Color blue.	^aForm	"(PNGReadWriterTest new drawStuffOn: (Form extent: 32@32 depth: 16)) display"! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nk 2/17/2004 11:09'!encodeAndDecode: original	"Make sure that the given form is encoded and decoded correctly"	| stream bytes decoded maxErr |	"encode"	stream := ByteArray new writeStream.	(PNGReadWriter on: stream) nextPutImage: original; close.	bytes := stream contents.	self writeEncoded: bytes.	"decode"	stream := self readEncoded: bytes.	decoded := (PNGReadWriter new on: stream) nextImage.	decoded display.	"compare"	self assert: original width = decoded width.	self assert: original height = decoded height.	self assert: original depth = decoded depth.	self assert: original bits = decoded bits.	self assert: original class == decoded class.	(original isKindOf: ColorForm) ifTrue:[		original colors with: decoded colors do:[:c1 :c2|			"we must round here due to encoding errors"			maxErr := 1. "max. error for 8bit rgb component"			self assert: ((c1 red * 255) truncated - (c2 red * 255) truncated) abs <= maxErr.			self assert: ((c1 green * 255) truncated - (c2 green * 255) truncated) abs <= maxErr.			self assert: ((c1 blue * 255) truncated - (c2 blue * 255) truncated) abs <= maxErr.			self assert: ((c1 alpha * 255) truncated - (c2 alpha * 255) truncated) abs <= maxErr.		].	].! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/12/2004 22:49'!encodeAndDecodeAlpha: original	fileName := 'testAlpha', original depth printString,'.png'.	self encodeAndDecode: original.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/18/2004 23:49'!encodeAndDecodeColor: aColor depth: aDepth	| aForm |	fileName := 'testColor', aColor name, aDepth printString,'.png'.	aForm := Form extent: 32@32 depth: aDepth.	aForm fillColor: aColor.	self encodeAndDecode: aForm.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nk 2/17/2004 11:02'!encodeAndDecodeDisplay: depth	| form |	fileName := 'testDisplay', depth printString,'.png'.	form := Form extent: (Display extent min: 560@560) depth: depth.	Smalltalk isMorphic 		ifTrue:[World fullDrawOn: form getCanvas]		ifFalse:[Display displayOn: form].	self encodeAndDecode: form.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/12/2004 22:50'!encodeAndDecodeForm: original	fileName := 'testForm', original depth printString,'.png'.	self encodeAndDecode: original.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/12/2004 22:47'!encodeAndDecodeReverse: original	"Make sure that the given form is encoded and decoded correctly"	| stream bytes decoded maxErr reversed |	fileName := 'testReverse', original depth printString,'.png'.	self assert: original class == Form. "won't work with ColorForm"	"Switch pixel order"	reversed := Form extent: original extent depth: original depth negated.	original displayOn: reversed.	self assert: original width = reversed width.	self assert: original height = reversed height.	self assert: original depth = reversed depth.	self deny: original nativeDepth = reversed nativeDepth.	original depth = 32		ifTrue:[self assert: original bits = reversed bits]		ifFalse:[self deny: original bits = reversed bits].	"encode"	stream := ByteArray new writeStream.	(PNGReadWriter on: stream) nextPutImage: reversed; close.	bytes := stream contents.	self writeEncoded: bytes.	"decode"	stream := bytes readStream.	decoded := (PNGReadWriter new on: stream) nextImage.	decoded display.	"compare"	self assert: original width = decoded width.	self assert: original height = decoded height.	self assert: original depth = decoded depth.	self assert: original bits = decoded bits.	self assert: original class == decoded class.	(original isKindOf: ColorForm) ifTrue:[		original colors with: decoded colors do:[:c1 :c2|			"we must round here due to encoding errors"			maxErr := 1. "max. error for 8bit rgb component"			self assert: ((c1 red * 255) truncated - (c2 red * 255) truncated) abs <= maxErr.			self assert: ((c1 green * 255) truncated - (c2 green * 255) truncated) abs <= maxErr.			self assert: ((c1 blue * 255) truncated - (c2 blue * 255) truncated) abs <= maxErr.			self assert: ((c1 alpha * 255) truncated - (c2 alpha * 255) truncated) abs <= maxErr.		].	].! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nk 2/17/2004 18:18'!encodeAndDecodeStream: file	| aForm |	file reset.	(PNGReadWriter new on: file) understandsImageFormat ifFalse:[^self error: 'don''t understand format!!' ].	file reset.	aForm := (PNGReadWriter new on: file) nextImage.	aForm ifNil:[^self error: 'nil form' ].	aForm display.	self encodeAndDecode: aForm.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/12/2004 22:36'!encodeAndDecodeWithColors: aColorForm	"Screw around with aColorForm colors"	| colors nColors indexedColors max myRandom |	fileName := 'testColors', aColorForm depth printString,'.png'.	indexedColors := Color indexedColors.	nColors := 1 bitShift: aColorForm depth.	colors := WriteStream on: Array new.	"Make first half translucent"	max := nColors // 2.	1 to: max do:[:i|		colors nextPut: ((indexedColors at: i) alpha: i / max asFloat).	].	"Make random choices for second half"	myRandom := Random seed: 42315.	max to: nColors do:[:i|		colors nextPut: (indexedColors atRandom: myRandom).	].! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nk 2/17/2004 11:10'!readEncoded: bytes	"Answer a ReadStream on the file named by fileName, if possible; else a ReadStream on bytes"	fileName ifNil:[^ bytes readStream ].	^(FileStream oldFileOrNoneNamed: fileName) ifNil: [ 		Transcript nextPutAll: 'can''t open ', fileName; cr.		bytes readStream ].! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/12/2004 22:45'!setUp	fileName := nil.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nk 2/17/2004 11:29'!tearDown	World changed.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/12/2004 22:51'!writeEncoded: bytes	| file |	fileName ifNil:[^self].	false ifTrue:[^self].	file := FileStream forceNewFileNamed: fileName.	[file nextPutAll: bytes] ensure:[file close].! !!ZLibReadStream methodsFor: 'initialize' stamp: 'nk 2/17/2004 17:42'!on: aCollection from: firstIndex to: lastIndex	"Check the header of the ZLib stream."	| method byte |	super on: aCollection from: firstIndex to: lastIndex.	adler32 _ 1.	method _ self nextBits: 8.	(method bitAnd: 15) = 8 ifFalse:[^self error:'Unknown compression method'].	(method bitShift: -4) + 8 > 15 ifTrue:[^self error:'Invalid window size'].	byte _ self nextBits: 8.	(method bitShift: 8) + byte \\ 31 = 0 ifFalse:[^self error:'Incorrect header'].	(byte anyMask: 32) ifTrue:[^self error:'Need preset dictionary'].! !!ZLibReadStream methodsFor: 'initialize' stamp: 'nk 2/17/2004 18:00'!pastEndRead	| b |	b _ super pastEndRead.	adler32 _ ZLibWriteStream updateAdler32: adler32 from: position  to: readLimit in: collection.	^b! !!ZLibReadStream methodsFor: 'initialize' stamp: 'nk 2/17/2004 18:03'!verifyAdler32	| storedAdler |	storedAdler := 0.	24 to: 0 by: -8 do: [ :i |		sourcePos >= sourceLimit ifTrue: [ ^ self error: 'missing Adler32 checksum!!' ].		storedAdler := storedAdler + (self nextByte bitShift: i) ].	storedAdler = adler32 ifFalse: [ ^ self error: 'Adler32 does not match' ].	^adler32! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'nk 2/17/2004 16:31'!release	"We're done with compression. Do some cleanup."	literals _ distances _ literalFreq _ distanceFreq _ nil.	self updateCrc.	encoder flushBits.	self writeFooter.! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'nk 2/17/2004 16:30'!writeFooter	"Write footer information if necessary"	crc _ crc bitXor: 16rFFFFFFFF.! !!ZipWriteStream methodsFor: 'private' stamp: 'nk 2/17/2004 16:51'!updateCrc: oldCrc from: start to: stop in: aCollection	^self class updateCrc: oldCrc from: start to: stop in: aCollection! !!GZipWriteStream methodsFor: 'initialize-release' stamp: 'nk 2/19/2004 08:31'!writeFooter	"Write some footer information for the crc"	super writeFooter.	0 to: 3 do:[:i| encoder nextBytePut: (crc >> (i*8) bitAnd: 255)].	0 to: 3 do:[:i| encoder nextBytePut: (bytesWritten >> (i*8) bitAnd: 255)].! !!ZLibWriteStream methodsFor: 'initialize-release' stamp: 'nk 2/17/2004 16:28'!on: aCollectionOrStream	super on: aCollectionOrStream.	crc _ 1.! !!ZLibWriteStream methodsFor: 'initialize-release' stamp: 'nk 2/17/2004 16:53'!updateCrc: adler from: start to: stop in: aCollection	"Update crc using the Adler32 checksum technique from RFC1950"	^self class updateAdler32: adler from:  start to:  stop in: aCollection! !!ZLibWriteStream methodsFor: 'initialize-release' stamp: 'nk 2/17/2004 16:54'!writeFooter	"Store the Adler32 checksum as the last 4 bytes."	encoder nextNumber: 4 put: crc.! !!ZLibWriteStream methodsFor: 'initialize-release' stamp: 'nk 2/17/2004 18:23'!writeHeader	"Write header information"	encoder nextBits: 8 put: 120. "deflate method with 15bit window size"	encoder nextBits: 8 put: 94. "checksum; no preset; fast (flevel=1) compression"! !!ZipWriteStream class methodsFor: 'crc' stamp: 'nk 2/17/2004 16:50'!updateCrc: oldCrc from: start to: stop in: aCollection	| newCrc |	<primitive: 'primitiveUpdateGZipCrc32' module: 'ZipPlugin'>	newCrc _ oldCrc.	start to: stop do:[:i|		newCrc _ (CrcTable at: ((newCrc bitXor: (aCollection byteAt: i)) 				bitAnd: 255) + 1) bitXor: (newCrc bitShift: -8).	].	^newCrc! !!ZLibWriteStream class methodsFor: 'crc' stamp: 'nk 2/17/2004 16:52'!updateAdler32: adler from: start to: stop in: aCollection	"Update crc using the Adler32 checksum technique from RFC1950""        unsigned long s1 = adler & 0xffff;        unsigned long s2 = (adler >> 16) & 0xffff;        int n;        for (n = 0; n < len; n++) {          s1 = (s1 + buf[n]) % BASE;          s2 = (s2 + s1)     % BASE;        }        return (s2 << 16) + s1;"	| s1 s2 |	s1 := adler bitAnd: 16rFFFF.	s2 := (adler bitShift: -16) bitAnd: 16rFFFF.	start to: stop do: [ :n | | b |		b := aCollection at: n.		s1 := (s1 + b) \\ 65521.		s2 := (s2 + s1) \\ 65521. ].	^(s2 bitShift: 16) + s1! !!PNGReadWriterTest reorganize!('tests' test16Bit test16BitDisplay test16BitReversed test1Bit test1BitColors test1BitDisplay test1BitReversed test2Bit test2BitColors test2BitDisplay test2BitReversed test32Bit test32BitDisplay test32BitReversed test4Bit test4BitColors test4BitDisplay test4BitReversed test8Bit test8BitColors test8BitDisplay test8BitReversed testAlphaCoding testPngSuite)('colors' testBlack16 testBlack32 testBlack8 testBlue16 testBlue32 testBlue8 testGreen16 testGreen32 testGreen8 testRed16 testRed32 testRed8)('decoding' coloredFiles16 coloredFiles32 coloredFiles8 decodeColors:depth: encodeColors:depth: testPngDecodingColors16 testPngDecodingColors32 testPngDecodingColors8 testPngEncodingColors16 testPngEncodingColors32 testPngEncodingColors8)('helpers' drawStuffOn: drawTransparentStuffOn: encodeAndDecode: encodeAndDecodeAlpha: encodeAndDecodeColor:depth: encodeAndDecodeDisplay: encodeAndDecodeForm: encodeAndDecodeReverse: encodeAndDecodeStream: encodeAndDecodeWithColors: readEncoded: setUp tearDown writeEncoded:)!PNGReadWriter initialize!ImageReadWriter subclass: #PNGReadWriter	instanceVariableNames: 'chunk form width height depth backColor bitsPerChannel colorType interlaceMethod bitsPerPixel bytesPerScanline thisScanline prevScanline rowSize globalDataChunk unknownChunks palette transparentPixelValue filtersSeen swizzleMap cachedDecoderMap bigEndian '	classVariableNames: 'BPP BlockHeight BlockWidth Debugging StandardColors StandardSwizzleMaps '	poolDictionaries: ''	category: 'Graphics-Files'!