'From Squeak3.8beta of ''2 November 2004'' [latest update: #6465] on 22 November 2004 at 1:46:38 pm'!"Change Set:		ttcFixDate:			22 November 2004Author:			Yoshiki OhshimaAdd Symbol font support to the later versions that uses Unicode.  Since the characters in the Symbol font now has legitimated character code point, we should use them."!KeyboardInputInterpreter subclass: #SymbolInputInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!MultiCharacter methodsFor: 'converting' stamp: 'yo 11/8/2004 19:08'!asUnicode	| table charset v |	self leadingChar = 0 ifTrue: [^ value].	charset _ EncodedCharSet charsetAt: self leadingChar.	(charset isKindOf: EncodedCharSet class) ifFalse: [^ self charCode].	table _ charset ucsTable.	table isNil ifTrue: [^ 16rFFFD].	v _ table at: self charCode + 1.	v = -1 ifTrue: [^ 16rFFFD].	^ v.! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'yo 11/8/2004 21:21'!scanMultiCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex _ startIndex.	lastIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].	startEncoding _ (sourceString at: startIndex) leadingChar.	font ifNil: [font _ (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f _ font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f _ font fontArray at: 1].		f ifNil: [ f _ font fontArray at: 1].		maxAscii _ f maxAscii.		spaceWidth _ f widthOf: Space.	] ifFalse: [		maxAscii _ font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding _ (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex _ lastIndex - 1. ^ stops at: EndOfRun].		ascii _ (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii _ maxAscii].		(encoding = 0 and: [ascii < stopConditions size and: [(stopConditions at: ascii + 1) ~~ nil]]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: Latin1) ifTrue: [			self registerBreakableIndex.		].		nextDestX _ destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX _ nextDestX + kernDelta.		lastIndex _ lastIndex + 1.	].	lastIndex _ stopIndex.	^ stops at: EndOfRun! !!SymbolInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2004 22:39'!nextCharFrom: sensor firstEvt: evtBuf	| keyValue |	keyValue := evtBuf third.	evtBuf fifth > 1 ifTrue: [^ keyValue asCharacter squeakToIso].	^ (self symbolKeyValueToUnicode: keyValue) asCharacter.! !!SymbolInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2004 18:53'!symbolKeyValueToUnicode: keyValue	keyValue = 127 ifTrue: [^ 127].	keyValue < 32 ifTrue: [^ keyValue].	keyValue > 255 ifTrue: [^ 0].	^ #(0 0 0 0 0 0 0 0 0 61472 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 61472 61473 61474 61475 61476 61477 61478 61479 61480 61481 61482 61483 61484 61485 61486 61487 61488 61489 61490 61491 61492 61493 61494 61495 61496 61497 61498 61499 61500 61501 61502 61503 61504 61505 61506 61507 61508 61509 61510 61511 61512 61513 61514 61515 61516 61517 61518 61519 61520 61521 61522 61523 61524 61525 61526 61527 61528 61529 61530 61531 61532 61533 61534 61535 61536 61537 61538 61539 61540 61541 61542 61543 61544 61545 61546 61547 61548 61549 61550 61551 61552 61553 61554 61555 61556 61557 61558 61559 61560 61561 61562 61563 61564 61565 61566 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 61601 61602 61603 61604 61605 61606 61607 61608 61609 61610 61611 61612 61613 61614 61615 61616 61617 61618 61619 61620 61621 61622 61623 61624 61625 61626 61627 61628 61629 61630 61631 61632 61633 61634 61635 61636 61637 61638 61639 61640 61641 61642 61643 61644 61645 61646 61647 61648 61649 61650 61651 61652 61653 61654 61655 61656 61657 61658 61659 61660 61661 61662 61663 61664 61665 61666 61667 61668 61669 61670 61671 61672 61673 61674 61675 61676 61677 61678 61679 0 61681 61682 61683 61684 61685 61686 61687 61688 61689 61690 61691 61692 61693 61694 0) at: keyValue + 1.! !!TTCFont class methodsFor: 'instance creation' stamp: 'yo 11/8/2004 19:27'!newTextStyleFromTTFile: fileName	"Create a new TextStyle from specified file name.  On certain versions of Windows, you can evaluate following to get Arial font into the image.  On other platforms, wait and see someone implements the support code for FontPlugin then we can start relying on the generic font lookup mechanism.	TTCFontReader encodingTag: 0.	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\symbol.TTF'.	"	| description |	description _ TTFontDescription addFromTTFile: fileName.	^ self newTextStyleFromTT: description.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2004 22:22'!readFrom: fontData fromOffset: offset at: encodingTag	| headerEntry maxProfileEntry nameEntry indexLocEntry charMapEntry glyphEntry horzHeaderEntry horzMetricsEntry kerningEntry glyphOffset cmap numHMetrics indexToLocFormat fontDescription0 fontDescription1 array result |	"Search the tables required to build the font"	(headerEntry _ self getTableDirEntry: 'head' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a header table'].	(maxProfileEntry _ self getTableDirEntry: 'maxp' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a maximum profile table'].	(nameEntry _ self getTableDirEntry: 'name' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a name table'].	(indexLocEntry _ self getTableDirEntry: 'loca' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a relocation table'].	(charMapEntry _ self getTableDirEntry: 'cmap' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a character map table'].	(glyphEntry _ self getTableDirEntry: 'glyf' from: fontData  offset: offset) == nil ifTrue:[		^self error:'This font does not have a glyph table'].	(horzHeaderEntry _ self getTableDirEntry: 'hhea' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a horizontal header table'].	(horzMetricsEntry _ self getTableDirEntry: 'hmtx' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a horizontal metrics table'].	(kerningEntry _ self getTableDirEntry: 'kern' from: fontData offset: offset) == nil ifTrue:[		Transcript cr; show:'This font does not have a kerning table';endEntry].	"Process the data"	indexToLocFormat _ self processFontHeaderTable: headerEntry.	self processMaximumProfileTable: maxProfileEntry.	self processNamingTable: nameEntry.	glyphOffset _ self processIndexToLocationTable: indexLocEntry format: indexToLocFormat.	cmap _ self processCharacterMappingTable: charMapEntry.	(cmap == nil or:[cmap value == nil])		ifTrue:[^self error:'This font has no suitable character mappings'].	self processGlyphDataTable: glyphEntry offsets: glyphOffset.	numHMetrics _ self processHorizontalHeaderTable: horzHeaderEntry.	self processHorizontalMetricsTable: horzMetricsEntry length: numHMetrics.	kerningEntry isNil 		ifTrue:[kernPairs _ #()]		ifFalse:[self processKerningTable: kerningEntry].	array _ self processCharMap: cmap.	fontDescription0 _ fontDescription clone.	fontDescription1 _ fontDescription clone.	fontDescription0 setGlyphs: (array at: 1) mapping: nil.	fontDescription1 setGlyphs: (array at: 2) mapping: nil.	"fontDescription setKernPairs: kernPairs."	result _ OrderedCollection new.	(encodingTag = nil or: [encodingTag = 0]) ifTrue: [^ Array with: fontDescription1].	result add: fontDescription0.	encodingTag -1 timesRepeat: [result add: nil].	result add: fontDescription1.	^ result asArray.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2004 21:18'!ascentOf: aCharacter	^ fontArray first ascentOf: aCharacter.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2004 21:18'!descentOf: aChar	^ fontArray first descentOf: aChar! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2004 21:57'!newTextStyleFromTTFile: fileName"	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\msmincho.TTC'	TTCFontReader encodingTag: 0.	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\symbol.ttf'"	| description |	description _ TTCFontDescription addFromTTFile: fileName.	^ self newTextStyleFromTT: description.! !