'From Squeak3.6alpha of ''17 March 2003'' [latest update: #5269] on 26 June 2003 at 6:17:44 pm'!"Change Set:		net-reorg-all-mirDate:			7 June 2003Author:			Michael RuegerRewrite of the most of the network code in Squeak 3.6 after removals.  (A single changeset containing the whole rewrite was created on June 26 to replace the original 8 changesets, which sometimes had problems loading.  The remaining 7 changesets (updates 5253 through 5259 are now empty). - Doug Way)What's new from 0.5:- some minor issues fixed- SocketStream now directly supports timeoutsWhat's new from 0.4:-bug fixes in SocketStream-SocketStream now supports a time out-SocketStream auto flush: if false, everything is written at once, if true, data is written when the out buffer is full-major change in some method semantics (see below)-all wait calls are now named xxxFor: instead of xxUntil: and use seconds instead of the weird milli seconds deadline-waitForDataFor: now does NOT return a boolean anymore but rather signals exceptions-new call waitForData that never times out (useful for e.g. chat clients)-new API for receiving data:	-receiveAvailableData fetches all currently available data without waiting, may return no new data	-receiveSomeData like above, but fetches data only once, no looping	-receiveData waits until some data is available, guarantees to return data (unless an exception occurs), once it has data it does not wait for more, does NOT time out	-receiveDataTimeout like receiveData but with time out parameter	-receiveDataWithTimeout like above but using default time outWhat's new from 0.3:-bug fixes (thanks to Goran and Luciano)-fixes up obsolete references to removed and renamed classes-SocketStream has now nextLine (crlf), nextLineLf and nextLineCrLF-Socket>>connectTo:port: now waits until the connection is established. connectNonBlockingTo:port: implements the old functionality."!RWBinaryOrTextStream subclass: #RemoteFileStream	instanceVariableNames: 'remoteFile localDataValid '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-RemoteDirectory'!Object subclass: #ServerDirectory	instanceVariableNames: 'server directory type user passwordHolder group moniker altURL urlObject socket loaderUrl eToyUserListUrl eToyUserList '	classVariableNames: 'LocalEToyBaseFolderSpecs LocalEToyUserListUrls LocalProjectDirectories Servers '	poolDictionaries: ''	category: 'Network-RemoteDirectory'!ServerDirectory subclass: #ProjectSwikiServer	instanceVariableNames: 'acceptsUploads '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-RemoteDirectory'!ProjectSwikiServer subclass: #HTTPServerDirectory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-RemoteDirectory'!ServerDirectory subclass: #ServerFile	instanceVariableNames: 'fileName rwmode '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-RemoteDirectory'!ProjectSwikiServer subclass: #SuperSwikiServer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-RemoteDirectory'!RWBinaryOrTextStream subclass: #SwikiPseudoFileStream	instanceVariableNames: 'directoryUrl localName directory '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-RemoteDirectory'!Smalltalk renameClassNamed: #Socket as: #OldSocket!Smalltalk renameClassNamed: #SimpleClientSocket as: #OldSimpleClientSocket!Error subclass: #InvalidSocketStatusException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Kernel'!!InvalidSocketStatusException commentStamp: 'mir 5/12/2003 18:15' prior: 0!Signals if an operation on a Socket found it in a state invalid for that operation.!Error subclass: #NetworkError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Kernel'!!NetworkError commentStamp: 'mir 5/12/2003 18:12' prior: 0!Abstract super class for all network related exceptions.!NetworkError subclass: #ConnectionClosed	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Kernel'!!ConnectionClosed commentStamp: 'mir 5/12/2003 18:12' prior: 0!Signals a prematurely closed connection.!NetworkError subclass: #ConnectionRefused	instanceVariableNames: 'host port '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Kernel'!!ConnectionRefused commentStamp: 'mir 5/12/2003 18:14' prior: 0!Signals that a connection to the specified host and port was refused.	host		host which refused the connection	port		prot to which the connection was refused!NetworkError subclass: #ConnectionTimedOut	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Kernel'!!ConnectionTimedOut commentStamp: 'mir 5/12/2003 18:14' prior: 0!Signals that a connection attempt timed out.!NetworkError subclass: #NameLookupFailure	instanceVariableNames: 'hostName '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Kernel'!!NameLookupFailure commentStamp: 'mir 5/12/2003 18:16' prior: 0!Signals that a name lookup operation failed.	hostName	hostName for which the name loopup failed!NetworkError subclass: #NoNetworkError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Kernel'!!NoNetworkError commentStamp: 'mir 5/12/2003 18:17' prior: 0!Signals that no network was found. This could happen, e.g., on dial-up connection when no connection was established when Squeak tried to access it.!Object subclass: #ProtocolClient	instanceVariableNames: 'stream connectInfo lastResponse progressObservers '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!ProtocolClient commentStamp: 'mir 5/12/2003 18:03' prior: 0!ProtocolClient is the abstract super class for a variety of network protocol clients.Is uses a stream rather than the direct network access so it could also work for stream on serial connections etc.Structure:	stream				stream presenting the connection to and from the server	connectInfo			infos required for opening a connection	lastResponse			remembers the last response from the server.	progressObservers 	any object understanding #show: can be registered as a progress observer (login, transfer, etc)!ProtocolClient subclass: #POP3Client	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!POP3Client commentStamp: 'mir 5/12/2003 17:57' prior: 0!This class implements POP3 (Post Office Protocol 3) as specified in RFC 1939.  (see http://www.ietf.org/rfc.html)You can use it to download email from the mail server to your personal mail program.To see an example of it's use, see POPSocket class>>example.!Error subclass: #ProtocolClientError	instanceVariableNames: 'protocolInstance '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!ProtocolClientError commentStamp: 'mir 5/12/2003 18:05' prior: 0!Abstract super class for protocol clients	protocolInstance		reference to the protocol client throughing the exception. Exception handlers can access the client in order close, respond or whatever may be appropriate!ProtocolClientError subclass: #LoginFailedException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!LoginFailedException commentStamp: 'mir 5/12/2003 17:57' prior: 0!Exception for signaling login failures of protocol clients.!ProtocolClientError subclass: #POP3LoginError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!POP3LoginError commentStamp: 'mir 5/12/2003 17:58' prior: 0!Exception for signaling POP3 login failures.!Object subclass: #Socket	instanceVariableNames: 'semaphore socketHandle readSemaphore writeSemaphore primitiveOnlySupportsOneSemaphore '	classVariableNames: 'Connected DeadServer InvalidSocket OtherEndClosed Registry RegistryThreshold TCPSocketType ThisEndClosed UDPSocketType Unconnected WaitingForConnection '	poolDictionaries: ''	category: 'Network-Kernel'!!Socket commentStamp: '<historical>' prior: 0!A Socket represents a network connection point. Current sockets are designed to support the TCP/IP and UDP protocolsSubclasses of socket provide support for network protocols such as POP, NNTP, HTTP, and FTP. Sockets also allow you to implement your own custom services and may be used to support Remote Procedure Call or Remote Method Invocation some day.JMM June 2nd 2000 Macintosh UDP support was added if you run open transport.!]style[(196 4 6 3 228)f1,f1LHTTPSocket Comment;,f1,f1LFTPSocket Comment;,f1!Stream subclass: #SocketStream	instanceVariableNames: 'socket inStream outStream timeout autoFlush buffered bufferSize '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Kernel'!!SocketStream commentStamp: 'mir 5/12/2003 16:27' prior: 0!SocketStream provides a Stream interface to Sockets decoupling protocol and other clients from the concrete Socket implementation and idiosyncrasies.The implementation is based on Bolot Kerimbaev's original version in Comanche.!Socket subclass: #SocksSocket	instanceVariableNames: 'vers method socksIP socksPort dstPort dstIP dstName '	classVariableNames: 'DefaultSocksVersion '	poolDictionaries: ''	category: 'Network-Kernel'!!SocksSocket commentStamp: '<historical>' prior: 0!This class implements the socks 4 and partially socks 5 connection protocol.For backward compatibility the socks protocol is disabled by default, so subclasses still work.For further documentation check out:Socks4: http://spiderman.socks.nec.com/protocol/socks4.protocolSocks5: http://spiderman.socks.nec.com/rfc/rfc1928.txt!ProtocolClient subclass: #TelnetProtocolClient	instanceVariableNames: 'responseCode '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!TelnetProtocolClient commentStamp: 'mir 5/12/2003 18:06' prior: 0!Abstract super class for protocol clients based on the generic telnet protocol "<response code> <response>"Structure:	responseCode	the numerical (integer) value of the last response code!TelnetProtocolClient subclass: #FTPClient	instanceVariableNames: 'dataSocket '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!FTPClient commentStamp: 'mir 5/12/2003 17:55' prior: 0!A minimal FTP client program.  Could store all state in inst vars, and use an instance to represent the full state of a connection in progress.  But simpler to do all that in one method and have it be a complete transaction.Always operates in passive mode (PASV).  All connections are initiated from client in order to get through firewalls.See ServerDirectory openFTP, ServerDirectory getFileNamed:, ServerDirectory putFile:named: for examples of use.See TCP/IP, second edition, by Dr. Sidnie Feit, McGraw-Hill, 1997, Chapter 14, p311.!TelnetProtocolClient subclass: #SMTPClient	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!SMTPClient commentStamp: 'mir 2/21/2002 16:57' prior: 0!This class implements the SMTP (mail sending) protocol specified in RFC 821.HELO <SP> <domain> <CRLF>MAIL <SP> FROM:<reverse-path> <CRLF>RCPT <SP> TO:<forward-path> <CRLF>DATA <CRLF>RSET <CRLF>SEND <SP> FROM:<reverse-path> <CRLF>SOML <SP> FROM:<reverse-path> <CRLF>SAML <SP> FROM:<reverse-path> <CRLF>VRFY <SP> <string> <CRLF>EXPN <SP> <string> <CRLF>HELP [<SP> <string>] <CRLF>NOOP <CRLF>QUIT <CRLF>TURN <CRLF>!ProtocolClientError subclass: #TelnetProtocolError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!TelnetProtocolError commentStamp: 'mir 5/12/2003 18:07' prior: 0!Abstract super class for exceptions signalled by clients based on the telnet protocol.!!ConnectionRefused methodsFor: 'accessing' stamp: 'len 12/14/2002 11:58'!host	^ host! !!ConnectionRefused methodsFor: 'accessing' stamp: 'len 12/14/2002 11:39'!host: addressOrHostName port: portNumber	host _ addressOrHostName.	port _ portNumber! !!ConnectionRefused methodsFor: 'accessing' stamp: 'len 12/14/2002 11:58'!port	^ port! !!ConnectionRefused class methodsFor: 'instance creation' stamp: 'len 12/14/2002 11:39'!host: addressOrHostName port: portNumber	^ self new host: addressOrHostName port: portNumber! !!NameLookupFailure methodsFor: 'accessing' stamp: 'len 12/14/2002 12:36'!defaultAction	"Backward compatibility"	| response |	response _ (PopUpMenu labels: 'Retry\Give Up' withCRs)			startUpWithCaption: self messageText.	^ response = 2		ifFalse: [self retry]! !!NameLookupFailure methodsFor: 'accessing' stamp: 'len 12/14/2002 11:57'!hostName	^ hostName! !!NameLookupFailure methodsFor: 'accessing' stamp: 'len 12/14/2002 11:57'!hostName: aString	hostName _ aString! !!NameLookupFailure class methodsFor: 'instance creation' stamp: 'len 12/14/2002 11:57'!hostName: aString	^ self new hostName: aString! !!ProtocolClient methodsFor: 'accessing' stamp: 'mir 3/7/2002 14:55'!logProgressToTranscript	self progressObservers add: Transcript! !!ProtocolClient methodsFor: 'accessing' stamp: 'mir 5/9/2003 15:52'!messageText	^super messageText		ifNil: [self response]! !!ProtocolClient methodsFor: 'accessing' stamp: 'mir 5/9/2003 15:52'!response	^self protocolInstance lastResponse! !!ProtocolClient methodsFor: 'accessing' stamp: 'mir 2/22/2002 17:33'!stream	^stream! !!ProtocolClient methodsFor: 'accessing' stamp: 'mir 2/22/2002 17:33'!stream: aStream	stream _ aStream! !!ProtocolClient methodsFor: 'testing' stamp: 'mir 3/7/2002 14:33'!isConnected	^stream notNil		and: [stream isConnected]! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:35'!connectionInfo	connectInfo ifNil: [connectInfo _ Dictionary new].	^connectInfo! !!ProtocolClient methodsFor: 'private' stamp: 'mir 2/25/2002 19:34'!defaultPortNumber	^self class defaultPortNumber! !!ProtocolClient methodsFor: 'private' stamp: 'mir 11/14/2002 18:29'!ensureConnection	self isConnected		ifTrue: [^self].	self stream		ifNotNil: [self stream close].	self stream: (SocketStream openConnectionToHost: self host port: self port).	self checkResponse.	self login! !!ProtocolClient methodsFor: 'private' stamp: 'mir 4/7/2003 16:56'!host	^self connectionInfo at: #host! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:37'!host: hostId	^self connectionInfo at: #host put: hostId! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/7/2002 13:35'!lastResponse	^lastResponse! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/7/2002 13:35'!lastResponse: aString	lastResponse _ aString.! !!ProtocolClient methodsFor: 'private' stamp: 'mir 2/25/2002 19:07'!logFlag	^self class logFlag! !!ProtocolClient methodsFor: 'private' stamp: 'mir 5/12/2003 18:10'!logProgress: aString	self progressObservers do: [:each | each show: aString].! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:40'!openOnHost: hostIP port: portNumber	self host: hostIP.	self port: portNumber.	self ensureConnection! !!ProtocolClient methodsFor: 'private' stamp: 'mir 4/7/2003 16:56'!password	^self connectionInfo at: #password! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:37'!password: aString	^self connectionInfo at: #password put: aString! !!ProtocolClient methodsFor: 'private' stamp: 'mir 4/7/2003 16:57'!port	^self connectionInfo at: #port! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:38'!port: aPortNumber	^self connectionInfo at: #port put: aPortNumber! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/7/2002 14:54'!progressObservers	progressObservers ifNil: [progressObservers _ OrderedCollection new].	^progressObservers! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:35'!resetConnectionInfo	connectInfo _ nil! !!ProtocolClient methodsFor: 'private' stamp: 'mir 11/11/2002 16:19'!user	^self connectionInfo at: #user ifAbsent: [nil]! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:39'!user: aString	^self connectionInfo at: #user put: aString! !!ProtocolClient methodsFor: 'actions' stamp: 'mir 3/7/2002 13:10'!close	self stream		ifNotNil: [			self stream close.			stream _ nil]! !!ProtocolClient methodsFor: 'actions' stamp: 'mir 3/7/2002 13:11'!reopen	self ensureConnection! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 11/19/2002 19:22'!checkForPendingError	"If data is waiting, check it to catch any error reports.	In case the response is not an error, push it back."	| currentResponse |	self stream isDataAvailable		ifFalse: [^self].	currentResponse := self lastResponse.	self checkResponse.	"if we get here, it wasn't an error"	self stream pushBack: self lastResponse , String crlf.	self lastResponse: currentResponse! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 5/9/2003 18:47'!checkResponse	"Get the response from the server and check for errors."	self		checkResponseOnError: [:response | (TelnetProtocolError protocolInstance: self) signal]		onWarning: [:response | (TelnetProtocolError protocolInstance: self) signal].! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 3/7/2002 13:42'!checkResponseOnError: errorBlock onWarning: warningBlock	"Get the response from the server and check for errors. Invoke one of the blocks if an error or warning is encountered. See class comment for classification of error codes."	self fetchNextResponse.	self responseIsError		ifTrue: [errorBlock value: self lastResponse].	self responseIsWarning		ifTrue: [warningBlock value: self lastResponse].! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 3/7/2002 13:16'!fetchNextResponse	self lastResponse: self stream nextLine! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 5/12/2003 18:10'!sendCommand: aString	self stream sendCommand: aString.! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 3/5/2002 14:31'!sendStreamContents: aStream	self stream sendStreamContents: aStream! !!ProtocolClient methodsFor: 'private testing' stamp: 'mir 3/7/2002 13:42'!responseIsError	self subclassResponsibility! !!ProtocolClient methodsFor: 'private testing' stamp: 'mir 3/7/2002 13:42'!responseIsWarning	self subclassResponsibility! !!POP3Client methodsFor: 'private' stamp: 'mir 11/11/2002 16:20'!loginMethod	^self connectionInfo at: #loginMethod ifAbsent: [nil]! !!POP3Client methodsFor: 'private' stamp: 'mir 3/8/2002 11:41'!loginMethod: aSymbol	^self connectionInfo at: #loginMethod put: aSymbol! !!POP3Client methodsFor: 'private testing' stamp: 'mir 3/7/2002 13:43'!responseIsError	^self lastResponse beginsWith: '-'! !!POP3Client methodsFor: 'private testing' stamp: 'mir 11/11/2002 15:44'!responseIsWarning	^self lastResponse beginsWith: '-'! !!POP3Client methodsFor: 'private protocol' stamp: 'mir 4/7/2003 17:15'!apopLogin	"Attempt to authenticate ourselves to the server without sending the password as cleartext."	"For secure authentication, we look for a timestamp in the initial response string we get from the server, and then try the APOP command as specified in RFC 1939.  If the initial response from the server is	+OK POP3 server ready <1896.697170952@dbc.mtview.ca.us>we extract the timestamp	<1896.697170952@dbc.mtview.ca.us>then form a string of the form	<1896.697170952@dbc.mtview.ca.us>USERPASSWORDand then send only the MD5 hash of that to the server.  Thus the password never hits the wire"	| timestamp hash |	[	"Look for a timestamp in the response we received from the server"	timestamp _ self lastResponse findTokens: '<>' includes: '@'.	timestamp		ifNil: [(POP3LoginError protocolInstance: self) signal: 'APOP not supported.'].	(Smalltalk includesKey: #MD5)		ifTrue: [			hash _ ((Smalltalk at: #MD5) hashMessage: ('<', timestamp, '>', self password)) hex asLowercase.		     "NB: trim unwanted 16r from start"			hash _ hash copyFrom: 4 to: hash size]		ifFalse: [(POP3LoginError protocolInstance: self) signal: 'APOP (MD5) not supported.'].	self sendCommand: 'APOP ', self user, ' ', hash.	self logProgress: self lastResponse]		on: ProtocolClientError		do: [:ex |			self close.			(LoginFailedException protocolInstance: self) signal: 'Login failed.']! !!POP3Client methodsFor: 'private protocol' stamp: 'mir 4/7/2003 17:38'!clearTextLogin	[self sendCommand: 'USER ', self user.	self checkResponse.	self logProgress: self lastResponse.	self sendCommand: 'PASS ', self password.	self checkResponse.	self logProgress: self lastResponse]		on: TelnetProtocolError		do: [:ex |			"Neither authentication worked.  Indicate an error and close up"			self close.			ex resignalAs: ((LoginFailedException protocolInstance: self) signal: 'Login failed.')]! !!POP3Client methodsFor: 'private protocol' stamp: 'mir 11/14/2002 17:40'!getMultilineResponse	"Get a multiple line response to the last command, filtering out LF characters. A multiple line response ends with a line containing only a single period (.) character."	| response done chunk |	response _ WriteStream on: ''.	done _ false.	[done] whileFalse: [		chunk _ self stream nextLine.		(chunk beginsWith: '.')			ifTrue: [response nextPutAll: (chunk copyFrom: 2 to: chunk size); cr ]			ifFalse: [response nextPutAll: chunk; cr ].		done _ (chunk = '.') ].	^ response contents! !!POP3Client methodsFor: 'private protocol' stamp: 'mir 4/7/2003 17:39'!login	self loginMethod		ifNil: [^self].	self loginMethod == #clearText		ifTrue: [^self clearTextLogin].	self loginMethod == #APOP		ifTrue: [^self apopLogin].	(POP3LoginError protocolInstance: self) signal: 'Unsupported login procedure.'! !!POP3Client methodsFor: 'public protocol' stamp: 'mir 3/7/2002 14:58'!apopLoginUser: userName password: password	self loginUser: userName password: password loginMethod: #APOP! !!POP3Client methodsFor: 'public protocol' stamp: 'mir 3/7/2002 14:35'!deleteMessage: num	"delete the numbered message"	self ensureConnection.	self sendCommand: 'DELE ', num printString.	self checkResponse.	self logProgress: self lastResponse! !!POP3Client methodsFor: 'public protocol' stamp: 'mir 3/7/2002 14:57'!loginUser: userName password: password	self loginUser: userName password: password loginMethod: #clearText! !!POP3Client methodsFor: 'public protocol' stamp: 'mir 3/8/2002 11:40'!loginUser: userName password: password loginMethod: aLoginMethod	self user: userName.	self password: password.	self loginMethod: aLoginMethod.	self login! !!POP3Client methodsFor: 'public protocol' stamp: 'mir 4/7/2003 17:17'!messageCount	"Query the server and answer the number of messages that are in the user's mailbox."	| answerString numMessages |	self ensureConnection.	self sendCommand: 'STAT'.	self checkResponse.	self logProgress: self lastResponse.	[answerString _ (self lastResponse findTokens: Character separators) second.	numMessages _ answerString asNumber asInteger]		on: Error		do: [:ex | (ProtocolClientError protocolInstance: self) signal: 'Invalid STAT response.'].	^numMessages! !!POP3Client methodsFor: 'public protocol' stamp: 'len 12/14/2002 17:50'!quit	"QUIT <CRLF>"	self sendCommand: 'QUIT'.	self checkResponse.! !!POP3Client methodsFor: 'public protocol' stamp: 'mir 3/7/2002 14:35'!retrieveMessage: number	"retrieve the numbered message"	self ensureConnection.	self sendCommand: 'RETR ', number printString.	self checkResponse.	self logProgress: self lastResponse.	^self getMultilineResponse! !!ProtocolClient class methodsFor: 'instance creation' stamp: 'mir 2/25/2002 15:59'!openOnHost: hostIP port: portNumber	^self new openOnHost: hostIP port: portNumber! !!ProtocolClient class methodsFor: 'instance creation' stamp: 'mir 2/25/2002 15:58'!openOnHostNamed: hostName	^self openOnHostNamed: hostName port: self defaultPortNumber! !!ProtocolClient class methodsFor: 'instance creation' stamp: 'mir 2/25/2002 15:58'!openOnHostNamed: hostName port: portNumber	| serverIP |	serverIP _ NetNameResolver addressForName: hostName timeout: 20.	^self openOnHost: serverIP port: portNumber! !!ProtocolClient class methodsFor: 'accessing' stamp: 'mir 2/25/2002 16:00'!defaultPortNumber	self subclassResponsibility! !!ProtocolClient class methodsFor: 'accessing' stamp: 'mir 2/25/2002 19:07'!logFlag	self subclassResponsibility! !!ProtocolClient class methodsFor: 'retrieval' stamp: 'mir 3/5/2002 16:21'!retrieveMIMEDocument: aURI	self subclassResponsibility! !!POP3Client class methodsFor: 'accessing' stamp: 'mir 3/7/2002 12:51'!defaultPortNumber	^110! !!POP3Client class methodsFor: 'accessing' stamp: 'mir 3/7/2002 12:52'!logFlag	^#pop! !!POP3Client class methodsFor: 'example' stamp: 'mir 11/11/2002 16:52'!example	"POP3Client example"	"download a user's messages into an OrderedCollection and inspect the OrderedCollection"	| ps messages userName password |	userName := (FillInTheBlank request: 'POP username').	password := (FillInTheBlank request: 'POP password').	ps _ POP3Client openOnHostNamed: (FillInTheBlank request: 'POP server').	[	ps loginUser: userName password: password.	ps logProgressToTranscript.	messages _ OrderedCollection new.	1 to: ps messageCount do: [ :messageNr |		messages add: (ps retrieveMessage: messageNr) ]]		ensure: [ps close].	messages inspect.! !!ProtocolClientError methodsFor: 'accessing' stamp: 'mir 5/16/2003 11:17'!messageText	^super messageText		ifNil: [self response]! !!ProtocolClientError methodsFor: 'accessing' stamp: 'mir 10/30/2000 13:48'!protocolInstance	^protocolInstance! !!ProtocolClientError methodsFor: 'accessing' stamp: 'mir 10/30/2000 13:48'!protocolInstance: aProtocolInstance	protocolInstance _ aProtocolInstance! !!ProtocolClientError methodsFor: 'accessing' stamp: 'mir 5/16/2003 11:18'!response	^self protocolInstance lastResponse! !!LoginFailedException methodsFor: 'exceptionDescription' stamp: 'mir 2/15/2002 13:10'!isResumable	"Resumable so we can give the user another chance to login"	^true! !!ProtocolClientError class methodsFor: 'instance creation' stamp: 'mir 10/30/2000 16:15'!protocolInstance: aProtocolInstance	^self new protocolInstance: aProtocolInstance! !!Socket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 22:47'!acceptFrom: aSocket	"Initialize a new socket handle from an accept call"	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore _ false.	semaphore _ Semaphore new.	readSemaphore _ Semaphore new.	writeSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	readSemaIndex _ Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex _ Smalltalk registerExternalObject: writeSemaphore.	socketHandle _ self primAcceptFrom: aSocket socketHandle						receiveBufferSize: 8000						sendBufSize: 8000						semaIndex: semaIndex						readSemaIndex: readSemaIndex						writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore _ writeSemaphore _ semaphore _ nil	] ifFalse:[self register].! !!Socket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 22:54'!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil ifFalse: 		[self isValid ifTrue: [self primSocketDestroy: socketHandle].		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		socketHandle _ nil.		readSemaphore _ writeSemaphore _ semaphore _ nil.		self unregister].! !!Socket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 23:04'!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore _ false.	semaphore _ Semaphore new.	readSemaphore _ Semaphore new.	writeSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	readSemaIndex _ Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex _ Smalltalk registerExternalObject: writeSemaphore.	socketHandle _		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore _ writeSemaphore _ semaphore _ nil	] ifFalse:[self register].! !!Socket methodsFor: 'initialize-destroy' stamp: 'mir 2/22/2002 15:48'!initializeNetwork	self class initializeNetwork! !!Socket methodsFor: 'accessing' stamp: 'ar 4/30/1999 04:25'!address	"Shortcut"	^self localAddress! !!Socket methodsFor: 'accessing' stamp: 'mir 5/15/2003 18:30'!localAddress	[self waitForConnectionFor: Socket standardTimeout]		on: ConnectionTimedOut		do: [:ex | ^ByteArray new: 4].	^ self primSocketLocalAddress: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'mir 5/15/2003 18:30'!localPort	[self waitForConnectionFor: Socket standardTimeout]		on: ConnectionTimedOut		do: [:ex | ^0 ].	^ self primSocketLocalPort: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'jm 3/13/98 12:11'!peerName	"Return the name of the host I'm connected to, or nil if its name isn't known to the domain name server or the request times out."	"Note: Slow. Calls the domain name server, taking up to 20 seconds to time out. Even when sucessful, delays of up to 13 seconds have been observed during periods of high network load." 	^ NetNameResolver		nameForAddress: self remoteAddress		timeout: 20! !!Socket methodsFor: 'accessing' stamp: 'ar 4/30/1999 04:25'!port	"Shortcut"	^self localPort! !!Socket methodsFor: 'accessing' stamp: 'JMM 6/5/2000 10:12'!primitiveOnlySupportsOneSemaphore	^primitiveOnlySupportsOneSemaphore! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/22/2000 22:49'!readSemaphore	primitiveOnlySupportsOneSemaphore ifTrue: [^semaphore].	^readSemaphore! !!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:34'!remoteAddress	^ self primSocketRemoteAddress: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:34'!remotePort	^ self primSocketRemotePort: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/9/2000 15:32'!semaphore	^semaphore! !!Socket methodsFor: 'accessing' stamp: 'ar 7/16/1999 17:22'!socketHandle	^socketHandle! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/22/2000 22:49'!writeSemaphore	primitiveOnlySupportsOneSemaphore ifTrue: [^semaphore].	^writeSemaphore! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:52'!dataAvailable	"Return true if this socket has unread received data."	socketHandle == nil ifTrue: [^ false].	^ self primSocketReceiveDataAvailable: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:52'!isConnected	"Return true if this socket is connected."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == Connected! !!Socket methodsFor: 'queries' stamp: 'JMM 5/5/2000 12:15'!isOtherEndClosed	"Return true if this socket had the other end closed."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == OtherEndClosed! !!Socket methodsFor: 'queries' stamp: 'JMM 5/5/2000 12:17'!isThisEndClosed	"Return true if this socket had the this end closed."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == ThisEndClosed! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!isUnconnected	"Return true if this socket's state is Unconnected."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == Unconnected! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!isUnconnectedOrInvalid	"Return true if this socket is completely disconnected or is invalid."	| status |	socketHandle == nil ifTrue: [^ true].	status _ self primSocketConnectionStatus: socketHandle.	^ (status = Unconnected) | (status = InvalidSocket)! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:51'!isValid	"Return true if this socket contains a valid, non-nil socket handle."	| status |	socketHandle == nil ifTrue: [^ false].	status _ self primSocketConnectionStatus: socketHandle.	^ status ~= InvalidSocket! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!isWaitingForConnection	"Return true if this socket is waiting for a connection."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == WaitingForConnection! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!sendDone	"Return true if the most recent send operation on this socket has completed."	socketHandle == nil ifTrue: [^ false].	^ self primSocketSendDone: socketHandle! !!Socket methodsFor: 'queries' stamp: 'JMM 5/8/2000 23:24'!socketError	^self primSocketError: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:56'!statusString	"Return a string describing the status of this socket."	| status |	socketHandle == nil ifTrue: [^ 'destroyed'].	status _ self primSocketConnectionStatus: socketHandle.	status = InvalidSocket ifTrue: [^ 'invalidSocketHandle'].	status = Unconnected ifTrue: [^ 'unconnected'].	status = WaitingForConnection ifTrue: [^ 'waitingForConnection'].	status = Connected ifTrue: [^ 'connected'].	status = OtherEndClosed ifTrue: [^ 'otherEndClosedButNotThisEnd'].	status = ThisEndClosed ifTrue: [^ 'thisEndClosedButNotOtherEnd'].	^ 'unknown socket status'! !!Socket methodsFor: 'connection open/close' stamp: 'bolot 7/16/1999 14:36'!accept	"Accept a connection from the receiver socket.	Return a new socket that is connected to the client"	^Socket acceptFrom: self.! !!Socket methodsFor: 'connection open/close' stamp: 'jm 9/11/97 20:29'!close	"Close this connection gracefully. For TCP, this sends a close request, but the stream remains open until the other side also closes it."	self primSocketCloseConnection: socketHandle.  "close this end"! !!Socket methodsFor: 'connection open/close' stamp: 'jm 11/4/97 07:15'!closeAndDestroy	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	self closeAndDestroy: 20.! !!Socket methodsFor: 'connection open/close' stamp: 'mir 5/15/2003 18:31'!closeAndDestroy: timeoutSeconds	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil		ifFalse: [			self isConnected ifTrue: [				self close.  "close this end"				(self waitForDisconnectionFor: timeoutSeconds)					ifFalse: [						"if the other end doesn't close soon, just abort the connection"						self primSocketAbortConnection: socketHandle]].			self destroy].! !!Socket methodsFor: 'connection open/close' stamp: 'mir 5/9/2003 18:13'!connectNonBlockingTo: hostAddress port: port	"Initiate a connection to the given port at the given host address. This operation will return immediately; follow it with waitForConnectionUntil: to wait until the connection is established."	| status |	self initializeNetwork.	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before opening a new connection'].	self primSocket: socketHandle connectTo: hostAddress port: port.! !!Socket methodsFor: 'connection open/close' stamp: 'mir 5/15/2003 18:29'!connectTo: hostAddress port: port	"Initiate a connection to the given port at the given host address.	Waits until the connection is established or time outs."	self connectTo: hostAddress port: port waitForConnectionFor: Socket standardTimeout! !!Socket methodsFor: 'connection open/close' stamp: 'mir 5/15/2003 18:29'!connectTo: hostAddress port: port waitForConnectionFor: timeout	"Initiate a connection to the given port at the given host address.	Waits until the connection is established or time outs."	self connectNonBlockingTo: hostAddress port: port.	self waitForConnectionFor: timeout! !!Socket methodsFor: 'connection open/close' stamp: 'mir 5/8/2003 16:03'!connectToHostNamed: hostName port: portNumber	| serverIP |	serverIP _ NetNameResolver addressForName: hostName timeout: 20.	^self connectTo: serverIP port: portNumber! !!Socket methodsFor: 'connection open/close' stamp: 'jm 3/10/98 11:56'!disconnect	"Break this connection, no matter what state it is in. Data that has been sent but not received will be lost."	self primSocketAbortConnection: socketHandle.! !!Socket methodsFor: 'connection open/close' stamp: 'mir 2/22/2002 16:25'!listenOn: port	"Listen for a connection on the given port. This operation will return immediately; follow it with waitForConnectionUntil: to wait until a connection is established."	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: port.! !!Socket methodsFor: 'connection open/close' stamp: 'mir 2/22/2002 16:25'!listenOn: portNumber backlogSize: backlog	"Listen for a connection on the given port.	If this method succeeds, #accept may be used to establish a new connection"	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog.! !!Socket methodsFor: 'receiving' stamp: 'jm 9/15/97 12:22'!discardReceivedData	"Discard any data received up until now, and return the number of bytes discarded."	| buf totalBytesDiscarded |	buf _ String new: 10000.	totalBytesDiscarded _ 0.	[self isConnected and: [self dataAvailable]] whileTrue: [		totalBytesDiscarded _			totalBytesDiscarded + (self receiveDataInto: buf)].	^ totalBytesDiscarded! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:52'!receiveAvailableData	"Receive all available data (if any). Do not wait." 	| buffer bytesRead |	buffer _ String new: 2000.	bytesRead _ self receiveAvailableDataInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:52'!receiveAvailableDataInto: buffer	"Receive all available data into the given buffer and return the number of bytes received.	Note the given buffer may be only partially filled by the received data.	Do not wait for data."	^self receiveAvailableDataInto: buffer startingAt: 1! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:53'!receiveAvailableDataInto: buffer startingAt: startIndex	"Receive all available data into the given buffer and return the number of bytes received.	Note the given buffer may be only partially filled by the received data.	Do not wait for data."	| bufferPos bytesRead |	bufferPos := startIndex.	[self dataAvailable		and: [bufferPos-1 < buffer size]] 		whileTrue: [			bytesRead := self receiveSomeDataInto: buffer startingAt: bufferPos.			bufferPos := bufferPos + bytesRead]! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:05'!receiveData	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	| buffer bytesRead |	buffer _ String new: 2000.	bytesRead _ self receiveDataInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:05'!receiveDataInto: aStringOrByteArray	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	^self receiveDataInto: aStringOrByteArray startingAt: 1! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 18:02'!receiveDataInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a connection close."	| bytesRead |	bytesRead := 0.	[bytesRead == 0]		whileTrue: [			self waitForData.			bytesRead := self primSocket: socketHandle				receiveDataInto: aStringOrByteArray				startingAt: aNumber				count: aStringOrByteArray size-aNumber+1].	^bytesRead! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:29'!receiveDataTimeout: timeout	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	| buffer bytesRead |	buffer _ String new: 2000.	bytesRead _ self receiveDataTimeout: timeout into: buffer.	^buffer copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'receiving' stamp: 'mir 5/16/2003 10:35'!receiveDataTimeout: timeout into: aStringOrByteArray 	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	^self receiveDataTimeout: timeout into: aStringOrByteArray startingAt: 1! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 18:02'!receiveDataTimeout: timeout into: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Wait for data once for the specified nr of seconds.	Either return data or signal a time out or connection close."	| bytesRead |	bytesRead := 0.	[bytesRead == 0]		whileTrue: [			self waitForDataFor: timeout.			bytesRead := self primSocket: socketHandle				receiveDataInto: aStringOrByteArray				startingAt: aNumber				count: aStringOrByteArray size-aNumber+1].	^bytesRead! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:18'!receiveDataWithTimeout	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	| buffer bytesRead |	buffer _ String new: 2000.	bytesRead _ self receiveDataWithTimeoutInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:18'!receiveDataWithTimeoutInto: aStringOrByteArray	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	^self receiveDataWithTimeoutInto: aStringOrByteArray startingAt: 1! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:28'!receiveDataWithTimeoutInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	^self receiveDataTimeout: Socket standardTimeout into: aStringOrByteArray startingAt: aNumber ! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:46'!receiveSomeData	"Receive currently available data (if any). Do not wait." 	| buffer bytesRead |	buffer _ String new: 2000.	bytesRead _ self receiveSomeDataInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:46'!receiveSomeDataInto: aStringOrByteArray	"Receive data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	^self receiveSomeDataInto: aStringOrByteArray startingAt: 1! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:46'!receiveSomeDataInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	^ self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: aNumber		count: aStringOrByteArray size-aNumber+1! !!Socket methodsFor: 'sending' stamp: 'mir 5/15/2003 18:33'!sendData: aStringOrByteArray	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent."	"An experimental version use on slow lines: Longer timeout and smaller writes to try to avoid spurious timeouts."	| bytesSent bytesToSend count |	bytesToSend _ aStringOrByteArray size.	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneFor: 60)			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count _ self primSocket: socketHandle			sendData: aStringOrByteArray			startIndex: bytesSent + 1			count: (bytesToSend - bytesSent min: 5000).		bytesSent _ bytesSent + count].	^ bytesSent! !!Socket methodsFor: 'sending' stamp: 'ar 7/20/1999 17:23'!sendData: buffer count: n	"Send the amount of data from the given buffer"	| sent |	sent _ 0.	[sent < n] whileTrue:[		sent _ sent + (self sendSomeData: buffer startIndex: sent+1 count: (n-sent))].! !!Socket methodsFor: 'sending' stamp: 'ls 1/5/1999 15:05'!sendSomeData: aStringOrByteArray	"Send as much of the given data as possible and answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	^ self		sendSomeData: aStringOrByteArray		startIndex: 1		count: aStringOrByteArray size! !!Socket methodsFor: 'sending' stamp: 'ls 3/3/1999 18:59'!sendSomeData: aStringOrByteArray startIndex: startIndex	"Send as much of the given data as possible starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	^ self		sendSomeData: aStringOrByteArray		startIndex: startIndex		count: (aStringOrByteArray size - startIndex + 1)! !!Socket methodsFor: 'sending' stamp: 'mir 5/15/2003 18:34'!sendSomeData: aStringOrByteArray startIndex: startIndex count: count	"Send up to count bytes of the given data starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	| bytesSent |	(self waitForSendDoneFor: 20)		ifTrue: [			bytesSent _ self primSocket: socketHandle				sendData: aStringOrByteArray				startIndex: startIndex				count: count]		ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].	^ bytesSent! !!Socket methodsFor: 'sending' stamp: 'mir 2/19/2002 18:33'!sendStreamContents: stream	"Send the data in the stream. Close the stream.	Usefull for directly sending contents of a file without reading into memory first."	self sendStreamContents: stream checkBlock: [true]! !!Socket methodsFor: 'sending' stamp: 'mir 2/19/2002 18:31'!sendStreamContents: stream checkBlock: checkBlock	"Send the data in the stream. Close the stream after you are done. After each block of data evaluate checkBlock and abort if it returns false.	Usefull for directly sending contents of a file without reading into memory first."	| chunkSize buffer |	chunkSize _ 5000.	buffer _ ByteArray new: chunkSize.	stream binary.	[[stream atEnd and: [checkBlock value]]		whileFalse: [			buffer _ stream next: chunkSize into: buffer.			self sendData: buffer]]		ensure: [stream close]! !!Socket methodsFor: 'waiting' stamp: 'mir 5/15/2003 18:30'!waitForAcceptFor: timeout	"Wait and accept an incoming connection"	self waitForConnectionFor: timeout.	self accept! !!Socket methodsFor: 'waiting' stamp: 'mir 5/15/2003 18:28'!waitForConnectionFor: timeout	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| status deadline |	deadline := Socket deadlineSecs: timeout.	status _ self primSocketConnectionStatus: socketHandle.	[(status = WaitingForConnection) and: [Time millisecondClockValue < deadline]]		whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self primSocketConnectionStatus: socketHandle].	status = Connected		ifFalse: [ConnectionTimedOut signal: (NetNameResolver stringFromAddress: self remoteAddress)]! !!Socket methodsFor: 'waiting' stamp: 'mir 5/15/2003 18:00'!waitForData	"Wait for data to arrive.	Signal connection close exception if it happens before data becomes available."	[true]		whileTrue: [			(self primSocketReceiveDataAvailable: socketHandle)				ifTrue: [^self].			self isConnected				ifFalse: [ConnectionClosed signal: 'Connection close while waiting for data.'].			self readSemaphore wait].	(self primSocketReceiveDataAvailable: socketHandle)		ifFalse: [			self isConnected				ifTrue: [ConnectionTimedOut signal: 'Data receive timed out.']				ifFalse: [ConnectionClosed signal: 'Connection close while waiting for data.']]! !!Socket methodsFor: 'waiting' stamp: 'mir 5/15/2003 17:58'!waitForDataFor: timeout	"Wait for the given nr of seconds for data to arrive.	Signal a time out or connection close exception if either happens before data becomes available."	| deadline |	deadline := Socket deadlineSecs: timeout.	[Time millisecondClockValue < deadline]		whileTrue: [			(self primSocketReceiveDataAvailable: socketHandle)				ifTrue: [^self].			self isConnected				ifFalse: [ConnectionClosed signal: 'Connection close while waiting for data.'].			self readSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	(self primSocketReceiveDataAvailable: socketHandle)		ifFalse: [			self isConnected				ifTrue: [ConnectionTimedOut signal: 'Data receive timed out.']				ifFalse: [ConnectionClosed signal: 'Connection close while waiting for data.']]! !!Socket methodsFor: 'waiting' stamp: 'mir 5/15/2003 18:32'!waitForDisconnectionFor: timeout	"Wait up until the given deadline for the the connection to be broken. Return true if it is broken by the deadline, false if not."	"Note: The client should know the the connect is really going to be closed (e.g., because he has called 'close' to send a close request to the other end) before calling this method.JMM 00/5/17 note that other end can close which will terminate wait"	| extraBytes status deadline |	extraBytes _ 0.	status _ self primSocketConnectionStatus: socketHandle.	deadline := Socket deadlineSecs: timeout.	[((status = Connected) or: [(status = ThisEndClosed)]) and:	 [Time millisecondClockValue < deadline]] whileTrue: [		self dataAvailable			ifTrue: [extraBytes _ extraBytes + self discardReceivedData].		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		status _ self primSocketConnectionStatus: socketHandle].	extraBytes > 0		ifTrue: [self inform: 'Discarded ', extraBytes printString, ' bytes while closing connection.'].	^ status ~= Connected! !!Socket methodsFor: 'waiting' stamp: 'mir 5/15/2003 18:33'!waitForSendDoneFor: timeout	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone deadline |	deadline := Socket deadlineSecs: timeout.	[self isConnected & (sendDone _ self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			self writeSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ sendDone! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex	"Create and return a new socket handle based on accepting the connection from the given listening socket"	<primitive: 'primitiveSocketAccept' module: 'SocketPlugin'>	^self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/22/2000 22:55'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"Create and return a new socket handle based on accepting the connection from the given listening socket"	<primitive: 'primitiveSocketAccept3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore _ true.	^self primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex ! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID connectTo: hostAddress port: port	"Attempt to establish a connection to the given port of the given host. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 'primitiveSocketConnectToPort' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 21:48'!primSocket: socketID getOption: aString 	"Get some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP_NODELAY, SO_KEEPALIVE are valid options for example	returns an array containing the error code and the option value"	<primitive: 'primitiveSocketGetOptions' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID listenOn: port	"Listen for a connection on the given port. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: aHandle listenOn: portNumber backlogSize: backlog	"Primitive. Set up the socket to listen on the given port.	Will be used in conjunction with #accept only."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self destroy. "Accept not supported so clean up"! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID receiveDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."	<primitive: 'primitiveSocketReceiveDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/24/2000 17:19'!primSocket: socketID receiveUDPDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. 	Return an Array containing the amount read, the host address byte array, the host port, and the more flag"	<primitive: 'primitiveSocketReceiveUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID sendData: aStringOrByteArray startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive: 'primitiveSocketSendDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 00:08'!primSocket: socketID sendUDPData: aStringOrByteArray toHost: hostAddress  port: portNumber startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive:  'primitiveSocketSendUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 7/18/2000 11:42'!primSocket: socketID setOption: aString value: aStringValue	"Set some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP_NODELAY, SO_KEEPALIVE are valid options for example	returns an array containing the error code and the negotiated value"	<primitive: 'primitiveSocketSetOptions' module: 'SocketPlugin'>	^nil! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID setPort: port	"Set the local port associated with a UDP socket.	Note: this primitive is overloaded.  The primitive will not fail on a TCP socket, but	the effects will not be what was desired.  Best solution would be to split Socket into	two subclasses, TCPSocket and UDPSocket."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketAbortConnection: socketID	"Terminate the connection on the given port immediately without going through the normal close sequence. This is an asynchronous call; query the socket status to discover if and when the connection is actually terminated."	<primitive: 'primitiveSocketAbortConnection' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketCloseConnection: socketID	"Close the connection on the given port. The remote end is informed that this end has closed and will do no further sends. This is an asynchronous call; query the socket status to discover if and when the connection is actually closed."	<primitive: 'primitiveSocketCloseConnection' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketConnectionStatus: socketID	"Return an integer reflecting the connection status of this socket. For a list of possible values, see the comment in the 'initialize' method of this class. If the primitive fails, return a status indicating that the socket handle is no longer valid, perhaps because the Squeak image was saved and restored since the socket was created. (Sockets do not survive snapshots.)"	<primitive: 'primitiveSocketConnectionStatus' module: 'SocketPlugin'>	^ InvalidSocket! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex	"Return a new socket handle for a socket of the given type and buffer sizes. Return nil if socket creation fails.	The netType parameter is platform dependent and can be used to encode both the protocol type (IP, Xerox XNS, etc.) and/or the physical network interface to use if this host is connected to multiple networks. A zero netType means to use IP protocols and the primary (or only) network interface.	The socketType parameter specifies:		0	reliable stream socket (TCP if the protocol is IP)		1	unreliable datagram socket (UDP if the protocol is IP)	The buffer size parameters allow performance to be tuned to the application. For example, a larger receive buffer should be used when the application expects to be receiving large amounts of data, especially from a host that is far away. These values are considered requests only; the underlying implementation will ensure that the buffer sizes actually used are within allowable bounds. Note that memory may be limited, so an application that keeps many sockets open should use smaller buffer sizes. Note the macintosh implementation ignores this buffer size. Also see setOption to get/set socket buffer sizes which allows you to set/get the current buffer sizes for reading and writing. 	If semaIndex is > 0, it is taken to be the index of a Semaphore in the external objects array to be associated with this socket. This semaphore will be signalled when the socket status changes, such as when data arrives or a send completes. All processes waiting on the semaphore will be awoken for each such event; each process must then query the socket state to figure out if the conditions they are waiting for have been met. For example, a process waiting to send some data can see if the last send has completed."	<primitive: 'primitiveSocketCreate' module: 'SocketPlugin'>	^ nil  "socket creation failed"! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/22/2000 22:48'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"See comment in primSocketCreateNetwork: with one semaIndex. However you should know that some implementations	ignore the buffer size and this interface supports three semaphores,  one for open/close/listen and the other two for	reading and writing"	<primitive: 'primitiveSocketCreate3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore _ true.	^ self primSocketCreateNetwork: netType			type: socketType			receiveBufferSize: rcvBufSize			sendBufSize: sendBufSize			semaIndex: semaIndex! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketDestroy: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted."	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketDestroyGently: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted.	Do not fail if the receiver is already closed."	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketError: socketID	"Return an integer encoding the most recent error on this socket. Zero means no error."	<primitive: 'primitiveSocketError' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketLocalAddress: socketID	"Return the local host address for this socket."	<primitive: 'primitiveSocketLocalAddress' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketLocalPort: socketID	"Return the local port for this socket, or zero if no port has yet been assigned."	<primitive: 'primitiveSocketLocalPort' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketReceiveDataAvailable: socketID	"Return true if data may be available for reading from the current socket."	<primitive: 'primitiveSocketReceiveDataAvailable' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketRemoteAddress: socketID	"Return the remote host address for this socket, or zero if no connection has been made."	<primitive: 'primitiveSocketRemoteAddress' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketRemotePort: socketID	"Return the remote port for this socket, or zero if no connection has been made."	<primitive: 'primitiveSocketRemotePort' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSocketSendDone: socketID	"Return true if there is no send in progress on the current socket."	<primitive: 'primitiveSocketSendDone' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'registry' stamp: 'ar 3/21/98 17:40'!register	^self class register: self! !!Socket methodsFor: 'registry' stamp: 'ar 3/21/98 17:41'!unregister	^self class unregister: self! !!Socket methodsFor: 'finalization' stamp: 'JMM 5/22/2000 22:52'!finalize	self primSocketDestroyGently: socketHandle.	Smalltalk unregisterExternalObject: semaphore.	Smalltalk unregisterExternalObject: readSemaphore.	Smalltalk unregisterExternalObject: writeSemaphore.! !!Socket methodsFor: 'printing' stamp: 'jm 11/23/1998 11:57'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '[', self statusString, ']'.! !!Socket methodsFor: 'datagrams' stamp: 'JMM 6/7/2000 14:58'!receiveDataInto: aStringOrByteArray fromHost: hostAddress port: portNumber	| datagram |	"Receive a UDP packet from the given hostAddress/portNumber, storing the data in the given buffer, and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	primitiveOnlySupportsOneSemaphore ifTrue:		[self setPeer: hostAddress port: portNumber.		^self receiveDataInto: aStringOrByteArray].	[true] whileTrue: 		[datagram _ self receiveUDPDataInto: aStringOrByteArray.		((datagram at: 2) = hostAddress and: [(datagram at: 3) = portNumber]) 			ifTrue: [^datagram at: 1]			ifFalse: [^0]]! !!Socket methodsFor: 'datagrams' stamp: 'JMM 6/3/2000 21:54'!receiveUDPDataInto: aStringOrByteArray	"Receive UDP data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data. What is returned is an array, the first element is the bytes read, the second the sending bytearray address, the third the senders port, the fourth, true if more of the datagram awaits reading"	^ self primSocket: socketHandle		receiveUDPDataInto: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size! !!Socket methodsFor: 'datagrams' stamp: 'JMM 5/25/2000 00:05'!sendData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	primitiveOnlySupportsOneSemaphore ifTrue:		[self setPeer: hostAddress port: portNumber.		^self sendData: aStringOrByteArray].	^self sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber! !!Socket methodsFor: 'datagrams' stamp: 'mir 5/15/2003 18:34'!sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	| bytesToSend bytesSent count |	bytesToSend _ aStringOrByteArray size.	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneFor: 20)			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count _ self primSocket: socketHandle			sendUDPData: aStringOrByteArray			toHost: hostAddress			port: portNumber			startIndex: bytesSent + 1			count: bytesToSend - bytesSent.		bytesSent _ bytesSent + count].	^ bytesSent! !!Socket methodsFor: 'datagrams' stamp: 'ar 4/30/1999 04:29'!setPeer: hostAddress port: port	"Set the default send/recv address."	self primSocket: socketHandle connectTo: hostAddress port: port.! !!Socket methodsFor: 'datagrams' stamp: 'ar 4/30/1999 04:29'!setPort: port	"Associate a local port number with a UDP socket.  Not applicable to TCP sockets."	self primSocket: socketHandle setPort: port.! !!Socket methodsFor: 'other' stamp: 'mir 2/22/2002 16:25'!getOption: aName 	"Get options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is an status number (0 ok, -1 read only option)	element two is the resulting of the requested option"	(socketHandle == nil or: [self isValid not])		ifTrue: [InvalidSocketStatusException signal: 'Socket status must valid before getting an option'].	^self primSocket: socketHandle getOption: aName"| foo options |Socket initializeNetwork.foo _ Socket newTCP.foo connectTo: (NetNameResolver addressFromString: '192.168.1.1') port: 80.foo waitForConnectionUntil: (Socket standardDeadline).options _ {'SO_DEBUG'. 'SO_REUSEADDR'. 'SO_REUSEPORT'. 'SO_DONTROUTE'.'SO_BROADCAST'. 'SO_SNDBUF'. 'SO_RCVBUF'. 'SO_KEEPALIVE'.'SO_OOBINLINE'. 'SO_PRIORITY'. 'SO_LINGER'. 'SO_RCVLOWAT'.'SO_SNDLOWAT'. 'IP_TTL'. 'IP_HDRINCL'. 'IP_RCVOPTS'.'IP_RCVDSTADDR'. 'IP_MULTICAST_IF'. 'IP_MULTICAST_TTL'.'IP_MULTICAST_LOOP'. 'UDP_CHECKSUM'. 'TCP_MAXSEG'.'TCP_NODELAY'. 'TCP_ABORT_THRESHOLD'. 'TCP_CONN_NOTIFY_THRESHOLD'. 'TCP_CONN_ABORT_THRESHOLD'. 'TCP_NOTIFY_THRESHOLD'.'TCP_URGENT_PTR_TYPE'}.1 to: options size do: [:i | | fum |	fum _foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr].foo _ Socket newUDP.foo setPeer: (NetNameResolver addressFromString: '192.168.1.9') port: 7.foo waitForConnectionUntil: (Socket standardDeadline).1 to: options size do: [:i | | fum |	fum _foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr]."! !!Socket methodsFor: 'other' stamp: 'mir 2/22/2002 16:30'!setOption: aName value: aValue 	| value |	"setup options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is the error number	element two is the resulting of the negotiated value.	See getOption for list of keys"	(socketHandle == nil or: [self isValid not])		ifTrue: [InvalidSocketStatusException signal: 'Socket status must valid before setting an option'].	value _ aValue asString.	aValue == true ifTrue: [value _ '1'].	aValue == false ifTrue: [value _ '0'].	^ self primSocket: socketHandle setOption: aName value: value! !!Socket class methodsFor: 'class initialization' stamp: 'ar 12/12/2001 19:12'!initialize	"Socket initialize"	"Socket Types"	TCPSocketType _ 0.	UDPSocketType _ 1.	"Socket Status Values"	InvalidSocket _ -1.	Unconnected _ 0.	WaitingForConnection _ 1.	Connected _ 2.	OtherEndClosed _ 3.	ThisEndClosed _ 4.	RegistryThreshold _ 100. "# of sockets"! !!Socket class methodsFor: 'instance creation' stamp: 'ls 9/24/1999 09:45'!acceptFrom: aSocket	^[ super new acceptFrom: aSocket ]		repeatWithGCIf: [ :sock | sock isValid not ]! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:15'!createIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	"Note: The default creates a TCP socket"	^self tcpCreateIfFail: failBlock! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:13'!new	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."	"Note: The default creates a TCP socket - this is also backward compatibility."	^self newTCP! !!Socket class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 15:48'!newTCP	"Create a socket and initialise it for TCP"	self initializeNetwork.	^[ super new initialize: TCPSocketType ]		repeatWithGCIf: [ :socket | socket isValid not ]! !!Socket class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 15:49'!newUDP	"Create a socket and initialise it for UDP"	self initializeNetwork.	^[ super new initialize: UDPSocketType ]		repeatWithGCIf: [ :socket | socket isValid not ]! !!Socket class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 15:49'!tcpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	self initializeNetwork.	sock _ super new initialize: TCPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 15:49'!udpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	self initializeNetwork.	sock _ super new initialize: UDPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'network initialization' stamp: 'mir 2/22/2002 15:01'!initializeNetwork	"Initialize the network drivers and the NetNameResolver. Do nothing if the network is already initialized."	"Note: The network must be re-initialized every time Squeak starts up, so applications that persist across snapshots should be prepared to re-initialize the network as needed. Such applications should call 'Socket initializeNetwork' before every network transaction. "	NetNameResolver initializeNetwork! !!Socket class methodsFor: 'network initialization' stamp: 'mir 2/22/2002 14:59'!primInitializeNetwork: resolverSemaIndex	"Initialize the network drivers on platforms that need it, such as the Macintosh, and return nil if network initialization failed or the reciever if it succeeds. Since mobile computers may not always be connected to a network, this method should NOT be called automatically at startup time; rather, it should be called when first starting a networking application. It is a noop if the network driver has already been initialized. If non-zero, resolverSemaIndex is the index of a VM semaphore to be associated with the network name resolver. This semaphore will be signalled when the resolver status changes, such as when a name lookup query is completed."	"Note: some platforms (e.g., Mac) only allow only one name lookup query at a time, so a manager process should be used to serialize resolver lookup requests."	<primitive: 'primitiveInitializeNetwork' module: 'SocketPlugin'>	^ nil  "return nil if primitive fails"! !!Socket class methodsFor: 'utilities' stamp: 'tk 4/9/98 15:54'!deadServer	^ DeadServer! !!Socket class methodsFor: 'utilities' stamp: 'tk 4/9/98 15:56'!deadServer: aStringOrNil	"Keep the machine name of the most recently encoutered non-responding machine.  Next time the user can move it to the last in a list of servers to try."	DeadServer _ aStringOrNil! !!Socket class methodsFor: 'utilities' stamp: 'mir 5/15/2003 18:28'!deadlineSecs: secs	"Return a deadline time the given number of seconds from now."	^ Time millisecondClockValue + (secs * 1000) truncated! !!Socket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 12:13'!nameForWellKnownTCPPort: portNum	"Answer the name for the given well-known TCP port number. Answer a string containing the port number if it isn't well-known."	| portList entry |	portList _ #(		(7 'echo') (9 'discard') (13 'time') (19 'characterGenerator')		(21 'ftp') (23 'telnet') (25 'smtp')		(80 'http') (110 'pop3') (119 'nntp')).	entry _ portList detect: [:pair | pair first = portNum] ifNone: [^ 'port-', portNum printString].	^ entry last! !!Socket class methodsFor: 'utilities' stamp: 'mir 5/15/2003 18:30'!ping: hostName	"Ping the given host. Useful for checking network connectivity. The host must be running a TCP echo server."	"Socket ping: 'squeak.cs.uiuc.edu'"	| tcpPort sock serverAddr startTime echoTime |	tcpPort _ 7.  "7 = echo port, 13 = time port, 19 = character generator port"	serverAddr _ NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil ifTrue: [		^ self inform: 'Could not find an address for ', hostName].	sock _ Socket new.	sock connectNonBlockingTo: serverAddr port: tcpPort.	[sock waitForConnectionFor: 10]		on: ConnectionTimedOut		do: [:ex |			(self confirm: 'Continue to wait for connection to ', hostName, '?')				ifTrue: [ex retry]				ifFalse: [					sock destroy.					^ self]].	sock sendData: 'echo!!'.	startTime _ Time millisecondClockValue.	[sock waitForDataFor: 15]		on: ConnectionTimedOut		do: [:ex | (self confirm: 'Packet sent but no echo yet; keep waiting?')			ifTrue: [ex retry]].	echoTime _ Time millisecondClockValue - startTime.	sock destroy.	self inform: hostName, ' responded in ', echoTime printString, ' milliseconds'.! !!Socket class methodsFor: 'utilities' stamp: 'mir 2/22/2002 15:49'!pingPorts: portList on: hostName timeOutSecs: timeOutSecs	"Attempt to connect to each of the given sockets on the given host. Wait at most timeOutSecs for the connections to be established. Answer an array of strings indicating the available ports."	"Socket pingPorts: #(7 13 19 21 23 25 80 110 119) on: 'squeak.cs.uiuc.edu' timeOutSecs: 15"	| serverAddr sockets sock deadline done unconnectedCount connectedCount waitingCount result |	serverAddr _ NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil ifTrue: [		self inform: 'Could not find an address for ', hostName.		^ #()].	sockets _ portList collect: [:portNum |		sock _ Socket new.		sock connectTo: serverAddr port: portNum].	deadline _ self deadlineSecs: timeOutSecs.	done _ false.	[done] whileFalse: [		unconnectedCount _ 0.		connectedCount _ 0.		waitingCount _ 0.		sockets do: [:s |			s isUnconnectedOrInvalid				ifTrue: [unconnectedCount _ unconnectedCount + 1]				ifFalse: [					s isConnected ifTrue: [connectedCount _ connectedCount + 1].					s isWaitingForConnection ifTrue: [waitingCount _ waitingCount + 1]]].		waitingCount = 0 ifTrue: [done _ true].		connectedCount = sockets size ifTrue: [done _ true].		Time millisecondClockValue > deadline ifTrue: [done _ true]].	result _ (sockets select: [:s | s isConnected])		collect: [:s | self nameForWellKnownTCPPort: s remotePort].	sockets do: [:s | s destroy].	^ result! !!Socket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 17:25'!pingPortsOn: hostName	"Attempt to connect to a set of well-known sockets on the given host, and answer the names of the available ports."	"Socket pingPortsOn: 'www.disney.com'"	^ Socket		pingPorts: #(7 13 19 21 23 25 80 110 119)		on: hostName		timeOutSecs: 20! !!Socket class methodsFor: 'utilities' stamp: 'mir 5/15/2003 16:17'!standardDeadline	"Return a default deadline time some seconds into the future."	^ self deadlineSecs: self standardTimeout! !!Socket class methodsFor: 'utilities' stamp: 'mir 5/15/2003 16:16'!standardTimeout	^45! !!Socket class methodsFor: 'utilities' stamp: 'ar 4/30/1999 04:21'!wildcardAddress	"Answer a don't-care address for use with UDP sockets."	^ByteArray new: 4		"0.0.0.0"! !!Socket class methodsFor: 'utilities' stamp: 'ar 4/30/1999 04:21'!wildcardPort	"Answer a don't-care port for use with UDP sockets.  (The system will allocate an	unused port number to the socket.)"	^0! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:40'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:40'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!Socket class methodsFor: 'registry' stamp: 'ar 12/12/2001 19:12'!registryThreshold	"Return the registry threshold above which socket creation may fail due to too many already open sockets. If the threshold is reached, a full GC will be issued if the creation of a socket fails."	^RegistryThreshold! !!Socket class methodsFor: 'registry' stamp: 'ar 12/12/2001 19:12'!registryThreshold: aNumber	"Return the registry threshold above which socket creation may fail due to too many already open sockets. If the threshold is reached, a full GC will be issued if the creation of a socket fails."	RegistryThreshold _ aNumber! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 15:22'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!SocketStream methodsFor: 'stream in' stamp: 'mir 3/1/2002 16:15'!next	self atEnd ifTrue: [^nil].	self inStream atEnd ifTrue: [self receiveData].	^self inStream next! !!SocketStream methodsFor: 'stream in' stamp: 'mir 2/21/2002 18:25'!next: n	| limit |	[self inStream size < n]		whileTrue: [self receiveData].	limit _ n min: self inStream size.	^self inStream next: limit! !!SocketStream methodsFor: 'stream in' stamp: 'mir 2/21/2002 18:46'!nextLine	^self nextLineCrLf! !!SocketStream methodsFor: 'stream in' stamp: 'mir 5/12/2003 16:28'!nextLineCrLf	| nextLine |	nextLine _ self upToAll: String crlf.	^nextLine! !!SocketStream methodsFor: 'stream in' stamp: 'mir 5/12/2003 16:28'!nextLineLf	| nextLine |	nextLine _ self upToAll: String lf.	^nextLine! !!SocketStream methodsFor: 'stream in' stamp: 'mir 5/9/2003 18:17'!upTo: delim 	| resultStream nextChar |	resultStream _ WriteStream on: (String new: 100).	[(nextChar _ self next) = delim]		whileFalse: [			nextChar				ifNil: [^resultStream contents]				ifNotNil: [resultStream nextPut: nextChar]].	^resultStream contents! !!SocketStream methodsFor: 'stream in' stamp: 'mir 5/15/2003 17:06'!upToAll: delims	| searchBuffer index |	searchBuffer _ String new.	[searchBuffer _ searchBuffer , self inStream upToEnd.	self resetInStream.	index _ searchBuffer indexOfSubCollection: delims startingAt: 1.	index = 0]		whileTrue: [self receiveData].	self pushBack: (searchBuffer copyFrom: index + delims size to: searchBuffer size).	^searchBuffer copyFrom: 1 to: index-1! !!SocketStream methodsFor: 'stream in' stamp: 'mir 3/1/2002 16:15'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| resultStream |	resultStream _ WriteStream on: (String new: 100).	[self atEnd]		whileFalse: [resultStream nextPut: self next].	^resultStream contents! !!SocketStream methodsFor: 'testing' stamp: 'mir 11/14/2002 17:56'!atEnd	^self isConnected not		and: [self isDataAvailable not]! !!SocketStream methodsFor: 'testing' stamp: 'mir 10/30/2000 20:00'!isConnected	^self socket isConnected! !!SocketStream methodsFor: 'testing' stamp: 'mir 5/15/2003 17:10'!isDataAvailable	^self inStream atEnd not		or: [self socket dataAvailable]! !!SocketStream methodsFor: 'testing' stamp: 'mir 10/31/2000 12:51'!isOtherEndConnected	^self socket isOtherEndClosed not! !!SocketStream methodsFor: 'testing' stamp: 'dvf 6/11/2003 18:21'!shouldTimeout	^self timeout > 0! !!SocketStream methodsFor: 'accessing' stamp: 'mir 5/20/2003 16:40'!autoFlush	^autoFlush! !!SocketStream methodsFor: 'accessing' stamp: 'mir 5/15/2003 20:52'!autoFlush: aBoolean	autoFlush := aBoolean! !!SocketStream methodsFor: 'accessing' stamp: 'mir 5/15/2003 22:14'!bufferSize	bufferSize ifNil: [bufferSize := 2000].	^bufferSize! !!SocketStream methodsFor: 'accessing' stamp: 'mir 5/15/2003 22:15'!bufferSize: anInt	bufferSize := anInt! !!SocketStream methodsFor: 'accessing' stamp: 'mir 5/20/2003 16:40'!buffered	^buffered! !!SocketStream methodsFor: 'accessing' stamp: 'mir 5/16/2003 15:02'!buffered: aBoolean	buffered := aBoolean! !!SocketStream methodsFor: 'accessing' stamp: 'mir 5/20/2003 16:44'!noTimeout	timeout := 0! !!SocketStream methodsFor: 'accessing' stamp: 'mir 10/31/2000 12:50'!socket	^socket! !!SocketStream methodsFor: 'accessing' stamp: 'mir 10/30/2000 18:59'!socket: aSocket	socket _ aSocket! !!SocketStream methodsFor: 'accessing' stamp: 'mir 5/15/2003 20:50'!timeout	timeout ifNil: [timeout := Socket standardTimeout].	^timeout! !!SocketStream methodsFor: 'accessing' stamp: 'mir 5/15/2003 20:50'!timeout: seconds	timeout := seconds! !!SocketStream methodsFor: 'initialize-release' stamp: 'mir 10/30/2000 19:59'!close	self flush.	self socket closeAndDestroy: 30! !!SocketStream methodsFor: 'initialize-release' stamp: 'mir 5/20/2003 16:40'!initialize	buffered := true.	autoFlush := true! !!SocketStream methodsFor: 'private' stamp: 'mir 5/19/2003 11:57'!checkFlush	self buffered		ifTrue: [self autoFlush			ifTrue: [self outStream position > self bufferSize				ifTrue: [self flush]]]		ifFalse: [self flush]! !!SocketStream methodsFor: 'private' stamp: 'mir 5/20/2003 14:44'!flush	self isOtherEndConnected		ifTrue: [self socket sendData: self outStream contents].	self resetOutStream! !!SocketStream methodsFor: 'private' stamp: 'mir 10/30/2000 18:56'!inStream	inStream ifNil: [inStream _ ReadStream on: ''].	^inStream! !!SocketStream methodsFor: 'private' stamp: 'mir 5/15/2003 22:16'!outStream	outStream ifNil: [outStream _ WriteStream on: (String new: self bufferSize)].	^outStream! !!SocketStream methodsFor: 'private' stamp: 'mir 10/30/2000 20:29'!pushBack: aString	inStream _ ReadStream on: (aString , self inStream contents)! !!SocketStream methodsFor: 'private' stamp: 'mir 5/20/2003 16:43'!receiveData	| buffer bytesRead |	buffer _ String new: self bufferSize.	bytesRead := self shouldTimeout		ifTrue: [self socket receiveDataTimeout: self timeout into: buffer]		ifFalse: [self socket receiveDataInto: buffer].	bytesRead > 0		ifTrue: [			inStream := ReadStream on: (self inStream upToEnd , (buffer copyFrom: 1 to: bytesRead))]! !!SocketStream methodsFor: 'private' stamp: 'mir 10/30/2000 18:56'!resetInStream	inStream _ nil! !!SocketStream methodsFor: 'private' stamp: 'mir 10/30/2000 19:03'!resetOutStream	outStream _ nil! !!SocketStream methodsFor: 'stream out' stamp: 'bolot 12/27/1999 12:17'!cr	self nextPutAll: String cr! !!SocketStream methodsFor: 'stream out' stamp: 'bolot 8/11/1999 22:13'!crlf	self nextPutAll: String crlf! !!SocketStream methodsFor: 'stream out' stamp: 'mir 5/19/2003 11:58'!nextPut: char	self outStream nextPut: char.	self checkFlush! !!SocketStream methodsFor: 'stream out' stamp: 'mir 5/19/2003 11:58'!nextPutAll: string	self outStream nextPutAll: string.	self checkFlush! !!SocketStream methodsFor: 'stream out' stamp: 'mir 11/20/2002 10:58'!sendCommand: aString	self outStream		nextPutAll: aString;		nextPutAll: String crlf.	self flush! !!SocketStream methodsFor: 'stream out' stamp: 'mir 5/8/2003 18:23'!space	self nextPut: Character space! !!SocketStream class methodsFor: 'instance creation' stamp: 'mir 5/20/2003 16:40'!on: socket	"create a socket stream on a server socket"	^self basicNew initialize socket: socket! !!SocketStream class methodsFor: 'instance creation' stamp: 'mir 5/15/2003 18:13'!openConnectionToHost: hostIP port: portNumber	| socket |	socket _ Socket new.	socket connectTo: hostIP port: portNumber.	^self on: socket! !!SocketStream class methodsFor: 'instance creation' stamp: 'mir 5/8/2003 16:04'!openConnectionToHostNamed: hostName port: portNumber	| hostIP |	hostIP _ NetNameResolver addressForName: hostName timeout: 20.	^self openConnectionToHost: hostIP port: portNumber! !!SocketStream class methodsFor: 'example' stamp: 'mir 11/14/2002 17:48'!finger: userName	"SocketStream finger: 'stp'"	| addr s |	addr _ NetNameResolver promptUserForHostAddress.	s _ SocketStream openConnectionToHost: addr port: 79.  "finger port number"	Transcript show: '---------- Connecting ----------'; cr.	s sendCommand: userName.	Transcript show: s getLine.	s close.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 17:42'!connectSocks5	self		socks5MethodSelection;		sendSocks5ConnectionRequest;		socks5RequestReply! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 17:29'!hostIP6Code	^4! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 15:20'!hostIPCode	^1! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 15:15'!qualifiedHostNameCode	^3! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 17:25'!sendSocks5ConnectionRequest	"Once the method-dependent subnegotiation has completed, the client   sends the request details."	| requestString |	requestString _ WriteStream on: ByteArray new.	requestString		nextPut: 5;		nextPut: self connectCommandCode;		nextPut: 0. "Reserved slot"	dstName isNil		ifTrue: [			requestString				nextPutAll: self hostIPCode;				nextPutAll: dstIP]		ifFalse: [			requestString				nextPut: self qualifiedHostNameCode;				nextPut: dstName size;				nextPutAll: dstName asByteArray].	requestString nextWordPut: dstPort.	self sendData: requestString contents! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 17:35'!skipQualifiedHostName	| startTime response bytesRead |	startTime _ Time millisecondClockValue.	response _ ByteArray new: 1.	[(bytesRead _ self receiveDataInto: response) < 1		and: [(Time millisecondClockValue - startTime) < self defaultTimeOutDuration]] whileTrue.	bytesRead < 1		ifTrue: [self socksError: 'Time out reading data'].	self waitForReply: (response at: 1) + 2 for: self defaultTimeOutDuration! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 15:16'!socks5MethodSelection	"The client connects to the server, and sends a version   identifier/method selection message.	The server selects from one of the methods given in METHODS, and   sends a METHOD selection message."	| requestString response |	requestString _ WriteStream on: ByteArray new.	requestString		nextPut: 5;		nextPut: 1;		nextPut: 0.	self sendData: requestString contents.	response _ self waitForReply: 2 for: self defaultTimeOutDuration.	(response at: 2) == 16rFF		ifTrue: [self socksError: 'No acceptable methods.']		ifFalse: [method _ response at: 2]! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 17:28'!socks5RequestReply	| response |	response _ self waitForReply: 4 for: self defaultTimeOutDuration.	"Skip rest for now."	(response at: 4) = self hostIPCode		ifTrue: [self waitForReply: 6 for: self defaultTimeOutDuration].	(response at: 4) = self qualifiedHostNameCode		ifTrue: [self skipQualifiedHostName].	(response at: 4) = self hostIP6Code		ifTrue: [self waitForReply: 18 for: self defaultTimeOutDuration].	(response at: 2) ~= 0		ifTrue: [^self socksError: 'Connection failed: ', (response at: 2) printString].! !!SocksSocket methodsFor: 'private' stamp: 'mir 3/6/2000 13:34'!connectCommandCode	^1! !!SocksSocket methodsFor: 'private' stamp: 'mir 3/6/2000 15:07'!defaultTimeOutDuration	^20000! !!SocksSocket methodsFor: 'private' stamp: 'mir 3/6/2000 15:29'!dstIP	^dstIP! !!SocksSocket methodsFor: 'private' stamp: 'mir 2/22/2002 16:23'!dstPort	^dstPort! !!SocksSocket methodsFor: 'private' stamp: 'mir 3/6/2000 14:03'!requestGrantedCode	^90! !!SocksSocket methodsFor: 'private' stamp: 'mir 9/26/2000 11:23'!shouldUseSocks	^vers notNil! !!SocksSocket methodsFor: 'private' stamp: 'mir 3/6/2000 15:11'!socksError: errorString	self close; destroy.	self error: errorString! !!SocksSocket methodsFor: 'private' stamp: 'len 12/14/2002 11:39'!waitForReply: replySize for: timeOutDuration	| startTime response delay bytesRead |	startTime _ Time millisecondClockValue.	response _ ByteArray new: replySize.	bytesRead _ 0.	delay _ Delay forMilliseconds: 500.	[bytesRead < replySize		and: [(Time millisecondClockValue - startTime) < timeOutDuration]] whileTrue: [		bytesRead _ bytesRead + (self receiveDataInto: response).		delay wait.		Transcript show: '.'].	bytesRead < replySize		ifTrue: [self close; destroy.				^ (ConnectionRefused host: self dstIP port: self dstPort) signal].	^response! !!SocksSocket methodsFor: 'initialize' stamp: 'mir 9/26/2000 00:05'!socks4	vers _ 4.	method _ nil.	socksIP _ self class defaultSocksHostAddress.	socksPort _ self class defaultSocksPort! !!SocksSocket methodsFor: 'initialize' stamp: 'mir 9/26/2000 00:05'!socks5	vers _ 5.	method _ self class noAutorizationMethod.	socksIP _ self class defaultSocksHostAddress.	socksPort _ self class defaultSocksPort! !!SocksSocket methodsFor: 'socks4' stamp: 'mir 3/6/2000 15:07'!connectSocks4	self		sendSocks4ConnectionRequestUserId: '';		waitForSocks4ConnectionReply.! !!SocksSocket methodsFor: 'socks4' stamp: 'mir 2/22/2002 15:49'!sendSocks4ConnectionRequestUserId: userId	"The client connects to the SOCKS server and sends a CONNECT request whenit wants to establish a connection to an application server. The clientincludes in the request packet the IP address and the port number of thedestination host, and userid, in the following format.	+----+----+----+----+----+----+----+----+----+----+....+----+	| VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|	+----+----+----+----+----+----+----+----+----+----+....+----+	   1    1      2              4           variable       1	"	| requestString |	requestString _ WriteStream on: ByteArray new.	dstIP		ifNil: [dstIP _ NetNameResolver addressForName: dstName].	requestString		nextPut: 4;		nextPut: self connectCommandCode;		nextWordPut: dstPort;		nextPutAll: self dstIP;		nextPutAll: userId asByteArray;		nextPut: 0.	self sendData: requestString contents! !!SocksSocket methodsFor: 'socks4' stamp: 'mir 3/6/2000 15:11'!waitForSocks4ConnectionReply	| response |	response _ self waitForReply: 8 for: self defaultTimeOutDuration.	(response at: 2) = self requestGrantedCode		ifFalse: [^self socksError: 'Connection failed: ' , (response at: 2) printString].! !!SocksSocket methodsFor: 'connection open/close' stamp: 'mir 2/22/2002 15:49'!connectTo: hostAddress port: port	self initializeNetwork.	self shouldUseSocks		ifFalse: [^super connectTo: hostAddress port: port].	super connectTo: socksIP port: socksPort.	self waitForConnectionUntil: Socket standardDeadline.	dstIP _ hostAddress.	dstPort _ port.	vers == 4		ifTrue: [self connectSocks4]		ifFalse: [self connectSocks5]	! !!SocksSocket methodsFor: 'connection open/close' stamp: 'mir 3/6/2000 15:17'!connectToHostNamed: hostName port: port	super connectTo: socksIP port: socksPort.	self waitForConnectionUntil: Socket standardDeadline.	dstName _ hostName.	dstPort _ port.	vers == 4		ifTrue: [self connectSocks4]		ifFalse: [self connectSocks5]	! !!SocksSocket methodsFor: 'methods' stamp: 'mir 3/6/2000 13:24'!noAutorizationMethod	^0! !!SocksSocket class methodsFor: 'accessing' stamp: 'mir 11/6/2002 17:10'!defaultSocksHostAddress	^NetNameResolver addressForName: InternetConfiguration default httpProxy host! !!SocksSocket class methodsFor: 'accessing' stamp: 'mir 11/6/2002 17:11'!defaultSocksPort	^InternetConfiguration default httpProxy port! !!SocksSocket class methodsFor: 'accessing' stamp: 'mir 9/26/2000 00:06'!defaultSocksVersion	"nil means no socks"	^DefaultSocksVersion! !!SocksSocket class methodsFor: 'accessing' stamp: 'mir 9/26/2000 00:07'!defaultSocksVersion: anInteger	"nil means no socks"	DefaultSocksVersion _ anInteger! !!TelnetProtocolClient methodsFor: 'private' stamp: 'mir 2/22/2002 17:34'!determineResponseCode	self lastResponse size >= 3		ifFalse: [^0].	^[SmallInteger readFromString: (self lastResponse copyFrom: 1 to: 3)]		on: Error		do: [:ex | ex return: 0]! !!TelnetProtocolClient methodsFor: 'private' stamp: 'mir 11/14/2002 18:27'!lastResponse: aString	super lastResponse: aString.	responseCode _ self determineResponseCode! !!TelnetProtocolClient methodsFor: 'accessing' stamp: 'mir 2/22/2002 17:33'!responseCode	^responseCode! !!TelnetProtocolClient methodsFor: 'private protocol' stamp: 'len 12/14/2002 14:43'!fetchNextResponse	"The telnet protocol allows multiple line replies."	| response result |	result := '' writeStream.	[response := self stream nextLine.	self responseIsContinuation: response]		whileTrue: [result nextPutAll: response; cr].	result nextPutAll: response.	self lastResponse: result contents! !!TelnetProtocolClient methodsFor: 'private protocol' stamp: 'mir 4/7/2003 15:46'!lookForCode: code	"We are expecting a certain code next."	self		lookForCode: code		ifDifferent: [:response | (TelnetProtocolError protocolInstance: self) signal: response]! !!TelnetProtocolClient methodsFor: 'private protocol' stamp: 'mir 11/14/2002 16:21'!lookForCode: code ifDifferent: handleBlock	"We are expecting a certain code next."	self fetchNextResponse.	self responseCode == code		ifFalse: [handleBlock value: self lastResponse]! !!TelnetProtocolClient methodsFor: 'private testing' stamp: 'mir 2/22/2002 17:35'!responseIsContinuation	^(self lastResponse size > 3		and: [(self lastResponse at: 4) == $-])! !!TelnetProtocolClient methodsFor: 'private testing' stamp: 'mir 11/14/2002 16:18'!responseIsContinuation: response	^(response size > 3		and: [(response at: 4) == $-])! !!TelnetProtocolClient methodsFor: 'private testing' stamp: 'mir 2/22/2002 17:35'!responseIsError	^self responseCode between: 500 and: 599! !!TelnetProtocolClient methodsFor: 'private testing' stamp: 'mir 2/22/2002 17:35'!responseIsWarning	^self responseCode between: 400 and: 499! !!FTPClient methodsFor: 'private' stamp: 'mir 2/19/2002 18:27'!closeDataSocket	self dataSocket		ifNotNil: [			self dataSocket closeAndDestroy.			self dataSocket: nil]! !!FTPClient methodsFor: 'private' stamp: 'mir 10/31/2000 16:24'!dataSocket	^dataSocket! !!FTPClient methodsFor: 'private' stamp: 'mir 10/31/2000 18:23'!dataSocket: aSocket	dataSocket _ aSocket! !!FTPClient methodsFor: 'private' stamp: 'mir 4/7/2003 17:20'!login	self user ifNil: [^self].	["repeat both USER and PASS since some servers require it"	self sendCommand: 'USER ', self user.	"331 Password required"	self lookForCode: 331.	"will ask user, if needed"	self sendCommand: 'PASS ', self password.	"230 User logged in"	([self lookForCode: 230.]		on: TelnetProtocolError		do: [false]) == false		] whileTrue: [			(LoginFailedException protocolInstance: self) signal: self lastResponse]! !!FTPClient methodsFor: 'private' stamp: 'mir 11/14/2002 18:14'!sendStreamContents: aStream	self dataSocket sendStreamContents: aStream checkBlock: [self checkForPendingError. true]! !!FTPClient methodsFor: 'protocol' stamp: 'mir 2/13/2002 18:05'!abortDataConnection	self sendCommand: 'ABOR'.	self closeDataSocket! !!FTPClient methodsFor: 'protocol' stamp: 'mir 3/7/2002 13:36'!ascii	self sendCommand: 'TYPE A'.	self lookForCode: 200! !!FTPClient methodsFor: 'protocol' stamp: 'mir 3/7/2002 13:36'!binary	self sendCommand: 'TYPE I'.	self lookForCode: 200! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/13/2002 17:52'!changeDirectoryTo: newDirName	self sendCommand: 'CWD ' , newDirName.	self checkResponse.! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/19/2002 17:11'!deleteDirectory: dirName	self sendCommand: 'RMD ' , dirName.	self checkResponse.! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/19/2002 17:12'!deleteFileNamed: fileName	self sendCommand: 'DELE ' , fileName.	self checkResponse.! !!FTPClient methodsFor: 'protocol' stamp: 'mir 2/20/2002 13:53'!getDirectory	| dirList |	self openPassiveDataConnection.	self sendCommand: 'LIST'.	dirList _ self getData.	self checkResponse.	self checkResponse.	^dirList! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/19/2002 16:50'!getFileList	| dirList |	self openPassiveDataConnection.	self sendCommand: 'NLST'.	dirList _ self getData.	self checkResponse.	self checkResponse.	^dirList! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/19/2002 19:23'!getFileNamed: remoteFileName	| data |	self openPassiveDataConnection.	self sendCommand: 'RETR ', remoteFileName.	[self checkResponse]		on: TelnetProtocolError		do: [:ex |			self closeDataSocket.			ex pass].	data _ self getData.	self checkResponse.	^data! !!FTPClient methodsFor: 'protocol' stamp: 'mir 5/9/2003 15:50'!getFileNamed: remoteFileName into: dataStream	self openPassiveDataConnection.	self sendCommand: 'RETR ', remoteFileName.	[self checkResponse]		on: TelnetProtocolError		do: [:ex |			self closeDataSocket.			ex pass].	self getDataInto: dataStream.	self closeDataSocket.	self checkResponse! !!FTPClient methodsFor: 'protocol' stamp: 'mir 10/31/2000 19:03'!getPartial: limit fileNamed: remoteFileName into: dataStream	| data |	self openPassiveDataConnection.	self sendCommand: 'RETR ', remoteFileName.	[self checkResponse]		on: TelnetProtocolError		do: [:ex |			self closeDataSocket.			ex pass].	data _ self get: limit dataInto: dataStream.	self abortDataConnection.	^data! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/12/2002 18:39'!loginUser: userName password: passwdString	self user: userName.	self password: passwdString.	self login! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/19/2002 17:10'!makeDirectory: newDirName	self sendCommand: 'MKD ' , newDirName.	self checkResponse.! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/14/2002 17:51'!openDataSocket: remoteHostAddress port: dataPort	dataSocket _ Socket new.	dataSocket connectTo: remoteHostAddress port: dataPort! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/14/2002 16:55'!passive	self sendCommand: 'PASV'.	self lookForCode: 227! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/19/2002 16:54'!putFileNamed: filePath as: fileNameOnServer	"FTP a file to the server."	| fileStream |	fileStream _ FileStream readOnlyFileNamed: filePath.	fileStream		ifNil: [(FileDoesNotExistException fileName: filePath) signal].	self putFileStreamContents: fileStream as: fileNameOnServer! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/19/2002 16:53'!putFileStreamContents: fileStream as: fileNameOnServer	"FTP a file to the server."	self openPassiveDataConnection.	self sendCommand: 'STOR ', fileNameOnServer.	[self sendStreamContents: fileStream]		ensure: [self closeDataSocket].	self checkResponse.	self checkResponse.! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/14/2002 16:43'!pwd	| result |	self sendCommand: 'PWD'.	self lookForCode: 257.	result := self lastResponse.	^result copyFrom: (result indexOf: $")+1 to: (result lastIndexOf: $")-1! !!FTPClient methodsFor: 'protocol' stamp: 'mir 10/31/2000 13:12'!quit	self sendCommand: 'QUIT'.	self close! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/13/2002 17:50'!removeFileNamed: remoteFileName	self sendCommand: 'DELE ', remoteFileName.	self checkResponse.! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/13/2002 17:49'!renameFileNamed: oldFileName to: newFileName	self sendCommand: 'RNFR ' , oldFileName.	self lookForCode: 200.	self sendCommand: 'RNTO ' , newFileName.	self lookForCode: 200! !!FTPClient methodsFor: 'private protocol' stamp: 'mir 11/14/2002 18:13'!get: limit dataInto: dataStream	"Reel in data until the server closes the connection or the limit is reached.	At the same time, watch for errors on otherSocket."	| buf bytesRead currentlyRead |	currentlyRead _ 0.	buf _ String new: 4000.	[[currentlyRead < limit]		whileTrue: [			self checkForPendingError.			bytesRead _ self dataSocket receiveDataWithTimeoutInto: buf.			1 to: (bytesRead min: (limit - currentlyRead)) do: [:ii | dataStream nextPut: (buf at: ii)].			currentlyRead _ currentlyRead + bytesRead]]		on: ConnectionClosed		do: [:ex | ].	dataStream reset.	"position: 0."	^ dataStream! !!FTPClient methodsFor: 'private protocol' stamp: 'mir 2/13/2002 18:06'!getData	| dataStream |	dataStream _ RWBinaryOrTextStream on: (String new: 4000).	self getDataInto: dataStream.	self closeDataSocket.	^dataStream contents! !!FTPClient methodsFor: 'private protocol' stamp: 'mir 11/14/2002 18:13'!getDataInto: dataStream	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Don't know how much is coming.  Put the data on the stream."	| buf bytesRead |	buf _ String new: 4000.	[[true]		whileTrue: [			self checkForPendingError.			bytesRead _ self dataSocket receiveDataWithTimeoutInto: buf.			1 to: bytesRead do: [:ii | dataStream nextPut: (buf at: ii)]]]		on: ConnectionClosed		do: [:ex | ].	dataStream reset.	"position: 0."	^ dataStream! !!FTPClient methodsFor: 'private protocol' stamp: 'mir 4/7/2003 16:59'!openPassiveDataConnection	| portInfo list dataPort remoteHostAddress |	self sendCommand: 'PASV'.	self lookForCode: 227 ifDifferent: [:response | (TelnetProtocolError protocolInstance: self) signal: 'Could not enter passive mode: ' , response].	portInfo _ (self lastResponse findTokens: '()') at: 2.	list _ portInfo findTokens: ','.	remoteHostAddress _ ByteArray		with: (list at: 1) asNumber		with: (list at: 2) asNumber		with: (list at: 3) asNumber		with: (list at: 4) asNumber.	dataPort _ (list at: 5) asNumber * 256 + (list at: 6) asNumber.	self openDataSocket: remoteHostAddress port: dataPort! !!SMTPClient methodsFor: 'private protocol' stamp: 'mir 2/22/2002 16:42'!data: messageData	"send the data of a message"	"DATA <CRLF>"	| cookedLine |	"inform the server we are sending the message data"	self sendCommand: 'DATA'.	self checkResponse.	"process the data one line at a time"	messageData linesDo:  [ :messageLine |		cookedLine _ messageLine.		(cookedLine beginsWith: '.') ifTrue: [ 			"lines beginning with a dot must have the dot doubled"			cookedLine _ '.', cookedLine ].		self sendCommand: cookedLine ].	"inform the server the entire message text has arrived"	self sendCommand: '.'.	self checkResponse.! !!SMTPClient methodsFor: 'private protocol' stamp: 'mir 6/12/2003 15:47'!initiateSession	"HELO <SP> <domain> <CRLF>"	"self checkResponse."	self sendCommand: 'HELO ' , NetNameResolver localHostName.	self checkResponse.! !!SMTPClient methodsFor: 'private protocol' stamp: 'mir 6/12/2003 15:39'!login	self user ifNil: [^self].	self sendCommand: 'AUTH LOGIN ' , (self encodeString: self user).	[self checkResponse]		on: TelnetProtocolError		do: [ :ex | ex isCommandUnrecognized ifTrue: [^ self] ifFalse: [ex pass]].	self sendCommand: (self encodeString: self password).	self checkResponse! !!SMTPClient methodsFor: 'private protocol' stamp: 'mir 2/21/2002 17:51'!mailFrom: fromAddress	" MAIL <SP> FROM:<reverse-path> <CRLF>"	self sendCommand: 'MAIL FROM: <', fromAddress, '>'.	self checkResponse.! !!SMTPClient methodsFor: 'private protocol' stamp: 'mir 2/21/2002 17:52'!quit	"send a QUIT command.  This is polite to do, and indeed some servers might drop messages that don't have an associated QUIT"	"QUIT <CRLF>"	self sendCommand: 'QUIT'.	self checkResponse.! !!SMTPClient methodsFor: 'private protocol' stamp: 'mir 2/21/2002 17:52'!recipient: aRecipient	"specify a recipient for the message.  aRecipient should be a bare email address"	"RCPT <SP> TO:<forward-path> <CRLF>"	self sendCommand: 'RCPT TO: <', aRecipient, '>'.	self checkResponse.! !!SMTPClient methodsFor: 'public protocol' stamp: 'mir 2/21/2002 15:43'!mailFrom: sender to: recipientList text: messageText	"deliver this mail to a list of users.  NOTE: the recipient list should be a collection of simple internet style addresses -- no '<>' or '()' stuff"	self mailFrom: sender.	recipientList do: [ :recipient |		self recipient: recipient ].	self data: messageText.! !!SMTPClient methodsFor: 'utility' stamp: 'dvf 11/18/2002 23:39'!encodeString: aString 	| str dec |	str _ String new: (aString size * 4 / 3 + 3) ceiling.	dec _ Base64MimeConverter new.	dec		mimeStream: (WriteStream on: str);		dataStream: (ReadStream on: aString);		mimeEncode.	^ str! !!TelnetProtocolClient class methodsFor: 'accessing' stamp: 'mir 2/21/2002 17:21'!rawResponseCodes	self subclassResponsibility! !!FTPClient class methodsFor: 'accessing' stamp: 'mir 10/30/2000 20:10'!defaultPortNumber	^21! !!FTPClient class methodsFor: 'accessing' stamp: 'mir 2/25/2002 19:08'!logFlag	^#ftp! !!FTPClient class methodsFor: 'accessing' stamp: 'mir 2/13/2002 17:50'!rawResponseCodes	#(200 'Command okay.'	500 'Syntax error, command unrecognized. This may include errors such as command line too long.'	501 'Syntax error in parameters or arguments.'	202 'Command not implemented, superfluous at this site.'	502 'Command not implemented.'	503 'Bad sequence of commands.'	504 'Command not implemented for that parameter.'	110 'Restart marker reply. In this case, the text is exact and not left to the particular implementation; it must read: MARK yyyy = mmmm Where yyyy is User-process data stream marker, and mmmm server''s equivalent marker (note the spaces between markers and "=").'	211 'System status, or system help reply.'	212 'Directory status.'	213 'File status.'	214 'Help message. On how to use the server or the meaning of a particular non-standard command. This reply is useful only to the human user.'	215 'NAME system type. Where NAME is an official system name from the list in the Assigned Numbers document.'	120 'Service ready in nnn minutes.'	220 'Service ready for new user.'	221 'Service closing control connection. Logged out if appropriate.'	421 'Service not available, closing control connection. This may be a reply to any command if the service knows it must shut down.'	125 'Data connection already open; transfer starting.'	225 'Data connection open; no transfer in progress.'	425 'Can''t open data connection.'	226 'Closing data connection. Requested file action successful (for example, file transfer or file abort).'	426 'Connection closed; transfer aborted.'	227 'Entering Passive Mode (h1,h2,h3,h4,p1,p2).'	230 'User logged in, proceed.'	530 'Not logged in.'	331 'User name okay, need password.'	332 'Need account for login.'	532 'Need account for storing files.'	150 'File status okay; about to open data connection.'	250 'Requested file action okay, completed.'	257 '"PATHNAME" created.'	350 'Requested file action pending further information.'	450 'Requested file action not taken. File unavailable (e.g., file busy).'	550 'Requested action not taken. File unavailable (e.g., file not found, no access).'	451 'Requested action aborted. Local error in processing.'	551 'Requested action aborted. Page type unknown.'	452 'Requested action not taken. Insufficient storage space in system.'	552 'Requested file action aborted. Exceeded storage allocation (for current directory or dataset).'	553 'Requested action not taken. File name not allowed.')! !!SMTPClient class methodsFor: 'accessing' stamp: 'mir 2/21/2002 17:22'!defaultPortNumber	^25! !!SMTPClient class methodsFor: 'accessing' stamp: 'mir 2/25/2002 19:07'!logFlag	^#smtp! !!SMTPClient class methodsFor: 'example' stamp: 'mir 2/22/2002 16:41'!example	"SMTPClient example"	self deliverMailFrom: 'm.rueger@acm.org' to: #('m.rueger@acm.org') text:'From: testTo: "not listed"Subject: this is a testHello from Squeak!!'	usingServer: 'smtp.concentric.net'! !!SMTPClient class methodsFor: 'example' stamp: 'mir 2/22/2002 16:43'!example2	"SMTPClient example2"	self deliverMailFrom: 'm.rueger@acm.org' to: #('m.rueger@acm.org') text:'Subject: this is a testHello from Squeak!!'	usingServer: 'smtp.concentric.net'! !!SMTPClient class methodsFor: 'sending mail' stamp: 'mir 2/22/2002 12:30'!deliverMailFrom: fromAddress to: recipientList text: messageText usingServer: serverName	"Deliver a single email to a list of users and then close the connection.  For delivering multiple messages, it is best to create a single connection and send all mail over it.  NOTE: the recipient list should be a collection of simple internet style addresses -- no '<>' or '()' stuff"	| smtpClient |	smtpClient _ self openOnHostNamed: serverName.	[smtpClient mailFrom: fromAddress to: recipientList text: messageText.	smtpClient quit]		ensure: [smtpClient close]! !!SMTPClient class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 17:37'!openOnHost: hostIP port: portNumber	| client |	client _ super openOnHost: hostIP port: portNumber.	client initiateSession.	^client! !!TelnetProtocolError methodsFor: 'accessing' stamp: 'mir 4/7/2003 16:47'!code	^self protocolInstance responseCode! !!TelnetProtocolError methodsFor: 'private' stamp: 'len 12/14/2002 14:15'!isCommandUnrecognized	^ self code = 500! !Socket initialize!Object subclass: #NetNameResolver	instanceVariableNames: ''	classVariableNames: 'DefaultHostName HaveNetwork ResolverBusy ResolverError ResolverMutex ResolverReady ResolverSemaphore ResolverUninitialized '	poolDictionaries: ''	category: 'Network-Kernel'!!NetNameResolver commentStamp: '<historical>' prior: 0!This class implements TCP/IP style network name lookup and translation facilities.Attempt to keep track of whether there is a network available.HaveNetwork	true if last attempt to contact the network was successful.LastContact		Time of that contact (totalSeconds).haveNetwork	returns true, false, or #expired.  True means there was contact in the last 30 minutes.  False means contact failed or was false last time we asked.  Get out of false state by making contact with a server in some way (FileList or updates).!!NetNameResolver class methodsFor: 'lookups' stamp: 'mir 2/22/2002 15:50'!addressForName: hostName timeout: secs	"Look up the given host name and return its address. Return nil if the address is not found in the given number of seconds."	"NetNameResolver addressForName: 'create.ucsb.edu' timeout: 30"	"NetNameResolver addressForName: '100000jobs.de' timeout: 30"	"NetNameResolver addressForName: '1.7.6.4' timeout: 30"	"NetNameResolver addressForName: '' timeout: 30 (This seems to return nil?)"	| deadline result |	self initializeNetwork.	"check if this is a valid numeric host address (e.g. 1.2.3.4)"	result _ self addressFromString: hostName.	result isNil ifFalse: [^result].	"Look up a host name, including ones that start with a digit (e.g. 100000jobs.de or squeak.org)"	deadline _ Time millisecondClockValue + (secs * 1000).	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."	self resolverMutex		critical: [			(self waitForResolverReadyUntil: deadline)				ifTrue: [					self primStartLookupOfName: hostName.					(self waitForCompletionUntil: deadline)						ifTrue: [result _ self primNameLookupResult]						ifFalse: [(NameLookupFailure hostName: hostName) signal: 'Could not resolve the server named: ', hostName]]				ifFalse: [(NameLookupFailure hostName: hostName) signal: 'Could not resolve the server named: ', hostName]]		ifError: [:msg :rcvr| rcvr error: msg].	^result! !!NetNameResolver class methodsFor: 'lookups' stamp: 'mir 2/22/2002 15:50'!localHostAddress	"Return the local address of this host."	"NetNameResolver localHostAddress"	self initializeNetwork.	^ self primLocalAddress! !!NetNameResolver class methodsFor: 'lookups' stamp: 'mir 2/22/2002 15:12'!localHostName	"Return the local name of this host."	"NetNameResolver localHostName"	| hostName |	hostName _ NetNameResolver		nameForAddress: self localHostAddress		timeout: 5.	^hostName		ifNil: [self localAddressString]		ifNotNil: [hostName]! !!NetNameResolver class methodsFor: 'lookups' stamp: 'mir 2/22/2002 15:50'!nameForAddress: hostAddress timeout: secs	"Look up the given host address and return its name. Return nil if the lookup fails or is not completed in the given number of seconds. Depends on the given host address being known to the gateway, which may not be the case for dynamically allocated addresses."	"NetNameResolver		nameForAddress: (NetNameResolver addressFromString: '128.111.92.40')		timeout: 30"	| deadline result |	self initializeNetwork.	deadline _ Time millisecondClockValue + (secs * 1000).	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."	self resolverMutex		critical: [			result _ (self waitForResolverReadyUntil: deadline)				ifTrue: [					self primStartLookupOfAddress: hostAddress.					(self waitForCompletionUntil: deadline)						ifTrue: [self primAddressLookupResult]						ifFalse: [nil]]				ifFalse: [nil]]		ifError: [:msg :rcvr| rcvr error: msg].	^result! !!NetNameResolver class methodsFor: 'lookups' stamp: 'mir 2/22/2002 16:31'!promptUserForHostAddressDefault: defaultName	"Ask the user for a host name and return its address. If the default name is the empty string, use the last host name as the default."	"NetNameResolver promptUserForHostAddressDefault: ''"	| default hostName serverAddr |	defaultName isEmpty		ifTrue: [default _ DefaultHostName]		ifFalse: [default _ defaultName].	hostName _ FillInTheBlank		request: 'Host name or address?'		initialAnswer: default.	hostName isEmpty ifTrue: [^ 0].	serverAddr _ NetNameResolver addressForName: hostName timeout: 15.	serverAddr = nil ifTrue: [(NameLookupFailure hostName: hostName) signal: 'Could not find the address for ', hostName].	hostName size > 0 ifTrue: [DefaultHostName _ hostName].	^ serverAddr! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'mir 2/22/2002 15:03'!initializeNetwork	"Initialize the network drivers and record the semaphore to be used by the resolver. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails."	"NetNameResolver initializeNetwork"	| semaIndex |	self resolverStatus = ResolverUninitialized		ifFalse: [^HaveNetwork _ true].  "network is already initialized"	HaveNetwork _ false.	"in case abort"	ResolverSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: ResolverSemaphore.	"result is nil if network initialization failed, self if it succeeds"	(self primInitializeNetwork: semaIndex)		ifNil: [NoNetworkError signal: 'failed network initialization']		ifNotNil: [HaveNetwork _ true].! !NetNameResolver class removeSelector: #haveNetwork!NetNameResolver class removeSelector: #haveNetwork:!NetNameResolver class removeSelector: #initializeNetworkIfFail:!!ConnectionQueue methodsFor: 'private' stamp: 'mir 5/15/2003 18:27'!listenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	| newConnection |	socket _ Socket newTCP.	"We'll accept four simultanous connections at the same time"	socket listenOn: portNumber backlogSize: 4.	"If the listener is not valid then the we cannot use the	BSD style accept() mechanism."	socket isValid ifFalse: [^self oldStyleListenLoop].	[true] whileTrue: [		socket isValid ifFalse: [			"socket has stopped listening for some reason"			socket destroy.			(Delay forMilliseconds: 10) wait.			^self listenLoop ].		[newConnection _ socket waitForAcceptFor: 10]			on: ConnectionTimedOut			do: [:ex | newConnection _ nil].		newConnection				ifNotNil: [accessSema critical: [connections addLast: newConnection]].		self pruneStaleConnections]. ! !!ConnectionQueue methodsFor: 'private' stamp: 'mir 5/15/2003 18:28'!oldStyleListenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	[true] whileTrue: [		((socket == nil) and: [connections size < maxQueueLength]) ifTrue: [			"try to create a new socket for listening"			socket _ Socket createIfFail: [nil]].		socket == nil			ifTrue: [(Delay forMilliseconds: 100) wait]			ifFalse: [				socket isUnconnected ifTrue: [socket listenOn: portNumber].				[socket waitForConnectionFor: 10]					on: ConnectionTimedOut					do: [:ex |						socket isConnected							ifTrue: [  "connection established"								accessSema critical: [connections addLast: socket].								socket _ nil]							ifFalse: [								socket isWaitingForConnection									ifFalse: [socket destroy. socket _ nil]]]].  "broken socket; start over"		self pruneStaleConnections].! !!ArbitraryObjectSocket methodsFor: 'private' stamp: 'mir 5/15/2003 15:35'!processInput	"recieve some data"	| inObjectData |	"read as much data as possible"	self addToInBuf: socket receiveAvailableData.	"decode as many objects as possible"	[self nextObjectLength ~~ nil and: [ self nextObjectLength <= (self inBufSize + 4) ]] whileTrue: [		"a new object has arrived"		inObjectData _ inBuf copyFrom: (inBufIndex + 4) to: (inBufIndex + 3 + self nextObjectLength).		inBufIndex := inBufIndex + 4 + self nextObjectLength.		inObjects addLast: (RWBinaryOrTextStream with: inObjectData) reset fileInObjectAndCode ].	self shrinkInBuf.! !!DocLibrary methodsFor: 'doc pane' stamp: 'mir 11/14/2002 19:37'!docObjectAt: classAndMethod	"Return a morphic object that is the documentation pane for this method.  nil if none can be found.  Look on both the network and the disk."	| fileNames server aUrl strm local obj |	methodVersions size = 0 ifTrue: [self updateMethodVersions].	"first time"	fileNames _ self docNamesAt: classAndMethod.	self assureCacheFolder.	"server _ (ServerDirectory serverInGroupNamed: group) clone."  "Note: directory ends with '/updates' which needs to be '/docpane', but altUrl end one level up"	server _ ServerDirectory serverInGroupNamed: group.		"later try multiple servers"	aUrl _ server altUrl, 'docpane/'.	fileNames do: [:aVersion | 		strm _ HTTPSocket httpGetNoError: aUrl,aVersion 			args: nil accept: 'application/octet-stream'.		strm class == RWBinaryOrTextStream ifTrue: [			self cache: strm as: aVersion.			strm reset.			obj _ strm fileInObjectAndCode asMorph.			(obj valueOfProperty: #classAndMethod) = classAndMethod ifFalse: [				self inform: 'suspicious object'.				obj setProperty: #classAndMethod toValue: classAndMethod].			^ obj].	"The pasteUpMorph itself"		"If file not there, error 404, just keep going"].	local _ ServerDirectory new fullPath: DocsCachePath.	"check that it is really there -- let user respecify"	fileNames do: [:aVersion | 		(local includesKey: aVersion) ifTrue: [			strm _ local readOnlyFileNamed: aVersion.			obj _ strm fileInObjectAndCode asMorph.			(obj valueOfProperty: #classAndMethod) = classAndMethod ifFalse: [				self inform: 'suspicious object'.				obj setProperty: #classAndMethod toValue: classAndMethod].			Transcript cr; show: 'local cache: ', aVersion.			^ obj].	"The pasteUpMorph itself"		"If file not there, just keep looking"].	"Never been documented"	^ nil! !!DocLibrary methodsFor: 'database of updates' stamp: 'mir 11/14/2002 19:38'!updateMethodVersions	"See if any new updates have occurred, and put their methods into the database."	| indexFile list result |	indexFile _ 'latest.ix'.	list _ OrderedCollection new.	[result _ self absorbAfter: lastUpdate from: indexFile.	"boolean if succeeded, or we are up to date, or server not available"	result class == String] whileTrue: [		"result is the prev file name"		list addFirst: indexFile.		indexFile _ result].	list do: [:aFile | self absorbAfter: lastUpdate from: aFile].		"should always work this time"! !!EToyPeerToPeer methodsFor: 'sending' stamp: 'mir 5/15/2003 18:29'!doConnectForSend	| addr |	addr _ NetNameResolver addressForName: ipAddress.	addr ifNil: [		communicatorMorph commResult: {#message -> ('could not find ',ipAddress)}.		^false	].	socket connectNonBlockingTo: addr port: self class eToyCommunicationsPort.	[socket waitForConnectionFor: 15]		on: ConnectionTimedOut		do: [:ex |			communicatorMorph commResult: {#message -> ('no connection to ',ipAddress,' (',				(NetNameResolver stringFromAddress: addr),')')}.			^false].	^true! !!EToyPeerToPeer methodsFor: 'receiving' stamp: 'mir 5/15/2003 15:40'!doReceiveOneMessage	| awaitingLength i length answer |	awaitingLength _ true.	answer _ WriteStream on: String new.	[awaitingLength] whileTrue: [		leftOverData _ leftOverData , socket receiveData.		(i _ leftOverData indexOf: $ ) > 0 ifTrue: [			awaitingLength _ false.			length _ (leftOverData first: i - 1) asNumber.			answer nextPutAll: (leftOverData allButFirst: i).		].	].	leftOverData _ ''.	[answer size < length] whileTrue: [		answer nextPutAll: socket receiveData.		communicatorMorph commResult: {#commFlash -> true}.	].	answer _ answer contents.	answer size > length ifTrue: [		leftOverData _ answer allButFirst: length.		answer _ answer first: length	].	^answer! !!HTTPClient class methodsFor: 'utilities' stamp: 'mir 5/13/2003 10:43'!getDirectoryListing: dirListURL	"HTTPClient getDirectoryListing: 'http://www.squeakalpha.org/uploads' "	| answer ftpEntries |"	answer _ self 		httpPostDocument: dirListURL		args: Dictionary new."	"Workaround for Mac IE problem"	answer _ self httpGetDocument: dirListURL.	answer isString		ifTrue: [^self error: 'Listing failed: ' , answer]		ifFalse: [answer _ answer content].	answer first == $<		ifTrue: [self error: 'Listing failed: ' , answer].	ftpEntries _ answer findTokens: String crlf.	^ ftpEntries 		collect:[:ftpEntry | ServerDirectory parseFTPEntry: ftpEntry]		thenSelect: [:entry | entry notNil]! !!HTTPClient class methodsFor: 'utilities' stamp: 'mir 5/13/2003 10:43'!tellAFriend: emailAddressOrNil url: urlForLoading name: projectName	| recipient subject body linkToInclude |	recipient _ emailAddressOrNil ifNil: ['RECIPIENT.GOESHERE'].	subject _ 'New/Updated Squeak project'.	body _ 'This is a link to the Squeak project ' , projectName , ': ' , String crlf.	linkToInclude _ urlForLoading.	HTTPClient shouldUsePluginAPI		ifTrue: [			self composeMailTo: recipient subject: subject body: body , (linkToInclude copyReplaceAll: '%' with: '%25')]		ifFalse: [Preferences allowCelesteTell			ifTrue: [FancyMailComposition new				celeste: nil 				to: recipient				subject: subject				initialText: body				theLinkToInclude: linkToInclude;				open]			ifFalse: [self inform: 'You need to run inside a web browser to use the tell function.']]! !!HTTPClient class methodsFor: 'private' stamp: 'mir 5/13/2003 10:43'!pluginHttpPostMultipart: url args: argsDict	| mimeBorder argsStream crLf fieldValue resultStream result |	" do multipart/form-data encoding rather than x-www-urlencoded "	crLf _ String crlf.	mimeBorder _ '----squeak-', Time millisecondClockValue printString, '-stuff-----'.	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, crLf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue _ value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', crLf, 'Content-Type: ', value contentType.				fieldValue _ (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: crLf, crLf, fieldValue, crLf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.	resultStream _ FileStream		post: 			('ACCEPT: text/html', crLf,			'User-Agent: Squeak 3.1', crLf,			'Content-type: multipart/form-data; boundary=', mimeBorder, crLf,			'Content-length: ', argsStream contents size printString, crLf, crLf, 			argsStream contents)		url: url ifError: [^'Error in post ' url toText].	"get the header of the reply"	result _ resultStream		ifNil: ['']		ifNotNil: [resultStream upToEnd].	^MIMEDocument content: result! !!HTTPLoader methodsFor: 'private' stamp: 'mir 5/12/2003 18:10'!startDownload	| newDownloadProcess |		downloads size >= self maxNrOfConnections ifTrue: [^self].	requests size <= 0 ifTrue: [^self].	newDownloadProcess _ [		[			self nextRequest startRetrieval		] on: FTPConnectionException do: [ :ex | 			Cursor normal show.			self removeProcess: Processor activeProcess.			self startDownload		].		self removeProcess: Processor activeProcess.		self startDownload	] newProcess.	downloads add: newDownloadProcess.	newDownloadProcess resume! !!IRCConnection methodsFor: 'network IO' stamp: 'mir 5/15/2003 15:37'!processIO	"do as much network IO as is immediately possible"		| amount idx messageText message |	"do nothing if the socket isn't ready for work"	(socket isNil or: [socket isValid not or: [ socket isConnected not ]]) ifTrue: [ 		"Transcript show: 'socket not ready; no IO done'; cr."		^self ].	"first do sending"	[ socket sendDone and: [ sendBuffer isNil not or: [ protocolMessagesToSend size > 0 ] ] ]	whileTrue: [		sendBuffer ifNil: [			protocolMessagesToSend isEmpty ifFalse: [				sendBuffer _ protocolMessagesToSend removeFirst asString ] ].		sendBuffer ifNotNil: [			amount _ socket sendSomeData: sendBuffer.			sendBuffer _ sendBuffer copyFrom: amount+1 to: sendBuffer size.			sendBuffer isEmpty ifTrue: [ sendBuffer _ nil ] ].	].	"now do receiving"	recieveBuffer _ recieveBuffer, socket receiveAvailableData.	"parse as many messages as possible"	[ idx _ recieveBuffer indexOf: Character lf.  	  idx > 0 ] whileTrue: [		messageText _ recieveBuffer copyFrom: 1 to: idx.		message _ IRCProtocolMessage fromString: messageText.				self processMessage: message.		recieveBuffer _ recieveBuffer copyFrom: idx+1 to: recieveBuffer size ].! !!MailComposition methodsFor: 'access' stamp: 'mir 5/12/2003 16:04'!submit	| message |	"submit the message"	textEditor		ifNotNil: [self hasUnacceptedEdits ifTrue: [textEditor accept]].	message := MailMessage from: messageText asString.	self breakLinesInMessage: message.	SMTPClient deliverMailFrom: message from to: (Array with: message to) text: message text usingServer: self smtpServer.	morphicWindow ifNotNil: [morphicWindow delete].	mvcWindow ifNotNil: [mvcWindow controller close]! !!FancyMailComposition methodsFor: 'actions' stamp: 'mir 5/13/2003 10:58'!submit: sendNow	| message |	messageText _ self breakLines: self completeTheMessage atWidth: 999.	message _ MailMessage from: messageText.	SMTPClient			deliverMailFrom: message from 			to: (Array with: message to) 			text: message text 			usingServer: self smtpServer.	self forgetIt.! !!NetworkTerminalMorph class methodsFor: 'instance creation' stamp: 'mir 5/15/2003 18:06'!socketConnectedTo: serverHost  port: serverPort	| sock |	Socket initializeNetwork.	sock _ Socket new.	[sock connectTo: (NetNameResolver addressForName: serverHost) port: serverPort]		on: ConnectionTimedOut		do: [:ex | self error: 'could not connect to server' ].	^StringSocket on: sock! !!OldSocket class methodsFor: 'network initialization' stamp: 'mir 11/14/2002 19:36'!initializeNetwork	"Initialize the network drivers and the NetNameResolver. Do nothing if the network is already initialized."	"Note: The network must be re-initialized every time Squeak starts up, so applications that persist across snapshots should be prepared to re-initialize the network as needed. Such applications should call 'Socket initializeNetwork' before every network transaction. "	NetNameResolver initializeNetwork! !!OldSocket class methodsFor: 'network initialization' stamp: 'mir 11/14/2002 19:36'!initializeNetworkIfFail: failBlock	"Initialize the network drivers. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails, perhaps because this computer isn't currently connected to a network."	NetNameResolver initializeNetwork! !!OldSimpleClientSocket class methodsFor: 'net news example' stamp: 'mir 5/13/2003 10:45'!nntpTest	"SimpleClientSocket nntpTest"	| addr s headers msgs header allNewsGroups |	addr _ NetNameResolver promptUserForHostAddress.	s _ OldSimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 119.  "119 is the NNTP port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s sendCommand: 'group comp.lang.smalltalk'.	Transcript show: s getResponse.	"get all the message headers for the current newsgroup"	s sendCommand: 'xover 1-1000000'.	headers _ s getMultilineResponseShowing: true.	"print the headers of the first 10 messages of comp.lang.smalltalk"	s sendCommand: 'listgroup comp.lang.smalltalk'.	msgs _ self parseIntegerList: s getMultilineResponse.	msgs ifNotNil: [		1 to: 5 do: [:i |			s sendCommand: 'head ', (msgs at: i) printString.			header _ s getMultilineResponse.			Transcript show: (self extractDateFromAndSubjectFromHeader: header); cr]].	"get a full list of usenet newsgroups"	s sendCommand: 'newgroups 010101 000000'.	allNewsGroups _ s getMultilineResponse.	Transcript show: allNewsGroups size printString, ' bytes in full newsgroup list'; cr.	Transcript show: 'Sending quit...'; cr.	s sendCommand: 'QUIT'.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	(headers ~~ nil and:	 [self confirm: 'show article headers from comp.lang.smalltalk?'])		ifTrue: [			(StringHolder new contents: (self parseHeaderList: headers))				openLabel: 'Newsgroup Headers'].	(allNewsGroups ~~ nil and:	 [self confirm: 'show list of all newsgroups available on your server?'])		ifTrue: [			(StringHolder new contents: allNewsGroups)				openLabel: 'All Usenet Newsgroups'].! !!OldSimpleClientSocket class methodsFor: 'POP mail example' stamp: 'mir 5/13/2003 10:45'!popTest	"SimpleClientSocket popTest"	| addr userName userPassword s msgs header |	addr _ NetNameResolver promptUserForHostAddress.	userName _ FillInTheBlank		request: 'What is your email name?'		initialAnswer: 'johnm'.	userPassword _ FillInTheBlank		request: 'What is your email password?'.	s _ OldSimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 110.  "110 is the POP3 port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s sendCommand: 'USER ', userName.	Transcript show: s getResponse.	s sendCommand: 'PASS ', userPassword.	Transcript show: s getResponse.	s sendCommand: 'LIST'.	"the following should be tweaked to handle an empy mailbox:"	msgs _ self parseIntegerList: s getMultilineResponse.	1 to: (msgs size min: 5) do: [ :i |		s sendCommand: 'TOP ', (msgs at: i) printString, ' 0'.		header _ s getMultilineResponse.		Transcript show: (self extractDateFromAndSubjectFromHeader: header); cr].	msgs size > 0 ifTrue: [		"get the first message"		s sendCommand: 'RETR 1'.		Transcript show: s getMultilineResponse].	Transcript show: 'closing connection'; cr.	s sendCommand: 'QUIT'.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!OldSimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'mir 5/13/2003 10:45'!forkingRemoteCursorSender	"This is the client side of a test that sends samples of the local input sensor state to the server, which may be running on a local or remote host. This method opens the connection, then forks a process to send the cursor data. Data is sent continuously until the user clicks in a 20x20 pixel square at the top-left corner of the display. The server should be started first. Note the server's address, since this method will prompt you for it."	"SimpleClientSocket forkingRemoteCursorSender"	| sock addr stopRect |	Transcript show: 'starting remote cursor sender'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	addr _ NetNameResolver promptUserForHostAddress.	Transcript show: 'opening connection'; cr.	sock _ OldSimpleClientSocket new.	sock connectTo: addr port: 54323.	sock waitForConnectionUntil: self standardDeadline.	(sock isConnected) ifFalse: [self error: 'sock not connected'].	Transcript show: 'connection established'; cr.	stopRect _ 0@0 corner: 20@20.  "click in this rectangle to stop sending"	Display reverse: stopRect.	["the sending process"		[(stopRect containsPoint: Sensor cursorPoint) and:		 [Sensor anyButtonPressed]]			whileFalse: [				sock sendCommand: self sensorStateString.				(Delay forMilliseconds: 20) wait].		sock waitForSendDoneUntil: self standardDeadline.		sock destroy.		Transcript show: 'remote cursor sender done'; cr.		Display reverse: stopRect.	] fork.! !!OldSimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'mir 5/13/2003 10:45'!remoteCursorReceiver	"Wait for a connection, then display data sent by the client until the client closes the stream. This server process is usually started first (optionally in a forked process), then the sender process is started (optionally on another machine). Note this machine's address, which is printed in the transcript, since the sender process will ask for it."	"[SimpleClientSocket remoteCursorReceiver] fork"	| sock response |	Transcript show: 'starting remote cursor receiver'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	Transcript show: 'my address is ', NetNameResolver localAddressString; cr.	Transcript show: 'opening connection'; cr.	sock _ OldSimpleClientSocket new.	sock listenOn: 54323.	sock waitForConnectionUntil: (Socket deadlineSecs: 60).	sock isConnected		ifFalse: [			 sock destroy.			Transcript show: 'remote cursor receiver did not receive a connection in 60 seconds; aborting.'.			^ self].	Transcript show: 'connection established'; cr.	[sock isConnected]		whileTrue: [			sock dataAvailable				ifTrue: [					response _ sock getResponse.					response displayOn: Display at: 10@10]				ifFalse: [					"if no data available, let other processes run for a while"					(Delay forMilliseconds: 20) wait]].	sock destroy.	Transcript show: 'remote cursor receiver done'; cr.! !!OldSimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'mir 5/13/2003 10:45'!remoteCursorTest	"This version of the remote cursor test runs both the client and the server code in the same loop."	"SimpleClientSocket remoteCursorTest"	| sock1 sock2 samplesToSend samplesSent done t |	Transcript show: 'starting remote cursor test'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	Transcript show: 'opening connection'; cr.	sock1 _ OldSimpleClientSocket new.	sock2 _ OldSimpleClientSocket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	samplesToSend _ 100.	t _ Time millisecondsToRun: [		samplesSent _ 0.		done _ false.		[done]			whileFalse: [				(sock1 sendDone and: [samplesSent < samplesToSend]) ifTrue: [					sock1 sendCommand: self sensorStateString.					samplesSent _ samplesSent + 1].				sock2 dataAvailable ifTrue: [					sock2 getResponse displayOn: Display at: 10@10].				done _ samplesSent = samplesToSend]].	sock1 destroy.	sock2 destroy.	Transcript show: 'remote cursor test done'; cr.	Transcript show:		samplesSent printString, ' samples sent in ',		t printString, ' milliseconds'; cr.	Transcript show: ((samplesSent * 1000) // t) printString, ' samples/sec'; cr.! !!OldSimpleClientSocket class methodsFor: 'other examples' stamp: 'mir 5/13/2003 10:45'!finger: userName	"OldSimpleClientSocket finger: 'stp'"	| addr s |	addr _ NetNameResolver promptUserForHostAddress.	s _ OldSimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 79.  "finger port number"	s waitForConnectionUntil: self standardDeadline.	s sendCommand: userName.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!OldSimpleClientSocket class methodsFor: 'other examples' stamp: 'mir 5/13/2003 10:45'!httpTestHost: hostName port: port url: url	"This test fetches a URL from the given host and port."	"SimpleClientSocket httpTestHost: 'www.disney.com' port: 80 url: '/'"	"Tests URL fetch through a local HTTP proxie server:		(SimpleClientSocket			httpTestHost: '127.0.0.1'			port: 8080			url: 'HTTP://www.exploratorium.edu/index.html')"	| hostAddr s result buf bytes totalBytes t |	Transcript cr; show: 'starting http test'; cr.	Socket initializeNetwork.	hostAddr _ NetNameResolver addressForName: hostName timeout: 10.	hostAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', hostName].	s _ OldSimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: hostAddr port: port.	s waitForConnectionUntil: "self standardDeadline" (Socket deadlineSecs: 10).	(s isConnected) ifFalse: [		s destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection open; waiting for data'; cr.	s sendCommand: 'GET ', url, ' HTTP/1.0'.	s sendCommand: 'User-Agent: Squeak 1.19'.	s sendCommand: 'ACCEPT: text/html'.	"always accept plain text"	s sendCommand: 'ACCEPT: application/octet-stream'.  "also accept binary data"	s sendCommand: ''.  "blank line"	result _ WriteStream on: (String new: 10000).	buf _ String new: 10000.	totalBytes _ 0.	t _ Time millisecondsToRun: [		[s isConnected] whileTrue: [			s waitForDataUntil: (Socket deadlineSecs: 5).			bytes _ s receiveDataInto: buf.			1 to: bytes do: [:i | result nextPut: (buf at: i)].			totalBytes _ totalBytes + bytes.			Transcript show: totalBytes printString, ' bytes received'; cr]].	s destroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	Transcript show: 'http test done; ', totalBytes printString, ' bytes read in '.	Transcript show: ((t / 1000.0) roundTo: 0.01) printString, ' seconds'; cr.	Transcript show: ((totalBytes asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.	(StringHolder new contents: (result contents))		openLabel: 'HTTP Test Result: URL Contents'.! !!OldSimpleClientSocket class methodsFor: 'other examples' stamp: 'mir 5/13/2003 10:45'!timeTest	"SimpleClientSocket timeTest"	| addr s |	addr _ NetNameResolver promptUserForHostAddress.	s _ OldSimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 13.  "time port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'mir 11/14/2002 17:37'!connectRemoteUserWithName: nameStringOrNil picture: aFormOrNil andIPAddress: aStringOrNil	"Prompt for the initials to be used to identify the cursor of a remote user, then create a cursor for that user and wait for a connection."	| initials addr h |	initials _ nameStringOrNil.	initials isEmptyOrNil ifTrue: [		initials _ FillInTheBlank request: 'Enter initials for remote user''s cursor?'.	].	initials isEmpty ifTrue: [^ self].  "abort"	addr _ 0.	aStringOrNil isEmptyOrNil ifFalse: [		addr _ NetNameResolver addressForName: aStringOrNil timeout: 30	].	addr = 0 ifTrue: [		addr _ NetNameResolver promptUserForHostAddress.	].	addr = 0 ifTrue: [^ self].  "abort"	RemoteHandMorph ensureNetworkConnected.	h _ RemoteHandMorph new userInitials: initials andPicture: aFormOrNil.	self addHand: h.	h changed.	h startListening.	h startTransmittingEventsTo: addr.! !!PositionableStream methodsFor: 'positioning' stamp: 'mir 5/14/2003 18:45'!pushBack: aString	"Compatibility with SocketStreams"	self skip: aString size negated! !!FileStream class methodsFor: 'browser requests' stamp: 'mir 5/13/2003 10:43'!httpPostMultipart: url args: argsDict	| mimeBorder argsStream crLf fieldValue resultStream result |	" do multipart/form-data encoding rather than x-www-urlencoded "	crLf _ String crlf.	mimeBorder _ '----squeak-', Time millisecondClockValue printString, '-stuff-----'.	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, crLf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue _ value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', crLf, 'Content-Type: ', value contentType.				fieldValue _ (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: crLf, crLf, fieldValue, crLf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.	resultStream _ self		post: 			('Content-type: multipart/form-data; boundary=', mimeBorder, crLf,			'Content-length: ', argsStream contents size printString, crLf, crLf, 			argsStream contents)		url: url ifError: [^'Error in post ' url toText].	"get the header of the reply"	result _ resultStream upToEnd.	^MIMEDocument content: result! !!RemoteHandMorph methodsFor: 'connections' stamp: 'mir 5/13/2003 10:44'!startTransmittingEvents	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket _ OldSimpleClientSocket new.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState _ #opening.	owner primaryHand addEventListener: self.! !!RemoteHandMorph methodsFor: 'connections' stamp: 'mir 5/13/2003 10:45'!startTransmittingEventsTo: remoteAddr	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	remoteAddress _ remoteAddr.	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket _ OldSimpleClientSocket new.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState _ #opening.	owner primaryHand addEventListener: self.! !!RemoteHandMorph class methodsFor: 'utilities' stamp: 'mir 11/14/2002 17:37'!ensureNetworkConnected	"Try to ensure that an intermittent network connection, such as a dialup or ISDN line, is actually connected. This is necessary to make sure a server is visible in order to accept an incoming connection."	"RemoteHandMorph ensureNetworkConnected"	Utilities		informUser: 'Contacting domain name server...'		during: [			NetNameResolver				addressForName: 'squeak.org'				timeout: 30].! !!ServerDirectory methodsFor: 'file directory' stamp: 'mir 5/13/2003 10:44'!entries 	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name> <creationTime> <modificationTime> <dirFlag> <fileSize>)."	| dir ftpEntries |	"We start with ftp directory entries of the form...d---------   1 owner    group               0 Apr 27 22:01 blasttest----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM    1        2   3           4                 5    6  7    8       9   -- token index"	self isTypeFile ifTrue: [		urlObject isAbsolute ifFalse: [urlObject default].		^ (FileDirectory on: urlObject pathForDirectory) entries	].	dir _ self getDirectory.	(dir respondsTo: #contentsOfEntireFile) ifFalse: [^ #()].	ftpEntries _ dir contentsOfEntireFile findTokens: String crlf."ftpEntries inspect."	^ ftpEntries 		collect:[:ftpEntry | self class parseFTPEntry: ftpEntry]		thenSelect: [:entry | entry notNil]! !!StringSocket methodsFor: 'private-IO' stamp: 'mir 5/15/2003 15:39'!processInput	| totalReceived chunkOfData |	"do as much input as possible"	self flag: #XXX.  "should have resource limits here--no more than X objects and Y bytes"	chunkOfData _ socket receiveAvailableData.	self addToInBuf: chunkOfData.	totalReceived _ chunkOfData size.	totalReceived > 0 ifTrue: [		NebraskaDebug at: #SendReceiveStats add: {'GET'. totalReceived}.	].	[ self gotSomething ] whileTrue: [].		"decode as many string arrays as possible"	self shrinkInBuf.! !!TelnetMachine methodsFor: 'IO' stamp: 'mir 5/15/2003 18:13'!connect	"connect to the name host"	| addr |	self isConnected ifTrue: [ self disconnect ].	Socket initializeNetwork.	addr _ NetNameResolver addressForName: hostname.	addr ifNil: [ self error: 'could not find address for ', hostname ].	socket _ Socket new.		[socket connectTo: addr port: port]		on: ConnectionTimedOut		do: [:ex | self error: 'connection failed' ].		requestedRemoteEcho _ true.	self do: OPTEcho.! !!TelnetMachine methodsFor: 'IO' stamp: 'mir 5/15/2003 15:39'!processIO	"should be called periodically--this actually sends and recieves some bytes over the network"	| amountSent |	self isConnected ifFalse: [ ^ self ].	outputBuffer _ outputBuffer contents.	"convert to String for convenience in the loop.  still not as optimal as it could be...."	[outputBuffer size > 0 and: [ socket sendDone ]] whileTrue: [ 		"do some output"		amountSent _ socket sendSomeData: outputBuffer.		outputBuffer _ outputBuffer copyFrom: amountSent+1 to: outputBuffer size. ].	outputBuffer _ WriteStream on: outputBuffer.	"do some input"	self processInput: socket receiveAvailableData.! !DocLibrary removeSelector: #haveNetwork!!ServerDirectory methodsFor: 'up/download' stamp: 'mir 11/19/2002 17:49'!getDirectory	"Return a stream with a listing of the current server directory.  (Later -- Use a proxy server if one has been registered.)"	| client listing |	client := self openFTPClient.	[listing := client getDirectory]		ensure: [client ifNotNil: [client quit]].	^ReadStream on: listing! !!ServerDirectory methodsFor: 'up/download' stamp: 'mir 11/19/2002 17:49'!getFileList	"Return a stream with a list of files in the current server directory.  (Later -- Use a proxy server if one has been registered.)"	| client listing |	client := self openFTPClient.	[listing := client getFileList]		ensure: [client ifNotNil: [client quit]].	^ReadStream on: listing! !!ServerDirectory methodsFor: 'up/download' stamp: 'mir 11/19/2002 17:54'!getFileNamed: fileNameOnServer	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| client result |	client := self openFTPClient.	[result := client getFileNamed: fileNameOnServer]		ensure: [client ifNotNil: [client quit]].	^result! !!ServerDirectory methodsFor: 'up/download' stamp: 'mir 11/19/2002 17:50'!getFileNamed: fileNameOnServer into: dataStream httpRequest: requestString	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| resp client |	self isTypeFile ifTrue: [		dataStream nextPutAll: 			(resp _ FileStream oldFileNamed: server,(self serverDelimiter asString), 				self bareDirectory, (self serverDelimiter asString),				fileNameOnServer) contentsOfEntireFile.		dataStream dataIsValid.		^ resp].	self isTypeHTTP ifTrue: [		resp _ HTTPSocket httpGet: (self fullNameFor: fileNameOnServer) 				args: nil accept: 'application/octet-stream' request: requestString.		resp class == String ifTrue: [^ dataStream].	"error, no data"		dataStream copyFrom: resp.		dataStream dataIsValid.		^ dataStream].	client _ self openFTPClient.	"Open passive.  Do everything up to RETR or STOR"	[client getFileNamed: fileNameOnServer into: dataStream]		ensure: [client ifNotNil: [client quit]].	dataStream dataIsValid.! !!ServerDirectory methodsFor: 'up/download' stamp: 'mir 11/19/2002 17:50'!getOnlyBuffer: buffer from: fileNameOnServer	"Open ftp, fill the buffer, and close the connection.  Only first part of a very long file."	| client dataStream |	client := self openFTPClient.	dataStream := WriteStream on: buffer.	[client getPartial: buffer size fileNamed: fileNameOnServer into: dataStream]		ensure: [client ifNotNil: [client quit]].	^buffer! !!ServerDirectory methodsFor: 'up/download' stamp: 'mir 11/19/2002 17:50'!putFile: fileStream named: fileNameOnServer	"Just FTP a local fileStream to the server.  (Later -- Use a proxy server if one has been registered.)"	| client |	client := self openFTPClient.	client isNil ifTrue: [^ self].	[client putFileStreamContents: fileStream as: fileNameOnServer]		ensure: [client quit]! !!ServerDirectory methodsFor: 'dis/connect' stamp: 'mir 11/19/2002 18:48'!openFTPClient	| client loginSuccessful what |	client _ FTPClient openOnHostNamed: server.	loginSuccessful := false.	[loginSuccessful]		whileFalse: [			[loginSuccessful := true.			client loginUser: self user password: self password]				on: LoginFailedException				do: [:ex | 					passwordHolder _ nil.					what _ (PopUpMenu labels: 'enter password\give up' withCRs) 						startUpWithCaption: 'Would you like to try another password?'.					what = 1 ifFalse: [self error: 'Login failed.'. ^nil].					loginSuccessful := false]].	client changeDirectoryTo: directory.	^client! !!ServerDirectory methodsFor: 'dis/connect' stamp: 'mir 11/19/2002 17:50'!quit	"break the connection"	"None to break"! !!ServerDirectory methodsFor: 'file directory' stamp: 'mir 11/19/2002 17:54'!createDirectory: localName	"Create a new sub directory within the current one"	| client |	self isTypeFile ifTrue: [		^FileDirectory createDirectory: localName	].	client := self openFTPClient.	[client makeDirectory: localName]		ensure: [client ifNotNil: [client quit]].! !!ServerDirectory methodsFor: 'file directory' stamp: 'mir 11/19/2002 17:54'!deleteDirectory: localName	"Delete the sub directory within the current one.  Call needs to ask user to confirm."	| client |	self isTypeFile ifTrue: [		^FileDirectory deleteFileNamed: localName	].		"Is this the right command???"	client := self openFTPClient.	[client deleteDirectory: localName]		ensure: [client ifNotNil: [client quit]].! !!ServerDirectory methodsFor: 'file directory' stamp: 'mir 11/19/2002 17:54'!deleteFileNamed: fullName	"Detete a remote file.  fullName is directory path, and does include name of the server.  Or it can just be a fileName."	| file client |	file _ self asServerFileNamed: fullName.	file isTypeFile ifTrue: [		^ (FileDirectory forFileName: (file fileNameRelativeTo: self)) 			deleteFileNamed: file fileName	].		client := self openFTPClient.	[client deleteFileNamed: fullName]		ensure: [client ifNotNil: [client quit]].! !!ServerDirectory methodsFor: 'file directory' stamp: 'mir 11/19/2002 17:53'!exists	"It is difficult to tell if a directory exists.  This is ugly, but it works for writable directories.  http: will fall back on ftp for this"	| probe success client |	success _ false.	self isTypeFile ifTrue: [		self entries size > 0 ifTrue: [^ true].		probe _ self newFileNamed: 'withNoName23'. 		probe ifNotNil: [			probe close.			probe directory deleteFileNamed: probe localName].		^success _ probe notNil].	[client := self openFTPClient.	[client pwd]		ensure: [client ifNotNil: [client quit]].		success := true]		on: Error		do: [:ex | ].	^success! !!ServerDirectory methodsFor: 'file directory' stamp: 'mir 11/19/2002 17:54'!rename: fullName toBe: newName	"Rename a remote file.  fullName is just be a fileName, or can be directory path that includes name of the server.  newName is just a fileName"	| file client |	file _ self asServerFileNamed: fullName.	file isTypeFile ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			rename: file fileName toBe: newName	].		client := self openFTPClient.	[client renameFileNamed: fullName to: newName]		ensure: [client ifNotNil: [client quit]].	! !!ServerDirectory methodsFor: 'multi-action sessions' stamp: 'mir 11/19/2002 17:51'!reset	! !!ServerDirectory methodsFor: 'multi-action sessions' stamp: 'mir 11/19/2002 17:50'!wakeUp	"Start a multi-action session: Open for FTP and keep the connection open"	"Ignore for now"! !ServerDirectory removeSelector: #changeWorkingDirectory:!ServerDirectory removeSelector: #directoryNamed:usingSameSession:!ServerDirectory removeSelector: #ensureCorrectWorkingDirectory!ServerDirectory removeSelector: #openFTP!ServerDirectory removeSelector: #openNoDataFTP!ServerDirectory removeSelector: #useSocket:!Smalltalk removeClassNamed: #FTPSocket!Smalltalk removeClassNamed: #InternetConfiguration!Smalltalk removeClassNamed: #POPSocket!Smalltalk removeClassNamed: #SMTPSocket!"Postscript:"(SystemNavigation new allCallsOn: (Smalltalk associationAt: #OldSocket))	do: [:each | each actualClass recompile: each methodSymbol].Socket deadServer: ''.!