Object subclass: #HtmlToken	instanceVariableNames: 'source '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Tokenizer'!!HtmlToken methodsFor: 'parser support' stamp: 'ls 6/25/1998 02:37'!entityFor	^self subclassResponsibility! !!HtmlToken methodsFor: 'formatting' stamp: 'ls 6/24/1998 17:29'!addToFormatter: aFormatter	"add ourself to a formatter"! !!HtmlToken methodsFor: 'printing' stamp: 'ls 1/25/98 05:45'!printOn: aStream	aStream nextPutAll: '{';		nextPutAll: self class name;		nextPut: $:;		nextPutAll: self source;		nextPut: $}.! !!HtmlToken methodsFor: 'private-initialization' stamp: 'ls 1/25/98 05:34'!initialize: s	"default initialization doesn't do much.  subclasses are free to override"	source _ s! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:47'!isComment	"whether this token is an HTML comment"	^false! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:38'!isTag	"is this an HTML tag"	^false! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:39'!isText	"return whether it is a string of text"	^false! !!HtmlToken methodsFor: 'access' stamp: 'ls 1/25/98 04:48'!source	"the raw source text that composes this token"	^source! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HtmlToken class	instanceVariableNames: ''!!HtmlToken class methodsFor: 'instance creation' stamp: 'ls 1/25/98 06:01'!forSource: source  	^super new initialize: source! !HtmlToken subclass: #HtmlComment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Tokenizer'!!HtmlComment commentStamp: 'ls 9/8/1998 21:39' prior: 0!A comment, eg <!!-- this is a comment -->Normally this is ignored, but it's included so that every byte in theinput gets put into one tag or another.!!HtmlComment methodsFor: 'parser support' stamp: 'ls 6/25/1998 02:37'!entityFor	^self shouldNotImplement! !!HtmlComment methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isComment	^true! !!HtmlComment methodsFor: 'access' stamp: 'ls 1/25/98 04:56'!text	"return the text of the comment, the part inside the <!!-- and -->"	^self notYetImplemented! !HtmlToken subclass: #HtmlTag	instanceVariableNames: 'isNegated name attribs '	classVariableNames: 'EntityClasses '	poolDictionaries: ''	category: 'HTML-Tokenizer'!!HtmlTag commentStamp: 'ls 9/8/1998 21:39' prior: 0!An HTML tag, eg <a href="foo.html">!!HtmlTag methodsFor: 'parser support' stamp: 'ls 6/27/1998 13:18'!entityFor	"return an empty entity corresponding to this tag"	| eClass |	eClass _ self class entityClasses at: name ifAbsent: [ ^nil ].	^eClass forTag: self ! !!HtmlTag methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isTag	^true! !!HtmlTag methodsFor: 'access' stamp: 'ls 1/25/98 04:50'!attribs	"return a dictionary mapping attribute names (in lowercase) to their values"	^attribs! !!HtmlTag methodsFor: 'access' stamp: 'ls 6/24/1998 18:53'!isNegated	^isNegated! !!HtmlTag methodsFor: 'access' stamp: 'ls 1/25/98 04:49'!name	"return the basic kind of tag, in lowercase"	^name! !!HtmlTag methodsFor: 'private-initialization' stamp: 'ls 7/14/1998 22:49'!name: name0  negated: isNegated0 attribs: attribs0	"initialize from the given attributes"	name _ name0.	isNegated _ isNegated0.	attribs _ attribs0 ifNil: (Dictionary new).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HtmlTag class	instanceVariableNames: ''!!HtmlTag class methodsFor: 'parser support' stamp: 'ls 7/29/1998 00:38'!entityClasses	"a Dictionary mapping tag names into the correct entity class"	"EntityClasses _ nil"	EntityClasses isNil ifFalse: [ ^EntityClasses ].	EntityClasses _ Dictionary new.	#( 		frameset	HtmlFrame		frame	HtmlFrame		title		HtmlTitle		style	HtmlStyle		meta	HtmlMeta		p		HtmlParagraph		form	HtmlForm		blockquote	HtmlBlockQuote		input	HtmlInput		textarea	HtmlTextArea		select	HtmlSelect		optgroup	HtmlOptionGroup		option		HtmlOption		img		HtmlImage		a		HtmlAnchor		br		HtmlBreak		li		HtmlListItem		dd		HtmlDefinitionDefinition		dt		HtmlDefinitionTerm		ol		HtmlOrderedList		ul		HtmlUnorderedList		dl		HtmlDefinitionList		h1		HtmlHeader		h2		HtmlHeader		h3		HtmlHeader		h4		HtmlHeader		h5		HtmlHeader		h6		HtmlHeader		hr		HtmlHorizontalRule		strong	HtmlBoldEntity		b		HtmlBoldEntity		em		HtmlItalicsEntity		i		HtmlItalicsEntity		dfn 	HtmlItalicsEntity		u		HtmlUnderlineEntity 		tt		HtmlFixedWidthEntity		kbd		HtmlFixedWidthEntity				strike	HtmlStrikeEntity		big		HtmlBiggerFontEntity		small	HtmlSmallerFontEntity		sub		HtmlSubscript		sup		HtmlSuperscript		font	HtmlFontEntity		pre		HtmlPreformattedRegion 		table	HtmlTable		tr		HtmlTableRow		td		HtmlTableDataItem 		) pairsDo: [ 			:tagName :className |			EntityClasses at: tagName asString put: (Smalltalk at: className) ].	^EntityClasses ! !!HtmlTag class methodsFor: 'parser support' stamp: 'ls 7/14/1998 22:56'!initialize	EntityClasses _ nil.! !!HtmlTag class methodsFor: 'instance creation' stamp: 'ls 6/24/1998 18:54'!source: source0  name: name0  negated: negated0 attribs: attribs0	^(super forSource: source0) name: name0 negated: negated0 attribs: attribs0! !HtmlTag initialize!HtmlToken subclass: #HtmlText	instanceVariableNames: 'text '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Tokenizer'!!HtmlText commentStamp: 'ls 9/8/1998 21:39' prior: 0!A sequence of text without any tags in it.  &sp; style characters have been replaced by their actual values. !!HtmlText methodsFor: 'formatter' stamp: 'ls 6/24/1998 17:29'!addToFormatter: aFormatter	"add ourself to a formatter"	aFormatter addText: source! !!HtmlText methodsFor: 'access' stamp: 'ls 1/25/98 04:57'!text	^text! !!HtmlText methodsFor: 'private-initialization' stamp: 'ls 8/25/1998 05:47'!initialize: source0	super initialize: source0.	self text: source0 replaceHtmlCharRefs.! !!HtmlText methodsFor: 'private-initialization' stamp: 'ls 7/21/1998 01:02'!text: text0	text _ text0.! !!HtmlText methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isText	^true! !Stream subclass: #HtmlTokenizer	instanceVariableNames: 'inputStream text pos '	classVariableNames: 'CSAttributeEnders CSNameEnders CSNonSeparators '	poolDictionaries: ''	category: 'HTML-Tokenizer'!!HtmlTokenizer commentStamp: 'ls 9/8/1998 21:39' prior: 0!This class takes a text stream and produces a sequence of HTML tokens.It requires its source stream to support #peek.!!HtmlTokenizer methodsFor: 'private-initialization' stamp: 'ls 8/25/1998 05:47'!initialize: s	text _ s withSqueakLineEndings.	pos _ 1.! !!HtmlTokenizer methodsFor: 'tokenizing' stamp: 'ls 8/20/1998 05:17'!next 	"return the next HtmlToken, or nil if there are no more"	"branch, depending on what the first character is"	self atEnd ifTrue: [ ^nil ].	self peekChar = $< ifTrue: [ ^self nextTagOrComment ].	^self nextText.! !!HtmlTokenizer methodsFor: 'stream protocol' stamp: 'ls 8/20/1998 05:15'!atEnd	"are there any more tokens?  This is equivalent to whether there is any more input"	^(pos > text size)! !!HtmlTokenizer methodsFor: 'private' stamp: 'ls 8/20/1998 05:14'!nextChar	| c |	self atEnd ifTrue: [ ^nil ].	c _ text at: pos.	pos _ pos + 1.	^c! !!HtmlTokenizer methodsFor: 'private' stamp: 'ls 8/20/1998 05:14'!peekChar	self atEnd ifTrue: [ ^nil ].	^text at: pos! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:33'!nextAttributeValue	"return the next sequence of alphanumeric characters; used to read in the value part of a tag's attribute, ie <tagname  attribname=attribvalue>"	"because of the plethora of sloppy web pages, this is EXTREMELY tolerant"	| c start end |	"make sure there are at least two characters left"	pos >= text size ifTrue: [ ^self nextChar asString ].	"okay, peek at the first character"	start _ pos.	c _ text at: start.	"check whether it's either kind of quote mark"	(c = $" or: [ c = $' ]) ifTrue: [		"yes--so find the matching quote mark"		end _ text indexOf: c startingAt: start+1 ifAbsent: [ text size + 1 ].		pos _ end+1.		^text copyFrom: start to: end ].	"no--go until a space or a $> is seen"	end _ text indexOfAnyOf: CSAttributeEnders startingAt: start ifAbsent: [ text size + 1 ].	end _ end - 1.	pos _ end + 1.	^text copyFrom: start to: end.! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:31'!nextComment	"we've seen < and the next is a !!.  read until the whole comment is done"	"this isn't perfectly correct--for instance <!!--> is considered a proper comment--but it should do for now.  It also picks up <!!DOCTYPE...> tags"	| source c hyphens |		self nextChar.   "swallow the $!!"	source _ WriteStream on: String new.	source nextPutAll: '<!!'.		self peekChar = $- ifFalse: [ 		"this case is wierd.  go until we find a > at all and pray it's the correct end-of-'comment'"		[	self atEnd or: [ self peekChar = $> ] 		] whileFalse: [			c _ self nextChar.			source nextPut: c 		].		self atEnd ifFalse: [ source nextPut: self nextChar ].		^HtmlComment forSource: source contents ].		hyphens _ 0.	[ 	c _ self nextChar.		c = nil or: [			source nextPut: c.			(hyphens >=2 and: [ c = $> ])]	] whileFalse: [		c = $- ifTrue: [ hyphens _ hyphens + 1 ] ifFalse: [ hyphens _ 0 ]	].			^HtmlComment forSource: source contents.! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:24'!nextName	"return the next sequence of alphanumeric characters"	"because of the plethora of sloppy web pages, this also accepts most non-space characters"	| start end |	start _ pos.	end _ text indexOfAnyOf: CSNameEnders startingAt: start ifAbsent: [ text size + 1].	end _ end - 1.	pos _ end+1.	^text copyFrom: start to: end! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:23'!nextSpaces	"read in as many consecutive space characters as possible"	| start end |	"short cut for a common case"	self peekChar isSeparator not ifTrue: [ ^'' ].	"find the start and end of the sequence of spaces"	start _ pos.	end _ text indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [ text size + 1 ].	end _ end - 1.	"update pos and return the sequence"	pos _ end + 1.	^text copyFrom: start to: end! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/25/1998 05:43'!nextTag	"we've seen a < and peek-ed something other than a !!.  Parse and return a tag"	| source negated name attribs attribName attribValue sourceStart sourceEnd c |		sourceStart _ pos-1.	attribs _ Dictionary new.	"determine if its negated"	self peekChar = $/ 		ifTrue: [ negated _ true.  self nextChar. ]		ifFalse: [ negated _ false ].	"read in the name"	self skipSpaces.	name _ self nextName.	name _ name asLowercase.	"read in any attributes"	[ 	self skipSpaces.		c _ self peekChar.		c = nil or: [c isLetter not ]	] whileFalse: [		attribName _ self nextName.		attribName _ attribName asLowercase.		self skipSpaces.		self peekChar = $= 			ifTrue: [ 				self nextChar.				self skipSpaces.				attribValue _ self nextAttributeValue withoutQuoting  ]			ifFalse: [ attribValue _ '' ].		attribs at: attribName  put: attribValue ].	self peekChar = $> ifTrue: [ self nextChar ].	sourceEnd _ pos-1.	source _ text copyFrom: sourceStart to: sourceEnd.	^HtmlTag source: source name: name asLowercase negated: negated attribs: attribs! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:31'!nextTagOrComment	"next character is a $<.  So read either a tag or a token"	self nextChar.  "skip the $<"	^self peekChar = $!! 		ifTrue: [ self nextComment ]		ifFalse: [ self nextTag ]! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:34'!nextText	"returns the next textual segment"	|start end|	start _ pos.	end _ (text indexOf: $< startingAt: start ifAbsent: [ text size + 1 ]) - 1.	pos _ end+1.	^HtmlText forSource: (text copyFrom: start to: end)! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/25/1998 05:26'!skipSpaces	"skip as many consecutive space characters as possible"	pos _ text indexOfAnyOf: CSNonSeparators startingAt: pos ifAbsent: [ text size + 1 ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HtmlTokenizer class	instanceVariableNames: ''!!HtmlTokenizer class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 05:13'!on: aStream	^super basicNew initialize: aStream contents! !!HtmlTokenizer class methodsFor: 'initialization' stamp: 'ls 8/19/1998 09:09'!initialize	"HtmlTokenizer initialize"	CSAttributeEnders _ CharacterSet empty.	CSAttributeEnders addAll: Character separators.	CSAttributeEnders add: $>.		CSNameEnders _ CharacterSet empty.	CSNameEnders addAll: '=>'.	CSNameEnders addAll: Character separators.	CSNonSeparators _ CharacterSet separators complement.! !HtmlTokenizer initialize!