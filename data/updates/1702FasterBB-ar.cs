'From Squeak2.7alpha of 6 December 1999 [latest update: #1698] on 7 December 1999 at 9:56:25 pm'!"Change Set:		FasterBB-arDate:			7 December 1999Author:			Andreas RaabThe change set speeds up BitBlt and WarpBlt in several different areas (funny: on Win32 there is only a minor speedup in BitBlt but a major one in WarpBlt - on the Mac it seems more evenly distributed).The change set contains also a number of other stuff such as:* Some preparations for the inclusion of OS surfaces (disabled for the time being)* A cleanup of BitBltSimulation so that the primitive index is no longer needed (enabling the build of BB as a plugin)* Providing simulated versions for BitBlt and WarpBlt (see BitBlt>>copyBitsSimulated and WarpBlt>>warpBitsSimulated) allowing for easier experimenting from within the image* Provides a simple facility for measuring speed improvements of BitBlt (see BitBlt class>>benchmark)"!Object subclass: #BitBltSimulation	instanceVariableNames: 'destForm sourceForm halftoneForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight sourceBits sourcePitch sourcePixSize destBits destPitch destPixSize pixPerWord bitCount skew mask1 mask2 preload nWords destMask hDir vDir sourceIndex sourceDelta destIndex destDelta sx sy dx dy bbW bbH srcWidth srcHeight destWidth destHeight halftoneHeight noSource noHalftone halftoneBase colorMap sourceAlpha cmBitsPerColor srcBitShift dstBitShift scanStart scanStop scanString scanRightX scanStopArray scanDisplayFlag scanXTable stopCode bitBltOop affectedL affectedR affectedT affectedB interpreterProxy opTable maskTable ditherMatrix4x4 ditherThresholds16 ditherValues16 hasSurfaceLock warpSrcShift warpSrcMask warpAlignShift warpAlignMask warpBitShiftTable cmDeltaBits cmRedMask cmBlueMask cmGreenMask cmRedShift cmBlueShift cmGreenShift '	classVariableNames: 'AllOnes BBClipHeightIndex BBClipWidthIndex BBClipXIndex BBClipYIndex BBColorMapIndex BBDestFormIndex BBDestXIndex BBDestYIndex BBHalftoneFormIndex BBHeightIndex BBLastIndex BBRuleIndex BBSourceFormIndex BBSourceXIndex BBSourceYIndex BBWarpBase BBWidthIndex BBXTableIndex BinaryPoint CrossedX EndOfRun FixedPt1 FormBitsIndex FormDepthIndex FormHeightIndex FormWidthIndex OpTable OpTableSize '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 10/25/1999 00:57'!transformWidth: w	"Transform the given width"	| deltaX deltaY dstWidth dstWidth2 |	self inline: false.	self var: #deltaX declareC:'double deltaX'.	self var: #deltaY declareC:'double deltaY'.	w = 0 ifTrue:[^0].	self point1Get at: 0 put: 0.	self point1Get at: 1 put: 0.	self point2Get at: 0 put: w * 256.	self point2Get at: 1 put: 0.	self point3Get at: 0 put: 0.	self point3Get at: 1 put: w * 256.	self transformPoints: 3.	deltaX _ ((self point2Get at: 0) - (self point1Get at: 0)) asFloat.	deltaY _ ((self point2Get at: 1) - (self point1Get at: 1)) asFloat.	dstWidth _ (((deltaX * deltaX) + (deltaY * deltaY)) sqrt asInteger + 128) // 256.	deltaX _ ((self point3Get at: 0) - (self point1Get at: 0)) asFloat.	deltaY _ ((self point3Get at: 1) - (self point1Get at: 1)) asFloat.	dstWidth2 _ (((deltaX * deltaX) + (deltaY * deltaY)) sqrt asInteger + 128) // 256.	dstWidth2 < dstWidth ifTrue:[dstWidth _ dstWidth2].	dstWidth = 0		ifTrue:[^1]		ifFalse:[^dstWidth]! !!BitBlt methodsFor: 'copying' stamp: 'ar 10/27/1999 23:36'!copyBitsSimulated	^BitBltSimulation copyBitsFrom: self.! !!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 10/28/1999 23:38'!benchDiffsFrom: before to: afterwards	"Given two outputs of BitBlt>>benchmark show the relative improvements."	| old new log oldLine newLine oldVal newVal improvement |	log _ WriteStream on: String new.	old _ ReadStream on: before.	new _ ReadStream on: afterwards.	[old atEnd or:[new atEnd]] whileFalse:[		oldLine _ old upTo: Character cr.		newLine _ new upTo: Character cr.		(oldLine includes: Character tab) ifTrue:[			oldLine _ ReadStream on: oldLine.			newLine _ ReadStream on: newLine.			Transcript cr; show: (oldLine upTo: Character tab); tab.			log cr; nextPutAll: (newLine upTo: Character tab); tab.			[oldLine skipSeparators. newLine skipSeparators.			oldLine atEnd] whileFalse:[				oldVal _ Integer readFrom: oldLine.				newVal _ Integer readFrom: newLine.				improvement _ oldVal asFloat / newVal asFloat roundTo: 0.1.				Transcript show: improvement printString; tab.				log print: improvement; tab].		] ifFalse:[			Transcript cr; show: oldLine.			log cr; nextPutAll: oldLine.		].	].	^log contents! !!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 10/28/1999 23:31'!benchmark		"BitBlt benchmark"	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.	Attention: *this*may*take*a*while*"	| bb source dest destRect log t |	log _ WriteStream on: String new.	destRect _ 0@0 extent: 600@600.	"Form paint/Form over - the most common rules"	#( 25 3 ) do:[:rule|		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.		#(1 2 4 8 16 32) do:[:destDepth|			dest _ nil.			dest _ Form extent: destRect extent depth: destDepth.			Transcript cr.			log cr.			#(1 2 4 8 16 32) do:[:sourceDepth|				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.				source _ nil. bb _ nil.				source _ Form extent: destRect extent depth: sourceDepth.				(FormCanvas on: source) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.				bb _ WarpBlt toForm: dest.				bb sourceForm: source.				bb sourceRect: source boundingBox.				bb destRect: dest boundingBox.				bb colorMap: (source colormapIfNeededForDepth: dest depth).				bb combinationRule: rule.				"Measure speed of copyBits"				t _ Time millisecondsToRun:[bb copyBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				bb sourceForm: source destRect: source boundingBox.				"Measure speed of 1x1 warpBits"				bb cellSize: 1.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 2x2 warpBits"				bb cellSize: 2.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 3x3 warpBits"				bb cellSize: 3.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.			].		].	].	^log contents! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/28/1999 22:21'!loadBitBltDestForm	"Load the dest form for BitBlt. Return false if anything is wrong, true otherwise."	| destBitsSize |	self inline: true.	destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.	destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.	destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.	(destWidth >= 0 and: [destHeight >= 0])		ifFalse: [^ false].	destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(interpreterProxy isIntegerObject: destBits) ifTrue:[		"Query for actual surface dimensions"		(self queryDestSurface: (interpreterProxy integerValueOf: destBits))			ifFalse:[^false].		pixPerWord _ 32 // destPixSize.		destBits _ destPitch _ 0.	] ifFalse:[		pixPerWord _ 32 // destPixSize.		destPitch _ destWidth + (pixPerWord-1) // pixPerWord * 4.		destBitsSize _ interpreterProxy byteSizeOf: destBits.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destPitch * destHeight)])			ifFalse: [^ false].		"Skip header since external bits don't have one"		destBits _ self cCoerce: (interpreterProxy firstIndexableField: destBits) to:'int'.	].	^true! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/27/1999 16:03'!loadBitBltFrom: bbObj	^self loadBitBltFrom: bbObj warping: false.! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/28/1999 18:00'!loadBitBltFrom: bbObj warping: aBool	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| ok |	self inline: false.	bitBltOop _ bbObj.	colorMap _ nil. "Assume no color map"	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > (OpTableSize - 2)]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bbObj.	((interpreterProxy isPointers: destForm) and: [(interpreterProxy slotSizeOf: destForm) >= 4])		ifFalse: [^ false].	ok _ self loadBitBltDestForm.	ok ifFalse:[^false].	destX _ interpreterProxy fetchIntegerOrTruncFloat: BBDestXIndex ofObject: bitBltOop.	destY _ interpreterProxy fetchIntegerOrTruncFloat: BBDestYIndex ofObject: bitBltOop.	width _ interpreterProxy fetchIntegerOrTruncFloat: BBWidthIndex ofObject: bitBltOop.	height _ interpreterProxy fetchIntegerOrTruncFloat: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy slotSizeOf: sourceForm) >= 4])			ifFalse: [^ false].		ok _ self loadBitBltSourceForm.		ok ifFalse:[^false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		ok _ self loadColorMap: aBool.		ok ifFalse:[^false].		self setupColorMasks.		sourceX _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceXIndex ofObject: bitBltOop.		sourceY _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceYIndex ofObject: bitBltOop].	ok _ self loadHalftoneForm.	ok ifFalse:[^false].	clipX _ interpreterProxy fetchIntegerOrTruncFloat: BBClipXIndex ofObject: bitBltOop.	clipY _ interpreterProxy fetchIntegerOrTruncFloat: BBClipYIndex ofObject: bitBltOop.	clipWidth _ interpreterProxy fetchIntegerOrTruncFloat: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ interpreterProxy fetchIntegerOrTruncFloat: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/28/1999 22:21'!loadBitBltSourceForm	"Load the source form for BitBlt. Return false if anything is wrong, true otherwise."	| sourcePixPerWord sourceBitsSize |	self inline: true.	sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.	srcWidth _ interpreterProxy fetchIntegerOrTruncFloat: FormWidthIndex ofObject: sourceForm.	srcHeight _ interpreterProxy fetchIntegerOrTruncFloat: FormHeightIndex ofObject: sourceForm.	(srcWidth >= 0 and: [srcHeight >= 0])		ifFalse: [^ false].	sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(interpreterProxy isIntegerObject: sourceBits) ifTrue:[		"Query for actual surface dimensions"		(self querySourceSurface: (interpreterProxy integerValueOf: sourceBits))			ifFalse:[^false].		sourcePixPerWord _ 32 // sourcePixSize.		sourceBits _ sourcePitch _ 0.	] ifFalse:[		sourcePixPerWord _ 32 // sourcePixSize.		sourcePitch _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord * 4.		sourceBitsSize _ interpreterProxy byteSizeOf: sourceBits.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourcePitch * srcHeight)])			ifFalse: [^ false].		"Skip header since external bits don't have one"		sourceBits _ self cCoerce: (interpreterProxy firstIndexableField: sourceBits) to:'int'.	].	^true! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/28/1999 22:21'!loadColorMap: warping	"ColorMap, if not nil, must be longWords, and 	2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 	or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."	| cmSize |	self inline: true.	cmBitsPerColor _ 0.	colorMap = interpreterProxy nilObject ifTrue:[		colorMap _ nil.	] ifFalse:[		(interpreterProxy isWords: colorMap) ifTrue:[			cmSize _ interpreterProxy slotSizeOf: colorMap.			cmSize = 512 ifTrue: [cmBitsPerColor _ 3].			cmSize = 4096 ifTrue: [cmBitsPerColor _ 4].			cmSize = 32768 ifTrue: [cmBitsPerColor _ 5].			warping ifFalse:[				"WarpBlt has different checks on the color map"				sourcePixSize <= 8					ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]					ifFalse: [cmBitsPerColor = 0 ifTrue: [^ false] ]].			colorMap _ self cCoerce: (interpreterProxy firstIndexableField: colorMap) to: 'int'.			self setupColorMasks.		] ifFalse: [^ false]].	^true! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/28/1999 22:22'!loadHalftoneForm	"Load the halftone form"	| halftoneBits |	self inline: true.	noHalftone ifTrue:[		halftoneBase _ nil.		^true].	((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy slotSizeOf: halftoneForm) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.		(interpreterProxy isWords: halftoneBits)			ifFalse: [noHalftone _ true]]		ifFalse:		["New spec accepts, basically, a word array"		((interpreterProxy isPointers: halftoneForm) not			and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].		halftoneBits _ halftoneForm.		halftoneHeight _ interpreterProxy slotSizeOf: halftoneBits].	halftoneBase _ self cCoerce: (interpreterProxy firstIndexableField: halftoneBits) to:'int'.	^true! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/27/1999 14:09'!loadScannerFrom: bbObj	start: start stop: stop string: string rightX: rightX	stopArray: stopArray displayFlag: displayFlag	self inline: false.	"Load arguments and Scanner state"	scanStart _ start.	scanStop _ stop.	scanString _ string.	scanRightX _ rightX.	scanStopArray _ stopArray.	scanDisplayFlag _ displayFlag.	interpreterProxy success: (		(interpreterProxy isPointers: scanStopArray)			and: [(interpreterProxy slotSizeOf: scanStopArray) >= 1]).	scanXTable _ interpreterProxy fetchPointer: BBXTableIndex ofObject: bbObj.	interpreterProxy success: (		(interpreterProxy isPointers: scanXTable)			and: [(interpreterProxy slotSizeOf: scanXTable) >= 1]).	"width and sourceX may not be set..."	interpreterProxy storeInteger: BBWidthIndex ofObject: bbObj withValue: 0.	interpreterProxy storeInteger: BBSourceXIndex ofObject: bbObj withValue: 0.	"Now load BitBlt state if displaying"	scanDisplayFlag		ifTrue: [interpreterProxy success: (self loadBitBltFrom: bbObj)]		ifFalse: [bitBltOop _ bbObj.				destX _ interpreterProxy fetchIntegerOrTruncFloat: BBDestXIndex ofObject: bbObj].	^interpreterProxy failed not! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/27/1999 16:03'!loadWarpBltFrom: bbObj	^self loadBitBltFrom: bbObj warping: true! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/23/1999 20:24'!scanCharacters	self inline: true.	scanDisplayFlag ifTrue:[		self clipRange.		self lockSurfaces ifFalse:[^interpreterProxy primitiveFail]].	self scanCharactersLockedAndClipped.	scanDisplayFlag ifTrue:[self unlockSurfaces].! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/28/1999 18:03'!setupColorMasks	| bits targetBits |	bits _ targetBits _ 0.	sourcePixSize <= 8 ifTrue:[^nil].	sourcePixSize = 16 ifTrue:[bits _ 5].	sourcePixSize = 32 ifTrue:[bits _ 8].	colorMap == nil		ifTrue:["Convert between RGB values"				destPixSize <= 8 ifTrue:[^nil].				destPixSize = 16 ifTrue:[targetBits _ 5].				destPixSize = 32 ifTrue:[targetBits _ 8]]		ifFalse:[targetBits _ cmBitsPerColor].	self setupColorMasksFrom: bits to: targetBits! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/28/1999 23:50'!setupColorMasksFrom: srcBits to: targetBits	"Setup color masks for converting an incoming RGB pixel value from srcBits to targetBits."	| delta mask |	cmDeltaBits _ targetBits - srcBits.	cmDeltaBits <= 0		ifTrue:[	mask _ 1 << targetBits - 1.				delta _ srcBits - targetBits.				"Mask for extracting a color part of the source"				cmRedMask _ mask << (srcBits*2 - cmDeltaBits).				cmGreenMask _ mask << (srcBits - cmDeltaBits).				cmBlueMask _ mask << (0 - cmDeltaBits)]		ifFalse:[	mask _ 1 << srcBits - 1.				delta _ targetBits - srcBits.				"Mask for extracting a color part of the source"				cmRedMask _ mask << (srcBits*2).				cmGreenMask _ mask << srcBits.				cmBlueMask _ mask].	"Shifts for adjusting each value in a cm RGB value"	cmRedShift _ delta * 3.	cmGreenShift _ delta * 2.	cmBlueShift _ delta.! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/23/1999 20:33'!checkSourceOverlap	"check for possible overlap of source and destination"	"ar 10/19/1999: This method requires surfaces to be locked."	| t |	self inline: true.	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir _ -1.			sy _ sy + bbH - 1.			dy _ dy + bbH - 1]		ifFalse:			[(dy = sy) & (dx > sx) ifTrue:				["y's are equal, but x's are backward"				hDir _ -1.				sx _ sx + bbW - 1.				"start at right"				dx _ dx + bbW - 1.				"and fix up masks"				nWords > 1 ifTrue: 					[t _ mask1.					mask1 _ mask2.					mask2 _ t]]].		"Dest inits may be affected by this change"		destIndex _ destBits + (dy * destPitch) + ((dx // pixPerWord) *4).		destDelta _ (destPitch * vDir) - (4 * (nWords * hDir))]! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/24/1999 21:32'!copyBits	self inline: true.	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil].	"Lock the surfaces"	self lockSurfaces ifFalse:[^interpreterProxy primitiveFail].	self copyBitsLockedAndClipped.	self unlockSurfaces.! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/23/1999 20:35'!copyBitsFrom: startX to: stopX at: yValue	"Support for the balloon engine."	destX _ startX.	destY _ yValue.	sourceX _ startX.	width _ (stopX - startX).	self copyBits.	interpreterProxy showDisplayBits.! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/25/1999 19:12'!copyBitsLockedAndClipped	"Perform the actual copyBits operation.	Assume: Surfaces have been locked and clipping was performed."	| done |	self inline: true.	"Try a shortcut for stuff that should be run as quickly as possible" 	done _ self tryCopyingBitsQuickly.	done ifTrue:[^nil].	(combinationRule = 30) | (combinationRule = 31) ifTrue:		["Check and fetch source alpha parameter for alpha blend"		interpreterProxy argCount = 1			ifTrue: [sourceAlpha _ interpreterProxy stackIntegerValue: 0.					(interpreterProxy failed not and: [(sourceAlpha >= 0) & (sourceAlpha <= 255)])						ifTrue: [interpreterProxy pop: 1]						ifFalse: [^ interpreterProxy primitiveFail]]			ifFalse: [^ interpreterProxy primitiveFail]].	bitCount _ 0.	"Choose and perform the actual copy loop."	self performCopyLoop.	(combinationRule = 22) | (combinationRule = 32) ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/23/1999 20:36'!destMaskAndPointerInit	"Compute masks for left and right destination words"	| startBits pixPerM1 endBits |	self inline: true.	pixPerM1 _ pixPerWord - 1.  "A mask, assuming power of two"	"how many pixels in first word"	startBits _ pixPerWord - (dx bitAnd: pixPerM1).	mask1 _ AllOnes >> (32 - (startBits*destPixSize)).	"how many pixels in last word"	endBits _ ((dx + bbW - 1) bitAnd: pixPerM1) + 1.	mask2 _ AllOnes << (32 - (endBits*destPixSize)).	"determine number of words stored per line; merge masks if only 1"	bbW < startBits		ifTrue: [mask1 _ mask1 bitAnd: mask2.				mask2 _ 0.				nWords _ 1]		ifFalse: [nWords _ (bbW - startBits) + pixPerM1 // pixPerWord + 1].	hDir _ vDir _ 1. "defaults for no overlap with source"	"calculate byte addr and delta, based on first word of data"	"Note pitch is bytes and nWords is longs, not bytes"	destIndex _ destBits + (dy * destPitch) + ((dx // pixPerWord) *4).	destDelta _ destPitch * vDir - (4 * (nWords * hDir)).  "byte addr delta"! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/25/1999 21:56'!performCopyLoop	"Based on the values provided during setup choose and	perform the appropriate inner loop function."	self inline: true. "Should be inlined into caller for speed"	self destMaskAndPointerInit.	noSource ifTrue: ["Simple fill loop"		self copyLoopNoSource.	] ifFalse: ["Loop using source and dest"		self checkSourceOverlap.		(sourcePixSize ~= destPixSize or: [colorMap ~= nil]) ifTrue: [			"If we must convert between pixel depths or use			color lookups use the general version"			self copyLoopPixMap.		] ifFalse: [			"Otherwise we simple copy pixels and can use a faster version"			self sourceSkewAndPointerInit.			self copyLoop.		]	].! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/23/1999 20:37'!scanCharactersLockedAndClipped	"Perform the actual scanCharacters operation.	Assume: Surfaces have been locked and clipping was performed."	| left top lastIndex charVal ascii sourceX2 nextDestX |	self inline: true.	scanDisplayFlag ifTrue:		[left _ dx.		top _ dy].	lastIndex _ scanStart.	[lastIndex <= scanStop]		whileTrue: [			charVal _ interpreterProxy stObject: scanString at: lastIndex.			ascii _ interpreterProxy integerValueOf: charVal.			interpreterProxy failed ifTrue: [^ nil].			stopCode _ interpreterProxy stObject: scanStopArray at: ascii + 1.			interpreterProxy failed ifTrue: [^ nil].			stopCode = interpreterProxy nilObject				ifFalse: [^ self returnAt: ascii + 1							 lastIndex: lastIndex								  left: left								  top: top].			sourceX _ interpreterProxy stObject: scanXTable at: ascii + 1.			sourceX2 _ interpreterProxy stObject: scanXTable at: ascii + 2.			interpreterProxy failed ifTrue: [^ nil].			(interpreterProxy isIntegerObject: sourceX) & (interpreterProxy isIntegerObject: sourceX2)				ifTrue: [sourceX _ interpreterProxy integerValueOf: sourceX.						sourceX2 _ interpreterProxy integerValueOf: sourceX2]				ifFalse: [interpreterProxy primitiveFail. ^ nil].			nextDestX _ destX + (width _ sourceX2 - sourceX).			nextDestX > scanRightX				ifTrue: [^ self returnAt: CrossedX							 lastIndex: lastIndex								  left: left								  top: top].			(scanDisplayFlag) ifTrue:[				self clipRange. "Must clip again"				 (bbW > 0 and:[bbH > 0]) ifTrue: [self copyBitsLockedAndClipped].			].			destX _ nextDestX.			interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.			lastIndex _ lastIndex + 1].	self returnAt: EndOfRun		 lastIndex: scanStop			  left: left			  top: top! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/23/1999 20:38'!sourceSkewAndPointerInit	"This is only used when source and dest are same depth,	ie, when the barrel-shift copy loop is used."	| dWid sxLowBits dxLowBits pixPerM1 |	self inline: true.	pixPerM1 _ pixPerWord - 1.  "A mask, assuming power of two"	sxLowBits _ sx bitAnd: pixPerM1.	dxLowBits _ dx bitAnd: pixPerM1.	"check if need to preload buffer	(i.e., two words of source needed for first word of destination)"	hDir > 0 ifTrue:		["n Bits stored in 1st word of dest"		dWid _ bbW min: pixPerWord - dxLowBits.		preload _ (sxLowBits + dWid) > pixPerM1]	ifFalse:		[dWid _ bbW min: dxLowBits + 1.		preload _ (sxLowBits - dWid + 1) < 0].	"calculate right-shift skew from source to dest"	skew _ (sxLowBits - dxLowBits) * destPixSize.  " -32..32 "	preload ifTrue: 		[skew < 0			ifTrue: [skew _ skew+32]			ifFalse: [skew _ skew-32]].	"Calc byte addr and delta from longWord info"	sourceIndex _ sourceBits + (sy * sourcePitch) + ((sx // (32//sourcePixSize)) *4).	"calculate increments from end of 1 line to start of next"	sourceDelta _ (sourcePitch * vDir) - (4 * (nWords * hDir)).	preload ifTrue:		["Compensate for extra source word fetched"		sourceDelta _ sourceDelta - (4*hDir)].! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/23/1999 20:40'!tryCopyingBitsQuickly	"Shortcut for stuff that's being run from the balloon engine.	Since we do this at each scan line we should avoid the expensive 	setup for source and destination."	self inline: true.	"We need a source."	noSource ifTrue:[^false].	"We handle only combinationRule 34"	(combinationRule = 34) ifFalse:[^false].	"We handle only sourcePixSize 32"	(sourcePixSize = 32) ifFalse:[^false].	"We don't handle overlaps"	(sourceForm = destForm) ifTrue:[^false].	"We need at least 8bit deep dest forms"	(destPixSize < 8) ifTrue:[^false].	"If 8bit, then we want a color map"	(destPixSize = 8 and:[colorMap = nil]) ifTrue:[^false].	destPixSize = 32 		ifTrue:[self alphaSourceBlendBits32].	destPixSize = 16		ifTrue:[self alphaSourceBlendBits16].	destPixSize = 8		ifTrue:[self alphaSourceBlendBits8].	affectedL _ dx.	affectedR _ dx + bbW.	affectedT _ dy.	affectedB _ dy + bbH.	^true! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/27/1999 17:05'!warpBits	| ns |	self inline: true.	ns _ noSource.  noSource _ true.		self clipRange.  "noSource suppresses sourceRect clipping"		noSource _ ns.	(noSource or: [bbW <= 0 or: [bbH <= 0]]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil]. 	self lockSurfaces.	self destMaskAndPointerInit.	self xWarpLoop. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1].	self unlockSurfaces.! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 10/28/1999 19:52'!alphaSourceBlendBits16	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 16		sourceForm ~= destForm.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift ditherBase ditherIndex ditherThreshold |	self inline: false. "This particular method should be optimized in itself"	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	(dx bitAnd: 1) = 0 		ifTrue:[	mask1 _ 16r0000FFFF.				srcShift _ 16]		ifFalse:[mask1 _ 16rFFFF0000.				srcShift _ 0].	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		srcIndex _ sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex _ destBits + (dstY * destPitch) + (dx // 2 * 4).		ditherBase _ (dstY bitAnd: 3) * 4.		ditherIndex _ (sx bitAnd: 3) - 1. "For pre-increment"		deltaX _ bbW + 1. "So we can pre-decrement"		dstMask _ mask1.		dstMask = 16rFFFF ifTrue:[srcShift _ 16] ifFalse:[srcShift _ 0].		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			ditherThreshold _ ditherMatrix4x4 at: ditherBase + (ditherIndex _ ditherIndex + 1 bitAnd: 3).			sourceWord _ self srcLongAt: srcIndex.			srcAlpha _ sourceWord >> 24.			srcAlpha = 255 ifTrue:[				"Dither from 32 to 16 bit"				sourceWord _ self dither32To16: sourceWord threshold: ditherThreshold.				sourceWord = 0 ifTrue:[sourceWord _ 1].				sourceWord _ sourceWord << srcShift.				"Store masked value"				self dstLongAt: dstIndex put: sourceWord mask: dstMask.			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifTrue:[				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord _ self dstLongAt: dstIndex.					destWord _ destWord bitAnd: dstMask bitInvert32.					destWord _ destWord >> srcShift.					"Expand from 16 to 32 bit by adding zero bits"					destWord _ (((destWord bitAnd: 16r7C00) bitShift: 9) bitOr:									((destWord bitAnd: 16r3E0) bitShift: 6)) bitOr:								(((destWord bitAnd: 16r1F) bitShift: 3) bitOr:									16rFF000000).					"Mix colors"					sourceWord _ self alphaBlendScaled: sourceWord with: destWord.					"And dither"					sourceWord _ self dither32To16: sourceWord threshold: ditherThreshold.					sourceWord = 0 ifTrue:[sourceWord _ 1].					sourceWord _ sourceWord << srcShift.					"Store back"					self dstLongAt: dstIndex put: sourceWord mask: dstMask.				].			].			srcIndex _ srcIndex + 4.			srcShift = 0 ifTrue:[dstIndex _ dstIndex + 4].			srcShift _ srcShift bitXor: 16. "Toggle between 0 and 16"			dstMask _ dstMask bitInvert32. "Mask other half word"		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 10/25/1999 19:16'!alphaSourceBlendBits32	"This version assumes 		combinationRule = 34		sourcePixSize = destPixSize = 32		sourceForm ~= destForm.	Note: The inner loop has been optimized for dealing		with the special cases of srcAlpha = 0.0 and srcAlpha = 1.0 	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY srcY dstY |	self inline: false. "This particular method should be optimized in itself"	"Give the compile a couple of hints"	self var: #sourceWord declareC:'register int sourceWord'.	self var: #deltaX declareC:'register int deltaX'.	"The following should be declared as pointers so the compiler will	notice that they're used for accessing memory locations 	(good to know on an Intel architecture) but then the increments	would be different between ST code and C code so must hope the	compiler notices what happens (MS Visual C does)"	self var: #srcIndex declareC:'register int srcIndex'.	self var: #dstIndex declareC:'register int dstIndex'.	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		srcIndex _ sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex _ destBits + (dstY * destPitch) + (dx * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ self srcLongAt: srcIndex.			srcAlpha _ sourceWord >> 24.			srcAlpha = 255 ifTrue:[				self dstLongAt: dstIndex put: sourceWord.				srcIndex _ srcIndex + 4.				dstIndex _ dstIndex + 4.				"Now copy as many words as possible with alpha = 255"				[(deltaX _ deltaX - 1) ~= 0 and:[					(sourceWord _ self srcLongAt: srcIndex) >> 24 = 255]]						whileTrue:[							self dstLongAt: dstIndex put: sourceWord.							srcIndex _ srcIndex + 4.							dstIndex _ dstIndex + 4.						].				"Adjust deltaX"				deltaX _ deltaX + 1.			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifTrue:[					srcIndex _ srcIndex + 4.					dstIndex _ dstIndex + 4.					"Now skip as many words as possible,"					[(deltaX _ deltaX - 1) ~= 0 and:[						(sourceWord _ self srcLongAt: srcIndex) >> 24 = 0]]						whileTrue:[							srcIndex _ srcIndex + 4.							dstIndex _ dstIndex + 4.						].					"Adjust deltaX"					deltaX _ deltaX + 1.				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord _ self dstLongAt: dstIndex.					destWord _ self alphaBlendScaled: sourceWord with: destWord.					self dstLongAt: dstIndex put: destWord.					srcIndex _ srcIndex + 4.					dstIndex _ dstIndex + 4.				].			].		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 10/28/1999 19:53'!alphaSourceBlendBits8	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 8		sourceForm ~= destForm.	Note: This is not real blending since we don't have the source colors available.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift adjust mappingTable |	self inline: false. "This particular method should be optimized in itself"	self var: #mappingTable declareC:'unsigned int *mappingTable'.	mappingTable _ self default8To32Table.	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	mask1 _ 24 - ((dx bitAnd: 3) * 8).	mask2 _ AllOnes bitXor:(16rFF << mask1).	(dx bitAnd: 1) = 0 		ifTrue:[adjust _ 0]		ifFalse:[adjust _ 16r1F1F1F1F].	(dy bitAnd: 1) = 0		ifTrue:[adjust _ adjust bitXor: 16r1F1F1F1F].	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		adjust _ adjust bitXor: 16r1F1F1F1F.		srcIndex _ sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex _ destBits + (dstY * destPitch) + (dx // 4 * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		srcShift _ mask1.		dstMask _ mask2.		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ ((self srcLongAt: srcIndex) bitAnd: (adjust bitInvert32)) + adjust.			srcAlpha _ sourceWord >> 24.			srcAlpha > 31 ifTrue:["Everything below 31 is transparent"				srcAlpha < 224 ifTrue:["Everything above 224 is opaque"					destWord _ self dstLongAt: dstIndex.					destWord _ destWord bitAnd: dstMask bitInvert32.					destWord _ destWord >> srcShift.					destWord _ mappingTable at: destWord.					sourceWord _ self alphaBlendScaled: sourceWord with: destWord.				].				sourceWord _ self rgbMap: sourceWord from: 8 to: cmBitsPerColor.				sourceWord _ self colormapAt: sourceWord.				sourceWord _ sourceWord << srcShift.				"Store back"				self dstLongAt: dstIndex put: sourceWord mask: dstMask.			].			srcIndex _ srcIndex + 4.			srcShift = 0 ifTrue:[				dstIndex _ dstIndex + 4.				srcShift _ 24.				dstMask _ 16r00FFFFFF.			] ifFalse:[				srcShift _ srcShift - 8.				dstMask _ (dstMask >> 8) bitOr: 16rFF000000.			].			adjust _ adjust bitXor: 16r1F1F1F1F.		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 12/7/1999 21:37'!copyLoop	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask mergeFnwith destWord |	"This version of the inner loop assumes noSource = false."	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	hInc _ hDir*4.  "Byte delta"	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew _ unskew _ skewMask _ 0]		ifFalse: [skew < 0			ifTrue:				[unskew _ skew+32.				skewMask _ AllOnes << (0-skew)]			ifFalse:				[skew == 0					ifTrue:						[unskew _ 0.						skewMask _ AllOnes]					ifFalse:						[unskew _ skew-32.						skewMask _ AllOnes >> skew]]].	notSkewMask _ skewMask bitInvert32.	noHalftone		ifTrue: [halftoneWord _ AllOnes.  halftoneHeight _ 0]		ifFalse: [halftoneWord _ self halftoneAt: 0].	y _ dy.	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"			[halftoneWord _ self halftoneAt: y.			y _ y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord _ self srcLongAt: sourceIndex.			sourceIndex _ sourceIndex + hInc]			ifFalse:			[prevWord _ 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			thisWord _ self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			destWord _ self dstLongAt: destIndex.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord) with: destWord.			destWord _ (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex _ destIndex + hInc.		"This central horizontal loop requires no store masking"		destMask _ AllOnes.combinationRule = 3ifTrue: [noHalftone & (notSkewMask = 0)		ifTrue:  		["Very special inner loop for STORE mode with no skew -- just move words"		2 to: nWords-1 do: 			[ :word |			thisWord _ self srcLongAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			self dstLongAt: destIndex put: thisWord.			destIndex _ destIndex + hInc]]		ifFalse:		["Special inner loop for STORE mode -- no need to call merge"		2 to: nWords-1 do: 			[ :word |			thisWord _ self srcLongAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			self dstLongAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex _ destIndex + hInc]]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord _ self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (self dstLongAt: destIndex).			self dstLongAt: destIndex put: mergeWord.			destIndex _ destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			thisWord _ self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			destWord _ self dstLongAt: destIndex.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord) with: destWord.			destWord _ (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex _ destIndex + hInc].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 12/7/1999 21:37'!copyLoopNoSource	| halftoneWord mergeWord mergeFnwith destWord |	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused"	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ self halftoneAt: dy+i-1].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			destWord _ self dstLongAt: destIndex.			mergeWord _ self mergeFn: halftoneWord							with: destWord.			destWord _ (destMask bitAnd: mergeWord) bitOr: 							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex _ destIndex + 4.		"This central horizontal loop requires no store masking"			destMask _ AllOnes.			combinationRule = 3 ifTrue: ["Special inner loop for STORE"				destWord _ halftoneWord.				2 to: nWords-1 do:[ :word |					self dstLongAt: destIndex put: destWord.					destIndex _ destIndex + 4].			] ifFalse:[ "Normal inner loop does merge"				2 to: nWords-1 do:[ :word | "Normal inner loop does merge"					destWord _ self dstLongAt: destIndex.					mergeWord _ self mergeFn: halftoneWord with: destWord.					self dstLongAt: destIndex put: mergeWord.					destIndex _ destIndex + 4].			].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			destWord _ self dstLongAt: destIndex.			mergeWord _ self mergeFn: halftoneWord with: destWord.			destWord _ (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex _ destIndex + 4].	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 12/7/1999 20:58'!copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	"ar 12/7/1999:	The loop has been rewritten to use only one pickSourcePixels call.	The idea is that the call itself could be inlined. If we decide not	to inline pickSourcePixels we could optimize the loop instead."	| skewWord halftoneWord mergeWord srcPixPerWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nullMap mergeFnwith nPix srcShift dstShift destWord words |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	"Additional inits peculiar to unequal source and dest pix size..."	srcPixPerWord _ 32//sourcePixSize.	sourcePixMask _ maskTable at: sourcePixSize.	destPixMask _ maskTable at: destPixSize.	nullMap _ colorMap = nil.	sourceIndex _ sourceBits +					(sy * sourcePitch) + ((sx // srcPixPerWord) *4).	scrStartBits _ srcPixPerWord - (sx bitAnd: srcPixPerWord-1).	bbW < scrStartBits		ifTrue: [nSourceIncs _ 0]		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//srcPixPerWord + 1].	sourceDelta _ sourcePitch - (nSourceIncs * 4).	"Note following two items were already calculated in destmask setup!!"	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1.	bbW < startBits ifTrue:[startBits _ bbW].	"Precomputed shifts for pickSourcePixels"	srcShift _ 32 - ((sx bitAnd: srcPixPerWord - 1) + 1 * sourcePixSize).	dstShift _ 32 - ((dx bitAnd: pixPerWord - 1) + 1 * destPixSize).	1 to: bbH do: "here is the vertical loop"		[ :i |		"*** is it possible at all that noHalftone == false? ***"		noHalftone			ifTrue:[halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ self halftoneAt: dy+i-1].		"setup first load"		srcBitShift _ srcShift.		dstBitShift _ dstShift.		destMask _ mask1.		nPix _ startBits.		"Here is the horizontal loop..."		words _ nWords.			["pick up the word"			skewWord _ self pickSourcePixels: nPix nullMap: nullMap 								srcMask: sourcePixMask destMask: destPixMask.			destMask = AllOnes ifTrue:["avoid read-modify-write"				mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)								with: (self dstLongAt: destIndex).				self dstLongAt: destIndex put: (destMask bitAnd: mergeWord).			] ifFalse:[ "General version using dest masking"				destWord _ self dstLongAt: destIndex.				mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)								with: (destWord bitAnd: destMask).				destWord _ (destMask bitAnd: mergeWord) bitOr:								(destWord bitAnd: destMask bitInvert32).				self dstLongAt: destIndex put: destWord.			].			destIndex _ destIndex + 4.			words = 2 "e.g., is the next word the last word?"				ifTrue:["set mask for last word in this row"						destMask _ mask2.						nPix _ endBits]				ifFalse:["use fullword mask for inner loop"						destMask _ AllOnes.						nPix _ pixPerWord].			(words _ words - 1) = 0] whileFalse.		"--- end of inner loop ---"		sourceIndex _ sourceIndex + sourceDelta.		destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 12/7/1999 20:59'!warpLoop	"ar 12/7/1999: This version is unused but kept as reference implemenation"	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation."	| skewWord halftoneWord mergeWord startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy	  xDelta yDelta pBx pBy smoothingCount sourceMapOop nSteps t |	self inline: false. 	(interpreterProxy slotSizeOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+3 ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx to: t nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ t - (nSteps*deltaP12x)].	pAy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+1 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+4 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy to: t nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ t - (nSteps*deltaP12y)].	pBx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+9 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+6 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx to: t nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ t - (nSteps*deltaP43x)].	pBy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+10 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+7 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy to: t nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ t - (nSteps*deltaP43y)].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy methodArgumentCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [sourcePixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy slotSizeOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail]]]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1]. 	destY to: clipY-1 do:		[ :i |	"Advance increments if there was clipping in y"		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y].	1 to: bbH do:		[ :i |		"here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pBx - (nSteps*xDelta)].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pBy - (nSteps*yDelta)].		destX to: clipX-1 do:			[:word |	"Advance increments if there was clipping in x"			sx _ sx + xDelta.			sy _ sy + yDelta].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ self halftoneAt: dy+i-1].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]. 		1 to: nWords do:			[ :word |		"here is the inner horizontal loop..."			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((self dstLongAt: destIndex) bitAnd: destMask).			self dstLongAt: destIndex put: (destMask bitAnd: mergeWord)				mask: destMask bitInvert32.			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop].			].		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y.		destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 10/28/1999 23:53'!xWarpLoop	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation."	| skewWord halftoneWord mergeWord startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy pBx pBy	  xDelta yDelta smoothingCount sourceMapOop 	  nSteps nPix words destWord endBits mergeFnwith |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler" 	(interpreterProxy slotSizeOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase ofObject: bitBltOop.	words _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+3 ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx to: words nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ words - (nSteps*deltaP12x)].	pAy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+1 ofObject: bitBltOop.	words _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+4 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy to: words nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ words - (nSteps*deltaP12y)].	pBx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+9 ofObject: bitBltOop.	words _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+6 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx to: words nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ words - (nSteps*deltaP43x)].	pBy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+10 ofObject: bitBltOop.	words _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+7 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy to: words nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ words - (nSteps*deltaP43y)].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy methodArgumentCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [sourcePixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy slotSizeOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail].					sourceMapOop _ self cCoerce: (interpreterProxy firstIndexableField: sourceMapOop) to:'int']]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1. 	bbW < startBits ifTrue:[startBits _ bbW].	destY < clipY ifTrue:[		"Advance increments if there was clipping in y"		pAx _ pAx + (clipY - destY * deltaP12x).		pAy _ pAy + (clipY - destY * deltaP12y).		pBx _ pBx + (clipY - destY * deltaP43x).		pBy _ pBy + (clipY - destY * deltaP43y)].	"Setup values for faster pixel fetching.	Note: this should really go into a separate method	since it only sets up globals so there is no need to	have it in this method."		"warpSrcShift = log2(sourcePixSize)"		warpSrcShift _ 0.		words _ sourcePixSize. "recycle temp"		[words = 1] whileFalse:[			warpSrcShift _ warpSrcShift + 1.			words _ words >> 1].		"warpSrcMask = mask for extracting one pixel from source word"		warpSrcMask _ maskTable at: sourcePixSize.		"warpAlignShift: Shift for aligning x position to word boundary"		warpAlignShift _ 5 - warpSrcShift.		"warpAlignMask: Mask for extracting the pixel position from an x position"		warpAlignMask _ 1 << warpAlignShift - 1.		"Setup the lookup table for source bit shifts"		"warpBitShiftTable: given an sub-word x value what's the bit shift?"		0 to: warpAlignMask do:[:i|			warpBitShiftTable at: i put: 32 - ( i + 1 << warpSrcShift )].	1 to: bbH do:		[ :i | "here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pBx - (nSteps*xDelta)].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pBy - (nSteps*yDelta)].		dstBitShift _ 32 - ((dx bitAnd: pixPerWord - 1) + 1 * destPixSize).		(destX < clipX) ifTrue:[			"Advance increments if there was clipping in x"			sx _ sx + (clipX - destX * xDelta).			sy _ sy + (clipX - destX * yDelta).		].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ self halftoneAt: dy+i-1].		destMask _ mask1.		nPix _ startBits.		"Here is the inner loop..."		words _ nWords.			["pick up word"			smoothingCount = 1 ifTrue:["Faster if not smoothing"				skewWord _ self warpPickSourcePixels: nPix								xDeltah: xDelta yDeltah: yDelta								xDeltav: deltaP12x yDeltav: deltaP12y.			] ifFalse:["more difficult with smoothing"				skewWord _ self warpPickSmoothPixels: nPix						xDeltah: xDelta yDeltah: yDelta						xDeltav: deltaP12x yDeltav: deltaP12y						sourceMap: sourceMapOop						smoothing: smoothingCount.			].			destMask = AllOnes ifTrue:["avoid read-modify-write"				mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)								with: (self dstLongAt: destIndex).				self dstLongAt: destIndex put: (destMask bitAnd: mergeWord).			] ifFalse:[ "General version using dest masking"				destWord _ self dstLongAt: destIndex.				mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)								with: (destWord bitAnd: destMask).				destWord _ (destMask bitAnd: mergeWord) bitOr:								(destWord bitAnd: destMask bitInvert32).				self dstLongAt: destIndex put: destWord.			].			destIndex _ destIndex + 4.			words = 2 "e.g., is the next word the last word?"				ifTrue:["set mask for last word in this row"						destMask _ mask2.						nPix _ endBits]				ifFalse:["use fullword mask for inner loop"						destMask _ AllOnes.						nPix _ pixPerWord].			(words _ words - 1) = 0] whileFalse.		"--- end of inner loop ---"		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y.		destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 10/23/1999 20:44'!OLDtallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord |	colorMap = nil		ifTrue: [^ destinationWord "no op"].	destPixSize < 16 ifTrue:		["loop through all packed pixels."		pixMask _ maskTable at: destPixSize.		shiftWord _ destinationWord.		1 to: pixPerWord do:			[:i |			mapIndex _ shiftWord bitAnd: pixMask.			self colormapAt: mapIndex put: (self colormapAt: mapIndex) + 1.			shiftWord _ shiftWord >> destPixSize].		^ destinationWord].	destPixSize = 16 ifTrue:		["Two pixels  Tally the right half..."		mapIndex _ self rgbMap: (destinationWord bitAnd: 16rFFFF) from: 5 to: cmBitsPerColor.		self colormapAt: mapIndex put: (self colormapAt: mapIndex) + 1.		"... and then left half"		mapIndex _ self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.		self colormapAt: mapIndex put: (self colormapAt: mapIndex) + 1]	ifFalse:		["Just one pixel."		mapIndex _ self rgbMap: destinationWord from: 8 to: cmBitsPerColor.		self colormapAt: mapIndex put: (self colormapAt: mapIndex) + 1].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 10/23/1999 20:46'!tallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Those tallied are exactly those	in the destination rectangle.  Note that the source should be 	specified == destination, in order for the proper color map checks 	to be performed at setup."	| mapIndex pixMask destShifted maskShifted pixVal |	self inline: false.	colorMap = nil		ifTrue: [^ destinationWord "no op"].	pixMask _ maskTable at: destPixSize.	destShifted _ destinationWord.	maskShifted _ destMask.	1 to: pixPerWord do:		[:i |		(maskShifted bitAnd: pixMask) = 0 ifFalse:			["Only tally pixels within the destination rectangle"			pixVal _ destShifted bitAnd: pixMask.			destPixSize < 16				ifTrue: [mapIndex _ pixVal]				ifFalse: [destPixSize = 16					ifTrue: [mapIndex _ self rgbMap: pixVal from: 5 to: cmBitsPerColor]					ifFalse: [mapIndex _ self rgbMap: pixVal from: 8 to: cmBitsPerColor]].			self colormapAt: mapIndex put: (self colormapAt: mapIndex) + 1].		maskShifted _ maskShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 10/27/1999 17:54'!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments."	self inline: true.	x2 > x1		ifTrue: [^ x2 - x1 + FixedPt1 // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + FixedPt1 // (n+1) + 1)]! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 12/7/1999 21:00'!pickSourcePixels: nPixels nullMap: nullMap srcMask: srcMask destMask: dstMask	"Pick nPix pixels starting at srcBitIndex from the source, map by the	color map, and justify them according to dstBitIndex in the resulting destWord.	Incoming pixels of 16 or 32 bits are first reduced to cmBitsPerColor.	With no color map, pixels are just masked or zero-filled or	if 16- or 32-bit pixels, the r, g, and b are so treated individually."	"ar 12/7/1999:	- the method currently has a side effect (see at the end)	- the idea is to inline this into a single sender and do 	most of the color space stuff here	- the '[...] whileFalse' is intended to generate 	'do { ... } while(...)' loops which are faster"	| sourceWord destWord sourcePix destPix srcShift dstShift nPix |	self inline: true. "oh please"	sourceWord _ self srcLongAt: sourceIndex.	destWord _ 0.	srcShift _ srcBitShift. "Hint: Keep in register"	dstShift _ dstBitShift. "Hint: Keep in register"	nPix _ nPixels. "always > 0 so we can use do { } while(--nPix);"	(nullMap or:[sourcePixSize > 8]) ifTrue:[		"Extract the degenerate case of sourcePixSize <= 8 and nullMap.		Note: The case is considered degenerate because there should always		be a colormap when copying between indexed color forms of differing depth."		sourcePixSize <= 8 ifTrue:[			"Degenerate so the dirty version w/o comments..."			[destWord _ destWord bitOr: 				((sourceWord >> srcShift bitAnd: srcMask) bitAnd: dstMask) << dstShift.			dstShift _ dstShift - destPixSize.			(srcShift _ srcShift - sourcePixSize) < 0 ifTrue:				[srcShift _ srcShift + 32.				sourceWord _ self srcLongAt: (sourceIndex _ sourceIndex + 4)].			(nPix _ nPix - 1) = 0] whileFalse.		] ifFalse:["sourcePixSize > 8"			"Convert RGB pixels. Since the cmMasks and cmShifts have been			setup initially we only need one version here."			["pick source pixel"			sourcePix _ sourceWord >> srcShift bitAnd: srcMask.			"map the pixel(either into colorMap or destFormat)"			cmDeltaBits = 0 "e.g., srcFormat == dstFormat"				ifTrue:[destPix _ sourcePix]				ifFalse:[	destPix _ self rgbMap: sourcePix.						"Avoid transparency by color conversion"						(destPix = 0 and:[sourcePix ~= 0]) ifTrue:[destPix _ 1]].			"if nullMap == false do colormap lookup after color reduction"			nullMap ifFalse:[destPix _ self colormapAt: destPix].			"Mix it in (note: in theory we could avoid the bitAnd but its safer for now)"			destWord _ destWord bitOr: (destPix bitAnd: dstMask) << dstShift.			dstShift _ dstShift - destPixSize.			"Adjust source if at pixel boundary"			(srcShift _ srcShift - sourcePixSize) < 0 ifTrue:				[srcShift _ srcShift + 32.				sourceWord _ self srcLongAt: (sourceIndex _ sourceIndex + 4)].			(nPix _ nPix - 1) = 0] whileFalse.		].	] ifFalse:[		"This part executed if we have a source pix size <= 8		and a colormap lookup as in the regular text display."		[			"pick source pixel"			sourcePix _ sourceWord >> srcShift bitAnd: srcMask.			"Map it by color map"			destPix _ (self colormapAt: sourcePix) bitAnd: dstMask.			"**** How do we find out if we have to do color space conversion here ****"			"Mix it in"			destWord _ destWord bitOr: destPix << dstShift.			"adjust shift"			dstShift _ dstShift - destPixSize.			"Adjust source if at pixel boundary"			(srcShift _ srcShift - sourcePixSize) < 0 ifTrue:				[srcShift _ srcShift + 32.				sourceWord _ self srcLongAt: (sourceIndex _ sourceIndex + 4)].		(nPix _ nPix - 1) = 0] whileFalse.	].	srcBitShift _ srcShift. "Store back"	"*** side effect ***"	"*** only the first pixel fetch can be unaligned ***"	"*** prepare the next one for aligned access ***"	dstBitShift _ 32 - destPixSize. "Shift towards leftmost pixel"	^destWord! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 10/29/1999 00:11'!pickWarpPixelAtX: xx y: yy	"Pick a single pixel from the source for WarpBlt.	Note: This method is crucial for WarpBlt speed w/o smoothing	and still relatively important when smoothing is used."	| x y srcIndex sourceWord sourcePix |	self inline: true. "*please*"	"note: it would be much faster if we could just	avoid these stupid tests for being inside sourceForm."	(xx < 0 or:[yy < 0 or:[		(x _ xx >> BinaryPoint) >= srcWidth or:[			(y _ yy >> BinaryPoint) >= srcHeight]]]) ifTrue:[^0]. "out of bounds"	"Fetch source word.	Note: We should really update srcIndex with sx and sy so that	we don't have to do the computation below. We might even be	able to simplify the out of bounds test from above."	srcIndex _ sourceBits + (y * sourcePitch) + (x >> warpAlignShift * 4).	sourceWord _ self srcLongAt: srcIndex.	"Extract pixel from word"	srcBitShift _ warpBitShiftTable at: (x bitAnd: warpAlignMask).	sourcePix _ sourceWord >> srcBitShift bitAnd: warpSrcMask.	^sourcePix! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 10/28/1999 18:30'!rgbMap: sourcePixel	"Color map the given source pixel.	Note: This relies on an accurate setup of the cmShifts and cmMasks	by BitBlt and can therefore not be used from WarpBlt in smoothing	mode (but hey, then we have to go over lots of different pixels	before we even come to the output color conversion so that doesn't	really matter)."	self inline: true. "you bet"	cmDeltaBits < 0 "Compress or expand RGB values?!!"		ifTrue:[^((sourcePixel bitAnd: cmRedMask) >> cmRedShift) bitOr:					(((sourcePixel bitAnd: cmGreenMask) >> cmGreenShift) bitOr:						((sourcePixel bitAnd: cmBlueMask) >> cmBlueShift))]		ifFalse:[^((sourcePixel bitAnd: cmRedMask) << cmRedShift) bitOr:					(((sourcePixel bitAnd: cmGreenMask) << cmGreenShift) bitOr:						((sourcePixel bitAnd: cmBlueMask) << cmBlueShift))]! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 10/23/1999 20:45'!smoothPix: n atXf: xf yf: yf dxh: dxh dyh: dyh dxv: dxv dyv: dyv	pixPerWord: srcPixPerWord pixelMask: sourcePixMask	sourceMap: sourceMap	| sourcePix r g b x y rgb bitsPerColor d nPix maxPix |	self inline: false.	r _ g _ b _ 0.  "Separate r, g, b components"	maxPix _ n*n.	x _ xf.  y _ yf.	nPix _ 0.  "actual number of pixels (not clipped and not transparent)"	0 to: n-1 do:		[:i |		0 to: n-1 do:			[:j |			sourcePix _ (self sourcePixAtX: x + (dxh*i) + (dxv*j)  >> BinaryPoint									y: y + (dyh*i) + (dyv*j)  >> BinaryPoint									pixPerWord: srcPixPerWord)									bitAnd: sourcePixMask.			(combinationRule=25 "PAINT" and: [sourcePix = 0]) ifFalse:  			["If not clipped and not transparent, then tally rgb values"			nPix _ nPix + 1.			sourcePixSize < 16				ifTrue: ["Get 24-bit RGB values from sourcemap table"						rgb _ (interpreterProxy fetchWord: sourcePix ofObject: sourceMap) bitAnd: 16rFFFFFF]				ifFalse: ["Already in RGB format"						sourcePixSize = 32						ifTrue: [rgb _ sourcePix bitAnd: 16rFFFFFF]						ifFalse: ["Note could be faster"								rgb _ self rgbMap: sourcePix from: 5 to: 8]].			r _ r + ((rgb >> 16) bitAnd: 16rFF).			g _ g + ((rgb >> 8) bitAnd: 16rFF).			b _ b + (rgb bitAnd: 16rFF).			]].		].	(nPix = 0 or: [combinationRule=25 "PAINT" and: [nPix < (maxPix//2)]])		ifTrue: [^ 0  "All pixels were 0, or most were transparent"].	colorMap ~= nil		ifTrue: [bitsPerColor _ cmBitsPerColor]		ifFalse: [destPixSize = 16 ifTrue: [bitsPerColor _ 5].				destPixSize = 32 ifTrue: [bitsPerColor _ 8]].	d _ 8 - bitsPerColor.	rgb _ ((r // nPix >> d) << (bitsPerColor*2))		+ ((g // nPix >> d) << bitsPerColor)		+ ((b // nPix >> d)).	rgb = 0 ifTrue: [		"only generate zero if pixel is really transparent"		(r + g + b) > 0 ifTrue: [rgb _ 1]].	colorMap ~= nil		ifTrue: [^self colormapAt: rgb]		ifFalse: [^ rgb]! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 10/25/1999 19:24'!sourcePixAtX: x y: y pixPerWord: srcPixPerWord	| sourceWord index |	self inline: true.	(x < 0 or: [x >= srcWidth]) ifTrue: [^ 0].	(y < 0 or: [y >= srcHeight]) ifTrue: [^ 0].	index _ (y * sourcePitch) + ((x // srcPixPerWord) *4).	sourceWord _ self srcLongAt: sourceBits + index.	^ sourceWord >> ((32-sourcePixSize) - (x\\srcPixPerWord*sourcePixSize))! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 10/27/1999 17:10'!warpPickSmoothPixels: nPixels	xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	sourceMap: sourceMap	smoothing: n	"Pick n (sub-) pixels from the source form, mapped by sourceMap,	average the RGB values, map by colorMap and return the new word.	This version is only called from WarpBlt with smoothingCount > 1"	| rgb x y a r g b xx yy xdh ydh xdv ydv dstMask destWord i j k nPix |	self inline: false. "nope - too much stuff in here"	dstMask _ maskTable at: destPixSize.	destWord _ 0.	n = 2 "Try avoiding divides for most common n (divide by 2 is generated as shift)"		ifTrue:[xdh _ xDeltah // 2. ydh _ yDeltah // 2. 				xdv _ xDeltav // 2. ydv _ yDeltav // 2]		ifFalse:[xdh _ xDeltah // n. ydh _ yDeltah // n. 				xdv _ xDeltav // n. ydv _ yDeltav // n].	i _ nPixels.	[		x _ sx. y _ sy.		a _ r _ g _ b _ 0.		"Pick and average n*n subpixels"		nPix _ 0.  "actual number of pixels (not clipped and not transparent)"		j _ n.		[			xx _ x. yy _ y.			k _ n.			[				"get a single subpixel"				rgb _ self pickWarpPixelAtX: xx y: yy.				(combinationRule=25 "PAINT" and: [rgb = 0]) ifFalse:[					"If not clipped and not transparent, then tally rgb values"					nPix _ nPix + 1.					sourcePixSize < 16 ifTrue:[						"Get RGBA values from sourcemap table"						rgb _ interpreterProxy longAt: sourceMap + (rgb << 2).					] ifFalse:["Already in RGB format"						sourcePixSize = 16 								ifTrue:[rgb _ self rgbMap16To32: rgb]								ifFalse:[rgb _ self rgbMap32To32: rgb]].					b _ b + (rgb bitAnd: 255).					g _ g + (rgb >> 8 bitAnd: 255).					r _ r + (rgb >> 16 bitAnd: 255).					a _ a + (rgb >> 24)].				xx _ xx + xdh.				yy _ yy + ydh.			(k _ k - 1) = 0] whileFalse.			x _ x + xdv.			y _ y + ydv.		(j _ j - 1) = 0] whileFalse.		(nPix = 0 or: [combinationRule=25 "PAINT" and: [nPix < (n * n // 2)]]) ifTrue:[			rgb _ 0  "All pixels were 0, or most were transparent"		] ifFalse:[			"normalize rgba sums"			nPix = 4 "Try to avoid divides for most common n"				ifTrue:[r _ r >> 2.	g _ g >> 2.	b _ b >> 2.	a _ a >> 2]				ifFalse:[	r _ r // nPix.	g _ g // nPix.	b _ b // nPix.	a _ a // nPix].			rgb _ (a << 24) + (r << 16) + (g << 8) + b.			"map the pixel"			colorMap == nil "means we have different src/dst format"				ifTrue:[rgb _ self rgbMap32ToX: rgb]				ifFalse:[rgb _ self rgbMap32: rgb to: cmBitsPerColor].			rgb = 0 ifTrue: [				"only generate zero if pixel is really transparent"				(r + g + b + a) > 0 ifTrue: [rgb _ 1]].			colorMap = nil				ifFalse:[rgb _ self colormapAt: rgb].		].		"Mix it in (note: in theory we could avoid the bitAnd but its safer for now)"		destWord _ destWord bitOr: (rgb bitAnd: dstMask) << dstBitShift.		dstBitShift _ dstBitShift - destPixSize.		sx _ sx + xDeltah.		sy _ sy + yDeltah.	(i _ i - 1) = 0] whileFalse.	"*** side effect ***"	"*** only the first pixel fetch can be unaligned ***"	"*** prepare the next one for aligned access ***"	dstBitShift _ 32 - destPixSize. "Shift towards leftmost pixel"	^destWord! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 10/29/1999 00:08'!warpPickSourcePixels: nPixels	xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	"Pick n pixels from the source form,	map by colorMap and return aligned by dstBitShift.	This version is only called from WarpBlt with smoothingCount = 1"	| dstMask destWord nPix sourcePix destPix |	self inline: true. "Yepp - this should go into warpLoop"	dstMask _ maskTable at: destPixSize.	destWord _ 0.	nPix _ nPixels.	[		"Pick a single pixel"		sourcePix _ self pickWarpPixelAtX: sx y: sy.		destPix _ sourcePix.		sourcePixSize > 8 ifTrue:["Color map RGB pix"			cmDeltaBits = 0 ifFalse:[ "but only if necessary"				destPix _ self rgbMap: sourcePix.				(destPix = 0 and:[sourcePix ~= 0]) ifTrue:[destPix _ 1]]].		"map by colormap if necessary"		colorMap == nil			ifFalse:[destPix _ self colormapAt: destPix].		"Mix it in (note: in theory we could avoid the bitAnd but its safer for now)"		destWord _ destWord bitOr: (destPix bitAnd: dstMask) << dstBitShift.		dstBitShift _ dstBitShift - destPixSize.		sx _ sx + xDeltah.		sy _ sy + yDeltah.	(nPix _ nPix - 1) = 0] whileFalse.	"*** side effect ***"	"*** only the first pixel fetch can be unaligned ***"	"*** prepare the next one for aligned access ***"	dstBitShift _ 32 - destPixSize. "Shift towards leftmost pixel"	^destWord! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 10/23/1999 20:45'!warpSourcePixels: nPix xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	smoothing: n sourceMap: sourceMapOop	"Pick nPix pixels using these x- and y-incs, and map color if necess."	| destWord sourcePix sourcePixMask destPixMask srcPixPerWord destPix |	self inline: false.	sourcePixMask _ maskTable at: sourcePixSize.	destPixMask _ maskTable at: destPixSize.	srcPixPerWord _ 32 // sourcePixSize.	destWord _ 0.	1 to: nPix do:		[:i |		n > 1		ifTrue:			["Average n pixels and compute dest pixel from color map"			destPix _ (self smoothPix: n atXf: sx yf: sy				dxh: xDeltah//n dyh: yDeltah//n dxv: xDeltav//n dyv: yDeltav//n				pixPerWord: srcPixPerWord pixelMask: sourcePixMask				sourceMap: sourceMapOop)					bitAnd: destPixMask]		ifFalse:			["No smoothing -- just pick pixel and map if difft depths or color map supplied"			sourcePix _ (self sourcePixAtX: sx >> BinaryPoint									y: sy >> BinaryPoint									pixPerWord: srcPixPerWord)						bitAnd: sourcePixMask.			colorMap = nil				ifTrue:				[destPixSize = sourcePixSize				ifTrue:					[destPix _ sourcePix]				ifFalse:					[sourcePixSize >= 16 ifTrue:						["Map between RGB pixels"						sourcePixSize = 16							ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]							ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]					ifFalse: [destPix _ sourcePix bitAnd: destPixMask]]]			ifFalse:				[sourcePixSize >= 16 ifTrue:					["RGB pixels first get reduced to cmBitsPerColor"					sourcePixSize = 16						ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]						ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor]].				"Then look up sourcePix in colorMap"				destPix _ (self colormapAt: sourcePix) bitAnd: destPixMask]].		destPixSize = 32			ifTrue:[destWord _ destPix]			ifFalse:[destWord _ (destWord << destPixSize) bitOr: destPix].		sx _ sx + xDeltah.		sy _ sy + yDeltah.		].	^ destWord! !!BitBltSimulation methodsFor: 'memory access' stamp: 'ar 10/25/1999 19:22'!colormapAt: idx	"Return the word at position idx from the colorMap"	^interpreterProxy longAt: colorMap + (idx << 2)! !!BitBltSimulation methodsFor: 'memory access' stamp: 'ar 10/25/1999 19:22'!colormapAt: idx put: value	"Store the word at position idx in the colorMap"	^interpreterProxy longAt: colorMap + (idx << 2) put: value! !!BitBltSimulation methodsFor: 'memory access' stamp: 'ar 10/25/1999 19:23'!dstLongAt: idx	^interpreterProxy longAt: idx! !!BitBltSimulation methodsFor: 'memory access' stamp: 'ar 10/26/1999 18:08'!dstLongAt: idx put: value	^interpreterProxy longAt: idx put: value! !!BitBltSimulation methodsFor: 'memory access' stamp: 'ar 12/7/1999 21:09'!dstLongAt: idx put: srcValue mask: dstMask	"Store the given value back into destination form, using dstMask	to mask out the bits to be modified. This is an essiantial	read-modify-write operation on the destination form."	| dstValue |	self inline: true.	dstValue _ self dstLongAt: idx.	dstValue _ dstValue bitAnd: dstMask.	dstValue _ dstValue bitOr: srcValue.	self dstLongAt: idx put: dstValue.! !!BitBltSimulation methodsFor: 'memory access' stamp: 'ar 10/25/1999 19:22'!halftoneAt: idx	"Return a value from the halftone pattern."	^interpreterProxy longAt: halftoneBase + (idx \\ halftoneHeight * 4)! !!BitBltSimulation methodsFor: 'memory access' stamp: 'ar 10/25/1999 19:23'!srcLongAt: idx	^interpreterProxy longAt: idx! !!BitBltSimulation methodsFor: 'color mapping' stamp: 'ar 12/7/1999 21:08'!rgbMap16: sourcePixel downTo: nBitsOut	"Convert the given 16bit pixel value to a color map index 	using nBitsOut bits for each color component. 	Note: This method is intended to deal with different source formats."	| delta |	self inline: true.	delta _ 5 - nBitsOut.	"note: evaluated strictly left to right"	^((sourcePixel >> 10 bitAnd: 31) >> delta) << nBitsOut +		((sourcePixel >> 5 bitAnd: 31) >> delta) << nBitsOut +			((sourcePixel bitAnd: 31) >> delta)! !!BitBltSimulation methodsFor: 'color mapping' stamp: 'ar 12/7/1999 21:08'!rgbMap16: sourcePixel to: nBitsOut	"Convert the given 16bit pixel value to a color map index 	using nBitsOut bits for each color component. 	Note: This method is intended to deal with different source formats."	self inline: true.	nBitsOut > 5		ifTrue:[^self rgbMap16: sourcePixel upTo: nBitsOut]		ifFalse:[^self rgbMap16: sourcePixel downTo: nBitsOut]! !!BitBltSimulation methodsFor: 'color mapping' stamp: 'ar 12/7/1999 21:07'!rgbMap16: sourcePixel upTo: nBitsOut	"Convert the given 16bit pixel value to a color map index 	using nBitsOut bits for each color component. 	Note: This method is intended to deal with different source formats."	| delta |	self inline: true.	delta _ nBitsOut - 5.	"note: evaluated strictly left to right"	^((sourcePixel >> 10 bitAnd: 31) << (5 + delta)) +		(sourcePixel >> 5 bitAnd: 31) << (5 + delta) +			(sourcePixel bitAnd: 31) << (delta)! !!BitBltSimulation methodsFor: 'color mapping' stamp: 'ar 10/28/1999 16:02'!rgbMap16To32: sourcePixel	"Convert the given 16bit pixel value to a 32bit RGBA value. 	Note: This method is intended to deal with different source formats."	^(((sourcePixel bitAnd: 31) << 3) bitOr:		((sourcePixel bitAnd: 16r3E0) << 6)) bitOr:			((sourcePixel bitAnd: 16r7C00) << 9)! !!BitBltSimulation methodsFor: 'color mapping' stamp: 'ar 10/28/1999 16:03'!rgbMap16ToX: sourcePixel	"Convert the given 16 pixel value to a color value in destination format.	Note: This method is intended to deal with different destination formats."	destPixSize = 32		ifTrue:[^self rgbMap16To32: sourcePixel]		ifFalse:[^sourcePixel]	"The above assumes that the caller is pickSourcePixels: using the standard	16bit to 32bit conversion"! !!BitBltSimulation methodsFor: 'color mapping' stamp: 'ar 12/7/1999 21:07'!rgbMap32: sourcePixel to: nBitsOut	"Convert the given 32bit pixel value to a color map index 	using nBitsOut bits for each color component. 	Note: This method is intended to deal with different source formats."	| delta |	self inline: true.	delta _ 8 - nBitsOut.	"note: evaluated strictly left to right"	^((sourcePixel >> 16 bitAnd: 255) >> delta) << nBitsOut +		((sourcePixel >> 8 bitAnd: 255) >> delta) << nBitsOut +			((sourcePixel bitAnd: 255) >> delta)! !!BitBltSimulation methodsFor: 'color mapping' stamp: 'ar 10/27/1999 14:28'!rgbMap32To32: sourcePixel	"Convert the given 32bit pixel value to a 32bit RGBA value. 	Note: This method is intended to deal with different source formats."	^sourcePixel "For now do it simple"! !!BitBltSimulation methodsFor: 'color mapping' stamp: 'ar 10/27/1999 17:31'!rgbMap32ToX: sourcePixel	"Convert the given 32bit pixel value to a color value in destination format.	Note: This method is intended to deal with different destination formats."	destPixSize = 16		ifTrue:[^self rgbMap32: sourcePixel to: 5]		ifFalse:[^sourcePixel]	"The above assumes that the caller is pickSourcePixels: using the standard	32bit to 16bit conversion"! !!BitBltSimulation methodsFor: 'surface support' stamp: 'ar 10/25/1999 22:21'!lockSurfaces	"Get a pointer to the bits of any OS surfaces."	"Note: The VM support code must robustly handle multiple attempts to lock	the same surface and return the same values since one might blt just a portion	of the surface from one location to another (see below; ioLockSurfaceBits()	is called twice if sourceForm == destForm)."	"Note: It is possible to query for the actual regions (e.g., after clipping)	that might be affected by the BB operation during ioLockSurfaceBits since	clipping is always performed before ioLockSurfaceBits is called. This	might an improvement on some platforms (e.g., Unix w/ X-Windows) where	getting actual bits requires a round-trip to the server. Right now we don't	have accessors for these values (basically sx, sy, dx, dy, bbW, and bbH)	but it would be trivial to add them -- iff somebody is interested..."	"ar 10/20/1999: Just noted that the above is not true for scanCharacters..."	"ar 10/19/1999: This *should* be inlined but how do we pass a pointer to the pitch	of the surfaces in this case?!!"	| surfaceHandle |	self inline: true. "If the CCodeGen learns how to inline #cCode: methods"	hasSurfaceLock _ false.	destBits == 0 ifTrue:["Blitting *to* OS surface"		surfaceHandle _ interpreterProxy fetchInteger: FormBitsIndex ofObject: destForm.		"destBits _ self cCode: 'ioLockSurfaceBits(surfaceHandle, &destPitch)'."		hasSurfaceLock _ true.	].	(sourceBits == 0 and:[noSource not]) ifTrue:["Blitting *from* OS surface"		surfaceHandle _ interpreterProxy fetchInteger: FormBitsIndex ofObject: sourceForm.		"sourceBits _ self cCode:'ioLockSurfaceBits(surfaceHandle, &sourcePitch)'."		hasSurfaceLock _ true.	].	^destBits ~~ 0 and:[sourceBits ~~ 0 or:[noSource]].! !!BitBltSimulation methodsFor: 'surface support' stamp: 'ar 12/7/1999 21:05'!queryDestSurface: handle	"Query the dimension of an OS surface.	This method is provided so that in case the inst vars of the	source form are broken, *actual* values of the OS surface	can be obtained. This might, for instance, happen if the user	resizes the main window.	Note: Moved to a separate function for better inlining of the caller."	"^(self cCode:'ioGetSurfaceFormat(handle, &destWidth, &destHeight, &destPixSize, &dstFormat)')		~~ 0"	^false! !!BitBltSimulation methodsFor: 'surface support' stamp: 'ar 12/7/1999 21:05'!querySourceSurface: handle	"Query the dimension of an OS surface.	This method is provided so that in case the inst vars of the	source form are broken, *actual* values of the OS surface	can be obtained. This might, for instance, happen if the user	resizes the main window.	Note: Moved to a separate function for better inlining of the caller."	"^(self cCode:'ioGetSurfaceFormat(handle, &srcWidth, &srcHeight, &sourcePixSize, &srcFormat)')		~~ 0"	^false! !!BitBltSimulation methodsFor: 'surface support' stamp: 'ar 10/25/1999 22:22'!unlockSurfaces	"Unlock the bits of any OS surfaces."	"Note: It is possible to query for the dirty rectangle from ioUnlockSurfaceBits()	since the affected regions are set before this method is called. This is currently	not part of the InterpreterProxy interface but one can query for affectedLeft(),	affectedRight(), affectedTop(), and affectedBottom() if the surface support	is compiled with the VM."	| surfaceHandle |	hasSurfaceLock ifTrue:[		surfaceHandle _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.		(interpreterProxy isIntegerObject: surfaceHandle) ifTrue:[			surfaceHandle _ interpreterProxy integerValueOf: surfaceHandle.			"self ioUnlockSurfaceBits: surfaceHandle."			sourceBits _ sourcePitch _ 0.		].		surfaceHandle _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		(interpreterProxy isIntegerObject: surfaceHandle) ifTrue:[			surfaceHandle _ interpreterProxy integerValueOf: surfaceHandle.			"self ioUnlockSurfaceBits: surfaceHandle."			destBits _ destPitch _ 0.		].		hasSurfaceLock _ false.	].! !!BitBltSimulation class methodsFor: 'translation' stamp: 'ar 10/28/1999 22:13'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'opTable'		declareC: 'int opTable[' , OpTableSize printString , ']'.	aCCodeGenerator var: 'maskTable'		declareC:'int maskTable[33] = {0, 1, 3, 0, 15, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}'.	aCCodeGenerator var: 'ditherMatrix4x4'		declareC:'const int ditherMatrix4x4[16] = {0,	8,	2,	10,12,	4,	14,	6,3,	11,	1,	9,15,	7,	13,	5}'.	aCCodeGenerator var: 'ditherThresholds16'		declareC:'const int ditherThresholds16[8] = { 0, 2, 4, 6, 8, 12, 14, 16 }'.	aCCodeGenerator var: 'ditherValues16'		declareC:'const int ditherValues16[32] = {0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}'.	aCCodeGenerator var: 'warpBitShiftTable'		declareC:'int warpBitShiftTable[32]'.! !!BitBltSimulation class methodsFor: 'system simulation' stamp: 'ar 10/27/1999 23:34'!copyBitsFrom: aBitBlt	"Simulate the copyBits primitive"	| proxy bb |	proxy _ InterpreterProxy new.	proxy loadStackFrom: thisContext sender.	bb _ self simulatorClass new.	bb setInterpreter: proxy.	proxy success: (bb loadBitBltFrom: aBitBlt).	bb copyBits.	proxy failed ifFalse:[		proxy showDisplayBits: aBitBlt destForm 				Left: bb affectedLeft Top: bb affectedTop 				Right: bb affectedRight Bottom: bb affectedBottom].	^proxy stackValue: 0! !!BitBltSimulation class methodsFor: 'system simulation' stamp: 'ar 10/27/1999 14:06'!simulatorClass	^BitBltSimulator! !!BitBltSimulation class methodsFor: 'system simulation' stamp: 'ar 10/27/1999 23:35'!warpBitsFrom: aBitBlt	"Simulate the warpBits primitive"	| proxy bb |	proxy _ InterpreterProxy new.	proxy loadStackFrom: thisContext sender.	bb _ self simulatorClass new.	bb setInterpreter: proxy.	proxy success: (bb loadWarpBltFrom: aBitBlt).	bb warpBits.	proxy failed ifFalse:[		proxy showDisplayBits: aBitBlt destForm 				Left: bb affectedLeft Top: bb affectedTop 				Right: bb affectedRight Bottom: bb affectedBottom].	^proxy stackValue: 0! !!BitBltSimulator methodsFor: 'as yet unclassified' stamp: 'ar 10/28/1999 22:13'!initBBOpTable	opTable _ OpTable.	maskTable _ Array new: 32.	#(1 2 4 8 16 32) do:[:i| maskTable at: i put: (1 << i)-1].	self initializeDitherTables.	warpBitShiftTable _ CArrayAccessor on: (Array new: 32).! !!BitBltSimulator methodsFor: 'debug support' stamp: 'ar 10/27/1999 14:22'!dstLongAt: dstIndex	interpreterProxy isInterpreterProxy		ifTrue:[^dstIndex longAt: 0].	((dstIndex anyMask: 3) or:[dstIndex + 4 < destBits or:[		dstIndex > (destBits + (destPitch * destHeight))]])			ifTrue:[self error:'Out of bounds'].	^interpreterProxy longAt: dstIndex! !!BitBltSimulator methodsFor: 'debug support' stamp: 'ar 10/27/1999 14:23'!dstLongAt: dstIndex put: value	interpreterProxy isInterpreterProxy		ifTrue:[^dstIndex longAt: 0 put: value].	((dstIndex anyMask: 3) or:[dstIndex < destBits or:[		dstIndex >= (destBits + (destPitch * destHeight))]])			ifTrue:[self error:'Out of bounds'].	^interpreterProxy longAt: dstIndex put: value! !!BitBltSimulator methodsFor: 'debug support' stamp: 'ar 10/27/1999 14:22'!srcLongAt: srcIndex	interpreterProxy isInterpreterProxy		ifTrue:[^srcIndex longAt: 0].	((srcIndex anyMask: 3) or:[srcIndex + 4 < sourceBits or:[		srcIndex > (sourceBits + (sourcePitch * srcHeight))]])			ifTrue:[self error:'Out of bounds'].	^interpreterProxy longAt: srcIndex! !!BitBltSimulator class methodsFor: 'instance creation' stamp: 'ar 10/27/1999 14:16'!new	^super new initBBOpTable.! !!Interpreter methodsFor: 'I/O primitives' stamp: 'ar 10/27/1999 16:03'!primitiveWarpBits	"Invoke the warpBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: self argCount.	self success: (self loadWarpBltFrom: rcvr).	successFlag ifTrue: [		self warpBits.		self showDisplayBits.	].! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 10/27/1999 14:13'!fetchIntegerOrTruncFloat: fieldIndex ofObject: objectPointer	"Support for BitBlt simulation only"	| intOrFloat |	intOrFloat _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOrFloat) ifTrue: [^ self integerValueOf: intOrFloat].	intOrFloat isFloat ifTrue:[^intOrFloat truncated].	^self primitiveFail.! !!InterpreterProxy methodsFor: 'private' stamp: 'ar 10/27/1999 14:21'!isInterpreterProxy	"Return true since I am not a real Interpreter simulation"	^true! !!InterpreterSimulator methodsFor: 'testing' stamp: 'ar 10/27/1999 14:21'!isInterpreterProxy	"Return false since I am a real Interpreter simulation"	^false! !!InterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'ar 10/27/1999 18:17'!loadWarpBltFrom: bbObj	^ myBitBlt loadWarpBltFrom: bbObj! !!InterpreterSimulator methodsFor: 'file primitives' stamp: 'ar 10/24/1999 17:05'!primitiveFileOpen	| namePointer writeFlag fileName f |	writeFlag _ self booleanValueOf: self stackTop.	namePointer _ self stackValue: 1.	self success: (self isBytes: namePointer).	successFlag ifTrue:		[fileName _ self stringOf: namePointer.		filesOpen addLast: (writeFlag			ifTrue: [(FileStream fileNamed: fileName) binary]			ifFalse: [(StandardFileStream isAFileNamed: fileName)				ifTrue: [f _ (FileStream oldFileNamed: fileName).						f ifNil:[^self primitiveFail] ifNotNil:[f readOnly; binary]]				ifFalse: [^ self primitiveFail]]).		self pop: 3.  "rcvr, name, write"		self pushInteger: filesOpen size]! !!InterpreterSimulatorLSB methodsFor: 'debug support' stamp: 'ar 10/24/1999 21:47'!displayForm: f	| width height depth bits realForm simDisp realDisp |	bits _ self fetchPointer: 0 ofObject: f.	width _ self fetchInteger: 1 ofObject: f.	height _ self fetchInteger: 2 ofObject: f.	depth _ self fetchInteger: 3 ofObject: f.	realForm _ Form extent: width@height depth: depth.	simDisp _ Form new hackBits: memory.	realDisp _ Form new hackBits: realForm bits.	realDisp		copy: (0 @ 0 extent: 4 @ realForm bits size)		from: (0 @ (bits + 4 // 4))		in: simDisp		rule: Form over.	realForm displayOn: Display at: 0@0.! !!WarpBlt methodsFor: 'system simulation' stamp: 'ar 10/27/1999 23:48'!warpBitsSimulated	"Simulate WarpBlt"	self warpBitsSimulated: cellSize		sourceMap: (sourceForm colormapIfNeededForDepth: 32).! !!WarpBlt methodsFor: 'system simulation' stamp: 'ar 10/27/1999 23:47'!warpBitsSimulated: n sourceMap: sourceMap	"Simulate WarpBlt"	BitBltSimulation warpBitsFrom: self.! !BitBltSimulation removeSelector: #pickSourcePixelsNullMap:srcMask:destMask:!BitBltSimulation removeSelector: #pickSourcePixels:srcMask:destMask:!BitBltSimulation removeSelector: #pickSourcePixelsRGB:nullMap:srcMask:destMask:!