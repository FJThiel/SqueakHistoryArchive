'From Squeak2.8alpha of 16 February 2000 [latest update: #2211] on 25 May 2000 at 6:26:28 pm'!"Change Set:		FXBlt-AlphaDate:			25 May 2000Author:			Andreas RaabAn alpha release of FXBlt. While there are still a couple of things missing (most noticably the display string primitive) it is a working version. This version is intended to be run for tracking down remaining incompatibilities with BitBlt.A plugin is required for running FXBlt. The plugin C code can be generated by executing 	FXBltSimulation translate.Again, there are few remaining issues - I haven't upgraded the CCodeGen yet to actually generate specialized versions of the inner loop which will make it slower than need be.True alpha testers should try to use FXBlt for their daily work in Morphic. The way to do it is trivial - just make Form>>defaultCanvasClass return FXFormCanvas instead of FormCanvas. From then on, everything in Morphic will use the new version. Please report any strange effects back so these can be fixed.Also, if you want to see something really weird, you may replace the bits of Display with an instance of Pixmap. This will show you how FXBlt deals with different pixel formats (that is, a Pixmap will be treated as containing LSB pixels whereas a Bitmap will be treated as containing MSB pixels). Here's a simple example of it:	| lsbForm |	lsbForm _ Form 		extent: Display extent 		depth: Display depth 		bits: (Pixmap new: Display bits size).	(FXBlt toForm: lsbForm)		copy: lsbForm boundingBox		from: 0@0		in: Display.	lsbForm display.	self inform:'All pixels should be reversed'.	(FXBlt toForm: Display)		copy: Display boundingBox		from: 0@0		in: lsbForm.	self inform:'All pixels should be okay'." !Object subclass: #ColorMap	instanceVariableNames: 'shifts masks colors '	classVariableNames: ''	poolDictionaries: ''	category: 'Experimental-FXBlt'!ColorMap class	instanceVariableNames: ''!Object subclass: #FXBlt	instanceVariableNames: 'destForm sourceForm halftoneForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight colorMap sourceMap destMap warpQuad warpQuality sourceKey destKey sourceAlpha tallyMap raiseErrors '	classVariableNames: 'RecursionLock '	poolDictionaries: ''	category: 'Experimental-FXBlt'!!FXBlt commentStamp: '<historical>' prior: 0!"Copy all methods from BitBlt"| from to |from _ BitBlt class.to _ FXBlt class.from selectorsDo:[:sel|	to compile: (from sourceCodeAt: sel) classified: (from organization categoryOfElement: sel)].Instance variables:	destForm	<Form>	Target form	sourceForm	<Form>	Source form	pattern		<Bitmap>	Fill or mask pattern	combinationRule	<Integer>	Describes the operation to perform	destRect		<Rectangle>	Destination rectangle of operation	clipRect		<Rectangle>	Destination clip rectangle of operation	sourceOrigin	<Point>	Offset in source form	sourceMap	<ColorMap>	Mapping from source pixels into 'operational depth'	destMap		<ColorMap>	Mapping from dest pixels into 'operational depth'	colorMap	<ColorMap>	Mapping from 'operational depth' into destination depth	warpQuad	<Array of: Integer>	Warp rectangle	warpQuality	<Integer>	Sampling rate for warps	sourceKey	<Integer>	Source color key	destKey		<Integer>	Destination color key	sourceAlpha	<Integer>	Constant source alpha	tallyMap	<Bitmap>		Map for tallying pixels.!FXBlt class	instanceVariableNames: ''!InterpreterPlugin subclass: #FXBltSimulation	instanceVariableNames: 'bitBltOop destForm sourceForm halftoneForm combinationRule destX destY sourceX sourceY width height clipX clipY clipWidth clipHeight destBits destWidth destHeight destDepth destPitch destPPW destMSB destIndex destDelta sourceBits sourceWidth sourceHeight sourceDepth sourcePitch sourcePPW sourceMSB sourceIndex sourceDelta noColorMap colorMap cmMask cmShiftTable cmMaskTable noDestMap destMap dmMask dmShiftTable dmMaskTable noSourceMap sourceMap smMask smShiftTable smMaskTable tallyMap tallyMapSize sourceAlpha sourceAlphaKey destAlphaKey srcKeyMode dstKeyMode bitCount skew mask1 mask2 preload nWords destMask hDir vDir sx sy dx dy bbW bbH halftoneHeight noSource noHalftone halftoneBase srcBitShift dstBitShift pixelDepth cmCache affectedL affectedR affectedT affectedB opTable maskTable ditherMatrix4x4 ditherThresholds16 ditherValues16 hasSurfaceLock noWarp warpQuad warpQuality warpSrcShift warpSrcMask warpAlignShift warpAlignMask warpBitShiftTable unlockSurfaceFn querySurfaceFn lockSurfaceFn '	classVariableNames: 'AllOnes AlphaIndex BBClipHeightIndex BBClipWidthIndex BBClipXIndex BBClipYIndex BBColorMapIndex BBDestFormIndex BBDestXIndex BBDestYIndex BBHalftoneFormIndex BBHeightIndex BBRuleIndex BBSourceFormIndex BBSourceXIndex BBSourceYIndex BBWidthIndex BinaryPoint BlueIndex ColorCacheMask ColorCacheSize FXDestKeyIndex FXDestMapIndex FXSourceAlphaIndex FXSourceKeyIndex FXSourceMapIndex FXTallyMapIndex FXWarpQuadIndex FXWarpQualityIndex FixedPt1 FormBitsIndex FormDepthIndex FormHeightIndex FormWidthIndex GreenIndex InvalidColorCacheEntry OpTable OpTableSize RedIndex '	poolDictionaries: ''	category: 'Experimental-FXBlt'!!FXBltSimulation commentStamp: '<historical>' prior: 0!This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (for old paint mode)	17	fail (for old mask mode)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	OLDrgbDiff: sourceWord with: destinationWord	23	OLDtallyIntoMap: destinationWord -- old vers doesn't clip to bit boundary	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord	30	alphaBlendConst: sourceWord with: destinationWord -- alpha passed as an arg	31	alphaPaintConst: sourceWord with: destinationWord -- alpha passed as an arg	32	rgbDiff: sourceWord with: destinationWord	33	tallyIntoMap: destinationWord	34	alphaBlendScaled: sourceWord with: destinationWord	35	srcPaint: sourceWord with: destinationWord	36	dstPaint: sourceWord with: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.To add a new rule to BitBlt...	1.  add the new rule method or methods in the category 'combination rules' of BBSim	2.  describe it in the class comment  of BBSim and in the class comment for BitBlt	3.  add refs to initializeRuleTable in proper positions	4.  add refs to initBBOpTable, following the pattern!FXBltSimulation class	instanceVariableNames: ''!FXBltSimulation subclass: #FXBltSimulator	instanceVariableNames: ''	classVariableNames: 'ColorCacheHits ColorCacheMisses '	poolDictionaries: ''	category: 'Experimental-FXBlt'!FXBltSimulator class	instanceVariableNames: ''!FXBlt subclass: #FXGrafPort	instanceVariableNames: 'fillPattern '	classVariableNames: ''	poolDictionaries: ''	category: 'Experimental-FXBlt'!FormCanvas subclass: #FXFormCanvas	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Experimental-FXBlt'!ArrayedCollection variableWordSubclass: #Pixmap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Experimental-FXBlt'!!Pixmap commentStamp: 'ar 5/25/2000 17:55' prior: 0!A Pixmap is like a Bitmap. The only difference is that it stores the pixels in reverse order. Where a Bitmap stores the left most pixel in the most significant bits of a word, a Pixmap stores its left most pixel in the least significant bits. That's all.Why do we need Pixmaps?!! They optimize certain drawing routines if it is known that the host OS is itself in Pixmap format. Copy-and-reverse operations of bits (which are supported by FXBlt) are much more expensive than simple copy operations where the bits are already in the same order. !!BitBlt methodsFor: 'accessing' stamp: 'ar 2/21/2000 22:06'!isFXBlt	^false! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 5/25/2000 16:36'!generatePerform: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: '('.	(msgNode args copyFrom: 2 to: msgNode args size) do:[:arg|		self emitCExpression: arg on: aStream.	] separatedBy:[aStream nextPutAll:', '].	aStream nextPutAll:')'.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'ar 5/25/2000 16:36'!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	translationDict _ Dictionary new: 200.	pairs _ #(	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateSequentialAnd:on:indent:	#or:			#generateSequentialOr:on:indent:	#not			#generateNot:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#*				#generateTimes:on:indent:	#/				#generateDivide:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<				#generateShiftLeft:on:indent:	#>>				#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:			#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#bitInvert32	#generateBitInvert32:on:indent:	#<				#generateLessThan:on:indent:	#<=				#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=				#generateGreaterThanOrEqual:on:indent:	#~=				#generateNotEqual:on:indent:	#==				#generateEqual:on:indent:	#~~				#generateNotEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue: 	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#whileTrue 		#generateDoWhileTrue:on:indent:	#whileFalse		#generateDoWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#ifTrue:		#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#basicAt:		#generateAt:on:indent:	#basicAt:put:	#generateAtPut:on:indent:	#integerValueOf:	#generateIntegerValueOf:on:indent:	#integerObjectOf:	#generateIntegerObjectOf:on:indent:	#isIntegerObject: 	#generateIsIntegerObject:on:indent:	#cCode:				#generateInlineCCode:on:indent:	#cCode:inSmalltalk:	#generateInlineCCode:on:indent:	#cCoerce:to:			#generateCCoercion:on:indent:	#preIncrement		#generatePreIncrement:on:indent:	#preDecrement		#generatePreDecrement:on:indent:	#inline:				#generateInlineDirective:on:indent:	#sharedCodeNamed:inCase:	#generateSharedCodeDirective:on:indent:	#asFloat				#generateAsFloat:on:indent:	#asInteger			#generateAsInteger:on:indent:	#anyMask:			#generateBitAnd:on:indent:	#raisedTo:			#generateRaisedTo:on:indent:	#perform:						#generatePerform:on:indent:	#perform:with:					#generatePerform:on:indent:	#perform:with:with:				#generatePerform:on:indent:	#perform:with:with:with:		#generatePerform:on:indent:	#perform:with:with:with:with:	#generatePerform:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:54'!alphaMask	^masks at: 4! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:55'!alphaMask: value	masks at: 4 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!alphaShift	^shifts at: 4! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!alphaShift: value	shifts at: 4 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:39'!at: index	^colors at: index! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:39'!at: index put: value	^colors at: index put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!blueMask	^masks at: 3! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!blueMask: value	masks at: 3 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!blueShift	^shifts at: 3! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:32'!blueShift: value	shifts at: 3 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 2/10/2000 17:12'!colors	^colors! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:32'!greenMask	^masks at: 2! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:32'!greenMask: value	masks at: 2 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:32'!greenShift	^shifts at: 2! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:36'!greenShift: value	shifts at: 2 put: value.! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:36'!redMask	^masks at: 1! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:37'!redMask: value	masks at: 1 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:37'!redShift	^shifts at: 1! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:37'!redShift: value	shifts at: 1 put: value! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 1/16/2000 20:52'!mapPixel: pixelValue	"Perform a forward pixel mapping operation"	| pv |	(shifts == nil and:[masks == nil]) ifFalse:[		pv _ (((pixelValue bitAnd: self redMask) bitShift: self redShift) bitOr:			((pixelValue bitAnd: self greenMask) bitShift: self greenShift)) bitOr:			(((pixelValue bitAnd: self blueMask) bitShift: self blueShift) bitOr:			((pixelValue bitAnd: self alphaMask) bitShift: self alphaShift)).	] ifTrue:[pv _ pixelValue].	colors == nil		ifTrue:[^pv]		ifFalse:[^colors at: pv].! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 1/16/2000 20:52'!pixelMap: pixelValue	"Perform a reverse pixel mapping operation"	| pv |	colors == nil		ifTrue:[pv _ pixelValue]		ifFalse:[pv _ colors at: pixelValue].	(shifts == nil and:[masks == nil]) 		ifTrue:[^pv]		ifFalse:[^(((pv bitAnd: self redMask) bitShift: self redShift) bitOr: 				((pv bitAnd: self greenMask) bitShift: self greenShift)) bitOr:					(((pv bitAnd: self blueMask) bitShift: self blueShift) bitOr: 						((pv bitAnd: self alphaMask) bitShift: self alphaShift))]! !!ColorMap methodsFor: 'private' stamp: 'ar 2/22/2000 16:47'!setShifts: shiftArray masks: maskArray colors: colorArray	shiftArray ifNotNil:[shifts _ shiftArray asIntegerArray].	maskArray ifNotNil:[masks _ maskArray asWordArray].	colorArray ifNotNil:[colors _ colorArray asWordArray].! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 2/22/2000 14:08'!colors: colorArray	^self new setShifts: nil masks: nil colors: colorArray! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 1/16/2000 16:02'!shifts: shiftArray masks: maskArray	^self shifts: shiftArray masks: maskArray colors: nil.! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 1/16/2000 16:02'!shifts: shiftArray masks: maskArray colors: colorArray	^self new setShifts: shiftArray masks: maskArray colors: colorArray! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!clipHeight	^clipHeight! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!clipHeight: anInteger 	"Set the receiver's clipping area height to be the argument, anInteger."	clipHeight _ anInteger! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!clipRect	"Answer the receiver's clipping area rectangle."	^clipX @ clipY extent: clipWidth @ clipHeight! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!clipRect: aRectangle 	"Set the receiver's clipping area rectangle to be the argument, aRectangle."	clipX _ aRectangle left.	clipY _ aRectangle top.	clipWidth _ aRectangle width.	clipHeight _ aRectangle height! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!clipWidth	^clipWidth! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!clipWidth: anInteger 	"Set the receiver's clipping area width to be the argument, anInteger."	clipWidth _ anInteger! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!clipX	^clipX! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!clipX: anInteger 	"Set the receiver's clipping area top left x coordinate to be the argument, 	anInteger."	clipX _ anInteger! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!clipY	^clipY! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!clipY: anInteger 	"Set the receiver's clipping area top left y coordinate to be the argument, 	anInteger."	clipY _ anInteger! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!colorMap	^ colorMap! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/17/2000 21:54'!colorMap: map	"See last part of BitBlt comment. 6/18/96 tk"	colorMap _ map.	"As long as we need to fix problems with colorMaps"	map ifNotNil:[		(map isKindOf: ColorMap) ifFalse:[			map size < 256 ifTrue:[				colorMap _ ColorMap shifts: nil masks: nil colors: map.			] ifFalse:[ sourceForm 					ifNil:["Can't fix -- ignore". colorMap _ nil]					ifNotNil:[colorMap _ sourceForm colormapIfNeededFor: destForm]]]].! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!combinationRule	^combinationRule! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!combinationRule: anInteger 	"Set the receiver's combination rule to be the argument, anInteger, a 	number in the range 0-15."	combinationRule _ anInteger! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!destForm	^ destForm! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!destForm: aForm	destForm _ aForm! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 23:37'!destMap	^destMap! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 23:37'!destMap: aColorMap	destMap _ aColorMap! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!destOrigin: aPoint 	"Set the receiver's destination top left coordinates to be those of the 	argument, aPoint."	destX _ aPoint x.	destY _ aPoint y! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!destRect	"The rectangle we are about to blit to or just blitted to.  "	^ destX @ destY extent: width @ height! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!destRect: aRectangle 	"Set the receiver's destination form top left coordinates to be the origin of 	the argument, aRectangle, and set the width and height of the receiver's 	destination form to be the width and height of aRectangle."	destX _ aRectangle left.	destY _ aRectangle top.	width _ aRectangle width.	height _ aRectangle height! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!destX: anInteger 	"Set the top left x coordinate of the receiver's destination form to be the 	argument, anInteger."	destX _ anInteger! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!destX: x destY: y width: w height: h	"Combined init message saves 3 sends from DisplayScanner"	destX _ x.	destY _ y.	width _ w.	height _ h.! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!destY: anInteger 	"Set the top left y coordinate of the receiver's destination form to be the 	argument, anInteger."	destY _ anInteger! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!fillColor	^ halftoneForm! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/17/2000 20:47'!fillColor: aColorOrPattern 	"The destForm will be filled with this color or pattern of colors.  May be an old Color, a new type Color, a Bitmap (see BitBlt comment), a Pattern, or a Form.  6/18/96 tk"	aColorOrPattern == nil ifTrue: [halftoneForm _ nil. ^ self].	destForm == nil ifTrue: [self error: 'Must set destForm first'].	"aColorOrPattern isColor ifFalse:[		self traceProblem:'fillColor is not Color' from: thisContext sender]."	halftoneForm _ aColorOrPattern bitPatternForDepth: destForm depth! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!height: anInteger 	"Set the receiver's destination form height to be the argument, anInteger."	height _ anInteger! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/21/2000 22:06'!isFXBlt	^true! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/13/2000 16:31'!raiseErrors: aBoolean	raiseErrors _ aBoolean! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!sourceForm	^ sourceForm! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!sourceForm: aForm 	"Set the receiver's source form to be the argument, aForm."	sourceForm _ aForm! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/17/2000 22:06'!sourceKey	^sourceKey! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/17/2000 22:06'!sourceKey: aKey	sourceKey _ aKey! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 23:37'!sourceMap	^sourceMap! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 23:37'!sourceMap: aColorMap	sourceMap _ aColorMap! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!sourceOrigin: aPoint 	"Set the receiver's source form coordinates to be those of the argument, 	aPoint."	sourceX _ aPoint x.	sourceY _ aPoint y! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!sourceRect: aRectangle 	"Set the receiver's source form top left x and y, width and height to be 	the top left coordinate and extent of the argument, aRectangle."	sourceX _ aRectangle left.	sourceY _ aRectangle top.	width _ aRectangle width.	height _ aRectangle height! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!sourceX: anInteger 	"Set the receiver's source form top left x to be the argument, anInteger."	sourceX _ anInteger! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!sourceX: sx sourceY: sy destX: x destY: y width: w height: h	"Combined init message saves sends from DisplayScanner"	sourceX _ sx.	sourceY _ sy.	destX _ x.	destY _ y.	width _ w.	height _ h.! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!sourceY: anInteger 	"Set the receiver's source form top left y to be the argument, anInteger."	sourceY _ anInteger! !!FXBlt methodsFor: 'accessing' stamp: 'ar 2/9/2000 19:21'!width: anInteger 	"Set the receiver's destination form width to be the argument, anInteger."	width _ anInteger! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 19:21'!copy: destRectangle from: sourcePt in: srcForm	| destOrigin |	sourceForm _ srcForm.	halftoneForm _ nil.	combinationRule _ 3.  "store"	destOrigin _ destRectangle origin.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourcePt x.	sourceY _ sourcePt y.	width _ destRectangle width.	height _ destRectangle height.	self copyBits! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 21:12'!copy: destRectangle from: sourcePt in: srcForm fillColor: hf rule: rule	"Specify a Color to fill, not a Form. 6/18/96 tk"  	| destOrigin |	sourceForm _ srcForm.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ rule.	destOrigin _ destRectangle origin.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourcePt x.	sourceY _ sourcePt y.	width _ destRectangle width.	height _ destRectangle height.	srcForm == nil ifFalse:		[colorMap _ srcForm colormapIfNeededFor: destForm].	^ self copyBits! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 19:21'!copy: destRectangle from: sourcePt in: srcForm halftoneForm: hf rule: rule 	| destOrigin |	sourceForm _ srcForm.	self fillColor: hf.		"sets halftoneForm"	combinationRule _ rule.	destOrigin _ destRectangle origin.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourcePt x.	sourceY _ sourcePt y.	width _ destRectangle width.	height _ destRectangle height.	self copyBits! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/19/2000 20:18'!copyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	| result |	result _ self primCopyBits.	result == nil ifFalse:[^result].raiseErrors == true ifTrue:[^self primitiveFailed].	self recover ifTrue:[^self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 19:21'!copyBitsSimulated	^FXBltSimulation copyBitsFrom: self.! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 21:11'!copyBitsTranslucent: factor	"This entry point to BitBlt supplies an extra argument to specify translucency	for operations 30 and 31.  The argument must be an integer between 0 and 255."	sourceAlpha _ factor.	sourceForm ifNotNil:[sourceMap _ sourceForm colormapToARGB].	destMap _ destForm colormapToARGB.	colorMap _ destForm colormapFromARGB.	^self copyBits! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 20:41'!copyForm: srcForm to: destPt rule: rule	^ self copyForm: srcForm to: destPt rule: rule		colorMap: (srcForm colormapIfNeededFor: destForm)! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 19:21'!copyForm: srcForm to: destPt rule: rule color: color	sourceForm _ srcForm.	halftoneForm _ color.	combinationRule _ rule.	destX _ destPt x + sourceForm offset x.	destY _ destPt y + sourceForm offset y.	sourceX _ 0.	sourceY _ 0.	width _ sourceForm width.	height _ sourceForm height.	self copyBits! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 19:21'!copyForm: srcForm to: destPt rule: rule colorMap: map	sourceForm _ srcForm.	halftoneForm _ nil.	combinationRule _ rule.	destX _ destPt x + sourceForm offset x.	destY _ destPt y + sourceForm offset y.	sourceX _ 0.	sourceY _ 0.	width _ sourceForm width.	height _ sourceForm height.	colorMap _ map.	self copyBits! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 19:21'!copyForm: srcForm to: destPt rule: rule fillColor: color	sourceForm _ srcForm.	self fillColor: color.	"sets halftoneForm"	combinationRule _ rule.	destX _ destPt x + sourceForm offset x.	destY _ destPt y + sourceForm offset y.	sourceX _ 0.	sourceY _ 0.	width _ sourceForm width.	height _ sourceForm height.	self copyBits! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 20:41'!copyFrom: sourceRectangle in: srcForm to: destPt	| sourceOrigin |	sourceForm _ srcForm.	halftoneForm _ nil.	combinationRule _ 3.  "store"	destX _ destPt x.	destY _ destPt y.	sourceOrigin _ sourceRectangle origin.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ sourceRectangle width.	height _ sourceRectangle height.	colorMap _ srcForm colormapIfNeededFor: destForm.	self copyBits! !!FXBlt methodsFor: 'copying' stamp: 'ar 5/25/2000 17:40'!displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta	destY _ aPoint y.	destX _ aPoint x.	^self primDisplayString: aString from: startIndex to: stopIndex			map: font characterToGlyphMap xTable: font xTable			kern: kernDelta.! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 19:21'!fill: destRect fillColor: grayForm rule: rule	"Fill with a Color, not a Form. 6/18/96 tk"	sourceForm _ nil.	self fillColor: grayForm.		"sets halftoneForm"	combinationRule _ rule.	destX _ destRect left.	destY _ destRect top.	sourceX _ 0.	sourceY _ 0.	width _ destRect width.	height _ destRect height.	self copyBits! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 19:21'!pixelAt: aPoint	"Assumes this BitBlt has been set up specially (see the init message,	BitBlt bitPeekerFromForm:.  Returns the pixel at aPoint."	sourceX _ aPoint x.	sourceY _ aPoint y.	destForm bits at: 1 put: 0.  "Just to be sure"	self copyBits.	^ destForm bits at: 1! !!FXBlt methodsFor: 'copying' stamp: 'ar 2/9/2000 19:21'!pixelAt: aPoint put: pixelValue	"Assumes this BitBlt has been set up specially (see the init message,	BitBlt bitPokerToForm:.  Overwrites the pixel at aPoint."	destX _ aPoint x.	destY _ aPoint y.	sourceForm bits at: 1 put: pixelValue.	self copyBits"| bb |bb _ (BitBlt bitPokerToForm: Display).[Sensor anyButtonPressed] whileFalse:	[bb pixelAt: Sensor cursorPoint put: 55]"! !!FXBlt methodsFor: 'private' stamp: 'ar 2/9/2000 19:21'!copyBitsAgain	"Primitive. See BitBlt|copyBits, also a Primitive. Essential. See Object	documentation whatIsAPrimitive."	<primitive: 96>	self primitiveFailed! !!FXBlt methodsFor: 'private' stamp: 'ar 2/9/2000 19:21'!copyBitsFrom: x0 to: x1 at: y	destX _ x0.	destY _ y.	sourceX _ x0.	width _ (x1 - x0).	self copyBits.! !!FXBlt methodsFor: 'private' stamp: 'ar 2/9/2000 20:42'!eraseBits	"Perform the erase operation, which puts 0's in the destination	wherever the source (which is assumed to be just 1 bit deep)	has a 1.  This requires the colorMap to be set in order to AND	all 1's into the destFrom pixels regardless of their size."	| oldMask oldMap |	oldMask _ halftoneForm.	halftoneForm _ nil.	oldMap _ colorMap.	self colorMap: (ColorMap shifts: nil masks: nil colors: (Bitmap with: 0 with: 16rFFFFFFFF)).	combinationRule _ Form erase.	self copyBits. 		"Erase the dest wherever the source is 1"	halftoneForm _ oldMask.	"already converted to a Bitmap"	colorMap _ oldMap! !!FXBlt methodsFor: 'private' stamp: 'ar 5/25/2000 17:24'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	| lastSourceDepth |	self flag: #fixThis.	sourceForm ifNotNil:[lastSourceDepth _ sourceForm depth].	sourceForm _ aStrikeFont glyphs.	(colorMap notNil and:[lastSourceDepth = sourceForm depth]) ifFalse:		["Set up color map for a different source depth (color font)"		"Note this may need some caching for reasonable efficiency"		colorMap _ (Color cachedColormapFrom: sourceForm depth to: destForm depth) copy.		colorMap at: 1 put: (backgroundColor pixelValueForDepth: destForm depth).		self colorMap: colorMap].	sourceForm depth = 1 ifTrue:		[colorMap colors at: 2 put: (foregroundColor pixelValueForDepth: destForm depth).		"Ignore any halftone pattern since we use a color map approach here"		halftoneForm _ nil].	sourceY _ 0.	height _ aStrikeFont height.! !!FXBlt methodsFor: 'private' stamp: 'ar 2/9/2000 20:41'!paintBits	"Perform the paint operation, which requires two calls to BitBlt."	| color oldMap saveRule |	sourceForm depth = 1 ifFalse: 		[^ self halt: 'paint operation is only defined for 1-bit deep sourceForms'].	saveRule _ combinationRule.	color _ halftoneForm.  halftoneForm _ nil.	oldMap _ colorMap.	"Map 1's to ALL ones, not just one"	self colorMap: (ColorMap shifts: nil masks: nil colors: (Bitmap with: 0 with: 16rFFFFFFFF)).	combinationRule _ Form erase.	self copyBits. 		"Erase the dest wherever the source is 1"	halftoneForm _ color.	combinationRule _ Form under.	self copyBits.	"then OR, with whatever color, into the hole"	colorMap _ oldMap.	combinationRule _ saveRule" | dot |dot _ Form dotOfSize: 32.((BitBlt destForm: Display		sourceForm: dot		fillColor: Color lightGray		combinationRule: Form paint		destOrigin: Sensor cursorPoint		sourceOrigin: 0@0		extent: dot extent		clipRect: Display boundingBox)		colorMap: (ColorMap shifts: nil masks: nil colors: (Bitmap with: 0 with: 16rFFFFFFFF))) copyBits"! !!FXBlt methodsFor: 'private' stamp: 'ar 5/25/2000 17:14'!primCopyBits	<primitive: 'primitiveCopyBits' module: 'FXBltPlugin'>	^nil "indicates error"! !!FXBlt methodsFor: 'private' stamp: 'ar 5/25/2000 17:21'!primDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta	| ascii glyph |	<primitive:'primitiveDisplayString' module:'FXBltPlugin'>	startIndex to: stopIndex do:[:charIndex|		ascii _ (aString at: charIndex) asciiValue.		glyph _ glyphMap at: ascii + 1.		sourceX _ xTable at: glyph + 1.		width _ (xTable at: glyph + 2) - sourceX.		self copyBits.		destX _ destX + width + kernDelta.	].! !!FXBlt methodsFor: 'private' stamp: 'ar 5/25/2000 17:13'!recover	"Recover after a BitBlt operation has failed. Return true if the	copyBits operation should be tried again."	"As long as we need to fix problems with colorMaps"	colorMap ifNotNil:[		(colorMap isKindOf: ColorMap) ifFalse:[			colorMap size < 256 ifTrue:[				colorMap _ ColorMap shifts: nil masks: nil colors: colorMap.			] ifFalse:[ sourceForm 					ifNil:["Can't fix -- ignore". colorMap _ nil]					ifNotNil:[colorMap _ sourceForm colormapIfNeededFor: destForm]].		^true "try again"]].	"Check for compressed source, destination or halftone forms"	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^true]. "try again"	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^true]. "try again"	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^true]. "try again"	^false "unable to recover"! !!FXBlt methodsFor: 'private' stamp: 'ar 2/9/2000 19:21'!setDestForm: df	| bb |	bb _ df boundingBox.	destForm _ df.	clipX _ bb left.	clipY _ bb top.	clipWidth _ bb width.	clipHeight _ bb height! !!FXBlt methodsFor: 'private' stamp: 'ar 2/9/2000 20:40'!setDestForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect	| aPoint |	destForm _ df.	sourceForm _ sf.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ cr.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ extent x.	height _ extent y.	aPoint _ clipRect origin.	clipX _ aPoint x.	clipY _ aPoint y.	aPoint _ clipRect corner.	clipWidth _ aPoint x - clipX.	clipHeight _ aPoint y - clipY.	sourceForm == nil ifFalse:		[colorMap _ sourceForm colormapIfNeededFor: destForm]! !!FXBlt methodsFor: 'private' stamp: 'ar 2/12/2000 19:51'!traceProblem: aString from: aContext	RecursionLock == true ifTrue:[^self].	RecursionLock _ true.	Transcript cr; show: aString; cr; show: aContext shortStack.	RecursionLock _ false.! !!FXBlt methodsFor: 'line drawing' stamp: 'ar 2/9/2000 19:21'!drawFrom: startPoint to: stopPoint 		 ^ self drawFrom: startPoint to: stopPoint withFirstPoint: true! !!FXBlt methodsFor: 'line drawing' stamp: 'ar 2/9/2000 19:21'!drawFrom: startPoint to: stopPoint withFirstPoint: drawFirstPoint	"Draw a line whose end points are startPoint and stopPoint.	The line is formed by repeatedly calling copyBits at every	point along the line.  If drawFirstPoint is false, then omit	the first point so as not to overstrike at line junctions."	| offset point1 point2 forwards |	"Always draw down, or at least left-to-right"	forwards _ (startPoint y = stopPoint y and: [startPoint x < stopPoint x])				or: [startPoint y < stopPoint y].	forwards		ifTrue: [point1 _ startPoint. point2 _ stopPoint]		ifFalse: [point1 _ stopPoint. point2 _ startPoint].	sourceForm == nil ifTrue:		[destX _ point1 x.		destY _ point1 y]		ifFalse:		[width _ sourceForm width.		height _ sourceForm height.		offset _ sourceForm offset.		destX _ (point1 x + offset x) rounded.		destY _ (point1 y + offset y) rounded].	"Note that if not forwards, then the first point is the last and vice versa.	We agree to always paint stopPoint, and to optionally paint startPoint."	(drawFirstPoint or: [forwards == false  "ie this is stopPoint"])		ifTrue: [self copyBits].	self drawLoopX: (point2 x - point1 x) rounded 				  Y: (point2 y - point1 y) rounded.	(drawFirstPoint or: [forwards  "ie this is stopPoint"])		ifTrue: [self copyBits].! !!FXBlt methodsFor: 'line drawing' stamp: 'ar 2/22/2000 22:30'!drawLoopX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."	| dx dy px py P |	<primitive: 'primitiveDrawLoop' module:'FXBltPlugin'>	dx _ xDelta sign.	dy _ yDelta sign.	px _ yDelta abs.	py _ xDelta abs.	"self copyBits."	py > px		ifTrue: 			["more horizontal"			P _ py // 2.			1 to: py do: 				[:i |				destX _ destX + dx.				(P _ P - px) < 0 ifTrue: 						[destY _ destY + dy.						P _ P + py].				i < py ifTrue: [self copyBits]]]		ifFalse: 			["more vertical"			P _ px // 2.			1 to: px do:				[:i |				destY _ destY + dy.				(P _ P - py) < 0 ifTrue: 						[destX _ destX + dx.						P _ P + px].				i < px ifTrue: [self copyBits]]]! !!FXBlt methodsFor: 'warping' stamp: 'ar 2/22/2000 17:13'!cellSize	^warpQuality! !!FXBlt methodsFor: 'warping' stamp: 'ar 2/10/2000 00:16'!cellSize: aNumber	warpQuality _ aNumber.! !!FXBlt methodsFor: 'warping' stamp: 'ar 2/22/2000 17:14'!copyQuad: pts toRect: destRect	self sourceQuad: pts destRect: destRect.	self warpBits! !!FXBlt methodsFor: 'warping' stamp: 'ar 2/22/2000 17:19'!sourceForm: srcForm destRect: dstRectangle	"Set up a WarpBlt from the entire source Form to the given destination rectangle."	| w h |	sourceForm _ srcForm.	sourceX _ sourceY _ 0.	destX _ dstRectangle left.	destY _ dstRectangle top.	width _ dstRectangle width.	height _ dstRectangle height.	w _ 16384 * (srcForm width - 1).	h _ 16384 * (srcForm height - 1).	warpQuad _ Array		with: 0@0 with: 0@h		with: w@h with: w@0.! !!FXBlt methodsFor: 'warping' stamp: 'ar 2/22/2000 17:21'!sourceQuad: pts destRect: aRectangle	| fixedPt1 |	sourceX _ sourceY _ 0.	self destRect: aRectangle.	fixedPt1 _ (pts at: 1) x isInteger ifTrue: [16384] ifFalse: [16384.0].	warpQuad _ pts collect:[:pt| pt * fixedPt1].! !!FXBlt methodsFor: 'warping' stamp: 'ar 2/22/2000 19:35'!warpBits	warpQuality ifNil:[warpQuality _ 1].	warpQuality > 1 ifTrue:[		"Must install source map"		sourceMap _ sourceForm colormapToARGB.		colorMap _ destForm colormapFromARGB.	].	self copyBits! !!FXBlt class methodsFor: 'examples' stamp: 'ar 2/9/2000 19:48'!alphaBlendDemo	"To run this demo, use...		Display restoreAfter: [FXBlt alphaBlendDemo]		Displays 10 alphas, then lets you paint.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  	"compute color maps if needed"	Display depth <= 8 ifTrue: [		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.		map32toD _ Color cachedColormapFrom: 32 to: Display depth].	"display 10 different alphas, across top of screen"	buff _ Form extent: 500@50 depth: 32.	dispToBuff _ self toForm: buff.	dispToBuff colorMap: mapDto32.	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)						fillColor: (Color red alpha: i/10)						rule: Form blend].	buffToDisplay _ self toForm: Display.	buffToDisplay colorMap: map32toD.	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.	"Create a brush with radially varying alpha"	brush _ Form extent: 30@30 depth: 32.	1 to: 5 do: 		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)				fillColor: (Color red alpha: 0.02 * i - 0.01)				at: brush extent // 2].	"Now paint with the brush using alpha blending."	buffSize _ 100.	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"	dispToBuff _ self toForm: buff.  "This is from Display to buff"	dispToBuff colorMap: mapDto32.	brushToBuff _ self toForm: buff.  "This is from brush to buff"	brushToBuff sourceForm: brush; sourceOrigin: 0@0.	brushToBuff combinationRule: Form blend.	buffToBuff _ self toForm: buff.  "This is for slewing the buffer"	[Sensor yellowButtonPressed] whileFalse:		[prevP _ nil.		buffRect _ Sensor cursorPoint - (buffSize // 2) extent: buff extent.		dispToBuff copyFrom: buffRect in: Display to: 0@0.		[Sensor redButtonPressed] whileTrue:			["Here is the painting loop"			p _ Sensor cursorPoint - (brush extent // 2).			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP _ p].				(p dist: prevP) > buffSize ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta _ (p-prevP) theta.					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].				brushRect _ p extent: brush extent.				(buffRect containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta _ brushRect amountToTranslateWithin: buffRect.					buffToBuff copyFrom: buff boundingBox in: buff to: delta.					newBuffRect _ buffRect translateBy: delta negated.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin].					buffRect _ newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP - buffRect origin									to: p - buffRect origin									withFirstPoint: false.				"Update (only) the altered pixels of the destination"				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.				prevP _ p]]]! !!FXBlt class methodsFor: 'examples' stamp: 'ar 2/22/2000 18:16'!antiAliasDemo 	"To run this demo, use...		Display restoreAfter: [FXBlt antiAliasDemo]	Goes immediately into on-screen paint mode.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"		"This version also uses WarpBlt to paint into twice as large a buffer,	and then use smoothing when reducing back down to the display.	In fact this same routine will now work for 3x3 soothing as well.	Remove the statements 'buff displayAt: 0@0' to hide the buffer. - di 3/19/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect scale p0 |  	"compute color maps if needed"	Display depth <= 8 ifTrue: [		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.		map32toD _ Color cachedColormapFrom: 32 to: Display depth].	"Create a brush with radially varying alpha"	brush _ Form extent: 3@3 depth: 32.	brush fill: brush boundingBox fillColor: (Color red alpha: 0.05).	brush fill: (1@1 extent: 1@1) fillColor: (Color red alpha: 0.2).	scale _ 2.  "Actual drawing happens at this magnification"	"Scale brush up for painting in magnified buffer"	brush _ brush magnify: brush boundingBox by: scale.	"Now paint with the brush using alpha blending."	buffSize _ 100.	buff _ Form extent: (brush extent + buffSize) * scale depth: 32.  "Travelling 32-bit buffer"	dispToBuff _ (self toForm: buff)  "From Display to buff - magnify by 2"		sourceForm: Display;		colorMap: mapDto32;		combinationRule: Form over.	brushToBuff _ (self toForm: buff)  "From brush to buff"		sourceForm: brush;		sourceOrigin: 0@0;		combinationRule: Form blend.	buffToDisplay _ (self toForm: Display)  "From buff to Display - shrink by 2"		sourceForm: buff;		colorMap: map32toD;		cellSize: scale;  "...and use smoothing"		combinationRule: Form over.	buffToBuff _ self toForm: buff.  "This is for slewing the buffer"	[Sensor yellowButtonPressed] whileFalse:		[prevP _ nil.		buffRect _ Sensor cursorPoint - (buff extent // scale // 2) extent: buff extent // scale.		p0 _ (buff extent // 2) - (buffRect extent // 2).		dispToBuff copyQuad: buffRect innerCorners toRect: buff boundingBox.buff displayAt: 0@0.  "** remove to hide sliding buffer **"		[Sensor redButtonPressed] whileTrue:			["Here is the painting loop"			p _ Sensor cursorPoint - buffRect origin + p0.  "p, prevP are rel to buff origin"			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP _ p].				(p dist: prevP) > (buffSize-1) ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta _ (p-prevP) theta.					p _ ((theta cos@theta sin) * (buffSize-2) asFloat + prevP) truncated].				brushRect _ p extent: brush extent.				((buff boundingBox insetBy: scale) containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta _ (brushRect amountToTranslateWithin: (buff boundingBox insetBy: scale)) // scale.					buffToBuff copyFrom: buff boundingBox in: buff to: delta*scale.					newBuffRect _ buffRect translateBy: delta negated.					p _ p translateBy: delta*scale.					prevP _ prevP translateBy: delta*scale.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyQuad: r innerCorners toRect: (r origin - newBuffRect origin*scale extent: r extent*scale)].					buffRect _ newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP to: p withFirstPoint: false.buff displayAt: 0@0.  "** remove to hide sliding buffer **"				"Update (only) the altered pixels of the destination"				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.				updateRect _ updateRect origin // scale * scale						corner: updateRect corner + scale // scale * scale.				buffToDisplay copyQuad: updateRect innerCorners							toRect: (updateRect origin // scale + buffRect origin										extent: updateRect extent // scale).				prevP _ p]]]! !!FXBlt class methodsFor: 'examples' stamp: 'ar 2/9/2000 19:49'!exampleOne	"This tests BitBlt by displaying the result of all sixteen combination rules that BitBlt is capable of using. (Please see the comment in BitBlt for the meaning of the combination rules)."	| path |	path _ Path new.	0 to: 3 do: [:i | 0 to: 3 do: [:j | path add: j * 100 @ (i * 75)]].	Display fillWhite.	path _ path translateBy: 60 @ 40.	1 to: 16 do: [:index | self			exampleAt: (path at: index)			rule: index - 1			fillColor: Color black]	"FXBlt exampleOne"! !!FXBlt class methodsFor: 'examples' stamp: 'ar 2/9/2000 19:49'!exampleTwo	"This is to test painting with a gray tone. It also tests that the seaming with gray patterns is correct in the microcode. Lets you paint for a while and then automatically stops."	| f aBitBlt |	"create a small black Form source as a brush. "	f _ Form extent: 20 @ 20.	f fillBlack.	"create a BitBlt which will OR gray into the display. "	aBitBlt _ self		destForm: Display		sourceForm: f		fillColor: Color gray		combinationRule: Form under		destOrigin: Sensor cursorPoint		sourceOrigin: 0 @ 0		extent: f extent		clipRect: Display computeBoundingBox.	"paint the gray Form on the screen for a while. "	[Sensor anyButtonPressed] whileFalse: 		[aBitBlt destOrigin: Sensor cursorPoint.		aBitBlt copyBits]	"FXBlt exampleTwo"! !!FXBlt class methodsFor: 'examples' stamp: 'ar 2/22/2000 17:22'!warpTest1   "Display restoreAfter: [FXBlt warpTest1]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p ext |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]! !!FXBlt class methodsFor: 'examples' stamp: 'ar 2/22/2000 17:23'!warpTest12   "Display restoreAfter: [FXBlt warpTest12]"	"Just like test1, but comparing smooth to non-smooth warps"	| warp pts r1 p0 p ext warp2 |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 2;  "installs a colormap"		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	warp2 _ (self toForm: Display)		clipRect: ((0@0 extent: r1 extent*5) translateBy: 200@0);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 200@0).		]! !!FXBlt class methodsFor: 'examples' stamp: 'ar 2/22/2000 17:31'!warpTest3   "Display restoreAfter: [FXBlt warpTest3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	warp _ (self toForm: Display)		clipRect: box;		sourceForm: Display;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!FXBlt class methodsFor: 'examples' stamp: 'ar 2/22/2000 17:32'!warpTest4   "Display restoreAfter: [FXBlt warpTest4]"	"The Squeak Release Mandala - 9/23/96 di	This version does smoothing"	"Move the mouse near the center ofhe square.	Up and dn affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	warp _ (self toForm: Display)		clipRect: box;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!FXBlt class methodsFor: 'examples' stamp: 'ar 2/22/2000 17:33'!warpTest5   "Display restoreAfter: [FXBlt warpTest5]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle fromUser.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 1;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		warp copyQuad: pts toRect: (r1 translateBy: r1 width@0)]! !!FXBlt class methodsFor: 'form rotation' stamp: 'ar 2/22/2000 17:35'!rotate: srcForm degrees: angleInDegrees center: aPoint scaleBy: scalePoint smoothing: cellSize	"Rotate the given Form the given number of degrees about the given center and scale its width and height by x and y of the given scale point. Smooth using the given cell size, an integer between 1 and 3, where 1 means no smoothing. Return a pair where the first element is the rotated Form and the second is the position offset required to align the center of the rotated Form with that of the original. Note that the dimensions of the resulting Form generally differ from those of the original."	| srcRect center radians dstOrigin dstCorner p dstRect inverseScale quad dstForm newCenter warpSrc |	srcRect _ srcForm boundingBox.	center _ srcRect center.	radians _ angleInDegrees degreesToRadians.	dstOrigin _ dstCorner _ center.	srcRect corners do: [:corner |		"find the limits of a rectangle that just encloses the rotated		 original; in general, this rectangle will be larger than the		 original (e.g., consider a square rotated by 45 degrees)"		p _ ((corner - center) scaleBy: scalePoint) + center.		p _ (p rotateBy: radians about: center) rounded.		dstOrigin _ dstOrigin min: p.		dstCorner _ dstCorner max: p].	"rotate the enclosing rectangle back to get the source quadrilateral"	dstRect _ dstOrigin corner: dstCorner.	inverseScale _ (1.0 / scalePoint x)@(1.0 / scalePoint y).	quad _ dstRect innerCorners collect: [:corner |		p _ corner rotateBy: radians negated about: center.		((p - center) scaleBy: inverseScale) + center].	"make a Form to hold the result and do the rotation"	warpSrc _ srcForm.	(srcForm isKindOf: ColorForm)		ifTrue: [			cellSize > 1				ifTrue: [					warpSrc _ Form extent: srcForm extent depth: 16.					srcForm displayOn: warpSrc.					dstForm _ Form extent: dstRect extent depth: 16]  "use 16-bit depth to allow smoothing"				ifFalse: [					dstForm _ srcForm class extent: dstRect extent depth: srcForm depth]]		ifFalse: [			dstForm _ srcForm class extent: dstRect extent depth: srcForm depth].	(self toForm: dstForm)		sourceForm: warpSrc;		colorMap: (dstForm colormapIfNeededFor: warpSrc);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form paint;		copyQuad: quad toRect: dstForm boundingBox.	(dstForm isKindOf: ColorForm) ifTrue: [dstForm colors: srcForm colors copy].	newCenter _ (center rotateBy: radians about: aPoint) truncated.	^ Array with: dstForm with: dstRect origin + (newCenter - center)! !!FXBlt class methodsFor: 'instance creation' stamp: 'ar 2/9/2000 19:48'!bitPeekerFromForm: sourceForm	"Answer an instance to be used extract individual pixels from the given Form. The destination for a 1x1 copyBits will be the low order bits of (bits at: 1)."	| pixPerWord |	pixPerWord _ 32 // sourceForm depth.	sourceForm unhibernate.	^ self destForm: (Form extent: pixPerWord@1 depth: sourceForm depth)	 	sourceForm: sourceForm		halftoneForm: nil		combinationRule: Form over		destOrigin: (pixPerWord - 1)@0		sourceOrigin: 0@0		extent: 1@1		clipRect: (0@0 extent: pixPerWord@1)! !!FXBlt class methodsFor: 'instance creation' stamp: 'ar 2/9/2000 19:48'!bitPokerToForm: destForm	"Answer an instance to be used for valueAt: aPoint put: pixValue.	The source for a 1x1 copyBits will be the low order of (bits at: 1)"	| pixPerWord |	pixPerWord _ 32//destForm depth.	destForm unhibernate.	^ self destForm: destForm	 	sourceForm: (Form extent: pixPerWord@1 depth: destForm depth)		halftoneForm: nil combinationRule: Form over		destOrigin: 0@0 sourceOrigin: (pixPerWord-1)@0		extent: 1@1 clipRect: (0@0 extent: destForm extent)! !!FXBlt class methodsFor: 'instance creation' stamp: 'ar 2/9/2000 19:48'!destForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect 	"Answer an instance of me with values set according to the arguments."	^ self new		setDestForm: df		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: sourceOrigin		extent: extent		clipRect: clipRect! !!FXBlt class methodsFor: 'instance creation' stamp: 'ar 2/9/2000 19:48'!destForm: df sourceForm: sf halftoneForm: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect 	"Answer an instance of me with values set according to the arguments."	^ self new		setDestForm: df		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: sourceOrigin		extent: extent		clipRect: clipRect! !!FXBlt class methodsFor: 'instance creation' stamp: 'ar 2/9/2000 19:48'!toForm: aForm	^ self new setDestForm: aForm! !!FXBlt class methodsFor: 'benchmarks' stamp: 'ar 2/9/2000 19:48'!benchDiffsFrom: before to: afterwards	"Given two outputs of BitBlt>>benchmark show the relative improvements."	| old new log oldLine newLine oldVal newVal improvement |	log _ WriteStream on: String new.	old _ ReadStream on: before.	new _ ReadStream on: afterwards.	[old atEnd or:[new atEnd]] whileFalse:[		oldLine _ old upTo: Character cr.		newLine _ new upTo: Character cr.		(oldLine includes: Character tab) ifTrue:[			oldLine _ ReadStream on: oldLine.			newLine _ ReadStream on: newLine.			Transcript cr; show: (oldLine upTo: Character tab); tab.			log cr; nextPutAll: (newLine upTo: Character tab); tab.			[oldLine skipSeparators. newLine skipSeparators.			oldLine atEnd] whileFalse:[				oldVal _ Integer readFrom: oldLine.				newVal _ Integer readFrom: newLine.				improvement _ oldVal asFloat / newVal asFloat roundTo: 0.1.				Transcript show: improvement printString; tab.				log print: improvement; tab].		] ifFalse:[			Transcript cr; show: oldLine.			log cr; nextPutAll: oldLine.		].	].	^log contents! !!FXBlt class methodsFor: 'benchmarks' stamp: 'ar 5/25/2000 17:58'!benchmark		"FXBlt benchmark"	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.	Attention: *this*may*take*a*while*"	| bb source dest destRect log t |	log _ WriteStream on: String new.	destRect _ 0@0 extent: 600@600.	"Form paint/Form over - the most common rules"	#( 25 3 ) do:[:rule|		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.		#(1 2 4 8 16 32) do:[:destDepth|			dest _ nil.			dest _ Form extent: destRect extent depth: destDepth.			Transcript cr.			log cr.			#(1 2 4 8 16 32) do:[:sourceDepth|				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.				source _ nil. bb _ nil.				source _ Form extent: destRect extent depth: sourceDepth.				(source getCanvas) fillOval: destRect color: Color yellow borderWidth: 30 borderColor: Color black.				bb _ FXBlt toForm: dest.				bb raiseErrors: true.				bb sourceForm: source.				bb sourceRect: source boundingBox.				bb destRect: destRect.				bb colorMap: (source colormapIfNeededFor: dest).				bb combinationRule: rule.				"Measure speed of copyBits"				t _ Time millisecondsToRun:[bb copyBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				bb sourceForm: source destRect: source boundingBox.				"Measure speed of 1x1 warpBits"				bb cellSize: 1.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 2x2 warpBits"				bb cellSize: 2.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 3x3 warpBits"				bb cellSize: 3.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.			].		].	].	^log contents! !!FXBlt class methodsFor: 'private' stamp: 'ar 2/9/2000 19:50'!exampleAt: originPoint rule: rule fillColor: mask 	"This builds a source and destination form and copies the source to the	destination using the specifed rule and mask. It is called from the method	named exampleOne."	| s d border aBitBlt | 	border_Form extent: 32@32.	border fillBlack.	border fill: (1@1 extent: 30@30) fillColor: Color white.	s _ Form extent: 32@32.	s fillWhite.	s fillBlack: (7@7 corner: 25@25).	d _ Form extent: 32@32.	d fillWhite.	d fillBlack: (0@0 corner: 32@16).	s displayOn: Display at: originPoint.	border displayOn: Display at: originPoint rule: Form under.	d displayOn: Display at: originPoint + (s width @0).	border displayOn: Display at: originPoint + (s width @0) rule: Form under.	d displayOn: Display at: originPoint + (s extent // (2 @ 1)).	aBitBlt _ self		destForm: Display		sourceForm: s		fillColor: mask		combinationRule: rule		destOrigin: originPoint + (s extent // (2 @ 1))		sourceOrigin: 0 @ 0		extent: s extent		clipRect: Display computeBoundingBox.	aBitBlt copyBits.	border 		displayOn: Display at: originPoint + (s extent // (2 @ 1))		rule: Form under.   	"BitBlt exampleAt: 100@100 rule: Form over fillColor: Color gray"! !!FXBlt class methodsFor: 'private' stamp: 'ar 2/10/2000 00:34'!swapBytesIn: aBitmap	"Byte-swap the contents of aBitmap"	"Notes: 		* We could setup BitBlt so that it uses aBitmap as source 		  but it's faster without a source		* We could move the conversion into the destMap but		  I'm planning to add a color cache for conversions		  and this cache will definitely be used for colorMap."	| bb form |	form _ Form extent: aBitmap size @ 1 depth: 32 bits: aBitmap.	bb _ self toForm: form.	bb fillColor: (Bitmap with: 16rFFFFFFFF).	"No conversion when reading the pixels"	bb destMap:(ColorMap			shifts: #(0 0 0 0)			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)). "<- so mask is identity!!"	"But do swap when writing"	bb colorMap:(ColorMap			shifts: #(-24 -8 8 24)			masks: #(16rFF000000 16rFF0000 16rFF00 16rFF)).	"Set the combination rule to #destinationWord:with: so	that the result is just the word we have in destForm.	Only byte swapped."	bb combinationRule: 5.	"And swap those bytes"	bb copyBits.! !!FXBltSimulation methodsFor: 'initialize' stamp: 'ar 5/25/2000 15:20'!initBBOpTable	self cCode: 'opTable[0+1] = (int)clearWordwith'.	self cCode: 'opTable[1+1] = (int)bitAndwith'.	self cCode: 'opTable[2+1] = (int)bitAndInvertwith'.	self cCode: 'opTable[3+1] = (int)sourceWordwith'.	self cCode: 'opTable[4+1] = (int)bitInvertAndwith'.	self cCode: 'opTable[5+1] = (int)destinationWordwith'.	self cCode: 'opTable[6+1] = (int)bitXorwith'.	self cCode: 'opTable[7+1] = (int)bitOrwith'.	self cCode: 'opTable[8+1] = (int)bitInvertAndInvertwith'.	self cCode: 'opTable[9+1] = (int)bitInvertXorwith'.	self cCode: 'opTable[10+1] = (int)bitInvertDestinationwith'.	self cCode: 'opTable[11+1] = (int)bitOrInvertwith'.	self cCode: 'opTable[12+1] = (int)bitInvertSourcewith'.	self cCode: 'opTable[13+1] = (int)bitInvertOrwith'.	self cCode: 'opTable[14+1] = (int)bitInvertOrInvertwith'.	self cCode: 'opTable[15+1] = (int)destinationWordwith'.	self cCode: 'opTable[16+1] = (int)destinationWordwith'.	self cCode: 'opTable[17+1] = (int)destinationWordwith'.	self cCode: 'opTable[18+1] = (int)addWordwith'.	self cCode: 'opTable[19+1] = (int)subWordwith'.	self cCode: 'opTable[20+1] = (int)rgbAddwith'.	self cCode: 'opTable[21+1] = (int)rgbSubwith'.	self cCode: 'opTable[22+1] = (int)OLDrgbDiffwith'.	self cCode: 'opTable[23+1] = (int)OLDtallyIntoMapwith'.	self cCode: 'opTable[24+1] = (int)alphaBlendwith'.	self cCode: 'opTable[25+1] = (int)pixPaintwith'.	self cCode: 'opTable[26+1] = (int)pixMaskwith'.	self cCode: 'opTable[27+1] = (int)rgbMaxwith'.	self cCode: 'opTable[28+1] = (int)rgbMinwith'.	self cCode: 'opTable[29+1] = (int)rgbMinInvertwith'.	self cCode: 'opTable[30+1] = (int)alphaBlendConstwith'.	self cCode: 'opTable[31+1] = (int)alphaPaintConstwith'.	self cCode: 'opTable[32+1] = (int)rgbDiffwith'.	self cCode: 'opTable[33+1] = (int)tallyIntoMapwith'.	self cCode: 'opTable[34+1] = (int)alphaBlendScaledwith'.	self cCode: 'opTable[35+1] = (int)srcPaintwith'.	self cCode: 'opTable[36+1] = (int)dstPaintwith'.! !!FXBltSimulation methodsFor: 'initialize' stamp: 'ar 5/25/2000 15:20'!initialiseModule	self export: true.	self initBBOpTable.	^true! !!FXBltSimulation methodsFor: 'initialize' stamp: 'ar 5/25/2000 16:11'!moduleUnloaded: aModuleName	"The module with the given name was just unloaded.	Make sure we have no dangling references."	self export: true.	self var: #aModuleName type: 'char *'.	(aModuleName strcmp: 'SurfacePlugin') = 0 ifTrue:[		"The surface plugin just shut down. How nasty."		querySurfaceFn _ lockSurfaceFn _ unlockSurfaceFn _ 0.	].! !!FXBltSimulation methodsFor: 'primitives' stamp: 'ar 2/21/2000 20:24'!primitiveCopyBits	| rcvr |	self export: true.	self inline: false.	rcvr _ interpreterProxy stackValue: interpreterProxy methodArgumentCount.	(self loadBitBltFrom: rcvr) ifFalse:[^interpreterProxy primitiveFail].	self copyBits.	self showDisplayBits.! !!FXBltSimulation methodsFor: 'primitives' stamp: 'ar 2/21/2000 20:24'!primitiveDrawLoop	"Invoke the line drawing primitive."	| rcvr xDelta yDelta |	self export: true.	self inline: false.	rcvr _ interpreterProxy stackValue: 2.	xDelta _ interpreterProxy stackIntegerValue: 1.	yDelta _ interpreterProxy stackIntegerValue: 0.	(self loadBitBltFrom: rcvr) ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self drawLoopX: xDelta Y: yDelta.		self showDisplayBits].	interpreterProxy failed ifFalse:[interpreterProxy pop: 2].! !!FXBltSimulation methodsFor: 'primitives' stamp: 'ar 2/23/2000 21:39'!primitiveVersion	"Return the version of FXBlt"	interpreterProxy pop: interpreterProxy methodArgumentCount+1.	interpreterProxy pushInteger: self version.! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 5/25/2000 15:10'!drawLoopX: xDelta Y: yDelta 	"This is the primitive implementation of the line-drawing loop.	See the comments in BitBlt>>drawLoopX:Y:"	| dx1 dy1 px py P affL affR affT affB |	xDelta > 0		ifTrue: [dx1 _ 1]		ifFalse: [xDelta = 0				ifTrue: [dx1 _ 0]				ifFalse: [dx1 _ -1]].	yDelta > 0		ifTrue: [dy1 _ 1]		ifFalse: [yDelta = 0				ifTrue: [dy1 _ 0]				ifFalse: [dy1 _ -1]].	px _ yDelta abs.	py _ xDelta abs.	affL _ affT _ 9999.  "init null rectangle"	affR _ affB _ -9999.	py > px		ifTrue: 			["more horizontal"			P _ py // 2.			1 to: py do: 				[:i |				destX _ destX + dx1.				(P _ P - px) < 0 ifTrue: 					[destY _ destY + dy1.					P _ P + py].				i < py ifTrue:					[self copyBits.					interpreterProxy failed ifTrue:						[^ nil "bail out now on failure -- avoid storing x,y"].					(affectedL < affectedR and: [affectedT < affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL _ affL min: affectedL.						affR _ affR max: affectedR.						affT _ affT min: affectedT.						affB _ affB max: affectedB.						(affR - affL) * (affB - affT) > 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL _ affL.  affectedR _ affR.							affectedT _ affT.  affectedB _ affB.							self showDisplayBits.							affL _ affT _ 9999.  "init null rectangle"							affR _ affB _ -9999]].					]]]		ifFalse: 			["more vertical"			P _ px // 2.			1 to: px do:				[:i |				destY _ destY + dy1.				(P _ P - py) < 0 ifTrue: 					[destX _ destX + dx1.					P _ P + px].				i < px ifTrue:					[self copyBits.					interpreterProxy failed ifTrue:						[^ nil "bail out now on failure -- avoid storing x,y"].					(affectedL < affectedR and: [affectedT < affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL _ affL min: affectedL.						affR _ affR max: affectedR.						affT _ affT min: affectedT.						affB _ affB max: affectedB.						(affR - affL) * (affB - affT) > 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL _ affL.  affectedR _ affR.							affectedT _ affT.  affectedB _ affB.							self showDisplayBits.							affL _ affT _ 9999.  "init null rectangle"							affR _ affB _ -9999]].					]]].	"Remaining affected rect"	affectedL _ affL.  affectedR _ affR.	affectedT _ affT.  affectedB _ affB.	"store destX, Y back"		interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.	interpreterProxy storeInteger: BBDestYIndex ofObject: bitBltOop withValue: destY.! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/19/2000 20:50'!fetchIntOrFloat: index ofObject: oop	| fieldOop floatValue |	self var: #floatValue declareC:'double floatValue'.	fieldOop _ interpreterProxy fetchPointer: index ofObject: oop.	(interpreterProxy isIntegerObject: fieldOop)		ifTrue:[^interpreterProxy integerValueOf: fieldOop].	floatValue _ interpreterProxy floatValueOf: fieldOop.	(-2147483648.0 <= floatValue and:[floatValue <= 2147483647.0])		ifFalse:[interpreterProxy primitiveFail. ^0].	^floatValue asInteger! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 1/16/2000 21:26'!fetchIntOrFloat: index ofObject: oop ifNil: defaultValue	| fieldOop floatValue |	self var: #floatValue declareC:'double floatValue'.	fieldOop _ interpreterProxy fetchPointer: index ofObject: oop.	(fieldOop = interpreterProxy nilObject) ifTrue:[^defaultValue].	(interpreterProxy isIntegerObject: fieldOop)		ifTrue:[^interpreterProxy integerValueOf: fieldOop].	floatValue _ interpreterProxy floatValueOf: fieldOop.	(-2147483648.0 <= floatValue and:[floatValue <= 2147483647.0])		ifFalse:[interpreterProxy primitiveFail].	^floatValue asInteger! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 1/16/2000 16:32'!loadBitBltClipRect	"Load the clipping rectangle from a BitBlt oop."	self inline: true.	clipX _ self fetchIntOrFloat: BBClipXIndex ofObject: bitBltOop ifNil: 0.	clipY _ self fetchIntOrFloat: BBClipYIndex ofObject: bitBltOop ifNil: 0.	clipWidth _ self fetchIntOrFloat: BBClipWidthIndex ofObject: bitBltOop ifNil: destWidth.	clipHeight _ self fetchIntOrFloat: BBClipHeightIndex ofObject: bitBltOop ifNil: destHeight.	interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^true! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 1/16/2000 16:32'!loadBitBltCombinationRule	"Load the combination rule from a BitBlt oop"	self inline: true.	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > (OpTableSize - 2)]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	^true! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/13/2000 15:38'!loadBitBltDestForm	"Load the dest form for BitBlt. Return false if anything is wrong, true otherwise."	| destBitsSize |	self inline: true.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.	((interpreterProxy isPointers: destForm) and: [		(interpreterProxy slotSizeOf: destForm) >= 4])			ifFalse: [^ false].	destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.	destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.	destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.	(destWidth >= 0 and: [destHeight >= 0]) ifFalse: [^ false].	destDepth _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.	(destDepth bitAnd: destDepth-1) = 0 ifFalse:[^false].	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(interpreterProxy isIntegerObject: destBits) ifTrue:[		"Query for actual surface dimensions"		(self queryDestSurface: (interpreterProxy integerValueOf: destBits))			ifFalse:[^false].		destPPW _ 32 // destDepth.		destBits _ destPitch _ 0.	] ifFalse:[		destPPW _ 32 // destDepth.		destPitch _ destWidth + (destPPW-1) // destPPW * 4.		destBitsSize _ interpreterProxy byteSizeOf: destBits.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destPitch * destHeight)])			ifFalse: [^ false].		((interpreterProxy isWords: destBits) and:[			(interpreterProxy fetchClassOf: destBits) = interpreterProxy classBitmap])			ifTrue:[destMSB _ true]			ifFalse:[destMSB _ false].		"Skip header since external bits don't have one"		destBits _ self cCoerce: (interpreterProxy firstIndexableField: destBits) to:'int'.	].	^true! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 1/16/2000 16:32'!loadBitBltDestRect	"Load the destination rectangle from a BitBlt oop"	self inline: true.	destX _ self fetchIntOrFloat: BBDestXIndex ofObject: bitBltOop ifNil: 0.	destY _ self fetchIntOrFloat: BBDestYIndex ofObject: bitBltOop ifNil: 0.	width _ self fetchIntOrFloat: BBWidthIndex ofObject: bitBltOop ifNil: destWidth.	height _ self fetchIntOrFloat: BBHeightIndex ofObject: bitBltOop ifNil: destHeight.	^interpreterProxy failed not! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/22/2000 17:45'!loadBitBltFrom: bbObj	"Load context from BitBlt instance.  Return false if anything is amiss"	| ok |	self export: true.	bitBltOop _ bbObj.	ok _ self loadBitBltCombinationRule.	ok ifFalse:[^false].	ok _ self loadBitBltDestForm.	ok ifFalse:[^false].	ok _ self loadBitBltDestRect.	ok ifFalse:[^false].	ok _ self loadBitBltSourceForm.	ok ifFalse:[^false].	ok _ self loadHalftoneForm.	ok ifFalse:[^false].	ok _ self loadBitBltClipRect.	ok ifFalse:[^false].	ok _ self loadFXColorMap.	ok ifFalse:[^false].	ok _ self loadFXSourceMap.	ok ifFalse:[^false].	ok _ self loadFXWarpQuad.	ok ifFalse:[^false].	ok _ self loadFXWarpQuality.	ok ifFalse:[^false].	ok _ self loadFXSourceMap.	ok ifFalse:[^false].	ok _ self loadFXDestMap.	ok ifFalse:[^false].	ok _ self loadFXAlphaValues.	ok ifFalse:[^false].	ok _ self loadFXTallyMap.	ok ifFalse:[^false].	^true! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/13/2000 15:39'!loadBitBltSourceForm	"Load the source form for BitBlt. Return false if anything is wrong, true otherwise."	| sourceBitsSize |	self inline: true.	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	noSource ifTrue:[		sourceX _ sourceY _ 0.		^true].	((interpreterProxy isPointers: sourceForm) and:[		(interpreterProxy slotSizeOf: sourceForm) >= 4])			ifFalse: [^ false].	sourceX _ self fetchIntOrFloat: BBSourceXIndex ofObject: bitBltOop ifNil: 0.	sourceY _ self fetchIntOrFloat: BBSourceYIndex ofObject: bitBltOop ifNil: 0.	sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.	sourceWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: sourceForm.	sourceHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: sourceForm.	interpreterProxy failed ifTrue:[^false].	(sourceWidth >= 0 and: [sourceHeight >= 0]) ifFalse: [^ false].	sourceDepth _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.	(sourceDepth bitAnd: sourceDepth-1) = 0 ifFalse:[^false].	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(interpreterProxy isIntegerObject: sourceBits) ifTrue:[		"Query for actual surface dimensions"		(self querySourceSurface: (interpreterProxy integerValueOf: sourceBits))			ifFalse:[^false].		sourcePPW _ 32 // sourceDepth.		sourceBits _ sourcePitch _ 0.	] ifFalse:[		sourcePPW _ 32 // sourceDepth.		sourcePitch _ sourceWidth + (sourcePPW-1) // sourcePPW * 4.		sourceBitsSize _ interpreterProxy byteSizeOf: sourceBits.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourcePitch * sourceHeight)])			ifFalse: [^ false].		((interpreterProxy isWords: sourceBits) and:[			(interpreterProxy fetchClassOf: sourceBits) = interpreterProxy classBitmap])			ifTrue:[sourceMSB _ true]			ifFalse:[sourceMSB _ false].		"Skip header since external bits don't have one"		sourceBits _ self cCoerce: (interpreterProxy firstIndexableField: sourceBits) to:'int'.	].	^true! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/22/2000 15:16'!loadFXAlphaValues	"Load the source/destination transparency keys"	| oop |	self inline: true.	oop _ interpreterProxy fetchPointer: FXSourceKeyIndex ofObject: bitBltOop.	srcKeyMode _ (oop ~= interpreterProxy nilObject).	srcKeyMode 		ifTrue:[sourceAlphaKey _ self fetchIntOrFloat: FXSourceKeyIndex ofObject: bitBltOop]		ifFalse:[sourceAlphaKey _ 0].	oop _ interpreterProxy fetchPointer: FXDestKeyIndex ofObject: bitBltOop.	dstKeyMode _ (oop ~= interpreterProxy nilObject).	dstKeyMode 		ifTrue:[destAlphaKey _ self fetchIntOrFloat: FXDestKeyIndex ofObject: bitBltOop]		ifFalse:[destAlphaKey _ 0].	sourceAlpha _ self fetchIntOrFloat: FXSourceAlphaIndex ofObject: bitBltOop ifNil: 255.	^interpreterProxy failed not! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/9/2000 22:56'!loadFXColorMap	"Load a color map from FXBlt"	| oop cmSize |	self inline: true.	oop _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.	oop = interpreterProxy nilObject ifTrue:[^noColorMap _ true].	"We have a colorMap even though it might be that it's just an identity mapping"	noColorMap _ false.	((interpreterProxy isPointers: oop) 		and:[(interpreterProxy slotSizeOf: oop) >= 3]) ifFalse:[^false].	cmShiftTable _ self loadFXShiftOrMaskFrom:		(interpreterProxy fetchPointer: 0 ofObject: oop).	cmMaskTable _ self loadFXShiftOrMaskFrom:		(interpreterProxy fetchPointer: 1 ofObject: oop).	oop _ interpreterProxy fetchPointer: 2 ofObject: oop.	oop = interpreterProxy nilObject 		ifTrue:[cmSize _ cmMask _ 0]		ifFalse:[(interpreterProxy isWords: oop) ifFalse:[^false].				cmSize _ (interpreterProxy slotSizeOf: oop)].	(cmSize bitAnd: cmSize - 1) = 0 ifFalse:[^false].	cmSize = 0 		ifTrue:[colorMap _ nil]		ifFalse:[colorMap _ interpreterProxy firstIndexableField: oop.				cmMask _ cmSize - 1].	"Check if colorMap is just identity mapping for RGBA parts"	(self isIdentityMap: cmShiftTable with: cmMaskTable)		ifTrue:[ cmMaskTable _ cmShiftTable _ nil ].	^true! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/9/2000 22:57'!loadFXDestMap	"Load a destination map from destForm to canonical 32bit RGBA values"	| oop dmSize |	self inline: true.	oop _ interpreterProxy fetchPointer: FXDestMapIndex ofObject: bitBltOop.	oop = interpreterProxy nilObject ifTrue:[^noDestMap _ true].	"We have a destMap even though it might be that it's just an identity mapping"	noDestMap _ false.	((interpreterProxy isPointers: oop) 		and:[(interpreterProxy slotSizeOf: oop) >= 3]) ifFalse:[^false].	dmShiftTable _ self loadFXShiftOrMaskFrom:		(interpreterProxy fetchPointer: 0 ofObject: oop).	dmMaskTable _ self loadFXShiftOrMaskFrom:		(interpreterProxy fetchPointer: 1 ofObject: oop).	oop _ interpreterProxy fetchPointer: 2 ofObject: oop.	oop = interpreterProxy nilObject 		ifTrue:[dmSize _ dmMask _ 0]		ifFalse:[(interpreterProxy isWords: oop) ifFalse:[^false].				dmSize _ (interpreterProxy slotSizeOf: oop)].	(dmSize bitAnd: dmSize - 1) = 0 ifFalse:[^false].	dmSize = 0 		ifTrue:[destMap _ nil]		ifFalse:[destMap _ interpreterProxy firstIndexableField: oop.				dmMask _ dmSize - 1].	"Check if destMap is just identity mapping for RGBA parts"	(self isIdentityMap: dmShiftTable with: dmMaskTable)		ifTrue:[ dmMaskTable _ dmShiftTable _ nil ].	^true! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/9/2000 19:35'!loadFXShiftOrMaskFrom: mapOop	self returnTypeC:'int *'.	mapOop = interpreterProxy nilObject ifTrue:[^nil].	((interpreterProxy isWords: mapOop) 		and:[(interpreterProxy slotSizeOf: mapOop) = 4])			ifFalse:[interpreterProxy primitiveFail. ^nil].	^interpreterProxy firstIndexableField: mapOop! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/9/2000 22:57'!loadFXSourceMap	"Load a source map from sourceForm to canonical 32bit RGBA values"	| oop smSize |	self inline: true.	noSource ifTrue:[^true].	oop _ interpreterProxy fetchPointer: FXSourceMapIndex ofObject: bitBltOop.	oop = interpreterProxy nilObject ifTrue:[^noSourceMap _ true].	"We have a sourceMap even though it might be that it's just an identity mapping"	noSourceMap _ false.	((interpreterProxy isPointers: oop) 		and:[(interpreterProxy slotSizeOf: oop) >= 3]) ifFalse:[^false].	smShiftTable _ self loadFXShiftOrMaskFrom:		(interpreterProxy fetchPointer: 0 ofObject: oop).	smMaskTable _ self loadFXShiftOrMaskFrom:		(interpreterProxy fetchPointer: 1 ofObject: oop).	oop _ interpreterProxy fetchPointer: 2 ofObject: oop.	oop = interpreterProxy nilObject 		ifTrue:[smSize _ smMask _ 0]		ifFalse:[(interpreterProxy isWords: oop) ifFalse:[^false].				smSize _ (interpreterProxy slotSizeOf: oop)].	(smSize bitAnd: smSize - 1) = 0 ifFalse:[^false].	smSize = 0 		ifTrue:[sourceMap _ nil]		ifFalse:[sourceMap _ interpreterProxy firstIndexableField: oop.				smMask _ smSize - 1].	"Check if sourceMap is just identity mapping for RGBA parts"	(self isIdentityMap: smShiftTable with: smMaskTable)		ifTrue:[ smMaskTable _ smShiftTable _ nil ].	^true! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/9/2000 19:41'!loadFXTallyMap	"Load the tally map"	| map |	self inline: true.	map _ interpreterProxy fetchPointer: FXTallyMapIndex ofObject: bitBltOop.	map = interpreterProxy nilObject ifTrue:[		tallyMap _ nil.		tallyMapSize _ 0.		^true].	(interpreterProxy isWords: map) ifFalse:[^false].	tallyMapSize _ interpreterProxy slotSizeOf: map.	tallyMap _ interpreterProxy firstIndexableField: map.	^interpreterProxy failed not! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/22/2000 17:50'!loadFXWarpQuad	"Load the new warp quad (used, e.g., for warping)"	| points oop |	self inline: true.	points _ interpreterProxy fetchPointer: FXWarpQuadIndex ofObject: bitBltOop.	points = interpreterProxy nilObject ifTrue:[^noWarp _ true].	noWarp _ false.	(interpreterProxy fetchClassOf: points) = interpreterProxy classArray		ifFalse:[^false].	(interpreterProxy slotSizeOf: points) = 4 ifFalse:[^false].	0 to: 3 do:[:i|		oop _ interpreterProxy fetchPointer: i ofObject: points.		(interpreterProxy fetchClassOf: oop) = interpreterProxy classPoint			ifFalse:[^false].		warpQuad at: i*2 put: (self fetchIntOrFloat: 0 ofObject: oop).		warpQuad at: i*2+1 put: (self fetchIntOrFloat: 1 ofObject: oop).	].	^interpreterProxy failed not! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 1/16/2000 16:36'!loadFXWarpQuality	"Load the warp quality (used, e.g., for warping)"	self inline: true.	warpQuality _ self fetchIntOrFloat: FXWarpQualityIndex ofObject: bitBltOop ifNil: 1.	^interpreterProxy failed not! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/9/2000 19:29'!loadHalftoneForm	"Load the halftone form"	| halftoneBits |	self inline: true.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	noHalftone ifTrue:[		halftoneBase _ nil.		^true].	((interpreterProxy isPointers: halftoneForm) not		and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].	halftoneBits _ halftoneForm.	halftoneHeight _ interpreterProxy slotSizeOf: halftoneBits.	halftoneBase _ self cCoerce: (interpreterProxy firstIndexableField: halftoneBits) to:'int'.	^true! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/23/2000 21:03'!showDisplayBits	interpreterProxy 		showDisplayBits: destForm		Left: affectedL		Top: affectedT		Right: affectedR		Bottom: affectedB! !!FXBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/23/2000 21:40'!version	"Return the version of FXBlt"	^1! !!FXBltSimulation methodsFor: 'accessing'!affectedBottom	^affectedB! !!FXBltSimulation methodsFor: 'accessing'!affectedLeft	^affectedL! !!FXBltSimulation methodsFor: 'accessing'!affectedRight	^affectedR! !!FXBltSimulation methodsFor: 'accessing'!affectedTop	^affectedT! !!FXBltSimulation methodsFor: 'accessing'!targetForm	"Return the destination form of a copyBits or scanCharacters operation."	^destForm! !!FXBltSimulation methodsFor: 'setup' stamp: 'ar 1/9/2000 16:25'!checkSourceOverlap	"check for possible overlap of source and destination"	"ar 10/19/1999: This method requires surfaces to be locked."	| t |	self inline: true.	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir _ -1.			sy _ sy + bbH - 1.			dy _ dy + bbH - 1]		ifFalse:			[(dy = sy) & (dx > sx) ifTrue:				["y's are equal, but x's are backward"				hDir _ -1.				sx _ sx + bbW - 1.				"start at right"				dx _ dx + bbW - 1.				"and fix up masks"				nWords > 1 ifTrue: 					[t _ mask1.					mask1 _ mask2.					mask2 _ t]]].		"Dest inits may be affected by this change"		destIndex _ destBits + (dy * destPitch) + ((dx // destPPW) *4).		destDelta _ (destPitch * vDir) - (4 * (nWords * hDir))]! !!FXBltSimulation methodsFor: 'setup' stamp: 'ar 1/10/2000 23:29'!clipDest	"clip and adjust source origin and extent appropriately"	"first in x"	destX >= clipX		ifTrue: [sx _ sourceX.				dx _ destX.				bbW _ width]		ifFalse: [sx _ sourceX + (clipX - destX).				bbW _ width - (clipX - destX).				dx _ clipX].	(dx + bbW) > (clipX + clipWidth)		ifTrue: [bbW _ bbW - ((dx + bbW) - (clipX + clipWidth))].	"then in y"	destY >= clipY		ifTrue: [sy _ sourceY.				dy _ destY.				bbH _ height]		ifFalse: [sy _ sourceY + clipY - destY.				bbH _ height - (clipY - destY).				dy _ clipY].	(dy + bbH) > (clipY + clipHeight)		ifTrue: [bbH _ bbH - ((dy + bbH) - (clipY + clipHeight))].! !!FXBltSimulation methodsFor: 'setup' stamp: 'ar 1/10/2000 23:30'!clipSource	"clip and adjust source origin and extent appropriately"	sx < 0		ifTrue: [dx _ dx - sx.				bbW _ bbW + sx.				sx _ 0].	sx + bbW > sourceWidth		ifTrue: [bbW _ bbW - (sx + bbW - sourceWidth)].	sy < 0		ifTrue: [dy _ dy - sy.				bbH _ bbH + sy.				sy _ 0].	sy + bbH > sourceHeight		ifTrue: [bbH _ bbH - (sy + bbH - sourceHeight)]! !!FXBltSimulation methodsFor: 'setup' stamp: 'ar 2/24/2000 22:54'!copyBits	self export: true.	self inline: false.	self initBBOpTable.	self clipDest.	"Clip against source if not warping"	noSource ifFalse:[		noWarp ifTrue:[self clipSource]].	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil].	"Lock the surfaces if necessary"	hasSurfaceLock _ false.	(destBits = 0 or:[noSource not and:[sourceBits = 0]])		ifTrue:[self lockSurfaces ifFalse:[^interpreterProxy primitiveFail]].	self copyBitsLockedAndClipped.	"And unlock the surfaces if necessary"	hasSurfaceLock ifTrue:[self unlockSurfaces].! !!FXBltSimulation methodsFor: 'setup' stamp: 'ar 2/21/2000 22:53'!copyBitsFrom: startX to: stopX at: yValue	"Support for the balloon engine."	self export: true.	destX _ startX.	destY _ yValue.	sourceX _ startX.	width _ (stopX - startX).	self copyBits.	self showDisplayBits.! !!FXBltSimulation methodsFor: 'setup' stamp: 'ar 2/29/2000 15:39'!copyBitsLockedAndClipped	"Perform the actual copyBits operation.	Assume: Surfaces have been locked and clipping was performed."	| done |	self inline: true.	pixelDepth _ destDepth. "default assumption"	bitCount _ 0.	"Try a shortcut for stuff that should be run as quickly as possible" 	done _ self copyBitsQuickly.	done ifTrue:[^nil].	self destMaskAndPointerInit.	noWarp ifTrue:[		"Choose and perform the actual copy loop."		noSource ifTrue: ["Simple fill loop"			noDestMap				ifTrue:[self copyLoopNoSource]				ifFalse:[self copyLoopNoSourcePixels].		] ifFalse: ["Loop using source and dest"			self checkSourceOverlap.			(sourceDepth = destDepth and:[				sourceMSB = destMSB and:[noColorMap and:[srcKeyMode not]]]) ifTrue: [				"Faster version when equal depths and no color conversion"				self sourceSkewAndPointerInit.				self copyLoop.			] ifFalse: [				"If we must convert between pixel depths or use				color lookups use the general version"				(noSourceMap and:[noDestMap])					ifTrue:[self doCopyLoopPixMap]					ifFalse:[self copyLoopPixels].			]		].	] ifFalse:[self doWarpLoop].	(combinationRule = 22) | (combinationRule = 32) ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: interpreterProxy methodArgumentCount + 1.		^ interpreterProxy pushInteger: bitCount].	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!FXBltSimulation methodsFor: 'setup' stamp: 'ar 2/21/2000 23:26'!copyBitsQuickly	"Shortcut for stuff that's being run from the balloon engine.	Since we do this at each scan line we should avoid the expensive 	setup for source and destination."	self inline: true.	"We need rule 34, source depth 32, and no warping please."	(combinationRule = 34 and:[sourceDepth = 32 and:[noWarp]]) ifFalse:[^false].	"We need a source different from destination with at least 16bit depth."	(noSource or:[sourceForm = destForm or:[destDepth <= 8]]) ifTrue:[^false].	"If 8bit, then we want a dest map"	(destDepth = 8 and:[noDestMap]) ifTrue:[^false].	"And *no* source map please"	noSourceMap ifFalse:[^false].	destDepth = 32 		ifTrue:[self alphaSourceBlendBits32].	destDepth = 16		ifTrue:[self alphaSourceBlendBits16].	destDepth = 8		ifTrue:[self alphaSourceBlendBits8].	affectedL _ dx.	affectedR _ dx + bbW.	affectedT _ dy.	affectedB _ dy + bbH.	^true! !!FXBltSimulation methodsFor: 'setup' stamp: 'ar 2/13/2000 15:44'!destMaskAndPointerInit	"Compute masks for left and right destination words"	| startBits pixPerM1 endBits |	self inline: true.	pixPerM1 _ destPPW - 1.  "A mask, assuming power of two"	"how many pixels in first word"	startBits _ destPPW - (dx bitAnd: pixPerM1). 	destMSB		ifTrue:[ mask1 _ AllOnes >> (32 - (startBits*destDepth))] 		ifFalse:[ mask1 _ AllOnes << (32 - (startBits*destDepth))].	"how many pixels in last word"	endBits _ ((dx + bbW - 1) bitAnd: pixPerM1) + 1.	destMSB 		ifTrue:[mask2 _ AllOnes << (32 - (endBits*destDepth))] 		ifFalse:[mask2 _ AllOnes >> (32 - (endBits*destDepth))].	"determine number of words stored per line; merge masks if only 1"	bbW < startBits		ifTrue: [mask1 _ mask1 bitAnd: mask2.				mask2 _ 0.				nWords _ 1]		ifFalse: [nWords _ (bbW - startBits) + pixPerM1 // destPPW + 1].	hDir _ vDir _ 1. "defaults for no overlap with source"	"calculate byte addr and delta, based on first word of data"	"Note pitch is bytes and nWords is longs, not bytes"	destIndex _ destBits + (dy * destPitch) + ((dx // destPPW) *4).	destDelta _ destPitch * vDir - (4 * (nWords * hDir)).  "byte addr delta"! !!FXBltSimulation methodsFor: 'setup'!ignoreSourceOrHalftone: formPointer	formPointer = interpreterProxy nilObject ifTrue: [ ^true ].	combinationRule = 0 ifTrue: [ ^true ].	combinationRule = 5 ifTrue: [ ^true ].	combinationRule = 10 ifTrue: [ ^true ].	combinationRule = 15 ifTrue: [ ^true ].	^false! !!FXBltSimulation methodsFor: 'setup' stamp: 'ar 2/13/2000 15:47'!sourceSkewAndPointerInit	"This is only used when source and dest are same depth,	ie, when the barrel-shift copy loop is used."	| dWid sxLowBits dxLowBits pixPerM1 |	self inline: true.	pixPerM1 _ destPPW - 1.  "A mask, assuming power of two"	sxLowBits _ sx bitAnd: pixPerM1.	dxLowBits _ dx bitAnd: pixPerM1.	"check if need to preload buffer	(i.e., two words of source needed for first word of destination)"	hDir > 0 ifTrue:		["n Bits stored in 1st word of dest"		dWid _ bbW min: destPPW - dxLowBits.		preload _ (sxLowBits + dWid) > pixPerM1]	ifFalse:		[dWid _ bbW min: dxLowBits + 1.		preload _ (sxLowBits - dWid + 1) < 0].	"calculate right-shift skew from source to dest"	sourceMSB "equal to destMSB so it doesn't matter"		ifTrue:[skew _ (sxLowBits - dxLowBits) * destDepth] 		ifFalse:[skew _ (dxLowBits - sxLowBits) * destDepth].  " -32..32 "	preload ifTrue: 		[skew < 0			ifTrue: [skew _ skew+32]			ifFalse: [skew _ skew-32]].	"Calc byte addr and delta from longWord info"	sourceIndex _ sourceBits + (sy * sourcePitch) + ((sx // sourcePPW) *4).	"calculate increments from end of 1 line to start of next"	sourceDelta _ (sourcePitch * vDir) - (4 * (nWords * hDir)).	preload ifTrue:		["Compensate for extra source word fetched"		sourceDelta _ sourceDelta - (4*hDir)].! !!FXBltSimulation methodsFor: 'setup' stamp: 'ar 1/10/2000 23:31'!warpBits	"obsolete"	self copyBits.! !!FXBltSimulation methodsFor: 'setup' stamp: 'ar 2/13/2000 15:48'!warpSetup	"Setup values for faster pixel fetching in WarpBlt."	| depth |	self inline: true.	"warpSrcShift = log2(sourceDepth)"	warpSrcShift _ 0.	depth _ sourceDepth.	[depth = 1] whileFalse:[		warpSrcShift _ warpSrcShift + 1.		depth _ depth >> 1].	"warpSrcMask = mask for extracting one pixel from source word"	warpSrcMask _ maskTable at: sourceDepth.	"warpAlignShift: Shift for aligning x position to word boundary"	warpAlignShift _ 5 - warpSrcShift.	"warpAlignMask: Mask for extracting the pixel position from an x position"	warpAlignMask _ 1 << warpAlignShift - 1.	"Setup the lookup table for source bit shifts"	"warpBitShiftTable: given an sub-word x value what's the bit shift?"	0 to: warpAlignMask do:[:i|		sourceMSB			ifTrue:[warpBitShiftTable at: i put: 32 - ( i + 1 << warpSrcShift )]			ifFalse:[warpBitShiftTable at: i put: (i << warpSrcShift)]].! !!FXBltSimulation methodsFor: 'inner loop' stamp: 'ar 2/13/2000 15:50'!alphaSourceBlendBits16	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 16		sourceForm ~= destForm.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift ditherBase ditherIndex ditherThreshold |	self inline: false. "This particular method should be optimized in itself"	pixelDepth _ 32.	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	srcShift _ (dx bitAnd: 1) * 16.	destMSB ifTrue:[srcShift _ 16 - srcShift].	mask1 _ 16rFFFF << (16 - srcShift).	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		srcIndex _ sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex _ destBits + (dstY * destPitch) + (dx // 2 * 4).		ditherBase _ (dstY bitAnd: 3) * 4.		ditherIndex _ (sx bitAnd: 3) - 1. "For pre-increment"		deltaX _ bbW + 1. "So we can pre-decrement"		dstMask _ mask1.		dstMask = 16rFFFF ifTrue:[srcShift _ 16] ifFalse:[srcShift _ 0].		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			ditherThreshold _ ditherMatrix4x4 at: ditherBase + (ditherIndex _ ditherIndex + 1 bitAnd: 3).			sourceWord _ self srcLongAt: srcIndex.			srcAlpha _ sourceWord >> 24.			srcAlpha = 255 ifTrue:[				"Dither from 32 to 16 bit"				sourceWord _ self dither32To16: sourceWord threshold: ditherThreshold.				sourceWord = 0 ifTrue:[sourceWord _ 1].				sourceWord _ sourceWord << srcShift.				"Store masked value"				self dstLongAt: dstIndex put: sourceWord mask: dstMask.			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifTrue:[				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord _ self dstLongAt: dstIndex.					destWord _ destWord bitAnd: dstMask bitInvert32.					destWord _ destWord >> srcShift.					"Expand from 16 to 32 bit by adding zero bits"					destWord _ (((destWord bitAnd: 16r7C00) bitShift: 9) bitOr:									((destWord bitAnd: 16r3E0) bitShift: 6)) bitOr:								(((destWord bitAnd: 16r1F) bitShift: 3) bitOr:									16rFF000000).					"Mix colors"					sourceWord _ self alphaBlendScaled: sourceWord with: destWord.					"And dither"					sourceWord _ self dither32To16: sourceWord threshold: ditherThreshold.					sourceWord = 0 ifTrue:[sourceWord _ 1].					sourceWord _ sourceWord << srcShift.					"Store back"					self dstLongAt: dstIndex put: sourceWord mask: dstMask.				].			].			srcIndex _ srcIndex + 4.			destMSB				ifTrue:[srcShift = 0 ifTrue:[dstIndex _ dstIndex + 4]]				ifFalse:[srcShift = 0 ifFalse:[dstIndex _ dstIndex + 4]].			srcShift _ srcShift bitXor: 16. "Toggle between 0 and 16"			dstMask _ dstMask bitInvert32. "Mask other half word"		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!FXBltSimulation methodsFor: 'inner loop' stamp: 'ar 1/16/2000 17:09'!alphaSourceBlendBits32	"This version assumes 		combinationRule = 34		sourcePixSize = destPixSize = 32		sourceForm ~= destForm.	Note: The inner loop has been optimized for dealing		with the special cases of srcAlpha = 0.0 and srcAlpha = 1.0 	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY srcY dstY |	self inline: false. "This particular method should be optimized in itself"	"Give the compile a couple of hints"	self var: #sourceWord declareC:'register int sourceWord'.	self var: #deltaX declareC:'register int deltaX'.	"The following should be declared as pointers so the compiler will	notice that they're used for accessing memory locations 	(good to know on an Intel architecture) but then the increments	would be different between ST code and C code so must hope the	compiler notices what happens (MS Visual C does)"	self var: #srcIndex declareC:'register int srcIndex'.	self var: #dstIndex declareC:'register int dstIndex'.	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		srcIndex _ sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex _ destBits + (dstY * destPitch) + (dx * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ self srcLongAt: srcIndex.			srcAlpha _ sourceWord >> 24.			srcAlpha = 255 ifTrue:[				self dstLongAt: dstIndex put: sourceWord.				srcIndex _ srcIndex + 4.				dstIndex _ dstIndex + 4.				"Now copy as many words as possible with alpha = 255"				[(deltaX _ deltaX - 1) ~= 0 and:[					(sourceWord _ self srcLongAt: srcIndex) >> 24 = 255]]						whileTrue:[							self dstLongAt: dstIndex put: sourceWord.							srcIndex _ srcIndex + 4.							dstIndex _ dstIndex + 4.						].				"Adjust deltaX"				deltaX _ deltaX + 1.			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifTrue:[					srcIndex _ srcIndex + 4.					dstIndex _ dstIndex + 4.					"Now skip as many words as possible,"					[(deltaX _ deltaX - 1) ~= 0 and:[						(sourceWord _ self srcLongAt: srcIndex) >> 24 = 0]]						whileTrue:[							srcIndex _ srcIndex + 4.							dstIndex _ dstIndex + 4.						].					"Adjust deltaX"					deltaX _ deltaX + 1.				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord _ self dstLongAt: dstIndex.					destWord _ self alphaBlendScaled: sourceWord with: destWord.					self dstLongAt: dstIndex put: destWord.					srcIndex _ srcIndex + 4.					dstIndex _ dstIndex + 4.				].			].		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!FXBltSimulation methodsFor: 'inner loop' stamp: 'ar 2/13/2000 15:50'!alphaSourceBlendBits8	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 8		sourceForm ~= destForm.	Note: This is not real blending since we don't have the source colors available.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift adjust |	self inline: false. "This particular method should be optimized in itself"	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	mask1 _ (dx bitAnd: 3) * 8.	destMSB ifTrue:[mask1 _ 24 - mask1].	mask2 _ AllOnes bitXor:(16rFF << mask1).	(dx bitAnd: 1) = 0 		ifTrue:[adjust _ 0]		ifFalse:[adjust _ 16r1F1F1F1F].	(dy bitAnd: 1) = 0		ifTrue:[adjust _ adjust bitXor: 16r1F1F1F1F].	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		adjust _ adjust bitXor: 16r1F1F1F1F.		srcIndex _ sourceBits + (srcY * sourcePitch) + (sx * 4).		dstIndex _ destBits + (dstY * destPitch) + (dx // 4 * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		srcShift _ mask1.		dstMask _ mask2.		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ ((self srcLongAt: srcIndex) bitAnd: (adjust bitInvert32)) + adjust.			srcAlpha _ sourceWord >> 24.			srcAlpha > 31 ifTrue:["Everything below 31 is transparent"				srcAlpha < 224 ifTrue:["Everything above 224 is opaque"					destWord _ self dstLongAt: dstIndex.					destWord _ destWord bitAnd: dstMask bitInvert32.					destWord _ destWord >> srcShift.					destWord _ self mapDestPixel: destWord.					sourceWord _ self alphaBlendScaled: sourceWord with: destWord.				].				sourceWord _ self mapPixel: sourceWord.				sourceWord _ sourceWord << srcShift.				"Store back"				self dstLongAt: dstIndex put: sourceWord mask: dstMask.			].			srcIndex _ srcIndex + 4.			destMSB ifTrue:[				srcShift = 0 					ifTrue:[dstIndex _ dstIndex + 4.							srcShift _ 24.							dstMask _ 16r00FFFFFF]					ifFalse:[srcShift _ srcShift - 8.							dstMask _ (dstMask >> 8) bitOr: 16rFF000000].			] ifFalse:[				srcShift = 32					ifTrue:[dstIndex _ dstIndex + 4.							srcShift _ 0.							dstMask _ 16rFFFFFF00]					ifFalse:[srcShift _ srcShift + 8.							dstMask _ dstMask << 8 bitOr: 255].			].			adjust _ adjust bitXor: 16r1F1F1F1F.		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!FXBltSimulation methodsFor: 'inner loop' stamp: 'ar 5/25/2000 15:41'!copyLoop	"This version of the inner loop assumes sourceDepth = destDepth,	noSource = false, noColorMap = noSourceMap = noDestMap = true"	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask destWord mergeFn |	self inline: false.	mergeFn _ opTable at: combinationRule+1.	hInc _ hDir*4.  "Byte delta"	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew _ unskew _ skewMask _ 0]		ifFalse: [skew < 0			ifTrue:				[unskew _ skew+32.				skewMask _ AllOnes << (0-skew)]			ifFalse:				[skew == 0					ifTrue:						[unskew _ 0.						skewMask _ AllOnes]					ifFalse:						[unskew _ skew-32.						skewMask _ AllOnes >> skew]]].	notSkewMask _ skewMask bitInvert32.	noHalftone		ifTrue: [halftoneWord _ AllOnes.  halftoneHeight _ 0]		ifFalse: [halftoneWord _ self halftoneAt: 0].	y _ dy.	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"			[halftoneWord _ self halftoneAt: y.			y _ y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord _ self srcLongAt: sourceIndex.			sourceIndex _ sourceIndex + hInc]			ifFalse:			[prevWord _ 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			thisWord _ self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			destWord _ self dstLongAt: destIndex.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord) 								with: destWord								function: mergeFn.			destWord _ (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex _ destIndex + hInc.		"This central horizontal loop requires no store masking"		destMask _ AllOnes.combinationRule = 3ifTrue: [noHalftone & (notSkewMask = 0)		ifTrue:  		["Very special inner loop for STORE mode with no skew -- just move words"		2 to: nWords-1 do: 			[ :word |			thisWord _ self srcLongAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			self dstLongAt: destIndex put: thisWord.			destIndex _ destIndex + hInc]]		ifFalse:		["Special inner loop for STORE mode -- no need to call merge"		2 to: nWords-1 do: 			[ :word |			thisWord _ self srcLongAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			self dstLongAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex _ destIndex + hInc]]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord _ self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)							with: (self dstLongAt: destIndex)							function: mergeFn.			self dstLongAt: destIndex put: mergeWord.			destIndex _ destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			thisWord _ self srcLongAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			destWord _ self dstLongAt: destIndex.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord) with: destWord function: mergeFn.			destWord _ (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex _ destIndex + hInc].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]! !!FXBltSimulation methodsFor: 'inner loop' stamp: 'ar 5/25/2000 15:41'!copyLoopNoSource	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused.	Note: This is the common fill loop without any fancy stuff."	| halftoneWord mergeWord destWord mergeFn |	self inline: false.	mergeFn _ opTable at: combinationRule+1.	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ self halftoneAt: dy+i-1].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			destWord _ self dstLongAt: destIndex.			mergeWord _ self merge: halftoneWord							with: destWord							function: mergeFn.			destWord _ (destMask bitAnd: mergeWord) bitOr: 							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex _ destIndex + 4.		"This central horizontal loop requires no store masking"			destMask _ AllOnes.			combinationRule = 3 ifTrue: ["Special inner loop for STORE"				destWord _ halftoneWord.				2 to: nWords-1 do:[ :word |					self dstLongAt: destIndex put: destWord.					destIndex _ destIndex + 4].			] ifFalse:[ "Normal inner loop does merge"				2 to: nWords-1 do:[ :word | "Normal inner loop does merge"					destWord _ self dstLongAt: destIndex.					mergeWord _ self merge: halftoneWord with: destWord function: mergeFn.					self dstLongAt: destIndex put: mergeWord.					destIndex _ destIndex + 4].			].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			destWord _ self dstLongAt: destIndex.			mergeWord _ self merge: halftoneWord with: destWord function: mergeFn.			destWord _ (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex _ destIndex + 4].	destIndex _ destIndex + destDelta]! !!FXBltSimulation methodsFor: 'inner loop' stamp: 'ar 5/25/2000 15:41'!copyLoopNoSourcePixels	"This version of the inner loop maps dest pixels one at a time.	Note: This loop is typically used for filling with alpha values.	Note2: There is probably some significant speedup in here	but for now I just need a version that does the job..."	| nPix dstShift destWord dstIndex nLines dstMask lastDstPix destPix dstMapped resultMapped resultPix halftoneWord dstPaint mergeFn |	self inline: false.	mergeFn _ opTable at: combinationRule+1.	dstPaint _ combinationRule = 36.	"Additional inits"	dstMask _ maskTable at: destDepth.	dstIndex _ destIndex.	"Precomputed shifts for pickSourcePixels"	dstShift _ ((dx bitAnd: destPPW - 1) * destDepth).	destMSB ifTrue:[dstShift _ 32 - destDepth - dstShift].	dstBitShift _ dstShift.	destMask _ -1.	pixelDepth _ 32.	nLines _ bbH.	["this is the vertical loop"		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ self halftoneAt: bbH - nLines].		destWord _ self dstLongAt: dstIndex.		"Prefetch first dest pixel"		lastDstPix _ destPix _ destWord >> dstShift bitAnd: dstMask.		dstMapped _ self mapDestPixel: destPix.		nPix _ bbW.		["this is the horizontal loop"			(dstPaint and:[destPix = destAlphaKey])				ifTrue:[resultMapped _ dstMapped]				ifFalse:[resultMapped _ self merge: halftoneWord with: dstMapped function: mergeFn].			(noColorMap and:[resultMapped = dstMapped]) ifFalse:[				resultPix _ self mapPixel: resultMapped.				destWord _ destWord bitAnd: (dstMask << dstShift) bitInvert32.				destWord _ destWord bitOr: (resultPix bitAnd: dstMask) << dstShift.			].			destMSB ifTrue:[				"Adjust dest if at pixel boundary"				(dstShift _ dstShift - destDepth) < 0 ifTrue:					[dstShift _ dstShift + 32.					self dstLongAt: dstIndex put: destWord.					destWord _ self dstLongAt: (dstIndex _ dstIndex + 4)].			] ifFalse:[				"Adjust dest if at pixel boundary"				(dstShift _ dstShift + destDepth) > 31 ifTrue:					[dstShift _ dstShift - 32.					self dstLongAt: dstIndex put: destWord.					destWord _ self dstLongAt: (dstIndex _ dstIndex + 4)].			].		(nPix _ nPix - 1) = 0] whileFalse:[			"Fetch next dest pixel"			destPix _ destWord >> dstShift bitAnd: dstMask.			lastDstPix = destPix ifFalse:[				dstMapped _ self mapDestPixel: destPix.				lastDstPix _ destPix]		].	(nLines _ nLines - 1) = 0] whileFalse:[		"Store last modified word"		self dstLongAt: dstIndex put: destWord.		"Advance destIndex"		dstIndex _ destIndex _ destIndex + destPitch.		dstShift _ dstBitShift.	].	"Store final destWord"	self dstLongAt: dstIndex put: destWord.! !!FXBltSimulation methodsFor: 'inner loop' stamp: 'ar 5/25/2000 15:41'!copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.	Note: Special care is taken to handle source paint mode correctly."	| skewWord halftoneWord mergeWord scrStartBits nSourceIncs startBits endBits 	sourcePixMask destPixMask nPix srcShift dstShift destWord 	words srcPaint mergeFn |	"Note: This method is inlined for specialization of LSB-MSB conversion"	self inline: true.	mergeFn _ opTable at: combinationRule+1.	srcPaint _ srcKeyMode.	"Additional inits peculiar to unequal source and dest pix size..."	sourcePixMask _ maskTable at: sourceDepth.	destPixMask _ maskTable at: destDepth.	sourceIndex _ sourceBits + (sy * sourcePitch) + ((sx // sourcePPW) *4).	scrStartBits _ sourcePPW - (sx bitAnd: sourcePPW-1).	bbW < scrStartBits		ifTrue: [nSourceIncs _ 0]		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//sourcePPW + 1].	sourceDelta _ sourcePitch - (nSourceIncs * 4).	"Note following two items were already calculated in destmask setup!!"	startBits _ destPPW - (dx bitAnd: destPPW-1).	endBits _ ((dx + bbW - 1) bitAnd: destPPW-1) + 1.	bbW < startBits ifTrue:[startBits _ bbW].	"Precomputed shifts for pickSourcePixels"	srcShift _ ((sx bitAnd: sourcePPW - 1) * sourceDepth).	dstShift _ ((dx bitAnd: destPPW - 1) * destDepth).	sourceMSB ifTrue:[srcShift _ 32 - sourceDepth - srcShift].	destMSB ifTrue:[dstShift _ 32 - destDepth - dstShift].	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue:[halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ self halftoneAt: dy+i-1].		"setup first load"		srcBitShift _ srcShift.		dstBitShift _ dstShift.		destMask _ mask1.		nPix _ startBits.		"Here is the horizontal loop..."		words _ nWords.			["pick up the word"			destWord _ self dstLongAt: destIndex.			skewWord _ self pickSourcePixels: nPix							srcMask: sourcePixMask 							destMask: destPixMask							paintMode: srcPaint							destWord: destWord.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)							with: (destWord bitAnd: destMask)							function: mergeFn.			destWord _ (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex _ destIndex + 4.			words = 2 "e.g., is the next word the last word?"				ifTrue:["set mask for last word in this row"						destMask _ mask2.						nPix _ endBits]				ifFalse:["use fullword mask for inner loop"						destMask _ AllOnes.						nPix _ destPPW].			(words _ words - 1) = 0] whileFalse.		"--- end of inner loop ---"		sourceIndex _ sourceIndex + sourceDelta.		destIndex _ destIndex + destDelta]! !!FXBltSimulation methodsFor: 'inner loop' stamp: 'ar 5/25/2000 15:41'!copyLoopPixels	"This version of the inner loop maps source pixels and dest pixels one at a time. This is the most general (and slowest) version which must also keep track of source and dest paint mode by itself."	| nPix srcShift dstShift destWord srcIndex dstIndex nLines sourceWord lastSrcPix sourcePix srcMask dstMask srcMapped lastDstPix destPix dstMapped resultMapped resultPix srcPaint dstPaint paintMode mergeFn |	self inline: false.	mergeFn _ opTable at: combinationRule+1.	srcPaint _ srcKeyMode.	dstPaint _ dstKeyMode.	paintMode _ srcPaint | dstPaint.	"Additional inits"	srcMask _ maskTable at: sourceDepth.	dstMask _ maskTable at: destDepth.	sourceIndex _ srcIndex _ sourceBits + (sy * sourcePitch) + ((sx // sourcePPW) *4).	dstIndex _ destIndex.	"Precomputed shifts for pickSourcePixels"	srcShift _ ((sx bitAnd: sourcePPW - 1) * sourceDepth).	dstShift _ ((dx bitAnd: destPPW - 1) * destDepth).	sourceMSB ifTrue:[srcShift _ 32 - sourceDepth - srcShift].	destMSB ifTrue:[dstShift _ 32 - destDepth - dstShift].	srcBitShift _ srcShift.	dstBitShift _ dstShift.	noSourceMap 		ifTrue:[pixelDepth _ sourceDepth]		ifFalse:[pixelDepth _ 32].	destMask _ -1.	nLines _ bbH.	["this is the vertical loop"		sourceWord _ self srcLongAt: srcIndex.		destWord _ self dstLongAt: dstIndex.		"Prefetch first source pixel"		lastSrcPix _ sourcePix _ sourceWord >> srcShift bitAnd: srcMask.		srcMapped _ self mapSourcePixel: sourcePix.		"Prefetch first dest pixel"		lastDstPix _ destPix _ destWord >> dstShift bitAnd: dstMask.		dstMapped _ self mapDestPixel: destPix.		nPix _ bbW.		["this is the horizontal loop"			(paintMode) ifTrue:[				((srcPaint and:[sourcePix = sourceAlphaKey])					or:[dstPaint and:[destPix ~= destAlphaKey]])						ifTrue:[resultMapped _ dstMapped]						ifFalse:[	resultMapped _ self merge: srcMapped with: dstMapped function: mergeFn].			] ifFalse:[				resultMapped _ self merge: srcMapped with: dstMapped function: mergeFn.			].			(noColorMap and:[resultMapped = dstMapped]) ifFalse:[				resultPix _ self mapPixel: resultMapped.				destWord _ destWord bitAnd: (dstMask << dstShift) bitInvert32.				destWord _ destWord bitOr: (resultPix bitAnd: dstMask) << dstShift.			].			sourceMSB ifTrue:[				"Adjust source if at pixel boundary"				(srcShift _ srcShift - sourceDepth) < 0 ifTrue:					[srcShift _ srcShift + 32.					sourceWord _ self srcLongAt: (srcIndex _ srcIndex + 4)].			] ifFalse:[				"Adjust source if at pixel boundary"				(srcShift _ srcShift + sourceDepth) > 31 ifTrue:					[srcShift _ srcShift - 32.					sourceWord _ self srcLongAt: (srcIndex _ srcIndex + 4)].			].			destMSB ifTrue:[				"Adjust dest if at pixel boundary"				(dstShift _ dstShift - destDepth) < 0 ifTrue:					[dstShift _ dstShift + 32.					self dstLongAt: dstIndex put: destWord.					destWord _ self dstLongAt: (dstIndex _ dstIndex + 4)].			] ifFalse:[				"Adjust dest if at pixel boundary"				(dstShift _ dstShift + destDepth) > 31 ifTrue:					[dstShift _ dstShift - 32.					self dstLongAt: dstIndex put: destWord.					destWord _ self dstLongAt: (dstIndex _ dstIndex + 4)].			].		(nPix _ nPix - 1) = 0] whileFalse:[			"Fetch next source/dest pixel"			sourcePix _ sourceWord >> srcShift bitAnd: srcMask.			lastSrcPix = sourcePix ifFalse:[				srcMapped _ self mapSourcePixel: sourcePix.				lastSrcPix _ sourcePix].			destPix _ destWord >> dstShift bitAnd: dstMask.			lastDstPix = destPix ifFalse:[				dstMapped _ self mapDestPixel: destPix.				lastDstPix _ destPix]		].	(nLines _ nLines - 1) = 0] whileFalse:[		"Store last destWord"		self dstLongAt: dstIndex put: destWord.		"Advance sourceIndex, destIndex"		srcIndex _ sourceIndex _ sourceIndex + sourcePitch.		dstIndex _ destIndex _ destIndex + destPitch.		srcShift _ srcBitShift.		dstShift _ dstBitShift.	].	"Store final destWord"	self dstLongAt: dstIndex put: destWord.! !!FXBltSimulation methodsFor: 'inner loop' stamp: 'ar 2/16/2000 18:43'!merge: sourceWord with: destinationWord function: mergeFn	^self perform: (self cCoerce: mergeFn to: 'int (*) (int, int)')		with: sourceWord		with: destinationWord! !!FXBltSimulation methodsFor: 'inner loop' stamp: 'ar 5/25/2000 15:41'!warpLoop	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation."	| skewWord halftoneWord mergeWord startBits	deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy pBx pBy	xDelta yDelta nSteps nPix words destWord endBits 	srcPaint mergeFn |	"We want to inline this into the specialized versions"	self inline: true.	false ifTrue:[	"Check if we have a simple scaling and can short cut this into scaleLoop"	((warpQuad at: 0) "p1x" = (warpQuad at: 2) "p2x"		and:[(warpQuad at: 4) "p3x" = (warpQuad at: 6) "p4x"		and:[(warpQuad at: 1) "p1y" = (warpQuad at: 7) "p4y"		and:[(warpQuad at: 3) "p2y" = (warpQuad at: 5) "p3y"]]])			ifTrue:["^self scaleLoop"]].	mergeFn _ opTable at: combinationRule+1.	srcPaint _ srcKeyMode. 	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ warpQuad at: 0.	words _ warpQuad at: 2.	deltaP12x _ self deltaFrom: pAx to: words nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ words - (nSteps*deltaP12x)].	pAy _ warpQuad at: 1.	words _ warpQuad at: 3.	deltaP12y _ self deltaFrom: pAy to: words nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ words - (nSteps*deltaP12y)].	pBx _ warpQuad at: 6.	words _ warpQuad at: 4.	deltaP43x _ self deltaFrom: pBx to: words nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ words - (nSteps*deltaP43x)].	pBy _ warpQuad at: 7.	words _ warpQuad at: 5.	deltaP43y _ self deltaFrom: pBy to: words nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ words - (nSteps*deltaP43y)].	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	startBits _ destPPW - (dx bitAnd: destPPW-1).	endBits _ ((dx + bbW - 1) bitAnd: destPPW-1) + 1. 	bbW < startBits ifTrue:[startBits _ bbW].	destY < clipY ifTrue:[		"Advance increments if there was clipping in y"		pAx _ pAx + (clipY - destY * deltaP12x).		pAy _ pAy + (clipY - destY * deltaP12y).		pBx _ pBx + (clipY - destY * deltaP43x).		pBy _ pBy + (clipY - destY * deltaP43y)].	"Setup values for faster pixel fetching."	self warpSetup.	1 to: bbH do:		[ :i | "here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pBx - (nSteps*xDelta)].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pBy - (nSteps*yDelta)].		destMSB			ifTrue:[dstBitShift _ 32 - ((dx bitAnd: destPPW - 1) + 1 * destDepth)]			ifFalse:[dstBitShift _ (dx bitAnd: destPPW - 1) * destDepth].		(destX < clipX) ifTrue:[			"Advance increments if there was clipping in x"			sx _ sx + (clipX - destX * xDelta).			sy _ sy + (clipX - destX * yDelta).		].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ self halftoneAt: dy+i-1].		destMask _ mask1.		nPix _ startBits.		"Here is the inner loop..."		words _ nWords.			["pick up word"			destWord _ self dstLongAt: destIndex.			warpQuality = 1 ifTrue:["Faster if not smoothing"				skewWord _ self warpPickSourcePixels: nPix								xDeltah: xDelta yDeltah: yDelta								xDeltav: deltaP12x yDeltav: deltaP12y								paintMode: srcPaint destWord: destWord			] ifFalse:["more difficult with smoothing"				skewWord _ self warpPickSmoothPixels: nPix						xDeltah: xDelta yDeltah: yDelta						xDeltav: deltaP12x yDeltav: deltaP12y						paintMode: srcPaint destWord: destWord.			].			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)							with: (destWord bitAnd: destMask)							function: mergeFn.			destWord _ (destMask bitAnd: mergeWord) bitOr:							(destWord bitAnd: destMask bitInvert32).			self dstLongAt: destIndex put: destWord.			destIndex _ destIndex + 4.			words = 2 "e.g., is the next word the last word?"				ifTrue:["set mask for last word in this row"						destMask _ mask2.						nPix _ endBits]				ifFalse:["use fullword mask for inner loop"						destMask _ AllOnes.						nPix _ destPPW].			(words _ words - 1) = 0] whileFalse.		"--- end of inner loop ---"		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y.		destIndex _ destIndex + destDelta]! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/17/2000 19:55'!OLDrgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination	and return the number of differing pixels.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| diff pixMask |	self inline: false.	diff _ sourceWord bitXor: destinationWord.	pixMask _ maskTable at: pixelDepth.	[diff = 0] whileFalse:		[(diff bitAnd: pixMask) ~= 0 ifTrue: [bitCount _ bitCount + 1].		diff _ diff >> pixelDepth].	^ destinationWord "for no effect".! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/16/2000 21:32'!OLDtallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the tally map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord |	tallyMapSize = 0 ifTrue: [^ destinationWord "no op"].	"loop through all packed pixels."	pixMask _ maskTable at: pixelDepth.	shiftWord _ destinationWord.	1 to: destPPW do:[:i |		mapIndex _ shiftWord bitAnd: pixMask.		mapIndex _ self mapPixel: mapIndex.		(mapIndex >= 0 and:[mapIndex < tallyMapSize]) ifTrue:[			tallyMap at: mapIndex put: (tallyMap at: mapIndex) + 1.		].		shiftWord _ shiftWord >> pixelDepth].	^ destinationWord! !!FXBltSimulation methodsFor: 'combination rules'!addWord: sourceWord with: destinationWord	^sourceWord + destinationWord! !!FXBltSimulation methodsFor: 'combination rules'!alphaBlend: sourceWord with: destinationWord	"Blend sourceWord with destinationWord, assuming both are 32-bit pixels.	The source is assumed to have 255*alpha in the high 8 bits of each pixel,	while the high 8 bits of the destinationWord will be ignored.	The blend produced is alpha*source + (1-alpha)*dest, with	the computation being performed independently on each color	component.  The high byte of the result will be 0."	| alpha unAlpha colorMask result blend shift |	self inline: false.	alpha _ sourceWord >> 24.  "High 8 bits of source pixel"	unAlpha _ 255 - alpha.	colorMask _ 16rFF.	result _ 0.	1 to: 3 do:		[:i | shift _ (i-1)*8.		blend _ (((sourceWord>>shift bitAnd: colorMask) * alpha)					+ ((destinationWord>>shift bitAnd: colorMask) * unAlpha))			 	+ 254 // 255 bitAnd: colorMask.		result _ result bitOr: blend<<shift].	^ result! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/22/2000 15:55'!alphaBlendConst: sourceWord with: destinationWord	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: false! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 2/9/2000 22:59'!alphaBlendConst: sourceWord with: destinationWord paintMode: paintMode	"Blend sourceWord with destinationWord using a constant alpha.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	The blend produced is alpha*source + (1.0-alpha)*dest, with the	computation being performed independently on each color component.	This function could eventually blend into any depth destination,	using the same color averaging and mapping as warpBlt.	paintMode = true means do nothing if the source pixel value is zero."	"This first implementation works with dest depths of 16 and 32 bits only.	Normal color mapping will allow sources of lower depths in this case,	and results can be mapped directly by truncation, so no extra color maps are needed.	To allow storing into any depth will require subsequent addition of two other	colormaps, as is the case with WarpBlt."	| pixMask destShifted sourceShifted destPixVal rgbMask sourcePixVal unAlpha result pixBlend shift blend maskShifted bitsPerColor ppw |	self inline: false.	pixelDepth < 16 ifTrue: [^ destinationWord "no-op"].	unAlpha _ 255 - sourceAlpha.	pixMask _ maskTable at: pixelDepth.	pixelDepth = 16 		ifTrue: [bitsPerColor _ 5. ppw _ 2]		ifFalse:[bitsPerColor _ 8. ppw _ 1].	rgbMask _ (1<<bitsPerColor) - 1.	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	result _ destinationWord.	1 to: ppw do:		[:j |		sourcePixVal _ sourceShifted bitAnd: pixMask.		((maskShifted bitAnd: pixMask) = 0  "no effect if outside of dest rectangle"			or: [paintMode & (sourcePixVal = 0)  "or painting a transparent pixel"])		ifFalse:			[destPixVal _ destShifted bitAnd: pixMask.			pixBlend _ 0.			1 to: 3 do:				[:i | shift _ (i-1)*bitsPerColor.				blend _ (((sourcePixVal>>shift bitAnd: rgbMask) * sourceAlpha)							+ ((destPixVal>>shift bitAnd: rgbMask) * unAlpha))					 	+ 254 // 255 bitAnd: rgbMask.				pixBlend _ pixBlend bitOr: blend<<shift].			pixelDepth = 16				ifTrue: [result _ (result bitAnd: (pixMask << (j-1*16)) bitInvert32)									bitOr: pixBlend << (j-1*16)]				ifFalse: [result _ pixBlend]].		maskShifted _ maskShifted >> pixelDepth.		sourceShifted _ sourceShifted >> pixelDepth.		destShifted _ destShifted >> pixelDepth].	^ result! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 11/27/1998 23:56'!alphaBlendScaled: sourceWord with: destinationWord	"Blend sourceWord with destinationWord using the alpha value from sourceWord.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	In contrast to alphaBlend:with: the color produced is		srcColor + (1-srcAlpha) * dstColor	e.g., it is assumed that the source color is already scaled."	| unAlpha dstMask srcMask b g r a |	self inline: false.	"Do NOT inline this into optimized loops"	unAlpha _ 255 - (sourceWord >> 24).  "High 8 bits of source pixel"	dstMask _ destinationWord.	srcMask _ sourceWord.	b _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	b > 255 ifTrue:[b _ 255].	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	g _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	g > 255 ifTrue:[g _ 255].	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	r _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	r > 255 ifTrue:[r _ 255].	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	a _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	a > 255 ifTrue:[a _ 255].	^(((((a << 8) + r) << 8) + g) << 8) + b! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 19:56'!alphaPaintConst: sourceWord with: destinationWord	sourceWord = 0 ifTrue: [^ destinationWord  "opt for all-transparent source"].	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: true! !!FXBltSimulation methodsFor: 'combination rules'!bitAnd: sourceWord with: destinationWord	^sourceWord bitAnd: destinationWord! !!FXBltSimulation methodsFor: 'combination rules'!bitAndInvert: sourceWord with: destinationWord	^sourceWord bitAnd: destinationWord bitInvert32! !!FXBltSimulation methodsFor: 'combination rules'!bitInvertAnd: sourceWord with: destinationWord	^sourceWord bitInvert32 bitAnd: destinationWord! !!FXBltSimulation methodsFor: 'combination rules'!bitInvertAndInvert: sourceWord with: destinationWord	^sourceWord bitInvert32 bitAnd: destinationWord bitInvert32! !!FXBltSimulation methodsFor: 'combination rules'!bitInvertDestination: sourceWord with: destinationWord	^destinationWord bitInvert32! !!FXBltSimulation methodsFor: 'combination rules'!bitInvertOr: sourceWord with: destinationWord	^sourceWord bitInvert32 bitOr: destinationWord! !!FXBltSimulation methodsFor: 'combination rules'!bitInvertOrInvert: sourceWord with: destinationWord	^sourceWord bitInvert32 bitOr: destinationWord bitInvert32! !!FXBltSimulation methodsFor: 'combination rules'!bitInvertSource: sourceWord with: destinationWord	^sourceWord bitInvert32! !!FXBltSimulation methodsFor: 'combination rules'!bitInvertXor: sourceWord with: destinationWord	^sourceWord bitInvert32 bitXor: destinationWord! !!FXBltSimulation methodsFor: 'combination rules'!bitOr: sourceWord with: destinationWord	^sourceWord bitOr: destinationWord! !!FXBltSimulation methodsFor: 'combination rules'!bitOrInvert: sourceWord with: destinationWord	^sourceWord bitOr: destinationWord bitInvert32! !!FXBltSimulation methodsFor: 'combination rules'!bitXor: sourceWord with: destinationWord	^sourceWord bitXor: destinationWord! !!FXBltSimulation methodsFor: 'combination rules'!clearWord: source with: destination	^ 0! !!FXBltSimulation methodsFor: 'combination rules'!destinationWord: sourceWord with: destinationWord	^destinationWord! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/16/2000 17:24'!dstPaint: sourceWord with: destinationWord	"Replace those pixels in destinationWord where the	pixel value is equal to destAlphaKey."	| mask key result val |	self inline: false.	mask _ maskTable at: pixelDepth.	key _ destAlphaKey.	result _ 0.	0 to: destPPW-1 do:[:i|		(val _ destinationWord bitAnd: mask) = key			ifTrue:[result _ result bitOr: (sourceWord bitAnd: mask)]			ifFalse:[result _ result bitOr: val].		mask _ mask << pixelDepth.		key _ key << pixelDepth].	^result! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:18'!partitionedAND: word1 to: word2 nBits: nBits nPartitions: nParts	"AND word1 to word2 as nParts partitions of nBits each.	Any field of word1 not all-ones is treated as all-zeroes.	Used for erasing, eg, brush shapes prior to ORing in a color"	| mask result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		(word1 bitAnd: mask) = mask			ifTrue: [result _ result bitOr: (word2 bitAnd: mask)].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:35'!partitionedAdd: word1 to: word2 nBits: nBits nPartitions: nParts	"Add word1 to word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask sum result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		sum _ (word1 bitAnd: mask) + (word2 bitAnd: mask).		sum <= mask  "result must not carry out of partition"			ifTrue: [result _ result bitOr: sum]			ifFalse: [result _ result bitOr: mask].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:35'!partitionedMax: word1 with: word2 nBits: nBits nPartitions: nParts	"Max word1 to word2 as nParts partitions of nBits each"	| mask result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		result _ result bitOr: ((word2 bitAnd: mask) max: (word1 bitAnd: mask)).		mask _ mask << nBits  "slide left to next partition"].	^ result! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:35'!partitionedMin: word1 with: word2 nBits: nBits nPartitions: nParts	"Min word1 to word2 as nParts partitions of nBits each"	| mask result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		result _ result bitOr: ((word2 bitAnd: mask) min: (word1 bitAnd: mask)).		mask _ mask << nBits  "slide left to next partition"].	^ result! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:36'!partitionedSub: word1 from: word2 nBits: nBits nPartitions: nParts	"Subtract word1 from word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask result p1 p2 |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		p1 _ word1 bitAnd: mask.		p2 _ word2 bitAnd: mask.		p1 < p2  "result is really abs value of thedifference"			ifTrue: [result _ result bitOr: p2 - p1]			ifFalse: [result _ result bitOr: p1 - p2].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/22/2000 16:08'!pixMask: sourceWord with: destinationWord	self inline: false.	^ self partitionedAND: sourceWord bitInvert32 to: destinationWord					nBits: destDepth nPartitions: destPPW! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/22/2000 16:09'!pixPaint: sourceWord with: destinationWord	self inline: false.	sourceWord = 0 ifTrue: [^ destinationWord].	^ sourceWord bitOr:		(self partitionedAND: sourceWord bitInvert32 to: destinationWord						nBits: destDepth nPartitions: destPPW)! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/16/2000 17:11'!rgbAdd: sourceWord with: destinationWord	self inline: false.	pixelDepth < 16 ifTrue:		["Add each pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: pixelDepth nPartitions: destPPW].	pixelDepth = 16 ifTrue:		["Add RGB components of each pixel separately"		^ (self partitionedAdd: sourceWord to: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedAdd: sourceWord>>16 to: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Add RGB components of the pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: 8 nPartitions: 3]! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/17/2000 19:57'!rgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination	and return the number of differing pixels."	| pixMask destShifted sourceShifted destPixVal sourcePixVal maskShifted |	self inline: false.	pixMask _ maskTable at: pixelDepth.	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	1 to: destPPW do:		[:i |		(maskShifted bitAnd: pixMask) > 0 ifTrue:			["Only tally pixels within the destination rectangle"			destPixVal _ destShifted bitAnd: pixMask.			sourcePixVal _ sourceShifted bitAnd: pixMask.			sourcePixVal = destPixVal ifFalse: [bitCount _ bitCount + 1]].		maskShifted _ maskShifted >> pixelDepth.		sourceShifted _ sourceShifted >> pixelDepth.		destShifted _ destShifted >> pixelDepth].	^ destinationWord  "For no effect on dest"! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/16/2000 17:11'!rgbMax: sourceWord with: destinationWord	self inline: false.	pixelDepth < 16 ifTrue:		["Max each pixel separately"		^ self partitionedMax: sourceWord with: destinationWord						nBits: pixelDepth nPartitions: destPPW].	pixelDepth = 16 ifTrue:		["Max RGB components of each pixel separately"		^ (self partitionedMax: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMax: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Max RGB components of the pixel separately"		^ self partitionedMax: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/16/2000 17:13'!rgbMin: sourceWord with: destinationWord	self inline: false.	pixelDepth < 16 ifTrue:		["Min each pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: pixelDepth nPartitions: destPPW].	pixelDepth = 16 ifTrue:		["Min RGB components of each pixel separately"		^ (self partitionedMin: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMin: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Min RGB components of the pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/16/2000 17:14'!rgbMinInvert: wordToInvert with: destinationWord	| sourceWord |	self inline: false.	sourceWord _ wordToInvert bitInvert32.	pixelDepth < 16 ifTrue:		["Min each pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: pixelDepth nPartitions: destPPW].	pixelDepth = 16 ifTrue:		["Min RGB components of each pixel separately"		^ (self partitionedMin: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMin: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Min RGB components of the pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/16/2000 17:14'!rgbSub: sourceWord with: destinationWord	self inline: false.	pixelDepth < 16 ifTrue:		["Sub each pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: pixelDepth nPartitions: destPPW].	pixelDepth = 16 ifTrue:		["Sub RGB components of each pixel separately"		^ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Sub RGB components of the pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3]! !!FXBltSimulation methodsFor: 'combination rules'!sourceWord: sourceWord with: destinationWord	^sourceWord! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 2/10/2000 17:01'!srcPaint: sourceWord with: destinationWord	"Replace those pixels in destinationWord where the	associated pixel in sourceWord is different from sourceAlphaKey.	Note: This will only work for sourceDepth = destDepth."	| mask key result val |	self inline: false.	"Note: If sourceDepth ~= destDepth or warpMode the pixels are pre-merged"	(sourceDepth = destDepth and:[noWarp])		ifFalse:[^sourceWord].	mask _ maskTable at: pixelDepth.	key _ sourceAlphaKey.	result _ 0.	0 to: destPPW-1 do:[:i|		(val _ sourceWord bitAnd: mask) = key			ifTrue:[result _ result bitOr: (destinationWord bitAnd: mask)]			ifFalse:[result _ result bitOr: val].		mask _ mask << pixelDepth.		key _ key << pixelDepth].	^result! !!FXBltSimulation methodsFor: 'combination rules'!subWord: sourceWord with: destinationWord	^sourceWord - destinationWord! !!FXBltSimulation methodsFor: 'combination rules' stamp: 'ar 1/17/2000 19:58'!tallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Those tallied are exactly those	in the destination rectangle.  Note that the source should be 	specified == destination, in order for the proper color map checks 	to be performed at setup."	| mapIndex pixMask mask shiftWord |	self inline: false.	tallyMapSize = 0 ifTrue: [^ destinationWord "no op"].	pixMask _ maskTable at: pixelDepth.	shiftWord _ destinationWord.	mask _ destMask.	1 to: destPPW do:[:i |		(mask bitAnd: pixMask) = 0 ifFalse:[			mapIndex _ shiftWord bitAnd: pixMask.			mapIndex _ self mapPixel: mapIndex.			(mapIndex >= 0 and:[mapIndex < tallyMapSize]) ifTrue:[				tallyMap at: mapIndex put: (tallyMap at: mapIndex) + 1]].		mask _ mask >> pixelDepth.		shiftWord _ shiftWord >> pixelDepth].	^ destinationWord  "For no effect on dest"! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 11/16/1998 00:23'!default8To32Table	"Return the default translation table from 1..8 bit indexed colors to 32bit"	"The table has been generated by the following statements"	"| pvs hex |	String streamContents:[:s|		s nextPutAll:'static unsigned int theTable[256] = { '.		pvs _ (Color colorMapIfNeededFrom: 8 to: 32) asArray.		1 to: pvs size do:[:i|			i > 1 ifTrue:[s nextPutAll:', '].			(i-1 \\ 8) = 0 ifTrue:[s cr].			s nextPutAll:'0x'.			hex _ (pvs at: i) printStringBase: 16.			s nextPutAll: (hex copyFrom: 4 to: hex size).		].		s nextPutAll:'};'.	]."	| theTable |	self returnTypeC:'unsigned int *'.	self var: #theTable declareC:'static unsigned int theTable[256] = { 0x0, 0xFF000001, 0xFFFFFFFF, 0xFF808080, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFF00FFFF, 0xFFFFFF00, 0xFFFF00FF, 0xFF202020, 0xFF404040, 0xFF606060, 0xFF9F9F9F, 0xFFBFBFBF, 0xFFDFDFDF, 0xFF080808, 0xFF101010, 0xFF181818, 0xFF282828, 0xFF303030, 0xFF383838, 0xFF484848, 0xFF505050, 0xFF585858, 0xFF686868, 0xFF707070, 0xFF787878, 0xFF878787, 0xFF8F8F8F, 0xFF979797, 0xFFA7A7A7, 0xFFAFAFAF, 0xFFB7B7B7, 0xFFC7C7C7, 0xFFCFCFCF, 0xFFD7D7D7, 0xFFE7E7E7, 0xFFEFEFEF, 0xFFF7F7F7, 0xFF000001, 0xFF003300, 0xFF006600, 0xFF009900, 0xFF00CC00, 0xFF00FF00, 0xFF000033, 0xFF003333, 0xFF006633, 0xFF009933, 0xFF00CC33, 0xFF00FF33, 0xFF000066, 0xFF003366, 0xFF006666, 0xFF009966, 0xFF00CC66, 0xFF00FF66, 0xFF000099, 0xFF003399, 0xFF006699, 0xFF009999, 0xFF00CC99, 0xFF00FF99, 0xFF0000CC, 0xFF0033CC, 0xFF0066CC, 0xFF0099CC, 0xFF00CCCC, 0xFF00FFCC, 0xFF0000FF, 0xFF0033FF, 0xFF0066FF, 0xFF0099FF, 0xFF00CCFF, 0xFF00FFFF, 0xFF330000, 0xFF333300, 0xFF336600, 0xFF339900, 0xFF33CC00, 0xFF33FF00, 0xFF330033, 0xFF333333, 0xFF336633, 0xFF339933, 0xFF33CC33, 0xFF33FF33, 0xFF330066, 0xFF333366, 0xFF336666, 0xFF339966, 0xFF33CC66, 0xFF33FF66, 0xFF330099, 0xFF333399, 0xFF336699, 0xFF339999, 0xFF33CC99, 0xFF33FF99, 0xFF3300CC, 0xFF3333CC, 0xFF3366CC, 0xFF3399CC, 0xFF33CCCC, 0xFF33FFCC, 0xFF3300FF, 0xFF3333FF, 0xFF3366FF, 0xFF3399FF, 0xFF33CCFF, 0xFF33FFFF, 0xFF660000, 0xFF663300, 0xFF666600, 0xFF669900, 0xFF66CC00, 0xFF66FF00, 0xFF660033, 0xFF663333, 0xFF666633, 0xFF669933, 0xFF66CC33, 0xFF66FF33, 0xFF660066, 0xFF663366, 0xFF666666, 0xFF669966, 0xFF66CC66, 0xFF66FF66, 0xFF660099, 0xFF663399, 0xFF666699, 0xFF669999, 0xFF66CC99, 0xFF66FF99, 0xFF6600CC, 0xFF6633CC, 0xFF6666CC, 0xFF6699CC, 0xFF66CCCC, 0xFF66FFCC, 0xFF6600FF, 0xFF6633FF, 0xFF6666FF, 0xFF6699FF, 0xFF66CCFF, 0xFF66FFFF, 0xFF990000, 0xFF993300, 0xFF996600, 0xFF999900, 0xFF99CC00, 0xFF99FF00, 0xFF990033, 0xFF993333, 0xFF996633, 0xFF999933, 0xFF99CC33, 0xFF99FF33, 0xFF990066, 0xFF993366, 0xFF996666, 0xFF999966, 0xFF99CC66, 0xFF99FF66, 0xFF990099, 0xFF993399, 0xFF996699, 0xFF999999, 0xFF99CC99, 0xFF99FF99, 0xFF9900CC, 0xFF9933CC, 0xFF9966CC, 0xFF9999CC, 0xFF99CCCC, 0xFF99FFCC, 0xFF9900FF, 0xFF9933FF, 0xFF9966FF, 0xFF9999FF, 0xFF99CCFF, 0xFF99FFFF, 0xFFCC0000, 0xFFCC3300, 0xFFCC6600, 0xFFCC9900, 0xFFCCCC00, 0xFFCCFF00, 0xFFCC0033, 0xFFCC3333, 0xFFCC6633, 0xFFCC9933, 0xFFCCCC33, 0xFFCCFF33, 0xFFCC0066, 0xFFCC3366, 0xFFCC6666, 0xFFCC9966, 0xFFCCCC66, 0xFFCCFF66, 0xFFCC0099, 0xFFCC3399, 0xFFCC6699, 0xFFCC9999, 0xFFCCCC99, 0xFFCCFF99, 0xFFCC00CC, 0xFFCC33CC, 0xFFCC66CC, 0xFFCC99CC, 0xFFCCCCCC, 0xFFCCFFCC, 0xFFCC00FF, 0xFFCC33FF, 0xFFCC66FF, 0xFFCC99FF, 0xFFCCCCFF, 0xFFCCFFFF, 0xFFFF0000, 0xFFFF3300, 0xFFFF6600, 0xFFFF9900, 0xFFFFCC00, 0xFFFFFF00, 0xFFFF0033, 0xFFFF3333, 0xFFFF6633, 0xFFFF9933, 0xFFFFCC33, 0xFFFFFF33, 0xFFFF0066, 0xFFFF3366, 0xFFFF6666, 0xFFFF9966, 0xFFFFCC66, 0xFFFFFF66, 0xFFFF0099, 0xFFFF3399, 0xFFFF6699, 0xFFFF9999, 0xFFFFCC99, 0xFFFFFF99, 0xFFFF00CC, 0xFFFF33CC, 0xFFFF66CC, 0xFFFF99CC, 0xFFFFCCCC, 0xFFFFFFCC, 0xFFFF00FF, 0xFFFF33FF, 0xFFFF66FF, 0xFFFF99FF, 0xFFFFCCFF, 0xFFFFFFFF};'.	^theTable! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 10/27/1999 17:54'!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments."	self inline: true.	x2 > x1		ifTrue: [^ x2 - x1 + FixedPt1 // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + FixedPt1 // (n+1) + 1)]! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 7/24/1999 19:16'!dither32To16: srcWord threshold: ditherValue	"Dither the given 32bit word to 16 bit. Ignore alpha."	| pv threshold value out |	self inline: true. "You bet"	pv _ srcWord bitAnd: 255.	threshold _ ditherThresholds16 at: (pv bitAnd: 7).	value _ ditherValues16 at: (pv bitShift: -3).	ditherValue < threshold		ifTrue:[out _ value + 1]		ifFalse:[out _ value].	pv _ (srcWord bitShift: -8) bitAnd: 255.	threshold _ ditherThresholds16 at: (pv bitAnd: 7).	value _ ditherValues16 at: (pv bitShift: -3).	ditherValue < threshold		ifTrue:[out _ out bitOr: (value+1 bitShift:5)]		ifFalse:[out _ out bitOr: (value bitShift: 5)].	pv _ (srcWord bitShift: -16) bitAnd: 255.	threshold _ ditherThresholds16 at: (pv bitAnd: 7).	value _ ditherValues16 at: (pv bitShift: -3).	ditherValue < threshold		ifTrue:[out _ out bitOr: (value+1 bitShift:10)]		ifFalse:[out _ out bitOr: (value bitShift: 10)].	^out! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 2/9/2000 20:48'!isIdentityMap: shifts with: masks	"Return true if shiftTable/maskTable define an identity mapping."	self var: #shifts declareC:'int *shifts'.	self var: #masks declareC:'int *masks'.	(shifts == nil or:[masks == nil]) ifTrue:[^true].	((shifts at: RedIndex) = 0 		and:[(shifts at: GreenIndex) = 0		and:[(shifts at: BlueIndex) = 0 		and:[(shifts at: AlphaIndex) = 0			and:[((masks at: RedIndex) = 16rFF0000)			and:[((masks at: GreenIndex) = 16r00FF00)			and:[((masks at: BlueIndex) = 16r0000FF)			and:[((masks at: AlphaIndex) = 16rFF000000)]]]]]]])		ifTrue:[^true].	^false! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 1/10/2000 18:32'!mapDestPixel: destPixel	"Expand the given destination pixel value into canonical RGBA space."	| val |	self inline: true.	noDestMap ifTrue:[^destPixel].	destMap == nil		ifTrue:[val _ destPixel]		ifFalse:[val _ destMap at: (destPixel bitAnd: dmMask)].	(dmShiftTable == nil or:[dmMaskTable == nil])		ifTrue:[^val]		ifFalse:[^self rgbMapPixel: val shifts: dmShiftTable masks: dmMaskTable].! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 1/13/2000 22:11'!mapPixel: sourcePixel	"Color map the given source pixel."	| pv |	self inline: true.	noColorMap ifTrue:[^sourcePixel].	(cmMaskTable == nil or:[cmShiftTable == nil])		ifTrue:[pv _ sourcePixel]		ifFalse:[pv _ self rgbMapPixel: sourcePixel shifts: cmShiftTable masks: cmMaskTable].	colorMap == nil		ifTrue:[^pv]		ifFalse:[^colorMap at: (pv bitAnd: cmMask)]! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 1/10/2000 18:33'!mapSourcePixel: sourcePixel	"Expand the given source pixel value into canonical RGBA space."	| val |	self inline: true.	noSourceMap ifTrue:[^sourcePixel].	sourceMap == nil		ifTrue:[val _ sourcePixel]		ifFalse:[val _ sourceMap at: (sourcePixel bitAnd: smMask)].	(smShiftTable == nil or:[smMaskTable == nil])		ifTrue:[^val]		ifFalse:[^self rgbMapPixel: val shifts: smShiftTable masks: smMaskTable].! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 2/16/2000 17:12'!pickSourcePixels: nPixels srcMask: srcMask destMask: dstMask paintMode: paintMode destWord: destinationWord	"Pick nPix pixels starting at srcBitIndex from the source, map by the	color map, and justify them according to dstBitIndex in the resulting destWord."	| sourceWord destWord sourcePix destPix srcShift dstShift nPix lastPix |	"Note: The method must be inlined for LSB-MSB conversion"	self inline: true.	sourceWord _ self srcLongAt: sourceIndex.	destWord _ 0.	srcShift _ srcBitShift. "Hint: Keep in register"	dstShift _ dstBitShift. "Hint: Keep in register"	nPix _ nPixels. "always > 0 so we can use do { } while(--nPix);"	"Pick and map first pixel so we can avoid the color conversion"	lastPix _ sourcePix _ sourceWord >> srcShift bitAnd: srcMask.	destPix _ self mapPixel: sourcePix.	["Mix in pixel"	(paintMode and:[sourcePix = sourceAlphaKey]) ifTrue:[		destWord _ destWord bitOr: (destinationWord bitAnd: (dstMask << dstShift)).	] ifFalse:[destWord _ destWord bitOr: (destPix bitAnd: dstMask) << dstShift].	destMSB		ifTrue:[dstShift _ dstShift - destDepth]		ifFalse:[dstShift _ dstShift + destDepth].	"Adjust source if at pixel boundary"	sourceMSB ifTrue:[		(srcShift _ srcShift - sourceDepth) < 0 ifTrue:			[srcShift _ srcShift + 32.			sourceWord _ self srcLongAt: (sourceIndex _ sourceIndex + 4)].	] ifFalse:[		(srcShift _ srcShift + sourceDepth) > 31 ifTrue:			[srcShift _ srcShift - 32.			sourceWord _ self srcLongAt: (sourceIndex _ sourceIndex + 4)].	].	(nPix _ nPix - 1) = 0] whileFalse:["Pick and map next pixel"		sourcePix _ sourceWord >> srcShift bitAnd: srcMask.		lastPix = sourcePix ifFalse:[			"map the pixel(either into colorMap or destFormat)"			destPix _ self mapPixel: sourcePix.			lastPix _ sourcePix]].	srcBitShift _ srcShift. "Store back"	"*** side effect ***"	"*** only the first pixel fetch can be unaligned ***"	"*** prepare the next one for aligned access ***"	destMSB		ifTrue:[dstBitShift _ 32 - destDepth] "Shift towards leftmost pixel"		ifFalse:[dstBitShift _ 0].	^destWord! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 1/11/2000 01:45'!pickWarpPixelAtX: x y: y	"Pick a single pixel from the source for WarpBlt.	Note: This method is crucial for WarpBlt speed w/o smoothing	and still relatively important when smoothing is used."	| srcIndex sourceWord sourcePix |	self inline: true.	"Fetch source word.	Note: We should really update srcIndex with sx and sy so that	we don't have to do the computation below. We might even be	able to simplify the out of bounds test from above."	srcIndex _ sourceBits + (y * sourcePitch) + (x >> warpAlignShift * 4).	sourceWord _ self srcLongAt: srcIndex.	"Extract pixel from word"	srcBitShift _ warpBitShiftTable at: (x bitAnd: warpAlignMask).	sourcePix _ sourceWord >> srcBitShift bitAnd: warpSrcMask.	^sourcePix! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 1/10/2000 16:16'!rgbMapPixel: sourcePixel shifts: shifts masks: masks	"Perform the RGBA conversion for the given source pixel"	| val mask shift |	self inline: true.	val _ 0.	mask _ (self cCoerce: masks to:'int*') at: RedIndex.	shift _ (self cCoerce: shifts to:'int*') at: RedIndex.	val _ val bitOr: ((sourcePixel bitAnd: mask) bitShift: shift).	mask _ (self cCoerce: masks to:'int*') at: GreenIndex.	shift _ (self cCoerce: shifts to:'int*') at: GreenIndex.	val _ val bitOr: ((sourcePixel bitAnd: mask) bitShift: shift).	mask _ (self cCoerce: masks to:'int*') at: BlueIndex.	shift _ (self cCoerce: shifts to:'int*') at: BlueIndex.	val _ val bitOr: ((sourcePixel bitAnd: mask) bitShift: shift).	mask _ (self cCoerce: masks to:'int*') at: AlphaIndex.	mask = 0 "common case"		ifFalse:[shift _ (self cCoerce: shifts to:'int*') at: AlphaIndex.				val _ val bitOr: ((sourcePixel bitAnd: mask) bitShift: shift)].	"Avoid transparency by color reduction.	Ugh ... check this!!!!!!"	(val = 0 and:[sourcePixel ~= 0]) ifTrue:[val _ 1].	^val! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 2/13/2000 15:47'!warpPickSmoothPixels: nPixels	xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	paintMode: paintMode destWord: destinationWord	"Pick n (sub-) pixels from the source form, mapped by sourceMap,	average the RGB values, map by colorMap and return the new word.	This version is only called from WarpBlt with smoothingCount > 1"	| rgb x y a r g b xx yy xdh ydh xdv ydv 	dstMask destWord i j k nPix pv n ptX ptY |	self inline: false. "nope - too much stuff in here"	n _ warpQuality.	n = 2 "Try avoiding divides for most common n (divide by 2 is generated as shift)"		ifTrue:[xdh _ xDeltah // 2. ydh _ yDeltah // 2. 				xdv _ xDeltav // 2. ydv _ yDeltav // 2]		ifFalse:[xdh _ xDeltah // n. ydh _ yDeltah // n. 				xdv _ xDeltav // n. ydv _ yDeltav // n].	dstMask _ maskTable at: destDepth.	destWord _ 0.	i _ nPixels.	[		x _ sx. y _ sy.		a _ r _ g _ b _ 0.		"Pick and average n*n subpixels"		nPix _ 0.  "actual number of pixels (not clipped and not transparent)"		j _ n.		[			xx _ x. yy _ y.			k _ n.			[				"get a single subpixel if not clipped"				(xx < 0 or:[yy < 0 or:[					(ptX _ xx >> BinaryPoint) >= sourceWidth or:[						(ptY _ yy >> BinaryPoint) >= sourceHeight]]]) ifFalse:[				pv _ self pickWarpPixelAtX: ptX y: ptY.				(paintMode and: [pv = sourceAlphaKey]) ifFalse:[					"If not clipped and not transparent, then tally rgb values"					nPix _ nPix + 1.					rgb _ self mapSourcePixel: pv.					b _ b + (rgb bitAnd: 255).					g _ g + (rgb >> 8 bitAnd: 255).					r _ r + (rgb >> 16 bitAnd: 255).					a _ a + (rgb >> 24)]].				xx _ xx + xdh.				yy _ yy + ydh.			(k _ k - 1) = 0] whileFalse.			x _ x + xdv.			y _ y + ydv.		(j _ j - 1) = 0] whileFalse.		(nPix = 0 or: [paintMode and: [nPix < (n * n // 2)]]) ifTrue:[			nPix _ pv _ 0  "All pixels were 0, or most were transparent"		] ifFalse:[			"normalize rgba sums"			nPix = 4 "Try to avoid divides for most common n"				ifTrue:[r _ r >> 2.	g _ g >> 2.	b _ b >> 2.	a _ a >> 2]				ifFalse:[	r _ r // nPix.	g _ g // nPix.	b _ b // nPix.	a _ a // nPix].			rgb _ (a << 24) + (r << 16) + (g << 8) + b.			"map the pixel"			rgb = 0 ifTrue: [				"only generate zero if pixel is really transparent"				(r + g + b + a) > 0 ifTrue: [rgb _ 1]].			pv _ self mapPixel: rgb.		].		"Mix it in"		nPix = 0 			ifTrue:[destWord _ destWord bitOr: (destinationWord bitAnd: (dstMask << dstBitShift))]			ifFalse:[destWord _ destWord bitOr: (pv bitAnd: dstMask) << dstBitShift].		destMSB			ifTrue:[dstBitShift _ dstBitShift - destDepth]			ifFalse:[dstBitShift _ dstBitShift + destDepth].		sx _ sx + xDeltah.		sy _ sy + yDeltah.	(i _ i - 1) = 0] whileFalse.	"*** side effect ***"	"*** only the first pixel fetch can be unaligned ***"	"*** prepare the next one for aligned access ***"	destMSB "Shift towards leftmost pixel"		ifTrue:[dstBitShift _ 32 - destDepth]		ifFalse:[dstBitShift _ 0].	^destWord! !!FXBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 2/13/2000 15:48'!warpPickSourcePixels: nPixels	xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	paintMode: paintMode destWord: destinationWord	"Pick n pixels from the source form,	map by colorMap and return aligned by dstBitShift.	This version is only called from WarpBlt with smoothingCount = 1"	| dstMask resultWord nPix sourcePix mappedPix lastPix x y hasPix |	self inline: true. "This should go into warpLoop"	dstMask _ maskTable at: destDepth.	resultWord _ 0.	nPix _ nPixels.	"Pick and map first pixel to avoid color conversion"	lastPix _ 0.	hasPix _ false.	(sx < 0 or:[sy < 0 or:[		(x _ sx >> BinaryPoint) >= sourceWidth or:[			(y _ sy >> BinaryPoint) >= sourceHeight]]]) ifFalse:[				lastPix _ sourcePix _ self pickWarpPixelAtX: x y: y.				(paintMode and:[sourcePix = sourceAlphaKey])					ifFalse:[hasPix _ true]].	"Note: lastPix might be zero here but who cares..."	mappedPix _ self mapPixel: lastPix.	["Mix it in"	hasPix		ifTrue:[resultWord _ resultWord bitOr: 					(mappedPix bitAnd: dstMask) << dstBitShift]		ifFalse:[resultWord _ resultWord bitOr: 					(destinationWord bitAnd: (dstMask << dstBitShift))].	destMSB		ifTrue:[dstBitShift _ dstBitShift - destDepth]		ifFalse:[dstBitShift _ dstBitShift + destDepth].	sx _ sx + xDeltah.	sy _ sy + yDeltah.	(nPix _ nPix - 1) = 0] whileFalse:["Pick and map next pixel"		hasPix _ false.		(sx < 0 or:[sy < 0 or:[			(x _ sx >> BinaryPoint) >= sourceWidth or:[				(y _ sy >> BinaryPoint) >= sourceHeight]]]) ifFalse:[			sourcePix _ self pickWarpPixelAtX: x y: y.			(paintMode and:[sourcePix = sourceAlphaKey]) ifFalse:[				hasPix _ true.				lastPix = sourcePix ifFalse:[					"map the pixel(either into colorMap or destFormat)"					mappedPix _ self mapPixel: sourcePix.					lastPix _ sourcePix]]].	].	"*** side effect ***"	"*** only the first pixel fetch can be unaligned ***"	"*** prepare the next one for aligned access ***"	destMSB "Shift towards leftmost pixel"		ifTrue:[dstBitShift _ 32 - destDepth]		ifFalse:[dstBitShift _ 0].	^resultWord! !!FXBltSimulation methodsFor: 'memory access' stamp: 'ar 10/25/1999 19:23'!dstLongAt: idx	^interpreterProxy longAt: idx! !!FXBltSimulation methodsFor: 'memory access' stamp: 'ar 10/26/1999 18:08'!dstLongAt: idx put: value	^interpreterProxy longAt: idx put: value! !!FXBltSimulation methodsFor: 'memory access' stamp: 'ar 12/7/1999 21:09'!dstLongAt: idx put: srcValue mask: dstMask	"Store the given value back into destination form, using dstMask	to mask out the bits to be modified. This is an essiantial	read-modify-write operation on the destination form."	| dstValue |	self inline: true.	dstValue _ self dstLongAt: idx.	dstValue _ dstValue bitAnd: dstMask.	dstValue _ dstValue bitOr: srcValue.	self dstLongAt: idx put: dstValue.! !!FXBltSimulation methodsFor: 'memory access' stamp: 'ar 10/25/1999 19:22'!halftoneAt: idx	"Return a value from the halftone pattern."	^interpreterProxy longAt: halftoneBase + (idx \\ halftoneHeight * 4)! !!FXBltSimulation methodsFor: 'memory access' stamp: 'ar 10/25/1999 19:23'!srcLongAt: idx	^interpreterProxy longAt: idx! !!FXBltSimulation methodsFor: 'surface support' stamp: 'ar 5/25/2000 16:10'!loadSurfacePlugin	"Load the surface support plugin"	querySurfaceFn _ interpreterProxy ioLoadFunction:'ioGetSurfaceFormat' From:'SurfacePlugin'.	lockSurfaceFn _ interpreterProxy ioLoadFunction:'ioLockSurface' From:'SurfacePlugin'.	unlockSurfaceFn _ interpreterProxy ioLoadFunction:'ioUnlockSurface' From:'SurfacePlugin'.	^querySurfaceFn ~= 0 and:[lockSurfaceFn ~= 0 and:[unlockSurfaceFn ~= 0]]! !!FXBltSimulation methodsFor: 'surface support' stamp: 'ar 5/25/2000 16:39'!lockSurfaces	"Get a pointer to the bits of any OS surfaces."	"Notes: 	* For equal source/dest handles only one locking operation is performed.	This is to prevent locking of overlapping areas which does not work with	certain APIs (e.g., DirectDraw prevents locking of overlapping areas). 	A special case for non-overlapping but equal source/dest handle would 	be possible but we would have to transfer this information over to 	unlockSurfaces somehow (currently, only one unlock operation is 	performed for equal source and dest handles). Also, this would require	a change in the notion of ioLockSurface() which is right now interpreted	as a hint and not as a requirement to lock only the specific portion of	the surface.	* The arguments in ioLockSurface() provide the implementation with	an explicit hint what area is affected. It can be very useful to	know the max. affected area beforehand if getting the bits requires expensive	copy operations (e.g., like a roundtrip to the X server or a glReadPixel op).	However, the returned pointer *MUST* point to the virtual origin of the surface	and not to the beginning of the rectangle. The promise made by BitBlt	is to never access data outside the given rectangle (aligned to 4byte boundaries!!)	so it is okay to return a pointer to the virtual origin that is actually outside	the valid memory area.	* The area provided in ioLockSurface() is already clipped (e.g., it will always	be inside the source and dest boundingBox) but it is not aligned to word boundaries	yet. It is up to the support code to compute accurate alignment if necessary.	* Warping always requires the entire source surface to be locked because	there is no beforehand knowledge about what area will actually be traversed.	"	| sourceHandle destHandle l r t b fn |	self inline: true. "If the CCodeGen learns how to inline #cCode: methods"	self var: #fn declareC:'int (*fn)(int, int*, int, int, int, int)'.	hasSurfaceLock _ false.	destBits = 0 ifTrue:["Blitting *to* OS surface"		lockSurfaceFn = 0 ifTrue:[self loadSurfacePlugin ifFalse:[^nil]].		fn _ self cCoerce: lockSurfaceFn to: 'int (*)(int, int*, int, int, int, int)'.		destHandle _ interpreterProxy fetchInteger: FormBitsIndex ofObject: destForm.		(sourceBits = 0 and:[noSource not]) ifTrue:[			sourceHandle _ interpreterProxy fetchInteger: FormBitsIndex ofObject: sourceForm.			"Handle the special case of equal source and dest handles"			(sourceHandle = destHandle) ifTrue:[				"If we have overlapping source/dest we lock the entire area				so that there is only one area transmitted"				noWarp ifTrue:[					l _ sx min: dx. r _ (sx max: dx) + bbW.					t _ sy min: dy. b _ (sy max: sy) + bbH.					sourceBits _ self cCode:'fn(sourceHandle, &sourcePitch, l, t, r-l, b-t)'.				] ifFalse:[					"When warping we always need the entire surface for the source"					sourceBits _ self cCode:'fn(sourceHandle, &sourcePitch, 0,0, sourceWidth, sourceHeight)'.				].				destBits _ sourceBits.				destPitch _ sourcePitch.				hasSurfaceLock _ true.				^destBits ~~ 0			].			"Fall through - if not equal it'll be handled below"		].		destBits _ self cCode:'fn(destHandle, &destPitch, dx, dy, bbW, bbH)'.		hasSurfaceLock _ true.	].	(sourceBits == 0 and:[noSource not]) ifTrue:["Blitting *from* OS surface"		sourceHandle _ interpreterProxy fetchInteger: FormBitsIndex ofObject: sourceForm.		lockSurfaceFn = 0 ifTrue:[self loadSurfacePlugin ifFalse:[^nil]].		fn _ self cCoerce: lockSurfaceFn to: 'int (*)(int, int*, int, int, int, int)'.		"Warping requiring the entire surface"		noWarp ifTrue:[			sourceBits _ self cCode:'fn(sourceHandle, &sourcePitch, sx, sy, bbW, bbH)'.		] ifFalse:[			sourceBits _ self cCode:'fn(sourceHandle, &sourcePitch, 0, 0, sourceWidth, sourceHeight)'.		].		hasSurfaceLock _ true.	].	^destBits ~~ 0 and:[sourceBits ~~ 0 or:[noSource]].! !!FXBltSimulation methodsFor: 'surface support' stamp: 'ar 5/25/2000 16:01'!queryDestSurface: handle	"Query the dimension of an OS surface.	This method is provided so that in case the inst vars of the	source form are broken, *actual* values of the OS surface	can be obtained. This might, for instance, happen if the user	resizes the main window.	Note: Moved to a separate function for better inlining of the caller."	querySurfaceFn = 0 ifTrue:[self loadSurfacePlugin ifFalse:[^false]].	^(self cCode:' ((int (*) (int, int*, int*, int*, int*))querySurfaceFn)		(handle, &destWidth, &destHeight, &destDepth, &destMSB)'			 inSmalltalk:[false])! !!FXBltSimulation methodsFor: 'surface support' stamp: 'ar 5/25/2000 16:00'!querySourceSurface: handle	"Query the dimension of an OS surface.	This method is provided so that in case the inst vars of the	source form are broken, *actual* values of the OS surface	can be obtained. This might, for instance, happen if the user	resizes the main window.	Note: Moved to a separate function for better inlining of the caller."	querySurfaceFn = 0 ifTrue:[self loadSurfacePlugin ifFalse:[^false]].	^(self cCode:' ((int (*) (int, int*, int*, int*, int*))querySurfaceFn)		(handle, &sourceWidth, &sourceHeight, &sourceDepth, &sourceMSB)'			inSmalltalk:[false])! !!FXBltSimulation methodsFor: 'surface support' stamp: 'ar 5/25/2000 16:07'!unlockSurfaces	"Unlock the bits of any OS surfaces."	"See the comment in lockSurfaces. Similar rules apply. That is, the area provided in ioUnlockSurface can be used to determine the dirty region after drawing. If a source is unlocked, then the area will be (0,0,0,0) to indicate that no portion is dirty."	| sourceHandle destHandle destLocked fn |	self var: #fn declareC:'int (*fn)(int, int, int, int, int)'.	hasSurfaceLock ifTrue:[		unlockSurfaceFn = 0 ifTrue:[self loadSurfacePlugin ifFalse:[^nil]].		fn _ self cCoerce: unlockSurfaceFn to: 'int (*)(int, int, int, int, int)'.		destLocked _ false.		destHandle _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		(interpreterProxy isIntegerObject: destHandle) ifTrue:[			destHandle _ interpreterProxy integerValueOf: destHandle.			"The destBits are always assumed to be dirty"			self cCode:'fn(destHandle, affectedL, affectedT, affectedR-affectedL, affectedB-affectedT)'.			destBits _ destPitch _ 0.			destLocked _ true.		].		noSource ifFalse:[			sourceHandle _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.			(interpreterProxy isIntegerObject: sourceHandle) ifTrue:[				sourceHandle _ interpreterProxy integerValueOf: sourceHandle.				"Only unlock sourceHandle if different from destHandle"				(destLocked and:[sourceHandle = destHandle]) 					ifFalse:[self cCode: 'fn(sourceHandle, 0, 0, 0, 0)'].				sourceBits _ sourcePitch _ 0.			].		].		hasSurfaceLock _ false.	].! !!FXBltSimulation methodsFor: 'special inner loops' stamp: 'ar 2/19/2000 20:19'!copyLoopPixMapLsbLsb	"Note: This loop is specialized by the CCodeGenerator."	self inline: false.	self copyLoopPixMap.! !!FXBltSimulation methodsFor: 'special inner loops' stamp: 'ar 2/19/2000 20:19'!copyLoopPixMapLsbMsb	"Note: This loop is specialized by the CCodeGenerator."	self inline: false.	self copyLoopPixMap.! !!FXBltSimulation methodsFor: 'special inner loops' stamp: 'ar 2/19/2000 20:19'!copyLoopPixMapMsbLsb	"Note: This loop is specialized by the CCodeGenerator."	self inline: false.	self copyLoopPixMap.! !!FXBltSimulation methodsFor: 'special inner loops' stamp: 'ar 2/19/2000 20:19'!copyLoopPixMapMsbMsb	"Note: This loop is specialized by the CCodeGenerator."	self inline: false.	self copyLoopPixMap.! !!FXBltSimulation methodsFor: 'special inner loops' stamp: 'ar 2/16/2000 17:41'!doCopyLoopPixMap	self inline: true.	sourceMSB ifTrue:[		destMSB 			ifTrue:[self copyLoopPixMapMsbMsb]			ifFalse:[self copyLoopPixMapMsbLsb]	] ifFalse:[		destMSB			ifTrue:[self copyLoopPixMapLsbMsb]			ifFalse:[self copyLoopPixMapLsbLsb]	].! !!FXBltSimulation methodsFor: 'special inner loops' stamp: 'ar 2/16/2000 17:41'!doWarpLoop	self inline: true.	sourceMSB ifTrue:[		destMSB 			ifTrue:[self warpLoopMsbMsb]			ifFalse:[self warpLoopMsbLsb]	] ifFalse:[		destMSB			ifTrue:[self warpLoopLsbMsb]			ifFalse:[self warpLoopLsbLsb]	].! !!FXBltSimulation methodsFor: 'special inner loops' stamp: 'ar 2/19/2000 20:19'!warpLoopLsbLsb	"Note: This loop is specialized by the CCodeGenerator."	self inline: false.	self warpLoop.! !!FXBltSimulation methodsFor: 'special inner loops' stamp: 'ar 2/19/2000 20:19'!warpLoopLsbMsb	"Note: This loop is specialized by the CCodeGenerator."	self inline: false.	self warpLoop.! !!FXBltSimulation methodsFor: 'special inner loops' stamp: 'ar 2/19/2000 20:20'!warpLoopMsbLsb	"Note: This loop is specialized by the CCodeGenerator."	self inline: false.	self warpLoop.! !!FXBltSimulation methodsFor: 'special inner loops' stamp: 'ar 2/19/2000 20:20'!warpLoopMsbMsb	"Note: This loop is specialized by the CCodeGenerator."	self inline: false.	self warpLoop.! !!FXBltSimulation class methodsFor: 'initialization' stamp: 'ar 2/16/2000 19:17'!initialize	"BitBltSimulation initialize"  	self initializeRuleTable.	"Mask constants"	AllOnes _ 16rFFFFFFFF.	BinaryPoint _ 14.	FixedPt1 _ 1 << BinaryPoint.  "Value of 1.0 in Warp's fixed-point representation" 	"Form fields"	FormBitsIndex _ 0.	FormWidthIndex _ 1.	FormHeightIndex _ 2.	FormDepthIndex _ 3. 	"BitBlt fields"	BBDestFormIndex _ 0.	BBSourceFormIndex _ 1.	BBHalftoneFormIndex _ 2.	BBRuleIndex _ 3.	BBDestXIndex _ 4.	BBDestYIndex _ 5.	BBWidthIndex _ 6.	BBHeightIndex _ 7.	BBSourceXIndex _ 8.	BBSourceYIndex _ 9.	BBClipXIndex _ 10.	BBClipYIndex _ 11.	BBClipWidthIndex _ 12.	BBClipHeightIndex _ 13.	BBColorMapIndex _ 14.	FXSourceMapIndex _ 15.	FXDestMapIndex _ 16.	FXWarpQuadIndex _ 17.	FXWarpQualityIndex _ 18.	FXSourceKeyIndex _ 19.	FXDestKeyIndex _ 20.	FXSourceAlphaIndex _ 21.	FXTallyMapIndex _ 22.	"RGBA indexes"	RedIndex _ 0.	GreenIndex _ 1.	BlueIndex _ 2.	AlphaIndex _ 3.	"Color cache"	ColorCacheSize _ 512. "Should be at least 256 and must be power of two"	ColorCacheMask _ ColorCacheSize - 1.	InvalidColorCacheEntry _ 16r01EC1B55.! !!FXBltSimulation class methodsFor: 'initialization' stamp: 'ar 1/22/2000 15:46'!initializeRuleTable	"BitBltSimulation initializeRuleTable"	"**WARNING** You MUST change initBBOpTable if you change this"	OpTable _ #(		"0" clearWord:with:		"1" bitAnd:with:		"2" bitAndInvert:with:		"3" sourceWord:with:		"4" bitInvertAnd:with:		"5" destinationWord:with:		"6" bitXor:with:		"7" bitOr:with:		"8" bitInvertAndInvert:with:		"9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" destinationWord:with:		"16" destinationWord:with: "unused - was old paint"		"17" destinationWord:with: "unused - was old mask"		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22" OLDrgbDiff:with:		"23" OLDtallyIntoMap:with:		"24" alphaBlend:with:		"25" pixPaint:with:		"26" pixMask:with:		"27" rgbMax:with:		"28" rgbMin:with:		"29" rgbMinInvert:with:		"30" alphaBlendConst:with:		"31" alphaPaintConst:with:		"32" rgbDiff:with:		"33" tallyIntoMap:with:		"34" alphaBlendScaled:with:		"35"	srcPaint:with:		"36" dstPaint:with:	).	OpTableSize _ OpTable size + 1.  "0-origin indexing"! !!FXBltSimulation class methodsFor: 'initialization'!test2  "BitBltSimulation test2"	| f |	Display fillWhite: (0@0 extent: 300@140).	1 to: 12 do:		[:i | f _ (Form extent: i@5) fillBlack.		0 to: 20 do:			[:x | f displayOn: Display					at: (x*13) @ (i*10)]]! !!FXBltSimulation class methodsFor: 'initialization'!timingTest: extent  "BitBltSimulation timingTest: 640@480"	| f f2 map |	f _ Form extent: extent depth: 8.	f2 _ Form extent: extent depth: 8.	map _ Bitmap new: 1 << f2 depth.	^ Array with:	(Time millisecondsToRun: [100 timesRepeat:		[f fillWithColor: Color white]])	with:	(Time millisecondsToRun: [100 timesRepeat:		[f copy: f boundingBox from: 0@0 in: f2 rule: Form over]])	with:	(Time millisecondsToRun: [100 timesRepeat:		[f copyBits: f boundingBox from: f2 at: 0@0 colorMap: map]])! !!FXBltSimulation class methodsFor: 'translation' stamp: 'ar 5/25/2000 16:29'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator		var: 'colorMap' declareC:'int *colorMap';		var: 'cmShiftTable' declareC:'int *cmShiftTable';		var: 'cmMaskTable' declareC:'int *cmMaskTable';		var: 'sourceMap' declareC:'int *sourceMap';		var: 'smShiftTable' declareC:'int *smShiftTable';		var: 'smMaskTable' declareC:'int *smMaskTable';		var: 'destMap' declareC:'int *destMap';		var: 'dmShiftTable' declareC:'int *dmShiftTable';		var: 'dmMaskTable' declareC:'int *dmMaskTable';		var: 'warpQuad' declareC:'int warpQuad[8]';		var: 'tallyMap' declareC:'int *tallyMap'.	aCCodeGenerator var: 'opTable'		declareC: 'int opTable[' , OpTableSize printString , ']'.	aCCodeGenerator var: 'maskTable'		declareC:'int maskTable[33] = {0, 1, 3, 0, 15, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}'.	aCCodeGenerator var: 'ditherMatrix4x4'		declareC:'const int ditherMatrix4x4[16] = {0,	8,	2,	10,12,	4,	14,	6,3,	11,	1,	9,15,	7,	13,	5}'.	aCCodeGenerator var: 'ditherThresholds16'		declareC:'const int ditherThresholds16[8] = { 0, 2, 4, 6, 8, 12, 14, 16 }'.	aCCodeGenerator var: 'ditherValues16'		declareC:'const int ditherValues16[32] = {0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}'.	aCCodeGenerator var: 'warpBitShiftTable'		declareC:'int warpBitShiftTable[32]'.! !!FXBltSimulation class methodsFor: 'translation' stamp: 'ar 2/21/2000 20:29'!moduleName	"FXBltScanner translateLocally"	^'FXBltPlugin'! !!FXBltSimulation class methodsFor: 'translation' stamp: 'jm 5/12/1999 12:02'!opTable	^ OpTable! !!FXBltSimulation class methodsFor: 'translation' stamp: 'ar 2/16/2000 19:32'!specializeLoopsIn: cg	"FXBltScanner translate"	"Specialize those loops that benefit from a distinction of LSB vs. MSB variants"	| i s |	'Specializing inner loops' 		displayProgressAt: Sensor cursorPoint		from: 1 to: 8 during:[:bar|	i _ 0.	{true. false} do:[:srcMsb|		{true. false} do:[:dstMsb|			#(copyLoopPixMap warpLoop) do:[:sel|				bar value: (i_i+1).				s _ sel, (srcMsb ifTrue:['Msb'] ifFalse:['Lsb']),							(dstMsb ifTrue:['Msb'] ifFalse:['Lsb']).				s _ s asSymbol.				cg specializeMethod: s variable: 'sourceMSB' value: srcMsb.				cg specializeMethod: s variable: 'destMSB' value: dstMsb]]].	].! !!FXBltSimulation class methodsFor: 'system simulation' stamp: 'ar 10/27/1999 23:34'!copyBitsFrom: aBitBlt	"Simulate the copyBits primitive"	| proxy bb |	proxy _ InterpreterProxy new.	proxy loadStackFrom: thisContext sender.	bb _ self simulatorClass new.	bb setInterpreter: proxy.	proxy success: (bb loadBitBltFrom: aBitBlt).	bb copyBits.	proxy failed ifFalse:[		proxy showDisplayBits: aBitBlt destForm 				Left: bb affectedLeft Top: bb affectedTop 				Right: bb affectedRight Bottom: bb affectedBottom].	^proxy stackValue: 0! !!FXBltSimulation class methodsFor: 'system simulation' stamp: 'ar 2/21/2000 20:24'!fxCopyBitsFrom: aBitBlt	"Simulate the copyBits primitive"	| proxy bb |	proxy _ InterpreterProxy new.	proxy loadStackFrom: thisContext sender.	bb _ self simulatorClass new.	bb setInterpreter: proxy.	proxy success: (bb loadBitBltFrom: aBitBlt).	bb copyBits.	proxy failed ifFalse:[		proxy showDisplayBits: aBitBlt destForm 				Left: bb affectedLeft Top: bb affectedTop 				Right: bb affectedRight Bottom: bb affectedBottom].	^proxy stackValue: 0! !!FXBltSimulation class methodsFor: 'system simulation' stamp: 'ar 1/22/2000 15:45'!simulatorClass	^FXBltSimulator! !!FXBltSimulation class methodsFor: 'system simulation' stamp: 'ar 1/10/2000 17:46'!warpBitsFrom: aBitBlt	"Simulate the warpBits primitive"	| proxy bb |	proxy _ InterpreterProxy new.	proxy loadStackFrom: thisContext sender.	bb _ self simulatorClass new.	bb setInterpreter: proxy.	proxy success: (bb loadWarpBltFrom: aBitBlt).	bb copyBits.	proxy failed ifFalse:[		proxy showDisplayBits: aBitBlt destForm 				Left: bb affectedLeft Top: bb affectedTop 				Right: bb affectedRight Bottom: bb affectedBottom].	^proxy stackValue: 0! !!FXBltSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/25/2000 15:42'!initBBOpTable	opTable _ OpTable.	maskTable _ Array new: 32.	#(1 2 4 8 16 32) do:[:i| maskTable at: i put: (1 << i)-1].	self initializeDitherTables.	warpBitShiftTable _ CArrayAccessor on: (Array new: 32).	cmCache _ CArrayAccessor on: (Array new: ColorCacheSize*2).	warpQuad _ CArrayAccessor on: (Array new: 8).! !!FXBltSimulator methodsFor: 'as yet unclassified' stamp: 'ar 7/24/1999 23:20'!initializeDitherTables	ditherMatrix4x4 _ CArrayAccessor on:		#(	0	8	2	10			12	4	14	6			3	11	1	9			15	7	13	5).	ditherThresholds16 _ CArrayAccessor on:#(0 2 4 6 8 10 12 14 16).	ditherValues16 _ CArrayAccessor on: 		#(0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14		15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30).! !!FXBltSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/25/2000 16:37'!mergeFn: arg1 with: arg2	^ self perform: (self cCoerce:(opTable at: combinationRule+1) to:'(int (*) (int,int))')		with: arg1 with: arg2! !!FXBltSimulator methodsFor: 'debug support' stamp: 'ar 10/27/1999 14:22'!dstLongAt: dstIndex	interpreterProxy isInterpreterProxy		ifTrue:[^dstIndex longAt: 0].	((dstIndex anyMask: 3) or:[dstIndex + 4 < destBits or:[		dstIndex > (destBits + (destPitch * destHeight))]])			ifTrue:[self error:'Out of bounds'].	^interpreterProxy longAt: dstIndex! !!FXBltSimulator methodsFor: 'debug support' stamp: 'ar 10/27/1999 14:23'!dstLongAt: dstIndex put: value	interpreterProxy isInterpreterProxy		ifTrue:[^dstIndex longAt: 0 put: value].	((dstIndex anyMask: 3) or:[dstIndex < destBits or:[		dstIndex >= (destBits + (destPitch * destHeight))]])			ifTrue:[self error:'Out of bounds'].	^interpreterProxy longAt: dstIndex put: value! !!FXBltSimulator methodsFor: 'debug support' stamp: 'ar 1/9/2000 16:26'!srcLongAt: srcIndex	interpreterProxy isInterpreterProxy		ifTrue:[^srcIndex longAt: 0].	((srcIndex anyMask: 3) or:[srcIndex + 4 < sourceBits or:[		srcIndex > (sourceBits + (sourcePitch * sourceHeight))]])			ifTrue:[self error:'Out of bounds'].	^interpreterProxy longAt: srcIndex! !!FXBltSimulator class methodsFor: 'translation' stamp: 'ar 1/22/2000 15:44'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep] 164760 167543 171826 174510"	| cg |	FXBltSimulation initialize.	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: FXBltSimulation.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	FXBltSimulation declareCVarsIn: cg.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!FXBltSimulator class methodsFor: 'instance creation' stamp: 'ar 10/27/1999 14:16'!new	^super new initBBOpTable.! !!FXBltSimulator class methodsFor: 'initialization' stamp: 'ar 1/10/2000 14:04'!resetCacheStats	"BitBltSimulator resetCacheStats"	ColorCacheHits _ ColorCacheMisses _ 0.! !!FXGrafPort methodsFor: 'copying' stamp: 'ar 2/17/2000 21:44'!clippedBy: aRectangle	^ self copy clipRect: (self clipRect intersect: aRectangle)! !!FXGrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 21:44'!fillOval: rect	| centerX centerY nextY yBias xBias outer nextOuterX |	rect area <= 0 ifTrue: [^ self].	height _ 1.	yBias _ rect height odd ifTrue: [0] ifFalse: [-1].	xBias _ rect width odd ifTrue: [1] ifFalse: [0].	centerX _ rect center x.	centerY _ rect center y.	outer _ EllipseMidpointTracer new on: rect.	nextY _ rect height // 2.	[nextY > 0] whileTrue:[		nextOuterX _ outer stepInY.		width _ (nextOuterX bitShift: 1) + xBias.		destX _ centerX - nextOuterX.		destY _ centerY - nextY.		self copyBits.		destY _ centerY + nextY + yBias.		self copyBits.		nextY _ nextY - 1.	].	destY _ centerY.	height _ 1 + yBias.	width _ rect width.	destX _ rect left.	self copyBits.! !!FXGrafPort methodsFor: 'drawing support' stamp: 'ar 5/25/2000 17:19'!fillRect: rect offset: aPoint	"The offset is really just for stupid InfiniteForms."	| fc |	fillPattern class == InfiniteForm ifTrue:[		fc _ halftoneForm.		self fillColor: nil.		fillPattern displayOnPort: ((self clippedBy: rect) colorMap: nil) at: aPoint.		halftoneForm _ fc.		^self].	destX _ rect left.	destY _ rect top.	sourceX _ 0.	sourceY _ 0.	width _ rect width.	height _ rect height.	self copyBits.! !!FXGrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 21:44'!frameOval: rect borderWidth: borderWidth	| centerX centerY nextY yBias xBias wp outer inner nextOuterX nextInnerX fillAlpha |	rect area <= 0 ifTrue: [^ self].	height _ 1.	wp _ borderWidth asPoint.	yBias _ rect height odd ifTrue: [0] ifFalse: [-1].	xBias _ rect width odd ifTrue: [1] ifFalse: [0].	centerX _ rect center x.	centerY _ rect center y.	outer _ EllipseMidpointTracer new on: rect.	inner _ EllipseMidpointTracer new on: (rect insetBy: wp).	nextY _ rect height // 2.	1 to: (wp y min: nextY) do:[:i|		nextOuterX _ outer stepInY.		width _ (nextOuterX bitShift: 1) + xBias.		destX _ centerX - nextOuterX.		destY _ centerY - nextY.		self copyBits.		destY _ centerY + nextY + yBias.		self copyBits.		nextY _ nextY - 1.	].	[nextY > 0] whileTrue:[		nextOuterX _ outer stepInY.		nextInnerX _ inner stepInY.		destX _ centerX - nextOuterX.		destY _ centerY - nextY.		width _ nextOuterX - nextInnerX.		self copyBits.		destX _ centerX + nextInnerX + xBias.		self copyBits.		destX _ centerX - nextOuterX.		destY _ centerY + nextY + yBias.		self copyBits.		destX _ centerX + nextInnerX + xBias.		self copyBits.		nextY _ nextY - 1.	].	destY _ centerY.	height _ 1 + yBias.	width _ wp x.	destX _ rect left.	self copyBits.	destX _ rect right - wp x.	self copyBits.! !!FXGrafPort methodsFor: 'drawing support' stamp: 'ar 2/22/2000 19:54'!frameRect: rect borderWidth: borderWidth	sourceX _ 0.	sourceY _ 0.	(rect areasOutside: (rect insetBy: borderWidth)) do:		[:edgeStrip | self destRect: edgeStrip; copyBits].! !!FXGrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 21:44'!frameRectBottom: rect height: h	destX _ rect left + 1.	destY _ rect bottom - 1.	width _ rect width - 2.	height _ 1.	1 to: h do: [:i |		self copyBits.		destX _ destX + 1.		destY _ destY - 1.		width _ width - 2].! !!FXGrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 21:44'!frameRectRight: rect width: w	width _ 1.	height _ rect height - 1.	destX _ rect right - 1.	destY _ rect top + 1.	1 to: w do: [:i |		self copyBits.		destX _ destX - 1.		destY _ destY + 1.		height _ height - 2].! !!FXGrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 21:44'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	sourceForm _ aForm.	combinationRule _ rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBits! !!FXGrafPort methodsFor: 'drawing support' stamp: 'ar 2/22/2000 16:47'!stencil: stencilForm at: aPoint sourceRect: aRect	"Paint using aColor wherever stencilForm has non-zero pixels"	self sourceForm: stencilForm;		destOrigin: aPoint;		sourceRect: aRect.	self copyBits! !!FXGrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 21:45'!alphaBits: a	sourceAlpha _ a! !!FXGrafPort methodsFor: 'accessing' stamp: 'ar 5/25/2000 17:20'!displayScannerFor: para foreground: foreColor background: backColor ignoreColorChanges: shadowMode	^ (DisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self			ignoreColorChanges: shadowMode)		setPort: self clone! !!FXGrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 21:44'!fillPattern: anObject	fillPattern _ anObject.	self fillColor: anObject.! !!Form methodsFor: 'color mapping' stamp: 'ar 1/16/2000 16:07'!colormapFromARGB	"Return a ColorMap mapping from canonical ARGB space into the receiver"	| map nBits |	self depth <= 8 ifTrue:[		map _ Color colorMapIfNeededFrom: 32 to: self depth.		map size = 512 ifTrue:[nBits _ 3].		map size = 4096 ifTrue:[nBits _ 4].		map size = 32768 ifTrue:[nBits _ 5].		^ColorMap			shifts: (Array 						with: 3 * nBits - 24						with: 2 * nBits - 16						with: 1 * nBits - 8						with: 0)			masks: (Array						with: (1 << nBits) - 1 << (24 - nBits)						with: (1 << nBits) - 1 << (16 - nBits)						with: (1 << nBits) - 1 << (8 - nBits)						with: 0)			colors: map].	self depth = 16 ifTrue:[		^ColorMap			shifts: #(-9 -6 -3 0)			masks: #(16rF80000 16rF800 16rF8 0)].	self depth = 32 ifTrue:[		^ColorMap			shifts: #(0 0 0 0)			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)].	self error:'Bad depth'! !!Form methodsFor: 'color mapping' stamp: 'ar 2/9/2000 22:44'!colormapIfNeededFor: destForm	"Return a ColorMap mapping from the receiver to destForm."	"Note: This is very magical for now - we really need to switch	to palettes here but as long as this isn't done we need something	that works."	| map nBits myBits |	self depth = destForm depth ifTrue:[^nil]. "no conversion"	self depth <= 8 ifTrue:["Always map indexed"		^ColorMap			shifts: nil			masks: nil			colors: (Color colorMapIfNeededFrom: self depth to: destForm depth)].	(self depth = 16 and:[destForm depth = 32]) ifTrue:["Expand bits"		^ColorMap 			shifts: #( 9 6 3 0) 			masks: #(16r7C00 16r3E0 16r1F 0)].	(self depth = 32 and:[destForm depth = 16]) ifTrue:["Contract bits"		^ColorMap			shifts: #(-9 -6 -3 0)			masks: #(16rF80000 16rF800 16rF8 0)].	"destForm is indexed, I am non-indexed"	map _ Color colorMapIfNeededFrom: self depth to: destForm depth.	map size = 512 ifTrue:[nBits _ 3].	map size = 4096 ifTrue:[nBits _ 4].	map size = 32768 ifTrue:[nBits _ 5].	myBits _ depth == 16 ifTrue:[5] ifFalse:[8].	^ColorMap		shifts: {	(3 * nBits) - (3 * myBits).				(2 * nBits) - (2 * myBits).				(1 * nBits) - (1 * myBits).				0}		masks: {	(1 bitShift: nBits) - 1 bitShift: (3 * myBits - nBits).				(1 bitShift: nBits) - 1 bitShift: (2 * myBits - nBits).				(1 bitShift: nBits) - 1 bitShift: (1 * myBits - nBits).				0}		colors: map.! !!Form methodsFor: 'color mapping' stamp: 'ar 1/16/2000 16:01'!colormapToARGB	"Return a ColorMap mapping from the receiver into canonical ARGB space."	self depth <= 8 ifTrue:[		^ColorMap			shifts: #(0 0 0 0)			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)			colors: (Color colorMapIfNeededFrom: self depth to: 32)].	self depth = 16 ifTrue:[		^ColorMap 			shifts: #( 9 6 3 0) 			masks: #(16r7C00 16r3E0 16r1F 0)].	self depth = 32 ifTrue:[		^ColorMap			shifts: #(0 0 0 0) 			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)].	self error:'Bad depth'! !!ColorForm methodsFor: 'color manipulation' stamp: 'ar 2/9/2000 21:55'!colormapIfNeededForDepth: destDepth	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."	| newMap |	colors == nil ifTrue: [		"use the standard colormap"		^ Color colorMapIfNeededFrom: depth to: destDepth].	(destDepth = cachedDepth and:[cachedColormap class == Bitmap]) 		ifTrue: [^ cachedColormap].	newMap _ Bitmap new: colors size.	1 to: colors size do: [:i |		newMap			at: i			put: ((colors at: i) pixelValueForDepth: destDepth)].	cachedDepth _ destDepth.	^ cachedColormap _ newMap.! !!ColorForm methodsFor: 'color mapping' stamp: 'ar 2/9/2000 22:19'!colormapIfNeededFor: destForm	| newMap |	colors == nil ifTrue: [		"use the standard colormap"		^ super colormapIfNeededFor: destForm].	(destForm depth = cachedDepth and:[cachedColormap class == ColorMap]) 		ifTrue: [^ cachedColormap].	newMap _ Bitmap new: (1 bitShift: depth).	1 to: colors size do: [:i |		newMap			at: i			put: ((colors at: i) pixelValueForDepth: destForm depth)].	cachedDepth _ destForm depth.	^cachedColormap _ ColorMap shifts: nil masks: nil colors: newMap.! !!FormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:25'!portClass	^GrafPort! !!FormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:25'!resetGrafPort	"Private!! Create a new grafPort for a new copy."	port _ self portClass toForm: form.	port clipRect: clipRect.! !!FormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:25'!setForm: aForm	self reset.	form _ aForm.	port _ self portClass toForm: form.! !!FXFormCanvas methodsFor: 'drawing-images' stamp: 'ar 5/25/2000 17:27'!image: aForm at: aPoint sourceRect: sourceRect rule: rule 	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	port sourceKey: nil; colorMap: (aForm colormapIfNeededFor: form).	port fillColor: nil.	port image: aForm at: aPoint + origin sourceRect: sourceRect rule: rule.! !!FXFormCanvas methodsFor: 'drawing-images' stamp: 'ar 5/25/2000 17:33'!stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor	"FXBlt needs a completely different setup for stenciling."	self setStencilColor: aColor form: stencilForm.	port stencil: stencilForm		at: aPoint + origin		sourceRect: sourceRect.! !!FXFormCanvas methodsFor: 'drawing-general' stamp: 'ar 5/25/2000 17:35'!warpFrom: sourceQuad toRect: destRect	^ (FXBlt toForm: port destForm)		combinationRule: Form paint;		sourceQuad: sourceQuad destRect: (destRect translateBy: origin);		clipRect: clipRect! !!FXFormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:37'!portClass	^FXGrafPort! !!FXFormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:28'!setClearColor: aColor	"Install a new clear color - e.g., a color is used for clearing the background"	port sourceMap: nil; destMap: nil; colorMap: nil.	port sourceKey: nil.	^super setClearColor: aColor! !!FXFormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:31'!setFillColor: aColor	"Install a new color used for filling."	| fillColor screen patternWord |	port sourceMap: nil; destMap: nil; colorMap: nil.	port sourceKey: nil.	fillColor _ self shadowColor ifNil:[aColor].	fillColor ifNil:[fillColor _ Color transparent].	fillColor isColor ifFalse:[		(aColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: aColor; combinationRule: Form over].	"Okay, so fillColor really *is* a color"	port sourceForm: nil.	fillColor isTranslucent ifFalse:[		port combinationRule: Form over.		port fillPattern: fillColor.		port fillPattern: fillColor.		self depth = 8 ifTrue:[			"In 8 bit depth it's usually a good idea to use a stipple pattern"			port fillColor: (fillColor balancedPatternForDepth: 8).			^self]].	"fillColor is some translucent color"	self depth >= 8 ifTrue:[		"We can represent actual transparency"		port fillColor: (fillColor bitPatternForDepth: 32).		port destMap: form colormapToARGB.		port colorMap: form colormapFromARGB.		^port combinationRule: Form blend].	"Less than 8bit depth -- use stipple pattern"	screen _ Color translucentMaskFor: fillColor alpha depth: self depth.	patternWord _ fillColor pixelWordForDepth: self depth.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint.! !!FXFormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:33'!setPaintColor: aColor	"Install a new color used for filling."	| paintColor screen patternWord |	port sourceMap: nil; destMap: nil; colorMap: nil.	port sourceKey: nil.	paintColor _ self shadowColor ifNil:[aColor].	paintColor ifNil:[paintColor _ Color transparent].	paintColor isColor ifFalse:[		(aColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: aColor; combinationRule: Form paint].	"Okay, so paintColor really *is* a color"	port sourceForm: nil.	(paintColor isTranslucent) ifFalse:[		port fillPattern: paintColor.		^port combinationRule: Form paint].	(self depth >= 8) ifTrue:[		port fillPattern: paintColor.		port fillColor: (paintColor bitPatternForDepth: 32).		port destMap: form colormapToARGB.		port colorMap: form colormapFromARGB.		port combinationRule: Form blend.		^self].	"Less than 8bit - use stipple pattern"	screen _ Color translucentMaskFor: paintColor alpha depth: self depth.	patternWord _ paintColor pixelWordForDepth: self depth.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint! !!FXFormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:34'!setStencilColor: aColor form: sourceForm	"Install a new color used for stenciling the given form.	Stenciling in general is done mapping all colors of source form	to the stencil color and installing the appropriate source key.	However, due to possible transparency we may have to install the	color map as source map so that sourceForm gets mapped to a 32bit	ARGB pixel value before the color combination is done. If we don't	need translucency we can just use the regular color map (faster!!)"	| stencilColor screen patternWord |	port sourceMap: nil; destMap: nil; colorMap: nil.	port sourceKey: nil.	stencilColor _ self shadowColor ifNil:[aColor].	stencilColor isColor ifFalse:[^self]. "No way"	(stencilColor isTranslucent) ifFalse:[		"If the paint color is not translucent we can use a simpler		transformation going through a single color map."		port sourceKey: 0. "The transparent source key"		port fillPattern: stencilColor.		port colorMap: (ColorMap colors: port fillColor).		port fillColor: nil.		^port combinationRule: Form over].	(self depth >= 8) ifTrue:[		"For transparent stenciling, things are more complicated.		We need to install the transparent stencil color as source map		so that all colors are mapped to the stencil color and afterwards		blended with the destination."		port sourceKey: 0. "The transparent source key"		port fillPattern: stencilColor.		port destMap: form colormapToARGB.		port colorMap: form colormapFromARGB.		port sourceMap: (ColorMap colors: (stencilColor bitPatternForDepth: 32)).		port fillColor: nil.		port combinationRule: Form blend.		^self].	"Translucent stenciling in < 8bit depth requires three parts,	a color map, a fill pattern and the appropriate combination rule."	port colorMap: (ColorMap colors: (Color maskingMap: form depth)).	screen _ Color translucentMaskFor: stencilColor alpha depth: self depth.	patternWord _ stencilColor pixelWordForDepth: self depth.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint! !FXBltSimulation initialize!