'From Squeak2.8alpha of 13 January 2000 [latest update: #2066] on 6 May 2000 at 12:07:36 am'!"Change Set:		halo-swDate:			6 May 2000Author:			Scott WallaceChanges involving halos, some motivated by observations from Bert Freudenberg:	¥	First cmd-click over a window now puts up halo on the window itself.	¥	Halo bounds match actual bounds of the morph the halo belongs to, not its 'fullBounds'.	¥	Allows the morph which is about to don a halo to choose what class of HaloMorph to use; this opens the door to having customized subclasses of HaloMorph.	¥	Adding halo speeded up by eliminating a long-standing, redundant recalculation of which morph is to acquire the halo."!!Morph methodsFor: 'geometry' stamp: 'sw 4/27/2000 13:53'!worldBoundsForHalo	"To restore older behavior, change this to return  self fullBoundsInWorld"	^ self boundsInWorld! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 5/4/2000 20:38'!addHalo: evt	| halo prospectiveHaloClass |	prospectiveHaloClass _ Smalltalk at: self classForHalo ifAbsent: [HaloMorph].	halo _ prospectiveHaloClass new bounds: self worldBoundsForHalo.	self world addMorphFront: halo.	halo target: self.	halo startStepping.! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 4/3/2000 15:20'!classForHalo	"Answer the name of the desired kind of HaloMorph to launch on behalf of the receiver"	^ #HaloMorph! !!HaloMorph methodsFor: 'stepping' stamp: 'sw 4/27/2000 13:40'!step	| newBounds |	target ifNil: [^ self].	target isWorldMorph		ifTrue: [newBounds _ target bounds]		ifFalse: [newBounds _ target renderedMorph worldBoundsForHalo].	newBounds = self bounds ifTrue: [^ self].	growingOrRotating ifFalse: [  "adjust halo bounds if appropriate"		submorphs size > 1			ifTrue: [self addHandles].  "recreates full set with new bounds"		self bounds: newBounds].! !!HaloMorph methodsFor: 'private' stamp: 'sw 4/27/2000 13:39'!addCircleHandles	| box |	simpleMode _ false.	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target renderedMorph worldBoundsForHalo.  "update my size"	box _ self basicBox.	target addHandlesTo: self box: box.	self addName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'sw 4/27/2000 13:40'!addSimpleHandles	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target renderedMorph worldBoundsForHalo.  "update my size"	self innerTarget addSimpleHandlesTo: self box: self basicBoxForSimpleHalos! !!HaloMorph methodsFor: 'private' stamp: 'sw 4/27/2000 13:40'!addSimpleHandlesTo: aHaloMorph box: aBox	| aHandle |	simpleMode _ true.	target isWorldMorph ifTrue: [^ self addSimpleHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"		self bounds: target renderedMorph worldBoundsForHalo.  "update my size"		self addHandleAt: (((aBox topLeft + aBox leftCenter) // 2) + self simpleFudgeOffset) color: Color paleBuff icon: 'Halo-MoreHandles'		on: #mouseDown send: #addFullHandles to: self.	aHandle _ self addGraphicalHandle: #Rotate at: aBox bottomLeft on: #mouseDown send: #startRot:with: to: self.	aHandle on: #mouseStillDown send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(self addGraphicalHandle: #Scale at: aBox bottomRight  on: #mouseDown send: #startScale:with: to: self)				on: #mouseStillDown send: #doScale:with: to: self]		ifFalse: [(self addGraphicalHandle: #Scale at: aBox bottomRight on: #mouseDown send: #startGrow:with: to: self)				on: #mouseStillDown send: #doGrow:with: to: self].	(innerTarget isMemberOf: SketchMorph) ifTrue:  "isMemberOf: used advisedly here"		[self addSimpleSketchMorphHandlesInBox: aBox].	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'sw 4/27/2000 13:40'!basicBoxForSimpleHalos	^ (target topRendererOrSelf worldBoundsForHalo expandBy: self handleAllowanceForIconicHalos)			intersect: (self world bounds insetBy: 8@8)! !!HandMorph methodsFor: 'event handling' stamp: 'sw 4/3/2000 17:44'!handleMouseOver: evt	| mList allMouseOvers leftMorphs enteredMorphs now t oldHalo balloonHelpEnabled |	owner ifNil: [^ self].	balloonHelpEnabled _ Preferences balloonHelpEnabled.	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	now _ Time millisecondClockValue.	"Make a list of all potential mouse-overs..."	allMouseOvers _ mList select:		[:m | m wantsHalo or: [(balloonHelpEnabled and: [m wantsBalloon])  "To start a timer"			or: [m handlesMouseOver: (evt transformedBy: (m transformFrom: self))]  "To send mouseEnter:"]].	leftMorphs _ mouseOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (mouseOverMorphs includes: m) not].	"Notify and remove any mouse-overs that have just been left..."	leftMorphs do: [:m |		mouseOverMorphs remove: m.		m wantsBalloon ifTrue: [m deleteBalloon].		m mouseLeave: (evt transformedBy: (m transformFrom: self)).		mouseOverTimes removeKey: m ifAbsent: [] ].	"Add any new mouse-overs and send mouseEnter: and/or start timers..."	enteredMorphs do: [:m |		mouseOverMorphs add: m.		dragOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		(m handlesMouseOver: evt) ifTrue:			[m mouseEnter: (evt transformedBy: (m transformFrom: self))].		(m wantsHalo or: [m wantsBalloon]) ifTrue:			[mouseOverTimes at: m put: now]].	mouseOverTimes keys do:		[:m | "Check pending timers for lingering"		t _ mouseOverTimes at: m.		(now < t "rollover" or: [now > (t+800)]) ifTrue:			["Yes we have lingered for 0.8 seconds..."			mouseOverTimes removeKey: m.			m owner ifNotNil:  "Not deleted during linger (--it happens ;--)"				[m wantsHalo					ifTrue: [oldHalo _ m world haloMorphOrNil.							(oldHalo == nil or: [oldHalo target ~~ m])								ifTrue: ["Put up halo for m"										self popUpHaloFor: m event: evt.										(balloonHelpEnabled and: [m wantsBalloon]) ifTrue:											["...and reschedule balloon after longer linger"											mouseOverTimes at: m put: now]]								ifFalse: ["Halo for m is already up, so show balloon"										(balloonHelpEnabled and: [m wantsBalloon])											ifTrue: [m showBalloon: m balloonText]]]					ifFalse:						[(balloonHelpEnabled and: [m wantsBalloon])							ifTrue: [m showBalloon: m balloonText]]]]]! !!HandMorph methodsFor: 'halos' stamp: 'sw 4/3/2000 17:47'!popUpHaloFor: aMorph event: evt	self world abandonAllHalos.	targetOffset _ self position.	aMorph addHalo: evt! !!HandMorphForReplay methodsFor: 'halos' stamp: 'sw 4/27/2000 13:42'!addHalo: evt	| halo |	argument isNil		ifTrue: 			[halo _ HaloMorph new bounds: self worldBoundsForHalo.			self world addMorphFront: halo.			halo target: self.			halo startStepping]		ifFalse: [argument addHalo: evt]! !!SystemWindow methodsFor: 'events' stamp: 'sw 4/18/2000 09:06'!wantsHaloFromClick	^ true! !