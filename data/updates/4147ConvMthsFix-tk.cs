'From Squeak3.1alpha of 28 February 2001 [latest update: #4146] on 8 June 2001 at 9:02:50 pm'!!ChangeSet methodsFor: 'fileIn/Out' stamp: 'tk 6/8/2001 20:28'!askAddedInstVars: classList	| pairList pairClasses index pls newStruct oldStruct |	"Ask the author whether these newly added inst vars need to be non-nil"	pairList _ OrderedCollection new.	pairClasses _ OrderedCollection new.	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."	classList do: [:cls |		newStruct _ (cls allInstVarNames).		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.		newStruct do: [:instVarName |			(oldStruct includes: instVarName) ifFalse: [				pairList add: cls name, ' ', instVarName.				pairClasses add: cls]]].	pairList isEmpty ifTrue: [^ #()].	[index _ PopUpMenu withCaption: 'These instance variables were added.When an old project comes in, newly added instance variables will have the value nil.Click on items to remove them from the list.Click on any for which nil is an OK value.'		chooseFrom: pairList, #('all of these need a non-nil value'						'all of these are OK with a nil value').	(index <= (pls _ pairList size)) & (index > 0) ifTrue: [		pairList removeAt: index.		pairClasses removeAt: index].	index = (pls + 2) ifTrue: ["all are OK" ^ #()].	pairList isEmpty | (index = (pls + 1)) "all need conversion, exit"] whileFalse.	^ pairClasses asSet asArray	"non redundant"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'tk 6/8/2001 20:29'!askRemovedInstVars: classList	| pairList pairClasses index pls newStruct oldStruct |	"Ask the author whether these newly removed inst vars need to have their info saved"	pairList _ OrderedCollection new.	pairClasses _ OrderedCollection new.	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."	classList do: [:cls |		newStruct _ (cls allInstVarNames).		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.		oldStruct do: [:instVarName |			(newStruct includes: instVarName) ifFalse: [				pairList add: cls name, ' ', instVarName.				pairClasses add: cls]]].	pairList isEmpty ifTrue: [^ #()].	[index _ PopUpMenu withCaption: 'These instance variables were removed.When an old project comes in, instance variables that have been removed will lose their contents.Click on items to remove them from the list.Click on any whose value is unimportant and need not be saved.'		chooseFrom: pairList, #('all of these need a conversion method'						'all of these have old values that can be erased').	(index <= (pls _ pairList size)) & (index > 0) ifTrue: [		pairList removeAt: index.		pairClasses removeAt: index].	index = (pls + 2) ifTrue: ["all are OK" ^ #()].	pairList isEmpty | (index = (pls + 1))  "all need conversion, exit"] whileFalse.	^ pairClasses asSet asArray	"non redundant"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/8/2001 20:55'!aComment"SmartRefStream implements the 'Seeds' object storage system.  Please see the class comment.There is just one method (per class) whose name is convertToCurrentVersion:refStream:. This method is expected to convert any old version to the current version. Determining which old version is represented by the incoming object can be done in several ways: noticing that a current inst var is nil when it should have data, noticing that there is an older inst var name in the variable dictionary (first argument), checking kinds of objects in one or more inst vars, or retrieving the classVersion of the incoming object from the ref stream. ChangeSet>>checkForConversionMethods prompts (if the preference is set) you to write/modify conversion methods when they might be needed.All you have to do is to write the method.  The Dictionary argument has entries (old inst var name -> value), so you can fetch the old vars by name.  See SmartRefStream.catalogValues:size:.  aSmartRefStream is available so you can get at 'structures' which tells the inst vars of other old classes in this file.====== example is out of date ========In the Squeak Goodies Folder, we provide an example.	Suppose there once was a file named ArrayTwoDee.  If it like Array2D in this system, but is implemented differently.  ArrayTwoDee was defined like this: (Array variableSubclass: #ArrayTwoDee instanceVariableNames: 'height '...) so it is a variable class with the array values directly in the instance.  	Array2D uses an instance var for 'contents' instead.   It has width varying most quickly, whereas the old ArrayTwoDee had height varying first.  The order of the elements must be changed.	File in the file ConvArrayTwoDee2.st.It defines SmartRefStream.arrayTwoDeeh2 to return Array2D, so we know what class to convert to.It defines Array2D.converth2:wc0: to do the actual conversion.  Look at the method.  The method 'test' has the code for actually doing the conversion:	| new2D ss |	ss _ SmartRefStream fileNamed: 'ArrayTwoDee.test.obj'.	new2D _ ss next.	ss close.	new2D class == Array2D ifFalse: [self error: 'Class conversion failed'].	(new2D atCol: 1) = #(1 2 3 4) ifFalse: [self error: 'not flipped properly'].	^ new2D	The file ArrayTwoDee.test.obj has the object data in it, and is the actual file we converted.  Note that we never had to file in the old class ArrayTwoDee.  It is never needs to be defined in our system.  	If ArrayTwoDee held an instance variable of another old class, say WeirdNumber, what form would it be in when converth2:wc0: gets run?  All objects get assigned instances in the current system before they are put into the value dictionary.  Generally, leaves of the object tree get converted first, so the values in an instance variable should be fully functioning objects in the current system."! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'tk 6/8/2001 21:01'!writeConversionMethodIn: newClass fromInstVars: oldList to: newList renamedFrom: oldName	"The method convertToCurrentVersion:refStream: was not found in newClass.  Write a default conversion method for the author to modify."	| code newOthers oldOthers copied |	(newClass includesSelector: #convertToCurrentVersion:refStream:) ifTrue: [		^ self].	"later put a new comment on the end of the method."	code _ WriteStream on: (String new: 500).	code nextPutAll: 'convertToCurrentVersion: varDict refStream: smartRefStrm'; cr.	newOthers _ newList asOrderedCollection "copy".	oldOthers _ oldList asOrderedCollection "copy".	copied _ OrderedCollection new.	newList do: [:instVar |		(oldList includes: instVar) ifTrue: [			instVar isInteger ifFalse: [copied add: instVar].			newOthers remove: instVar.			oldOthers remove: instVar]].	code tab; nextPutAll: '"These variables are automatically stored into the new instance: '.	code nextPutAll: copied asArray printString; nextPut: $.; cr.	code tab; nextPutAll: 'This method is for additional changes.'; 		nextPutAll: '  Use statements like (foo _ varDict at: ''foo'')."'; cr; cr.	(newOthers size = 0) & (oldOthers size = 0) & (oldName == nil) ifTrue: [^ self].		"Instance variables are the same.  Only the order changed.  No conversion needed."	(newOthers size > 0) ifTrue: [		code tab; nextPutAll: '"New variables: ', newOthers asArray printString, 			'.  If a non-nil value is needed, please assign it."'; cr].	(oldOthers size > 0) ifTrue: [		code tab; nextPutAll: '"These are going away ', oldOthers asArray printString, 			'.  Possibly store their info in some other variable?"'; cr].	oldName ifNotNil: [		code tab; nextPutAll: '"Test for instances of class ', oldName, '.'; cr.		code tab; nextPutAll: 'Instance vars with the same name have been moved here."'; cr.		].	code cr; tab.	code nextPutAll: '^ super convertToCurrentVersion: varDict refStream: smartRefStrm'.	newClass compile: code contents classified: 'object fileIn'.	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe." ! !