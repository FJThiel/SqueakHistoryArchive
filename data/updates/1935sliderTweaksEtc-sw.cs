'From Squeak2.8alpha of 13 January 2000 [latest update: #1931] on 13 March 2000 at 2:51:56 pm'!"Change Set:		sliderTweaksEtc-swDate:			14 March 2000Author:			Scott WallaceMakes it possible for sliders, scrollbars, etc.,to have their smaller values at either end.  (Formerly, vertical sliders always had to have the smaller value at the top; now it can be at the bottom)Changes the default behavior of the sliders in parts bins to have zero at the bottom.In the etoy system, the ascending/descending behavior of a slider is now directly controllable via the Viewer.Makes the control that determines whether a slider should assume only integer values ('truncate') accessible to the etoy system.Makes the wording of menu items relating to sliders be dynamic, so that persistent menus will tell the truth.The default precision for 'cursor' readouts (Pasteups/Holders) and 'numericValue' readouts (Slider) is set to give two decimal places.  This works both for Viewers and Watchers."!MorphicModel subclass: #Slider	instanceVariableNames: 'slider value setValueSelector sliderShadow sliderColor descending '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!Object methodsFor: 'scripting' stamp: 'sw 3/10/2000 13:57'!defaultFloatPrecisionFor: aGetSelector	"Answer a number indicating the default float precision to be used in a numeric readout for which the receiver is the model."	^ 1! !!Morph methodsFor: 'scripting' stamp: 'sw 3/10/2000 17:23'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putSelector	| aColor aTile displayer |	aColor _ Color lightGray lighter.	aTile _ typeSymbol == #number		ifTrue:			[NumericReadoutTile new typeColor: aColor]		ifFalse:				[typeSymbol == #sound				ifTrue:					[SoundReadoutTile new typeColor: aColor]				ifFalse:					[StringReadoutTile new typeColor: aColor]]. 	displayer _ UpdatingStringMorph new		getSelector: getSelector;		target: self player;		growable: true;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	(typeSymbol == #number)		ifTrue:			 [(#(cursorWrapped  "etc...") includes: partName)				ifTrue:					[displayer floatPrecision: 0.1]				ifFalse:					[(self player slotInfo includesKey: partName)  "i.e., a user-defined numeric slot"						ifTrue:							[displayer floatPrecision: (self player slotInfoAt: partName) floatPrecision]]].	typeSymbol == #string		ifTrue:			[displayer useStringFormat.			displayer growable: true]		ifFalse:			[(typeSymbol == #sound)				ifTrue: 	[displayer useStringFormat]				ifFalse:	[displayer useDefaultFormat]].	aTile addMorphBack: displayer.	((putSelector ~~ #unused) and: [#(number sound boolean) includes: typeSymbol])  ifTrue: [aTile addArrows].	aTile literal: (self scriptPerformer perform: getSelector).	^ aTile! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 3/10/2000 17:25'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new		getSelector: (ScriptingSystem getterSelectorFor: partName);		target: scriptedPlayer costume renderedMorph;		borderWidth: 1;		extent:  22@22.		putSelector == #unused ifFalse: [readout putSelector: (ScriptingSystem setterSelectorFor: partName)]].	readout ifNil: [readout _ scriptedPlayer costume updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 3/10/2000 13:50'!getDescending	^  self getValueFromCostume: #descending! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 3/12/2000 11:51'!getTruncate	^  self getValueFromCostume: #truncate! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 3/10/2000 13:52'!setDescending: aBoolean	self setCostumeSlot: #descending: toValue: aBoolean! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 3/12/2000 11:52'!setTruncate: aBoolean	self setCostumeSlot: #truncate: toValue: aBoolean! !!Player methodsFor: 'slots-user' stamp: 'sw 3/11/2000 20:06'!tearOffFancyWatcherFor: aSlotName	| aWatcher aTile getSel aLine aColor aTower precision |	aColor _ Color r: 0.903 g: 0.903 b: 1.0.	aLine _ AlignmentMorph newRow vResizing: #shrinkWrap; color: aColor.	aLine borderWidth: 1; borderColor: aColor darker.	aLine addMorphBack: (self tileReferringToSelf borderWidth: 0; typeColor: aColor; color: aColor; bePossessive).	aLine addTransparentSpacerOfSize: (4@0).	aTower _ AlignmentMorph newColumn color: aColor.	aTower addTransparentSpacerOfSize: (0 @ 1).	aTower addMorphBack: (StringMorph contents: aSlotName, ' = ' font: ScriptingSystem fontForTiles).	aLine addMorphBack: aTower.	aTile _ NumericReadoutTile new typeColor: aColor.	aWatcher _ UpdatingStringMorph new.	(precision _ self defaultFloatPrecisionFor: (getSel _ ScriptingSystem getterSelectorFor: aSlotName)) ~= 1 ifTrue:		[aWatcher floatPrecision: precision].	aWatcher growable: true;		getSelector: getSel;		putSelector: (ScriptingSystem setterSelectorFor: aSlotName).	aWatcher target: self.	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: (self perform: getSel) width: 30.	aLine addMorphBack: aTile.	aWatcher step; fitContents.	self currentHand attachMorph: aLine! !!Player methodsFor: 'slots-user' stamp: 'sw 3/11/2000 20:07'!tearOffWatcherFor: aSlotName	| aWatcher precision getSel |	aWatcher _ UpdatingStringMorph new.	getSel _ ScriptingSystem getterSelectorFor: aSlotName.	((self typeForSlot: aSlotName) = #number)		ifFalse:			[aWatcher useStringFormat]		ifTrue:			[precision _ self defaultFloatPrecisionFor: getSel.			precision ~= 1 ifTrue: [aWatcher floatPrecision: precision]].	aWatcher growable: true;		getSelector: getSel;		putSelector: (ScriptingSystem setterSelectorFor: aSlotName);		setNameTo: aSlotName. 	aWatcher target: self.	aWatcher step.	aWatcher fitContents.	self currentHand attachMorph: aWatcher! !!Player methodsFor: 'misc' stamp: 'sw 3/11/2000 20:09'!defaultFloatPrecisionFor: aGetSelector	| aSlotName |	(#(getCursor getNumericValue getCursorWrapped) includes: aGetSelector)		ifTrue:			[^ 0.01].	aSlotName _ Utilities inherentSelectorForGetter: aGetSelector.	((self elementTypeFor: aSlotName) == #userSlot)		ifTrue:			[^ (self slotInfoAt: aSlotName) floatPrecision].	^ 1! !!Slider methodsFor: 'initialize' stamp: 'sw 3/10/2000 13:05'!initialize	super initialize.	bounds := 0@0 corner: 16@100.	color := Color gray.	borderWidth := 1.	borderColor := #inset.	value _ 0.0.	descending _ false.	self initializeSlider! !!Slider methodsFor: 'access' stamp: 'sw 3/10/2000 13:05'!descending	^ descending == true! !!Slider methodsFor: 'access' stamp: 'sw 3/12/2000 11:57'!descending: aBoolean	descending _ aBoolean.	self value: value! !!Slider methodsFor: 'geometry' stamp: 'sw 3/10/2000 13:44'!computeSlider	| r |	r _ self roomToMove.	self descending		ifFalse:			[slider position: (bounds isWide				ifTrue: [r topLeft + ((r width * value) asInteger @ 0)]				ifFalse: [r topLeft + (0 @ (r height * value)  asInteger)])]		ifTrue:			[slider position: (bounds isWide				ifTrue:	[r bottomRight - ((r width * value) asInteger @ 0)]				ifFalse:	[r bottomRight - ((0 @ (r height * value) asInteger))])].	slider extent: self sliderExtent! !!Slider methodsFor: 'scrolling' stamp: 'sw 3/10/2000 13:37'!scrollAbsolute: event	| r p |	r _ self roomToMove.	bounds isWide		ifTrue: [r width = 0 ifTrue: [^ self]]		ifFalse: [r height = 0 ifTrue: [^ self]].	p _ event targetPoint adhereTo: r.	self descending		ifFalse:			[self setValue: (bounds isWide 				ifTrue: [(p x - r left) asFloat / r width]				ifFalse: [(p y - r top) asFloat / r height])]		ifTrue:			[self setValue: (bounds isWide				ifTrue: [(r right - p x) asFloat / r width]				ifFalse:	[(r bottom - p y) asFloat / r height])]! !!Slider methodsFor: 'object fileIn' stamp: 'sw 3/10/2000 13:43'!convertbosfcebbmsosvsss0: varDict bosfcebbmsosvsssd0: smartRefStrm	"These variables are automatically stored into the new instance ('slider' 'value' 'setValueSelector' 'sliderShadow' 'sliderColor' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('descending' )  If a non-nil value is needed, please assign it."! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'sw 3/12/2000 11:39'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'set action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.	aCustomMenu add: 'set minimum value' action: #setMinVal.	aCustomMenu add: 'set maximum value' action: #setMaxVal.	aCustomMenu addUpdating: #descendingString action: #toggleDescending.	aCustomMenu addUpdating: #truncateString action: #toggleTruncate.	((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue: [		aCustomMenu add: 'set target' action: #setTarget:].	target ifNotNil: [		aCustomMenu add: 'clear target' action: #clearTarget].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'sw 3/12/2000 11:38'!descendingString	^ self descending		ifTrue:			['switch to ascending']		ifFalse:			['switch to descending']! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'sw 3/12/2000 11:40'!toggleDescending	descending _ self descending not! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'sw 3/12/2000 18:37'!truncateString	^ truncate		ifTrue:			['turn off truncation']		ifFalse:			['turn on truncation']! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/12/2000 11:48'!getScaledValue	| aValue |	aValue _ (value * (maxVal - minVal)) + minVal.	^ truncate ifTrue: [aValue truncated] ifFalse: [aValue]! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/12/2000 11:54'!truncate	^ truncate == true! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/12/2000 11:53'!truncate: aBoolean	truncate _ aBoolean! !!SimpleSliderMorph class methodsFor: 'as yet unclassified' stamp: 'sw 3/10/2000 13:45'!authoringPrototype	| aSlider nominalColor |	"self currentHand attachMorph: SimpleSliderMorph authoringPrototype"	aSlider _ super authoringPrototype beSticky.	aSlider extent: 14@120.	nominalColor _ Color r: 0.4 g: 0.86 b: 0.7.	aSlider color: nominalColor.	aSlider sliderColor: nominalColor muchLighter.	aSlider descending: true.	aSlider setScaledValue: 0.3.	^ aSlider! !!SimpleSliderMorph class methodsFor: 'as yet unclassified' stamp: 'sw 3/12/2000 11:51'!categoryContributions	^ #(('slider' ((slot numericValue) (slot minVal) (slot maxVal) (slot descending) (slot truncate) (slot color) (slot knobColor) (slot width) (slot height))))! !!SimpleSliderMorph class methodsFor: 'as yet unclassified' stamp: 'sw 3/12/2000 11:50'!helpContributions	^ #((numericValue			'A number representing the current position of the knob.')		(minVal			'The number represented when the knob is at the left or top of the slider; the smallest value returned by the slider.')		(maxVal			'The number represented when the knob is at the right or bottom of the slider; the largest value returned by the slider.')		(descending			'Tells whether the smallest value is at the top/left (descending = false) or at the bottom/right (descending = true)')		(truncate			'If true, only whole numbers are used as values; if false, fractional values are allowed.')		(knobColor			'The color of the slider''s knob.'))! !!SimpleSliderMorph class methodsFor: 'as yet unclassified' stamp: 'sw 3/12/2000 11:51'!standardSlotInfo	^ #((numericValue 	number		readWrite	getNumericValue	setNumericValue:)		(minVal			number		readWrite	getMinVal			setMinVal:)		(maxVal			number		readWrite	getMaxVal			setMaxVal:)		(descending		boolean		readWrite	getDescending		setDescending:)		(truncate		boolean		readWrite	getTruncate			setTruncate:)		(knobColor		color		readWrite	getKnobColor		setKnobColor:))! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 3/11/2000 20:05'!target: anObject	target _ anObject.	getSelector ifNotNil: [floatPrecision _ anObject defaultFloatPrecisionFor: getSelector]! !!UpdatingStringMorph class methodsFor: 'instance creation' stamp: 'sw 3/10/2000 17:27'!on: targetObject selector: aSymbol	^ self new		getSelector: aSymbol;		target: targetObject! !Object removeSelector: #defaultFloatPrecision!Player removeSelector: #defaultFloatPrecision!Player removeSelector: #floatPrecisionForSlot:!Slider removeSelector: #defaultFloatPrecision!"Postscript:"StandardScriptingSystem initialize.Utilities replacePartSatisfying: [:m | (m isKindOf: MorphThumbnail) and:	[m morphRepresented isKindOf: SimpleSliderMorph]] inGlobalFlapSatisfying:		[:f | f wording = 'Supplies'] with: SimpleSliderMorph authoringPrototype.Utilities replaceScriptingAreaInToolsFlap.ScriptingSystem resetStandardPartsBin.!