'From Squeak 2.1 of June 30, 1998 on 11 September 1998 at 3:57:29 pm'!"Change Set:		jhmKeyboardFixDate:			11 September 1998Author:			John MaloneyFixes problems with the piano keyboard in the envelope editor.Makes it possible to submit a sound without quick-start. Supportschanging the duration of a sound while it is being played andimproves on the 'stopGracefully' feature added by Dan."!!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:56'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds. This default implementation does nothing."! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:54'!stopGracefully	"End this note with a graceful decay. If the note has envelopes, determine the decay time from its envelopes."	| decayInMs env |	envelopes isEmpty		ifTrue: [			self adjustVolumeTo: 0 overMSecs: 10.			decayInMs _ 10]		ifFalse: [			env _ envelopes first.			decayInMs _ env attackTime + env decayTime].	self duration: (mSecsSinceStart + decayInMs) / 1000.0.	self stopAfterMSecs: decayInMs.! !!FMSound methodsFor: 'accessing' stamp: 'jm 9/9/1998 07:49'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!FMSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:55'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:36'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:57'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!MixedSound reorganize!('initialization' initialize)('accessing' duration sounds)('sound generation' doControl mixSampleCount:into:startingAt:leftVol:rightVol: reset samplesRemaining)('composition' + add: add:pan: add:pan:volume:)('copying' copy copySounds)!!PianoKeyboardMorph methodsFor: 'all' stamp: 'jm 9/9/1998 22:22'!mouseDownEvent: event noteMorph: noteMorph pitch: pitch	| wasPlaying |	noteMorph color: playingKeyColor.	wasPlaying _ false.	soundPlaying		ifNil: [			soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]		ifNotNil: [			wasPlaying _ soundPlaying samplesRemaining > 0.			wasPlaying ifFalse: [soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]].	soundPlaying		pitch: (AbstractSound pitchForMIDIKey: pitch+24);		internalizeModulationAndRatio;		duration: 100.0.	wasPlaying ifFalse: [soundPlaying reset].	SoundPlayer resumePlaying: soundPlaying quickStart: wasPlaying not.! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'jm 9/9/1998 10:45'!mouseUpEvent: event noteMorph: noteMorph pitch: pitch	noteMorph color: ((#(0 1 3 5 6 8 10) includes: pitch\\12)					ifTrue: [whiteKeyColor]					ifFalse: [blackKeyColor]).	soundPlaying ifNotNil: [soundPlaying stopGracefully].! !!PluckedSound reorganize!('initialization' setPitch:dur:loudness:)('accessing' duration duration:)('sound generation' mixSampleCount:into:startingAt:leftVol:rightVol: reset samplesRemaining stopAfterMSecs:)('copying' copy copyRing)!!PluckedSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:40'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:58'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!RestSound reorganize!('initialization' setDur:)('accessing' duration duration:)('sound generation' mixSampleCount:into:startingAt:leftVol:rightVol: reset samplesRemaining)!!RestSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:42'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!SampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:39'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!SampledSound methodsFor: 'playing' stamp: 'jm 9/9/1998 21:58'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!SequentialSound reorganize!('initialization' initialize)('accessing' duration sounds)('sound generation' doControl mixSampleCount:into:startingAt:leftVol:rightVol: reset samplesRemaining)('copying' copy copySounds)('composition' , add:)!!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 9/11/1998 15:34'!initialize	"SoundPlayer initialize"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothing, especially during other activities. If it is too high, there will be an overly long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. It is typically in the range 50-200."	"SoundPlayer initialize; shutDown; startUp"	SamplingRate _ 22050.	BufferMSecs _ 100.	Stereo _ true.	UseReverb ifNil: [UseReverb _ true].! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/8/1998 17:54'!resumePlaying: aSound	"Start playing the given sound without resetting it; it will resume playing from where it last stopped."	"Implementation detail: On virtual machines that don't support the quickstart primitive, you may need to edit this method to pass false to resumePlaying:quickStart:."	self resumePlaying: aSound quickStart: true.! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/8/1998 18:02'!resumePlaying: aSound quickStart: quickStart	"Start playing the given sound without resetting it; it will resume playing from where it last stopped. If quickStart is true, then try to start playing the given sound immediately."	| doQuickStart |	Preferences disableSounds ifTrue: [^ self].	doQuickStart _ quickStart.	PlayerProcess == nil ifTrue: [		self canStartPlayer ifFalse: [^ self].		self startUp.		doQuickStart _ false].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound)			ifTrue: [doQuickStart _ false]			ifFalse: [				doQuickStart ifFalse: [ActiveSounds add: aSound]]].	"quick-start the given sound, unless the sound player has just started"	doQuickStart ifTrue: [self startPlayingImmediately: aSound].! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 9/10/1998 07:04'!updateTargetAt: mSecs	"Update the volume envelope slope and limit for my target. Answer false."	mSecs < nextRecomputeTime ifTrue: [^ false].	self computeSlopeAtMSecs: mSecs.	mSecsForChange < 5 ifTrue: [mSecsForChange _ 5].  "don't change instantly to avoid clicks"	target adjustVolumeTo: targetVol * scale overMSecs: mSecsForChange.	^ false! !FMSound removeSelector: #stopGracefully!SoundPlayer initialize!