'From Squeak2.8alpha of 16 February 2000 [latest update: #2231] on 31 May 2000 at 10:20:23 pm'!"Change Set:		VMChanges-miscDate:			31 May 2000Author:			John Maloney, Tim Rowledge, and Andreas RaabThe change set is a combination of Johns and Tims changes folded into the very latest modifications." !ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP localHomeContext messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache atCache lkupClass reclaimableContextCount nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals compilerInitialized compilerHooks extraVMMemory interpreterVersion obsoleteIndexedPrimitiveTable obsoleteNamedPrimitiveTable interpreterProxy showSurfaceFn '	classVariableNames: 'ActiveProcessIndex AtCacheEntries AtCacheFixedFields AtCacheFmt AtCacheMask AtCacheOop AtCacheSize AtCacheTotalSize AtPutBase BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex CompilerHooksSize CrossedX DirBadPath DirEntryFound DirNoMoreEntries EndOfRun ExcessSignalsIndex FirstLinkIndex GenerateBrowserPlugin HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageLookupClassIndex MessageSelectorIndex MethodArrayIndex MethodCacheClass MethodCacheEntries MethodCacheEntrySize MethodCacheMask MethodCacheMethod MethodCachePrim MethodCacheSelector MethodCacheSize MethodIndex MyListIndex NextLinkIndex PrimitiveExternalCallIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'VMConstruction-Interpreter'!!CCodeGenerator methodsFor: 'public' stamp: 'TPR 5/23/2000 17:10'!declareModuleName: nameString local: bool	"add the declaration of a module name, version and local/external tag"	self var: #moduleName declareC:'const char *moduleName = "', nameString, (bool ifTrue:[' (i)"'] ifFalse:[' (e)"'])! !!Interpreter methodsFor: 'interpreter shell' stamp: 'jm 5/30/2000 08:28'!interpret	"This is the main interpreter loop. It normally loops forever, fetching and executing bytecodes. When running in the context of a browser plugin VM, however, it must return control to the browser periodically. This should done only when the state of the currently running Squeak thread is safely stored in the object heap. Since this is the case at the moment that a check for interrupts is performed, that is when we return to the browser if it is time to do so. Interrupt checks happen quite frequently."	"record entry time when running as a browser plug-in"	GenerateBrowserPlugin ifTrue: [self plugInSetStartTime].	self internalizeIPandSP.	self fetchNextBytecode.	[true] whileTrue: [self dispatchOn: currentBytecode in: BytecodeTable].	localIP _ localIP - 1.  "undo the pre-increment of IP before returning"	self externalizeIPandSP.! !!Interpreter methodsFor: 'processes' stamp: 'jm 5/30/2000 09:35'!internalQuickCheckForInterrupts	"Internal version of quickCheckForInterrupts for use within jumps."	self inline: true.	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		self externalizeIPandSP.		self checkForInterrupts.		"When Squeak runs as a browser plugin, it must return control to the browser periodically. This should done only when the state of the currently running Squeak thread is safely stored in the object heap, as is the case at this point. Since this method is inlined, the message 'ReturnFromInterpret' is actually a C macro that returns control from the interpret() method to the browser that called it."		GenerateBrowserPlugin ifTrue: [			self plugInTimeToReturn ifTrue: [self ReturnFromInterpret]].		self internalizeIPandSP].! !!Interpreter methodsFor: 'other primitives' stamp: 'TPR 5/16/2000 16:48'!primitiveListExternalModule	"Primitive. Return the n-th loaded external module name."	| moduleName index length nameOop |	self var: #moduleName type: 'char *'.	self methodArgumentCount = 1 ifFalse:[^self primitiveFail].	index _ self stackIntegerValue: 0.	index <= 0 ifTrue:[^self primitiveFail].	moduleName _ self ioListLoadedModule: index.	moduleName == nil ifTrue:[		self pop: 2. "arg+rcvr"		^self push: self nilObject].	length _ self strlen: moduleName.	nameOop _ self instantiateClass: self classString indexableSize: length.	0 to: length-1 do:[:i|		self storeByte: i ofObject: nameOop withValue: (moduleName at: i)].	self pop: 2. "arg+rcvr"	self push: nameOop.! !!Interpreter methodsFor: 'image save/restore' stamp: 'jm 5/30/2000 08:44'!readImageFromFile: f HeapSize: desiredHeapSize StartingAt: imageOffset	"Read an image from the given file stream, allocating the given amount of memory to its object heap. Fail if the image has an unknown format or requires more than the given amount of memory."	"Details: This method detects when the image was stored on a machine with the opposite byte ordering from this machine and swaps the bytes automatically. Furthermore, it allows the header information to start 512 bytes into the file, since some file transfer programs for the Macintosh apparently prepend a Mac-specific header of this size. Note that this same 512 bytes of prefix area could also be used to store an exec command on Unix systems, allowing one to launch Smalltalk by invoking the image name as a command."	"This code is based on C code by Ian Piumarta and Smalltalk code by Tim Rowledge. Many thanks to both of you!!!!"	| swapBytes headerStart headerSize dataSize oldBaseAddr minimumMemory memStart bytesRead bytesToShift heapSize |	self var: #f declareC: 'sqImageFile f'.	swapBytes _ self checkImageVersionFrom: f startingAt: imageOffset.	headerStart _ (self sqImageFilePosition: f) - 4.  "record header start position"	headerSize			_ self getLongFromFile: f swap: swapBytes.	dataSize				_ self getLongFromFile: f swap: swapBytes.	oldBaseAddr			_ self getLongFromFile: f swap: swapBytes.	specialObjectsOop	_ self getLongFromFile: f swap: swapBytes.	lastHash			_ self getLongFromFile: f swap: swapBytes.	savedWindowSize	_ self getLongFromFile: f swap: swapBytes.	fullScreenFlag		_ self getLongFromFile: f swap: swapBytes.	extraVMMemory		_ self getLongFromFile: f swap: swapBytes.	lastHash = 0 ifTrue: [		"lastHash wasn't stored (e.g. by the cloner); use 999 as the seed"		lastHash _ 999].	"decrease Squeak object heap to leave extra memory for the VM"	heapSize _ self cCode: 'reserveExtraCHeapBytes(desiredHeapSize, extraVMMemory)'.	"compare memory requirements with availability".	minimumMemory _ dataSize + 100000.  "need at least 100K of breathing room"	heapSize < minimumMemory ifTrue: [		GenerateBrowserPlugin			ifTrue: [				self plugInNotifyUser: 'The amount of memory specified by the ''memory'' EMBED tag is not enough for the installed Squeak image file.'.				^ nil]			ifFalse: [self error: 'Insufficient memory for this image']].	"allocate a contiguous block of memory for the Squeak heap"	memory _ self cCode: '(unsigned char *) sqAllocateMemory(minimumMemory, heapSize)'.	memory = nil ifTrue: [		GenerateBrowserPlugin			ifTrue: [				self plugInNotifyUser: 'There is not enough memory to give Squeak the amount specified by the ''memory'' EMBED tag.'.				^ nil]			ifFalse: [self error: 'Failed to allocate memory for the heap']].	memStart _ self startOfMemory.	memoryLimit _ (memStart + heapSize) - 24.  "decrease memoryLimit a tad for safety"	endOfMemory _ memStart + dataSize.	"position file after the header"	self sqImageFile: f Seek: headerStart + headerSize.	"read in the image in bulk, then swap the bytes if necessary"	bytesRead _ self cCode: 'sqImageFileRead(memory, sizeof(unsigned char), dataSize, f)'.	bytesRead ~= dataSize ifTrue: [		GenerateBrowserPlugin			ifTrue: [				self plugInNotifyUser: 'Squeak had problems reading its image file.'.				self plugInShutdown.				^ nil]			ifFalse: [self error: 'Read failed or premature end of image file']].	swapBytes ifTrue: [self reverseBytesInImage].	"compute difference between old and new memory base addresses"	bytesToShift _ memStart - oldBaseAddr.	self initializeInterpreter: bytesToShift.  "adjusts all oops to new location"	^ dataSize! !!Interpreter class methodsFor: 'initialization' stamp: 'jm 5/30/2000 08:21'!initialize	"Interpreter initialize"	super initialize.  "initialize ObjectMemory constants"	self initializeAssociationIndex.	self initializeBytecodeTable.	self initializeCaches.	self initializeCharacterIndex.	self initializeClassIndices.	self initializeCompilerHooks.	self initializeContextIndices.	self initializeDirectoryLookupResultCodes.	self initializeMessageIndices.	self initializeMethodIndices.	self initializePointIndices.	self initializePrimitiveTable.	self initializeSchedulerIndices.	self initializeSmallIntegers.	self initializeStreamIndices.	SemaphoresToSignalSize _ 25.	PrimitiveExternalCallIndex _ 117. "Primitive index for #primitiveExternalCall"	GenerateBrowserPlugin _ false.! !!Interpreter class methodsFor: 'initialization' stamp: 'TPR 5/23/2000 22:02'!initializePrimitiveTable 	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveArrayBecomeOneWay)	"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveStoreStackp)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveBlockCopy)		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveTestDisplayDepth)			"Blue Book: primitiveCursorLocPut"		(92 primitiveSetDisplayMode)				"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)						"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveObsoleteIndexedPrimitive)	"primitiveCopyBits"		(97 primitiveSnapshot)		(98 primitiveStoreImageSegment)		(99 primitiveLoadImageSegment)		(100 primitivePerformInSuperclass)		"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveObsoleteIndexedPrimitive)	"primitiveDrawLoop"		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFlushCacheByMethod)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)			"Squeak 2.2 and earlier use 119.  Squeak 2.3 and later use 116.			Both are supported for backward compatibility."		"Miscellaneous Primitives (120-127)"		(120 primitiveCalloutToFFI)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveObsoleteIndexedPrimitive)	"primitiveReadJoystick"		(147 primitiveObsoleteIndexedPrimitive)	"primitiveWarpBits"		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 163 primitiveObsoleteIndexedPrimitive)		(164 168 primitiveFail)		(169 primitiveObsoleteIndexedPrimitive)		"Sound Primitives (170-199)"		(170 175 primitiveObsoleteIndexedPrimitive)		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 oldprimSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(186 188 primitiveFail)		(189 194 primitiveObsoleteIndexedPrimitive)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 225 primitiveObsoleteIndexedPrimitive)		(226 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 241 primitiveObsoleteIndexedPrimitive)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 primStringfindSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveInstVarsPutFromStack) "Never used except in Disney tests.  Remove after 2.3 release."		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 529 primitiveObsoleteIndexedPrimitive)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 545 primitiveObsoleteIndexedPrimitive)		(546 547 primitiveFail)		"Pen Tablet Primitives"		(548 primitiveObsoleteIndexedPrimitive)		(549 primitiveObsoleteIndexedPrimitive)		"Sound Codec Primitives"		(550 primADPCMCodecprivateDecodeMono)			(551 primADPCMCodecprivateDecodeStereo)			(552 primADPCMCodecprivateEncodeMono)			(553 primADPCMCodecprivateEncodeStereo)			(554 569 primitiveFail)  "reserved for additional codec primitives"		"External primitive support primitives"		(570 primitiveFlushExternalPrimitives)		(571 primitiveUnloadModule)		(572 primitiveListBuiltinModule)		(573 primitiveListExternalModule)		(574 primitiveFail) "reserved for addl. external support prims"		"Unassigned Primitives"		(575 700 primitiveFail)).! !!Interpreter class methodsFor: 'translation' stamp: 'jm 5/30/2000 08:53'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]"	"Interpreter patchInterp: 'Squeak VM PPC'"	self translate: fileName doInlining: inlineFlag forBrowserPlugin: false.! !!Interpreter class methodsFor: 'translation' stamp: 'ar 5/31/2000 21:19'!translate: fileName doInlining: inlineFlag forBrowserPlugin: pluginFlag	"Note: The pluginFlag is meaningless on Windows and Unix. On these platforms Squeak runs as it's own process and doesn't need any special attention from the VMs point of view. Meaning that NONE of the required additional functions will be supported. In other words, the pluginFlag is not needed and not supported."	"Translate the Smalltalk description of the virtual machine into C. If inlineFlag is true,small method bodies are inlined to reduce procedure call overhead. On the PPC, this results in a factor of three speedup with only 30% increase in code size. If pluginFlag is true, generate code for an interpreter that runs as a browser plugin (Netscape or IE)."	| doInlining cg exports |	doInlining _ inlineFlag.	pluginFlag ifTrue: [doInlining _ true].  "must inline when generating browser plugin"	Interpreter initialize.	ObjectMemory initialize.	GenerateBrowserPlugin _ pluginFlag.	cg _ CCodeGenerator new initialize.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	"Get all the named prims from the VM.	Note: the format of exports is:		pluginName -> Array of: primitiveName.	so we can generate a nice table from it."	exports _ Array with: '' -> cg exportedPrimitiveNames asArray.	cg storeCodeOnFile: fileName doInlining: doInlining.	"Add our plugins"	{		"Graphics"			"Note: BitBltSimulation should go first, 			because three of it's entries might be 			looked up quite often (due to refs from 			InterpreterProxy). This will go away at			some point but for now it's a good idea			to have those entries early in the table."		BitBltSimulation.			BalloonEnginePlugin. 		SurfacePlugin. "To support OS surfaces through FXBlt"		"I/O subsystems"		FilePlugin.		SocketPlugin. 		SoundPlugin. 		MIDIPlugin. 		SerialPlugin. 		JoystickTabletPlugin. 		AsynchFilePlugin. 	 	"Numerics"		LargeIntegersPlugin.		FFTPlugin. 		FloatArrayPlugin. 		Matrix2x3Plugin. 		"Compression"		DeflatePlugin.		"Note: Optionally, you can translate the following as builtins.		As of Squeak 2.7 they are not builtins by default:			DSAPlugin.			KlattSynthesizerPlugin.			SoundCodecPlugin.			B3DEnginePlugin.			FFIPlugin.		"	} do:[:plugin|		cg _ plugin translate: plugin moduleName, '.c'					doInlining: doInlining					locally: true.		exports _ exports copyWith: 			(plugin moduleName -> cg exportedPrimitiveNames asArray).	].	self storeExports: exports on: 'sqNamedPrims.h'.! !!Interpreter class methodsFor: 'translation' stamp: 'ar 5/31/2000 21:20'!translateForBrowserPlugin: fileName	"NOTE: For other than Mac, see the comment in		#translate:doInlining:forBrowserPlugin:	"	"Time millisecondsToRun: [		Interpreter translateForBrowserPlugin: 'pluginInterp.c'.		Smalltalk beep]"	"Interpreter patchInterp: 'Squeak VM PPC'"	self translate: fileName doInlining: true forBrowserPlugin: true.! !!InterpreterPlugin class methodsFor: 'accessing' stamp: 'TPR 5/23/2000 15:33'!moduleNameAndVersion	"Answer the receiver's module name and version info that is used for the plugin's C code. The default is to append the code generation date, but any useful text is ok (keep it short)"	^ self moduleName, Character space asString, Date today asString! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'TPR 5/23/2000 17:09'!translate: fileName doInlining: inlineFlag locally: localFlag	"Time millisecondsToRun: [		FloatArrayPlugin translate: 'SqFloatArray.c' doInlining: true.		Smalltalk beep]"	| cg theClass fullName fd |	fullName _ self baseDirectoryName.	fd _ FileDirectory on: fullName.	localFlag ifFalse:[		(fd directoryExists: self moduleName) 			ifFalse:[fd createDirectory: self moduleName].		fd _ fd on: (fd fullNameFor: self moduleName)].	fullName _ fd fullNameFor: fileName.	self initialize.	self headerFile ifNotNil:[		(CrLfFileStream newFileNamed: (fd fullNameFor: self moduleName,'.h'))			nextPutAll: self headerFile;			close].	cg _ self codeGeneratorClass new initialize.	localFlag ifTrue:[cg pluginPrefix: self moduleName].	"Add an extra declaration for module name"	cg declareModuleName: self moduleNameAndVersion local: localFlag.	theClass _ self.	[theClass == Object] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass _ theClass superclass].	cg storeCodeOnFile: fullName doInlining: inlineFlag.	^cg! !!B3DEnginePlugin class methodsFor: 'translation' stamp: 'TPR 5/23/2000 17:26'!translate: fileName doInlining: inlineFlag locally: localFlag	"Time millisecondsToRun: [		FloatArrayPlugin translate: 'SqFloatArray.c' doInlining: true.		Smalltalk beep]"	| cg fullName fd |	fullName _ self baseDirectoryName.	fd _ FileDirectory on: fullName.	localFlag ifFalse:[		(fd directoryExists: self moduleName) 			ifFalse:[fd createDirectory: self moduleName].		fd _ fd on: (fd fullNameFor: self moduleName)].	fullName _ fd fullNameFor: fileName.	self initialize.	self headerFile ifNotNil:[		(CrLfFileStream newFileNamed: (fd fullNameFor: self moduleName,'.h'))			nextPutAll: self headerFile;			close].	cg _ self codeGeneratorClass new initialize.	localFlag ifTrue:[cg pluginPrefix: self moduleName].	"Add an extra declaration for module name"		cg declareModuleName: self moduleNameAndVersion local: localFlag.	{InterpreterPlugin. B3DEnginePlugin. B3DTransformerPlugin. B3DVertexBufferPlugin. B3DShaderPlugin. B3DClipperPlugin. B3DPickerPlugin. B3DRasterizerPlugin} do: 		[:theClass | 		theClass initialize.		cg addClass: theClass.		theClass declareCVarsIn: cg].	cg storeCodeOnFile: fullName doInlining: inlineFlag.	B3DRasterizerPlugin writeSupportCode: true.	^cg! !!B3DEnginePlugin class methodsFor: 'translation' stamp: 'TPR 5/23/2000 17:26'!translateB3D	"B3DEnginePlugin translateB3D"	"Translate all the basic plugins into one support module 	and write the C sources for the rasterizer."	| cg |	cg _ PluggableCodeGenerator new initialize.		cg declareModuleName: self moduleNameAndVersion local: false.	{InterpreterPlugin. B3DEnginePlugin. B3DTransformerPlugin. B3DVertexBufferPlugin. B3DShaderPlugin. B3DClipperPlugin. B3DPickerPlugin. B3DRasterizerPlugin} do: 		[:theClass | 		theClass initialize.		cg addClass: theClass.		theClass declareCVarsIn: cg].	cg storeCodeOnFile: self moduleName , '.c' doInlining: true.	"	cg storeCodeOnFile: '/tmp/Ballon3D.c' doInlining: true."	B3DRasterizerPlugin writeSupportCode: true! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 5/30/2000 18:45'!readmeFile	^ 'Building the Squeak Virtual MachineThe Macintosh virtual machine is built using the following source files:	sq.h				-- shared definitions included in all .c files	sqConfig.h			-- platform configuration settings	sqMachDep.h		-- machine dependent macros to support threaded code	sqPlatformSpecific.h -- platform specific macros and definitions	sqVirtualMachine.h	-- support for dynamic primitives	sqADPCMPrims.c		-- ADCPM sound compression primitives	sqFilePrims.c		-- file primitives	sqMacAsyncFilePrims.c -- Mac asynchronous file I/O	sqMacDirectory.c	-- Mac directory enumerations	sqMacJoystickAndTablet.c -- Mac support for Wacom tablets and Gravis MouseStickII joystick	sqMacNetwork.c		-- Mac networking primitives	sqMacSerialAndMIDIPort.c -- Mac serial and MIDI port primitives	sqMacSound.c		-- Mac audio output primitives	sqMacWindow.c		-- Mac window and event handling; main program	sqMiscPrims.c		-- miscellaneous automatically generated primitives	sqNamedPrims.c		-- support for named primitives	sqSoundPrims.c		-- automatically generated sound synthesis primitives	sqOldSoundPrims.c	-- old versions of sound primitives for backward compatibility	sqVirtualMachine.c	-- support for dynamic primitives	interp.c				-- automatically generated code for the virtual machineIn addition to these files, a number of .h and .c files are generated when Squeak generates a new interpreter. The exact set of files depends on which sets of primitives are included. In general, all the files created by this process should be visible to the CW project and all the generated .c files should be added to the CW project. Don''t worry--the linker will tell you if you forget something.The platform specific files are sqMacXXX.c, totaling about 2000 lines of code when this document was originally written. All other code is written to standard ANSI libraries and should port easily to other C environments.The file sqMacMinimal.c can be used a porting guide. This ~1100 line file stubs out all non-essential support functions and, together with sqFilePrims.c, allows one to build a functioning virtual machine that only lacks non-essential I/O functions (including support for file directory enumeration, which is not really essential!!). The small size of this file demonstrates how little code is really needed to get Squeak running on a new platform.Thanks to Ian Piumarta, the C header files are identical across all the major Squeak platforms.The code assumes that C ints and pointers are 4 bytes and double floats are 8 bytes; these assumptions are checked at start up time. Float objects in the image are stored in the IEEE standard byte ordering for double-precision floats on all platforms; macros in sq.h can be defined to swap bytes into and out of the platform native float format if necessary. (To ensure proper word alignment, one typically has to copy a Squeak Float object into a C "double" variable before operating on it; byte swapping can be done while doing this copy for little or no additional cost.)The files interp.c, sqSoundPrims.c, and sqMiscPrims.c are generated automatically, so changes to these files will be lost when they are next generated. It is fine to make ephemeral changes to these file for the purpose of debugging or statistics gathering. To generate the interpreter, see the "translation" category in Interpreter class. To generate sqSoundPrims.c, see the class method "cCodeForSoundPrimitives" in AbstractSound.The current VM was compiled with Metrowerks CodeWarrior 11. Earlier, I used Semantec Think C 6.0, but discovered a few bugs in their libraries having to do with 8-byte versus 4-byte integers. These bugs have probably been fixed by now.This code has also been compiled under the MPW "Mr. C" Macintosh compiler by Hans-Martin Mosner (hmm@heeg.de) with only one minor change: you will need to create an empty "MacHeaders.h" file. You may get some harmless compiler warnings and, for peak performance, the method that patches the dispatch loop must also be changed. Hans-Martin says: "The whole VM seems to be marginally slower than the delivered VM, but it is significantly smaller."The virtual machine uses the following libraries:	Libraries for 68K Project:		dnr.c		InterfaceLib		MathLibCFM68K (4i/8d).Lib		MSL C.CFM68K Far(4i/8d).Lib		MWCFM68KRuntime.Lib		Profiler68kCFM.lib	Libraries for PowerPC Project:		dnr.c		InterfaceLib		MathLib		MSL C.PPC.Lib		MWCRuntime.Lib		profilerPPC.libThe Mac networking code also requires three files from Apple''s MacTCP developer''s kit:	MacTCP.h	AddressXlation.h	dnr.cFor convenience, these files are included.To build a fat binary, build the 68K version first, and make sure that the file "Squeak VM 68K" is included in the PowerPC project. Then build the PowerPC version. CodeWarrior will include the 68K interpreter in the resource fork of the output file, resulting in an interpreter that runs on either 68K or PowerPC Macs.To get an additional speedup, the object code for the bytecode dispatch loop of the PPC version can be patched using the method "patchInterp:" in Interpreter class.Note: In order to support dynamically loaded primitives, we have switched to using Code Fragement Manager model for the 68K VM. This has several ramifications:  1. You now need to use the CFM versions of the library files. The 68K project file has been updated accordingly.  2. You cannot run the 68K VM under the emulator on the PowerPC (Apple doesn''t support CFM apps under the 68K emulator).  3. You need to be sure that version 4.0 or later of "CFM-68K Runtime Enabler" is in the Extensions folder of the system folder on your 68K Mac. *** Warning: Older versions of "CFM-68K Runtime Enabler" had bugs that will probably prevent Squeak from even starting!! ***.Building Named Primitive PluginsI''ve included a pair of sample projects for building Squeak primitive plugins. As usual, you must build the 68K version first, then the FAT one. If you don''t need a FAT version, you can remove the 68K project from the PPC one.Pluginized VMSqueak 2.8 introduces the "pluginized VM". In the interest of getting a Mac version of the 2.8 out as quickly and with as little chance of introducing bugs as possible, I''ve made the bare minimal changes to the Mac support files. For this reason, all the Mac primitives that were previously linked into the VM must still be built into the VM as "internal" primitives. That is because many of them still access a few VM functions and variables directly, rather than calling through the interpreter proxy, which they must in order to run in an external plugin. One can still override these builtin primitives with an external plugin and, of course, newly built plugins can be created as external or internal plugins. When the dust settles, it will be easy to make the final few changes required.Building Squeak as a Browser PluginI''ve included an archive containing a CW project file and various supporting files for building the Squeak VM as plugin for Netscape or Internet Explorer on the Mac. The plugin works with versions 4.0 or later of either browser. However, the primitives that can be used to ask the browser to fetch a URL do not work in versions of IE earlier than 5.0. There are also two resource files the contain the strings needed to tell the browser about the plugin--its name, version, and the mime and file extensions it recognizes.To build this, you will need a copy of the Netscape Plugin SDK, available for free at their web site. The required support files are:	jri.h	jritypes.h	jri_md.h	npapi.h	npmac.cpp	npupp.hThe installation and use of Squeak as a browser plugin is somewhat beyond the scope of this readme file. The basic idea is that the Squeak image started by the browser lives in a pre-defined directory ("Disney:Disney Online:Squeak:Files" by default) with predefined name (e.g., "squeak.image" or "DOLSqueak.image"). The browser plugin can only read and write files within the image directory and directories contained within it. This is called Squeak file system "sand box". The browser captures most of the command key combination, so you have to use the menus rather than your favorite Squeak command key shortcuts. The browser also captures cmd-., so the interrupt key when running under the browser is control-C. The most flexible way to invoke Squeak is through the HTML "EMBED" command. This allows arbitrary arguments to be made available to Squeak. The "memory" EMBED tag can be used to tell Squeak how much memory is required by a given Squeaklet.To build a browser plugin VM, do the following:  1. translate a browser plugin version of the interpreter (using Interpreter>translateForBrowserPlugin:).  2. edit the file sqMacWindow.c and uncomment the #define of "PLUGIN"  3. edit the file platform.exports and uncomment the #define of "PLUGIN"  4. build the plugin using the supplied browser plugin projectIf you build your own project file, note that IE requires that the main entry point be "main" rather than CW''s usual "__start". (Netscape doesn''t care, so it took me a long time to figure out why it wasn''t working under IE!!) The supplied project produces a PPC-only plugin.	-- John Maloney, May 25, 2000'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 5/31/2000 21:27'!squeakConfigFile	^ '/* sqConfig.h -- platform identification and configuration */#if defined(__MWERKS__) && !!defined(macintosh)  /* CodeWarrior 8 neglects to define "macintosh" */# define macintosh#endif#if defined(WIN32) || defined(_WIN32) || defined(Win32)  /* Some compilers use different win32 definitions.     Define WIN32 so we have only to check for one symbol. */# if !!defined(WIN32)#  define WIN32# endif#endif#if defined(macintosh)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define SQ_CONFIG_DONE#endif#if defined(ACORN)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define SQ_CONFIG_DONE#endif#if defined(WIN32)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# if defined(_M_IX86) || defined(X86)  /* x86 systems */#  define DOUBLE_WORD_ALIGNMENT#  define DOUBLE_WORD_ORDER  /* Note: We include a generic sqWin32.h to override some settings */#  include "sqWin32.h"#  define SQ_CONFIG_DONE# elif defined(_WIN32_WCE)#  include "sqWin32.h"#  define SQ_CONFIG_DONE# else#  error unsupported win32 processor type (alpha?!!)# endif#endif/* This file has been superseded by autoconf for Unix variants. */#if defined(HAVE_CONFIG_H)# include "sqUnixConfig.h"#endif#if !!defined(SQ_CONFIG_DONE)# error test for, and describe, your architecture here.#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 5/31/2000 21:51'!squeakFilePrimsFile	^ '#include "sq.h"#ifndef NO_STD_FILE_SUPPORT#include "FilePlugin.h"/***	The state of a file is kept in the following structure,	which is stored directly in a Squeak bytes object.	NOTE: The Squeak side is responsible for creating an	object with enough room to store sizeof(SQFile) bytes.	The session ID is used to detect stale file objects--	files that were still open when an image was written.	The file pointer of such files is meaningless.	Files are always opened in binary mode; Smalltalk code	does (or someday will do) line-end conversion if needed.	Writeable files are opened read/write. The stdio spec	requires that a positioning operation be done when	switching between reading and writing of a read/write	filestream. The lastOp field records whether the last	operation was a read or write operation, allowing this	positioning operation to be done automatically if needed.	typedef struct {		File	*file;		int		sessionID;		int		writable;		int		fileSize;		int		lastOp;  // 0 = uncommitted, 1 = read, 2 = write //	} SQFile;***//*** Constants ***/#define UNCOMMITTED	0#define READ_OP		1#define WRITE_OP	2#ifndef SEEK_SET#define SEEK_SET	0#define SEEK_CUR	1#define SEEK_END	2#endif/*** Variables ***/int thisSession = 0;extern struct VirtualMachine * interpreterProxy;int sqFileAtEnd(SQFile *f) {	/* Return true if the file''s read/write head is at the end of the file. */	if (!!sqFileValid(f)) return interpreterProxy->success(false);	return ftell(f->file) == f->fileSize;}int sqFileClose(SQFile *f) {	/* Close the given file. */	if (!!sqFileValid(f)) return interpreterProxy->success(false);	fclose(f->file);	f->file = NULL;	f->sessionID = 0;	f->writable = false;	f->fileSize = 0;	f->lastOp = UNCOMMITTED;}int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize) {	char cFileName[1000];	int i, err;	if (sqFileNameSize >= 1000) {		return interpreterProxy->success(false);	}	/* copy the file name into a null-terminated C string */	sqFilenameFromString(cFileName, sqFileNameIndex, sqFileNameSize);	if (!!plugInAllowAccessToFilePath(cFileName, sqFileNameSize)) {		return interpreterProxy->success(false);	}	err = remove(cFileName);	if (err) {		return interpreterProxy->success(false);	}}int sqFileGetPosition(SQFile *f) {	/* Return the current position of the file''s read/write head. */	int position;	if (!!sqFileValid(f)) return interpreterProxy->success(false);	position = ftell(f->file);	if (position < 0) return interpreterProxy->success(false);	return position;}int sqFileInit(void) {	/* Create a session ID that is unlikely to be repeated.	   Zero is never used for a valid session number.	   Should be called once at startup time.	*/	thisSession = clock() + time(NULL);	if (thisSession == 0) thisSession = 1;	/* don''t use 0 */	return 1;}int sqFileShutdown(void) {	return 1;}int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag) {	/* Opens the given file using the supplied sqFile structure	   to record its state. Fails with no side effects if f is	   already open. Files are always opened in binary mode;	   Squeak must take care of any line-end character mapping.	*/	char cFileName[1001];	int i;	/* don''t open an already open file */	if (sqFileValid(f)) return interpreterProxy->success(false);	/* copy the file name into a null-terminated C string */	if (sqFileNameSize > 1000) {		return interpreterProxy->success(false);	}	sqFilenameFromString(cFileName, sqFileNameIndex, sqFileNameSize);	if (!!plugInAllowAccessToFilePath(cFileName, sqFileNameSize)) {		return interpreterProxy->success(false);	}	if (writeFlag) {		/* First try to open an existing file read/write: */		f->file = fopen(cFileName, "r+b");		if (f->file == NULL) {			/* Previous call fails if file does not exist. In that case,			   try opening it in write mode to create a new, empty file.			*/			f->file = fopen(cFileName, "w+b");			if (f->file !!= NULL) {				/* set the type and creator of newly created Mac files */				dir_SetMacFileTypeAndCreator((char *)sqFileNameIndex, sqFileNameSize, "TEXT", "R*ch");				}		}		f->writable = true;	} else {		f->file = fopen(cFileName, "rb");		f->writable = false;	}	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		return interpreterProxy->success(false);	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}	f->lastOp = UNCOMMITTED;}int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Read count bytes from the given file into byteArray starting at	   startIndex. byteArray is the address of the first byte of a	   Squeak bytes object (e.g. String or ByteArray). startIndex	   is a zero-based index; that is a startIndex of 0 starts writing	   at the first byte of byteArray.	*/	char *dst;	int bytesRead;	if (!!sqFileValid(f)) return interpreterProxy->success(false);	if (f->writable && (f->lastOp == WRITE_OP)) fseek(f->file, 0, SEEK_CUR);  /* seek between writing and reading */	dst = (char *) (byteArrayIndex + startIndex);	bytesRead = fread(dst, 1, count, f->file);	f->lastOp = READ_OP;	return bytesRead;}int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize) {	char cOldName[1000], cNewName[1000];	int i, err;	if ((oldNameSize >= 1000) || (newNameSize >= 1000)) {		return interpreterProxy->success(false);	}	/* copy the file names into null-terminated C strings */	sqFilenameFromString(cOldName, oldNameIndex, oldNameSize);	sqFilenameFromString(cNewName, newNameIndex, newNameSize);	if (!!plugInAllowAccessToFilePath(cOldName, oldNameSize) ||		!!plugInAllowAccessToFilePath(cNewName, newNameSize)) {		return interpreterProxy->success(false);	}	err = rename(cOldName, cNewName);	if (err) {		return interpreterProxy->success(false);	}}int sqFileSetPosition(SQFile *f, int position) {	/* Set the file''s read/write head to the given position. */	if (!!sqFileValid(f)) return interpreterProxy->success(false);	fseek(f->file, position, SEEK_SET);	f->lastOp = UNCOMMITTED;}int sqFileSize(SQFile *f) {	/* Return the length of the given file. */	if (!!sqFileValid(f)) return interpreterProxy->success(false);	return f->fileSize;}int sqFileValid(SQFile *f) {	return (		(f !!= NULL) &&		(f->file !!= NULL) &&		(f->sessionID == thisSession));}int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Write count bytes to the given writable file starting at startIndex	   in the given byteArray. (See comment in sqFileReadIntoAt for interpretation	   of byteArray and startIndex).	*/	char *src;	int bytesWritten, position;	if (!!(sqFileValid(f) && f->writable)) return interpreterProxy->success(false);	if (f->lastOp == READ_OP) fseek(f->file, 0, SEEK_CUR);  /* seek between reading and writing */	src = (char *) (byteArrayIndex + startIndex);	bytesWritten = fwrite(src, 1, count, f->file);	position = ftell(f->file);	if (position > f->fileSize) {		f->fileSize = position;  /* update file size */	}	if (bytesWritten !!= count) {		interpreterProxy->success(false);	}	f->lastOp = WRITE_OP;	return bytesWritten;}#endif /* NO_STD_FILE_SUPPORT */'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 5/31/2000 21:30'!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#include "sqVirtualMachine.h"#define true 1#define false 0#define null 0  /* using "null" because nil is predefined in Think C *//* pluggable primitives macros *//* Note: All pluggable primitives are defined as	EXPORT(int) somePrimitive(void)   If the platform requires special declaration modifiers   the EXPORT macro can be redefined*/#define EXPORT(returnType) returnType/* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* platform-dependent memory size adjustment macro *//* Note: This macro can be redefined to allows platforms with a   fixed application memory partition (notably, the Macintosh)   to reserve extra C heap memory for special applications that need   it (e.g., for a 3D graphics library). Since most platforms can   extend their application memory partition at run time if needed,   this macro is defined as a noop here and redefined if necessary   in sqPlatformSpecific.h.*/#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) origHeapSize/* platform-dependent millisecond clock macros *//* Note: The Squeak VM uses three different clocks functions for   timing. The primary one, ioMSecs(), is used to implement Delay   and Time millisecondClockValue. The resolution of this clock   determines the resolution of these basic timing functions. For   doing real-time control of music and MIDI, a clock with resolution   down to one millisecond is preferred, but a coarser clock (say,   1/60th second) can be used in a pinch. The VM calls a different   clock function, ioLowResMSecs(), in order to detect long-running   primitives. This function must be inexpensive to call because when   a Delay is active it is polled twice per primitive call. On several   platforms (Mac, Win32), the high-resolution system clock used in   ioMSecs() would incur enough overhead in this case to slow down the   the VM significantly. Thus, a cheaper clock with low resolution is   used to implement ioLowResMSecs() on these platforms. Finally, the   function ioMicroMSecs() is used only to collect timing statistics   for the garbage collector and other VM facilities. (The function   name is meant to suggest that the function is based on a clock   with microsecond accuracy, even though the times it returns are   in units of milliseconds.) This clock must have enough precision to   provide accurate timings, and normally isn''t called frequently   enough to slow down the VM. Thus, it can use a more expensive clock   that ioMSecs(). By default, all three clock functions are defined   here as macros based on the standard C library function clock().   Any of these macros can be overridden in sqPlatformSpecific.h.*/int ioMSecs(void);int ioLowResMSecs(void);int ioMicroMSecs(void);#define ioMSecs()		((1000 * clock()) / CLOCKS_PER_SEC)#define ioLowResMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)#define ioMicroMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)/* filename copy/transform macro. An opportunity to transform the filenames for   platforms with strange needs, anda simple encapsulation for everyone else*/#define sqFilenameFromString(dst, src, num) \if (1) {\	int i; \	for (i = 0; i < num; i++) { \		dst[i] = *((char *) (src + i)); \	} \	dst[num] = 0;\}/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);int ioHasDisplayDepth(int depth);int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag);/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore *//* Read the image from the given file starting at the given image offset */int readImageFromFileHeapSizeStartingAt(sqImageFile f, int desiredHeapSize, int imageOffset);/* NOTE: The following is obsolete - it is only provided for compatibility */#define readImageFromFileHeapSize(f, s) readImageFromFileHeapSizeStartingAt(f,s,0)/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* browser plug-in support */int plugInAllowAccessToFilePath(char *pathString, int pathStringLength);void plugInForceTimeToReturn(void);int plugInInit(char *imageName);int plugInNotifyUser(char *msg);void plugInSetStartTime(void);int plugInShutdown(void);int plugInTimeToReturn(void);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* ar 5/13/2000:	The following set of miscellaneous and sound primitives should	at some point go into named primitives. Right now there are a few	problems with that (related to how the distinct set of methods can	be defined as residing in one plugin).*//* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringfindSubstringinstartingAtmatchTable(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);int oldprimSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/*** sound compression primitives ***/int primADPCMCodecprivateDecodeMono(void);int primADPCMCodecprivateDecodeStereo(void);int primADPCMCodecprivateEncodeMono(void);int primADPCMCodecprivateEncodeStereo(void);/*** pluggable primitive support ***//* NOTE: The following functions are those implemented by sqNamedPrims.c */int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength,  int moduleNameIndex, int moduleNameLength);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadFunctionFrom(char *functionName, char *pluginName);int ioShutdownAllModules(void);int ioUnloadModule(char *);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);char *ioListBuiltinModule(int moduleIndex);char *ioListLoadedModule(int moduleIndex);/* The next two are FFI entries!! (implemented in sqNamedPrims.c as well) */int ioLoadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadSymbolOfLengthFromModule(int functionNameIndex, int functionNameLength, int moduleHandle);/* The next three functions must be implemented by sqXYZExternalPrims.c *//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName);/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle);/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle);/* The Squeak version this interpreter was generated from */extern const char *interpreterVersion;'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'TPR 5/23/2000 17:34'!squeakNamedPrimsFile^'/*****************************************************************************   PROJECT: Squeak *   FILE:    sqNamedPrims.c*   CONTENT: Generic (cross platform) named primitive support**   AUTHOR:  Andreas Raab (ar)*   ADDRESS: Walt Disney Imagineering, Glendale, CA*   EMAIL:   Andreas.Raab@disney.com*   RCSID:   $Id$**   NOTES:******************************************************************************/#include "sq.h"#include "sqNamedPrims.h"#ifdef DEBUG#define dprintf(what) printf what#else#define dprintf(what)#endiftypedef struct ModuleEntry {	struct ModuleEntry *next;	void *handle;	int ffiLoaded;	char name[1];} ModuleEntry;static ModuleEntry *squeakModule = NULL;static ModuleEntry *firstModule = NULL;struct VirtualMachine *sqGetInterpreterProxy(void);static void *findLoadedModule(char *pluginName){	ModuleEntry *module;	if(!!pluginName || !!pluginName[0]) return squeakModule;	module = firstModule;	while(module) {		if(strcmp(module->name, pluginName) == 0) return module;		module = module->next;	}	return NULL;}static ModuleEntry *addToModuleList(char *pluginName, void* handle, int ffiFlag){	ModuleEntry *module;	module = (ModuleEntry*) calloc(1, sizeof(ModuleEntry) + strlen(pluginName));	strcpy(module->name, pluginName);	module->handle = handle;	module->ffiLoaded = ffiFlag;	module->next = firstModule;	firstModule = module;	return firstModule;}/*	removeFromList:	Remove the given entry from the list of loaded modules.	Do NOT free it yet.*/static int removeFromList(ModuleEntry *entry){	ModuleEntry *prevModule;	/* Unlink the entry from the module chain */	if(entry == firstModule) {		firstModule = entry->next;	} else {		prevModule = firstModule;		while(prevModule->next !!= entry)			prevModule = prevModule->next;		prevModule->next = entry->next;	}	return 1;}/*	findExternalFunctionIn:	Look up "pluginName_functionName" in the specified module through	the OS dependent call. NEVER used to search through the internal	primitive table.*/static void *findExternalFunctionIn(char *functionName, ModuleEntry *module){	void *result;	dprintf(("Looking (externally) for %s ... ", functionName));	if(module->handle)		result = (void*) ioFindExternalFunctionIn(functionName, (int) module->handle);	else		result = NULL;	dprintf(("%s\n", result ? "found" : "not found"));	return result;}/*	findInternalFunctionIn:	Lookup the given "pluginName_functionName" in the internal	primitive table. If it can not be found try to look it up	by using the OS dependent mechanism (see comment below).*/static void *findInternalFunctionIn(char *functionName, char *pluginName){	char *function, *plugin;	int index;	dprintf(("Looking (internally) for %s in %s ... ", functionName, (pluginName ? pluginName : "<intrinsic>")));	/* canonicalize functionName and pluginName to be NULL if not specified */	if(functionName && !!functionName[0]) functionName = NULL;	if(pluginName && !!pluginName[0]) pluginName = NULL;	for(index=0;;index++) {		plugin = internalPrimitiveNames[index][0];		function = internalPrimitiveNames[index][1];		/* canonicalize plugin and function to be NULL if not specified */		if(plugin && !!plugin[0]) plugin = NULL;		if(function && !!function[0]) function = NULL;		if(!!plugin && !!function) {/* At end of table. */			dprintf(("not found\n"));			return NULL;		}		/* check for module name match */		if((pluginName == NULL) !!= (plugin == NULL)) continue; /* one is missing */		if(plugin && strcmp(pluginName, plugin)) continue; /* name mismatch */		/* check for function name match */		if((functionName == NULL) !!= (function == NULL)) continue; /* one is missing */		if(function && strcmp(functionName, function)) continue; /* name mismatch */		/* match */		dprintf(("found\n"));		return internalPrimitiveAddresses[index];	}}static void *findFunctionIn(char *functionName, ModuleEntry *module){	if(module->handle == squeakModule->handle)		return findInternalFunctionIn(functionName, module->name);	else		return findExternalFunctionIn(functionName, module);}/*	callInitializersIn:	Call the required initializers in the given module.	The module has been loaded before so the task is to	call a) setInterpreter() and check it''s return, and	b) initialiseModule (if defined) and check it''s return	as well.*/static int callInitializersIn(ModuleEntry *module){	void *init0;	void *init1;	void *init2;	char *moduleName;	int okay;	init0 = findFunctionIn("getModuleName", module);	init1 = findFunctionIn("setInterpreter", module);	init2 = findFunctionIn("initialiseModule", module);	if(init0) {		/* Check the compiled name of the module */		moduleName = ((char* (*) (void))init0)();		if(!!moduleName) {			dprintf(("ERROR: getModuleName() returned NULL\n"));			return 0;		}		if(strncmp(moduleName, module->name, strlen(module->name)) !!= 0) {			dprintf(("ERROR: getModuleName returned %s (expected: %s)\n", moduleName, module->name));			return 0;		}	} else {		/* Note: older plugins may not export the compiled module name */		dprintf(("WARNING: getModuleName() not found in %s\n", module->name));	}	if(!!init1) { 		dprintf(("ERROR: setInterpreter() not found\n"));		return 0;	}	/* call setInterpreter */	okay = ((int (*) (struct VirtualMachine*))init1)(sqGetInterpreterProxy());	if(!!okay) {		dprintf(("ERROR: setInterpreter() returned false\n"));		return 0;	}	if(init2) {		okay = ((int (*) (void)) init2)();		if(!!okay) {			dprintf(("ERROR: initialiseModule() returned false\n"));			return 0;		}	}	dprintf(("SUCCESS: Module %s is now initialized\n", module->name));	return 1;}/*	findAndLoadModule:	Find the module with the given name by,	* first looking it up in some (external) shared library	* then, by trying to find pluginName_setInterpreter.	If the module is found and the initialisers work, add it	to the list of loaded modules and return the new module.	If anything goes wrong make sure the module is unloaded	(WITHOUT calling shutdownModule()) and return NULL.*/static ModuleEntry *findAndLoadModule(char *pluginName, int ffiLoad){	void *handle;	ModuleEntry *module;	dprintf(("Looking for plugin %s\n", (pluginName ? pluginName : "<intrinsic>")));	/* Try to load the module externally */	handle = (void*) ioLoadModule(pluginName);	if(ffiLoad) {		/* When dealing with the FFI, don''t attempt to mess around internally */		if(!!handle) return NULL;		return addToModuleList(pluginName, handle, ffiLoad);	}	/* NOT ffiLoad */	if(!!handle) {		/* might be internal, so go looking for setInterpreter() */		if(findInternalFunctionIn("setInterpreter", pluginName))			handle = squeakModule->handle;		else			return NULL; /* PluginName_setInterpreter() not found */	}	module = addToModuleList(pluginName, handle, ffiLoad);	if(!!callInitializersIn(module)) {		/* Initializers failed */		if(handle !!= squeakModule->handle) {			/* physically unload module */			ioFreeModule((int)handle);		}		removeFromList(module); /* remove list entry */		free(module); /* give back space */		module = NULL;	}	return module;}/* findOrLoadModule:	Look if the given module is already loaded. 	If so, return it''s handle, otherwise try to load it.*/static ModuleEntry *findOrLoadModule(char *pluginName, int ffiLoad){	ModuleEntry *module;	if(!!squeakModule) {		/* Load intrinsics (if possible) */		squeakModule = addToModuleList("", NULL, 1);		firstModule = NULL; /* drop off module list - will never be unloaded */	}	/* see if the module was already loaded */	module = findLoadedModule(pluginName);	if(!!module) {		/* if not try loading it */		module = findAndLoadModule(pluginName, ffiLoad);	}	return module; /* module not found */}/* ioLoadFunctionFrom:	Load and return the given function from the specified plugin.	Return the function address if successful, otherwise 0.	This entry point is called from the interpreter proxy.*/int ioLoadFunctionFrom(char *functionName, char *pluginName){	ModuleEntry *module;	module = findOrLoadModule(pluginName, 0);	if(!!module) {		/* no module */		dprintf(("Failed to find %s (module %s was not loaded)\n", functionName, pluginName));		return 0;	}	if(!!functionName) {		/* only the module was requested but not any specific function */		return 1;	}	/* and load the actual function */	return (int) findFunctionIn(functionName, module);}/* ioLoadExternalFunctionOfLengthFromModuleOfLength	Entry point for functions looked up through the VM.*/int ioLoadExternalFunctionOfLengthFromModuleOfLength(int functionNameIndex, int functionNameLength,                                                      int moduleNameIndex,   int moduleNameLength){	char functionName[256];	char moduleName[256];	int i;	if(functionNameLength > 255 || moduleNameLength > 255)		return 0; /* can''t cope with those */	for(i=0; i< functionNameLength; i++)		functionName[i] = ((char*)functionNameIndex)[i];	functionName[functionNameLength] = 0;	for(i=0; i< moduleNameLength; i++)		moduleName[i] = ((char*)moduleNameIndex)[i];	moduleName[moduleNameLength] = 0;	return ioLoadFunctionFrom(functionName, moduleName);}/* ioLoadSymbolOfLengthFromModule	This entry point is exclusively for the FFI.*/int ioLoadSymbolOfLengthFromModule(int functionNameIndex, int functionNameLength, int moduleHandle){	char functionName[256];	int i;	if(functionNameLength > 255)		return 0; /* can''t cope with those */	for(i=0; i< functionNameLength; i++)		functionName[i] = ((char*)functionNameIndex)[i];	functionName[functionNameLength] = 0;	if(moduleHandle)		return ioFindExternalFunctionIn(functionName, moduleHandle);	else		return 0;}/* ioLoadModuleOfLength	This entry point is exclusively for the FFI.	It does *NOT* call any of the initializers nor	does it attempt to lookup stuff internally.*/int ioLoadModuleOfLength(int moduleNameIndex, int moduleNameLength){	ModuleEntry *module;	char moduleName[256];	int i;	if(moduleNameLength > 255) return 0; /* can''t cope with those */	for(i=0; i< moduleNameLength; i++)		moduleName[i] = ((char*)moduleNameIndex)[i];	moduleName[moduleNameLength] = 0;	module = findOrLoadModule(moduleName, 1);	if(module) return (int) module->handle;	return 0;}/* shutdownModule:	Call the shutdown mechanism from the specified module.*/static int shutdownModule(ModuleEntry *module){	void* fn;	if(module->ffiLoaded) return 1; /* don''t even attempt for ffi loaded modules */	/* load the actual function */	fn = findFunctionIn("shutdownModule", module);	if(fn) return ((int (*) (void)) fn) ();	return 1;}/* ioShutdownAllModules:	Call the shutdown mechanism for all loaded modules.*/int ioShutdownAllModules(void){	ModuleEntry *entry;	entry = firstModule;	while(entry) {		shutdownModule(entry);		entry = entry->next;	}	return 1;}/* ioUnloadModule:	Unload the module with the given name.*/int ioUnloadModule(char *moduleName){	ModuleEntry *entry, *temp;	if(!!squeakModule) return 0; /* Nothing has been loaded */	if(!!moduleName || !!moduleName[0]) return 0; /* nope */	entry = findLoadedModule(moduleName);	if(!!entry) return 1; /* module was never loaded */	/* Try to shutdown the module */	if(!!shutdownModule(entry)) {		/* Could not shut down the module. Bail out. */		return 0;	}	/* Notify all interested parties about the fact */	temp = firstModule;	while(temp) {		if(temp !!= entry) {			/* Lookup moduleUnloaded: from the plugin */			void *fn = findFunctionIn("moduleUnloaded", temp);			if(fn) {				/* call it */				((int (*) (char *))fn)(entry->name);			}		}		temp = temp->next;	}	/* And actually unload it if it isn''t just the VM... */	if(entry->handle !!= squeakModule->handle)		ioFreeModule((int) entry->handle);	removeFromList(entry);	free(entry); /* give back space */	return 1;}/* ioUnloadModuleOfLength:	Entry point for the interpreter.*/int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength){	char moduleName[256];	int i;	if(moduleNameLength > 255) return 0; /* can''t cope with those */	for(i=0; i< moduleNameLength; i++)		moduleName[i] = ((char*)moduleNameIndex)[i];	moduleName[moduleNameLength] = 0;	return ioUnloadModule(moduleName);}/* ioListBuiltinModule:	Return the name of the n-th builtin module.*/char *ioListBuiltinModule(int moduleIndex){	int index;	char *function;	char *plugin;	for(index=0;;index++) {		plugin = internalPrimitiveNames[index][0];		function = internalPrimitiveNames[index][1];		if(!!function && !!plugin) return NULL; /* no more plugins */		if(strcmp(function,"setInterpreter") == 0) {			/* new module */			if(--moduleIndex == 0) {				char *moduleName;				void * init0;						init0 = findInternalFunctionIn("getModuleName", plugin);				if(init0) {					/* Check the compiled name of the module */					moduleName = ((char* (*) (void))init0)();					if(moduleName) { return moduleName;}				}				return plugin;			}		}	}}char *ioListLoadedModule(int moduleIndex) {	int index = 1;	ModuleEntry *entry;	entry = firstModule;	if ( moduleIndex < 1) return (char*)NULL;	while(entry && index < moduleIndex) {		entry = entry->next;		index = index + 1;	}	if ( entry ) {		char *moduleName;		void * init0;		init0 = findFunctionIn("getModuleName", entry);		if(init0) {			/* Check the compiled name of the module */			moduleName = ((char* (*) (void))init0)();			if(moduleName) { return moduleName;}		}		return entry->name;	}	else return (char*)NULL;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 5/31/2000 21:39'!squeakPlatSpecFile	^ '/* sqPlatformSpecific.h -- Platform-specific prototypes and definitions *//* How to use this file:   This file is for general platform-specific macros and declarations.   Function prototypes that are unlikely to introduce name conflicts on   other platforms can be added directly. Macro re-definitions or conflicting   function prototypes can be wrapped in a #ifdefs. Alternatively, a customized   version of this file can be used on that platform. The goal is to keep all   the other header files generic across platforms. To override a definition or   macro from sq.h, you must first #undef it, then provide the new definition.*/#ifdef UNIX/* unix-specific prototypes and definitions */void aioPollForIO(int microSeconds, int extraFd);#define SQ_FORM_FILENAME	"squeak-form.ppm"/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs#undef ioLowResMSecs#endif /* UNIX */#ifdef macintosh/* replace the image file manipulation macros with functions */#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#undef sqAllocateMemorytypedef int sqImageFile;void        sqImageFileClose(sqImageFile f);sqImageFile sqImageFileOpen(char *fileName, char *mode);int         sqImageFilePosition(sqImageFile f);int         sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f);void        sqImageFileSeek(sqImageFile f, int pos);int         sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f);void *						sqAllocateMemory(int minHeapSize, int desiredHeapSize);/* override reserveExtraCHeapBytes() macro to reduce Squeak object heap size on Mac */#undef reserveExtraCHeapBytes#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) (origHeapSize - bytesToReserve)/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs/* macro to return from interpret() loop in browser plugin VM */#define ReturnFromInterpret() return#endif /* macintosh */#ifdef ACORN/* acorn memory allocation */#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) platAllocateMemory(desiredHeapSize)#undef sqFilenameFromString#define sqFilenameFromString(dst, src, num) sqFilenameFromString(dst, src, num)/* string copying macro to compensate for bug in Acorn library code */#define copyNCharsFromTo(num, src, dst)\if(1) {int sqfni;\	char cc;\	for (sqfni = 0; sqfni < num; sqfni++) {\		dst[sqfni] = cc = *((char *) (src + sqfni));\		if ( cc == 0) break;\	}\	dst[num] = 0;\}/* undefine clock macros that are implemented as functions */#undef ioMicroMSecs#undef ioMSecs#define ioMSecs() (10* (int)os_read_monotonic_time())#undef ioLowResMSecs#define ioLowResMSecs() (ioMSecs())#endif /* ACORN */#ifdef WIN32/* Override necessary definitions */#undef putchar#include "sqWin32Alloc.h"#ifdef WIN32_FILE_SUPPORT#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#define sqImageFile unsigned longint sqImageFileClose(sqImageFile h);sqImageFile sqImageFileOpen(char *fileName, char *mode);int sqImageFilePosition(sqImageFile h);int sqImageFileRead(void *ptr, int sz, int count, sqImageFile h);int sqImageFileSeek(sqImageFile h, int pos);int sqImageFileWrite(void *ptr, int sz, int count, sqImageFile h);#endif /* WIN32_FILE_SUPPORT *//* pluggable primitive support */#if defined(_MSC_VER) || defined(__MINGW32__)#  undef EXPORT#  define EXPORT(returnType) __declspec( dllexport ) returnType#endif /* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioLowResMSecs#undef ioMicroMSecs/* Declare GetTickCount() in case <windows.h> is not included */#if !!defined(_WINDOWS_) && !!defined(_WIN32_WCE) && !!defined(_WINDOWS_H)__declspec(dllimport) unsigned long __stdcall GetTickCount(void);#endif#define ioLowResMSecs() GetTickCount()#endif /* WIN32 */'! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'TPR 5/16/2000 16:56'!listLoadedModule: index	"Return the name of the n-th loaded module.	This list is not sorted!!"	<primitive: 573>	^self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'TPR 5/16/2000 16:55'!listLoadedModules	"Smalltalk listLoadedModules"	"Return a list of all loaded modules (e.g., plugins).	This list is not sorted!!"	| modules index name |	modules _ WriteStream on: Array new.	index _ 1.	[true] whileTrue:[		name _ self listExternalModule: index.		name ifNil:[^modules contents].		modules nextPut: name.		index _ index + 1.	].! !Interpreter initialize!