'From Squeak 2.3 beta of Nov 25, 1998 on 12 January 1999 at 5:57:09 pm'!"Change Set:		jhmMiscDate:			12 January 1999Author:			John MaloneySundry fixes including:  1. fix for aborted connections in ConnectionQueue  2. reading of Forms from files was failing to close the file  3. removes obsolete Object>do:  4. adds 'Integer>tinyBenchmarks' which returns benchmark stats as a string  5. adds Socket>ping: for ping-ing a host that has an echo server"!!ColorForm methodsFor: 'color manipulation' stamp: 'jm 10/19/1998 10:52'!mapColor: oldColor to: newColor	"Replace all occurances of the given color with the given new color in my color map."	self ensureColorArrayExists.	1 to: colors size do: [:i | 		(colors at: i) = oldColor ifTrue: [colors at: i put: newColor]].	self clearColormapCache.! !!ConnectionQueue methodsFor: 'private' stamp: 'jm 11/10/1998 18:01'!listenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	[true] whileTrue: [		((socket == nil) and: [connections size < maxQueueLength]) ifTrue: [			"try to create a new socket for listening"			socket _ Socket createIfFail: [nil]].		socket == nil			ifTrue: [(Delay forMilliseconds: 100) wait]			ifFalse: [				socket isUnconnected ifTrue: [socket listenOn: portNumber].				socket waitForConnectionUntil: (Socket deadlineSecs: 10).				socket isConnected					ifTrue: [  "connection established"						accessSema critical: [connections addLast: socket].						socket _ nil]					ifFalse: [						socket isWaitingForConnection							ifFalse: [socket destroy. socket _ nil]]].  "broken socket; start over"		self pruneStaleConnections].! !!Form class methodsFor: 'instance creation' stamp: 'jm 1/11/1999 10:43'!fromBinaryStream: aBinaryStream	"Read a Form or ColorForm from given file, using the first byte of the file to guess its format. Currently handles: GIF, uncompressed BMP, and both old and new DisplayObject writeOn: formats, JPEG, and PCX. Return nil if the file could not be read or was of an unrecognized format."	| firstByte |	firstByte _ aBinaryStream next.	firstByte = 1 ifTrue: [		"old Squeakform format"		^ self new readFromOldFormat: aBinaryStream].	firstByte = 2 ifTrue: [		"new Squeak form format"		^ self new readFrom: aBinaryStream].	firstByte = $B asciiValue ifTrue: [		"BMP format"		aBinaryStream skip: - 1.		^ self fromBMPFile: aBinaryStream].	"Try for JPG, GIF, or PCX..."	"Note: The following call closes the stream."	^ Smalltalk imageReaderClass formFromStream: aBinaryStream! !!Form class methodsFor: 'instance creation' stamp: 'jm 1/11/1999 10:42'!fromFileNamed: fileName	"Read a Form or ColorForm from the given file."	| file form |	file _ (FileStream readOnlyFileNamed: fileName) binary.	form _ self fromBinaryStream: file.	file close.	^ form! !!Integer methodsFor: 'benchmarks' stamp: 'jm 11/20/1998 07:03'!tinyBenchmarks	"Report the results of running the two tiny Squeak benchmarks."	"0 tinyBenchmarks"	| n t1 t2 r |	n _ 1.	t1 _ Time millisecondsToRun: [n benchmark].	t2 _ Time millisecondsToRun: [r _ 28 benchFib].	^ ((n * 500000 * 1000) // t1) printString, ' bytecodes/sec; ',	  ((r * 1000) // t2) printString, ' sends/sec'! !!Socket methodsFor: 'printing' stamp: 'jm 11/23/1998 11:57'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '[', self statusString, ']'.! !!Socket class methodsFor: 'utilities' stamp: 'jm 11/23/1998 17:19'!ping: hostName	"Ping the given host. Useful for checking network connectivity. The host must be running a TCP echo server."	"Socket ping: 'squeak.cs.uiuc.edu'"	| tcpPort sock serverAddr startTime echoTime |	tcpPort _ 7.  "7 = echo port, 13 = time port, 19 = character generator port"	Socket initializeNetwork.	serverAddr _ NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil ifTrue: [		^ self inform: 'Could not find an address for ', hostName].	sock _ Socket new.	sock connectTo: serverAddr port: tcpPort.	[sock waitForConnectionUntil: (Socket deadlineSecs: 10).	 sock isConnected] whileFalse: [		(self confirm: 'Continue to wait for connection to ', hostName, '?') ifFalse: [			sock destroy.			^ self]].	sock sendData: 'echo!!'.	startTime _ Time millisecondClockValue.	[sock waitForDataUntil: (Socket deadlineSecs: 15).	 sock dataAvailable] whileFalse: [		(self confirm: 'Packet sent but no echo yet; keep waiting?') ifFalse: [			sock destroy.			^ self]].	echoTime _ Time millisecondClockValue - startTime.	sock destroy.	self inform: hostName, ' responded in ', echoTime printString, ' milliseconds'.! !!SystemMonitor methodsFor: 'system parameters' stamp: 'jm 10/20/1998 11:36'!cacheVal	| icHit mcHit mcMiss total deltaMcMiss deltaMcHit deltaIcHit |	mcMiss _ vmParameters at: 15.	deltaMcMiss _ mcMiss - prevMcMiss.	prevMcMiss _ mcMiss.	mcHit _ vmParameters at: 16.	deltaMcHit _ mcHit - prevMcHit.	prevMcHit _ mcHit.	icHit _ vmParameters at: 17.	deltaIcHit _ icHit - prevIcHit.	prevIcHit _ icHit.	total _ deltaMcMiss + deltaMcHit + deltaIcHit.	total = 0 ifTrue: [total _ 1].	deltaMcMiss _ (deltaMcMiss * 100 / total asInteger).	deltaMcHit _ (deltaMcHit * 100 / total asInteger).	^Array		with: deltaMcMiss		with: deltaMcMiss + deltaMcHit! !Object removeSelector: #do:!CompiledMethod class removeSelector: #toReturnConst:!