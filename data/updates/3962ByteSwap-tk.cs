'From Squeak3.1alpha [latest update: #''Squeak3.1alpha'' of 28 February 2001 update 3961] on 30 April 2001 at 4:21:23 pm'!"Change Set:		ByteSwap-tkDate:			30 April 2001Author:			Ted KaehlerAndreas discovered that PositionableStream was not treating endianness correctly when the collection is a byte object.  The two cases are writing to a file, and writing to an internal RWBinaryOrTextStream.	ArrayedCollection>>writeOn: makes writes word objects as bigEndian (Mac-like).  	StandardFileStream>>nextWordsInto: reads and converts if the machine is littleEndian (PC or Unix like).	PositionableStream>>nextWordsInto:, used by RWBinaryOrTextStream, converted but did it incorrectly!!Fixed in this update.Here is the test case that failed:Write object file(FileStream newFileNamed:'test')	fileOutChangeSet: nil 	andObject: (Color colorNames collect:[:s| Color perform: s]) asColorArray; close.Read object file from FileStream (this does work)(FileStream readOnlyFileNamed: 'test') fileInObjectAndCode.Read object file from internal stream (fails)(RWBinaryOrTextStream with: 	((FileStream readOnlyFileNamed: 'test') contentsOfEntireFile)) reset; fileInObjectAndCode."!!PositionableStream methodsFor: 'accessing' stamp: 'tk 4/27/2001 16:37'!nextWordsInto: aBitmap 	| blt pos mainX mainY frontX frontY source |	"Fill the word based buffer from my collection.  Stored on stream as Big Endian.  Optimized for speed.  Read in BigEndian, then restoreEndianness."	(collection class isBytes) ifTrue:		["1 to: aBitmap size do: [:index | aBitmap at: index put: (self nextNumber: 4)]."		collection basicSize \\ 4 = 0 			ifTrue: [source _ collection.  					pos _ self position.					self skip: aBitmap size * aBitmap bytesPerElement "1, 2, or 4"]			ifFalse: [source _ self next: aBitmap size * aBitmap bytesPerElement.						"forced to copy it into a buffer"					pos _ 0].		mainX _ pos \\ 4.   mainY _ pos // 4.	"two Blts required if not word aligned"		frontX _ 0.  frontY _ mainY + 1.		blt _ (BitBlt current toForm: (Form new hackBits: aBitmap)) 					sourceForm: (Form new hackBits: source).		blt combinationRule: Form over.  "store"		blt sourceX: mainX; sourceY: mainY; height: aBitmap basicSize; width: 4-mainX.		blt destX: 0; destY: 0.		blt copyBits.		mainX = 0 ifFalse: [			"second piece when not word aligned"			blt sourceX: frontX; sourceY: frontY; height: aBitmap size; width: mainX.			blt destX: 4-mainX; destY: 0.			blt copyBits].		aBitmap restoreEndianness.	"May be WordArray, ColorArray, etc"		^ aBitmap ].	^ self next: aBitmap size into: aBitmap startingAt: 1.! !