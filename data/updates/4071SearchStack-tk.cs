'From Squeak3.1alpha of 28 February 2001 [latest update: #4060] on 23 May 2001 at 4:56:05 pm'!"Change Set:		SearchStack-tkDate:			23 May 2001Author:			Ted KaehlerExtended HyperCard-like search to StackMorphs.  Made Command-g work to search for next occurance.  (Use the Find... menu item to get started.)Rejoice!!  rejoice!!  I have found and fixed the place where unwanted replacement of text was happening.  Sometimes when you get implementors of X, and it tries to autoselect X, it replaces it.  In PluggableTextMorph>>update: it needed to say (ChangeText _ FindText).  We do this by calling (ParagraphEditor abandonChangeText) there."!!CardPlayer methodsFor: 'card data' stamp: 'tk 5/9/2001 20:26'!allStringsAfter: aSubmorph	| list ok instVarValue string |	"return an OrderedCollection of strings of text in my instance vars.  If aSubmorph is non-nil, begin with that object."	list _ OrderedCollection new.	ok _ aSubmorph == nil.	CardPlayer instSize + 1 to: self class instSize do: [:ind |		instVarValue _ self instVarAt: ind.		ok ifFalse: [ok _ instVarValue == aSubmorph].		"and do this one too"		ok ifTrue: [string _ nil.			instVarValue isString ifTrue: [string _ instVarValue].			instVarValue isText ifTrue: [string _ instVarValue string].			instVarValue isMorph ifTrue: [string _ instVarValue userString].			string ifNotNil: [string isString 					ifTrue: [list add: string]					ifFalse: [list addAll: string]]]].	privateMorphs ifNotNil: [		privateMorphs do: [:mm | list addAll: (mm allStringsAfter: nil)]].	^ list! !!CardPlayer methodsFor: 'card data' stamp: 'tk 5/7/2001 15:51'!url	"For now, don't know we could be on a server"	^ nil! !!Morph methodsFor: 'debug and other' stamp: 'tk 5/7/2001 15:47'!allStringsAfter: aSubmorph	"return an OrderedCollection of strings of text in my submorphs.  If aSubmorph is non-nil, begin with that container."	| list string ok |	list _ OrderedCollection new.	ok _ aSubmorph == nil.	self allMorphsDo: [:sub | 		ok ifFalse: [ok _ sub == aSubmorph].		"and do this one too"		ok ifTrue: [			(string _ sub userString) ifNotNil: [				string isString 					ifTrue: [list add: string]					ifFalse: [list addAll: string]]]].	^ list! !!BookMorph methodsFor: 'menu' stamp: 'tk 5/23/2001 16:52'!findText: keys inStrings: rawStrings	startAt: startIndex container: oldContainer pageNum: pageNum	"Call once to search a page of the book.  Return true if found and highlight the text.  oldContainer should be NIL.  	(oldContainer is only non-nil when (1) doing a 'search again' and (2) the page is in memory and (3) keys has just one element.  oldContainer is a TextMorph.)"	| good thisWord index insideOf place container start wasIn strings old |	good _ true.	start _ startIndex.	strings _ oldContainer ifNil: [rawStrings]	"normal case"		ifNotNil: [(pages at: pageNum) isInMemory 					ifFalse: [rawStrings]					ifTrue: [(pages at: pageNum) allStringsAfter: oldContainer]].	keys do: [:searchString | "each key"		good ifTrue: [thisWord _ false.			strings do: [:longString |				(index _ longString findString: searchString startingAt: start 					caseSensitive: false) > 0 ifTrue: [						thisWord not & (searchString == (keys at: 1)) ifTrue: [							insideOf _ longString. place _ index].						thisWord _ true].				start _ 1].	"only first key on first container"			good _ thisWord]].	good ifTrue: ["all are on this page"		wasIn _ (pages at: pageNum) isInMemory.		self goToPage: pageNum.		wasIn ifFalse: ["search again, on the real current text.  Know page is in."			^ self findText: keys 				inStrings: ((pages at: pageNum) allStringsAfter: nil) "recompute"					startAt: startIndex container: oldContainer 				pageNum: pageNum]].	(old _ self valueOfProperty: #searchContainer) ifNotNil: [		(old respondsTo: #editor) ifTrue: [			old editor selectFrom: 1 to: 0. 	"trying to remove the previous selection!!"			old changed]].	good ifTrue: ["have the exact string object"		(container _ oldContainer)			ifNil: [container _ self highlightText: (keys at: 1) at: place in: insideOf]			ifNotNil: [				container userString == insideOf 					ifFalse: [						container _ self highlightText: (keys at: 1) at: place 							in: insideOf]					ifTrue: [(container isKindOf: TextMorph) ifTrue: [						container editor selectFrom: place to: 								(keys at: 1) size - 1 + place.						container changed].						]].		self setProperty: #searchContainer toValue: container.		self setProperty: #searchOffset toValue: place.		self setProperty: #searchKey toValue: keys.		"override later"		ActiveHand newKeyboardFocus: container.		^ true].	^ false! !!PluggableTextMorph methodsFor: 'updating' stamp: 'tk 5/23/2001 12:26'!update: aSymbol	aSymbol ifNil: [^ self].	aSymbol == #flash ifTrue: [^ self flash].	aSymbol == getTextSelector ifTrue:			[self setText: self getText.			^ self setSelection: self getSelection].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector ~~ nil]) ifTrue:			[self handleEdit:				[ParagraphEditor abandonChangeText.	"no replacement!!"				textMorph editor setSearch: model autoSelectString;							againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [^ self promptForCancel].			^ self].	aSymbol == #appendEntry ifTrue:			[self handleEdit: [self appendEntry].			^ self refreshWorld].	aSymbol == #clearText ifTrue:			[self handleEdit: [self changeText: Text new].			^ self refreshWorld].	aSymbol == #bs ifTrue:			[self handleEdit: [self bsText].			^ self refreshWorld].	aSymbol == #codeChangedElsewhere ifTrue:			[self hasEditingConflicts: true.			^ self changed]! !!PluggableTextView methodsFor: 'updating' stamp: 'tk 5/23/2001 12:26'!update: aSymbol	"Refer to the comment in View|update:. Do nothing if the given symbol does not match any action. "	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [self promptForCancel].  ^ self].	aSymbol == #flash ifTrue: [^ controller flash].	aSymbol == getTextSelector ifTrue: [^ self updateDisplayContents].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	(aSymbol == #autoSelect and: [getSelectionSelector ~~ nil]) ifTrue:			[ParagraphEditor abandonChangeText.	"no replacement!!"			^ controller setSearch: model autoSelectString;					againOrSame: true].	aSymbol == #appendEntry ifTrue:			[^ controller doOccluded: [controller appendEntry]].	aSymbol == #clearText ifTrue:			[^ controller doOccluded:				[controller changeText: Text new]].	aSymbol == #bs ifTrue:			[^ controller doOccluded:				[controller bsText]].	aSymbol == #codeChangedElsewhere ifTrue:			[^ self hasEditingConflicts: true]! !!StackMorph methodsFor: 'menu' stamp: 'tk 5/23/2001 10:10'!findText: wants	"Turn to the next card that has all of the strings mentioned on it.  Highlight where it is found.  allText and allTextUrls have been set.  Case insensitive search.	Resuming a search.  If container's text is still in the list and secondary keys are still in the page, (1) search rest of that container.  (2) search rest of containers on that page (3) pages till end of book, (4) from page 1 to this page again."	"Later sort wants so longest key is first"	| allText good thisWord here fromHereOn startToHere oldContainer oldIndex otherKeys strings |	allText _ self valueOfProperty: #allText ifAbsent: [#()].	here _ cards identityIndexOf: self currentCard ifAbsent: [1].	fromHereOn _ here+1 to: cards size.	startToHere _ 1 to: here.		"repeat this page"	(self valueOfProperty: #searchKey ifAbsent: [#()]) = wants ifTrue: [		"does page have all the other keys?  No highlight if found!!"		otherKeys _ wants allButFirst.		strings _ allText at: here.		good _ true.		otherKeys do: [:searchString | "each key"			good ifTrue: [thisWord _ false.				strings do: [:longString |					(longString findString: searchString startingAt: 1 						caseSensitive: false) > 0 ifTrue: [							thisWord _ true]].				good _ thisWord]].		good ifTrue: ["all are on this page.  Look in rest for string again."			oldContainer _ self valueOfProperty: #searchContainer.			oldIndex _ self valueOfProperty: #searchOffset.			(self findText: (OrderedCollection with: wants first) inStrings: strings					startAt: oldIndex+1 container: oldContainer 				cardNum: here) ifTrue: [					self setProperty: #searchKey toValue: wants.					^ true]]]		ifFalse: [fromHereOn _ here to: pages size].	"do search this page"	"other pages"	fromHereOn do: [:cardNum |		(self findText: wants inStrings: (allText at: cardNum) startAt: 1 container: nil 				cardNum: cardNum) 					ifTrue: [^ true]].	startToHere do: [:cardNum |		(self findText: wants inStrings: (allText at: cardNum) startAt: 1 container: nil 				cardNum: cardNum) 					ifTrue: [^ true]].	"if fail"	self setProperty: #searchContainer toValue: nil.	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	^ false! !!StackMorph methodsFor: 'menu' stamp: 'tk 5/23/2001 16:51'!findText: keys inStrings: rawStrings	startAt: startIndex container: oldContainer cardNum: cardNum	"Call once to search a card of the stack.  Return true if found and highlight the text.  oldContainer should be NIL.  	(oldContainer is only non-nil when (1) doing a 'search again' and (2) the page is in memory and (3) keys has just one element.  oldContainer is a TextMorph.)"	| good thisWord index insideOf place container start strings old |	good _ true.	start _ startIndex.	strings _ oldContainer 			ifNil: [rawStrings]	"normal case"			ifNotNil: [self currentPage allStringsAfter: oldContainer].	keys do: [:searchString | "each key"		good ifTrue: [thisWord _ false.			strings do: [:longString |				(index _ longString findString: searchString startingAt: start 					caseSensitive: false) > 0 ifTrue: [						thisWord not & (searchString == (keys at: 1)) ifTrue: [							insideOf _ longString. place _ index].						thisWord _ true].				start _ 1].	"only first key on first container"			good _ thisWord]].	good ifTrue: ["all are on this page"		"wasIn _ (pages at: pageNum) isInMemory."		self goToCardNumber: cardNum.		"wasIn ifFalse: ['search again, on the real current text.  Know page is in.'.			^ self findText: keys 				inStrings: ((pages at: pageNum) allStringsAfter: nil)         recompute it					startAt: startIndex container: oldContainer 				pageNum: pageNum]" 			].	(old _ self valueOfProperty: #searchContainer) ifNotNil: [		(old respondsTo: #editor) ifTrue: [			old editor selectFrom: 1 to: 0. 	"trying to remove the previous selection!!"			old changed]].	good ifTrue: ["have the exact string object"		(container _ oldContainer)			ifNil: [container _ self highlightText: (keys at: 1) at: place in: insideOf]			ifNotNil: [				container userString == insideOf 					ifFalse: [						container _ self highlightText: (keys at: 1) at: place 							in: insideOf]					ifTrue: [(container isKindOf: TextMorph) ifTrue: [						container editor selectFrom: place to: 								(keys at: 1) size - 1 + place.						container changed].						]].		self setProperty: #searchContainer toValue: container.		self setProperty: #searchOffset toValue: place.		self setProperty: #searchKey toValue: keys.		"override later"		ActiveHand newKeyboardFocus: container.		^ true].	^ false! !!StackMorph methodsFor: 'menu' stamp: 'tk 5/9/2001 21:44'!getAllText	"Collect the text for each card.  Just point at strings so don't have to recopy them.  (Parallel array of urls for ID of cards.  Remote cards not working yet.)	allText = Array (cards size) of arrays (fields in it) of strings of text.	allTextUrls = Array (cards size) of urls or card numbers."	| oldUrls oldStringLists allText allTextUrls aUrl which |	self writeSingletonData.	oldUrls _ self valueOfProperty: #allTextUrls ifAbsent: [#()].	oldStringLists _ self valueOfProperty: #allText ifAbsent: [#()].	allText _ cards collect: [:pg | OrderedCollection new].	allTextUrls _ Array new: cards size.	cards doWithIndex: [:aCard :ind | aUrl _ aCard url.  aCard isInMemory 		ifTrue: [(allText at: ind) addAll: (aCard allStringsAfter: nil).			aUrl ifNil: [aUrl _ ind].			allTextUrls at: ind put: aUrl]		ifFalse: ["Order of cards on server may be different.  (later keep up to date?)"			"*** bug in this algorithm if delete a page?"			which _ oldUrls indexOf: aUrl.			allTextUrls at: ind put: aUrl.			which = 0 ifFalse: [allText at: ind put: (oldStringLists at: which)]]].	self setProperty: #allText toValue: allText.	self setProperty: #allTextUrls toValue: allTextUrls.	^ allText! !!StackMorph methodsFor: 'menu' stamp: 'tk 5/9/2001 21:46'!writeSingletonData	| sieve |	"Backgrounds that have just one card, may never get their data written into a CardPlayer. Make sure we do it."	sieve _ IdentityDictionary new.	pages do: [:pp | sieve at: pp put: 0].	cards do: [:cc | sieve at: cc costume put: (sieve at: cc costume) + 1].	sieve associationsDo: [:ass | 		ass value = 1 ifTrue: [			(ass key) player commitCardPlayerDataFrom: (ass key)]].			"If currently showing card, may be some trouble..."! !!TextMorphEditor methodsFor: 'accessing' stamp: 'tk 5/23/2001 16:41'!setSearch: aString	| bk |	"Set the FindText and ChangeText to seek aString; except if already seeking aString, leave ChangeText alone so again will repeat last replacement."	(bk _ morph ownerThatIsA: BookMorph) ifNotNil: [		bk setProperty: #searchKey 			toValue: (aString findTokens: Character separators)].	FindText string = aString		ifFalse: [FindText _ ChangeText _ aString asText]! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'tk 5/23/2001 12:15'!againOrSame: bool	| bk keys |	(bk _ morph ownerThatIsA: BookMorph) ifNotNil: [		(keys _ bk valueOfProperty: #searchKey ifAbsent: [nil]) ifNotNil: [			keys size > 0 ifTrue: [				bk findText: keys.				^ (morph respondsTo: #editView) ifTrue: [					morph editView selectionInterval: self selectionInterval].				]]].	super againOrSame: bool.	(morph respondsTo: #editView) ifTrue: [		morph editView selectionInterval: self selectionInterval].! !StackMorph removeSelector: #findText:inStrings:startAt:container:pageNum:!