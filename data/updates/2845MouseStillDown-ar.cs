'From Squeak2.9alpha of 13 June 2000 [latest update: #2892] on 25 October 2000 at 6:39 pm'!"Change Set:		MouseStillDown-arDate:			25 October 2000Author:			Andreas RaabThe change set completely separates #mouseMove from #mouseStillDown by extending the event handler and fixing (hopefully all) affected places. #mouseStillDown is sent after a certain threshold when #mouseDown happened."!Object subclass: #EventHandler	instanceVariableNames: 'mouseDownRecipient mouseDownSelector mouseStillDownRecipient mouseStillDownSelector mouseUpRecipient mouseUpSelector mouseEnterRecipient mouseEnterSelector mouseLeaveRecipient mouseLeaveSelector mouseEnterDraggingRecipient mouseEnterDraggingSelector mouseLeaveDraggingRecipient mouseLeaveDraggingSelector keyStrokeRecipient keyStrokeSelector valueParameter startDragRecipient startDragSelector doubleClickSelector doubleClickRecipient clickSelector clickRecipient mouseMoveRecipient mouseMoveSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!!EventHandler methodsFor: 'initialization' stamp: 'ar 10/25/2000 17:32'!forgetDispatchesTo: aSelector	"aSelector is no longer implemented by my corresponding Player, so don't call it any more"	mouseDownSelector == aSelector		ifTrue: [mouseDownRecipient _ mouseDownSelector _ nil].	mouseMoveSelector == aSelector		ifTrue: [mouseMoveRecipient _ mouseMoveSelector _ nil].	mouseStillDownSelector == aSelector		ifTrue: [mouseStillDownRecipient _ mouseStillDownSelector _ nil].	mouseUpSelector == aSelector		ifTrue: [mouseUpRecipient _ mouseUpSelector _ nil].	mouseEnterSelector == aSelector		ifTrue: [mouseEnterRecipient _ mouseEnterSelector _ nil].	mouseLeaveSelector == aSelector		ifTrue: [mouseLeaveRecipient _ mouseLeaveSelector _ nil].	mouseEnterDraggingSelector == aSelector		ifTrue: [mouseEnterDraggingRecipient _ mouseEnterDraggingSelector _ nil].	mouseLeaveDraggingSelector == aSelector		ifTrue: [mouseLeaveDraggingRecipient _ mouseLeaveDraggingSelector _ nil].	clickSelector == aSelector		ifTrue: [clickRecipient _ clickSelector _ nil].	doubleClickSelector == aSelector		ifTrue: [doubleClickRecipient _ doubleClickSelector _ nil].	keyStrokeSelector == aSelector		ifTrue: [keyStrokeRecipient _ keyStrokeSelector _ nil].! !!EventHandler methodsFor: 'initialization' stamp: 'ar 10/25/2000 17:30'!on: eventName send: selector to: recipient	eventName = #mouseDown ifTrue:		[mouseDownRecipient _ recipient.  mouseDownSelector _ selector. ^ self].	eventName = #mouseMove ifTrue:		[mouseMoveRecipient _ recipient.  mouseMoveSelector _ selector. ^ self].	eventName = #mouseStillDown ifTrue:		[mouseStillDownRecipient _ recipient.  mouseStillDownSelector _ selector. ^ self].	eventName = #mouseUp ifTrue:		[mouseUpRecipient _ recipient.  mouseUpSelector _ selector. ^ self].	eventName = #mouseEnter ifTrue:		[mouseEnterRecipient _ recipient.  mouseEnterSelector _ selector. ^ self].	eventName = #mouseLeave ifTrue:		[mouseLeaveRecipient _ recipient.  mouseLeaveSelector _ selector. ^ self].	eventName = #mouseEnterDragging ifTrue:		[mouseEnterDraggingRecipient _ recipient.  mouseEnterDraggingSelector _ selector. ^ self].	eventName = #mouseLeaveDragging ifTrue:		[mouseLeaveDraggingRecipient _ recipient.  mouseLeaveDraggingSelector _ selector. ^ self].	eventName = #click ifTrue:		[clickRecipient _ recipient. clickSelector _ selector. ^ self].	eventName = #doubleClick ifTrue:		[doubleClickRecipient _ recipient. doubleClickSelector _ selector. ^ self].	eventName = #startDrag ifTrue:		[startDragRecipient _ recipient. startDragSelector _ selector. ^ self].	eventName = #keyStroke ifTrue:		[keyStrokeRecipient _ recipient.  keyStrokeSelector _ selector. ^ self].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!EventHandler methodsFor: 'testing' stamp: 'ar 10/25/2000 17:33'!handlesMouseMove: evt	^mouseMoveRecipient notNil and:[mouseMoveSelector notNil]! !!EventHandler methodsFor: 'events' stamp: 'ar 10/25/2000 17:32'!mouseMove: event fromMorph: sourceMorph	^ self send: mouseMoveSelector to: mouseMoveRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'access' stamp: 'ar 10/25/2000 17:33'!allRecipients	"Answer a list, without duplication, of all the objects serving as recipients to any of the events I handle.  Intended for debugging/documentation use only"	| aList |	aList _ OrderedCollection with: mouseDownRecipient with: mouseStillDownRecipient with: mouseUpRecipient with: mouseEnterRecipient with: mouseLeaveRecipient.	aList addAll: (OrderedCollection with:  mouseEnterDraggingRecipient with: mouseLeaveDraggingRecipient with: doubleClickRecipient with: keyStrokeRecipient).	aList add: mouseMoveRecipient.	^ (aList copyWithout: nil) asSet asArray! !!EventHandler methodsFor: 'access' stamp: 'ar 10/25/2000 17:34'!firstMouseSelector	"Answer the selector corresponding to the first mouse-handling selector fielded.  Created in support of providing balloon-help for halo handles, triggered by the selector handled"	mouseDownSelector ifNotNil: [^ mouseDownSelector].	mouseMoveSelector ifNotNil:[^mouseMoveSelector].	mouseStillDownSelector ifNotNil: [^ mouseStillDownSelector].	mouseUpSelector ifNotNil: [^ mouseUpSelector].	mouseEnterSelector ifNotNil: [^ mouseEnterSelector].	mouseLeaveSelector ifNotNil: [^ mouseLeaveSelector].	mouseEnterDraggingSelector ifNotNil: [^ mouseEnterDraggingSelector].	mouseLeaveDraggingSelector ifNotNil: [^ mouseLeaveDraggingSelector].	doubleClickSelector ifNotNil: [^ doubleClickSelector].	^ nil! !!EventHandler methodsFor: 'access' stamp: 'ar 10/25/2000 17:31'!messageList	"Return a list of 'Class selector' for each message I can send.  tk9/13/97"	| list |	list _ SortedCollection new.	mouseDownRecipient ifNotNil:		[list add: (mouseDownRecipient class classThatUnderstands:					mouseDownSelector) name , ' ', mouseDownSelector].	mouseMoveRecipient ifNotNil:		[list add: (mouseMoveRecipient class classThatUnderstands:					mouseMoveSelector) name , ' ', mouseMoveSelector].	mouseStillDownRecipient ifNotNil:		[list add: (mouseStillDownRecipient class classThatUnderstands:					mouseStillDownSelector) name , ' ', mouseStillDownSelector].	mouseUpRecipient ifNotNil:		[list add: (mouseUpRecipient class classThatUnderstands:					mouseUpSelector) name , ' ', mouseUpSelector].	mouseEnterRecipient ifNotNil:		[list add: (mouseEnterRecipient class classThatUnderstands:					mouseEnterSelector) name , ' ', mouseEnterSelector].	mouseLeaveRecipient ifNotNil:		[list add: (mouseLeaveRecipient class classThatUnderstands:					mouseLeaveSelector) name , ' ', mouseLeaveSelector].	mouseEnterDraggingRecipient ifNotNil:		[list add: (mouseEnterDraggingRecipient class classThatUnderstands:					mouseEnterDraggingSelector) name , ' ', mouseEnterDraggingSelector].	mouseLeaveDraggingRecipient ifNotNil:		[list add: (mouseLeaveDraggingRecipient class classThatUnderstands:					mouseLeaveDraggingSelector) name , ' ', mouseLeaveDraggingSelector].	doubleClickRecipient ifNotNil:		[list add: (doubleClickRecipient class classThatUnderstands:					doubleClickSelector) name , ' ', doubleClickSelector].	keyStrokeRecipient ifNotNil:		[list add: (keyStrokeRecipient class classThatUnderstands:					keyStrokeSelector) name , ' ', keyStrokeSelector].	^ list! !!EventHandler methodsFor: 'access' stamp: 'ar 10/25/2000 18:27'!mouseStillDownRecipient	^mouseStillDownRecipient! !!EventHandler methodsFor: 'access' stamp: 'ar 10/25/2000 18:27'!mouseStillDownSelector	^mouseStillDownSelector! !!EventHandler methodsFor: 'object fileIn' stamp: 'ar 10/25/2000 18:34'!convertmmmmmmmmmmmmmmkkvssddcc0: varDict mmmmmmmmmmmmmmmmkkvssddcc0: smartRefStrm	"These variables are automatically stored into the new instance #('mouseDownRecipient' 'mouseDownSelector' 'mouseStillDownRecipient' 'mouseStillDownSelector' 'mouseUpRecipient' 'mouseUpSelector' 'mouseEnterRecipient' 'mouseEnterSelector' 'mouseLeaveRecipient' 'mouseLeaveSelector' 'mouseEnterDraggingRecipient' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingRecipient' 'mouseLeaveDraggingSelector' 'keyStrokeRecipient' 'keyStrokeSelector' 'valueParameter' 'startDragRecipient' 'startDragSelector' 'doubleClickSelector' 'doubleClickRecipient' 'clickSelector' 'clickRecipient').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('mouseMoveRecipient' 'mouseMoveSelector')  If a non-nil value is needed, please assign it."! !!Morph methodsFor: 'event handling' stamp: 'ar 10/25/2000 18:04'!mouseMove: evt	"Handle a mouse move event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseMove: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'ar 10/25/2000 18:02'!mouseStillDownThreshold	"Return the number of milliseconds after which mouseStillDown: should be sent"	^200! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/25/2000 18:04'!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingBalloonFor: self.	anEvent hand removePendingHaloFor: self.	anEvent wasHandled: true.	anEvent controlKeyPressed ifTrue:[^self invokeMetaMenu: anEvent].	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent blueButtonChanged ifTrue:[^self blueButtonDown: anEvent].	self mouseDown: anEvent.	anEvent hand removeHaloFromClick: anEvent on: self.	(self handlesMouseStillDown: anEvent) ifTrue:[		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue + self mouseStillDownThreshold			arguments: {anEvent copy resetHandlerFields}			stepTime: 1].! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/25/2000 18:04'!handleMouseMove: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	"Rules say that by default a morph gets #mouseMove iff		* the hand is not dragging anything,			+ and some button is down,			+ and the receiver is the current mouse focus."	(anEvent hand hasSubmorphs) ifTrue:[^self].	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.	(self handlesMouseStillDown: anEvent) ifTrue:[		"Step at the new location"		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue			arguments: {anEvent copy resetHandlerFields}			stepTime: 1].! !!AlignmentMorph methodsFor: 'initialization' stamp: 'ar 10/25/2000 17:53'!addUpDownArrowsFor: aMorph	"Add a column of up and down arrows that serve to send upArrowHit and downArrowHit to aMorph when they're pressed/held down"	| holder downArrow upArrow |	holder _ Morph new extent: 16 @ 16; beTransparent.	downArrow _ ImageMorph new image: (ScriptingSystem formAtKey: 'DownArrow').	upArrow _ ImageMorph new image: (ScriptingSystem formAtKey: 'UpArrow').	upArrow position: holder bounds topLeft + (2@2).	downArrow align: downArrow bottomLeft				with: holder topLeft + (0 @ TileMorph defaultH) + (2@-2).	holder addMorph: upArrow.	holder addMorph: downArrow.	self addMorphBack: holder.	upArrow on: #mouseDown send: #upArrowHit to: aMorph.	upArrow on: #mouseStillDown send: #upArrowHit to: aMorph.	downArrow on: #mouseDown send: #downArrowHit to: aMorph.	downArrow on: #mouseStillDown send: #downArrowHit to: aMorph.! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/25/2000 17:46'!rebuild	| history r1 |	changeCounter _ ProjectHistory changeCounter.	history _ ProjectHistory currentHistory mostRecentCopy.	self removeAllMorphs.	r1 _ self addARow: {		self inAColumn: {			StringMorph new contents: 'Jump...'; lock.		}.	}.	r1 on: #mouseUp send: #jumpToProject to: self.	history do: [ :each |		(			self addARow: {				(self inAColumn: {					StretchyImageMorph new form: each second; minWidth: 35; minHeight: 35; lock				}) vResizing: #spaceFill.				self inAColumn: {					StringMorph new contents: each first; lock.					"StringMorph new contents: each third; lock."				}.			}		)			color: Color paleYellow;			borderWidth: 1;			borderColor: #raised;			vResizing: #spaceFill;			on: #mouseUp send: #mouseUp:in: to: self;			on: #mouseDown send: #mouseDown:in: to: self;			on: #mouseMove send: #mouseMove:in: to: self;			on: #mouseLeave send: #mouseLeave:in: to: self;			setProperty: #projectParametersTuple toValue: each;			setBalloonText: (each third isEmptyOrNil ifTrue: ['not saved'] ifFalse: [each third])	]."---	newTuple _ {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.---"! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'ar 10/25/2000 17:47'!addHandlesIn: frame	| handle |	handle := PolygonMorph		vertices: (Array with: 0@0 with: 8@0 with: 4@8)		color: Color orange borderWidth: 1 borderColor: Color black.	handle addMorph: ((RectangleMorph			newBounds: ((self handleOffset: handle)-(2@0) extent: 1@(graphArea height-2))			color: Color orange) borderWidth: 0).	limitHandles _ Array with: handle with: handle fullCopy with: handle fullCopy.	1 to: limitHandles size do:		[:i | handle _ limitHandles at: i.		handle on: #mouseDown				send: #limitHandleMoveEvent:from:index:				to: self withValue: i.		handle on: #mouseMove				send: #limitHandleMoveEvent:from:index:				to: self withValue: i.		self addMorph: handle.		handle position: ((self xFromMs: (envelope points at: (limits at: i)) x) @ (graphArea top)) - (self handleOffset: handle)]! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/25/2000 17:48'!addDirectionHandles	| centerHandle d w directionShaft patch patchColor crossHairColor |	self showingDirectionHandles ifFalse: [^ self].	directionArrowAnchor _ target referencePositionInWorld rounded.	patch _ target imageFormForRectangle: (Rectangle center: directionArrowAnchor extent: 3@3).	patchColor _ patch colorAt: 1@1.	(directionShaft _ LineMorph newSticky makeForwardArrow)		borderWidth: 2; borderColor: (Color green orColorUnlike: patchColor).	self positionDirectionShaft: directionShaft.	self addMorphFront: directionShaft.	directionShaft setCenteredBalloonText: 'Set forward direction';		on: #mouseDown send: #doDirection:with: to: self;		on: #mouseMove send: #trackDirectionArrow:with: to: self;		on: #mouseUp send: #setDirection:with: to: self.	d _ 15.  "diameter"  w _ 3.  "borderWidth"	crossHairColor _ Color red orColorUnlike: patchColor.	(centerHandle _ EllipseMorph newBounds: (0@0 extent: d@d) color: Color transparent)			borderWidth: w; borderColor: (Color blue orColorUnlike: patchColor);			addMorph: (LineMorph from: (d//2)@w to: (d//2)@(d-w-1) color: crossHairColor width: 1);			addMorph: (LineMorph from: w@(d//2) to: (d-w-1)@(d//2) color: crossHairColor width: 1);			align: centerHandle bounds center with: directionArrowAnchor.	self addMorph: centerHandle.	centerHandle setCenteredBalloonText: 'Set rotation center';			on: #mouseDown send: #prepareToTrackCenterOfRotation:with: to: self;			on: #mouseMove send: #trackCenterOfRotation:with: to: self;			on: #mouseUp send: #setCenterOfRotation:with: to: self! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/25/2000 17:49'!addSimpleHandlesTo: aHaloMorph box: aBox	| aHandle |	simpleMode _ true.	target isWorldMorph ifTrue: [^ self addSimpleHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"		self bounds: target renderedMorph worldBoundsForHalo.  "update my size"		self addHandleAt: (((aBox topLeft + aBox leftCenter) // 2) + self simpleFudgeOffset) color: Color paleBuff icon: 'Halo-MoreHandles'		on: #mouseDown send: #addFullHandles to: self.	aHandle _ self addGraphicalHandle: #Rotate at: aBox bottomLeft on: #mouseDown send: #startRot:with: to: self.	aHandle on: #mouseMove send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(self addGraphicalHandle: #Scale at: aBox bottomRight  on: #mouseDown send: #startScale:with: to: self)				on: #mouseMove send: #doScale:with: to: self]		ifFalse: [(self addGraphicalHandle: #Scale at: aBox bottomRight on: #mouseDown send: #startGrow:with: to: self)				on: #mouseMove send: #doGrow:with: to: self].	(innerTarget isMemberOf: SketchMorph) ifTrue:  "isMemberOf: used advisedly here"		[self addSimpleSketchMorphHandlesInBox: aBox].	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'handles' stamp: 'ar 10/25/2000 17:48'!addCollapseHandle: handleSpec	"we're hacking here - using mostly dismiss' infrastructure"	| dismissHandle |	dismissHandle _ self addHandle: handleSpec		on: #mouseDown send: #mouseDownInCollapseHandle:with: to: self.	dismissHandle on: #mouseUp send: #maybeCollapse:with: to: self.	dismissHandle on: #mouseDown send: #setDismissColor:with: to: self.	dismissHandle on: #mouseMove send: #setDismissColor:with: to: self.! !!HaloMorph methodsFor: 'handles' stamp: 'ar 10/25/2000 17:48'!addDismissHandle: handleSpec	| dismissHandle |	dismissHandle _ self addHandle: handleSpec		on: #mouseDown send: #mouseDownInDimissHandle:with: to: self.	dismissHandle on: #mouseUp send: #maybeDismiss:with: to: self.	dismissHandle on: #mouseDown send: #setDismissColor:with: to: self.	dismissHandle on: #mouseMove send: #setDismissColor:with: to: self.! !!HaloMorph methodsFor: 'handles' stamp: 'ar 10/25/2000 17:48'!addDragHandle: haloSpec	(self addHandle: haloSpec on: #mouseDown send: #startDrag:with: to: self)		on: #mouseMove send: #doDrag:with: to: self! !!HaloMorph methodsFor: 'handles' stamp: 'ar 10/25/2000 17:49'!addGrowHandle: haloSpec	target isFlexMorph ifFalse: 		[(self addHandle: haloSpec				on: #mouseDown send: #startGrow:with: to: self)				on: #mouseMove send: #doGrow:with: to: self].	"This or addScaleHandle:, but not both, will prevail at any one time"! !!HaloMorph methodsFor: 'handles' stamp: 'ar 10/25/2000 17:49'!addRotateHandle: haloSpec	(self addHandle: haloSpec on: #mouseDown send: #startRot:with: to: self)		on: #mouseMove send: #doRot:with: to: self! !!HaloMorph methodsFor: 'handles' stamp: 'ar 10/25/2000 17:49'!addScaleHandle: haloSpec	target isFlexMorph ifTrue: 		[(self addHandle: haloSpec				on: #mouseDown send: #startScale:with: to: self)				on: #mouseMove send: #doScale:with: to: self].	"This or addGrowHandle:, but not both, will prevail at any one time"! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 10/25/2000 17:49'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: self referencePosition color: Color lightGray icon: nil on: #mouseMove send: #changeRotationCenter:with: to: self! !!PaintBoxColorPicker methodsFor: 'event handling' stamp: 'ar 10/25/2000 17:49'!initMouseHandlers	self on: #mouseDown send: #startColorSelection: to: self.	self on: #mouseMove send: #selectColor: to: self.	self on: #mouseUp send: #endColorSelection: to: self.	self on: #mouseLeave send: #delete to: self.! !!PaintBoxMorph methodsFor: 'recent colors' stamp: 'ar 10/25/2000 17:50'!fixUpRecentColors	| inner outer border box form newImage canvas morph |	self fixUpColorPicker.	recentColors _ WriteStream on: Array new.	form _ image.	newImage _ Form extent: form extent + (0@41) depth: form depth.	form displayOn: newImage.	newImage copy: ((0@(form height-10)) extent: form width @ (newImage height - form height + 10)) 		from: 0 @ (form height - (newImage height - form height + 10))		in: form rule: Form over.	canvas _ newImage getCanvas.	canvas line: 12@(form height-10) to: 92@(form height-10) width: 1 color: Color black.	canvas _ canvas copyOffset: 12@(form height-9).	inner _ (Color r: 0.677 g: 0.71 b: 0.968).	outer _ inner darker darker.	border _  (Color r: 0.194 g: 0.258 b: 0.194).	0 to: 1 do:[:y|		0 to: 3 do:[:x|			box _ (x*20) @ (y*20) extent: 20@20.			morph _ BorderedMorph new bounds: ((box insetBy: 1) translateBy: canvas origin + bounds origin).			morph borderWidth: 1; borderColor: border.			morph color: Color white.			morph on: #mouseDown send: #mouseDownRecent:with: to: self.			morph on: #mouseMove send: #mouseStillDownRecent:with: to: self.			morph on: #mouseUp send: #mouseUpRecent:with: to: self.			self addMorphFront: morph.			recentColors nextPut: morph.			canvas fillRectangle: box color: Color white.			canvas frameRectangle: (box insetBy: 1) color: border.			canvas frameRectangle: (box) color: inner.			box _ box insetBy: 1.			canvas line: box topRight to: box bottomRight width: 1 color: outer.			canvas line: box bottomLeft to: box bottomRight width: 1 color: outer.	]].	recentColors _ recentColors contents.	self image: newImage.	self toggleStamps.	self toggleStamps.! !!PolygonMorph methodsFor: 'editing' stamp: 'ar 10/25/2000 17:50'!addHandles	| handle newVert tri |	self removeHandles.	handles _ OrderedCollection new.	tri _ Array with: 0@-4 with: 4@3 with: -3@3.	vertices withIndexDo:		[:vertPt :vertIndex |		handle _ EllipseMorph newBounds: (Rectangle center: vertPt extent: 8@8)				color: Color yellow.		handle on: #mouseMove send: #dragVertex:fromHandle:vertIndex:				to: self withValue: vertIndex.		handle on: #mouseUp send: #dropVertex:fromHandle:vertIndex:				to: self withValue: vertIndex.		self addMorph: handle.		handles addLast: handle.		(closed or: [vertIndex < vertices size]) ifTrue:			[newVert _ PolygonMorph					vertices: (tri collect: [:p | p + (vertPt + (vertices atWrap: vertIndex+1) // 2)])					color: Color green borderWidth: 1 borderColor: Color black.			newVert on: #mouseDown send: #newVertex:fromHandle:afterVert:					to: self withValue: vertIndex.			self addMorph: newVert.			handles addLast: newVert]].	smoothCurve ifTrue: [self updateHandles; layoutChanged].	self changed! !!ProjectViewMorph methodsFor: 'events' stamp: 'ar 10/25/2000 17:37'!handlesMouseStillDown: evt	^true! !!ScriptInstantiation methodsFor: 'status control' stamp: 'ar 10/25/2000 18:26'!status: newStatus	| stati actualMorph |	actualMorph _ player costume renderedMorph.	stati _ ScriptingSystem standardEventStati.	(stati includes: status) ifTrue:[		actualMorph on: status send: nil to: nil.  			"remove old link in event handler"		status == #mouseStillDown ifTrue:[actualMorph on: #mouseDown send: nil to: nil]].	(stati includes: newStatus) ifTrue:[		actualMorph on: newStatus send: selector to: player.  "establish new link in evt handler"		newStatus == #mouseStillDown ifTrue:[actualMorph on: #mouseDown send: selector to: player]].	status _ newStatus.	self flag: #arNote.	self flag: #workaround. "Code below was in #chooseTriggerFrom: which did not reflect status changes from other places (e.g., the stepping/pause buttons). It is not clear why this is necessary though - theoretically, any morph should step when it has a player but alas!! something is broken and I have no idea why and where."	status == #ticking ifTrue: [player costume arrangeToStartStepping].! !!SimpleButtonMorph methodsFor: 'events' stamp: 'ar 10/25/2000 18:15'!handlesMouseStillDown: evt	^actWhen == #whilePressed! !!SimpleButtonMorph methodsFor: 'events' stamp: 'ar 10/25/2000 18:10'!mouseDown: evt	| now dt |	now _ Time millisecondClockValue.	oldColor _ color. 	actWhen == #buttonDown		ifTrue: [self doButtonAction]		ifFalse: [	self updateVisualState: evt; refreshWorld].	dt _ Time millisecondClockValue - now max: 0.  "Time it took to do"	dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait].	self mouseStillDown: evt.! !!SimpleButtonMorph methodsFor: 'events' stamp: 'ar 10/25/2000 18:10'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	self updateVisualState: evt.! !!SimpleButtonMorph methodsFor: 'events' stamp: 'ar 10/25/2000 18:15'!mouseStillDown: evt	actWhen == #whilePressed ifFalse:[^self].	(self containsPoint: evt cursorPoint) ifTrue:[self doButtonAction].! !!SimpleButtonMorph methodsFor: 'events' stamp: 'ar 10/25/2000 18:12'!mouseUp: evt	oldColor ifNotNil:		["if oldColor nil, it signals that mouse had not gone DOWN		inside me, e.g. because of a cmd-drag; in this case we want		to avoid triggering the action!!"		self color: oldColor.		oldColor _ nil.		(actWhen == #buttonUp and: [self containsPoint: evt cursorPoint])			ifTrue: [self doButtonAction]].! !!SimpleButtonDelayedMenuMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/25/2000 18:08'!mouseStillDown: evt	(mouseDownTime isNil or: [(Time millisecondClockValue - mouseDownTime) abs < 1000]) ifTrue: [		^super mouseStillDown: evt	].	didMenu ifNotNil: [^super mouseStillDown: evt].	self color: oldColor.		"in case menu never returns"	didMenu _ target showMenuFor: actionSelector event: evt.! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'ar 10/25/2000 17:50'!initialize	super initialize.	self on: #mouseMove send: #mouseStillDown:onItem: to: self! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/25/2000 17:51'!installEventHandlerOn: morphList	| handler |	handler _ EventHandler new.	handler on: #mouseDown send: #mouseDown:onItem: to: self.	self dragEnabled		ifTrue: [handler				on: #mouseMove				send: #mouseStillDown:onItem:				to: self].	self dropEnabled		ifTrue: 			[handler				on: #mouseEnterDragging				send: #mouseEnterDragging:onItem:				to: self.			handler				on: #mouseLeaveDragging				send: #mouseLeaveDragging:onItem:				to: self].	morphList do: [:m | m eventHandler: handler].! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'ar 10/25/2000 17:51'!addRotationScaleHandles	"Rotation and scaling handles"	rotationButton _ SketchMorph withForm: (palette rotationTabForm).	rotationButton position: bounds topCenter - (6@0).	rotationButton on: #mouseDown send: #rotateScalePrep: to: self.	rotationButton on: #mouseMove send: #rotateBy: to: self.	rotationButton on: #mouseUp send: #rotateDone: to: self.	rotationButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	rotationButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: rotationButton.	rotationButton setBalloonText: 'Drag me sideways to\rotate yourpicture.' withCRs.	scaleButton _ SketchMorph withForm: (palette scaleTabForm).	scaleButton position: bounds rightCenter - ((scaleButton width)@6).	scaleButton on: #mouseDown send: #rotateScalePrep: to: self.	scaleButton on: #mouseMove send: #scaleBy: to: self.	scaleButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	scaleButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: scaleButton.	scaleButton setBalloonText: 'Drag me up and down to change\the sizeof your picture.' withCRs."REMOVED:	fwdButton _ PolygonMorph new.	pt _ bounds topCenter.	fwdButton borderWidth: 2; makeOpen; makeBackArrow; borderColor:(Color r: 0 g: 0.8 b: 0).	fwdButton removeHandles; setVertices: (Array with: pt+(0@7) with:pt+(0@22)).	fwdButton on: #mouseMove send: #forward:direction: to: self.	fwdButton on: #mouseEnter send: #mouseLeave: to: self.		fwdButton on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdButton toValue: fwdButton.	self addMorph: fwdButton.	fwdButton setBalloonText: 'Drag me around to point\in the directionI go forward.' withCRs.	toggle _ EllipseMorph		newBounds: (Rectangle center: fwdButton vertices last +(-4@4) extent: 8@8)		color: Color gray.	toggle on: #mouseUp send: #toggleDirType:in: to: self.	toggle on: #mouseEnter send: #mouseLeave: to: self.	toggle on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdToggle toValue: toggle.	fwdButton addMorph: toggle.	toggle setBalloonText: 'When your object turns,\how should itspicture change?\It can rotate, face left or right,\face up or down, or notchange.' withCRs.	"	self setProperty: #rotationStyle toValue: hostView rotationStyle."	self forward: hostView setupAngle direction: fwdButton.	"	"Set to its current value"! !!Slider methodsFor: 'initialize' stamp: 'ar 10/25/2000 17:51'!initializeSlider	slider := RectangleMorph newBounds: self totalSliderArea color: self sliderColor.	sliderShadow := RectangleMorph newBounds: self totalSliderArea						color: self pagingArea color.	slider on: #mouseMove send: #scrollAbsolute: to: self.	slider on: #mouseDown send: #mouseDownInSlider: to: self.	slider on: #mouseUp send: #mouseUpInSlider: to: self.	slider setBorderWidth: 1 borderColor: #raised.	sliderShadow setBorderWidth: 1 borderColor: #inset.	"(the shadow must have the pagingArea as its owner to highlight properly)"	self pagingArea addMorph: sliderShadow.	sliderShadow hide.	self addMorph: slider.	self computeSlider.! !!StarMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/25/2000 17:52'!addHandles	| handle strokeOrigin p |	handles ifNotNil: [handles do: [:hh | hh delete]].	strokeOrigin _ 0@0.	vertices do: [:each | strokeOrigin _ strokeOrigin + each].	strokeOrigin _ strokeOrigin // vertices size.	"average is the center"	handles _ Array new: 2.		handle _ EllipseMorph newBounds: (Rectangle center: strokeOrigin extent: 8@8)				color: Color yellow.		handle on: #mouseMove send: #dragVertex:fromHandle:vertIndex:				to: self withValue: #center.		self addMorph: handle.	handles at: 1 put: handle.	"The center one!!!!"		p _ vertices at: 2.	"an outside one"		handle _ EllipseMorph newBounds: (Rectangle center: p + (borderWidth//2) extent: 8@8)				color: Color yellow.		handle on: #mouseMove send: #dragVertex:fromHandle:vertIndex:				to: self withValue: #outside.		self addMorph: handle.	handles at: 2 put: handle.	"The outside one!!!!"	self changed! !!StringButtonMorph methodsFor: 'events' stamp: 'ar 10/25/2000 18:14'!handlesMouseStillDown: evt	^actWhen == #whilePressed! !!StringButtonMorph methodsFor: 'events' stamp: 'ar 10/25/2000 18:15'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue:[self color: (oldColor alphaMixed: 1/2 with: Color white)]		ifFalse: [self color: oldColor].! !!StringButtonMorph methodsFor: 'events' stamp: 'ar 10/25/2000 18:15'!mouseStillDown: evt	actWhen == #whilePressed ifFalse: [^ self].	(self containsPoint: evt cursorPoint) ifTrue:[self doButtonAction].! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 18:18'!handlesMouseStillDown: evt	^actWhen == #whilePressed! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 18:16'!mouseDown: evt	| now dt |	self state: #pressed.	actWhen == #buttonDown		ifTrue:			[self doButtonAction]		ifFalse:			[now _ Time millisecondClockValue.			super mouseDown: evt.			"Allow on:send:to: to set the response to events other than actWhen"			dt _ Time millisecondClockValue - now max: 0.  "Time it took to do"			dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait]].	self mouseStillDown: evt.! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 18:18'!mouseMove: evt	(self containsPoint: evt cursorPoint)		ifTrue: [self state: #pressed.				super mouseMove: evt]				"Allow on:send:to: to set the response to events other than actWhen"		ifFalse: [self state: #off].! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 18:17'!mouseStillDown: evt	actWhen == #whilePressed ifFalse:[^self].	(self containsPoint: evt cursorPoint) ifTrue:[self doButtonAction].! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 18:17'!mouseUp: evt	"Allow on:send:to: to set the response to events other than actWhen"	actWhen == #buttonUp ifFalse: [^super mouseUp: evt].	(self containsPoint: evt cursorPoint) ifTrue: [		self state: #on.		self doButtonAction: evt	] ifFalse: [		self state: #off.		target ifNotNil: [target mouseUpBalk: evt]	].	"Allow owner to keep it selected for radio buttons"! !!TileMorph methodsFor: 'mouse handling' stamp: 'ar 10/25/2000 18:38'!mouseDown: evt	"The mouse went down on the receiver; take appropriate action"	| aPoint |	"Note: evt is in local coordinates, so bounds is better than boundsInWorld"	aPoint _ evt cursorPoint.	nArrowTicks _ 0.	upArrow ifNotNil:		[(upArrow bounds containsPoint: aPoint) ifTrue: [^ self mouseStillDown: evt].		(downArrow bounds containsPoint: aPoint) ifTrue: [^ self mouseStillDown: evt].		"next line maybe outside this block & below it"		operatorOrExpression ifNotNil: [^ self presentOperatorAlternatives: evt]].		suffixArrow ifNotNil:		[(suffixArrow bounds containsPoint: aPoint)			 ifTrue: [self showSuffixChoices.  ^ self]].	retractArrow ifNotNil:		[(retractArrow bounds containsPoint: aPoint)			 ifTrue: [self deleteLastTwoTiles.  ^ self]].	^ super mouseDown: evt! !!NumericReadoutTile methodsFor: 'mouse' stamp: 'ar 10/25/2000 18:07'!handlesMouseMove: evt	^true! !!NumericReadoutTile methodsFor: 'mouse' stamp: 'ar 10/25/2000 18:06'!mouseDown: evt	^self mouseStillDown: evt! !!SoundTile methodsFor: 'user interface' stamp: 'ar 10/25/2000 18:05'!mouseDown: evt	| aPoint index isUp soundChoices adjustment |	upArrow ifNotNil: [((isUp _ upArrow containsPoint: (aPoint _ evt cursorPoint)) or:			[downArrow containsPoint: aPoint]) ifTrue: [		soundChoices _ #('silence').  "default, if no SampledSound class"		Smalltalk at: #SampledSound ifPresent:			[:sampledSound | soundChoices _ sampledSound soundNames].		index _ soundChoices indexOf: literal.		index > 0 ifTrue:			[adjustment _ isUp ifTrue: [1] ifFalse: [-1].			self literal: (soundChoices atWrap: (index + adjustment))].		self playSoundNamed: literal].		^ self].	super mouseStillDown: evt.! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 10/25/2000 17:52'!addHandlesTo: aHaloMorph box: box	| dismissHandle s |	s _ aHaloMorph handleSize.	myActor getTexturePointer == nil ifFalse:[		aHaloMorph addHandleAt: box rightCenter color: Color lightGray on: #mouseDown send: #extractTexture: to: aHaloMorph target].	aHaloMorph addHandleAt: box topLeft color: Color red icon: 'Halo-Menu'		on: #mouseDown send: #doMenu:with: to: aHaloMorph.	aHaloMorph addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown icon: 'Halo-Tile'		on: #mouseDown send: #yourself "#tearOffTile" to: self.	dismissHandle _ aHaloMorph addHandleAt: (box topLeft + ((s+2)@0) min: box topLeft + box topCenter // 2)		color: Color red muchLighter icon: 'Halo-Dismiss'		on: #mouseDown send: #mouseDownInDimissHandle:with: to: aHaloMorph.	dismissHandle on: #mouseUp send: #maybeDismiss:with: to: aHaloMorph.	dismissHandle on: #mouseDown send: #setDismissColor:with: to: aHaloMorph.	dismissHandle on: #mouseMove send: #setDismissColor:with: to: aHaloMorph.	aHaloMorph addHandleAt: box leftCenter color: Color cyan icon: 'Halo-View'		on: #mouseDown send: #yourself "#openViewerForArgument" to: self.	aHaloMorph addHandleAt: box topCenter color: Color black icon: 'Halo-Grab'		on: #mouseDown send: #grabFromHalo:with: to: self.	(aHaloMorph addHandleAt: (box topCenter + ((s+2)@0) min: box topCenter + box topRight // 2)		color: Color brown icon: 'Halo-Drag'		on: #mouseDown send: #dragStartFromHalo:with: to: self)		on: #mouseMove send: #dragMoveFromHalo:with: to: self;		on: #mouseUp send: #dragEndFromHalo:with: to: self.	(aHaloMorph addHandleAt: box topRight color: Color green icon: 'Halo-Dup'		on: #mouseDown send: #dupStartFromHalo:with: to: self)		on: #mouseMove send: #dupMoveFromHalo:with: to: self;		on: #mouseUp send: #dupEndFromHalo:with: to: self.	Preferences showDebugHaloHandle ifTrue:		[aHaloMorph addHandleAt: ((box topRight + box rightCenter) // 2)			color: Color blue veryMuchLighter icon: 'Halo-Debug'			on: #mouseDown send: #doDebug:with: to: aHaloMorph].	(aHaloMorph addHandleAt: box bottomLeft color: Color blue icon: 'Halo-Rotate'		on: #mouseDown send: #rotateStartFromHalo:with: to: self)		on: #mouseMove send: #rotateMoveFromHalo:with: to: self;		on: #mouseUp send: #rotateEndFromHalo:with: to: self.	(aHaloMorph addHandleAt: box bottomRight color: Color yellow icon: 'Halo-Scale'		on: #mouseDown send: #growStartFromHalo:with: to: self)		on: #mouseMove send: #growMoveFromHalo:with: to: self;		on: #mouseUp send: #growEndFromHalo:with: to: self.	myActor isHandmade		ifTrue: [			(aHaloMorph addHandleAt: box center color: Color white icon: 'Halo-Paint'				on: #mouseUp send: #paintMode to: self getCameraMorph)]! !NumericReadoutTile removeSelector: #mouseMove:!TileMorph removeSelector: #mouseMove:!TileMorph removeSelector: #mouseStillDownStepTime!SimpleButtonDelayedMenuMorph removeSelector: #mouseMove:!SimpleButtonMorph removeSelector: #step!SimpleButtonMorph removeSelector: #stepTime!SimpleButtonMorph removeSelector: #wantsSteps!ProjectViewMorph removeSelector: #mouseMove:!ProjectViewMorph removeSelector: #mouseStillDownStepTime!Morph removeSelector: #mouseStillDownStepTime!Object subclass: #EventHandler	instanceVariableNames: 'mouseDownRecipient mouseDownSelector mouseMoveRecipient mouseMoveSelector mouseStillDownRecipient mouseStillDownSelector mouseUpRecipient mouseUpSelector mouseEnterRecipient mouseEnterSelector mouseLeaveRecipient mouseLeaveSelector mouseEnterDraggingRecipient mouseEnterDraggingSelector mouseLeaveDraggingRecipient mouseLeaveDraggingSelector keyStrokeRecipient keyStrokeSelector valueParameter startDragRecipient startDragSelector doubleClickSelector doubleClickRecipient clickSelector clickRecipient '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!"Postscript:Fix up a few old guys that we know have problems."EventHandler allInstancesDo:[:eh|	(eh mouseStillDownSelector == #upArrowHit and:[eh mouseDownSelector == nil])		ifTrue:[eh on: #mouseDown send: #upArrowHit to: eh mouseStillDownRecipient].	(eh mouseStillDownSelector == #downArrowHit and:[eh mouseDownSelector == nil])		ifTrue:[eh on: #mouseDown send: #downArrowHit to: eh mouseStillDownRecipient].].!