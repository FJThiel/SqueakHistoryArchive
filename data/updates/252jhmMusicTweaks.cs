'From Squeak 2.2beta of Sept 11, 1998 on 12 September 1998 at 11:06:59 pm'!"Change Set:		jhmMusicTweaksDate:			12 September 1998Author:			John MaloneyThis file contains code to support the unloading of bulky sampled timbres. Anyscore editors that are using these timbres remember which timbre they wereusing so that when the timbre is reloaded, they immediately start using it.An attempt is made to show whether a particular sound is not loaded,by appending the short string '(out)' to the instrument name.This file also adds several features to the MIDI file reader including:  a. The ability to read a MIDI file that has some data before the MIDI file header.     Don Lewis sent me a file with this problem.  b. The ability to split a type-0 MIDI file into multiple tracks by channel number.  c. Attempts to guess instrument names for tracks when they are not provided, using     the first MIDI program number of the track, if there is one."!Object subclass: #AbstractSound	instanceVariableNames: 'envelopes mSecsSinceStart samplesUntilNextControl scaledVol scaledVolIncr scaledVolLimit '	classVariableNames: 'FloatScaleFactor MaxScaledValue PitchesForBottomOctave ScaleFactor Sounds TopOfBottomOctave UnloadedSnd '	poolDictionaries: ''	category: 'System-Sound'!FMSound subclass: #UnloadedSound	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!!AbstractSound class reorganize!('class initialization' initialize scaleFactor)('instance creation' default dur: new noteSequenceOn:from: pitch:dur:loudness:)('utilities' indexOfBottomOctavePitch: midiKeyForPitch: pitchForMIDIKey: pitchForName: pitchTable)('examples' chromaticPitchesFrom: chromaticRunFrom:to:on: chromaticScale chromaticScaleOn: hiMajorScale hiMajorScaleOn: lowMajorScale lowMajorScaleOn: majorChord majorChordOn:from: majorPitchesFrom: majorScale majorScaleOn: majorScaleOn:from: scaleTest testFMInteractively)('examples-bach fugue' bachFugue bachFugueOn: bachFugueVoice1On: bachFugueVoice2On: bachFugueVoice3On: bachFugueVoice4On: stereoBachFugue)('sound library' initSounds soundNamed: soundNamed:ifAbsent: soundNamed:put: soundNames sounds)('sound library-file in/out' fileInSoundLibrary fileInSoundLibraryNamed: fileOutSoundLibrary fileOutSoundLibrary: storeFiledInSound:named: unloadSampledTimbres unloadSoundNamed: unloadedSound updateScorePlayers)('primitive generation' cCodeForSoundPrimitives)!!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 22:18'!fileInSoundLibraryNamed: fileName	"File in the sound library with the given file name, and add its contents to the current sound library."	| s newSounds |	s _ FileStream oldFileNamed: fileName.	newSounds _ s fileInObjectAndCode.	s close.	newSounds associationsDo:		[:assoc | self storeFiledInSound: assoc value named: assoc key].	ScorePlayerMorph allInstances do: [:p | p updateInstrumentsFromLibrary].	Smalltalk garbageCollect.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:35'!storeFiledInSound: snd named: sndName	"Store the given sound in the sound library. Use the given name if it isn't in use, otherwise ask the user what to do."	| menu choice i |	(Sounds includesKey: sndName) ifFalse: [  "no name clash"		Sounds at: sndName put: snd.		^ self].	(Sounds at: sndName) == UnloadedSnd ifTrue: [		"re-loading a sound that was unloaded to save space"		Sounds at: sndName put: snd.		^ self].	"the given sound name is already used"	menu _ SelectionMenu selections:		#('replace the existing sound' 'rename the new sound' 'skip it').	choice _ menu startUpWithCaption:		'"', sndName, '" has the same name as an existing sound'.	(choice beginsWith: 'replace') ifTrue: [		Sounds at: sndName put: snd.		^ self].	(choice beginsWith: 'rename') ifTrue: [		i _ 2.		[Sounds includesKey: (sndName, ' v', i printString)] whileTrue: [i _ i + 1].		Sounds at: (sndName, ' v', i printString) put: snd].! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 22:18'!unloadSampledTimbres	"This can be done to unload those bulky sampled timbres to shrink the image. The unloaded sounds are replaced by a well-known 'unloaded sound' object to enable the unloaded sounds to be detected when the process is reversed."	"AbstractSound unloadSampledTimbres"	Sounds keys copy do: [:soundName |		(((Sounds at: soundName) isKindOf: SampledInstrument) or:		 [(Sounds at: soundName) isKindOf: LoopedSampledSound]) ifTrue: [			Sounds at: soundName put: self unloadedSound]].	self updateScorePlayers.	Smalltalk garbageCollect.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/11/1998 16:47'!unloadSoundNamed: soundName	(Sounds includesKey: soundName) ifTrue: [		Sounds at: soundName put: self unloadedSound].	self updateScorePlayers.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:48'!unloadedSound	"Answer a sound to be used as the place-holder for sounds that have been unloaded."	UnloadedSnd ifNil: [UnloadedSnd _ UnloadedSound default copy].	^ UnloadedSnd! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/11/1998 16:52'!updateScorePlayers	"Force all ScorePlayers to update their instrument list from the sound library. This may done after loading, unloading, or replacing a sound to make all ScorePlayers feel the change."	ScorePlayer allInstances do: [:p | p pause].	SoundPlayer shutDown.	ScorePlayerMorph allInstances do: [:p | p updateInstrumentsFromLibrary].! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/12/1998 18:29'!readHeaderChunk	| chunkType chunkSize division |	chunkType _ self readChunkType.	chunkType = 'RIFF' ifTrue:[chunkType _ self riffSkipToMidiChunk].	chunkType = 'MThd' ifFalse: [self scanForMIDIHeader].	chunkSize _ self readChunkSize.	fileType _ self next16BitWord.	trackCount _ self next16BitWord.	division _ self next16BitWord.	(division anyMask: 16r8000)		ifTrue: [self error: 'SMPTE time formats are not yet supported']		ifFalse: [ticksPerQuarter _ division].	maxNoteTicks _ 12 * 4 * ticksPerQuarter.		"longest acceptable note; used to detect stuck notes"	"sanity checks"	chunkSize = 6		ifFalse: [self error: 'unexpected MIDI header size ', chunkSize printString].	(#(0 1 2) includes: fileType)		ifFalse: [self error: 'unknown MIDI file type ', fileType printString].	Transcript		show: 'Reading Type ', fileType printString, ' MIDI File (';		show: trackCount printString, ' tracks, ';		show: ticksPerQuarter printString, ' ticks per quarter note)';		cr.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/12/1998 19:08'!readMIDIFrom: aBinaryStream	"Read one or more MIDI tracks from the given binary stream."	stream _ aBinaryStream.	tracks _ OrderedCollection new.	trackInfo _ OrderedCollection new.	self readHeaderChunk.	trackCount timesRepeat: [self readTrackChunk].	stream atEnd ifFalse: [self report: 'data beyond final track'].	fileType = 0 ifTrue: [self splitIntoTracks].	self guessMissingInstrumentNames.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:10'!readTrackContents: byteCount	| info |	strings _ OrderedCollection new.	track _ OrderedCollection new.	trackStream _ ReadStream on: (stream next: byteCount).	activeEvents _ OrderedCollection new.	self readTrackEvents.	(tracks isEmpty and: [self isTempoTrack: track])		ifTrue: [tempoMap _ track asArray]		ifFalse: [			"Note: Tracks without note events are currently not saved to			 eliminate clutter in the score player. In control applications,			 this can be easily changed by modifying the following test."			(self trackContainsNotes: track) ifTrue: [				tracks add: track asArray.				info _ WriteStream on: (String new: 100).				strings do: [:s | info nextPutAll: s; cr].				trackInfo add: info contents]].	strings _ track _ trackStream _ activeEvents _ nil.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:15'!trackContainsNotes: eventList	"Answer true if the given track contains at least one note event."	eventList do: [:e | e isNoteEvent ifTrue: [^ true]].	^ false! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 20:00'!guessMissingInstrumentNames	"Attempt to guess missing instrument names from the first program change in that track."	| progChange instrIndex instrName |	1 to: tracks size do: [:i |		(trackInfo at: i) isEmpty ifTrue: [			progChange _ (tracks at: i) detect: [:e | e isProgramChange] ifNone: [nil].			progChange ifNotNil: [				instrIndex _ progChange program + 1.				instrName _ self class standardMIDIInstrumentNames at: instrIndex.				trackInfo at: i put: instrName]]].! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 17:32'!readChunkType	"Read a chunk ID string from the next 4 bytes."	"Assume: Stream has at least four bytes left."	| s |	s _ String new: 4.	1 to: 4 do: [:i | s at: i put: (stream next) asCharacter].	^ s! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 19:19'!scanForMIDIHeader	"Scan the first part of this file in search of the MIDI header string 'MThd'. Report an error if it is not found. Otherwise, leave the input stream positioned to the first byte after this string."	| asciiM p lastSearchPosition byte restOfHeader |	asciiM _ $M asciiValue.	stream skip: -3.	p _ stream position.	lastSearchPosition _ p + 10000.  "search only the first 10000 bytes of the file"	[p < lastSearchPosition and: [stream atEnd not]] whileTrue: [		[(byte _ stream next) ~= asciiM and: [byte ~~ nil]] whileTrue.  "find the next 'M' or file end"		restOfHeader _ (stream next: 3) asString.		restOfHeader = 'Thd'			ifTrue: [^ self]			ifFalse: [restOfHeader size = 3 ifTrue: [stream skip: -3]].		p _ stream position].	self error: 'MIDI header chunk not found'.! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 20:10'!splitIntoTracks	"Split a type zero MIDI file into separate tracks by channel number."	| newTempoMap newTracks |	tracks size = 1 ifFalse: [self error: 'expected exactly one track in type 0 file'].	tempoMap ifNotNil: [self error: 'did not expect a tempo map in type 0 file'].	newTempoMap _ OrderedCollection new.	newTracks _ (1 to: 16) collect: [:i | OrderedCollection new].	tracks first do: [:e |		e isTempoEvent			ifTrue: [newTempoMap addLast: e]			ifFalse: [(newTracks at: e channel + 1) addLast: e]].	newTempoMap size > 0 ifTrue: [tempoMap _ newTempoMap asArray].	newTracks _ newTracks select: [:t | self trackContainsNotes: t].	tracks _ newTracks collect: [:t | t asArray].	trackInfo _ trackInfo, ((2 to: tracks size) collect: [:i | '']).! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 9/12/1998 19:57'!standardMIDIInstrumentNames	"Answer an array of Standard MIDI instrument names."	^ #(		'Grand Piano'		'Bright Piano'		'Electric Grand Piano'		'Honky-tonk Piano'		'Electric Piano 1'		'Electric Piano 2'		'Harpsichord'		'Clavichord'		'Celesta'		'Glockenspiel'		'Music Box'		'Vibraphone'		'Marimba'		'Xylophone'		'Tubular Bells'		'Duclimer'		'Drawbar Organ'		'Percussive Organ'		'Rock Organ'		'Church Organ'		'Reed Organ'		'Accordion'		'Harmonica'		'Tango Accordion'		'Nylon Guitar'		'Steel Guitar'		'Electric Guitar 1'		'Electric Guitar 2'		'Electric Guitar 3'		'Overdrive Guitar'		'Distorted Guitar'		'Guitar Harmonics'		'Acoustic Bass'		'Electric Bass 1'		'Electric Bass 2'		'Fretless Bass'		'Slap Bass 1'		'Slap Bass 2'		'Synth Bass 1'		'Synth Bass 2'		'Violin'		'Viola'		'Cello'		'Contrabass'		'Tremolo Strings'		'Pizzicato Strings'		'Orchestral Harp'		'Timpani'		'String Ensemble 1'		'String Ensemble 2'		'Synth Strings 1'		'Synth Strings 2'		'Choir Ahhs'		'Choir Oohs'		'Synth Voice'		'Orchestra Hit'		'Trumpet'		'Trombone'		'Tuba'		'Muted Trumpet'		'French Horn'		'Brass Section'		'Synth Brass 1'		'Synth Brass 2'		'Soprano Sax'		'Alto Sax'		'Tenor Sax'		'Baritone Sax'		'Oboe'		'English Horn'		'Bassoon'		'Clarinet'		'Piccolo'		'Flute'		'Recorder'		'Pan Flute'		'Blown Bottle'		'Shakuhachi'		'Whistle'		'Ocarina'		'Lead 1 (square)'		'Lead 2 (sawtooth)'		'Lead 3 (calliope)'		'Lead 4 (chiff)'		'Lead 5 (charang)'		'Lead 6 (voice)'		'Lead 7 (fifths)'		'Lead 8 (bass+lead)'		'Pad 1 (new age)'		'Pad 2 (warm)'		'Pad 3 (polysynth)'		'Pad 4 (choir)'		'Pad 5 (bowed)'		'Pad 6 (metallic)'		'Pad 7 (halo)'		'Pad 8 (sweep)'		'FX 1 (rain)'		'FX 2 (soundtrack)'		'FX 3 (crystals)'		'FX 4 (atmosphere)'		'FX 5 (brightness)'		'FX 6 (goblins)'		'FX 7 (echoes)'		'FX 8 (sci-fi)'		'Sitar'		'Banjo'		'Shamisen'		'Koto'		'Kalimba'		'Bagpipe'		'Fiddle'		'Shanai'		'Tinkle Bell'		'Agogo'		'Steel Drum'		'Woodblock'		'Taiko Drum'		'Melodic Tom'		'Synth Drum'		'Reverse Cymbal'		'Guitar Fret Noise'		'Breath Noise'		'Seashore'		'Bird Tweet'		'Telephone Ring'		'Helicopter'		'Applause'		'Gunshot')! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:14'!instrumentChoicesForTrack: trackIndex	| names inst |	names _ AbstractSound soundNames asOrderedCollection.	names _ names collect: [:n |		inst _ AbstractSound soundNamed: n.		(inst isKindOf: UnloadedSound)			ifTrue: [n, '(out)']			ifFalse: [n]].	names add: 'clink'.	names add: 'edit ', (instrumentSelector at: trackIndex) contents.	^ names asArray! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:09'!trackNumAndMuteButtonFor: trackIndex	| muteButton instSelector r |	muteButton _ SimpleSwitchMorph new		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		offColor: color;		color: color;		label: 'Mute';		target: scorePlayer;		actionSelector: #mutedForTrack:put:;		arguments: (Array with: trackIndex).	instSelector _ PopUpChoiceMorph new		extent: 95@14;		contentsClipped: 'oboe1';		target: self;		actionSelector: #atTrack:from:selectInstrument:;		getItemsSelector: #instrumentChoicesForTrack:;		getItemsArgs: (Array with: trackIndex).	instSelector arguments:		(Array with: trackIndex with: instSelector).	instrumentSelector at: trackIndex put: instSelector.	r _ self makeRow		hResizing: #rigid;		vResizing: #spaceFill;		extent: 70@10.	r addMorphBack:		(StringMorph			contents: trackIndex printString			font: (TextStyle default fontOfSize: 24)).	trackIndex < 10		ifTrue: [r addMorphBack: (Morph new color: color; extent: 19@8)]  "spacer"		ifFalse: [r addMorphBack: (Morph new color: color; extent: 8@8)].  "spacer"	r addMorphBack:		(StringMorph new			extent: 140@14;			contentsClipped: (scorePlayer infoForTrack: trackIndex)).	r addMorphBack: (Morph new color: color; extent: 8@8).  "spacer"	r addMorphBack: instSelector.	r addMorphBack: (AlignmentMorph newRow color: color).  "spacer"	r addMorphBack: muteButton.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:14'!updateInstrumentsFromLibrary	"The instrument library has been modified. Update my instruments with the new versions from the library. Use a single instrument prototype for all parts with the same name; this allows the envelope editor to edit all the parts by changing a single sound prototype."	| unloadPostfix myInstruments name displaysAsUnloaded isUnloaded |	unloadPostfix _ '(out)'.	myInstruments _ Dictionary new.	1 to: instrumentSelector size do: [:i |		name _ (instrumentSelector at: i) contents.		displaysAsUnloaded _ name endsWith: unloadPostfix.		displaysAsUnloaded ifTrue: [			name _ name copyFrom: 1 to: name size - unloadPostfix size].		(myInstruments includesKey: name) ifFalse: [			myInstruments at: name put:				(name = 'clink'					ifTrue: [						(SampledSound							samples: SampledSound coffeeCupClink							samplingRate: 11025) copy]					ifFalse: [						(AbstractSound							soundNamed: name							ifAbsent: [								(instrumentSelector at: i) contentsClipped: 'default'.								FMSound default]) copy])].		scorePlayer instrumentForTrack: i put: (myInstruments at: name).		"update loaded/unloaded status in instrumentSelector if necessary"		isUnloaded _ (myInstruments at: name) isKindOf: UnloadedSound.		(displaysAsUnloaded and: [isUnloaded not])			ifTrue: [(instrumentSelector at: i) contentsClipped: name].		(displaysAsUnloaded not and: [isUnloaded])			ifTrue: [(instrumentSelector at: i) contentsClipped: name, unloadPostfix]].! !!UnloadedSound commentStamp: 'jm 9/12/1998 21:40' prior: 0!Instances of me, which are really just FMSounds, are used placeholders for sounds that have been unloaded from this image but which may be re-loaded later.!!UnloadedSound class methodsFor: 'as yet unclassified' stamp: 'jm 9/12/1998 23:05'!default	"UnloadedSound default play"	| snd p |	snd _ super new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !AbstractSound class removeSelector: #unloadSampledInstruments!AbstractSound class removeSelector: #unloadAllSampledInstruments!MIDIFileReader removeSelector: #standardMIDIInstrumentNames!