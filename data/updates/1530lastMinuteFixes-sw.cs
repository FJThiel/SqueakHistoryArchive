'From Squeak 2.5 of August 6, 1999 [latest update: #1529] on 10 October 1999 at 10:28:42 am'!"Change Set:		lastMinuteFixes-swDate:			10 October 1999Author:			Scott Wallace1.  Fixes the recent bug that made mouseover behaviors not work in new morphic projects, and repairs damaged HandMorphs that may linger from such projects created during the lifespan of that bug.  As part of this fix, cleans out some leftovers from the earliest days of morphic mouseover implementation.2.  Fixes Morph.flash so that it does not hang the system if called from a step method.3.  Fixes ChangeList class.versionCount such that it does not fail when called for a method that has been removed from the system or is unlogged.4.  Fixes a bug that dropped user into a debugger when cmd-f was issued in a class-list pane of a change sorter."!!ChangeList class methodsFor: 'public access' stamp: 'sw 10/9/1999 21:03'!versionCountForSelector: aSelector class: aClass	"Answer the number of versions known to the system for the given class and method, including the current version.  A result of greater than one means that there is at least one superseded version.  Answer zero if no logged version can be obtained."		| method aChangeList |	method _ aClass compiledMethodAt: aSelector ifAbsent: [^ 0].	aChangeList _ self new			scanVersionsOf: method class: aClass meta: aClass isMeta			category: nil selector: aSelector.	^ aChangeList ifNil: [0] ifNotNil: [aChangeList list size]! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 10/5/1999 18:01'!classListKey: aChar from: view		"Overridden to obviate spurious StringHolder processing of $s for findClass"	^ self messageListKey: aChar from: view! !!Morph methodsFor: 'drawing' stamp: 'sw 10/10/1999 10:23'!flash	| c w |	c _ self color.	self color: Color black.	(w _ self world) ifNotNil: [w displayWorldSafely].	self color: c! !!HandMorph methodsFor: 'initialization' stamp: 'sw 10/10/1999 10:13'!initForEvents	eventSubscribers _ Set new.	mouseDownMorph _ nil.	lastEvent _ MorphicEvent new.	eventTransform _ MorphicTransform identity.	self resetClickState.	mouseOverTimes _ Dictionary new.	suppressDrawing _ false! !!HandMorph methodsFor: 'initialization' stamp: 'sw 10/10/1999 10:22'!initializeMouseOverTimes	"Not normally need, but inserted temporarily for the purpose of repairing damaged HandMorph instances that had nil in the mouseOverTimes slots."	mouseOverTimes _ Dictionary new! !!HandMorph methodsFor: 'event handling' stamp: 'sw 10/10/1999 10:13'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: (Sensor cursorPoint - owner viewBox topLeft)]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				clickState == #firstClickDown ifFalse:					["ensure that at least one mouseMove: is reported for each mouse transaction:"					m mouseMove: (localEvt copy setType: #mouseMove).					(m handlesMouseOverDragging: localEvt) ifTrue:						["If m also handles dragOver, enter it in the list"						dragOverMorphs add: m.						mouseOverMorphs remove: m ifAbsent: []]]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes removeKey: m ifAbsent: []]! !!HandMorph methodsFor: 'event handling' stamp: 'sw 10/10/1999 10:13'!handleMouseOver: evt	| mList allMouseOvers leftMorphs enteredMorphs now t oldHalo balloonHelpEnabled mouseOverHalosEnabled |	owner ifNil: [^ self].  "this hand is not in a world"	balloonHelpEnabled _ Preferences balloonHelpEnabled & evt anyButtonPressed not.	mouseOverHalosEnabled _ Preferences mouseOverHalosEnabled & evt anyButtonPressed not.	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	now _ Time millisecondClockValue.	"Make a list of all potential mouse-overs..."	allMouseOvers _ mList select:		[:m | ((mouseOverHalosEnabled and: [m wantsHalo])			or: [balloonHelpEnabled and: [m wantsBalloon]])  "To start a timer"			or: [m handlesMouseOver: (evt transformedBy: (m transformFrom: self))]  "To send mouseEnter:"].	leftMorphs _ mouseOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (mouseOverMorphs includes: m) not].	"Notify and remove any mouse-overs that have just been left..."	leftMorphs do: [:m |		mouseOverMorphs remove: m.		m wantsBalloon ifTrue: [m deleteBalloon].		m mouseLeave: (evt transformedBy: (m transformFrom: self)).		mouseOverTimes removeKey: m ifAbsent: [] ].	"Add any new mouse-overs and send mouseEnter: and/or start timers..."	enteredMorphs do: [:m |		mouseOverMorphs add: m.		dragOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		(m handlesMouseOver: evt) ifTrue:			[m mouseEnter: (evt transformedBy: (m transformFrom: self))].		(m wantsHalo or: [m wantsBalloon]) ifTrue:			[mouseOverTimes at: m put: now]].	mouseOverTimes keys do:		[:m | "Check pending timers for lingering"		t _ mouseOverTimes at: m.		(now < t "rollover" or: [now > (t+800)]) ifTrue:			["Yes we have lingered for 0.8 seconds..."			mouseOverTimes removeKey: m.			m owner ifNotNil:  "Not deleted during linger (--it happens ;--)"				[(mouseOverHalosEnabled and: [m wantsHalo])					ifTrue: [oldHalo _ m world haloMorphOrNil.							(oldHalo == nil or: [oldHalo target ~~ m])								ifTrue: ["Put up halo for m"										self popUpHalo: evt.										(balloonHelpEnabled and: [m wantsBalloon]) ifTrue:											["...and reschedule balloon after longer linger"											mouseOverTimes at: m put: now]]								ifFalse: ["Halo for m is already up, so show balloon"										(balloonHelpEnabled and: [m wantsBalloon])											ifTrue: [m showBalloon: m balloonText]]]					ifFalse:						[(balloonHelpEnabled and: [m wantsBalloon])							ifTrue: [m showBalloon: m balloonText]]]]]! !"Postscript:"HandMorph allSubInstancesDo: [:mkono | mkono initializeMouseOverTimes].HandMorph removeSelector: #initializeMouseOverTimes.!