'From Squeak2.7alpha of 19 November 1999 [latest update: #1617] on 21 November 1999 at 12:52:43 am'!"Change Set:		clickMenu-bfDate:			1 November 1999Author:			Bert FreudenbergAllows click-move-click menu selection (as suggested by Kevin McGee) in addition to the down-move-up style."!!InputSensor methodsFor: 'mouse' stamp: 'bf 11/1/1999 20:12'!waitButton	"Wait for the user to press any mouse button and then answer with the 	current location of the cursor."	[self anyButtonPressed] whileFalse:		[(Delay forMilliseconds: 50) wait].	^self cursorPoint! !!InputSensor methodsFor: 'mouse' stamp: 'bf 11/1/1999 20:22'!waitNoButton	"Wait for the user to release any mouse button and then answer with the 	current location of the cursor."	[self anyButtonPressed] whileTrue:		[(Delay forMilliseconds: 50) wait].	^self cursorPoint! !!MenuItemMorph methodsFor: 'events' stamp: 'bf 11/1/1999 19:20'!mouseUp: evt	"Handle a mouse up event. Menu items get activated when the mouse is over them."	| mouseInMe |	mouseInMe _ self boundsInWorld containsPoint: evt cursorPoint.	self deselectItem.	self isInMenu		ifTrue:			[(mouseInMe and: [self selector = #toggleStayUp:])				ifFalse: [owner deleteIfPopUpFrom: self event: evt].			subMenu ifNil:				[mouseInMe ifTrue:					[evt hand world displayWorld.					owner invokeItem: self event: evt]]]		ifFalse:  			[self invokeWithEvent: evt]						! !!MenuMorph methodsFor: 'control' stamp: 'bf 11/1/1999 20:55'!deleteIfPopUpFrom: item event: evt	"Remove this menu from the screen if stayUp is not true, but only if the user did move the mouse since invoking me. This allows for click-move-click selection style."	(stayUp not and: [(evt cursorPoint dist: originalEvent cursorPoint) < 2])		ifTrue: [^evt hand newMouseFocus: item "Do tracking and delete on next click"].	self deleteIfPopUp.! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'bf 11/1/1999 20:44'!startUpWithCaption: captionOrNil at: location	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released, answer the index of the current selection, or zero if the mouse is not released over any menu item. Location specifies the desired topLeft of the menu body rectangle."	| maxHeight |	maxHeight _ Display height*3//4.	self frameHeight > maxHeight ifTrue:		[^ self startUpSegmented: maxHeight withCaption: captionOrNil at: location].	World ifNotNil:		[selection _ Cursor normal showWhile:			[(MVCMenuMorph from: self title: captionOrNil) invokeAt: location in: World].		^ selection].	frame ifNil: [self computeForm].	Cursor normal showWhile:		[self displayAt: location			withCaption: captionOrNil			during: [ | didNotMove |					didNotMove _ true.					Sensor anyButtonPressed ifFalse:						[didNotMove _ false.						Sensor waitButton].					self manageMarker.					(didNotMove and: [selection = 0]) ifTrue:						[ | downPos |						downPos _ Sensor cursorPoint.						[didNotMove and: [Sensor anyButtonPressed]] whileTrue:							[(downPos dist: Sensor cursorPoint) < 2 ifFalse:								[didNotMove _ false]].						didNotMove ifTrue: [Sensor waitButton]].					[Sensor anyButtonPressed] whileTrue: [self manageMarker]]].	^ selection! !