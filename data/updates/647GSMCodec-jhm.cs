'From Squeak 2.3 of January 14, 1999 on 4 February 1999 at 3:34:45 pm'!"Change Set:		GSMCodec-jhmDate:			4 February 1999Author:			John MaloneyAdds support for GSM 6.10 codec (9.7 to 1 compression)plus a simple drag-n-drop codec test morph."!RectangleMorph subclass: #CodecDemoMorph	instanceVariableNames: 'codecClassName '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!SoundCodec subclass: #GSMCodec	instanceVariableNames: 'encodeState decodeState '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Synthesis'!InterpreterPlugin subclass: #SoundCodecPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!!CodecDemoMorph methodsFor: 'as yet unclassified' stamp: 'jm 2/4/1999 12:37'!acceptDroppingMorph: aMorph event: evt	| codecClass |	'None' = codecClassName		ifTrue: [aMorph sound play]		ifFalse: [			codecClass _ Smalltalk at: codecClassName ifAbsent: [^ self].			(codecClass new compressAndDecompress: aMorph sound) play].	aMorph position: self topRight + (10@0).! !!CodecDemoMorph methodsFor: 'as yet unclassified' stamp: 'jm 2/4/1999 12:33'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'select codec' action: #selectCodec.! !!CodecDemoMorph methodsFor: 'as yet unclassified' stamp: 'jm 2/4/1999 12:36'!codecClassName: aStringOrSymbol	| label |	codecClassName _ aStringOrSymbol asSymbol.	self removeAllMorphs.	label _ StringMorph contents: aStringOrSymbol.	label position: self position + (5@5).	self addMorph: label.	label lock: true.	self extent: label extent + (10@10).! !!CodecDemoMorph methodsFor: 'as yet unclassified' stamp: 'jm 2/4/1999 12:18'!initialize	super initialize.	self borderWidth: 2.	self color: (Color r: 1.0 g: 0.806 b: 0.677).	self codecClassName: 'MuLawCodec'.! !!CodecDemoMorph methodsFor: 'as yet unclassified' stamp: 'jm 2/4/1999 12:33'!selectCodec	| aMenu codecs newCodec |	aMenu _ CustomMenu new title: 'Codec:'.	codecs _ (SoundCodec allSubclasses collect: [:c | c name]) asSortedCollection.	codecs add: 'None'.	codecs do:[:cName | aMenu add: cName action: cName].	newCodec _ aMenu startUp.	newCodec ifNil: [^ self].	self codecClassName: newCodec.! !!CodecDemoMorph methodsFor: 'as yet unclassified' stamp: 'jm 2/4/1999 12:19'!wantsDroppedMorph: aMorph event: evt	^ aMorph isMemberOf: SoundTile! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:30'!reset	"Reset my encoding and decoding state. Optional. This default implementation does nothing."! !!SoundCodec methodsFor: 'private' stamp: 'jm 2/4/1999 11:42'!decodeCompressedData: aByteArray	"Decode the entirety of the given encoded data buffer with this codec. Answer a monophonic SoundBuffer containing the uncompressed samples."	| codeFrameSize frameCount result increments |	codeFrameSize _ self bytesPerEncodedFrame.	codeFrameSize = 0 ifTrue: [self error: 'variable frame size codecs are not yet handled'].	(aByteArray size \\ codeFrameSize) = 0 ifFalse: [		self error: 'encoded buffer is not an even multiple of the encoded frame size'].	frameCount _ aByteArray size // codeFrameSize.	result _ SoundBuffer newMonoSampleCount: frameCount * self samplesPerFrame.	self reset.	increments _ self decodeFrames: frameCount from: aByteArray at: 1 into: result at: 1.	((increments first = aByteArray size) and: [increments last = result size]) ifFalse: [		self error: 'implementation problem; increment sizes should match buffer sizes'].	^ result! !!SoundCodec methodsFor: 'private' stamp: 'jm 2/4/1999 11:41'!encodeSoundBuffer: aSoundBuffer	"Encode the entirety of the given monophonic SoundBuffer with this codec. Answer a ByteArray containing the compressed sound data."	| codeFrameSize frameSize fullFrameCount lastFrameSamples result increments finalFrame i |	codeFrameSize _ self bytesPerEncodedFrame.	codeFrameSize = 0 ifTrue: [self error: 'variable frame size codecs are not yet handled'].	frameSize _ self samplesPerFrame.	fullFrameCount _ aSoundBuffer monoSampleCount // frameSize.	lastFrameSamples _ aSoundBuffer monoSampleCount - (fullFrameCount * frameSize).	lastFrameSamples > 0		ifTrue: [result _ ByteArray new: (fullFrameCount + 1) * self bytesPerEncodedFrame]		ifFalse: [result _ ByteArray new: fullFrameCount * self bytesPerEncodedFrame].	self reset.	increments _ self encodeFrames: fullFrameCount from: aSoundBuffer at: 1 into: result at: 1.	lastFrameSamples > 0 ifTrue: [		finalFrame _ SoundBuffer newMonoSampleCount: frameSize.		i _ fullFrameCount * frameSize.		1 to: lastFrameSamples do: [:j |			finalFrame at: j put: (aSoundBuffer at: (i _ i + 1))].		self encodeFrames: 1 from: finalFrame at: 1 into: result at: (1 + increments at: 2)].	^ result! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:36'!bytesPerEncodedFrame	^ 33! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:44'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	| p |	p _ self	primDecode: decodeState frames: frameCount			from: srcByteArray at: srcIndex			into: dstSoundBuffer at: dstIndex.	^ Array with: p x with: p y! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:44'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	| p |	p _ self	primEncode: encodeState frames: frameCount			from: srcSoundBuffer at: srcIndex			into: dstByteArray at: dstIndex.	^ Array with: p x with: p y! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:32'!reset	"Reset my encoding/decoding state to prepare to encode or decode a new sound stream."	encodeState _ self primNewState.	decodeState _ self primNewState.! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:36'!samplesPerFrame	^ 160! !!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:33'!primDecode: state frames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	<primitive: 'primitiveGSMDecode' module: 'SoundCodecPrims'>	self primitiveFailed.! !!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:33'!primEncode: state frames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	<primitive: 'primitiveGSMEncode' module: 'SoundCodecPrims'>	self primitiveFailed.! !!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:35'!primNewState	<primitive: 'primitiveGSMNewState' module: 'SoundCodecPrims'>	self error: 'The SoundCodecPrims plugin is not available'.! !!SoundCodecPlugin methodsFor: 'gsm 6.10 codec' stamp: 'jm 2/4/1999 08:38'!primitiveGSMDecode	| dstIndex dst srcIndex src frameCount state srcSize dstSize result srcDelta dstDelta |	self export: true.	dstIndex _ interpreterProxy stackIntegerValue: 0.	dst _ interpreterProxy stackObjectValue: 1.	srcIndex _ interpreterProxy stackIntegerValue: 2.	src _ interpreterProxy stackObjectValue: 3.	frameCount _ interpreterProxy stackIntegerValue: 4.	state _ interpreterProxy stackObjectValue: 5.	interpreterProxy success: (interpreterProxy isWords: dst).	interpreterProxy success: (interpreterProxy isBytes: src).	interpreterProxy success: (interpreterProxy isBytes: state).	interpreterProxy failed ifTrue:[^ nil].	srcSize _ interpreterProxy slotSizeOf: src.	dstSize _ (interpreterProxy slotSizeOf: dst) * 2.	self cCode: 'gsmDecode(state + 4, frameCount, src, srcIndex, srcSize, dst, dstIndex, dstSize, &srcDelta, &dstDelta)'.	interpreterProxy failed ifTrue:[^ nil].	result _ interpreterProxy makePointwithxValue: srcDelta yValue: dstDelta.	interpreterProxy failed ifTrue:[^ nil].	interpreterProxy pop: 6.	interpreterProxy push: result.! !!SoundCodecPlugin methodsFor: 'gsm 6.10 codec' stamp: 'jm 2/4/1999 08:37'!primitiveGSMEncode	| dstIndex dst srcIndex src frameCount state srcSize dstSize result srcDelta dstDelta |	self export: true.	dstIndex _ interpreterProxy stackIntegerValue: 0.	dst _ interpreterProxy stackObjectValue: 1.	srcIndex _ interpreterProxy stackIntegerValue: 2.	src _ interpreterProxy stackObjectValue: 3.	frameCount _ interpreterProxy stackIntegerValue: 4.	state _ interpreterProxy stackObjectValue: 5.	interpreterProxy success: (interpreterProxy isBytes: dst).	interpreterProxy success: (interpreterProxy isWords: src).	interpreterProxy success: (interpreterProxy isBytes: state).	interpreterProxy failed ifTrue:[^ nil].	srcSize _ (interpreterProxy slotSizeOf: src) * 2.	dstSize _ interpreterProxy slotSizeOf: dst.	self cCode: 'gsmEncode(state + 4, frameCount, src, srcIndex, srcSize, dst, dstIndex, dstSize, &srcDelta, &dstDelta)'.	interpreterProxy failed ifTrue:[^ nil].	result _ interpreterProxy makePointwithxValue: srcDelta yValue: dstDelta.	interpreterProxy failed ifTrue:[^ nil].	interpreterProxy pop: 6.	interpreterProxy push: result.! !!SoundCodecPlugin methodsFor: 'gsm 6.10 codec' stamp: 'jm 2/4/1999 08:37'!primitiveGSMNewState	| stateBytes state |	self export: true.	stateBytes _ self cCode: 'gsmStateBytes()'.	state _ interpreterProxy		instantiateClass: interpreterProxy classByteArray		indexableSize: stateBytes.	self cCode: 'gsmInitState(state + 4)'.	interpreterProxy push: state.! !!SoundCodecPlugin class methodsFor: 'accessing' stamp: 'jm 2/4/1999 08:47'!moduleName	"Time millisecondsToRun: [		SoundCodecPlugin translateDoInlining: true]"	^ 'soundCompressionPlugin'! !!SoundTile methodsFor: 'all' stamp: 'jm 2/4/1999 12:02'!sound	^ SampledSound soundNamed: literal! !