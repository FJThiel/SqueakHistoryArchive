'From Squeak3.3alpha of 15 February 2002 [latest update: #4805] on 22 March 2002 at 10:00 pm'!"Change Set:		HTMLTable-tkDate:			22 March 2002Author:			Ted KaehlerAfter you parse an incoming web pabe, class HTMLTable is able to deliver its data to you in an Array2D.  Very handy.When grubbing around in web pages, the match: method is very handy.  (strm match: 'foo'), advances the stream to just after then next 'foo', and returns true if is found one.  	Now added backUpTo:, for going backwards."!!HtmlTable methodsFor: 'accessing' stamp: 'tk 3/20/2002 15:43'!asArrayOfData	"Return an Array2D of the table, removing all html.  This in only the text and numbers that the user would see on a web page.  Remove all comments and formatting."	| cc ff array |	cc _ contents select: [:ent | ent isTableRow].	ff _ cc first contents select: [:ent | ent isTableDataItem].	array _ Array2D width: ff size height: cc size.	cc withIndexDo: [:row :rowNum |		array atRow: rowNum put: row asArrayOfData].	^ array! !!HtmlTableRow methodsFor: 'accessing' stamp: 'tk 3/20/2002 15:52'!asArrayOfData	"Return an Array of the table row, removing all html.  This is only the text and numbers that the user would see on a web page.  Remove all comments and formatting."	| cc |	cc _ contents select: [:ent | ent isTableDataItem].	^ cc collect: [:ent | ent asHtml asUnHtml withBlanksTrimmed]		"for now, leave the numbers as strings.  User will know which to convert"! !!PositionableStream methodsFor: 'positioning' stamp: 'tk 3/22/2002 19:33'!backUpTo: subCollection	"Back up the position to he subCollection.  Position must be somewhere within the stream initially.  Leave it just after it.  Return true if succeeded.  No wildcards, and case does matter.""Example:	| strm | strm _ ReadStream on: 'zabc abdc'.	strm setToEnd; backUpTo: 'abc'; position "	| pattern startMatch |	pattern _ ReadStream on: subCollection reversed.	startMatch _ nil.	[pattern atEnd] whileFalse: 		[self position = 0 ifTrue: [^ false].		self skip: -1.		(self next) = (pattern next) 			ifTrue: [pattern position = 1 ifTrue: [startMatch _ self position]]			ifFalse: [pattern position: 0.					startMatch ifNotNil: [						self position: startMatch-1.						startMatch _ nil]].		self skip: -1].	self position: startMatch.	^ true! !