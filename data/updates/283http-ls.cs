'From Squeak 2.1 of June 30, 1998 on 20 September 1998 at 11:37:18 am'!"Change Set:		http-lsDate:			20 September 1998Author:			Lex Spoonvarious web browser tweaks"!SimpleClientSocket subclass: #HTTPSocket	instanceVariableNames: 'headerTokens headers responseCode '	classVariableNames: 'HTTPBlabEmail HTTPPort HTTPProxy HTTPProxyPort HTTPProxyServer ParamDelimiters '	poolDictionaries: ''	category: 'Network-Protocols'!Stream subclass: #HtmlTokenizer	instanceVariableNames: 'inputStream text pos inTextArea textAreaLevel '	classVariableNames: 'CSAttributeEnders CSNameEnders CSNonSeparators '	poolDictionaries: ''	category: 'HTML-Tokenizer'!!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/18/1998 05:40'!downloadState	"download the image"	| doc |	doc _ url retrieveContents.	downloadQueue nextPut: doc.! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/18/1998 05:42'!step	| doc |	downloadQueue size > 0 ifTrue: [		doc _ downloadQueue next.		doc mainType = 'image' 		ifTrue: [			image _ ImageReadWriter  formFromStream: doc contentStream binary.			self setContents ] ].! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 9/17/1998 07:18'!httpGetDocument: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index first connectToHost connectToPort type argsString newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ self defaultPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [		argsString _ WriteStream on: String new.		argsString nextPut: $?.		first _ true.		args associationsDo: [ :assoc |			assoc value do: [ :value |				first ifTrue: [ first _ false ] ifFalse: [ argsString nextPut: $& ].				argsString nextPutAll: assoc key encodeForHTTP.				argsString nextPut: $=.				argsString nextPutAll: value encodeForHTTP. ] ].		argsString _ argsString contents.		page _ page, argsString ].	HTTPProxyServer isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxyServer.			connectToPort _ HTTPProxyPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr; show: connectToHost; cr.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: header; cr.	firstData _ list at: 3.	header isEmpty ifTrue: [ ^'no header' ].	"dig out some headers"	sock header: header.	length _ sock getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ sock getHeader: 'content-type'.	sock responseCode first = $3 ifTrue: [		newUrl _ sock getHeader: 'location'.		newUrl ifNotNil: [ 			Transcript show: 'redirecting to ', newUrl; cr.			sock destroy.			^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].	aStream _ sock getRestOfBuffer: firstData totalLength: length.	sock destroy.	"Always OK to destroy!!" 	^ MIMEDocument contentType: type content: aStream contents url: url! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 9/17/1998 07:19'!httpPostDocument: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| serverName serverAddr s header length bare page list firstData aStream port argsStream first specifiedServer type newUrl |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxy ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	first _ true.	argsDict associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsStream nextPut: $& ].			argsStream nextPutAll: assoc key encodeForHTTP.			argsStream nextPut: $=.			argsStream nextPutAll: value encodeForHTTP.	] ].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: application/x-www-form-urlencoded', CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: argsStream contents; cr; show: header; cr.	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpPostDocument: newUrl  args: argsDict  accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HTTPSocket class methodsFor: 'magic numbers' stamp: 'ls 9/17/1998 07:17'!defaultPort	"default port to connect on"	^80! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ls 9/17/1998 07:18'!stopUsingProxyServer	"Stop directing HTTP request through a proxy server."	HTTPProxyServer _ nil.	HTTPProxyPort _ 80.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ls 9/17/1998 07:17'!useProxyServerNamed: proxyServerName port: portNum	"Direct all HTTP requests to the HTTP proxy server with the given name and port number."	proxyServerName ifNil: [  "clear proxy settings"		HTTPProxyServer _ nil.		HTTPProxyPort _ 80.		^ self].	proxyServerName class == String		ifFalse: [self error: 'Server name must be a String or nil'].	HTTPProxy _ proxyServerName.	HTTPProxyPort _ portNum.	HTTPProxyPort class == String ifTrue: [HTTPPort _ portNum asNumber].	HTTPProxyPort ifNil: [HTTPProxyPort _ self defaultPort].! !!HtmlInput methodsFor: 'attributes' stamp: 'ls 9/18/1998 08:22'!defaultValue	^(self getAttribute: 'value' default: '') replaceHtmlCharRefs! !!HtmlTokenizer methodsFor: 'private-initialization' stamp: 'ls 9/18/1998 08:06'!initialize: s	text _ s withSqueakLineEndings.	pos _ 1.	textAreaLevel _ 0.! !!HtmlTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/18/1998 08:08'!next 	"return the next HtmlToken, or nil if there are no more"	|token|	"branch, depending on what the first character is"	self atEnd ifTrue: [ ^nil ].	self peekChar = $< 		ifTrue: [ token _ self nextTagOrComment ]		ifFalse: [ token _ self nextText ].	"return the token, modulo modifications inside of textarea's"	textAreaLevel > 0 ifTrue: [		(token isTag and: [ token name = 'textarea' ]) ifTrue: [			"textarea tag--change textAreaLevel accordingly"			token isNegated				ifTrue: [ textAreaLevel _ textAreaLevel - 1 ]				ifFalse: [ textAreaLevel _ textAreaLevel -2 ].			textAreaLevel > 0				ifTrue: [ 					"still inside a <textarea>, so convert this tag to text"					^HtmlText forSource: token source ]				ifFalse: [ "end of the textarea; return the tag"  ^token ] ].			"end of the textarea"		"inside the text area--return the token as text"		^HtmlText forSource: token source ].	(token isTag and: [ token isNegated not and: [ token name = 'textarea' ]]) ifTrue: [		"beginning of a textarea"		inTextArea _ true.		^token ].			^token! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/25/1998 05:43'!nextTag	"we've seen a < and peek-ed something other than a !!.  Parse and return a tag"	| source negated name attribs attribName attribValue sourceStart sourceEnd c |		sourceStart _ pos-1.	attribs _ Dictionary new.	"determine if its negated"	self peekChar = $/ 		ifTrue: [ negated _ true.  self nextChar. ]		ifFalse: [ negated _ false ].	"read in the name"	self skipSpaces.	name _ self nextName.	name _ name asLowercase.	"read in any attributes"	[ 	self skipSpaces.		c _ self peekChar.		c = nil or: [c isLetter not ]	] whileFalse: [		attribName _ self nextName.		attribName _ attribName asLowercase.		self skipSpaces.		self peekChar = $= 			ifTrue: [ 				self nextChar.				self skipSpaces.				attribValue _ self nextAttributeValue withoutQuoting  ]			ifFalse: [ attribValue _ '' ].		attribs at: attribName  put: attribValue ].	self peekChar = $> ifTrue: [ self nextChar ].	sourceEnd _ pos-1.	source _ text copyFrom: sourceStart to: sourceEnd.	^HtmlTag source: source name: name asLowercase negated: negated attribs: attribs! !!MIMEDocument methodsFor: 'access' stamp: 'ls 9/18/1998 05:41'!contentStream	"return a RWBinaryOrTextStream on the contents"	^(RWBinaryOrTextStream with: self content) reset! !!Scamper methodsFor: 'user interface' stamp: 'ls 9/18/1998 06:43'!openAsMorph	"open a set of windows for viewing this browser"	|win urlMorph |	"create a window for it"	win _ SystemWindow labelled: 'Scamper'.	win model: self.	win setProperty: #webBrowserView toValue: true.	"create a title view"	win addMorph: (PluggableTextMorph on: self text: #title accept: nil) frame: (0.0@0 extent: 1@0.1).	"create a view of the current url"	"win addMorph: (RectangleMorph new) frame: (0@0.1 extent: 0.3@0.1)."	urlMorph _  PluggableTextMorph on: self text: #currentUrl accept: #jumpToAbsoluteUrl:.	urlMorph acceptOnCR: true.	win addMorph: urlMorph frame: (0@0.1 extent: 1@0.1).	"create a status view"	win addMorph: (PluggableTextMorph on: self text: #status accept: nil) frame: (0@0.9 extent: 1.0@0.1).	"create the text area"	win addMorph: (PluggableTextMorph on: self text: #formattedPage accept: nil readSelection: #formattedPageSelection menu: #menu:shifted:)		frame: (0@0.2 extent: 1@0.7).		win openInWorld.	^win! !!String methodsFor: 'internet' stamp: 'ls 9/15/1998 02:47'!replaceHtmlCharRefs        | pos ampIndex scIndex special specialValue outString outPos newOutPos |        outString _ String new: self size.        outPos _ 0.        pos _ 1.                [ pos <= self size ] whileTrue: [                 "read up to the next ampersand"                ampIndex _ self indexOf: $& startingAt: pos ifAbsent: [0].                                ampIndex = 0 ifTrue: [                        pos = 1 ifTrue: [ ^self ] ifFalse: [ ampIndex _ self size ] ].                newOutPos _ outPos + ampIndex - pos.                outString                        replaceFrom: outPos + 1                        to: newOutPos                        with: self                        startingAt: pos.                outPos _ newOutPos.                pos _ ampIndex.                ampIndex <= self size ifTrue: [                        "find the $;"                        scIndex _ self indexOf: $; startingAt: ampIndex ifAbsent: [ self size + 1 ].                        special _ self copyFrom: ampIndex+1 to: scIndex-1.                               specialValue _ String valueOfHtmlEntity: special.                         specialValue                                ifNil: [                                        "not a recognized entity.  wite it back"								  scIndex > self size ifTrue: [ scIndex _ self size ].                                        newOutPos _ outPos + scIndex - ampIndex + 1.                                        outString                                                replaceFrom: outPos+1                                                to: newOutPos                                                with: self                                                startingAt: ampIndex.                                        outPos _ newOutPos.]                                ifNotNil: [                                        outPos _ outPos + 1.                                        outString at: outPos put: specialValue.].                                                pos _ scIndex + 1. ]. ].        ^outString copyFrom: 1 to: outPos! !