'From Squeak2.8alpha of 12 January 2000 [latest update: #2334] on 12 June 2000 at 7:27:04 pm'!"Change Set:		skipAnySubStrstartingAtDate:			12 June 2000Author:			Bijan Parsiarussell.allen@firebirdmedia.com wrote:	When I try to do:	'A reference to <A HREF=""someurl"">Copyright Act 1968</A>?> '	findBetweenSubStrs: {'<A HREF=""' . '"">' . '</A>'}	I get an error: Subscript is out of bounds.I tracked it down. It's actually a bug in String>>findAnySubStr:startingAt: It doesn't check that the substr you're trying to match would actually *fit* into the receiver starting at thestartingAt:. Nor does it trap the overflow when it happens. Your example exposed it because your first substr is size 9, and a match is attempted at position 52 of a size 58 str."!!String methodsFor: 'accessing' stamp: 'BJP 6/12/2000 18:53'!skipAnySubStr: delimiters startingAt: start 	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."	| any this ind ii |	ii _ start-1.	[(ii _ ii + 1) <= self size] whileTrue: [ "look for char that does not match"		any _ false.		delimiters do: [:delim |			delim class == Character 				ifTrue: [(self at: ii) == delim ifTrue: [any _ true]]				ifFalse: ["a substring"					delim size > (self size - ii + 1) ifFalse: "Here's where the one-off error was."						[ind _ 0.						this _ true.						delim do: [:dd | 							dd == (self at: ii+ind) ifFalse: [this _ false].							ind _ ind + 1].						this ifTrue: [ii _ ii + delim size - 1.  any _ true]]							ifTrue: [any _ false] "if the delim is too big, it can't match"]].		any ifFalse: [^ ii]].	^ self size + 1! !