'From Squeak 2.4b of April 23, 1999 on 12 August 1999 at 10:20:54 am'!"Change Set:		Morphic-PS-6Date:			7 August 1930Author:			Marcel WeiherA Canvas subclass and supporting code to generate graphical representations of Morphs as Postscript code ready for printing or inclusion into drawing programs."!FlattenEncoder subclass: #Canvas	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!Canvas subclass: #PostscriptCanvas	instanceVariableNames: 'origin clipRect currentColor currentFont morphLevel gstateStack fontMap usedFonts psBounds '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Postscript'!PostscriptCanvas subclass: #DSCPostscriptCanvas	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Postscript'!PostscriptCanvas subclass: #EPSCanvas	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Postscript'!Object subclass: #PostscriptCharacterScanner	instanceVariableNames: 'canvas paragraph bounds curPos font foregroundColor emphasis '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Postscript'!Object subclass: #PostscriptDummyWarp	instanceVariableNames: 'canvas subCanvas transform '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Postscript'!PrintableEncoder subclass: #PostscriptEncoder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Postscript'!!Object methodsFor: 'filter streaming'!drawOnCanvas:aStream	self flattenOnStream:aStream.! !!Object methodsFor: 'filter streaming'!encodePostscriptOn:aStream	self byteEncode:aStream.! !!Object methodsFor: 'filter streaming' stamp: 'mpw 6/22/1930 22:56'!fullDrawPostscriptOn:aStream	^aStream fullDraw:self.! !!Bitmap methodsFor: 'filing'!storeBits:startBit to:stopBit on:aStream	self do: [:word | 		startBit to:stopBit by:-4 do:[:shift |						aStream print:((word >>shift) bitAnd:15) asHexDigit.		]	].! !!Canvas methodsFor: 'initialization'!reset	super initWithTarget:self class defaultTarget.	origin _ 0@0.							"origin of the top-left corner of this cavas"	clipRect _ (0@0 corner: 10000@10000).		"default clipping rectangle"	shadowDrawing _ false.					"draw translucent shadows when true"! !!Canvas methodsFor: 'drawing-general'!drawMorph: aMorph	(self isVisible: aMorph bounds) ifTrue:[self draw: aMorph]! !!Canvas methodsFor: 'drawing-general'!fullDraw: anObject	^anObject fullDrawOn: self! !!Canvas methodsFor: 'other'!flushDisplay		" Dummy ."! !!Canvas methodsFor: 'other'!forceToScreen:rect	" dummy "! !!Canvas methodsFor: 'other'!translateBy:aPoint clippingTo:aRect during:aBlock	^aBlock value:(self copyOffset:aPoint clipRect:aRect).! !!Canvas class reorganize!('configuring' filterSelector)!!Canvas class methodsFor: 'configuring'!filterSelector	^#drawOnCanvas:.! !!Color methodsFor: 'printing'!encodePostscriptOn: aStream	aStream setrgbcolor:self.! !!Form methodsFor: 'fileIn/Out'!store15To24HexBitsOn:aStream	bits do: [:word | 		#( 31 26 21 15 10 5 )  do:[:startBit |						aStream print:((word >>(startBit-4)) bitAnd:15) asHexDigit.				aStream print:((word >>(startBit+1)) bitAnd:8) asHexDigit.		]	].! !!Form methodsFor: 'fileIn/Out'!store32To24HexBitsOn:aStream	^self storeBits:20 to:0 on:aStream.! !!Form methodsFor: 'fileIn/Out'!storeBits:startBit to:stopBit on:aStream	bits storeBits:startBit to:stopBit on:aStream.! !!Form methodsFor: 'fileIn/Out'!storeBitsOn:aStream base:anInteger	bits do: [:word | 		anInteger = 10			ifTrue: [aStream space]			ifFalse: [aStream crtab: 2].		word printOn: aStream base: anInteger].! !!Form methodsFor: 'fileIn/Out'!storeHexBitsOn:aStream	^self storeBits:28 to:0 on:aStream.! !!Form methodsFor: 'fileIn/Out'!storeOn: aStream base: anInteger 	"Store the receiver out as an expression that can be evaluated to recreate a Form with the same contents as the original."	self unhibernate.	aStream nextPut: $(.	aStream nextPutAll: self species name.	aStream crtab: 1.	aStream nextPutAll: 'extent: '.	self extent printOn: aStream.	aStream crtab: 1.	aStream nextPutAll: 'depth: '.	self depth printOn: aStream.	aStream crtab: 1.	aStream nextPutAll: 'fromArray: #('.	self storeBitsOn:aStream base:anInteger.	aStream nextPut: $).	aStream crtab: 1.	aStream nextPutAll: 'offset: '.	self offset printOn: aStream.	aStream nextPut: $).! !!Form methodsFor: 'other'!mapColors: oldColorBitsCollection to: newColorBits	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	depth < 16		ifTrue: [map _ (Color cachedColormapFrom: depth to: depth) copy]		ifFalse: [			"use maximum resolution color map"			"source is 16-bit or 32-bit RGB; use colormap with 5 bits per color component"			map _ Color computeRGBColormapFor: depth bitsPerColor: 5].	oldColorBitsCollection do:[ :oldColor | map at: oldColor put: newColorBits].	(BitBlt toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!Form methodsFor: 'postscript generation'!bitsPerComponent	^depth <= 8 ifTrue:[depth] ifFalse:[8].! !!Form methodsFor: 'postscript generation'!decodeArray	^depth <= 8 ifTrue:['[1 0]'] ifFalse:['[0 1 0 1 0 1 ]'].! !!Form methodsFor: 'postscript generation'!encodePostscriptOn:aStream	^self printPostscript:aStream operator:(self depth=1 ifTrue:['imagemask'] ifFalse:['image']) .! !!Form methodsFor: 'postscript generation'!numComponents	^depth <= 8 ifTrue:[1] ifFalse:[3].! !!Form methodsFor: 'postscript generation'!paddedWidth	^ (self width + (self rowPadding-1)// self rowPadding) * self rowPadding.! !!Form methodsFor: 'postscript generation'!printPostscript:aStream operator:operator	aStream	gsave; 			rectclip:(0 @ 0 extent: width @ height).	self setColorspaceOn:aStream.	aStream print:'<<'; cr;			print:'/ImageType 1'; cr;			print:'/ImageMatrix [1 0 0 1 0 0]'; cr;			print:'/MultipleDataSources false'; cr;			print:'/DataSource currentfile /ASCIIHexDecode filter'; cr;			print:'/Width '; write:self paddedWidth; cr;			print:'/Height '; write:self height; cr;			print:'/Decode '; print:self decodeArray;  cr;			print:'/BitsPerComponent '; write:self bitsPerComponent; cr;			print:'>> '; print:operator; cr.	self depth <= 8 ifTrue:[self storeHexBitsOn:aStream].	self depth = 16 ifTrue:[self store15To24HexBitsOn:aStream].	self depth = 32 ifTrue:[self store32To24HexBitsOn:aStream].	aStream print:$>; cr.	aStream grestore; cr.! !!Form methodsFor: 'postscript generation'!rowPadding	^ 32 // self depth! !!Form methodsFor: 'postscript generation'!setColorspaceOn:aStream	self numComponents = 1 ifTrue:[aStream print:'/DeviceGray setcolorspace 0 setgray'; cr.]		ifFalse:[aStream print:'/DeviceRGB setcolorspace'; cr.].! !!ColorForm methodsFor: 'postscript generation'!asFormWithSingleTransparentColors	| transparentIndexes |	transparentIndexes _ self transparentColorIndexes.	transparentIndexes size <= 1 ifTrue:[^self]		ifFalse:[^self mapTransparencies:transparentIndexes].! !!ColorForm methodsFor: 'postscript generation'!decodeArray	^self depth = 1 ifTrue:['[1 0]'] ifFalse:['[0 255]'].! !!ColorForm methodsFor: 'postscript generation'!encodePostscriptOn:aStream	aStream print:'% form contains '; 			write:((colors select:[:c| c=Color transparent]) size); 			print:' transparent colors'; cr.	^self asFormWithSingleTransparentColors printPostscript:aStream operator:(self depth=1 ifTrue:['imagemask'] 	ifFalse:[ (self indexOfColor:Color transparent) printString ,' transparentimage']) .! !!ColorForm methodsFor: 'postscript generation'!getTransparencyUnificationLUT	| lut transparentIndex |	lut _ Array new:colors size.	transparentIndex _ self indexOfColor:Color transparent.	1 to: colors size do:		[ :i | lut at:i put:(((colors at:i) = Color transparent) ifTrue:[transparentIndex] ifFalse:[i])]. ! !!ColorForm methodsFor: 'postscript generation'!mapTransparencies:transparentIndexes	^self deepCopy mapColors:transparentIndexes to:(transparentIndexes at:1).! !!ColorForm methodsFor: 'postscript generation'!printPostscript:aStream	aStream nextPutAll:'% form contains '; 			print:((colors select:[:c| c=Color transparent]) size); 			nextPutAll:' transparent colors'; cr.	^self asFormWithSingleTransparentColors printPostscript:aStream operator:(self depth=1 ifTrue:['imagemask'] 	ifFalse:[ (self indexOfColor:Color transparent) printString ,' transparentimage']) .! !!ColorForm methodsFor: 'postscript generation'!setColorspaceOn:aStream	self depth = 1 ifTrue:[		aStream print:'/DeviceRGB setcolorspace 0 setgray'; cr.	]	ifFalse:[	aStream print:'[ /Indexed /DeviceRGB ';	write:self colors size-1;	print:' <'.	(self colormapIfNeededForDepth: 32 ) storeBits:20 to:0 on:aStream.	aStream print:'> ] setcolorspace'; cr.].! !!ColorForm methodsFor: 'postscript generation'!transparentColorIndexes	^(1 to: colors size) select: [ :index | (colors at:index) isTransparent ].! !!FormCanvas methodsFor: 'other'!flushDisplay		Display deferUpdates: false; forceDisplayUpdate.! !!FormCanvas methodsFor: 'other'!forceToScreen:rect	^Display forceToScreen:rect.! !!FormCanvas methodsFor: 'other' stamp: 'mpw 8/4/1930 20:05'!warpFrom: sourceQuad toRect: destRect        ^ (WarpBlt toForm: port destForm)                combinationRule: Form paint;                sourceQuad: sourceQuad destRect: (destRect translateBy: origin);                clipRect: clipRect! !!MatrixTransform2x3 methodsFor: 'printing'!encodePostscriptOn: aStream	aStream writeMatrix:self.! !!Morph methodsFor: 'drawing'!drawOnCanvas:aCanvas	^aCanvas fullDraw:self.! !!Morph methodsFor: 'drawing' stamp: 'mpw 8/10/1930 05:21'!drawPostscriptOn: aCanvas	self drawOn:aCanvas.! !!Morph methodsFor: 'drawing'!fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"	self visible ifFalse: [^ self].	(self hasProperty: #errorOnDraw) ifTrue:[^self drawErrorOn: aCanvas].	aCanvas drawMorph: self.	self drawSubmorphsOn:aCanvas.! !!Morph methodsFor: 'drawing' stamp: 'mpw 8/10/1930 05:25'!fullDrawPostscriptOn: aCanvas	self fullDrawOn:aCanvas.! !!Morph methodsFor: 'menus'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	aMenu add:'copy Postscript' action:#clipPostscript.	self player ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	"aMenu add: 'open viewer' action: #openViewerForArgument.	(self isKindOf: MorphThumbnail) ifFalse:		[aMenu add: 'make alias' action: #makeAliasForArgument]."	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [Smalltalk imageImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	self colorSettable ifTrue:		[aMenu add: 'change color...' action: #changeColor].	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind].! !!Morph methodsFor: 'menus'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	aCustomMenu add: 'add drop-shadow' action: #addDropShadow.	aCustomMenu add: 'clip as Postscript' action: #clipPostscript.	self isSticky		ifTrue:			[aCustomMenu add: 'stop being sticky' action: #toggleStickiness]		ifFalse:			[aCustomMenu add: 'start being sticky' action: #toggleStickiness].	aCustomMenu add: 'adhere to edge...' action: #adhereToEdge! !!Morph methodsFor: 'printing'!asEPS	^EPSCanvas morphAsPostscript:self.! !!Morph methodsFor: 'printing'!asPostscript	^self asEPS.! !!Morph methodsFor: 'printing'!asPostscriptPrintJob	^DSCPostscriptCanvas morphAsPostscript:self.! !!Morph methodsFor: 'printing'!clipPostscript	^Smalltalk clipboardText:self asPostscript.! !!BookMorph methodsFor: 'drawing' stamp: 'mpw 8/10/1930 05:27'!drawPostscriptOn:aCanvas	^aCanvas drawBookMorph:self.! !!BookMorph methodsFor: 'drawing'!fullDrawPostscriptOn:aCanvas	^aCanvas drawBookMorph:self.! !!BookMorph methodsFor: 'printing'!asPostscript	^self asPostscriptPrintJob.! !!DropShadowMorph methodsFor: 'drawing'!drawOn: aCanvas	"Draw my submorphs as a shadow, then fullDrawOn will droaw them normally."	submorphs isEmpty ifTrue: [^ super drawOn: aCanvas].	aCanvas translateBy: shadowOffset during:[:shadowCanvas|		shadowCanvas setShadowDrawing; stipple: color.		self drawSubmorphsOn: shadowCanvas].! !!GradientFillMorph methodsFor: 'drawing' stamp: 'mpw 8/10/1930 05:21'!drawPostscriptOn: aCanvas	"Note that this could run about 4 times faster if we got hold of	the canvas's port and just sent it copyBits with new coords and color" 	| r colors step |	super drawOn: aCanvas.	(color isKindOf: Color) ifFalse: [^ self].  "An InfiniteForm, for example"	(color = Color transparent) ifTrue: [^ self].  "Skip the gradient attempts, which will drop into debugger"	color = fillColor2 ifTrue: [^ self].  "same color; no gradient"	r _ self innerBounds intersect: aCanvas clipRect.	colors _ self colorsArray.	step _ self stepSize.	gradientDirection = #vertical		ifTrue:		[r top to: r bottom-1 by: step do:			[:y | aCanvas fillRectangle: (r left @ y corner: r right @ (y+step min: r bottom))					color: (colors at: y - bounds top //step+1)]]		ifFalse:		[r left to: r right-1 by: step do:			[:x | aCanvas fillRectangle: (x @ r top corner: (x+step min: r right) @ r bottom)					color: (colors at: x - bounds left //step+1)]]! !!GradientFillMorph methodsFor: 'private' stamp: 'mpw 8/9/1930 09:54'!colorsArray	| range mix step colorsArray |	"We need to mix colors so as to minimize Mach bands (visible boundaries due to the fact that there is a sudden quantization change in one or more of the color components.  We use a 2x2 halftone as a simple solution.  On large areas, we only compute every fourth line for a factor of four in speed, and becuse it looks just as good.  The ideal way of doing this is by error propagation -- 1/2 the error to propagate back and forth across a word of pixels, and the other half to propagate down from one scan line to the next.  This will never be good enough with our 8-bit palette, and appears not to be needed in 16 bits."	true ifTrue:[		step _ self stepSize.		colorsArray _ Array new: (gradientDirection = #vertical				ifTrue: [bounds height+(step-1)//step]				ifFalse: [bounds width+(step-1)//step]).		range _ (colorsArray size - 1 max: 1) asFloat.		1 to: colorsArray size do:			[:i | mix _ fillColor2 mixed: (i-1) / range with: color.			colorsArray at: i put: mix]].	^ colorsArray! !!Point methodsFor: 'printing'!encodePostscriptOn:aStream 	aStream writePoint:self.! !!PolygonMorph methodsFor: 'drawing'!drawOnFormCanvas: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not		ifTrue: [aCanvas stencil: self filledForm at: bounds topLeft - 1 color: color].	(borderColor isColor and: [borderColor isTranslucentColor])		ifTrue: [aCanvas stencil: self borderForm at: bounds topLeft						color: borderColor]		ifFalse: [self drawBorderOn: aCanvas].	self arrowForms do:		[:f | aCanvas stencil: f at: f offset			color: (borderColor isColor ifTrue: [borderColor] ifFalse: [color])]! !!BalloonMorph methodsFor: 'all'!step	target ~= nil ifTrue:[self position: target position + offsetFromTarget].! !!PostscriptCanvas commentStamp: 'mpw 8/4/1930 19:44' prior: 0!I am a canvas that converts Morphic drawing messages into Postscript.  The canvas itself does not actually generate the Postscript code, but rather sends messages corresponding 1:1 to the Postscript imaging model to its target (default: PostscriptEncoder), which has the job of generating actual drawing commands.PostscriptCharacterScanner and PostscriptDummyWarp are helper classes that simulate effects currently implemented via BitBlt-specific mechanisms during Postscript generation.  They should be going away as Morphic becomes fully device independent.!!PostscriptCanvas reorganize!('printing' printContentsOn: psSize)('initialization' bounds: initializeFontMap reset resetContent writeHeader writePSIdentifier writeProcset writeSetupForRect:)('morph drawing' drawBookMorph: drawPage: drawPages: fullDrawBookMorph: setupGStateForMorph:)('misc canvas' asBalloonCanvas preserveStateDuring: setOrigin:clipRect: warpFrom:toRect:)('drawing-general' draw: fullDraw:)('drawing support' clip clipBy:during: closepath comment: comment:with: curveto:c2:final: defaultFont defineFont: drawGradient: drawPostscriptContext: fill: fill:andStroke: grestore gsave lineto: mapFontName: moveto: oval: paint:operation: postscriptFontNameForFont: rect: setColor: setFont: setLinewidth: stroke: strokepath transformBy: transformBy:clippingTo:during: translate: translateBy:clippingTo:during:)('drawing' drawPolygon:color:borderWidth:borderColor: drawRectangle:color:borderWidth:borderColor: fillColor: fillOval:color:borderWidth:borderColor: fillRectangle:color: frameAndFillRectangle:fillColor:borderWidth:borderColor: frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor: frameRectangle:width:color: image:at:sourceRect:rule: line:to:brushForm: line:to:width:color: outlinePolygon: outlineQuadratic: paragraph:bounds:color: point:color: stencil:at:color: text:bounds:font:color:)('accessing' clipRect origin)('ballon compatibility' aaLevel: drawGeneralBezierShape:color:borderWidth:borderColor:)!!PostscriptCanvas methodsFor: 'printing'!printContentsOn: aStream 	^ aStream nextPutAll: target contents! !!PostscriptCanvas methodsFor: 'printing'!psSize	^ target size! !!PostscriptCanvas methodsFor: 'initialization'!bounds:newBounds	psBounds _ newBounds.! !!PostscriptCanvas methodsFor: 'initialization'!initializeFontMap	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	fontMap _ Dictionary new: 5.	pairs _ #(		'Palatino'  'Palatino-Roman'		'NewYork' 'Helvetica'		'NewYork-Bold' 'Helvetica-Bold'		'ComicBold' 'VAGRounded-Black'	).	1 to: pairs size by: 2 do: [:i |		fontMap at: (pairs at: i) put: (pairs at: i + 1)].! !!PostscriptCanvas methodsFor: 'initialization' stamp: 'mpw 8/10/1930 21:14'!reset	super reset.	origin _ 0@0.							"origin of the top-left corner of this cavas"	clipRect _ (0@0 corner: 10000@10000).		"default clipping rectangle"	morphLevel _ 0.	gstateStack _ OrderedCollection new.	self initializeFontMap.	usedFonts _ Set new.     ^self.! !!PostscriptCanvas methodsFor: 'initialization'!resetContent	target _ self class defaultTarget.	self writeHeader.     ^self.! !!PostscriptCanvas methodsFor: 'initialization'!writeHeader	self writePSIdentifier.	self writeProcset.! !!PostscriptCanvas methodsFor: 'initialization'!writePSIdentifier	target print:'%!!'; cr.! !!PostscriptCanvas methodsFor: 'initialization'!writeProcset	target print:'%%BeginProcset: Squeak-Printing/textclip { rectclip } bind def/_showpageSqueak /showpage load def/showpage { gsave _showpageSqueak grestore } bind def/transparentimage {  gsave  32 dict begin  /tinteger exch def  /transparent 1 string def  transparent 0 tinteger put  /olddict exch def  olddict /DataSource get dup type /filetype ne {    olddict /DataSource 3 -1 roll 0 () /SubFileDecode filter put  } {    pop  } ifelse  /newdict olddict maxlength dict def  olddict newdict copy pop  /w newdict /Width get def  /str w string def  /substrlen 2 w log 2 log div floor exp cvi def  /substrs [  {     substrlen string     0 1 substrlen 1 sub {       1 index exch tinteger put     } for     /substrlen substrlen 2 idiv def     substrlen 0 eq {exit} if  } loop  ] def  /h newdict /Height get def  1 w div 1 h div matrix scale  olddict /ImageMatrix get exch matrix concatmatrix  matrix invertmatrix concat  newdict /Height 1 put  newdict /DataSource str put  /mat [w 0 0 h 0 0] def  newdict /ImageMatrix mat put  0 1 h 1 sub {    mat 5 3 -1 roll neg put    olddict /DataSource get str readstring pop pop    /tail str def    /x 0 def    {      tail transparent search dup /done exch not def      {exch pop exch pop} if      /w1 1 index length def      w1 0 ne {        newdict /DataSource 3 -1 roll put        newdict /Width w1 put        mat 4 x neg put        /x x w1 add def        newdict image        /tail tail w1 tail length w1 sub getinterval def      } if      done {exit} if      tail substrs {        anchorsearch {pop} if      } forall      /tail exch def      tail length 0 eq {exit} if      /x w tail length sub def    } loop  } for  end  grestore} bind def/copydict {	dup length dict begin 		 { 1 index /FID eq {pop pop} {  def  } ifelse } forall	currentdict end} bind def/getSymbolcharproc {	1 dict begin 		/charstring exch def 	 [ 550 0 0 0 650 600 /setcachedevice cvx 50 100 /translate cvx  /pop cvx 		<< /setbbox { pop pop pop } bind >> /begin cvx   		gsave  /Symbol 600 selectfont 0 0 moveto charstring false charpath false upath grestore	 /exec cvx /fill cvx /end cvx ] cvx bind 	end} bind def/adjustFontForSqueak		% converts _ to left-arrow, ^to upArrow and tab -> 4 spaces{ 	gsave dup 1000 selectfont	dup dup findfont copydict	begin	CharStrings 	/CharStrings exch copydict	dup /leftarrow (\254) getSymbolcharproc  put	dup /uparrow (\255) getSymbolcharproc  put	dup /tab [ /pop cvx ( ) stringwidth pop 4 mul 0 0 0 0 0  /setcachedevice cvx ] cvx bind  put	def	/Encoding Encoding dup length array copy 	dup 94 /uparrow put	dup 95 /leftarrow put	dup 9 /tab put	def	currentdict end definefont pop	grestore} bind def%%endProcset'.! !!PostscriptCanvas methodsFor: 'initialization'!writeSetupForRect:aRect	target translate: 0 @ aRect extent y;			scale:1 @ -1;		print:' [ {true setstrokeadjust} stopped ] pop[ currenttransfer /exec cvx 1.2 /exp cvx ] cvx bind  settransfer'; cr.! !!PostscriptCanvas methodsFor: 'morph drawing'!drawBookMorph:aBookMorph	^self fullDraw:aBookMorph.! !!PostscriptCanvas methodsFor: 'morph drawing' stamp: 'mpw 8/10/1930 05:44'!drawPage:aMorph	self fullDrawMorph:aMorph.	target showpage.! !!PostscriptCanvas methodsFor: 'morph drawing'!drawPages:collectionOfPages	| currentPage |	currentPage _ 0.	collectionOfPages do:[ :page |		currentPage _ currentPage + 1.		target print:'%%Page: '; write:currentPage; space; write:currentPage; cr.		self drawPage:page.	].	target print:'%%Pages: '; write:currentPage; cr.! !!PostscriptCanvas methodsFor: 'morph drawing' stamp: 'mpw 8/10/1930 05:42'!fullDrawBookMorph:aBookMorph	^aBookMorph fullDrawOn:self.! !!PostscriptCanvas methodsFor: 'morph drawing'!setupGStateForMorph:aMorph.! !!PostscriptCanvas methodsFor: 'misc canvas'!asBalloonCanvas     ^self.! !!PostscriptCanvas methodsFor: 'misc canvas'!preserveStateDuring:aBlock	| retval |     self gsave.	retval _ aBlock value:self.     self grestore.		^retval! !!PostscriptCanvas methodsFor: 'misc canvas'!setOrigin: aPoint clipRect: aRectangle	self comment:'new origin: ' with:aPoint.	target rectclip:aRectangle.	self translate:aPoint - origin."	self grestore; gsave.	self write:aRectangle.	target print:' textclip'; cr.	target print:'% new offset '.	target write:aPoint.	target cr."	super setOrigin: aPoint clipRect: aRectangle.! !!PostscriptCanvas methodsFor: 'misc canvas' stamp: 'mpw 8/4/1930 20:11'!warpFrom: sourceQuad toRect: innerRect	"^PostscriptDummyWarp canvas:self."! !!PostscriptCanvas methodsFor: 'drawing-general' stamp: 'mpw 8/10/1930 05:23'!draw: anObject	^anObject drawPostscriptOn: self! !!PostscriptCanvas methodsFor: 'drawing-general' stamp: 'mpw 8/10/1930 06:20'!fullDraw:aMorph	self comment:'begin morph: ' with:aMorph.	self comment:'level: ' with:morphLevel.	morphLevel_morphLevel+1.	self gsave.	self setupGStateForMorph:aMorph.	aMorph fullDrawPostscriptOn:self.	self grestore.	morphLevel_morphLevel-1.	self comment:'end morph: ' with:aMorph.	self comment:'level: ' with:morphLevel.	! !!PostscriptCanvas methodsFor: 'drawing support'!clip		^target clip.! !!PostscriptCanvas methodsFor: 'drawing support' stamp: 'mpw 6/22/1930 22:37'!clipBy: aRectangle during: aBlock	^self translateBy: 0@0 clippingTo: aRectangle during: aBlock.! !!PostscriptCanvas methodsFor: 'drawing support' stamp: 'mpw 8/3/1930 08:39'!closepath	^target closepath.              ! !!PostscriptCanvas methodsFor: 'drawing support'!comment:aString	target comment:aString.! !!PostscriptCanvas methodsFor: 'drawing support'!comment:aString with:anObject	target comment:aString with:anObject.! !!PostscriptCanvas methodsFor: 'drawing support'!defaultFont	^(TextStyle default) fontAt:1.! !!PostscriptCanvas methodsFor: 'drawing support'!defineFont:aFont	(usedFonts contains:aFont) ifFalse:[		usedFonts add:aFont.		" here: define as Type-3 unless we think its available "		" or, just remap"		target remapFontForSqueak:(self postscriptFontNameForFont:aFont).	].! !!PostscriptCanvas methodsFor: 'drawing support'!drawGradient:fillColor	 self comment:'not-solid fill ' with:fillColor.	 self comment:' origin ' with:fillColor origin.	 self comment:' direction ' with:fillColor direction.	self fill:fillColor asColor.              ! !!PostscriptCanvas methodsFor: 'drawing support' stamp: 'mpw 8/4/1930 09:21'!drawPostscriptContext:subCanvas	| contents |	contents _ subCanvas contents.	contents ifNotNil:[		^target comment:' sub-canvas start';			gsave;			print:subCanvas contents;			grestore;			comment:'sub-canvas stop'.		].! !!PostscriptCanvas methodsFor: 'drawing support'!fill:fillColor	fillColor isSolidFill ifTrue:[		self paint:fillColor asColor operation:#fill.	] ifFalse: [		 self gsave.		 self clip.		 self drawGradient:fillColor.		 self grestore.	].	              ! !!PostscriptCanvas methodsFor: 'drawing support'!fill:fillColor andStroke:strokeColor	self gsave;		fill:fillColor;		grestore;		stroke:strokeColor.! !!PostscriptCanvas methodsFor: 'drawing support'!grestore     target safeGrestore.	currentColor _ gstateStack removeLast.	currentFont _ gstateStack removeLast.              ! !!PostscriptCanvas methodsFor: 'drawing support'!gsave     target gsave.	gstateStack addLast:currentFont.	gstateStack addLast:currentColor.              ! !!PostscriptCanvas methodsFor: 'drawing support'!lineto:aPoint	^target lineto:aPoint.              ! !!PostscriptCanvas methodsFor: 'drawing support'!mapFontName:fontName	^ fontMap at:fontName ifAbsent:[fontName].! !!PostscriptCanvas methodsFor: 'drawing support'!moveto:aPoint	^target moveto:aPoint.              ! !!PostscriptCanvas methodsFor: 'drawing support'!oval:aPoint	^target oval:aPoint.! !!PostscriptCanvas methodsFor: 'drawing support'!paint:color operation:operation	self setColor:color.	currentColor isTransparent ifFalse:[target perform:operation] ifTrue:[target newpath].              ! !!PostscriptCanvas methodsFor: 'drawing support'!postscriptFontNameForFont:font	| fontName |	fontName _ font familyName asString.	font emphasis == 1 ifTrue:[		fontName _ fontName,'-Bold'.	].	^self mapFontName:fontName.! !!PostscriptCanvas methodsFor: 'drawing support'!rect:aRect	^target rect:aRect.! !!PostscriptCanvas methodsFor: 'drawing support'!setColor: color      currentColor ~= color ifTrue:[          target write:color asColor.		currentColor _ color.	].! !!PostscriptCanvas methodsFor: 'drawing support'!setFont:aFont	aFont ~= currentFont ifTrue:[		currentFont _ aFont.		self defineFont:aFont.		target selectflippedfont:(self postscriptFontNameForFont:aFont) size:aFont height * 0.9 ascent:aFont ascent.				" the 0.9 is obviously a fudge factor.  I have to figure out how 				  to figure out the actual font-size to request, neither #ascent nor #height				  are correct." 	]! !!PostscriptCanvas methodsFor: 'drawing support'!setLinewidth: width 	target setLinewidth: width.! !!PostscriptCanvas methodsFor: 'drawing support'!stroke:strokeColor	strokeColor ifNotNil:[		strokeColor isSolidFill ifTrue:[			self paint:strokeColor asColor operation:#stroke.		] ifFalse: [			 self gsave.			 self strokepath.			 self fill:strokeColor.			 self grestore.		].	].	              ! !!PostscriptCanvas methodsFor: 'drawing support'!strokepath	^target strokepath.              ! !!PostscriptCanvas methodsFor: 'drawing support' stamp: 'mpw 8/4/1930 12:13'!transformBy:aMatrix	("aMatrix isPureTranslation" false) ifTrue:[		target translate:aMatrix offset negated.	] ifFalse:[		target  concat:aMatrix.	].	^self.! !!PostscriptCanvas methodsFor: 'drawing support' stamp: 'mpw 8/4/1930 12:08'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	| retval |	self comment:'drawing clipped ' with:aClipRect.	self comment:'drawing transformed ' with:aDisplayTransform.     self gsave;		rect:aClipRect; clip;		transformBy:aDisplayTransform.	retval _ aBlock value:self.     self grestore.		self comment:'end of drawing clipped ' with:aClipRect.	^retval! !!PostscriptCanvas methodsFor: 'drawing support'!translate:aPoint	^target translate:aPoint.              ! !!PostscriptCanvas methodsFor: 'drawing support' stamp: 'mpw 8/4/1930 12:07'!translateBy: delta clippingTo: aRect during: aBlock	self comment:'translateBy: ' with:delta.	^self transformBy:(MatrixTransform2x3 withOffset:delta) clippingTo:aRect during:aBlock.! !!PostscriptCanvas methodsFor: 'drawing' stamp: 'mpw 8/4/1930 09:45'!drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc	self outlinePolygon:vertices.	self fill:aColor andStroke:bc.! !!PostscriptCanvas methodsFor: 'drawing'!drawRectangle: r		color: color		borderWidth: borderWidth		borderColor: borderColor.	^self frameAndFillRectangle: r fillColor: color borderWidth: borderWidth borderColor: borderColor .! !!PostscriptCanvas methodsFor: 'drawing'!fillColor:aColor	self rect:clipRect; fill:aColor.! !!PostscriptCanvas methodsFor: 'drawing'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor 	self	oval:r;		setLinewidth:borderWidth;		fill:c andStroke:borderColor.			! !!PostscriptCanvas methodsFor: 'drawing'!fillRectangle: r color: c	self rect:r; fill:c.! !!PostscriptCanvas methodsFor: 'drawing'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor 	self setLinewidth:borderWidth; 	 	rect:r;		fill:fillColor andStroke:borderColor.! !!PostscriptCanvas methodsFor: 'drawing'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor  	self setLinewidth:borderWidth; 	 	rect:r;		fill:fillColor andStroke:topLeftColor.	"Now draw bottom right border.	Note: Must inset this manually!!"	self comment:'draw inset border'.	self setLinewidth:0.	0 to: borderWidth-1 do:[ :offset |		target comment:'drawing inset: ' with:offset.		self moveto:r topRight + ( offset negated @ offset ); 			lineto:r bottomRight + ( offset negated @ offset negated );			lineto:r bottomLeft + ( offset @ offset negated ).		self stroke:bottomRightColor	]! !!PostscriptCanvas methodsFor: 'drawing'!frameRectangle: r width: w color: c 	self rect:r; stroke:c.! !!PostscriptCanvas methodsFor: 'drawing' stamp: 'mpw 8/3/1930 07:40'!image: aForm at: aPoint sourceRect: sourceRect rule: rule 	self gsave; translate:aPoint + self origin.	target write:aForm.	self grestore.! !!PostscriptCanvas methodsFor: 'drawing'!line: pt1 to: pt2 brushForm: brush 	" to do: set brushform "	self moveto:pt1; lineto:pt2; stroke:currentColor. ! !!PostscriptCanvas methodsFor: 'drawing'!line: pt1 to: pt2 width: w color: c 	self setLinewidth:w; moveto:pt1; lineto:pt2; stroke:c. 	! !!PostscriptCanvas methodsFor: 'drawing'!paragraph: para bounds: bounds color: c 	self comment:'paragraph with bounds: ' with:bounds.	self gsave.	para		displayOn: self		using: (PostscriptCharacterScanner scannerWithCanvas:self paragraph:para bounds:bounds)		at: bounds topLeft.	self grestore.! !!PostscriptCanvas methodsFor: 'drawing'!point: p color: c 	"Noop here; overridden by non-trivial canvases."	^ self! !!PostscriptCanvas methodsFor: 'drawing'!stencil: stencilForm at: aPoint color: aColor	target comment:' imagemask'.! !!PostscriptCanvas methodsFor: 'drawing'!text: s bounds: boundsRect font: fontOrNil color: c 	self setFont:(fontOrNil ifNil:[self defaultFont]).	self comment:' text color: ',c printString.	self setColor:c.	self comment:' boundsrect origin ', boundsRect origin printString.	self comment:'  origin ',  origin printString.     self moveto: (boundsRect origin ).	target print:' (';     	 print:s asPostscript;		print:') show';		 cr.! !!PostscriptCanvas methodsFor: 'accessing' stamp: 'mpw 8/3/1930 07:36'!clipRect	^clipRect.! !!PostscriptCanvas methodsFor: 'accessing' stamp: 'mpw 8/3/1930 07:35'!origin	^origin.! !!DSCPostscriptCanvas commentStamp: 'mpw 8/4/1930 19:55' prior: 0!I generate multi-page Postscript files, for example of Book morphs.  The goal is to crete Adobe Document Structuring Conventions compliant, but this is currently not the case.!!DSCPostscriptCanvas methodsFor: 'as yet unclassified' stamp: 'mpw 8/4/1930 19:56'!defaultPageSize	" This is European A4 size in points.  Letter is 612 @ 792 "	^ 0 @ 0 extent: 595 @ 842.! !!DSCPostscriptCanvas methodsFor: 'as yet unclassified' stamp: 'mpw 8/4/1930 19:56'!drawBookMorph:aBookMorph	" draw all the pages in a book morph, but only if it is the top-level morph "	morphLevel == 0 ifTrue:[		self drawPages:aBookMorph pages.	] ifFalse:[		^self fullDraw:aBookMorph.	].	target print:'%%EOF'; cr.! !!DSCPostscriptCanvas methodsFor: 'as yet unclassified' stamp: 'mpw 8/10/1930 05:43'!fullDrawBookMorph:aBookMorph	" draw all the pages in a book morph, but only if it is the top-level morph "	morphLevel == 0 ifTrue:[		self drawPages:aBookMorph pages.	] ifFalse:[		^super fullDrawBookMorph:aBookMorph.	].	target print:'%%EOF'; cr.! !!DSCPostscriptCanvas methodsFor: 'as yet unclassified'!pageBBox	| pageSize offset bbox |	pageSize _ self defaultPageSize.	offset _ (pageSize extent x - psBounds extent x) / 2 @ 			((pageSize extent y - psBounds extent y) /2 ).	bbox _ offset extent:psBounds extent.	^bbox! !!DSCPostscriptCanvas methodsFor: 'as yet unclassified'!pageOffset	|  offset  |	offset _ self pageBBox origin.	^ offset x @ offset y negated.! !!DSCPostscriptCanvas methodsFor: 'as yet unclassified' stamp: 'mpw 8/4/1930 19:57'!setupGStateForMorph:aMorph	" position the morph on the page  "	morphLevel == 1 ifTrue:[ 		self writeSetupForRect:aMorph bounds.		target translate:self pageOffset.		target translate:aMorph bounds origin negated.	].! !!DSCPostscriptCanvas methodsFor: 'as yet unclassified' stamp: 'mpw 8/4/1930 19:58'!writePSIdentifier	^target print:'%!!'; cr.	" cannot use the DSC-compliance header yet!! "	" target	print:'%!!PS-Adobe-2.0'; cr; 			print:'%%Pages: (atend)'; cr;			print:'%%BoundingBox: '; write:self pageBBox rounded; cr;			print:'%%EndComments'; cr. "! !!EPSCanvas commentStamp: 'mpw 8/4/1930 19:53' prior: 0!I am a canvas for generating Encapsulates PostScript (EPS) files from single morphs, for example for screen-dumps.I make sure that the bounding box of the EPS surrounds exactly the morph, and am not capable of generating multiple pages.  I do not generate an on-screen Preview for the EPS file, though that should be possible.!!EPSCanvas methodsFor: 'as yet unclassified' stamp: 'mpw 6/22/1930 22:52'!setupGStateForMorph:aMorph.	target comment:'setupGState in EPSCanvas'.	morphLevel == 1 ifTrue:[ 		self writeSetupForRect:aMorph bounds.		target translate:aMorph bounds origin negated.	].! !!EPSCanvas methodsFor: 'as yet unclassified'!writePSIdentifier	target print:'%!!PS-Adobe-2.0 EPSF-1.2'; cr;		print:'%%BoundingBox: '; write:psBounds rounded; cr.! !!PostscriptCanvas class reorganize!('testing' morphAsPostscript: worldAsPostscript)('configuring' defaultTarget filterSelector)('creating')!!PostscriptCanvas class methodsFor: 'testing' stamp: 'mpw 8/10/1930 06:28'!morphAsPostscript:aMorph | psCanvas |  psCanvas _ self new.  psCanvas reset.  psCanvas bounds:(0 @ 0 extent:aMorph bounds extent).  psCanvas resetContent.  psCanvas fullDrawMorph: aMorph .  ^psCanvas contents.! !!PostscriptCanvas class methodsFor: 'testing'!worldAsPostscript     ^self morphAsPostscript:World.! !!PostscriptCanvas class methodsFor: 'configuring'!defaultTarget	^PostscriptEncoder stream.! !!PostscriptCanvas class methodsFor: 'configuring'!filterSelector	^#fullDrawPostscriptOn:.! !!PostscriptCharacterScanner commentStamp: '<historical>' prior: 0!I am a simple character scanner that forwards text-drawing commands to my canvas.  Despite the name, it should also work with other Canvases that actually implement the text-drawing commands (which the basic FormCanvas does not).Style text support currently includes color, centering, fonts and emphasis.  Not yet supported are embedded objects, full justification and probably some others as well.Tabs aren't supported properly, but rather hacked in the Postscript Header provided by PostscriptCanvas to be equivalent to 4 space.mpw.!!PostscriptCharacterScanner reorganize!('accessing' bounds: canvas canvas: defaultFont font paragraph paragraph: setDestForm: textStyle)('displaying' displayLine:offset:leftInRun:)('textstyle support' addEmphasis: addKern: indentationLevel: placeEmbeddedObject: setActualFont: setFont: setTextStylesForOffset: textColor:)!!PostscriptCharacterScanner methodsFor: 'accessing'!bounds:newBounds    bounds_newBounds.    curPos_newBounds origin.	! !!PostscriptCharacterScanner methodsFor: 'accessing'!canvas	^canvas.	! !!PostscriptCharacterScanner methodsFor: 'accessing'!canvas:newCanvas    canvas_newCanvas.	! !!PostscriptCharacterScanner methodsFor: 'accessing'!defaultFont	^(TextStyle default) fontAt:1.! !!PostscriptCharacterScanner methodsFor: 'accessing'!font	^ font ifNil:[self defaultFont].! !!PostscriptCharacterScanner methodsFor: 'accessing'!paragraph	^paragraph.	! !!PostscriptCharacterScanner methodsFor: 'accessing'!paragraph:newPara    paragraph_newPara.	! !!PostscriptCharacterScanner methodsFor: 'accessing' stamp: 'mpw 8/4/1930 09:09'!setDestForm:destForm	"dummy"! !!PostscriptCharacterScanner methodsFor: 'accessing'!textStyle	^paragraph textStyle.! !!PostscriptCharacterScanner methodsFor: 'displaying'!displayLine: line offset: baseOffset leftInRun: leftInRun   | drawFont offset |   self setTextStylesForOffset:((line first) + 1).		" sets up various instance vars from text styles "   drawFont _ self font.   offset _ baseOffset.   offset _ offset + (bounds origin x @ (line top + line baseline - drawFont ascent )).    offset _ offset + ((self textStyle alignment caseOf:{	[2] -> [ line paddingWidth /2 ].	[1] -> [ line paddingWidth ] } otherwise:[0]) @ 0).   " missing: support for justified text "   canvas text: ((paragraph string) copyFrom:line first to:line last)            at:  offset             font:drawFont            color:foregroundColor.! !!PostscriptCharacterScanner methodsFor: 'textstyle support'!addEmphasis: emphasisCode	emphasis _ emphasisCode.! !!PostscriptCharacterScanner methodsFor: 'textstyle support'!addKern: kern	" canvas comment:'kern now: ',kern printString. "! !!PostscriptCharacterScanner methodsFor: 'textstyle support'!indentationLevel: amount	" canvas comment:'indentation level ',amount printString. "! !!PostscriptCharacterScanner methodsFor: 'textstyle support'!placeEmbeddedObject: anchoredMorph! !!PostscriptCharacterScanner methodsFor: 'textstyle support'!setActualFont: newFont	font _ newFont.! !!PostscriptCharacterScanner methodsFor: 'textstyle support'!setFont: fontNumber	self setActualFont:(self textStyle fontAt:fontNumber).! !!PostscriptCharacterScanner methodsFor: 'textstyle support'!setTextStylesForOffset:offset	" default text style "	font _ self textStyle fontAt:1.	emphasis _ 0.	foregroundColor _ Color black.	" set text styles defined at this point, these methods will set instance vars of myself "	(paragraph text attributesAt: offset) do: 		[:att | att emphasizeScanner: self].	" post-processing of 'emphasis' "	self setActualFont:( font emphasized: emphasis).! !!PostscriptCharacterScanner methodsFor: 'textstyle support'!textColor: aColor	foregroundColor _ aColor.! !!PostscriptCharacterScanner class methodsFor: 'as yet unclassified'!scannerWithCanvas:aCanvas paragraph:aParagraph bounds:newBounds    ^self new canvas:aCanvas; paragraph:aParagraph; bounds:newBounds. ! !!PostscriptDummyWarp commentStamp: '<historical>' prior: 0!I simulate the effects of having a WarpBlit done in Postscript, by simply adjusting the coordinat system.!!PostscriptDummyWarp reorganize!('dummy' canvas canvas: cellSize: colorMap: combinationRule: drawPostscriptContext: grestore gsave sourceForm: sourceQuad:destRect: subCanvas: transform transform: transformBy: warpBits)!!PostscriptDummyWarp methodsFor: 'dummy'!canvas	^canvas! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'mpw 8/4/1930 09:19'!canvas:newCanvas	canvas _ newCanvas.! !!PostscriptDummyWarp methodsFor: 'dummy'!cellSize:newCellSize	^self.! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'mpw 8/4/1930 09:09'!colorMap:aMap! !!PostscriptDummyWarp methodsFor: 'dummy'!combinationRule:newRule	^self.! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'mpw 8/4/1930 09:12'!drawPostscriptContext:aCanvas	canvas drawPostscriptContext:aCanvas.! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'mpw 8/4/1930 09:12'!grestore	canvas grestore.! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'mpw 8/4/1930 09:11'!gsave	canvas gsave.! !!PostscriptDummyWarp methodsFor: 'dummy'!sourceForm:newForm	^self.! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'mpw 8/4/1930 09:10'!sourceQuad:aQuad destRect:aRect! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'mpw 8/10/1930 21:02'!subCanvas:patchRect	subCanvas ifNil:		[ subCanvas _ PostscriptCanvas new reset setOrigin:patchRect topLeft clipRect:(-10000@-10000 extent:20000@20000)].	^subCanvas.! !!PostscriptDummyWarp methodsFor: 'dummy'!transform	^transform.! !!PostscriptDummyWarp methodsFor: 'dummy'!transform:newTransform	transform _ newTransform.	^self.! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'mpw 8/4/1930 09:11'!transformBy:aTransform	canvas transformBy:aTransform.! !!PostscriptDummyWarp methodsFor: 'dummy'!warpBits	canvas gsave.	transform ~= nil ifTrue: [ canvas transformBy:transform ].	canvas drawPostscriptContext:subCanvas.	canvas grestore.	^self. ! !!PostscriptDummyWarp class methodsFor: 'as yet unclassified' stamp: 'mpw 8/4/1930 09:18'!canvas:aCanvas	^self new canvas:aCanvas.! !!PostscriptEncoder commentStamp: 'mpw 8/4/1930 19:41' prior: 0!I translate the message protocol generated by PostscriptCanvas that represents the Postscript imaging model into an actual stream of ASCII-encoded Postscript Level 2.Alternative implementations might provide binary representations, Level I or Level III or even PDF.!!PostscriptEncoder methodsFor: 'Postscript generation' stamp: 'mpw 8/10/1930 21:34'!clip	self print:'clip newpath'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!closepath	self print:'closepath'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!comment:aString	self print:'%'; print:aString; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!comment:aString with:anObject	self print:'%'; print:aString; print:' '; write:anObject; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!concat:aMatrix	self write:aMatrix asMatrixTransform2x3; print:' concat'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!fill	self print:'fill'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!grestore	self print:'grestore'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!gsave	self print:'gsave'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!lineto:aPoint	self write:aPoint; print:' lineto'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!moveto:aPoint	self write:aPoint; print:' moveto'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!newpath	self print:'newpath'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!oval:aPoint	self print:'matrix currentmatrix'; cr.	self gsave;	write:(aPoint extent // 2); space;	write:aPoint topLeft;	print:' newpath translate scale 1 1 1 0 360 arc setmatrix'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!rect:aRect	self moveto:aRect topLeft;		lineto:aRect topRight x @ aRect topRight y;		lineto:aRect bottomRight x @ aRect bottomRight y;		lineto:aRect bottomLeft x @ aRect bottomLeft y;		closepath.! !!PostscriptEncoder methodsFor: 'Postscript generation'!rectclip:aRect	self write:aRect; print:' rectclip'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!rectfill:aRect	self write:aRect; print:' rectfill'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!remapFontForSqueak:aFontName	self print:'/'; print:aFontName; print:' adjustFontForSqueak'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!safeGrestore	self print:'{ grestore } stopped pop'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!scale:aPoint	self write:aPoint; print:' scale'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!selectflippedfont:fontname size:size	self selectflippedfont:fontname size:size ascent:size.! !!PostscriptEncoder methodsFor: 'Postscript generation'!selectflippedfont:fontname size:size ascent:ascent	self print:'/'; print:fontname; space; 		print:'[ '; write:size; print:' 0 0 ';write:size negated; print:' 0 '; write:ascent; print:'] selectfont'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!selectfont:fontname size:size	self print:'/'; print:fontname; space; write:size; print:' selectfont'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!setLinewidth:width	self write:width; print:' setlinewidth';cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!setrgbcolor:aColor	self write:aColor red; space;		 write:aColor green; space;		write:aColor blue; 		print:' setrgbcolor'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation' stamp: 'mpw 8/10/1930 21:34'!showpage	self print:'showpage'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!stroke	self print:'stroke'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation' stamp: 'mpw 8/10/1930 21:34'!strokepath	self print:'strokepath'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!translate:aPoint	self write:aPoint; print:' translate'; cr.! !!PostscriptEncoder methodsFor: 'Postscript generation'!writeMatrix:m	self print:'[';		write:m a11; print:' ';		write:m a21; print:' ';		write:m a12; print:' ';		write:m a22; print:' ';		write:m a13; print:' ';		write:m a23; print:'] '.! !!PostscriptEncoder methodsFor: 'Postscript generation'!writeNumber:aNumber	super writeNumber:(aNumber roundTo:0.001).! !!PostscriptEncoder methodsFor: 'Postscript generation'!writePoint:aPoint	self write:aPoint x; space; write:aPoint y.! !!PostscriptEncoder class methodsFor: 'configuring'!filterSelector	^#encodePostscriptOn:.! !!Rectangle methodsFor: 'printing' stamp: 'mpw 8/9/1930 08:00'!encodePostscriptOn:aStream 	aStream write:self origin; print:' '; write:self extent; print:' '.! !!StrikeFont methodsFor: 'accessing'!familyName	^self name withoutTrailingDigits.! !!String methodsFor: 'converting'!asPostscript	| temp |	temp _ self asString copyReplaceAll: '(' with: '\('.	temp _ temp copyReplaceAll: ')' with: '\)'.	temp _ temp copyReplaceAll: '' 			with: ''.	^ temp! !!String methodsFor: 'converting'!withoutTrailingDigits	"Answer the portion of the receiver that precedes any trailing series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstDigit |	firstDigit _ (self findFirst: [:m | m isDigit or: [m == $ ]]).	^ firstDigit > 0		ifTrue:			[self copyFrom: 1   to: firstDigit-1]		ifFalse:			[self]"'Whoopie234' withoutTrailingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!TextMorph methodsFor: 'drawing'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size		ifTrue: [self drawNullTextOn: aCanvas]		ifFalse: [aCanvas paragraph: self paragraph bounds: bounds color: color].! !!TransformMorph methodsFor: 'drawing'!drawSubmorphsOn: aCanvasaCanvas transformBy: transform				clippingTo: self innerBounds				during:[:myCanvas| submorphs reverseDo:[:m | myCanvas fullDrawMorph: m] ].! !Object removeSelector: #drawPostscriptOn:!GradientFillMorph removeSelector: #drawOnPostscriptCanvas:!GradientFillMorph removeSelector: #fullDrawPostscriptOn:!GradientFillMorph removeSelector: #fullDrawOnPostscriptCanvas:!PostscriptCanvas removeSelector: #fullDrawGradientMorph:!PostscriptCanvas removeSelector: #cllipRect!