'From Squeak2.9alpha of 12 June 2000 [latest update: #2466] on 31 July 2000 at 8:51:41 pm'!"Change Set:		MSecClockMaskDate:			31 July 2000Author:			Andreas RaabThis change set makes the millisecond clock mask a class variable in Interpreter and fixes the methods that formerly used the value explicitly."!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP localHomeContext messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache atCache lkupClass reclaimableContextCount nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignalA semaphoresUseBufferA semaphoresToSignalCountA semaphoresToSignalB semaphoresToSignalCountB savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals compilerInitialized compilerHooks extraVMMemory interpreterVersion obsoleteIndexedPrimitiveTable obsoleteNamedPrimitiveTable interpreterProxy showSurfaceFn interruptCheckCounterFeedBackReset interruptChecksEveryNms '	classVariableNames: 'ActiveProcessIndex AtCacheEntries AtCacheFixedFields AtCacheFmt AtCacheMask AtCacheOop AtCacheSize AtCacheTotalSize AtPutBase BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex CompilerHooksSize CrossedX DirBadPath DirEntryFound DirNoMoreEntries EndOfRun ExcessSignalsIndex FirstLinkIndex GenerateBrowserPlugin HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageLookupClassIndex MessageSelectorIndex MethodArrayIndex MethodCacheClass MethodCacheEntries MethodCacheEntrySize MethodCacheMask MethodCacheMethod MethodCachePrim MethodCacheSelector MethodCacheSize MethodIndex MillisecondClockMask MyListIndex NextLinkIndex PrimitiveExternalCallIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'VMConstruction-Interpreter'!!Interpreter methodsFor: 'primitive support' stamp: 'ar 7/30/2000 17:39'!primitiveResponse	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| timerPending startTime |	timerPending _ nextWakeupTick ~= 0.	timerPending ifTrue: [startTime _ self ioLowResMSecs].	successFlag _ true.	self dispatchOn: primitiveIndex in: PrimitiveTable.	timerPending ifTrue: [		(self ioLowResMSecs ~= startTime) ifTrue: [			"primitive ran for more than a tick; check for possible timer interrupts"			((self ioMSecs bitAnd: MillisecondClockMask) >= nextWakeupTick) ifTrue: [				successFlag					ifTrue: ["process the interrupt now"							self checkForInterrupts]					ifFalse: ["process the interrupt in primtive failure code"							interruptCheckCounter _ 0]]]].	^ successFlag! !!Interpreter methodsFor: 'processes' stamp: 'ar 7/30/2000 17:37'!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now |	self inline: false.	"Mask so same wrap as primitiveMillisecondClock"	now _ self ioMSecs bitAnd: MillisecondClockMask. 	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	(now - lastTick) < interruptChecksEveryNms ifTrue: "wrapping is not a concern"	    [interruptCheckCounterFeedBackReset _ interruptCheckCounterFeedBackReset + 10]	ifFalse: 		[interruptCheckCounterFeedBackReset <= 1000 			ifTrue: [interruptCheckCounterFeedBackReset _ 1000]			ifFalse: [interruptCheckCounterFeedBackReset _ interruptCheckCounterFeedBackReset - 12]].	interruptCheckCounter _ interruptCheckCounterFeedBackReset.  "reset the interrupt check counter"	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	"signal any pending finalizations"	pendingFinalizationSignals > 0 ifTrue:[		sema _ self splObj: TheFinalizationSemaphore.		(self fetchClassOf: sema) = (self splObj: ClassSemaphore) 			ifTrue:[self synchronousSignal: sema].		pendingFinalizationSignals _ 0.	].	"signal all semaphores in semaphoresToSignal" 	(semaphoresToSignalCountA > 0 or: [semaphoresToSignalCountB > 0])		ifTrue: [self signalExternalSemaphores].! !!Interpreter methodsFor: 'other primitives' stamp: 'ar 7/30/2000 17:38'!primitiveMillisecondClock	"Return the value of the millisecond clock as an integer. Note that the millisecond clock wraps around periodically. On some platforms it can wrap daily. The range is limited to SmallInteger maxVal / 2 to allow delays of up to that length without overflowing a SmallInteger."	self pop: 1.  "pop rcvr"	self push: (self integerObjectOf: (self ioMSecs bitAnd: MillisecondClockMask)).! !!Interpreter class methodsFor: 'initialization' stamp: 'ar 7/30/2000 17:36'!initialize	"Interpreter initialize"	super initialize.  "initialize ObjectMemory constants"	self initializeAssociationIndex.	self initializeBytecodeTable.	self initializeCaches.	self initializeCharacterIndex.	self initializeClassIndices.	self initializeCompilerHooks.	self initializeContextIndices.	self initializeDirectoryLookupResultCodes.	self initializeMessageIndices.	self initializeMethodIndices.	self initializePointIndices.	self initializePrimitiveTable.	self initializeSchedulerIndices.	self initializeSmallIntegers.	self initializeStreamIndices.	SemaphoresToSignalSize _ 500.	PrimitiveExternalCallIndex _ 117. "Primitive index for #primitiveExternalCall"	GenerateBrowserPlugin _ false.	MillisecondClockMask _ 16r1FFFFFFF.! !Interpreter initialize!