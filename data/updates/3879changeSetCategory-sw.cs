'From Squeak3.1alpha of 28 February 2001 [latest update: #3890] on 30 March 2001 at 10:53:44 pm'!"Change Set:		changeSetCategory-swDate:			30 March 2001Author:			Scott WallaceIntroduces the notion of a change-set-category.  ChangeSorters can now be pointed at any such category.  By default, a ChangeSorter looks at the 'All' category, thus tshows all change sets known to the system.  But if you choose a different category, such as numbered change sets, you can narrow your view of change sets.New features added to change-sorters: * 'check for unclassified methods' -  identifies methods that have not been put into a category.* 'conflicts with category opposite' - finds all conflicts between methods in the selected change set and *any* change set on the opposite side of a dual change sorter.* 'file out category's change sets' -- files out *all* the change sets in a category.* 'set recent-updates marker' -- used in conjunction with the change-set-category named RecentUpdates, this lets you determine which update numbers should be considered 'recent'.* 'fill aggregate change set' -- fills a change set named Aggregate with all the changes in all the change sets in a category.Also provides a minor tool addition, the Change-set browser.  Each instance of this tool is wed to precisely one change set.  Since it has no need for a change-set-list pane, it apportions space in a different manner than ChangeSorters, and unlike any other change sorters, this one has a button-tool pane."!CodeHolder subclass: #ChangeSorter	instanceVariableNames: 'parent myChangeSet currentClassName currentSelector priorChangeSetList changeSetCategory '	classVariableNames: 'AllChangeSets ChangeSetCategories RecentUpdateMarker '	poolDictionaries: ''	category: 'Tools-Changes'!ChangeSorter subclass: #ChangeSetBrowser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ChangeSetBrowser commentStamp: '<historical>' prior: 0!A tool allowing you to browse the methods of a single change set.!ElementCategory subclass: #ChangeSetCategory	instanceVariableNames: 'membershipSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ChangeSetCategory commentStamp: 'sw 3/30/2001 14:37' prior: 0!A ChangeSetCategory represents a list of change sets to be shown in a ChangeSorter.  It computes whether a given change set is in the list by sending its membershipSelector to ChangeSorter (i.e. the class object) with the change set as message argument.!!ChangeSet methodsFor: 'testing' stamp: 'sw 3/29/2001 14:32'!methodsWithoutClassifications	"Return a collection representing methods in the receiver which have not been categorized"	| slips notClassified aSelector |	notClassified _ {'as yet unclassified' asSymbol. #all}.	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (aClass selectors includes:  (aSelector _ mAssoc key)) ifTrue:						[(notClassified includes: (aClass organization categoryOfElement: aSelector))								ifTrue: [slips add: aClass name , ' ' , aSelector]]]].	^ slips	"Smalltalk browseMessageList: (Smalltalk changes methodsWithoutClassifications) name: 'unclassified methods'"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 3/29/2001 14:30'!checkForUnclassifiedMethods	"Open a message list browser on all methods in the current change set that have not been categorized,"	| aList |	(aList _ self methodsWithoutClassifications) size > 0		ifFalse:			[^ self inform: 'All methods in "', self name, '"are categorized.']		ifTrue:			[Smalltalk browseMessageList: aList name: 'methods in "', self name, '" which have not been categorized']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 3/30/2001 13:47'!setPreambleToSay: aString	"Make aString become the preamble of this change set"	preamble _ StringHolder new contents: aString! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 3/29/2001 14:46'!setDefaultChangeSetCategory	"Set a default ChangeSetCategory for the receiver, and answer it"	^ changeSetCategory _ self class changeSetCategoryNamed: #All! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 3/29/2001 13:01'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared."super veryDeepInner: deepCopier."parent _ parent.		Weakly copied""myChangeSet _ myChangeSet.		Weakly copied"currentClassName _ currentClassName veryDeepCopyWith: deepCopier."currentSelector _ currentSelector.		Symbol"priorChangeSetList _ priorChangeSetList veryDeepCopyWith: deepCopier.changeSetCategory _ changeSetCategory.! !!ChangeSorter methodsFor: 'access' stamp: 'sw 3/29/2001 14:45'!changeSetCategory	"Answer the current changeSetCategory object that governs which change sets are shown in this ChangeSorter"	^ changeSetCategory ifNil:		[self setDefaultChangeSetCategory]! !!ChangeSorter methodsFor: 'access' stamp: 'sw 3/29/2001 22:53'!labelString	"The label for my entire window.  The large button that displays my name is gotten via mainButtonName"	^ String streamContents:		[:aStream |			aStream nextPutAll: (Smalltalk changes == myChangeSet				ifTrue: ['Changes go to "', myChangeSet name, '"']				ifFalse: ['ChangeSet: ', myChangeSet name]).		(self changeSetCategory categoryName ~~ #All)			ifTrue:				[aStream nextPutAll:  ' - ', self parenthesizedCategoryName]]! !!ChangeSorter methodsFor: 'access' stamp: 'sw 3/29/2001 22:51'!parenthesizedCategoryName	"Answer my category name in parentheses"	^ ' (', self changeSetCategory categoryName, ')'! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 00:00'!changeSetList	"Answer a list of ChangeSet names to be shown in the change sorter."	^ self changeSetCategory changeSetList! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/9/2001 15:32'!changeSetListKey: aChar from: view	"Respond to a Command key.  I am a model with a listView that has a list of changeSets."	aChar == $b ifTrue: [^ self browseChangeSet].	aChar == $B ifTrue: [^ self openChangeSetBrowser].	aChar == $f ifTrue: [^ self findCngSet].	aChar == $m ifTrue: [^ self newCurrent].	aChar == $n ifTrue: [^ self newSet].	aChar == $o ifTrue: [^ self fileOut].	aChar == $r ifTrue: [^ self rename].	aChar == $x ifTrue: [^ self remove].	aChar == $p ifTrue: [^ self addPreamble].	aChar == $c ifTrue: [^ self copyAllToOther].	aChar == $D ifTrue: [^ self toggleDiffing]. 	^ self messageListKey: aChar from: view! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 12:32'!changeSetMenu: aMenu shifted: isShifted 	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"	isShifted ifTrue: [^ self shiftedChangeSetMenu: aMenu].	Smalltalk isMorphic		ifTrue:			[aMenu title: 'Change Set'.			aMenu addStayUpItemSpecial]		ifFalse:			[aMenu title: 'Change Set:' , myChangeSet name].	aMenu add: 'make changes go to me (m)' action: #newCurrent.	aMenu addLine.	aMenu add: 'new change set... (n)' action: #newSet.	aMenu add: 'find...(f)' action: #findCngSet.	aMenu add: 'show category...' action:  #chooseChangeSetCategory.	aMenu balloonTextForLastItem:'Lets you choose which change sets should be listed in this change sorter'.	aMenu add: 'select change set...' action: #chooseCngSet.	aMenu addLine.	aMenu add: 'rename change set (r)' action: #rename.	aMenu add: 'file out (o)' action: #fileOut.	aMenu add: 'mail to list' action: #mailOut.	aMenu add: 'browse methods (b)' action: #browseChangeSet.	aMenu add: 'browse change set (B)' action: #openChangeSetBrowser.	aMenu addLine.	parent		ifNotNil: 			[aMenu add: 'copy all to other side (c)' action: #copyAllToOther.			aMenu add: 'submerge into other side' action: #submergeIntoOtherSide.			aMenu add: 'subtract other side' action: #subtractOtherSide.			aMenu addLine].	myChangeSet hasPreamble		ifTrue: 			[aMenu add: 'edit preamble (p)' action: #addPreamble.			aMenu add: 'remove preamble' action: #removePreamble]		ifFalse: [aMenu add: 'add preamble (p)' action: #addPreamble].	myChangeSet hasPostscript		ifTrue: 			[aMenu add: 'edit postscript...' action: #editPostscript.			aMenu add: 'remove postscript' action: #removePostscript]		ifFalse: [aMenu add: 'add postscript...' action: #editPostscript].	aMenu addLine.	aMenu add: 'destroy change set (x)' action: #remove.	aMenu addLine.	aMenu add: 'more...' action: #offerShiftedChangeSetMenu.	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/29/2001 12:47'!checkForUnclassifiedMethods	"Open a message list browser on all methods in the current change set that have not been categorized"	myChangeSet checkForUnclassifiedMethods! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 13:20'!chooseChangeSetCategory	"Present the user with a list of change-set-categories and let her choose one"	|  cats aMenu result |	self okToChange ifFalse: [^ self].	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	Smalltalk isMorphic ifTrue: [^ self chooseChangeSetCategoryInMorphic].  "gives balloon help"	cats _ ChangeSetCategories elementsInOrder.	aMenu _ SelectionMenu		labels: (cats collect: [:cat | cat categoryName])		selections: cats.	result _ aMenu startUp.	result ifNotNil:		[changeSetCategory _ result.		self changed: #changeSetList.		(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangeSorter changeSetNamed: self changeSetList first)].		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 13:24'!chooseChangeSetCategoryInMorphic	"Present the user with a list of change-set-categories and let her choose one.  In this morphic variant, we include balloon help"	|  aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu title: 'Choose the category ofchange sets to show inthis Change Sorter(red = current choice)'.	ChangeSetCategories elementsInOrder do:		[:aCategory |			aMenu add: aCategory categoryName target: self selector: #showChangeSetCategory: argument: aCategory.			aCategory == changeSetCategory ifTrue:				[aMenu lastItem color: Color red].			aMenu balloonTextForLastItem: aCategory documentation].	aMenu popUpInWorld! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/29/2001 23:56'!chooseCngSet	"Present the user with an alphabetical list of change set names, and let her choose one"	| changeSetsSortedAlphabetically chosen |	self okToChange ifFalse: [^ self].	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	changeSetsSortedAlphabetically _ self changeSetList asSortedCollection:		[:a :b | a asLowercase withoutLeadingDigits < b asLowercase withoutLeadingDigits].	chosen _ (SelectionMenu selections: changeSetsSortedAlphabetically)			startUp.	chosen ifNil: [^ self].	self showChangeSet: (ChangeSorter changeSetNamed: chosen)! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 00:57'!fileOutAllChangeSets	"File out all nonempty change sets in the current category, probably"	self changeSetCategory fileOutAllChangeSets! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 01:26'!fillAggregateChangeSet	"Create a change-set named Aggregate and pour into it all the changes in all the change-sets of the currently-selected category"	self changeSetCategory fillAggregateChangeSet! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 14:15'!methodConflictsWithOppositeCategory	"Check to see if ANY change set on the other side shares any methods with the selected change set; if so, open a browser on all such."	| aList aClass aSelector otherCategory |	self checkThatSidesDiffer: [^ self].	otherCategory _ (parent other: self) changeSetCategory.	((otherCategory categoryName == #All) or: [changeSetCategory categoryName == #All]) ifTrue:		[^ self inform: 'Sorry, but for any reasonable use of thisfeature, neither side of the Change Sortershould be showing the "All" category.(use "show category" to change category)'].	otherCategory == changeSetCategory ifTrue:		[^ self inform: 'Sorry, for reasonable use of this feature, the other side must be showing a different category from this side.'].	(otherCategory includesChangeSet: myChangeSet) ifTrue:		[^ self inform: 'Sorry, but since the other side also lists this change set, *every* method would show up as a conflict, which would be pointless'].	aList _ myChangeSet changedMessageListAugmented select:		[:aChange |			MessageSet parse: aChange toClassAndSelector: [:cls :sel | aClass _ cls.  aSelector _ sel].			aClass notNil and: [otherCategory hasChangeForClassName:  aClass name selector: aSelector]].	aList size == 0 ifTrue: [^ self inform: 'There are no methods that appearboth in this change set andin any change on the other side.'].		MessageSet openMessageList: aList name: 'Methods in "', myChangeSet name, '" that are also somwhere in category ', otherCategory categoryName,' (', aList size printString, ')'	! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/9/2001 15:30'!openChangeSetBrowser	"Open a ChangeSet browser on the current change set"	Smalltalk isMorphic		ifFalse:			[self browseChangeSet]  "msg-list browser only"		ifTrue:			[(ChangeSetBrowser new myChangeSet: myChangeSet) openAsMorph]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 13:37'!setRecentUpdatesMarker	"Allow the user to change the recent-updates marker"	| result |	result _ FillInTheBlank request: ('Enter the lowest change-set numberthat you wish to consider "recent"?(note: highest change-set numberin this image at this time is ', self class highestNumberedChangeSet asString, ')') initialAnswer: self class recentUpdateMarker asString.	(result notNil and: [result startsWithDigit]) ifTrue:		[self class recentUpdateMarker: result asInteger.		Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup]]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 13:58'!shiftedChangeSetMenu: aMenu	"Set up aMenu to hold items relating to the change-set-list pane when the shift key is down"	Smalltalk isMorphic ifTrue:		[aMenu title: 'Change set (shifted)'.		aMenu addStayUpItemSpecial].	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.	parent ifNotNil:		[aMenu add: 'conflicts with change set opposite' action: #methodConflictsWithOtherSide.			aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in the one on the opposite side of the change sorter.'.			aMenu add: 'conflicts with category opposite' action: #methodConflictsWithOppositeCategory.			aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in ANY change set in the cattegory list on the opposite side of this change sorter.  (Caution -- this could be VERY slow)'.].	aMenu addLine.	aMenu add: 'check for slips' action: #lookForSlips.	aMenu balloonTextForLastItem: 'Check this change set for halts and references to Transcript.'.	aMenu add: 'check for unsent messages' action: #checkForUnsentMessages.	aMenu balloonTextForLastItem:'Check this change set for messages that are not sent anywhere in the system'.	aMenu add: 'check for uncommented methods' action: #checkForUncommentedMethods.	aMenu balloonTextForLastItem:'Check this change set for methods that do not have comments'.	Utilities authorInitialsPerSe isEmptyOrNil ifFalse:		[aMenu add: 'check for other authors' action: #checkForAlienAuthorship.		aMenu balloonTextForLastItem:'Check this change set for methods whose current authoring stamp does not start with "', Utilities authorInitials, '"'].	aMenu add: 'check for uncategorized methods' action: #checkForUnclassifiedMethods.	aMenu balloonTextForLastItem:'Check to see if any methods in the selected change set have not yet been assigned to a category.  If any are found, open a browser on them.'.	aMenu addLine.	aMenu add: 'inspect change set' action: #inspectChangeSet.	aMenu balloonTextForLastItem: 'Open an inspector on this change set. (There are some details in a change set which you don''t see in a change sorter.)'.	aMenu add: 'update' action: #update.	aMenu balloonTextForLastItem: 'Update the display for this change set.  (This is done automatically when you activate this window, so is seldom needed.)'.	aMenu add: 'go to change set''s project' action: #goToChangeSetsProject.	aMenu balloonTextForLastItem: 'If this change set is currently associated with a Project, go to that project right now.'.	aMenu add: 'promote to top of list' action: #promoteToTopChangeSet.	aMenu balloonTextForLastItem:'Make this change set appear first in change-set lists in all change sorters.'.	aMenu add: 'trim history' action: #trimHistory.	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.  NOTE: can cause confusion if later filed in over an earlier version of these changes'.	aMenu add: 'clear this change set' action: #clearChangeSet.	aMenu balloonTextForLastItem: 'Reset this change set to a pristine state where it holds no information. CAUTION: this is destructive and irreversible!!'.	aMenu add: 'expunge uniclasses' action: #expungeUniclasses.	aMenu balloonTextForLastItem:'Remove from the change set all memory of uniclasses, e.g. classes added on behalf of etoys, fabrik, etc., whose classnames end with a digit.'.	aMenu add: 'uninstall this change set' action: #uninstallChangeSet.	aMenu balloonTextForLastItem: 'Attempt to uninstall this change set. CAUTION: this may not work completely and is irreversible!!'.	aMenu addLine.	aMenu add: 'file into new...' action: #fileIntoNewChangeSet.	aMenu balloonTextForLastItem: 'Load a fileout from disk and place its changes into a new change set (seldom needed -- much better to do this from a file-list browser these days.)'.	aMenu add: 'file out category''s change sets' action: #fileOutAllChangeSets.	aMenu balloonTextForLastItem:'File out every change set in this category that has anything in it.  The usual checks for slips are suppressed when this command is done.'.	aMenu add: 'reorder all change sets' action: #reorderChangeSets.	aMenu balloonTextForLastItem:'Applies a standard reordering of all change-sets in the system -- at the bottom will come the  sets that come with the release; next will come change sets you have designated as Personal, next will come all the numbered updates; finally, at the top, will come all other change sets'.	aMenu add: 'set recent-updates marker' action: #setRecentUpdatesMarker.	aMenu balloonTextForLastItem:'Allows you to specify a number that will demarcate which updates are considered "recent" and which are not.  This will govern which updates are included in the RecentUpdates category in a change sorter'.	aMenu add: 'fill aggregate change set' action: #fillAggregateChangeSet.	aMenu balloonTextForLastItem:'Creates a change-set named Aggregate into which all the changes in all the change sets in this category will be copied.'.	aMenu addLine.	aMenu add: 'more...' action: #offerUnshiftedChangeSetMenu.	aMenu balloonTextForLastItem: 'Takes you back to the primary change-set menu.'.	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/30/2001 13:27'!showChangeSetCategory: aChangeSetCategory	"Show the given change-set category"		changeSetCategory _ aChangeSetCategory.	self changed: #changeSetList.	(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangeSorter changeSetNamed: self changeSetList first)].	self changed: #relabel! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/29/2001 12:24'!updateIfNecessary	"Recompute all of my panes."	| newList |	self okToChange ifFalse: [^ self].	myChangeSet ifNil: [^ self].  "Has been known to happen though shouldn't"	myChangeSet isMoribund ifTrue:		[^ self showChangeSet: self changeSetCategory defaultChangeSetToShow].	newList _ self changeSetList.	(priorChangeSetList == nil or: [priorChangeSetList ~= newList])		ifTrue:			[priorChangeSetList _ newList.			self changed: #changeSetList].	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 3/29/2001 15:19'!classList	"Computed.  View should try to preserve selections, even though index changes"	^ myChangeSet ifNotNil: [myChangeSet changedClassNames] ifNil: [OrderedCollection new]! !!ChangeSetBrowser methodsFor: 'initialization' stamp: 'sw 3/12/2001 14:05'!addModelItemsToWindowMenu: aMenu	"Add model-related items to the given window menu"	| oldTarget |	oldTarget _ aMenu defaultTarget.	aMenu defaultTarget: self.	aMenu addLine.	aMenu add: 'rename change set' action: #rename.	aMenu add: 'make changes go to me' action: #newCurrent.	aMenu addLine.	aMenu add: 'file out' action: #fileOut.	aMenu add: 'browse methods' action: #browseChangeSet.	aMenu addLine.	myChangeSet hasPreamble		ifTrue:			[aMenu add: 'edit preamble' action: #addPreamble.			aMenu add: 'remove preamble' action: #removePreamble]		ifFalse:			[aMenu add: 'add preamble' action: #addPreamble].	myChangeSet hasPostscript		ifTrue:			[aMenu add: 'edit postscript...' action: #editPostscript.			aMenu add: 'remove postscript' action: #removePostscript]		ifFalse:			[aMenu add: 'add postscript...' action: #editPostscript].	aMenu addLine.		aMenu add: 'destroy change set' action: #remove.	aMenu addLine.	aMenu add: 'more...' action: #offerShiftedChangeSetMenu.	aMenu defaultTarget: oldTarget.	^ aMenu! !!ChangeSetBrowser methodsFor: 'initialization' stamp: 'sw 3/29/2001 23:38'!openAsMorphIn: window rect: rect	"Add a set of changeSetBrowser views to the given top view offset by the given amount"	| aHeight |	contents _ ''.	aHeight _ 0.25.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: (PluggableListMorphByItem on: self				list: #classList				selected: #currentClassName				changeSelected: #currentClassName:				menu: #classListMenu:shifted:				keystroke: #classListKey:from:)		frame: (((0.0@0 extent: 0.5 @ aHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem on: self				list: #messageList				selected: #currentSelector				changeSelected: #currentSelector:				menu: #messageMenu:shifted:				keystroke: #messageListKey:from:)		frame: (((0.5@0 extent: 0.5 @ aHeight)			scaleBy: rect extent) translateBy: rect origin).	 self addLowerPanesTo: window		at: (((0@aHeight corner: 1@1) scaleBy: rect extent) translateBy: rect origin)		with: nil! !!ChangeSetBrowser methodsFor: 'initialization' stamp: 'sw 3/14/2001 10:03'!wantsAnnotationPane	"This kind of browser always wants annotation panes, so answer true"	^ true! !!ChangeSetBrowser methodsFor: 'initialization' stamp: 'sw 3/9/2001 15:02'!wantsOptionalButtons	"Sure, why not?"	^ true! !!ChangeSetBrowser methodsFor: 'menu' stamp: 'sw 3/12/2001 14:07'!offerUnshiftedChangeSetMenu	"The user chose 'more' from the shifted window menu; go back to the regular window menu"	self containingWindow ifNotNil: [self containingWindow offerWindowMenu] ! !!ChangeSetBrowser methodsFor: 'menu' stamp: 'sw 3/29/2001 23:20'!shiftedChangeSetMenu: aMenu	"Set up aMenu to hold items relating to the change-set-list pane when the shift key is down"	Smalltalk isMorphic ifTrue:		[aMenu title: 'Change set (shifted)'.		aMenu addStayUpItemSpecial].	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.	aMenu addLine.	aMenu add: 'check for slips' action: #lookForSlips.	aMenu balloonTextForLastItem: 'Check this change set for halts and references to Transcript.'.	aMenu add: 'check for unsent messages' action: #checkForUnsentMessages.	aMenu balloonTextForLastItem:'Check this change set for messages that are not sent anywhere in the system'.	aMenu add: 'check for uncommented methods' action: #checkForUncommentedMethods.	aMenu balloonTextForLastItem:'Check this change set for methods that do not have comments'.	Utilities authorInitialsPerSe isEmptyOrNil ifFalse:		[aMenu add: 'check for other authors' action: #checkForAlienAuthorship.		aMenu balloonTextForLastItem:'Check this change set for methods whose current authoring stamp does not start with "', Utilities authorInitials, '"'].	aMenu add: 'check for uncategorized methods' action: #checkForUnclassifiedMethods.	aMenu balloonTextForLastItem:'Check to see if any methods in the selected change set have not yet been assigned to a category.  If any are found, open a browser on them.'.	aMenu addLine.	aMenu add: 'inspect change set' action: #inspectChangeSet.	aMenu balloonTextForLastItem: 'Open an inspector on this change set. (There are some details in a change set which you don''t see in a change sorter.)'.	aMenu add: 'update' action: #update.	aMenu balloonTextForLastItem: 'Update the display for this change set.  (This is done automatically when you activate this window, so is seldom needed.)'.	aMenu add: 'go to change set''s project' action: #goToChangeSetsProject.	aMenu balloonTextForLastItem: 'If this change set is currently associated with a Project, go to that project right now.'.	aMenu add: 'trim history' action: #trimHistory.	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.  NOTE: can cause confusion if later filed in over an earlier version of these changes'.	aMenu add: 'clear this change set' action: #clearChangeSet.	aMenu balloonTextForLastItem: 'Reset this change set to a pristine state where it holds no information. CAUTION: this is destructive and irreversible!!'.	aMenu add: 'expunge uniclasses' action: #expungeUniclasses.	aMenu balloonTextForLastItem:'Remove from the change set all memory of uniclasses, e.g. classes added on behalf of etoys, fabrik, etc., whose classnames end with a digit.'.	aMenu add: 'uninstall this change set' action: #uninstallChangeSet.	aMenu balloonTextForLastItem: 'Attempt to uninstall this change set. CAUTION: this may not work completely and is irreversible!!'.	aMenu addLine.	aMenu add: 'more...' action: #offerUnshiftedChangeSetMenu.	aMenu balloonTextForLastItem: 'Takes you back to the primary change-set menu.'.	^ aMenu! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 16:01'!belongsInAdditions: aChangeSet	"Answer whether a change set belongs in the Additions category, which is fed by all change sets that are neither numbered nor in the initial release"	^ (((self belongsInProjectsInRelease: aChangeSet) or:		[self belongsInNumbered: aChangeSet])) not! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:38'!belongsInAll: aChangeSet	"Answer whether a change set belongs in the All category"	^ true ! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:47'!belongsInMyInitials: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet name endsWith: ('-', Utilities authorInitials)! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:45'!belongsInNumbered:  aChangeSet	"Answer whether a change set belongs in the Numbered category. "	^  aChangeSet name startsWithDigit! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:49'!belongsInProjectChangeSets: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet belongsToAProject! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:44'!belongsInProjectsInRelease:  aChangeSet	"Answer whether a change set belongs in the ProjectsInRelease category.  You can hand-tweak this to suit your working style.  This just covers the space of project names in the 2.9, 3.0, and 3.1a systems"	| aString |	^ ((aString _ aChangeSet name) beginsWith: 'Play With Me') or: [self changeSetNamesInReleaseImage includes: aString]! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 12:56'!belongsInRecentUpdates: aChangeSet	"Answer whether a change set belongs in the RecentUpdates category."	^ aChangeSet name startsWithDigit and:			[aChangeSet name asInteger >= self recentUpdateMarker]! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/29/2001 14:44'!changeSetCategoryNamed: aName	"Answer the changeSetCategory of the given name, or nil if none"	^ ChangeSetCategories elementAt: aName asSymbol ! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/29/2001 23:26'!changeSetNamesInReleaseImage	"Hard-coded: answer a list of names of project change sets that come pre-shipped in the latest sytem release"	^ #('The Worlds of Squeak' 'Fun with Morphic' 'Games' 'Fun With Music' 'Building with Squeak' 'Squeak and the Internet' 'Squeak in 3D' 'More About Sound' ) ! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 00:46'!initialize	"Initialize the class variables"	AllChangeSets == nil ifTrue:		[AllChangeSets _ OrderedCollection new].	self gatherChangeSets.	ChangeSetCategories ifNil:		[self initializeChangeSetCategories].	RecentUpdateMarker _ 0	"ChangeSorter initialize"! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'sw 3/30/2001 13:30'!initializeChangeSetCategories	"Initialize the set of change-set categories"	"ChangeSorter initializeChangeSetCategories"	| aCategory |	ChangeSetCategories _ ElementCategory new categoryName: #ChangeSetCategories.	aCategory _ ChangeSetCategory new categoryName: #All.	aCategory membershipSelector: #belongsInAll:.	aCategory documentation: 'All change sets known to the system'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #Additions.	aCategory membershipSelector: #belongsInAdditions:.	aCategory documentation: 'All unnumbered change sets except those representing projects in the system as initially released.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #MyInitials.	aCategory membershipSelector: #belongsInMyInitials:.	aCategory documentation: 'All change sets whose names end with the current author''s initials.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #Numbered.	aCategory membershipSelector: #belongsInNumbered:.	aCategory documentation: 'All change sets whose names start with a digit -- normally these will be the official updates to the system.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #ProjectChangeSets.	aCategory membershipSelector: #belongsInProjectChangeSets:.	aCategory documentation: 'All change sets that are currently associated with projects present in the system right now.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #ProjectsInRelease.	aCategory membershipSelector: #belongsInProjectsInRelease:.	aCategory documentation: 'All change sets belonging to projects that were shipped in the initial release of this version of Squeak'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #RecentUpdates.	aCategory membershipSelector: #belongsInRecentUpdates:.	aCategory documentation: 'Updates whose numbers are at or beyond the number I have designated as the earliest one to qualify as Recent'.	ChangeSetCategories addCategoryItem: aCategory.	ChangeSetCategories elementsInOrder do: [:anElem | anElem reconstituteList] ! !!ChangeSorter class methodsFor: 'adding' stamp: 'sw 3/30/2001 01:29'!newChangeSetNamed: aName	"Establish a new change set of the given name (if ok), making it the current changeset.  Return nil of not ok, else return the actual changeset."	| newSet |	newSet _ self basicNewChangeSet: aName.	newSet ifNotNil:		[Smalltalk newChanges: newSet.		Transcript cr; show: aName, ' is now the current change set'].	^ newSet! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 3/30/2001 13:43'!assuredChangeSetNamed: aName	"Answer a change set of the given name.  If one already exists, answer that, else create a new one and answer it."	| existing |	^ (existing _ self changeSetNamed: aName)		ifNotNil:			[existing]		ifNil:			[self basicNewChangeSet: aName]! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 3/30/2001 00:30'!recentUpdateMarker	"Answer the number representing the threshold of what counts as 'recent' for an update number.  This allow you to use the RecentUpdates category in a ChangeSorter to advantage"	^ RecentUpdateMarker ifNil: [RecentUpdateMarker _ 0]! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 3/30/2001 00:30'!recentUpdateMarker: aNumber	"Set the recent update marker as indicated"	^ RecentUpdateMarker _ aNumber! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 3/30/2001 16:06'!reorderChangeSets	"Change the order of the change sets to something more convenient:		First come the project changesets that come with the release.  These are mostly empty.		Next come all numbered updates.		Next come all remaining changesets	In a ChangeSorter, they will appear in the reversed order."	"ChangeSorter reorderChangeSets"	| newHead newMid newTail |	self gatherChangeSets.	newHead _ OrderedCollection new.	newMid _ OrderedCollection new.	newTail _ OrderedCollection new.	AllChangeSets do:		[:aChangeSet |			(self belongsInProjectsInRelease: aChangeSet)				ifTrue:					[newHead add: aChangeSet]				ifFalse:					[(self belongsInNumbered: aChangeSet)						ifTrue:							[newMid add: aChangeSet]						ifFalse:							[newTail add: aChangeSet]]].	AllChangeSets _ newHead, newMid, newTail.	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup]! !!DualChangeSorter methodsFor: 'other' stamp: 'sw 3/30/2001 16:16'!labelString	"The window label"	| leftName rightName changesName |	leftName _ leftCngSorter changeSetCategory categoryName.	rightName _ rightCngSorter changeSetCategory categoryName.	changesName _ 'Changes go to "', Smalltalk changes name,  '"'.	^ ((leftName ~~ #All) or: [rightName ~~ #All])		ifTrue:			['(', leftName, ') - ', changesName, ' - (', rightName, ')']		ifFalse:			[changesName]! !!ElementCategory methodsFor: 'initialization' stamp: 'sw 3/30/2001 00:12'!addCategoryItem: anItem	"Add the item at the end, obtaining its key from itself (it must respond to #categoryName)"	self elementAt: anItem categoryName put: anItem! !!ElementCategory methodsFor: 'initialization' stamp: 'sw 3/28/2001 19:46'!clear	"Clear the receiber's keysInOrder and elementDictionary"	keysInOrder _ OrderedCollection new.	elementDictionary _ IdentityDictionary new! !!ElementCategory methodsFor: 'initialization' stamp: 'sw 3/28/2001 19:47'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	super initialize.	self clear! !!ChangeSetCategory methodsFor: 'initialization' stamp: 'sw 3/30/2001 12:35'!membershipSelector: aSelector	"Set the membershipSelector"	membershipSelector _ aSelector! !!ChangeSetCategory methodsFor: 'queries' stamp: 'sw 3/30/2001 14:39'!changeSetList	"Answer the list of change-set names in the category"	| aChangeSet |	self reconstituteList.	keysInOrder size == 0 ifTrue:		["don't tolerate emptiness, because ChangeSorters gag when they have no change-set selected"		aChangeSet _ ChangeSorter assuredChangeSetNamed: 'New Changes'.		self elementAt: aChangeSet name put: aChangeSet].	^ keysInOrder reversed! !!ChangeSetCategory methodsFor: 'queries' stamp: 'sw 3/30/2001 14:08'!hasChangeForClassName: aClassName selector: aSelector	"Answer whether any change set in this category has a change marked for the given class and selector"	self elementsInOrder do:		[:aChangeSet |			((aChangeSet methodChangesAtClass: aClassName) includesKey: aSelector) ifTrue:	[^ true]].	^ false! !!ChangeSetCategory methodsFor: 'queries' stamp: 'sw 3/30/2001 14:04'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ ChangeSorter perform: membershipSelector with: aChangeSet! !!ChangeSetCategory methodsFor: 'services' stamp: 'sw 3/30/2001 14:41'!fileOutAllChangeSets	"File out all the nonempty change sets in the current category, suppressing the checks for slips that might otherwise ensue.  Obtain user confirmation before undertaking this possibly prodigious task."	| aList |	aList _ self elementsInOrder select:		[:aChangeSet  | aChangeSet isEmpty not].	aList size == 0 ifTrue: [^ self inform: 'sorry, all the change sets in this category are empty'].	(self confirm: 'This will result in filing out ', aList size printString, ' change set(s)Are you certain you want to do this?') ifFalse: [^ self].	Preferences setFlag: #checkForSlips toValue: false during: 		[Utilities fileOutChangeSetsNamed: (aList collect: [:m | m name]) asSortedArray]! !!ChangeSetCategory methodsFor: 'services' stamp: 'sw 3/30/2001 13:55'!fillAggregateChangeSet	"Create a change-set named Aggregate and pour into it all the changes in all the change-sets of the currently-selected category"	| aggChangeSet |	aggChangeSet _  ChangeSorter assuredChangeSetNamed: #Aggregate.	aggChangeSet clear.	aggChangeSet setPreambleToSay: '"Change Set:		AggregateCreated at ', Time now printString, ' on ', Date today printString, ' by combining all the changes in all the change sets in the category ', categoryName printString, '"'.	(self elementsInOrder copyWithout: aggChangeSet) do:		[:aChangeSet  | aggChangeSet assimilateAllChangesFoundIn: aChangeSet].	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup] ! !!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'sw 3/29/2001 11:47'!defaultChangeSetToShow	"Answer the name of a change-set to show"	^ Smalltalk changes! !!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'sw 3/30/2001 13:01'!reconstituteList	"Clear out the receiver's elements and rebuild them"	self clear.	ChangeSorter gatherChangeSets do:		[:aChangeSet | 			(ChangeSorter perform: membershipSelector with: aChangeSet) ifTrue:				[self elementAt: aChangeSet name asSymbol put: aChangeSet]] ! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 3/9/2001 15:56'!findAChangeSorter: evt	"Locate a change sorter, open it, and bring it to the front.  Create one if necessary.  Only works in morphic, initially, probably"	| aWindow |	submorphs do:		[:aMorph | (((aWindow _ aMorph renderedMorph) isKindOf: SystemWindow) and:			[((aWindow model isMemberOf: ChangeSorter) or:				[aWindow model isKindOf: DualChangeSorter])]) ifTrue:					[aWindow isCollapsed ifTrue: [aWindow expand].					aWindow activateAndForceLabelToShow.					^ self]].	"None found, so create one"	DualChangeSorter open! !!Utilities class methodsFor: 'fileout' stamp: 'sw 3/29/2001 15:39'!fileOutChangeSetsNamed: nameList	"File out the list of change sets whose names are provided"	"Utilities fileOutChangeSetsNamed: #('New Changes' 'miscTidies-sw')"	| notFound aChangeSet infoString empty |	notFound _ OrderedCollection new.	empty _ OrderedCollection new.	nameList do:		[:aName | (aChangeSet _ ChangeSorter changeSetNamed: aName)			ifNotNil:				[aChangeSet isEmpty					ifTrue:						[empty add: aName]					ifFalse:						[aChangeSet fileOut]]			ifNil:				[notFound add: aName]].	infoString _ (nameList size - notFound size) printString, ' change set(s) filed out'.	notFound size > 0 ifTrue:		[infoString _ infoString, '', notFound size printString, ' change set(s) not found:'.		notFound do:			[:aName | infoString _ infoString, '', aName]].	empty size > 0 ifTrue:		[infoString _ infoString, '', empty size printString, ' change set(s) were empty:'.		empty do:			[:aName | infoString _ infoString, '', aName]].	self inform: infoString! !Utilities class removeSelector: #fileOutUnnumberedChangeSets!ChangeSetCategory class removeSelector: #allChangeSetsCategory!ChangeSetCategory removeSelector: #elementRetrievalBlock:!ChangeSetCategory removeSelector: #hasChangeForClass:selector:!!ChangeSetCategory reorganize!('initialization' membershipSelector:)('queries' changeSetList hasChangeForClassName:selector: includesChangeSet:)('services' fileOutAllChangeSets fillAggregateChangeSet)('miscellaneous' defaultChangeSetToShow reconstituteList)!!DualChangeSorter reorganize!('initialization' morphicWindow okToChange open openAsMorph release)('other' isLeftSide: labelString modelWakeUp other:)!ChangeSorter initialize!!ChangeSetBrowser reorganize!('initialization' addModelItemsToWindowMenu: openAsMorphIn:rect: wantsAnnotationPane wantsOptionalButtons)('menu' offerUnshiftedChangeSetMenu shiftedChangeSetMenu:)!ChangeSorter removeSelector: #fileOutUnnumberedChangeSets!ChangeSet removeSelector: #methodsWithouClassifications!"Postscript:"Preferences setWindowColorFor: #ChangeSetBrowser to:   (Color r: 1.0 g: 0.903 b: 0.742).!