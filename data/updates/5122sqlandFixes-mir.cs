'From Squeak3.4alpha of ''11 November 2002'' [latest update: #5109] on 18 November 2002 at 6:55:40 pm'!"Change Set:		sqFixes2-mirDate:			18 November 2002Author:			Michael RuegerA collection of fixes from the Squeakland plugin update stream.Enables the project loader to fall back to Squeak Sockets if the Browser Plugin isn't supported or simply not working.Fixes some minor and major problems:- introduces a backward compatibility for ScrollController- makes the My Squeak folder accessible on the Mac- adds support for external proxy settings- fixes an issue with fetching updates from behind a firewallFixes problems with storing projects in local files and reading BMP files from a project archive.Fixes a problem with dnd'ing images into squeak after the sandbox has been activated. FileUrl cleverly enough returns a html directory listing when it can't open the file. Fix is really only a workaround."!Object subclass: #HTTPClient	instanceVariableNames: ''	classVariableNames: 'BrowserSupportsAPI RunningInBrowser '	poolDictionaries: ''	category: 'Framework-Download'!!AutoStart class methodsFor: 'class initialization' stamp: 'mir 8/23/2002 14:49'!startUp	| startupParameters launchers |	startupParameters _ AbstractLauncher extractParameters.	(startupParameters includesKey: 'apiSupported' asUppercase )		ifTrue: [HTTPClient browserSupportsAPI: ((startupParameters at: 'apiSupported' asUppercase) asUppercase = 'TRUE')].	self checkForUpdates		ifTrue: [^self].	self checkForPluginUpdate.	launchers _ self installedLaunchers collect: [:launcher |		launcher new].	launchers do: [:launcher |		launcher parameters: startupParameters].	launchers do: [:launcher |		Smalltalk at: #WorldState ifPresent: [ :ws | ws addDeferredUIMessage: [launcher startUp]]]! !!ExternalDropHandler class methodsFor: 'private' stamp: 'mir 10/14/2002 15:26'!defaultImageHandler	| image sketch |	^ExternalDropHandler		type: 'image/'		extension: nil		action: [:stream :pasteUp :event |			stream binary.			image _ Form fromBinaryStream: ((RWBinaryOrTextStream with: stream contents) reset).			Project current resourceManager 				addResource: image 				url: (FileDirectory urlForFileNamed: stream name) asString.			sketch _ SketchMorph withForm: image.			pasteUp addMorph: sketch centeredNear: event position] fixTemps! !!ExternalSettings class methodsFor: 'accessing' stamp: 'mir 8/23/2002 14:22'!parseServerEntryArgsFrom: stream	"Args are in the form <argName>: <argValueString> delimited by end of line.	It's not a very robust format and should be replaced by something like XML later.	But it avoids evaluating the entries for security reasons."	| entries lineStream entryName entryValue |	entries _ Dictionary new.	stream skipSeparators.	[stream atEnd]		whileFalse: [			lineStream _ ReadStream on: stream nextLine.			entryName _ lineStream upTo: $:.			lineStream skipSeparators.			entryValue _ lineStream upToEnd.			(entryName isEmptyOrNil 				or: [entryValue isEmptyOrNil])				ifFalse: [entries at: entryName put: entryValue withoutTrailingBlanks].			stream skipSeparators].	^entries! !!Form methodsFor: 'resources' stamp: 'mir 9/14/2002 17:18'!readNativeResourceFrom: byteStream	| img aStream |	(byteStream isKindOf: FileStream) ifTrue:[		"Ugly, but ImageReadWriter will send #reset which is implemented as #reopen and we may not be able to do so."		"And even more ugly is the fact that those frickin' RWB...etc streams open positioned at the end"		aStream _ (RWBinaryOrTextStream with: byteStream contents) reset.	] ifFalse:[		aStream _ byteStream.	].	img _ [Form fromBinaryStream: aStream] on: Error do:[:ex| nil].	img ifNil:[^nil].	img displayOn: self.	img _ nil.! !!HTTPClient class methodsFor: 'class initialization' stamp: 'mir 4/2/2002 15:37'!browserSupportsAPI	^BrowserSupportsAPI == true! !!HTTPClient class methodsFor: 'class initialization' stamp: 'mir 4/2/2002 15:36'!browserSupportsAPI: aBoolean	BrowserSupportsAPI _ aBoolean! !!HTTPClient class methodsFor: 'testing' stamp: 'mir 4/2/2002 15:51'!shouldUsePluginAPI	"HTTPClient shouldUsePluginAPI" 	self isRunningInBrowser		ifFalse: [^false].	self browserSupportsAPI		ifFalse: [^false].	"The Mac plugin calls do not work in full screen mode"	^((Smalltalk platformName = 'Mac OS')		and: [ScreenController lastScreenModeSelected]) not! !!HTTPClient class methodsFor: 'post/get' stamp: 'mir 4/2/2002 15:52'!requestURL: url target: target	^self shouldUsePluginAPI		ifTrue: [FileStream requestURL: url target: target]		ifFalse: [self error: 'Requesting a new URL target is not supported.']! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'mir 8/23/2002 14:19'!initialize	"HTTPSocket initialize"	ParamDelimiters _ ' ', CrLf.	HTTPPort _ 80.	HTTPProxyServer _ nil.	HTTPBlabEmail _ ''.  "	'From: somebody@no.where', CrLf	"	ExternalSettings registerClient: self! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'mir 8/23/2002 14:28'!fetchExternalSettingsIn: aDirectory	"Scan for server configuration files"	"HTTPSocket fetchExternalSettingsIn: (FileDirectory default directoryNamed: 'prefs')"	| stream entries |	(aDirectory fileExists: self proxySettingsFileName)		ifFalse: [^self].	stream _ aDirectory readOnlyFileNamed: self proxySettingsFileName.	stream		ifNotNil: [			[entries _ ExternalSettings parseServerEntryArgsFrom: stream]				ensure: [stream close]].	entries ifNil: [^self].	HTTPProxyServer _ entries at: 'host' ifAbsent: [nil].	HTTPProxyPort _ (entries at: 'port' ifAbsent: ['80']) asInteger ifNil: [self defaultPort].	HTTPSocket addProxyException: (entries at: 'exception' ifAbsent: [nil])! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'mir 8/23/2002 14:29'!proxySettingsFileName	^'proxySettings'! !!ProjectLauncher methodsFor: 'initialization' stamp: 'mir 8/23/2002 14:52'!setupFromParameters	(self includesParameter: 'showSplash')		ifTrue: [showSplash _ (self parameterAt: 'showSplash') asUppercase = 'TRUE'].	(self includesParameter: 'flaps')		ifTrue: [whichFlaps _ (self parameterAt: 'flaps')].! !!ProjectLoading class methodsFor: 'as yet unclassified' stamp: 'mir 7/5/2002 18:42'!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNil withProjectView: existingView	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world." 	| morphOrList proj trusted localDir projStream archive mgr projectsToBeDeleted baseChangeSet |	(preStream isNil or: [preStream size = 0]) ifTrue: [		ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"		^self inform: 'It looks like a problem occurred whilegetting this project. It may be temporary,so you may want to try again,'	].	ProgressNotification signal: '2:fileSizeDetermined ',preStream size printString.	preStream isZipArchive 		ifTrue:[	archive _ ZipArchive new readFrom: preStream.				projStream _ self projectStreamFromArchive: archive]		ifFalse:[projStream _ preStream].	trusted _ SecurityManager default positionToSecureContentsOf: projStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		(preStream respondsTo: #close) ifTrue:[preStream close].		^self]].	localDir _ Project squeakletDirectory.	aFileName ifNotNil: [		(aDirectoryOrNil isNil or: [aDirectoryOrNil pathName ~= localDir pathName]) ifTrue: [			localDir deleteFileNamed: aFileName.			(localDir fileNamed: aFileName) 				nextPutAll: preStream contents;				close.		].	].	morphOrList _ projStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	ResourceCollector current: ResourceCollector new.	baseChangeSet _ Smalltalk changes.	self useTempChangeSet.		"named zzTemp"	"The actual reading happens here"	[morphOrList _ morphOrList fileInObjectAndCode] ensure: [				Smalltalk newChanges: baseChangeSet].	mgr _ ResourceManager new initializeFrom: ResourceCollector current.	mgr registerUnloadedResources.	archive ifNotNil:[mgr preLoadFromArchive: archive cacheName: aFileName].	(preStream respondsTo: #close) ifTrue:[preStream close].	ResourceCollector current: nil.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj _ morphOrList arrayOfRoots 			detect: [:mm | mm class == Project] 			ifNone: [^self inform: 'No project found in this file'].		proj resourceManager: mgr.		"proj versionFrom: preStream."		proj lastDirectory: aDirectoryOrNil.		CurrentProjectRefactoring currentBeParentTo: proj.		projectsToBeDeleted _ OrderedCollection new.		existingView ifNil: [			Smalltalk isMorphic ifTrue: [				proj createViewIfAppropriate.			] ifFalse: [				ChangeSorter allChangeSets add: proj changeSet.				ProjectView openAndEnter: proj.				"Note: in MVC we get no further than the above"			].		] ifNotNil: [			(existingView project isKindOf: DiskProxy) ifFalse: [				existingView project changeSet name: ChangeSet defaultName.				projectsToBeDeleted add: existingView project.			].			(existingView owner isKindOf: SystemWindow) ifTrue: [				existingView owner model: proj			].			existingView project: proj.		].		ChangeSorter allChangeSets add: proj changeSet.		Project current projectParameters 			at: #deleteWhenEnteringNewProject 			ifPresent: [ :ignored | 				projectsToBeDeleted add: Project current.				Project current removeParameter: #deleteWhenEnteringNewProject.			].		projectsToBeDeleted isEmpty ifFalse: [			proj projectParameters 				at: #projectsToBeDeleted 				put: projectsToBeDeleted.		].		^ ProjectEntryNotification signal: proj	].	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph	].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'	].	(Project newMorphicOn: morphOrList) enter! !!ResourceCollector methodsFor: 'resource writing' stamp: 'mir 9/13/2002 11:10'!writeResourceForm: aForm fromLocator: aLocator	"The given form has been externalized before. If it was reasonably compressed, use the bits of the original data - this allows us to recycle GIF, JPEG, PNG etc. data without using the internal compression (which is in most cases inferior). If necessary the data will be retrieved from its URL location. This retrieval is done only if the resouce comes from either		* the local disk (in which case the file has never been published)		* the browser cache (in which case we don't cache the resource locally)	In any other case we will *not* attempt to retrieve it, because doing so can cause the system to connect to the network which is probably not what we want. It should be a rare case anyways; could only happen if one clears the squeak cache selectively."	| fName fStream url data |	"Try to be smart about the name of the file"	fName _ (aLocator urlString includes: $:)		ifTrue: [			url _ aLocator urlString asUrl.			url path last]		ifFalse: [aLocator urlString].	fName isEmptyOrNil ifFalse:[fName _ fName asFileName].	(fName isEmptyOrNil or:[localDirectory isAFileNamed: fName]) ifTrue:[		"bad luck -- duplicate name"		fName _ localDirectory 				nextNameFor:'resource' 				extension: (FileDirectory extensionFor: aLocator urlString)].	"Let's see if we have cached it locally"	ResourceManager		lookupCachedResource: self baseUrl , aLocator urlString		ifPresentDo:[:stream | data _ stream upToEnd].	"Check if the cache entry is without qualifying baseUrl. Workaround for older versions."	data ifNil:[		ResourceManager			lookupCachedResource: aLocator urlString			ifPresentDo:[:stream | data _ stream upToEnd]].	data ifNil:[		"We don't have it cached locally. Retrieve it from its original location."		((url notNil and: [url hasRemoteContents]) and:[HTTPClient isRunningInBrowser not])			ifTrue:[^nil]. "see note above"		(Url schemeNameForString: aLocator urlString)			ifNil: [^nil].		data _ HTTPLoader default retrieveContentsFor: aLocator urlString.		data ifNil:[^nil].		data _ data content.	].	"data size > aForm bits byteSize ifTrue:[^nil]."	fStream _ localDirectory newFileNamed: fName.	fStream nextPutAll: data.	fStream close.	^{fName. data size}! !!ResourceCollector methodsFor: 'resource writing' stamp: 'mir 9/13/2002 10:54'!writeResourceForm: aForm locator: aLocator	"Store the given form on a file. Return an array with the name and the size of the file"	| fName fStream fullSize result writerClass |	aLocator ifNotNil:[		result _ self writeResourceForm: aForm fromLocator: aLocator.		result ifNotNil:[^result]		"else fall through"	].	fName _ localDirectory nextNameFor:'resource' extension:'form'.	fStream _ localDirectory newFileNamed: fName.	fStream binary.	"aForm storeResourceOn: fStream."	writerClass _ ((Smalltalk includesKey: #JPEGReadWriter2)		and: [(Smalltalk at: #JPEGReadWriter2) new isPluginPresent])		ifTrue: [(Smalltalk at: #JPEGReadWriter2)]		ifFalse: [GIFReadWriter].	writerClass putForm: aForm onStream: fStream.	fStream open.	fullSize _ fStream size.	fStream close.	"Compress contents here""		fStream position: 0.		fStream compressFile.		localDirectory deleteFileNamed: fName.		localDirectory rename: fName, FileDirectory dot, 'gz' toBe: fName.		fStream _ localDirectory readOnlyFileNamed: fName.		fullSize _ fStream size.		fStream close."	^{fName. fullSize}! !!ResourceManager class methodsFor: 'resource caching' stamp: 'mir 9/15/2002 15:59'!lookupCachedResource: cachedUrlString ifPresentDo: streamBlock	"See if we have cached the resource described by the given url and if so, evaluate streamBlock with the cached resource."	|  urlString candidates url stream |	CachedResources ifNil:[^self].	candidates _ CachedResources at: cachedUrlString ifAbsent:[nil].	(self lookupCachedResource: cachedUrlString in: candidates ifPresentDo: streamBlock)		ifTrue: [^self].	urlString _ self relocatedExternalResource: cachedUrlString.	urlString ifNil: [^self].	candidates _ CachedResources at: urlString ifAbsent:[nil].	candidates		ifNil: [			(url _ urlString asUrl) schemeName = 'file'				ifTrue: [					stream _ [FileStream readOnlyFileNamed: url pathForFile] 							on: FileDoesNotExistException do:[:ex| ex return: nil].					stream						ifNotNil: [[streamBlock value: stream] ensure: [stream close]]]]		ifNotNil: [self lookupCachedResource: urlString in: candidates ifPresentDo: streamBlock]! !!ServerDirectory class methodsFor: 'server prefs' stamp: 'mir 8/23/2002 13:12'!determineLocalServerDirectory: directoryName	"This is part of a workaround for Mac file name oddities regarding relative file names.	The real fix should be in fullNameFor: but that seems to break other parts of the system."	| dirName |	dirName _ directoryName.	(Smalltalk platformName = 'Mac OS'		and: [directoryName beginsWith: ':'])			ifTrue: [				dirName _ (FileDirectory default pathName endsWith: directoryName)					ifTrue: [FileDirectory default pathName]					ifFalse: [(FileDirectory default pathName , directoryName) replaceAll: '::' with: ':']].	^FileDirectory default directoryNamed: dirName! !!ServerDirectory class methodsFor: 'server prefs' stamp: 'mir 8/23/2002 14:22'!parseServerEntryFrom: stream		| server type directory entries serverName |	entries _ ExternalSettings parseServerEntryArgsFrom: stream.	serverName _ entries at: 'name' ifAbsent: [^nil].	directory _ entries at: 'directory' ifAbsent: [^nil].	type _ entries at: 'type' ifAbsent: [^nil].	type = 'file'		ifTrue: [			server _ self determineLocalServerDirectory: directory.			entries at: 'userListUrl' ifPresent:[:value | server eToyUserListUrl: value].			entries at: 'baseFolderSpec' ifPresent:[:value | server eToyBaseFolderSpec: value].			^self addLocalProjectDirectory: server].	type = 'bss'		ifTrue: [server _ SuperSwikiServer new type: #http].	type = 'http'		ifTrue: [server _ HTTPServerDirectory new type: #ftp].	type = 'ftp'		ifTrue: [server _ ServerDirectory new type: #ftp].	server directory: directory.	entries at: 'server' ifPresent: [:value | server server: value].	entries at: 'user' ifPresent: [:value | server user: value].	entries at: 'group' ifPresent: [:value | server groupName: value].	entries at: 'passwdseq' ifPresent: [:value | server passwordSequence: value asNumber].	entries at: 'url' ifPresent: [:value | server altUrl: value].	entries at: 'loaderUrl' ifPresent: [:value | server loaderUrl: value].	entries at: 'acceptsUploads' ifPresent: [:value | server acceptsUploads: value asLowercase = 'true'].	entries at: 'userListUrl' ifPresent:[:value | server eToyUserListUrl: value].	ServerDirectory addServer: server named: serverName.! !!SmartRefStream methodsFor: 'conversion' stamp: 'mir 7/12/2002 18:03'!scrollControllermvslrrsmsms0	^ MouseMenuController! !ServerDirectory class removeSelector: #parseServerEntryArgsFrom:!HTTPSocket initialize!"Postscript:"ExternalSettings registerClient: HTTPSocket.ExternalDropHandler initialize.!