'From Squeak2.9alpha of 17 July 2000 [latest update: #3214] on 30 December 2000 at 10:32:57 am'!"Change Set:		samplingRateDate:			24 December 2000Author:			Bob ArningProvides a way to capture recorded sounds at a sampling rate lower than the OS would generally permit. SoundRecorder>>desiredSampleRate: will encourage the sound recorder to produce that rate even if it the underlying OS insisted on using a higher rate. Senders of the older #samplingRate: will continue to get whatever the OS deigns to provide."!Object subclass: #SoundRecorder	instanceVariableNames: 'stereo samplingRate recordLevel recordedBuffers recordedSound recordProcess bufferAvailableSema paused meteringBuffer meterLevel soundPlaying currentBuffer nextIndex codec desiredSampleRate '	classVariableNames: 'CanRecordWhilePlaying '	poolDictionaries: ''	category: 'Sound-Synthesis'!!CompressedSoundData methodsFor: 'as yet unclassified' stamp: 'RAA 12/24/2000 08:53'!compressWith: codecClass atRate: aSamplingRate	(codecName == codecClass name asSymbol and: [samplingRate = aSamplingRate]) ifTrue: [^self].	^self asSound compressWith: codecClass atRate: aSamplingRate! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'RAA 12/30/2000 10:24'!addVoiceControls 	| levelSlider r meterBox |	voiceRecorder _ SoundRecorder new		desiredSampleRate: 11025.0;		"<==try real hard to get the low rate"		codec: (ADPCMCodec new initializeForBitsPerSample: 4 samplesPerFrame: 0)..	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: voiceRecorder;		actionSelector: #recordLevel:;		adjustToValue: voiceRecorder recordLevel.	r _ AlignmentMorph newRow		color: color;		layoutInset: 0;		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.	meterBox _ Morph new extent: 102@18; color: Color gray.	recordMeter _ Morph new extent: 1@16; color: Color yellow.	recordMeter position: meterBox topLeft + (1@1).	meterBox addMorph: recordMeter.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: meterBox.	self addMorphBack: r.! !!SampledSound methodsFor: 'accessing' stamp: 'RAA 12/24/2000 08:49'!compressWith: codecClass atRate: aSamplingRate	^ codecClass new compressSound: self atRate: aSamplingRate! !!SequentialSound methodsFor: 'composition' stamp: 'RAA 12/24/2000 08:42'!compressWith: codecClass atRate: aSamplingRate	^ self copy transformSounds: [:s | s compressWith: codecClass atRate: aSamplingRate]! !!SoundCodec methodsFor: 'compress/decompress' stamp: 'RAA 12/30/2000 10:26'!compressSound: aSound atRate: desiredSampleRate	"Compress the entirety of the given sound with this codec. Answer a CompressedSoundData."	| compressed channels samples newRate ratio newCount buffer fromIndex sum |	compressed _ CompressedSoundData new		codecName: self class name;		soundClassName: aSound class name.	(aSound isKindOf: SampledSound) ifTrue: [		(desiredSampleRate isNil or: 				[(ratio _ aSound originalSamplingRate // desiredSampleRate) <= 1]) ifTrue: [			samples _ aSound samples.			newRate _ aSound originalSamplingRate.		] ifFalse: [			newCount _ (buffer _ aSound samples) monoSampleCount // ratio.			samples _ SoundBuffer newMonoSampleCount: newCount.			fromIndex _ 1.			1 to: newCount do: [ :i |				sum _ 0.				ratio timesRepeat: [					sum _ sum + (buffer at: fromIndex).					fromIndex _ fromIndex + 1.				].				samples at: i put: sum // ratio.			].			newRate _ desiredSampleRate.		].		channels _ Array new: 1.		channels at: 1 put: (self encodeSoundBuffer: samples).		compressed			channels: channels;			samplingRate: newRate;			firstSample: 1;			loopEnd: samples size;			loopLength: 0.0;			perceivedPitch: 100.0;			gain: aSound loudness.		^ compressed].	(aSound isKindOf: LoopedSampledSound) ifTrue: [		aSound isStereo			ifTrue: [				channels _ Array new: 2.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples).				channels at: 2 put: (self encodeSoundBuffer: aSound rightSamples)]			ifFalse: [				channels _ Array new: 1.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples)].		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: aSound firstSample;			loopEnd: aSound loopEnd;			loopLength: aSound loopLength;			perceivedPitch: aSound perceivedPitch;			gain: aSound gain.		^ compressed].	self error: 'you can only compress sampled sounds'.! !!SoundRecorder methodsFor: 'accessing' stamp: 'RAA 12/30/2000 10:28'!desiredSampleRate: newRate	"use of this method indicates a strong desire for the specified rate, even if	the OS/hardware are not cooperative"	desiredSampleRate _ samplingRate _ newRate  "Best are 44100 22050 11025"! !!SoundRecorder methodsFor: 'private' stamp: 'RAA 12/30/2000 10:21'!emitBuffer: buffer	| sound ratio newCount resultBuf fromIndex sum |	"since some sound recording devices cannot (or will not) record below a certain sample rate,	trim the samples down if the user really wanted fewer samples"	(desiredSampleRate isNil or: [(ratio _ samplingRate // desiredSampleRate) <= 1]) ifTrue: [		sound _ SampledSound new setSamples: buffer samplingRate: samplingRate.	] ifFalse: [		newCount _ buffer monoSampleCount // ratio.		resultBuf _ SoundBuffer newMonoSampleCount: newCount.		fromIndex _ 1.		1 to: newCount do: [ :i |			sum _ 0.			ratio timesRepeat: [				sum _ sum + (buffer at: fromIndex).				fromIndex _ fromIndex + 1.			].			resultBuf at: i put: sum // ratio.		].		sound _ SampledSound new setSamples: resultBuf samplingRate: desiredSampleRate.	].	recordedSound add: (codec ifNil: [sound] ifNotNil: [codec compressSound: sound])! !