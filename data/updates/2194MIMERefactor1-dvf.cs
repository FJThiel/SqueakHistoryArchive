'From Squeak2.8alpha of 4 February 2000 [latest update: #2158] on 20 May 2000 at 12:27:00 pm'!"Change Set:		071MIMERefactor1-dvfDate:			18 May 2000Author:			Daniel VainsencherMedium surgery moving some of the text massaging into the MIME classes, and out of it's clients. Makes it trivial to add a stream of stuff to a message as an encoded attachment. Still uses text as the basic medium for changes - direct modification of MIME contents awaits for next refactoring."!!CelesteComposition methodsFor: 'access' stamp: 'dvf 5/13/2000 16:51'!submit	"submit the message"	textEditor		ifNotNil: [self hasUnacceptedEdits ifTrue: [textEditor accept]].	celeste queueMessageWithText: (MailMessage from: messageText asString) asSendableText.	morphicWindow ifNotNil: [morphicWindow delete].	mvcWindow ifNotNil: [mvcWindow controller close]! !!CelesteComposition methodsFor: 'interface' stamp: 'dvf 5/13/2000 12:31'!addAttachment	| file fileResult fileName |	textEditor		ifNotNil: [self hasUnacceptedEdits ifTrue: [textEditor accept]].	"transform into multipart if needed"	self hasAttachments ifFalse: [self transformToMultipart].	"then simply append another attachment section"	(fileResult _ StandardFileMenu oldFile)		ifNotNil: 			[fileName _ fileResult directory fullNameFor: fileResult name.			file _ FileStream oldFileNamed: fileName.			file ifNotNil: [self messageText: ((MailMessage from: self messageText)						asTextEncodingNewPart: file named: fileResult name)]] ! !!CelesteComposition methodsFor: 'interface' stamp: 'dvf 5/13/2000 12:16'!transformToMultipart	| oldPart |	oldPart _ MailMessage from: self messageText asString.	self messageText: oldPart asMultipartText	! !!MIMEPart methodsFor: 'as yet unclassified' stamp: 'dvf 5/13/2000 23:08'!save	| fileName decoder file decoderClass bufferStream |	(fileName _ self name) ifNil: [fileName _ FillInTheBlank request: 'File name for save?' initialAnswer: 'attachment' , Utilities dateTimeSuffix].	fileName ifNil: [^ nil].	file _ FileStream newFileNamed: fileName.	file binary.	(decoderClass _ self decoderClass) ifNil: ["decoder not needed or unknown"		file nextPutAll: self content]		ifNotNil: 			[decoder _ decoderClass new.			bufferStream _ WriteStream on: String new.			decoder dataStream: bufferStream;			 mimeStream: (ReadStream on: self content);			 mimeDecode.			file nextPutAll: bufferStream contents asByteArray].	file close ! !!MailMessage methodsFor: 'printing/formatting' stamp: 'dvf 5/13/2000 16:39'!asSendableText	"break lines in the given string into shorter lines"	| result start end pastHeader atAttachment width aString |	width _ 72.	aString _ self text.	result _ WriteStream on: (String new: aString size * 50 // 49).	pastHeader _ false.	atAttachment _ false.	aString asString		linesDo: 			[:line | 			line isEmpty ifTrue: [pastHeader _ true].			pastHeader				ifTrue: 					[(line beginsWith: '====')						ifTrue: [atAttachment _ true].					atAttachment						ifTrue: 							["at or after an attachment line; no more 							wrapping for the rest of the message"							result nextPutAll: line.							result cr]						ifFalse: [(line beginsWith: '>')								ifTrue: 									["it's quoted text; don't wrap it"									result nextPutAll: line.									result cr]								ifFalse: 									["regular old line.  Wrap it to multiple 									lines "									start _ 1.									"output one shorter line each time 									through this loop"									[start + width <= line size]										whileTrue: 											["find the end of the line"											end _ start + width - 1.											[end >= start and: [(line at: end + 1) isSeparator not]]												whileTrue: [end _ end - 1].											end < start ifTrue: ["a word spans the entire 												width!! "												end _ start + width - 1].											"copy the line to the output"											result nextPutAll: (line copyFrom: start to: end).											result cr.											"get ready for next iteration"											start _ end + 1.											(line at: start) isSeparator ifTrue: [start _ start + 1]].									"write out the final part of the line"									result nextPutAll: (line copyFrom: start to: line size).									result cr]]]				ifFalse: 					[result nextPutAll: line.					result cr]].	^ result contents! !!MailMessage methodsFor: 'multipart' stamp: 'dvf 5/13/2000 16:25'!asMultipartText	"Return a multipart mime-formatted text otherwise equivalent to this  	message."	| attachmentSeparator newText strm |	self body isMultipart ifTrue: [^ self text].	attachmentSeparator _ MailMessage generateSeparator.	newText _ String new: 200.	strm _ WriteStream on: newText.	strm nextPutAll: 'Mime-Version: 1.0';	 cr;	 nextPutAll: 'Content-Type: multipart/mixed; boundary="';	 nextPutAll: attachmentSeparator;	 nextPut: $";	 cr;	 nextPutAll: self fieldsAsMimeHeader;	 cr;	 cr;	 nextPutAll: '--' , attachmentSeparator;	 cr;	 nextPutAll: 'Content-Type: text/plain; charset="us-ascii"';	 cr;	 cr;	 nextPutAll: self content;	 cr;	 nextPutAll: '--' , attachmentSeparator;	 cr.	^strm contents! !!MailMessage methodsFor: 'multipart' stamp: 'dvf 5/13/2000 16:27'!asTextEncodingNewPart: aStream named: aName 	"Return a multipart mime-formatted text otherwise equivalent to this      	message, with the contents of aStream attached (base64 encoded)."	| strm |	strm _ WriteStream on: (String new: 100).	strm nextPutAll: self asMultipartText;	 cr;	 nextPutAll: 'Content-Type: application/octet-stream; name="' , aName , '"';	 cr;	 nextPutAll: 'Content-Disposition: attachment; filename="' , aName , '"';	 cr;	 nextPutAll: 'Content-Transfer-Encoding: base64';	 cr;	 cr.	Base64MimeConverter new dataStream: aStream;	 mimeStream: strm;	 mimeEncode.	strm cr; nextPutAll: '--' , self attachmentSeparator; cr.	^ strm contents! !!MailMessage methodsFor: 'multipart' stamp: 'dvf 5/13/2000 12:40'!attachmentSeparator	^(self fields at: 'content-type') parameters at: 'boundary' ! !