'From Squeak2.8alpha of 4 February 2000 [latest update: #1919] on 11 March 2000 at 9:01:38 pm'!"Change Set:		02MouseMenuRefactorings-smaDate:			11 March 2000Author:			Stefan Matthias AustThis started out as a fix to update 1879 and ended as a complete refactoring of the MouseMenuController class and its subclasses.  Be careful as that class doesn't work with PopupMenus anymore but requires SelectionMenus.  Overwrite #getPluggableYellowButtonMenu: to answer that menu."!Controller subclass: #MouseMenuController	instanceVariableNames: 'redButtonMenu redButtonMessages '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!MouseMenuController subclass: #BitEditor	instanceVariableNames: 'scale squareForm color transparent '	classVariableNames: 'YellowButtonMenu YellowButtonMessages'	poolDictionaries: ''	category: 'ST80-Editors'!Controller subclass: #ScreenController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!ScrollController subclass: #ParagraphEditor	instanceVariableNames: 'paragraph startBlock stopBlock beginTypeInBlock emphasisHere initialText selectionShowing otherInterval '	classVariableNames: 'ChangeText CmdActions CurrentSelection FindText Keyboard ShiftCmdActions TextEditorYellowButtonMenu UndoInterval UndoMessage UndoParagraph UndoSelection Undone '	poolDictionaries: 'TextConstants '	category: 'Kernel-ST80 Remnants'!!Controller methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:23'!isControlActive	"Answer whether receiver wishes to continue evaluating its controlLoop 	method. It is sent by Controller|controlLoop in order to determine when 	the receiver's control loop should terminate, and should be redefined in 	a subclass if some special condition for terminating the main control loop 	is needed."	^ self viewHasCursor		and: [sensor blueButtonPressed not		and: [sensor yellowButtonPressed not]]! !!MouseMenuController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:54'!release	super release.	redButtonMenu release! !!MouseMenuController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:54'!reset	"Eliminate references to all mouse button menus."	redButtonMenu _ nil.	redButtonMessages _ nil! !!MouseMenuController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:28'!controlActivity	"Refer to the comment in Controller|controlActivity."	| cursorPoint |	cursorPoint _ sensor cursorPoint.	super controlActivity.	(cursorPoint = sensor cursorPoint and: [self viewHasCursor])		ifTrue: 			[sensor redButtonPressed ifTrue: [^ self redButtonActivity].			sensor yellowButtonPressed ifTrue: [^ self yellowButtonActivity].			sensor blueButtonPressed ifTrue: [^ self blueButtonActivity]]! !!MouseMenuController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 11:24'!isControlActive 	"In contrast to class Controller, only blue button but not yellow button	events will end the receiver's control loop."	^ self viewHasCursor and: [sensor blueButtonPressed not]! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 15:01'!blueButtonActivity	"This normally opens the window menu. It is a no-op here	as only the StandardSystemController deals with that kind	of menus."! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 14:56'!redButtonActivity	"Determine which item in the red button pop-up menu is selected. If one 	is selected, then send the corresponding message to the object designated 	as the menu message receiver."	| index |	redButtonMenu ~~ nil		ifTrue: 			[index _ redButtonMenu startUp.			index ~= 0 				ifTrue: [self perform: (redButtonMessages at: index)]]		ifFalse: [super controlActivity]! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 14:59'!yellowButtonActivity	"This normally opens a popup menu. Determine the selected	item and, if one is selected, then send the corresponding message	to either the model or the receiver."	^ self pluggableYellowButtonActivity: sensor leftShiftDown! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:36'!getPluggableYellowButtonMenu: shiftKeyState	^ view getMenu: shiftKeyState! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:38'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's popup menu."	| menu selector |	(menu _ self getPluggableYellowButtonMenu: shiftKeyState)		ifNil: [sensor waitNoButton]		ifNotNil:			[(selector _ menu startUp) ifNil: [^ self].			self terminateAndInitializeAround: [model perform: selector orSendTo: self]]! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:37'!shiftedYellowButtonActivity	"Invoke the model's special popup menu."	^ self pluggableYellowButtonActivity: true! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:37'!unshiftedYellowButtonActivity	"Invoke the model's normal popup menu."	^ self pluggableYellowButtonActivity: false! !!MouseMenuController methodsFor: 'menu setup'!redButtonMenu: aSystemMenu redButtonMessages: anArray 	"Initialize the pop-up menu that should appear when the user presses the 	red mouse button to be aSystemMenu. The corresponding messages that 	should be sent are listed in the array, anArray."	redButtonMenu release.	redButtonMenu _ aSystemMenu.	redButtonMessages _ anArray! !!BitEditor methodsFor: 'control defaults' stamp: 'sma 3/11/2000 14:52'!isControlActive	^ super isControlActive and: [sensor keyboardPressed not]! !!BitEditor methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 15:04'!getPluggableYellowButtonMenu: shiftKeyState	^ YellowButtonMenu! !!BitEditor class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 14:48'!initialize	"The Bit Editor is the only controller to override the use of the blue	button with a different pop-up menu. Initialize this menu."	YellowButtonMenu _ SelectionMenu		labels:'cancelacceptfile outtest'		lines: #(2 3)		selections: #(cancel accept fileOut test)	"BitEditor initialize"! !!BitEditor class methodsFor: 'instance creation' stamp: 'sma 3/11/2000 11:29'!openScreenViewOnForm: aForm at: formLocation magnifiedAt: magnifiedLocation scale: scaleFactor	"Create and schedule a BitEditor on the form aForm. Show the magnified	view of aForm in a scheduled window."	| smallFormView bitEditor savedForm r |	smallFormView _ FormView new model: aForm.	smallFormView align: smallFormView viewport topLeft with: formLocation.	bitEditor _ self bitEdit: aForm at: magnifiedLocation scale: scaleFactor remoteView: smallFormView.	savedForm _ Form fromDisplay: (r _ bitEditor displayBox expandBy: (0@23 corner: 0@0)).	bitEditor controller startUp.	savedForm displayOn: Display at: r topLeft.	bitEditor release.	smallFormView release.	"BitEditor magnifyOnScreen."! !!FormEditor methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:07'!initialize	super initialize.	self setVariables! !!FormEditor methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:07'!isControlActive	^ super isControlActive and: [sensor keyboardPressed not]! !!FormEditor methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 15:08'!getPluggableYellowButtonMenu: shiftKeyState	^ YellowButtonMenu! !!FormEditor class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 15:06'!initialize	FlashCursor _ false.	self setKeyboardMap.	YellowButtonMenu _ SelectionMenu 		labels:'acceptcanceleditfile out'		lines: #(2)		selections: #(accept cancel edit fileOut).	"FormEditor initialize"! !!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:21'!controlActivity	"Any button opens the screen's menu.	If the shift key is down, do find window."	sensor leftShiftDown ifTrue: [^ self findWindow].	(self projectScreenMenu invokeOn: self) ifNil: [super controlActivity]! !!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:06'!isControlActive	^ self isControlWanted! !!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:05'!isControlWanted	^ self viewHasCursor and: [sensor anyButtonPressed]! !!ScreenController methodsFor: 'nested menus' stamp: 'sma 3/11/2000 12:23'!popUpMenuFor: aSymbol	(self perform: aSymbol) invokeOn: self! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:17'!controlActivity	self scrollByKeyboard ifTrue: [^ self].	self scrollBarContainsCursor		ifTrue: [self scroll]		ifFalse: [self normalActivity]! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:34'!isControlActive 	super isControlActive ifTrue: [^ true].	sensor blueButtonPressed ifTrue: [^ false].	^ scrollBar inside containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:31'!isControlWanted	^ self viewHasCursor! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:16'!normalActivity	super controlActivity! !!ParagraphEditor methodsFor: 'controlling' stamp: 'sma 3/11/2000 15:17'!normalActivity	self processKeyboard.	self processMouseButtons! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 3/11/2000 15:47'!getPluggableYellowButtonMenu: shiftKeyState	^ shiftKeyState		ifTrue: [self class shiftedYellowButtonMenu]		ifFalse: [self class yellowButtonMenu]! !!FillInTheBlankController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 14:45'!isControlActive	^ self isControlWanted! !!FillInTheBlankController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 14:45'!isControlWanted	^ model done not! !!PluggableListController reorganize!('initialization' initialize)('control defaults' redButtonActivity)('private' changeModelSelection: processKeyboard terminateDuringSelect:)!!PluggableListController methodsFor: 'private' stamp: 'sma 3/11/2000 15:38'!processKeyboard	sensor keyboardPressed		ifTrue: [view handleKeystroke: sensor keyboard]		ifFalse: [super processKeyboard]! !!PluggableListControllerOfMany reorganize!('control defaults' redButtonActivity)('scrolling' scrollView:)!!StandardSystemController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 11:48'!initialize	super initialize.	status _ #inactive! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:01'!blueButtonActivity	ScheduledBlueButtonMenu ifNil: [^ super controlActivity].	ScheduledBlueButtonMenu invokeOn: self! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:20'!controlActivity	self checkForReframe.	^ super controlActivity! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 11:39'!redButtonActivity	"If cursor is in label of a window when red button is pushed,	check for closeBox or growBox, else drag the window frame	or edit the label."	| box p |	p _ sensor cursorPoint.	self labelHasCursor ifFalse: [super redButtonActivity. ^ self].	((box _ view closeBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [self close. ^ self].			^ self].	((box _ view growBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed:					[Sensor controlKeyPressed ifTrue: [^ self expand; fullScreen].					^ view isCollapsed						ifTrue: [self expand]						ifFalse: [self collapse]].			^ self].	((box _ view labelTextRegion expandBy: 1) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [^ self label].			^ self].	self move! !!StandardSystemController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 15:12'!getPluggableYellowButtonMenu: shiftKeyState	^ nil! !!StandardSystemController class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 11:57'!initialize	"StandardSystemController initialize"	ScheduledBlueButtonMenu _ SelectionMenu		labels:'edit labelchoose color...two-tone/full colormoveframefull screencollapseclose'	lines: #(3 7)	selections: #(label chooseColor toggleTwoTone move reframe fullScreen collapse close).	VBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010010000100000		2r1010110000110000		2r1011111111111000		2r1010110000110000		2r1010010000100000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000)			offset: 0@0.	HBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1111111111111111		2r0000000000000000		2r1111111111111111		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: 0@0.! !!StrikeFont methodsFor: 'character shapes' stamp: 'sma 3/11/2000 11:28'!edit: character		"(TextStyle default fontAt: 1) edit: $_"	"Open a Bit Editor on the given character.  Note that you must do an accept	(in the option menu of the bit editor) if you want this work.	Accepted edits will not take effect in the font until you leave or close the bit editor.	Also note that unaccepted edits will be lost when you leave or close."	| charForm editRect scaleFactor bitEditor savedForm r |	charForm _ self characterFormAt: character.	editRect _ BitEditor locateMagnifiedView: charForm	                                        scale: (scaleFactor _ 8@8).	bitEditor _ BitEditor bitEdit: charForm at: editRect topLeft			scale: scaleFactor remoteView: nil.	savedForm _ Form fromDisplay: (r _ bitEditor displayBox expandBy: (0@23 corner: 0@0)).	bitEditor controller startUp.	bitEditor release.	savedForm displayOn: Display at: r topLeft.	self characterFormAt: character put: charForm! !MouseMenuController removeSelector: #startUpYellowButtonMenu!MouseMenuController removeSelector: #yellowButtonMenu:yellowButtonMessages:!MouseMenuController removeSelector: #blueButtonMenu:blueButtonMessages:!MouseMenuController removeSelector: #menuMessageReceiver!MouseMenuController removeSelector: #shiftedYellowButtonMenu!BitEditor removeSelector: #initialize!BitEditor removeSelector: #initializeYellowButtonMenu!BitEditor initialize!FormEditor removeSelector: #initializeYellowButtonMenu!FormEditor initialize!ScreenController removeSelector: #yellowButtonActivity!ScreenController removeSelector: #blueButtonActivity!ScreenController removeSelector: #hyperSqueakMenu!ScreenController removeSelector: #redButtonActivity!ScrollController removeSelector: #pluggableYellowButtonActivity:!ListController removeSelector: #isControlActive!ParagraphEditor removeSelector: #initialize!ParagraphEditor removeSelector: #isControlActive!ParagraphEditor removeSelector: #controlActivity!ParagraphEditor removeSelector: #initializeYellowButtonMenu!PluggableListController removeSelector: #unshiftedYellowButtonActivity!PluggableListController removeSelector: #shiftedYellowButtonActivity!PluggableListController removeSelector: #controlActivity!PluggableListController removeSelector: #yellowButtonActivity!PluggableTextController removeSelector: #unshiftedYellowButtonActivity!PluggableTextController removeSelector: #shiftedYellowButtonActivity!PluggableTextController removeSelector: #yellowButtonActivity!StandardSystemController removeSelector: #initializeBlueButtonMenu!StandardSystemController removeSelector: #menuMessageReceiver!MouseMenuController subclass: #BitEditor	instanceVariableNames: 'scale squareForm color transparent '	classVariableNames: 'YellowButtonMenu '	poolDictionaries: ''	category: 'ST80-Editors'!StandardSystemController initialize!