'From Squeak2.9alpha of 13 June 2000 [latest update: #2915] on 12 November 2000 at 5:43:20 pm'!"Change Set:		239NewSymbolTable1-sqrDate:			1 September 2000Author:			Andres ValloudNew symbol table, first changeset of who knows how many.Implements WeakSet, install support code in Symbol. Also removed old Bob code from Symbol class"!String variableByteSubclass: #Symbol	instanceVariableNames: ''	classVariableNames: 'OtherTable SelectorTables SingleCharSymbols SymbolTable '	poolDictionaries: ''	category: 'Collections-Text'!Set subclass: #WeakSet	instanceVariableNames: 'flag '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!!Set methodsFor: 'accessing' stamp: 'SqR 8/23/2000 13:51'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| index |	^(index _ self scanFor: anObject) = 0		ifFalse: [array at: index]! !!Set methodsFor: 'private' stamp: 'SqR 8/23/2000 14:39'!findElementOrNil: anObject	"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found."	| index |	index _ self scanFor: anObject.	index > 0 ifTrue: [^index].	"Bad scene.  Neither have we found a matching element	nor even an empty slot.  No hashed set is ever supposed to get	completely full."	self error: 'There is no free space in this set!!'.! !!Set methodsFor: 'private' stamp: 'SqR 8/23/2000 14:28'!fixCollisionsFrom: index	"The element at index has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"	| length oldIndex newIndex element |	oldIndex _ index.	length _ array size.	[oldIndex = length			ifTrue: [oldIndex _ 1]			ifFalse: [oldIndex _ oldIndex + 1].	(element _ self keyAt: oldIndex) == nil]		whileFalse: 			[newIndex _ self findElementOrNil: element.			oldIndex = newIndex ifFalse: [self swap: oldIndex with: newIndex]]! !!Symbol class methodsFor: 'new symbol table' stamp: 'SqR 8/23/2000 15:52'!initializeNewSymbolTable	SymbolTable _ WeakSet new! !!Symbol class methodsFor: 'new symbol table' stamp: 'SqR 8/23/2000 14:07'!newIntern: aStringOrSymbol	^(SymbolTable like: aStringOrSymbol)		ifNil:			[				SymbolTable add:					((aStringOrSymbol isKindOf: Symbol)						ifTrue: [aStringOrSymbol]						ifFalse: [(self new: aStringOrSymbol size) string: aStringOrSymbol])			]! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:06'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index _ self findElementOrNil: newObject.	((array at: index) == flag or: [(array at: index) isNil])		ifTrue: [self atNewIndex: index put: newObject].	^newObject! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:46'!do: aBlock	| each |	tally = 0 ifTrue: [^self].	1 to: array size do:		[:index |			((each _ array at: index) == nil or: [each == flag])				ifFalse: [aBlock value: each]		]! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 14:51'!includes: anObject 	^ (array at: (self findElementOrNil: anObject)) ~~ flag! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 16:02'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| index element |	^(index _ self scanFor: anObject) = 0		ifFalse: [(element _ array at: index) == flag ifFalse: [element]]! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:50'!printElementsOn: aStream	aStream nextPut: $(.	self do: [:element | aStream print: element; space].	element ifNotNil: [aStream skip: -1].	aStream nextPut: $)! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:08'!remove: oldObject ifAbsent: aBlock	| index |	index _ self findElementOrNil: oldObject.	(array at: index) == flag ifTrue: [ ^ aBlock value ].	array at: index put: flag.	tally _ tally - 1.	self fixCollisionsFrom: index.	^oldObject! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:12'!size	"Careful!! Answer the maximum amount	of elements in the receiver, not the	exact amount"	^tally! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:17'!slowSize	"Careful!! Answer the maximum amount	of elements in the receiver, not the	exact amount"	tally _ array inject: 0 into:		[:total :each | (each == nil or: [each == flag])			ifTrue: [total] ifFalse: [total + 1]].	^tally! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 14:30'!fixCollisionsFrom: index	"The element at index has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"	| length oldIndex newIndex element |	oldIndex _ index.	length _ array size.	[oldIndex = length			ifTrue: [oldIndex _ 1]			ifFalse: [oldIndex _ oldIndex + 1].	(element _ self keyAt: oldIndex) == flag]		whileFalse: 			[newIndex _ self findElementOrNil: element.			oldIndex = newIndex ifFalse: [self swap: oldIndex with: newIndex]]! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 15:43'!grow	"Grow the elements array and reinsert the old elements"	self growTo: array size + self growSize! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 15:43'!growTo: anInteger	"Grow the elements array and reinsert the old elements"	| oldElements |	oldElements _ array.	array _ WeakArray new: anInteger.	array atAllPut: flag.	tally _ 0.	oldElements do:		[:each | (each == flag or: [each == nil]) ifFalse: [self noCheckAdd: each]]! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 14:38'!init: n	"Initialize array to an array size of n"	flag _ Object new.	array _ WeakArray new: n.	array atAllPut: flag.	tally _ 0! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 15:43'!rehash	self growTo: array size! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 14:35'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements"	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == flag or: [element = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == flag or: [element = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakSet reorganize!('public' add: do: includes: like: printElementsOn: remove:ifAbsent: size slowSize)('private' fixCollisionsFrom: grow growTo: init: rehash scanFor:)!!Symbol class reorganize!('access' morePossibleSelectorsFor: otherThatStarts:skipping: possibleSelectorsFor: selectorsContaining: thatStarts:skipping:)('class initialization' initialize)('instance creation' intern: internCharacter: newFrom: readFrom:)('private' fastRehash hasInterned:ifTrue: rehash slowRehash useArrayTables useWeakArrayTables)('new symbol table' initializeNewSymbolTable newIntern:)!"Postscript:Initialize the symbol table"Symbol class removeSelector: #testTiming.Symbol initializeNewSymbolTable!