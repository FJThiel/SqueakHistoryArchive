'From Squeak3.7alpha of 11 September 2003 [latest update: #5816] on 30 March 2004 at 11:29:24 am'!"Change Set:		DateTimeFactoredPrint-nkDate:			30 March 2004Author:			Ned KonzMakes all the Kernel-Chronology-Tests test cases pass in a 5816 image.This requires the following prerequisites:	accurateDateAndTimeNowV2-avi (21 February, Avi Bryant)	testChronologyHours12-brp (12 March, Brent Pinkney)	chronologyTimeStampNow-brp (12 March, Brent Pinkney)v2 (30 March 2004):- sped up DateAndTime comparisons considerably (very noticeable on BFAV)- sped up DateAndTime creation (ticks:offset:)- added default initialization of Duration to 0- sped up Duration class>>seconds: and Duration class>>zero- fixed broken test cases- added timezone saving/restoring to test cases- removed linefeeds- removed some assumptions about strict monotonicity of Timestamps from test cases  (which is appropriate for this version of the Timestamp code, but may need to  be revisited if the Timestamp logic is changed).v1 (12 March 2004):- Factors DateAndTime>>printOn: into separate parts for easier use.- Omits leading space by default in printOn:- Adds alternative printOn:withLeadingSpace:- Fixes DateAndTime test cases- Omits recompilation of Deprecated>>defaultAction from test cases (why was this done?)- Fixes the spelling of 'Greenwich'- Adds a class comment to Date- Changes TimeZone default to report UTC rather than GMT"!!Date commentStamp: '<historical>' prior: 0!Instances of Date are Timespans with duration of 1 day.Their default creation assumes a start of midnight in the local time zone.!!Stopwatch commentStamp: '<historical>' prior: 0!A Stopwatch maintains a collection of timespans.!!Time commentStamp: '<historical>' prior: 0!This represents a period of time.!!TimeStamp commentStamp: '<historical>' prior: 0!This represents a duration of 0 length that marks a particular point in time.!!TimeTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Time.!!DateAndTime methodsFor: 'ansi protocol' stamp: 'nk 3/30/2004 09:09'!< comparand	"comparand conforms to protocol DateAndTime,	or can be converted into something that conforms."	| lticks rticks comparandAsDateAndTime |	comparandAsDateAndTime := comparand asDateAndTime.	offset = comparandAsDateAndTime offset		ifTrue: [lticks := self ticks.			rticks := comparandAsDateAndTime ticks]		ifFalse: [lticks := self asUTC ticks.			rticks := comparandAsDateAndTime asUTC ticks].	^ lticks first < rticks first		or: [lticks first > rticks first				ifTrue: [false]				ifFalse: [lticks second < rticks second						or: [lticks second > rticks second								ifTrue: [false]								ifFalse: [lticks third < rticks third]]]]! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'nk 3/30/2004 08:49'!= comparand	"comparand conforms to protocol DateAndTime,	or can be converted into something that conforms."	| comparandAsDateAndTime |	self == comparand		ifTrue: [^ true].	[comparandAsDateAndTime := comparand asDateAndTime]		on: MessageNotUnderstood		do: [^ false].	^ self offset = comparandAsDateAndTime offset		ifTrue: [self ticks = comparandAsDateAndTime ticks]		ifFalse: [self asUTC ticks = comparandAsDateAndTime asUTC ticks]! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'nk 3/12/2004 10:03'!printHMSOn: aStream	"Print just hh:mm:ss"	aStream		nextPutAll: (self hour asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (self minute asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (self second asString padded: #left to: 2 with: $0).! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'nk 3/12/2004 10:38'!printOn: aStream	"Print as per ISO 8601 sections 5.3.3 and 5.4.1.	Prints either:		'YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)"	^self printOn: aStream withLeadingSpace: false! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'nk 3/12/2004 10:37'!printOn: aStream withLeadingSpace: printLeadingSpaceToo	"Print as per ISO 8601 sections 5.3.3 and 5.4.1.	If printLeadingSpaceToo is false, prints either:		'YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)	If printLeadingSpaceToo is true, prints either:		' YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)	"	self printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo.	aStream nextPut: $T.	self printHMSOn: aStream.	self nanoSecond ~= 0 ifTrue:		[ | z ps |		ps := self nanoSecond printString padded: #left to: 9 with: $0.		z := ps findLast: [ :c | c asciiValue > $0 asciiValue ].		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ].	aStream		nextPut: (offset positive ifTrue: [$+] ifFalse: [$-]);		nextPutAll: (offset hours abs asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (offset minutes abs asString padded: #left to: 2 with: $0).	offset seconds = 0 ifFalse:		[ aStream			nextPut: $:;			nextPutAll: (offset seconds abs truncated asString) ].! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'nk 3/12/2004 10:29'!printYMDOn: aStream	"Print just YYYY-MM-DD part.	If the year is negative, prints out '-YYYY-MM-DD'."	^self printYMDOn: aStream withLeadingSpace: false.! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'nk 3/12/2004 10:29'!printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo	"Print just the year, month, and day on aStream.	If printLeadingSpaceToo is true, then print as:		' YYYY-MM-DD' (if the year is positive) or '-YYYY-MM-DD' (if the year is negative)	otherwise print as:		'YYYY-MM-DD' or '-YYYY-MM-DD' "	| year month day |	self dayMonthYearDo: [ :d :m :y | year := y. month := m. day := d ].	year negative		ifTrue: [ aStream nextPut: $- ]		ifFalse: [ printLeadingSpaceToo ifTrue: [ aStream space ]].	aStream		nextPutAll: (year abs asString padded: #left to: 4 with: $0);		nextPut: $-;		nextPutAll: (month asString padded: #left to: 2 with: $0);		nextPut: $-;		nextPutAll: (day asString padded: #left to: 2 with: $0)! !!DateAndTime methodsFor: 'private' stamp: 'nk 3/30/2004 09:38'!ticks: ticks offset: utcOffset	"ticks is {julianDayNumber. secondCount. nanoSeconds}"	| normalize |	normalize := [ :i :base | | tick div quo rem |		tick := ticks at: i.		div := tick digitDiv: base neg: tick negative.		quo := div first normalize.		rem := div second normalize.		rem < 0 ifTrue: [ quo := quo - 1. rem := base + rem ].		ticks at: (i-1) put: ((ticks at: i-1) + quo).		ticks at: i put: rem ].	normalize value: 3 value: NanosInSecond.	normalize value: 2 value: SecondsInDay.	jdn	_ ticks first.	seconds	_ ticks second.	nanos := ticks third.	offset := utcOffset.! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'nk 3/30/2004 09:53'!localTimeZone: aTimeZone	"Set the local time zone"	"	DateAndTime localTimeZone: (TimeZone offset:  0 hours name: 'Universal Time' abbreviation: 'UTC').	DateAndTime localTimeZone: (TimeZone offset: -8 hours name: 'Pacific Standard Time' abbreviation: 'PST').	"	LocalTimeZone := aTimeZone! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'nk 3/12/2004 10:16'!testPrintOn	| cs rw |	cs := ReadStream on: '1901-01-01T00:00:00+00:00'.	rw := ReadWriteStream on: ''.	aDateAndTime printOn: rw.	self assert: rw contents = cs contents.	cs  := ReadStream on: 'a TimeZone(ETZ)'.	rw := ReadWriteStream on: ''.	aTimeZone printOn:  rw.	self assert: rw contents = cs contents! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'nk 3/12/2004 11:26'!testtimeZone	self assert: aDateAndTime timeZoneName	= 'Universal Time'.	self assert: aDateAndTime timeZoneAbbreviation	=  'UTC'! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'nk 3/12/2004 11:27'!testPrintOn	| cs rw |	cs := ReadStream on: '2004-02-29T13:33:00+02:00'.	rw := ReadWriteStream on: ''.	aDateAndTime printOn: rw.	self assert: rw contents = cs contents.	cs  := ReadStream on: 'a TimeZone(UTC)'.	rw := ReadWriteStream on: ''.	aTimeZone printOn:  rw.	self assert: rw contents = cs contents	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'nk 3/12/2004 11:26'!testtimeZone	self assert: aDateAndTime timeZoneName	= 'Universal Time'.	self assert: aDateAndTime timeZoneAbbreviation	=  'UTC'! !!DateAndTimeLeapTest methodsFor: 'running' stamp: 'nk 3/12/2004 11:00'!setUp	localTimeZoneToRestore := DateAndTime localTimeZone.	DateAndTime localTimeZone: TimeZone default.	aDateAndTime := (DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: 2 hours).	aTimeZone := TimeZone default.	aDuration := Duration days: 0 hours: 13 minutes: 33 seconds: 0 nanoSeconds: 0! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'nk 3/12/2004 11:06'!testMonotonicity	| t1 t2 t3 t4 |	t1 := DateAndTime now.	t2 := DateAndTime now.	(Delay forMilliseconds: 1000) wait.	t3 := DateAndTime now.	t4 := DateAndTime now.	self		assert: (	t1 <= t2);		assert: (	t2 < t3);		assert: (	t3 <= t4).! !!Duration methodsFor: 'initialize-release' stamp: 'nk 3/30/2004 10:01'!initialize	self seconds: 0 nanoSeconds: 0.! !!Duration class methodsFor: 'ansi protocol' stamp: 'nk 3/30/2004 10:05'!seconds: aNumber	^ (self basicNew) seconds: aNumber nanoSeconds: 0; yourself.! !!Duration class methodsFor: 'ansi protocol' stamp: 'nk 3/30/2004 10:06'!zero	^ (self basicNew) seconds: 0 nanoSeconds: 0; yourself.! !!ScheduleTest methodsFor: 'Tests' stamp: 'nk 3/30/2004 10:34'!testMonotonicity	| t1 t2 t3 t4 |	t1 := DateAndTime now.	t2 := DateAndTime now.	t3 := DateAndTime now.	t4 := DateAndTime now.	self 		assert: (	t1 <= t2);		assert: (	t2 <= t3);		assert: (	t3 <= t4).! !!StopwatchTest methodsFor: 'Tests' stamp: 'nk 3/30/2004 11:14'!testStartStop	| sw t1 t2 t3 t4 |	sw := Stopwatch new.	t1 := DateAndTime now.	(Delay forMilliseconds: 10) wait.	sw activate; activate.	(Delay forMilliseconds: 10) wait.	t2 := DateAndTime now.		self 		deny: (sw isSuspended);		assert: (sw isActive);		assert: (sw timespans size = 1);		assert: (t1 < sw start);		assert: (sw start < t2).	(Delay forMilliseconds: 10) wait.	t3 := DateAndTime now.	(Delay forMilliseconds: 10) wait.	sw suspend; suspend.	(Delay forMilliseconds: 10) wait.	t4 := DateAndTime now.	self 		assert: (sw isSuspended);		deny: (sw isActive);		assert: (sw timespans size = 1);		assert: (sw end between: t3 and: t4);		assert: (t3 < sw end);		assert: (sw end < t4).! !!TimeTest methodsFor: 'Running' stamp: 'nk 3/30/2004 09:40'!setUp	localTimeZoneToRestore := DateAndTime localTimeZone.	DateAndTime localTimeZone: TimeZone default.	time := self timeClass fromSeconds: 14567.		"4:02:47 am"	aTime := Time readFrom: '12:34:56 pm' readStream! !!TimeTest methodsFor: 'Running' stamp: 'nk 3/30/2004 09:40'!tearDown	DateAndTime localTimeZone: localTimeZoneToRestore.! !!TimeTest methodsFor: 'testing' stamp: 'nk 3/30/2004 09:42'!testHour	self assert: aTime hour =  12.	self assert: aTime hour12 =  12.	self assert: aTime hour24 =  12.	self assert: aTime hours =  12.! !!TimeZone class methodsFor: 'accessing' stamp: 'nk 3/30/2004 10:21'!timeZones	^ {		self offset:  0 hours name: 'Universal Time' abbreviation: 'UTC'.		self offset:  0 hours name: 'Greenwich Mean Time' abbreviation: 'GMT'.		self offset:  0 hours name: 'British Summer Time' abbreviation: 'BST'.		self offset:  2 hours name: 'South African Standard Time' abbreviation: 'SAST'.		self offset: -8 hours name: 'Pacific Standard Time' abbreviation: 'PST'.		self offset: -7 hours name: 'Pacific Daylight Time' abbreviation: 'PDT'.	}! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'nk 3/30/2004 11:12'!testWeeksDo	| weeks weekArray |	weeks := aTimespan weeks.	self assert: weeks size = ((aDuration days / 7.0) ceiling + 1).	weekArray := OrderedCollection new.	weekArray		addLast: (Week starting: (DateAndTime year: 2004 month: 12 day: 26) duration: 7 days).	2 to: 86 by: 7 do:		[ :i | weekArray				addLast: (Week starting: (DateAndTime year: 2005 day: i) duration: 7 days) ].	weekArray := weekArray asArray.	self assert: aTimespan weeks = weekArray! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'nk 3/30/2004 11:08'!testYearsDo	| yearArray |	yearArray := Array				with: (Year						starting: (DateAndTime								year: 2004								month: 12								day: 25)						duration: 366 days).	self assert: aTimespan years = yearArray! !!TimespanTest methodsFor: 'Running' stamp: 'nk 3/30/2004 09:21'!setUp	localTimeZoneToRestore := DateAndTime localTimeZone.	DateAndTime localTimeZone: TimeZone default.	"100 hours starting noon 22 March 2003"	timespan := Timespan starting:					(DateAndTime year: 2003 month: 03 day: 22 hour: 12 minute: 0 second: 0)						duration: (Duration hours: 100).	dec31 := (DateAndTime year: 2004 month: 12 day: 31 hour: 0 minute: 0 second: 0).	jan01 := (DateAndTime year: 2005 month: 1 day: 1 hour: 0 minute: 0 second: 0).	jan08 := (DateAndTime year: 2005 month: 1 day: 8 hour: 0 minute: 0 second:0).	aDay := Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.	aWeek := Duration days: 7 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.	aTimespan := Timespan starting: jan01 duration: aWeek.	anOverlappingTimespan := Timespan starting: dec31 duration: aWeek.	anIncludedTimespan := Timespan starting: jan01 duration: aDay.	aDisjointTimespan := Timespan starting: jan08 duration: aWeek.! !!TimespanTest methodsFor: 'Running' stamp: 'nk 3/30/2004 09:22'!tearDown	DateAndTime localTimeZone: localTimeZoneToRestore.	timespan := nil! !!TimespanTest methodsFor: 'testing' stamp: 'nk 3/30/2004 09:26'!testCurrent	self assert: (Timespan starting: DateAndTime current)			<= Timespan current.	self assert:  Timespan current			<= (Timespan starting: DateAndTime current)! !!TimespanTest methodsFor: 'testing' stamp: 'nk 3/30/2004 09:23'!testPrintOn	| cs rw |	cs := ReadStream on: 'a Timespan(2005-01-01T00:00:00+00:00D7:00:00:00)'.	rw := ReadWriteStream on: ''.	aTimespan  printOn: rw.	self assert: rw contents = cs contents! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'nk 3/30/2004 10:32'!testWeekPrintOn	|aWeek cs rw |	aWeek := Week starting: DateAndTime new duration: 7 days. 	cs := 'a Week starting: 1900-12-31T00:00:00+00:00'.	rw := WriteStream on: ''.	aWeek printOn: rw.	self assert: rw contents = cs! !!Duration reorganize!('ansi protocol' * + - / < = abs asDuration asSeconds days hash hours minutes negated negative positive seconds)('initialize-release' initialize)('squeak protocol' // \\ asDelay asMilliSeconds asNanoSeconds nanoSeconds printOn: roundTo: truncateTo:)('private' seconds:nanoSeconds: storeOn: ticks)!