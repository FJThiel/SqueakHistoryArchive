'From Squeak 2.3 beta of Nov 25, 1998 on 24 December 1998 at 7:48:23 am'!!BookMorph methodsFor: 'accessing' stamp: 'tk 12/24/1998 07:27'!pageNumberOf: aMorph	"Modified so that if the page IS in memory, other pages don't have to be brought in.  (This method may wrongly say a page is not here if pages has a tombstone (MorphObjectOut) and that tombstone would resolve to an object already in this image.  This is an unlikely case, and callers just have to tolerate it.)"	^ pages identityIndexOf: aMorph ifAbsent: [0]! !!BookMorph methodsFor: 'navigation' stamp: 'tk 12/24/1998 07:14'!goToPage: pageNumber transitionSpec: transitionSpec	| pageIndex  aWorld oldPageNumber ascending newPage tSpec |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	tSpec _ transitionSpec ifNil:  "If transition not specified by requestor..."		[newPage valueOfProperty: #transitionSpec  " ... then consult new page"			ifAbsent: [self transitionSpecFor: self  " ... otherwise this is the default"]].	oldPageNumber _ pages identityIndexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue: [nil]			ifFalse: [oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	self currentPage ~~ nil		ifTrue:		[(((pages at: pageIndex) owner isKindOf: TransitionMorph)			and: [(pages at: pageIndex) isInWorld])			ifTrue: [^ self  "In the process of a prior pageTurn"].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		ascending ifNotNil:			["Show appropriate page transition and start new page when done"			currentPage stopStepping.			(pages at: pageIndex) position: currentPage position.			^ (TransitionMorph					effect: tSpec second					direction: tSpec third					inverse: (ascending or: [transitionSpec notNil]) not)				showTransitionFrom: currentPage				to: (pages at: pageIndex)				in: self				whenStart: [self playPageFlipSound: tSpec first]				whenDone:					[currentPage delete; fullReleaseCachedState.					self addMorphBack: (currentPage _ pages at: pageIndex).					self snapToEdgeIfAppropriate.					aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].					self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].					(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld]]].		"No transition, but at least decommission current page"		currentPage delete; fullReleaseCachedState].	self addMorphBack: (currentPage _ pages at: pageIndex).	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld].! !!BookMorph methodsFor: 'navigation' stamp: 'tk 12/24/1998 07:17'!goToPageMorph: aMorph	self goToPage: (pages identityIndexOf: aMorph ifAbsent: [^ self "abort"]).! !!BookMorph methodsFor: 'navigation' stamp: 'tk 12/24/1998 07:18'!goToPageMorph: aMorph fromBookmark: aBookmark	"This protocol enables sensitivity to a transitionSpec on the bookmark"		self goToPage: (pages identityIndexOf: aMorph ifAbsent: [^ self "abort"])		transitionSpec: (aBookmark valueOfProperty: #transitionSpec).! !!BookMorph methodsFor: 'navigation' stamp: 'tk 12/24/1998 07:19'!pageNumber	^ self pageNumberOf: currentPage! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/24/1998 07:39'!findText: wants	"turn to the next page that has all of the strings mentioned on it.  Maybe highlight one?  allText and allTextUrls have been set.  (is case insensitive now?)"	"Later sort wants so longest key is first"	| allText good thisWord here fromHereOn startToHere array |	allText _ self valueOfProperty: #allText ifAbsent: [#()].	here _ pages identityIndexOf: currentPage ifAbsent: [1].	fromHereOn _ here to: pages size.	startToHere _ 1 to: here-1.	fromHereOn do: [:pageNo | 		array _ allText at: pageNo.		good _ true.		wants do: [:searchString | "each key"			good ifTrue: [thisWord _ false.				array do: [:longString |					(longString findString: searchString startingAt: 1 						caseSensitive: false) > 0 ifTrue: [thisWord _ true]].				good _ thisWord]].		good ifTrue: ["all are on this page"			self goToPage: pageNo.			"highlight the text?"			^ true]].	startToHere do: [:pageNo | 		array _ allText at: pageNo.		good _ true.		wants do: [:searchString | "each key"			good ifTrue: [thisWord _ false.				array do: [:longString |					(longString findString: searchString startingAt: 1 						caseSensitive: false) > 0 ifTrue: [thisWord _ true]].				good _ thisWord]].		good ifTrue: ["all are on this page"			self goToPage: pageNo.			"highlight the text?"			^ true]].	^ false! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/24/1998 07:32'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu hand |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addList:	#(			('sort pages'				sortPages)			('uncache page sorter'	uncachePageSorter)			('make bookmark'		bookmarkForThisPage)			('make thumbnail'		thumbnailForThisPage)			('remove control panel'	hidePageControls)		).	aMenu addLine.	aMenu add: 'sound effect for all pages' action: #menuPageSoundForAll:.	aMenu add: 'sound effect this page only' action: #menuPageSoundForThisPage:.	aMenu add: 'visual effect for all pages' action: #menuPageVisualForAll:.	aMenu add: 'visual effect this page only' action: #menuPageVisualForThisPage:.	aMenu addLine.	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	aMenu add: 'search for text' action: #textSearch.	aMenu add: 'send all pages to server' action: #savePagesOnURL.	aMenu add: 'send this page to server' action: #saveOneOnURL.	aMenu add: 'reload all from server' action: #reload.	aMenu add: 'keep in one file' action: #keepTogether.	hand _ self world primaryHand.	aMenu popUpAt: hand position forHand: hand."	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel]."! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/24/1998 07:26'!saveOneOnURL	"Write out this single page in this book that are not showing, onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	| stem ind |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.		^ self].	"Don't give the chance to put in a different place.  Assume named by number"	stem _ self getStemUrl.	"user must approve"	stem size = 0 ifTrue: [^ self].	ind _ pages identityIndexOf: currentPage ifAbsent: [self error: 'where is the page?'].	currentPage isInMemory ifTrue: ["not out now"			currentPage saveOnURL: stem,(ind printString),'.sp'].	self saveIndexOfOnly: currentPage.! !