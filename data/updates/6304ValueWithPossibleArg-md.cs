'From Squeak3.8alpha of ''17 July 2004'' [latest update: #6301] on 7 October 2004 at 3:31:01 pm'!"Change Set:		ValueWithPossibleArg-mdDate:			7 October 2004Author:			Marcus DenkerV2: added documentation, revertet to the old implementation which wasfaster for the cases of 0 and 1 args.Implements BlockContext>>valueWithPossibleArgument: as suggsted by avi,adds test for both valueWithPossibleArgument: and valueWithPossibleArgs:"!!BlockContext methodsFor: 'evaluating' stamp: 'md 10/7/2004 15:24'!valueWithPossibleArgs: anArray      "Evaluate the block represented by the receiver.      If the block requires arguments, take them from anArray. If anArray is too     large, the rest is ignored, if it is too small, use nil for the other arguments" 	self numArgs = 0 ifTrue: [^self value].	self numArgs = anArray size ifTrue: [^self valueWithArguments: anArray].	self numArgs > anArray size ifTrue: [		^self valueWithArguments: anArray,				(Array new: (self numArgs - anArray size))	].	^self valueWithArguments: (anArray copyFrom: 1 to: self numArgs)! !!BlockContext methodsFor: 'evaluating' stamp: 'md 10/7/2004 15:26'!valueWithPossibleArgument: anArg      "Evaluate the block represented by the receiver.      If the block requires one argument, use anArg, if it requires more than one,     fill up the rest with nils."	self numArgs = 0 ifTrue: [^self value].	self numArgs = 1 ifTrue: [^self value: anArg].	self numArgs  > 1 ifTrue: [^self valueWithArguments: {anArg}, (Array new: self numArgs  - 1)]! !!BlockContextTest methodsFor: 'testing - evaluating' stamp: 'md 10/7/2004 13:52'!testValueWithPossibleArgs	| block  blockWithArg blockWith2Arg |	block := [1].	blockWithArg  := [:arg | arg].	blockWith2Arg := [:arg1 :arg2 | {arg1. arg2}].	self assert: (block valueWithPossibleArgs: #()) = 1.	self assert: (block valueWithPossibleArgs: #(1)) = 1.		self assert: (blockWithArg valueWithPossibleArgs: #()) = nil.	self assert: (blockWithArg valueWithPossibleArgs: #(1)) = 1.	self assert: (blockWithArg valueWithPossibleArgs: #(1 2)) = 1.	self assert: (blockWith2Arg valueWithPossibleArgs: #()) = {nil .nil}.	self assert: (blockWith2Arg valueWithPossibleArgs: #(1)) =  {1 . nil}.	self assert: (blockWith2Arg valueWithPossibleArgs: #(1 2)) =  #(1 2).	self assert: (blockWith2Arg valueWithPossibleArgs: #(1 2 3)) = #(1 2).			! !!BlockContextTest methodsFor: 'testing - evaluating' stamp: 'md 10/7/2004 13:59'!testValueWithPossibleArgument	| block  blockWithArg blockWith2Arg |	block := [1].	blockWithArg  := [:arg | arg].	blockWith2Arg := [:arg1 :arg2 | {arg1. arg2}].	self assert: (block valueWithPossibleArgument: 1) = 1.		self assert: (blockWithArg valueWithPossibleArgument: 1) = 1.		self assert: (blockWith2Arg valueWithPossibleArgument: 1) = {1 . nil}.		! !!BlockContextTest reorganize!('testing - evaluating' testValueWithArguments testValueWithPossibleArgs testValueWithPossibleArgument)('testing' testBlockIsBottomContext testCopyStack testFindContextSuchThat testNew testNoArguments testOneArgument testRunSimulated testSetUp testTallyInstructions testTallyMethods testTrace)('setup' setUp)!!BlockContext reorganize!('initialize-release' home:startpc:nargs: privRefresh)('accessing' argumentCount blockHome copyForSaving finalBlockHome fixTemps hasInstVarRef hasMethodReturn home isBlock isExecutingBlock isMethodContext method numArgs receiver reentrant tempAt: tempAt:put:)('evaluating' bench durationToRun ifError: timeToRun value value: value:value: value:value:value: value:value:value:value: valueWithArguments: valueWithPossibleArgs: valueWithPossibleArgument:)('controlling' doWhileFalse: doWhileTrue: repeat repeatWithGCIf: whileFalse whileFalse: whileTrue whileTrue:)('scheduling' fork forkAndWait forkAt: forkAt:named: forkNamed: newProcess newProcessWith:)('instruction decoding' blockReturnTop)('printing' decompile fullPrintOn: printOn: printOnStream:)('private' aboutToReturn:through: cannotReturn: copyTo:blocks: instVarAt:put: privHome: startpc valueError valueUnpreemptively)('system simulation' pushArgs:from: stepToSendOrReturn)('exceptions' assert ensure: ifCurtailed: on:do: onDNU:do: valueUninterruptably)('private-exceptions' ifProperUnwindSupportedElseSignalAboutToReturn)('private-debugger' hideFromDebugger)('*sunit-preload' sunitEnsure: sunitOn:do:)!