'From Squeak3.1alpha [latest update: #''Squeak3.1alpha'' of 5 February 2001 update 3959] on 30 April 2001 at 11:36:04 am'!"Change Set:		NewUpdateLogicDate:			28 April 2001Author:			Dan IngallsThis changeSet adapts the broadcast of updates (from internal to external streams) to the new scheme where the files are shared, and only the indices (*updates.list) are different.It also reimplements the handling of updates.list so that it gets parsed into a list that can be easily be manipulated without needing to reread the files.  This should speed the update process.It also moves the backup of the old updates.list index to the local disk of the person making the update.  This is faster and simpler."!!ServerDirectory methodsFor: 'updates' stamp: 'di 4/29/2001 10:46'!checkServersWithPrefix: prefix andParseListInto: listBlock	"Check that all servers are up and have the latest Updates.list.	Warn user when can't write to a server that can still be read.	The contents of updates.list is parsed into {{vers. {fileNames*}}*},	and returned via the listBlock."	| final fileSize this serverList listContents decided myContents abort |	serverList _ group			ifNil: [Array with: self]			ifNotNil: [group value].	final _ OrderedCollection new.	fileSize _ 0.  listContents _ ''.	"list of updates"	abort _ false.	serverList do: [:aServer |		decided _ false.		this _ aServer getFileNamed: prefix , 'updates.list'.		(this = #error:) ifTrue: [^'' "Not found"].		this class == String ifTrue: ["no ftp"			(PopUpMenu labels: 'Cancel entire update' withCRs)				startUpWithCaption: 'Server ', aServer moniker,				' is unavailable.\Please consider phoning the administator.\' withCRs, this.			abort _ true.			decided _ true].		decided not & (this size > fileSize) ifTrue:			["new has a longer update.list"			fileSize _ this size.			final do: [:each | abort _ self outOfDate: each].			(final _ OrderedCollection new) add: aServer.			listContents _ this contentsOfEntireFile.			listBlock value: (Utilities parseListContents: listContents).			decided _ true].		decided not & (this size < fileSize) ifTrue:			[abort _ self outOfDate: aServer.  decided _ true].		decided not ifTrue:			[myContents _ this contentsOfEntireFile.			myContents = listContents				ifTrue: [final add: aServer]				ifFalse: [abort _ self outOfDate: aServer]].		abort ifTrue: [^ Array new].		].	^ final! !!ServerDirectory methodsFor: 'updates' stamp: 'di 4/30/2001 11:29'!exportUpdatesExcept: skipList	"Into the section of updates.list corresponding to this version,	copy all the fileNames in the named updates.list for this group	that are more recently numbered.		(ServerDirectory groupNamed: 'Disney Internal Updates*')			exportUpdatesExcept: #(3959)."	| myServers updateStrm response seq indexPrefix listContents version versIndex lastNum expContents expVersIndex additions |	self openGroup.	indexPrefix _ (group key includes: $*) 		ifTrue: [(group key findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	myServers _ self checkServersWithPrefix: indexPrefix					andParseListInto: [:x | listContents _ x].	myServers size = 0 ifTrue: [self closeGroup.  ^ self].	version _ SystemVersion current version.	versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for your version'.		self closeGroup.  ^ nil].	"abort"	versIndex < listContents size ifTrue:		[response _ (PopUpMenu labels: 'Make update for an older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', SystemVersion current version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil]].	"abort"	"Get the old export updates.list."	expContents _  Utilities parseListContents: 			(myServers first getFileNamed: 'updates.list') contentsOfEntireFile.	expVersIndex _ (expContents collect: [:pair | pair first]) indexOf: version.	expVersIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for your version'.		self closeGroup.  ^ nil].	"abort"	lastNum _ (expContents at: expVersIndex) last last initialIntegerOrNil.	"Save old copy of updates.list on local disk"	FileDirectory default deleteFileNamed: 'updates.list.bk'.	Utilities writeList: expContents toStream: (FileStream fileNamed: 'updates.list.bk').	"Append all fileNames in my list that are not in the export list"	additions _ OrderedCollection new.	(listContents at: versIndex) last do:		[:fileName | seq _ fileName initialIntegerOrNil.		(seq > lastNum and: [(skipList includes: seq) not]) ifTrue:			[additions addLast: fileName]].	expContents at: expVersIndex put:		{version. (expContents at: expVersIndex) last , additions}.	(self confirm: 'Do you really want to export ' , additions size printString , ' recent updates?')		ifFalse: [self closeGroup.  ^ nil].	"abort"	"Write a new copy of updates.list on all servers..."	updateStrm _ ReadStream on:		(String streamContents: [:s | Utilities writeList: expContents toStream: s]).	myServers do:		[:aServer |		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript show: 'Update succeeded on server ', aServer moniker; cr].	self closeGroup.			Transcript cr; show: 'Be sure to test your new update!!'; cr.! !!ServerDirectory methodsFor: 'updates' stamp: 'di 4/30/2001 08:38'!putUpdate: fileStrm 	"Put this file out as an Update on the servers of my group.  Each version of the system may have its own set of update files, or they may all share the same files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class readServerUpdatesThrough:saveLocally:updateImage:.	When two sets of updates are stored on the same directory, one of them has a * in its serverUrls description.  When that is true, the first word of the description is put onthe front of 'updates.list', and that index file is used."	| myServers updateStrm newName myName response localName seq indexPrefix listContents version versIndex lastNum stripped |	localName _ fileStrm localName.	fileStrm size = 0 ifTrue:		[^ self inform: 'That file has zero bytes!!  May have a new name.'].	(fileStrm contentsOfEntireFile includes: Character linefeed)		ifTrue: [self notify: 'That file contains linefeeds.Proceed if you know that this is okay (e.g. the file contains raw binary data).'].	fileStrm reset.	(self checkNames: {localName}) ifFalse: [^ nil].	"illegal characters"	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', localName, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	indexPrefix _ (group key includes: $*) 		ifTrue: [(group key findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	myServers _ self checkServersWithPrefix: indexPrefix					andParseListInto: [:x | listContents _ x].	myServers size = 0 ifTrue: [self closeGroup.  ^ self].	version _ SystemVersion current version.	versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for your version'.		self closeGroup.  ^ nil].	"abort"	lastNum _ (listContents at: versIndex) last last initialIntegerOrNil.	versIndex < listContents size ifTrue:		[response _ (PopUpMenu labels: 'Make update for an older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', SystemVersion current version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil]].	"abort"	"Save old copy of updates.list on local disk"	FileDirectory default deleteFileNamed: indexPrefix , 'updates.list.bk'.	Utilities writeList: listContents toStream: (FileStream fileNamed: indexPrefix , 'updates.list.bk').	"append name to updates with new sequence number"	seq _ (lastNum + 1) printString padded: #left to: 4 with: $0.	"strip off any old seq number"	stripped _ localName copyFrom: (localName  findFirst: [:c | c isDigit not]) to: localName size.	newName _ seq , stripped.	listContents at: versIndex put:		{version. (listContents at: versIndex) last copyWith: newName}.	"Write a new copy on all servers..."	updateStrm _ ReadStream on:		(String streamContents: [:s | Utilities writeList: listContents toStream: s]).	myServers do:		[:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName retry: true.		updateStrm reset.		aServer putFile: updateStrm named: indexPrefix , 'updates.list' retry: true.		Transcript show: 'Update succeeded on server ', aServer moniker; cr].	self closeGroup.			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: localName toBe: newName.! !!ServerDirectory methodsFor: 'updates' stamp: 'di 4/30/2001 10:30'!putUpdateMulti: list fromDirectory: updateDirectory 	"Put these files out as an Update on the servers of my group.  List is an array of local file names without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm lastNum myName response newNames file numStr indexPrefix listContents version versIndex seq stripped |self inform: 'This code has not been tested since the rewrite formultiple copies of updates.list.'.	(self checkNames: list) ifFalse: [^ nil].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	indexPrefix _ (group key includes: $*) 		ifTrue: [(group key findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	myServers _ self checkServersWithPrefix: indexPrefix					andParseListInto: [:x | listContents _ x].	myServers size = 0 ifTrue: [self closeGroup.  ^ self].	version _ SystemVersion current version.	versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for your version'.		self closeGroup.  ^ nil].	"abort"	lastNum _ (listContents at: versIndex) last last initialIntegerOrNil.	versIndex < listContents size ifTrue:		[response _ (PopUpMenu labels: 'Make update for an older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', SystemVersion current version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil].		numStr _ FillInTheBlank 			request: 'Please confirm or change the starting update number' 			initialAnswer: (lastNum+1) printString.		lastNum _ numStr asNumber - 1].	"abort"	"Save old copy of updates.list on local disk"	FileDirectory default deleteFileNamed: indexPrefix , 'updates.list.bk'.	Utilities writeList: listContents toStream: (FileStream fileNamed: indexPrefix , 'updates.list.bk').	"Append names to updates with new sequence numbers"	newNames _ list with: (lastNum+1 to: lastNum+list size) collect:		[:each :num | seq _ num printString padded: #left to: 4 with: $0.		"strip off any old seq number"		stripped _ each copyFrom: (each  findFirst: [:c | c isDigit not]) to: each size.		seq , stripped].	listContents at: versIndex put:		{version. (listContents at: versIndex) , newNames}.	"Write a new copy on all servers..."	updateStrm _ ReadStream on:		(String streamContents: [:s | Utilities writeList: listContents toStream: s]).	myServers do:		[:aServer |		list doWithIndex: [:local :ind |			file _ updateDirectory oldFileNamed: local.			aServer putFile: file named: (newNames at: ind) retry: true.			file close].		updateStrm reset.		aServer putFile: updateStrm named: indexPrefix , 'updates.list' retry: true.		Transcript show: 'Update succeeded on server ', aServer moniker; cr].	self closeGroup.	Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally"	list with: newNames do:		[:local :newName | updateDirectory rename: local toBe: newName].! !!ServerDirectory methodsFor: 'updates' stamp: 'di 4/30/2001 11:22'!updateInstallVersion: newVersion	"For each server group, ask whether we want to put the new version marker (eg 'Squeak2.3') at the end of the file.  Current version of Squeak must be the old one when this is done.		ServerDirectory new updateInstallVersion: 'Squeak9.9test'"	| myServers updateStrm names choice indexPrefix listContents version versIndex |	[names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil]		whileFalse:		[indexPrefix _ (choice endsWith: '*') 			ifTrue: [(choice findTokens: ' ') first]	"special for internal updates"			ifFalse: ['']. 	"normal"		myServers _ (ServerDirectory groupNamed: choice)						checkServersWithPrefix: indexPrefix						andParseListInto: [:x | listContents _ x].		myServers size = 0 ifTrue: [^ self].		version _ SystemVersion current version.		versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.		versIndex = 0 ifTrue:			[^ self inform: 'There is no section in updates.list for your version'].  "abort"		"Append new version to updates following my version"		listContents _ listContents copyReplaceFrom: versIndex+1 to: versIndex with: {{newVersion. {}}}.		updateStrm _ ReadStream on:			(String streamContents: [:s | Utilities writeList: listContents toStream: s]).		myServers do:			[:aServer | updateStrm reset.			aServer putFile: updateStrm named: indexPrefix ,'updates.list'.			Transcript cr; show: indexPrefix ,'updates.list written on server ', aServer moniker].		self closeGroup]! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 4/30/2001 11:27'!broadcastUpdatesFrom: n1 to: n2 except: skipList"	Note:  This method takes its list of files from the directory named 'updates',	which will have been created and filled by, eg,		Utilities readServerUpdatesSaveLocally: true updateImage: true.	These can then be rebroadcast to any server using, eg,		Utilities broadcastUpdatesFrom: 1 to: 9999 except: #(223 224).	If the files are already on the server, and it is only a matter	of copying them to the index for a different version, then use...		(ServerDirectory groupNamed: 'Disney Internal Updates*')			exportUpdatesExcept: #()."	| fileNames fileNamesInOrder names choice file updateDirectory |	updateDirectory _ FileDirectory default directoryNamed: 'updates'.	fileNames _ updateDirectory fileNames select:		[:n | n first isDigit			and: [(n initialIntegerOrNil between: n1 and: n2)			and: [(skipList includes: n initialIntegerOrNil) not]]].	(file _ fileNames select: [:n | (n occurrencesOf: $.) > 1]) size > 0		ifTrue: [self halt: file first , ' has multiple periods'].	fileNamesInOrder _ fileNames asSortedCollection:		[:a :b | a initialIntegerOrNil < b initialIntegerOrNil].	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	(ServerDirectory groupNamed: choice)		putUpdateMulti: fileNamesInOrder fromDirectory: updateDirectory! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 4/29/2001 22:26'!extractThisVersion: list	"Pull out the part of the list that applies to this version."	| listContents version versIndex |	listContents _ self parseListContents: list.	version _ SystemVersion current version.	versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue: [^ Array new].		"abort"	^ (listContents at: versIndex) last! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 4/29/2001 14:27'!parseListContents: listContents	| sections vers strm line fileNames |	"Parse the contents of updates.list into {{vers. {fileNames*}}*}, and return it."	sections _ OrderedCollection new.	fileNames _ OrderedCollection new: 1000.	vers _ nil.	strm _ ReadStream on: listContents.	[strm atEnd] whileFalse:		[line _ strm upTo: Character cr.		line size > 0 ifTrue:			[line first = $#				ifTrue: [vers ifNotNil: [sections addLast: {vers. fileNames asArray}].						"Start a new section"						vers _ line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	vers ifNotNil: [sections addLast: {vers. fileNames asArray}].	^ sections asArray" TEST: | list |list _ Utilities parseListContents: (FileStream oldFileNamed: 'updates.list') contentsOfEntireFile.list = (Utilities parseListContents: (String streamContents: [:s | Utilities writeList: list toStream: s]))	ifFalse: [self error: 'test failed']	ifTrue: [self inform: 'test OK']"! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 4/30/2001 11:28'!updateComment"The following used to be at the beginning of the update file.	Now it is here to simplify parsing the file...* To add a new update:  Name it starting with a new four-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put a copy of updates.list on the server.** Special file with a different name for Disney Internal Updates.  * No need to move or rename files to release them to external updates."! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 4/29/2001 14:04'!writeList: listContents toStream: strm	"Write a parsed updates.list out as text.	This is the inverse of parseListContents:"	| fileNames version |	strm reset.	listContents do:		[:pair | version _ pair first.  fileNames _ pair last.		strm nextPut: $#; nextPutAll: version; cr.		fileNames do: [:fileName | strm nextPutAll: fileName; cr]].	strm close! !Utilities class removeSelector: #olderVersNum:from:default:!ServerDirectory removeSelector: #checkServers!ServerDirectory removeSelector: #parseListContents:!