'From Squeak2.9alpha of 13 June 2000 [latest update: #2426] on 25 June 2000 at 5:58:30 pm'!"Change Set:		178SUnit2-rhDate:			14 June 2000Author:			Robert Hirschfeld[I removed the documentation class mentioned below and also removed the TestTest class. Everything else is unchanged but I added a #discardSUnit method to the SystemDictionary class --sma]Project URL:  http://www.prakinf.tu-ilmenau.de/~hirsch/Projects/Squeak/SUnit/Documentation:  * method content of    - TestingFrameworkPaper class>>simpleSmalltalkTestingWithPatterns    - TestModel class>>testModelUsage    - TestRunner class>>testRunnerUsage  * Test cases my be filtered by the class name of the fixture and the    name of the test method selector. The patterns for the class and the    selector name can be specified/accepted either in the first text field of    the TestModel or as a parameter for the runTests: method of TestRunner.    They are separated by a '.', a ' ', or a '|'. As for the class name    pattern, only subclasses of TestCase are taken into consideration.    The names of the test methods of those classes do have to start    with 'test' to be in the match.  * Kent Beck's paper 'Simple Smalltalk Testing: With Patterns'    - see class comment of TestingFrameworkPaper    - evaluate [TestingFrameworkPaper openFromHtml]"!Object subclass: #TestCase	instanceVariableNames: 'testMessage '	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Framework'!!TestCase commentStamp: '<historical>' prior: 0!Defines the fixture to run multiple tests plus the tests using this fixture. To define a test case  * implement a subclass of TestCase,  * define instance variables that store the state of the fixture,  * initialize the fixture state by overriding TestCase setUp,  * clean-up after a test by overriding TestCase tearDown, andEach test runs in its own fixture so there can be no side effects among test runs.For each test in the context of this fixture set-up,  * implement a method(s) which interacts with the fixture.In the test method(s) verify the expected results with assertions specified by calling  * TestCase assert:  * TestCase deny:  * TestCase should:  * TestCase shouldnt:  * TestCase value:shouldRaise: or  * TestCase value:shouldntRaise:with arguments of the expected type.Instance Variables:	testMessage		<Symbol>!]style[(252 14 42 17 298 16 5 14 5 16 5 18 5 27 8 29 75 6 1)f1,f1LTestCase setUp;,f1,f1LTestCase tearDown;,f1,f1LTestCase assert:;,f1,f1LTestCase deny:;,f1,f1LTestCase should:;,f1,f1LTestCase shouldnt:;,f1,f1LTestCase value:shouldRaise:;,f1,f1LTestCase value:shouldntRaise:;,f1,f1LSymbol Hierarchy;,f1!TestCase class	instanceVariableNames: ''!Model subclass: #TestInterfaceBase	instanceVariableNames: 'result duration classPattern selectorPattern '	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Interface'!!TestInterfaceBase commentStamp: '<historical>' prior: 0!ABSTRACT base class for user interfaces to the SUnit framework.Hints for improvement of this port?mailto:hirschfeld@acm.orgInstance Variables:	result			<TestResult>	classPattern		<String>	selectorPattern	<String>	duration		<Integer> [ms]!]style[(47 1 1 3 49 25 33 10 18 6 20 6 14 7 6)f1,f1cgreen;b,f1cred;b,f1bcblack;,f1,f1Rmailto:hirschfeld@acm.org;,f1,f1LTestResult Hierarchy;,f1,f1LString Hierarchy;,f1,f1LString Hierarchy;,f1,f1LInteger Hierarchy;,f1!TestInterfaceBase class	instanceVariableNames: ''!TestInterfaceBase subclass: #TestModel	instanceVariableNames: 'summaryText detailsText failureList errorList patternHistory summaryTextM summaryTextV updateColorSelector patternTextM patternTextV '	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Interface'!!TestModel commentStamp: '<historical>' prior: 0!A simple graphical user interface to run all the test cases that exist in this image within the SUnit framework by Kent Beck and Erich Gamma (SUnit release 2, November 1998). A window can be opened via TestModel openAsMorph in a morphic environment, or via TestModel open in a MVC environment. A selection pattern history keeps track of all valid patterns used. The pattern history as well as its management operations are accessible via the yellow button menu of the pattern text entry field.Hints for improvement of this port?mailto:hirschfeld@acm.orgInstance Variables:	summaryText		<String>	detailsText			<String>	failureList			<OrderedCollection of: String>	errorList			<OrderedCollection of: String>	patternHistory		<OrderedCollection of: String>	summaryTextM		<PluggableTextMorph | nil>	summaryTextV		<PluggableTextView | nil>	updateColorSelector	<Symbol>	patternTextM		<PluggableTextMorph | nil>	patternTextV		<PluggableTextView | nil>!]style[(96 1 1 3 12 31 58 21 34 14 260 25 37 6 18 6 18 17 5 6 16 17 5 6 20 17 5 6 18 18 24 17 30 6 18 18 24 17 7)f1,f1cgreen;b,f1cred;b,f1bcblack;,f1,f1cblack;,f1,f1dTestModel openAsMorph;;,f1,f1dTestModel open;;,f1,f1Rmailto:hirschfeld@acm.org;,f1,f1LString Hierarchy;,f1,f1LString Hierarchy;,f1,f1LOrderedCollection Hierarchy;,f1,f1LString Hierarchy;,f1,f1LOrderedCollection Hierarchy;,f1,f1LString Hierarchy;,f1,f1LOrderedCollection Hierarchy;,f1,f1LString Hierarchy;,f1,f1LPluggableTextMorph Hierarchy;,f1,f1LPluggableTextView Hierarchy;,f1,f1LSymbol Hierarchy;,f1,f1LPluggableTextMorph Hierarchy;,f1,f1LPluggableTextView Hierarchy;,f1!TestModel class	instanceVariableNames: ''!Object subclass: #TestResult	instanceVariableNames: 'runCount failures errors '	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Framework'!!TestResult commentStamp: '<historical>' prior: 0!Collects the results of executing a test case. The test framework distinguishes between failures and errors. A failure is anticipated and checked for with assertions. Errors are unanticipated problems like a division by 0 or an index out of bound ...Instance Variables:	runCount	<SmallInteger>	failures		<OrderedCollection of: TestCase>	errors		<OrderedCollection of: TestCase>!]style[(283 12 14 17 5 8 12 17 5 8 1)f1,f1LSmallInteger Hierarchy;,f1,f1LOrderedCollection Hierarchy;,f1,f1LTestCase Hierarchy;,f1,f1LOrderedCollection Hierarchy;,f1,f1LTestCase Hierarchy;,f1!TestResult class	instanceVariableNames: ''!TestInterfaceBase subclass: #TestRunner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Interface'!!TestRunner commentStamp: '<historical>' prior: 0!A simple text-based user interface to run all the test cases that exist in this image within the SUnit framework by Kent Beck and Erich Gamma (SUnit release 2, November 1998). The tests can be executed via TestRunner runTests or TestRunner runTests: '* test*'. The test results appear in the Transcript window.Hints for improvement of this port?mailto:hirschfeld@acm.org!]style[(97 1 1 3 13 33 58 19 4 30 89 25)f1,f1cgreen;b,f1cred;b,f1bcblack;,f1,f1cblack;,f1,f1dTestRunner runTests;;,f1,f1dTestRunner runTests: '* test*';;,f1,f1Rmailto:hirschfeld@acm.org;!TestRunner class	instanceVariableNames: ''!Object subclass: #TestSuite	instanceVariableNames: 'tests '	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Framework'!!TestSuite commentStamp: '<historical>' prior: 0!A Composite of test cases. It runs a collection of test cases.Instance Variables:	tests	<OrderedCollection of: TestCase>!]style[(92 17 5 8 1)f1,f1LOrderedCollection Hierarchy;,f1,f1LTestCase Hierarchy;,f1!TestSuite class	instanceVariableNames: ''!!SystemDictionary methodsFor: 'shrinking' stamp: 'sma 6/25/2000 17:57'!discardSUnit   "Smalltalk discardSUnit"	| oc |	oc _ OrderedCollection new.	(Smalltalk at: #TestCase ifAbsent: [^ self])		allSubclassesWithLevelDo: [:c :i | oc addFirst: c]		startingLevel: 0.	oc do: [:c | c removeFromSystem].	SystemOrganization removeCategoriesMatching: 'SUnit-*'! !!TestCase methodsFor: 'asserting' stamp: 'rhi 2/5/2000 12:36'!assert: aBoolean	aBoolean		ifFalse: [TestResult testFailureException signal: 'Assertion failed'].! !!TestCase methodsFor: 'asserting' stamp: 'rhi 2/5/2000 12:36'!deny: aBoolean	self assert: aBoolean not.! !!TestCase methodsFor: 'asserting' stamp: 'rhi 2/5/2000 12:36'!should: aBlockContext	self assert: aBlockContext value.! !!TestCase methodsFor: 'asserting' stamp: 'rhi 2/5/2000 12:36'!shouldnt: aBlockContext	self deny: aBlockContext value.! !!TestCase methodsFor: 'asserting' stamp: 'rhi 2/5/2000 12:36'!value: aBlockContext shouldRaise: anException	aBlockContext		on: anException		do: [:ex | ^self].	TestResult testFailureException signal: 'Failed to raise ', anException printString.! !!TestCase methodsFor: 'asserting' stamp: 'rhi 2/5/2000 12:36'!value: aBlockContext shouldntRaise: anException	aBlockContext		on: anException		do: [:ex | TestResult testFailureException			signal: 'Should not raise ', anException printString].! !!TestCase methodsFor: 'printing' stamp: 'rhi 2/5/2000 12:37'!printOn: aStream	aStream		nextPutAll: self class printString;		nextPutAll: '>>';		nextPutAll: self testMessage.! !!TestCase methodsFor: 'private accessing' stamp: 'rhi 5/22/1999 17:37'!testMessage	^testMessage! !!TestCase methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:38'!testMessage: aSymbol	testMessage := aSymbol.! !!TestCase methodsFor: 'running' stamp: 'rhi 2/5/2000 12:37'!debug	self runCase.! !!TestCase methodsFor: 'running' stamp: 'rhi 5/22/1999 17:32'!run	| result |	result := TestResult new.	self run: result.	^result! !!TestCase methodsFor: 'running' stamp: 'rhi 2/5/2000 12:37'!run: aTestResult	aTestResult runCase: self.! !!TestCase methodsFor: 'running' stamp: 'rhi 2/5/2000 12:38'!runCase	self setUp.	[self perform: self testMessage]		ensure: [self tearDown].! !!TestCase methodsFor: 'running' stamp: 'rhi 5/24/1999 21:16'!setUp	"Sets up the fixture. This method is called before a test is executed."! !!TestCase methodsFor: 'running' stamp: 'rhi 5/24/1999 21:17'!tearDown	"Tears down the fixture. This method is called after a test is executed."! !!TestCase class methodsFor: 'instance creation' stamp: 'rhi 5/22/1999 17:36'!selector: aSymbol	^self new testMessage: aSymbol! !!TestCase class methodsFor: 'instance creation' stamp: 'rhi 10/23/1999 01:29'!suite	| testMethods testSuite |	testMethods := self selectors select: [:each |		'test*' match: each].	testSuite := TestSuite new.	testMethods do: [:each |		testSuite addTest: (self selector: each)].	^testSuite! !!TestCase class methodsFor: 'processing' stamp: 'rhi 5/22/1999 13:21'!debug: aSymbol	^(self selector: aSymbol) debug! !!TestCase class methodsFor: 'processing' stamp: 'rhi 5/22/1999 13:21'!run: aSymbol	^(self selector: aSymbol) run! !!TestInterfaceBase methodsFor: 'accessing' stamp: 'rhi 12/26/1999 11:25'!classPattern	^classPattern! !!TestInterfaceBase methodsFor: 'accessing' stamp: 'rhi 2/5/2000 12:41'!classPattern: aString	classPattern := aString.! !!TestInterfaceBase methodsFor: 'accessing' stamp: 'rhi 12/26/1999 11:24'!duration	^duration! !!TestInterfaceBase methodsFor: 'accessing' stamp: 'rhi 2/5/2000 12:41'!duration: anInteger	duration := anInteger.! !!TestInterfaceBase methodsFor: 'accessing' stamp: 'rhi 12/26/1999 11:24'!result	^result! !!TestInterfaceBase methodsFor: 'accessing' stamp: 'rhi 2/5/2000 12:41'!result: aTestResult	result := aTestResult.! !!TestInterfaceBase methodsFor: 'accessing' stamp: 'rhi 12/26/1999 11:25'!selectorPattern	^selectorPattern! !!TestInterfaceBase methodsFor: 'accessing' stamp: 'rhi 2/5/2000 12:41'!selectorPattern: aString	selectorPattern := aString.! !!TestInterfaceBase methodsFor: 'constants' stamp: 'rhi 12/26/1999 11:32'!classSelectorDelimiters	^self class classSelectorDelimiters! !!TestInterfaceBase methodsFor: 'constants' stamp: 'rhi 12/26/1999 11:32'!defaultClassPattern	^self class defaultClassPattern! !!TestInterfaceBase methodsFor: 'constants' stamp: 'rhi 12/26/1999 11:32'!defaultClassSelectorDelimiter	^self class defaultClassSelectorDelimiter! !!TestInterfaceBase methodsFor: 'constants' stamp: 'rhi 12/26/1999 11:32'!defaultSelectorPattern	^self class defaultSelectorPattern! !!TestInterfaceBase methodsFor: 'constants' stamp: 'rhi 1/16/2000 10:20'!failureMessage	^self class failureMessage! !!TestInterfaceBase methodsFor: 'constants' stamp: 'rhi 1/16/2000 10:22'!successMessage	^self class successMessage! !!TestInterfaceBase methodsFor: 'constants' stamp: 'rhi 1/16/2000 10:17'!version	^self class version! !!TestInterfaceBase methodsFor: 'constants' stamp: 'rhi 1/16/2000 10:17'!versionDate	^self class versionDate! !!TestInterfaceBase methodsFor: 'constants' stamp: 'rhi 1/16/2000 10:17'!versionName	^self class versionName! !!TestInterfaceBase methodsFor: 'initialize-release' stamp: 'rhi 2/5/2000 12:41'!initialize	self		result: TestResult new;		classPattern: self defaultClassPattern;		selectorPattern: self defaultSelectorPattern;		duration: 0.! !!TestInterfaceBase methodsFor: 'test patterns' stamp: 'rhi 1/21/2000 21:55'!classPatternFrom: aString	| tokens |	tokens := aString findTokens: self classSelectorDelimiters.	^tokens isEmpty		ifTrue: [self defaultClassPattern]		ifFalse: [			| newClassPattern |			newClassPattern := tokens first.			(self matchingClassesForPattern: newClassPattern) isEmpty				ifFalse: [newClassPattern]				ifTrue: [self defaultClassPattern]]! !!TestInterfaceBase methodsFor: 'test patterns' stamp: 'rhi 12/26/1999 11:29'!matchingClasses	^self matchingClassesForPattern: self classPattern! !!TestInterfaceBase methodsFor: 'test patterns' stamp: 'rhi 12/26/1999 11:29'!matchingClassesForPattern: aString	^TestCase allSubclasses select: [:class |		aString match: class name]! !!TestInterfaceBase methodsFor: 'test patterns' stamp: 'rhi 1/21/2000 21:55'!selectorPatternFrom: aString	| tokens |	tokens := aString findTokens: self classSelectorDelimiters.	^(tokens isEmpty not and: [tokens size >= 2])		ifFalse: [self defaultSelectorPattern]		ifTrue: [			| selPattern |			selPattern := tokens at: 2.			(self defaultSelectorPattern match: selPattern)				ifTrue: [selPattern]				ifFalse: [self defaultSelectorPattern]]! !!TestInterfaceBase methodsFor: 'test processing' stamp: 'rhi 4/26/2000 08:07'!runTests	"Cursor wait showWhile: [		self duration: (Time millisecondsToRun: [self result: self suite run])].	self showResult"	| saveCursor |	self flag: #exceptionsProblem. "Eventually switch back to Cursor wait showWhile: [...]"	saveCursor := Cursor currentCursor.	Cursor wait show.	self		duration: (Time millisecondsToRun: [self result: self suite run]);		showResult.	saveCursor show.! !!TestInterfaceBase methodsFor: 'test processing' stamp: 'rhi 2/5/2000 12:42'!showResult	self subclassResponsibility.! !!TestInterfaceBase methodsFor: 'test processing' stamp: 'rhi 12/26/1999 11:54'!suite	| suite |	suite := TestSuite new.	self matchingClasses do: [:class |		| matchingSelectors |		matchingSelectors := class selectors select: [:selector |			self selectorPattern match: selector].		matchingSelectors do: [:selector |			suite addTest: (class selector: selector)]].	^suite! !!TestInterfaceBase class methodsFor: 'constants' stamp: 'rhi 4/26/2000 07:47'!classSelectorDelimiters	^'. |' copy! !!TestInterfaceBase class methodsFor: 'constants' stamp: 'rhi 4/26/2000 07:47'!defaultClassPattern	^'*' copy! !!TestInterfaceBase class methodsFor: 'constants' stamp: 'rhi 1/16/2000 10:10'!defaultClassSelectorDelimiter	^self classSelectorDelimiters first asString! !!TestInterfaceBase class methodsFor: 'constants' stamp: 'rhi 4/26/2000 07:47'!defaultSelectorPattern	^'test*' copy! !!TestInterfaceBase class methodsFor: 'constants' stamp: 'rhi 4/26/2000 07:47'!failureMessage	^'*** FAIL ***' copy! !!TestInterfaceBase class methodsFor: 'constants' stamp: 'rhi 4/26/2000 07:48'!successMessage	^'*** PASS ***' copy! !!TestInterfaceBase class methodsFor: 'constants' stamp: 'rhi 1/16/2000 10:06'!version	"printIt: [TestInterfaceBase version]"	^self versionName, ' ', self versionDate! !!TestInterfaceBase class methodsFor: 'constants' stamp: 'rhi 6/14/2000 11:00'!versionDate	^'14 June 2000' copy! !!TestInterfaceBase class methodsFor: 'constants' stamp: 'rhi 4/26/2000 07:48'!versionName	^'SUnit 2' copy! !!TestInterfaceBase class methodsFor: 'instance creation' stamp: 'rhi 12/26/1999 11:41'!new	^super new initialize! !!TestModel methodsFor: 'accessing' stamp: 'rhi 5/23/1999 22:25'!detailsText	^detailsText! !!TestModel methodsFor: 'accessing' stamp: 'rhi 5/23/1999 23:36'!errorList	^errorList! !!TestModel methodsFor: 'accessing' stamp: 'rhi 5/23/1999 23:36'!failureList	^failureList! !!TestModel methodsFor: 'accessing' stamp: 'rhi 5/23/1999 22:25'!summaryText	^summaryText! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:24'!balloonDetailsText	^self class balloonDetailsText! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:24'!balloonErrorList	^self class balloonErrorList! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:24'!balloonFailureList	^self class balloonFailureList! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:25'!balloonPatternText	^self class balloonPatternText! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:25'!balloonRunButton	^self class balloonRunButton! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:25'!balloonSummaryText	^self class balloonSummaryText! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/24/1999 13:47'!failureColor	^self class failureColor! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/24/1999 13:47'!runButtonColor	^self class runButtonColor! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/24/1999 13:01'!runButtonLabel	^self class runButtonLabel! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/24/1999 13:02'!runButtonState	^self class runButtonState! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/24/1999 13:47'!successColor	^self class successColor! !!TestModel methodsFor: 'constants' stamp: 'rhi 5/24/1999 19:43'!windowLabel	^self class windowLabel! !!TestModel methodsFor: 'derived accessing' stamp: 'rhi 5/24/1999 00:23'!errorListSelectionIndex	^0! !!TestModel methodsFor: 'derived accessing' stamp: 'rhi 2/5/2000 12:42'!errorListSelectionIndex: anInteger	(anInteger ~= 0)		ifTrue: [(self result errors at: anInteger) debug].! !!TestModel methodsFor: 'derived accessing' stamp: 'rhi 5/24/1999 00:23'!failureListSelectionIndex	^0! !!TestModel methodsFor: 'derived accessing' stamp: 'rhi 2/5/2000 12:42'!failureListSelectionIndex: anInteger	(anInteger ~= 0)		ifTrue: [(self result failures at: anInteger) debug].! !!TestModel methodsFor: 'derived accessing' stamp: 'rhi 12/26/1999 08:33'!patternText	^self classPattern, self defaultClassSelectorDelimiter, self selectorPattern! !!TestModel methodsFor: 'derived accessing' stamp: 'rhi 5/5/2000 13:26'!patternText: aTextOrString	| patternInput |	patternInput := aTextOrString asString.	self		classPattern: (self classPatternFrom: patternInput);		selectorPattern: (self selectorPatternFrom: patternInput);		updatePatternHistory;		changed: #patternText.	^true! !!TestModel methodsFor: 'initialize-release' stamp: 'rhi 5/5/2000 13:28'!initialize	super initialize.	self		summaryText: String new;		detailsText: String new;		failureList: OrderedCollection new;		errorList: OrderedCollection new;		patternHistory: OrderedCollection new;		summaryTextM: nil;		summaryTextV: nil;		updateColorSelector: nil;		patternTextM: nil;		patternTextV: nil.! !!TestModel methodsFor: 'interface opening' stamp: 'rhi 5/5/2000 13:31'!open	"doIt: [TestModel new open]"	| topWindowV runButtonV detailsTextV failureListV errorListV |	self updateColorSelector: #updateColorV.	"=== build the parts ... ==="	(topWindowV := StandardSystemView new)		label: self windowLabel;		model: self.	self patternTextV: (PluggableTextView		on: self		text: #patternText		accept: #patternText:		readSelection: nil		menu: #patternHistoryMenuMVC:).	runButtonV := PluggableButtonView		on: self		getState: #runButtonState		action: #runTests		label: #runButtonLabel.	runButtonV		label: self runButtonLabel;		insideColor: self runButtonColor.	self summaryTextV: (PluggableTextView		on: self		text: #summaryText		accept: nil).	detailsTextV := PluggableTextView on: self		text: #detailsText		accept: nil.	failureListV := PluggableListView		on: self		list: #failureList		selected: #failureListSelectionIndex		changeSelected: #failureListSelectionIndex:.	errorListV := PluggableListView		on: self		list: #errorList		selected: #errorListSelectionIndex		changeSelected: #errorListSelectionIndex:.	"=== size the parts ... ==="	self patternTextV		borderWidth: 1;		window: (0@0 corner: 100@10). "(0.0@0.0 extent: 1.0@0.1)"	runButtonV		borderWidth: 1;		window: (0@0 corner: 20@10). "(0.0@0.1 extent: 0.2@0.1)"	self summaryTextV		borderWidth: 1;		window: (0@0 corner: 80@10). "(0.2@0.1 extent: 0.8@0.1)"	detailsTextV		borderWidth: 1;		window: (0@0 corner: 100@10). "(0.0@0.2 extent: 1.0@0.1)"	failureListV		borderWidth: 1;		window: (0@0 corner: 100@35). "(0.0@0.3 extent: 1.0@0.35)"	errorListV		borderWidth: 1;		window: (0@0 corner: 100@35). "(0.0@0.65 extent: 1.0@0.35)"	"=== assemble the whole ... ==="	topWindowV		addSubView: self patternTextV;		addSubView: runButtonV below: self patternTextV;		addSubView: self summaryTextV toRightOf: runButtonV;		addSubView: detailsTextV below: runButtonV;		addSubView: failureListV below: detailsTextV;		addSubView: errorListV below: failureListV.	"=== open it ... ==="	topWindowV minimumSize: 200@200.	topWindowV maximumSize: 250@200.	topWindowV controller open.! !!TestModel methodsFor: 'interface opening' stamp: 'rhi 5/5/2000 13:32'!openAsMorph	"doIt: [TestModel new openAsMorph]"	| topWindowM runButtonM detailsTextM failureListM errorListM |	self updateColorSelector: #updateColorM.	"=== build the parts ... ==="	(topWindowM := SystemWindow labelled: self windowLabel)		model: self.	self patternTextM: (PluggableTextMorph		on: self		text: #patternText		accept: #patternText:		readSelection: nil		menu: #patternHistoryMenu:).	self patternTextM setBalloonText: self balloonPatternText.	runButtonM := PluggableButtonMorph		on: self		getState: #runButtonState		action: #runTests		label: #runButtonLabel.	runButtonM		onColor: self runButtonColor		offColor: self runButtonColor.	runButtonM setBalloonText: self balloonRunButton.	self summaryTextM: (PluggableTextMorph		on: self		text: #summaryText		accept: nil).	self summaryTextM setBalloonText: self balloonSummaryText.	detailsTextM := PluggableTextMorph		on: self		text: #detailsText		accept: nil.	detailsTextM setBalloonText: self balloonDetailsText.	failureListM := PluggableListMorph		on: self		list: #failureList		selected: #failureListSelectionIndex		changeSelected: #failureListSelectionIndex:.	failureListM setBalloonText: self balloonFailureList.	errorListM := PluggableListMorph		on: self		list: #errorList		selected: #errorListSelectionIndex		changeSelected: #errorListSelectionIndex:.	errorListM setBalloonText: self balloonErrorList.	"=== assemble the whole ... ==="	topWindowM		addMorph: self patternTextM frame: (0.0@0.0 extent: 1.0@0.1);		addMorph: runButtonM frame: (0.0@0.1 extent: 0.2@0.1);		addMorph: self summaryTextM frame: (0.2@0.1 extent: 0.8@0.1);		addMorph: detailsTextM frame: (0.0@0.2 extent: 1.0@0.1);		addMorph: failureListM frame: (0.0@0.3 extent: 1.0@0.35);		addMorph: errorListM frame: (0.0@0.65 extent: 1.0@0.35).	"=== open it ... ==="	topWindowM openInWorldExtent: 250@200.	^topWindowM! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:43'!detailsText: aString	(detailsText = aString)		ifFalse: [			detailsText := aString.			self changed: #detailsText].! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:44'!errorList: anOrderedCollection	(errorList = anOrderedCollection)		ifFalse: [			errorList := anOrderedCollection.			self changed: #errorList].! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:44'!failureList: anOrderedCollection	(failureList = anOrderedCollection)		ifFalse: [			failureList := anOrderedCollection.			self changed: #failureList].! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 5/5/2000 13:21'!patternHistory	^patternHistory! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 5/5/2000 13:22'!patternHistory: anOrderedCollection	patternHistory := anOrderedCollection.! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 12/26/1999 07:04'!patternTextM	^patternTextM! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:44'!patternTextM: aPluggableTextMorph	patternTextM := aPluggableTextMorph.! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 12/26/1999 07:06'!patternTextV	^patternTextV! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:44'!patternTextV: aPluggableTextView	patternTextV := aPluggableTextView.! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:44'!summaryText: aString	(summaryText = aString)		ifFalse: [			summaryText := aString.			self changed: #summaryText].! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 5/24/1999 12:48'!summaryTextM	^summaryTextM! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:44'!summaryTextM: aPluggableTextMorph	summaryTextM := aPluggableTextMorph.! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 5/24/1999 21:36'!summaryTextV	^summaryTextV! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:44'!summaryTextV: aPluggableTextView	summaryTextV := aPluggableTextView.! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 5/24/1999 22:37'!updateColorSelector	^updateColorSelector! !!TestModel methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:44'!updateColorSelector: aSymbol	updateColorSelector := aSymbol.! !!TestModel methodsFor: 'test processing' stamp: 'rhi 2/5/2000 12:43'!showResult	self		updateColor;		updateText;		updateLists.! !!TestModel methodsFor: 'test processing' stamp: 'rhi 2/5/2000 12:43'!updateColor	self perform: self updateColorSelector.! !!TestModel methodsFor: 'test processing' stamp: 'rhi 2/5/2000 12:43'!updateColorM	self summaryTextM color: ((self result runCount = self result correctCount)		ifTrue: [self successColor]		ifFalse: [self failureColor]).! !!TestModel methodsFor: 'test processing' stamp: 'rhi 2/5/2000 12:43'!updateColorV	self summaryTextV insideColor: ((self result runCount = self result correctCount)		ifTrue: [self successColor]		ifFalse: [self failureColor]).! !!TestModel methodsFor: 'test processing' stamp: 'rhi 10/23/1999 01:40'!updateLists	self failureList: (self result failures collect: [:failure |		failure printString]).	self errorList: (self result errors collect: [:error |		error printString]).! !!TestModel methodsFor: 'test processing' stamp: 'rhi 2/5/2000 12:43'!updateText	self summaryText: ((self result runCount = self result correctCount)		ifTrue: [self successMessage]		ifFalse: [self failureMessage]).	self detailsText:		self result runCount printString, ' run, ' ,		self result failureCount printString, ' failed, ',		self result errorCount printString, ' errors (',		self duration printString, ' ms)'.! !!TestModel methodsFor: 'menus' stamp: 'rhi 4/27/2000 11:19'!perform: selector orSendTo: otherTarget	(#(	#alphabetizePatternHistory		#cleanUpPatternHistory		#emptyPatternHistory		#acceptNewPattern) includes: selector)			ifTrue: [self perform: selector]			ifFalse: [self patternText: selector].! !!TestModel methodsFor: 'patterns menu' stamp: 'rhi 4/27/2000 09:40'!patternHistoryMenu: aMenuMorph	self patternHistory isEmpty		ifFalse: [			"aMenuMorph addTitle: 'Selection Patterns'."			self patternHistory do: [:each |				aMenuMorph add: each selector: #patternText: argument: each].			aMenuMorph				addLine;				add: 'alphabetize list' selector: #alphabetizePatternHistory argument: nil;				add: 'clean-up list' selector: #cleanUpPatternHistory argument: nil;				add: 'empty list' selector: #emptyPatternHistory argument: nil;				addLine].	aMenuMorph add: 'accept pattern (s)' selector: #acceptNewPattern argument: nil.	^aMenuMorph! !!TestModel methodsFor: 'patterns menu' stamp: 'rhi 4/27/2000 12:28'!patternHistoryMenuMVC: aCustomMenu	self patternHistory isEmpty		ifFalse: [			"aCustomMenu title: 'Selection Patterns'."			self patternHistory do: [:each |				aCustomMenu add: each action: each].			aCustomMenu				addLine;				add: 'alphabetize list' action: #alphabetizePatternHistory;				add: 'clean-up list' action: #cleanUpPatternHistory;				add: 'empty list' action: #emptyPatternHistory;				addLine].	aCustomMenu add: 'accept pattern (s)' action: #acceptNewPattern.	^aCustomMenu! !!TestModel methodsFor: 'test patterns' stamp: 'rhi 4/27/2000 12:13'!acceptNewPattern	(Smalltalk isMorphic)		ifTrue: [self patternTextM accept]		ifFalse: [self patternTextV controller accept].! !!TestModel methodsFor: 'test patterns' stamp: 'rhi 2/5/2000 12:45'!alphabetizePatternHistory	self patternHistory: self patternHistory asSortedCollection asOrderedCollection.! !!TestModel methodsFor: 'test patterns' stamp: 'rhi 4/28/2000 03:32'!cleanUpPatternHistory	self patternHistory: (self patternHistory select: [:each |		((self classPatternFrom: each) ~= self defaultClassPattern)			or: [(self selectorPatternFrom: each) ~= self defaultSelectorPattern]]).! !!TestModel methodsFor: 'test patterns' stamp: 'rhi 2/5/2000 12:45'!emptyPatternHistory	self patternHistory: OrderedCollection new.! !!TestModel methodsFor: 'test patterns' stamp: 'rhi 2/5/2000 12:45'!updatePatternHistory	(self patternHistory includes: self patternText)		ifFalse: [self patternHistory add: self patternText].! !!TestModel class methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:23'!balloonDetailsText	^'Detailed summary of tests processed.' copy! !!TestModel class methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:23'!balloonErrorList	^'Tests with unexpected errors. SELECT to debug!!' copy! !!TestModel class methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:23'!balloonFailureList	^'Failed tests. SELECT to debug!!' copy! !!TestModel class methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:23'!balloonPatternText	^'ENTER and ACCEPT test selection pattern!! USE yellow mouse button for pattern history!!' copy! !!TestModel class methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:23'!balloonRunButton	^'START processing of matching tests!!' copy! !!TestModel class methodsFor: 'constants' stamp: 'rhi 5/5/2000 13:24'!balloonSummaryText	^'Summary of tests processed.' copy! !!TestModel class methodsFor: 'constants' stamp: 'rhi 5/24/1999 12:58'!failureColor	^Color red! !!TestModel class methodsFor: 'constants' stamp: 'rhi 5/24/1999 12:59'!runButtonColor	^Color yellow! !!TestModel class methodsFor: 'constants' stamp: 'rhi 4/26/2000 07:48'!runButtonLabel	^'RUN!!' copy! !!TestModel class methodsFor: 'constants' stamp: 'rhi 5/24/1999 22:51'!runButtonState	^true! !!TestModel class methodsFor: 'constants' stamp: 'rhi 5/24/1999 12:59'!successColor	^Color green! !!TestModel class methodsFor: 'constants' stamp: 'rhi 1/16/2000 10:08'!windowLabel	^self versionName! !!TestModel class methodsFor: 'documentation' stamp: 'rhi 2/5/2000 12:40'!testModelUsage	"Please see the class comment for some documentation.	Documentation links:		* TestingFrameworkPaper		* TestModel		* TestRunner"	self error: 'comment only'.!]style[(14 83 21 5 9 5 10 31)f1b,f1,f1LTestingFrameworkPaper Comment;,f1,f1LTestModel Comment;,f1,f1LTestRunner Comment;,f1! !!TestModel class methodsFor: 'interface opening' stamp: 'rhi 5/24/1999 21:55'!open	"doIt: [TestModel open]"	^self new open! !!TestModel class methodsFor: 'interface opening' stamp: 'rhi 5/23/1999 23:27'!openAsMorph	"doIt: [TestModel openAsMorph]"	^self new openAsMorph! !!TestResult methodsFor: 'accessing' stamp: 'rhi 5/22/1999 17:31'!correctCount	^self runCount - self failureCount - self errorCount! !!TestResult methodsFor: 'accessing' stamp: 'rhi 5/22/1999 17:46'!defects	^self errors, self failures! !!TestResult methodsFor: 'accessing' stamp: 'rhi 5/22/1999 13:44'!errorCount	^self errors size! !!TestResult methodsFor: 'accessing' stamp: 'rhi 5/22/1999 17:46'!errors	^errors! !!TestResult methodsFor: 'accessing' stamp: 'rhi 5/22/1999 17:42'!failureCount	^self failures size! !!TestResult methodsFor: 'accessing' stamp: 'rhi 5/22/1999 17:46'!failures	^failures! !!TestResult methodsFor: 'accessing' stamp: 'rhi 5/22/1999 13:45'!runCount	^runCount! !!TestResult methodsFor: 'exceptions' stamp: 'rhi 10/23/1999 01:26'!testFailureException	^self class testFailureException! !!TestResult methodsFor: 'initialize-release' stamp: 'rhi 2/5/2000 12:38'!initialize	self		runCount: 0;		failures: OrderedCollection new;		errors: OrderedCollection new.! !!TestResult methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:39'!errors: anOrderedCollection	errors := anOrderedCollection.! !!TestResult methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:39'!failures: anOrderedCollection	failures := anOrderedCollection.! !!TestResult methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:39'!runCount: aSmallInteger	runCount := aSmallInteger.! !!TestResult methodsFor: 'running' stamp: 'rhi 2/5/2000 12:39'!runCase: aTestCase	self runCount: self runCount + 1.	[[aTestCase runCase]		on: self testFailureException do: [:ex |			self failures add: aTestCase]]		on: Error do: [:ex |			self errors add: aTestCase].! !!TestResult class methodsFor: 'exceptions' stamp: 'rhi 10/23/1999 01:09'!testFailureException	^TestFailure! !!TestResult class methodsFor: 'instance creation' stamp: 'rhi 5/22/1999 13:46'!new	^super new initialize! !!TestRunner methodsFor: 'test processing' stamp: 'rhi 4/26/2000 07:51'!runTests: aString	"doIt: [TestRunner new runTests: 'Test* test*']"	self		classPattern: (self classPatternFrom: aString);		selectorPattern: (self selectorPatternFrom: aString).	self runTests.! !!TestRunner methodsFor: 'test processing' stamp: 'rhi 2/5/2000 12:45'!showResult	Transcript cr;cr; show: '==== SUnit ======== Start ===='.	self		showResultSummary;		showResultDefects.	Transcript cr; show: '==== SUnit ========== End ===='; cr.! !!TestRunner methodsFor: 'test processing' stamp: 'rhi 2/5/2000 12:45'!showResultDefects	(self result failureCount > 0)		ifTrue: [			Transcript cr; show: '---- SUnit ----- Failures ----'.			self result failures do: [:failure |				Transcript crtab; show: failure printString]].	(self result errorCount > 0)		ifTrue: [			Transcript cr; show: '---- SUnit ------- Errors ----'.			self result errors do: [:error |				Transcript crtab; show: error printString]].! !!TestRunner methodsFor: 'test processing' stamp: 'rhi 2/5/2000 12:45'!showResultSummary	| message summary |	message := (self result runCount = self result correctCount)		ifTrue: [self successMessage]		ifFalse: [self failureMessage].	Transcript crtab; show: message.	summary :=		self result runCount printString, ' run, ',		self result failureCount printString, ' failed, ',		self result errorCount printString, ' errors (',		self duration printString, ' ms)'.	Transcript crtab; show: summary.! !!TestRunner class methodsFor: 'documentation' stamp: 'rhi 2/5/2000 12:40'!testRunnerUsage	"Please see the class comment for some documentation.	Documentation links:		* TestingFrameworkPaper		* TestModel		* TestRunner"	self error: 'comment only'.!]style[(15 83 21 5 9 5 10 31)f1b,f1,f1LTestingFrameworkPaper Comment;,f1,f1LTestModel Comment;,f1,f1LTestRunner Comment;,f1! !!TestRunner class methodsFor: 'processing' stamp: 'rhi 2/5/2000 12:40'!runTests	"doIt: [TestRunner runTests]"	TestRunner new runTests.! !!TestRunner class methodsFor: 'processing' stamp: 'rhi 2/5/2000 12:40'!runTests: aString	"doIt: [TestRunner runTests: '* test*']"	TestRunner new runTests: aString.! !!TestSuite methodsFor: 'accessing' stamp: 'rhi 5/22/1999 17:51'!tests	^tests! !!TestSuite methodsFor: 'adding' stamp: 'rhi 2/5/2000 12:39'!addTest: aTestCase	self tests add: aTestCase.! !!TestSuite methodsFor: 'initialize-release' stamp: 'rhi 2/5/2000 12:39'!initialize	self tests: OrderedCollection new.! !!TestSuite methodsFor: 'private accessing' stamp: 'rhi 2/5/2000 12:39'!tests: anOrderedCollection	tests := anOrderedCollection.! !!TestSuite methodsFor: 'running' stamp: 'rhi 5/22/1999 13:51'!run	| result |	result := TestResult new.	self run: result.	^result! !!TestSuite methodsFor: 'running' stamp: 'rhi 2/5/2000 12:39'!run: aTestResult	self tests do: [:each |		each run: aTestResult].! !!TestSuite class methodsFor: 'instance creation' stamp: 'rhi 5/22/1999 19:45'!new	^super new initialize! !