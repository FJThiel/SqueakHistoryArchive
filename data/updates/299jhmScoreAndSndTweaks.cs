'From Squeak 2.2beta of Sept 11, 1998 on 22 September 1998 at 9:53:37 am'!"Change Set:		jhmScoreAndSndTweaksDate:			22 September 1998Author:			John MaloneyAdds menu commands to re-direct ScorePlayer output to a MIDI port or to theinternal sound synth. Makes piano rolls attempt to adapt their synchronizationto the actual redisplay time of the machine. This has not yet beentested on a wide variety of machines. Adds some utilities for scaling soundsegments in time and volume to support experiments with extracting wavesfrom SampledSounds for use as FM wavetables."!RectangleMorph subclass: #PianoRollScoreMorph	instanceVariableNames: 'scorePlayer score colorForTrack lowestNote leftEdgeTime timeScale indexInTrack lastUpdateTick lastStepMSec approximateScreenUpdateTime '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 11:31'!editSound: aSound	| p |	sound _ aSound.	sound envelopes isEmpty ifTrue: [		"provide a default volume envelope"		p _ OrderedCollection new.		p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.		sound addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3)].	self editEnvelope: sound envelopes first.	keyboard soundPrototype: sound.! !!FMSound methodsFor: 'initialization' stamp: 'jm 9/20/1998 10:10'!setWavetable: anArray	"(AbstractSound lowMajorScaleOn: (FMSound new setWavetable: AA)) play"	| samples p dur vol |	"copy the array into a SoundBuffer if necessary"	anArray class isPointers		ifTrue: [samples _ SoundBuffer fromArray: anArray]		ifFalse: [samples _ anArray].	p _ self pitch.	dur _ self duration.	vol _ self loudness.	waveTable _ samples.	scaledWaveTableSize _ waveTable size * ScaleFactor.	self setPitch: p dur: dur loudness: vol.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 9/22/1998 09:33'!step	| t fudge |	score ifNil: [^ self].	approximateScreenUpdateTime ifNil: [approximateScreenUpdateTime _ 1000].	lastStepMSec ifNotNil: [		"compute the approximate redisplay time"		"Details: lastStepMSecs is set only when we've updated the piano roll, so		 this display time estimate is done on the cycle following an actual piano roll		 update. The goal is to adjust for different processor speeds automatically."		t _ Time millisecondClockValue - lastStepMSec.		(t > 0 and: [t < (4 * approximateScreenUpdateTime)]) ifTrue: [			"ignore clock wrap (i.e., t < 0) and very large values of t for stability"			approximateScreenUpdateTime _ (approximateScreenUpdateTime + t) // 2].		lastStepMSec _ nil].  "don't do this calculation again until the next real piano roll update"	t _ scorePlayer ticksSinceStart.	t = lastUpdateTick ifFalse: [		lastStepMSec _ Time millisecondClockValue.		fudge _ 5.  "alignment tweak, in pixels"		self goToTime:			t - (((self width // 2) - borderWidth + fudge) asFloat / timeScale) truncated +			(scorePlayer ticksForMSecs: approximateScreenUpdateTime).		self addNotes.		lastUpdateTick _ t].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/21/1998 17:55'!closeMIDIPort	"Close my MIDI port, if it is open. Music will be played using the built-in sound synthesis."	self pause.	midiPort ifNil: [^ self].	midiPort close.	midiPort _ nil.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/21/1998 17:55'!openMIDIPort: portNum	"Open the given MIDI port. Music will be played as MIDI commands to the given MIDI port."	self closeMIDIPort.	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/22/1998 09:32'!ticksForMSecs: mSecs	^ (mSecs asFloat / (1000.0 * secsPerTick)) rounded! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:57'!closeMIDI	scorePlayer closeMIDIPort.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:40'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('reload instruments'		updateInstrumentsFromLibrary)		('play via built in synth'	closeMIDI)		('play via MIDI port 0'		openMIDIPort0)		('play via MIDI port 1'		openMIDIPort1)).	aMenu invokeOn: self defaultSelection: nil.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:43'!makeControls	| b r reverbSwitch repeatSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2;		color: color.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: '<>'; actWhen: #buttonDown;														actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Piano Roll';		actionSelector: #makePianoRoll).	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	b target: scorePlayer.	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #resumePlaying).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #pause).	reverbSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Reverb Disable';		actionSelector: #disableReverb:;		target: scorePlayer;		setSwitchState: SoundPlayer isReverbOn not.	r addMorphBack: reverbSwitch.	repeatSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Repeat';		actionSelector: #repeat:;		target: scorePlayer;		setSwitchState: scorePlayer repeat.	r addMorphBack: repeatSwitch.	b target: self.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:57'!openMIDIPort0	scorePlayer openMIDIPort: 0.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:57'!openMIDIPort1	scorePlayer openMIDIPort: 1.! !!SerialPort reorganize!('initialization' initialize)('settings' baudRate baudRate: dataBits dataBits: inputFlowControlType inputFlowControlType: outputFlowControlType outputFlowControlType: parityType parityType: stopBitsType stopBitsType: xOffByte xOffByte: xOnByte xOnByte:)('open/close' close openPort:)('input/output' nextPutAll: readByteArray readInto:startingAt: readString)('printing' printOn:)('primitives' primClosePort: primOpenPort:baudRate:stopBitsType:parityType:dataBits:inFlowControlType:outFlowControlType:xOnByte:xOffByte: primReadPort:into:startingAt:count: primWritePort:from:startingAt:count:)!!WaveEditor methodsFor: 'other' stamp: 'jm 9/19/1998 15:03'!normalize: sampleArray	"Return a copy of the given sample array scaled to use the maximum 16-bit sample range. Remove any D.C. offset."	| max abs scale out |	max _ 0.	sampleArray do: [:s |		s > 0 ifTrue: [abs _ s] ifFalse: [abs _ 0 - s].		abs > max ifTrue: [max _ abs]].	scale _ ((1 << 15) - 1) asFloat / max.	out _ sampleArray species new: sampleArray size.	1 to: sampleArray size do: [:i |		out at: i put: (scale * (sampleArray at: i)) truncated].	^ out! !!WaveEditor methodsFor: 'other' stamp: 'jm 9/20/1998 09:13'!stretch: sampleArray by: stretchFactor	"Return an array consisting of the given samples \stretched in time by the given factor."	| out end incr i frac index |	out _ OrderedCollection new: (stretchFactor * sampleArray size) asInteger + 1.	end _ (sampleArray size - 1) asFloat.	incr _ 1.0 / stretchFactor.	i _ 1.0.	[i < end] whileTrue: [		frac _ i fractionPart.		index _ i truncated.		i _ i + incr.		out addLast:			(((1.0 - frac) * (sampleArray at: index)) + (frac * (sampleArray at: index + 1))) rounded].	^ out asArray! !ScorePlayer removeSelector: #playOnMidiPort:!ScorePlayer removeSelector: #midiPort:!ScorePlayerMorph removeSelector: #reset!