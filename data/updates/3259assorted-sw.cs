'From Squeak2.9alpha of 5 August 2000 [latest update: #3318] on 29 January 2001 at 1:05:56 am'!"Change Set:		assorted-swDate:			29 January 2001Author:			Scott Wallace* Various customized message-list-browsers that formerly maintained entries for methods that had been removed from the system no longer do that -- e.g. changed-message browser, recent-submissions browser.* After issuing a cmd to remove a method from the current change set (in a browser) the annotation pane is now properly refreshed.* Fixes logic in confirm-script-deletion dialog.* Adds a method for retrieving a code-browsing button with given selector, and makes an initial use of it.* Message list whose current selection is a method that no longer is in the image will no longer drop you into a debugger on cmd-m, cmd-n, etc.* The check for other authors in the change sorter no longer will ever put up the please-type-your-initials dialog.* Added call to #noteAcceptanceOfCodeFor: in acceptance code in MessageSet, in preparation for forthcoming current-working-set features.* Added 'trash' support generically to Model.* A couple of class reorgs, and misc other minor code, some in support of forthcoming features."!Browser subclass: #MessageSet	instanceVariableNames: 'messageList autoSelectString growable '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 1/27/2001 22:30'!checkForAlienAuthorship	"Check to see if there are any methods in the receiver that have author initials other than that of the current author, and open a browser on all found"	| aList initials |	(initials _ Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].	(aList _ self methodsWithInitialsOtherThan: initials) size > 0		ifFalse:			[^ self inform: 'All methods in "', self name, '"have authoring stamps which start with "', initials, '"']		ifTrue:			[Smalltalk browseMessageList: aList name: 'methods in "', self name, '" whose authoring stamps do not start with "', initials, '"']! !!Class methodsFor: 'class name' stamp: 'sw 12/1/2000 20:40'!uniqueNameForReference	"Answer a unique name by which the receiver can be referred to from user scripts, for example"	^ name! !!Model methodsFor: 'menus' stamp: 'sw 12/15/2000 13:21'!trash	"What should be displayed if a trash pane is restored to initial state"	^ ''! !!Model methodsFor: 'menus' stamp: 'sw 12/15/2000 13:21'!trash: ignored	"Whatever the user submits to the trash, it need not be saved."	^ true! !!Model methodsFor: 'keyboard' stamp: 'sw 1/29/2001 00:54'!arrowKey: aChar from: view	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index.  Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany anEvent |	(#(1 4 11 12 30 31) includes: (keyEvent _ aChar asciiValue)) ifFalse:		[(Smalltalk isMorphic and: [false]) ifTrue:			[((anEvent _ view currentEvent) isKindOf: KeyboardEvent) ifTrue: [self currentWorld keystrokeInWorld: anEvent]].			self flag: #deferred.			"Would like to pass all command-keys that pass through the hands of the model via this protocol but are not in fact interecepted here on to the desktop, where they might be quite relevant.  But when we obtain the event this way we are not getting the keyboard event"			^ self].     oldSelection := view getCurrentSelectionIndex.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view numSelectionsInView.	"get this exactly??"     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[self okToChange			ifTrue:				[view changeModelSelection: nextSelection.				"view controller moveMarker"]]			! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/25/2001 09:22'!destroyScript	"At user request, and only after confirmation, destroy the script, thus removing it from the uniclass's method dictionary and removing its instantiations from all instances of uniclass, etc."	(self confirm: 'Caution -- this destroys this scriptpermanently; are you sure you want to do this?') ifFalse: [^ self].	true ifTrue: [^ playerScripted removeScript: scriptName fromWorld: self world].	self flag: #deferred.  "revisit"	(playerScripted okayToDestroyScriptNamed: scriptName)		ifFalse:			[^ self inform: 'Sorry, this script is being calledfrom another script.'].	self actuallyDestroyScript! !!StringHolder methodsFor: 'accessing' stamp: 'sw 12/9/2000 23:59'!noteAcceptanceOfCodeFor: aSelector	"A method has possibly been submitted for the receiver with aSelector as its selector; If the receiver wishes to take soem action here is a chance for it to do so"! !!StringHolder methodsFor: 'accessing' stamp: 'sw 12/6/2000 17:48'!reformulateListNoting: newSelector	"A method has possibly been submitted for the receiver with newSelector as its selector; If the receiver has a way of reformulating its message list, here is a chance for it to do so"	^ self reformulateList! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 1/11/2001 13:28'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.    If in mvc, an old-style protocol browser is opened instead.  Someone who still uses mvc might wish to make the protocol-category-browser work there too, thanks.  The temporary circumlocution regarding the presence/absence of ProtocolCategoryBrowser is of course quite temporary."	| aClass |	(Smalltalk isMorphic and: [Smalltalk includesKey: #ProtocolCategoryBrowser]) ifFalse: [^ self spawnFullProtocol].	(aClass _ self selectedClassOrMetaClass) ifNotNil:		[(Smalltalk at: #ProtocolCategoryBrowser) new openOnClass: aClass targetObject: nil inWorld: self currentWorld showingSelector: self selectedMessageName]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 1/25/2001 17:04'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	Smalltalk changes removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.	self changed: #annotation! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 1/28/2001 02:48'!selectMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selector method messages |	(selector _ self selectedMessageName) ifNil: [^ self].	method _ (self selectedClassOrMetaClass ifNil: [^ self])		compiledMethodAt: selector		ifAbsent: [].	(method isNil or: [(messages _ method messages) size == 0])		 ifTrue: [^ aBlock value: selector].	(messages size == 1 and: [messages includes: selector])		ifTrue:			[^ aBlock value: selector].  "If only one item, there is no choice"	Smalltalk 		showMenuOf: messages		withFirstItem: selector		ifChosenDo: [:sel | aBlock value: sel]! !!CodeHolder methodsFor: 'misc' stamp: 'sw 1/28/2001 00:11'!browseSenders	"Create and schedule a message set browser on all senders of the currently selected message selector. Do nothing if no message is selected."	| aMessageName |	(aMessageName _ self selectedMessageName) ifNotNil: 		[Smalltalk browseAllCallsOn: aMessageName]! !!CodeHolder methodsFor: 'misc' stamp: 'sw 1/7/2001 07:15'!buttonWithSelector: aSelector	"If receiver has a control button with the given action selector answer it, else answer nil.  morphic only at this point"	| aWindow aPane |	((aWindow _ self containingWindow) isKindOf: SystemWindow) ifFalse: [^ nil].	(aPane _ aWindow submorphNamed: 'buttonPane') ifNil: [^ nil].	^  aPane submorphThat: [:m | (m isKindOf: PluggableButtonMorph) and:		[m actionSelector == aSelector]] ifNone: [^ nil]! !!CodeHolder methodsFor: 'misc' stamp: 'sw 1/25/2001 14:44'!inheritanceButton	"If receiver has an Inheritance button, answer it, else answer nil.  morphic only at this point"	^ self buttonWithSelector: #methodHierarchy! !!MessageSet methodsFor: 'message list' stamp: 'sw 1/28/2001 20:57'!addExtraShiftedItemsTo: aMenu	"The shifted selector-list menu is being built.  Add items specific to MessageSet"	self growable ifTrue:		[aMenu addList: #(			-			('remove from this browser'		removeMessageFromBrowser)			('filter message list...'			filterMessageList)			('add to message list...'			augmentMessageList))]! !!MessageSet methodsFor: 'message list' stamp: 'sw 1/28/2001 20:56'!growable	"Answer whether the receiver is capable of growing/shrinking dynamically"	^ growable ~~ false! !!MessageSet methodsFor: 'message list' stamp: 'sw 12/6/2000 07:12'!growable: aBoolean	"Give or take away the growable trait; when a message set is growable, methods submitted within it will be added to its message list"	growable _ aBoolean! !!MessageSet methodsFor: 'message functions' stamp: 'sw 12/1/2000 11:52'!removeMessage	"Remove the selected message from the system. 1/15/96 sw"	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self deleteFromMessageList: self selection.	self reformulateList.	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !!MessageSet methodsFor: 'message functions' stamp: 'sw 1/12/2001 00:19'!removeMessageFromBrowser	"Remove the selected message from the browser."	messageListIndex = 0 ifTrue: [^ self].	self deleteFromMessageList: self selection.	self reformulateList.	self adjustWindowTitleAfterFiltering! !!MessageSet methodsFor: 'message functions' stamp: 'sw 12/5/2000 16:48'!toggleShowDocumentation	"Toggle the setting of the showDocumentation flag"	self okToChange ifTrue:		[self showDocumentation: self showingDocumentation not.		self changed: #contents]! !!MessageSet methodsFor: 'contents' stamp: 'sw 12/5/2000 12:17'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		class ifNil: [^ 'Class vanished'].		source _ class sourceMethodAt: selector ifAbsent:			[currentCompiledMethod _ nil.			^ 'Missing'].		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		self showingDocumentation ifTrue:			[^ self commentContents].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil decorated: Preferences colorWhenPrettyPrinting].		self showDiffs ifTrue:			[source _ self diffFromPriorSourceFor: source].		^ source asText makeSelectorBoldIn: class]! !!MessageSet methodsFor: 'private' stamp: 'sw 12/9/2000 23:59'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answertrue."	| category selector class oldSelector |	messageListIndex = 0 ifTrue: [^ false].	self okayToAccept ifFalse: [^ false].	self setClassAndSelectorIn: [:c :os | class_c.  oldSelector_os].	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^ false].	self noteAcceptanceOfCodeFor: selector.	selector == oldSelector ifFalse:		[self reformulateListNoting: selector].	contents _ aString copy.	self changed: #annotation.	^ true! !!MessageSet methodsFor: 'private' stamp: 'sw 12/9/2000 17:13'!initializeMessageList: anArray	"Initialize the message list from anArray, which must contain objects which, when sent #asString, answer a string in standard format such as 'Rectangle width'"	messageList _ anArray collect: [:each |		MessageSet parse: each asString toClassAndSelector: [:class :sel |			class ifNotNil: [class name , ' ' , sel , ' {' , ((class organization categoryOfElement: sel) ifNil: ['']) , '}']]]		thenSelect:			[:each | each notNil].	messageListIndex _ 0.	contents _ ''! !!MessageSet methodsFor: 'private' stamp: 'sw 12/28/2000 14:28'!selection	"Answer the item in the list that is currently selected, or nil if no selection is present"	^ messageList at: messageListIndex ifAbsent: [nil]! !!ChangedMessageSet methodsFor: 'everything' stamp: 'sw 1/28/2001 20:59'!growable	"Answer whether the receiver can be changed by manual additions & deletions"	^ false! !!MessageSet class methodsFor: 'utilities' stamp: 'sw 1/27/2001 12:18'!extantMethodsIn: aList	"Answer the subset of the incoming list consisting only of those message markers that refer to methods actually in the current image"	^ aList select:		[:aToken |			self parse: aToken toClassAndSelector:				[:aClass :aSelector | aClass notNil and: [aClass includesSelector: aSelector]]]! !!MessageSet class methodsFor: 'utilities' stamp: 'sw 1/28/2001 23:40'!parse: messageString toClassAndSelector: csBlock	"Decode strings of the form <className> [class] <selectorName>."	| tuple cl |	messageString ifNil: [^ csBlock value: nil value: nil].	tuple _ messageString findTokens: ' .'.	cl _ Smalltalk atOrBelow: tuple first asSymbol ifAbsent: [^ csBlock value: nil value: nil].	(tuple size = 2 or: [tuple size > 2 and: [(tuple at: 2) ~= 'class']])		ifTrue: [^ csBlock value: cl value: (tuple at: 2) asSymbol]		ifFalse: [^ csBlock value: cl class value: (tuple at: 3) asSymbol]! !!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'sw 1/27/2001 12:20'!openFor: aChangeSet	"Open up a ChangedMessageSet browser on the given change set; this is a conventional message-list browser whose message-list consists of all the methods in aChangeSet.  After any method submission, the message list is refigured, making it plausibly dynamic"	| messageSet |	messageSet _ MessageSet extantMethodsIn: aChangeSet changedMessageListAugmented.	self openMessageList: messageSet name: ('Methods in Change Set ', aChangeSet name) autoSelect: nil changeSet: aChangeSet! !!RecentMessageSet methodsFor: 'update' stamp: 'sw 1/28/2001 20:59'!growable	"Answer whether the receiver can be changed by manual additions & deletions"	^ false! !!RecentMessageSet methodsFor: 'update' stamp: 'sw 1/27/2001 12:25'!reformulateList	"Reformulate the receiver's list.  Exclude methods now deleted"	self initializeMessageList: (MessageSet extantMethodsIn: Utilities recentMethodSubmissions reversed).	self messageListIndex: (messageList size min: 1).	"0 or 1"	self changed: #messageList.	self changed: #messageListIndex! !!RecentMessageSet reorganize!('contents' contents:notifying:)('update' growable reformulateList updateListsAndCodeIn:)('selection' maybeSetSelection)!!MessageSet class reorganize!('instance creation' messageList: open:name: openAsMorph:name: openAsMorph:name:inWorld: openMessageList:name: openMessageList:name:autoSelect:)('utilities' extantMethodsIn: parse:toClassAndSelector:)!Browser removeSelector: #browseSenders!ProtoObject removeSelector: #info!