'From Squeak 2.5 of August 6, 1999 on 27 September 1999 at 9:07:47 pm'!"Change Set:		ApplescriptDate:			27 September 1999Author:			Andrew C. GreenbergFirst update of the Applescript Plugin.  Provides substantially better encapsulation of the Applescript data structures, and simpler creation and manipulation of Applescript compiled scripts and contexts (including inheritance), and code assuring that script contexts will be properly maintained between execution.  See class comment for Applescript.  Further documentation will be posted on the Swiki.To install, you must first install the most current version of the Applescript Plugin, which you can autogenerate yourself (See class comment in TestOSAPlugin) or download from the Swiki.  With the plugin installed, simply execute the following in a workspace:	Applescript initializeand you are ready to go.  This changeset requires a fully updated 2.6test system, including the 1465NewCompiler-ACG and 1465NewCompiler2-ACG changesets."!Object subclass: #Applescript	instanceVariableNames: 'compiledScript source '	classVariableNames: 'ApplescriptGeneric '	poolDictionaries: ''	category: 'Werdna-Applescript'!StringHolder subclass: #ApplescriptError	instanceVariableNames: 'errorMessage from to '	classVariableNames: ''	poolDictionaries: ''	category: 'Werdna-Applescript'!ByteArray variableByteSubclass: #CompiledApplescript	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Werdna-Applescript'!ComponentInstance variableWordSubclass: #ApplescriptInstance	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Werdna-Applescript'!!Applescript commentStamp: '<historical>' prior: 0!I represent a Squeak front-end to Applescript.  My instances represent either compiled scripts, contexts or both.  My instances maintain separately the original source code from which I was compiled, and then a CompiledApplescript corresponding to that source code in its "current state."  I provide facilities for executing my scripts, alone or in various contexts, as well as for recompiling my script to restore the script to its initial state (if the script bears context information).Examples:	To execute some text:		Applescript doIt: 'beep 3'	To compile code into a script object (for MUCH faster execution of repeated tasks, and to maintain state between execution), and then to execute the code:		|aVariable|		aVariable _ Applescript on: '			property sam: 0			set sam to sam + 1			beep sam'.		aVariable doIt	Other. somewhat more general operations		Applescript doIt: aString mode: anInteger		Applescript doIt: aString in: aContext mode: anInteger		s _ Applescript on: aString mode: anInteger		s doItMode: anInteger		s doItIn: aContext		s doItIn: aContext mode: anInteger		s recompile	Also note the examples in the class side of me.		!!Applescript reorganize!('accessing' compiledScript modeDocumentation source)('testing' hasSource isCompiledScript isScriptContext isScriptValue timesModified)('interpreting' asContextDoOSAID:mode: doIt doItIn: doItIn:mode: doItMode:)('recompiling' recompile recompileMode:)('printing' printOn:)('private' doAsOSAID: doAsOSAID:onErrorDo: on: on:mode: on:mode:onErrorDo:)!!Applescript methodsFor: 'accessing' stamp: 'acg 9/26/1999 01:00'!compiledScript	^compiledScript! !!Applescript methodsFor: 'accessing' stamp: 'acg 9/27/1999 00:32'!modeDocumentation"	16r0000			kOSAModeNull (kOSANullMode)	16r0001			kOSAModePreventGetSource	16r0002			kOSAModeCompileIntoContext	16r0004			kOSAModeAugmentContext	16r0008			kOSAModeDisplayForHumans					kOSAModeNeverInteract					kOSAModeCanInteract					kOSAModeAlwaysInteract					kOSAModeDontReconnect	16r0040			kOSAModeCantSwitchLayer	16r1000			kOSAModeDoRecord	16r4000			kOSAModeDontStoreParent"! !!Applescript methodsFor: 'accessing' stamp: 'acg 9/26/1999 00:59'!source	^source! !!Applescript methodsFor: 'testing' stamp: 'acg 9/26/1999 22:40'!hasSource	^self doAsOSAID: [:o | Applescript generic hasSource: o]! !!Applescript methodsFor: 'testing' stamp: 'acg 9/26/1999 22:39'!isCompiledScript	^self doAsOSAID: [:o | Applescript generic isCompiledScript: o]! !!Applescript methodsFor: 'testing' stamp: 'acg 9/26/1999 22:39'!isScriptContext	^self doAsOSAID: [:o | Applescript generic isScriptContext: o]! !!Applescript methodsFor: 'testing' stamp: 'acg 9/26/1999 22:39'!isScriptValue	^self doAsOSAID: [:o | Applescript generic isScriptValue: o]! !!Applescript methodsFor: 'testing' stamp: 'acg 9/26/1999 22:39'!timesModified	^self doAsOSAID: [:o | Applescript generic timesModified: o]! !!Applescript methodsFor: 'interpreting' stamp: 'acg 9/26/1999 21:13'!asContextDoOSAID: scptOSAID mode: anInteger	"Answer a string corresponding to the result of executing preloaded scptOSAID using my compiledScript as the context, and using mode anInteger.  As a side-effect, update my script information as necessary.  (This routine will not update any stored versions of scptOSAID"	^self 		doAsOSAID: 			[:contextOSAID |			 ApplescriptGeneric 				executeAndDisplayOSAID: scptOSAID				in: contextOSAID				mode: anInteger]		onErrorDo: 					[ApplescriptError 				syntaxErrorFor: (String streamContents:					[:aStream |					 aStream 						nextPutAll: (ApplescriptGeneric sourceOfOSAID: scptOSAID); cr; cr;						nextPutAll: '<=== Source Code of Context ===>'; cr;						nextPutAll: source])				withComponent: ApplescriptGeneric]! !!Applescript methodsFor: 'interpreting' stamp: 'acg 9/26/1999 20:43'!doIt	"Answer a string corresponding to the result of executing my script in the default context. mode 0.  As a side-effect, update my script information as necessary."	^self doAsOSAID: [:scptOSAID |		ApplescriptGeneric executeAndDisplayOSAID: scptOSAID in: (OSAID new) mode: 0]! !!Applescript methodsFor: 'interpreting' stamp: 'acg 9/26/1999 21:22'!doItIn: aContext	"Answer a string corresponding to the result of executing my script in aContext. mode 0.  As a side-effect, update my script and the aContext information as necessary."	^self doAsOSAID: [:scptContext |		aContext asContextDoOSAID: scptContext mode: 0]! !!Applescript methodsFor: 'interpreting' stamp: 'acg 9/26/1999 20:43'!doItIn: aContext mode: anInteger	"Answer a string corresponding to the result of executing my script in aContext. mode anInteger.  As a side-effect, update my script and the aContext information as necessary."	^self doAsOSAID: [:scptContext |		aContext asContextDoOSAID: scptContext mode: anInteger]! !!Applescript methodsFor: 'interpreting' stamp: 'acg 9/26/1999 20:43'!doItMode: anInteger	"Answer a string corresponding to the result of executing my script in the default context. mode anInteger.  As a side-effect, update my script information as necessary."	^self doAsOSAID: [:scptOSAID |		ApplescriptGeneric 			executeAndDisplayOSAID: scptOSAID 			in: (OSAID new) 			mode: anInteger]! !!Applescript methodsFor: 'recompiling' stamp: 'acg 9/26/1999 20:55'!recompile	self on: source! !!Applescript methodsFor: 'recompiling' stamp: 'acg 9/26/1999 20:55'!recompileMode: anInteger	self on: source mode: anInteger! !!Applescript methodsFor: 'printing' stamp: 'acg 9/26/1999 22:52'!printOn: aStream	aStream nextPutAll: 'an Applescript('.	self isCompiledScript ifTrue: [aStream nextPutAll: 'script '].	self isScriptContext ifTrue: [aStream nextPutAll: 'context '].	aStream 		nextPutAll: compiledScript size asString;		nextPutAll: ' bytes)'! !!Applescript methodsFor: 'private' stamp: 'acg 9/26/1999 20:59'!doAsOSAID: aBlock	"Answer the result of performing aBlock on my compiledScript, converted to OSAID form.  As a side-effect, update compiledScript to conform to any changes that may have occurred inside the Applescript scripting component."	^self doAsOSAID: aBlock onErrorDo:		[ApplescriptError 			syntaxErrorFor: source 			withComponent: ApplescriptGeneric]! !!Applescript methodsFor: 'private' stamp: 'acg 9/27/1999 00:04'!doAsOSAID: aCodeBlock onErrorDo: anErrorBlock	"Answer the result of performing aBlock on my compiledScript, converted to OSAID form.  As a side-effect, update compiledScript to conform to any changes that may have occurred inside the Applescript scripting component."	| anOSAID result |	anOSAID _ compiledScript asAEDesc asOSAIDThenDisposeAEDescWith: ApplescriptGeneric.	result _ aCodeBlock value: anOSAID.	compiledScript _ (anOSAID asCompiledApplescriptWith: ApplescriptGeneric)						ifNil: [compiledScript].	anOSAID disposeWith: ApplescriptGeneric.	^result ifNil: [anErrorBlock value]! !!Applescript methodsFor: 'private' stamp: 'acg 9/26/1999 21:00'!on: aString	^self on: aString mode: 2 onErrorDo: 		[ApplescriptError 			syntaxErrorFor: aString 			withComponent: ApplescriptGeneric]! !!Applescript methodsFor: 'private' stamp: 'acg 9/26/1999 20:59'!on: aString mode: anInteger	^self on: aString mode: anInteger onErrorDo: 		[ApplescriptError 			syntaxErrorFor: aString 			withComponent: ApplescriptGeneric]! !!Applescript methodsFor: 'private' stamp: 'acg 9/26/1999 20:47'!on: aString mode: anInteger onErrorDo: aBlock	source _ aString.	compiledScript _ ApplescriptGeneric compile: aString mode: anInteger.	compiledScript ifNil: [^aBlock value].	^self! !!Applescript class reorganize!('instance creation' on: on:mode:)('generic scripting component' doIt: doIt:in:mode: doIt:mode: generic lastError)('sample scripts' beep: browse: distill mandatoryDemo playQT4Movie say: selectFile selectFolder silly sillyButtons sillyDialog sillyList sleep with:say:)('initialize-release' initialize reopen startUp)!!Applescript class methodsFor: 'instance creation' stamp: 'acg 9/25/1999 23:36'!on: aString	^super new on: aString! !!Applescript class methodsFor: 'instance creation' stamp: 'acg 9/26/1999 20:49'!on: aString mode: anInteger	^super new on: aString mode: anInteger! !!Applescript class methodsFor: 'generic scripting component' stamp: 'acg 9/26/1999 02:19'!doIt: aString	^(self on: aString) doIt! !!Applescript class methodsFor: 'generic scripting component' stamp: 'acg 9/26/1999 20:50'!doIt: aString in: aContext mode: anInteger	^(self on: aString mode: anInteger) doItIn: aContext mode: anInteger! !!Applescript class methodsFor: 'generic scripting component' stamp: 'acg 9/26/1999 20:50'!doIt: aString mode: anInteger	^(self on: aString mode: anInteger) doItMode: anInteger! !!Applescript class methodsFor: 'generic scripting component' stamp: 'acg 9/25/1999 23:43'!generic	"Answer an ApplescriptInstance (Applescript Generic Scripting Component) that is guaranteed to be active from startUp, but is not (at present) guaranteed to be identical across startups.  Additional instances can be created for multi-threaded applications by using ApplescriptInstance."	^ApplescriptGeneric ifNil:		[ApplescriptGeneric _ ApplescriptInstance new]! !!Applescript class methodsFor: 'generic scripting component' stamp: 'acg 9/25/1999 23:28'!lastError	^self generic lastError! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:16'!beep: anInteger	"Beep n times"	^self doIt: 'beep ', anInteger asString! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:16'!browse: anUrl	"Open Microsoft's Web Browser to a page"		^self doIt: 'tell application "Internet Explorer"		activate		openURL "', anUrl, '"	end tell'! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:16'!distill	Applescript doIt: 'set prompt to "Select a file to convert to .pdf format"set myFile to (choose file with prompt prompt of type "TEXT")tell application "Acrobatª Distillerª 3.02"	activate	open myFileend tell'! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:16'!mandatoryDemo	"A mandatory first script"	^self doIt: '3 + 4'! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/27/1999 08:12'!playQT4Movie	"Demonstrate Access to Quicktime"	^Applescript doIt: '-- Play QuickTime File-- ©1999 Sal Soghoian, Apple Computerproperty source_folder : ""property container_kind : "folder"property reset_string : "Pick New Source Folder"-- Check the version of QuickTimecopy my gestaltVersion_info("qtim", 8) to {QT_version, QT_string}if the QT_version is less than "0400" then	display dialog "This script requires QuickTime 4.0 or higher." & Â		return & return & "The currently installed version is: " & Â		QT_string buttons {"Cancel"} default button 1end if-- Check the version of the OScopy my gestaltVersion_info("sysv", 4) to {system_version, system_string}if the system_version is less than "0850" then	display dialog "This script requires Mac OS 8.5 or higher." & Â		return & return & "The currently installed version is: " & Â		system_string buttons {"Cancel"} default button 1end if-- check to see if source folder existstry	if the source_folder is "" then error	set the source_folder to alias (source_folder as text)on error	set the source_folder to choose_source_folder()	if the result is false then return "user canceled"end try-- set the target folder to the source folderset the target_folder to the source_folderrepeat	-- search the target folder for folders or QT files	try		tell application "Finder"			set the item_list to (the name of every item of Â				the target_folder whose Â				(creator type is "TVOD") or Â				(kind is the container_kind)) as list			set the item_list to my ASCII_Sort(item_list)			set the beginning of the item_list to "Pick New Source Folder"		end tell	on error		beep		display dialog "The chosen folder contains no folders or QuickTime files." buttons {"Show Me", "Cancel"} default button 2		tell application "Finder"			activate			open the target_folder		end tell		return "no items"	end try		-- prompt the user to pick a folder or file	set the chosen_item to choose from list the item_list with prompt Â		"Pick an item:"	if the chosen_item is false then return	set the chosen_item to the chosen_item as string		if the chosen_item is reset_string then		set the source_folder to choose_source_folder()		if the result is false then return "user canceled"		set the target_folder to the source_folder	else		-- Check the user''s choice to determine whether it''s a file or folder		tell application "Finder"			if the kind of item chosen_item of the target_folder is the container_kind then				-- The user picked a folder. Set the new target folder and repeat the process.				set the target_folder to folder chosen_item of the the target_folder			else				-- The user picked a file. Get the path to the file and exit the repeat.				set the chosen_item to (item chosen_item of the target_folder) as alias				exit repeat			end if		end tell	end ifend repeat-- Find out if the user wants to play the item in the front or back.set play_in_background to truedisplay dialog "Play the media in the foreground or background?" buttons {"Cancel", "Foreground", "Background"} default button 3if the button returned of the result is "Foreground" then set play_in_background to false-- Quit the QuickTime Player if it is opentell application "Finder"	if (the creator type of every process) contains Çclass TVODÈ then Â		tell application "QuickTime Player" to quitend tell-- Convert the alias to a URL format stringset this_file to "file:///" & my filepath_to_URL(the chosen_item, true, false)-- Tell the QuickTime Player to open the file.-- NOTE: to autoplay, Check the Auto-Play preference in the General setting in the QuickTime Player.tell application "QuickTime Player"	if play_in_background is false then activate	open location this_fileend tellon gestaltVersion_info(gestalt_code, string_length)	try		tell application "Finder" to Â			copy my NumToHex((computer gestalt_code), Â				string_length) to {a, b, c, d}		set the numeric_version to {a, b, c, d} as string		if a is "0" then set a to ""		set the version_string to (a & b & "." & c & "." & d) as string		return {numeric_version, version_string}	on error		return {"", "unknown"}	end tryend gestaltVersion_infoon NumToHex(hexData, stringLength)	set hexString to {}	repeat with i from stringLength to 1 by -1		set hexString to ((hexData mod 16) as string) & hexString		set hexData to hexData div 16	end repeat	return (hexString as string)end NumToHexon choose_source_folder()	try		set the source_folder to choose folder with prompt Â			"Pick a folder containing Quicktime content:"		return the source_folder	on error		return false	end tryend choose_source_folder-- this sub-routine converts a filepath to an encoded URL-- My Disk:My Folder:My File-- My%20Disk/My%20Folder/My%20Fileon filepath_to_URL(this_file, encode_URL_A, encode_URL_B)	set this_file to this_file as text	set AppleScript''s text item delimiters to ":"	set the path_segments to every text item of this_file	repeat with i from 1 to the count of the path_segments		set this_segment to item i of the path_segments		set item i of the path_segments to Â			my encode_text(this_segment, encode_URL_A, encode_URL_B)	end repeat	set AppleScript''s text item delimiters to "/"	set this_file to the path_segments as string	set AppleScript''s text item delimiters to ""	return this_fileend filepath_to_URL-- this sub-routine is used to encode texton encode_text(this_text, encode_URL_A, encode_URL_B)	set the standard_characters to Â		"abcdefghijklmnopqrstuvwxyz0123456789"	set the URL_A_chars to "$+!!''/?;&@=#%><{}[]\"~`^\\|*"	set the URL_B_chars to ".-_:"	set the acceptable_characters to the standard_characters	if encode_URL_A is false then Â		set the acceptable_characters to Â			the acceptable_characters & the URL_A_chars	if encode_URL_B is false then Â		set the acceptable_characters to Â			the acceptable_characters & the URL_B_chars	set the encoded_text to ""	repeat with this_char in this_text		if this_char is in the acceptable_characters then			set the encoded_text to Â				(the encoded_text & this_char)		else			set the encoded_text to Â				(the encoded_text & encode_char(this_char)) as string		end if	end repeat	return the encoded_textend encode_text-- this sub-routine is used to encode a characteron encode_char(this_char)	set the ASCII_num to (the ASCII number this_char)	set the hex_list to Â		{"0", "1", "2", "3", "4", "5", "6", "7", "8", Â			"9", "A", "B", "C", "D", "E", "F"}	set x to item ((ASCII_num div 16) + 1) of the hex_list	set y to item ((ASCII_num mod 16) + 1) of the hex_list	return ("%" & x & y) as stringend encode_char-- This routine sorts a list of strings passed to iton ASCII_Sort(my_list)	set the index_list to {}	set the sorted_list to {}	repeat (the number of items in my_list) times		set the low_item to ""		repeat with i from 1 to (number of items in my_list)			if i is not in the index_list then				set this_item to item i of my_list as text				if the low_item is "" then					set the low_item to this_item					set the low_item_index to i				else if this_item comes before the low_item then					set the low_item to this_item					set the low_item_index to i				end if			end if		end repeat		set the end of sorted_list to the low_item		set the end of the index_list to the low_item_index	end repeat	return the sorted_listend ASCII_Sort'! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:16'!say: aString	"Speak the string"	^self doIt: 'say "', aString, '"'! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:16'!selectFile	"Harness Apple's select file dialog for Squeak"	^self doIt: '(choose file with prompt "Hi guys!!" of type "TEXT") as string'! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:16'!selectFolder	"Harness Apple's select Folder dialog for Squeak"	^self doIt: '(choose folder with prompt "Hi guys!!") as string'! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:17'!sillyButtons	"A silly Apple GUI demo"	^self doIt: '		display dialog "The Mouse that Roars!!" ',			'buttons {"One", "Two", "Three"} default button "One"'! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:17'!sillyDialog	"A silly Apple GUI demo"	self doIt: 'display dialog "Enter a number between 1 and 10." default answer ""set userValue to {text returned of result} as realif (userValue < 1) or (userValue > 10) then	display dialog "That Value is out of range." buttons {"OK"} default button 1else 	display dialog "Thanks for playing." buttons {"OK"} default button 1end if'! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:17'!sillyList	"A silly Apple GUI demo"	^Applescript doIt:		'choose from list {"dogs", "cats", "lions", "pick the mouse!!"}',			'with prompt "hi there"',			'default items {"dogs"}',			'OK button name "DoIt!!"', 			'cancel button name "Chicken!!"'! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:17'!sleep	^self doIt: 'tell application "Finder"	sleepend tell'"Applescript sleep"! !!Applescript class methodsFor: 'sample scripts' stamp: 'acg 9/26/1999 02:17'!with: voiceString say: contentString	"Speak the string"	^self doIt: 'say "', contentString, '" using "', voiceString, '"'! !!Applescript class methodsFor: 'initialize-release' stamp: 'acg 9/27/1999 08:35'!initialize	Smalltalk addToStartUpList: self after: nil.	ApplescriptGeneric _ nil.	Applescript generic! !!Applescript class methodsFor: 'initialize-release' stamp: 'acg 9/25/1999 23:29'!reopen	^self generic reopen! !!ApplescriptError commentStamp: '<historical>' prior: 0!I represent a syntax or execution error report for errors encountered when processing Applescripts. As a StringHolder, the string to be viewed is generally the method code or expression containing the error.!!ApplescriptError methodsFor: 'as yet unclassified' stamp: 'acg 9/26/1999 02:10'!canDiscardEdits	^true! !!ApplescriptError methodsFor: 'as yet unclassified' stamp: 'acg 9/26/1999 01:26'!code: codeString errorMessage: errString from: fromInteger to: toInteger	contents _ codeString.	from _ fromInteger.	to _ toInteger.	errorMessage _ errString! !!ApplescriptError methodsFor: 'as yet unclassified' stamp: 'acg 9/26/1999 01:25'!contentsSelection	^from to: to! !!ApplescriptError methodsFor: 'as yet unclassified' stamp: 'acg 9/26/1999 01:27'!list	^Array with: errorMessage! !!ApplescriptError methodsFor: 'as yet unclassified' stamp: 'acg 9/26/1999 01:27'!listIndex	^1! !!ApplescriptError methodsFor: 'as yet unclassified' stamp: 'acg 9/26/1999 22:10'!listMenu: aMenu	^aMenu labels: '' lines: #() selections: #()! !!ApplescriptError class methodsFor: 'as yet unclassified' stamp: 'acg 9/26/1999 21:00'!buildMVCViewOn: aSyntaxError	"Answer an MVC view on the given SyntaxError."	| topView aListView aCodeView |	topView _ StandardSystemView new		model: aSyntaxError;		label: 'Applescript Error';		minimumSize: 380@220.	aListView _ PluggableListView on: aSyntaxError		list: #list		selected: #listIndex		changeSelected: nil		menu: #listMenu:.	aListView window: (0@0 extent: 380@20).	topView addSubView: aListView.	aCodeView _ PluggableTextView on: aSyntaxError		text: #contents		accept: nil		readSelection: #contentsSelection		menu: #codePaneMenu:shifted:.	aCodeView window: (0@0 extent: 380@200).	topView addSubView: aCodeView below: aListView.	^ topView! !!ApplescriptError class methodsFor: 'as yet unclassified' stamp: 'acg 9/26/1999 21:01'!buildMorphicViewOn: aSyntaxError	"Answer an Morphic view on the given SyntaxError."	| window |	window _ (SystemWindow labelled: 'Applescript Error') model: aSyntaxError.	window addMorph: (PluggableListMorph on: aSyntaxError list: #list			selected: #listIndex changeSelected: nil menu: #listMenu:)		frame: (0@0 corner: 1@0.15).	window addMorph: (PluggableTextMorph on: aSyntaxError text: #contents			accept: nil readSelection: #contentsSelection			menu: #codePaneMenu:shifted:)		frame: (0@0.15 corner: 1@1).	^ window openInWorldExtent: 380@220! !!ApplescriptError class methodsFor: 'as yet unclassified' stamp: 'acg 9/26/1999 01:29'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	<primitive: 19> "Simulation guard"	World ifNotNil:		[self buildMorphicViewOn: aSyntaxError.		Project current spawnNewProcessIfNeeded.		^ Processor activeProcess suspend].	topView _ self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor activeProcess suspend.! !!ApplescriptError class methodsFor: 'as yet unclassified' stamp: 'acg 9/26/1999 01:38'!syntaxErrorFor: aString withComponent: anApplescriptInstance	|range |	range _ anApplescriptInstance lastErrorCodeRange.	self open:		(super new 			code: aString 			errorMessage: anApplescriptInstance lastErrorString			from: range first			to: range last)! !!CompiledApplescript commentStamp: '<historical>' prior: 0!I represent a stored persistent representation of a compiled Applescript.  Ultimately, Squeak interfaces should endeavor to coerce Applescript information to me in one form or the other as soon as possible, as I require no special treatment with respect to memory management.  I *WILL*, however, retain state information between executions of applescripts if I was compiled using modes with bits 2 or 3 set.I am generally kept as an internal value inside of Applescript or Context objects.  To operate on my instances, they are first generally converted to an AEDesc of type 'scpt', and then "loaded" into an Applescript scripting component (represented by an OSAID handle).  The OSAID is used to "work on" the instance.  If changed state information is desired, the modified OSAID must be "stored" from Applescript back to an AEDesc, and then ultimately converted back into another persistent CompiledScript, which can then replace the first instance.!!CompiledApplescript reorganize!('accessing' source sourceWith:)('processing' value valueIn: valueWith:in:mode:)('converting' asAEDesc asOSAIDWith:)('intermediate actions' loadWith: loadWith:mode:)('printing' printOn:)!!CompiledApplescript methodsFor: 'accessing' stamp: 'acg 9/26/1999 22:19'!source	^self sourceWith: Applescript generic! !!CompiledApplescript methodsFor: 'accessing' stamp: 'acg 9/26/1999 22:18'!sourceWith: anApplescriptInstance	| theOSAID theSource|	(theOSAID _ self asOSAIDWith: anApplescriptInstance) ifNil: [^''].	theSource _ anApplescriptInstance sourceOfOSAID: theOSAID.	theOSAID disposeWith: anApplescriptInstance.	^theSource ifNil: [^''].! !!CompiledApplescript methodsFor: 'processing' stamp: 'acg 9/25/1999 23:27'!value	^self valueWith: Applescript generic in: (OSAID new) mode: 0! !!CompiledApplescript methodsFor: 'processing' stamp: 'acg 9/25/1999 23:27'!valueIn: contextOSAID	^self valueWith: Applescript generic in: contextOSAID mode: 0! !!CompiledApplescript methodsFor: 'processing' stamp: 'acg 9/22/1999 08:51'!valueWith: anApplescriptInstance in: contextOSAID mode: anInteger	^anApplescriptInstance 		doCompiledScript: self 		in: contextOSAID 		mode: anInteger! !!CompiledApplescript methodsFor: 'converting' stamp: 'acg 9/22/1999 08:07'!asAEDesc	^AEDesc scptTypeOn: self! !!CompiledApplescript methodsFor: 'converting' stamp: 'acg 9/26/1999 18:33'!asOSAIDWith: anApplescriptInstance	^self asAEDesc asOSAIDThenDisposeAEDescWith: anApplescriptInstance! !!CompiledApplescript methodsFor: 'intermediate actions' stamp: 'acg 9/26/1999 01:06'!loadWith: anApplescriptInstance	^self loadWith: anApplescriptInstance mode: 0! !!CompiledApplescript methodsFor: 'intermediate actions' stamp: 'acg 9/26/1999 01:05'!loadWith: anApplescriptInstance mode: anInteger	^anApplescriptInstance loadAndDisposeAEDesc: (self asAEDesc) mode: anInteger! !!CompiledApplescript methodsFor: 'printing' stamp: 'acg 9/24/1999 00:37'!printOn: aStream	aStream 			nextPutAll: 'a CompiledApplescript (';			nextPutAll: self size asString;			nextPutAll: ' bytes)'! !!ExternalData commentStamp: '<historical>' prior: 0!I am a collection of word-aligned external data.  My instances are very helpful for interacting with plugin routines.!!ExternalData methodsFor: 'accessing' stamp: 'acg 9/23/1999 20:54'!shortAt: anInteger	| loc offset |	loc _ ((anInteger-1) // 2) + 1.	offset _ 32 - (16*((anInteger-1) \\ 2)).	^ ((self at: loc) >> offset) bitAnd: 16rFFFF! !!AEDesc commentStamp: '<historical>' prior: 0!I represent an Apple Event Descriptor.  I am a low-level representation of Apple Event (and hence Applescript) information.  For further Information, see Apple's Inside Macintosh: Interapplication Communications, at	http://developer.apple.com/techpubs/mac/IAC/IAC-2.html.Essentially, I represent a record comprising a one-word "string" (treating the word as fourbyte characters) representing a data type, followed by a pointer to a pointer (a handle) to the data I represent.  Care must be taken to assure that the Handle data is disposed after use, or memory leaks result.  At this time, I make no effort to do this automatically through finalization.!]style[(218 54 384)f1,f1Rhttp://developer.apple.com/techpubs/mac/IAC/IAC-2.html;,f1!!AEDesc reorganize!('accessing' dataSize dispose)('converting' asCompiledApplescript asCompiledApplescriptThenDispose asOSAIDThenDisposeAEDescWith: asShort asShortThenDispose asString asStringThenDispose to:)('private' createFromScpt: createFromText: createNull primAECoerceDesc:to: primAECreateDesc:from: primAEDescToString: primAEDisposeDesc primAEGetKeyPtr:type:actual:to:)!!AEDesc methodsFor: 'converting' stamp: 'acg 9/24/1999 00:35'!asCompiledApplescript	| theSize |	((self at: 1) ~= 16r73637074) ifTrue:		[^self error: 'AEDesc is not of type ''scpt'''].	(theSize _ self dataSize) < 0 ifTrue: [^self error: 'Invalid size for data'].	^self primAEDescToString: (CompiledApplescript new: theSize).! !!AEDesc methodsFor: 'converting' stamp: 'acg 9/24/1999 00:31'!asCompiledApplescriptThenDispose	| CAD |	CAD _ self asCompiledApplescript.	self dispose.	^CAD! !!AEDesc methodsFor: 'converting' stamp: 'acg 9/26/1999 18:39'!asOSAIDThenDisposeAEDescWith: aComponent	^aComponent loadAndDisposeAEDesc: self mode: 0! !!AEDesc methodsFor: 'converting' stamp: 'acg 9/23/1999 23:46'!asShort	^(self primAEDescToString: (ByteArray new: 2))		shortAt: 1 bigEndian: true! !!AEDesc methodsFor: 'converting' stamp: 'acg 9/23/1999 23:47'!asShortThenDispose	| short |	short _ self asShort.	self dispose.	^short! !!AEDesc methodsFor: 'converting' stamp: 'acg 9/26/1999 01:15'!to: aString	| newAEDesc result |	newAEDesc _ AEDesc new.	result _ self primAECoerceDesc: (DescType of: aString) to: newAEDesc.	result isZero ifFalse: [^result].	self dispose.	self at: 1 put: (newAEDesc at: 1).	self at: 2 put: (newAEDesc at: 2).	^0! !!AEDesc methodsFor: 'private' stamp: 'acg 9/24/1999 00:38'!createFromScpt: aCompiledApplescriptData	(aCompiledApplescriptData class = CompiledApplescript) ifFalse:		[^self error: 'textType Data Not From CompiledApplescriptData'].	(self 		primAECreateDesc: (DescType of: 'scpt')		from: aCompiledApplescriptData) isZero ifTrue: [^self].	self error: 'failed to create aeDesc'.	^nil! !!AEDesc methodsFor: 'private' stamp: 'acg 9/25/1999 22:54'!createNull	(self 		primAECreateDesc: (DescType of: 'null')		from: '') isZero ifTrue: [^self].	self error: 'failed to create aeDesc'.	^nil! !!AEDesc methodsFor: 'private' stamp: 'acg 9/23/1999 22:51'!primAECoerceDesc: typeCode to: result	<primitive: 'primAECoerceDesc' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primAECoerceDesc:to:'		withArguments: {typeCode. result}! !!AEDesc methodsFor: 'private' stamp: 'acg 9/23/1999 21:13'!primAEDescToString: aString	<primitive: 'primAEDescToString' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primAEDescToString:'		withArguments: {aString}! !!AEDesc methodsFor: 'private' stamp: 'acg 9/23/1999 22:20'!primAEGetKeyPtr: keyDesc type: typeDesc actual: ignoreDesc to: aByteArray	<primitive: 'primAEGetKeyPtr' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primAEGetKeyPtr:type:actual:to:'		withArguments: {keyDesc. typeDesc. ignoreDesc. aByteArray}! !!ComponentInstance commentStamp: '<historical>' prior: 0!I am an ExternalData representation of a MacOS Scripting Component.  I am typically subclassed to generate the relevant scripting component, for example, by ApplescriptInstance.!!ApplescriptInstance commentStamp: '<historical>' prior: 0!I represent an Applescript Scripting Component, derived from the Component Manager.  For more information about Scripting Components, see Inside Macintosh: Interapplication Communications, at:	http://developer.apple.com/techpubs/mac/IAC/IAC-2.html.Essentially, I represent a record comprising a one-word handle to the scripting component. That handle is passed as a matter of course to almost every important Applescript call.  Accordingly, I am also the repository for most of the primitives for the Applescript/Squeak interface.!]style[(195 54 285)f1,f1Rhttp://developer.apple.com/techpubs/mac/IAC/IAC-2.html;,f1!!ApplescriptInstance reorganize!('testing' hasSource: isCompiledScript: isScriptContext: isScriptValue: timesModified:)('interpreting' compile: compile:mode: do: do:in:mode: doCompiledScript:in:mode: doScript: doScript:in:mode: scriptingName sourceOfOSAID: valueOf:in:mode:)('error handling' lastBriefErrorString lastError lastErrorCodeRange lastErrorNumber lastErrorString)('intermediate operations' compileAndDisposeAEDesc:mode: displayAndDisposeOSAID:as:mode: executeAndDisplayOSAID:in:mode: executeAndDisposeOSAID:in:mode: executeOSAID:in:mode: loadAndDisposeAEDesc:mode: makeContextAndDiposeOSAID: makeContextAndDisposeOSAID: makeContextOSAID: storeAndDisposeOSAID:type:mode: storeOSAID:type:mode:)('printing' printOn:)('private' initialize primOSACompile:mode:to: primOSADisplay:as:mode:to: primOSADispose: primOSADoScript:in:mode:resultType:to: primOSAExecute:in:mode:to: primOSAGetScriptInfo:type:to: primOSAGetSource:type:to: primOSALoad:mode:to: primOSAMakeContext:parent:to: primOSAScriptError:type:to: primOSAScriptingComponentNameTo: primOSAStore:resultType:mode:to: reopen)!!ApplescriptInstance methodsFor: 'testing' stamp: 'acg 9/26/1999 22:43'!hasSource: anOSAID	| result |	result _ IntegerArray new: 1.	(self 		primOSAGetScriptInfo: anOSAID 		type: (DescType of: 'gsrc')		to: result) isZero ifFalse: [^nil].	^(result at: 1) > 0! !!ApplescriptInstance methodsFor: 'testing' stamp: 'acg 9/26/1999 22:43'!isCompiledScript: anOSAID	| result |	result _ IntegerArray new: 1.	(self 		primOSAGetScriptInfo: anOSAID 		type: (DescType of: 'cscr')		to: result) isZero ifFalse: [^nil].	^(result at: 1) > 0! !!ApplescriptInstance methodsFor: 'testing' stamp: 'acg 9/26/1999 22:43'!isScriptContext: anOSAID	| result |	result _ IntegerArray new: 1.	(self 		primOSAGetScriptInfo: anOSAID 		type: (DescType of: 'cntx')		to: result) isZero ifFalse: [^nil].	^(result at: 1) > 0! !!ApplescriptInstance methodsFor: 'testing' stamp: 'acg 9/26/1999 22:43'!isScriptValue: anOSAID	| result |	result _ IntegerArray new: 1.	(self 		primOSAGetScriptInfo: anOSAID 		type: (DescType of: 'valu')		to: result) isZero ifFalse: [^nil].	^(result at: 1) > 0! !!ApplescriptInstance methodsFor: 'testing' stamp: 'acg 9/26/1999 22:42'!timesModified: anOSAID	| result |	result _ IntegerArray new: 1.	(self 		primOSAGetScriptInfo: anOSAID 		type: (DescType of: 'modi')		to: result) isZero ifFalse: [^nil].	^result at: 1! !!ApplescriptInstance methodsFor: 'interpreting' stamp: 'acg 9/23/1999 02:27'!compile: aString	^self compileScript: aString mode: 0! !!ApplescriptInstance methodsFor: 'interpreting' stamp: 'acg 9/27/1999 00:05'!compile: aString mode: anInteger	| sourceAEDesc objectOSAID objectAEDesc |	sourceAEDesc _ AEDesc textTypeOn: aString.	(objectOSAID _ self 		compileAndDisposeAEDesc: sourceAEDesc 		mode: anInteger) ifNil: [^nil].	(objectAEDesc _ self 		storeAndDisposeOSAID: objectOSAID 		type: 'scpt' 		mode: anInteger) ifNil: [^nil].	^objectAEDesc asCompiledApplescriptThenDispose! !!ApplescriptInstance methodsFor: 'interpreting' stamp: 'acg 9/27/1999 00:05'!do: aString	"Answer text result of compiling script in null context"	^self doScript: aString in: OSAID new mode: 0! !!ApplescriptInstance methodsFor: 'interpreting' stamp: 'acg 9/25/1999 14:14'!do: aString in: contextOSAID mode: anInteger	"Answer text result of executing Applescript aString in context contexOSAID in mode: anInteger"	| source object result |	source _ AEDesc textTypeOn: aString.	object _ AEDesc new.	result _ self			primOSADoScript: source		in: contextOSAID		mode: anInteger		resultType: (DescType of: 'TEXT')		to: object.	source dispose.	result isZero ifFalse: [^nil].	^object asStringThenDispose! !!ApplescriptInstance methodsFor: 'interpreting' stamp: 'acg 9/25/1999 14:14'!doCompiledScript: aCompiledApplescriptData in: contextOSAID mode: anInteger	"Answer text result of executing Applescript aString in context contexOSAID in mode: anInteger"	^self valueOf: aCompiledApplescriptData in: contextOSAID mode: anInteger! !!ApplescriptInstance methodsFor: 'interpreting' stamp: 'acg 9/25/1999 14:14'!doScript: aString	"Answer text result of compiling script in null context"	^self do: aString! !!ApplescriptInstance methodsFor: 'interpreting' stamp: 'acg 9/25/1999 14:15'!doScript: aString in: contextOSAID mode: anInteger	"Answer text result of executing Applescript aString in context contexOSAID in mode: anInteger"	^self do: aString in: contextOSAID mode: anInteger! !!ApplescriptInstance methodsFor: 'interpreting' stamp: 'acg 9/27/1999 00:06'!scriptingName"Answer the name of my generic scripting component"	|aeDesc result |	aeDesc _ AEDesc new.	result _ self primOSAScriptingComponentNameTo: aeDesc.	result isZero ifFalse: [^nil].	^aeDesc asStringThenDispose.! !!ApplescriptInstance methodsFor: 'interpreting' stamp: 'acg 9/26/1999 21:08'!sourceOfOSAID: anOSAID	| anAEDesc result |	anAEDesc _ AEDesc new.	result _ self primOSAGetSource: anOSAID type: 'TEXT' to: anAEDesc.	anOSAID disposeWith: self.	result isZero ifFalse: [^''].	^anAEDesc asStringThenDispose		! !!ApplescriptInstance methodsFor: 'interpreting' stamp: 'acg 9/25/1999 21:53'!valueOf: aCompiledApplescript in: contextOSAID mode: anInteger	"Answer text result of executing Applescript aString in context contexOSAID in mode: anInteger"	| sourceAEDesc sourceOSAID objectOSAID objectAEDesc |	sourceAEDesc _ AEDesc scptTypeOn: aCompiledApplescript.	sourceOSAID _ self 		loadAndDispose: sourceAEDesc 		mode: anInteger.	sourceOSAID ifNil: [^nil].	objectOSAID _ self 		executeAndDispose: sourceOSAID		in: contextOSAID		mode: anInteger.	objectOSAID ifNil: [^nil].	objectAEDesc _ self		displayAndDispose: objectOSAID		as: 'TEXT'		mode: anInteger.	objectAEDesc ifNil: [^nil].	^objectAEDesc asStringThenDispose! !!ApplescriptInstance methodsFor: 'error handling' stamp: 'acg 9/25/1999 23:27'!lastBriefErrorString	"Answer the brief error message for the last error"	| aeDesc |	aeDesc _ AEDesc new.	Applescript generic		primOSAScriptError: (DescType of: 'errb')		type: (DescType of: 'TEXT')		to: aeDesc.	^aeDesc asStringThenDispose! !!ApplescriptInstance methodsFor: 'error handling' stamp: 'acg 9/24/1999 00:06'!lastError	|range|	range _ self lastErrorCodeRange.	^String streamContents: [:aStream |		aStream			nextPutAll: 'Error #';			nextPutAll: self lastErrorNumber asString;			nextPutAll: ': ';			nextPutAll: self lastErrorString;			nextPutAll: ' (code ';			nextPutAll: range first asString;			nextPutAll: ' to ';			nextPutAll: range last asString;			nextPutAll: ').']! !!ApplescriptInstance methodsFor: 'error handling' stamp: 'acg 9/25/1999 23:27'!lastErrorCodeRange	"Answer the brief error message for the last error"	| aeDesc recordDesc data from to |	aeDesc _ AEDesc new.	recordDesc _ AEDesc new.	Applescript generic		primOSAScriptError: (DescType of: 'erng')		type: (DescType of: 'erng')		to: aeDesc.	aeDesc		primAECoerceDesc: (DescType of: 'reco')		to: recordDesc.	aeDesc dispose.	data _ ByteArray new: 2.	recordDesc		primAEGetKeyPtr: (DescType of: 'srcs') 		type: (DescType of: 'shor')		actual: (DescType of: 'shor')		to: data.	from _ data shortAt: 1 bigEndian: true.	recordDesc		primAEGetKeyPtr: (DescType of: 'srce') 		type: (DescType of: 'shor')		actual: (DescType of: 'shor')		to: data.	to _ data shortAt: 1 bigEndian: true.	recordDesc dispose.	^ (from + 1) to: (to + 1)! !!ApplescriptInstance methodsFor: 'error handling' stamp: 'acg 9/25/1999 23:27'!lastErrorNumber	"Answer the error code number of the last error"	| aeDesc |	aeDesc _ AEDesc new.	Applescript generic 		primOSAScriptError: (DescType of: 'errn')		type: (DescType of: 'shor')		to: aeDesc.	^aeDesc asShortThenDispose! !!ApplescriptInstance methodsFor: 'error handling' stamp: 'acg 9/25/1999 23:27'!lastErrorString	"Answer the error message for the last error"	| aeDesc |	aeDesc _ AEDesc new.	Applescript generic		primOSAScriptError: (DescType of: 'errs')		type: (DescType of: 'TEXT')		to: aeDesc.	^aeDesc asStringThenDispose! !!ApplescriptInstance methodsFor: 'intermediate operations' stamp: 'acg 9/25/1999 13:55'!compileAndDisposeAEDesc: sourceAEDesc mode: anInteger	| objectOSAID result |	objectOSAID _ OSAID new.	result _ self			primOSACompile: sourceAEDesc		mode: anInteger		to: objectOSAID.	sourceAEDesc dispose.	result isZero ifFalse: [^nil].	^objectOSAID! !!ApplescriptInstance methodsFor: 'intermediate operations' stamp: 'acg 9/26/1999 00:14'!displayAndDisposeOSAID: anOSAID as: aString mode: anInteger	| anAEDesc result |	anOSAID isEmpty ifTrue: [^AEDesc textTypeOn: ''].	anAEDesc _ AEDesc new.	result _ self 		primOSADisplay: anOSAID 		as: (DescType of: aString)		mode: anInteger 		to: anAEDesc.	anOSAID disposeWith: self.	result isZero ifFalse: 		[^nil].	^anAEDesc! !!ApplescriptInstance methodsFor: 'intermediate operations' stamp: 'acg 9/26/1999 20:29'!executeAndDisplayOSAID: anOSAID in: contextOSAID mode: anInteger	| resultOSAID resultAEDesc |	resultOSAID _ (self executeOSAID: anOSAID in: contextOSAID mode: anInteger)		ifNil: [^nil].	resultAEDesc _ (self displayAndDisposeOSAID: resultOSAID as: 'TEXT' mode: anInteger)		ifNil: [^nil].	^resultAEDesc asStringThenDispose  ! !!ApplescriptInstance methodsFor: 'intermediate operations' stamp: 'acg 9/25/1999 09:57'!executeAndDisposeOSAID: sourceOSAID in: contextOSAID mode: anInteger	| objectOSAID result |	objectOSAID _ OSAID new.	result _ self 		primOSAExecute: sourceOSAID 		in: contextOSAID		mode: anInteger 		to: objectOSAID.	sourceOSAID disposeWith: self.	result isZero ifFalse: 		[^nil].	^objectOSAID! !!ApplescriptInstance methodsFor: 'intermediate operations' stamp: 'acg 9/26/1999 00:03'!executeOSAID: sourceOSAID in: contextOSAID mode: anInteger	| objectOSAID result |	objectOSAID _ OSAID new.	result _ self 		primOSAExecute: sourceOSAID 		in: contextOSAID		mode: anInteger 		to: objectOSAID.	result isZero ifFalse: [^nil].	^objectOSAID! !!ApplescriptInstance methodsFor: 'intermediate operations' stamp: 'acg 9/25/1999 09:57'!loadAndDisposeAEDesc: anAEDesc mode: anInteger	| anOSAID result |	anOSAID _ OSAID new.	result _ self primOSALoad: anAEDesc mode: anInteger to: anOSAID.	anAEDesc dispose.	result isZero ifFalse: [^nil].	^anOSAID! !!ApplescriptInstance methodsFor: 'intermediate operations' stamp: 'acg 9/26/1999 02:59'!makeContextAndDiposeOSAID: anOSAID		| result contextOSAID contextAEDesc |	contextOSAID _ OSAID new.	result _ self 		primOSAMakeContext: (AEDesc nullType)		parent: anOSAID		to: contextOSAID.	anOSAID dispose.	result isZero ifFalse: [^nil].	contextAEDesc _ self storeAndDisposeOSAID: contextOSAID type: 'scpt' mode: 0.	contextAEDesc ifNil: [^nil].	^ contextAEDesc asCompiledApplescriptThenDispose! !!ApplescriptInstance methodsFor: 'intermediate operations' stamp: 'acg 9/26/1999 02:49'!makeContextAndDisposeOSAID: anOSAID		| result contextAEDesc |	contextAEDesc _ AEDesc new.	result _ self 		primOSAMakeContext: (AEDesc nullType)		parent: anOSAID		to: contextAEDesc.	result isZero ifFalse: [^nil].	anOSAID disposeWith: self.	^ contextAEDesc asCompiledApplescriptThenDispose! !!ApplescriptInstance methodsFor: 'intermediate operations' stamp: 'acg 9/26/1999 02:58'!makeContextOSAID: anOSAID		| result contextOSAID contextAEDesc |	contextOSAID _ OSAID new.	result _ self 		primOSAMakeContext: (AEDesc nullType)		parent: anOSAID		to: contextOSAID.	result isZero ifFalse: [^nil].	contextAEDesc _ self storeAndDisposeOSAID: contextOSAID type: 'scpt' mode: 0.	contextAEDesc ifNil: [^nil].	^ contextAEDesc asCompiledApplescriptThenDispose! !!ApplescriptInstance methodsFor: 'intermediate operations' stamp: 'acg 9/25/1999 14:17'!storeAndDisposeOSAID: anOSAID type: aString mode: anInteger	| theAEDesc result |	theAEDesc _ AEDesc new.	result _ self			primOSAStore: anOSAID 		resultType: (DescType of: aString) 		mode: 0  to: (theAEDesc).	anOSAID disposeWith: self.	result isZero ifFalse: [^nil].	^theAEDesc! !!ApplescriptInstance methodsFor: 'intermediate operations' stamp: 'acg 9/25/1999 16:41'!storeOSAID: anOSAID type: aString mode: anInteger	| theAEDesc result |	theAEDesc _ AEDesc new.	result _ self			primOSAStore: anOSAID 		resultType: (DescType of: aString) 		mode: 0  to: (theAEDesc).	result isZero ifFalse: [^nil].	^theAEDesc! !!ApplescriptInstance methodsFor: 'printing' stamp: 'acg 9/26/1999 00:52'!printOn: aStream	aStream 		nextPutAll: 'an ';		nextPutAll: self species asString;		nextPutAll: '(';		nextPutAll: self scriptingName;		nextPutAll: ')'! !!ApplescriptInstance methodsFor: 'private' stamp: 'acg 9/22/1999 03:14'!primOSACompile: anAEDesc mode: anInteger to: anOSAID	<primitive: 'primOSACompile' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSACompile:mode:to:'		withArguments: {anAEDesc. anInteger. anOSAID}! !!ApplescriptInstance methodsFor: 'private' stamp: 'acg 9/26/1999 22:24'!primOSAGetScriptInfo: aScriptID type: aDescType to: resultData	<primitive: 'primOSAGetScriptInfo' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSAGetScriptInfo:type:to:'		withArguments: {aScriptID. aDescType. resultData}! !!ApplescriptInstance methodsFor: 'private' stamp: 'acg 9/25/1999 17:27'!primOSAGetSource: aScriptID type: aDescType to: resultData	<primitive: 'primOSAGetSource' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSAGetSource:type:to:'		withArguments: {aScriptID. aDescType. resultData}! !!ApplescriptInstance methodsFor: 'private' stamp: 'acg 9/22/1999 03:17'!primOSALoad: anAEDesc mode: anInteger to: anOSAID	<primitive: 'primOSALoad' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSALoad:mode:to:'		withArguments: {anAEDesc. anInteger. anOSAID}! !!ApplescriptInstance methodsFor: 'private' stamp: 'acg 9/25/1999 22:56'!primOSAMakeContext: name parent: parent to: result	<primitive: 'primOSAMakeContext' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSAMakeContext:parent:to:'		withArguments: {name. parent. result}! !!ApplescriptInstance methodsFor: 'private' stamp: 'acg 9/23/1999 20:43'!primOSAScriptError: anOSType type: aDescType to: anAEDesc	<primitive: 'primOSAScriptError' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSAScriptError:type:to:'		withArguments: {anOSType. aDescType. anAEDesc}! !!ApplescriptInstance methodsFor: 'private' stamp: 'acg 9/22/1999 04:22'!primOSAStore: a resultType: b mode: c to: d	<primitive: 'primOSAStore' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSAStore:resultType:mode:to:'		withArguments: {a. b. c. d}! !!DescType commentStamp: '<historical>' prior: 0!I am an ExternalData representation of a MacOS DescType or OSID!!DescType reorganize!('printing' printOn:)!!ExternalData class methodsFor: 'as yet unclassified' stamp: 'acg 9/25/1999 14:55'!ccgDeclareCForVar: aSymbolOrString	^self asString, ' *', aSymbolOrString! !!AEDesc class methodsFor: 'as yet unclassified' stamp: 'acg 9/25/1999 22:53'!nullType	^self new createNull! !!AEDesc class methodsFor: 'as yet unclassified' stamp: 'acg 9/22/1999 08:05'!scptTypeOn: aCompiledApplescriptData	^(self new) createFromScpt: aCompiledApplescriptData		! !!IntegerArray class methodsFor: 'plugin generation' stamp: 'acg 9/25/1999 15:00'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asIntPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isWords')! !!OSAID commentStamp: '<historical>' prior: 0!I am an ExternalData representation of an OSAID handle.  OSAIDs are low-level representations of Applescript information stored in an active scripting component.  For further Information, see Apple's Inside Macintosh: Interapplication Communications, at	http://developer.apple.com/techpubs/mac/IAC/IAC-2.html.Essentially, I represent a record comprising a one-word handle for manipulation by the scripting component.  Virtually all operations are done on objects with OSAID forms.  Accordingly, text and compiled script information is reduced to AEDesc objects, and then processed into or from OSAID form for later manipulation.  The OSAID can then be "coerced" back into text or compiled script information, typically indirectly through AEDesc Objects. !]style[(256 54 448)f1,f1Rhttp://developer.apple.com/techpubs/mac/IAC/IAC-2.html;,f1!!OSAID reorganize!('interpretation' doIt doItWith:in:mode: isEmpty)('conversions' asAEDescWith: asCompiledApplescriptWith:)('creation/release' dispose disposeWith:)('private' initialize)!!OSAID methodsFor: 'interpretation' stamp: 'acg 9/26/1999 02:14'!doIt	^self doItWith: Applescript generic in: (OSAID new) mode: 0! !!OSAID methodsFor: 'interpretation' stamp: 'acg 9/26/1999 02:14'!doItWith: anApplescriptInstance in: aContext mode: anInteger	| resultID displayResult |	resultID _ anApplescriptInstance executeOSAID: self in: aContext mode: anInteger.	resultID ifNil: [^nil].	displayResult _ anApplescriptInstance 		displayAndDisposeOSAID: resultID 		as: 'TEXT' 		mode: anInteger.	displayResult ifNil: [^nil].	^displayResult asStringThenDispose! !!OSAID methodsFor: 'interpretation' stamp: 'acg 9/22/1999 09:16'!isEmpty	^(self at: 1) isZero! !!OSAID methodsFor: 'conversions' stamp: 'acg 9/26/1999 18:26'!asAEDescWith: anApplescriptInstance	^anApplescriptInstance storeOSAID: self type: 'scpt' mode: 0	! !!OSAID methodsFor: 'conversions' stamp: 'acg 9/26/1999 18:27'!asCompiledApplescriptWith: anApplescriptInstance	| anAEDesc |	anAEDesc _ self asAEDescWith: anApplescriptInstance.	anAEDesc ifNil: [^nil].	^anAEDesc asCompiledApplescriptThenDispose	! !!OSAID methodsFor: 'creation/release' stamp: 'acg 9/26/1999 00:28'!dispose	^self disposeWith: Applescript generic! !!OSAID methodsFor: 'creation/release' stamp: 'acg 9/22/1999 08:34'!disposeWith: aComponent	| result |	(0 = (self at: 1)) ifTrue:		[self error: 'cannot dispose unallocated OSAID'].	result _ aComponent primOSADispose: self.	result isZero ifFalse: 		[self error: 'dispose operation failed'].	self at: 1 put: 0.	^nil! !!TestOSAPlugin commentStamp: '<historical>' prior: 0!I am the Plugin for the Squeak/Applescript Interface.A new 'TestOSAPlugin.c' file can be created by executing the following doIt:	TestOSAPlugin translateThe support header files necessary for compiling the plugin can be generated by excecuting the following doIt:	InterpreterSupportCode writePluginSupportFiles!!TestOSAPlugin reorganize!('Gen''l Mac OS prims' primGetHandleSize:)('AppleEvents prims' primAECoerceDesc:to: primAECreateDesc:from: primAEDescToString: primAEDisposeDesc primAEGetKeyPtr:type:actual:to:)('Component Mgr prims' primOpenDefaultConfiguration:subtype:)('OSA prims' primOSACompile:mode:to: primOSADisplay:as:mode:to: primOSADispose: primOSADoScript:in:mode:resultType:to: primOSAExecute:in:mode:to: primOSAGetScriptInfo:type:to: primOSAGetSource:type:to: primOSALoad:mode:to: primOSAMakeContext:parent:to: primOSAScriptError:type:to: primOSAScriptingComponentNameTo: primOSAStore:resultType:mode:to:)!!TestOSAPlugin methodsFor: 'AppleEvents prims' stamp: 'acg 9/23/1999 22:49'!primAECoerceDesc: typeCode to: result	|rcvr |	rcvr _ self 	primitive: 	'primAECoerceDesc'				parameters:	#(DescType AEDesc)				receiver:	#AEDesc.	^(self 		cCode: 'AECoerceDesc(rcvr,*typeCode,result)'		inSmalltalk: [[rcvr]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'AppleEvents prims' stamp: 'acg 9/23/1999 22:37'!primAEGetKeyPtr: key type: type actual: ignoreDesc to: bytes	| rcvr size ignoreSize |	self var: #ignoreSize declareC: 'Size ignoreSize'.	rcvr _ self	primitive: 	'primAEGetKeyPtr'				parameters: #(DescType DescType DescType ByteArray)				receiver: #AEDesc.	size _ ignoreSize _ bytes size.	^(self cCode: 'AEGetKeyPtr(rcvr, *key, *type, ignoreDesc, bytes, size, &ignoreSize)'		 inSmalltalk: [[rcvr. size. ignoreSize]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'OSA prims' stamp: 'acg 9/25/1999 15:01'!primOSAGetScriptInfo: aScriptID type: aDescType to: resultData	|component|	component _ self	primitive: 	'primOSAGetScriptInfo'						parameters: #(OSAID DescType IntegerArray)						receiver:	#ComponentInstance.		^(self cCode: 'OSAGetScriptInfo(*component,*aScriptID,*aDescType, (long *)resultData)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'OSA prims' stamp: 'acg 9/25/1999 17:25'!primOSAGetSource: aScriptID type: aDescType to: resultData	|component|	component _ self	primitive: 	'primOSAGetSource'						parameters: #(OSAID DescType AEDesc)						receiver:	#ComponentInstance.		^(self cCode: 'OSAGetSource(*component,*aScriptID,*aDescType, resultData)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'OSA prims' stamp: 'acg 9/22/1999 03:08'!primOSALoad: source mode: mode to: result	|component|	component _ self primitive: 	'primOSALoad'					parameters: #(AEDesc SmallInteger OSAID)					receiver:	#ComponentInstance.	^(self cCode: 'OSALoad(*component,source,mode,result)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'OSA prims' stamp: 'acg 9/25/1999 22:55'!primOSAMakeContext: name parent: parent to: result	|component|	component _ self primitive: 	#primOSAMakeContext					parameters: #(AEDesc OSAID OSAID)					receiver:	#ComponentInstance.	^(self cCode: 'OSAMakeContext(*component,name,*parent,result)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'OSA prims' stamp: 'acg 9/23/1999 20:39'!primOSAScriptError: selector type: type to: result	|component|	component _ self primitive: 	'primOSAScriptError'					parameters: #(DescType DescType AEDesc)					receiver:	#ComponentInstance.	^(self cCode: 'OSAScriptError(*component,*selector,*type,result)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'OSA prims' stamp: 'acg 9/22/1999 07:51'!primOSAStore: source resultType: type mode: mode to: result	|component|	component _ self primitive: 	#primOSAStore					parameters: #(OSAID DescType SmallInteger AEDesc)					receiver:	#ComponentInstance.	^(self cCode: 'OSAStore(*component,*source,*type,mode,result)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !Applescript initialize!Applescript class removeSelector: #doScript:!"Postscript:Initialize Applescript after installing the plugin"!