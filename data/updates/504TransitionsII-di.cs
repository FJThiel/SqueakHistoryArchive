'From Squeak 2.3 beta of Nov 25, 1998 on 22 December 1998 at 2:49:21 pm'!"Change Set:		TransitionsIIDate:			22 December 1998Author:			Dan IngallsA first set of follow-up tweaks to TransitionMorphs.  Makes transitions non-invasive to bookmorph structure.  Instead a transition is now an evanescent morph in the world that lies directly over the page that is about to change.  Performance is generally better, although some cases still require attention."!!BookMorph methodsFor: 'navigation' stamp: 'di 12/22/1998 13:28'!goToPage: pageNumber transitionSpec: transitionSpec	| pageIndex  aWorld oldPageNumber ascending newPage tSpec |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	tSpec _ transitionSpec ifNil:  "If transition not specified by requestor..."		[newPage valueOfProperty: #transitionSpec  " ... then consult new page"			ifAbsent: [self transitionSpecFor: self  " ... otherwise this is the default"]].	oldPageNumber _ pages indexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue: [nil]			ifFalse: [oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	self currentPage ~~ nil		ifTrue:		[(((pages at: pageIndex) owner isKindOf: TransitionMorph)			and: [(pages at: pageIndex) isInWorld])			ifTrue: [^ self  "In the process of a prior pageTurn"].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		ascending ifNotNil:			["Show appropriate page transition and start new page when done"			currentPage stopStepping.			^ (TransitionMorph					effect: tSpec second					direction: tSpec third					inverse: ascending not)				showTransitionFrom: currentPage				to: (pages at: pageIndex)				in: self				whenStart: [self playPageFlipSound: tSpec first]				whenDone:					[currentPage delete; fullReleaseCachedState.					self addMorphBack: (currentPage _ pages at: pageIndex).					self snapToEdgeIfAppropriate.					aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].					self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].					(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld]]].		"No transition, but at least decommission current page"		currentPage delete; fullReleaseCachedState].	self addMorphBack: (currentPage _ pages at: pageIndex).	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld].! !!BookMorph methodsFor: 'menu' stamp: 'di 12/22/1998 14:21'!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu addLine.	subMenu add: 'set page sound for all' action: #menuPageSoundForAll:.	subMenu add: 'set page visual for all' action: #menuPageVisualForAll:.	subMenu add: 'set sound for this page' action: #menuPageSoundForThisPage:.	subMenu add: 'set visual for this page' action: #menuPageVisualForThisPage:.	subMenu addLine.	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	subMenu add: 'send other pages to server' action: #savePagesOnURL.	aMenu add: 'book...' subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'di 12/22/1998 14:21'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu hand |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addList:	#(			('sort pages'				sortPages)			('make bookmark'		bookmarkForThisPage)			('make thumbnail'		thumbnailForThisPage)			('remove control panel'	hidePageControls)		).	aMenu addLine.	aMenu add: 'set page sound for all' action: #menuPageSoundForAll:.	aMenu add: 'set page visual for all' action: #menuPageVisualForAll:.	aMenu add: 'set sound for this page' action: #menuPageSoundForThisPage:.	aMenu add: 'set visual for this page' action: #menuPageVisualForThisPage:.	aMenu addLine.	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	aMenu add: 'send all pages to server' action: #savePagesOnURL.	aMenu add: 'send this page to server' action: #saveOneOnURL.	aMenu add: 'reload all from server' action: #reload.	aMenu add: 'keep in one file' action: #keepTogether.	hand _ self world primaryHand.	aMenu popUpAt: hand position forHand: hand."	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel]."! !!MenuMorph methodsFor: 'control' stamp: 'di 12/22/1998 14:26'!popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta tryToPlace selectedOffset |	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | each == lastSelection]							ifNone: [self items first].	self fullBounds.  "ensure layout is current"	selectedOffset := selectedItem position - self position.	tryToPlace :=		[ :where :mustFit |		self position: where - selectedOffset.		delta _ self fullBoundsInWorld amountToTranslateWithin: hand worldBounds.		(delta x = 0 or: [mustFit]) ifTrue:			[delta = (0@0) ifFalse: [self position: self position + delta].			sourceItem owner owner addMorphFront: self.			^ self]].	tryToPlace 		value: rightOrLeftPoint first value: false;		value: rightOrLeftPoint last  - (self width @ 0) value: false;		value: rightOrLeftPoint first value: true	! !!MenuMorph methodsFor: 'control' stamp: 'di 12/22/1998 14:27'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem i yOffset sub delta |	popUpOwner _ hand.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | each == lastSelection] ifNone: [self items first].	"Note: items may not be laid out yet (I found them all to be at 0@0),		so have to add up heights of items above the selected item."	i _ 0.  yOffset _ 0.	[(sub _ self submorphs at: (i _ i+1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2@(yOffset + 8)).	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self.	hand newMouseFocus: selectedItem.	self changed.! !!MenuMorph methodsFor: 'control' stamp: 'di 12/22/1998 14:26'!popUpAt: aPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta |	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self items detect:		 [:each | each == lastSelection] ifNone: [self items first].	self fullBounds.  "ensure layout is current"	self position: aPoint - (selectedItem position - self position).	sourceItem owner owner addMorphFront: self.	delta _ self fullBoundsInWorld amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/22/1998 12:52'!completeReplacement	self delete.	completionBlock value! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/22/1998 14:11'!initiateReplacement	| n |	startForm _ (startMorph imageFormForRectangle: bounds) offset: 0@0.	endForm _ (endMorph imageFormForRectangle: bounds) offset: 0@0.	nSteps == nil ifTrue:		[self nSteps: 15 stepTime: 16.		(#(zoom pageForward pageBack) includes: effect) ifTrue:			[n _ 20 * 100000 // self bounds area min: 20 max: 4.			self nSteps: n stepTime: 30].		(#dissolve = effect) ifTrue:			[n _ 20 * 50000 // self bounds area min: 20 max: 4.			self nSteps: n stepTime: 30]].	startBlock value.  "with forms in place there should b no further delay."	self startStepping! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/22/1998 13:32'!showTransitionFrom: startingMorph to: endingMorph in: containingMorph	whenStart: firstBlock whenDone: doneBlock	effect == #none ifTrue: [firstBlock value.  ^ doneBlock value].	self startMorph: startingMorph endMorph: endingMorph		startBlock: firstBlock completionBlock: doneBlock.	stepNumber _ 0.	self bounds: startingMorph bounds.	endingMorph privateOwner: self.  "Allows test of transition in progress"	containingMorph owner privateAddMorph: self atIndex: 		(containingMorph owner submorphs indexOf: containingMorph).	self initiateReplacement! !BookMorph removeSelector: #showPageTurningFeedbackFromOrigin:ascending:!TransitionMorph removeSelector: #replace:by:whenStart:whenDone:!TransitionMorph removeSelector: #imageForm!TransitionMorph removeSelector: #initiateReplacement:!TransitionMorph removeSelector: #replace:andRelease:by:whenStart:whenDone:!