'From Squeak3.2alpha of 17 December 2001 [latest update: #4639] on 31 December 2001 at 1:25:19 pm'!"Change Set:		GraphicsTweaks-arDate:			31 December 2001Author:			Andreas RaabVarious changes to graphics in Morphic:* The CS cleans up most of the simple string drawing and measuring methods. Rather than using DisplayScanner's #quickPrint: variants the font is queried directly which is more obvious, more general, and even faster (drawing strings through canvases is now roughly twice as fast as before; measuring string sizes is about five times faster).* The canvas' #text:... methods have been renamed to #drawString:... to make the intent more clear. * An issue with overly optimistic clipping in Canvases has been fixed.* Methods for image warping based on some transformation have been added to canvas (the #warpImage family of methods).* An old issue with HandMorph leading to gribblies has finally been fixed.* Morph>>position: has been modified to send #layoutChanged to its owner - when a morph is moved the owner's layout needs to be recomputed."!AbstractFont subclass: #StrikeFont	instanceVariableNames: 'characterToGlyphMap xTable glyphs name type minAscii maxAscii maxWidth strikeLength ascent descent xOffset raster subscript superscript emphasis derivativeFonts pointSize '	classVariableNames: 'DefaultStringScanner '	poolDictionaries: 'TextConstants '	category: 'Graphics-Text'!!AbstractFont methodsFor: 'measuring' stamp: 'ar 12/31/2001 00:55'!widthOfString: aString	^self widthOfString: aString from: 1 to: aString size."	TextStyle default defaultFont widthOfString: 'zort' 21"! !!AbstractFont methodsFor: 'measuring' stamp: 'ar 12/31/2001 00:54'!widthOfString: aString from: startIndex to: stopIndex	"Measure the length of the given string between start and stop index"	| character resultX |	resultX _ 0.	startIndex to: stopIndex do:[:i | 		character _ aString at: i.		resultX _ resultX + (self widthOf: character)].	^resultX! !!BitBlt methodsFor: 'accessing' stamp: 'ar 12/30/2001 20:31'!clipBy: aRectangle	| aPoint right bottom |	right _ clipX + clipWidth.	bottom _ clipY + clipHeight.	aPoint _ aRectangle origin.	aPoint x > clipX ifTrue:[clipX _ aPoint x].	aPoint y > clipY ifTrue:[clipY _ aPoint y].	aPoint _ aRectangle corner.	aPoint x < right ifTrue:[right _ aPoint x].	aPoint y < bottom ifTrue:[bottom _ aPoint y].	clipWidth _ right - clipX.	clipHeight _ bottom - clipY.	clipWidth < 0 ifTrue:[clipWidth _ 0].	clipHeight < 0 ifTrue:[clipHeight _ 0].! !!BitBlt methodsFor: 'accessing' stamp: 'ar 12/30/2001 20:33'!clipByX1: x1 y1: y1 x2: x2 y2: y2	| right bottom |	right _ clipX + clipWidth.	bottom _ clipY + clipHeight.	x1 > clipX ifTrue:[clipX _ x1].	y1 > clipY ifTrue:[clipY _ y1].	x2 < right ifTrue:[right _ x2].	y2 < bottom ifTrue:[bottom _ y2].	clipWidth _ right - clipX.	clipHeight _ bottom - clipY.	clipWidth < 0 ifTrue:[clipWidth _ 0].	clipHeight < 0 ifTrue:[clipHeight _ 0].! !!CArrayAccessor methodsFor: 'accessing' stamp: 'ar 12/31/2001 01:36'!byteAt: index	^object byteAt: index + offset + 1! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 12/30/2001 15:23'!drawMorph: aMorph	self draw: aMorph! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 12/30/2001 15:23'!fullDrawMorph: aMorph	self fullDraw: aMorph! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 12/30/2001 18:47'!roundCornersOf: aMorph during: aBlock	^self roundCornersOf: aMorph in: aMorph bounds during: aBlock! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 12/30/2001 18:47'!roundCornersOf: aMorph in: bounds during: aBlock	^aBlock value! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 12/28/2001 23:44'!warpImage: aForm transform: aTransform	"Warp the given form using aTransform"	^self warpImage: aForm transform: aTransform at: 0@0! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 12/28/2001 23:54'!warpImage: aForm transform: aTransform at: extraOffset	"Warp the given form using aTransform.	TODO: Use transform to figure out appropriate cell size"	^self warpImage: aForm transform: aTransform at: extraOffset sourceRect: aForm boundingBox cellSize: 1! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 12/29/2001 00:20'!warpImage: aForm transform: aTransform at: extraOffset sourceRect: sourceRect cellSize: cellSize	"Warp the given using the appropriate transform and offset."	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-text' stamp: 'ar 12/30/2001 20:35'!drawString: s at: pt	^ self drawString: s from: 1 to: s size at: pt font: nil color: Color black! !!Canvas methodsFor: 'drawing-text' stamp: 'ar 12/31/2001 02:25'!drawString: s at: pt font: aFont color: aColor	^ self drawString: s from: 1 to: s size at: pt font: aFont color: aColor! !!Canvas methodsFor: 'drawing-text' stamp: 'ar 12/30/2001 20:36'!drawString: s from: firstIndex to: lastIndex at: pt font: font color: aColor	self drawString: s from: firstIndex to: lastIndex in: (pt extent: 10000@10000) font: font color: aColor! !!Canvas methodsFor: 'drawing-text' stamp: 'ar 12/30/2001 20:37'!drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-text' stamp: 'ar 12/31/2001 02:39'!drawString: s in: boundsRect	^self drawString: s from: 1 to: s size in: boundsRect font: nil color: Color black! !!Canvas methodsFor: 'drawing-text' stamp: 'ar 12/31/2001 02:13'!drawString: s in: boundsRect font: fontOrNil color: c	^self drawString: s from: 1 to: s size in: boundsRect font: fontOrNil color: c! !!Canvas methodsFor: 'drawing-text' stamp: 'ar 12/31/2001 02:40'!text: s at: pt font: fontOrNil color: c	"OBSOLETE"	^ self drawString: s at: pt font: fontOrNil color: c! !!Canvas methodsFor: 'drawing-text' stamp: 'ar 12/31/2001 02:40'!text: s bounds: boundsRect font: fontOrNil color: c	"OBSOLETE"	^self drawString: s in: boundsRect font: fontOrNil color: c! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ar 12/31/2001 02:33'!drawText: command	| boundsEnc colorEnc  text bounds color fontIndexEnc fontIndex |	text := command at: 2.	boundsEnc := command at: 3.	fontIndexEnc := command at: 4.	colorEnc := command at: 5.	bounds _ self class decodeRectangle: boundsEnc.	fontIndex := self class decodeInteger: fontIndexEnc.	color _ self class decodeColor: colorEnc.	self drawCommand: [ :c |		c drawString: text in: bounds font: (fonts at: fontIndex) color: color ]! !!CanvasEncoder methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:36'!drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c	| fontIndex |	fontIndex := self establishFont: (fontOrNil ifNil: [ TextStyle defaultFont ]).	self sendCommand: {		String with: CanvasEncoder codeText.		s asString copyFrom: firstIndex to: lastIndex.		self class encodeRectangle: boundsRect.		self class encodeInteger: fontIndex.		self class encodeColor: c	}! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 12/31/2001 00:52'!measureString: aString inFont: aFont from: startIndex to: stopIndex	"WARNING: In order to use this method the receiver has to be set up using #initializeStringMeasurer"	destX _ destY _ lastIndex _ 0.	xTable _ aFont xTable.	map _ aFont characterToGlyphMap.	self scanCharactersFrom: startIndex to: stopIndex in: aString rightX: 999999 stopConditions: stopConditions kern: 0.	^destX! !!CharacterScanner methodsFor: 'initialize' stamp: 'ar 12/31/2001 00:52'!initializeStringMeasurer	stopConditions _ Array new: 258.	stopConditions at: CrossedX put: #crossedX.	stopConditions at: EndOfRun put: #endOfRun.! !!CanvasCharacterScanner methodsFor: 'scanning' stamp: 'ar 12/31/2001 02:35'!displayLine: textLine  offset: offset  leftInRun: leftInRun	|  nowLeftInRun done startLoc startIndex stopCondition |	"largely copied from DisplayScanner's routine"	line _ textLine.	foregroundColor ifNil: [ foregroundColor _ Color black ].	leftMargin _ (line leftMarginForAlignment: alignment) + offset x.	rightMargin _ line rightMargin + offset x.	lineY _ line top + offset y.	lastIndex _ textLine first.	leftInRun <= 0		ifTrue: [self setStopConditions.  "also sets the font"				nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	runX _ destX _ leftMargin.	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	done _ false.	[done] whileFalse: [		"remember where this portion of the line starts"		startLoc _ destX@destY.		startIndex _ lastIndex.		"find the end of this portion of the line"		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: text string rightX: rightMargin stopConditions: stopConditions						kern: kern "displaying: false".		"display that portion of the line"		canvas drawString: text string			from: startIndex to: lastIndex			at: startLoc			font: font			color: foregroundColor.		"handle the stop condition"		done _ self perform: stopCondition	].	^runStopIndex - lastIndex! !!ColorMappingCanvas methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:28'!drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c	"Draw the given string in the given font and color clipped to the given rectangle. If the font is nil, the default font is used."	myCanvas		drawString: s from: firstIndex to: lastIndex 		in: boundsRect 		font: fontOrNil 		color: (self mapColor: c)! !!CornerRounder methodsFor: 'all' stamp: 'ar 12/30/2001 18:44'!saveBitsUnderCornersOf: aMorph on: aCanvas in: bounds	| offset corner mask form |	underBits _ (1 to: 4) collect:		[:i | 		mask _ cornerMasks at: i.		corner _ bounds corners at: i.		i = 1 ifTrue: [offset _ 0@0].		i = 2 ifTrue: [offset _ 0@mask height negated].		i = 3 ifTrue: [offset _ mask extent negated].		i = 4 ifTrue: [offset _ mask width negated@0].		form _ aCanvas contentsOfArea: (corner + offset extent: mask extent).		form copyBits: form boundingBox from: mask at: 0@0 clippingBox: form boundingBox rule: Form and fillColor: nil map: (Bitmap with: 16rFFFFFFFF with: 0)].! !!CornerRounder methodsFor: 'all' stamp: 'ar 12/30/2001 18:44'!tweakCornersOf: aMorph on: aCanvas in: bounds borderWidth: w corners: cornerList	"This variant has a cornerList argument, to allow some corners to be rounded and others not"	| offset corner saveBits fourColors mask outBits shadowColor |	shadowColor _ aCanvas shadowColor.	aCanvas shadowColor: nil. "for tweaking it's essential"	w > 0 ifTrue:[			fourColors _ shadowColor 				ifNil:[aMorph borderStyle colorsAtCorners]				ifNotNil:[Array new: 4 withAll: shadowColor]].	mask _ Form extent: cornerMasks first extent depth: aCanvas depth.	1 to: 4 do:[:i | 		(cornerList includes: i) ifTrue:			[corner _ bounds corners at: i.			saveBits _ underBits at: i.			i = 1 ifTrue: [offset _ 0@0].			i = 2 ifTrue: [offset _ 0@saveBits height negated].			i = 3 ifTrue: [offset _ saveBits extent negated].			i = 4 ifTrue: [offset _ saveBits width negated@0].			"Mask out corner area (painting saveBits won't clear if transparent)."			mask copyBits: mask boundingBox from: (cornerMasks at: i) at: 0@0 clippingBox: mask boundingBox rule: Form over fillColor: nil map: (Bitmap with: 0 with: 16rFFFFFFFF).			outBits _ aCanvas contentsOfArea: (corner + offset extent: mask extent).			mask displayOn: outBits at: 0@0 rule: Form and.			"Paint back corner bits."			saveBits displayOn: outBits at: 0@0 rule: Form paint.			"Paint back corner bits."			aCanvas drawImage: outBits at: corner + offset.			w > 0 ifTrue:				["Paint over with border if any"				aCanvas stencil: (cornerOverlays at: i) at: corner + offset						color: (fourColors at: i)]]].	aCanvas shadowColor: shadowColor. "restore shadow color"! !!CornerRounder class methodsFor: 'all' stamp: 'ar 12/30/2001 18:45'!roundCornersOf: aMorph on: aCanvas in: bounds displayBlock: displayBlock borderWidth: w corners: aList	| rounder |	rounder _ CR0.	w = 1 ifTrue: [rounder _ CR1].	w = 2 ifTrue: [rounder _ CR2].	rounder _ rounder copy.	rounder saveBitsUnderCornersOf: aMorph on: aCanvas in: bounds.	displayBlock value.	rounder tweakCornersOf: aMorph on: aCanvas in: bounds borderWidth: w corners: aList! !!DisplayScanner methodsFor: 'MVC-compatibility' stamp: 'ar 12/31/2001 02:24'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	leftInRun _ 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment]).			destX _ (runX _ leftMargin).			line _ aParagraph lines at: lineIndex.			lineHeight _ line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex _ line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun _ text runLengthFor: line first].			destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"			runLength _ leftInRun.			runStopIndex _ lastIndex + (runLength - 1) min: line last.			leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).			spaceCount _ 0.			done _ false.			string _ text string.			self handleIndentation.			[done] whileFalse:[				startIndex _ lastIndex.				lastPos _ destX@destY.				stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern].				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].			fillBlt == nil ifFalse:				[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY _ lineY + lineHeight]]! !!DisplayScanner methodsFor: 'MVC-compatibility' stamp: 'ar 12/31/2001 02:23'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt _ BitBlt current toForm: aParagraph destinationForm.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt combinationRule: Form paint.	bitBlt colorMap:		(Bitmap with: 0      "Assumes 1-bit deep fonts"				with: (bitBlt destForm pixelValueFor: aParagraph foregroundColor)).	bitBlt clipRect: clippingRectangle.! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 12/31/2001 03:26'!contentsOfArea: aRectangle into: aForm	| bb |	self flush.	bb _ BitBlt toForm: aForm.	bb sourceForm: form; combinationRule: Form over;		sourceX: (aRectangle left + origin x); sourceY: (aRectangle top + origin y);		width: aRectangle width; height: aRectangle height;		copyBits.	^aForm! !!FormCanvas methodsFor: 'private' stamp: 'ar 12/30/2001 16:35'!privateWarp: aForm transform: aTransform at: extraOffset sourceRect: sourceRect cellSize: cellSize	"Warp the given using the appropriate transform and offset."	| globalRect sourceQuad warp tfm |	tfm _ aTransform.	globalRect _ tfm localBoundsToGlobal: sourceRect.	sourceQuad _ (tfm sourceQuadFor: globalRect) collect:[:p| p - sourceRect topLeft].	extraOffset ifNotNil:[globalRect _ globalRect translateBy: extraOffset].     warp _ (WarpBlt current toForm: port destForm)                combinationRule: Form paint;                sourceQuad: sourceQuad destRect: globalRect;                clipRect: port clipRect.	warp cellSize: cellSize.	warp sourceForm: aForm.	warp warpBits! !!FormCanvas methodsFor: 'drawing-images' stamp: 'ar 12/30/2001 16:36'!warpImage: aForm transform: aTransform at: extraOffset sourceRect: sourceRect cellSize: cellSize	"Warp the given using the appropriate transform and offset."	| tfm |	tfm _ (MatrixTransform2x3 withOffset: origin) composedWithLocal: aTransform.	^self privateWarp: aForm transform: tfm at: extraOffset sourceRect: sourceRect cellSize: cellSize! !!FormCanvas methodsFor: 'drawing-general' stamp: 'ar 12/30/2001 18:58'!roundCornersOf: aMorph in: bounds during: aBlock	aMorph wantsRoundedCorners ifFalse:[^aBlock value].	(self seesNothingOutside: (CornerRounder rectWithinCornersOf: bounds))		ifTrue: ["Don't bother with corner logic if the region is inside them"				^ aBlock value].	CornerRounder roundCornersOf: aMorph on: self in: bounds		displayBlock: aBlock		borderWidth: aMorph borderWidthForRounding		corners: aMorph roundedCorners! !!FormCanvas methodsFor: 'drawing-text' stamp: 'ar 12/31/2001 02:42'!drawString: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: c	| font |	font _ fontOrNil ifNil: [TextStyle defaultFont].	font installOn: port		foregroundColor: (self shadowColor ifNil:[c]) 		backgroundColor: Color transparent.	port combinationRule: Form paint.	font displayString: aString on: port 		from: firstIndex to: lastIndex at: (origin + aPoint) kern: 0.! !!FormCanvas methodsFor: 'drawing-text' stamp: 'ar 12/31/2001 02:42'!drawString: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: c	| font |	port clipByX1: bounds left + origin x 		y1: bounds top + origin y 		x2: bounds right + origin x 		y2: bounds bottom + origin y.	font _ fontOrNil ifNil: [TextStyle defaultFont].	font installOn: port		foregroundColor: (self shadowColor ifNil:[c]) 		backgroundColor: Color transparent.	port combinationRule: Form paint.	font displayString: aString asString on: port 		from: firstIndex to: lastIndex at: (bounds topLeft + origin) kern: 0.	port clipRect: clipRect.! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 12/31/2001 02:27'!drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c	(self ifNoTransformWithIn: boundsRect)		ifTrue:[^super drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c]! !!FormCanvas class methodsFor: 'testing' stamp: 'ar 12/31/2001 02:26'!test1	"FormCanvas test1"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color black).	canvas line: 10@10 to: 50@30 width: 1 color: (Color red).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color green).	canvas point: 100@100 color: (Color black).	canvas drawString: 'Hello, World!!' at: 40@40 font: nil color: (Color cyan).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color magenta).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color cyan).	canvas frameOval: ((40@80) corner: (61@121)) color: (Color blue).	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: (Color red alpha: 0.2).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightYellow).	canvas showAt: 0@0.! !!FormCanvas class methodsFor: 'testing' stamp: 'ar 12/31/2001 02:26'!test2	"FormCanvas test2"	| baseCanvas p |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	[Sensor anyButtonPressed] whileFalse: [		baseCanvas translateBy: (Sensor cursorPoint - p) during:[:canvas|			canvas fillColor: Color white.			canvas line: 10@10 to: 50@30 width: 1 color: Color red.			canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.			canvas point: 100@100 color: Color black.			canvas drawString: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.			canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.			canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.			canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.			canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.			canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.			canvas showAt: 0@0]].! !!FormCanvas class methodsFor: 'testing' stamp: 'ar 12/31/2001 02:25'!test3	"FormCanvas test3"	| baseCanvas |	baseCanvas _ FormCanvas extent: 200@200.	baseCanvas fillColor: Color white.	baseCanvas translateBy: 10@10 during:[:canvas|		canvas shadowColor: (Color black alpha: 0.5).		canvas line: 10@10 to: 50@30 width: 1 color: Color red.		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.		canvas point: 100@100 color: Color black.		canvas drawString: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.		canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.		canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.		canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.		canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.		canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.		canvas showAt: 0@0.	].! !!GrafPort methodsFor: 'copying' stamp: 'ar 12/30/2001 20:32'!clippedBy: aRectangle	^ self copy clipBy: aRectangle! !!InterpreterPlugin class methodsFor: 'instance creation' stamp: 'ar 12/31/2001 01:36'!doPrimitive: primitiveName 	| proxy plugin |	proxy _ InterpreterProxy new.	proxy loadStackFrom: thisContext sender.	plugin _ self simulatorClass new.	plugin setInterpreter: proxy.	(plugin respondsTo: #initialiseModule) ifTrue:[plugin initialiseModule].	plugin perform: primitiveName asSymbol.	^ proxy stackValue: 0! !!Morph methodsFor: 'drawing' stamp: 'ar 12/30/2001 19:17'!drawDropShadowOn: aCanvas	aCanvas 		translateBy: self shadowOffset 		during: [ :shadowCanvas |			shadowCanvas shadowColor: self shadowColor.			shadowCanvas roundCornersOf: self during: [ 				(shadowCanvas isVisible: self bounds) ifTrue:[shadowCanvas drawMorph: self ]]		].! !!Morph methodsFor: 'drawing' stamp: 'ar 12/30/2001 15:22'!fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"	self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:[^self].	(self hasProperty: #errorOnDraw) ifTrue:[^self drawErrorOn: aCanvas].	"Note: At some point we should generalize this into some sort of 	multi-canvas so that we can cross-optimize some drawing operations."	"Pass 1: Draw eventual drop-shadow"	self hasDropShadow ifTrue: [self drawDropShadowOn: aCanvas].	(self hasRolloverBorder and: [(aCanvas seesNothingOutside: self bounds) not])		ifTrue: [self drawRolloverBorderOn: aCanvas].	"Pass 2: Draw receiver itself"	aCanvas roundCornersOf: self during:[		(aCanvas isVisible: self bounds) ifTrue:[aCanvas drawMorph: self].		self drawSubmorphsOn: aCanvas.		self drawDropHighlightOn: aCanvas.		self drawMouseDownHighlightOn: aCanvas].! !!Morph methodsFor: 'geometry' stamp: 'ar 12/30/2001 17:40'!position: aPoint	"Change the position of this morph and and all of its submorphs."	| delta box |	delta _ aPoint - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"	box _ self fullBounds.	(delta dotProduct: delta) > 100 ifTrue:[		"e.g., more than 10 pixels moved"		self invalidRect: box.		self invalidRect: (box translateBy: delta).	] ifFalse:[		self invalidRect: (box merge: (box translateBy: delta)).	].	self privateFullMoveBy: delta.	owner ifNotNil:[owner layoutChanged].! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2001 19:14'!fullDrawOn: aCanvas	| mask |	(aCanvas isVisible: self fullBounds) ifFalse:[^self].	super fullDrawOn: aCanvas.	mask _ self valueOfProperty: #disabledMaskColor ifAbsent: [^self].	aCanvas fillRectangle: bounds color: mask.! !!BackgroundMorph methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2001 19:16'!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse:[^self].	running ifFalse: [		^aCanvas clipBy: (bounds translateBy: aCanvas origin)				during:[:clippedCanvas| super fullDrawOn: clippedCanvas]].	(aCanvas isVisible: self bounds) ifTrue:[aCanvas drawMorph: self].! !!CachingMorph methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2001 19:14'!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse:[^self].	self updateCacheCanvas: aCanvas.	aCanvas cache: self fullBounds			using: cacheCanvas form			during:[:cachingCanvas| super fullDrawOn: cachingCanvas].! !!FlashThumbnailMorph methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:35'!drawOn: aCanvas	(player == nil or:[frameNumber == nil]) ifTrue:[^super drawOn: aCanvas].false ifTrue:[super drawOn: aCanvas.			^aCanvas drawString: frameNumber printString in: self innerBounds font: nil color: Color red].	image ifNil:[		Cursor wait showWhile:[			image _ player imageFormOfSize: (self extent - (self borderWidth * 2))					 forFrame: frameNumber.			frameNumber printString displayOn: image]].	aCanvas frameRectangle: self bounds width: self borderWidth color: self borderColor.	aCanvas paintImage: image at: self topLeft + self borderWidth.! !!HandMorph methodsFor: 'geometry' stamp: 'ar 12/30/2001 17:32'!invalidRect: damageRect from: aMorph	"Note that a change has occurred and record the given damage rectangle relative to the origin this hand's cache."	hasChanged _ true.	aMorph == self ifTrue:[^self].	damageRecorder recordInvalidRect: damageRect.! !!HandMorph methodsFor: 'geometry' stamp: 'ar 12/30/2001 20:44'!userInitials: aString andPicture: aForm	| cb pictRect initRect f |	userInitials _ aString.	pictRect _ initRect _ cb _ self cursorBounds.	userInitials isEmpty ifFalse: [		f _ TextStyle defaultFont.		initRect _ cb topRight + (0@4) extent: (f widthOfString: userInitials)@(f height).	].	self userPicture: aForm.	aForm ifNotNil: [		pictRect _ (self cursorBounds topRight + (0@24)) extent: aForm extent.	].	self bounds: ((cb merge: initRect) merge: pictRect).! !!HandMorph methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:25'!drawOn: aCanvas	| userPic |	"Draw the hand itself (i.e., the cursor)."	temporaryCursor == nil		ifTrue: [aCanvas paintImage: NormalCursor at: bounds topLeft]		ifFalse: [aCanvas paintImage: temporaryCursor at: bounds topLeft].	self hasUserInformation ifTrue: [		aCanvas 			drawString: userInitials			at: (self cursorBounds topRight + (0@4))			font: nil			color: color.		(userPic _ self userPicture) ifNotNil: [			aCanvas paintImage: userPic at: (self cursorBounds topRight + (0@24))		].	].! !!HandMorph methodsFor: 'drawing' stamp: 'ar 12/30/2001 19:13'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds roundCorners rounded |	self visible ifFalse:[^self].	(aCanvas isVisible: self fullBounds) ifFalse:[^self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue:		[cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvas: aCanvas.	(cacheCanvas == nil or: [cachedCanvasHasHoles and: [cacheCanvas depth = 1]])		ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"--> begin rounded corners hack <---"	roundCorners _ (cachedCanvasHasHoles == false) and:[		submorphs size = 1 and:[submorphs first wantsRoundedCorners]].	roundCorners ifTrue:[		rounded _ submorphs first.			aCanvas asShadowDrawingCanvas				translateBy: self shadowOffset during:[:shadowCanvas|			shadowCanvas roundCornersOf: rounded during:[				(subBnds areasOutside: (rounded boundsWithinCorners translateBy: self shadowOffset negated)) do:					[:r | shadowCanvas fillRectangle: r color: Color black]]].		aCanvas roundCornersOf: rounded during:[			aCanvas drawImage: cacheCanvas form at: subBnds origin					sourceRect: cacheCanvas form boundingBox].		^self drawOn: aCanvas.  "draw the hand itself in front of morphs"].	"--> end rounded corners hack <---"	"draw the shadow"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		cachedCanvasHasHoles			ifTrue: ["Have to draw the real shadow of the form"					shadowCanvas paintImage: cacheCanvas form at: subBnds origin]			ifFalse: ["Much faster if only have to shade the edge of a solid rectangle"					(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do:						[:r | shadowCanvas fillRectangle: r color: Color black]]].	"draw morphs in front of the shadow using the cached Form"	cachedCanvasHasHoles		ifTrue: [aCanvas paintImage: cacheCanvas form at: subBnds origin]		ifFalse: [aCanvas drawImage: cacheCanvas form at: subBnds origin					sourceRect: cacheCanvas form boundingBox].	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'ar 12/30/2001 17:42'!updateCacheCanvas: aCanvas	"Update the cached image of the morphs being held by this hand."	| subBnds rectList nPix |	"Note: The following is an attempt to quickly get out if there's no change"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	rectList _ damageRecorder invalidRectsFullBounds: subBnds.	damageRecorder reset.	(rectList isEmpty and:[cacheCanvas notNil and:[cacheCanvas extent = subBnds extent]])		ifTrue:[^self].	"Always check for real translucency -- can't be cached in a form"	self submorphsDo:[:m|		m wantsToBeCachedByHand ifFalse:[			cacheCanvas _ nil.			cachedCanvasHasHoles _ true.			^ self]].	(cacheCanvas == nil or: [cacheCanvas extent ~= subBnds extent]) ifTrue: [		cacheCanvas _ (aCanvas allocateForm: subBnds extent) getCanvas.		cacheCanvas translateBy: subBnds origin negated			during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].		self submorphsDo:			[:m | (m areasRemainingToFill: subBnds) isEmpty				ifTrue: [^ cachedCanvasHasHoles _ false]].		nPix _ cacheCanvas form tallyPixelValues at: 1.		"--> begin rounded corners hack <---"		(nPix = 48 and:[submorphs size = 1 and:[submorphs first wantsRoundedCorners]])			ifTrue:[cachedCanvasHasHoles _ false]			ifFalse:[cachedCanvasHasHoles _ nPix > 0].		"--> end rounded corners hack <---"		^ self].	"incrementally update the cache canvas"	rectList do: [:r |		cacheCanvas translateTo: subBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			self drawSubmorphsOn: c]].! !!MinesTile methodsFor: 'accessing' stamp: 'ar 12/31/2001 02:38'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color *and* the inset border color are generated	from the receiver's own color, instead of having the inset border color	generated from the owner's color, as in BorderedMorph."	| font rct |	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self.].	borderColor == #raised ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color lighter lighter			bottomRightColor: color darker darker darker].	borderColor == #inset ifTrue: [		aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: 1 " borderWidth"			topLeftColor: (color darker darker darker)			bottomRightColor: color lighter.		self isMine ifTrue: [  			font  _ StrikeFont familyName: 'Atlanta' size: 22 emphasized: 1.			rct _ bounds insetBy: ((bounds width) - (font widthOfString: '*'))/2@0.			rct _ rct top: rct top + 1.			aCanvas drawString: '*' in: (rct translateBy: 1@1) font: font color: Color black.			^ aCanvas drawString: '*' in: rct font: font color: Color red .].		self nearMines > 0 ifTrue: [ 			font _ StrikeFont familyName: 'ComicBold' size: 22 emphasized: 1.			rct _ bounds insetBy: ((bounds width) - (font widthOfString: nearMines asString))/2@0.			rct _ rct top: rct top + 1.			aCanvas drawString: nearMines asString in: (rct translateBy: 1@1) font: font color: Color black.			^ aCanvas drawString: nearMines asString in: rct font: font color: ((palette at: nearMines) ) .].		^self. ].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: color		borderWidth: borderWidth		borderColor: borderColor.! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ar 12/31/2001 02:28'!drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c	self apply: [ :clippedCanvas |		clippedCanvas drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ar 12/30/2001 18:46'!roundCornersOf: aMorph in: bounds during: aBlock	aMorph wantsRoundedCorners ifFalse:[^aBlock value].	(self seesNothingOutside: (CornerRounder rectWithinCornersOf: bounds))		ifTrue: ["Don't bother with corner logic if the region is inside them"				^ aBlock value].	CornerRounder roundCornersOf: aMorph on: self in: bounds		displayBlock: aBlock		borderWidth: aMorph borderWidthForRounding		corners: aMorph roundedCorners! !!PoohTestMorph methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:38'!drawOn: aCanvas	| ptList last |	super drawOn: aCanvas.	aCanvas translateBy: bounds origin clippingTo: self innerBounds during:[:cc|		points ifNotNil:[			points class == Array 				ifTrue:[ptList _ points]				ifFalse:[ptList _ points contents].			last _ ptList last.				ptList do:[:next|					cc line: last to: next width: 5 color: (Color gray: 0.9).					last _ next]].		self drawSubdivisionTrianglesOn: cc.		self drawSubdivisionEdgesOn: cc.		self drawSubdivisionSpineOn: cc.	].	time ifNotNil:[		aCanvas drawString: time printString,' msecs' in: self innerBounds font: nil color: Color black.	].! !!PostscriptCanvas methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:36'!drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c	self setFont:(fontOrNil ifNil:[self defaultFont]).	self comment:' text color: ',c printString.	self setColor:c.	self comment:' boundsrect origin ', boundsRect origin printString.	self comment:'  origin ',  origin printString.     self moveto: (boundsRect origin ).	target print:' (';     	 print: (s asString copyFrom: firstIndex to: lastIndex) asPostscript;		print:') show';		 cr.! !!RemoteCanvas methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:29'!drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c	"Draw the given string in the given font and color clipped to the given rectangle. If the font is nil, the default font is used."	"(innerClipRect intersects: (transform transformBoundsRect: boundsRect)) ifFalse: [ ^self ]."		"clip rectangles seem to be all screwed up...."	s isAllSeparators ifTrue: [ ^self ].   "is this correct??  it sure does speed things up!!"	self drawCommand: [ :executor |		executor drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c]! !!RemoteCanvas methodsFor: 'accessing' stamp: 'ar 12/30/2001 18:47'!roundCornersOf: aMorph in: bounds during: aBlock	self flag: #roundedRudeness.		aMorph wantsRoundedCorners ifFalse:[^aBlock value].	(self seesNothingOutside: (CornerRounder rectWithinCornersOf: bounds))		ifTrue: ["Don't bother with corner logic if the region is inside them"				^ aBlock value].	CornerRounder roundCornersOf: aMorph on: self in: bounds		displayBlock: aBlock		borderWidth: aMorph borderWidthForRounding		corners: aMorph roundedCorners! !!RulerMorph methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2001 02:38'!drawOn: aCanvas	| s |	super drawOn: aCanvas.	s _ self width printString, 'x', self height printString.	aCanvas drawString: s in: (bounds insetBy: borderWidth + 5) font: nil color: Color red.! !!ScreeningMorph methodsFor: 'drawing' stamp: 'ar 12/30/2001 19:14'!fullDrawOn: aCanvas	| mergeForm |	submorphs size = 0 ifTrue: [^ super fullDrawOn: aCanvas].	(aCanvas isVisible: self fullBounds) ifFalse:[^self].	(submorphs size = 1 or: [displayMode == #showScreenOnly]) ifTrue:		[^ aCanvas fullDrawMorph: self screenMorph].	displayMode == #showSourceOnly ifTrue:		[^ aCanvas fullDrawMorph: self sourceMorph].	displayMode == #showScreenOverSource ifTrue:		[aCanvas fullDrawMorph: self sourceMorph.		^ aCanvas fullDrawMorph: self screenMorph].	displayMode == #showScreened ifTrue:		[aCanvas fullDrawMorph: self screenMorph.		self flag: #fixCanvas. "There should be a more general way than this"		mergeForm _ self sourceMorph imageFormForRectangle: self screenMorph bounds.		(BitBlt current toForm: mergeForm) copyForm: self screenForm to: 0@0 rule: Form and			colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		aCanvas paintImage: mergeForm at: self screenMorph position]! !!StrikeFont methodsFor: 'accessing' stamp: 'ar 12/31/2001 01:15'!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| ascii |	ascii _ aCharacter asciiValue.	(ascii >= minAscii and:[ascii <= maxAscii]) ifFalse: [ascii _ maxAscii + 1].	^ (xTable at: ascii + 2) - (xTable at: ascii + 1)! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 12/31/2001 00:55'!widthOfString: aString from: firstIndex to: lastIndex	"Measure the length of the given string between start and stop index"	DefaultStringScanner 		ifNil:[DefaultStringScanner _ CharacterScanner new initializeStringMeasurer].	^DefaultStringScanner measureString: aString inFont: self from: firstIndex to: lastIndex! !!StringMorph methodsFor: 'accessing' stamp: 'ar 12/30/2001 20:45'!measureContents	| f |	f _ self fontToUse.	^(((f widthOfString: contents) max: self minimumWidth)  @ f height).! !!StringMorph methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:38'!drawOn: aCanvas	aCanvas drawString: contents in: bounds font: self fontToUse color: color.! !!BorderedStringMorph methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2001 02:34'!drawOn: aCanvas	| nameForm |	font _ self fontToUse.	nameForm _ Form extent: bounds extent depth: 8.	nameForm getCanvas drawString: contents at: 0@0 font: self fontToUse color: Color black.	(bounds origin + 1) eightNeighbors do: [ :pt |		aCanvas			stencil: nameForm 			at: pt			color: self borderColor.	].	aCanvas		stencil: nameForm 		at: bounds origin + 1 		color: color.	! !!DropDownChoiceMorph methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:35'!drawOn: aCanvas	aCanvas drawString: contents in: (bounds insetBy: 2)  font: self fontToUse color: color.	border ifNotNil: [aCanvas frameAndFillRectangle: bounds		fillColor: Color transparent		borderWidth: 1		borderColor: Color black].	aCanvas			paintImage: SubMenuMarker			at: (self right - 8 @ ((self top + self bottom - SubMenuMarker height) // 2))! !!DropDownChoiceMorph methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:51'!maxExtent: listOfStrings	| h w maxW f |	maxW _ 0.	listOfStrings do: [:str |		f _ self fontToUse.		w _ f widthOfString: str.		h _ f height.		maxW _ maxW max: w].	self extent: (maxW + 4 + h) @ (h + 4).	self changed! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:37'!drawOn: aCanvas	| tRect sRect columnRect columnScanner columnData columnLeft colorToUse |	tRect := self toggleRectangle.	sRect := bounds withLeft: tRect right + 3.	self drawToggleOn: aCanvas in: tRect.	colorToUse _ complexContents preferredColor ifNil: [color].	(container columns isNil or: [(contents asString indexOf: Character tab) = 0]) ifTrue: [		aCanvas drawString: contents asString in: sRect font: self fontToUse color: colorToUse.	] ifFalse: [		columnLeft _ sRect left.		columnScanner _ ReadStream on: contents asString.		container columns do: [ :width |			columnRect _ columnLeft @ sRect top extent: width @ sRect height.			columnData _ columnScanner upTo: Character tab.			columnData isEmpty ifFalse: [				aCanvas drawString: columnData in: columnRect font: self fontToUse color: colorToUse.			].			columnLeft _ columnRect right + 5.		].	]! !!MenuItemMorph methodsFor: 'layout' stamp: 'ar 12/30/2001 20:44'!minWidth	| f |	f _ self fontToUse.	^ (f widthOfString: contents) + (subMenu == nil ifTrue: [0] ifFalse: [10])! !!PDAChoiceMorph methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2001 02:38'!drawOn: aCanvas	| offset |	offset _ 4@(bounds height - self fontToUse height // 2).	aCanvas frameAndFillRectangle: bounds fillColor: backgroundColor			borderWidth: 1 borderColor: Color black.	aCanvas drawString: contents			in: ((bounds translateBy: offset) intersect: bounds)			font: self fontToUse color: Color black.! !!SystemWindow methodsFor: 'label' stamp: 'ar 12/30/2001 20:47'!widthOfFullLabelText	^(Preferences windowTitleFont emphasized: 1) widthOfString: labelString! !!TextAnchorPlus methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2001 02:22'!emphasizeScanner: scanner	anchoredMorph ifNil: [^self].	(anchoredMorph owner isKindOf: TextPlusPasteUpMorph) ifFalse: [^anchoredMorph _ nil].	"follwing has been removed - there was no implementation for it"	"scanner setYFor: anchoredMorph"! !!TranslucentProgessMorph methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2001 02:14'!drawOn: aCanvas	| revealPercentage revealingStyle revealingColor revealingBounds revealToggle x baseColor revealTimes secondsRemaining stringToDraw where fontToUse innerBounds |		innerBounds _ bounds.	opaqueBackgroundColor ifNotNil: [		aCanvas 			frameAndFillRectangle: bounds			fillColor: opaqueBackgroundColor			borderWidth: 8			borderColor: Color blue.		innerBounds _ innerBounds insetBy: 8.	].	revealTimes _ (self valueOfProperty: #revealTimes) ifNil: [^self].	revealPercentage _ (revealTimes first / revealTimes second) asFloat.	revealingStyle _ self revealingStyle.	x _ self valueOfProperty: #progressStageNumber ifAbsent: [1].	baseColor _ Color perform: (#(red blue green magenta cyan yellow) atPin: x).	revealingColor _ baseColor alpha: 0.2.	revealingStyle = 3 ifTrue: [	"wrap and change color"		revealPercentage > 1.0 ifTrue: [			revealingColor _ baseColor alpha: (0.2 + (revealingStyle / 10) min: 0.5).		].		revealPercentage _ revealPercentage fractionPart.	].	revealingStyle = 2 ifTrue: [	"peg at 75 and blink"		revealPercentage > 0.75 ifTrue: [			revealToggle _ self valueOfProperty: #revealToggle ifAbsent: [true].			self setProperty: #revealToggle toValue: revealToggle not.			revealToggle ifTrue: [revealingColor _ baseColor alpha: 0.8.].		].		revealPercentage _ revealPercentage min: 0.75.	].	revealingBounds _ innerBounds withLeft: innerBounds left + (innerBounds width * revealPercentage) truncated.	aCanvas 		fillRectangle: revealingBounds		color: revealingColor.	secondsRemaining _ (revealTimes second - revealTimes first / 1000) rounded.	secondsRemaining > 0 ifTrue: [		fontToUse _ StrikeFont familyName: 'ComicBold' size: 24.		stringToDraw _ secondsRemaining printString.		where _ innerBounds corner - ((fontToUse widthOfString: stringToDraw) @ fontToUse height).		aCanvas 			drawString: stringToDraw 			in: (where corner: innerBounds corner)			font: fontToUse			color: Color black.		aCanvas			drawString: stringToDraw 			in: (where - (1@1) corner: innerBounds corner)			font: fontToUse			color: Color white.	]. ! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'ar 12/30/2001 20:48'!fitContents	| newExtent f |	f _ self fontToUse.	newExtent _ (((f widthOfString: contents) max: self minimumWidth) min: self maximumWidth)  @ f height.	(self extent = newExtent) ifFalse:		[self extent: newExtent.		self changed]! !!SyntaxUpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'ar 12/31/2001 02:06'!drawOn: aCanvas	| tempForm strm where chars wid spaceWidth putLigature topOfLigature sizeOfLigature colorOfLigature dots charZero canvas f |	tempForm _ Form extent: self extent depth: aCanvas depth.	canvas _ tempForm getCanvas.	f _ self fontToUse.	spaceWidth _ f widthOf: Character space.	strm _ ReadStream on: contents.	charZero _ Character value: 0.	"a marker for center dot ¥"	where _ 0@0.	topOfLigature _ self height // 2 - 1.	sizeOfLigature _ (spaceWidth-2)@(spaceWidth-2).	colorOfLigature _ Color black alpha: 0.45	"veryLightGray".	dots _ OrderedCollection new.	putLigature _ [		dots add: ((where x + 1) @ topOfLigature extent: sizeOfLigature).		where _ where + (spaceWidth@0)].	strm peek = charZero ifTrue: [		strm next.		putLigature value].	[strm peek = charZero] whileTrue: [strm next].	[strm atEnd] whileFalse: [		chars _ strm upTo: charZero.		wid _ font widthOfString: chars.		canvas drawString: chars at: where.		where _ where + (wid@0).		strm atEnd ifFalse: [putLigature value.			[strm peek = charZero] whileTrue: [strm next]].	].	aCanvas paintImage: tempForm at: self topLeft.	dots do: [ :each |		aCanvas 			fillRectangle: (each translateBy: self topLeft) 			fillStyle: colorOfLigature.	].! !StrikeFont removeSelector: #composeWord:in:beginningAt:!StrikeFont removeSelector: #widthOfString:!RemoteCanvas removeSelector: #roundCornersOf:during:!RemoteCanvas removeSelector: #text:bounds:font:color:!PostscriptCharacterScanner removeSelector: #setYFor:!PostscriptCanvas removeSelector: #text:bounds:font:color:!PluggableCanvas removeSelector: #roundCornersOf:during:!PluggableCanvas removeSelector: #text:bounds:font:color:!BalloonCanvas removeSelector: #text:bounds:font:color:!FormCanvas removeSelector: #nebraskaText:bounds:font:color:!FormCanvas removeSelector: #roundCornersOf:during:!FormCanvas removeSelector: #text:bounds:font:color:!DisplayScanner class removeSelector: #example!DisplayScanner class removeSelector: #quickPrintOn:!DisplayScanner class removeSelector: #quickPrintOn:box:!DisplayScanner class removeSelector: #quickPrintOn:box:font:!DisplayScanner class removeSelector: #quickPrintOn:box:font:color:!DisplayScanner removeSelector: #doesDisplaying!DisplayScanner removeSelector: #drawString:at:!DisplayScanner removeSelector: #lineHeight!DisplayScanner removeSelector: #quickPrintNebraska:bitBlt:box:font:color:ignoreColorChanges:!DisplayScanner removeSelector: #quickPrintOn:box:font:color:!DisplayScanner removeSelector: #setYFor:!DisplayScanner removeSelector: #stringWidth:!CornerRounder class removeSelector: #roundCornersOf:on:displayBlock:borderWidth:corners:!CornerRounder removeSelector: #saveBitsUnderCornersOf:on:!CornerRounder removeSelector: #tweakCornersOf:on:borderWidth:corners:!ColorMappingCanvas removeSelector: #text:bounds:font:color:!CharacterScanner removeSelector: #setYFor:!CanvasEncoder removeSelector: #text:bounds:font:color:!Canvas removeSelector: #text:at:!AbstractFont removeSelector: #composeWord:in:beginningAt:!