'From Squeak 2.1 of June 30, 1998 on 3 July 1998 at 2:54:43 pm'!"Change Set:		DragOverChangesDate:			3 July 1998Author:			Dan IngallsThis changeSet removes the conflict between clients of mouseEnter: and mouseLeave:, regarding whether they are interested in mouseUp activity, or mouseDown (really hand-carrying) activity.  It does this by establishing that, if you wish to receive enter and leave events,	handlesMouseOver: will do so when the hand is empty and the mouse is not pressed,and that 	handlesDragOver: will do so when the hand is carrying something.Returning true to the first works well for most browser-like components.  Returning true to both works for dragging tiles into scriptors, and probably dragOver only would suffice there.It adds dragOverMorphs to HandMorph, parallel to mouseOverMorphs, and ensures that a given morph is never in both at once.The successes achieved include:Browsers no longer show two scrollbars at once.Auto-scrolling now works, even when you pull the mouse over other panes.Scrollbars do not disappear if you drag the elevator outside the scrollbar.Resize handles do not conflict with adjacent scrollbars.Time is not wasted on mouseOver support when you are dragging a morph."!Morph subclass: #HandMorph	instanceVariableNames: 'eventSubscribers keyboardFocus mouseDownMorph mouseOverMorphs mouseOverTimes dragOverMorphs clickClient clickState firstClickEvent firstClickTime userInitials lastEvent eventTransform argument targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset grid gridOn remoteConnections transmitBuffer lastEventTransmitted lastWorldExtent menuTargetOffset hasChanged savedPatch suppressDrawing formerOwner formerPosition '	classVariableNames: 'DoubleClickTime NormalCursor PasteBuffer '	poolDictionaries: ''	category: 'Morphic-Kernel'!ThreePhaseButtonMorph subclass: #TrashCanMorph	instanceVariableNames: ''	classVariableNames: 'TrashPic TrashPicOn '	poolDictionaries: ''	category: 'Morphic-Widgets'!!Morph methodsFor: 'event handling' stamp: 'di 7/3/1998 14:11'!handlesDragOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the hand drags something over me (button up or button down)?"	"NOTE: The default response is false, even if the eventHandler has entries for mouseEnter: and mouseLeave:.  You must override this method and return true if you want to get dragOver events."	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 7/3/1998 14:15'!handlesMouseDown: evt	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"	"NOTE: The default response is false, except if you have added sensitivity to mouseDown events using the on:send:to: mechanism.  Subclasses that implement these messages directly should override this one to return true." 	eventHandler ifNotNil: [^ eventHandler handlesMouseDown: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 7/3/1998 14:11'!handlesMouseOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?"	"NOTE: The default response is false, except if you have added sensitivity to mouseEnter: or mouseLeave:, using the on:send:to: mechanism." 	eventHandler ifNotNil: [^ eventHandler handlesMouseOver: evt].	^ false! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!HandMorph methodsFor: 'initialization' stamp: 'di 7/3/1998 12:23'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	mouseOverMorphs _ OrderedCollection new.	dragOverMorphs _ OrderedCollection new.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	grid _ 4@4.	gridOn _ false.	remoteConnections _ OrderedCollection new.	lastEventTransmitted _ MorphicEvent new.	mouseOverTimes _ Dictionary new.	temporaryCursor _ nil.	temporaryCursorOffset _ 0@0.! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 13:47'!handleDragOver: evt	| mList allMouseOvers leftMorphs enteredMorphs |	owner ifNil: [^ self].  "this hand is not in a world"	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	"Make a list of all potential drag-overs..."	allMouseOvers _ mList select:		[:m | m handlesDragOver: (evt transformedBy: (m transformFrom: self))].	leftMorphs _ dragOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (dragOverMorphs includes: m) not].	"Notify and remove any morphs that have just been left..."	leftMorphs do: [:m |		dragOverMorphs remove: m.		m mouseLeave: (evt transformedBy: (m transformFrom: self))].	"Add any new mouse-overs and send mouseEnter:"	enteredMorphs do: [:m |		dragOverMorphs add: m.		mouseOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		m mouseEnter: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 14:00'!handleMouseMove: evt	"Dispatch a mouseMove event."	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	mouseDownMorph ifNotNil:		[mouseDownMorph mouseMove: (self transformEvent: evt)].	submorphs isEmpty		ifTrue: [evt anyButtonPressed ifFalse: [self handleMouseOver: evt]]		ifFalse: [self handleDragOver: evt]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 13:46'!handleMouseOver: evt	| mList allMouseOvers leftMorphs enteredMorphs now t oldHalo balloonHelpEnabled mouseOverHalosEnabled |	owner ifNil: [^ self].  "this hand is not in a world"	balloonHelpEnabled _ self world balloonHelpEnabled & evt anyButtonPressed not.	mouseOverHalosEnabled _ self world mouseOverHalosEnabled & evt anyButtonPressed not.	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	now _ Time millisecondClockValue.	"Make a list of all potential mouse-overs..."	allMouseOvers _ mList select:		[:m | ((mouseOverHalosEnabled and: [m wantsHalo])			or: [balloonHelpEnabled and: [m wantsBalloon]])  "To start a timer"			or: [m handlesMouseOver: (evt transformedBy: (m transformFrom: self))]  "To send mouseEnter:"].	leftMorphs _ mouseOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (mouseOverMorphs includes: m) not].	"Notify and remove any mouse-overs that have just been left..."	leftMorphs do: [:m |		mouseOverMorphs remove: m.		m wantsBalloon ifTrue: [m deleteBalloon].		m mouseLeave: (evt transformedBy: (m transformFrom: self)).		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: [] ]].	"Add any new mouse-overs and send mouseEnter: and/or start timers..."	enteredMorphs do: [:m |		mouseOverMorphs add: m.		dragOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		(m handlesMouseOver: evt) ifTrue:			[m mouseEnter: (evt transformedBy: (m transformFrom: self))].		(m wantsHalo or: [m wantsBalloon]) ifTrue:			[mouseOverTimes ifNotNil: [mouseOverTimes at: m put: now]]].mouseOverTimes ifNotNil:	[mouseOverTimes keys do:		[:m | "Check pending timers for lingering"		t _ mouseOverTimes at: m.		(now < t "rollover" or: [now > (t+800)]) ifTrue:			["Yes we have lingered for 0.8 seconds..."			mouseOverTimes removeKey: m.			m owner ifNotNil:  "Not deleted during linger (--it happens ;--)"				[(mouseOverHalosEnabled and: [m wantsHalo])					ifTrue: [oldHalo _ m world haloMorphOrNil.							(oldHalo == nil or: [oldHalo target ~~ m])								ifTrue: ["Put up halo for m"										self popUpHalo: evt.										(balloonHelpEnabled and: [m wantsBalloon]) ifTrue:											["...and reschedule balloon after longer linger"											mouseOverTimes at: m put: now]]								ifFalse: ["Halo for m is already up, so show balloon"										(balloonHelpEnabled and: [m wantsBalloon])											ifTrue: [m showBalloon: m balloonText]]]					ifFalse:						[(balloonHelpEnabled and: [m wantsBalloon])							ifTrue: [m showBalloon: m balloonText]]]]]]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 12:56'!mouseOverList: evt 	"Returns a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	| p roots mList mm r |	p _ evt cursorPoint.	roots _ self world rootMorphsAt: p.  "root morphs in world"	[roots size > 0 and: [roots first isPlayfieldLike]]		whileTrue:		[roots _ roots first rootMorphsAt: p].  "roots in innermost frame"	roots size > 0		ifTrue: [mList _ roots first unlockedMorphsAt: p.				mList size > 0 ifTrue:					["NOTE: We really only want the top morph and all its owners"					mm _ mList first.  r _ roots first.					mList _ OrderedCollection new.					[mm == r] whileFalse:						[mList addLast: mm.						mm _ mm owner].					mList add: r]]		ifFalse: [mList _ EmptyArray].	^ mList! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'di 7/2/1998 14:51'!rootMorphsAt: aPoint	"Return the list of root morphs containing the given point, excluding the world and its hands."	^ self submorphs select:		[:m | (m fullContainsPoint: aPoint) and: [m isLocked not]]! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:24'!handlesDragOver: evt	^ true! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!ScrollPane methodsFor: 'pane events' stamp: 'di 7/3/1998 12:07'!handlesMouseOver: evt	^ true! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 7/3/1998 00:53'!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform invert: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ transform invertRect: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'di 7/3/1998 12:55'!mouseLeave: event 	selectionInterval _ textMorph editor selectionInterval.	super mouseLeave: event.	event hand newKeyboardFocus: nil! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^true! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 7/3/1998 01:29'!addHandles 	| pt handle |	isCollapsed ifTrue: [^ self "no handles if collapsed"].	#(topLeft topRight bottomLeft bottomRight rightCenter leftCenter		topLeft topRight bottomLeft bottomRight topCenter bottomCenter)		withIndexDo: [:ptName :i | pt _ self bounds perform: ptName.			handle _ Morph new color: Color yellow; extent: (i<=6 ifTrue: [1@20] ifFalse: [20@1]).			handle align: (handle bounds perform: ptName) with: pt.			handle on: #mouseEnter send: #enterHandle:morph:pointName:					to: self withValue: ptName.			self addMorphBack: handle].! !!SystemWindow methodsFor: 'top window' stamp: 'di 7/3/1998 01:30'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColor.	"Note - the following code is equiv to simply:		self removeHandles.	It has been rewritten so that only 4 damage rects will get repainted, 	all within this window, and none within its subpanes"	"First do the top and bottom handles, together with the label"	self invalidRect: (self bounds topLeft corner: self right@(self top+1)).	self invalidRect: (self left@(self bottom-1) corner: self bounds bottomRight).	(self submorphs select: [:m | (m isMemberOf: Morph)			and: [m bottom <= (self top+1) or: [m top >= (self bottom-1)]]])		do: [:m | m delete].self world displayWorld.	"Now do the left and right handles"	self invalidRect: (self bounds topLeft corner: (self left+1)@self bottom).	self invalidRect: ((self right-1)@self top corner: self bounds bottomRight).	self removeHandles.  "Only these are left"self world displayWorld.	self submorphsDo: [:m | m lock].! !!TilePadMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!TrashCanMorph methodsFor: 'initialization' stamp: 'di 7/3/1998 14:28'!initialize	super initialize.	self image: TrashPicOn;		offImage: TrashPic;		pressedImage: TrashPicOn.	self setNameTo: 'Trash'.	self setProperty: #scriptingControl toValue: true.	self setBalloonText:'The Trash CanTo remove an object, drag itover the Trash, and drop it,and it will disappear.'.! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 13:17'!handlesDragOver: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 13:33'!handlesMouseOver: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 14:23'!mouseEnter: event	"Present feedback for potential deletion."	| hand |	hand _ event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue: [			self world soundsEnabled ifTrue: [self class playMouseEnterSound].			hand startDisplaySuppression.			self world abandonAllHalos.			self state: #pressed]		ifFalse: [			self showStampIn: hand].! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 14:23'!mouseLeave: event	"Present feedback for aborted deletion."	| hand |	hand _ event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue: [			self world soundsEnabled ifTrue: [self class playMouseLeaveSound].			hand endDisplaySuppression.			self state: #off]		ifFalse: [			self stopShowingStampIn: hand].! !PluggableListMorph removeSelector: #handlesMouseOver:!PluggableTextMorph removeSelector: #handlesMouseOver:!TrashCanMorph removeSelector: #stepTime!TrashCanMorph removeSelector: #step!TrashCanMorph removeSelector: #handEntering:!TrashCanMorph removeSelector: #handExiting:!WorldMorph removeSelector: #rootMorphsAt:!"Postscript:Init new field in extant HandMorphsExecutable statements after this comment quote..."HandMorph allSubInstancesDo: [:h | h instVarNamed: 'dragOverMorphs' put: OrderedCollection new]!