'From Squeak 2.0 of May 22, 1998 on 22 June 1998 at 9:43:10 pm'!"Change Set:		MoreFixes-diDate:			22 June 1998Author:			Dan IngallsAny selection past the end of text now selects the end, not the character above.A text ending with CR now ends with a selectable null line.Second select on end of text selects the entire text as we are accustomed.AutoScrolling of text now works properly.  However the old problem of	mouseOver actions interferes if you drag over another scrollPane.Restored the 90-degree detents in flex rotations that got lost in the big merge.Fixed the cursor offset in compatibility menus to be near the first selection.Fixed a bug that prevented error corrections from being seen immediately.Made all links to a project disappear when the project gets deleted.	(orphaned links used to cause crashes).Fixed a bug that introduced boldface when typing or paste caused a line break.Morphic inspectors now respond to cmd-i to inspect the currently selected field.Morphic inspectors no longer care if their eval pane is dirty.Morphic ChangeLists can now be accepted when clean, as in MVC."!PluggableTextMorph subclass: #AcceptableCleanTextMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!ChangeList class methodsFor: 'instance creation' stamp: 'di 6/22/1998 21:40'!openAsMorph: aChangeList name: labelString multiSelect: multiSelect	"Open a morphic view for the messageSet, whose label is labelString.	The listView may be either single or multiple selection type"	| window listView |	window _ (SystemWindow labelled: labelString) model: aChangeList.	window addMorph: (listView _ PluggableListMorph on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: #changeListMenu: keystroke: #messageListKey:from:)		frame: (0@0 corner: 1@0.3)."	multiSelect ifTrue: [listView controller: PluggableListControllerOfMany new]."	window addMorph: (AcceptableCleanTextMorph on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window openInWorld! !!Inspector class methodsFor: 'instance creation' stamp: 'di 6/22/1998 21:20'!openAsMorphOn: anObject	"(Inspector openAsMorphOn: SystemOrganization) openInMVC"	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: anObject defaultLabelForInspector)				model: inspector.	window addMorph: (PluggableListMorph on: inspector list: #fieldList				selected: #selectionIndex changeSelected: #toggleIndex:				menu: #fieldListMenu: keystroke: #inspectorKey:from:)		frame: (0@0 corner: 0.3@0.7).	window addMorph: (PluggableTextMorph on: inspector text: #contents accept: #accept:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.3@0 corner: 1@0.7).	window addMorph: ((PluggableTextMorph on: inspector text: #trash accept: #trash:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)					askBeforeDiscardingEdits: false)		frame: (0@0.7 corner: 1@1).	window position: 16@0.  "Room for scroll bar."	^ window! !!Inspector class methodsFor: 'instance creation' stamp: 'di 6/22/1998 21:12'!openAsMorphOn: anObject withEvalPane: withEval			withLabel: label valueViewClass: valueViewClass	"Note: for now, this always adds an eval pane, and ignores the valueViewClass"	(self openAsMorphOn: anObject) openInWorld! !!MenuMorph methodsFor: 'control' stamp: 'di 6/22/1998 15:15'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem i yOffset sub delta |	popUpOwner _ hand.	selectedItem _ self items detect: [:each | each == lastSelection] ifNone: [self items first].	"Note: items may not be laid out yet (I found them all to be at 0@0),		so have to add up heights of items above the selected item."	i _ 0.  yOffset _ 0.	[(sub _ self submorphs at: (i _ i+1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2@(yOffset + 8)).	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self.	hand newMouseFocus: selectedItem.	self changed.! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'di 6/22/1998 14:26'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	| h |	h _ aWorld activeHand.	h ifNil: [h _ aWorld hands first].	self popUpAt: aPoint forHand: h.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneCycle].	self delete.	^ selectedItem! !!NewParagraph methodsFor: 'composition' stamp: 'di 6/22/1998 12:37'!composeLinesFrom: startingIndex withLines: startingLines atY: startingY	| charIndex lineY lineHeight scanner line row firstLine lineHeightGuess saveCharIndex hitCR |	charIndex _ startingIndex.	lines _ startingLines.	lineY _ startingY.	lineHeightGuess _ textStyle lineGrid.	maxRightX _ container left.	scanner _ CompositionScanner new text: text textStyle: textStyle.	firstLine _ true.	[charIndex <= text size and: [(lineY + lineHeightGuess) <= container bottom]]		whileTrue:		[lineHeight _ lineHeightGuess.		saveCharIndex _ charIndex.		hitCR _ false.		(row _ container rectanglesAt: lineY height: lineHeight)			withIndexDo:			[:r :i | (charIndex <= text size and: [hitCR not]) ifTrue:				[line _ scanner composeFrom: charIndex inRectangle: r						firstLine: firstLine leftSide: i=1 rightSide: i=row size.				lines addLast: line.				(text at: line last) = Character cr ifTrue: [hitCR _ true].				lineHeight _ lineHeight max: line lineHeight.  "includes font changes"				charIndex _ line last + 1]].		row size >= 1 ifTrue:		[lineY _ lineY + lineHeight.		lineY > container bottom			ifTrue: ["Oops -- the line is really too high to fit -- back out"					charIndex _ saveCharIndex.					row do: [:r | lines removeLast]]			ifFalse: ["It's OK -- the line still fits."					maxRightX _ maxRightX max: scanner rightX.					1 to: row size - 1 do:  "Adjust heights across row if necess"						[:i | (lines at: lines size - row size + i)								lineHeight: lines last lineHeight								baseline: lines last baseline].					charIndex > text size ifTrue:						["end of text"						hitCR ifTrue:							["If text ends with CR, add a null line at the end"							((lineY + lineHeightGuess) <= container bottom) ifTrue:								[row _ container rectanglesAt: lineY height: lineHeightGuess.								row size > 0 ifTrue:									[line _ (TextLine start: charIndex stop: charIndex-1										internalSpaces: 0 paddingWidth: 0)									rectangle: row first;									lineHeight: lineHeightGuess baseline: textStyle baseline.									lines addLast: line]]].						lines _ lines asArray.						^ maxRightX].					firstLine _ false]]			ifFalse:			[lineY _ lineY + lineHeight]].	firstLine ifTrue:		["No space in container or empty text"		line _ (TextLine start: startingIndex stop: startingIndex-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (container topLeft extent: 0@lineHeightGuess);				lineHeight: lineHeightGuess baseline: textStyle baseline.		lines _ Array with: line].	"end of container"	lines _ lines asArray.	^ maxRightX! !!NewParagraph methodsFor: 'selection' stamp: 'di 6/22/1998 12:28'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: aPoint index: nil		in: line! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 6/22/1998 15:15'!correctFrom: start to: stop with: aString	^ self handleEdit: [textMorph editor correctFrom: start to: stop with: aString]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 6/22/1998 15:14'!handleEdit: editBlock	| result |	textMorph editor model: model.  "For evaluateSelection"	textMorph handleEdit: [result _ editBlock value].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 6/22/1998 13:38'!scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform invert: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2].		cpHere y >= self bottom			ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2].		selectionInterval _ textMorph editor selectionInterval].	selRect _ transform invertRect: rectToTest.	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!AcceptableCleanTextMorph reorganize!('all' accept)!!AcceptableCleanTextMorph methodsFor: 'all' stamp: 'di 6/22/1998 21:38'!accept	"Overridden to allow accept of clean text"	| textToAccept ok |	textToAccept _ textMorph asText.	ok _ (setTextSelector == nil) or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]].	ok ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false]! !!Project methodsFor: 'release' stamp: 'di 6/22/1998 09:40'!okToChange	| ok hasSubProjects |	hasSubProjects _ world isMorph		ifTrue: [(world submorphs select:						[:m | (m isKindOf: SystemWindow)								and: [m model isKindOf: Project]]) size > 0]		ifFalse: [(world controllerWhoseModelSatisfies:						[:m | m isKindOf: Project]) notNil].	hasSubProjects ifTrue:		[PopUpMenu notify: 'The project ', self name printString, 'contains sub-projects.  You must remove theseexplicitly before removing their parent.'.		^ false].	ok _ (world isMorph not and: [world scheduledControllers size <= 1]) or:			[self confirm:'Really delete the project', self name printString, 'and all its windows?'].	ok ifFalse: [^ false].	"about to delete this project; clear previous links to it from other Projects:"	Project allInstancesDo: [:p | p deletingProject: self].	ProjectViewMorph allInstancesDo: [:p | p deletingProject: self].	^ true! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/22/1998 09:41'!deletingProject: aProject	"My project is being deleted.  Delete me as well."	project == aProject ifTrue: [self delete].! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:55'!drawBoundsOn: aCanvas	"Shows where line boundaries are"	self paragraph lines do:		[:line | aCanvas frameRectangle: line rectangle color: Color brown]! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:39'!drawNullTextOn: aCanvas	"make null text frame visible"	aCanvas fillRectangle: bounds color: Color lightRed! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 12:37'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size		ifTrue: [self drawNullTextOn: aCanvas]		ifFalse: [aCanvas paragraph: self paragraph bounds: bounds color: color].! !!TextMorph methodsFor: 'private' stamp: 'di 6/22/1998 20:22'!updateFromParagraph  	| newStyle sel oldLast |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [sel _ editor selectionInterval.					editor storeSelectionInParagraph].	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				sel ifNotNil: [self installEditor selectFrom: sel first to: sel last]].	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast orLineAbove: false.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self releaseEditor.		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditor selectFrom: sel first to: sel last.							m selectionChanged.							^ self passKeyboardFocusTo: m]].		^ self].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditor selectFrom: sel first to: sel last.		self editor setEmphasisHere]! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/22/1998 10:44'!drawNullTextOn: aCanvas	"Just run the normal code to show selection in a window"	aCanvas paragraph: self paragraph bounds: bounds color: color! !!TransformationMorph methodsFor: 'accessing' stamp: 'di 6/22/1998 13:54'!rotationDegrees: degrees	self adjustAfter:		[self angle: (degrees degreesToRadians negated						detentBy: Float pi / 20.0						atMultiplesOf: Float pi / 2.0 snap: false)]! !TextMorphForEditView removeSelector: #drawOn:!Smalltalk removeClassNamed: #ReadOnlyTextMorph!