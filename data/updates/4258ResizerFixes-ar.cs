'From Squeak3.1alpha of 28 February 2001 [latest update: #4257] on 18 August 2001 at 1:00:01 am'!"Change Set:		TmpCursorFix-arDate:			18 August 2001Author:			Andreas RaabFixes two problems with the cursor-based resizer scheme:#1: A problem when switching between temporary cursors that used to offset the hands position by the delta between the old and the new cursor hotspot offset (resulting in quite annoying sudden cursor jumps).#2: A problem in determining overlapping morphs in SysWindows #spawnReframeHandle: method that would incorrectly disable a resize if the hand had a temporary cursor assigned."!!HandMorph methodsFor: 'cursor' stamp: 'ar 8/18/2001 00:50'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset	"Set the temporary cursor to the given Form.	If the argument is nil, revert to the normal hardware cursor."	self changed.	temporaryCursorOffset ifNotNil:[		bounds _ bounds translateBy: temporaryCursorOffset negated.	].	cursorOrNil == nil		ifTrue: [temporaryCursor _ temporaryCursorOffset _ nil]		ifFalse: [temporaryCursor _ cursorOrNil asCursorForm.				temporaryCursorOffset _ temporaryCursor offset - hotSpotOffset].	bounds _ self cursorBounds.	self 		userInitials: userInitials andPicture: (self userPicture);		layoutChanged;		changed! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'ar 8/18/2001 00:57'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds cursor |	allowReframeHandles ifFalse: [^ self].	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) ifTrue:  [^ self].	((self world ifNil: [^ self]) firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[^ self  "Prevent multiple handles"].	pt _ event cursorPoint.	"prevent spurios mouse leave when dropping morphs"	owner morphsInFrontOf: self overlapping: (pt-2 extent: 4@4)		do:[:m| m isHandMorph ifFalse:[(m fullContainsPoint: pt) ifTrue:[^self]]].	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	cursor _ Cursor resizeForEdge: ptName.	resizer _ NewHandleMorph new		sensorMode: self fastFramingOn;		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ self bounds				withSideOrCorner: ptName				setToPoint: localPt				minExtent: self minimumExtent.			self fastFramingOn 			ifTrue:				[Cursor currentCursor == cursor ifFalse:[					event hand visible: false; refreshWorld; visible: true.					cursor show].				self doFastWindowReframe: ptName]			ifFalse:				[self bounds: newBounds.				(Preferences roundedWindowCorners					and: [#(bottom right bottomRight) includes: ptName])					ifTrue:					["Complete kluge: causes rounded corners to get painted correctly,					in spite of not working with top-down displayWorld."					ptName = #bottom ifFalse:						[self invalidRect: (self bounds topRight - (6@0) extent: 7@7)].					ptName = #right ifFalse:						[self invalidRect: (self bounds bottomLeft - (0@6) extent: 7@7)].					self invalidRect: (self bounds bottomRight - (6@6) extent: 7@7)]]]		lastPointDo:			[:p | ]		withCursor: cursor.	event hand world addMorphInLayer: resizer.	resizer startStepping! !