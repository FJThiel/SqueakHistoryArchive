'From Squeak2.9alpha of 17 July 2000 [latest update: #2466] on 1 August 2000 at 1:50:35 pm'!"Change Set:		NebraskaEtcDate:			19 July 2000Author:			Lex Spoon, Bob Arning- comprising (parts of) GenericServer, PluggableCanvas and Nebraska by Lex SpoonThis is a first cut at providing a collaborative screen-sharing for Alan, SuperSwiki and the world at large. This version has been tested in a Disney image at change set 2466. Consider this experimental and don't overwrite your favorite image after loading it. What it currently provides is:-- person A decides to share his screen and evaluates:	NebraskaServerMorph serveWorld: World-- person B wants to view A's screen and evaluates	NetworkTerminalMorph openAndConnectTo: 'ipAddressForA'-- a small white morph will appear and as soon as enough data appears, it will grow into a full-size replica of A's screen. Note: It may completely cover B's screen!! At this point both A and B can see A's screen and both can interact with it (with some limitations).-- limitation: mouseOver events are tricky. B's mouse will not register entering and leaving morphs on A's screen. I'm not sure what we want here as it could lead to nasty fights over keyboard focus, scrollbar flipping, etc.-- limitation: I have noticed a few drawing anomalies that will need looking into.-- limitation: speed. This works reasonably well across 10Mbit Ethernet. We'll see how it does in the real world soon.--- speed improvements ---- starting to investigate caching things to avoid retransmission. First change outside of Nebraska itself is to cache the arrows used by scroll bars so we don't make two new ones for every scrollbar.==== testing/debugging code ====StringSocket showStats: 10CanvasEncoder beginStatsCanvasEncoder showStatsCanvasEncoder killStatsCanvasEncoder beginCachingNebraskaDebug beginStatsNebraskaDebug showStatsNebraskaDebug showStats: #delaysNebraskaDebug showStats: #bigImageNebraskaDebug showStats: #FormEncodeTimesNebraskaDebug killStats"!CharacterScanner subclass: #CanvasCharacterScanner	instanceVariableNames: 'canvas fillBlt foregroundColor runX lineY '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!CanvasCharacterScanner commentStamp: '<historical>' prior: 0!A displaying scanner which draws its output to a Morphic canvas.!Object subclass: #CanvasDecoder	instanceVariableNames: 'drawingCanvas clipRect transform connection fonts '	classVariableNames: 'CachedForms '	poolDictionaries: ''	category: 'Morphic-Remote'!!CanvasDecoder commentStamp: '<historical>' prior: 0!Decodes commands encoded by MREncoder, and draws them onto a canvas.!CanvasDecoder class	instanceVariableNames: ''!Object subclass: #CanvasEncoder	instanceVariableNames: 'connection lastClipRect lastTransform fontCache junk '	classVariableNames: 'CachedObjects SentTypesAndSizes SimpleCounters '	poolDictionaries: ''	category: 'Morphic-Remote'!!CanvasEncoder commentStamp: '<historical>' prior: 0!Encodes canvas commands into string-arrays format.---possible further compression for forms ---600 * 359 * 4    861600self encodeForRemoteCanvas size 76063Time millisecondsToRun: [self encodeForRemoteCanvas]| raw data |data _ self encodeForRemoteCanvas.raw _ RWBinaryOrTextStream on: (String new: 1000).Time millisecondsToRun: [(GZipWriteStream on: raw) nextPutAll: data; close].raw contents size(GZipReadStream on: (ReadStream on: raw contents)) upToEnd size| raw |raw _ RWBinaryOrTextStream on: (String new: bits size).raw nextPutAll: bitsTime millisecondsToRun: [bits compressGZip]   50bits compressGZip size 861620!Object subclass: #FontCache	instanceVariableNames: 'fonts '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!!FontCache commentStamp: '<historical>' prior: 0!Used by MREncoder and MRDecoder.  It associates an integer index with a number of fonts.  Fonts can be searched by index, and the index can be found for a font that isn't present.  If a font is added to the cache, sometimes the cache will discard another font to make room.!InterpreterPlugin subclass: #IntegerPokerPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-ObjectSocket'!!IntegerPokerPlugin commentStamp: '<historical>' prior: 0!a plugin that sticks the 4 bytes of a small integer into a string.  and read them back....IntegerPokerPlugin translate.!Object subclass: #LoopbackStringSocket	instanceVariableNames: 'associate inArrays outArrays '	classVariableNames: 'WRITESTRINGSIZES '	poolDictionaries: ''	category: 'Morphic-Remote'!!LoopbackStringSocket commentStamp: '<historical>' prior: 0!a string socket which is connected to another string sockt on the local computer.  Used mostly for testing.!Object subclass: #MorphicEventDecoder	instanceVariableNames: 'connection '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!!MorphicEventDecoder commentStamp: '<historical>' prior: 0!decode messages sent via a MorphicEventEncoder.!Object subclass: #MorphicEventEncoder	instanceVariableNames: 'connection lastEventSent '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!!MorphicEventEncoder commentStamp: '<historical>' prior: 0!A filter which translates MorphEvent's into StringArray's.!Object subclass: #NebraskaClient	instanceVariableNames: 'connection encoder hand canvas '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!!NebraskaClient commentStamp: '<historical>' prior: 0!A client that has connected to a Nebraska server, seen from the server's point of view.!Object subclass: #NebraskaDebug	instanceVariableNames: ''	classVariableNames: 'DEBUG '	poolDictionaries: ''	category: 'Morphic-Remote'!Object subclass: #NebraskaServer	instanceVariableNames: 'worldDepth world clients listenQueue '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!!NebraskaServer commentStamp: '<historical>' prior: 0!A Nebraska server has a private world and some collection of clients.  It associates a RemoteControlledHand for each client.  Redraw events in the world are broadcasted to all connected clients.  A Nebraska server can listen on a TCP/IP port and accept new clients. Current version has been modified so that the server serves the world in which it was launched. Other variations are certainly possible.To start a server, execute the following code:	NebraskaServerMorph serveWorld: WorldTo start a client, run the following in another image:	NetworkTerminalMorph openAndConnectTo: 'servername'Fill in your server's hostname for 'servername'. At this point, everything should be working!!Before starting a server, you can tweak these:BufferedCanvas enabled: false.BufferedCanvas enabled: true.At any time you can do these:NebraskaDebug beginStatsNebraskaDebug showStatsNebraskaDebug showStats: #delaysNebraskaDebug showStats: #bigImageNebraskaDebug showStats: #FormEncodeTimesNebraskaDebug killStatsNOTE: if you want to have a local view of the server, you shouldn't use the TCP connections. The problem is that the server will occasionally do a #flush, and it won't work due to single threading. The better solution is to use a LoopBackStringSocket instead of a regular StringSocket, but there is no handy method for that right now....!]style[(266 136 49 39 56 53 96 46 1 62 29 525)f1,f1cred;,f1,f1cblue;,f1,f1cblue;,f1,f1cblue;,f1,f1cred;,f1cblue;,f1!Morph subclass: #NebraskaServerMorph	instanceVariableNames: 'server slowCounter previousBacklog '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!!NebraskaServerMorph commentStamp: '<historical>' prior: 0!A cheezy morph that simply steps a Nebraska server instance over and over.!Morph subclass: #NetworkTerminalMorph	instanceVariableNames: 'connection decoder eventEncoder backgroundForm enteringHand '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!!NetworkTerminalMorph commentStamp: '<historical>' prior: 0!A morph used to communicate with a remote image.  It sends all mouse/keyboard events to the remote side, and it displays canvas commands that are sent back.!NetworkTerminalMorph subclass: #NullTerminalMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!Stream subclass: #ObjectSocket	instanceVariableNames: 'socket outBuf outBufIndex outBufSize inBuf inBufIndex inBufLastIndex outObjects inObjects '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-ObjectSocket'!!ObjectSocket commentStamp: '<historical>' prior: 0!This is a socket which sends arrays of strings back and forth.  This is less convenient than ObjectSockets but it is more secure.An array of strings is represented on the network as:	4-bytes		number of strings in the array	4-byte		number of bytes in the first string	n1-bytes		characters in the first string	4-bytes		number of bytes in the second string	n2-bytes	characters in the second string	...!ObjectSocket subclass: #ArbitraryObjectSocket	instanceVariableNames: 'encodingOfLastEncodedObject lastEncodedObject '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-ObjectSocket'!!ArbitraryObjectSocket commentStamp: '<historical>' prior: 0!A network connection that passes objects instead of bytes.  The objects are encoded with SmartRefStreams.Of course, one can send Arrays of Strings if one is unsure of what exactly SmartRefStream's are going to do.!PasteUpMorph subclass: #NebraskaPasteUpMorph	instanceVariableNames: 'remoteCanvases needToUpdateCanvas '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!!NebraskaPasteUpMorph commentStamp: '<historical>' prior: 0!Main comment stating the purpose of this class and relevant relationship to other classes.Possible useful expressions for doIt or printIt.Structure: instVar1		type -- comment about the purpose of instVar1 instVar2		type -- comment about the purpose of instVar2Any further useful comments about the general approach of this implementation.!Canvas subclass: #PluggableCanvas	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!PluggableCanvas commentStamp: '<historical>' prior: 0!An abstract canvas which modifies the behavior of an underlying canvas in some way.  Subclasses should implement apply:, which takes a one argument block and an actual canvas to draw on.  See apply: for the specific definition.!PluggableCanvas subclass: #BufferedCanvas	instanceVariableNames: 'remote previousVersion lastTick dirtyRect '	classVariableNames: 'BufferingEnabled '	poolDictionaries: ''	category: 'Morphic-Remote'!PluggableCanvas subclass: #CachingCanvas	instanceVariableNames: 'cacheCanvas mainCanvas '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!CachingCanvas commentStamp: '<historical>' prior: 0!A canvas which has a hidden form caching the events.  contentsOfArea:into: uses the cache, instead of the main canvas.  This is typically used with remote canvases, where querying the bits would involve a network transaction.!PluggableCanvas subclass: #ClippingCanvas	instanceVariableNames: 'canvas clipRect '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!ClippingCanvas commentStamp: '<historical>' prior: 0!A modified canvas which clips all drawing commands.!PluggableCanvas subclass: #MultiCanvas	instanceVariableNames: 'canvases extent depth '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!MultiCanvas commentStamp: '<historical>' prior: 0!A canvas which forwards drawing commands to sub-canvases.!PluggableCanvas subclass: #NullCanvas	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!NullCanvas commentStamp: '<historical>' prior: 0!A canvas which ignores all drawing commands.!Canvas subclass: #RemoteCanvas	instanceVariableNames: 'innerClipRect outerClipRect transform connection '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!!RemoteCanvas commentStamp: '<historical>' prior: 0!A canvas which draws to a terminal across the network.  Note that multiple RemoteCanvas's might exist for a single MREncoder, each having different transformations and clipping rectangles.!HandMorph subclass: #RemoteControlledHandMorph	instanceVariableNames: 'eventDecoder viewExtent '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!!RemoteControlledHandMorph commentStamp: '<historical>' prior: 0!Used as part of the Nebraska system.  It is controlled by commands sent through a socket.  The encoding is interpreted via a MorphicEventDecoder.!HandMorph subclass: #RemoteHandMorph	instanceVariableNames: 'remoteWorldExtent socket waitingForConnection receiveBuffer '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!Slider subclass: #ScrollBar	instanceVariableNames: 'menuButton upButton downButton pagingArea scrollDelta pageDelta interval menuSelector timeOfMouseDown timeOfLastScroll nextPageDirection currentScrollDelay '	classVariableNames: 'CachedImages UpArrow UpArrow8Bit '	poolDictionaries: ''	category: 'Morphic-Windows'!!ScrollBar commentStamp: '<historical>' prior: 0!Inspired by an oiginal design of Hans-Martin Mosner, this ScrollBar is intended to exercise the handling of input events in Morphic.  With sufficient flexibility in this area, all particular behavior can be concentrated in this single class with no need to specialize any other morphs to achieve button, slider and menu-button behavior.Once we have this working, put in logic for horizontal operation as well.CachedImages was added to reduce the number of forms created and thrown away. This will be helpful for Nebraska and others as well.!ObjectSocket subclass: #StringSocket	instanceVariableNames: 'numStringsInNextArray stringsForNextArray nextStringSize files startTime stringCounter socketWriterProcess outputQueue slowNetworkTime slowNetworkCount '	classVariableNames: 'JUNK '	poolDictionaries: ''	category: 'Network-ObjectSocket'!StringSocket class	instanceVariableNames: ''!WorldState subclass: #NebraskaWorldState	instanceVariableNames: 'remoteCanvases needToUpdateCanvas '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Worlds'!!Canvas methodsFor: 'copying' stamp: 'ls 3/20/2000 21:24'!copyClipRect: newClipRect	^ ClippingCanvas canvas: self clipRect: newClipRect! !!Canvas methodsFor: 'drawing' stamp: 'ls 3/19/2000 15:12'!paragraph2: para bounds: bounds color: c	| scanner |	scanner _ CanvasCharacterScanner new.	scanner		 canvas: self;		text: para text textStyle: para textStyle;		textColor: c.	para displayOn: self using: scanner at: bounds topLeft.! !!Canvas methodsFor: 'Nebraska/embeddedWorlds' stamp: 'RAA 8/1/2000 13:36'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"an attempt to use #displayInterpolatedOn: instead of WarpBlt."	| innerRect patchRect subCanvas |	self flag: #bob.		"added to Canvas in hopes it will work for Nebraska"	(aDisplayTransform isPureTranslation) ifTrue: [		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ aClipRect.	patchRect _ aDisplayTransform globalBoundsToLocal: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	subCanvas _ FormCanvas extent: patchRect extent depth: self depth.	self isShadowDrawing ifTrue: [		subCanvas shadowColor: self shadowColor	].	subCanvas 		translateBy: patchRect topLeft negated truncated		during: [ :offsetCanvas | aBlock value: offsetCanvas].	subCanvas form 		displayInterpolatedIn: (innerRect translateBy: self origin) truncated		on: self form.! !!CanvasCharacterScanner methodsFor: 'private' stamp: 'ls 9/26/1999 10:03'!doesDisplaying	^false   "it doesn't do displaying using copyBits"! !!CanvasCharacterScanner methodsFor: 'private' stamp: 'ls 9/30/1999 12:34'!setFont	foregroundColor _ Color black.	super setFont.	destY _ lineY + line baseline - font ascent! !!CanvasCharacterScanner methodsFor: 'private' stamp: 'ls 9/25/1999 16:24'!textColor: color	foregroundColor _ color! !!CanvasCharacterScanner methodsFor: 'scanning' stamp: 'RAA 7/22/2000 10:06'!displayLine: textLine  offset: offset  leftInRun: leftInRun	|  nowLeftInRun done startLoc startIndex stopCondition |	"largely copied from DisplayScanner's routine"	line _ textLine.	foregroundColor ifNil: [ foregroundColor _ Color black ].	leftMargin _ (line leftMarginForAlignment: textStyle alignment) + offset x.	rightMargin _ line rightMargin + offset x.	lineY _ line top + offset y.	lastIndex _ textLine first.	leftInRun <= 0		ifTrue: [self setStopConditions.  "also sets the font"				nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	runX _ destX _ leftMargin.	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	done _ false.	[done] whileFalse: [		"remember where this portion of the line starts"		startLoc _ destX@destY.		startIndex _ lastIndex.		"find the end of this portion of the line"		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: text string rightX: rightMargin stopConditions: stopConditions						kern: kern "displaying: false".		"display that portion of the line"		canvas text: (text string copyFrom: startIndex to: lastIndex)			bounds: (startLoc corner: 99999@99999)			font: font			color: foregroundColor.		"handle the stop condition"		done _ self perform: stopCondition	].	^runStopIndex - lastIndex! !!CanvasCharacterScanner methodsFor: 'accessing' stamp: 'ls 9/25/1999 15:59'!canvas: aCanvas	"set the canvas to draw on"	canvas ifNotNil: [ self inform: 'initializing twice!!' ].	canvas _ aCanvas! !!CanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'ls 9/25/1999 16:07'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex_ lastIndex + 1.	^false! !!CanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'ls 9/25/1999 16:10'!crossedX	"This condition will sometimes be reached 'legally' during display, when, 	for instance the space that caused the line to wrap actually extends over 	the right boundary. This character is allowed to display, even though it 	is technically outside or straddling the clipping ectangle since it is in 	the normal case not visible and is in any case appropriately clipped by 	the scanner."	"self fillLeading."	^ true ! !!CanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'ls 9/25/1999 16:11'!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	lastIndex = line last ifTrue: [^true].	runX _ destX.	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).	runStopIndex _ lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!CanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'ls 9/29/1999 20:13'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	destX _ destX + spaceWidth + (line justifiedPadFor: spaceCount).	lastIndex _ lastIndex + 1.	^ false! !!CanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'ls 9/25/1999 16:14'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	stopConditions 		at: Space asciiValue + 1 		put: (textStyle alignment = Justified ifTrue: [#paddedSpace])! !!CanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'ls 9/25/1999 16:14'!tab	destX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastIndex _ lastIndex + 1.	^ false! !!CanvasDecoder methodsFor: 'initialization' stamp: 'ls 4/9/2000 14:26'!initialize	"set the canvas to draw on"	drawingCanvas := FormCanvas extent: 100@100 depth: 16.	clipRect _ drawingCanvas extent.	transform _ MorphicTransform identity.	fonts := Array new: 2.! !!CanvasDecoder methodsFor: 'network' stamp: 'ls 9/26/1999 14:59'!connection: aStringSocket	"set this terminal to talk over the given socket"	connection _ aStringSocket! !!CanvasDecoder methodsFor: 'network' stamp: 'ls 3/18/2000 13:38'!processIO	| command didSomething |	connection ifNil: [ ^self ].	connection processIO.	didSomething := false.	[ command _ connection nextOrNil.  command notNil ] whileTrue: [		didSomething := true.		self processCommand: command ].	^didSomething! !!CanvasDecoder methodsFor: 'network' stamp: 'ls 3/26/2000 22:16'!processIOOnForce: forceBlock	| command didSomething |	connection ifNil: [ ^self ].	connection processIO.	didSomething := false.	[ command _ connection nextOrNil.  command notNil ] whileTrue: [		didSomething := true.		self processCommand: command onForceDo: forceBlock].	^didSomething! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 3/27/2000 17:57'!addFontToCache: command	| index font |	index := self class decodeInteger: command second.	font := self class decodeFont: command third.	index > fonts size ifTrue: [		| newFonts |		newFonts  := Array new: index.		newFonts replaceFrom: 1 to: fonts size with: fonts.		fonts := newFonts ].	fonts at: index put: font! !!CanvasDecoder methodsFor: 'decoding' stamp: 'RAA 7/28/2000 07:55'!drawBalloonRect: command	| aRectangle aFillStyle |	aRectangle _ self class decodeRectangle: (command at: 2).	aFillStyle _ self class decodeFillStyle: (command at: 3).	self drawCommand: [ :c |		c asBalloonCanvas 			fillRectangle: aRectangle 			fillStyle: aFillStyle.	].! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 4/9/2000 14:26'!drawCommand: aBlock	"call aBlock with the canvas it should actually draw on so that the clipping rectangle and transform are set correctly"	drawingCanvas transformBy: transform clippingTo: clipRect during: aBlock! !!CanvasDecoder methodsFor: 'decoding' stamp: 'RAA 7/28/2000 17:18'!drawImage: command	| image point sourceRect rule cacheID cacheNew |	image := self class decodeImage: (command at: 2).	point := self class decodePoint: (command at: 3).	sourceRect := self class decodeRectangle: (command at: 4).	rule := self class decodeInteger: (command at: 5).	command size >= 7 ifTrue: [		cacheID _ self class decodeInteger: (command at: 6).		cacheNew _ (self class decodeInteger: (command at: 7)) = 1.		cacheID > 0 ifTrue: [			CachedForms ifNil: [CachedForms _ Array new: 100].			(cacheNew or: [(CachedForms at: cacheID) isNil]) ifFalse: [				image _ (CachedForms at: cacheID) addDeltasFrom: image. "1 beep."			].			CachedForms at: cacheID put: image		].	].	self drawCommand: [ :c |		c image: image  at: point  sourceRect: sourceRect rule: rule	]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 2/28/2000 00:22'!drawLine: command	| verb pt1Enc pt2Enc widthEnc colorEnc pt1 pt2 width color |	verb := command at: 1.	pt1Enc := command at: 2.	pt2Enc := command at: 3.	widthEnc := command at: 4.	colorEnc := command at: 5.	pt1 _ self class decodePoint: pt1Enc.	pt2 _ self class decodePoint: pt2Enc.	width _ self class decodeInteger: widthEnc.	color _ self class decodeColor: colorEnc.	self drawCommand: [ :c |		c line: pt1 to: pt2 width: width color: color ]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 2/28/2000 00:24'!drawOval: command	| verb rectEnc colorEnc borderWidthEnc borderColorEnc rect color borderWidth borderColor |	verb := command at: 1.	rectEnc := command at: 2.	colorEnc := command at: 3.	borderWidthEnc := command at: 4.	borderColorEnc := command at: 5.	rect _ self class decodeRectangle: rectEnc.	color _ self class decodeColor: colorEnc.	borderWidth _ self class decodeInteger: borderWidthEnc.	borderColor _ self class decodeColor: borderColorEnc.	self drawCommand: [ :c |		c fillOval: rect color: color borderWidth: borderWidth borderColor: borderColor ]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 4/8/2000 22:28'!drawPoly: command	|  verticesEnc fillColorEnc borderWidthEnc borderColorEnc vertices fillColor borderWidth borderColor |	fillColorEnc := command at: 2.	borderWidthEnc := command at: 3.	borderColorEnc := command at: 4.	verticesEnc := command copyFrom: 5 to: command size.	fillColor := self class decodeColor: fillColorEnc.	borderWidth := self class decodeInteger: borderWidthEnc.	borderColor := self class decodeColor: borderColorEnc.	vertices := verticesEnc collect: [ :enc | self class decodePoint: enc ].	self drawCommand: [ :c |		c drawPolygon: vertices color: fillColor borderWidth: borderWidth borderColor: borderColor ].! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 2/28/2000 00:24'!drawRect: command	| verb rectEnc fillColorEnc borderWidthEnc borderColorEnc rect fillColor borderWidth borderColor |	verb := command at: 1.	rectEnc := command at: 2.	fillColorEnc := command at: 3.	borderWidthEnc := command at: 4.	borderColorEnc := command at: 5.	rect _ self class decodeRectangle: rectEnc.	fillColor _ self class decodeColor: fillColorEnc.	borderWidth _ self class decodeInteger: borderWidthEnc.	borderColor _ self class decodeColor: borderColorEnc.	self drawCommand: [ :c |		c frameAndFillRectangle: rect  fillColor: fillColor  borderWidth: borderWidth  borderColor: borderColor ]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 3/26/2000 13:20'!drawStencil: command	| stencilFormEnc locationEnc sourceRectEnc colorEnc stencilForm location sourceRect color |	stencilFormEnc := command at: 2.	locationEnc := command at: 3.	sourceRectEnc := command at: 4.	colorEnc := command at: 5.	stencilForm := self class decodeImage: stencilFormEnc.	location := self class decodePoint: locationEnc.	sourceRect := self class decodeRectangle: sourceRectEnc.	color := self class decodeColor: colorEnc.	self drawCommand: [ :executor |		executor stencil: stencilForm at: location sourceRect: sourceRect  color: color ]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 3/27/2000 18:02'!drawText: command	| boundsEnc colorEnc  text bounds color fontIndexEnc fontIndex |	text := command at: 2.	boundsEnc := command at: 3.	fontIndexEnc := command at: 4.	colorEnc := command at: 5.	bounds _ self class decodeRectangle: boundsEnc.	fontIndex := self class decodeInteger: fontIndexEnc.	color _ self class decodeColor: colorEnc.	self drawCommand: [ :c |		c text: text bounds: bounds font: (fonts at: fontIndex) color: color ]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 4/9/2000 14:40'!extentDepth: command	| depth extent |	extent := self class decodePoint: (command at: 2).	depth := self class decodeInteger: (command at: 3).	drawingCanvas := FormCanvas  extent: extent depth: depth.! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 3/26/2000 22:04'!forceToScreen: aCommand  withBlock: forceBlock	| region |	region := self class decodeRectangle: aCommand second.	forceBlock value: region.! !!CanvasDecoder methodsFor: 'decoding' stamp: 'RAA 7/28/2000 17:01'!processCommand: command  onForceDo: forceBlock	| verb verbCode |	command isEmpty ifTrue: [ ^self ].	verb _ command first.	verbCode := verb at: 1.	verbCode = CanvasEncoder codeClip ifTrue: [ ^self setClip: command ].	verbCode = CanvasEncoder codeTransform ifTrue: [ ^self setTransform: command ].	verbCode = CanvasEncoder codeText ifTrue: [ ^self drawText: command ].	verbCode = CanvasEncoder codeLine ifTrue: [ ^self drawLine: command ].	verbCode = CanvasEncoder codeRect ifTrue: [ ^self drawRect: command ].	verbCode = CanvasEncoder codeBalloonRect ifTrue: [ ^self drawBalloonRect: command ].	verbCode = CanvasEncoder codeOval ifTrue: [ ^self drawOval: command ].	verbCode = CanvasEncoder codeImage ifTrue: [ ^self drawImage: command ].	verbCode = CanvasEncoder codeReleaseCache ifTrue: [ ^self releaseImage: command ].	verbCode = CanvasEncoder codePoly ifTrue: [ ^self drawPoly: command ].	verbCode = CanvasEncoder codeStencil ifTrue: [ ^self drawStencil: command ].	verbCode = CanvasEncoder codeForce ifTrue: [ ^self forceToScreen: command withBlock: forceBlock ].	verbCode = CanvasEncoder codeFont ifTrue: [ ^self addFontToCache: command ].	verbCode = CanvasEncoder codeExtentDepth ifTrue: [ ^self extentDepth: command ].self error: 'unknown command: ', command first.! !!CanvasDecoder methodsFor: 'decoding' stamp: 'RAA 7/28/2000 17:13'!releaseImage: command	| cacheID |	CachedForms ifNil: [^self].	cacheID _ self class decodeInteger: (command at: 2).	CachedForms at: cacheID put: nil.! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 10/9/1999 20:28'!setClip: command	| clipRectEnc |	clipRectEnc _ command at: 2.	clipRect _ self class decodeRectangle: clipRectEnc! !!CanvasDecoder methodsFor: 'decoding' stamp: 'ls 10/9/1999 20:28'!setTransform: command	| transformEnc |	transformEnc _ command at: 2.	transform _ self class decodeTransform: transformEnc! !!CanvasDecoder methodsFor: 'attributes' stamp: 'ls 4/9/2000 14:29'!drawingForm	"return the form that we are drawing on behind thescenes"	^drawingCanvas form! !!CanvasDecoder methodsFor: 'shutting down' stamp: 'ls 4/9/2000 14:33'!delete	connection ifNotNil: [ connection destroy ].! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'RAA 7/25/2000 13:06'!decodeColor: string	| rgb a rgb1 rgb2 |	rgb1 := string getInteger32: 1.	rgb2 := string getInteger32: 5.	a := string getInteger32: 9.	rgb := rgb2 << 16 + rgb1.	a < 255		ifTrue: [ ^TranslucentColor basicNew setRgb: rgb  alpha: a/255.0 ]		ifFalse: [ ^Color basicNew setRGB: rgb ]! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'RAA 7/28/2000 08:33'!decodeFillStyle: string	^DataStream unStream: string! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'ls 3/27/2000 17:57'!decodeFont: fontString	^StrikeFont decodedFromRemoteCanvas: fontString! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'RAA 7/24/2000 13:36'!decodeImage: string	| bitsStart depth width height bits rs numColors colorArray |	bitsStart _ string indexOf: $|.	rs := ReadStream on: (string copyFrom: 1 to: bitsStart-1).	rs peek == $C ifTrue: [		rs next.		numColors _ Integer readFromString: (rs upTo: $,).		colorArray _ Array new: numColors.		1 to: numColors do: [ :i |			colorArray at: i put: (self decodeColor: (rs next: 12))		].	].	depth := Integer readFromString: (rs upTo: $,).	width :=  Integer readFromString: (rs upTo: $,).	height :=  Integer readFromString: (rs upToEnd).	bits _ Bitmap newFromStream: (		RWBinaryOrTextStream with: (string copyFrom: bitsStart+1 to: string size)	) binary reset.	colorArray ifNil: [		^Form extent: width@height depth: depth bits: bits	].	^(ColorForm extent: width@height depth: depth bits: bits)		colors: colorArray! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'ls 9/24/1999 20:10'!decodeInteger: string	^Integer readFromString: string! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'ls 3/27/2000 00:36'!decodePoint: string	| x y |	x := string getInteger32: 1.	y := string getInteger32: 5.	^x@y! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'ls 3/25/2000 23:02'!decodePoints: aString	^(aString findTokens: '|') asArray collect: [ :encPoint | self decodePoint: encPoint ]! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'ls 3/27/2000 22:24'!decodeRectangle: string	| x y cornerX cornerY |	x := string getInteger32: 1.	y := string getInteger32: 5.	cornerX := string getInteger32: 9.	cornerY := string getInteger32: 13.	^x@y corner: cornerX@cornerY! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'ls 10/9/1999 20:28'!decodeTransform: transformEnc	"decode an encoded transform"	^DisplayTransform fromRemoteCanvasEncoding: transformEnc! !!CanvasDecoder class methodsFor: 'instance creation' stamp: 'ls 4/9/2000 14:24'!connection: aConnection	^self new initialize;		connection: aConnection;		yourself! !!CanvasEncoder methodsFor: 'connection' stamp: 'RAA 8/1/2000 00:17'!backlog	^connection backlog! !!CanvasEncoder methodsFor: 'connection' stamp: 'ls 10/9/1999 18:20'!connection: aStringSocket	"set this connection to talk over the given socket"	connection _ aStringSocket! !!CanvasEncoder methodsFor: 'connection' stamp: 'ls 9/26/1999 15:47'!disconnect	connection ifNotNil: [		connection destroy.		connection _ nil.	].! !!CanvasEncoder methodsFor: 'connection' stamp: 'ls 9/26/1999 15:45'!isConnected	^connection notNil and: [ connection isConnected ]! !!CanvasEncoder methodsFor: 'clipping and transforming' stamp: 'ls 4/11/2000 18:59'!setClipRect: newClipRect	self sendCommand: {		String with: CanvasEncoder codeClip.		self class encodeRectangle: newClipRect }! !!CanvasEncoder methodsFor: 'clipping and transforming' stamp: 'ls 4/11/2000 18:59'!setTransform: newTransform	self sendCommand: {		String with: CanvasEncoder codeTransform.		self class encodeTransform: newTransform }! !!CanvasEncoder methodsFor: 'clipping and transforming' stamp: 'ls 10/9/1999 18:19'!updateTransform: aTransform andClipRect: aClipRect	"sets the given transform and clip rectangle, if they aren't already the ones being used"	aTransform = lastTransform ifFalse: [		self setTransform: aTransform.		lastTransform _ aTransform ].	aClipRect = lastClipRect ifFalse: [		self setClipRect: aClipRect.		lastClipRect _ aClipRect. ].! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 7/28/2000 07:54'!balloonFillRectangle: aRectangle fillStyle: aFillStyle	self sendCommand: {		String with: CanvasEncoder codeBalloonRect.		self class encodeRectangle: aRectangle.		self class encodeFillStyle: aFillStyle	}! !!CanvasEncoder methodsFor: 'drawing' stamp: 'ls 4/11/2000 18:59'!drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc	| encodedVertices |	encodedVertices := vertices collect: [ :vertex | self class encodePoint: vertex ].	self sendCommand: {		String with: CanvasEncoder codePoly.		self class encodeColor: aColor.		self class encodeInteger: bw.		self class encodeColor: bc},  encodedVertices .! !!CanvasEncoder methodsFor: 'drawing' stamp: 'ls 4/9/2000 14:39'!extent: newExtent  depth: newDepth	self sendCommand: {		self class codeExtentDepth asString.		self class encodePoint: newExtent. 		self class encodeInteger: newDepth.	}! !!CanvasEncoder methodsFor: 'drawing' stamp: 'ls 4/11/2000 18:59'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	self sendCommand: {		String with: CanvasEncoder codeOval.		self class encodeRectangle: r.		self class encodeColor: c.		self class encodeInteger: borderWidth.		self class encodeColor: borderColor	}! !!CanvasEncoder methodsFor: 'drawing' stamp: 'ls 4/11/2000 18:59'!forceToScreen: aRectangle	self sendCommand: {		String with: CanvasEncoder codeForce.		self class encodeRectangle: aRectangle }! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 7/28/2000 07:52'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor"(r extent = (276@272)) ifTrue: [Smalltalk at: #Q put: {r . fillColor . borderWidth . borderColor. thisContext longStack}]."	self sendCommand: {		String with: CanvasEncoder codeRect.		self class encodeRectangle: r.		self class encodeColor: fillColor.		self class encodeInteger: borderWidth.		self class encodeColor: borderColor }! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 7/29/2000 19:27'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	| cacheID cacheNew cacheReply formToSend cacheEntry t destRect visRect |	"first if we are only going to be able to draw a small part of the form,	it may be faster just to send the part of the form that will actually show up"	(aForm width * aForm height) > 20000 ifTrue: [		destRect _ aPoint extent: sourceRect extent.		(destRect intersects: lastClipRect) ifFalse: [			^NebraskaDebug at: #bigImage add: {lastClipRect. aPoint. sourceRect extent. 'skipped'}.		].		visRect _ destRect intersect: lastClipRect.		visRect area < (aForm boundingBox area // 20) ifTrue: [			NebraskaDebug 				at: #bigImage 				add: {lastClipRect. aPoint. sourceRect extent. 'reduced'. lastTransform}.			formToSend _ aForm copy: (visRect translateBy: sourceRect origin - aPoint).			^self 				image: formToSend 				at: visRect origin 				sourceRect: formToSend 				boundingBox rule: rule		].	].t _ Time millisecondsToRun: [	cacheID _ 0.	cacheNew _ 0.	formToSend _ aForm.	(aForm width * aForm height) > 5000 ifTrue: [		CachedObjects ifNotNil: [			(cacheReply _ self testCache: aForm) ifNotNil: [				cacheID _ cacheReply first.				cacheEntry _ cacheReply third.				cacheReply second ifTrue: [					cacheNew _ 1.				] ifFalse: [					cacheNew _ 0. "1 beep."					formToSend _ aForm deltaFrom: cacheEntry fourth.				].				cacheEntry at: 4 put: aForm deepCopy.			].		].	].	self sendCommand: {		String with: CanvasEncoder codeImage.		self class encodeImage: formToSend.		self class encodePoint: aPoint.		self class encodeRectangle: sourceRect.		self class encodeInteger: rule.		self class encodeInteger: cacheID.		self class encodeInteger: cacheNew.	}.].	(aForm width * aForm height) > 5000 ifTrue: [		NebraskaDebug at: #bigImage add: {lastClipRect. aPoint. sourceRect extent. t}.	].! !!CanvasEncoder methodsFor: 'drawing' stamp: 'ls 4/11/2000 18:59'!line: pt1  to: pt2  width: w  color: c	self sendCommand: {		String with: CanvasEncoder codeLine.		self class encodePoint: pt1.		self class encodePoint: pt2.		self class encodeInteger: w.		self class encodeColor: c	}! !!CanvasEncoder methodsFor: 'drawing' stamp: 'ls 4/11/2000 18:59'!stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor	self sendCommand: {		String with: CanvasEncoder codeStencil.		self class encodeImage: stencilForm.		self class encodePoint: aPoint.		self class encodeRectangle: sourceRect.		self class encodeColor: aColor }! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 7/29/2000 10:05'!testCache: anObject	| firstFree cachedObject newEntry |	CachedObjects ifNil: [^nil].	firstFree _ nil.	CachedObjects withIndexDo: [ :each :index |		cachedObject _ each first first.		cachedObject ifNil: [			firstFree ifNil: [firstFree _ index].			each second ifNotNil: [				2 to: each size do: [ :j | each at: j put: nil].				self sendCommand: {					String with: CanvasEncoder codeReleaseCache.					self class encodeInteger: index.				}.			].		] ifNotNil: [			cachedObject == anObject ifTrue: [				each at: 2 put: (each at: 2) + 1.				^{index. false. each}			].		].	].	firstFree ifNil: [^nil].	newEntry _ {		WeakArray with: anObject.		1.		Time millisecondClockValue.		nil.		anObject printString	}.	CachedObjects at: firstFree put: newEntry.	^{firstFree. true. newEntry}! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 7/22/2000 08:02'!testRectangleFillTiming| r fillColor borderWidth borderColor t |"CanvasEncoder new testRectangleFillTiming"	r _ 100@100 extent: 300@300.	fillColor _ Color blue.	borderWidth _ 1.	borderColor _ Color red.	t _ Time millisecondsToRun: [		1000 timesRepeat: [		{		String with: CanvasEncoder codeRect.		self class encodeRectangle: r.		self class encodeColor: fillColor.		self class encodeInteger: borderWidth.		self class encodeColor: borderColor }		].	].	t inspect.! !!CanvasEncoder methodsFor: 'drawing' stamp: 'ls 4/11/2000 18:59'!text: s bounds: boundsRect font: fontOrNil color: c	| fontIndex |	fontIndex := self establishFont: (fontOrNil ifNil: [ TextStyle defaultFont ]).	self sendCommand: {		String with: CanvasEncoder codeText.		s.		self class encodeRectangle: boundsRect.		self class encodeInteger: fontIndex.		self class encodeColor: c	}! !!CanvasEncoder methodsFor: 'private' stamp: 'RAA 7/28/2000 09:05'!sendCommand: stringArray	| bucket |	connection ifNil: [ ^self ].	connection isConnected ifFalse: [ ^self ].	connection nextPut: stringArray.		SentTypesAndSizes ifNil: [^self].	bucket _ SentTypesAndSizes at: stringArray first ifAbsentPut: [{0. 0. 0}].	bucket at: 1 put: (bucket at: 1) + 1.	bucket at: 2 put: (bucket at: 2) + (		stringArray inject: 4 into: [ :sum :array | sum + (array size + 4) ]	).	! !!CanvasEncoder methodsFor: 'network' stamp: 'ls 9/24/1999 19:52'!destroy	self disconnect.! !!CanvasEncoder methodsFor: 'network' stamp: 'ls 3/21/2000 23:22'!flush	connection ifNotNil: [		connection flush ]! !!CanvasEncoder methodsFor: 'network' stamp: 'ls 9/24/1999 19:52'!processIO	connection ifNil: [ ^self ].	connection isConnected ifFalse: [ ^self ].	connection processIO.! !!CanvasEncoder methodsFor: 'initialization' stamp: 'ls 3/27/2000 17:33'!initialize	fontCache := FontCache new: 5.! !!CanvasEncoder methodsFor: 'fonts' stamp: 'ls 3/27/2000 18:06'!establishFont: aFont	"make sure that the given font is in the fonts cache.  If it is not there already, then transmit it.  Either way, after this returns, the font is in the cache at the index specified by the return value"	| index |	(fontCache includesFont: aFont) ifTrue: [ ^fontCache indexOf: aFont ].	index := fontCache indexForNewFont: aFont.	self sendFont: aFont atIndex: index.	^index! !!CanvasEncoder methodsFor: 'fonts' stamp: 'ls 4/11/2000 18:59'!sendFont: aFont atIndex: index	"transmit the given fint to the other side"	self sendCommand: {		String with: CanvasEncoder codeFont.		self class encodeInteger: index.		self class encodeFont: aFont }.! !!CanvasEncoder class methodsFor: 'encoding' stamp: 'RAA 7/24/2000 13:24'!encodeColor: color		^color encodeForRemoteCanvas! !!CanvasEncoder class methodsFor: 'encoding' stamp: 'RAA 7/28/2000 07:53'!encodeFillStyle: aFillStyle		^aFillStyle encodeForRemoteCanvas! !!CanvasEncoder class methodsFor: 'encoding' stamp: 'ls 3/27/2000 17:57'!encodeFont: aFont	^aFont encodedForRemoteCanvas! !!CanvasEncoder class methodsFor: 'encoding' stamp: 'RAA 7/29/2000 12:40'!encodeImage: form		| t answer |	t _ Time millisecondsToRun: [answer _ form encodeForRemoteCanvas].	form boundingBox area > 5000 ifTrue: [		NebraskaDebug at: #FormEncodeTimes add: {t. form extent. answer size}	].			"answer size > 50000 ifTrue: [Smalltalk at: #Q2 put: thisContext longStack]."	^answer	"HandMorph>>restoreSavedPatchOn: is one culprit here"! !!CanvasEncoder class methodsFor: 'encoding' stamp: 'ls 3/26/2000 23:12'!encodeInteger: integer	^integer asInteger storeString! !!CanvasEncoder class methodsFor: 'encoding' stamp: 'RAA 7/28/2000 08:20'!encodePoint: point		^point encodeForRemoteCanvas! !!CanvasEncoder class methodsFor: 'encoding' stamp: 'RAA 7/31/2000 18:33'!encodeRectangle: rectangle	| x y encoded cornerX cornerY |(Smalltalk includesKey: #Q) ifFalse: [Smalltalk at: #Q put: thisContext longStack].	x _ rectangle origin x asInteger.	y _ rectangle origin y asInteger.	cornerX _ rectangle corner x asInteger.	cornerY _ rectangle corner y asInteger.	CanvasEncoder at: 2 count:  1.	encoded := String new: 16.	encoded putInteger32: x at: 1.	encoded putInteger32: y at: 5.	encoded putInteger32: cornerX at: 9.	encoded putInteger32: cornerY at: 13.	^encoded! !!CanvasEncoder class methodsFor: 'encoding' stamp: 'ls 10/9/1999 18:54'!encodeTransform: transform	^transform encodeForRemoteCanvas! !!CanvasEncoder class methodsFor: 'instance creation' stamp: 'ls 9/26/1999 16:22'!new	^super new initialize! !!CanvasEncoder class methodsFor: 'instance creation' stamp: 'ls 10/20/1999 21:17'!on: connection	^self new connection: connection! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:29'!aaaReadme	"these codes are used instead of strings, because String>>= was taking around 20% of the decoder's time"	! !!CanvasEncoder class methodsFor: 'codes' stamp: 'RAA 7/28/2000 07:43'!codeBalloonRect	^$R! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:34'!codeClip	^$A! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 4/9/2000 14:39'!codeExtentDepth	^$M! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:34'!codeFont	^$L! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:34'!codeForce	^$J! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:34'!codeImage	^$G! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:34'!codeLine	^$D! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:34'!codeOval	^$F! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:34'!codePoly	^$H! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:34'!codeRect	^$E! !!CanvasEncoder class methodsFor: 'codes' stamp: 'RAA 7/28/2000 16:50'!codeReleaseCache	^$z! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:34'!codeStencil	^$I! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:34'!codeText	^$C! !!CanvasEncoder class methodsFor: 'codes' stamp: 'ls 3/27/2000 22:35'!codeTransform	^$B! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 17:27'!at: anIndex count: anInteger	SimpleCounters ifNil: [(SimpleCounters _ Array new: 10) atAllPut: 0].	SimpleCounters at: anIndex put: (SimpleCounters at: anIndex) + anInteger.! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 15:48'!beginCaching	CachedObjects _ (1 to: 100) collect: [ :x | {WeakArray new: 1. nil. nil. nil}].! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 09:01'!beginStats	SentTypesAndSizes _ Dictionary new.! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 17:30'!clearTestVars"CanvasEncoder clearTestVars"	SimpleCounters _ nil! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 17:47'!explainTestVars"CanvasEncoder explainTestVars"	| answer total oneBillion data putter nReps |	SimpleCounters ifNil: [^1 beep].	total _ 0.	oneBillion _ 1000 * 1000 * 1000.	answer _ String streamContents: [ :strm |		data _ SimpleCounters copy.		putter _ [ :msg :index :nSec |			nReps _ data at: index.			total _ total + (nSec * nReps).			strm nextPutAll: nReps asStringWithCommas,' * ',nSec printString,' ',					(nSec * nReps / oneBillion roundTo: 0.01) printString,' secs for ',msg; cr		].		putter value: 'string socket' value: 1 value: 8000.		putter value: 'rectangles' value: 2 value: 40000.		putter value: 'points' value: 3 value: 18000.		putter value: 'colors' value: 4 value: 8000.	].	StringHolder new		contents: answer;		openLabel: 'put integer times'.! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 17:26'!inspectTestVars"CanvasEncoder inspectTestVars"	^SimpleCounters! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 09:01'!killStats	SentTypesAndSizes _ nil! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 09:09'!showStats"CanvasEncoder showStats"	| answer bucket |	SentTypesAndSizes ifNil: [^1 beep].	answer _ WriteStream on: String new.	SentTypesAndSizes keys asSortedCollection do: [ :each |		bucket _ SentTypesAndSizes at: each.		answer nextPutAll: each printString,' ',bucket first printString,'  ',bucket second asStringWithCommas; cr.	].	StringHolder new contents: answer contents; openLabel: 'send/receive stats'.! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 17:48'!timeSomeThings"CanvasEncoder timeSomeThings"	| s iter answer ms pt rect bm writer array color |	iter _ 1000000.	array _ Array new: 4.	color _ Color red.	answer _ String streamContents: [ :strm |		writer _ [ :msg :doer |			ms _ [iter timesRepeat: doer] timeToRun.			strm nextPutAll: msg,((ms * 1000 / iter) roundTo: 0.01) printString,' usec'; cr.		].		s _ String new: 4.		bm _ Bitmap new: 20.		pt _ 100@300.		rect _ pt extent: pt.	iter _ 1000000.		writer value: 'empty loop ' value: [self].		writer value: 'modulo ' value: [12345678 \\ 256].		writer value: 'bitAnd: ' value: [12345678 bitAnd: 255].		strm cr.	iter _ 100000.		writer value: 'putInteger ' value: [s putInteger32: 12345678 at: 1].		writer value: 'bitmap put ' value: [bm at: 1 put: 12345678].		writer value: 'encodeBytesOf: (big) ' value: [bm encodeInt: 12345678 in: bm at: 1].		writer value: 'encodeBytesOf: (small) ' value: [bm encodeInt: 5000 in: bm at: 1].		writer value: 'array at: (in) ' value: [array at: 1].		writer value: 'array at: (out) ' value: [array at: 6 ifAbsent: []].		strm cr.	iter _ 10000.		writer value: 'color encode ' value: [color encodeForRemoteCanvas].		writer value: 'pt encode ' value: [pt encodeForRemoteCanvas].		writer value: 'rect encode ' value: [self encodeRectangle: rect].		writer value: 'rect encode2 ' value: [rect encodeForRemoteCanvas].		writer value: 'rect encodeb ' value: [rect encodeForRemoteCanvasB].	].	StringHolder new contents: answer; openLabel: 'send/receive stats'.! !!Collection methodsFor: 'testing' stamp: 'ls 3/27/2000 17:25'!identityIncludes: anObject 	"Answer whether anObject is one of the receiver's elements."	self do: [:each | anObject == each ifTrue: [^true]].	^false! !!Bitmap methodsFor: 'filing' stamp: 'RAA 7/28/2000 08:40'!compressGZip	| ba hackwa hackba blt rowsAtATime sourceOrigin rowsRemaining bufferStream gZipStream |"just hacking around to see if further compression would help Nebraska"	bufferStream _ RWBinaryOrTextStream on: (ByteArray new: 5000).	gZipStream _ GZipWriteStream on: bufferStream.	ba _ nil.	rowsAtATime _ 20000.		"or 80000 bytes"	hackwa _ Form new hackBits: self.	sourceOrigin _ 0@0.	[(rowsRemaining _ hackwa height - sourceOrigin y) > 0] whileTrue: [		rowsAtATime _ rowsAtATime min: rowsRemaining.		(ba isNil or: [ba size ~= (rowsAtATime * 4)]) ifTrue: [			ba _ ByteArray new: rowsAtATime * 4.			hackba _ Form new hackBits: ba.			blt _ (BitBlt toForm: hackba) sourceForm: hackwa.		].		blt 			combinationRule: Form over;			sourceOrigin: sourceOrigin;			destX: 0 destY: 0 width: 4 height: rowsAtATime;			copyBits.		"bufferStream nextPutAll: ba."		sourceOrigin _ sourceOrigin x @ (sourceOrigin y + rowsAtATime).	].	gZipStream close.	^bufferStream contents! !!Bitmap methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 21:51'!copy	^self clone! !!Color methodsFor: 'printing' stamp: 'RAA 7/31/2000 17:25'!encodeForRemoteCanvas	| encoded |	CanvasEncoder at: 4 count:  1.	(encoded := String new: 12)		putInteger32: (rgb bitAnd: 16rFFFF) at: 1;		putInteger32: (rgb >> 16) at: 5;		putInteger32: self privateAlpha at: 9.	^encoded! !!Color methodsFor: 'private' stamp: 'ls 9/24/1999 20:04'!setRGB: rgb0	rgb == nil ifFalse: [self attemptToMutateError].	rgb _ rgb0! !!ConnectionQueue methodsFor: 'public' stamp: 'ls 9/26/1999 15:34'!isValid	^process notNil! !!DataStream class methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 08:38'!streamedRepresentationOf: anObject	| file |	file _ (RWBinaryOrTextStream on: (ByteArray new: 5000)).	file binary.	(self on: file) nextPut: anObject.	^file contents! !!DataStream class methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 08:33'!unStream: aString	^(self on: ((RWBinaryOrTextStream with: aString) reset; binary)) next! !!DisplayTransform methodsFor: 'encoding' stamp: 'ls 10/9/1999 18:56'!encodeForRemoteCanvas	"encode this transform into a string for use by a RemoteCanvas"	^self subclassResponsibility! !!CompositeTransform methodsFor: 'encoding' stamp: 'ls 3/19/2000 16:28'!encodeForRemoteCanvas	^String streamContents: [ :str |		str			nextPutAll: 'Composite,';			nextPutAll: '(';			nextPutAll: globalTransform encodeForRemoteCanvas;			nextPutAll: ')(';			nextPutAll: localTransform encodeForRemoteCanvas;			nextPutAll: ')' ]! !!DisplayTransform class methodsFor: 'instance creation' stamp: 'ls 3/19/2000 16:44'!fromRemoteCanvasEncoding: encoded	| type |	"decode a transform from the given encoded string"	type _ (ReadStream on: encoded) upTo: $,.	type = 'Morphic' ifTrue: [		^MorphicTransform fromRemoteCanvasEncoding: encoded ].	type = 'Matrix' ifTrue: [		^MatrixTransform2x3 fromRemoteCanvasEncoding: encoded ].	type = 'Composite' ifTrue: [		^CompositeTransform fromRemoteCanvasEncoding: encoded ].	^self error: 'invalid transform encoding'! !!CompositeTransform class methodsFor: 'instance creation' stamp: 'ls 3/19/2000 16:49'!fromRemoteCanvasEncoding: encoding	| firstStart firstEnd firstEncoding firstTransform secondStart secondEnd secondEncoding secondTransform |	"format: Composite,(enc1)(enc2)"	"decode the first encoding"	firstStart := encoding indexOf: $(.	firstStart = 0 ifTrue: [ self error: 'invalid encoding' ].	firstEnd := encoding findCloseParenthesisFor: firstStart.	firstEncoding := encoding copyFrom: firstStart+1 to: firstEnd-1.	firstTransform := DisplayTransform fromRemoteCanvasEncoding: firstEncoding.	"decode the second encoding"	secondStart := firstEnd + 1.	(encoding at: secondStart) = $( ifFalse: [ ^self error: 'invalid encoding' ].	secondEnd := encoding findCloseParenthesisFor: secondStart.	secondEncoding := encoding copyFrom: secondStart+1 to: secondEnd-1.	secondTransform := DisplayTransform fromRemoteCanvasEncoding: secondEncoding.		"put it together"	^self globalTransform: firstTransform localTransform: secondTransform! !!CompositeTransform class methodsFor: 'instance creation' stamp: 'ls 3/19/2000 16:44'!globalTransform: gt localTransform: lt	^self new globalTransform: gt localTransform: lt! !!FontCache methodsFor: 'initialization' stamp: 'ls 3/27/2000 17:23'!initialize: cacheSize	fonts := Array new: cacheSize.! !!FontCache methodsFor: 'lookups' stamp: 'ls 3/27/2000 17:28'!fontAt: index	"return the font associated with the given index"	^fonts at: index! !!FontCache methodsFor: 'lookups' stamp: 'ls 3/27/2000 17:25'!includesFont: aFont	"decide whether the given font is included in the collection"	^fonts identityIncludes: aFont	! !!FontCache methodsFor: 'lookups' stamp: 'ls 3/27/2000 17:28'!indexForNewFont: aFont	"add aFont to the cache.  Return its index.  The receiver will sometimes choose an index that is already used; that means that aFont is replacing the other font"	| index |	index := fonts size atRandom.      "random is simpler to manage than anything else"	fonts at: index put: aFont.	^index! !!FontCache methodsFor: 'lookups' stamp: 'ls 3/27/2000 17:25'!indexOf: aFont	"return the index for a given font"	^fonts identityIndexOf: aFont! !!FontCache class methodsFor: 'instance creation' stamp: 'ls 3/27/2000 17:33'!new: size	^super new initialize: size! !!Form methodsFor: 'displaying' stamp: 'RAA 8/1/2000 13:39'!displayInterpolatedIn: aRectangle on: aForm	"Display the receiver on aForm, using interpolation if necessary.		Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine |	self extent = aRectangle extent ifTrue:[^self displayOn: aForm at: aRectangle origin].	Smalltalk at: #B3DRenderEngine 		ifPresent:[:engineClass| engine _ (engineClass defaultForPlatformOn: aForm)].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aRectangle;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	"Otherwise use the 3D engine for our purposes"	engine viewport: aRectangle.	engine material: (B3DMaterial new emission: Color white).	engine texture: self.	engine render: (B3DIndexedQuadMesh new plainTextureRect).	engine finish.! !!Form methodsFor: 'fileIn/Out' stamp: 'ls 3/27/2000 00:21'!encodeForRemoteCanvas	| header binaryForm |	"encode into a bitstream for use with RemoteCanvas.  The format does not require invoking the Compiler"	header := String streamContents: [ :str |	str "nextPutAll: 'F|';"		nextPutAll: self depth printString;		nextPut: $,;		nextPutAll: self width printString;		nextPut: $,;		nextPutAll: self height printString;		nextPut: $|. ].	binaryForm := ByteArray streamContents: [ :str |		bits writeOn: str. ].	^header, binaryForm asString! !!Form methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 09:01'!addDeltasFrom: previousForm	(BitBlt 		destForm: self 		sourceForm: previousForm 		fillColor: nil 		combinationRule: Form reverse		destOrigin: 0@0		sourceOrigin: 0@0		extent: self extent 		clipRect: self boundingBox) copyBits.	^self! !!Form methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 09:01'!deltaFrom: previousForm	| newForm |	newForm _ previousForm deepCopy.	(BitBlt 		destForm: newForm 		sourceForm: self 		fillColor: nil 		combinationRule: Form reverse 		destOrigin: 0@0		sourceOrigin: 0@0		extent: self extent 		clipRect: self boundingBox) copyBits.	^newForm! !!Form methodsFor: 'as yet unclassified' stamp: 'RAA 8/1/2000 06:15'!deltaFrom: smallerForm at: offsetInMe	| newForm |	newForm _ smallerForm deepCopy.	(BitBlt 		destForm: newForm 		sourceForm: self 		fillColor: nil 		combinationRule: Form reverse 		destOrigin: 0@0		sourceOrigin: offsetInMe		extent: smallerForm extent 		clipRect: newForm boundingBox) copyBits.	^newForm! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'RAA 7/24/2000 13:32'!encodeForRemoteCanvas	"encode into a bitstream for use with RemoteCanvas."	| colorsToSend |	colorsToSend _ self colors.	^String streamContents: [ :str |		str			nextPut: $C;		"indicates color form"			nextPutAll: colorsToSend size printString;			nextPut: $,.		colorsToSend do: [ :each |			str nextPutAll: each encodeForRemoteCanvas		].		str nextPutAll: super encodeForRemoteCanvas	].! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'RAA 7/28/2000 07:39'!balloonFillRectangle: aRectangle fillStyle: aFillStyle	self asBalloonCanvas fillRectangle: aRectangle fillStyle: aFillStyle.! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'RAA 7/28/2000 08:15'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	| pattern |	self shadowColor ifNotNil:		[^self fillRectangle: aRectangle color: self shadowColor].	(aFillStyle isBitmapFill and:[aFillStyle isKindOf: InfiniteForm]) ifTrue:[		self flag: #fixThis.		self flag: #bob.		"maybe I fixed it"		^aFillStyle displayOnPort: (port clippedBy: aRectangle) at: aRectangle origin - origin		"^self fillRectangle: aRectangle color: aFillStyle"	].	(aFillStyle isSolidFill) 		ifTrue:[^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern _ aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead"	self balloonFillRectangle: aRectangle fillStyle: aFillStyle.! !!GradientFillStyle methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 08:37'!encodeForRemoteCanvas	^(DataStream streamedRepresentationOf: self) asString! !!HandMorph methodsFor: 'drawing' stamp: 'ls 4/3/2000 20:30'!hasChanged	"Return true if this hand has changed, either because it has moved or because some morph it is holding has changed."	^ hasChanged ifNil: [ true ]! !!InfiniteForm methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 08:07'!encodeForRemoteCanvas	self flag: #bob.		"need to do this""patternForm"! !!IntegerPokerPlugin methodsFor: 'as yet unclassified' stamp: 'ls 3/26/2000 23:51'!asCharacter: anInteger	^anInteger ! !!IntegerPokerPlugin methodsFor: 'as yet unclassified' stamp: 'ls 3/26/2000 23:51'!asInteger: aChar	^aChar ! !!IntegerPokerPlugin methodsFor: 'as yet unclassified' stamp: 'ls 3/27/2000 00:12'!cutOffForPositives	"return the largest positive integer that we can encode"	^1 << 30! !!IntegerPokerPlugin methodsFor: 'as yet unclassified' stamp: 'ls 3/27/2000 00:51'!getInteger	| stringOop stringData integer locationOop location |	self export: true.	self var: #stringData declareC: 'unsigned char *stringData'.	self var: #location declareC: 'int location'.	"decode the string to read it from"	stringOop := (interpreterProxy stackValue: 1).	(interpreterProxy isBytes: stringOop ) ifFalse: [		interpreterProxy success: false.  ^nil ].	stringData := (interpreterProxy arrayValueOf: stringOop).	"decode the location"	locationOop := (interpreterProxy stackValue: 0).	(interpreterProxy isIntegerValue: locationOop) ifFalse: [		interpreterProxy success: false.  ^nil ].	location := interpreterProxy integerValueOf: locationOop.	location := location - 1.	location < 0 ifTrue: [		interpreterProxy success: false. ^nil ].	"check that the string has room"	location + 4 > (interpreterProxy stSizeOf: stringOop) ifTrue: [		interpreterProxy success: false.  ^nil ].	"do the retrieval"	integer := (stringData at: location) asInteger << 24.	integer := (stringData at: location+1) asInteger << 16 + integer.	integer := (stringData at: location+2) asInteger << 8 + integer.	integer := (stringData at: location+3) asInteger + integer.	"convert it to a negative number, if it's too large"	integer > (self cutOffForPositives) ifTrue: [		integer := (self cutOffForPositives) - integer ].	"push the result"	interpreterProxy pop: 2.	interpreterProxy pushInteger: integer.! !!IntegerPokerPlugin methodsFor: 'as yet unclassified' stamp: 'ls 3/27/2000 00:05'!negated: anInteger	^-1 * anInteger! !!IntegerPokerPlugin methodsFor: 'as yet unclassified' stamp: 'ls 3/27/2000 00:51'!putInteger	| stringOop stringData integerOop integer locationOop location |	self export: true.	self var: #stringData declareC: 'unsigned char *stringData'.	self var: #location declareC: 'int location'.	"decode the string to store it into"	stringOop := (interpreterProxy stackValue: 2).	(interpreterProxy isBytes: stringOop ) ifFalse: [		interpreterProxy success: false.  ^nil ].	stringData := (interpreterProxy arrayValueOf: stringOop).	"decode the integer to be stored"	integerOop := (interpreterProxy stackValue: 1).	(interpreterProxy isIntegerValue: integerOop) ifFalse: [		interpreterProxy success: false.  ^nil ].	integer := interpreterProxy integerValueOf: integerOop.	"decode the location"	locationOop := (interpreterProxy stackValue: 0).	(interpreterProxy isIntegerValue: locationOop) ifFalse: [		interpreterProxy success: false.  ^nil ].	location := interpreterProxy integerValueOf: locationOop.	location := location - 1.	location < 0 ifTrue: [		interpreterProxy success: false. ^nil ].	"check that the string has room"	location + 4 > (interpreterProxy stSizeOf: stringOop) ifTrue: [		interpreterProxy success: false.  ^nil ].	"check that the integer is reasonably sized"	integer > (self cutOffForPositives) ifTrue: [		interpreterProxy success: false. ^nil ].	integer < (self cutOffForPositives) negated ifTrue: [		interpreterProxy success: false. ^ nil ].	"if the integer is negative, convert it to a large positive number"	integer < 0 ifTrue: [		integer := (self cutOffForPositives) - integer. ].	"do the copy"	stringData at: location+3 put: (integer \\ 256) asCharacter.	stringData at: location+2 put: (integer >> 8 \\ 256) asCharacter.	stringData at: location+1 put: (integer >> 16 \\ 256) asCharacter.	stringData at: location+0 put: (integer >> 24 \\ 256) asCharacter.	"all done"	interpreterProxy pop: 2! !!LoopbackStringSocket methodsFor: 'initialization' stamp: 'ls 3/18/2000 13:28'!associate: aLoopbackStringSocket	associate := aLoopbackStringSocket.	inArrays := OrderedCollection new.	outArrays := OrderedCollection new.! !!LoopbackStringSocket methodsFor: 'I/O' stamp: 'ls 3/21/2000 23:40'!flush! !!LoopbackStringSocket methodsFor: 'I/O' stamp: 'ls 3/18/2000 13:27'!isConnected	^true! !!LoopbackStringSocket methodsFor: 'I/O' stamp: 'RAA 7/22/2000 07:47'!nextOrNil	inArrays ifNil: [^nil].	inArrays isEmpty 		ifTrue: [ ^nil ]		ifFalse: [			^inArrays removeFirst. ]	! !!LoopbackStringSocket methodsFor: 'I/O' stamp: 'RAA 7/22/2000 08:55'!nextPut: aStringArray	inArrays ifNil: [^self].	outArrays add: aStringArray.	"WRITESTRINGSIZES ifNil: [WRITESTRINGSIZES _ Bag new].	aStringArray do: [ :each | WRITESTRINGSIZES add: each size]."! !!LoopbackStringSocket methodsFor: 'I/O' stamp: 'RAA 7/22/2000 07:48'!processIO	inArrays ifNil: [^self].	associate arraysFromAssociate: outArrays.	outArrays := OrderedCollection new.! !!LoopbackStringSocket methodsFor: 'private' stamp: 'RAA 7/22/2000 07:47'!arraysFromAssociate: arrays	"new string-arrays have arrived from our associate"	inArrays ifNil: [^self].	inArrays addAll: arrays.! !!LoopbackStringSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/22/2000 07:44'!destroy	associate _ inArrays _ outArrays _ nil.! !!LoopbackStringSocket class methodsFor: 'instance creation' stamp: 'ls 3/18/2000 13:24'!newPair	"create a connected pair of sockets"	| a b |	a := self new.	b := self new.	a associate: b.	b associate: a.	^{a. b}! !!LoopbackStringSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 7/22/2000 08:14'!clearStats	WRITESTRINGSIZES _ nil! !!LoopbackStringSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 7/22/2000 08:15'!stats	^WRITESTRINGSIZES! !!MatrixTransform2x3 methodsFor: 'encoding' stamp: 'ls 10/9/1999 19:03'!encodeForRemoteCanvas	"encode this transform into a string for use by a RemoteCanvas"	^String streamContents: [ :str |		str nextPutAll: 'Matrix,'.		1 to: 6 do: [ :i |			str print: (self basicAt: i).			str nextPut: $, ].	]! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ls 10/9/1999 19:51'!fromRemoteCanvasEncoding: encoded	"DisplayTransform fromRemoteCanvasEncoding:  'Matrix,1065353216,0,1137541120,0,1065353216,1131610112,'"	| nums transform encodedNums |	"split the numbers up"	encodedNums _ encoded findTokens: ','.	"remove the initial 'Matrix' specification"	encodedNums _ encodedNums asOrderedCollection.	encodedNums removeFirst.	"parse the numbers"	nums _ encodedNums collect: [ :enum |		Integer readFromString: enum ].	"create an instance"	transform _ self new.	"plug in the numbers"	nums doWithIndex: [ :num :i |		transform basicAt: i put: num ].	^transform! !!MorphicEvent methodsFor: 'private' stamp: 'ls 9/24/1999 19:12'!setMousePoint: aPoint buttons: anInteger lastEvent: lastEvent	cursorPoint _ aPoint.	buttons _ anInteger.	keyValue _ 0.	self anyButtonPressed ifTrue: [		lastEvent anyButtonPressed			ifTrue: [type _ #mouseMove]			ifFalse: [type _ #mouseDown].	] ifFalse: [		lastEvent anyButtonPressed			ifTrue: [type _ #mouseUp]			ifFalse: [type _ #mouseMove]].! !!MorphicEvent methodsFor: 'encoding' stamp: 'ls 4/11/2000 18:59'!encodedAsStringArray	"encode the receiver into an array of strings, such that it can be retrieved via the fromStringArray: class method"	^{		type.		CanvasEncoder encodePoint: cursorPoint.		CanvasEncoder encodeInteger: buttons.		CanvasEncoder encodeInteger: keyValue asInteger	}! !!MorphicEvent methodsFor: 'copying' stamp: 'ls 3/24/2000 22:02'!translatedBy: delta	"add delta to cursorPoint, and return the new event"	| newEvent |	newEvent := MorphicEvent new		setType: type		cursorPoint: cursorPoint+delta		buttons: buttons		keyValue: keyValue.	newEvent setSourceHand: sourceHand.	^newEvent! !!MorphicEvent methodsFor: 'as yet unclassified' stamp: 'ls 3/24/2000 22:02'!setSourceHand: aHand	sourceHand := aHand! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'ls 4/11/2000 19:00'!fromStringArray: array	"decode an event that was encoded with encodedAsStringArray"	| type cursorPoint buttons keyValue event |	type := (array at: 1) asSymbol.	cursorPoint := CanvasDecoder decodePoint: (array at: 2).	buttons := CanvasDecoder decodeInteger: (array at: 3).	keyValue := CanvasDecoder decodeInteger: (array at: 4).	event := MorphicEvent new.	event setType: type cursorPoint: cursorPoint buttons: buttons keyValue: keyValue.	^event! !!MorphicEventDecoder methodsFor: 'initialization' stamp: 'ls 3/24/2000 21:42'!connection: aConnection	connection := aConnection! !!MorphicEventDecoder methodsFor: 'handling messages' stamp: 'ls 3/25/2000 17:04'!apply: aStringArray to: aHand	"decode aStringArray, and apply the encoded command to aHand"	aStringArray first = 'event' ifTrue: [ ^self applyEventMessage: aStringArray to: aHand ].	aStringArray first = 'viewExtent' ifTrue: [ ^self applyViewExtentMessage: aStringArray to: aHand ].	^self error: 'unknown message type: ', aStringArray first! !!MorphicEventDecoder methodsFor: 'handling messages' stamp: 'ls 3/25/2000 16:53'!applyEventMessage: aStringArray to: aHand	| event |	event := MorphicEvent fromStringArray: (aStringArray copyFrom: 2 to: aStringArray size).	aHand queueEvent: event! !!MorphicEventDecoder methodsFor: 'handling messages' stamp: 'ls 3/25/2000 16:56'!applyMessagesTo: aHand	| msg |	"apply all queued events to the given hand"	"currently, there is no way to extract the rawmessages.  This is simply because I didn't feel like implementing individual classes for each message -lex"	[ msg := connection nextOrNil.  msg notNil ] whileTrue: [		self apply: msg to: aHand ].! !!MorphicEventDecoder methodsFor: 'handling messages' stamp: 'ls 4/11/2000 19:00'!applyViewExtentMessage: aStringArray to: aHand	| newViewExtent |	newViewExtent := CanvasDecoder decodePoint: aStringArray second.	aHand setViewExtent: newViewExtent! !!MorphicEventDecoder methodsFor: 'handling messages' stamp: 'ls 3/24/2000 22:54'!processIO	connection processIO! !!MorphicEventDecoder class methodsFor: 'instance creation' stamp: 'ls 3/24/2000 21:43'!on: aStringArray	^self basicNew connection: aStringArray! !!MorphicEventEncoder methodsFor: 'initialization' stamp: 'ls 3/24/2000 21:38'!connection: aConnection	connection := aConnection! !!MorphicEventEncoder methodsFor: 'network I/O' stamp: 'ls 3/24/2000 21:42'!flush	connection flush! !!MorphicEventEncoder methodsFor: 'network I/O' stamp: 'ls 3/24/2000 21:38'!processIO	connection processIO! !!MorphicEventEncoder methodsFor: 'network I/O' stamp: 'ls 3/26/2000 01:08'!sendEvent: anEvent	(anEvent isMouseMove and: [ anEvent = lastEventSent ]) ifTrue: [		"save on network traffic--don't send duplicate mouse moves"		^self ].	lastEventSent := anEvent.	connection nextPut: #('event'), anEvent encodedAsStringArray! !!MorphicEventEncoder methodsFor: 'network I/O' stamp: 'ls 4/11/2000 18:59'!sendViewExtent: newExtent	"inform the opposite side that our view extent has changed"		connection nextPut: { 'viewExtent'. CanvasEncoder encodePoint: newExtent }! !!MorphicEventEncoder class methodsFor: 'instance creation' stamp: 'ls 3/24/2000 21:43'!on: aStringArray	^self basicNew connection: aStringArray! !!MorphicTransform methodsFor: 'encoding' stamp: 'ls 10/9/1999 19:06'!encodeForRemoteCanvas	"encode this transform into a string for use by a RemoteCanvas"	^String streamContents: [ :str |		str nextPutAll: 'Morphic,';			print: offset x truncated;			nextPut: $,;			print: offset y truncated;			nextPut: $,;			print: scale;			nextPut: $,;			print: angle	]! !!MorphicTransform class methodsFor: 'instance creation' stamp: 'ls 3/27/2000 22:15'!fromRemoteCanvasEncoding: encoded	"DisplayTransform fromRemoteCanvasEncoding:  'Morphic,-88,-128,1.345165663873898,0.1352584843149221'"	| type offsetXEnc offsetYEnc scaleEnc angleEnc offsetX offsetY angle scale rs |	"separate the numbers"	rs := ReadStream on: encoded.	type := rs upTo: $,.	offsetXEnc := rs upTo: $,.	offsetYEnc := rs upTo: $,.	scaleEnc := rs upTo: $,.	angleEnc := rs upToEnd.	"decode the numbers"	offsetX _ Integer readFromString: offsetXEnc.	offsetY _ Integer readFromString: offsetYEnc.	scale _ Number readFromString: scaleEnc.	angle _ Number readFromString: angleEnc.	"create an instance"	^self offset: offsetX@offsetY angle: angle scale: scale! !!NebraskaClient methodsFor: 'network' stamp: 'ls 4/9/2000 14:43'!extent: newExtent  depth: newDepth	encoder extent: newExtent  depth: newDepth! !!NebraskaClient methodsFor: 'network' stamp: 'ls 3/25/2000 22:25'!isConnected	^connection isConnected! !!NebraskaClient methodsFor: 'network' stamp: 'ls 3/25/2000 22:25'!processIO	connection processIO.! !!NebraskaClient methodsFor: 'initialization' stamp: 'RAA 7/31/2000 19:10'!initialize: aConnection	connection := aConnection.	hand := RemoteControlledHandMorph on: (MorphicEventDecoder on: aConnection).	encoder := CanvasEncoder on: aConnection.	canvas := BufferedCanvas		"could return us a RemoteCanvas" 		connection: encoder		clipRect: (0@0 extent: 5000@5000)		transform: MorphicTransform identity! !!NebraskaClient methodsFor: 'attributes' stamp: 'ls 3/25/2000 22:27'!canvas	"return the hand this canvas that should be drawn on for this client"	^canvas! !!NebraskaClient methodsFor: 'attributes' stamp: 'ls 3/25/2000 22:27'!hand	"return the hand this client is controlling"	^hand! !!NebraskaClient methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 23:59'!backlog	^connection backlog! !!NebraskaClient class methodsFor: 'instance creation' stamp: 'ls 3/25/2000 22:28'!onConnection: aStringSocket	^self new initialize: aStringSocket! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 09:24'!at: queueName add: anArray	| collection now newData |	DEBUG ifNil: [^self].	collection _ DEBUG at: queueName ifAbsentPut: [OrderedCollection new].	now _ Time millisecondClockValue.	newData _ {now. 0},anArray.	collection isEmpty ifFalse: [newData at: 2 put: now - collection last first].	collection add: newData! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 09:02'!beginStats	DEBUG _ Dictionary new! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 09:03'!killStats	| prev |	prev _ DEBUG.	DEBUG _ nil.	prev explore.! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 09:03'!showStats	DEBUG ifNil: [^1 beep].	DEBUG explore.! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 10:13'!showStats: queueName	| collection |	DEBUG ifNil: [^1 beep].	collection _ DEBUG at: queueName ifAbsent: [^1 beep].	StringHolder new 		contents: (			String streamContents: [ :s | collection do: [ :each | s nextPutAll: each printString; cr]]		); 		openLabel: 'x'! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 13:08'!statsAt: queueName	DEBUG ifNil: [^nil].	^DEBUG at: queueName ifAbsent: [nil].! !!NebraskaServer methodsFor: 'initialization' stamp: 'ls 4/11/2000 19:48'!initialize	world := NebraskaPasteUpMorph new.	world beWorldForProject: Project newMorphic.	clients := IdentitySet new.	self extent: 800@600 depth: 16.! !!NebraskaServer methodsFor: 'initialization' stamp: 'RAA 7/20/2000 10:24'!initializeForWorld: aWorld	world _ aWorld.	clients _ IdentitySet new.	self extent: world extent depth: Display depth.! !!NebraskaServer methodsFor: 'networking' stamp: 'ls 3/25/2000 22:35'!acceptNewConnections	| connection |	listenQueue ifNil: [ ^self ].	[ clients size > 20 ifTrue: [ "too many connections!!" ^self ].	  connection := listenQueue getConnectionOrNil.  	  connection isNil ] 	whileFalse: [	  self addClientFromConnection: (StringSocket on: connection) ].! !!NebraskaServer methodsFor: 'networking' stamp: 'RAA 7/22/2000 07:23'!acceptNullConnection	| twins |	twins _ LoopbackStringSocket newPair.	self addClientFromConnection: twins first.	(NullTerminalMorph new connection: twins second) openInWorld.! !!NebraskaServer methodsFor: 'networking' stamp: 'RAA 7/20/2000 12:57'!acceptPhonyConnection	| twins |	twins _ LoopbackStringSocket newPair.	self addClientFromConnection: twins first.	(NetworkTerminalMorph new connection: twins second) inspect "openInWorld".! !!NebraskaServer methodsFor: 'networking' stamp: 'RAA 7/20/2000 10:03'!addClientFromConnection: connection	| client |	client := NebraskaClient onConnection: connection.	clients add: client.	client extent: world extent  depth: worldDepth.	world addRemoteClient: client.	self changed: #numClients.! !!NebraskaServer methodsFor: 'networking' stamp: 'RAA 8/1/2000 00:01'!backlog	^clients inject: 0 into: [ :max :each | max max: each backlog]! !!NebraskaServer methodsFor: 'networking' stamp: 'ls 3/25/2000 22:36'!processIO	self pruneDeadConnections.	self acceptNewConnections.! !!NebraskaServer methodsFor: 'networking' stamp: 'ls 4/11/2000 19:43'!pruneDeadConnections	| deadConnections |	deadConnections := clients select: [ :client | client isConnected not ].	deadConnections do: [ :client |		world removeRemoteCanvas: client canvas.		world removeHand: client hand. ].	deadConnections isEmpty ifTrue:[ ^self ].	clients removeAll: deadConnections.	self changed: #numClients.! !!NebraskaServer methodsFor: 'networking' stamp: 'ls 3/25/2000 22:31'!startListeningOnPort: portNumber	Socket initializeNetwork.	self stopListening.	listenQueue := ConnectionQueue portNumber: portNumber  queueLength: 5.! !!NebraskaServer methodsFor: 'networking' stamp: 'RAA 7/31/2000 22:28'!step	self processIO.	"savedWorld := Processor activeProcess world.	Processor activeProcess setWorld: world."	self flag: #bob.		"in this version, world is THE WORLD, so it steps itself"	"world doOneCycle."	"Processor activeProcess setWorld: savedWorld."	clients do: [ :each | each canvas apply: [ :ignore | ]].	"for modes that need a little push"! !!NebraskaServer methodsFor: 'networking' stamp: 'ls 3/25/2000 22:32'!stopListening	listenQueue ifNil: [ ^self ].	listenQueue destroy.	listenQueue := nil.! !!NebraskaServer methodsFor: 'attributes' stamp: 'ls 4/11/2000 19:48'!extent: newExtent  depth: newDepth	"modify the extent and/or depth of the shared world"	clients do: [ :client |		client extent: newExtent depth: newDepth ].	world extent: newExtent.	worldDepth := newDepth.! !!NebraskaServer methodsFor: 'attributes' stamp: 'ls 4/11/2000 18:41'!numClients	"return the number of connected clients"	^clients size! !!NebraskaServer methodsFor: 'attributes' stamp: 'ls 3/25/2000 23:13'!sharedWorld	^world! !!NebraskaServer class methodsFor: 'instance creation' stamp: 'ls 3/25/2000 22:39'!new	^super new initialize! !!NebraskaServer class methodsFor: 'instance creation' stamp: 'RAA 7/20/2000 10:24'!newForWorld: aWorld	^super new initializeForWorld: aWorld! !!NebraskaServer class methodsFor: 'as yet unclassified' stamp: 'RAA 7/24/2000 12:06'!defaultPort	^9091! !!NebraskaServerMorph methodsFor: 'initialization' stamp: 'ls 4/11/2000 18:44'!initialExtent	^200@25! !!NebraskaServerMorph methodsFor: 'initialization' stamp: 'RAA 8/1/2000 06:27'!initialize	super initialize.	self extent: self initialExtent.	self color: Color white.	slowCounter _ 0.! !!NebraskaServerMorph methodsFor: 'initialization' stamp: 'ls 4/11/2000 19:43'!server: aServer	server := aServer.	aServer addDependent: self.! !!NebraskaServerMorph methodsFor: 'stepping and presenter' stamp: 'ls 4/11/2000 19:46'!stepError: description  withReceiver: receiver	"assume the error was made by code in hte world itself, instead of in this morph.  Thus, don't stop stepping."	Processor activeProcess errorHandler: nil. "So we don't handle this guy twice"	receiver error: description.! !!NebraskaServerMorph methodsFor: 'stepping and presenter' stamp: 'ls 3/26/2000 01:22'!stepTime	^10! !!NebraskaServerMorph methodsFor: 'stepping and presenter' stamp: 'ls 4/11/2000 19:43'!update: aSymbol	aSymbol = #numClients ifTrue: [ ^self changed ].! !!NebraskaServerMorph methodsFor: 'structure' stamp: 'ls 4/3/2000 10:17'!delete	server stopListening.	super delete.! !!NebraskaServerMorph methodsFor: 'structure' stamp: 'RAA 8/1/2000 06:50'!step	server ifNil: [ ^self ].	server step.	(slowCounter _ (slowCounter ifNil: [0]) + 1 \\ 20) = 0 ifTrue: [		previousBacklog = server backlog ifFalse: [self changed]	].! !!NebraskaServerMorph methodsFor: 'drawing' stamp: 'RAA 8/1/2000 06:51'!drawOn: aCanvas	aCanvas clipBy: self bounds during: [ :c |		c fillColor: self color.		c			text: 'server with ', server numClients printString, ' clients  ',					(previousBacklog _ server backlog) printString			at: self position + (5@5)			font: nil			color: Color black.		c frameRectangle: self bounds color: Color black.	].! !!NebraskaServerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/24/2000 12:06'!serveWorld: aWorld	^self serveWorld: aWorld onPort: NebraskaServer defaultPort! !!NebraskaServerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/24/2000 12:05'!serveWorld: aWorld onPort: aPortNumber	| server |	server := NebraskaServer newForWorld: aWorld.	server startListeningOnPort: aPortNumber.	(self new server: server) openInWorld: aWorld.	"server acceptNullConnection"		"server acceptPhonyConnection."! !!NetworkTerminalMorph methodsFor: 'initialization' stamp: 'RAA 7/24/2000 11:35'!connection: aConnection	connection := aConnection.	decoder := CanvasDecoder connection: aConnection.	backgroundForm := Form extent: 100@100 depth: 32.	backgroundForm fillWhite.	eventEncoder := MorphicEventEncoder on: aConnection.! !!NetworkTerminalMorph methodsFor: 'initialization' stamp: 'RAA 7/24/2000 11:42'!initialize	super initialize.! !!NetworkTerminalMorph methodsFor: 'drawing' stamp: 'RAA 7/24/2000 11:43'!drawOn: aCanvas	backgroundForm ifNotNil: [		aCanvas clipBy: bounds during: [ :c |			c drawImage: backgroundForm at: bounds topLeft		].	].! !!NetworkTerminalMorph methodsFor: 'drawing' stamp: 'RAA 7/24/2000 11:43'!forceToFront: aRegion	"force the given region from the drawing form onto the background form"	self updateBackgroundForm.	backgroundForm		copy: aRegion		from: aRegion topLeft		in: decoder drawingForm		rule: Form over.	self invalidRect: (aRegion translateBy: bounds topLeft)! !!NetworkTerminalMorph methodsFor: 'drawing' stamp: 'RAA 7/24/2000 11:34'!updateBackgroundForm	"make sure that our background form matches what the server has most recently requested"	| drawingForm |	drawingForm := decoder drawingForm.	(drawingForm extent = backgroundForm extent and: [		drawingForm depth = backgroundForm depth ]) ifTrue: [			"they match just fine"			^self ].	"they don't match--make a new background form"	backgroundForm := Form extent: drawingForm extent  depth: drawingForm depth.	"resize ourself to match the form"	self extent: backgroundForm extent.! !!NetworkTerminalMorph methodsFor: 'stepping and presenter' stamp: 'RAA 8/1/2000 09:42'!step	decoder ifNil: [ ^self ].	decoder processIOOnForce: [ :rectangle |		self forceToFront: rectangle ].	enteringHand ifNotNil: [		self sendEvent: (			MorphicEvent new				setType: #mouseMove				cursorPoint: Sensor cursorPoint 				buttons: Sensor primMouseButtons 				keyValue: 0		)	].! !!NetworkTerminalMorph methodsFor: 'stepping and presenter' stamp: 'ls 3/25/2000 16:58'!stepTime	^10! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'ls 3/24/2000 21:48'!handlesMouseDown: evt	^true! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'ls 3/24/2000 22:10'!handlesMouseOver: evt	^true! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'ls 3/24/2000 22:34'!keyStroke: evt	self sendEvent: evt! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'ls 3/24/2000 21:48'!mouseDown: evt	self sendEvent: evt! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'RAA 8/1/2000 09:34'!mouseEnter: evt	evt hand newKeyboardFocus: self.	enteringHand _ evt hand.! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'RAA 8/1/2000 09:35'!mouseLeave: evt	enteringHand _ nil.! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'ls 3/24/2000 22:05'!mouseMove: evt	self sendEvent: evt! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'ls 3/24/2000 22:33'!mouseUp: evt	self sendEvent: evt! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'RAA 7/24/2000 11:44'!sendEvent: evt	eventEncoder ifNil: [ ^self ].	eventEncoder sendEvent: (evt translatedBy: bounds topLeft negated).! !!NetworkTerminalMorph methodsFor: 'geometry' stamp: 'RAA 7/24/2000 11:35'!extent: newExtent	super extent: newExtent.	eventEncoder sendViewExtent: self extent! !!NetworkTerminalMorph methodsFor: 'shutting down' stamp: 'ls 4/11/2000 18:36'!delete	super delete.	self disconnect.! !!NetworkTerminalMorph methodsFor: 'shutting down' stamp: 'ls 4/11/2000 18:36'!disconnect	connection ifNotNil: [ connection destroy ].	eventEncoder := connection := decoder := nil.! !!NetworkTerminalMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/25/2000 13:00'!areasRemainingToFill: aRectangle	"I assume that we are opaque"	^ aRectangle areasOutside: self bounds! !!NetworkTerminalMorph class methodsFor: 'instance creation' stamp: 'RAA 7/24/2000 12:08'!openAndConnectTo: serverHost	^self openAndConnectTo: serverHost port: NebraskaServer defaultPort! !!NetworkTerminalMorph class methodsFor: 'instance creation' stamp: 'RAA 7/25/2000 12:20'!openAndConnectTo: serverHost port: serverPort	| stringSock me |	stringSock _ self socketConnectedTo: serverHost port: serverPort.	me _ self new connection: stringSock.	me openInWorld."=== need to deal with the delete aspect first	AlignmentMorph newColumn		hResizing: 	#shrinkWrap;		vResizing: 	#shrinkWrap;		borderWidth: 8;		borderColor: Color blue;		addMorph: me;		openInWorld.==="! !!NetworkTerminalMorph class methodsFor: 'instance creation' stamp: 'RAA 7/24/2000 12:14'!socketConnectedTo: serverHost  port: serverPort	| sock |	Socket initializeNetwork.	sock _ Socket new.	sock connectTo: (NetNameResolver addressForName: serverHost) port: serverPort.	sock waitForConnectionUntil: Socket standardDeadline.	sock isConnected ifFalse: [ self error: 'could not connect to server' ].	^StringSocket on: sock! !!NullTerminalMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/22/2000 07:20'!drawOn: aCanvas	aCanvas fillRectangle: self bounds fillStyle: Color orange.	aCanvas frameRectangle: self bounds color: Color black! !!NullTerminalMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/22/2000 07:21'!extent: newExtent	| aPoint |	aPoint _ 50@50.	bounds extent = aPoint ifFalse: [		self changed.		bounds _ bounds topLeft extent: aPoint.		self layoutChanged.		self changed	].	eventEncoder sendViewExtent: newExtent! !!NullTerminalMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/22/2000 07:22'!forceToFront: aRegion	"force the given region from the drawing form onto the background form"	self updateBackgroundForm.! !!ObjectSocket methodsFor: 'stream protocol' stamp: 'ls 4/25/2000 18:48'!next	^inObjects removeFirst	! !!ObjectSocket methodsFor: 'stream protocol' stamp: 'ls 4/25/2000 18:48'!nextOrNil	inObjects isEmpty		ifTrue: [ ^nil ]		ifFalse: [ ^inObjects removeFirst ]! !!ObjectSocket methodsFor: 'stream protocol' stamp: 'ls 4/25/2000 18:48'!nextPut: anObject	outObjects addLast: anObject! !!ObjectSocket methodsFor: 'private-initialization' stamp: 'ls 4/25/2000 18:49'!initialize: aSocket	socket _ aSocket.	inBuf _ String new: 1000.	inBufIndex _ 1.	inBufLastIndex := 0.	outBuf _ nil.	inObjects _ OrderedCollection new.	outObjects _ OrderedCollection new.! !!ObjectSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/20/2000 15:10'!isConnected	^socket notNil and: [socket isConnected]! !!ObjectSocket methodsFor: 'as yet unclassified' stamp: 'ls 1/8/1999 16:14'!processIO	"do some as much network IO as possible"	self processOutput.	self processInput.! !!ArbitraryObjectSocket methodsFor: 'private' stamp: 'ls 4/25/2000 19:18'!encodeObject: object  into: buffer  startingAt: startIndex	"encode the given object into the given buffer"	| encoded |	encoded := self smartRefStreamEncode: object.	buffer putInteger32: encoded size at: startIndex.	buffer replaceFrom: startIndex+4 to: startIndex+4+(encoded size)-1 with: encoded.! !!ArbitraryObjectSocket methodsFor: 'private' stamp: 'ls 4/25/2000 19:19'!nextObjectLength	"read the next object length from inBuf.  Returns nil if less than 4 bytes are available in inBuf"	self inBufSize < 4 ifTrue: [ ^nil ].	^inBuf getInteger32: inBufIndex! !!ArbitraryObjectSocket methodsFor: 'private' stamp: 'ls 4/25/2000 19:34'!processInput	"recieve some data"	| inObjectData |	"read as much data as possible"	[ self isConnected and: [ socket dataAvailable ] ] whileTrue: [		self addToInBuf: socket getData. ].	"decode as many objects as possible"	[self nextObjectLength ~~ nil and: [ self nextObjectLength <= (self inBufSize + 4) ]] whileTrue: [		"a new object has arrived"		inObjectData _ inBuf copyFrom: (inBufIndex + 4) to: (inBufIndex + 3 + self nextObjectLength).		inBufIndex := inBufIndex + 4 + self nextObjectLength.		inObjects addLast: (RWBinaryOrTextStream with: inObjectData) reset fileInObjectAndCode ].	self shrinkInBuf.! !!ArbitraryObjectSocket methodsFor: 'private' stamp: 'ls 4/25/2000 19:33'!smartRefStreamEncode: anObject	| encodingStream |	"encode an object using SmartRefStream"	anObject == lastEncodedObject ifTrue: [		^encodingOfLastEncodedObject ].	encodingStream := RWBinaryOrTextStream on: ''.	encodingStream reset.	(SmartRefStream on: encodingStream) nextPut: anObject.		lastEncodedObject := anObject.	encodingOfLastEncodedObject := encodingStream contents.	^encodingOfLastEncodedObject! !!ArbitraryObjectSocket methodsFor: 'private' stamp: 'ls 4/25/2000 19:36'!spaceToEncode: anObject	"return the number of characters needed to encode the given object"	^ 4 + (self smartRefStreamEncode: anObject) size! !!ObjectSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 7/20/2000 15:47'!on: aSocket	^self basicNew initialize: aSocket! !!PasteUpMorph methodsFor: 'Nebraska' stamp: 'RAA 7/20/2000 10:07'!addRemoteClient: aClient	(worldState isKindOf: NebraskaWorldState) ifFalse: [		worldState _ worldState as: NebraskaWorldState	].	self addHand: aClient hand.	worldState addRemoteCanvas: aClient canvas.	self fullDrawOn: aClient canvas.	self changed.  "force a redraw"! !!PasteUpMorph methodsFor: 'Nebraska' stamp: 'RAA 8/1/2000 13:19'!removeRemoteCanvas: aCanvas	worldState removeRemoteCanvas: aCanvas.	worldState remoteCanvases isEmpty ifTrue: [		worldState _ worldState as: WorldState.		worldState canvas: nil	].! !!NebraskaPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'ls 3/25/2000 16:08'!addInitialHands	"Kentucky continues on even if no one is around to see it.  No hands are necessary"! !!NebraskaPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'ls 3/26/2000 00:49'!addRemoteCanvas: c	remoteCanvases add: c.	needToUpdateCanvas := true.! !!NebraskaPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/20/2000 10:02'!addRemoteClient: aClient	self addHand: aClient hand.	self addRemoteCanvas: aClient canvas.	self fullDrawOn: aClient canvas.	self changed.  "force a redraw"! !!NebraskaPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'ls 4/8/2000 22:36'!assuredCanvas	"never update the canvas"	| newCanvas |	(needToUpdateCanvas not and: [ self canvas notNil ]) ifTrue: [ ^self canvas ].	newCanvas := MultiCanvas new.	newCanvas depth: 32.	newCanvas extent: self extent.	remoteCanvases do: [ :c | newCanvas addCanvas: c ].	newCanvas := CachingCanvas on: newCanvas.	self canvas: newCanvas.	needToUpdateCanvas := false.	^newCanvas! !!NebraskaPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'ls 3/26/2000 00:43'!doDeferredUpdating	^false! !!NebraskaPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'ls 3/26/2000 00:49'!initialize	super initialize.	remoteCanvases := IdentitySet new.	needToUpdateCanvas := true.! !!NebraskaPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'ls 3/25/2000 15:46'!removeRemoteCanvas: c	remoteCanvases remove: c ifAbsent: []! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'RAA 7/28/2000 06:52'!balloonFillRectangle: aRectangle fillStyle: aFillStyle	self apply: [ :c | c balloonFillRectangle: aRectangle fillStyle: aFillStyle ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 19:59'!clipBy: newClipRect during: aBlock	self apply: [ :c |		c clipBy: newClipRect during: aBlock ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:02'!clipRect	| innerClipRect |	self apply: [ :c |		innerClipRect := c clipRect ].	^innerClipRect! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/26/2000 13:57'!contentsOfArea: aRectangle into: aForm	self apply: [ :c |		c contentsOfArea: aRectangle into: aForm ].	^aForm! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:01'!drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc	self apply: [ :c |		c drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:02'!extent	| extent |	self apply: [ :c |		extent := c extent ].	^extent! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:03'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	self apply: [ :clippedCanvas |		clippedCanvas fillOval: r color: c borderWidth: borderWidth borderColor: borderColor ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'RAA 7/28/2000 08:13'!fillRectangle: aRectangle fillStyle: aFillStyle	| pattern |	self shadowColor ifNotNil: [^self fillRectangle: aRectangle color: self shadowColor].	(aFillStyle isBitmapFill and:[aFillStyle isKindOf: InfiniteForm]) ifTrue:[		self flag: #bob.		"how do we do this here?"		^self"aFillStyle displayOnPort: (port clippedBy: aRectangle) at: aRectangle origin - origin"	].	aFillStyle isSolidFill ifTrue:[ ^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern _ aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead"	self balloonFillRectangle: aRectangle fillStyle: aFillStyle.! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:16'!flush	self apply: [ :c |		c flush ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:16'!flushDisplay	self apply: [ :c |		c flushDisplay ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'RAA 7/20/2000 16:49'!forceToScreen: rect	self apply: [ :c |		c forceToScreen: rect ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:04'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	self apply: [ :c |		c frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:30'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	self apply:  [ :c |		c image: aForm at: aPoint sourceRect: sourceRect rule: rule ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:31'!line: pt1 to: pt2 brushForm: brush	self apply: [ :c |		c line: pt1 to: pt2 brushForm: brush ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:31'!line: pt1 to: pt2 width: w color: c	self apply: [ :clippedCanvas |		clippedCanvas line: pt1 to: pt2 width: w color: c ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:32'!origin	| origin |	self apply: [ :c |		origin := c origin ].	^origin! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:32'!paintImage: aForm at: aPoint	self apply: [ :c |		c paintImage: aForm at: aPoint ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:32'!paintImage: aForm at: aPoint sourceRect: sourceRect	self apply: [ :c |		c paintImage: aForm at: aPoint sourceRect: sourceRect ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:33'!paragraph: paragraph bounds: bounds color: color	self apply: [ :c |		c paragraph: paragraph bounds: bounds color: color ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:34'!render: anObject	self apply: [ :c |		c render: anObject ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:14'!shadowColor: color	self apply: [ :c |		c shadowColor: color ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/25/2000 15:53'!showAt: pt invalidRects: updateRects	self apply: [ :c |		c showAt: pt invalidRects: updateRects ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:35'!stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor	self apply: [ :c |		c stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:35'!text: s bounds: boundsRect font: fontOrNil color: c	self apply: [ :clippedCanvas |		clippedCanvas text: s bounds: boundsRect font: fontOrNil color: c ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:35'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	self apply: [ :clippedCanvas |		clippedCanvas transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:37'!translateBy: aPoint clippingTo: aRect during: aBlock	self apply: [ :clippedCanvas |		clippedCanvas translateBy: aPoint clippingTo: aRect during: aBlock ]! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 20:37'!translateBy: delta during: aBlock	self apply: [ :clippedCanvas |		 clippedCanvas translateBy: delta during: aBlock ]! !!PluggableCanvas methodsFor: 'private' stamp: 'ls 3/20/2000 20:46'!apply: aBlock	"evaluate aBlock with a canvas to do a drawing command on.  See implementors for examples"! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 21:47'!apply: aBlock	self checkIfTimeToDisplay! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 8/1/2000 06:27'!checkIfTimeToDisplay	remote backlog > 0 ifTrue: [^self].	"why bother if network full?"	dirtyRect ifNil: [^self].	self sendDeltas.	lastTick _ Time millisecondClockValue.! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 20:44'!clipBy: aRectangle during: aBlock! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 19:14'!connection: connection  clipRect: newClipRect  transform: transform	remote _ RemoteCanvas new 		connection: connection 		clipRect: newClipRect 		transform: transform.	lastTick _ 0.! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 20:32'!drawMorph: x! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 22:36'!extent	^Display extent! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 8/1/2000 00:23'!forceToScreen: rect	dirtyRect _ dirtyRect ifNil: [rect] ifNotNil: [dirtyRect merge: rect].	self checkIfTimeToDisplay! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 22:36'!origin	^0@0! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 8/1/2000 06:35'!sendDeltas"NebraskaDebug showStats: #sendDeltas"	| t current deltas dirtyFraction |	previousVersion ifNil: [		previousVersion _ Display deepCopy.		remote 			image: previousVersion 			at: 0@0 			sourceRect: previousVersion boundingBox 			rule: Form paint.		^remote forceToScreen: previousVersion boundingBox.	].	dirtyRect ifNil: [^self].	t _ Time millisecondClockValue.	dirtyFraction _ dirtyRect area / previousVersion boundingBox area roundTo: 0.0001.	dirtyFraction > 0.75 ifTrue: [		"may be faster to do the whole thing"		dirtyRect _ previousVersion boundingBox.		current _ Display deepCopy.		deltas _ current deltaFrom: previousVersion.		previousVersion _ current.	] ifFalse: [		current _ Display copy: dirtyRect.		deltas _ previousVersion deltaFrom: current at: dirtyRect origin.		previousVersion copy: dirtyRect from: 0@0 in: current rule: Form over.	].	"bytes _ deltas encodeForRemoteCanvas."	remote 		image: deltas at: dirtyRect origin sourceRect: deltas boundingBox rule: Form reverse;		forceToScreen: dirtyRect.	t _ Time millisecondClockValue - t.	NebraskaDebug at: #sendDeltas add: {t. "bytes size." dirtyFraction}.	dirtyRect _ nil.! !!BufferedCanvas class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 20:31'!connection: connection  clipRect: clipRect  transform: transform	| new |	self enabled ifFalse: [		^RemoteCanvas connection: connection clipRect: clipRect transform: transform	].	new _ self new.	new connection: connection clipRect: clipRect transform: transform.	^new! !!BufferedCanvas class methodsFor: 'as yet unclassified' stamp: 'RAA 8/1/2000 07:24'!enabled	^BufferingEnabled ifNil: [true]! !!BufferedCanvas class methodsFor: 'as yet unclassified' stamp: 'RAA 8/1/2000 07:24'!enabled: aBoolean	BufferingEnabled _ aBoolean! !!CachingCanvas methodsFor: 'initialization' stamp: 'ls 4/8/2000 22:35'!mainCanvas: mainCanvas0	mainCanvas := mainCanvas0.	cacheCanvas := FormCanvas extent: mainCanvas extent depth: mainCanvas depth.! !!CachingCanvas methodsFor: 'canvas methods' stamp: 'RAA 7/20/2000 13:08'!allocateForm: extentPoint	^cacheCanvas form allocateForm: extentPoint! !!CachingCanvas methodsFor: 'canvas methods' stamp: 'ls 3/26/2000 13:35'!apply: aBlock	aBlock value: cacheCanvas.	aBlock value: mainCanvas.! !!CachingCanvas methodsFor: 'canvas methods' stamp: 'ls 3/27/2000 22:50'!contentsOfArea: area  into: aForm	^cacheCanvas contentsOfArea: area  into: aForm! !!CachingCanvas methodsFor: 'canvas methods' stamp: 'ls 3/26/2000 20:21'!form	^cacheCanvas form! !!CachingCanvas methodsFor: 'canvas methods' stamp: 'RAA 7/21/2000 09:54'!showAt: pt  invalidRects: rects	mainCanvas showAt: pt  invalidRects: rects! !!CachingCanvas class methodsFor: 'instance creation' stamp: 'ls 3/26/2000 13:37'!on: aCanvas	^super new mainCanvas: aCanvas! !!ClippingCanvas methodsFor: 'private' stamp: 'ls 3/20/2000 20:44'!apply: aBlock	"apply the given block to the inner canvas with clipRect as the clipping rectangle"	canvas clipBy: clipRect during: aBlock! !!ClippingCanvas methodsFor: 'initialization' stamp: 'ls 3/20/2000 20:44'!canvas: aCanvas  clipRect: aRectangle	canvas := aCanvas.	clipRect := aRectangle.! !!ClippingCanvas methodsFor: 'canvas methods' stamp: 'ls 3/25/2000 22:56'!clipRect	^clipRect! !!ClippingCanvas methodsFor: 'canvas methods' stamp: 'ls 3/26/2000 14:22'!contentsOfArea: aRectangle into: aForm	self flag: #hack.    "ignore the clipping specification for this command.  This is purely so that CachingCanvas will work properly when clipped.  There *has* to be a clean way to do this...."	^canvas contentsOfArea: aRectangle into: aForm! !!ClippingCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:17'!form	^canvas form! !!ClippingCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:17'!isBalloonCanvas	^canvas isBalloonCanvas! !!ClippingCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:18'!isShadowDrawing	^canvas isShadowDrawing! !!ClippingCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:15'!shadowColor	^canvas shadowColor! !!ClippingCanvas class methodsFor: 'instance creation' stamp: 'ls 3/20/2000 20:45'!canvas: aCanvas  clipRect: aRectangle	^self new canvas: aCanvas  clipRect: aRectangle! !!MultiCanvas methodsFor: 'initialization' stamp: 'RAA 8/1/2000 13:50'!allocateForm: extentPoint	"Allocate a new form which is similar to the receiver and can be used for accelerated blts"	^Form extent: extentPoint depth: self depth! !!MultiCanvas methodsFor: 'initialization' stamp: 'ls 4/8/2000 22:35'!depth	^depth! !!MultiCanvas methodsFor: 'initialization' stamp: 'ls 4/8/2000 22:35'!depth: newDepth	"set the extent to be used with this canvas"	depth := newDepth.! !!MultiCanvas methodsFor: 'initialization' stamp: 'ls 4/8/2000 22:35'!extent	^extent! !!MultiCanvas methodsFor: 'initialization' stamp: 'ls 4/8/2000 22:34'!extent: newExtent	"set the extent to be used with this canvas"	extent := newExtent.! !!MultiCanvas methodsFor: 'initialization' stamp: 'ls 4/8/2000 22:34'!initialize	canvases := Set new.	extent := 600@400.	depth := 32. ! !!MultiCanvas methodsFor: 'accessing' stamp: 'ls 3/20/2000 20:48'!addCanvas: aCanvas	canvases add: aCanvas! !!MultiCanvas methodsFor: 'accessing' stamp: 'ls 3/20/2000 20:48'!removeCanvas: aCanvas	canvases remove: aCanvas ifAbsent: []! !!MultiCanvas methodsFor: 'private' stamp: 'ls 3/20/2000 20:49'!apply: aCommand	canvases do: [ :canvas |		aCommand value: canvas ]! !!MultiCanvas class methodsFor: 'instance creation' stamp: 'ls 3/20/2000 20:49'!new	^super new initialize! !!NullCanvas methodsFor: 'private' stamp: 'ls 3/20/2000 21:10'!apply: aBlock	"do nothing"! !!NullCanvas methodsFor: 'private' stamp: 'ls 3/27/2000 21:41'!clipBy: region during: aBlock	"do this in order that timing runs work better"	aBlock value: self! !!NullCanvas methodsFor: 'private' stamp: 'ls 3/27/2000 21:39'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"do this in order that timing runs work better"	aBlock value: self! !!NullCanvas methodsFor: 'private' stamp: 'ls 3/27/2000 21:40'!translateBy: delta during: aBlock	"do this in order that timing runs work better"	aBlock value: self! !!NullCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:11'!clipRect	^1@1 extent: 99@99! !!NullCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:26'!copyClipRect: clipRect	"who cares what the clipping rectangle is?"	^self! !!NullCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:11'!extent	^100@100! !!NullCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:12'!form	^Form extent: self extent! !!NullCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:12'!isBalloonCanvas	^false! !!NullCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:13'!isShadowDrawing	^false! !!NullCanvas methodsFor: 'canvas methods' stamp: 'ls 3/20/2000 21:13'!origin	^0@0! !!Point methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 17:27'!encodeForRemoteCanvas	| encoded |	CanvasEncoder at: 3 count:  1.	encoded := String new: 8.	encoded putInteger32: x asInteger at: 1.	encoded putInteger32: y asInteger at: 5.	^encoded! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ls 3/27/2000 22:24'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than n elements have been read."	"Overriden for efficiency"	| max |	max _ (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position _ position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!Rectangle methodsFor: 'printing' stamp: 'RAA 7/31/2000 17:25'!encodeForRemoteCanvas	| encoded |	CanvasEncoder at: 2 count:  1.	encoded := String new: 16.	encoded putInteger32: origin x asInteger at: 1.	encoded putInteger32: origin y asInteger at: 5.	encoded putInteger32: corner x asInteger at: 9.	encoded putInteger32: corner y asInteger at: 13.	^encoded! !!Rectangle methodsFor: 'printing' stamp: 'RAA 7/31/2000 16:39'!encodeForRemoteCanvasB	| encoded |	encoded := Bitmap new: 4.	encoded at: 1 put: origin x asInteger.	encoded at: 2 put: origin y asInteger.	encoded at: 3 put: corner x asInteger.	encoded at: 4 put: corner y asInteger.	^encoded! !!RemoteCanvas methodsFor: 'initialization' stamp: 'ls 3/19/2000 15:57'!connection: connection0 clipRect: clipRect0 transform: transform0	connection _ connection0.	outerClipRect _ clipRect0.	transform _ transform0.	innerClipRect := transform globalBoundsToLocal: outerClipRect. ! !!RemoteCanvas methodsFor: 'drawing' stamp: 'RAA 7/28/2000 07:41'!balloonFillRectangle: aRectangle fillStyle: aFillStyle	self drawCommand: [ :executor |		executor balloonFillRectangle: aRectangle fillStyle: aFillStyle	].! !!RemoteCanvas methodsFor: 'drawing' stamp: 'ls 3/25/2000 22:44'!drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc	self drawCommand: [ :c |		c drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc ]! !!RemoteCanvas methodsFor: 'drawing' stamp: 'ls 10/9/1999 18:36'!fillOval: bounds color: color borderWidth: borderWidth borderColor: borderColor	"Fill the given oval."	self drawCommand: [ :executor |		executor fillOval: bounds color: color borderWidth: borderWidth borderColor: borderColor	].! !!RemoteCanvas methodsFor: 'drawing' stamp: 'ls 10/9/1999 18:35'!frameAndFillRectangle: bounds fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	"Draw the rectangle using the given attributes"	self drawCommand: [ :executor |		executor frameAndFillRectangle: bounds fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	].! !!RemoteCanvas methodsFor: 'drawing' stamp: 'ls 10/9/1999 18:38'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the given form."	self drawCommand: [ :executor |		executor image: aForm at: aPoint sourceRect: sourceRect rule: rule	].! !!RemoteCanvas methodsFor: 'drawing' stamp: 'ls 10/9/1999 18:25'!line: point1 to: point2 width: width color: color	"Draw a line using the given width and color"	self drawCommand: [ :executor |		executor line: point1 to: point2 width: width color: color ]! !!RemoteCanvas methodsFor: 'drawing' stamp: 'ls 3/26/2000 13:25'!stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	self drawCommand: [ :executor |		executor stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor ]! !!RemoteCanvas methodsFor: 'drawing' stamp: 'ls 3/27/2000 18:53'!text: text bounds: boundsRect font: fontOrNil color: color	"Draw the given string in the given font and color clipped to the given rectangle. If the font is nil, the default font is used."	"(innerClipRect intersects: (transform transformBoundsRect: boundsRect)) ifFalse: [ ^self ]."		"clip rectangles seem to be all screwed up...."	text isAllSeparators ifTrue: [ ^self ].   "is this correct??  it sure does speed things up!!"	self drawCommand: [ :executor |		executor text: text bounds: boundsRect font: fontOrNil color: color ]! !!RemoteCanvas methodsFor: 'private' stamp: 'ls 3/27/2000 18:50'!drawCommand: aBlock	"set up the connection for a drawing command, and then execute aBlock with the connection as an argument"	connection updateTransform: transform andClipRect: outerClipRect.	aBlock value: connection! !!RemoteCanvas methodsFor: 'drawing-support' stamp: 'ls 3/18/2000 13:15'!clipBy: aRectangle during: aBlock	| newCanvas |	"Set a clipping rectangle active only during the execution of aBlock."	newCanvas _ RemoteCanvas connection: connection clipRect: aRectangle transform: transform.	aBlock value: newCanvas! !!RemoteCanvas methodsFor: 'drawing-support' stamp: 'RAA 7/20/2000 17:47'!forceToScreen: rect		self drawCommand: [ :exec |			exec forceToScreen: rect ]! !!RemoteCanvas methodsFor: 'drawing-support' stamp: 'ls 3/26/2000 00:07'!showAt: pt invalidRects: updateRects	updateRects do: [ :rect |		self drawCommand: [ :exec |			exec forceToScreen: rect ] ]! !!RemoteCanvas methodsFor: 'drawing-support' stamp: 'RAA 7/26/2000 10:03'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	| newCanvas |	self flag: #bob.		"do tranform and clip work together properly?"	newCanvas := RemoteCanvas 		connection: connection 		clipRect: (aClipRect intersect: outerClipRect)		transform: (transform composedWith: aDisplayTransform).	aBlock value: newCanvas.! !!RemoteCanvas methodsFor: 'drawing-support' stamp: 'ls 3/26/2000 20:26'!translateBy: delta during: aBlock	self transformBy: (MorphicTransform offset: delta negated) clippingTo: outerClipRect during: aBlock smoothing: 1! !!RemoteCanvas methodsFor: 'misc' stamp: 'ls 3/21/2000 23:22'!flush	connection ifNotNil: [ connection flush ]! !!RemoteCanvas methodsFor: 'misc' stamp: 'ls 2/28/2000 00:16'!processIO	connection processIO! !!RemoteCanvas methodsFor: 'accessing' stamp: 'ls 3/19/2000 15:56'!clipRect	^innerClipRect! !!RemoteCanvas methodsFor: 'accessing' stamp: 'ls 4/8/2000 22:32'!contentsOfArea: aRectangle into: aForm	"this should never be called; normally, RemoteCanvas's are used in conjunction with a CachingCanvas"	aForm fillWhite.	^aForm! !!RemoteCanvas methodsFor: 'accessing' stamp: 'ls 4/8/2000 22:33'!extent	self flag: #hack.	^1500@1500! !!RemoteCanvas methodsFor: 'accessing' stamp: 'ls 4/8/2000 22:33'!origin	^0@0! !!RemoteCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 8/1/2000 08:17'!apply: ignored	"added for the convenience of BufferedCanvas"! !!RemoteCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 7/22/2000 09:59'!paragraph: paragraph bounds: bounds color: c	self flag: #bob.		"we need to fill this in"	self paragraph2: paragraph bounds: bounds color: c.! !!RemoteCanvas methodsFor: 'nil' stamp: 'RAA 8/1/2000 00:13'!backlog	^connection backlog! !!RemoteCanvas class methodsFor: 'instance creation' stamp: 'ls 10/20/1999 21:14'!connection: connection  clipRect: clipRect  transform: transform	^self new connection: connection clipRect: clipRect transform: transform! !!RemoteControlledHandMorph methodsFor: 'events' stamp: 'ls 3/25/2000 16:51'!processEvents	| |	eventDecoder processIO.	eventDecoder applyMessagesTo: self.! !!RemoteControlledHandMorph methodsFor: 'events' stamp: 'RAA 8/1/2000 09:34'!queueEvent: anEvent	"add an event to be handled"	"Q add: anEvent."	anEvent setSourceHand: self.	self handleEvent: anEvent! !!RemoteControlledHandMorph methodsFor: 'events' stamp: 'ls 3/25/2000 16:44'!setViewExtent: newExtent	"set the extent of this hand's view of the world"	viewExtent := newExtent! !!RemoteControlledHandMorph methodsFor: 'initialization' stamp: 'ls 3/24/2000 21:53'!decoder: aDecoder	eventDecoder := aDecoder! !!RemoteControlledHandMorph methodsFor: 'initialization' stamp: 'ls 3/25/2000 16:44'!initialize	super initialize.	viewExtent := 100@100.! !!RemoteControlledHandMorph methodsFor: 'queries' stamp: 'ls 3/25/2000 16:44'!worldBounds	^0@0 extent: viewExtent! !!RemoteControlledHandMorph class methodsFor: 'instance creation' stamp: 'ls 3/24/2000 21:53'!on: aDecoder	^super new initialize decoder: aDecoder! !!ScrollBar methodsFor: 'initialize' stamp: 'RAA 7/28/2000 10:08'!initializeDownButton	downButton := RectangleMorph		newBounds: (self innerBounds bottomRight - self buttonExtent extent: self buttonExtent)		color: Color lightGray.	downButton on: #mouseDown send: #scrollDownInit to: self.	downButton on: #mouseStillDown send: #scrollDown to: self.	downButton on: #mouseUp send: #borderRaised to: downButton.	downButton addMorphCentered: (ImageMorph new image: 		(self 			cachedImageAt: (bounds isWide ifTrue: ['right'] ifFalse: ['down']) 			ifAbsentPut: [				self upArrow8Bit					rotateBy: (bounds isWide ifTrue: [#right] ifFalse: [#pi])					centerAt: 0@0			]		)	).	downButton setBorderWidth: 1 borderColor: #raised.	self addMorph: downButton! !!ScrollBar methodsFor: 'initialize' stamp: 'RAA 7/28/2000 10:09'!initializeUpButton	upButton := RectangleMorph		newBounds: ((menuButton ifNil: [self innerBounds topLeft]				ifNotNil: [bounds isWide ifTrue: [menuButton bounds topRight]									ifFalse: [menuButton bounds bottomLeft]])					extent: self buttonExtent)		color: Color lightGray.	upButton on: #mouseDown send: #scrollUpInit to: self.	upButton on: #mouseStillDown send: #scrollUp to: self.	upButton on: #mouseUp send: #borderRaised to: upButton.	upButton addMorphCentered: (ImageMorph new image:		(self 			cachedImageAt: (bounds isWide ifTrue: ['left'] ifFalse: ['up'])			ifAbsentPut: [				bounds isWide ifTrue: [					self upArrow8Bit rotateBy: #left centerAt: 0@0				] ifFalse: [					self upArrow8Bit				]			]		)	).	upButton setBorderWidth: 1 borderColor: #raised.	self addMorph: upButton! !!ScrollBar methodsFor: 'initialize' stamp: 'RAA 7/28/2000 10:12'!upArrow8Bit	"convert to 8-bit and convert white to transparent to avoid gratuitous conversion every time we put one in an ImageMorph"	^UpArrow8Bit ifNil: [		UpArrow8Bit _ (ColorForm mappingWhiteToTransparentFrom: UpArrow) asFormOfDepth: 8	]! !!ScrollBar methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 09:40'!cachedImageAt: aKey ifAbsentPut: aBlock	CachedImages ifNil: [CachedImages _ Dictionary new].	^CachedImages at: aKey ifAbsentPut: aBlock! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'RAA 7/29/2000 09:00'!mouseMove: evt	"In the middle of drawing a stroke.  6/11/97 19:51 tk"	| pt |	pt _ evt cursorPoint.	(lastEvent ~~ nil and: [pt = lastEvent cursorPoint]) ifTrue: [^ self].	NebraskaDebug at: #sketch add: {action}.	self perform: action with: evt.		"Each action must do invalidRect:"	lastEvent _ evt.	false ifTrue: ["So senders will find the things performed here"		self paint: nil; fill: nil; areaFill: nil; erase: nil; pickup: nil; stamp: nil.		self rect: nil; ellipse: nil; polygon: nil; line: nil; star: nil].! !!StrikeFont methodsFor: 'accessing' stamp: 'ls 3/27/2000 19:54'!name	"Answer the receiver's name."	^name ifNil: ['(unnamed)']! !!StrikeFont methodsFor: 'file in/out' stamp: 'ls 3/27/2000 17:45'!encodedForRemoteCanvas	| stream |	stream := RWBinaryOrTextStream on: ''.	self writeAsStrike2On: stream.	^stream contents asString! !!StrikeFont methodsFor: 'file in/out' stamp: 'ls 3/27/2000 17:43'!writeAsStrike2On: file	"Write me onto a file in strike2 format.	fileName should be of the form: <family name><pointSize>.sf2"	file binary.	file nextInt32Put: 2.	file nextInt32Put: minAscii.	file nextInt32Put: maxAscii.	file nextInt32Put: maxWidth.	file nextInt32Put: ascent.	file nextInt32Put: descent.	file nextInt32Put: pointSize.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		file nextInt32Put: emphasis.	(minAscii + 1 to: maxAscii + 3) do:		[:index | file nextInt32Put: (xTable at: index)].	glyphs writeOn: file.	file close.! !!StrikeFont methodsFor: 'file in/out' stamp: 'ls 4/11/2000 18:57'!writeAsStrike2named: fileName	"Write me onto a file in strike2 format.	fileName should be of the form: <family name><pointSize>.sf2"	| file |	file _ FileStream fileNamed: fileName.	self writeAsStrike2On: file.	file close.! !!StrikeFont class methodsFor: 'instance creation' stamp: 'ls 3/27/2000 17:49'!decodedFromRemoteCanvas: aString	| stream |	stream := RWBinaryOrTextStream with: aString.	stream reset.	stream binary.	^self new readFromStrike2Stream: stream! !!String methodsFor: 'accessing' stamp: 'ls 3/19/2000 16:43'!findCloseParenthesisFor: startIndex	"assume (self at: startIndex) is $(.  Find the matching $), allowing parentheses to nest."	" '(1+(2-3))-3.14159' findCloseParenthesisFor: 1 "	" '(1+(2-3))-3.14159' findCloseParenthesisFor: 4 "	| pos nestLevel |	pos := startIndex+1.	nestLevel := 1.	[ pos <= self size ] whileTrue: [		(self at: pos) = $( ifTrue: [ nestLevel := nestLevel + 1 ].		(self at: pos) = $) ifTrue: [ nestLevel := nestLevel - 1 ].		nestLevel = 0 ifTrue: [ ^pos ].		pos := pos + 1.	].	^self size + 1! !!String methodsFor: 'encoding' stamp: 'RAA 7/22/2000 08:52'!getInteger32: location	| integer |	<primitive: 'getInteger' module: 'IntegerPokerPlugin'>	"^IntegerPokerPlugin doPrimitive: #getInteger"	"the following is about 7x faster than interpreting the plugin if not compiled"	integer := 		((self byteAt: location) bitShift: 24) +		((self byteAt: location+1) bitShift: 16) +		((self byteAt: location+2) bitShift: 8) +		(self byteAt: location+3).	integer > 1073741824 ifTrue: [		^1073741824 - integer ].	^integer! !!String methodsFor: 'encoding' stamp: 'RAA 7/22/2000 08:42'!primGetInteger32: location	<primitive: 'getInteger' module: 'IntegerPokerPlugin'>	^IntegerPokerPlugin doPrimitive: #getInteger! !!String methodsFor: 'encoding' stamp: 'RAA 7/22/2000 08:30'!primPutInteger32: anInteger at: location	| |	<primitive: 'putInteger' module: 'IntegerPokerPlugin'>	IntegerPokerPlugin doPrimitive: #putInteger! !!String methodsFor: 'encoding' stamp: 'RAA 7/31/2000 16:06'!putInteger32: anInteger at: location	| integer |	<primitive: 'putInteger' module: 'IntegerPokerPlugin'>	"IntegerPokerPlugin doPrimitive: #putInteger"	"the following is close to 20x faster than the above if the primitive is not compiled"	"PUTCOUNTER _ PUTCOUNTER + 1."	integer _ anInteger.	integer < 0 ifTrue: [integer :=  1073741824 - integer. ].	self byteAt: location+3 put: (integer \\ 256).	self byteAt: location+2 put: (integer bitShift: -8) \\ 256.	self byteAt: location+1 put: (integer bitShift: -16) \\ 256.	self byteAt: location put: (integer bitShift: -24) \\ 256."Smalltalk at: #PUTCOUNTER put: 0"! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/22/2000 09:14'!addToInBuf: aString	| newAlloc |	newAlloc _ aString size * 2 max: 8000.	inBuf ifNil: [		inBuf _ String new: newAlloc.		inBufIndex _ 1.		inBufLastIndex _ 0.	].	aString size > (inBuf size - inBufLastIndex) ifTrue: [		inBuf _ inBuf , (String new: newAlloc)	].	inBuf 		replaceFrom: inBufLastIndex + 1 		to: inBufLastIndex + aString size		with: aString 		startingAt: 1.	inBufLastIndex _ inBufLastIndex + aString size.! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/31/2000 17:24'!addToOutBuf: arrayToWrite	| size newAlloc |	size _ self spaceToEncode: arrayToWrite.	newAlloc _ size * 2 max: 8000.	"gives us room to grow"	outBuf ifNil: [		outBuf _ String new: newAlloc.		outBufIndex _ 1.	].	outBuf size - outBufIndex + 1 < size ifTrue: [		outBuf _ outBuf , (String new: newAlloc).	].	CanvasEncoder at: 1 count: arrayToWrite size + 1.	outBuf putInteger32: arrayToWrite size at: outBufIndex.	outBufIndex _ outBufIndex + 4.	arrayToWrite do: [ :each |		outBuf putInteger32: each size at: outBufIndex.		outBufIndex _ outBufIndex + 4.		outBuf 			replaceFrom: outBufIndex 			to: outBufIndex + each size - 1 			with: each 			startingAt: 1.		outBufIndex _ outBufIndex + each size.	].	^size! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/31/2000 23:58'!backlog	^outputQueue size! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/21/2000 09:51'!barf	self halt.	! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/22/2000 09:11'!gotSomething	numStringsInNextArray ifNil: [^self tryForNumStringsInNextArray ].	nextStringSize ifNil: [^ self tryForNextStringSize ].	^self tryForString! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/20/2000 15:55'!inBufNext: anInteger		| answer |	answer _ inBuf copyFrom: inBufIndex to: inBufIndex + anInteger - 1.	inBufIndex _ inBufIndex + anInteger.	^answer! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/20/2000 15:55'!inBufSize	inBuf ifNil: [^0].	^inBufLastIndex - inBufIndex + 1! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/29/2000 13:05'!processInput	| totalReceived chunkOfData |	"do as much input as possible"	self flag: #XXX.  "should have resource limits here--no more than X objects and Y bytes"	totalReceived _ 0.	[ self isConnected and: [ socket dataAvailable ]] whileTrue: [		chunkOfData _ socket getData.		self addToInBuf: chunkOfData.		totalReceived _ totalReceived + chunkOfData size.	].	totalReceived > 0 ifTrue: [		NebraskaDebug at: #SendReceiveStats add: {'GET'. totalReceived}.	].	[ self gotSomething ] whileTrue: [].		"decode as many string arrays as possible"	self shrinkInBuf.! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/29/2000 13:06'!processOutput	| arrayToWrite size bytesSent timeStartSending t itemsSent |	outBufIndex _ 1.	itemsSent _ bytesSent _ 0.	timeStartSending _ Time millisecondClockValue.	[outObjects isEmpty not and: [self isConnected]] whileTrue: [		arrayToWrite _ outObjects removeFirst.		t _ [size _ self addToOutBuf: arrayToWrite] timeToRun.		"NebraskaDebug at: #addToOutBuf: add: {arrayToWrite first. size. t}."		bytesSent _ bytesSent + size.		itemsSent _ itemsSent + 1.		outBufIndex > 10000 ifTrue: [self queueOutBufContents].	].	outBufIndex > 1 ifTrue: [self queueOutBufContents].	bytesSent > 0 ifTrue: [		t _ Time millisecondClockValue - timeStartSending.		NebraskaDebug at: #addToOutBuf: add: {'--done--'. bytesSent. t. itemsSent}.		NebraskaDebug at: #SendReceiveStats add: {'put'. bytesSent. t. itemsSent}.	].! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/29/2000 09:56'!queueOutBufContents	outputQueue nextPut: {outBuf. outBufIndex - 1}.	outBufIndex _ 1.	outBuf _ String new: 11000.	! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/22/2000 08:59'!sendDataCautiously: aStringOrByteArray bytesToSend: bytesToSend	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent. Try not to send too much at once since this seemed to cause problems talking to a port on the same machine"	| bytesSent count |	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		count _ socket 			sendSomeData: aStringOrByteArray 			startIndex: bytesSent + 1  			count: (bytesToSend - bytesSent min: 4000).		bytesSent _ bytesSent + count.		(Delay forMilliseconds: 5) wait.	].	^ bytesSent! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/22/2000 09:06'!shrinkInBuf	inBuf ifNil: [^self].	inBufLastIndex < inBufIndex ifTrue: [		inBufLastIndex _ 0.		inBufIndex _ 1.		inBuf size > 20000 ifTrue: [inBuf _ nil].	"if really big, kill it"		^self	].	inBuf _ inBuf copyFrom: inBufIndex to: inBufLastIndex.	inBufLastIndex _ inBuf size.	inBufIndex _ 1.! !!StringSocket methodsFor: 'private-IO' stamp: 'ls 4/25/2000 18:36'!spaceToEncode: anArray	"return the number of characters needed to encode the given string array"	^anArray inject: 4 into: [ :sum :array |		sum + (array size + 4) ].! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 8/1/2000 07:21'!transmitQueueNext	| bufTuple now elapsed slowElapsed waitTime |	slowNetworkTime ifNil: [slowNetworkTime _ Time millisecondClockValue].	bufTuple _ outputQueue next.	self sendDataCautiously: bufTuple first bytesToSend: bufTuple second.	"below is an aid in simulating slow networks"	false ifTrue: [		now _ Time millisecondClockValue.		slowNetworkCount _ (slowNetworkCount ifNil: [0]) + bufTuple second.		elapsed _ now - slowNetworkTime max: 1.		slowElapsed _ slowNetworkCount // 30.	"simulate 30kBytes/sec"		elapsed > 1000 ifTrue: [			elapsed < slowElapsed ifTrue: [				waitTime _ slowElapsed - elapsed.				NebraskaDebug at: #delays add: {waitTime. elapsed. slowNetworkCount}.				(Delay forMilliseconds: waitTime) wait			].			slowNetworkCount _ slowNetworkTime _ nil.		].	].	! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/22/2000 09:05'!tryForNextStringSize	"grab the size of the next string, if it's available"	self inBufSize >= 4 ifFalse: [^false].	nextStringSize _ inBuf getInteger32: inBufIndex.	"nextStringSize > 100000 ifTrue: [self barf]."	inBufIndex := inBufIndex + 4.	^true! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/22/2000 09:03'!tryForNumStringsInNextArray	"input numStringsInNextARray, if 4 bytes are available"	self inBufSize >= 4 ifFalse: [^false].	numStringsInNextArray := inBuf getInteger32: inBufIndex.	"(numStringsInNextArray > 100 or: [numStringsInNextArray < 1]) ifTrue: [self barf]."	inBufIndex := inBufIndex + 4.	stringsForNextArray _ Array new: numStringsInNextArray.	stringCounter _ 0.	nextStringSize _ nil. 	^true! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 7/22/2000 09:04'!tryForString	"try to grab an actual string"	self inBufSize >= nextStringSize ifFalse: [^false].	stringsForNextArray 		at: (stringCounter _ stringCounter + 1)		put: (self inBufNext: nextStringSize) asString.	stringCounter = numStringsInNextArray ifTrue: [	"we have finished another array!!"		inObjects addLast: stringsForNextArray.		stringCounter _ stringsForNextArray _ numStringsInNextArray _ nextStringSize _ nil.	] ifFalse: [	"still need more strings for this array"		nextStringSize _ nil.	].	^true! !!StringSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 09:44'!destroy	socketWriterProcess ifNotNil: [socketWriterProcess terminate. socketWriterProcess _ nil].	outputQueue _ nil.	socket ifNotNil: [socket destroy. socket _ nil.].! !!StringSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 09:48'!initialize: aSocket	super initialize: aSocket.	outputQueue _ SharedQueue new.	socketWriterProcess _ [		[true] whileTrue: [self transmitQueueNext]	] forkAt: Processor lowIOPriority.! !!StringSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 7/21/2000 09:37'!compareFiles"StringSocket compareFiles"	| data1 data2 |	data1 _ (FileStream fileNamed: 'Macintosh HD:bob:nebraska test:58984048.1')			contentsOfEntireFile.	data2 _ (FileStream fileNamed: 'BobsG3:squeak:dsqueak:DSqueak2.7 folder:58795431.3')			contentsOfEntireFile.	1 to: (data1 size min: data2 size) do: [ :i |		(data1 at: i) = (data2 at: i) ifFalse: [self halt].	].! !!StringSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 13:09'!showStats: timeIntervalInSeconds"StringSocket showStats: 10"	| answer dumpBucket bucketStart bucketEnd elapsed totalSent totalReceived stats |	stats _ (NebraskaDebug statsAt: #SendReceiveStats) ifNil: [^1 beep].	totalSent _ totalReceived _ 0.	bucketEnd _ bucketStart _ nil.	answer _ WriteStream on: String new.	dumpBucket _ [		elapsed _ (bucketEnd - bucketStart) max: 1.		answer 			nextPutAll: (bucketStart // 1000) printString,'  ';			nextPutAll: 'put = ',totalSent asStringWithCommas;			nextPutAll: '  ',(totalSent * 1000 / elapsed) rounded asStringWithCommas, '/sec';			nextPutAll: '     get = ',totalReceived asStringWithCommas;			nextPutAll: '  ',(totalReceived * 1000 / elapsed) rounded asStringWithCommas, '/sec';			cr.	].	stats copy do: [ :each |		bucketStart ifNil: [bucketEnd _ bucketStart _ each first].		each first - bucketStart > (timeIntervalInSeconds * 1000) ifTrue: [			dumpBucket value.			(each first - bucketEnd) > 10000 ifTrue: [				answer nextPutAll: '**gap of ',(each first - bucketEnd // 1000) asStringWithCommas,					' sec '; cr.			].			totalSent _ totalReceived _ 0.			bucketEnd _ bucketStart _ each first.		].		each third = 'GET' ifTrue: [			totalReceived _ totalReceived + each fourth.			bucketEnd _ each first + 10.		] ifFalse: [			totalSent _ totalSent + each fourth.			bucketEnd _ each first + each fifth.		].	].	bucketStart ifNotNil: dumpBucket.	StringHolder new contents: answer contents; openLabel: 'send/receive stats'.! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 7/20/2000 16:54'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: canvas].  "draw hands onto world canvas"	"*make this true to flash damaged areas for testing*"	false ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 7/20/2000 10:22'!doDeferredUpdatingFor: aWorld	| properDisplay |        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	properDisplay _ canvas notNil and: [canvas form == Display].	aWorld == World ifTrue: [  "this world fills the entire Display"		properDisplay ifFalse: [			aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"			self canvas: Display getCanvas.		]	] ifFalse: [  "this world is inside an MVC window"		(properDisplay and: [canvas clipRect = aWorld viewBox]) ifFalse: [			self canvas:				(Display getCanvas copyOffset: 0@0 clipRect: aWorld viewBox)		]	].	^ true! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 7/20/2000 16:54'!forceDamageToScreen: allDamage	"here for the convenience of NebraskaWorldState"	allDamage do: [:r | Display forceToScreen: r]! !!NebraskaWorldState methodsFor: 'as yet unclassified' stamp: 'RAA 7/20/2000 09:51'!addRemoteCanvas: c	self remoteCanvases add: c.	needToUpdateCanvas _ true.! !!NebraskaWorldState methodsFor: 'as yet unclassified' stamp: 'RAA 8/1/2000 13:50'!assuredCanvas	"never update the canvas"	| newCanvas |	(needToUpdateCanvas == false and: [ self canvas notNil ]) ifTrue: [ ^self canvas ].	newCanvas := MultiCanvas new.	newCanvas depth: 32.	newCanvas extent: viewBox extent.	self remoteCanvases do: [ :c | newCanvas addCanvas: c ].	newCanvas addCanvas: Display getCanvas.	"newCanvas := CachingCanvas on: newCanvas."	self canvas: newCanvas.	needToUpdateCanvas := false.	^newCanvas! !!NebraskaWorldState methodsFor: 'as yet unclassified' stamp: 'RAA 7/20/2000 16:20'!doDeferredUpdatingFor: aWorld	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	self assuredCanvas.	^true! !!NebraskaWorldState methodsFor: 'as yet unclassified' stamp: 'RAA 7/20/2000 16:56'!forceDamageToScreen: allDamage	"here for the convenience of NebraskaWorldState"	allDamage do: [:r | Display forceToScreen: r].	self remoteCanvases do: [ :each | allDamage do: [:r | each forceToScreen: r]].! !!NebraskaWorldState methodsFor: 'as yet unclassified' stamp: 'RAA 7/20/2000 09:45'!remoteCanvases	^remoteCanvases ifNil: [remoteCanvases _ IdentitySet new].! !!NebraskaWorldState methodsFor: 'as yet unclassified' stamp: 'RAA 7/22/2000 10:29'!removeRemoteCanvas: c	self remoteCanvases remove: c ifAbsent: [].	self canvas: nil.	"force withdrawal of remote from MultiCanvas"! !!StringSocket reorganize!('private-IO' addToInBuf: addToOutBuf: backlog barf gotSomething inBufNext: inBufSize processInput processOutput queueOutBufContents sendDataCautiously:bytesToSend: shrinkInBuf spaceToEncode: transmitQueueNext tryForNextStringSize tryForNumStringsInNextArray tryForString)('as yet unclassified' destroy initialize:)!!MultiCanvas reorganize!('initialization' allocateForm: depth depth: extent extent: initialize)('accessing' addCanvas: removeCanvas:)('private' apply:)('converting')!!BufferedCanvas reorganize!('as yet unclassified' apply: checkIfTimeToDisplay clipBy:during: connection:clipRect:transform: drawMorph: extent forceToScreen: origin sendDeltas)!!NetworkTerminalMorph reorganize!('initialization' connection: initialize)('drawing' drawOn: forceToFront: updateBackgroundForm)('stepping and presenter' step stepTime)('event handling' handlesMouseDown: handlesMouseOver: keyStroke: mouseDown: mouseEnter: mouseLeave: mouseMove: mouseUp: sendEvent:)('geometry' extent:)('shutting down' delete disconnect)('as yet unclassified' areasRemainingToFill:)!!MorphicEventDecoder reorganize!('initialization' connection:)('handling messages' apply:to: applyEventMessage:to: applyMessagesTo: applyViewExtentMessage:to: processIO)!!CanvasEncoder reorganize!('connection' backlog connection: disconnect isConnected)('clipping and transforming' setClipRect: setTransform: updateTransform:andClipRect:)('drawing' balloonFillRectangle:fillStyle: drawPolygon:color:borderWidth:borderColor: extent:depth: fillOval:color:borderWidth:borderColor: forceToScreen: frameAndFillRectangle:fillColor:borderWidth:borderColor: image:at:sourceRect:rule: line:to:width:color: stencil:at:sourceRect:color: testCache: testRectangleFillTiming text:bounds:font:color:)('private' sendCommand:)('network' destroy flush processIO)('initialization' initialize)('fonts' establishFont: sendFont:atIndex:)!!CanvasDecoder reorganize!('initialization' initialize)('network' connection: processIO processIOOnForce:)('decoding' addFontToCache: drawBalloonRect: drawCommand: drawImage: drawLine: drawOval: drawPoly: drawRect: drawStencil: drawText: extentDepth: forceToScreen:withBlock: processCommand:onForceDo: releaseImage: setClip: setTransform:)('attributes' drawingForm)('shutting down' delete)!"Postscript:"StringHolder new	textContents: NebraskaServer comment;		openLabel: 'Nebraska tips' andTerminate: false!