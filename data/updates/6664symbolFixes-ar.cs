'From Squeak3.8gamma of ''24 November 2004'' [latest update: #6662] on 26 April 2005 at 3:48:50 pm'!"Change Set:		SymbolFixes-arDate:			26 April 2005Author:			Andreas RaabSome more fixes for isMemberOf: Symbol."!!Object methodsFor: 'message handling' stamp: 'ar 4/25/2005 13:35'!perform: selector withArguments: argArray inSuperclass: lookupClass	"NOTE:  This is just like perform:withArguments:, except that	the message lookup process begins, not with the receivers's class,	but with the supplied superclass instead.  It will fail if lookupClass	cannot be found among the receiver's superclasses.	Primitive. Essential. See Object documentation whatIsAPrimitive."	<primitive: 100>	(selector isSymbol)		ifFalse: [^ self error: 'selector argument must be a Symbol'].	(selector numArgs = argArray size)		ifFalse: [^ self error: 'incorrect number of arguments'].	(self class == lookupClass or: [self class inheritsFrom: lookupClass])		ifFalse: [^ self error: 'lookupClass is not in my inheritance chain'].	self primitiveFailed! !!PDARecord methodsFor: 'as text' stamp: 'ar 4/25/2005 13:36'!readFrom: aText	| buffer tokenStream fieldName token |	tokenStream _ ReadStream on: (Scanner new scanTokens: aText asString).	buffer _ WriteStream on: (String new: 500).	fieldName _ nil.	self sharedFieldsWithBaseDo:		[:fields :instVarBase |  		[tokenStream atEnd] whileFalse:			[token _ tokenStream next.			((token isSymbol) and: [token endsWith: ':'])				ifTrue: [fieldName ifNotNil:							[self readField: fieldName fromString: buffer contents								fields: fields base: instVarBase].						buffer reset.  fieldName _ token allButLast]				ifFalse: [(token isSymbol)							ifTrue: [buffer nextPutAll: token; space]							ifFalse: [buffer print: token; space]]].		self readField: fieldName fromString: buffer contents			fields: fields base: instVarBase]! !!Player class methodsFor: 'housekeeping' stamp: 'ar 4/25/2005 13:36'!freeUnreferencedSubclasses	"Player classes may hold in their class instance variables referencesto instances of themselves that are housekeepingwise unreachable. Thismethod allows such loops to be garbage collected. This is done in threesteps:	1. Remove user-created subclasses from the 'subclasses' set and fromSmalltalk. Only remove classes whose name begins with 'Player' and whichhave no references.	2. Do a full garbage collection.	3. Enumerate all Metaclasses and find those whose soleInstance'ssuperclass is this class. Reset the subclasses set to this set ofclasses, and add back to Smalltalk."	"Player freeUnreferencedSubclasses"	| oldFree candidatesForRemoval class |	oldFree _ Smalltalk garbageCollect.	candidatesForRemoval _ self subclasses asOrderedCollection select:		[:aClass | (aClass name beginsWith: 'Player') and: [aClass nameendsWithDigit]].	"Break all system links and then perform garbage collection."	candidatesForRemoval do:		[:c | self removeSubclass: c.  "Break downward subclass pointers."		Smalltalk removeKey: c name ifAbsent: [].  "Break binding of globalname"].	candidatesForRemoval _ nil.	Smalltalk garbageCollect.  "Now this should reclaim all unusedsubclasses"	"Now reconstruct system links to subclasses with valid references."	"First restore any global references via associations"	(Association allSubInstances select:			[:assn | (assn key isSymbol)					and: [(assn key beginsWith: 'Player')					and: [assn key endsWithDigit]]])		do: [:assn | class _ assn value.			(class isKindOf: self class) ifTrue:				[self addSubclass: class.				Smalltalk add: assn]].	"Then restore any further direct references, creating newassociations."	(Metaclass allInstances select:			[:m | (m soleInstance name beginsWith: 'Player')					and: [m soleInstance name endsWithDigit]])		do: [:m | class _ m soleInstance.			((class isKindOf: self class) and: [(Smalltalk includesKey: classname) not]) ifTrue:				[self addSubclass: class.				Smalltalk at: class name put: class]].	SystemOrganization removeMissingClasses.	^ Smalltalk garbageCollect - oldFree! !!SystemNavigation methodsFor: 'query' stamp: 'ar 4/25/2005 13:33'!allCallsOn: aLiteral 	"Answer a Collection of all the methods that call on aLiteral even deeply embedded in 	literal array."	"self new browseAllCallsOn: #open:label:."	| aCollection special thorough aList byte |	aCollection _ OrderedCollection new.	special _ Smalltalk				hasSpecialSelector: aLiteral				ifTrueSetByte: [:b | byte _ b].	thorough _ (aLiteral isSymbol)				and: ["Possibly search for symbols imbedded in literal arrays"					Preferences thoroughSenders].	Cursor wait		showWhile: [self				allBehaviorsDo: [:class | 					aList _ thorough								ifTrue: [class										thoroughWhichSelectorsReferTo: aLiteral										special: special										byte: byte]								ifFalse: [class										whichSelectorsReferTo: aLiteral										special: special										byte: byte].					aList						do: [:sel | sel == #DoIt								ifFalse: [aCollection										add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^ aCollection! !!SystemNavigation methodsFor: 'query' stamp: 'ar 4/25/2005 13:33'!allSentMessagesWithout: classesAndMessagesPair 	"Answer the set of selectors which are sent somewhere in the system,  	computed in the absence of the supplied classes and messages."	| sent absentClasses absentSelectors |	sent _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	absentSelectors _ classesAndMessagesPair second.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:.	"sd 29/04/03"	Cursor execute		showWhile: [Smalltalk classNames				do: [:cName | ((absentClasses includes: cName)						ifTrue: [{}]						ifFalse: [{Smalltalk at: cName. (Smalltalk at: cName) class}])						do: [:cl | (absentSelectors isEmpty								ifTrue: [cl selectors]								ifFalse: [cl selectors copyWithoutAll: absentSelectors])								do: [:sel | "Include all sels, but not if sent by self"									(cl compiledMethodAt: sel) literals										do: [:m | 											(m isSymbol)												ifTrue: ["might be sent"													m == sel														ifFalse: [sent add: m]].											(m isMemberOf: Array)												ifTrue: ["might be performed"													m														do: [:x | (x isSymbol)																ifTrue: [x == sel																		ifFalse: [sent add: x]]]]]]]].			"The following may be sent without being in any literal frame"			1				to: Smalltalk specialSelectorSize				do: [:index | sent						add: (Smalltalk specialSelectorAt: index)]].	Smalltalk presumedSentMessages		do: [:sel | sent add: sel].	^ sent! !