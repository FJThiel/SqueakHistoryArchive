'From Squeak2.9alpha of 13 June 2000 [latest update: #2411] on 18 June 2000 at 11:01:03 am'!"Change Set:		151NoFIBMorph-smaDate:			18 June 2000Author:			Stefan Matthias AustRemove direct references to FillInTheBlankMorph and replace them to call to FillInTheBlank which will do the dispatch based on 'Smalltalk isMorphic'. Ialso refactored the FIB class to reduce copy'n'pasteness.The changes help to correctly discard MVC and/or Morphic."!!CipherPanel methodsFor: 'menu' stamp: 'sma 6/18/2000 10:32'!enterANewCipher	self encodedQuote:		(FillInTheBlank request: 'Type a cipher text to work on here below...')! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'sma 6/18/2000 10:33'!readTape	(Smalltalk		at: #RequestBoxMorph		ifAbsent:			[^ self readTape:				(FillInTheBlank					request: 'Tape to read'					initialAnswer: 'tapeName.tape')])		request: 'Tape to read'		respondTo: self		selector: #readTape:! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'sma 6/18/2000 10:34'!writeTape	| args b |	args _ (b _ self button: 'writeTape') isNil				ifTrue: [#()]				ifFalse: [b arguments].	(args size > 0 and: [args first size > 0])		ifTrue: [args first.				self writeTape: args first]		ifFalse: [(Smalltalk					at: #RequestBoxMorph					ifAbsent:						[^ self writeTape:							(FillInTheBlank								request: 'Tape to write'								initialAnswer: 'tapeName.tape')])						request: 'Tape to write'						respondTo: self						selector: #writeTape:]! !!FileDirectory class methodsFor: 'name utilities' stamp: 'sma 6/17/2000 00:11'!searchAllFilesForAString	"Prompt the user for a search string, and a starting directory. Search the contents of all files in the starting directory and its subdirectories for the search string (case-insensitive search.)	List the paths of files in which it is found on the Transcript.	By Stewart MacLean 5/00; subsequently moved to FileDirectory class-side, and refactored to call FileDirectory.filesContaining:caseSensitive:"	| searchString dir |	searchString _ FillInTheBlank request: 'Enter search string'.	searchString isEmpty ifTrue: [^nil].	Transcript cr; show: 'Searching for ', searchString printString, ' ...'.	(dir _ PluggableFileList getFolderDialog open) ifNotNil:		[(dir filesContaining: searchString caseSensitive: false) do:				[:pathname | Transcript cr; show: pathname]].	Transcript cr; show: 'Finished searching for ', searchString printString	"FileDirectory searchAllFilesForAString"! !!FillInTheBlank methodsFor: 'private' stamp: 'sma 6/18/2000 10:54'!show: fillInView	| savedArea |	savedArea _ Form fromDisplay: fillInView displayBox.	fillInView display.	contents isEmpty		ifFalse: [fillInView lastSubView controller selectFrom: 1 to: contents size].	(fillInView lastSubView containsPoint: Sensor cursorPoint)		ifFalse: [fillInView lastSubView controller centerCursorInView].	fillInView controller startUp.	fillInView release.	savedArea displayOn: Display at: fillInView viewport topLeft.	^ contents! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'sma 6/18/2000 10:56'!multiLineRequest: queryString centerAt: aPoint initialAnswer: defaultAnswer answerHeight: answerHeight	"Create a multi-line instance of me whose question is queryString with	the given initial answer. Invoke it centered at the given point, and	answer the string the user accepts.  Answer nil if the user cancels.  An	empty string returned means that the ussr cleared the editing area and	then hit 'accept'.  Because multiple lines are invited, we ask that the user	use the ENTER key, or (in morphic anyway) hit the 'accept' button, to 	submit; that way, the return key can be typed to move to the next line.	NOTE: The ENTER key does not work on Windows platforms."	"FillInTheBlank		multiLineRequest:'Enter several lines; end input by acceptingor canceling via menu or press Alt+s/Alt+l'		centerAt: Display center		initialAnswer: 'Once upon a time...'		answerHeight: 200"	| model fillInView |	Smalltalk isMorphic		ifTrue:			[^ self fillInTheBlankMorphClass				request: queryString				initialAnswer: defaultAnswer				centerAt: aPoint				inWorld: self currentWorld				onCancelReturn: nil				acceptOnCR: false].	model _ self new initialize.	model contents: defaultAnswer.	model responseUponCancel: nil.	model acceptOnCR: false.	fillInView _		self fillInTheBlankViewClass			multiLineOn: model			message: queryString			centerAt: aPoint			answerHeight: answerHeight.	^ model show: fillInView! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'sma 6/18/2000 10:27'!request: queryString 	"Create an instance of me whose question is queryString. Invoke it 	centered at the cursor, and answer the string the user accepts. Answer 	the empty string if the user cancels."	"FillInTheBlank request: 'Your name?'"	^ self		request: queryString		initialAnswer: ''		centerAt: Sensor cursorPoint! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'sma 6/18/2000 10:28'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given 	initial answer. Invoke it centered at the given point, and answer the 	string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank 		request: 'What is your favorite color?' 		initialAnswer: 'red, no blue. Ahhh!!'"	^ self		request: queryString		initialAnswer: defaultAnswer		centerAt: Sensor cursorPoint! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'sma 6/18/2000 10:53'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint	"Create an instance of me whose question is queryString with the given	initial answer. Invoke it centered at the given point, and answer the	string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| model fillInView |	Smalltalk isMorphic		ifTrue:			[^ self fillInTheBlankMorphClass				request: queryString				initialAnswer: defaultAnswer				centerAt: aPoint].	model _ self new initialize.	model contents: defaultAnswer.	fillInView _		self fillInTheBlankViewClass			on: model			message: queryString			centerAt: aPoint.	^ model show: fillInView! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'sma 6/18/2000 10:57'!requestPassword: queryString	"Create an instance of me whose question is queryString. Invoke it centered	at the cursor, and answer the string the user accepts. Answer the empty 	string if the user cancels."	"FillInTheBlank requestPassword: 'POP password'"	| model fillInView |	Smalltalk isMorphic		ifTrue: [^ self fillInTheBlankMorphClass requestPassword: queryString].	model _ self new initialize.	model contents: ''.	fillInView _		self fillInTheBlankViewClass			requestPassword: model			message: queryString			centerAt: Sensor cursorPoint			answerHeight: 40.	^ model show: fillInView! !!FillInTheBlank class methodsFor: 'private' stamp: 'sma 6/18/2000 10:39'!fillInTheBlankMorphClass	"By factoring out this class references, it becomes possible to discard 	morphic by simply removing this class.  All calls to this method needs	to be protected by 'Smalltalk isMorphic' tests."	^ FillInTheBlankMorph! !!FillInTheBlank class methodsFor: 'private' stamp: 'sma 6/18/2000 10:47'!fillInTheBlankViewClass	"By factoring out this class references, it becomes possible to discard 	MVC by simply removing this class.  All calls to this method needs	to be protected by 'Smalltalk isMorphic' tests."	^ FillInTheBlankView! !!GraphicalDictionaryMenu methodsFor: 'as yet unclassified' stamp: 'sma 6/18/2000 10:36'!renameEntry	| reply curr |	reply _ FillInTheBlank		request: 'New key? '		initialAnswer: (curr _ entryNames at: currentIndex)		centerAt: self center.	(reply isEmptyOrNil or: [reply = curr]) ifTrue: [^ self beep].	(baseDictionary includesKey: reply) ifTrue:		[^ self inform: 'sorry that conflicts withthe name of anotherentry in this dictionary'].	baseDictionary at: reply put: (baseDictionary at: curr).	baseDictionary removeKey: curr.	self baseDictionary: baseDictionary.	self updateThumbnail! !!ReferenceMorph methodsFor: 'menu' stamp: 'sma 6/18/2000 10:36'!changeTabText	| reply |	reply _ FillInTheBlank		request: 'new wording for this tab:'		initialAnswer: submorphs first contents.	reply isEmptyOrNil ifFalse: [submorphs first contents: reply]! !!FlapTab methodsFor: 'textual tabs' stamp: 'sma 6/18/2000 10:35'!changeTabText	| reply |	reply _ FillInTheBlank		request: 'new wording for this tab:'		initialAnswer: self existingWording.	reply isEmptyOrNil ifTrue: [^ self].	self useStringTab: reply.	submorphs first delete.	self		assumeString: reply		font: Preferences standardFlapFont		orientation: (Utilities orientationForEdge: edgeToAdhereTo)		color: nil! !FillInTheBlank removeSelector: #show:defaultAnswer:!