'From Squeak2.9alpha of 13 June 2000 [latest update: #3313] on 27 January 2001 at 3:20:42 pm'!"Change Set:		FasterLayouts-arDate:			27 January 2001Author:			Andreas RaabSpeed up layout computations by caching the minExtent which is recomputed many times for any incremental layout."!LayoutPolicy subclass: #TableLayout	instanceVariableNames: 'properties minExtentCache '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!!LayoutPolicy methodsFor: 'layout' stamp: 'ar 1/27/2001 14:39'!flushLayoutCache	"Flush any cached information associated with the receiver"! !!Morph methodsFor: 'layout' stamp: 'ar 1/27/2001 14:41'!layoutChanged	| layout |	fullBounds ifNil:[^self]. "layout will be recomputed so don't bother"	fullBounds _ nil.	layout _ self layoutPolicy.	layout ifNotNil:[layout flushLayoutCache].	owner ifNotNil: [owner layoutChanged].	"note: does not send #ownerChanged here - we'll do this when computing the new layout"! !!TableLayout methodsFor: 'layout' stamp: 'ar 1/27/2001 14:40'!flushLayoutCache	"Flush any cached information associated with the receiver"	minExtentCache _ nil.! !!TableLayout methodsFor: 'layout' stamp: 'ar 1/27/2001 14:42'!minExtentOf: aMorph in: box	"Return the minimal size aMorph's children would require given the new bounds"	| cells arrangement horizontal newBounds minX minY dir |	minExtentCache == nil ifFalse:[^minExtentCache].	aMorph hasSubmorphs ifFalse:[^0@0].	properties _ aMorph assureTableProperties.	(properties wrapDirection == #none and:[properties cellSpacing == #none]) ifTrue:[		"Get into the fast lane"		dir _ properties listDirection.		(dir == #leftToRight or:[dir == #rightToLeft])			ifTrue:[^self minExtentHorizontal: aMorph].		(dir == #topToBottom or:[dir == #bottomToTop])			ifTrue:[^self minExtentVertical: aMorph].	].	newBounds _ box origin asIntegerPoint corner: (box corner asIntegerPoint).	(properties listDirection == #topToBottom or:[properties listDirection == #bottomToTop])		ifTrue:[	horizontal _ false]		ifFalse:[	horizontal _ true].	"Step 1: Compute the minimum extent for all the children of aMorph"	cells _ self computeCellSizes: aMorph 				in: (0@0 corner: newBounds extent) 				horizontal: horizontal.	"Step 2: Compute the arrangement of the cells for each row and column"	arrangement _ self computeCellArrangement: cells 						in: newBounds 						horizontal: horizontal						target: aMorph.	"Step 3: Extract the minimum size out of the arrangement"	minX _ minY _ 0.	arrangement do:[:cell|		minX _ minX max: cell cellSize x + cell extraSpace x.		minY _ minY + cell cellSize y + cell extraSpace y].	horizontal 		ifTrue:[minExtentCache _ minX@minY]		ifFalse:[minExtentCache _ minY@minX].	^minExtentCache! !!TableLayout methodsFor: 'optimized' stamp: 'ar 1/27/2001 14:42'!minExtentHorizontal: aMorph	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint.	n _ 0.	width _ height _ 0.	aMorph submorphsDo:[:m|		m disableTableLayout ifFalse:[			n _ n + 1.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			width _ width + sizeX.			sizeY > height ifTrue:[height _ sizeY].		].	].	n > 1 ifTrue:[width _ width + (n-1 * inset x)].	^minExtentCache _ width @ height! !!TableLayout methodsFor: 'optimized' stamp: 'ar 1/27/2001 14:42'!minExtentVertical: aMorph	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint.	n _ 0.	width _ height _ 0.	aMorph submorphsDo:[:m|		m disableTableLayout ifFalse:[			n _ n + 1.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			height _ height + sizeY.			sizeX > width ifTrue:[width _ sizeX].		].	].	n > 1 ifTrue:[height _ height + (n-1 * inset y)].	^minExtentCache _ width @ height! !