'From Squeak2.8alpha of 16 February 2000 [latest update: #2176] on 23 May 2000 at 1:04:14 pm'!"Change Set:		CSRework-ACDate:			23 May 2000Author:			Andreas RaabCharacter scanner rework part3. Reshape StrikeFont and remove all the obsolete character scanner classes."!AbstractFont subclass: #StrikeFont	instanceVariableNames: 'xTable glyphs name stopConditions type minAscii maxAscii maxWidth strikeLength ascent descent xOffset raster subscript superscript emphasis derivativeFonts pointSize characterToGlyphMap '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Text'!!StrikeFont methodsFor: 'accessing' stamp: 'ar 5/23/2000 12:52'!characterToGlyphMap	^characterToGlyphMap ifNil:[characterToGlyphMap _ self createCharacterToGlyphMap].! !!StrikeFont methodsFor: 'accessing' stamp: 'ar 5/23/2000 12:52'!characterToGlyphMap: anArray	characterToGlyphMap _ anArray.! !!StrikeFont methodsFor: 'Mac reader' stamp: 'ar 5/23/2000 12:49'!readMacFontHex: fileName	"Read the hex version of a Mac FONT type resource.  See the method aComment for how to prepare the input file. 4/26/96 tk"	| file hh fRectWidth |	name _ fileName.	"Palatino 12"	file _ FileStream readOnlyFileNamed: fileName, ' hex'.	"See Inside Macintosh page IV-42 for this record"	"FontType _ " Number readFrom: (file next: 4) base: 16.	emphasis		_		0.	minAscii _ Number readFrom: (file next: 4) base: 16.	maxAscii _ Number readFrom: (file next: 4) base: 16.	maxWidth		_ Number readFrom: (file next: 4) base: 16.	"kernMax _ " Number readFrom: (file next: 4) base: 16.	"NDescent _ " Number readFrom: (file next: 4) base: 16.	fRectWidth _  Number readFrom: (file next: 4) base: 16.	hh _  Number readFrom: (file next: 4) base: 16.	"OWTLoc _ " Number readFrom: (file next: 4) base: 16.	ascent			_ Number readFrom: (file next: 4) base: 16.	descent			_ Number readFrom: (file next: 4) base: 16.	"leading _ " Number readFrom: (file next: 4) base: 16.	xOffset			_		0. 		raster			_ Number readFrom: (file next: 4) base: 16.	strikeLength	_		raster*16.	superscript		_		ascent - descent // 3.		subscript		_		descent - ascent // 3.		self strikeFromHex: file width: raster height: hh.	self xTableFromHex: file.	file close.	"Insert one pixel between each character.  And add space character."	self fixKerning: (fRectWidth - maxWidth).		"Recompute character to glyph mapping"	characterToGlyphMap _ nil.! !!StrikeFont methodsFor: 'file in/out' stamp: 'ar 5/23/2000 12:50'!buildfontNamed: nm fromForms: forms startingAtAscii: startAscii	ascent: a descent: d maxWid: m	"This builds a StrikeFont instance from existing forms."	| lastAscii width ascii charForm missingForm tempGlyphs |	name _ nm.	ascent _ 11.	descent _ 3.	maxWidth _ 16.	pointSize _ 8.	name _ (name copyWithout: Character space) ,				(pointSize < 10					ifTrue: ['0' , pointSize printString]					ifFalse: [pointSize printString]).	minAscii _ 258.	maxAscii _ 0.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	type _ 0.  "ignored for now"	tempGlyphs _ Form extent: (maxWidth*257) @ self height.	xTable _ (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	"Read character forms and blt into tempGlyphs"	lastAscii _ -1.	1 to: forms size do:		[:i | charForm _ forms at: i. width _ charForm width.		ascii _ startAscii-1+i.		self displayChar: ascii form: charForm.		ascii = 256			ifTrue: [missingForm _ charForm deepCopy]			ifFalse:			[minAscii _ minAscii min: ascii.			maxAscii _ maxAscii max: ascii.			lastAscii+1 to: ascii-1 do: [:as | xTable at: as+2 put: (xTable at: as+1)].			tempGlyphs copy: ((xTable at: ascii+1)@0									extent: charForm extent)						from: 0@0 in: charForm rule: Form over.			xTable at: ascii+2 put: (xTable at: ascii+1) + width.			lastAscii _ ascii]].	lastAscii+1 to: maxAscii+1 do: [:as | xTable at: as+2 put: (xTable at: as+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs _ Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable _ xTable copyFrom: 1 to: maxAscii+3.	characterToGlyphMap _ nil.! !!StrikeFont methodsFor: 'file in/out' stamp: 'ar 5/23/2000 12:50'!newFromStrike: fileName	"Build an instance from the strike font file name. The '.strike' extension	is optional."	| strike startName raster16 |	name _ fileName copyUpTo: $..	"assumes extension (if any) is '.strike'".	strike _ FileStream oldFileNamed: name, '.strike.'.	strike binary.	strike readOnly.		"strip off direcory name if any"	startName _ name size.	[startName > 0 and: [((name at: startName) ~= $>) & ((name at: startName) ~= $])]]		whileTrue: [startName _ startName - 1].	name _ name copyFrom: startName+1 to: name size.	type			_		strike nextWord.		"type is ignored now -- simplest												assumed.  Kept here to make												writing and consistency more												straightforward."	minAscii		_		strike nextWord.	maxAscii		_		strike nextWord.	maxWidth		_		strike nextWord.	strikeLength	_		strike nextWord.	ascent			_		strike nextWord.	descent			_		strike nextWord.	"xOffset			_"		strike nextWord. 		raster16			_		strike nextWord.		superscript		_		ascent - descent // 3.		subscript		_		descent - ascent // 3.		emphasis		_		0.	glyphs			_	Form extent: (raster16 * 16) @ (self height)  							offset: 0@0.		glyphs bits fromByteStream: strike.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: strike nextWord].	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	strike close.	characterToGlyphMap _ nil.! !!StrikeFont methodsFor: 'file in/out' stamp: 'ar 5/23/2000 12:50'!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f lastAscii charLine width ascii charForm line missingForm tempGlyphs iRect p rectLine left tokens right |	f _ FileStream readOnlyFileNamed: fileName.	self readBFHeaderFrom: f.	"NOTE: if font has been scaled (and in any case),	the REAL bitmap dimensions come after the header."	self restOfLine: 'Extent information for entire font' from: f.	"Parse the following line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	tokens _ (f upTo: Character cr)  findTokens: ' '.	iRect _ Rectangle left: (tokens at: 5) asNumber right: (tokens at: 8) asNumber				top: (tokens at: 14) asNumber bottom: (tokens at: 11) asNumber.	ascent _ iRect top.	descent _ iRect bottom negated.		tempGlyphs _ Form extent: (maxWidth*257) @ self height.	xTable _ (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	"Read character forms and blt into tempGlyphs"	lastAscii _ -1.	[charLine _ self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[p _ f position.		rectLine _ f upTo: Character cr.		(rectLine beginsWith: 'Image rectange: left = ')			ifTrue: [tokens _ rectLine findTokens: ' '.					left _ (tokens at: 5) asNumber. right _ (tokens at: 8) asNumber]			ifFalse: [left _ right _ 0. f position: p].		width_ (self restOfLine: 'Width (final pen position) = ' from: f) asNumber - left					max: (right-left+1).		(charLine beginsWith: 'Missing character') ifTrue: [ascii _ 256].		('x''*' match: charLine) ifTrue:			[ascii _ Number readFrom: (charLine copyFrom: 3 to: 4) asUppercase base: 16].		charForm _ Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line _ f upTo: Character cr.				4 to: (width + 3 min: line size + iRect left - left) do:					[:x | (line at: x - iRect left + left) = $*						ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm _ charForm deepCopy]				ifFalse:				[minAscii _ minAscii min: ascii.				maxAscii _ maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii _ ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs _ Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable _ xTable copyFrom: 1 to: maxAscii+3.	characterToGlyphMap _ nil.! !!StrikeFont methodsFor: 'file in/out' stamp: 'ar 5/23/2000 12:53'!readFromStrike2Stream: file 	"Build an instance from the supplied binary stream on data in strike2 format"	type _ file nextInt32.  type = 2 ifFalse: [file close. self error: 'not strike2 format'].	minAscii _ file nextInt32.	maxAscii _ file nextInt32.	maxWidth _ file nextInt32.	ascent _ file nextInt32.	descent _ file nextInt32.	pointSize _ file nextInt32.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ file nextInt32.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: file nextInt32].	glyphs _ Form new readFrom: file.	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	characterToGlyphMap _ nil.! !!StrikeFont methodsFor: 'character shapes' stamp: 'ar 5/23/2000 12:48'!extendMaxAsciiTo: newMax	"Extend the range of this font so that it can display glyphs up to newMax."	(newMax+3) <= xTable size ifTrue: [^ self].  "No need to extend."	xTable size = (maxAscii+3) ifFalse:		[^ self error: 'This font is not well-formed.'].	"Insert a bunch of zero-width characters..."	xTable _ (xTable copyFrom: 1 to: maxAscii+2) ,			((maxAscii+1 to: newMax) collect: [:i | xTable at: maxAscii+2]) ,			{ xTable at: maxAscii+3 }.	maxAscii _ newMax.	self fillZeroWidthSlots.	characterToGlyphMap _ nil.! !!StrikeFont methodsFor: 'object fileIn' stamp: 'ar 5/23/2000 12:51'!convertxgnstmmmsadxrssedp0: varDict cxgntmmmsadxrssedp0: smartRefStrm	"These variables are automatically stored into the new instance ('xTable' 'glyphs' 'name' 'type' 'minAscii' 'maxAscii' 'maxWidth' 'strikeLength' 'ascent' 'descent' 'xOffset' 'raster' 'subscript' 'superscript' 'emphasis' 'derivativeFonts' 'pointSize' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('characterToGlyphMap' )  If a non-nil value is needed, please assign it."	"These are going away ('stopConditions' ).  Possibly store their info in another variable?"! !!FormSetFont methodsFor: 'as yet unclassified' stamp: 'ar 5/23/2000 12:49'!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width x badChar |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	badChar _ (Form extent: 7@height) borderWidth: 1.	width _ width + badChar width.	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: maxAscii + 3 withAll: 0.	x _ 0.	formArray doWithIndex:		[:f :i | f displayOn: glyphs at: x@0.		xTable at: minAscii + i+1 put: (x _ x + f width)].	badChar displayOn: glyphs at: x@0.	xTable at: maxAscii + 3 put: x + badChar width.	characterToGlyphMap _ nil.! !StrikeFont removeSelector: #setStopConditions!StrikeFont removeSelector: #stopConditions!AbstractFont subclass: #StrikeFont	instanceVariableNames: 'characterToGlyphMap xTable glyphs name type minAscii maxAscii maxWidth strikeLength ascent descent xOffset raster subscript superscript emphasis derivativeFonts pointSize '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Text'!Smalltalk removeClassNamed: #CharacterBlockScanner!Smalltalk removeClassNamed: #CharacterScanner!Smalltalk removeClassNamed: #CompositionScanner!Smalltalk removeClassNamed: #DisplayScanner!Smalltalk removeClassNamed: #QuickPrint!Smalltalk removeClassNamed: #SegmentScanner!