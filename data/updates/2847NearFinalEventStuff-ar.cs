'From Squeak2.9alpha of 13 June 2000 [latest update: #2893] on 26 October 2000 at 12:50:59 am'!"Change Set:		NearFinalEventStuff-arDate:			25 October 2000Author:			Andreas RaabSome near-final event stuff. Fixes up the event recorder and provides backward compatibility (e.g., Alan's recorded sessions don't need to be recorded again).Also fixes up Nebraska and gets rid of the repeated mouse moves in Nebraska since we don't need them any longer.Finally, prepares the conversion methods for the removal of MorphicEvent and MorphicSoundEvent and converts all existing instances."!AlignmentMorph subclass: #EventRecorderMorph	instanceVariableNames: 'tape state time recHand playHand lastEvent lastDelta tapeStream saved statusLight voiceRecorder startSoundEvent recordMeter caption journalFile deltaTime '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!NewMorphicEvent subclass: #MorphicUnknownEvent	instanceVariableNames: 'type argument '	classVariableNames: ''	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Events'!!EventHandler methodsFor: 'object fileIn' stamp: 'ar 10/25/2000 23:36'!convertmmmmmmmmmmmmmmkkvssdd0: varDict mmmmmmmmmmmmmmmmkkvssddcc0: smartRefStrm	"These variables are automatically stored into the new instance #('mouseDownRecipient' 'mouseDownSelector' 'mouseStillDownRecipient' 'mouseStillDownSelector' 'mouseUpRecipient' 'mouseUpSelector' 'mouseEnterRecipient' 'mouseEnterSelector' 'mouseLeaveRecipient' 'mouseLeaveSelector' 'mouseEnterDraggingRecipient' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingRecipient' 'mouseLeaveDraggingSelector' 'keyStrokeRecipient' 'keyStrokeSelector' 'valueParameter' 'startDragRecipient' 'startDragSelector' 'doubleClickSelector' 'doubleClickRecipient').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('mouseMoveRecipient' 'mouseMoveSelector' 'clickSelector' 'clickRecipient')  If a non-nil value is needed, please assign it."! !!Morph methodsFor: 'menus' stamp: 'ar 10/25/2000 23:17'!doMenuItem: menuString	| aMenu anItem aNominalEvent aHand |	aMenu _ self buildHandleMenu: (aHand _ self currentHand).	aMenu allMorphsDo: [:m | m step].  "Get wordings current"	anItem _ aMenu itemWithWording: menuString.	anItem ifNil:		[^ self player scriptingError: 'Menu item not found: ', menuString].	aNominalEvent _  MouseButtonEvent new		setType: #mouseDown		position: anItem bounds center		which: 4 "red"		buttons: 4 "red"		hand: aHand		stamp: nil.	anItem invokeWithEvent: aNominalEvent! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'ar 10/25/2000 21:42'!addJournalFile	"In case there is a chance of not regaining control to stop recording and save a file, the EventRecorder can write directly to file as it is recording.  This is useful for capturing a sequence that results in a nasty crash."	journalFile ifNotNil: [journalFile close].	journalFile _ FileStream newFileNamed: 'EventRecorder.tape'.	journalFile nextPutAll:'Event Tape v1 ASCII'; cr.! !!EventRecorderMorph methodsFor: 'commands' stamp: 'ar 10/25/2000 22:38'!condense	"Shorten the tape by deleting mouseMove events that can just as well be	interpolated later at playback time."	| e1 e2 t1 t2 e3 t3 |	"e1, e2, and e3 are three consecutive events on the tape.	t1, t2, and t3 are the associated time steps for each of them."	tape _ Array streamContents:	[:tStream |	e1 _ e2 _ e3 _ nil.  t1 _ t2 _ t3 _ nil.	1 to: tape size do:[:i|		e1 _ e2.  t1 _ t2.		e2 _ e3.  t2 _ t3.		e3 _ tape at: i. t3 _ e3 timeStamp.		((e1 ~~ nil and: [(e2 type == #mouseMove) &				(e1 type == #mouseMove or: [e3 type == #mouseMove])]) and: 			["Middle point within 3 pixels of mean of outer two"			e2 position onLineFrom: e1 position to: e3 position within: 2.5])			ifTrue: ["Delete middle mouse move event.  Absorb its time into e3"					e2 _ e1.  t2 _ t1]			ifFalse: [e1 ifNotNil: [tStream nextPut: (e1 copy setTimeStamp: t1)]]].	e2 ifNotNil: [tStream nextPut: (e2 copy setTimeStamp: t2)].	e3 ifNotNil: [tStream nextPut: (e3 copy setTimeStamp: t3)]].! !!EventRecorderMorph methodsFor: 'commands' stamp: 'ar 10/25/2000 23:00'!play	self isInWorld ifFalse: [^ self].	self stop.	tape ifNil: [^ self].	tapeStream _ ReadStream on: tape.	self resumePlayIn: self world.	statusLight color: Color yellow.! !!EventRecorderMorph methodsFor: 'commands' stamp: 'ar 10/25/2000 20:24'!record	self isInWorld ifFalse: [^ self].	self stop.	self writeCheck.	self addJournalFile.	tapeStream _ WriteStream on: (Array new: 10000).	self resumeRecordIn: self world.	statusLight color: Color red.! !!EventRecorderMorph methodsFor: 'commands' stamp: 'ar 10/25/2000 23:00'!shrink	"Shorten the tape by deleting mouseMove events that can just as well be	interpolated later at playback time."	| oldSize priorSize |	self writeCheck.	oldSize _ priorSize _ tape size.	[self condense.  tape size < priorSize] whileTrue: [priorSize _ tape size].	PopUpMenu notify: oldSize printString , ' events reduced to ' , tape size printString.	voiceRecorder ifNotNil: [voiceRecorder suppressSilence].	saved _ false.! !!EventRecorderMorph methodsFor: 'commands' stamp: 'ar 10/25/2000 23:01'!stop	state = #record ifTrue:		[tape _ tapeStream contents.		saved _ false].	journalFile ifNotNil:		[journalFile close].	self pauseIn: self world.	tapeStream _ nil.	state _ nil.	statusLight color: Color green.	self checkTape.! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'ar 10/25/2000 20:04'!pauseIn: aWorld	"Suspend playing or recording, either as part of a stop command,	or as part of a project switch, after which it will be resumed."	state = #play ifTrue:		[state _ #suspendedPlay.		playHand delete.		aWorld removeHand: playHand.		playHand _ nil].	state = #record ifTrue:		[state _ #suspendedRecord.		recHand removeEventListener: self.		recHand _ nil].	voiceRecorder ifNotNil:		[voiceRecorder pause.		startSoundEvent ifNotNil:			[startSoundEvent argument: voiceRecorder recordedSound.			voiceRecorder clearRecordedSound.			startSoundEvent _ nil]].! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'ar 10/25/2000 20:58'!resumePlayIn: aWorld	playHand _ HandMorphForReplay new recorder: self.	playHand position: tapeStream peek position.	aWorld addHand: playHand.	playHand newKeyboardFocus: aWorld.	playHand userInitials: 'play' andPicture: nil.	lastEvent _ nil.	lastDelta _ 0@0.	state _ #play.	self synchronize.! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'ar 10/26/2000 00:50'!resumeRecordIn: aWorld	recHand _ aWorld activeHand ifNil: [aWorld primaryHand].	recHand newKeyboardFocus: aWorld.	recHand addEventListener: self.	lastEvent _ nil.	state _ #record.	voiceRecorder ifNotNil:		[voiceRecorder clearRecordedSound.		voiceRecorder resumeRecording.		startSoundEvent _ MorphicUnknownEvent new setType: #startSound argument: nil hand: nil stamp: Time millisecondClockValue.		tapeStream nextPut: startSoundEvent].	self synchronize.! !!EventRecorderMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 21:26'!handleListenEvent: anEvent	"Record the given event"	(state == #record and:[anEvent hand == recHand]) 		ifFalse:[^self].	anEvent = lastEvent ifTrue: [^ self].	(anEvent isKeyboard and:[anEvent keyValue = 27 "esc"])		ifTrue: [^ self stop].	time _ anEvent timeStamp.	tapeStream nextPut: (anEvent copy setHand: nil).	journalFile ifNotNil:		[journalFile store: anEvent; cr; flush].	lastEvent _ anEvent.! !!EventRecorderMorph methodsFor: 'event handling' stamp: 'ar 10/26/2000 00:50'!nextEventToPlay	"Return the next event when it is time to be replayed.	If it is not yet time, then return an interpolated mouseMove.	Return nil if nothing has happened.	Return an EOF event if there are no more events to be played."	| nextEvent now nextTime lastP delta |	(tapeStream == nil or:[tapeStream atEnd]) 		ifTrue:[^MorphicUnknownEvent new setType: #EOF argument: nil].	now _ Time millisecondClockValue.	nextEvent _ tapeStream next.	deltaTime ifNil:[deltaTime _ now - nextEvent timeStamp].	nextTime _ nextEvent timeStamp + deltaTime.	now < time ifTrue:["clock rollover"		time _ now.		deltaTime _ nil.		^nil "continue it on next cycle"].	time _ now.	(now >= nextTime) ifTrue:[		nextEvent _ nextEvent copy setTimeStamp: nextTime.		nextEvent isMouse ifTrue:[lastEvent _ nextEvent] ifFalse:[lastEvent _ nil].		^nextEvent].	tapeStream skip: -1.	"Not time for the next event yet, but interpolate the mouse.	This allows tapes to be compressed when velocity is fairly constant."	lastEvent ifNil: [^ nil].	lastP _ lastEvent position.	delta _ (nextEvent position - lastP) * (now - lastEvent timeStamp) // (nextTime - lastEvent timeStamp).	delta = lastDelta ifTrue: [^ nil]. "No movement"	lastDelta _ delta.	^MouseMoveEvent new		setType: #mouseMove 		startPoint: lastEvent position endPoint: lastP + delta		trail: #() buttons: lastEvent buttons hand: nil stamp: now.! !!EventRecorderMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 20:44'!synchronize	time _ Time millisecondClockValue.	deltaTime _ nil.! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 23:02'!checkTape	"See if this tape was already converted to the new format"	tape ifNil:[^self].	tape size = 0 ifTrue:[^self].	(tape first isKindOf: Association) ifTrue:[tape _ self convertV0Tape: tape].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/26/2000 00:50'!convertV0Tape: anArray	"Convert the tape into the new format"	| lastKey evt |	lastKey _ 0.	^anArray collect:[:assn| 		evt _ assn value.		evt isMorphicEvent ifFalse:[			(evt type == #startSound)				ifTrue:[evt _ MorphicUnknownEvent new setType: #startSound argument: evt sound]				ifFalse:[evt _ NewMorphicEvent readFromObsolete: (ReadStream on: evt storeString)]].		evt setTimeStamp: (lastKey _ lastKey + assn key).		evt]! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 22:00'!readFrom: aStream	"Private"	| cr header |	cr _ Character cr.	header _ aStream upTo: cr.	(header = 'Event Tape v1 BINARY') ifTrue:[^aStream fileInObjectAndCode].	(header = 'Event Tape v1 ASCII') ifTrue:[^self readFromV1: aStream].	"V0 had no header so guess"	aStream reset.	header first isDigit ifFalse:[^self convertV0Tape: (aStream fileInObjectAndCode)].	^self convertV0Tape: (self readFromV0: aStream).! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 21:58'!readFromV0: aStream	| cr line lineStream t evt |	cr _ Character cr.	^Array streamContents:[:tStream |		[aStream atEnd] whileFalse:			[line _ aStream upTo: cr.			line isEmpty "Some MW tapes have an empty record at the end"				ifFalse: [lineStream _ ReadStream on: line.						t _ Integer readFrom: lineStream.						[lineStream peek isLetter] whileFalse: [lineStream next].						evt _ NewMorphicEvent readFromObsolete: lineStream.						tStream nextPut: t -> evt]]].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 22:13'!readFromV1: aStream	| cr |	cr _ Character cr.	^Array streamContents:[:tStream |		[aStream atEnd] whileFalse:[			tStream nextPut: (NewMorphicEvent readFromString: (aStream upTo: cr))]]! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 22:00'!readTape: fileName 	| file |	self writeCheck.	(FileStream isAFileNamed: fileName) ifFalse: [^ nil].	file _ FileStream oldFileNamed: fileName.	tape _ self readFrom: file.	file close.	saved _ true  "Still exists on file"! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 22:11'!writeFileNamed: fileName	| file noVoice delta |	file _ FileStream newFileNamed: fileName.	noVoice _ true.	tape do:[:evt | evt type = #startSound ifTrue: [noVoice _ false]].	noVoice		ifTrue: ["Simple format (reads fast) for no voice"				file nextPutAll:'Event Tape v1 ASCII'; cr.				delta _ tape first timeStamp.				tape do: [:evt | file store: (evt copy setTimeStamp: evt timeStamp-delta); cr].				file close]		ifFalse: ["Inclusion of voice events requires general object storage"				file nextPutAll:'Event Tape v1 BINARY'; cr.				file fileOutClass: nil andObject: tape].	saved _ true.	^ file name! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 22:11'!writeTape: fileName 	| b name |	name _ self writeFileNamed: fileName.	(b _ self button: 'writeTape') ifNotNil: [		b actionSelector: #writeTape:.		b arguments: (Array with: name)].! !!EventRecorderMorph methodsFor: 'object fileIn' stamp: 'ar 10/25/2000 23:59'!convertbosfcebbochvimlptstrplltssvsrcj0: varDict bosfcebbochvimlptstdrplltssvsrcj0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'tape' 'state' 'time' 'recHand' 'playHand' 'lastEvent' 'lastDelta' 'tapeStream' 'saved' 'statusLight' 'voiceRecorder' 'startSoundEvent' 'recordMeter' 'caption' 'journalFile').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('deltaTime')  If a non-nil value is needed, please assign it."! !!HandMorph methodsFor: 'initialization' stamp: 'ar 10/25/2000 20:59'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	cachedCanvasHasHoles _ false.	temporaryCursor _ temporaryCursorOffset _ nil.	self initForEvents.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 21:03'!handleEvent: anEvent	| evt prevEvt ofs |	owner ifNil:[^self].	anEvent isMorphicEvent 		ifTrue:[evt _ anEvent]		ifFalse:[			prevEvt _ lastEvent.			lastEvent _ anEvent.			evt _ anEvent asNewEventFrom: prevEvt].	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendEvent: evt focus: mouseFocus].ShowEvents == true ifTrue:[	ofs _ (owner hands indexOf: self) - 1 * 60.	evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	keyboardFocus printString displayAt: (0@ofs)+(0@45).].	"Notify listeners"	self sendListenEvent: evt to: eventListeners.	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: keyboardListeners.		self sendEvent: evt focus: keyboardFocus.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: mouseListeners.		lastMouseEvent _ evt].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendEvent: evt focus: mouseFocus.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendEvent: evt focus: mouseFocus].	].	ShowEvents == true ifTrue:[mouseFocus printString displayAt: (0@ofs) + (0@15)].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'object fileIn' stamp: 'ar 10/25/2000 23:36'!convertbosfceekmmmdccffuleatdccttggrtllmhssffacw0: varDict bosfcemkemkmmlltdcctthsul0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'keyboardFocus' 'lastEvent' 'targetOffset' 'damageRecorder' 'cacheCanvas' 'cachedCanvasHasHoles' 'temporaryCursor' 'temporaryCursorOffset' 'hasChanged' 'savedPatch' 'userInitials').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('mouseFocus' 'eventListeners' 'mouseListeners' 'keyboardListeners' 'mouseClickState' 'mouseOverHandler' 'lastMouseEvent' 'lastEventBuffer')  If a non-nil value is needed, please assign it."	"These are going away #('eventSubscribers' 'mouseDownMorph' 'mouseOverMorphs' 'mouseOverTimes' 'dragOverMorphs' 'clickClient' 'clickState' 'firstClickEvent' 'firstClickTime' 'eventTransform' 'argument' 'grid' 'gridOn' 'remoteConnections' 'transmitBuffer' 'lastEventTransmitted' 'lastWorldExtent' 'menuTargetOffset' 'suppressDrawing' 'formerOwner' 'formerPosition' 'addedFlexAtGrab' 'currentCommand' 'worldUnderCursor').  Possibly store their info in another variable?"! !!HandMorphForReplay methodsFor: 'event dispatching' stamp: 'ar 10/25/2000 22:14'!processEvents	"Play back the next event"	| evt hadMouse hadAny |	hadMouse _ hadAny _ false.	[(evt _ recorder nextEventToPlay) == nil] whileFalse:[		evt type == #EOF ifTrue: [recorder pauseIn: self world. ^self].		evt type == #startSound ifTrue: [evt argument play.  recorder synchronize.  ^ self].		evt isMouse ifTrue:[hadMouse _ true].		(evt isMouse or:[evt isKeyboard]) ifTrue:[			self handleEvent: (evt setHand: self) resetHandlerFields.			hadAny _ true].	].	(mouseClickState notNil and:[hadMouse not]) ifTrue:[		"No mouse events during this cycle. Make sure click states time out accordingly"		mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	hadAny ifFalse:[		"No pending events. Make sure z-order is up to date"		self mouseOverHandler processMouseOver: lastMouseEvent.	].! !!HandMorphForReplay methodsFor: 'initialization' stamp: 'ar 10/25/2000 20:58'!initialize	super initialize.	self showTemporaryCursor: Cursor normal.! !!HandMorphForReplay methodsFor: 'object fileIn' stamp: 'ar 10/25/2000 23:49'!convertbosfceekmmmdccffuleatdccttggrtllmhssffacwr0: varDict bosfcemkemkmmlltdcctthsulr0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'keyboardFocus' 'lastEvent' 'targetOffset' 'damageRecorder' 'cacheCanvas' 'cachedCanvasHasHoles' 'temporaryCursor' 'temporaryCursorOffset' 'hasChanged' 'savedPatch' 'userInitials' 'recorder').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('mouseFocus' 'eventListeners' 'mouseListeners' 'keyboardListeners' 'mouseClickState' 'mouseOverHandler' 'lastMouseEvent' 'lastEventBuffer')  If a non-nil value is needed, please assign it."	"These are going away #('eventSubscribers' 'mouseDownMorph' 'mouseOverMorphs' 'mouseOverTimes' 'dragOverMorphs' 'clickClient' 'clickState' 'firstClickEvent' 'firstClickTime' 'eventTransform' 'argument' 'grid' 'gridOn' 'remoteConnections' 'transmitBuffer' 'lastEventTransmitted' 'lastWorldExtent' 'menuTargetOffset' 'suppressDrawing' 'formerOwner' 'formerPosition' 'addedFlexAtGrab' 'currentCommand' 'worldUnderCursor').  Possibly store their info in another variable?"! !!MorphicEventDecoder methodsFor: 'handling messages' stamp: 'ar 10/25/2000 23:32'!applyEventMessage: aStringArray to: aHand	| event |	event := NewMorphicEvent fromStringArray: (aStringArray copyFrom: 2 to: aStringArray size).	event ifNotNil:[aHand queueEvent: event].! !!NetworkTerminalMorph methodsFor: 'stepping and presenter' stamp: 'ar 10/25/2000 23:19'!step	decoder ifNil: [ ^self ].	decoder processIOOnForce: [ :rectangle | self forceToFront: rectangle ].! !!NewMorphicEvent methodsFor: 'private' stamp: 'ar 10/25/2000 21:26'!setHand: aHand	source _ aHand! !!NewMorphicEvent methodsFor: 'private' stamp: 'ar 10/25/2000 20:53'!setTimeStamp: stamp	timeStamp _ stamp.! !!NewMorphicEvent methodsFor: 'object fileIn' stamp: 'ar 10/26/2000 00:50'!converttcbks0: varDict ts0: smartRefStrm	"ar 10/25/2000: This method is used to convert OLD MorphicEvents into new ones."	"These are going away #('type' 'cursorPoint' 'buttons' 'keyValue' 'sourceHand').  Possibly store their info in another variable?"	| type cursorPoint buttons keyValue sourceHand |	type _ varDict at: 'type'.	cursorPoint _ varDict at: 'cursorPoint'.	buttons _ varDict at: 'buttons'.	keyValue _ varDict at: 'keyValue'.	sourceHand _ varDict at: 'sourceHand'.	type == #mouseMove ifTrue:[		^MouseMoveEvent new			setType: #mouseMove 			startPoint: cursorPoint			endPoint: cursorPoint			trail: #() 			buttons: buttons 			hand: sourceHand 			stamp: nil].	(type == #mouseDown) | (type == #mouseUp) ifTrue:[			^MouseButtonEvent new				setType: type				position: cursorPoint				which: 0				buttons: buttons				hand: sourceHand				stamp: nil].	(type == #keystroke) | (type == #keyDown) | (type == #keyUp) ifTrue:[		^KeyboardEvent new			setType: type			buttons: buttons			position: cursorPoint			keyValue: keyValue			hand: sourceHand			stamp: nil].	"All others will be handled there"	^MorphicUnknownEvent new! !!MorphicUnknownEvent methodsFor: 'accessing' stamp: 'ar 10/25/2000 20:04'!argument	^argument! !!MorphicUnknownEvent methodsFor: 'accessing' stamp: 'ar 10/25/2000 20:04'!argument: arg	argument _ arg! !!MorphicUnknownEvent methodsFor: 'accessing' stamp: 'ar 10/25/2000 19:55'!position	^0@0! !!MorphicUnknownEvent methodsFor: 'accessing' stamp: 'ar 10/25/2000 19:55'!type	^type! !!MorphicUnknownEvent methodsFor: 'printing' stamp: 'ar 10/25/2000 19:57'!storeOn: aStream	aStream nextPutAll: 'misc'.	aStream space.	type storeOn: aStream.	aStream space.	argument storeOn: aStream.! !!MorphicUnknownEvent methodsFor: 'private' stamp: 'ar 10/25/2000 19:59'!setType: evtType argument: arg	type _ evtType.	argument _ arg.! !!MorphicUnknownEvent methodsFor: 'private' stamp: 'ar 10/25/2000 19:58'!setType: evtType argument: arg hand: evtHand stamp: stamp	type _ evtType.	argument _ arg.	source _ evtHand.	timeStamp _ stamp.! !!MorphicUnknownEvent methodsFor: 'private' stamp: 'ar 10/25/2000 22:08'!type: eventType readFrom: aStream	timeStamp _ Integer readFrom: aStream.	aStream skip: 1.	type _ Object readFrom: aStream.	aStream skip: 1.	argument _ Object readFrom: aStream.! !!MorphicUnknownEvent methodsFor: 'object fileIn' stamp: 'ar 10/25/2000 23:53'!converttcbkss0: varDict tsta0: smartRefStrm	"Used for converting MorphicSoundEvents"	"These are going away #('cursorPoint' 'buttons' 'keyValue' 'sourceHand' 'sound').  Possibly store their info in another variable?"	type _ #startSound.	source _ varDict at: 'sourceHand'.	argument _ varDict at: 'sound'.! !!MorphicUnknownEvent methodsFor: 'printing' stamp: 'ar 10/26/2000 00:49'!storeOn: aStream	aStream nextPutAll: 'unknown'.	aStream space.	type storeOn: aStream.	aStream space.	argument storeOn: aStream.! !!NewMorphicEvent class methodsFor: 'instance creation' stamp: 'ar 10/26/2000 00:44'!convertObsolete: anEvent	"ar 10/25/2000: This method is used to convert OLD MorphicEvents into new ones."	| type cursorPoint buttons keyValue sourceHand |	type _ anEvent type.	cursorPoint _ anEvent cursorPoint.	buttons _ anEvent buttons.	keyValue _ anEvent keyValue.	sourceHand _ anEvent hand.	type == #mouseMove ifTrue:[		^MouseMoveEvent new			setType: #mouseMove 			startPoint: cursorPoint			endPoint: cursorPoint			trail: #() 			buttons: buttons 			hand: sourceHand 			stamp: nil].	(type == #mouseDown) | (type == #mouseUp) ifTrue:[			^MouseButtonEvent new				setType: type				position: cursorPoint				which: 0				buttons: buttons				hand: sourceHand				stamp: nil].	(type == #keystroke) | (type == #keyDown) | (type == #keyUp) ifTrue:[		^KeyboardEvent new			setType: type			buttons: buttons			position: cursorPoint			keyValue: keyValue			hand: sourceHand			stamp: nil].	^nil! !!NewMorphicEvent class methodsFor: 'instance creation' stamp: 'ar 10/25/2000 23:32'!fromStringArray: array	"decode an event that was encoded with encodedAsStringArray"	| type |	type := (array at: 1).	(type = 'mouseMove')		ifTrue:[^MouseMoveEvent new decodeFromStringArray: array].	(type = 'mouseDown' or:[type = 'mouseUp']) 		ifTrue:[^MouseButtonEvent new decodeFromStringArray: array].	(type = 'keystroke' or:[type = 'keyDown' or:[type = 'keyUp']]) 		ifTrue:[^KeyboardEvent new decodeFromStringArray: array].	^nil! !!NewMorphicEvent class methodsFor: 'instance creation' stamp: 'ar 10/26/2000 00:49'!readFrom: aStream	"Read a MorphicEvent from the given stream."	| typeString c |	typeString _ String streamContents:		[:s |   [(c _ aStream next) isLetter] whileTrue: [s nextPut: c]].	typeString = 'mouseMove' ifTrue:[^MouseMoveEvent type: #mouseMove readFrom: aStream].	typeString = 'mouseDown' ifTrue:[^MouseButtonEvent type: #mouseDown readFrom: aStream].	typeString = 'mouseUp' ifTrue:[^MouseButtonEvent type: #mouseUp readFrom: aStream].	typeString = 'keystroke' ifTrue:[^KeyboardEvent type: #keystroke readFrom: aStream].	typeString = 'keyDown' ifTrue:[^KeyboardEvent type: #keyDown readFrom: aStream].	typeString = 'keyUp' ifTrue:[^KeyboardEvent type: #keyUp readFrom: aStream].	typeString = 'mouseOver' ifTrue:[^MouseEvent type: #mouseOver readFrom: aStream].	typeString = 'mouseEnter' ifTrue:[^MouseEvent type: #mouseEnter readFrom: aStream].	typeString = 'mouseLeave' ifTrue:[^MouseEvent type: #mouseLeave readFrom: aStream].	typeString = 'unknown' ifTrue:[^MorphicUnknownEvent type: #unknown readFrom: aStream].	^nil! !!NewMorphicEvent class methodsFor: 'instance creation' stamp: 'ar 10/25/2000 21:58'!readFromObsolete: aStream	"Read one of those old and now obsolete events from the stream"	| type x y buttons keyValue typeString c |	typeString _ String streamContents:		[:s |   [(c _ aStream next) isLetter] whileTrue: [s nextPut: c]].	typeString = 'mouseMove'		ifTrue: [type _ #mouseMove  "fast treatment of common case"]		ifFalse: [type _ typeString asSymbol].	x _ Integer readFrom: aStream.	aStream skip: 1.	y _ Integer readFrom: aStream.	aStream skip: 1.	buttons _ Integer readFrom: aStream.	aStream skip: 1.	keyValue _ Integer readFrom: aStream.	typeString = 'mouseMove' ifTrue:[		^MouseMoveEvent new			setType: #mouseMove 			startPoint: x@y 			endPoint: x@y 			trail: #() 			buttons: buttons 			hand: nil 			stamp: nil].	(typeString = 'mouseDown') | (typeString = 'mouseUp') ifTrue:[			^MouseButtonEvent new				setType: type				position: x@y				which: 0				buttons: buttons				hand: nil				stamp: nil].	(typeString = 'keystroke') | (typeString = 'keyDown') | (typeString = 'keyUp') ifTrue:[		^KeyboardEvent new			setType: type			buttons: buttons			position: x@y			keyValue: keyValue			hand: nil			stamp: nil].	^nil! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'ar 10/25/2000 23:13'!prepareToUndoDropOf: aMorph	| m |	self mouseLeave: MouseMoveEvent new.	m _ self owner.	[m == nil] whileFalse: [		(m isKindOf: ScriptEditorMorph) ifTrue: [^ m prepareToUndoDropOf: aMorph].		m _ m owner].! !!RemoteControlledHandMorph methodsFor: 'events' stamp: 'ar 10/25/2000 23:29'!queueEvent: anEvent	"add an event to be handled"	anEvent setHand: self.	self handleEvent: anEvent resetHandlerFields.! !!RemoteHandMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 20:00'!processEvents	"Process user input events from the remote input devices."	| evt |	evt _ self getNextRemoteEvent.	[evt ~~ nil] whileTrue: [		evt type == #worldExtent ifTrue: [			remoteWorldExtent _ evt argument.			^ self].		self handleEvent: evt.		evt _ self getNextRemoteEvent]! !!RemoteHandMorph methodsFor: 'event handling' stamp: 'ar 10/26/2000 00:50'!transmitEvent: aMorphicEvent	"Transmit the given event to all remote connections."	| firstEvt |	self readyToTransmit ifFalse: [^ self].	self lastEventTransmitted = aMorphicEvent ifTrue: [^ self].	sendBuffer ifNil: [sendBuffer _ WriteStream on: (String new: 10000)].	sendBuffer nextPutAll: aMorphicEvent storeString; cr.	self lastEventTransmitted: aMorphicEvent.	sendSocket isConnected ifTrue:[		sendState = #opening ifTrue: [			"connection established; disable TCP delays on sends"			sendSocket setOption: 'TCP_NODELAY' value: true.			"send worldExtent as first event"			firstEvt _ MorphicUnknownEvent type: #worldBounds argument: self worldBounds extent.			sendSocket sendData: firstEvt storeString, (String with: Character cr).			Transcript				show: 'Connection established with remote WorldMorph at ';				show: (NetNameResolver stringFromAddress: sendSocket remoteAddress); cr.			sendState _ #connected].		sendSocket sendData: sendBuffer contents.	] ifFalse: [		owner primaryHand removeEventListener: self.		sendState = #connected ifTrue: [			"other end has closed; close our end"			Transcript				show: 'Closing connection with remote WorldMorph at ';				show: (NetNameResolver stringFromAddress: sendSocket remoteAddress); cr.			sendSocket close.		sendState _ #closing]].	sendBuffer reset.! !!SameGameBoard methodsFor: 'actions' stamp: 'ar 10/25/2000 23:13'!hint	"find a possible selection and select it"	| tile |	self deselectSelection.	tile _ self findSelection.	tile ifNotNil: [tile mouseDown: MouseButtonEvent new]! !!SmartRefStream methodsFor: 'conversion' stamp: 'ar 10/25/2000 23:37'!morphicEventtcbks0	^ NewMorphicEvent! !!SmartRefStream methodsFor: 'conversion' stamp: 'ar 10/26/2000 00:48'!morphicSoundEventtcbkss0	^ MorphicUnknownEvent! !!TilePadMorph methodsFor: 'mouse' stamp: 'ar 10/25/2000 23:13'!prepareToUndoDropOf: aMorph	| m |	self mouseLeave: MouseMoveEvent new.	m _ self owner.	[m == nil] whileFalse: [		(m isKindOf: ScriptEditorMorph) ifTrue: [^ m prepareToUndoDropOf: aMorph].		m _ m owner].! !!UserInputEvent methodsFor: 'encoding' stamp: 'ar 10/25/2000 23:23'!encodedAsStringArray	"encode the receiver into an array of strings, such that it can be retrieved via the fromStringArray: class method"	^{		type.		CanvasEncoder encodePoint: position.		CanvasEncoder encodeInteger: buttons.	}! !!KeyboardEvent methodsFor: 'printing' stamp: 'ar 10/25/2000 22:07'!storeOn: aStream	aStream nextPutAll: type.	aStream space.	self timeStamp storeOn: aStream.	aStream space.	buttons storeOn: aStream.	aStream space.	keyValue storeOn: aStream.! !!KeyboardEvent methodsFor: 'private' stamp: 'ar 10/25/2000 22:08'!type: eventType readFrom: aStream	type _ eventType.	timeStamp _ Integer readFrom: aStream.	aStream skip: 1.	buttons _ Integer readFrom: aStream.	aStream skip: 1.	keyValue _ Integer readFrom: aStream.! !!KeyboardEvent methodsFor: 'encoding' stamp: 'ar 10/25/2000 23:31'!decodeFromStringArray: array	"decode the receiver from an array of strings"	type _ array first asSymbol.	position _ CanvasDecoder decodePoint: (array at: 2).	buttons _ CanvasDecoder decodeInteger: (array at: 3).	keyValue _ CanvasDecoder decodeInteger: (array at: 4).! !!MouseEvent methodsFor: 'printing' stamp: 'ar 10/25/2000 22:09'!storeOn: aStream	aStream nextPutAll: type.	aStream space.	self timeStamp storeOn: aStream.	aStream space.	position x storeOn: aStream.	aStream space.	position y storeOn: aStream.	aStream space.	buttons storeOn: aStream.! !!MouseEvent methodsFor: 'private' stamp: 'ar 10/25/2000 22:08'!type: eventType readFrom: aStream	| x y |	type _ eventType.	timeStamp _ Integer readFrom: aStream.	aStream skip: 1.	x _ Integer readFrom: aStream.	aStream skip: 1.	y _ Integer readFrom: aStream.	aStream skip: 1.	buttons _ Integer readFrom: aStream.	position _ x@y.! !!MouseButtonEvent methodsFor: 'encoding' stamp: 'ar 10/25/2000 23:31'!decodeFromStringArray: array	"decode the receiver from an array of strings"	type _ array first asSymbol.	position _ CanvasDecoder decodePoint: (array at: 2).	buttons _ CanvasDecoder decodeInteger: (array at: 3).	whichButton _ CanvasDecoder decodeInteger: (array at: 4).! !!MouseButtonEvent methodsFor: 'encoding' stamp: 'ar 10/25/2000 23:24'!encodedAsStringArray	"encode the receiver into an array of strings, such that it can be retrieved via the fromStringArray: class method"	^{		type.		CanvasEncoder encodePoint: position.		CanvasEncoder encodeInteger: buttons.		CanvasEncoder encodeInteger: whichButton.	}! !!MouseMoveEvent methodsFor: 'encoding' stamp: 'ar 10/25/2000 23:30'!decodeFromStringArray: array	"decode the receiver from an array of strings"	type _ array first asSymbol.	position _ CanvasDecoder decodePoint: (array at: 2).	buttons _ CanvasDecoder decodeInteger: (array at: 3).	startPoint _ CanvasDecoder decodePoint: (array at: 4).! !!MouseMoveEvent methodsFor: 'encoding' stamp: 'ar 10/25/2000 23:25'!encodedAsStringArray	"encode the receiver into an array of strings, such that it can be retrieved via the fromStringArray: class method"	^{		type.		CanvasEncoder encodePoint: position.		CanvasEncoder encodeInteger: buttons.		CanvasEncoder encodePoint: startPoint.	}! !UserInputEvent removeSelector: #setHand:!EventRecorderMorph removeSelector: #handleEvent:!EventRecorderMorph removeSelector: #handleSignificantEvent:!EventRecorderMorph removeSelector: #noteSignificantEvent:!AlignmentMorph subclass: #EventRecorderMorph	instanceVariableNames: 'tape state time deltaTime recHand playHand lastEvent lastDelta tapeStream saved statusLight voiceRecorder startSoundEvent recordMeter caption journalFile '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!"Postscript:Convert all existing old events into new ones"| old new |old _ MorphicEvent allInstances.new _ old collect:[:evt| NewMorphicEvent convertObsolete: evt].old elementsForwardIdentityTo: new.old _ MorphicSoundEvent allInstances.new _ old collect:[:evt| MorphicUnknownEvent new setType: #startSound argument: evt sound].old elementsForwardIdentityTo: new.!