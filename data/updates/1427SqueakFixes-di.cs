'From Squeak 2.5 of August 6, 1999 on 8 September 1999 at 12:33:42 am'!"Change Set:		SqueakFixesDate:			7 September 1999Author:			Dan IngallsFixes a few bugs reported in Squeakville...Deleting a page from a Morphic book with transitions now works correctly.	Reported by Bolot Kerimbaev.Positioning of Morphic windows and panes now work correctly in an MVC window.Ditto for fast reframing.	Reported by Doug Way.Also eliminates redundant display when zooming into MVC projects."!!BookMorph methodsFor: 'insert and delete' stamp: 'di 9/7/1999 21:57'!deletePageBasic	| thisPage |	thisPage _ self pageNumberOf: currentPage.	pages remove: currentPage.	currentPage delete.	currentPage _ nil.	pages isEmpty ifTrue: [^ self insertPage].	self goToPage: (thisPage min: pages size)! !!Project methodsFor: 'menu messages' stamp: 'di 9/8/1999 00:30'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case."	| showZoom recorderOrNil same |	self == CurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	World isMorph ifTrue: [World triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	CurrentProject makeThumbnail.	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue:[displayDepth _ Display depth].	Display newDepthNoRestore: displayDepth.	showZoom _ Preferences showProjectZoom		and: ["Only show zoom if there is room for the both displays plus a megabyte"			Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+1000000)].	showZoom ifTrue:[self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag		ifTrue: [nextProject _ CurrentProject]		ifFalse: [previousProject _ CurrentProject].	CurrentProject saveState.	(same _ CurrentProject topIsolated == self topIsolated) ifFalse: [		CurrentProject revoke].	CurrentProject _ self.	same ifFalse: [CurrentProject invoke].	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	World isMorph ifTrue:		[recorderOrNil _ World pauseEventRecorder].	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			recorderOrNil ifNotNil: [recorderOrNil resumeIn: World].			world triggerOpeningScripts.			self spawnNewProcessAndTerminateOld: true]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world.			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 9/7/1999 23:53'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds vbtl |	(self world firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[ ^ self  "Prevent multiple handles"].	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	vbtl _ self world viewBox topLeft.	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ growingPane bounds withSideOrCorner: side setToPoint: localPt.			Preferences fastDragWindowForMorphic			ifTrue:				["For fast display, only higlight the rectangle during loop"				newBounds _ (growingPane bounds translateBy: vbtl)					 newRectFrom:					[:f | (growingPane bounds translateBy: vbtl) withSideOrCorner: side							setToPoint: (self pointFromWorld: Sensor cursorPoint)].					self reframePanesAdjoining: growingPane along: side						to: (newBounds translateBy: vbtl negated)]			ifFalse:				[self reframePanesAdjoining: growingPane along: side to: newBounds]]		lastPointDo: [:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 9/7/1999 23:58'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds vbtl |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) ifTrue:  [^ self].	((self world ifNil: [^ self]) firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[^ self  "Prevent multiple handles"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	vbtl _ self world viewBox topLeft.	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ self bounds withSideOrCorner: ptName setToPoint: localPt.			Preferences fastDragWindowForMorphic			ifTrue:				["For fast display, only higlight the rectangle during loop"				newBounds _ (self bounds translateBy: vbtl) newRectFrom:					[:f | f extent > (100@80)						ifTrue: [f withSideOrCorner: ptName									setToPoint: (self pointFromWorld: Sensor cursorPoint)]						ifFalse: [f]].				self bounds: (newBounds translateBy: vbtl negated)]			ifFalse:				[newBounds extent > (100@80) ifTrue: [self bounds: newBounds].				(Preferences roundedWindowCorners					and: [#(bottom right bottomRight) includes: ptName])					ifTrue:					["Complete kluge: causes rounded corners to get painted correctly,					in spite of not working with top-down displayWorld."					ptName = #bottom ifFalse:						[self invalidRect: (self bounds topRight - (6@0) extent: 7@7)].					ptName = #right ifFalse:						[self invalidRect: (self bounds bottomLeft - (0@6) extent: 7@7)].					self invalidRect: (self bounds bottomRight - (6@6) extent: 7@7)]]]		lastPointDo:			[:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'events' stamp: 'di 9/7/1999 23:48'!mouseDown: evt	| cp offset newBounds vbtl |	self activate.	(Sensor redButtonPressed "If mouse is really still down after activate"		and: [self labelRect containsPoint: evt cursorPoint]) ifTrue:		["All copied from super (should use that code)"		Preferences fastDragWindowForMorphic		ifTrue: [vbtl _ self world viewBox topLeft.				offset _ self position + vbtl - Sensor cursorPoint.				newBounds _ (self bounds translateBy: vbtl)					newRectFrom: [:f | Sensor cursorPoint + offset extent: self extent].				^ self position: newBounds topLeft - vbtl]		ifFalse: [^ evt hand grabMorph: self topRendererOrSelf]].	model windowActiveOnFirstClick ifTrue:		["Normally window keeps control of first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseDown: evt]]]! !!SystemWindow methodsFor: 'drawing' stamp: 'di 9/7/1999 23:10'!makeMeVisible 	((self world bounds insetBy: (0@0 corner: self labelHeight asPoint))		containsPoint: self position) ifTrue: [^ self "OK -- at least my top left is visible"].	"window not on screen (probably due to reframe) -- move it now"	self isCollapsed		ifTrue: [self position: (RealEstateAgent assignCollapsePointFor: self)]		ifFalse: [self position: (RealEstateAgent initialFrameFor: self initialExtent: self extent) topLeft].! !!ObjectExplorerWindow methodsFor: 'as yet unclassified' stamp: 'di 9/7/1999 23:48'!mouseDown: evt	| offset newBounds vbtl |	self activate.	(Sensor redButtonPressed "If mouse is really still down after activate"		and: [self labelRect containsPoint: evt cursorPoint]) ifTrue:		["All copied from super (should use that code)"		Preferences fastDragWindowForMorphic		ifTrue: [vbtl _ self world viewBox topLeft.				offset _ self position + vbtl - Sensor cursorPoint.				newBounds _ (self bounds translateBy: vbtl)					newRectFrom: [:f | Sensor cursorPoint + offset extent: self extent].				^ self position: newBounds topLeft - vbtl]		ifFalse: [^ evt hand grabMorph: self topRendererOrSelf]].	true "model windowActiveOnFirstClick" ifTrue:		["Normally window keeps control of first click.		Need explicit transmission for first-click activity."		evt hand handleMouseDown: evt.	"this is more like it"	]! !