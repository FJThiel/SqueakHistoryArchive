'From Squeak3.1alpha [latest update: #''Squeak3.1alpha'' of 28 February 2001 update 3928] on 13 April 2001 at 12:25:01 am'!"Change Set:		prefJuntaPhaseTwo-swDate:			15 April 2001Author:			Scott WallaceRetools Preferences so that each individual preference is represented by a Preference object which holds all its state.  Numerous old tables are expunged by the postscript to this update.CAUTION: This fileout has been hand-jimmied"PreferencesPanel deleteAllPreferencesPanels!Object subclass: #Preference	instanceVariableNames: 'name value defaultValue helpString localToProject categoryList changeInformee changeSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!!Preference commentStamp: 'sw 4/12/2001 23:42' prior: 0!Represents a true/false flag that is under user control and which can be interrogated by a call to Preferences	name 				a symbol, the formal name of the preference.	value				a boolean, the current value	defaultValue		the default value of the preference	helpString 			string or text, constituting the help message	localToProject		boolean, whether each project holds its own version	categoryList			list of categories under which to offer this	changeInformee 	whom, if anyone, to inform if the value changes:	changeSelector 		what selector to send to the changeInformee when the value changes!Object subclass: #Preferences	instanceVariableNames: ''	classVariableNames: 'CategoryInfo DesktopColor DictionaryOfPreferences FlagDictionary FlagsHeldByProjects HelpDictionary Parameters SyntaxColorsAndStyles '	poolDictionaries: ''	category: 'System-Support'!!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:26'!autoAccessors	self flag: #hottest.	^ false! !!Preferences class methodsFor: 'add preferences' stamp: 'sw 4/10/2001 01:07'!preferenceAt: aSymbol	"Answer the Preference object at the given symbol, or nil if not there"	self flag: #hottest.	DictionaryOfPreferences ifNil: [^ FlagDictionary at: aSymbol].	^ DictionaryOfPreferences at: aSymbol ifAbsent: [nil]! !!Preferences class methodsFor: 'add preferences' stamp: 'sw 4/13/2001 00:24'!preferenceAt: aSymbol ifAbsent: aBlock	"Answer the Preference object at the given symbol, or the value of aBlock if not present"	self flag: #hottest.	"Interim step for bootstraping;"	DictionaryOfPreferences ifNil: [^ FlagDictionary at: aSymbol ifAbsent: [aBlock value]].	^ DictionaryOfPreferences at: aSymbol ifAbsent: [aBlock value]! !!Preference methodsFor: 'initialization' stamp: 'sw 4/10/2001 12:52'!name: aName defaultValue: aValue helpString: aString localToProject: projectBoolean categoryList: aList changeInformee: informee changeSelector:  aChangeSelector	"Initialize the preference from the given values.  There is an extra tolerence here for the symbols #true, #false, and #nil, which are interpreted, when appropriate, as meaning true, false, and nil"	name _ aName asSymbol.	defaultValue _ aValue == true or: [aValue = #true].	value _ defaultValue.	helpString _ aString.	localToProject _ projectBoolean == true or: [projectBoolean = #true].	categoryList _ aList ifNil: [OrderedCollection with: #Unclassified].	changeInformee _ (informee == nil or: [informee == #nil])						ifTrue: [nil]						ifFalse:	[(informee isKindOf: Symbol)							ifTrue:								[Smalltalk at: informee]							ifFalse:								[informee]].	changeSelector  _ aChangeSelector! !!Preference methodsFor: 'menu' stamp: 'sw 4/12/2001 23:42'!categoryList	"Answer the categoryList"	^ categoryList! !!Preference methodsFor: 'menu' stamp: 'sw 4/13/2001 00:01'!copyName	"Copy the name of the given preference to the clipboard"	Clipboard clipboardText: name asString asText! !!Preference methodsFor: 'menu' stamp: 'sw 4/13/2001 00:04'!helpString	"Answer the help string provided for the receiver"	^ helpString ifNil: ['no help available']! !!Preference methodsFor: 'menu' stamp: 'sw 4/10/2001 15:02'!name	"Answer this preference's name"	^ name! !!Preference methodsFor: 'menu' stamp: 'sw 4/13/2001 00:01'!offerPreferenceNameMenu: aPanel with: ignored1 in: ignored2	"the user clicked on a preference name -- put up a menu"	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: name.	(Preferences okayToChangeProjectLocalnessOf: name) ifTrue:		[aMenu addUpdating: #isProjectLocalString target: self action: #toggleProjectLocalness.		aMenu balloonTextForLastItem: 'Some preferences are best applied uniformly to all projects, and others are best set by each individual project.  If this item is checked, then this preference will be printed in bold and will have a separate value for each project'].	aMenu add: 'browse senders' target: Smalltalk  selector: #browseAllCallsOn: argument: name.	aMenu balloonTextForLastItem: 'This will open a method-list browser on all methods that the send the preference "', name, '".'. 	aMenu add: 'show category...' target: aPanel selector: #findCategoryFromPreference: argument: name.	aMenu balloonTextForLastItem: 'Allows you to find out which category, or categories, this preference belongs to.'.	Smalltalk isMorphic ifTrue:		[aMenu add: 'hand me a button for this preference' target: self selector: #tearOffButton.		aMenu balloonTextForLastItem: 'Will give you a button that governs this preference, which you may deposit wherever you wish'].	aMenu add: 'copy this name to clipboard' target: self selector: #copyName.	aMenu balloonTextForLastItem: 'Copy the name of the preference to the text clipboard, so that you can paste into code somewhere'.	aMenu popUpInWorld! !!Preference methodsFor: 'button' stamp: 'sw 4/12/2001 23:32'!representativeButtonWithColor: aColor inPanel: aPreferencesPanel	"Return a button that controls the setting of prefSymbol.  It will keep up to date even if the preference value is changed in a different place"	| outerButton aButton str miniWrapper |		outerButton _ AlignmentMorph newRow height: 24.	outerButton color:  (aColor ifNil: [Color r: 0.645 g: 1.0 b: 1.0]).	outerButton hResizing: (aPreferencesPanel ifNil: [#shrinkWrap] ifNotNil: [#spaceFill]).	outerButton vResizing: #shrinkWrap.	outerButton addMorph: (aButton _ UpdatingThreePhaseButtonMorph checkBox).	aButton		target: self;		actionSelector: #togglePreferenceValue;		getSelector: #preferenceValue.	outerButton addTransparentSpacerOfSize: (2 @ 0).	str _ StringMorph contents: name font: (StrikeFont familyName: 'NewYork' size: 12).	localToProject ifTrue:		[str emphasis: 1].	miniWrapper _ AlignmentMorph newRow hResizing: #shrinkWrap; vResizing: #shrinkWrap.	miniWrapper beTransparent addMorphBack: str lock.	aPreferencesPanel ifNotNil:		[miniWrapper on: #mouseDown send: #offerPreferenceNameMenu:with:in: to: self withValue: aPreferencesPanel].	outerButton addMorphBack: miniWrapper.	aButton setBalloonText: helpString.	miniWrapper setBalloonText: helpString; setProperty: #balloonTarget toValue: aButton.	^ outerButton	"self currentHand attachMorph: (Preferences buttonRepresenting: #balloonHelpEnabled"! !!Preference methodsFor: 'button' stamp: 'sw 4/10/2001 14:22'!tearOffButton	"Hand the user a button the can control this"	| aButton |	aButton _ self representativeButtonWithColor: self defaultBackgroundColor inPanel: nil.	aButton borderWidth: 1; borderColor:  Color black; useRoundedCorners.	aButton openInHand"(Preferences preferenceAt: #balloonHelpEnabled) tearOffButton"! !!Preference methodsFor: 'value' stamp: 'sw 4/10/2001 15:01'!defaultValue	"Answer this preference's defaultValue"	^ defaultValue! !!Preference methodsFor: 'value' stamp: 'sw 4/10/2001 15:35'!preferenceValue	"Answer the current value of the preference"	^ value! !!Preference methodsFor: 'value' stamp: 'sw 4/12/2001 23:28'!preferenceValue: aValue	"set the value as indicated, and invoke the change selector if appropriate"	| oldValue |	oldValue _ value.	value _ aValue.	oldValue ~~ value ifTrue:		[self notifyInformeeOfChange]! !!Preference methodsFor: 'value' stamp: 'sw 4/12/2001 23:28'!rawValue: aValue	"set the value as indicated, with no side effects"	value _ aValue! !!Preference methodsFor: 'value' stamp: 'sw 4/12/2001 00:04'!restoreDefaultValue	"restore the default value to the preference"	value _ defaultValue! !!Preference methodsFor: 'value' stamp: 'sw 4/12/2001 00:04'!togglePreferenceValue	"Toggle whether the value of the preference"	value _ value not.	self notifyInformeeOfChange! !!Preference methodsFor: 'local to project' stamp: 'sw 4/10/2001 12:37'!isProjectLocalString	"Answer a string representing whether sym is a project-local preference or not"	| aStr |	aStr _  'each project has its own setting'.	^ localToProject		ifTrue:			['<yes>', aStr]		ifFalse:			['<no>', aStr]! !!Preference methodsFor: 'local to project' stamp: 'sw 4/10/2001 01:14'!localToProject	"Answer whether this preference is project-local"	^ localToProject! !!Preference methodsFor: 'local to project' stamp: 'sw 4/10/2001 11:58'!toggleProjectLocalness	"Toggle whether the preference should be held project-by-project or globally"	localToProject _ localToProject not.	PreferencesPanel allInstancesDo:		[:aPanel | aPanel adjustProjectLocalEmphasisFor: name].! !!Preference methodsFor: 'change notification' stamp: 'sw 4/12/2001 01:39'!changeInformee: informee changeSelector: aSelector	"Set the changeInformee and changeSelector as specified"	changeInformee _ informee.	changeSelector _ aSelector! !!Preference methodsFor: 'change notification' stamp: 'sw 4/12/2001 00:03'!notifyInformeeOfChange	"If there is a changeInformee, notify her that I have changed value"	changeInformee ifNotNil: [changeInformee perform: changeSelector]! !!Preference methodsFor: 'debugging' stamp: 'sw 4/13/2001 00:05'!printOn: aStream	"Print a string decribing the receiver to the given stream"	super printOn: aStream.	aStream nextPutAll: name storeString, ' ', value storeString! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/11/2001 23:52'!addPreferenceForCelesteShowingAttachmentsFlag	"Assure the existence of a preference governing the showing of the celeste attachments flag"	"Preferences addPreferenceForCelesteShowingAttachmentsFlag"	self preferenceAt: #celesteShowsAttachmentsFlag ifAbsent:		[self				addPreference: #celesteShowsAttachmentsFlag				category: #general				default: false				balloonHelp: 'If true, Celeste (e-mail reader) annotates messages in it''s list that have attachments.  This is a performance hit and by default is off.']! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/11/2001 23:33'!addPreferenceForOptionalCelesteStatusPane	"Assure existence of a preference that governs the optional celeste status pane"	"Preferences addPreferenceForOptionalCelesteStatusPane"	self preferenceAt: #celesteHasStatusPane ifAbsent:		[self			addPreference: #celesteHasStatusPane			category: #general			default: false			balloonHelp: 'If true, Celeste (e-mail reader) includes a status pane.'		"Because Lex doesn't like it the default is false :)"]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/12/2001 01:56'!allPreferenceInitializationSpecs	"Answer a list of all the preference initialization specs found in the 'initial values' category; overlay any initial values found there if requested to be #defaultOverridesForCertainPreferences "	| aList additions overrides entryToAdd anOverride |	self flag: #toRemove.	overrides _ self defaultOverridesForCertainPreferences.	aList _ OrderedCollection new.	(self class organization listAtCategoryNamed: 'initial values' asSymbol) do:		[:aSelector | aSelector numArgs = 0 ifTrue:			[additions _ self perform: aSelector.			(additions isKindOf: Collection) ifFalse: [self error: 'method in "initial values" categories must return collections'].			additions do:				[:anAddition | (aList detect: [:elem | elem first == anAddition first] ifNone: [nil])					ifNil:						[entryToAdd _ (anOverride _ overrides detect: [:ov | ov first == anAddition first] ifNone: [nil])							ifNil:								[anAddition]							ifNotNil:								[{anAddition first. anOverride second}, (anAddition copyFrom: 3 to: anAddition size)].						aList add: entryToAdd]]]].	^ aList	"Preferences allPreferenceInitializationSpecs size"! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/12/2001 22:48'!bootstrapNewPreferenceScheme	"Bootstrap the new preference scheme"	| existing |	self flag: #toRemove.	self initializeDictionaryOfPreferences.	self allPreferenceFlagKeys do:		[:aKey |			self addPreferenceObjectFor: aKey].	self recompileAllPreferenceGetters.	self setNotificationParametersForStandardPreferences.	(self parameterAt: #Prevailing ifAbsent: [^ self]) associationsDo:  "Restore user's prevailing preference settings"		[:assoc | (assoc value isKindOf: Boolean) ifTrue:			[self setPreference: assoc key toValue: assoc value]].	(Project current projectParameterAt: #PrevailingProjectFlags ifAbsent: [^ self])		associationsDo:			[:assoc | (self preferenceAt: assoc key) rawValue:  assoc value]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/10/2001 15:28'!chooseInitialSettings	"Restore the default choices for all of the standard Preferences."	self allPreferenceObjects do:		[:aPreference |			aPreference restoreDefaultValue].	Project current installProjectPreferences! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/10/2001 14:52'!compileAccessMethodForPreference: aPreference	"Compile an accessor method for the given preference"	self class compileProgrammatically: (aPreference name, '	^ self valueOfFlag: #', aPreference name, ' ifAbsent: [', aPreference defaultValue storeString, ']') classified: 'standard queries'! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/12/2001 01:56'!defaultOverridesForCertainPreferences	"Answer a list of overrides to the default settings of certain preferences.  The default state of preferences -- i.e. the one you get back to if you hit the 'Restore all System Defaults' button -- is defined by the initializer methods of preferences (look in category 'initial values' in Preferences class), as then subsequently amended and overridden by this table, which will continue to evolve right up to each release, and which users may wish to hand-edit as well for their own private configurations"	self flag: #toRemove.	^ #((capitalizedReferences			true)		(clickOnLabelToEdit				false)		(decorateBrowserButtons			false)		(fastDragWindowForMorphic		true)		(infiniteUndo					false)		(menuColorFromWorld			true)		(mvcProjectsAllowed				true)		(optionalButtons					false)		(preserveTrash					false)		(roundedWindowCorners			true)		(scrollBarsNarrow				false)		(soundsEnabled					true)		(useGlobalFlaps					true))! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/12/2001 22:51'!expungePreferenceNamed: aSymbol	"Remove all memory of the given preference symbol in my various structures."	self preferenceAt: aSymbol ifAbsent: [^ self].	DictionaryOfPreferences removeKey: aSymbol ifAbsent: [].	self class removeSelector: aSymbol"Preferences expungePreferenceNamed: #tileToggleInBrowsers"! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/12/2001 00:00'!initialize	"Preferences initialize"	"Sometimes placed in a change-set even though unchanged, to trigger reinitialization upon update."	self flag: #toRemove.	FlagDictionary _ Dictionary new.	self chooseInitialSettings! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/4/2001 00:09'!initializeDictionaryOfPreferences	"Initialize the DictionaryOfPreferences to be an empty IdentityDictionary"	"Preferences initializeDictionaryOfPreferences"	DictionaryOfPreferences _ IdentityDictionary new.! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/12/2001 00:09'!initializeHelpMessages	"Initialize the preferences help messages from the initialization information found"	self flag: #toRemove.  	HelpDictionary _ IdentityDictionary new.	self allPreferenceInitializationSpecs do:		[:quad |			quad size >= 4 ifTrue:				[HelpDictionary at: quad first put: quad fourth]]	"Preferences initializeHelpMessages"! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/10/2001 14:43'!listOfCategories	"Answer a list of category names for the preferences panel"	| categoryNames |	categoryNames _ Set new.	DictionaryOfPreferences do:		[:aPreference |  			categoryNames addAll: aPreference categoryList].	categoryNames _ categoryNames asSortedArray.	^ {'?'}, categoryNames asSortedArray, {'search results'}	"Preferences listOfCategories"! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/12/2001 01:57'!postHocCategoryAdjustments	"Provides a table governing post-hoc changes to default categories for certain preferences.  In the table below, each element gives the name a preference and a list of categories it belongs in; the method returns a dictionary whose keys are the pref names and whose values are the ultimate desired list."	| aDictionary |	self flag: #toRemove.	aDictionary _ IdentityDictionary new.	#(	(checkForUnsavedProjects			(projects))		(mvcProjectsAllowed					(projects))		(projectViewsInWindows				(projects))		(projectZoom							(projects))		(projectsSendToDisk					(projects))		(signProjectFiles						(projects))) do:		[:pair | aDictionary at: pair first put: pair second].	^ aDictionary! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/10/2001 13:18'!restorePersonalPreferences	"Restore all the user's saved personal preferences"	| savedPrefs |	savedPrefs _ self parameterAt: #PersonalDictionaryOfPreferences ifAbsent: [^ self inform: 'There are no personal preferences saved in this image yet'].	savedPrefs associationsDo:		[:assoc | DictionaryOfPreferences at: assoc key put: assoc value]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 4/10/2001 13:16'!savePersonalPreferences	"Save the current list of Preference settings as the user's personal choices"	self setParameter: #PersonalDictionaryOfPreferences to: DictionaryOfPreferences deepCopy! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 4/12/2001 23:29'!disable: aSymbol	"Shorthand access to enabling a preference of the given name.  If there is none in the image, conjure one up"	| aPreference |	aPreference _ self preferenceAt: aSymbol ifAbsent:		[self addPreference: aSymbol category: 'unclassified' default: false balloonHelp: 'this preference was added idiosyncratically and has no help message.'.		self preferenceAt: aSymbol].	aPreference preferenceValue: false! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 4/12/2001 23:29'!enable: aSymbol	"Shorthand access to enabling a preference of the given name.  If there is none in the image, conjure one up"	| aPreference |	aPreference _ self preferenceAt: aSymbol ifAbsent:		[self addPreference: aSymbol category: 'unclassified' default: true balloonHelp: 'this preference was added idiosyncratically and has no help message.'.		self preferenceAt: aSymbol].	aPreference preferenceValue: true! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 4/11/2001 23:55'!inspectPreferences	"Open a window on the current preferences dictionary, allowing the user to inspect and change the current preference settings.  This is fallen back upon if Morphic is not present"	"Preferences inspectPreferences"	DictionaryOfPreferences inspectWithLabel: 'Preferences'! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 4/10/2001 15:42'!oldValueOfFlag: aFlagName	"Answer the value of the given flag"	self flag: #toRemove.	^ (self isProjectPreference: aFlagName)		ifTrue:			[Project current projectPreferenceAt: aFlagName]		ifFalse:			[FlagDictionary at: aFlagName ifAbsent: [false]]! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 4/12/2001 01:20'!optionalButtonsChanged	"The setting of the optionalButtons preference changed; react"	Utilities replacePartSatisfying: [:el | (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isKindOf: FileList]]] inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  FileList openAsMorph applyModelExtent.	Utilities replaceBrowserInToolsFlap! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 4/11/2001 23:19'!preferencesLackingInitializers	self flag: #toRemove.	^ self allPreferenceFlagKeys copyWithoutAll: (self allPreferenceInitializationSpecs collect: [:info | info first])"Preferences preferencesLackingInitializers"! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 4/12/2001 23:29'!setPreference: prefSymbol toValue: aBoolean	"Set the given preference to the given value, and answer that value"	^ (self preferenceAt: prefSymbol ifAbsent: [^ aBoolean]) preferenceValue: aBoolean! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 4/12/2001 00:08'!helpMessageForPreference: aSymbol	self flag: #toRemove.	^ (self helpMessageOrNilForPreference: aSymbol) ifNil:		['No help available for ', aSymbol]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 4/12/2001 00:09'!helpMessageOrNilForPreference: aSymbol	"If the HelpDictionary has a help message prepared for aSymbol, return it, else return nil"	self flag: #toRemove.	HelpDictionary ifNil: [self initializeHelpMessages].	^ HelpDictionary at: aSymbol ifAbsent: [nil]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 4/12/2001 00:07'!openPreferencesControlPanel	"Open a preferences panel"	"Preferences openPreferencesControlPanel"	Smalltalk verifyMorphicAvailability ifFalse: [^ self beep].	^ self openFactoredPanel! !!Preferences class methodsFor: 'reacting to change' stamp: 'sw 4/12/2001 01:22'!annotationPanesChanged	"The setting of the annotationPanes preference changed; react"	Utilities replaceBrowserInToolsFlap! !!Preferences class methodsFor: 'reacting to change' stamp: 'sw 4/12/2001 01:31'!eToyFriendlyChanged	"The eToyFriendly preference changed; React"		ScriptingSystem customizeForEToyUsers: Preferences eToyFriendly! !!Preferences class methodsFor: 'reacting to change' stamp: 'sw 4/12/2001 01:09'!globalFlapsSettingChanged	"The user has changed the setting of #useGlobalFlaps; react"	| keep |	self useGlobalFlaps  "i.e. what it just changed to"		ifFalse:		"Turning off use of flaps"			[keep _ self confirm:'Do you want to preserve the existingglobal flaps for future use?'.			Utilities globalFlapTabsIfAny do:				[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: keep.				aFlapTab isInWorld ifTrue: [self error: 'Flap problem']].			keep ifFalse: [Utilities clobberFlapTabList]]		ifTrue:		"Turning on use of flaps"			[Smalltalk isMorphic ifTrue:				[self currentWorld enableGlobalFlaps]]! !!Preferences class methodsFor: 'reacting to change' stamp: 'sw 4/12/2001 01:32'!infiniteUndoChanged	"The infiniteUndo preference changed; react"		self infiniteUndo ifFalse:		[CommandHistory resetAllHistory]! !!Preferences class methodsFor: 'reacting to change' stamp: 'sw 4/12/2001 01:11'!roundedWindowCornersChanged	"The user changed the value of the roundedWindowCorners preference.  React"	ActiveWorld fullRepaintNeeded! !!Preferences class methodsFor: 'reacting to change' stamp: 'sw 4/13/2001 12:07'!setNotificationParametersForStandardPreferences	"Set up the notification parameters for the standard preferences that require it.  Others obtain them via the code that creates them."		"Preferences setNotificationParametersForStandardPreferences"	| aPreference |	#(			(annotationPanes		annotationPanesChanged)		(eToyFriendly			eToyFriendlyChanged)		(infiniteUndo			infiniteUndoChanged)		(largeTiles				largeTilesSettingToggled)		(optionalButtons			optionalButtonsChanged)		(roundedWindowCorners	roundedWindowCornersChanged)		(showProjectNavigator	showProjectNavigatorChanged)		(smartUpdating			smartUpdatingChanged)		(universalTiles			universalTilesSettingToggled)		(useGlobalFlaps			useGlobalFlapsChanged))  do:			[:pair |				aPreference _ self preferenceAt: pair first.				aPreference changeInformee: self changeSelector: pair second]! !!Preferences class methodsFor: 'reacting to change' stamp: 'sw 4/12/2001 01:33'!showProjectNavigatorChanged	"The showProjectNavigatorChanged preference changed; react"		Project current assureNavigatorPresenceMatchesPreference! !!Preferences class methodsFor: 'reacting to change' stamp: 'sw 4/12/2001 01:30'!smartUpdatingChanged	"The smartUpdating preference changed. React"	SystemWindow allSubInstancesDo:		[:aWindow | aWindow amendSteppingStatus]	"NOTE: This makes this preference always behave like a global preference, which is problematical"! !!Preferences class methodsFor: 'pref buttons' stamp: 'sw 4/12/2001 00:04'!togglePreference: prefSymbol	"Toggle the given preference"	(self preferenceAt: prefSymbol ifAbsent: [self error: 'unknown preference: ', prefSymbol]) togglePreferenceValue! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 4/11/2001 23:19'!allGlobalPreferenceFlagKeys	"Answer a list of all the keys in the global FlagDictionary"	self flag: #toRemove.	^ FlagDictionary keys asOrderedCollection	"Preferences allGlobalPreferenceFlagKeys"! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 4/11/2001 23:19'!allPreferenceFlagKeys	"Answer a sorted list of all preference keys, whether they be global or project-specific"	| keys |	self flag: #toRemove.	keys _ self allGlobalPreferenceFlagKeys.	keys addAll: self flagsHeldByProjects keys.	^ keys asSet asSortedArray	"Preferences allPreferenceFlagKeys"! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 4/13/2001 00:06'!allPreferenceObjects	"Answer a list of all the Preference objects registered in the system"	^ DictionaryOfPreferences values! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 4/12/2001 22:46'!categoriesContainingPreference: prefSymbol	"Return a list of all categories in which the preference occurs"	self flag: #toRemove.	^ self factoredCategories select:		[:pair |  pair second includes: prefSymbol] thenCollect:			[:pair | pair first]! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 4/11/2001 23:15'!factoredCategories	"Answer the list of categories, each with its corresponding list of elements"	| prefsWithoutInits extraItem |	"CategoryInfo _ nil"	self flag: #toRemove.	CategoryInfo ifNil:		[CategoryInfo _ self initialCategoryInfo].	((prefsWithoutInits _ self preferencesLackingInitializers) size > 0)		ifTrue:			[extraItem _ (Array with: 'uncategorized' with: prefsWithoutInits asSortedArray)].	^ {{'?'. {}}}, (extraItem		ifNil:			[CategoryInfo]		ifNotNil:			[CategoryInfo, {extraItem}]) copyWith: {'search results'. OrderedCollection new}	"Preferences factoredCategories"! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 4/12/2001 01:53'!initialCategoryInfo	"Answer an alphabetized array of pairs, each of which consists of:		the name of a category		a list of preferences belonging to that category	This is done by scanning all the initializer methods found in category 'initial values' in Preferences class."	| categories catList adjustments itsCategories |	self flag: #toRemove.	categories _ IdentityDictionary new.	adjustments _ self postHocCategoryAdjustments.	self allPreferenceInitializationSpecs do:		[:spec |			itsCategories _ adjustments at: spec first ifAbsent: [spec size > 2 ifTrue:				[spec third] ifFalse: [#()]].			itsCategories do:					[:sym | 						(categories includesKey: sym) ifFalse:							[categories at: sym put: OrderedCollection new].					((catList _ categories at: sym) includes: spec first)						ifFalse:	[catList add: spec first]]].	^ categories keys asSortedArray collect:		[:aKey | Array with: aKey with: (categories at: aKey) asSortedArray]! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 4/10/2001 14:44'!initializePreferencePanel: aPanel in: aPasteUpMorph	"Initialize the given Preferences panel. in the given pasteup, which is the top-level panel installed in the container window.  Also used to reset it after some change requires reformulation"	| tabbedPalette controlPage aColor aFont maxEntriesPerCategory tabsMorph anExtent  prefObjects |	aPasteUpMorph removeAllMorphs.	aFont _ StrikeFont familyName: 'NewYork' size: 19.	aColor _ aPanel defaultBackgroundColor.	tabbedPalette _ TabbedPalette newSticky.	tabbedPalette dropEnabled: false.	(tabsMorph _ tabbedPalette tabsMorph) color: aColor darker;		 highlightColor: Color red regularColor: Color brown darker darker.	tabbedPalette on: #mouseDown send: #yourself to: #().	maxEntriesPerCategory _ 0.	self listOfCategories do: 		[:aCat | 			controlPage _ AlignmentMorph newColumn beSticky color: aColor.			controlPage on: #mouseDown send: #yourself to: #().			controlPage dropEnabled: false.			controlPage borderColor: aColor;				 layoutInset: 4.			(prefObjects _ self preferenceObjectsInCategory: aCat) do:				[:aPreference | controlPage						addMorphBack: (aPreference representativeButtonWithColor: nil inPanel: aPanel)].			controlPage setNameTo: aCat asString.			aCat = '?'				ifTrue:	[aPanel addHelpItemsTo: controlPage].			aCat == #halos				ifTrue: [aPanel addHaloControlsTo: controlPage].			tabbedPalette addTabFor: controlPage font: aFont.			aCat = 'search results' ifTrue:				[(tabbedPalette tabNamed: aCat) setBalloonText:					'Use the ? category to find preferences by keyword; the results of your search will show up here'].		maxEntriesPerCategory _ maxEntriesPerCategory max: prefObjects size].	tabbedPalette selectTabNamed: '?'.	tabsMorph rowsNoWiderThan: aPasteUpMorph width.	aPasteUpMorph on: #mouseDown send: #yourself to: #().	anExtent _ aPasteUpMorph width @ (25 + tabsMorph height + (20 * maxEntriesPerCategory)).	aPasteUpMorph extent: anExtent.	aPasteUpMorph color: aColor.	aPasteUpMorph 	 addMorphBack: tabbedPalette.! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 4/14/2001 17:48'!preferenceObjectsInCategory: aCategorySymbol	"Answer a list of Preference objects that reside in the given category, in alphabetical order"	^ (DictionaryOfPreferences select:		[:aPreference | aPreference categoryList includes: aCategorySymbol])			asSortedCollection:				[:pref1 :pref2 | pref1 name < pref2 name]! !!Preferences class methodsFor: 'factored pref panel' stamp: 'sw 4/10/2001 14:56'!recompileAllPreferenceGetters	"Recompile all the preference getters"		self flag: #toRemove.	self allPreferenceObjects do:		[:aPreference |			self compileAccessMethodForPreference: aPreference]	"Preferences recompileAllPreferenceGetters"! !!Preferences class methodsFor: 'add preferences' stamp: 'sw 4/10/2001 14:55'!addPreference: prefSymbol categories: categoryList default: defaultValue balloonHelp: helpString 	"Add an item repreesenting the given preference symbol to the system"	self addPreference: prefSymbol  categories: categoryList  default:  defaultValue balloonHelp: helpString  projectLocal: false  changeInformee: nil changeSelector: nil! !!Preferences class methodsFor: 'add preferences' stamp: 'sw 4/12/2001 23:15'!addPreference: prefSymbol categories: categoryList default: aValue balloonHelp: helpString projectLocal: localBoolean changeInformee: informeeSymbol  changeSelector: aChangeSelector	"Add or replace a preference as indicated.  This replaces an pre-existing preference object with the same key."	| aPreference |	aPreference _ Preference new name: prefSymbol defaultValue: aValue helpString: helpString localToProject: localBoolean categoryList: categoryList changeInformee: informeeSymbol changeSelector:  aChangeSelector.	DictionaryOfPreferences at: prefSymbol put: aPreference.	self compileAccessMethodForPreference: aPreference! !!Preferences class methodsFor: 'add preferences' stamp: 'sw 4/10/2001 14:30'!addPreferenceObjectFor: prefSymbol	"For transition only: create a Preference instance representing a pre-existing preference"	self flag: #toRemove.	self addPreference: prefSymbol		categories: (Preferences categoriesContainingPreference: prefSymbol)		default: (Preferences oldValueOfFlag: prefSymbol)		balloonHelp: (Preferences helpMessageForPreference: prefSymbol)		projectLocal: (Preferences isProjectPreference: prefSymbol)		changeInformee: nil		changeSelector: nil! !!Preferences class methodsFor: 'add preferences' stamp: 'sw 4/10/2001 01:07'!preferenceAt: aSymbol	"Answer the Preference object at the given symbol, or nil if not there"	self flag: #hottest.	DictionaryOfPreferences ifNil: [^ FlagDictionary at: aSymbol].	^ DictionaryOfPreferences at: aSymbol ifAbsent: [nil]! !!Preferences class methodsFor: 'add preferences' stamp: 'sw 4/13/2001 00:24'!preferenceAt: aSymbol ifAbsent: aBlock	"Answer the Preference object at the given symbol, or the value of aBlock if not present"	self flag: #hottest.	"Interim step for bootstraping;"	DictionaryOfPreferences ifNil: [^ FlagDictionary at: aSymbol ifAbsent: [aBlock value]].	^ DictionaryOfPreferences at: aSymbol ifAbsent: [aBlock value]! !!PreferencesPanel methodsFor: 'initialization' stamp: 'sw 4/10/2001 14:19'!findPreferencesMatching: incomingTextOrString	"find all preferences matching incomingTextOrString"	| result aList aPalette controlPage |	result _ incomingTextOrString asString asLowercase.	result _ result asLowercase withBlanksTrimmed.	result isEmptyOrNil ifTrue: [^ self].	aList _ Preferences allPreferenceObjects select:		[:aPreference | 			(aPreference name includesSubstring: result caseSensitive: false) or:				[aPreference helpString includesSubstring: result caseSensitive: false]].	aPalette _ self dependents first containingWindow findDeeplyA: TabbedPalette.	aPalette ifNil: [^ self].	aPalette selectTabNamed:  'search results'.	aPalette currentPage ifNil: [^ self].  "bkwd compat"	controlPage _ aPalette currentPage.	controlPage removeAllMorphs.	controlPage addMorph: (StringMorph contents: ('Preferences matching "', self searchString, '"') font: Preferences standardButtonFont).	aList do:		[:aPreference |			controlPage addMorphBack: (aPreference representativeButtonWithColor: nil inPanel: self)].	aPalette world startSteppingSubmorphsOf: aPalette! !!Project methodsFor: 'menu messages' stamp: 'sw 4/12/2001 22:45'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess |	(world isKindOf: StringMorph) ifTrue: [		self inform: 'This project is not all here. I will try to load a complete version.'.		^self loadFromServer: true	"try to get a fresh copy"	].	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [			CurrentProject finalExitActions.			CurrentProject makeThumbnail.			returningFlag == #specialReturn				ifTrue:					[ProjectHistory forget: CurrentProject.		"this guy is irrelevant"					Project forget: CurrentProject]				ifFalse:					[ProjectHistory remember: CurrentProject]].	(revertFlag | saveForRevert | forceRevert) ifFalse:		[(Preferences valueOfFlag: #projectsSentToDisk) ifTrue:			[self storeToMakeRoom]].	CurrentProject abortResourceLoading.	Smalltalk isMorphic ifTrue: [CurrentProject world triggerClosingScripts].	CurrentProject saveProjectPreferences.	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresentAndInMemory:					[:playerClass | playerClass allSubInstancesDo:						[:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject _ nil	] ifFalse: [		returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	self installProjectPreferences.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ World pauseEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			world transferRemoteServerFrom: old world.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		world repairEmbeddedWorlds.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess _ [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!Project methodsFor: 'menu messages' stamp: 'sw 4/12/2001 23:29'!installProjectPreferences	"Install the settings of all preferences presently held individually by projects in the receiver's projectPreferenceFlagDictionary"	| localValue |	Preferences allPreferenceObjects do:		[:aPreference | 			aPreference localToProject ifTrue:				[localValue _ projectPreferenceFlagDictionary at: aPreference name ifAbsent: [nil].				localValue ifNotNil:					[aPreference rawValue: localValue]]]! !!Project methodsFor: 'menu messages' stamp: 'sw 4/12/2001 22:29'!saveProjectPreferences	"Preserve the settings of all preferences presently held individually by projects in the receiver's projectPreferenceFlagDictionary"	Preferences allPreferenceObjects do:		[:aPreference | 			aPreference localToProject ifTrue:				[projectPreferenceFlagDictionary at: aPreference name put: aPreference preferenceValue]]! !!Project methodsFor: 'project parameters' stamp: 'sw 4/12/2001 20:29'!initializeProjectPreferences	"Initialize the project's preferences from currently-prevailing preferences that are currently being held in projects in this system"		projectPreferenceFlagDictionary _ Project current projectPreferenceFlagDictionary deepCopy.    "Project overrides in the new project start out being the same set of overrides in the calling project"	Preferences allPreferenceObjects do:  "in case we missed some"		[:aPreference |			aPreference localToProject ifTrue:				[(projectPreferenceFlagDictionary includesKey: aPreference name) ifFalse:			[projectPreferenceFlagDictionary at: aPreference name put: aPreference preferenceValue]]].	(Project current projectParameterAt: #globalFlapsEnabledInProject) ifNotNilDo:		[:aBoolean | self projectParameterAt: #globalFlapsEnabledInProject put:			aBoolean].	(Project current projectParameterAt: #disabledGlobalFlaps ifAbsent: [nil]) ifNotNilDo:		[:flaps | self projectParameterAt: #disabledGlobalFlaps put: flaps copy]! !!Project methodsFor: 'project parameters' stamp: 'sw 4/12/2001 23:36'!projectPreferenceAt: aSymbol	"Answer the project preference stored at the given symbol.  If there is none in the local preference dictionary, it must be because it was only latterly declared to be a project-local preference, so obtain its initial value instead from the last-known global or default setting"	| aValue |	^ self projectPreferenceAt: aSymbol ifAbsent: 		[aValue _ Preferences valueOfFlag: aSymbol.		self projectPreferenceFlagDictionary at: aSymbol put: aValue.		^ aValue]! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 4/12/2001 23:34'!valueOfFlag: aFlagName	"Answer the value of the given flag"	DictionaryOfPreferences ifNil: [^ FlagDictionary at: aFlagName ifAbsent: [false]].	^ (self preferenceAt: aFlagName ifAbsent: [^ false]) preferenceValue! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 4/11/2001 23:50'!valueOfFlag: aFlagName ifAbsent: booleanValuedBlock	"Answer the value of the given flag"	DictionaryOfPreferences ifNil: [^ FlagDictionary at: aFlagName ifAbsent: [false]].	^ (self preferenceAt: aFlagName ifAbsent: [^ booleanValuedBlock value]) preferenceValue! !"Postscript:"Preferences bootstrapNewPreferenceScheme.!