'From Squeak 2.3 beta of Nov 25, 1998 on 12 January 1999 at 5:44:41 pm'!"Change Set:		jhmBMPFixesDate:			12 January 1999Author:			John MaloneyFixes the BMP file reader for the case where the creater doesnot set the colorCount field of the header. (Some programs, suchas PhotoShop 4.0 do not set this field)."!!Form class methodsFor: 'BMP file reading' stamp: 'jm 1/12/1999 17:31'!bmpColorsFrom: aBinaryStream count: colorCount depth: depth	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."	| maxLevel colors b g r |	colorCount = 0 ifTrue: [  "this BMP file does not have a color map"		"default monochrome color map"		depth = 1 ifTrue: [^ Array with: Color white with: Color black].		"default gray-scale color map"		maxLevel _ (2 raisedTo: depth) - 1.		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].	colors _ Array new: (2 raisedTo: depth).	1 to: colorCount do: [:i |		b _ aBinaryStream next.		g _ aBinaryStream next.		r _ aBinaryStream next.		aBinaryStream skip: 1.		colors at: i put: (Color r: r g: g b: b range: 255)].	^ colors! !!Form class methodsFor: 'BMP file reading' stamp: 'jm 1/12/1999 17:37'!fromBMPFile: aBinaryStream	"Read a BMP format image from the given binary stream."	"Form fromBMPFile:		(HTTPSocket			httpGet: 'http://anHTTPServer/squeak/squeakers.bmp'			accept: 'image/bmp')"	| fType fSize reserved pixDataStart hdrSize w h planes d      compressed colorCount colors colorForm |	(aBinaryStream isMemberOf: String) ifTrue: [^ nil].  "a network error message"	aBinaryStream binary.	fType _ aBinaryStream nextLittleEndianNumber: 2.	fSize _ aBinaryStream nextLittleEndianNumber: 4.	reserved _ aBinaryStream nextLittleEndianNumber: 4.	pixDataStart _ aBinaryStream nextLittleEndianNumber: 4.	hdrSize _ aBinaryStream nextLittleEndianNumber: 4.	w _ aBinaryStream nextLittleEndianNumber: 4.	h _ aBinaryStream nextLittleEndianNumber: 4.	planes _ aBinaryStream nextLittleEndianNumber: 2.	d _ aBinaryStream nextLittleEndianNumber: 2.	compressed _ aBinaryStream nextLittleEndianNumber: 4.	aBinaryStream nextLittleEndianNumber: 4.  "biSizeImage"	aBinaryStream nextLittleEndianNumber: 4.  "biXPelsPerMeter"	aBinaryStream nextLittleEndianNumber: 4.  "biYPelsPerMeter"	colorCount _ aBinaryStream nextLittleEndianNumber: 4.	aBinaryStream nextLittleEndianNumber: 4.  "biClrImportant"	((fType = 19778) & (reserved = 0) & (planes = 1) &	 (hdrSize = 40) & (fSize <= aBinaryStream size))		ifFalse: [self error: 'Bad BMP file header'].	compressed = 0		ifFalse: [self error: 'Can only read uncompressed BMP files'].	d = 24 ifTrue: [		aBinaryStream position: pixDataStart.		^ self bmp24BitPixelDataFrom: aBinaryStream width: w height: h].	"read the color map"	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"	colorCount _ (pixDataStart - 54) // 4.	colors _ self bmpColorsFrom: aBinaryStream count: colorCount depth: d.	"read the pixel data"	aBinaryStream position: pixDataStart.	colorForm _ self bmpPixelDataFrom: aBinaryStream width: w height: h depth: d.	colorForm colors: colors.	^ colorForm! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'jm 1/12/1999 12:02'!loadOnImage: fileName	"Read in and convert the image for the paintBox with the buttonson.  A .bmp 24-bit image.  For each button, cut that chunk out and save it."	"	self loadOnImage: 'NoSh_on.bmp'.		AllOnImage _ nil.	'save space'.	"	| pic16Bit blt aa on type |	type _ 'gif'.  "   gif or bmp  "type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	pic16Bit display.	aa _ AllOnImage _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	].type = 'bmp' ifTrue: [	pic16Bit _ (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	pic16Bit display.	aa _ AllOnImage _ Form extent: OriginalBounds extent depth: 16.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	aa removeZeroPixelsFromForm.	].	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			type = 'gif' ifTrue: [on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors]				ifFalse: [on _ Form extent: button extent depth: 16].			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button onImage: on]].	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'jm 1/12/1999 12:02'!loadPressedImage: fileName	"Read in and convert the image for the paintBox with the buttonson.  A .bmp 24-bit image.  For each button, cut that chunk out and save it."	"	self loadPressedImage: 'NoSh_on.bmp'.		AllPressedImage _ nil.	'save space'.	"	| pic16Bit blt aa on type |	type _ 'gif'.  "   gif or bmp  "type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	pic16Bit display.	aa _ AllPressedImage _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	].type = 'bmp' ifTrue: [	pic16Bit _ (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	pic16Bit display.	aa _ AllPressedImage _ Form extent: OriginalBounds extent depth: 16.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	aa removeZeroPixelsFromForm.	].	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			type = 'gif' ifTrue: [on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors]				ifFalse: [on _ Form extent: button extent depth: 16].			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button pressedImage: on]].	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'jm 1/12/1999 12:01'!loadRotScalePics	"Load up class vars with .bmp files for the images of the Rotation control button and the Scale control button."	rotationTabForm _ (Form fromBMPFileNamed: 'Rotaball.bmp') asFormOfDepth: 16.	scaleTabForm _ (Form fromBMPFileNamed: 'Scalball.bmp') asFormOfDepth: 16.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'jm 1/12/1999 12:01'!loadoffImage: fileName	"Read in and convert the background image for the paintBox.  Allbuttons off.  A .bmp 24-bit image."	"	Prototype loadoffImage: 'roundedPalette3.bmp'	"	| pic16Bit blt type getBounds |	type _ 'bmp'.  " gif or bmp  "	getBounds _ 'fromPic'.	"fromUser = draw out rect of paintbox on image"		"fromOB = just read in new bits, keep same size and place as last time."		"fromPic = picture is just the PaintBox, use its bounds"type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	getBounds = 'fromUser' ifTrue: ["Just first time, collect the bounds"			pic16Bit display.			OriginalBounds _ Rectangle fromUser].	getBounds = 'fromPic' ifTrue: [OriginalBounds _ pic16Bit boundingBox].	].		"Use OriginalBounds as it was last time".type = 'bmp' ifTrue: [	pic16Bit _ (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	getBounds = 'fromUser' ifTrue: ["Just first time, collect the bounds"			pic16Bit display.			OriginalBounds _ Rectangle fromUser].		"Use OriginalBounds as it was last time".	(getBounds = 'fromPic') ifTrue: [OriginalBounds _ pic16Bit boundingBox].	AllOffImage _ Form extent: OriginalBounds extent depth: 16.	].type = 'gif' ifTrue: [	AllOffImage _ ColorForm extent: OriginalBounds extent depth: 8.	AllOffImage colors: pic16Bit colors].	blt _ BitBlt toForm: AllOffImage.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.type = 'bmp' ifTrue: [AllOffImage removeZeroPixelsFromForm].	self image: AllOffImage.	self invalidRect: bounds.	! !Form class removeSelector: #fromBMPFileNamed:depth:!Form class removeSelector: #bmpColorsFrom:count:!