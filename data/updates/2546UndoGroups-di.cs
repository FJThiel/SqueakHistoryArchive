'From Squeak2.9alpha of 12 June 2000 [latest update: #2545] on 31 August 2000 at 12:09:13 am'!"Change Set:		UndoGroupsDate:			30 August 2000Author:			Dan IngallsAllows any morph to override its default undo behavior (needed for selections).Supports undo for border width of BorderedMorphs.Supports undo for color and border changes in multiple selections.Supports undo for move of multiple selections.Fixes a bug in display of command to undo when last command has been undone.Yet to do...[ ]	undo duplicate for normal morphs[ ]	undo duplicate for groups.[ ]	undo delete for normal morphs[ ]	undo delete for groups."!HandleMorph subclass: #NewHandleMorph	instanceVariableNames: 'hand offset waitingForClickInside '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!EllipseMorph subclass: #HandleMorph	instanceVariableNames: 'pointBlock lastPointBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!Command methodsFor: 'initialization' stamp: 'di 8/30/2000 20:53'!redoTarget: target selector: selector arguments: arguments	"Give target morph a chance to refine its undo operation"	target refineRedoTarget: target selector: selector arguments: arguments in:		[:rTarget :rSelector :rArguments |		redoTarget _ rTarget.		redoSelector _ rSelector.		redoArguments _ rArguments]! !!Command methodsFor: 'initialization' stamp: 'di 8/30/2000 20:53'!undoTarget: target selector: selector arguments: arguments	"Give target morph a chance to refine its undo operation"	target refineUndoTarget: target selector: selector arguments: arguments in:		[:rTarget :rSelector :rArguments |		undoTarget _ rTarget.		undoSelector _ rSelector.		undoArguments _ rArguments]! !!Command class methodsFor: 'menu' stamp: 'di 8/31/2000 00:02'!nextCommandToUndo	| anIndex |	LastCommand ifNil: [^ nil].	LastCommand phase == #done ifTrue: [^ LastCommand].	(LastCommand phase == #undone and:		[(anIndex _ CommandHistory indexOf: LastCommand) > 1])		ifTrue: [^ CommandHistory at: anIndex - 1]		ifFalse: [^ nil]! !!Command class methodsFor: 'menu' stamp: 'di 8/31/2000 00:03'!undoMenuWording	"Answer the wording to be used in an 'undo' menu item"	((LastCommand == nil or: [Preferences useUndo not]) or:		[Preferences infiniteUndo not and: [LastCommand phase == #undone]]) ifTrue: [^ 'can''t undo'].	^ String streamContents:		[:aStream | 			aStream nextPutAll: 'undo "'.			aStream nextPutAll: (self nextCommandToUndo cmdWording truncateTo: 12).			aStream nextPut: $".			LastCommand phase == #done ifTrue:				[aStream nextPutAll: ' (z)']]! !!Command class methodsFor: 'called from the ui' stamp: 'di 8/30/2000 23:57'!commandToUndo	"Undo the last command, i.e. move backward in the recent-commands tape, if possible."	| anIndex |	LastCommand ifNil: [^ nil].	LastCommand phase == #done ifTrue: [^ LastCommand].	(LastCommand phase == #undone and:		[(anIndex _ CommandHistory indexOf: LastCommand) > 1])		ifTrue: [^ CommandHistory at: anIndex - 1]		ifFalse: [^ nil]! !!Morph methodsFor: 'rounding' stamp: 'di 8/30/2000 21:08'!roundedCornersString	"Answer the string to put in a menu that will invite the user to switch to the opposite  corner-rounding mode"	^ self wantsRoundedCorners		ifTrue: ['make corners square']		ifFalse: ['make corners round']! !!Morph methodsFor: 'undo' stamp: 'di 8/30/2000 20:44'!refineRedoTarget: target selector: aSymbol arguments: arguments in: refineBlock	"Any morph can override this method to refine its redo specification"	^ refineBlock value: target value: aSymbol value: arguments! !!Morph methodsFor: 'undo' stamp: 'di 8/30/2000 20:37'!refineUndoTarget: target selector: aSymbol arguments: arguments in: refineBlock	"Any morph can override this method to refine its undo specification"	^ refineBlock value: target value: aSymbol value: arguments! !!Morph methodsFor: 'undo' stamp: 'di 8/30/2000 23:42'!undoMove: cmd redo: redo owner: formerOwner bounds: formerBounds predecessor: formerPredecessor	"Handle undo and redo of move commands in morphic"	self owner ifNil: [^ self beep].	redo ifFalse:		["undo sets up the redo state first"		cmd redoTarget: self			selector: #undoMove:redo:owner:bounds:predecessor:			arguments: {cmd. true. owner. bounds. (owner morphPreceding: self)}].	formerOwner ifNotNil:		[formerPredecessor			ifNil: [formerOwner addMorphBack: self]			ifNotNil: [formerOwner addMorph: self after: formerPredecessor]].	self bounds: formerBounds.	(self isKindOf: SystemWindow) ifTrue: [self activate]! !!BorderedMorph methodsFor: 'menu' stamp: 'di 8/30/2000 21:57'!changeBorderWidth: evt	| handle origin aHand cmd newWidth |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	cmd _ Command new cmdWording: 'border change';			undoTarget: self selector: #borderWidth: argument: self borderWidth.	handle _ HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			newWidth _ (newPoint - origin) r asInteger // 5.			self borderWidth: newWidth]		lastPointDo:			[:newPoint | self addHalo.			cmd redoTarget: self selector: #borderWidth: argument: newWidth;				remember].	aHand attachMorph: handle.	handle startStepping! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'di 8/30/2000 21:39'!changeBorderWidth: evt	| handle origin aHand |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	handle _ HandleMorph new forEachPointDo:		[:newPoint | handle removeAllMorphs.		handle addMorph:			(LineMorph from: origin to: newPoint color: Color black width: 1).		self borderWidth: (newPoint - origin) r asInteger // 5].	aHand attachMorph: handle.	handle startStepping! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 8/30/2000 20:42'!grabMorphInner: aMorph	"The real work of grabbing a morph.  Set up a command object to represent the forthcoming move (in support of Undo), then actually wrench the morph out of its old home and add it as one of MY submorphs."	| myPos morphPos localPt trans morphToGrab newT |	formerOwner _ aMorph owner.	formerPosition _ aMorph position.	(formerOwner notNil and: [(aMorph isKindOf: NewHandleMorph orOf: MenuMorph) not]) ifTrue:		[(currentCommand _ Command new)			cmdWording: 'move ', (aMorph externalName truncateTo: 10);			undoTarget: aMorph				selector: #undoMove:redo:owner:bounds:predecessor:				arguments: {currentCommand. false. formerOwner. aMorph bounds. (formerOwner morphPreceding: aMorph)}].	"Check if the morph will keep its transform while grabbed"	myPos _ self position.	morphPos _ aMorph position.	localPt _ (aMorph keepsTransform "or: [formerOwner isNil]")		ifTrue:[myPos]		ifFalse:[((aMorph world ifNil: [self worldUnderCursor]) 							globalPointToLocal: myPos) truncated].						"fix grabbing new morph in embedded world"	(formerOwner == nil		or: [aMorph keepsTransform			or: [(trans _ formerOwner transformFromOutermostWorld) isPureTranslation]]) ifTrue: [		aMorph position: myPos + (morphPos - localPt).		morphToGrab _ aMorph.		addedFlexAtGrab _ false.	] ifFalse: ["Morph was in a flexed environment.  Flex it in the hand."		morphToGrab _ aMorph addFlexShell transform: trans asMorphicTransform.		aMorph position: morphPos.  "revert offset from addFlexShell"		newT _ trans withOffset: (trans offset + (trans localPointToGlobal: localPt) - myPos).		morphToGrab position: (morphToGrab localPointToGlobal: morphToGrab position).		morphToGrab transform: newT.		addedFlexAtGrab _ true.	].	(morphToGrab isKindOf: PhraseTileMorph) ifTrue:		[morphToGrab position: Sensor cursorPoint].	self addMorphBack: morphToGrab! !!HandleMorph methodsFor: 'initialize' stamp: 'di 8/30/2000 21:48'!forEachPointDo: aBlock lastPointDo: otherBlock	pointBlock _ aBlock.	lastPointBlock _ otherBlock! !!HandleMorph methodsFor: 'termination' stamp: 'di 8/30/2000 21:49'!justDroppedInto: aMorph event: anEvent	"So that when the hand drops me (into the world) I go away"	lastPointBlock ifNotNil: [lastPointBlock value: self center].	anEvent hand keyboardFocus == self		ifTrue:[anEvent hand newKeyboardFocus: nil].	self changed.	self delete.! !!PolygonMorph methodsFor: 'editing' stamp: 'di 8/30/2000 22:03'!color: newColor	self isOpen		ifTrue: [^ self borderColor: newColor  "easy access to line color from halo"]		ifFalse: [^ super color: newColor]! !!SelectionMorph methodsFor: 'drag and drop' stamp: 'di 8/30/2000 22:21'!justDroppedInto: newOwner event: evt	selectedItems isEmpty ifTrue: [^ self extendByHand: evt hand].	dupLoc ifNotNil: [dupDelta _ self position - dupLoc].	selectedItems reverseDo: [:m | newOwner addMorphFront: m].	^ super justDroppedInto: newOwner event: evt! !!SelectionMorph methodsFor: 'undo' stamp: 'di 8/30/2000 20:58'!borderColorForItems: colorCollection	selectedItems with: colorCollection do: [:m :c | m borderColor: c]! !!SelectionMorph methodsFor: 'undo' stamp: 'di 8/30/2000 20:59'!borderWidthForItems: widthCollection	selectedItems with: widthCollection do: [:m :c | m borderWidth: c]! !!SelectionMorph methodsFor: 'undo' stamp: 'di 8/30/2000 20:50'!colorForItems: colorCollection	selectedItems with: colorCollection do: [:m :c | m color: c]! !!SelectionMorph methodsFor: 'undo' stamp: 'di 8/30/2000 23:12'!refineUndoTarget: target selector: selector arguments: arguments in: refineBlock	"Any morph can override this method to refine its undo specification"	selector == #color: ifTrue:		[^ refineBlock value: target value: #colorForItems:			value: {selectedItems collect: [:m | m color]}].	selector == #borderColor: ifTrue:		[^ refineBlock value: target value: #borderColorForItems:			value: {selectedItems collect: [:m | m borderColor]}].	selector == #borderWidth: ifTrue:		[^ refineBlock value: target value: #borderWidthForItems:			value: {selectedItems collect: [:m | m borderWidth]}].	selector == #undoMove:redo:owner:bounds:predecessor: ifTrue:		["This is the biggy.  Need to gather parameters for all selected items"		^ refineBlock value: target			value: #undoMove:redo:owner:bounds:predecessor:			value: {arguments first.					arguments second.					selectedItems collect: [:m | m owner].					selectedItems collect: [:m | m bounds].					selectedItems collect: [:m | m owner morphPreceding: m]}].	^ refineBlock value: target value: selector value: arguments! !!SelectionMorph methodsFor: 'undo' stamp: 'di 8/30/2000 23:44'!undoMove: cmd redo: redo owner: oldOwners bounds: oldBoundses predecessor: oldPredecessors	| item |	"Handle undo and redo of move commands in morphic"	redo ifFalse:		["undo sets up the redo state first"		cmd redoTarget: self			selector: #undoMove:redo:owner:bounds:predecessor:			arguments: {cmd. true.						selectedItems collect: [:m | m owner].						selectedItems collect: [:m | m bounds].						selectedItems collect: [:m | m owner morphPreceding: m]}].	(redo ifTrue: [1 to: selectedItems size]			ifFalse: [1 to: selectedItems size]) do:		[:i | item _ selectedItems at: i.		(oldOwners at: i) ifNotNil:			[(oldPredecessors at: i)				ifNil: [(oldOwners at: i) addMorphFront: item]				ifNotNil: [(oldOwners at: i) addMorph: item after: (oldPredecessors at: i)]].		item bounds: (oldBoundses at: i).		(item isKindOf: SystemWindow) ifTrue: [item activate]]! !!SelectionMorph methodsFor: 'undo' stamp: 'di 8/31/2000 00:24'!borderColorForItems: colorCollection	(selectedItems select: [:m | m isKindOf: BorderedMorph])		with: colorCollection		do: [:m :c | m borderColor: c]! !!SelectionMorph methodsFor: 'undo' stamp: 'di 8/31/2000 00:26'!borderWidthForItems: widthCollection	(selectedItems select: [:m | m isKindOf: BorderedMorph])		with: widthCollection		do: [:m :c | m borderWidth: c]! !!SelectionMorph methodsFor: 'undo' stamp: 'di 8/31/2000 00:23'!refineUndoTarget: target selector: selector arguments: arguments in: refineBlock	"Any morph can override this method to refine its undo specification"	selector == #color: ifTrue:		[^ refineBlock value: target value: #colorForItems:			value: {selectedItems collect: [:m | m color]}].	selector == #borderColor: ifTrue:		[^ refineBlock value: target value: #borderColorForItems:			value: {selectedItems select: [:m | m isKindOf: BorderedMorph]								thenCollect: [:m | m borderColor]}].	selector == #borderWidth: ifTrue:		[^ refineBlock value: target value: #borderWidthForItems:			value: {selectedItems select: [:m | m isKindOf: BorderedMorph]								thenCollect: [:m | m borderWidth]}].	selector == #undoMove:redo:owner:bounds:predecessor: ifTrue:		["This is the biggy.  Need to gather parameters for all selected items"		^ refineBlock value: target			value: #undoMove:redo:owner:bounds:predecessor:			value: {arguments first.					arguments second.					selectedItems collect: [:m | m owner].					selectedItems collect: [:m | m bounds].					selectedItems collect: [:m | m owner morphPreceding: m]}].	^ refineBlock value: target value: selector value: arguments! !Morph removeSelector: #undoCommand:redo:owner:bounds:predecessor:!Undeclared removeUnreferencedKeys!