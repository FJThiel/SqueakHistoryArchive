'From Squeak2.8alpha of 12 January 2000 [latest update: #1851] on 17 February 2000 at 10:50:26 am'!"Change Set:		EnvironmentChgs1Date:			11 February 2000Author:			Dan IngallsEnvironments and ImageSegments are back on top of the todo list...Several bug fixes, and changes to environments.  Restores the	ability to partition the squeak image by executing...		Environment reorganizeEverythingWhen an environment is swapped out using storeSegment,	now the name structure remains resident.Records the traceback of any fault on a non-resident environment.Here is a sample sequence (in a partitioned image)...	ImageSegmentRootStub startLoggingFaults.	Smalltalk storeAll.  -- Write all Environments to disk. -- 	Smalltalk stillOut.  -- Lists in the Transcript, who is still out. -- 	ImageSegmentRootStub faultLogs inspect.		-- This brings up an inspector that shows, for each fault,		the call stack that caused that segment to be brought in. -- Reduces the need to bring in non-resident environments...	Waking up a fileList no longer requires Network envt.	Opening an inspector in Morphic doesnt bring in ST80 envt.	Using ScreenController for world menu doens't bring in ST80 envt.	Changes StartupStamp logic so it doesn't search Smalltalk dict each time.NOTE:  This is still extreme test pilot material."!B3DVertexRasterizer subclass: #B3DSimulRasterizer	instanceVariableNames: 'canvas scanner '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Engine'!ProtoObject subclass: #ImageSegmentRootStub	instanceVariableNames: 'shadowSuper shadowMethodDict shadowFormat imageSegment '	classVariableNames: 'FaultLogs LoggingFaults '	poolDictionaries: ''	category: 'System-Object Storage'!MouseMenuController subclass: #ScreenController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!IdentityDictionary subclass: #SystemDictionary	instanceVariableNames: 'cachedClassNames '	classVariableNames: 'LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore ShutDownList SpecialSelectors StartUpList StartupStamp SystemChanges '	poolDictionaries: ''	category: 'System-Support'!SystemDictionary subclass: #Environment	instanceVariableNames: 'envtName outerEnvt '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!!ProtoObject methodsFor: 'system primitives' stamp: 'di 2/11/2000 13:34'!cannotInterpret: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but a null methodDictionary was encountered while looking up the message selector.  Hopefully this is the result of encountering a stub for a swapped out class which induces this exception on purpose.""If this is the result of encountering a swap-out stub, then simulating the lookup in Smalltalk should suffice to install the class properly, and the message may be resent."	| handler errorString |	(self class lookupSelector: aMessage selector) == nil ifFalse:		["Simulated lookup succeeded -- resend the message."		^ aMessage sentTo: self].	"Could not recover by simulated lookup -- it's an error"	errorString _ 'MethodDictionary fault'.	(handler _ Processor activeProcess errorHandler) notNil		ifTrue: [handler value: errorString value: self]		ifFalse: [Debugger openContext: thisContext					label: errorString					contents: thisContext shortStack].	^ aMessage sentTo: self! !!FileDirectory methodsFor: 'file directory' stamp: 'di 2/11/2000 22:37'!wakeUp	"Entering a FileList window.  Do nothing.  Disk directories do not have to be awakened."! !!FileList methodsFor: 'initialization' stamp: 'di 2/16/2000 10:50'!modelWakeUp	"User has entered or expanded the window -- reopen any remote connection."	(directory isKindOf: ServerDirectory) ifTrue:		[directory wakeUp]! !!ImageSegment methodsFor: 'read/write segment' stamp: 'di 2/11/2000 13:06'!install	"This operation retrieves the segment if necessary from file storage, installs it in memory, and replaces (using become:) all the root stubs with the reconstructed roots of the segment."	| newRoots |	state = #onFile ifTrue: [self readFromFile].	state = #onFileWithSymbols ifTrue: [self readFromFileWithSymbols.		endMarker _ segment nextObject. 	"for enumeration of objects"		endMarker == 0 ifTrue: [endMarker _ 'End' clone]].	(state = #active) | (state = #imported) ifFalse: [self errorWrongState].	newRoots _ self loadSegmentFrom: segment outPointers: outPointers.	state = #imported 		ifTrue: ["just came in from exported file"			arrayOfRoots _ newRoots]		ifFalse: [			arrayOfRoots elementsForwardIdentityTo: newRoots].	state _ #inactive.	self beep.	"Don't use Squeak sound here."! !!ImageSegmentRootStub methodsFor: 'fetch from disk' stamp: 'di 2/11/2000 12:38'!doesNotUnderstand: aMessage 	 "Any normal message sent to this object is really intended for another object that is in a non-resident imageSegment.  Reinstall the segment and resend the message."	imageSegment install.	LoggingFaults ifTrue:		[FaultLogs at: Time millisecondClockValue printString			put: (String streamContents:				[:strm | 				strm print: self class; space; print: aMessage selector; cr.				(thisContext sender stackOfSize: 30)					do: [:item | strm print: item; cr]])].	"NOTE:  The following should really be (aMessage sentTo: self)		in order to recover properly from a fault in a super-send,		however, the lookupClass might be bogus in this case, and it's		almost unthinkable that the first fault would be a super send."	^ self perform: aMessage selector withArguments: aMessage arguments! !!ImageSegmentRootStub class methodsFor: 'as yet unclassified' stamp: 'di 2/7/2000 23:43'!doLogFaults  "ImageSegmentRootStub doLogFaults"	FaultLogs _ Dictionary new.	LoggingFaults _ true.! !!ImageSegmentRootStub class methodsFor: 'as yet unclassified' stamp: 'di 2/7/2000 23:17'!dontLogFaults  "ImageSegmentRootStub dontLogFaults"	FaultLogs _ Dictionary new.	LoggingFaults _ false.! !!ImageSegmentRootStub class methodsFor: 'as yet unclassified' stamp: 'di 2/11/2000 12:33'!faultLogs  "ImageSegmentRootStub faultLogs"  "<-- inspect it"	^ FaultLogs! !!ImageSegmentRootStub class methodsFor: 'as yet unclassified' stamp: 'di 2/11/2000 12:31'!startLoggingFaults  "ImageSegmentRootStub startLoggingFaults"	FaultLogs _ Dictionary new.	LoggingFaults _ true.! !!ImageSegmentRootStub class methodsFor: 'as yet unclassified' stamp: 'di 2/11/2000 12:33'!stopLoggingFaults  "ImageSegmentRootStub stopLoggingFaults"	FaultLogs _ Dictionary new.	LoggingFaults _ false.! !!Inspector class methodsFor: 'instance creation' stamp: 'di 2/16/2000 10:52'!openOn: anObject withEvalPane: withEval withLabel: label	Smalltalk isMorphic ifTrue:		[^ self openAsMorphOn: anObject withEvalPane: withEval			withLabel: label valueViewClass: nil].	^ self openOn: anObject 		withEvalPane: withEval 		withLabel: label 		valueViewClass: PluggableTextView! !!Inspector class methodsFor: 'instance creation' stamp: 'di 2/16/2000 10:52'!openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	| topView inspector listView valueView evalView |	inspector _ self inspect: anObject.	topView _ StandardSystemView new model: inspector.	topView borderWidth: 1.	listView _ PluggableListView on: inspector		list: #fieldList		selected: #selectionIndex		changeSelected: #toggleIndex:		menu: #fieldListMenu:		keystroke: #inspectorKey:from:.	(inspector isMemberOf: DictionaryInspector)		ifTrue: [listView menu: #dictionaryMenu:].	listView window: (0 @ 0 extent: 40 @ 40).	topView addSubView: listView.	valueView _ valueViewClass new.		"PluggableTextView or PluggableFormView"	(valueView respondsTo: #getText) ifTrue: [		valueView on: inspector 			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:].	(valueViewClass inheritsFrom: FormView) ifTrue: [		valueView model: inspector].	valueView window: (0 @ 0 extent: 75 @ 40).	topView addSubView: valueView toRightOf: listView.		withEval ifTrue:		[evalView _ PluggableTextView new on: inspector 			text: #trash accept: #trash:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		evalView window: (0 @ 0 extent: 115 @ 20).		evalView askBeforeDiscardingEdits: false.		topView addSubView: evalView below: listView].	topView label: label.	topView minimumSize: 180 @ 120.	topView setUpdatablePanesFrom: #(fieldList).	topView controller open! !!ServerDirectory methodsFor: 'do ftp' stamp: 'di 2/11/2000 22:36'!wakeUp	"Open for FTP and keep the connection open"	| so |	(so _ self openNoDataFTP) class == String ifTrue: [^ so].	^ socket _ so! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 2/11/2000 22:34'!openGroup	"Open all servers in the group.  Don't forget to close later."	(group		ifNil: [Array with: self]		ifNotNil: [group value]) do: [:aDir | aDir wakeUp].! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 2/16/2000 13:40'!kernelCategories	^ #(Kernel Collections Graphics System)! !!SystemDictionary methodsFor: 'retrieving' stamp: 'di 2/9/2000 07:58'!allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system 	(that is, Object and its subclasses).	ar 7/15/1999: The code below will not enumerate any obsolete or anonymous	behaviors for which the following should be executed:		Smalltalk allObjectsDo:[:obj| obj isBehavior ifTrue:[aBlock value: obj]].	but what follows is way faster than enumerating all objects."	aBlock value: ProtoObject.	ProtoObject allSubclassesDoGently: aBlock.		"don't bring in ImageSegments"	"Classes outside the ProtoObject hierarchy"	Class subclassesDo: [:aClass |		(aClass == ProtoObject class			or: [aClass isInMemory not			or: [aClass isMeta not]]) ifFalse:			["Enumerate the non-meta class and its subclasses"			aBlock value: aClass soleInstance.			aClass soleInstance allSubclassesDoGently: aBlock]].! !!SystemDictionary methodsFor: 'class names' stamp: 'di 2/16/2000 10:28'!flushClassNameCache	"Smalltalk flushClassNameCache"	"Forse recomputation of the cached list of class names."	cachedClassNames _ nil! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 2/11/2000 17:23'!assureStartupStampLogged	"If there is a startup stamp not yet actually logged to disk, do it now."	| changesFile |	StartupStamp ifNil: [^ self].	(SourceFiles isNil or: [(changesFile _ SourceFiles at: 2) == nil]) ifTrue: [^ self].	changesFile setToEnd; cr; cr.	changesFile nextChunkPut: StartupStamp asString; cr.	StartupStamp _ nil.	self forceChangesToDisk.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 2/11/2000 17:24'!readDocumentFile	"Process system updates. Read a document file, if one was provided. Start application."	| fileName object |	StartupStamp _ '----STARTUP----', Time dateAndTimeNow printString.	self processUpdates.	fileName _ Smalltalk getSystemAttribute: 2.	((fileName ~~ nil) and: [fileName size > 0])		ifTrue: [			(fileName asLowercase beginsWith: 'http://')				ifTrue: [					"fetch remote file"					HTTPSocket httpFileIn: fileName]				ifFalse: [					"read local file"					object _ (FileStream oldFileNamed: fileName) fileInObjectAndCode.					"if launching a .sqo document, send open to the final object"					(fileName endsWith: '.sqo') ifTrue: [object open]]]		ifFalse: [			(Preferences valueOfFlag: #startImagineeringStudio)				ifTrue: [ScriptingSystem openImagineeringStudio]].! !!Environment methodsFor: 'dictionary access' stamp: 'di 2/16/2000 13:29'!= another	"Environments should only be compared on the basis of identity"	^ self == another! !!Environment methodsFor: 'dictionary access' stamp: 'di 2/16/2000 09:50'!atOrBelow: key ifAbsent: absentBlock	| envt value maybe onDisk envName |	"Compatibility hack -- find things in sub environments for now.	Adjusted to not fault on every environment."	^ super at: key ifAbsent:		[onDisk _ OrderedCollection new.		self associationsDo: [:assn | 			((assn key endsWith: 'Environment')				and: [assn key size > 'Environment' size]) ifTrue: [				envName _ (assn key copyFrom: 1 to: assn key size - 11 "Environment") asSymbol.				(envt _ super at: envName ifAbsent: [nil]) ifNotNil: [					envt isInMemory 						ifTrue: [((envt isKindOf: Environment) and: [envt ~~ self])							ifTrue: [maybe _ true.								value _ envt atOrBelow: key ifAbsent: [maybe _ false].								maybe ifTrue: [^ value]]]						ifFalse: [onDisk add: envName]]]].		onDisk do: [:outName |			(envt _ super at: outName ifAbsent: [nil]) ifNotNil: [				((envt isKindOf: Environment) and: [envt ~~ self])					ifTrue: [maybe _ true.						value _ envt atOrBelow: key ifAbsent: [maybe _ false].						maybe ifTrue: [^ value]]]].		^ absentBlock value]! !!Environment methodsFor: 'dictionary access' stamp: 'di 2/7/2000 21:41'!scopeFor: varName from: prior envtAndPathIfFound: envtAndPathBlock	"Look up varName here or in any sub-environments, and also in any sub-environments of the outer environment.  If found, evaluate pathBlock with a string giving the path for the access, and return the environment in which the variable was found.  Return nil if the variable is not found.	Call from outside with prior == nil.	prior ~= nil prevents revisiting prior parts of the tree."	| envt |	"Might be right here -- null path."	(self includesKey: varName) ifTrue:		[^ envtAndPathBlock value: self value: String new].	"Might be in a sub-environment -- append envt name to downward path."	self associationsDo:		[:assn |		(((envt _ assn value) isKindOf: Environment)			and: [envt ~~ self and: [envt ~~ prior]]) ifTrue:				[envt scopeFor: varName from: self envtAndPathIfFound:						[:subEnvt :subPath |						^ envtAndPathBlock value: subEnvt value: assn key , ' ' , subPath]]].	"If not found, traverse outer environment."	outerEnvt ifNil: [^ nil].	outerEnvt == prior ifTrue: [^ nil].	subEnvt _ outerEnvt scopeFor: varName from: self envtAndPathIfFound:						[:subEnvt :subPath |						^ envtAndPathBlock value: subEnvt value: subPath].! !!Environment methodsFor: 'system conversion' stamp: 'di 2/7/2000 14:41'!rewriteSourceForSelector: selector inClass: aClass using: envtForVar	"Rewrite the source code for the method in question so that all global references out of the direct access path are converted to indirect global references.  This is done by parsing the source with a lenient parser able to find variables in any environment.  Then the parse tree is consulted for the source code ranges of each reference that needs to be rewritten and the pattern to which it should be rewritten.  Note that assignments, which will take the form	envt setValueOf: #GlobalName to: ...may generate spurious message due to agglutination of keywords with the value expression."	| code methodNode edits varName eName envt |	code _ aClass sourceCodeAt: selector.	methodNode _ Compiler new parse: code in: aClass notifying: nil.	edits _ OrderedCollection new.	methodNode encoder globalSourceRanges do:		[:tuple |   "{ varName. srcRange. store }"		(aClass scopeHas: (varName _ tuple first asSymbol) ifTrue: [:ignored]) ifFalse:			["This is a remote global.  Add it as reference to be edited."			edits addLast: { varName. tuple at: 2. tuple at: 3 }]].	"Sort the edits by source position."	edits _ edits asSortedCollection: [:a :b | a second first < b second first].	edits reverseDo:		[:edit | varName _ edit first.		(eName _ envtForVar at: varName ifAbsent: [nil]) ifNotNil:			["If varName is not already exported, define an export method"			envt _ self at: eName.			(envt class includesSelector: varName) ifFalse:				[envt class compile: (self exportMethodFor: varName)						 classified: 'exports'].			"Replace each access out of scope with a proper remote reference"			code _ code copyReplaceFrom: edit second first						to: edit second last						with: eName , ' ' , varName]].	aClass compile: code classified: (aClass organization categoryOfElement: selector)! !!Environment methodsFor: 'fileIn/out' stamp: 'di 2/16/2000 23:38'!isInMemory	self associationsDo:		[:a | ^ a value isInMemory]! !!Environment methodsFor: 'fileIn/out' stamp: 'di 2/16/2000 23:36'!stillOut		"Smalltalk stillOut"	"Write transcript the names of the Environments in the list who are still out on disk."	Transcript clear.	Smalltalk associationsDo:		[:assn |		(assn value isKindOf: Environment) ifTrue:			[Transcript cr; nextPutAll: assn key , 					(assn value isInMemory							ifTrue: [':  in']							ifFalse: [':  out'])]].	Transcript endEntry! !!Environment methodsFor: 'fileIn/out' stamp: 'di 2/16/2000 13:35'!storeAll	"Write all Environments except me and the top one out as image segments."	| firstToGo others |	firstToGo _ {VMConstruction. Morphic. Sound. Network. Balloon}.	others _ Smalltalk values select:		[:value |  (value isKindOf: Environment)					and: [(firstToGo includes: value) not & (value ~~ Smalltalk)]].	firstToGo , others do: [:anEnv | anEnv storeSegment].! !!Environment methodsFor: 'fileIn/out' stamp: 'di 2/16/2000 22:28'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <my name>.seg."	| is roots |	is _ ImageSegment new.	is segmentName: self name.	roots _ OrderedCollection new: self size * 2.	"roots addFirst: self."	self valuesDo:		[:value | value == self ifFalse: [roots addLast: value].		value class class == Metaclass ifTrue: [roots addLast: value class]].	is copyFromRootsLocalFileFor: roots sizeHint: 0.	"NOTE: self is now an ISRootStub..."	is state = #tooBig ifTrue: [^ false].	is extract.	is state = #active ifFalse: [^ false].	is writeToFile: is segmentName.	^ true! !!Environment class methodsFor: 'system conversion' stamp: 'di 2/16/2000 11:49'!computePrerequisites	| bigCats bigCat preReqs supCat dict kernelCategories |	"We say one environment is a prerequisite of another if classes defined	in the other inherit from classes in the first.	Compute a dictionary with an entry for every non-kernel environment.	That entry is another dictionary giving the names of any prerequisite	environments and the list of classes that require it."	"Environment computePrerequisites."  " <-- inspect this "	bigCats _ IdentityDictionary new.	kernelCategories _ Environment new kernelCategories.	Smalltalk allClasses do:		[:cl |  bigCat _ (cl category asString copyUpTo: '-' first) asSymbol.		(kernelCategories includes: bigCat) ifTrue: [bigCat _ #Kernel].		bigCats at: cl name put: bigCat].	preReqs _ IdentityDictionary new.	Smalltalk allClasses do:		[:cl |  		cl superclass ifNotNil:			[bigCat _ bigCats at: cl name.			supCat _ bigCats at: cl superclass name.			bigCat ~~ supCat ifTrue:				[dict _ preReqs at: bigCat					ifAbsent: [preReqs at: bigCat put: IdentityDictionary new].				dict at: supCat					put: ((dict at: supCat ifAbsent: [Array new]) copyWith: cl name)]]].	^ preReqs! !!Environment class methodsFor: 'system conversion' stamp: 'di 2/16/2000 12:43'!reorganizeEverything	"Environment reorganizeEverything."	| bigCat envt pool s |	"First check for clashes between environment names and existing globals..."	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			[(Smalltalk includesKey: bigCat) ifTrue:				[^ self error: bigCat , ' cannot be used to nameboth a package and a class or other global variable.No reorganization will be attempted.']]].	(PopUpMenu confirm:'Your image is about to be partitioned into environments.Many things may not work after this, so you should beworking in a throw-away copy of your working image.Are you really ready to procede?(choose ''no'' to stop here safely)')		ifFalse: [^ PopUpMenu notify: 'No changes were made'].	Smalltalk newChanges: (ChangeSet new initialize name: 'Reorganization').	"Recreate the Smalltalk dictionary as the top-level Environment."	Smalltalk _ SmalltalkEnvironment newFrom: Smalltalk.	Smalltalk setName: #Smalltalk inOuterEnvt: nil.	"Don't hang onto old copy of Smalltalk ."	Smalltalk recreateSpecialObjectsArray.	Smalltalk allClassesDo:		[:c | c environment: nil. "Flush any old values"].	"Run through all categories making up new sub-environments"	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			["Not a kernel category ..."			envt _ Smalltalk at: bigCat						ifAbsent: ["... make up a new environment if necessary ..."									Smalltalk makeSubEnvironmentNamed: bigCat].			"... and install the member classes in that category"			envt transferBindingsNamedIn: (SystemOrganization listAtCategoryNamed: cat)									from: Smalltalk].		].	"Move all shared pools that are only referred to in sub environments"	Smalltalk associationsDo:		[:assn | ((pool _ assn value) isMemberOf: Dictionary) ifTrue:			[s _ IdentitySet new.			Smalltalk allClassesAnywhereDo:				[:c | c sharedPools do:					[:p | p == pool ifTrue:						[s add: c environment]]].			(s size = 1 and: [(envt _ s someElement) ~~ Smalltalk]) ifTrue:				[envt declare: assn key from: Smalltalk]]].	Smalltalk rewriteIndirectRefs.	Smalltalk newChanges: (ChangeSet new initialize name: 'PostReorganization').	ChangeSorter gatherChangeSets.	Preferences enable: #browserShowsPackagePane.! !ContextPart removeSelector: #longStack!ServerDirectory removeSelector: #openKeepFTP!Environment removeSelector: #kernelCategories!Environment removeSelector: #stillOut:!Environment removeSelector: #rebuildSystemOrganization!"Postscript:Remove obsolete global."Smalltalk removeKey: #StartupStamp ifAbsent: [].InterpreterPlugin allSubclassesDo: [:cl | cl category: InterpreterPlugin category].!