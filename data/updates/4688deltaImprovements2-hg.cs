'From Squeak3.2alpha of 1 November 2001 [latest update: #4646] on 28 January 2002 at 10:29:48 am'!!Module methodsFor: 'module definition protocol' stamp: 'hg 1/19/2002 22:27'!submodule: mod name: submoduleName version: versionOrNil importNames: shouldImport	"use this message to declare a submodule of this module. Note that this just creates an unresolved (Sub)ModuleReference, not any module unless given as an argument"	| submodule |	submodule _ mod 		ifNotNil: [mod version: mod verbatimVersion parentModule: self]			"use path instead of module during loading"		ifNil: [self path copyWith: submoduleName].	^(SubmoduleReference new			name: submoduleName version: versionOrNil 			module: submodule import: shouldImport)		ensureReferenceFrom: self! !!Module methodsFor: 'module composition' stamp: 'hg 1/27/2002 12:28'!neighborModuleRefs	^self privateNeighborModuleRefs! !!Module methodsFor: 'module composition' stamp: 'hg 1/27/2002 14:08'!submodulesDo: aBlock	^self neighborModuleRefs do: [:ref | 		ref refersToSubmodule & ref isModuleResolved ifTrue: [aBlock value: ref module]]! !!Module methodsFor: 'changing module composition' stamp: 'hg 1/27/2002 12:02'!addNeighborModule: moduleReference export: shouldExportOrNil	| export |	(self hasNeighborModule: moduleReference module) ifTrue: [		self error: 'Neighbor module ', 				moduleReference module pathAsMessages, ' already exists.'].	moduleReference isModuleResolved & moduleReference importNames ifTrue: [		self checkImportForCircularity: moduleReference module].	moduleReference isModuleResolved & moduleReference hasAlias ifTrue: [		export _ shouldExportOrNil ifNil: [self shouldExport: moduleReference].		self defineName: moduleReference name as: moduleReference module export: export].	self privateAddNeighborModuleRef: moduleReference.! !!Module methodsFor: 'changing module composition' stamp: 'hg 1/27/2002 12:30'!moveModule: module toAfter: anotherModule	"use this to change the order of name lookup"	| moveRef afterRef |	moveRef _ self refForNeighborModule: module.	afterRef _ self refForNeighborModule: anotherModule.	moveRef isNil |  afterRef isNil ifTrue: [		self error: 'module reference not found'].	neighborModules _ (self privateNeighborModuleRefs asOrderedCollection 						remove: moveRef;						add: moveRef after: afterRef;						yourself)					asArray.	self invalidateCaches.! !!Module methodsFor: 'changing module composition' stamp: 'hg 1/27/2002 12:30'!moveModule: module toBefore: anotherModule	"use this to change the order of name lookup"	| moveRef beforeRef |	moveRef _ self refForNeighborModule: module.	beforeRef _ self refForNeighborModule: anotherModule.	moveRef isNil |  beforeRef isNil ifTrue: [		self error: 'module reference not found'].	neighborModules _ (self privateNeighborModuleRefs asOrderedCollection 						remove: moveRef;						add: moveRef before: beforeRef; 						yourself)					asArray.	self invalidateCaches.! !!Module methodsFor: 'changing module composition' stamp: 'hg 1/27/2002 12:05'!removeNeighborModule: module	"just remove the module from me--do not finialize/unistall it, etc."	| moduleReference |	moduleReference _ self refForNeighborModule: module.	moduleReference hasAlias ifTrue: [self removeName: moduleReference name].	self privateRemoveNeighborModuleRef: moduleReference.	^moduleReference! !!Module methodsFor: 'user interface' stamp: 'hg 1/27/2002 13:17'!moduleExplorerContents	| list |	list _ OrderedCollection new.	list add: 			(ModuleExplorerWrapper 				with: self privateNeighborModuleRefs				name: 'neighbor refs'				model: self);		add: 			(ModuleExplorerWrapper 				with: self definedNames				name: 'defined names'				model: self);		add: 			(ModuleExplorerWrapper 				with: self exportedNames				name: 'exported names'				model: self).	repository ifNotNil: [		list add: 			(ModuleExplorerWrapper 				with: self repository				name: 'repository'				model: self)].	self verbatimVersion ifNotNil: [		list add: 			(ModuleExplorerWrapper 				with: self verbatimVersion				name: 'version'				model: self)].	self annotations associationsDo: [:assoc |		list _ list copyWith: 			(ModuleExplorerWrapper 					with: assoc value					name: assoc key					model: assoc)].	^list			! !!Module methodsFor: 'private' stamp: 'hg 1/27/2002 12:29'!clearDeclaredModules	neighborModules _ self privateNeighborModuleRefs select: [:ref | 		ref refersToExternalModule not]! !!DeltaModule methodsFor: 'module composition' stamp: 'hg 1/27/2002 12:27'!neighborModuleRefs	"a DeltaModule does not define its neighbors, but changes to its baseModule's neighbors (implement it properly later)"	| deltaRefs baseModuleRefs |	deltaRefs _ self privateNeighborModuleRefs.	baseModuleRefs _ self baseModuleRef isModuleResolved 		ifTrue: [self baseModule neighborModuleRefs]		ifFalse: [#()]. 	^(Array with: self baseModuleRef),		baseModuleRefs,		deltaRefs! !!DeltaModule methodsFor: 'fileIn/Out' stamp: 'hg 1/27/2002 12:40'!neighborDefinitionsOn: aStream	"store the changes that I make relative to base. not the final implementation yet"	self privateNeighborModuleRefs do: [:ref |		aStream nextPut: $;; crtab. ref storeOn: aStream.]! !!Module class methodsFor: 'virtual hierarchy' stamp: 'hg 1/27/2002 14:08'!fromPath: modulePath forceCreate: create	"return the module with the given path"	"don't be case sensitive but preserve given case when creating names"	| subref |	^modulePath inject: self root into: [:parentModule :localName |		subref _ parentModule neighborModuleRefs  			detect: [:ref | 				ref refersToSubmodule | ref refersToDeltaModule and: [					ref name asLowercase = localName asLowercase]] 			ifNone: [				create ifTrue: [					"creation phase 1: create unresolved reference (i.e. not the module)"					parentModule submodule: nil name: localName 						version: nil importNames: false]].		(create and: [subref isModuleResolved not]) ifTrue: [			"creation phase 2: resolve the module reference"			subref resolvedModule: (Module new version: nil parentModule: parentModule)].		(subref isNil or: [subref isModuleResolved not]) ifTrue: [^nil].		subref module]! !!Module class methodsFor: 'virtual hierarchy' stamp: 'hg 1/27/2002 14:01'!moduleForCategory: catString forceCreate: create	"Return the module corresponding to the given system category"	| mod |	mod _ Module fromPath: (self pathFromCategory: catString create: create) forceCreate: create.	mod ifNil: [self error: 'No module for category ', catString].	^ mod! !!Repository methodsFor: 'composite repositories' stamp: 'hg 1/27/2002 12:43'!prepareForCompositeLoading: mod	"during composite loading, module objects need to be created before their definition is loaded"	mod privateNeighborModuleRefs do: [:ref |		ref refersToSubmodule | ref refersToDeltaModule 			ifTrue: [ref createModuleWithParent: mod]].! !ModuleReference removeSelector: #isSubmodule!Module class removeSelector: #pathFromCategory:!Module removeSelector: #addNeighborModuleRef:!Module removeSelector: #removeNeighborModuleRef:!Module removeSelector: #shouldExportDeltaModules!Module removeSelector: #shouldExportExternalModules!Module removeSelector: #shouldExportSubmodules!