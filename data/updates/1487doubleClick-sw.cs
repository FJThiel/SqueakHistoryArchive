'From Squeak 2.5 of August 6, 1999 on 24 September 1999 at 12:49:04 pm'!"Change Set:		doubleClick-swDate:			23 September 1999Author:			Scott WallaceFixes a bug in morphic's double-click handling -- mouseMove: was erroneously being dispatched at mouse-down time even if the morph requested a wait-for-double-click.Provides a simple example illustrating how one can make a morph respond to double-click.  To run the example, either launch a DoubleClickExample morph from the 'new morph' menu, or else just evaluate:	self currentHand attachMorph: DoubleClickExample newWhen you double-click on the rectangle, it changes color. When you hold the mouse down on the rectangle it grows or shrinks, depending on its color."!RectangleMorph subclass: #DoubleClickExample	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Experimental'!!DoubleClickExample commentStamp: 'sw 9/23/1999 17:52' prior: 0!Illustrates the double-click capabilities of Morphic.If you have a kind of morph you wish to have respond specially to a double-click, it should:(1)  Respond "true" to #handlesMouseDown:(2)  In its mouseDown: method, send #waitForClicksOrDrag:event: to the hand.(3)  Reimplement #doubleClick: to make the appropriate response to a double-click.(4)  Reimplement #mouseMove: to react to non-double-clicked mouse-down.  If you want to do something special on the *first* mouseMove:, you must manage the record-keeping for this yourself.!!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/23/1999 17:49'!balloonText	^ 'Double-click on me to change my color; hold mouse down on me to grow (if I''m red) or shrink (if I''m blue).'! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/23/1999 17:43'!doubleClick: evt	self color: ((color = Color blue) ifTrue: [Color red] ifFalse: [Color blue])! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/14/1999 16:05'!handlesMouseDown: evt	^ true! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/23/1999 17:55'!initialize	super initialize.	self color: Color red! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/23/1999 17:43'!mouseDown: evt	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing mouseMove: or doubleClick: message gets dispatched"	evt hand waitForClicksOrDrag: self event: evt! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/23/1999 17:49'!mouseMove: evt	| oldCenter |	(self containsPoint: evt cursorPoint)		ifFalse: [^ self].	oldCenter _ self center.	color = Color red		ifTrue:			[self extent: self extent + (1@1)]		ifFalse:			[self extent: ((self extent - (1@1)) max: (16@16))].	self center: oldCenter! !!HandMorph methodsFor: 'event handling' stamp: 'sw 9/23/1999 17:40'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: (Sensor cursorPoint - owner viewBox topLeft)]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				clickState == #firstClickDown ifFalse:					["ensure that at least one mouseMove: is reported for each mouse transaction:"					m mouseMove: (localEvt copy setType: #mouseMove).					(m handlesMouseOverDragging: localEvt) ifTrue:						["If m also handles dragOver, enter it in the list"						dragOverMorphs add: m.						mouseOverMorphs remove: m ifAbsent: []]]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: []]]! !