'From Squeak2.8alpha of 12 January 2000 [latest update: #2178] on 25 May 2000 at 6:54:59 am'!"Change Set:		MethodTrailerBytesDate:			25 May 2000Author:			Dan IngallsGeneralizes the handling of the source code trailer on methods so that, eg, recompilations work properly after abandonSources.  Note that fileIn order is important in this change set."!!Behavior methodsFor: 'creating method dictionary' stamp: 'di 5/24/2000 16:05'!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode |	method _ oldClass compiledMethodAt: selector.	trailer _ (method endPC + 1 to: method size) collect: [:i | method at: i].	methodNode _ self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self addSelector: selector withMethod: (methodNode generate: trailer).! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:37'!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits method |	nTemps > 64 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		largeBit _ (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	primBits _ primitiveIndex <= 16r1FF		ifTrue: [primitiveIndex]		ifFalse: ["For now the high 2 bits of primitive no. are in high bits of header"				(primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r600) bitShift: 19)].	method _ self newMethod: numberOfBytes + trailer size		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits.	1 to: trailer size do:  "Copy the source code trailer to the end"		[:i | method at: method size - trailer size + i put: (trailer at: i)].	^ method! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:43'!toReturnConstant: index trailerBytes: trailer	"Answer an instance of me that is a quick return of the constant	indexed in (true false nil -1 0 1 2)."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 0 primitive: 256 + index! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:44'!toReturnField: field trailerBytes: trailer	"Answer an instance of me that is a quick return of the instance variable 	indexed by the argument, field."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 0 primitive: 264 + field! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:51'!toReturnSelf	"Answer an instance of me that is a quick return of the instance (^self)."	^ self toReturnSelfTrailerBytes: #(0 0 0 0)! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:44'!toReturnSelfTrailerBytes: trailer	"Answer an instance of me that is a quick return of the instance (^self)."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 0 primitive: 256! !!MethodNode methodsFor: 'code generation' stamp: 'di 5/25/2000 06:45'!generate: trailer ifQuick: methodBlock	| v |	(primitive = 0 and: [arguments size = 0 and: [block isQuick]])		ifFalse: [^ self].	v _ block code.	v < 0		ifTrue: [^ self].	v = LdSelf		ifTrue: [^ methodBlock value: (CompiledMethod toReturnSelfTrailerBytes: trailer)].	(v between: LdTrue and: LdMinus1 + 3)		ifTrue: [^ methodBlock value: (CompiledMethod toReturnConstant: v - LdSelf trailerBytes: trailer)].	v < ((CodeBases at: LdInstType) + (CodeLimits at: LdInstType))		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v trailerBytes: trailer)].	v // 256 = 1		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v \\ 256 trailerBytes: trailer)]! !!MethodNode methodsFor: 'code generation' stamp: 'di 5/25/2000 06:48'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs method |	self generate: trailer ifQuick: 		[:m |  method _ m.		method cacheTempNames: self tempNames.		^ method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stackdiscrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method cacheTempNames: self tempNames.	^ method! !MethodNode removeSelector: #generateIfQuick:!CompiledMethod class removeSelector: #newBytes:nArgs:nTemps:nStack:nLits:primitive:!CompiledMethod class removeSelector: #toReturnConstant:!CompiledMethod class removeSelector: #toReturnField:!