'From Squeak2.8alpha of 13 January 2000 [latest update: #2335] on 12 June 2000 at 6:29:04 pm'!"Change Set:		multiProjectsRAADate:			12 June 2000Author:			Bob ArningMany, many changes related to the support of multiple projects/worlds being active simultaneously. At this stage, multiple projects do work, but there are bugs. Single project worlds hopefully continue to work as they have in the past.Please note that there is a fair bit of work-in-progress here, so don't get too upset about some of the details - they may changeMore to come later"!Object subclass: #Bob	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Bob-Bob'!Object subclass: #ComplexProgressIndicator	instanceVariableNames: 'formerWorld targetMorph estimate prevData formerProcess translucentMorph userSuppliedMorph specificHistory historyCategory cumulativeStageTime formerProject newRatio stageCompleted start '	classVariableNames: 'History '	poolDictionaries: ''	category: 'Morphic-Windows'!Object subclass: #CurrentProjectRefactoring	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!CelesteComposition subclass: #FancyCelesteComposition	instanceVariableNames: 'theLinkToInclude to subject textFields '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Mail Reader'!Form subclass: #DisplayScreen	instanceVariableNames: 'clippingBox '	classVariableNames: 'CurrentMorphicWorld CurrentWorldIsMeaningful DisplayChangeSignature OuterMorphicWorld ScreenSave '	poolDictionaries: ''	category: 'Graphics-Display Objects'!AlignmentMorph subclass: #AlignmentMorphBob1	instanceVariableNames: 'heights minWidth minHeight '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Mail Reader'!TransformationMorph subclass: #BOBTransformationMorph	instanceVariableNames: ''	classVariableNames: 'BOBDEBUG '	poolDictionaries: ''	category: 'Morphic-Basic'!Exception subclass: #ProgressInitiationException	instanceVariableNames: 'workBlock maxVal minVal aPoint progressTitle '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!ProgressInitiationException commentStamp: '<historical>' prior: 0!I provide a way to alter the behavior of the old-style progress notifier in String. See examples in:ProgressInitiationException testWithout.ProgressInitiationException testWith.!Notification subclass: #ProgressNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!ProgressNotification commentStamp: '<historical>' prior: 0!Used to signal progress without requiring a specific receiver to notify. Caller/callee convention could be to simply count the number of signals caught or to pass more substantive information with #signal:.!Model subclass: #Project	instanceVariableNames: 'world changeSet transcript parentProject previousProject displayDepth activeProcess exitFlag viewSize thumbnail nextProject guards projectParameters isolatedHead inForce version urlList environment '	classVariableNames: 'CurrentProject GoalFreePercent GoalNotMoreThan UIProcess '	poolDictionaries: ''	category: 'System-Support'!Notification subclass: #ProjectEntryNotification	instanceVariableNames: 'projectToEnter '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!AlignmentMorph subclass: #ProjectNavigationMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!SystemWindow subclass: #NewWorldWindow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!Object subclass: #TheWorldMenu	instanceVariableNames: 'myProject myWorld myHand '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!Morph subclass: #TranslucentProgessMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!Object methodsFor: 'private' stamp: 'RAA 6/6/2000 17:28'!primitiveError: aString 	"This method is called when the error handling results in a recursion in 	calling on error: or halt or halt:."	| context |	(String		streamContents: 			[:s |			s nextPutAll: '**System error handling failed**'.			s cr; nextPutAll: aString.			context _ thisContext sender sender.			20 timesRepeat: [context == nil ifFalse: [s cr; print: (context _ context sender)]].			s cr; nextPutAll: '**Type CR to enter an emergency evaluator.**'.			s cr; nextPutAll: '**Type any other character to restart.**'])		displayAt: 0 @ 0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard == Character cr ifTrue: [Transcripter emergencyEvaluator].	Smalltalk isMorphic ifTrue: [		^Display reinstallMorphicWorldAfterError "To init hand events and redisplay world"	].	ScheduledControllers searchForActiveController! !!Object methodsFor: 'macpal' stamp: 'RAA 5/26/2000 10:04'!currentWorld	"Answer a morphic world that is the current UI focus.		If in a morphic project, it's that project's world.  		If in an mvc project, it is the topmost morphic-mvc-window's worldMorph. 		If in an mvc project that has no morphic-mvc-windows, then it's just some existing worldmorph instance.		If in an mvc project in a Squeak that has NO WorldMorph instances, one is created.	This method will never return nil, it will always return its best effort at returning a relevant world morph, but if need be -- if there are no worlds anywhere, it will create a new one."	| aView aSubview |		^Display getCurrentMorphicWorld ifNil: [		aView _ ScheduledControllers controllerSatisfying:			[:ctrl | (aSubview _ ctrl view firstSubView) notNil and:				[aSubview model isMorph and: [aSubview model isWorldMorph]]].		aView			ifNotNil:				[aSubview model]			ifNil:				[MVCWiWPasteUpMorph newWorldForProject: nil]	].! !!Object methodsFor: 'world hacking' stamp: 'RAA 5/24/2000 08:50'!isTheActiveWorld	^self == World and: [self notNil]! !!ApplescriptError class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:12'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	<primitive: 19> "Simulation guard"	Smalltalk isMorphic		ifTrue:			[self buildMorphicViewOn: aSyntaxError.			CurrentProjectRefactoring newProcessIfUI: Processor activeProcess.			^ Processor activeProcess suspend].	topView _ self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor activeProcess suspend! !!Bob class methodsFor: 'as yet unclassified' stamp: 'RAA 6/2/2000 11:51'!say: x	| file |	file _ FileDirectory default oldFileNamed: 'bob.log'.	[		file			setToEnd;			nextPutAll: x printString;			cr;			cr;			nextPutAll: thisContext longStack;			cr;			cr.	] ensure: [file close]! !!Celeste methodsFor: 'sending mail' stamp: 'RAA 6/1/2000 17:55'!PROTOqueueMessageWithText: aStringOrText	"Queue a message to be sent later. The message is added to the database and filed in the '.tosend.' category."	| messageText id |	messageText _		'X-Mailer: ', Celeste versionString, String cr,		'Date: ', MailMessage dateStampNow, String cr.	messageText _ messageText,		aStringOrText asString.		self requiredCategory: '.tosend.'.	"queue the message"	id _ mailDB addNewMessage: (MailMessage from: messageText).	mailDB file: id inCategory: '.tosend.'.	(self category = '.tosend.') ifTrue: [self updateTOC].	^id! !!Celeste methodsFor: 'sending mail' stamp: 'RAA 6/1/2000 17:55'!PROTOsendQueuedMail	"Post queued messages to the SMTP server."	| outgoing |	outgoing _ mailDB messagesIn: '.tosend.'.	outgoing isEmpty ifTrue: [^ self inform: 'no mail to be sent'].	self sendMail: outgoing.! !!Celeste methodsFor: 'sending mail' stamp: 'RAA 5/19/2000 12:27'!sendMail: aCollectionOfMessages	"Send <aCollectionOfMessages> to the SMTP server."	| sender n message recipients socket |	self requiredCategory: '.sent.'.	self preSendAuthentication.	sender _ (MailAddressParser addressesIn: self class userName) first.	[socket _ SMTPSocket usingServer: Celeste smtpServer]		ifError: [ :a :b | self error: 'error opening connection to mail server'].	('sending ', aCollectionOfMessages size printString, ' messages...')		displayProgressAt: Sensor mousePoint		from: 1		to: aCollectionOfMessages size		during: [:progressBar |			n _ 0.			aCollectionOfMessages do: [:id |				progressBar value: (n _ n + 1).				message _ mailDB getMessage: id.				recipients _ Set new.				recipients addAll: (MailAddressParser addressesIn: message to).				recipients addAll: (MailAddressParser addressesIn: message cc).				[socket 					mailFrom: sender					to: recipients 					text: message text.	"send this one message on the stream"				mailDB remove: id fromCategory: '.tosend.'.				mailDB file: id inCategory: '.sent.'				] ifError: [ :a :b | self error: 'error posting mail']		]].	socket quit; close.	mailDB saveDB.	(self category = '.tosend.') |  (self category = '.sent.') ifTrue: [self updateTOC].! !!Color methodsFor: 'transformations' stamp: 'RAA 6/2/2000 08:47'!atLeastAsLuminentAs: aFloat	| revisedColor |	revisedColor _ self.	[revisedColor luminance < aFloat] whileTrue: [revisedColor _ revisedColor slightlyLighter].	^revisedColor! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 5/23/2000 10:00'!historyCategory: aKey	History ifNil: [History _ Dictionary new].	specificHistory _ History		at: aKey		ifAbsentPut: [Dictionary new].	^specificHistory! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 5/23/2000 09:55'!loadingHistoryAt: aKey add: aNumber	(self loadingHistoryDataForKey: aKey) add: aNumber.! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 5/23/2000 10:02'!loadingHistoryDataForKey: anObject	| answer |	answer _ specificHistory 		at: anObject		ifAbsentPut: [OrderedCollection new].	answer size > 50 ifTrue: [		answer _ answer copyFrom: 25 to: answer size.		specificHistory at: anObject put: answer.	].	^answer! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 5/23/2000 11:11'!targetMorph: aMorph	userSuppliedMorph _ targetMorph _ aMorph! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 5/23/2000 12:33'!withProgressDo: aBlock	| safetyFactor totals f |	targetMorph ifNil: [		targetMorph _ RectangleMorph new			position: Sensor cursorPoint;			extent: 120@120;			openInWorld		"need to see about deleting later"	].	translucentMorph _ TranslucentProgessMorph new		bounds: targetMorph bounds;		openInWorld.	stageCompleted _ 0.	safetyFactor _ 1.1.	"better to guess high than low"	translucentMorph setProperty: #progressStageNumber toValue: 1.	totals _ self loadingHistoryDataForKey: 'total'.	newRatio _ 1.0.	estimate _ totals size < 2 ifTrue: [		5000	] ifFalse: [		(totals sum - totals max) / (totals size - 1 max: 1) * safetyFactor.	].	formerProject _ Project current.	formerWorld _ World.	formerProcess _ Processor activeProcess.	start _ Time millisecondClockValue.	[		[stageCompleted < 999 and: [formerProject == Project current and: 					[formerWorld == World]]] whileTrue: [			translucentMorph setProperty: #revealTimes toValue: 					{(Time millisecondClockValue - start max: 1). (estimate * newRatio max: 1)}.			translucentMorph changed.			"World displayWorldSafely."	"ugliness to try to track down a possible error"			[World displayWorld] ifError: [ :a :b |				stageCompleted _ 999.				f _ FileDirectory default fileNamed: 'bob.errors'.				f nextPutAll: a printString,'  ',b printString; cr; cr.				f nextPutAll: 'worlds equal ',(formerWorld == World) printString; cr; cr.				f nextPutAll: thisContext longStack; cr; cr.				f nextPutAll: formerProcess suspendedContext longStack; cr; cr.				f close. 1 beep.			].			(Delay forMilliseconds: 100) wait.		].		translucentMorph removeProperty: #revealTimes.		self loadingHistoryAt: 'total' add: (Time millisecondClockValue - start max: 1).		formerWorld == World ifTrue: [			translucentMorph delete.			userSuppliedMorph ifNil: [targetMorph delete].		] ifFalse: [			translucentMorph privateDeleteWithAbsolutelyNoSideEffects.			userSuppliedMorph ifNil: [targetMorph privateDeleteWithAbsolutelyNoSideEffects].		].	] forkAt: 6.	[		aBlock 			on: ProgressInitiationException			do: [ :ex | 				ex sendNotificationsTo: [ :min :max :curr |					"ignore this as it is inaccurate"				].			].	] on: ProgressNotification do: [ :note |		stageCompleted _ (note messageText findTokens: ' ') first asNumber.		cumulativeStageTime _ Time millisecondClockValue - start max: 1.		prevData _ self loadingHistoryDataForKey: stageCompleted.		prevData isEmpty ifFalse: [			newRatio _ (cumulativeStageTime / (prevData average max: 1)) asFloat.		].		self loadingHistoryAt: stageCompleted add: cumulativeStageTime.		translucentMorph setProperty: #progressStageNumber toValue: stageCompleted + 1.		note resume.	].	stageCompleted _ 999.	"we'll rarely get here"! !!ContextPart methodsFor: 'debugger access' stamp: 'RAA 5/16/2000 12:14'!longStack	"Answer a String showing the top 100 contexts on my sender chain."	^ String streamContents:		[:strm |		(self stackOfSize: 100)			do: [:item | strm print: item; cr]]! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 10:55'!currentAddGuard: anObject"CurrentProjectRefactoring currentAddGuard:"	^self xxxCurrent addGuard: anObject! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 11:00'!currentBeIsolated"CurrentProjectRefactoring currentBeIsolated"	^self xxxCurrent beIsolated! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:50'!currentBeParentTo: anotherProject"CurrentProjectRefactoring currentBeParentTo:"	^anotherProject setParent: self xxxCurrent! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:50'!currentBeParentToCurrent"CurrentProjectRefactoring currentBeParentToCurrent"	^self xxxCurrent setParent: self xxxCurrent! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:50'!currentFlapsSuppressed"CurrentProjectRefactoring currentFlapsSuppressed"	^self xxxCurrent flapsSuppressed! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 11:02'!currentFromMyServerLoad: aProjectName"CurrentProjectRefactoring currentFromMyServerLoad:"	^self xxxCurrent fromMyServerLoad: aProjectName! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 18:58'!currentInterruptName: aString"CurrentProjectRefactoring currentInterruptName:"	^Project interruptName: aString! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:50'!currentIsolationHead"CurrentProjectRefactoring currentIsolationHead"	^self xxxCurrent isolationHead! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:50'!currentProjectName"CurrentProjectRefactoring currentProjectName"	^self xxxCurrent name! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 11:01'!currentPropagateChanges"CurrentProjectRefactoring currentPropagateChanges"	^self xxxCurrent propagateChanges! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 18:51'!currentSpawnNewProcessAndTerminateOld: aBoolean"CurrentProjectRefactoring currentSpawnNewProcessAndTerminateOld:"	^Project spawnNewProcessAndTerminateOld: aBoolean! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 11:18'!currentToggleFlapsSuppressed"CurrentProjectRefactoring currentToggleFlapsSuppressed"	^self xxxCurrent flapsSuppressed: self xxxCurrent flapsSuppressed not.! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:51'!exitCurrentProject"CurrentProjectRefactoring exitCurrentProject"	^self xxxCurrent exit! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 18:50'!newProcessIfUI: aDeadOrDyingProcess"CurrentProjectRefactoring newProcessIfUI:used ONLY for Morphic"	^Project spawnNewProcessIfThisIsUI: aDeadOrDyingProcess! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:51'!projectWithNameOrCurrent: aString"CurrentProjectRefactoring projectWithNameOrCurrent:"	^(Project named: aString) ifNil: [self xxxCurrent]! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:51'!updateProjectFillsIn: aFlashPlayerMorph"CurrentProjectRefactoring updateProjectFillsIn:"	^aFlashPlayerMorph updateProjectFillsFrom: self xxxCurrent! !!CurrentProjectRefactoring class methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:49'!xxxCurrent	^Project current! !!Debugger methodsFor: 'initialize' stamp: 'RAA 6/3/2000 09:12'!openFullNoSuspendLabel: aString	"Create and schedule a full debugger with the given label. Do not terminate the current active process."	| topView |	Smalltalk isMorphic ifTrue:		[self openFullMorphicLabel: aString.		^ CurrentProjectRefactoring newProcessIfUI: interruptedProcess].	topView _ self buildMVCDebuggerViewLabel: aString minSize: 300@200.	topView controller openNoTerminate.	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'RAA 6/3/2000 09:12'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg topView p |	Sensor flushKeyboard.	savedCursor _ Sensor currentCursor.	Sensor currentCursor: Cursor normal.	msg _ msgString.	(label beginsWith: 'Space is low') ifTrue: [msg _ self lowSpaceChoices, msgString].	isolationHead ifNotNil:		["We have already revoked the isolation layer -- now jump to the parent project."		msg _ self isolationRecoveryAdvice, msgString.		failedProject _ Project current.		isolationHead parent enterForEmergencyRecovery].	Smalltalk isMorphic		ifTrue:			[self buildMorphicNotifierLabelled: label message: msg.			^ CurrentProjectRefactoring newProcessIfUI: interruptedProcess].	Display fullScreen.	topView _ self buildMVCNotifierViewLabel: label message: msg minSize: 350@((14 * 5) + 16 + self optionalButtonHeight).	ScheduledControllers activeController		ifNil: [p _ Display boundingBox center]		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: (p max: (200@60)).	^ topView! !!Debugger methodsFor: 'private' stamp: 'RAA 6/12/2000 18:12'!resumeProcess: aTopView	Smalltalk isMorphic ifFalse: [aTopView erase].	savedCursor ifNotNil: [Sensor currentCursor: savedCursor].	isolationHead ifNotNil:		[failedProject enterForEmergencyRecovery.		isolationHead invoke. isolationHead _ nil].	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate)		ifFalse:		[contextStackIndex > 1			ifTrue: [interruptedProcess popTo: self selectedContext]			ifFalse: [interruptedProcess install: self selectedContext].		Smalltalk isMorphic			ifTrue: [Project resumeProcess: interruptedProcess]			ifFalse: [ScheduledControllers						activeControllerNoTerminate: interruptedController						andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil. "Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: [aTopView delete. World displayWorld]		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.  "restart low space handler"	Processor terminateActive! !!Debugger class methodsFor: 'opening' stamp: 'RAA 6/3/2000 09:18'!openContext: aContext label: aString contents: contentsString	| isolationHead |	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	<primitive: 19> "Simulation guard"	ErrorRecursion not & Preferences logDebuggerStackToFile ifTrue:		[Smalltalk logError: aString inContext: aContext to: 'SqueakDebug.log'].	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		(isolationHead _ CurrentProjectRefactoring currentIsolationHead)			ifNil: [self primitiveError: aString]			ifNotNil: [isolationHead revoke]].	ErrorRecursion _ true.	(Debugger context: aContext isolationHead: isolationHead)		openNotifierContents: contentsString		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!DiskProxy methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 10:10'!comeFullyUpOnReload: smartRefStream	"Internalize myself into a fully alive object after raw loading from a DataStream. (See my class comment.)  DataStream will substitute the object from this eval for the DiskProxy."	| globalObj symbol pr nn |	symbol _ globalObjectName.	"See if class is mapped to another name"	(smartRefStream respondsTo: #renamed) ifTrue: [		symbol _ smartRefStream renamed at: symbol ifAbsent: [symbol]].	globalObj _ Smalltalk at: symbol 		ifAbsent: [^ self halt: 'Global not found'].	((symbol == #World) and: [Smalltalk isMorphic not]) ifTrue: [		self inform: 'These objects will work better if opened in a Morphic World.Dismiss and reopen all menus.'].	preSelector ifNotNil: [		Symbol hasInterned: preSelector ifTrue: [:selector |			globalObj _ globalObj perform: selector]].	symbol == #Project ifTrue: [		(constructorSelector = #fromUrl:) ifTrue: [			nn _ (constructorArgs first findTokens: '/') last.			nn _ (nn findTokens: '.|') first.			pr _ Project named: nn. 			^ pr ifNil: [self] ifNotNil: [pr]].		pr _ globalObj perform: constructorSelector withArguments: constructorArgs.		^ pr ifNil: [self] ifNotNil: [pr]].	"keep the Proxy if Project does not exist"	constructorSelector ifNil: [^ globalObj].	constructorSelector ifNotNil: [		Symbol hasInterned: constructorSelector ifTrue: [:selector |			^ globalObj perform: selector					withArguments: constructorArgs]].					"args not checked against Renamed"	^ nil 	"was not in proper form"! !!DiskProxy methodsFor: 'exceptions' stamp: 'RAA 6/3/2000 11:02'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Look for our project on the server, then try to enter it!!  DiskProxy is acting as a stub for the real thing.  Called from a ProjectViewMorph in the current project.  If have url, use it.  Else look in current Project's server and folder."	constructorSelector == #namedUrl: ifTrue: ["Project namedUrl: xxx"		^ ((Smalltalk at: globalObjectName) perform: #fromUrl:					withArguments: constructorArgs) ].	constructorSelector == #named: ifTrue: [		CurrentProjectRefactoring currentFromMyServerLoad: constructorArgs first].	"name"! !!DiskProxy methodsFor: 'exceptions' stamp: 'RAA 5/17/2000 11:51'!loadFromServer	"In support of check for newer version in ProjectViewMorph menu"	self enter! !!DocLibrary methodsFor: 'doc pane' stamp: 'RAA 5/25/2000 08:16'!fetchDocSel: aSelector class: className	"Look on servers to see if there is documentation pane for the selected message. Take into account the current update number.  If not, ask the user if she wants to create a blank one."	| key response docPane ext |	key _ aSelector size = 0 		ifFalse: [className, ' ', aSelector]		ifTrue: [className].	(self openDocAt: key) ifNil: [		response _ (PopUpMenu labels: 'Create new page\Cancel' withCRs)				startUpWithCaption: 'No documentation exists for this method.\Would you like to write some?' withCRs.		response = 1 ifTrue: [			docPane _ PasteUpMorph new.			docPane color: Color white; borderWidth: 2; borderColor: Color green.			docPane setProperty: #classAndMethod toValue: key.			docPane setProperty: #initialExtent toValue: (ext _ 200@200).			docPane topLeft: (RealEstateAgent initialFrameFor: docPane world: Smalltalk currentWorld) origin.			docPane extent: ext.			docPane addMorph: (TextMorph new topLeft: docPane topLeft + (10@10);					extent: docPane width - 15 @ 30).			Smalltalk currentWorld addMorph: docPane]].	"If found, openDocAt: put it on the screen"! !!DocLibrary methodsFor: 'doc pane' stamp: 'RAA 5/25/2000 08:17'!openDocAt: classAndMethod	| docPane |	(docPane _ self docObjectAt: classAndMethod) ifNotNil: [		docPane setProperty: #initialExtent toValue: docPane bounds extent.		docPane topLeft: (RealEstateAgent initialFrameFor: docPane world: Smalltalk currentWorld) origin.		Smalltalk currentWorld addMorph: docPane].	^ docPane! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 12:22'!buttonWithAction: aSymbol	^SimpleButtonMorph new		target: self;		actionSelector: aSymbol			! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 18:55'!celeste: aCeleste to: argTo subject: argSubject initialText: aText theLinkToInclude: linkText	celeste _ aCeleste.	to _ argTo.	subject _ argSubject.	messageText _ aText.	theLinkToInclude _ linkText.	textFields _ #().! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 19:03'!completeTheMessage	| newText strm |	textFields do: [ :each | each hasUnacceptedEdits ifTrue: [ each accept ] ].	newText _ String new: 200.	strm _ WriteStream on: newText.	strm 		nextPutAll: 'Content-Type: text/html'; cr;		nextPutAll: 'From: ', Celeste userName; cr;		nextPutAll: 'To: ',to; cr;		nextPutAll: 'Subject: ',subject; cr;		cr;		nextPutAll: '<HTML><BODY><BR>';		nextPutAll: messageText asString asHtml;		nextPutAll: '<BR><BR>',theLinkToInclude,'<BR></BODY></HTML>'.	^strm contents! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 18:56'!openInMorphic	"open an interface for sending a mail message with the given initial 	text "	| buttonsList container toField subjectField |	morphicWindow _ SystemWindow labelled: 'Mister Postman'.	morphicWindow model: self.	(buttonsList _ AlignmentMorph newRow)		addMorphBack: (			(self buttonWithAction: #submit)				label: 'send later';				setBalloonText: 'add this to the queue of messages to be sent'		);		addTransparentSpacerOfSize: 4@4;		addMorphBack: (			(self buttonWithAction: #sendNow)				label: 'send now';				setBalloonText: 'send this message immediately'		).	container _ AlignmentMorphBob1 new.	container heights: #(25 14 50 14 50 14 9999999).	container 		addMorphBack: buttonsList;		addMorphBack: (self simpleString: 'To:');		addMorphBack: (toField _ PluggableTextMorph			on: self			text: #to			accept: #to:		);		addMorphBack: (self simpleString: 'Subject:');		addMorphBack: (subjectField _ PluggableTextMorph			on: self			text: #subject			accept: #subject:		);		addMorphBack: (self simpleString: 'Message:');		addMorphBack: (textEditor _ PluggableTextMorph			on: self			text: #messageText			accept: #messageText:		).	textFields _ {toField. subjectField. textEditor}.	morphicWindow 		addMorph: container frame: (0 @ 0 corner: 1 @ 1);		openInMVC! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 12:53'!sendNow	self submit: true! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 18:45'!simpleString: aString	^AlignmentMorph newRow		addMorphBack: (StringMorph contents: aString)! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 18:48'!subject	^subject	! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 19:02'!subject: x	subject _ x.	self changed: #subject.	^true! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 12:53'!submit	self submit: false! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 19:09'!submit: sendNow	| newMessageNumber database personalCeleste |	personalCeleste _ false.	celeste ifNil: [		personalCeleste _ true.		database _  MailDB openOn: 'EMAIL'.		database ifNil: [ ^ 1 beep ].		celeste _ Celeste new openOnDatabase: database.	].	newMessageNumber _ celeste queueMessageWithText: (		self breakLines: self completeTheMessage atWidth: 72	).	sendNow ifTrue: [celeste sendMail: {newMessageNumber}].	personalCeleste ifTrue: [celeste close].	morphicWindow ifNotNil: [ morphicWindow delete ].	mvcWindow ifNotNil: [ mvcWindow controller close ].! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 18:47'!to	^to! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 19:02'!to: x	to _ x.		self changed: #to.	^true	! !!FileList methodsFor: 'file list menu' stamp: 'RAA 6/2/2000 11:03'!openBookFromFile	"Reconstitute a Morph from the selected file, presumed to be represent	a Morph saved via the SmartRefStream mechanism, and open it in an	appropriate Morphic world"	| book aFileStream |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ directory oldFileNamed: self fullName.	book _ BookMorph new.	book setProperty: #url toValue: aFileStream url.	book fromRemoteStream: aFileStream.	aFileStream close.	Smalltalk isMorphic 		ifTrue: [Display getCurrentMorphicWorld addMorphsAndModel: book]		ifFalse:			[book isMorph ifFalse: [^ self errorMustBeMorph].			book openInWorld].	book goToPage: 1! !!FileList methodsFor: 'file list menu' stamp: 'RAA 6/2/2000 17:58'!openImageInWindow	"Handle five file formats: GIF, JPG, PNG, Form stoteOn: (run coded), and BMP.	Fail if file format is not recognized."	| image myStream |	myStream _ (directory readOnlyFileNamed: fileName) binary.	image _ Form fromBinaryStream: myStream.	myStream close.	Smalltalk isMorphic		ifTrue: [(SketchMorph withForm: image) openInWorld]		ifFalse: [FormView open: image named: fileName]! !!FileList methodsFor: 'file list menu' stamp: 'RAA 6/2/2000 11:03'!openMorphFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved	via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ directory oldFileNamed: self fullName.	morphOrList _ aFileStream fileInObjectAndCode.	(morphOrList isKindOf: SqueakPage) ifTrue: [morphOrList _ morphOrList contentsMorph].	Smalltalk isMorphic		ifTrue: [Display getCurrentMorphicWorld addMorphsAndModel: morphOrList]		ifFalse:			[morphOrList isMorph ifFalse: [^ self errorMustBeMorph].			morphOrList openInWorld]! !!FileList methodsFor: 'file list menu' stamp: 'RAA 6/6/2000 19:21'!openProjectFromFile	"Reconstitute a Morph from the selected file, presumed to be represent	a Morph saved via the SmartRefStream mechanism, and open it in an	appropriate Morphic world."	Project canWeLoadAProjectNow ifFalse: [^ self].	ProjectViewMorph openFromStreamBlock: [		directory oldFileNamed: fileName	]! !!FileList class methodsFor: 'instance creation' stamp: 'RAA 5/24/2000 19:26'!openFileDirectly	| aResult |	(aResult _ StandardFileMenu oldFile) ifNotNil:		[self openEditorOn: (aResult directory readOnlyFileNamed: aResult name) editString: nil]! !!Form methodsFor: 'displaying' stamp: 'RAA 6/12/2000 07:50'!displayInterpolatedIn: aRectangle on: aForm	"Display the receiver on aForm, using interpolation if necessary.		Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine |	self extent = aRectangle extent ifTrue:[^self displayOn: aForm at: aRectangle origin].	Smalltalk at: #B3DRenderEngine 		ifPresent:[:engineClass| engine _ (engineClass defaultForPlatformOn: aForm)].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aRectangle;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	"Otherwise use the 3D engine for our purposes"	engine viewport: aRectangle.	engine material: (B3DMaterial new emission: Color white).	engine texture: self.	engine render: (B3DIndexedQuadMesh new plainTextureRect).	engine finish.! !!DisplayScreen methodsFor: 'displaying' stamp: 'RAA 6/2/2000 12:09'!flash: aRectangle andWait: msecs	"Flash the area of the screen defined by the given rectangle."	self reverse: aRectangle.	self forceDisplayUpdate.	(Delay forMilliseconds: msecs) wait.	self reverse: aRectangle.	self forceDisplayUpdate.	(Delay forMilliseconds: msecs) wait.! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/25/2000 10:15'!bestGuessOfCurrentWorld	^World! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 6/2/2000 16:39'!changeMorphicWorldTo: aWorldOrNil	self flag: #bob.		OuterMorphicWorld _ World _ aWorldOrNil.	CurrentMorphicWorld _ nil.! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/25/2000 09:50'!checkCurrentHandForObjectToPaste	| response |	self flag: #bob.		World currentHand objectToPaste ifNil: [^self].	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer].! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/25/2000 09:52'!checkCurrentHandForObjectToPaste2	self flag: #bob.		World currentHand objectToPaste ifNil: [^self].	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString.! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 6/2/2000 10:52'!doOneCycleMorphic	self getOuterMorphicWorld doOneCycle.! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 6/2/2000 10:50'!doOneCycleNowMorphic	self getOuterMorphicWorld doOneCycleNow.! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 6/2/2000 16:41'!getCurrentMorphicWorld	^CurrentMorphicWorld ifNil: [		(self morphicWorldAt: Sensor cursorPoint) ifNil: [			self getOuterMorphicWorld		].	]! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/26/2000 09:53'!getOuterMorphicWorld	^OuterMorphicWorld ifNil: [OuterMorphicWorld _ World]! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/25/2000 10:01'!isCurrentMorphicWorld: aWorld	self flag: #bob.		^aWorld == World! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/25/2000 09:32'!lastKnownCursorPoint	self flag: #bob.		"maybe Sensor cursorPoint is adequate"	^Smalltalk isMorphic ifTrue: [World cursorPoint] ifFalse: [Sensor cursorPoint]! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 6/2/2000 17:38'!morphicWorldAt: aPoint	| roots outer |	outer _ self getOuterMorphicWorld.	roots _ outer rootMorphsAt: aPoint.  "root morphs in world"	roots isEmpty ifTrue: [^outer].	^((roots first morphsAt: aPoint) 		detect: [ :each | true]		ifNone: [roots first]) world! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 6/2/2000 17:23'!morphicWorldString	^(self morphicWorldAt: Sensor cursorPoint) hash printString"===	aString _ UpdatingStringMorph new target: Display.	aString useStringFormat; color: Color blue; stepTime: 1000; getSelector: #morphicWorldString.	aString openInWorld.==="! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/25/2000 10:03'!pauseMorphicEventRecorder	self flag: #bob.		Smalltalk isMorphic ifTrue: [^World pauseEventRecorder].	^nil! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/25/2000 09:40'!reinstallMorphicWorldAfterError	self flag: #bob.		Smalltalk isMorphic ifTrue:		[World install "To init hand events and redisplay world"].! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/26/2000 09:54'!repaintMorphicDisplay	"this merely says everything needs to be redrawn, but the actual redraw will happen later"	(self getOuterMorphicWorld ifNil: [^self]) fullRepaintNeeded.	! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/26/2000 09:53'!repaintMorphicDisplayNow	(self getOuterMorphicWorld ifNil: [^self]) displayWorld.! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/25/2000 08:05'!restore	Smalltalk isMorphic		ifTrue: [self repaintMorphicDisplay]		ifFalse: [ScheduledControllers unCacheWindows; restore].! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/25/2000 08:06'!restoreAfter: aBlock	"Evaluate the block, wait for a mouse click, and then restore the screen."	aBlock value.	Sensor waitButton.	Smalltalk isMorphic		ifTrue: [self repaintMorphicDisplay]		ifFalse: [(ScheduledControllers restore; activeController) view emphasize]! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/26/2000 09:53'!restoreMorphicDisplay	DisplayScreen startUp.	self getOuterMorphicWorld 		extent: self extent;		viewBox: self boundingBox;		handsDo: [:h | h endDisplaySuppression];		restoreFlapsDisplay;		fullRepaintNeeded! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 6/6/2000 18:47'!useMorphicWorld: aWorld during: aBlock	| save result |	[		save _ CurrentMorphicWorld.		CurrentMorphicWorld _ aWorld.		result _ aBlock value.	] ensure: [		CurrentMorphicWorld _ save.	].	^result! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 5/25/2000 10:29'!useTemporaryHandDuring: aBlock	| lastHand tmpHand w |	w _ Display bestGuessOfCurrentWorld.	w removeHand: (lastHand _ w activeHand).	w addHand: (tmpHand _ lastHand copy).	aBlock value: tmpHand.	w removeHand: tmpHand.	w addHand: lastHand.! !!DisplayScreen class methodsFor: 'display box access' stamp: 'RAA 5/25/2000 08:04'!checkForNewScreenSize	Display extent = DisplayScreen actualScreenSize ifTrue: [^ self].	DisplayScreen startUp.	Smalltalk isMorphic		ifTrue: [Display restoreMorphicDisplay]		ifFalse: [ScheduledControllers restore; searchForActiveController]! !!FormCanvas methodsFor: 'drawing-support' stamp: 'RAA 6/12/2000 08:04'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"an attempt to use #displayInterpolatedOn: instead of WarpBlt."	| innerRect patchRect start subCanvas |	self flag: #bob.		"we probably want a generic version of this in Canvas"	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ aClipRect.	patchRect _ aDisplayTransform globalBoundsToLocal: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					"warp combinationRule: Form erase"]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					"warp combinationRule: Form paint"].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		subCanvas form displayInterpolatedIn: (innerRect translateBy: origin) on: self form.	].! !!ImageSegment class methodsFor: 'testing' stamp: 'RAA 6/3/2000 09:23'!swapOutProjects  "ImageSegment swapOutProjects"  	"Swap out segments for all projects other than the current one."	| spaceLeft newSpaceLeft |	spaceLeft _ Smalltalk garbageCollect.	Project allSubInstances doWithIndex:		[:p :i | p couldBeSwappedOut ifTrue:			[Transcript cr; cr; nextPutAll: p name.			(ImageSegment new copyFromRoots: (Array with: p) sizeHint: 0)				extract; writeToFile: 'project' , i printString.			newSpaceLeft _ Smalltalk garbageCollect.			Transcript cr; print: newSpaceLeft - spaceLeft; endEntry.			spaceLeft _ newSpaceLeft]].! !!InfiniteForm methodsFor: 'as yet unclassified' stamp: 'RAA 6/1/2000 10:50'!addFillStyleMenuItems: aMenu hand: aHand from: aMorph	"Add the items for changing the current fill style of the receiver"	"prevents a walkback when control menu is built for morph with me as color"! !!MethodFinder class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 10:17'!methodFor: dataAndAnswers	"Return an expression that computes these answers."	| result selFinder |	self flag: #bob.	"there was a reference to World, but this method seems to be unused"	result _ (self new) load: dataAndAnswers; findMessage.	Smalltalk isMorphic ifTrue: [		((selFinder _ Display bestGuessOfCurrentWorld submorphs first model) 			isKindOf: SelectorBrowser) ifTrue: [	 			selFinder searchResult: result]].	^result! !!Morph methodsFor: 'initialization' stamp: 'RAA 5/25/2000 08:12'!openInWindowLabeled: aString inWorld: aWorld	| window extent |	window _ (SystemWindow labelled: aString) model: nil.	window 		" guess at initial extent"		bounds:  (RealEstateAgent initialFrameFor: window initialExtent: self fullBounds extent world: aWorld);		addMorph: self frame: (0@0 extent: 1@1);		updatePaneColors.	" calculate extent after adding in case any size related attributes were changed.  Use	fullBounds in order to trigger re-layout of layout morphs"	extent _ self fullBounds extent + 			(window borderWidth@window labelHeight) + window borderWidth.	window extent: extent.	aWorld addMorph: window.	window activate.	aWorld startSteppingSubmorphsOf: window.	^window! !!Morph methodsFor: 'structure' stamp: 'RAA 6/7/2000 09:58'!activeHand	self flag: #bob.		"need to do a better job here"	^ (self outermostWorldMorph ifNil: [^ nil]) activeHand! !!Morph methodsFor: 'structure' stamp: 'RAA 6/7/2000 09:57'!currentHand	self flag: #bob.		"need to do a better job here"	^ (self outermostWorldMorph ifNil: [^ super currentHand]) primaryHand! !!Morph methodsFor: 'structure' stamp: 'RAA 5/25/2000 15:39'!outermostWorldMorph	| outer |	outer _ self outermostMorphThat: [ :x | x isWorldMorph].	outer ifNotNil: [^outer].	self isWorldMorph ifTrue: [^self].	^nil! !!Morph methodsFor: 'structure' stamp: 'RAA 6/11/2000 23:45'!topRendererOrSelf	"Answer the topmost renderer for this morph, or this morph itself if it has no renderer. See the comment in Morph>isRenderer."	| top topsOwner |	owner ifNil: [^ self].	self isWorldMorph ifTrue: [^self].	"ignore scaling of this world"	top _ self.	topsOwner _ top owner.	[(topsOwner ~~ nil) and: [topsOwner isRenderer]] whileTrue: [		top _ topsOwner.		topsOwner _ top owner].	^ top! !!Morph methodsFor: 'submorphs-accessing' stamp: 'RAA 5/25/2000 16:12'!allLowerWorldsDo: aBlock	self allMorphsDo: [ :each | 		each == self ifFalse: [ each isWorldMorph ifTrue: [aBlock value: each]]	].! !!Morph methodsFor: 'submorphs-accessing' stamp: 'RAA 6/11/2000 20:41'!rootMorphsAtGlobal: aPoint	"Return the list of root morphs containing the given point, excluding the receiver.	ar 11/8/1999: Moved into morph for an incredibly ugly hack in 3D worlds"	^ self rootMorphsAt: (self pointFromWorld: aPoint)! !!Morph methodsFor: 'submorphs-accessing' stamp: 'RAA 6/11/2000 15:43'!unlockedMorphsAtGlobal: aPoint	"Return a collection of all unlocked morphs in this morph structure that contain the given point, possibly including the receiver itself.  Simplified "	^ self unlockedMorphsAt: (self pointFromWorld: aPoint) addTo: OrderedCollection new! !!Morph methodsFor: 'geometry' stamp: 'RAA 6/12/2000 06:18'!boundsInWorld	owner ifNil: [^ bounds].	^ owner transformFromNearestWorld localBoundsToGlobal: bounds.! !!Morph methodsFor: 'geometry' stamp: 'RAA 6/12/2000 06:34'!globalPointToLocal: aPoint	owner ifNil: [^ aPoint].	^ (self transformFrom: self outermostWorldMorph) globalPointToLocal: aPoint.! !!Morph methodsFor: 'geometry' stamp: 'RAA 6/12/2000 13:47'!localPointToGlobal: aPoint	owner ifNil: [^ aPoint].	^ (self transformFrom: self outermostWorldMorph) localPointToGlobal: aPoint.! !!Morph methodsFor: 'event handling' stamp: 'sw 3/8/1999 00:17'!cursorPoint	^ self currentHand lastEvent cursorPoint! !!Morph methodsFor: 'event handling' stamp: 'RAA 6/12/2000 06:13'!transformFromNearestWorld	"Return a transform to map world coordinates into my local coordinates"	self isWorldMorph ifTrue: [^ MorphicTransform identity].	^ self transformFrom: self world! !!Morph methodsFor: 'menus' stamp: 'RAA 6/12/2000 09:02'!adhereToEdge	| menu |	menu _ MenuMorph new defaultTarget: self.	#(top right bottom left - center - topLeft topRight bottomRight bottomLeft - none)		do: [:each |			each == #-				ifTrue: [menu addLine]				ifFalse: [menu add: each asString selector: #setToAdhereToEdge: argument: each]].	menu popUpEvent: self currentEvent in: self world! !!Morph methodsFor: 'halos and balloon help' stamp: 'RAA 6/1/2000 19:33'!addHalo: evt	| halo prospectiveHaloClass |	prospectiveHaloClass _ Smalltalk at: self classForHalo ifAbsent: [HaloMorph].	halo _ prospectiveHaloClass new bounds: self worldBoundsForHalo.	self world addMorphFront: halo.	halo target: self.	halo startStepping.! !!Morph methodsFor: 'e-toy support' stamp: 'RAA 5/25/2000 09:06'!embedInWindow	| window worldToUse |	worldToUse _ self world.		"I'm assuming we are already in a world"	window _ (SystemWindow labelled: self defaultLabelForInspector) model: nil.	window bounds: ((self position - ((0@window labelHeight) + window borderWidth))						corner: self bottomRight + window borderWidth).	window addMorph: self frame: (0@0 extent: 1@1).	window updatePaneColors.	worldToUse addMorph: window.	window activate! !!Morph methodsFor: 'debug and other' stamp: 'RAA 5/24/2000 18:20'!resumeAfterDrawError	self changed.	self removeProperty:#errorOnDraw.	self changed.! !!Morph methodsFor: 'debug and other' stamp: 'RAA 5/24/2000 18:20'!resumeAfterStepError	"Resume stepping after an error has occured."	self startStepping. "Will #step"	self removeProperty:#errorOnStep. "Will remove prop only if #step was okay"! !!Morph methodsFor: 'private' stamp: 'RAA 5/23/2000 11:31'!privateDeleteWithAbsolutelyNoSideEffects	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	"used to delete a morph from an inactive world"	owner ifNil: [^self].	owner privateRemoveMorphWithAbsolutelyNoSideEffects: self.	owner _ nil.! !!Morph methodsFor: 'private' stamp: 'RAA 5/23/2000 11:30'!privateRemoveMorphWithAbsolutelyNoSideEffects: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	"used to delete a morph from an inactive world"	submorphs _ submorphs copyWithout: aMorph.! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 6/10/2000 11:02'!fixLayout	| nextY newBnds r |	submorphs size < 1 ifTrue: [^super fixLayout].	submorphs size = heights size ifFalse: [^super fixLayout].	r _ self innerBounds.	nextY _ r top.	submorphs with: heights do: [ :sub :ht |		newBnds _ r left @ nextY corner: (r right @ (nextY + ht min: r bottom)).		newBnds = sub bounds ifFalse: [sub bounds: newBnds].		nextY _ nextY + ht.	].! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 18:37'!heights: aCollection	heights _ aCollection.! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 18:33'!initialize	super initialize.	orientation _ #vertical.	inset _ 0.	borderWidth _ 0.	hResizing _ #rigid.	vResizing _ #rigid.	heights _ OrderedCollection new.! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 6/11/2000 12:16'!minHeight	^minHeight ifNil: [super minHeight]! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 6/11/2000 12:16'!minHeight: anInteger	minHeight _ anInteger! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 6/11/2000 12:16'!minWidth	^minWidth ifNil: [super minWidth]! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 6/11/2000 12:16'!minWidth: anInteger	minWidth _ anInteger! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/10/2000 14:22'!adjustAfter: changeBlock 	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| |		"oldRefPos _ self referencePosition."	changeBlock value.	self chooseSmoothing.		"self penUpWhile: [self position: self position + (oldRefPos - self referencePosition)]."	self layoutChanged.	owner ifNotNil: [owner invalidRect: bounds]! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/12/2000 08:04'!drawSubmorphsOn: aCanvas	| t1 t2 |	(self innerBounds intersects: aCanvas clipRect) ifFalse: [^self].	"(Smalltalk garbageCollectMost) < 1000000 ifTrue: [		^aCanvas fillRectangle: self innerBounds color: Color red	]."	t1 _ Time millisecondsToRun: [		aCanvas 			transform2By: transform		"#transformBy: for pure WarpBlt"			clippingTo: ((self innerBounds intersect: aCanvas clipRect) expandBy: 1)			during: [:myCanvas |				t2 _ Time millisecondsToRun: [					submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]				].			]			smoothing: smoothing	].	"BOBDEBUG ifNil: [BOBDEBUG _ OrderedCollection new].	BOBDEBUG add: {Time millisecondClockValue. t1. t2. aCanvas clipRect. self innerBounds.			(self innerBounds intersects: aCanvas clipRect)}.	BOBDEBUG size > 100 ifTrue: [ BOBDEBUG _ BOBDEBUG last: 50]."! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/11/2000 12:41'!extent: aPoint	| scaleFactor newExtent |	newExtent _ aPoint truncated.	bounds extent = newExtent ifTrue: [^self].	scaleFactor _ (self scale * newExtent r / self fullBounds extent r) max: 0.01.		"transform _ transform withScale: (scaleFactor detentBy: 0.1 atMultiplesOf: 1.0 snap: false)."	transform _ transform withScale: scaleFactor.	(scaleFactor < 1.0)		ifTrue: [smoothing _ 2]		ifFalse: [smoothing _ 1].	self changed.	bounds _ bounds topLeft extent: newExtent.	self layoutChanged.	self changed.! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/10/2000 14:59'!layoutChanged	"use the version from Morph"	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	submorphs size > 0 ifTrue:		["Let submorphs know about a change above"		submorphs do: [:m | m ownerChanged]].! !!BookMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:57'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu add: 'find...' action: #textSearch.	aMenu add: 'go to page...' action: #goToPage.	aMenu addLine.	aMenu addList:		#(('sort pages'			sortPages)		('uncache page sorter'	uncachePageSorter)).	(self hasProperty: #dontWrapAtEnd)		ifTrue: [aMenu add: 'wrap after last page' selector: #setWrapPages: argument: true]		ifFalse: [aMenu add: 'stop at last page' selector: #setWrapPages: argument: false].	aMenu addList:		#(('make bookmark'		bookmarkForThisPage)		('make thumbnail'		thumbnailForThisPage)).	aMenu addUpdating: #showingPageControlsString action: #toggleShowingOfPageControls.	aMenu addLine.	aMenu add: 'sound effect for all pages' action: #menuPageSoundForAll:.	aMenu add: 'sound effect this page only' action: #menuPageSoundForThisPage:.	aMenu add: 'visual effect for all pages' action: #menuPageVisualForAll:.	aMenu add: 'visual effect this page only' action: #menuPageVisualForThisPage:.	aMenu addLine.	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'   action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (self dragNDropEnabled ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #toggleDragNDrop.	aMenu add: 'make all pages this size' action: #makeUniformPageSize.	aMenu add: 'send all pages to server' action: #savePagesOnURL.	aMenu add: 'send this page to server' action: #saveOneOnURL.	aMenu add: 'reload all from server' action: #reload.	aMenu add: 'copy page url to clipboard' action: #copyUrl.	aMenu add: 'keep in one file' action: #keepTogether.	aMenu addLine.	aMenu add: 'load PPT images from slide #1' action: #loadImagesIntoBook.	aMenu add: 'background color for all pages...' action: #setPageColor.	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!BookMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!menuPageSoundFor: target event: evt	| tSpec menu |	tSpec _ self transitionSpecFor: target.	menu _ (MenuMorph entitled: 'Choose a sound(it is now ' , tSpec first , ')') defaultTarget: target.	SampledSound soundNames do:		[:soundName |		menu add: soundName target: target			selector: #setProperty:toValue:			argumentList: (Array with: #transitionSpec								with: (tSpec copy at: 1 put: soundName; yourself))].	menu popUpEvent: evt in: self world! !!BookMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!menuPageVisualFor: target event: evt	| tSpec menu subMenu directionChoices |	tSpec _ self transitionSpecFor: target.	menu _ (MenuMorph entitled: 'Choose an effect(it is now ' , tSpec second , ')') defaultTarget: target.	TransitionMorph allEffects do:		[:effect |		directionChoices _ TransitionMorph directionsForEffect: effect.		directionChoices isEmpty		ifTrue: [menu add: effect target: target					selector: #setProperty:toValue:					argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: #none))]		ifFalse: [subMenu _ MenuMorph new.				directionChoices do:					[:dir |					subMenu add: dir target: target						selector: #setProperty:toValue:						argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: dir))].				menu add: effect subMenu: subMenu]].	menu popUpEvent: evt in: self world! !!ChineseCheckers methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:57'!mouseDown: evt	| menu |	evt yellowButtonPressed ifFalse: [^ self].	menu _ MenuMorph new defaultTarget: self.	self addMenuItemsTo: menu hand: evt hand.	menu popUpEvent: evt in: self world.! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!chooseDenominator: evt	| menu |	menu _ MenuMorph new.	(Integer primesUpTo: 30) do:		[:i |		menu add: i printString			target: self selector: #setDenominator:			argument: i].	menu addLine.	menu add: 'none' target: self selector: #setDenominator: argument: 9999.	menu popUpEvent: evt in: self world! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!chooseSound: evt	| menu |	menu _ MenuMorph new.	menu add: 'new' target: self selector: #editNewSound.	menu addLine.	AbstractSound soundNames do:		[:name |		menu add: name			target: self selector: #editSoundNamed:			argument: name].	menu popUpEvent: evt in: self world! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!readFromDisk: evt	| menu |	menu _ MenuMorph new.	(FileDirectory default fileNamesMatching: '*.fmp') do:		[:fileName |		menu add: fileName			target: self selector: #readFileNamed:			argument: fileName].	menu popUpEvent: evt in: self world! !!FatBitsPaint methodsFor: 'events' stamp: 'RAA 6/12/2000 08:58'!toolMenu: evt	| menu |	menu _ MenuMorph new.	menu		addTitle: 'Tools';		addStayUpItem.	{		{'paint brush'. self toolsForPaintBrush}.		{'selections'. self toolsForSelection}	} do: [:each |		menu add: each first			target: self			selector: #setCurrentToolTo:			argumentList: {each second}].	menu toggleStayUp: nil.	menu popUpEvent: evt in: self world! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!selectionMenu: evt        | menu |         (menu _ MenuMorph new)                addTitle: 'Edit';                addStayUpItem.        {                {'edit separately'. #editSelection}.                {'copy'. #copySelection}.                {'cut'. #cutSelection}.                {'paste'. #pasteSelection}        } do: [:each |                menu add: each first                        target: self                        selector: each second                        argumentList: #()].        menu toggleStayUp: nil.        menu popUpEvent: evt in: self world! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!setMagnification: evt	| menu |	menu _ MenuMorph new.	((1 to: 8), #(16 24 32)) do: [:w |		menu add: w printString			target: self			selector: #magnification:			argumentList: (Array with: w).		magnification = w ifTrue: [menu lastSubmorph color: Color red]].	menu popUpEvent: evt in: self world! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!setPenSize: evt	| menu sizes | 	menu _ MenuMorph new.	sizes _ (1 to: 5), (6 to: 12 by: 2), (15 to: 40 by: 5).	sizes do: [:w |		menu add: w printString			target: self			selector: #penSize:			argumentList: (Array with: w).		(brushSize // magnification) = w ifTrue: [menu lastSubmorph color: Color red]].	menu popUpEvent: evt in: self world! !!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'RAA 6/2/2000 11:01'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	w _ self world.	w ifNil: [^ response].	done _ false.	[done] whileFalse: [Display doOneCycleMorphic].	self delete.	Display doOneCycleMorphic.	^ response! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'RAA 6/2/2000 11:03'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels.	This variant is only for calling from within a Morphic project."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	 ^ self 		request: queryString 		initialAnswer: defaultAnswer 		centerAt: aPoint 		inWorld: Display getCurrentMorphicWorld! !!FlapTab methodsFor: 'edge' stamp: 'RAA 6/12/2000 08:58'!setEdgeToAdhereTo	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	#(left top right bottom) do:		[:sym | aMenu add: sym asString target: self selector:  #setEdge: argument: sym].	aMenu popUpEvent: self currentEvent in: self world! !!FlapTab methodsFor: 'positioning' stamp: 'RAA 6/2/2000 14:02'!positionObject: anObject	"anObject could be myself or my referent"	| container |	(container _ (self world ifNil: [self currentWorld]) viewBox) ifNil: [^ self].	"Could consider container _ referent pasteUpMorph, to allow flaps on things other than the world, but for the moment, let's skip it!!"	(edgeToAdhereTo == #left) ifTrue:		[^ anObject left: container left].	(edgeToAdhereTo == #right) ifTrue:		[^ anObject right: container right].	(edgeToAdhereTo == #top) ifTrue:		[^ anObject top: container top].	(edgeToAdhereTo == #bottom) ifTrue:		[^ anObject bottom: container bottom]! !!FlapTab methodsFor: 'positioning' stamp: 'RAA 6/2/2000 14:25'!spanWorld	| myWorld |	myWorld _ self world ifNil: [self currentWorld].	(self orientation == #vertical) ifTrue: [		referent height: myWorld height.		referent top: myWorld top.	] ifFalse: [		referent width: myWorld width.		referent left: myWorld left.	] ! !!FlapTab methodsFor: 'show & hide' stamp: 'RAA 6/2/2000 14:27'!hideFlapUnlessOverReferent	| aWorld where |		(referent isInWorld and: 		[			where _ self outermostWorldMorph activeHand lastEvent cursorPoint.			referent bounds containsPoint: where		]	) ifTrue: [^self].	aWorld _ self world.	self referent delete.	aWorld removeAccommodationForFlap: self.	flapShowing _ false.	self isInWorld ifFalse:		[self inboard ifTrue: [aWorld addMorphFront: self]].	self adjustPositionAfterHidingFlap! !!FlapTab methodsFor: 'show & hide' stamp: 'RAA 6/2/2000 14:07'!maybeHideFlapOnMouseLeave	self hasHalo ifTrue: [^ self].	referent isInWorld ifFalse: [^ self].	self hideFlapUnlessOverReferent.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'RAA 6/2/2000 10:53'!loadedFrames: aNumber 	self isStreaming		ifTrue: 			[activationKeys _ self collectActivationKeys: aNumber.			aNumber = 1				ifTrue: 					[activeMorphs addAll: activationKeys first.					self changed].			progressValue contents: aNumber asFloat / maxFrames.			"Give others a chance"			Smalltalk isMorphic				ifTrue: [Display doOneCycleMorphic]				ifFalse: [Processor yield]].	loadedFrames _ aNumber! !!FlashPlayerMorph methodsFor: 'project transition' stamp: 'RAA 6/3/2000 09:43'!addFillForProjectTarget: aFillStyle	| fillStyles |	fillStyles _ self valueOfProperty: #projectTargetFills ifAbsent:[IdentityDictionary new].	(fillStyles includesKey: aFillStyle) ifTrue:[^self].	fillStyles at: aFillStyle put: aFillStyle form.	self setProperty: #projectTargetFills toValue: fillStyles.	CurrentProjectRefactoring updateProjectFillsIn: self.	self changed.! !!FlashPlayerMorph methodsFor: 'project transition' stamp: 'RAA 6/3/2000 09:07'!beTransitionFrom: srcProjectName	^self beTransitionFrom: srcProjectName to: CurrentProjectRefactoring currentProjectName! !!FlashPlayerMorph methodsFor: 'project transition' stamp: 'RAA 6/3/2000 09:39'!beTransitionFrom: srcProjectName to: dstProjectName	"Make the receiver the animation between the two projects"	| srcProject dstProject |	srcProject _ CurrentProjectRefactoring projectWithNameOrCurrent: srcProjectName.	dstProject _ CurrentProjectRefactoring projectWithNameOrCurrent: dstProjectName.	(dstProject projectParameters at: #flashTransition ifAbsentPut:[IdentityDictionary new])		at: srcProject put: self.! !!FlashPlayerMorph methodsFor: 'project transition' stamp: 'RAA 6/3/2000 09:07'!beTransitionTo: dstProjectName	^self beTransitionFrom: CurrentProjectRefactoring currentProjectName to: dstProjectName! !!FlashPlayerMorph methodsFor: 'project transition' stamp: 'RAA 6/6/2000 17:00'!playProjectTransitionFrom: oldProject to: newProject entering: aBoolean	"Play the transition from the old to the new project."	Smalltalk isMorphic ifFalse: [^ self]. "Not in MVC"	self stopPlaying.	owner ifNotNil:[		self stopStepping.		owner privateRemoveMorph: self.		owner _ nil].	aBoolean ifTrue:[		self updateProjectFillsFrom: newProject.	] ifFalse:[		self updateProjectFillsFrom: oldProject.		self setProperty: #transitionBackground toValue: newProject imageForm.	].	self frameNumber: 1.	self loopFrames: false.	(self valueOfProperty: #fullScreenTransition ifAbsent:[false])		ifTrue:[self bounds: self world bounds].	self comeToFront.	self startStepping.	self startPlaying.	[playing] whileTrue: [Display doOneCycleNowMorphic].	self stopPlaying.	self stopStepping.	owner privateRemoveMorph: self.	owner _ nil.	self removeProperty: #transitionBackground.	Display deferUpdates: true.	Display bestGuessOfCurrentWorld fullDrawOn: (Display getCanvas).	Display deferUpdates: false.! !!FlashPlayerMorph methodsFor: 'project transition' stamp: 'RAA 6/3/2000 09:43'!removeFillForProjectTarget: aFillStyle	| fillStyles |	fillStyles _ self valueOfProperty: #projectTargetFills ifAbsent:[^self].	aFillStyle form: (fillStyles at: aFillStyle ifAbsent:[^self]).	fillStyles removeKey: aFillStyle.	CurrentProjectRefactoring updateProjectFillsIn: self.	self changed.! !!FlashPlayerMorph class methodsFor: 'project transition' stamp: 'RAA 6/3/2000 09:07'!transitionFrom: srcProjectName	^self transitionFrom: srcProjectName to: CurrentProjectRefactoring currentProjectName! !!FlashPlayerMorph class methodsFor: 'project transition' stamp: 'RAA 6/3/2000 09:39'!transitionFrom: srcProjectName to: dstProjectName	"Return the transition between the two projects"	| srcProject dstProject |	srcProject _ CurrentProjectRefactoring projectWithNameOrCurrent: srcProjectName.	dstProject _ CurrentProjectRefactoring projectWithNameOrCurrent: dstProjectName.	^dstProject projectParameters at: #flashTransition ifPresent:[:dict|		dict at: srcProject ifAbsent:[nil]].! !!FlashPlayerMorph class methodsFor: 'project transition' stamp: 'RAA 6/3/2000 09:07'!transitionTo: dstProjectName	^self transitionFrom: CurrentProjectRefactoring currentProjectName to: dstProjectName! !!HaloMorph methodsFor: 'stepping' stamp: 'RAA 6/11/2000 23:43'!step	| newBounds |	target ifNil: [^ self].	target isWorldMorph		ifTrue: [newBounds _ target bounds]		ifFalse: [newBounds _ target renderedMorph worldBoundsForHalo].	newBounds = self bounds ifTrue: [^ self].	growingOrRotating ifFalse: [  "adjust halo bounds if appropriate"		submorphs size > 1			ifTrue: [self addHandles].  "recreates full set with new bounds"		self bounds: newBounds].! !!HaloMorph methodsFor: 'private' stamp: 'RAA 6/12/2000 08:56'!doDebug: evt with: menuHandle	"Ask hand to invoke the a debugging menu for my inner target.  If shift key is down, immediately put up an inspector on the inner target"	| menu |	self removeAllHandlesBut: nil.  "remove all handles"	self world displayWorld.	evt shiftPressed ifTrue: 		[self delete.		^ innerTarget inspectInMorphic].	menu _ evt hand buildDebugHandleMenuFor: innerTarget.	menu addTitle: innerTarget externalName.	menu popUpEvent: evt in: self world.! !!HaloMorph methodsFor: 'private' stamp: 'RAA 6/12/2000 08:56'!doMenu: evt with: menuHandle	"Ask hand to invoke the halo menu for my inner target."	| menu |	self removeAllHandlesBut: nil.  "remove all handles"	self world displayWorld.	menu _ evt hand buildMorphHandleMenuFor: innerTarget.	target addDropShadowItemsTo: menu hand: evt hand.	innerTarget addTitleForHaloMenu: menu.	menu popUpEvent: evt in: self world.! !!HandMorph methodsFor: 'accessing' stamp: 'RAA 6/12/2000 06:38'!setArgument: aMorph	targetOffset _ menuTargetOffset _ self position.	self flag: #bob.		"do we need this?""	targetOffset _ aMorph world globalPointToLocal: self position."	argument _ aMorph.! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 6/11/2000 20:15'!dragOverList: evt		^self dragOverListAt: evt cursorPoint! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 6/11/2000 20:17'!dragOverListAt: p	|  roots mList mm root |	roots _ self worldUnderCursor rootMorphsAtGlobal: p.  "root morphs in world"	roots isEmpty		ifTrue: [^EmptyArray]		ifFalse: [root _ roots first].	mList _ root morphsAt: p.	mList size > 0 ifTrue:		["NOTE: We really only want the top morph and all its owners"		mm _ mList first.		mList _ OrderedCollection new.		[mm == root] whileFalse:			[mList addLast: mm.			mm _ mm owner].		mList add: root].	^ mList! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 5/25/2000 07:47'!handleDragOver: evt	| mList allMouseOvers leftMorphs enteredMorphs |	self worldUnderCursor ifNil: [^ self].  "this hand is not in a world"	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self dragOverList: evt.	"Make a list of all potential drag-overs..."	allMouseOvers _ mList select:		[:m | m handlesMouseOverDragging: (evt transformedBy: (m transformFrom: self))].	leftMorphs _ dragOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (dragOverMorphs includes: m) not].	"Notify and remove any morphs that have just been left..."	leftMorphs do: [:m |		dragOverMorphs remove: m.		m mouseLeaveDragging: (evt transformedBy: (m transformFrom: self))].	"Add any new mouse-overs and send mouseEnter:"	enteredMorphs do: [:m |		dragOverMorphs add: m.		mouseOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		m mouseEnterDragging: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 6/12/2000 18:13'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: Sensor cursorPoint]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ m world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [m world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				clickState == #firstClickDown					ifTrue: [clickClient click: firstClickEvent]					ifFalse:					["ensure that at least one mouseMove: is reported for each mouse transaction:"					m mouseMove: (localEvt copy setType: #mouseMove).					(m handlesMouseOverDragging: localEvt) ifTrue:						["If m also handles dragOver, enter it in the list"						dragOverMorphs add: m.						mouseOverMorphs remove: m ifAbsent: []]]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab					ifNotNil:						[self grabMorph: rootForGrab]					ifNil:						[self newMouseFocus: m   "trigger automatic viewing, for example"]].		mouseOverTimes removeKey: m ifAbsent: []]! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 5/25/2000 07:46'!handleMouseOver: evt	| mList allMouseOvers leftMorphs enteredMorphs now t oldHalo balloonHelpEnabled |		self worldUnderCursor ifNil: [^ self].	balloonHelpEnabled _ Preferences balloonHelpEnabled.	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	now _ Time millisecondClockValue.	"Make a list of all potential mouse-overs..."	allMouseOvers _ mList select:		[:m | m wantsHalo or: [(balloonHelpEnabled and: [m wantsBalloon])  "To start a timer"			or: [m handlesMouseOver: (evt transformedBy: (m transformFrom: self))]  "To send mouseEnter:"]].	leftMorphs _ mouseOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (mouseOverMorphs includes: m) not].	"Notify and remove any mouse-overs that have just been left..."	leftMorphs do: [:m |		mouseOverMorphs remove: m.		m wantsBalloon ifTrue: [m deleteBalloon].		m mouseLeave: (evt transformedBy: (m transformFrom: self)).		mouseOverTimes removeKey: m ifAbsent: [] ].	"Add any new mouse-overs and send mouseEnter: and/or start timers..."	enteredMorphs do: [:m |		mouseOverMorphs add: m.		dragOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		(m handlesMouseOver: evt) ifTrue:			[m mouseEnter: (evt transformedBy: (m transformFrom: self))].		(m wantsHalo or: [m wantsBalloon]) ifTrue:			[mouseOverTimes at: m put: now]].	mouseOverTimes keys do:		[:m | "Check pending timers for lingering"		t _ mouseOverTimes at: m.		(now < t "rollover" or: [now > (t+800)]) ifTrue:			["Yes we have lingered for 0.8 seconds..."			mouseOverTimes removeKey: m.			m owner ifNotNil:  "Not deleted during linger (--it happens ;--)"				[m wantsHalo					ifTrue: [oldHalo _ m world haloMorphOrNil.							(oldHalo == nil or: [oldHalo target ~~ m])								ifTrue: ["Put up halo for m"										self popUpHaloFor: m event: evt.										(balloonHelpEnabled and: [m wantsBalloon]) ifTrue:											["...and reschedule balloon after longer linger"											mouseOverTimes at: m put: now]]								ifFalse: ["Halo for m is already up, so show balloon"										(balloonHelpEnabled and: [m wantsBalloon])											ifTrue: [m showBalloon: m balloonText]]]					ifFalse:						[(balloonHelpEnabled and: [m wantsBalloon])							ifTrue: [m showBalloon: m balloonText]]]]]! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 6/11/2000 20:18'!mouseOverList: evt rank: rank 	"With rank = 1, returns a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame.	With rank = 2, returns the smae kind of list, but rooted in the next lower	rootmorph.  This can be useful to get mouseOvers below an active halo."	| p roots mList mm r |	p _ evt cursorPoint.	roots _ self worldUnderCursor rootMorphsAtGlobal: p.  "root morphs in world"	roots size >= rank		ifTrue: [mList _ (roots at: rank) unlockedMorphsAtGlobal: p.				mList size > 0 ifTrue:					["NOTE: We really only want the top morph and all its owners"					mm _ mList first.  r _ roots at: rank.					mList _ OrderedCollection new.					[mm == r] whileFalse:						[mList addLast: mm.						mm _ mm owner].					mList add: r]]		ifFalse: [mList _ EmptyArray].	^ mList! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 6/11/2000 20:18'!recipientForMouseDown: evt	"Return the morph that should handle the given mouseDown: event."	"Details: To get mouse events, a morph must		a. contain the point at which the mouse went down, and		b. respond true to handlesMouseDown:, and		c1. be in front of all other submorphs that respond true to handlesMouseDown: or		c2. be the outer-most submorph that responds true to preemptsMouseDown:If no morph handles the mouse down, the front-most submorph is grabbed. The complexity in this description arises from the need to resolve conflicts when nested submorphs all want to handle mouse events. The preemptsMouseDown: mechanism allows a morph to intercept mouse events before its submorphs. It is needed only in unusual situations, such as parts bins containing mouse-sensitive objects."	| p roots coreSample worldUnderCursor |	worldUnderCursor _ self worldUnderCursor.	worldUnderCursor ifNil: [^ nil].  "this hand is not in a world"	p _ evt cursorPoint.	roots _ worldUnderCursor rootMorphsAtGlobal: p.  "root morphs in world"	roots size = 0 ifTrue: [		"no morphs at the given point, so world gets it"		^ worldUnderCursor].	"coreSample is submorphs of the front-most root morph in front-to-back order"	coreSample _ roots first unlockedMorphsAtGlobal: p.	coreSample do: [:subM | (subM trumpsMouseDown: evt) ifTrue: [^ subM]].	"first, look for an outer-most submorph that preempts mouse events, if any"	coreSample reverseDo: [:subM |		(subM preemptsMouseDown: evt) ifTrue: [^ subM]].	"second, look for the inner-most submorph that handles mouse events, if any"	coreSample do: [:subM |		(subM handlesMouseDown: evt) ifTrue: [^ subM]].	"no enclosing morph wants the event, so return the front-most submorph"	coreSample size = 0 ifTrue: [		"no morphs at the given point, so world gets it"		^ worldUnderCursor].	^ coreSample first! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 5/25/2000 18:52'!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drops into the world."	| newOwner morphToDrop tfm localPt grabbedMorph pos worldUnderCursor |	worldUnderCursor _ self worldUnderCursor.	worldUnderCursor ifNil: [^ self].	self changed.	self submorphsReverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		addedFlexAtGrab == true			ifTrue: [pos _ m firstSubmorph position.					grabbedMorph _ m removeFlexShell.					self privateRemoveMorph: grabbedMorph.					grabbedMorph position: pos  "undo offset from removeFlexShell"]			ifFalse: [grabbedMorph _ m].		newOwner _ self dropTargetFor: grabbedMorph event: evt.		newOwner ifNil:  "Drop not allowed"			[self rejectDropMorph: grabbedMorph event: evt.			addedFlexAtGrab == true			ifTrue: [self privateRemoveMorph: m.					addedFlexAtGrab _ false].			^ self]."Transcript show: newOwner printString; cr."		morphToDrop _ newOwner morphToDropFrom: grabbedMorph. 		morphToDrop == grabbedMorph ifFalse: [submorphs size == 1 ifTrue:			[self privateRemoveMorph: m.			m privateOwner: nil.			addedFlexAtGrab _ false]].		"the above says: the thing to drop is not what I was carrying; silently vaporize what I was carrying lest it cause trouble later; keep the owner/submorph relationship invariant, but don't go through the standard delete protocol"		tfm _ newOwner transformFromWorld.		localPt _ tfm globalPointToLocal: self position.		addedFlexAtGrab == true			ifTrue: [morphToDrop position: localPt			 			+ (morphToDrop position - (m transform globalPointToLocal: self position)).					self privateRemoveMorph: m.					addedFlexAtGrab _ false]			ifFalse: [morphToDrop position: localPt + (morphToDrop position - self position)].		newOwner acceptDroppingMorph: morphToDrop event: evt.		morphToDrop justDroppedInto: newOwner event: evt.		morphToDrop owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 6/12/2000 13:00'!dropTargetFor: aMorph event: evt	"Return the morph that the given morph is to be dropped onto.  Return nil if we must repel the morph.  Return the world, if no other morph wants the dropping morph."	| root coreSample w | 	w _ self worldUnderCursor.	aMorph willingToBeEmbeddedUponLanding ifFalse: [^ w].	root _ nil.	w submorphsReverseDo: [:m |		((m fullContainsPoint: evt cursorPoint) and:		 [(m isKindOf: HaloMorph) not]) ifTrue: [root _ m]].	root == nil ifTrue: [^ w].	coreSample _ root morphsAt: evt cursorPoint.	coreSample do:		[:m |			(m repelsMorph: aMorph event: evt) ifTrue:				[^ nil]].	coreSample do:		[:m |			(m wantsDroppedMorph: aMorph event: evt) ifTrue: [^ m]].	^ w! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 6/12/2000 18:25'!grabMorph: aMorph	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor localPt m trans morphToGrab pos |	m _ aMorph.	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike ifTrue:		[editor _ m topEditor].	(m owner isKindOf: DropShadowMorph) ifTrue:		[self grabMorph: m owner.		^ editor ifNotNil: [editor scriptEdited]].	"Check if the morph will keep it's transform while grabbed"	m keepsTransform		ifTrue:[localPt _ self position]		ifFalse:[localPt _ m globalPointToLocal: self position].	m _ m aboutToBeGrabbedBy: self.	m == nil ifTrue: [^ self].	(formerOwner == nil		or: [m keepsTransform		or: [(trans _ formerOwner transformFromNearestWorld) isPureTranslation]]) 		ifTrue: [m position: (m globalPointToLocal: self position) + (m position - localPt).				morphToGrab _ m.				addedFlexAtGrab _ false]		ifFalse: ["Morph was in a flexed environment.  Flex it in the hand."				pos _ m position.				morphToGrab _ m addFlexShell transform: trans asMorphicTransform.				m position: pos.  "revert offset from addFlexShell"				morphToGrab transform: (trans withOffset: (trans offset + (trans localPointToGlobal: pos + targetOffset) - self position)).				addedFlexAtGrab _ true].	morphToGrab position: (morphToGrab localPointToGlobal: morphToGrab position).	gridOn ifTrue: [morphToGrab position: (morphToGrab position grid: grid)].	self addMorphBack: morphToGrab.	editor ifNotNil: [editor scriptEdited].! !!HandMorph methodsFor: 'world menu' stamp: 'RAA 5/24/2000 19:34'!buildWorldMenu	"Build the meta menu for the world."		^self worldMenuBuilder buildWorldMenu.! !!HandMorph methodsFor: 'world menu' stamp: 'RAA 5/24/2000 19:34'!getWorldMenu: aSymbol	"Build the meta menu for the world."		^self worldMenuBuilder perform: aSymbol! !!HandMorph methodsFor: 'world menu' stamp: 'RAA 5/25/2000 07:39'!worldMenuBuilder		^TheWorldMenu new 		world: self worldUnderCursor project: self worldUnderCursor project hand: self! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 5/24/2000 17:21'!argumentOrNil	"Answer the root of the front-most morph under the cursor. If the cursor is not over any morph, answer nil."	self worldUnderCursor submorphsDo:		[:m | ((m fullContainsPoint: targetOffset) and: [m isLocked not]) ifTrue: [^ m rootAt: targetOffset]].	^ nil! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 5/25/2000 07:40'!buildMorphHandleMenuFor: argMorph	"Build the morph menu for the given morph's halo's menu handle. This menu has two sections. The first section contains commands that are interpreted by the hand; the second contains commands provided by the target morph. This method allows the morph to decide which items should be included in the hand's section of the menu."	| menu |	argMorph == self worldUnderCursor "i.e., the world" ifTrue:		[^ self buildWorldMenu].	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	argMorph addAddHandMenuItemsForHalo: menu hand: self.	menu defaultTarget: argMorph.	argMorph addCustomHaloMenuItems: menu hand: self.	menu addLine.	argMorph player ifNotNil: [argMorph player addPlayerMenuItemsTo: menu hand: self].	menu defaultTarget: self.	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 5/24/2000 19:54'!changeColorTarget: aMorph selector: aSymbol originalColor: aColor	^ ColorPickerMorph new		sourceHand: self;		target: aMorph;		selector: aSymbol;		originalColor: aColor;		addToWorld: self world			near: (aMorph					ifNil: [Rectangle center: self position extent: 20]					ifNotNil: [aMorph == self world								ifTrue: [aMorph viewBox bottomLeft + (20@-20) extent: 200]								ifFalse: [aMorph fullBounds]]);		yourself! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/2/2000 11:02'!chooseColor	"Wait for the user to select a color and return that color."	"Details: Waiting for the user is implemented by running the interaction loop until the user has selected a color or dismisse the color picker."	| colorPicker |	colorPicker _ self changeColorTarget: nil selector: nil.	[colorPicker isInWorld] whileTrue: [Display doOneCycleMorphic].	^ colorPicker selectedColor! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/1/2000 19:31'!dismissMorph	argument world abandonAllHalos; stopStepping: argument.	argument delete! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/12/2000 08:59'!findDirtyBrowsers	"Present a menu of window titles for browsers with changes,	and activate the one that gets chosen."	| menu |	self flag: #bob.		"which world??"	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | (w model isKindOf: Browser) and: [w model canDiscardEdits not]])		do: [:w | menu add: w label target: w action: #activate].	menu submorphs size > 0 ifTrue:		[menu popUpEvent: lastEvent]! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/12/2000 08:59'!findDirtyWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	| menu |	self flag: #bob.		"which world??"	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | w model canDiscardEdits not])		do: [:w | menu add: w label target: w action: #activate].	menu submorphs size > 0 ifTrue:		[menu popUpEvent: lastEvent]! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/12/2000 09:00'!findWindow	"Present a menu of window titles, and activate the one that gets chosen.	Collapsed windows appear below line, expand if chosen."	| menu expanded collapsed nakedMorphs |	self flag: #bob.		"which world??"	menu _ MenuMorph new.	expanded _ SystemWindow windowsIn: self world satisfying: [:w | w isCollapsed not].	collapsed _ SystemWindow windowsIn: self world satisfying: [:w | w isCollapsed].	nakedMorphs _ self world submorphsSatisfying:		[:m | ((m isKindOf: SystemWindow) not and: [(m isKindOf: StickySketchMorph) not]) and:			[(m isKindOf: FlapTab) not]].	(expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty)) ifTrue: [^ self beep].	(expanded asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do:		[:w | menu add: w label target: w action: #activateAndForceLabelToShow.			w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	(expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty)) ifFalse: [menu addLine].	(collapsed asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do: 		[:w | menu add: w label target: w action: #collapseOrExpand.		w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	nakedMorphs isEmpty ifFalse: [menu addLine].	(nakedMorphs asSortedCollection: [:w1 :w2 | w1 externalName caseInsensitiveLessOrEqual: w2 externalName]) do:		[:w | menu add: w externalName target: w action: #comeToFrontAndAddHalo].	menu addTitle: 'find window'.		menu popUpEvent: lastEvent! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/11/2000 19:13'!invokeMenu: menu event: evt	"Invoke the given menu for the given event."	self halt.		"not used in current image"	"menu popUpEvent: evt"! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/12/2000 13:57'!invokeMetaMenu: evt	"Invoke the meta menu. If the hand is over the background, the world menu is presented. If it is over a morph, a menu of operations for that morph is presented. Each menu entry contains a string to be presented in the menu and a selector. If the selector takes an argument, the mouse-down event that invoked the menu is passed as an argument. This lets the command know which hand invoked it in order to do things like attaching the result of the command to that hand.If the hand is over the background and the shift key is pressed, the find-window menu is immediately put up.If the hand is over the background but the yellow button was pressed, an alternate menu, which individual users are encouraged to personalize, is put up -- see HandMorph.yellowButtonClickOnDesktopWithEvent:"	| menu |	Preferences noviceMode ifTrue: [^ self].	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	self flag: #bob.		"do we need this?"	targetOffset _ menuTargetOffset _ self worldUnderCursor globalPointToLocal: self position.	argument _ self argumentOrNil.	argument == nil		ifTrue:			[Utilities bringFlapsToFront.			evt yellowButtonPressed				ifTrue: [^ self yellowButtonClickOnDesktopWithEvent: evt].			evt shiftPressed				ifFalse:					["put put screen menu"					menu _ self buildWorldMenu.					menu addTitle: 'World']				ifTrue:					[^ self findWindow]]		ifFalse:			[menu _ self buildMorphMenuFor: argument.			menu addTitle: argument class name].	menu popUpEvent: evt.! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/1/2000 19:31'!lockMorph	argument lock.	argument world abandonAllHalos! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/12/2000 09:06'!operateOnSubmorph: aMorph event: evt	"Invoke the morph menu for the given submorph."	| menu |	menu _ self buildMorphMenuFor: aMorph.	menu addTitle: aMorph class name.	menu popUpEvent: evt in: aMorph world.! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/3/2000 09:40'!projectThumbnail	"Offer the user a menu of project names. Attach to the hand a thumbnail of the project the user selects."	| menu projName pr |	menu _ MVCMenuMorph entitled: 'Select Project'.	menu 		add: (CurrentProjectRefactoring currentProjectName, ' (current)') 		action: CurrentProjectRefactoring currentProjectName.	menu addLine.	Project allNames do: [:n | menu add: n action: n].	projName _ menu invokeAt: self position in: self world.	projName ifNotNil:		[(pr _ Project named: projName) 			ifNotNil: [self attachMorph: (ProjectViewMorph on: pr)]			ifNil: [self inform: 'can''t seem to find that project']].! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/12/2000 09:06'!selectSubmorphToOperateOn: rootMorph sending: aSymbol event: evt	"Let the user select a submorph of the given root morph. When selected, the given selector is sent with the selected submorph as an argument."	| possibleTargets menu |	possibleTargets _ rootMorph morphsAt: targetOffset.	possibleTargets size = 1 ifTrue: [^ self perform: aSymbol with: possibleTargets first with: evt].	menu _ MenuMorph new.	possibleTargets do: [:m |		menu add: (self submorphNameFor: m)			target: self			selector: aSymbol			argumentList: (Array with: m with: evt)].	menu popUpEvent: evt in: rootMorph world! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/11/2000 19:12'!yellowButtonClickOnDesktopWithEvent: evt	"Put up either the personalized menu or the world menu when the user clicks on the morphic desktop with the yellow button.  The preference 'personalizedWorldMenu' governs which one is used"	| aMenu |		Preferences personalizedWorldMenu			ifFalse:				[ 				aMenu _ self buildWorldMenu.				aMenu addTitle: 'World']			ifTrue:				[aMenu _ MenuMorph new defaultTarget: self world.				Preferences personalizeUserMenu: aMenu.				aMenu addLine.				aMenu add: 'personalize...' target: Preferences action: #letUserPersonalizeMenu].	aMenu popUpEvent: evt! !!HandMorph methodsFor: 'special gestures' stamp: 'RAA 6/12/2000 06:41'!specialGesture: evt	"Special gestures (cmd-mouse on the Macintosh) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	"Summary:		Cmd-click			pop up halo		Cmd-drag			reposition morph"	Preferences cmdGesturesEnabled ifFalse: [^ self].	self newMouseFocus: nil.	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	targetOffset _ menuTargetOffset _ self worldUnderCursor globalPointToLocal: self position.	argument _ self argumentOrNil.	evt shiftPressed		ifFalse:	[self popUpHaloFromClick: evt]		ifTrue:	[self popUpHaloFromShiftClick: evt]! !!HandMorph methodsFor: 'halos' stamp: 'RAA 6/11/2000 15:47'!chooseHaloSubmorphOf: root caption: caption	"Answer the submorph of the root that should be given the halo"	^ (root unlockedMorphsAtGlobal: targetOffset) first! !!HandMorph methodsFor: 'halos' stamp: 'RAA 6/12/2000 09:01'!invokeMetaMenuFor: aMorph	| menu |	menu _ self buildMorphMenuFor: aMorph.	menu addTitle: aMorph externalName.	menu popUpEvent: lastEvent in: aMorph world! !!HandMorph methodsFor: 'halos' stamp: 'RAA 6/12/2000 06:42'!popUpHalo: evt	"Pop up a halo on the top-most unlocked morph below the hand."	self flag: #bob.		"appears to be unused"	self halt.	self world abandonAllHalos.	targetOffset _ self position.	(argument _ self argumentOrNil) ifNil: [^ self].	argument submorphCount > 0 ifTrue:		[(argument _ self chooseHaloSubmorphOf: argument caption: 'Who gets halo?')			ifNil: [^ self]].	self addHalo: evt.! !!HandMorph methodsFor: 'halos' stamp: 'RAA 6/12/2000 06:37'!popUpHaloFor: aMorph event: evt	aMorph world abandonAllHalos.	targetOffset _ aMorph world globalPointToLocal: self position.	aMorph addHalo: evt! !!HandMorph methodsFor: 'halos' stamp: 'RAA 6/12/2000 06:35'!popUpHaloFromClick: evt	"Pop up a halo on a suitable morph below the hand.	If there are multiple possible targets, and one of them already has a halo, then	choose the next inner target.  That is, unless we are already at the bottom, in which case	go topmost again."	| oldTargets targets anIndex w |	oldTargets _ OrderedCollection new.	w _ self worldUnderCursor.	w haloMorphs do: [:h | oldTargets addLast: h target. h delete].	targetOffset _ w globalPointToLocal: self position.	(argument _ self argumentOrNil) ifNil: [^ w addHalo: evt].	argument submorphCount = 0 ifTrue: [^ argument wantsHaloFromClick ifTrue: [argument addHalo: evt "sole target"]].	"Multiple possible targets, choose the outermost suitable one first, but if one already		has a halo, then choose the next farther in."	targets _ argument unlockedMorphsAtGlobal: targetOffset.	targets _ targets reversed select: [:aMorph | aMorph wantsHaloFromClick].	targets size = 0 ifTrue: [^ argument wantsHaloFromClick			ifTrue: [argument addHalo: evt "sole target"]			ifFalse: ["no halo recipient"]].	targets size = 1 ifTrue: [^ targets first addHalo: evt "sole target"].	anIndex _ targets findFirst: [:t | oldTargets includes: t].	anIndex = 0 ifTrue:		[^ self popUpNewHaloFromClick: evt targets: targets].	^ (targets atWrap: anIndex + 1) addHalo: evt from: (targets at: anIndex) "next inner target"! !!HandMorph methodsFor: 'halos' stamp: 'RAA 6/12/2000 06:42'!popUpHaloFromShiftClick: evt	| oldTargets targets anIndex w |	"Given that the shift key is down, pop up a halo on an appropriate morph.  Go to the deepest morph (locked or not), unless there is an existing halo, in which case go out one level"	w _ self worldUnderCursor.	oldTargets _ OrderedCollection new.	w haloMorphs do:		[:h | oldTargets addLast: h innerTarget. h delete].	targetOffset _ w globalPointToLocal: self position.	(argument _ self argumentOrNil) ifNil: [^ w addHalo: evt].	argument submorphCount = 0 ifTrue: [^ argument addHalo: evt "sole target"].	"Multiple possible targets, choose the deepest first, but if one already has a halo, then choose the next farther out.   Ignore renderers in the list"	targets _ (argument morphsAt: targetOffset) reject: [:m | m isRenderer].	targets size = 0 ifTrue: [^ argument addHalo: evt "sole target"].	targets size = 1 ifTrue: [^ targets first addHalo: evt "sole target"].	anIndex _ targets findFirst: [:t | oldTargets includes: t].	anIndex = 0 ifTrue: [^ targets first addHalo: evt "deepest target"].	^ (targets atWrap: anIndex + 1) addHalo: evt from: (targets at: anIndex) "next outer target"! !!HandMorph methodsFor: 'world hacking' stamp: 'RAA 6/2/2000 10:05'!worldUnderCursor	"will ultimately allow one Hand to service multiple worlds"	^Display morphicWorldAt: Sensor cursorPoint! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 09:02'!setChannel: evt	| menu |	menu _ MenuMorph new.	1 to: 16 do: [:chan |		menu add: chan printString			target: self			selector: #channel:			argumentList: (Array with: chan - 1)].	menu popUpEvent: evt in: self world! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 09:02'!setController: evt	| menu |	menu _ MenuMorph new.	self controllerList do: [:pair |		menu add: (pair last)			target: self			selector: #controller:			argumentList: (Array with: pair first)].	menu popUpEvent: evt in: self world! !!MenuMorph methodsFor: 'control' stamp: 'RAA 6/6/2000 17:19'!popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta tryToPlace selectedOffset |	hand world startSteppingSubmorphsOf: self.	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self selectedItem.	self fullBounds.  "ensure layout is current"	selectedOffset := selectedItem position - self position.	tryToPlace :=		[ :where :mustFit |		self position: where - selectedOffset.		delta _ self fullBoundsInWorld amountToTranslateWithin: sourceItem worldBounds.		(delta x = 0 or: [mustFit]) ifTrue:			[delta = (0@0) ifFalse: [self position: self position + delta].			sourceItem owner owner addMorphFront: self.			^ self]].	tryToPlace 		value: rightOrLeftPoint first value: false;		value: rightOrLeftPoint last  - (self width @ 0) value: false;		value: rightOrLeftPoint first value: true	! !!MenuMorph methodsFor: 'control' stamp: 'RAA 6/11/2000 19:13'!popUpAt: aPoint event: evt	"Present this menu at the given point in response to the given event."	self halt.		"there are currently no senders in image"	"self popUpAt: aPoint forHand: evt hand"! !!MenuMorph methodsFor: 'control' stamp: 'RAA 6/12/2000 09:11'!popUpAt: aPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta |	self flag: #bob.		"currently no senders"	self halt.	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self selectedItem.	self fullBounds.  "ensure layout is current"	self position: aPoint - (selectedItem position - self position).	sourceItem owner owner addMorphFront: self.	delta _ self fullBoundsInWorld amountToTranslateWithin: sourceItem worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta]! !!MenuMorph methodsFor: 'control' stamp: 'RAA 6/12/2000 08:52'!popUpAt: aPoint forHand: hand in: aWorld	"Present this menu at the given point under control of the given hand."	| selectedItem |	self items isEmpty ifTrue: [^ self].	popUpOwner _ hand.	originalEvent _ hand lastEvent.	selectedItem _ self selectedItem.	self positionAt: aPoint relativeTo: selectedItem inWorld: aWorld.	aWorld addMorphFront: self; startSteppingSubmorphsOf: self.	hand newMouseFocus: selectedItem.	self changed! !!MenuMorph methodsFor: 'control' stamp: 'RAA 6/12/2000 09:07'!popUpEvent: evt	"Present this menu in response to the given event."	self flag: #bob.		"on the way out in favor of #popUpEvent:in:"	^self popUpEvent: evt in: evt hand worldUnderCursor! !!MenuMorph methodsFor: 'control' stamp: 'RAA 6/12/2000 08:55'!popUpEvent: evt in: aWorld	| h p |	"Present this menu in response to the given event."	h _ evt hand.	p _ (aWorld pointFromWorld: h position) truncated.	^self popUpAt: p forHand: h in: aWorld! !!MenuMorph methodsFor: 'control' stamp: 'RAA 6/12/2000 08:53'!popUpForHand: hand 	| w p |	"Present this menu under control of the given hand."	w _ hand worldUnderCursor.	p _ (w pointFromWorld: hand position) truncated.	^self popUpAt: p forHand: hand in: w! !!MenuMorph methodsFor: 'control' stamp: 'RAA 6/12/2000 09:13'!popUpForHand: hand in: aWorld	| p |	"Present this menu under control of the given hand."	p _ (aWorld pointFromWorld: hand position) truncated.	^self popUpAt: p forHand: hand in: aWorld! !!MenuMorph methodsFor: 'control' stamp: 'RAA 6/11/2000 19:18'!popUpNearHand	self popUpForHand: self currentHand! !!MenuMorph methodsFor: 'private' stamp: 'RAA 6/6/2000 17:24'!positionAt: aPoint relativeTo: selectedItem inWorld: aWorld	"Note: items may not be laid out yet (I found them all to be at 0@0),  	so we have to add up heights of items above the selected item."	| i yOffset sub delta |	i _ 0.	yOffset _ 0.	[(sub _ self submorphs at: (i _ i + 1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	"If it doesn't fit, show it to the left, not to the right of the hand."	self right > aWorld worldBounds right		ifTrue: [self left: self left - self width + 4].	"Make sure that the menu fits in the world."	delta _ self bounds amountToTranslateWithin: aWorld worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta]! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'RAA 6/2/2000 11:05'!displayAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	Smalltalk isMorphic ifFalse: [^ self].	Display getCurrentMorphicWorld addMorph: self centeredNear: aPoint.	self world displayWorld.  "show myself"	aBlock value.	self delete! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'RAA 6/2/2000 11:05'!informUserAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	| title w |	Smalltalk isMorphic ifFalse: [^ self].	title _ submorphs first submorphs first.	self visible: false.	w _ Display getCurrentMorphicWorld.	aBlock value:[:string|		self visible ifFalse:[			w addMorph: self centeredNear: aPoint.			self visible: true].		title contents: string.		self setConstrainedPositionFrom: Sensor cursorPoint.		self changed.		w displayWorld		 "show myself"	]. 	self delete.	w displayWorld! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'RAA 6/12/2000 08:53'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	self flag: #bob.		"is <aPoint> global or local?"	self popUpAt: aPoint forHand: aWorld primaryHand in: aWorld.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneSubCycle].	self delete.	^ selectedItem! !!MorphWorldView methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 10:34'!deEmphasizeView 	"This window is becoming inactive."	Cursor normal show.    "restore the normal cursor"	model deEmphasizeViewMVC: self topView cacheBitsAsTwoTone.! !!MorphicEvent methodsFor: 'mouse'!cursorPoint	"Answer the location of the cursor's hotspot when this event occured."	^ cursorPoint! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'RAA 6/12/2000 09:07'!setPenSize: evt	| menu sizes |	menu _ MenuMorph new.	sizes _ (0 to: 5), (6 to: 12 by: 2), (15 to: 40 by: 5).	sizes do: [:w |		menu add: w printString			target: self			selector: #penSize:hand:			argumentList: (Array with: w with: evt hand)].	menu popUpEvent: evt in: self world! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'RAA 6/10/2000 10:38'!initializeNetworkIfFail: errorBlock	"Initialize the network drivers and record the semaphore to be used by the resolver. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails."	"NetNameResolver initializeNetworkIfFail: [self error: 'network initialization failed']"	| semaIndex result |	self resolverStatus = ResolverUninitialized		ifFalse: [			LastContact _ Time totalSeconds.  HaveNetwork _ true.			^ self].  "network is already initialized"	LastContact _ Time totalSeconds.  HaveNetwork _ false.	"in case abort"	ResolverSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: ResolverSemaphore.	Utilities informUser:'Initializing the network drivers; this maytake up to 30 seconds and can''t be interrupted'		during: [result _ self primInitializeNetwork: semaIndex].	Display repaintMorphicDisplayNow.  "take the informer down"	"result is nil if network initialization failed, self if it succeeds"	result ifNil: [errorBlock value]		ifNotNil: [HaveNetwork _ true].! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'RAA 6/2/2000 16:23'!initialExtent	^300@500! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'RAA 6/2/2000 16:24'!openExplorerFor: anObject"ObjectExplorer new openExplorerFor: Smalltalk"    (self explorerFor: anObject) openInWorld.    ^ self! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'RAA 6/10/2000 10:40'!acceptDroppingMorph: aMorph event: evt	| slotSpecs aValue incomingName nameObtained mm tfm |	self isWorldMorph		ifTrue:			["Add the given morph to this world and start stepping it if it wants to be."			self addMorphFront: aMorph.			(aMorph fullBounds intersects: self viewBox) ifFalse:				[self beep.  aMorph position: self bounds center]]		ifFalse:			[self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).			self changed.			self layoutChanged].	incomingName _ aMorph knownName.	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self autoLineLayout ifTrue: [self fixLayout].	aMorph allMorphsDo:  "Establish any penDown morphs in new world"		[:m | m player ifNotNil:			[m player getPenDown ifTrue:				[((mm _ m player costume) notNil and: [(tfm _ mm owner transformFrom: self) notNil])					ifTrue: [self noteNewLocation: (tfm localPointToGlobal: mm referencePosition)									forPlayer: m player]]]].	self isPartsBin		ifTrue:			[aMorph isPartsDonor: true.			aMorph stopSteppingSelfAndSubmorphs.			aMorph suspendEventHandler]		ifFalse:			[self world startSteppingSubmorphsOf: aMorph].	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	slotSpecs _ aMorph slotSpecifications.  "A Fabrik component, for example.  Just a hook at this time"	slotSpecs size > 0 ifTrue:		[self assuredPlayer.		slotSpecs do:			[:tuple |				aValue _ aMorph initialValueFor: tuple first.				nameObtained _ self player addSlotNamedLike: tuple first withValue: aValue.				nameObtained ~= incomingName ifTrue:					[aMorph setNameTo: nameObtained]].		self player updateAllViewers]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'RAA 6/12/2000 13:17'!morphToDropFrom: aMorph	| itsSelector aScriptor adjustment anEditor actualObject aUserScript ownersChoice aNail representee handy posBlock tempPos |	handy _ self primaryHand.	posBlock _ [ :z |		tempPos _ handy position - (			(handy targetOffset - handy formerPosition) * (z extent / aMorph extent)		) rounded.		self pointFromWorld: tempPos	].	owner ifNotNil: [		ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self.		ownersChoice ifNotNil: [^ ownersChoice]	].	self alwaysShowThumbnail ifTrue: [		aNail _ aMorph 			representativeNoTallerThan: self maxHeightToAvoidThumbnailing 			norWiderThan: self maximumThumbnailWidth 			thumbnailHeight: self heightForThumbnails.		aNail == aMorph ifFalse: [			aNail position: (posBlock value: aNail)		].		^ aNail	].	((aMorph isKindOf: MorphThumbnail) and: 				[(representee _ aMorph morphRepresented) owner == nil]) ifTrue: [		representee position: (posBlock value: representee).		^ representee	].	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newPermanentScript) ifTrue: [		^ self emptyPermanentScriptorFrom: aMorph	].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	aMorph isCommand ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	actualObject assureUniClass.	itsSelector _ aMorph userScriptSelector.	aScriptor _ (itsSelector ~~ nil and: [itsSelector size > 0]) ifTrue: [		actualObject isFlagshipForClass ifFalse: [		"We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor		] ifTrue: [		"old note: ambiguous case: if there's a script editor on the world, 		drop down a button, else drop down the script editor"			aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.			aUserScript isTextuallyCoded ifTrue: [				^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject			].			((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:					[anEditor owner == self])				ifFalse: [					adjustment _ 50 @ 30.					anEditor				] ifTrue: [					adjustment _ 60 @ 20.					actualObject permanentScriptEditorFor: aMorph				]		]	] ifFalse: [ "It's a system-defined selector; construct an anonymous scriptor around it"		adjustment _ 60 @ 20.		actualObject permanentScriptEditorFor: aMorph	].	aScriptor position: (self pointFromWorld: (handy position - adjustment)).	(aScriptor isMemberOf: ScriptEditorMorph) ifTrue: [		aScriptor playerScripted expungeEmptyUnRenamedScripts	].	^ aScriptor! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/12/2000 09:14'!presentPlayfieldMenu	self playfieldOptionsMenu popUpForHand: self activeHand in: self world! !!PasteUpMorph methodsFor: 'misc' stamp: 'RAA 5/25/2000 15:07'!invalidRect: damageRect	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	self isTheActiveWorld		ifTrue: [worldState recordDamagedRect: damageRect]		ifFalse: [super invalidRect: (damageRect intersect: bounds)]! !!PasteUpMorph methodsFor: 'misc' stamp: 'RAA 6/1/2000 10:28'!position: aPoint	"Prevent moving a world (e.g. via HandMorph>>specialGesture:)"	"for now, let's allow it and see what happens"	self isWorldMorph ifFalse: [^super position: aPoint].	super position: aPoint.	self viewBox ifNotNil: [self viewBox: (aPoint extent: self viewBox extent)].! !!PasteUpMorph methodsFor: 'flaps' stamp: 'RAA 6/3/2000 09:09'!addGlobalFlaps 	"Must make global flaps adapt to world.  Do this even if not shown, so the old world will not be pointed at by the flaps."	| use thisWorld |	use _ true.	(Preferences valueOfFlag: #useGlobalFlaps) ifFalse: [use _ false].	CurrentProjectRefactoring currentFlapsSuppressed ifTrue: [use _ false].	"Smalltalk isMorphic ifFalse: [use _ false]."	thisWorld _ use 		ifTrue: [self]		ifFalse: [(PasteUpMorph new) initForProject:  "fake to be flap owner"						WorldState new;					bounds: (0@0 extent: 4000@4000);					viewBox: (0@0 extent: 4000@4000)].		Utilities globalFlapTabs do: [:aFlapTab |		(aFlapTab world == thisWorld) ifFalse:			[thisWorld addMorphFront: aFlapTab.			aFlapTab adaptToWorld: thisWorld].	"always do"		use ifTrue: [			aFlapTab spanWorld.			aFlapTab adjustPositionAfterHidingFlap.			aFlapTab flapShowing ifTrue: [aFlapTab showFlap]]]."	Utilities clobberFlapTabList.	Utilities initializeStandardFlaps.	self currentWorld deleteAllFlapArtifacts.	self currentWorld addGlobalFlaps."! !!PasteUpMorph methodsFor: 'project state' stamp: 'RAA 5/24/2000 11:11'!handsDo: aBlock	^ worldState handsDo: aBlock! !!PasteUpMorph methodsFor: 'project state' stamp: 'RAA 6/1/2000 13:51'!viewBox: newViewBox	| vb |	((vb _ self viewBox) == nil or: [vb extent ~= newViewBox extent])		ifTrue: [worldState canvas: nil].	worldState viewBox: newViewBox.	super position: newViewBox topLeft."23 may 2000 - RAA - let's see if this is ok"	bounds _ newViewBox.	"0@0 extent: newViewBox extent."	"Paragraph problem workaround; clear selections to avoid screen droppings:"	worldState handsDo: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !!PasteUpMorph methodsFor: 'stepping' stamp: 'RAA 5/24/2000 11:10'!cleanseStepList	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."	worldState cleanseStepListForWorld: self! !!PasteUpMorph methodsFor: 'stepping' stamp: 'RAA 6/7/2000 10:12'!runLocalStepMethods	worldState runLocalStepMethodsIn: self! !!PasteUpMorph methodsFor: 'stepping' stamp: 'RAA 5/24/2000 10:27'!runStepMethods	worldState runStepMethodsIn: self! !!PasteUpMorph methodsFor: 'stepping' stamp: 'RAA 5/24/2000 11:02'!startStepping: aMorph	"Add the given morph to the step list. Do nothing if it is already being stepped."	worldState startStepping: aMorph! !!PasteUpMorph methodsFor: 'stepping' stamp: 'RAA 5/24/2000 11:08'!stopStepping: aMorph	"Remove the given morph from the step list."	worldState stopStepping: aMorph! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 22:29'!activeHand: aHandMorph	"temporarily retained for old main event loops"	worldState activeHand: aHandMorph.! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 12:08'!addHand: aHandMorph	"Add the given hand to the list of hands for this world."	worldState addHand: aHandMorph.	aHandMorph privateOwner: self.! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 12:09'!allMorphsDo: aBlock	"Enumerate all morphs in the world, including those held in hands."	super allMorphsDo: aBlock.	self isWorldMorph		ifTrue: [worldState handsReverseDo: [:h | h allMorphsDo: aBlock]].! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 10:45'!assuredCanvas		^worldState assuredCanvas! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/25/2000 15:15'!beWorldForProject: aProject	self privateOwner: nil.	worldState _ WorldState new.	self addHand: HandMorph new.	self setProperty: #automaticPhraseExpansion toValue: true.	self startSteppingSubmorphsOf: self! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 10:34'!deEmphasizeViewMVC: asTwoTone	worldState handsDo:          "free dependents links if any"		[:h | h newKeyboardFocus: nil].	worldState canvas: nil.		"free model's canvas to save space"	self fullReleaseCachedState.	asTwoTone ifTrue: [		"draw deEmphasized as a two-tone (monochrome) form"		self displayWorldAsTwoTone].! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/25/2000 15:43'!displayWorld	self outermostWorldMorph privateOuterDisplayWorld! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 13:20'!displayWorldAsTwoTone	"Display the world in living black-and-white. (This is typically done to save space.)"	worldState displayWorldAsTwoTone: self submorphs: submorphs color: color! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/6/2000 17:31'!displayWorldNonIncrementally	"Display the morph world non-incrementally. Used for testing."	(worldState canvas == nil or:	 [(worldState canvas extent ~= self viewBox extent) or:	 [worldState canvas form depth ~= Display depth]]) ifTrue: [		"allocate a new offscreen canvas the size of the window"		worldState canvas: (Display defaultCanvasClass extent: self viewBox extent)].	worldState canvas fillColor: color.	submorphs reverseDo: [:m | m fullDrawOn: worldState canvas].	worldState handsReverseDo: [:h | h fullDrawOn: worldState canvas].	worldState canvas form displayOn: Display at: self viewBox origin.	self fullRepaintNeeded.  "don't collect damage"	Display forceDisplayUpdate.! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 12:23'!displayWorldSafely	worldState displayWorldSafely: self.! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 11:57'!doOneCycle	worldState doOneCycleFor: self! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 10:14'!doOneCycleInBackground		worldState doOneCycleInBackground! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 11:59'!doOneSubCycle	"Like doOneCycle, but preserves activeHand."	worldState doOneSubCycleFor: self! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/11/2000 17:45'!embeddedProjectDisplayMode	"#naked - the embedded project/world is just a pasteup in the outer p/w	#window - the embedded p/w is in a system window in the outer p/w	#frame - the embedded p/w is in a green frame and clipped	#scaled - the embedded p/w is in a green frame and scaled to fit"	^#scaled! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/3/2000 09:44'!exit	CurrentProjectRefactoring exitCurrentProject! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/2/2000 12:30'!extent: aPoint	super extent: aPoint.	worldState ifNotNil: [		"Bob say: 'setting extent to: ',aPoint printString,' in ',self printString."		worldState viewBox ifNotNil: [			worldState viewBox: bounds		].	].! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/2/2000 10:22'!fullContainsPoint: pt	"The world clips its children"	worldState ifNil: [^super fullContainsPoint: pt].	^bounds containsPoint: pt! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/25/2000 15:12'!fullRepaintNeeded	worldState doFullRepaint.	SystemWindow windowsIn: self		satisfying: [:w | w makeMeVisible. false].! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/10/2000 17:06'!install	owner _ nil.	"since we may have been inside another world previously"	submorphs do: [:ss | ss owner == nil ifTrue: [ss privateOwner: self]].		"Transcript that was in outPointers and then got deleted."	self viewBox: Display boundingBox.	worldState handsDo: [:h | h initForEvents].	self installFlaps.	SystemWindow noteTopWindowIn: self.	self displayWorldSafely.! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/11/2000 16:08'!installAsActiveSubprojectIn: enclosingWorld at: newBounds titled: aString	| window howToOpen tm boundsForWorld |	howToOpen _ self embeddedProjectDisplayMode.	submorphs do: [:ss | ss owner == nil ifTrue: [ss privateOwner: self]].		"Transcript that was in outPointers and then got deleted."	boundsForWorld _ howToOpen == #naked ifTrue: [newBounds] ifFalse: [bounds].	worldState canvas: nil.	worldState viewBox: boundsForWorld.	self bounds: boundsForWorld.	"self viewBox: Display boundingBox."	"worldState handsDo: [:h | h initForEvents]."	self installFlaps.	"SystemWindow noteTopWindowIn: self."	"self displayWorldSafely."	howToOpen == #naked ifTrue: [		enclosingWorld addMorphFront: self.	].	howToOpen == #window ifTrue: [		window _ (NewWorldWindow labelled: aString) model: self.		window addMorph: self frame: (0@0 extent: 1.0@1.0).		window openInWorld: enclosingWorld.	].	howToOpen == #frame ifTrue: [		window _ AlignmentMorphBob1 new			minWidth: 100;			minHeight: 100;			borderWidth: 8;			borderColor: Color green;			heights: #(999999);			bounds: newBounds.		window addMorph: self.		window openInWorld: enclosingWorld.	].	howToOpen == #scaled ifTrue: [		self position: 0@0.		window _ AlignmentMorphBob1 new			minWidth: 100;			minHeight: 100;			borderWidth: 8;			borderColor: Color green;			heights: #(999999);			bounds: newBounds.		tm _ BOBTransformationMorph new.		window addMorph: tm.		tm addMorph: self.		window openInWorld: enclosingWorld.		tm scale: (tm width / self width min: tm height / self height) asFloat.	].! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/11/2000 16:16'!installAsActiveSubprojectIn: enclosingWorld titled: aString	| opt newWidth |	opt _ self optimumExtentFromAuthor.	(opt x > (enclosingWorld width * 0.7) or: 			[opt y > (enclosingWorld height * 0.7)]) ifTrue: [		newWidth _ enclosingWorld width // 2.		opt _ newWidth @ (opt y * newWidth / opt x) truncated	].	^self 		installAsActiveSubprojectIn: enclosingWorld 		at: (enclosingWorld topLeft + (enclosingWorld extent - opt // 2) extent: opt) 		titled: aString! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/11/2000 15:09'!optimumExtentFromAuthor	| opt |	^self 		valueOfProperty: #optimumExtentFromAuthor 		ifAbsent: [			opt _ bounds extent.			self setProperty: #optimumExtentFromAuthor toValue: opt.			^opt		]! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 12:10'!patchAt: patchRect without: stopMorph andNothingAbove: stopThere	"Return a complete rendering of this patch of the display screen	without stopMorph, and possibly without anything above it."	| c |	c _ ColorPatchCanvas extent: patchRect extent depth: Display depth.	c stopMorph: stopMorph.	c doStop: stopThere.	c _ c copyOrigin: patchRect topLeft negated clipRect: (0@0 extent: patchRect extent).	(self bounds containsRect: patchRect) ifFalse:		["Need to fill area outside bounds with black."		c form fillColor: Color black].	(self bounds intersects: patchRect) ifFalse:		["Nothing within bounds to show."		^ c form].	c fillRectangle: self bounds color: color.  "Fill bounds with world color."	self drawSubmorphsOn: c.	worldState handsReverseDo: [:h | h drawSubmorphsOn: c].	^c form! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 10:38'!pauseEventRecorder	"Suspend any event recorder, and return it if found"	| er |	worldState handsDo: [:h | (er _ h pauseEventRecorderIn: self) ifNotNil: [^ er]].	^ nil! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/1/2000 14:23'!privateMoveBy: delta	super privateMoveBy: delta.	worldState ifNotNil: [		worldState viewBox ifNotNil: [			worldState viewBox: bounds		].	].! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/25/2000 15:43'!privateOuterDisplayWorld	worldState displayWorld: self submorphs: submorphs! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 12:06'!removeHand: aHandMorph	"Remove the given hand from the list of hands for this world."	(worldState hands includes: aHandMorph) ifFalse: [^self].	aHandMorph dropMorphsEvent: MorphicEvent new.	self invalidRect: aHandMorph fullBounds.	worldState removeHand: aHandMorph.! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/25/2000 08:04'!restoreDisplay	Display restoreMorphicDisplay.	"I don't actually expect this to be called"! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/3/2000 09:09'!restoreFlapsDisplay	(Preferences useGlobalFlaps and: [CurrentProjectRefactoring currentFlapsSuppressed not]) ifTrue:		[Utilities globalFlapTabs do:			[:aFlapTab | aFlapTab adaptToWorld]].	self localFlapTabs do:			[:aFlapTab | aFlapTab adaptToWorld].	self assureFlapTabsFitOnScreen.	self bringFlapTabsToFront! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 10:38'!selectHandsToDrawForDamage: damageList	"Select the set of hands that must be redrawn because either (a) the hand itself has changed or (b) the hand intersects some damage rectangle."	| result hBnds |	result _ OrderedCollection new.	worldState handsDo: [:h |		h needsToBeDrawn ifTrue: [			h hasChanged				ifTrue: [result add: h]				ifFalse: [					hBnds _ h fullBounds.					(damageList detect: [:r | r intersects: hBnds] ifNone: [nil])						ifNotNil: [result add: h]]]].	^ result! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 10:50'!sleep	worldState canvas ifNil: [^ self  "already called (clean this up)"].	Cursor normal show.	"restore the normal cursor"	(turtleTrailsForm ~~ nil and: [self confirm: 'May I clear the pen trailsin this worldState to save space?']) ifTrue: [self clearTurtleTrails].	worldState canvas: nil.		"free my canvas to save space"	self fullReleaseCachedState.! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/1/2000 19:01'!startSteppingSubmorphsOf: aMorph	"Ensure that all submorphs of the given morph that want to be stepped are added to the step list.   Typically used after adding a morph to the world."	aMorph allMorphsDo: [:m |		m wantsSteps ifTrue: [m arrangeToStartSteppingIn: m world].	]! !!PasteUpMorph methodsFor: 'interaction loop' stamp: 'RAA 5/24/2000 11:55'!doOneCycleNow	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	worldState doOneCycleNowFor: self.! !!PasteUpMorph methodsFor: 'WiW support' stamp: 'RAA 6/3/2000 09:48'!restartWorldCycleWithEvent: evt	"RAA 27 Nov 99 - redispatch that click picked up from our inner world"	evt ifNotNil: [		self primaryHand handleEvent: (evt setHand: self primaryHand).	].	CurrentProjectRefactoring currentSpawnNewProcessAndTerminateOld: true! !!PasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 15:15'!newWorldForProject: projectOrNil 	"Return a new pasteUpMorph configured as a world (ie project notNil).	projectOrNil is no longer used."	^ self new initForProject: WorldState new! !!PasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 5/26/2000 10:07'!newWorldTesting	| world ex |	ex _ 500@500.	world _ PasteUpMorph newWorldForProject: nil.	world extent: ex; color: Color orange.	world openInWorld.	world viewBox: (0@0 extent: ex).	BouncingAtomsMorph new openInWorld: world."-----	| world window |	world _ PasteUpMorph newWorldForProject: nil.	world extent: 300@300; color: Color orange.	world viewBox: (0@0 extent: 300@300).	window _ (SystemWindow labelled: 'the new world') model: world.	window color: Color orange.	window addMorph: world frame: (0@0 extent: 1.0@1.0).	window openInWorld.---"! !!PasteUpMorph class methodsFor: 'project' stamp: 'RAA 5/25/2000 15:26'!disableDeferredUpdates	^DisableDeferredUpdates ifNil: [DisableDeferredUpdates _ false]! !!PasteUpMorph class methodsFor: 'project' stamp: 'RAA 6/6/2000 17:35'!startUp		Display restoreMorphicDisplay.! !!PianoRollNoteMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 09:03'!invokeNoteMenu: evt	"Invoke the note's edit menu."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addList:		#(('grid to next quarter'		gridToNextQuarter)		('grid to prev quarter'		gridToPrevQuarter)).	menu popUpEvent: evt in: self world.! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 09:03'!invokeScoreMenu: evt	"Invoke the score's edit menu."	| menu subMenu |	menu _ MenuMorph new defaultTarget: self.	menu addList:		#(('cut'		cutSelection)		('copy'		copySelection)		('paste'		insertSelection)		('paste...'	insertTransposed)).	menu addLine.	menu addList:		#(('legato'		selectionBeLegato)		('staccato'		selectionBeStaccato)		('normal'		selectionBeNormal)).	menu addLine.	menu addList:		#(('expand time'		expandTime)		('contract time'		contractTime)).	menu addLine.	subMenu _ MenuMorph new defaultTarget: self.		(2 to: 12) do: [:i | subMenu add: i printString selector: #beatsPerMeasure: argument: i].		menu add: 'time   ', beatsPerMeasure printString subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.		#(2 4 8) do: [:i | subMenu add: i printString selector: #notePerBeat: argument: i].		menu add: 'sig     ', notePerBeat printString subMenu: subMenu.	menu addLine.	showMeasureLines		ifTrue: [menu add: 'hide measure lines' action: #measureLinesOnOff]		ifFalse: [menu add: 'show measure lines' action: #measureLinesOnOff].	showBeatLines		ifTrue: [menu add: 'hide beat lines' action: #beatLinesOnOff]		ifFalse: [menu add: 'show beat lines' action: #beatLinesOnOff].	menu addLine.	menu add: 'add keyboard' action: #addKeyboard.	menu popUpEvent: evt in: self world.! !!Player methodsFor: 'scripts-kernel' stamp: 'RAA 6/12/2000 09:14'!slotInfoButtonHitFor: aSlotName inViewer: aViewer	"The user made a gesture asking for info/menu relating"	| aMenu slotSym aType |	slotSym _ aSlotName asSymbol.	aType _ self typeForSlot: aSlotName asSymbol.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'simple watcher' selector: #tearOffWatcherFor: argument: slotSym.	aType == #number "later others" ifTrue:		[aMenu add: 'fancier watcher' selector: #tearOffFancyWatcherFor: argument: slotSym].	(self slotInfo includesKey: slotSym)		ifTrue:  "User slot"			[aMenu add: 'change data type' selector: #chooseSlotTypeFor: argument: slotSym.			aType == #number ifTrue:				[aMenu add: 'decimal places...' selector: #setPrecisionFor: argument: slotSym].			aMenu add: 'remove "', aSlotName, '"' selector: #removeSlotNamed: argument: slotSym.			aMenu add: 'rename  "', aSlotName, '"' selector: #renameSlot: argument: slotSym].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: (aSlotName asString, ' (', aType, ')').	aMenu popUpForHand: aViewer primaryHand in: aViewer world! !!PluggableButtonMorph methodsFor: 'private' stamp: 'RAA 6/12/2000 09:04'!invokeMenu: evt	"Invoke my menu in response to the given event."	| menu |	menu _ self getMenu: evt shiftPressed.	menu ifNotNil: [menu popUpEvent: evt in: self world]! !!PluggableFileList methodsFor: 'StandardFileMenu' stamp: 'RAA 5/25/2000 09:29'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor,	so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil at: Display lastKnownCursorPoint! !!PolygonMorphDashed class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 09:21'!animationExample	"PolygonMorphDashed animationExample"	| m numOfAnimationSteps start stop stepVec s delay delayAtAll point animation |	m _ self				vertices: {Display boundingBox origin. Display boundingBox corner}				color: Color transparent				firstBorderWidth: 2				secondBorderWidth: 2				firstBorderColor: Color black				secondBorderColor: Color white				firstBorderStepWidth: 10				secondBorderStepWidth: 10.	m lock.	m openInWorld.	m refreshWorld.	(Delay forSeconds: 1) wait.	numOfAnimationSteps _ 25.	delayAtAll _ 1.	start _ m vertices at: 1.	stop _ m vertices at: 2.	start = stop ifTrue: [^ self].	stepVec _ stop - start / (numOfAnimationSteps + 1).	s _ Array new: numOfAnimationSteps.	1 to: numOfAnimationSteps do: 		[:step | 		point _ start + (step * stepVec).		"avoid problems"		s at: step put: (point = stop				ifTrue: 					[					stop - (1 @ 1)]				ifFalse: [point])].	delay _ Delay forSeconds: delayAtAll / numOfAnimationSteps.	animation _ 			[1 to: s size do: 				[:j | 				"Move to the next point"				m vertices at: 1 put: (s at: j).				"update"				m computeBounds.				"not necessary here since forked"				"	World refreshWorld."				"for fast machines"				delay wait].			m delete].	animation fork! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'RAA 5/25/2000 09:29'!startUpCenteredWithCaption: captionOrNil	"Differs from startUpWithCaption: by appearing with cursor in the menu,	and thus ready to act on mouseUp, without requiring user tweak to confirm"	| cursorPoint |	cursorPoint _ Display lastKnownCursorPoint.	^ self startUpWithCaption: captionOrNil at: cursorPoint - (20@0)! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'RAA 5/25/2000 09:29'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor,	so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil at: Display lastKnownCursorPoint! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'RAA 6/6/2000 17:38'!startUpWithCaption: captionOrNil at: location	"Display the menu, with caption if supplied. Wait for the mouse button to go down,	then track the selection as long as the button is pressed. When the button is released, 	answer the index of the current selection, or zero if the mouse is not released over 	any menu item. Location specifies the desired topLeft of the menu body rectangle."	| maxHeight |	maxHeight _ Display height*3//4.	self frameHeight > maxHeight ifTrue:		[^ self			startUpSegmented: maxHeight			withCaption: captionOrNil			at: location].	Smalltalk isMorphic		ifTrue:			[selection _ Cursor normal showWhile:				[(MVCMenuMorph from: self title: captionOrNil) 					invokeAt: location 					in: (Display morphicWorldAt: location)].			^ selection].	frame ifNil: [self computeForm].	Cursor normal showWhile:		[self			displayAt: location			withCaption: captionOrNil			during: [self controlActivity]].	^ selection! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'RAA 5/25/2000 09:13'!noteThatFlag: prefSymbol justChangedTo: aBoolean	"Provides a hook so that a user's toggling of a preference might precipitate some immediate action"	| keep |	prefSymbol == #useGlobalFlaps ifTrue:		[aBoolean			ifFalse:		"Turning off use of flaps"				[keep _ self confirm:'Do you want to preserve the existingglobal flaps for future use?'.				Utilities globalFlapTabsIfAny do:					[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: keep.					aFlapTab isInWorld ifTrue: [self error: 'Flap problem']].				keep ifFalse: [Utilities clobberFlapTabList]]			ifTrue:		"Turning on use of flaps"				[Smalltalk isMorphic ifTrue:					[self currentWorld addGlobalFlaps]]].	prefSymbol == #roundedWindowCorners ifTrue: [Display repaintMorphicDisplay].	prefSymbol == #optionalButtons ifTrue:		[Utilities replacePartSatisfying: [:el |  (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isKindOf: FileList]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  FileList openAsMorph applyModelExtent].	(prefSymbol == #optionalButtons  or: [prefSymbol == #annotationPanes]) ifTrue:		[Utilities replaceBrowserInToolsFlap].	(prefSymbol == #smartUpdating) ifTrue:		[SystemWindow allSubInstancesDo:			[:aWindow | aWindow amendSteppingStatus]]! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'RAA 6/6/2000 18:46'!defaultAction	| delta savedArea captionText textFrame barFrame outerFrame result range lastW w |	barFrame _ aPoint - (75@10) corner: aPoint + (75@10).	captionText _ DisplayText text: progressTitle asText allBold.	captionText		foregroundColor: Color black		backgroundColor: Color white.	textFrame _ captionText boundingBox insetBy: -4.	textFrame _ textFrame align: textFrame bottomCenter					with: barFrame topCenter + (0@2).	outerFrame _ barFrame merge: textFrame.	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	barFrame _ barFrame translateBy: delta.	textFrame _ textFrame translateBy: delta.	outerFrame _ outerFrame translateBy: delta.	savedArea _ Form fromDisplay: outerFrame.	Display fillBlack: barFrame; fillWhite: (barFrame insetBy: 2).	Display fillBlack: textFrame; fillWhite: (textFrame insetBy: 2).	captionText displayOn: Display at: textFrame topLeft + (4@4).	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"	lastW _ 0.	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"		[:barVal |		w _ ((barFrame width-4) asFloat * ((barVal-minVal) asFloat / range min: 1.0)) asInteger.		w ~= lastW ifTrue: [			Display fillGray: (barFrame topLeft + (2@2) extent: w@16).			lastW _ w]].	savedArea displayOn: Display at: outerFrame topLeft.	self resume: result! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'RAA 5/15/2000 11:43'!display: argString at: argPoint from: argMinVal to: argMaxVal during: argWorkBlock	progressTitle _ argString.	aPoint _ argPoint.	minVal _ argMinVal.	maxVal _ argMaxVal.	workBlock _ argWorkBlock.	^self signal! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'RAA 5/15/2000 12:39'!isResumable		^true! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'RAA 5/15/2000 12:40'!sendNotificationsTo: aNewBlock	self resume: (		workBlock value: [ :barVal |			aNewBlock value: minVal value: maxVal value: barVal		]	)! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'RAA 5/15/2000 15:46'!testInnermost	"test the progress code WITHOUT special handling"	^'Now here''s some Real Progress'		displayProgressAt: Sensor cursorPoint		from: 0 		to: 10		during: [ :bar |			1 to: 10 do: [ :x | 				bar value: x. (Delay forMilliseconds: 500) wait.				x = 5 ifTrue: [1/0].	"just to make life interesting"			].			'done'		].! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'RAA 5/15/2000 12:42'!testWith	"test progress code WITH special handling of progress notifications"	^[ self testWithAdditionalInfo ] 		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				Transcript show: min printString,'  ',max printString,'  ',curr printString; cr			].		].! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'RAA 5/15/2000 12:04'!testWithAdditionalInfo	^{'starting'. self testWithout. 'really!!'}! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'RAA 5/15/2000 15:45'!testWithout	"test the progress code WITHOUT special handling"	^[self testInnermost]		on: ZeroDivide		do: [ :ex | ex resume]! !!ProgressInitiationException class methodsFor: 'signalling' stamp: 'RAA 5/15/2000 11:44'!display: aString at: aPoint from: minVal to: maxVal during: workBlock	^self new		initialContext: thisContext sender;		display: aString at: aPoint from: minVal to: maxVal during: workBlock! !!Project methodsFor: 'accessing' stamp: 'RAA 6/3/2000 10:23'!isCurrentProject	^self == CurrentProject! !!Project methodsFor: 'menu messages' stamp: 'RAA 6/6/2000 17:39'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg |	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [CurrentProject makeThumbnail].	(revertFlag | saveForRevert | forceRevert) ifFalse: [		(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [			self storeToMakeRoom]].	Smalltalk isMorphic ifTrue: [Display bestGuessOfCurrentWorld triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag		ifTrue: [nextProject _ CurrentProject]		ifFalse: [previousProject _ CurrentProject].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ Display pauseMorphicEventRecorder].	world isMorph		ifTrue:			[Display changeMorphicWorldTo: world.  "Signifies Morphic"			world install.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[Display changeMorphicWorldTo: nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph		ifTrue:			[self finalEnterActions.			Project spawnNewProcessAndTerminateOld: true]		ifFalse:			[showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController]! !!Project methodsFor: 'menu messages' stamp: 'RAA 6/11/2000 15:04'!enterAsActiveSubprojectWithin: enclosingWorld	"Install my ChangeSet, Transcript, and scheduled views as current globals. 	If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	"Experimental mods for initial multi-project work:		1. assume in morphic (this eliminated need for <showZoom>)		2. assume <saveForRevert> is false (usual case) - removed <old>		3. assume <revertFlag> is false		4. assume <revertWithoutAsking> is false - <forceRevert> now auto false <seg> n.u.		5. no zooming		6. assume <projectsSentToDisk> false - could be dangerous here		7. assume no isolation problems (isolationHead ==)		8. no closing scripts	"	self isCurrentProject ifTrue: [^ self].	guards ifNotNil: [		guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]	].		"CurrentProject makeThumbnail."		"--> Display bestGuessOfCurrentWorld triggerClosingScripts."	CurrentProject displayDepth: Display depth.	displayDepth == nil ifTrue: [displayDepth _ Display depth].		"Display newDepthNoRestore: displayDepth."		"(world hasProperty: #letTheMusicPlay)			ifTrue: [world removeProperty: #letTheMusicPlay]			ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 						playerClass allSubInstancesDo: [:player | player pause]]]."		"returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject]."		"CurrentProject saveState."		"CurrentProject _ self."		"Smalltalk newChanges: changeSet."		"TranscriptStream newTranscript: transcript."		"Sensor flushKeyboard."		"recorderOrNil _ Display pauseMorphicEventRecorder."		"Display changeMorphicWorldTo: world."  "Signifies Morphic"	world 		installAsActiveSubprojectIn: enclosingWorld 		titled: self name.		"recorderOrNil ifNotNil: [recorderOrNil resumeIn: world]."	world triggerOpeningScripts.	self removeParameter: #exportState.		"self spawnNewProcessAndTerminateOld: true"! !!Project methodsFor: 'menu messages' stamp: 'RAA 6/3/2000 18:20'!enterForEmergencyRecovery	"This version of enter invokes an absolute minimum of mechanism.	An unrecoverable error has been detected in an isolated project.	It is assumed that the old changeSet has already been revoked.	No new process gets spawned here.  This will happen in the debugger."	self isCurrentProject ifTrue: [^ self].	CurrentProject saveState.	CurrentProject _ self.	Display newDepthNoRestore: displayDepth.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Display pauseMorphicEventRecorder.	world isMorph		ifTrue:			["Entering a Morphic project"			Display changeMorphicWorldTo: world.			world install.			world triggerOpeningScripts]		ifFalse:			["Entering an MVC project"			Display changeMorphicWorldTo: nil.			Smalltalk at: #ScheduledControllers put: world.			ScheduledControllers restore].	UIProcess _ Processor activeProcess.! !!Project methodsFor: 'menu messages' stamp: 'RAA 5/18/2000 11:47'!finalEnterActions	| navigator |	"this will probably become conditional on swiki-ness of this project or on preferences"	(world findA: ProjectNavigationMorph) ifNil: [		navigator _ ProjectNavigationMorph new openInWorld.		navigator bottomLeft: world bottomLeft.		"navigator setToAdhereToEdge: #bottomLeft."	].! !!Project methodsFor: 'menu messages' stamp: 'RAA 6/3/2000 18:23'!saveState	"Save the current state in me prior to leaving this project"	changeSet _ Smalltalk changes.	Smalltalk isMorphic		ifTrue:			[world _ Display bestGuessOfCurrentWorld.			world sleep]		ifFalse:			[world _ ScheduledControllers.			ScheduledControllers unCacheWindows].	transcript _ Transcript.	activeProcess _ nil.		"we will be doing away with this, but for now just clear it out"! !!Project methodsFor: 'release' stamp: 'RAA 6/3/2000 09:56'!okToChange	| ok hasSubProjects itsName is list |	hasSubProjects _ world isMorph		ifTrue: [(world submorphs select:						[:m | (m isKindOf: SystemWindow)								and: [m model isKindOf: Project]]) size > 0]		ifFalse: [(world controllerWhoseModelSatisfies:						[:m | m isKindOf: Project]) notNil].	hasSubProjects ifTrue:		[PopUpMenu notify: 'The project ', self name printString, 'contains sub-projects.  You must remove theseexplicitly before removing their parent.'.		^ false].	ok _ world isMorph not and: [world scheduledControllers size <= 1].	ok ifFalse: [self isMorphic ifTrue: [		self parent == CurrentProject 			ifFalse: [^true]]].  "view from elsewhere.  just delete it."	ok _ (self confirm:'Really delete the project', self name printString, 'and all its windows?').			ok ifFalse: [^ false].	"about to delete this project; clear previous links to it from other Projects:"	ImageSegment allSubInstancesDo: [:seg |		seg ifOutPointer: self thenAllObjectsDo: [:obj |			(obj isKindOf: ProjectViewMorph) ifTrue: [				obj deletingProject: self.  obj abandon].			obj class == Project ifTrue: [obj deletingProject: self]]].	Project allProjects do: [:p | p deletingProject: self].	"ones that are in"	ProjectViewMorph allSubInstancesDo: [:p | 		p deletingProject: self.		p project == self ifTrue: [p abandon]].	world isMorph 		ifTrue: [world submorphs do:   "special release for wonderlands"						[:m | (m isKindOf: WonderlandCameraMorph)								and: [m getWonderland release]].			"Remove Player classes and metaclasses owned by project"			is _ ImageSegment new arrayOfRoots: (Array with: self).			(list _ is rootsIncludingPlayers) ifNotNil: [				(list copyWithout: self) do: [:playerCls | 					playerCls isMeta ifFalse: [						playerCls removeFromSystemUnlogged]]]].	(changeSet isEmpty and: [(changeSet projectsBelongedTo copyWithout: self) isEmpty])		ifTrue:			[itsName _ changeSet name.			ChangeSorter removeChangeSet: changeSet.			Transcript cr; show: 'project change set ', itsName, ' deleted.'].	^ true! !!Project methodsFor: 'release' stamp: 'RAA 6/7/2000 09:24'!release	self flag: #bob.	"this can be trouble if Projects are reused before garbage collection"	world == nil ifFalse:		[world release.		world _ nil].	^ super release! !!Project methodsFor: 'active process' stamp: 'RAA 6/3/2000 18:24'!activeProcess	self flag: #bob.		"fallback during transition to UIProcess"	^ activeProcess! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/3/2000 10:25'!couldBeSwappedOut	self flag: #bob.		"need a better test in multi-project world"	^self isCurrentProject not! !!Project methodsFor: 'file in/out' stamp: 'RAA 5/25/2000 09:51'!exportSegmentWithCatagories: catList classes: classList	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."| is str ans revertSeg roots holder |"world == World ifTrue: [^ false]."	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.Display checkCurrentHandForObjectToPaste.world fullReleaseCachedState. world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages.holder _ Project allInstances.	"force them in to outPointers, where DiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ OrderedCollection new.roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).catList do: [:sysCat | 	(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |		roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].is _ ImageSegment new copyFromRootsForExport: roots asArray.	"world, and all Players"is state = #tooBig ifTrue: [^ false].str _ ''.is segment size < 3000 ifTrue: [	str _ 'Segment is only ', is segment size printString, ' long.'].(is outPointers detect: [:out | out isMorph] ifNone: [nil]) ifNotNil: [	str _ str, '\Morphs are pointed at from the outside.' withCRs].(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		^ false].	ans = 3 ifTrue: [self halt: 'Segment not written']].is writeForExportWithSources: self name, '.pr'.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.^ true! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/3/2000 09:33'!fromMyServerLoad: otherProjectName	| servers pair pr pvm proj projViewer |	"If a newer version of me is on the server, load it."	(pr _ Project named: otherProjectName) ifNotNil: ["it appeared"		^ pr enter].	(servers _ self serverList) isEmpty 		ifTrue: [^ self inform: 			'Current project does not know a server either.'].	pair _ self class mostRecent: otherProjectName onServer: servers first.	pair first ifNil: [		pvm _ ProjectViewMorph newMorphicProjectOn: nil.		pvm _ pvm findA: ProjectViewMorph.		(proj _ pvm project) changeSet name: otherProjectName.		projViewer _ self findProjectView: otherProjectName.		CurrentProjectRefactoring currentBeParentTo: proj.		(projViewer owner isKindOf: SystemWindow) ifTrue: [				projViewer owner model: proj].		^ projViewer project: proj].	self installRemoteNamed: pair first from: servers first named: otherProjectName.! !!Project methodsFor: 'file in/out' stamp: 'RAA 5/18/2000 18:18'!hasBadNameForStoring	| badChars |	"will the name of this project cause problems when stored on an arbitrary file system?"	badChars _ #( $: $< $> $| $/ $\ $? $* $") asSet.	^self name size > 24 or: [self name anySatisfy: [ :each | badChars includes: each]]! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/6/2000 18:59'!installRemoteFrom: strm named: otherProjectName	| projViewer is proj |	"Find the current ProjectViewMorph, fetch the project, install in ProjectViewMorph without changing size, and jump into new project."	ProgressNotification signal: '2 streamSize ',strm size printString.	projViewer _ self findProjectView: otherProjectName.	projViewer ifNil: [		(SelectionMenu confirm: 'No old thumbnail found. Debug?') ifTrue: [self halt].		ProjectViewMorph openFromFile: strm.		"Later check rest of servers if fails.  Still have list here"		^self	].	is _ strm asUnZippedStream.	ProgressNotification  signal: '3 unzipped'.	is _ is fileInObjectAndCode.	ProgressNotification  signal: '4 filedIn'.	(is isKindOf: ImageSegment) ifTrue: [		proj _ is arrayOfRoots detect: [:mm | mm class == Project] 					ifNone: [nil].		proj ifNotNil: [			proj versionFrom: strm.			(projViewer project isKindOf: DiskProxy) ifFalse: [				projViewer project changeSet name: ChangeSet defaultName].			proj changeSet name: otherProjectName.			CurrentProjectRefactoring currentBeParentTo: proj.			(projViewer owner isKindOf: SystemWindow) ifTrue: [				projViewer owner model: proj].			projViewer project: proj.			"stop background drawing NOW"			ProgressNotification  signal: '9999 about to enter project'.				^ ProjectEntryNotification signal: proj		]	].	ProjectViewMorph openFromFile: strm.	"Later check rest of servers if fails.  Still have list here"! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/2/2000 09:58'!installRemoteNamed: remoteFileName from: aServer named: otherProjectName	ProgressNotification signal: '1 found most recent'.	self 		installRemoteFrom: (aServer oldFileNamed: remoteFileName) 		named: otherProjectName.! !!Project methodsFor: 'file in/out' stamp: 'RAA 5/17/2000 18:52'!loadFromServer		^self loadFromServer: false! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/3/2000 10:26'!loadFromServer: newerAutomatically	| servers pair resp |	"If a newer version of me is on the server, load it."	self isCurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #loadFromServer].	(servers _ self serverList) isEmpty 		ifTrue: [^ self inform: 'This project thinks it has never been on a server'].	pair _ self class mostRecent: self name onServer: servers first.	pair first ifNil: [^ self inform: 'can''t find file on server for ', self name].	(Base64MimeConverter decodeInteger: version unescapePercents) > pair second ifTrue: [		^ self inform: 'That server has an older version of the project.'].	version = (pair first findTokens: '|.') second ifTrue: [		resp _ (PopUpMenu labels: 'Reload anyway\Cancel' withCRs) startUpWithCaption: 					'The only changes are the ones you made here.'.		resp ~= 1 ifTrue: [^ nil]	] ifFalse: [		newerAutomatically ifFalse: [			resp _ (PopUpMenu labels: 'Load it\Cancel' withCRs) startUpWithCaption: 						'A newer version exists on the server.'.			resp ~= 1 ifTrue: [^ nil]		].	].	"Find parent project, go there, zap old thumbnail"	parentProject installRemoteNamed: pair first from: servers first named: self name.! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/3/2000 10:27'!storeOnServer	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	self hasBadNameForStoring ifTrue: [		^self inform: 'The name of this project may cause problems when stored in a file.Please fix it and try again.'	].	self isCurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #storeOnServer].	self storeOnServerWithProgressInfo.! !!Project methodsFor: 'file in/out' stamp: 'RAA 5/23/2000 12:55'!storeOnServerInnards	| servers pair newVersion resp newName local folder |	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	"write locally"	self exportSegment.	(FileStream oldFileNamed: self name, '.pr') compressFile.	"Find out what version"	(servers _ self serverList) isEmpty 		ifTrue: [folder _ PluggableFileList getFolderDialog openLabel:					 'Select a folder on a server:'.			folder ifNil: [^ self].			servers _ Array with: folder.			urlList _ Array with: folder realUrl, '/'.			pair _ Array with: nil with: -1]		ifFalse: [pair _ self class mostRecent: self name onServer: servers first].	(newVersion _ self newVersion: pair) ifNil: [^ self].	newName _ self name, '|', newVersion, '.pr'.	local _ FileStream oldFileNamed: self name, '.pr.gz'.	resp _ servers first putFile: local named: newName retry: false.	resp ifFalse: [self inform: 'the primary server of this project seems to be down'.  ^ self].	version _ newVersion.	"committed"	"Later, store with same name on secondary servers.  Still can be race conditions.  All machines will go through the server list in the same order."	"2 to: servers size do: [:aServer | aServer putFile: local named: newName]."	"Rename disk file to be the final name"	local reset.	local localName = newName 		ifFalse: [FileDirectory default rename: local localName toBe: newName]		ifTrue: [local close].! !!Project methodsFor: 'file in/out' stamp: 'RAA 5/23/2000 12:56'!storeOnServerWithProgressInfo	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	ComplexProgressIndicator new 		targetMorph: nil;		historyCategory: 'project storing';		withProgressDo: [self storeOnServerInnards]	! !!Project methodsFor: 'file in/out' stamp: 'RAA 5/25/2000 10:01'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg.  *** Caller must be holding (Project alInstances) to keep subprojects from going out. ***"| is sizeHint |(Display isCurrentMorphicWorld: world) ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ false].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.Display checkCurrentHandForObjectToPaste.world releaseSqueakPages.sizeHint _ self projectParameters at: #segmentSize ifAbsent: [0].is _ ImageSegment new copyFromRootsLocalFileFor: 			(Array with: world presenter with: world)	"world, and all Players"		 sizeHint: sizeHint.is state = #tooBig ifTrue: [^ false].is segment size < 2000 ifTrue: ["debugging" 	Transcript show: self name, ' only ', is segment size printString, 		'bytes in Segment.'; cr].self projectParameters at: #segmentSize put: is segment size.is extract; writeToFile: self name.^ true! !!Project methodsFor: 'file in/out' stamp: 'RAA 5/25/2000 10:28'!storeSegmentNoFile	"For testing.  Make an ImageSegment.  Keep the outPointers in memory.  Also useful if you want to enumerate the objects in the segment afterwards (allObjectsDo:)"| is str |(Display isCurrentMorphicWorld: world) ifTrue: [^ self].		" inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ self].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ self].	"Only Morphic projects for now"world ifNil: [^ self].  world presenter ifNil: [^ self]."Do this on project enter"Display bestGuessOfCurrentWorld flapTabs do: [:ft | ft referent adaptToWorld: Display bestGuessOfCurrentWorld].	"Hack to keep the Menu flap from pointing at my project""Preferences setPreference: #useGlobalFlaps toValue: false.""Utilities globalFlapTabsIfAny do:	[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: false].Utilities clobberFlapTabList.	""project world deleteAllFlapArtifacts.""self currentWorld deleteAllFlapArtifacts.	"Utilities emptyScrapsBook.Display checkCurrentHandForObjectToPaste2.is _ ImageSegment new copyFromRootsLocalFileFor: 		(Array with: world presenter with: world)	"world, and all Players"	sizeHint: 0.is segment size < 800 ifTrue: ["debugging" 	Transcript show: self name, ' did not get enough objects'; cr.  ^ self beep].false ifTrue: [	str _ String streamContents: [:strm |		strm nextPutAll: 'Only a tiny part of the project got into the segment'.		strm nextPutAll: '\These are pointed to from the outside:' withCRs.		is outPointers do: [:out |			(out class == Presenter) | (out class == ScriptEditorMorph) ifTrue: [				strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]].			(is arrayOfRoots includes: out class) ifTrue: [strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]]]].	self inform: str.	^ is inspect].is extract."is instVarAt: 2 put: is segment clone."		"different memory"! !!Project methodsFor: 'isolation layers' stamp: 'RAA 6/3/2000 10:24'!beIsolated	"Establish an isolation layer at this project.	This requires clearing the current changeSet or installing a new one."	isolatedHead ifTrue: [^ self error: 'Already isolated'].	self isCurrentProject ifFalse:		[^ self inform: 'Must be in this project to isolate it'.].	changeSet isEmpty ifFalse: [changeSet _ ChangeSorter newChangeSet].	changeSet beIsolationSetFor: self.	isolatedHead _ true.	inForce _ true.	environment _ Environment new setName: self name outerEnvt: Smalltalk.! !!Project methodsFor: 'OBSOLETE' stamp: 'RAA 6/3/2000 19:01'!obsolete	self flag: #obsolete.	"instance variable 		exitFlag is no longer used		activeProcess is on the way out	"! !!Project methodsFor: 'SuperSwiki' stamp: 'RAA 5/19/2000 19:11'!tellAFriend"Project current tellAFriend"	self url isEmpty ifTrue: [		^self inform: 'Since this project has not been saved yet,I cannot tell someone where it is.'	].	FancyCelesteComposition new		celeste: nil 		to: 'RECIPIENT.GOESHERE' 		subject: 'A Squeak project link you might like'		initialText: 'This is a link to a Squeak project: '		theLinkToInclude: '<A HREF="sqPr://',self url,'">',self name,'</A>';		open.! !!Project class methodsFor: 'class initialization' stamp: 'RAA 6/3/2000 18:50'!initialize	"This is the Top Project."   	CurrentProject ifNil:		[CurrentProject _ super new initialProject.		Project spawnNewProcessAndTerminateOld: true].	"Project initialize"! !!Project class methodsFor: 'instance creation' stamp: 'RAA 6/3/2000 18:26'!uiProcess	self flag: #bob.		"ultimately we can get rid of the #ifNil: business"	^ UIProcess ifNil: [UIProcess _ CurrentProject activeProcess]! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 10:24'!buildJumpToMenu: menu	"Make the supplied menu offer a list of potential projects, consisting of:		*	The previous-project chain		*	The next project, if any		*	The parent project, if any		*	All projects, alphabetically"	| prev listed i next  toAdd |	listed _ OrderedCollection with: CurrentProject.	i _ 0.	prev _ CurrentProject previousProject.	[(prev ~~ nil and: [(listed includes: prev) not])] whileTrue:		[i _ i + 1.		listed add: prev.		self addItem: prev name , ' (back ' , i printString , ')'					toMenu: menu selection: ('%back' , i printString) project: prev.				prev _ prev previousProject].	(((next _ CurrentProject nextProject) ~~ nil) and: [(listed includes: next) not]) ifTrue:		[self addItem: (next name, ' (forward 1)') toMenu: menu selection: next name project: next]. 	(i > 0 or: [next ~~ nil]) ifTrue: [menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: 		[self addItem: CurrentProject parent name , ' (parent)' toMenu: menu selection: #parent project: CurrentProject parent.		menu addLine].	"Finally all the projects, in alphabetical order"	Project allNamesAndProjects do:		[:aPair | 			toAdd _ aPair last isCurrentProject				ifTrue:					[aPair first, ' (current)']				ifFalse:					[aPair first].			self addItem: toAdd toMenu: menu selection: aPair first project: aPair last].	^ menu! !!Project class methodsFor: 'utilities' stamp: 'RAA 5/23/2000 10:26'!canWeLoadAProjectNow	Smalltalk verifyMorphicAvailability ifFalse: [^ false].	Smalltalk isMorphic ifFalse: [		self inform: 'Later, allow jumping from MVC to Morphic Projects.'.		^false	].	^true! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 09:52'!enter: aString	"Enter the project with the given name"	^ ((self named: aString) ifNil: [^ CurrentProject]) enter! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/7/2000 12:03'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	| suspendingList projectProcess |	Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].	projectProcess _ self uiProcess.	"we still need the accessor for a while"	(suspendingList _ projectProcess suspendingList) == nil		ifTrue: [projectProcess == Processor activeProcess					ifTrue: [projectProcess suspend]]		ifFalse: [suspendingList remove: projectProcess.				projectProcess offList].	Debugger openInterrupt: labelString onProcess: projectProcess! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 19:00'!maybeForkInterrupt	Preferences cmdDotEnabled ifFalse: [^self].	Smalltalk isMorphic		ifTrue: [[self interruptName: 'User Interrupt'] fork]		ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 09:56'!ofWorld: aPasteUpMorph	"Find the project of a world."	"Usually it is the current project"	CurrentProject world == aPasteUpMorph ifTrue: [^ CurrentProject].	"Inefficient enumeration if it is not..."	^ self allSubInstances		detect:		[:pr | pr world isInMemory 			ifTrue: [pr world == aPasteUpMorph]			ifFalse: [false]]		ifNone: [nil]! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 18:28'!resumeProcess: aProcess	"Adopt aProcess as the project process -- probably because of proceeding from a debugger"	UIProcess _ aProcess.	UIProcess resume! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 18:49'!spawnNewProcess	UIProcess _ [		[World doOneCycle.  Processor yield.  false] whileFalse: [].	] newProcess priority: Processor userSchedulingPriority.	UIProcess resume! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 18:49'!spawnNewProcessAndTerminateOld: terminate	self spawnNewProcess.	terminate		ifTrue: [Processor terminateActive]		ifFalse: [Processor activeProcess suspend]! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 19:07'!spawnNewProcessIfThisIsUI: suspendedProcess	self uiProcess == suspendedProcess ifTrue: [ self spawnNewProcess ] ! !!Project class methodsFor: 'utilities' stamp: 'RAA 5/23/2000 11:07'!thumbnailFromUrl: urlString	"Load the project, and make a thumbnail to it in the current project.Project thumbnailFromUrl: 'http://www.squeak.org/Squeak2.0/2.7segments/SqueakEasy.extSeg'."	Project canWeLoadAProjectNow ifFalse: [^ self].	ProjectViewMorph openFromStreamBlock: [		(ServerFile new fullPath: urlString) asStream	].! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 6/3/2000 09:53'!fromUrl: urlString	| serverFile pair pvm projName proj projViewer num triple |	"Load the project, and make a thumbnail to it in the current project.  Replace the old one if necessary.Project fromUrl: 'http://www.squeak.org/Squeak2.0/2.7segments/Squeak_Easy.pr.gz'."	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	Smalltalk isMorphic ifFalse: [^ self inform: 			'Later, allow jumping from MVC to Morphic Projects.'].	serverFile _ ServerFile new fullPath: urlString.	(proj _ Project named: (projName _ (serverFile fileName unescapePercents findTokens: '|.') first))		ifNotNil: ["it appeared" ^ proj enter].	serverFile type == #http		ifTrue: [num _ (triple _ serverFile fileName findTokens: '|.') size >= 3 				ifTrue: [Base64MimeConverter decodeInteger: triple second unescapePercents]				ifFalse: [0].			pair _ Array with: serverFile fileName with: num]		ifFalse: [pair _ self mostRecent: serverFile localName onServer: serverFile].	"Pair first is name exactly as it is on the server"	pair first ifNil: ["If none, open a blank project"		pvm _ ProjectViewMorph newMorphicProjectOn: nil.		pvm _ pvm findA: ProjectViewMorph.		(proj _ pvm project) changeSet name: projName.		projViewer _ CurrentProject findProjectView: projName.		CurrentProjectRefactoring currentBeParentTo: proj.		(projViewer owner isKindOf: SystemWindow) ifTrue: [				projViewer owner model: proj].		^ projViewer project: proj].	CurrentProject installRemoteNamed: pair first from: serverFile named: projName.! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 5/20/2000 15:42'!namedUrl: urlString	| projName |	"Return project if in, else nil"	"Ted's fix for unreachable projects"	projName _ (urlString findTokens: '/') last.	projName _ (projName unescapePercents findTokens: '.|') first.	^ Project named: projName! !!ProjectEntryNotification methodsFor: 'as yet unclassified' stamp: 'RAA 6/6/2000 18:55'!defaultAction	self resume: projectToEnter enter! !!ProjectEntryNotification methodsFor: 'as yet unclassified' stamp: 'RAA 6/6/2000 19:02'!projectToEnter	^projectToEnter! !!ProjectEntryNotification methodsFor: 'as yet unclassified' stamp: 'RAA 6/6/2000 18:53'!projectToEnter: aProject	projectToEnter _ aProject! !!ProjectEntryNotification class methodsFor: 'as yet unclassified' stamp: 'RAA 6/6/2000 18:56'!signal: aProject	| ex |	ex := self new.	ex initialContext: thisContext sender.	ex projectToEnter: aProject.	^ex signal: 'Entering ',aProject printString! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/17/2000 18:19'!addButton: aString for: aSymbol	| b a |	b _ SimpleButtonMorph new 		target: self;		borderColor: #raised;		color: color darker;		label: aString;		actionSelector: aSymbol.	a _ AlignmentMorph newColumn.	a color: color; borderWidth: 0; inset: 2.	a hResizing: #shrinkWrap; vResizing: #shrinkWrap.	a addMorphBack: b.	self addMorphBack: a.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/18/2000 14:45'!addButtons	self 		addButton: '< Prev' for: #previousProject;		addButton: 'Next >' for: #nextProject;		addButton: '^ Publish' for: #publishProject;		addButton: 'Newer?' for: #getNewerVersionIfAvailable;		addButton: 'Tell!!' for: #tellAFriend.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/17/2000 18:57'!getNewerVersionIfAvailable	(self world ifNil: [^1 beep]) project loadFromServer: true.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/18/2000 11:43'!initialize	super initialize.	self useRoundedCorners.	inset _ 6.	color _ Color orange.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	self addButtons.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/17/2000 18:57'!nextProject	Project advanceToNextProject.	1 beep.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:45'!previousProject	Project returnToPreviousProject.	CurrentProjectRefactoring exitCurrentProject.	"go to parent if no previous"	1 beep.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/17/2000 18:23'!publishProject	(self world ifNil: [^1 beep]) project storeOnServer.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/18/2000 11:50'!step	| delta |	owner == self world ifFalse: [^self].	(owner submorphs indexOf: self) = 1 ifFalse: [		owner addMorphFront: self	].	delta _ self bounds amountToTranslateWithin: self worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta].! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/18/2000 11:43'!stepTime	^1000! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 10:54'!tellAFriend	self world project tellAFriend! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/18/2000 11:43'!wantsSteps	^true! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'RAA 6/6/2000 17:40'!drawOn: aCanvas	project ifNil: [^ super drawOn: aCanvas].	(project isInMemory not or: [project class == DiskProxy]) ifTrue: [		super drawOn: aCanvas.		^self "drawTranslucentRevealOn: aCanvas"	].	project thumbnail ifNil: [		image fill: (0@0 extent: image extent) rule: Form over 			fillColor: project defaultBackgroundColor.		^ super drawOn: aCanvas].	project thumbnail ~~ lastProjectThumbnail ifTrue:			["scale thumbnail to fit my bounds"			(WarpBlt current toForm: image)				sourceForm: project thumbnail;				cellSize: 2;  "installs a colormap"				combinationRule: Form over;				copyQuad: (project thumbnail boundingBox) innerCorners				toRect: (0@0 extent: image extent).			lastProjectThumbnail _ project thumbnail.			image borderWidth: 1].	super drawOn: aCanvas.! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 5/17/2000 11:39'!checkForNewerVersionAndLoad	self withProgressDo: [		project loadFromServer	] ! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 6/10/2000 10:52'!enter	"Enter my project."	self world == self outermostWorldMorph ifFalse: [^1 beep]. "can't do this at the moment"	project class == DiskProxy ifFalse: [		(project world notNil and: 				[project world outermostWorldMorph == self outermostWorldMorph]) ifTrue: [			^1 beep		"project is open in a window already"		].	].	project class == DiskProxy ifTrue: ["When target is not in yet"		self enterWhenNotPresent.	"will bring it in"		project class == DiskProxy ifTrue: [self error: 'Could not find view']].	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	self showBorderAs: Color gray.	project enter: false revert: false saveForRevert: false.! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 6/6/2000 19:53'!enterAsActiveSubproject	"Enter my project."	project class == DiskProxy ifTrue: ["When target is not in yet"		[self enterWhenNotPresent]	"will bring it in"			on: ProjectEntryNotification			do: [ :ex | 				^ex projectToEnter enterAsActiveSubprojectWithin: self world			].		project class == DiskProxy ifTrue: [self error: 'Could not find view']].	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	self showBorderAs: Color gray.	project enterAsActiveSubprojectWithin: self world.! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 5/17/2000 11:38'!enterWhenNotPresent	self withProgressDo: [		project enter: false revert: false saveForRevert: false.	"will bring it in"	] ! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 6/2/2000 12:27'!mouseDown: evt	self removeProperty: #wasOpenedAsSubproject.	self showBorderAs: Color red.	self world displayWorld.	mouseDownTime _ Time millisecondClockValue! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 6/2/2000 12:28'!mouseMove: evt	| menu selection |	(self containsPoint: evt cursorPoint) ifFalse: [		self showBorderAs: Color blue.		mouseDownTime _ nil.		^self	].	self showBorderAs: Color red.	mouseDownTime ifNil: [		mouseDownTime _ Time millisecondClockValue.		^self	].	((Time millisecondClockValue - mouseDownTime) > 1100) ifFalse: [^self].					(menu _ CustomMenu new)		add: 'enter this project' action: #enter;		add: 'ENTER ACTIVE' action: #enterAsActiveSubproject;		add: 'save (also saves a local copy)' action: #storeOnServer;		add: 'saveAs' action: #store;		add: 'see if server version is more recent' action: #loadFromServer.	selection _ (menu build preSelect: #enter) startUpCenteredWithCaption: ('Project Named','"', project name, '"').	selection = #enter ifTrue: [^ self enter].	selection = #enterAsActiveSubproject ifTrue: [		self setProperty: #wasOpenedAsSubproject toValue: true.		^ self enterAsActiveSubproject	].	selection = #storeOnServer ifTrue: [^ project storeOnServer].	selection = #store ifTrue: [project urlList: nil. ^ project storeOnServer].	selection = #loadFromServer ifTrue: [ ^ self checkForNewerVersionAndLoad].					! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 6/2/2000 12:26'!mouseUp: evt	((self containsPoint: evt cursorPoint) and: 				[(self hasProperty: #wasOpenedAsSubproject) not]) ifTrue:		[^ self enter].	self showBorderAs: Color gray! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 5/23/2000 10:08'!withProgressDo: aBlock	ComplexProgressIndicator new 		targetMorph: self;		historyCategory: 'project loading';		withProgressDo: aBlock! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'RAA 6/6/2000 18:59'!openFromFile: preStream	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world." 	| morphOrList window proj |ProgressNotification signal: '2 streamSize ',preStream size printString.	morphOrList _ preStream asUnZippedStream.ProgressNotification  signal: '3 unzipped'.	morphOrList _ morphOrList fileInObjectAndCode.ProgressNotification  signal: '4 filedIn'.	(morphOrList isKindOf: ImageSegment) ifTrue: [		(morphOrList arrayOfRoots count: [:mm | mm class == Project]) > 1 ifTrue: [			self error: 'which project is main?']. 	"debug"		proj _ morphOrList arrayOfRoots detect: [:mm | mm class == Project] 					ifNone: [nil].		"rename the project if it conflicts?"		proj ifNotNil: [proj versionFrom: preStream.			window _ (SystemWindow labelled: proj name) model: proj.			window				addMorph: (self on: proj)				frame: (0@0 corner: 1.0@1.0).			window openInWorld.			CurrentProjectRefactoring currentBeParentTo: proj.ProgressNotification  signal: '9999 about to enter project'.	"stop background drawing NOW"			^ ProjectEntryNotification signal: proj]].ProgressNotification  signal: '9999 about to enter project'.	"stop background drawing NOW"	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'].	(window _ self newMorphicProjectOn: morphOrList) openInWorld.	window model enter! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'RAA 5/23/2000 11:40'!openFromStreamBlock: aBlock	| fileStream |	ComplexProgressIndicator new 		targetMorph: nil;		historyCategory: 'project loading';		withProgressDo: [			fileStream _ aBlock value.			ProjectViewMorph openFromFile: fileStream.		]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:09'!assignCollapseFrameFor: aSSView 	"Offer up a location along the left edge of the screen for a collapsed SSView. Make sure it doesn't overlap any other collapsed frames."	| grid otherFrames topLeft viewBox collapsedFrame extent newFrame verticalBorderDistance top |	grid _ 8.	verticalBorderDistance _ 8.	Smalltalk isMorphic		ifTrue: 			[otherFrames _ (SystemWindow windowsIn: aSSView world satisfying: [:w | w ~= aSSView])						collect: [:w | w collapsedFrame]						thenSelect: [:rect | rect notNil].			viewBox _ aSSView world viewBox]		ifFalse: 			[otherFrames _ ScheduledControllers scheduledWindowControllers						collect: [:aController | aController view ~= aSSView ifTrue: [aController view collapsedFrame]]						thenSelect: [:rect | rect notNil].			viewBox _ Display boundingBox].	collapsedFrame _ aSSView collapsedFrame.	extent _ collapsedFrame notNil				ifTrue: [collapsedFrame extent]				ifFalse: [Smalltalk isMorphic					ifTrue: [aSSView getRawLabel width + aSSView labelWidgetAllowance @ (aSSView labelHeight + 2)]					ifFalse: [(aSSView labelText extent x + 70) @ aSSView labelHeight							min: aSSView labelDisplayBox extent					]				].	collapsedFrame notNil		ifTrue: [(otherFrames anySatisfy: [:f | collapsedFrame intersects: f])				ifFalse: ["non overlapping"					^ collapsedFrame]].	top _ viewBox top + verticalBorderDistance.	[topLeft _ viewBox left @ top.	newFrame _ topLeft extent: extent.	newFrame bottom <= (viewBox height - verticalBorderDistance)]		whileTrue: 			[(otherFrames anySatisfy: [:w | newFrame intersects: w])				ifFalse: ["no overlap"					^ newFrame].			top _ top + grid].	"If all else fails... (really to many wins here)"	^ 0 @ 0 extent: extent! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:09'!assignCollapsePointFor: aSSView	"Offer up a location along the left edge of the screen for a collapsed SSView.	Make sure it doesn't overlap any other collapsed frames."	| grid otherFrames y free topLeft viewBox |	grid _ 24.  "should be mult of 8, since manual move is gridded by 8"	Smalltalk isMorphic		ifTrue: [otherFrames _ (SystemWindow windowsIn: aSSView world satisfying: [:w | true])					collect: [:w | w collapsedFrame]					thenSelect: [:rect | rect notNil].				viewBox _ aSSView world viewBox]		ifFalse: [otherFrames _ ScheduledControllers scheduledWindowControllers					collect: [:aController | aController view collapsedFrame]					thenSelect: [:rect | rect notNil].				viewBox _ Display boundingBox].	y _ viewBox top.	[(y _ y + grid) <= (viewBox height - grid)]		whileTrue:		[topLeft _ viewBox left@y.		free _ true.		otherFrames do: [:w | free _ free & (topLeft ~= w topLeft)].		free ifTrue: [^ topLeft]].	"If all else fails..."	^ 0 @ 0! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:17'!initialFrameFor: aView	"Find a plausible initial screen area for the supplied view.  See called method."	self error: 'please use #initialFrameFor:world:'! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:18'!initialFrameFor: aView initialExtent: initialExtent	self error: 'please use #initialFrameFor:initialExtent:world:'! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 09:14'!initialFrameFor: aView initialExtent: initialExtent world: aWorld	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen."	| allOrigins screenRight screenBottom putativeOrigin putativeFrame allowedArea staggerOrigin otherFrames |	Preferences reverseWindowStagger ifTrue:		[^ self strictlyStaggeredInitialFrameFor: aView initialExtent: initialExtent world: aWorld].	allowedArea _ self maximumUsableAreaInWorld: aWorld.	screenRight _ allowedArea right.	screenBottom _ allowedArea bottom.	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	allOrigins _ otherFrames collect: [:f | f origin].	(self standardPositionsInWorld: aWorld) do:  "First see if one of the standard positions is free"		[:aPosition | (allOrigins includes: aPosition)			ifFalse:				[^ (aPosition extent: initialExtent) squishedWithin: allowedArea]].	staggerOrigin _ (self standardPositionsInWorld: aWorld) first.  "Fallback: try offsetting from top left"	putativeOrigin _ staggerOrigin.	[putativeOrigin _ putativeOrigin + StaggerOffset.	putativeFrame _ putativeOrigin extent: initialExtent.	(putativeFrame bottom < screenBottom) and:					[putativeFrame right < screenRight]]				whileTrue:					[(allOrigins includes: putativeOrigin)						ifFalse:							[^ (putativeOrigin extent: initialExtent) squishedWithin: allowedArea]].	^ (self scrollBarSetback @ self screenTopSetback extent: initialExtent) squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:13'!initialFrameFor: aView world: aWorld	"Find a plausible initial screen area for the supplied view.  See called method."	^ self initialFrameFor: aView initialExtent: aView initialExtent world: aWorld! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 6/2/2000 11:06'!maximumUsableArea	| allowedArea |	allowedArea _ Display usableArea.	Smalltalk isMorphic ifTrue: [		allowedArea _ allowedArea intersect: Display getCurrentMorphicWorld viewBox	].	^allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:42'!maximumUsableAreaInWorld: aWorldOrNil	| allowedArea |	allowedArea _ Display usableArea.	aWorldOrNil ifNotNil: [allowedArea _ allowedArea intersect: aWorldOrNil viewBox].	^allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:45'!standardPositions		self error: 'please use #standardPositionsInWorld:'! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:43'!standardPositionsInWorld: aWorldOrNil	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  "	| anArea aList  midX midY |	anArea _ self maximumUsableAreaInWorld: aWorldOrNil.	midX _ self scrollBarSetback +   ((anArea width - self scrollBarSetback)  // 2).	midY _ self screenTopSetback + ((anArea height - self screenTopSetback) // 2).	aList _ OrderedCollection with: (self scrollBarSetback @ self screenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ self screenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (self scrollBarSetback @ (midY+self screenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+self screenTopSetback))]].	^ aList! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 09:15'!strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent	self error: 'please use #strictlyStaggeredInitialFrameFor:initialExtent:world:'! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 09:24'!strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	"	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea _(self maximumUsableAreaInWorld: aWorld) insetBy: (		self scrollBarSetback @ self screenTopSetback extent: 0@0	).	"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			otherFrames do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (self scrollBarSetback @ self screenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!ScreenController methodsFor: 'menu messages' stamp: 'RAA 6/3/2000 11:00'!beIsolated	"Establish this project as an isolation layer.	Further method changes made here will be revoked when you leave the project."	CurrentProjectRefactoring currentBeIsolated! !!ScreenController methodsFor: 'menu messages' stamp: 'RAA 6/3/2000 09:44'!exitProject 	"Leave the current Project and enter the Project in which the receiver's 	view is scheduled."	CurrentProjectRefactoring exitCurrentProject! !!ScreenController methodsFor: 'menu messages' stamp: 'RAA 6/3/2000 11:01'!propagateChanges.	"The changes made in this isolated project will be propagated to projects above."	CurrentProjectRefactoring currentPropagateChanges! !!ScreenController methodsFor: 'menu messages' stamp: 'RAA 5/25/2000 09:41'!restoreDisplay 	"Clear the screen to gray and then redisplay all the scheduled views."	Smalltalk isMorphic ifTrue: [^ Display restoreMorphicDisplay].	Display extent = DisplayScreen actualScreenSize		ifFalse:			[DisplayScreen startUp.			ScheduledControllers unCacheWindows].	ScheduledControllers restore! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'RAA 6/12/2000 09:02'!chooseFrequency	| currentFrequency aMenu |	currentFrequency _ self scriptInstantiation frequency.	currentFrequency = 0 ifTrue: [currentFrequency _ 1].	aMenu _ MenuMorph new defaultTarget: self.	#(1 2 5 10 25 50 100 1000 5000 10000) do:		[:i | aMenu add: i printString selector: #setFrequencyTo: argument: i].		aMenu add: 'other...' action: #typeInFrequency.	aMenu addTitle: 'Choose frequency (current: ', currentFrequency printString, ')'.	aMenu  popUpEvent: self currentEvent in: self world! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 6/12/2000 09:02'!yellowButtonActivity: shiftKeyState	| menu |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[menu setInvokingView: self.		menu popUpEvent: self activeHand lastEvent in: self world]! !!PluggableListMorph methodsFor: 'object fileIn' stamp: 'RAA 6/6/2000 19:04'!convertbosfcebbmsopssrsggslssggskafllldp0: varDict bosfcebbmsopssrsggshlssggskafllldp0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'model' 'slotName' 'open' 'pinSpecs' 'scrollBar' 'scroller' 'retractableScrollBar' 'scrollBarOnLeft' 'getMenuSelector' 'getMenuTitleSelector' 'scrollBarHidden' 'list' 'selectedMorph' 'selection' 'getListSelector' 'getIndexSelector' 'setIndexSelector' 'keystrokeActionSelector' 'autoDeselect' 'font' 'lastKeystrokeTime' 'lastKeystrokes' 'lastClickTime' 'doubleClickSelector' 'potentialDropMorph').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('hasFocus')  If a non-nil value is needed, please assign it."! !!PluggableListMorphByItem methodsFor: 'object fileIn' stamp: 'RAA 6/6/2000 19:04'!convertbosfcebbmsopssrsggslssggskafllldpi0: varDict bosfcebbmsopssrsggshlssggskafllldpi0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'model' 'slotName' 'open' 'pinSpecs' 'scrollBar' 'scroller' 'retractableScrollBar' 'scrollBarOnLeft' 'getMenuSelector' 'getMenuTitleSelector' 'scrollBarHidden' 'list' 'selectedMorph' 'selection' 'getListSelector' 'getIndexSelector' 'setIndexSelector' 'keystrokeActionSelector' 'autoDeselect' 'font' 'lastKeystrokeTime' 'lastKeystrokes' 'lastClickTime' 'doubleClickSelector' 'potentialDropMorph' 'itemList').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('hasFocus')  If a non-nil value is needed, please assign it."! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'RAA 6/12/2000 09:02'!scrollBarMenuButtonPressed: event	| menu |	(menu _ self getMenu: event shiftPressed) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		menu popUpEvent: event in: self world]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'RAA 6/12/2000 09:02'!yellowButtonActivity	"Called when the shifted-menu's 'more' item is chosen"	| menu |	(menu _ self getMenu: false) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		menu popUpEvent: self currentEvent in: self world]! !!PluggableTextMorph methodsFor: 'object fileIn' stamp: 'RAA 6/6/2000 19:04'!convertbosfcebbmsopssrsggstgsghash0: varDict bosfcebbmsopssrsggshtgsghash0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'model' 'slotName' 'open' 'pinSpecs' 'scrollBar' 'scroller' 'retractableScrollBar' 'scrollBarOnLeft' 'getMenuSelector' 'getMenuTitleSelector' 'scrollBarHidden' 'textMorph' 'getTextSelector' 'setTextSelector' 'getSelectionSelector' 'hasUnacceptedEdits' 'askBeforeDiscardingEdits' 'selectionInterval' 'hasEditingConflicts').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('hasFocus')  If a non-nil value is needed, please assign it."! !!SqueakPage methodsFor: 'saving' stamp: 'RAA 5/25/2000 10:28'!prePurge	"Return self if ready to be purged, or nil if not"	self isContentsInMemory ifFalse: [^ nil].	contentsMorph ifNil: [^ nil].  "out already"	url ifNil: [^ nil].	"just to be safe"	^ (Display bestGuessOfCurrentWorld ~~ nil and: [contentsMorph world == Display bestGuessOfCurrentWorld]) 		ifTrue: [nil "showing now"] ifFalse: [self]! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'RAA 5/25/2000 09:30'!oldFileMenu: aDirectory withPattern: aPattern	Smalltalk isMorphic ifFalse: [^PluggableFileList oldFileMenu: aDirectory].	^super new oldFileFrom: aDirectory withPattern: aPattern! !!StandardSystemView methodsFor: 'framing' stamp: 'RAA 5/25/2000 08:14'!initialFrame	"Find a plausible initial screen area for the receiver, taking into account user preference, the size needed, and other windows currently on the screen.  5/22/96 sw: let RealEstateAgent do it for us"	^ RealEstateAgent initialFrameFor: self world: nil! !!StandardSystemView methodsFor: 'displaying' stamp: 'RAA 5/25/2000 08:14'!makeMeVisible	| newLoc portRect |	((Display boundingBox insetBy: (0@0 corner: self labelHeight asPoint))		containsPoint: self displayBox topLeft) ifTrue: [^ self "OK -- my top left is visible"].	"window not on screen (probably due to reframe) -- move it now"	newLoc _ self isCollapsed		ifTrue: [RealEstateAgent assignCollapsePointFor: self]		ifFalse: [(RealEstateAgent initialFrameFor: self world: nil) topLeft].	portRect _ newLoc + self labelOffset				extent: self windowBox extent - self labelOffset.	self resizeTo: portRect.	self setLabelRegion.! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:14'!openAndEnter: aProject 	"Answer an instance of me for the argument, aProject. It is created on the	display screen."	| topView |	topView _ self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView window: (RealEstateAgent initialFrameFor: topView world: nil).	ScheduledControllers schedulePassive: topView controller.	aProject enter: false revert: false saveForRevert: false! !!String methodsFor: 'displaying' stamp: 'RAA 5/15/2000 11:00'!displayProgressAt: aPoint from: minVal to: maxVal during: workBlock 	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressAt: Sensor cursorPoint	from: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]].HOW IT WORKS (Try this in any other language :-)Since your code (the last 2 lines in the above example) is in a block,this method gets control to display its heading before, and clean up the screen after, its execution.The key, though, is that the block is supplied with an argument,named 'bar' in the example, which will update the bar image every it is sent the message value: x, where x is in the from:to: range."	^ProgressInitiationException 		display: self		at: aPoint 		from: minVal 		to: maxVal 		during: workBlock! !!SyntaxError class methodsFor: 'instance creation' stamp: 'RAA 6/3/2000 09:12'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	<primitive: 19> "Simulation guard"	Smalltalk isMorphic		ifTrue:			[self buildMorphicViewOn: aSyntaxError.			CurrentProjectRefactoring newProcessIfUI: Processor activeProcess.			^ Processor activeProcess suspend].	topView _ self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor activeProcess suspend.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'RAA 6/3/2000 09:36'!zapMVCprojects   "Smalltalk zapMVCprojects"	| window |	Smalltalk garbageCollect.  "So allInstances is precise"	Project allSubInstancesDo:		[:proj |		proj isTopProject		ifTrue: [proj isMorphic ifFalse:					["Root project is MVC -- we must become the root"					CurrentProjectRefactoring currentBeParentToCurrent]]		ifFalse: [proj parent isMorphic				ifFalse: [proj isMorphic ifTrue:							["Remove Morphic projects from MVC views"							"... and add them back here."							window _ (SystemWindow labelled: proj name) model: proj.							window addMorph: (ProjectViewMorph on: proj)									frame: (0@0 corner: 1.0@1.0).							window openInWorld.							CurrentProjectRefactoring currentBeParentTo: proj]].				proj isMorphic					ifFalse: ["Remove MVC projects from Morphic views"							Project allInstancesDo: [:p | p deletingProject: proj].							ProjectViewMorph allInstancesDo: [:p | p deletingProject: proj]]]		]! !!SystemDictionary methodsFor: 'memory space' stamp: 'RAA 6/3/2000 09:27'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting low space watcher"			^ self beep]].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user now unprotected until the low space watcher is re-installed"	self memoryHogs do: [:hog | hog freeSomeSpace].	self bytesLeft > self lowSpaceThreshold ifTrue: [^ self installLowSpaceWatcher].	Smalltalk isMorphic			ifTrue: [CurrentProjectRefactoring currentInterruptName: 'Space is low']			ifFalse: [ScheduledControllers interruptName: 'Space is low']! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'RAA 6/3/2000 09:28'!handleUserInterrupt	Preferences cmdDotEnabled ifTrue:		[Smalltalk isMorphic			ifTrue: [[CurrentProjectRefactoring currentInterruptName: 'User Interrupt'] fork]			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]]! !!SystemWindow methodsFor: 'open/close' stamp: 'RAA 6/1/2000 18:44'!openInWorld: aWorld	"This msg and its callees result in the window being activeOnlyOnTop"	self bounds: (RealEstateAgent initialFrameFor: self world: aWorld).	aWorld addMorph: self.	self activate.	aWorld startSteppingSubmorphsOf: self.! !!SystemWindow methodsFor: 'open/close' stamp: 'RAA 5/25/2000 08:14'!openInWorld: aWorld extent: extent	"This msg and its callees result in the window being activeOnlyOnTop"	self position: (RealEstateAgent initialFrameFor: self world: aWorld) topLeft; extent: extent.	aWorld addMorph: self.	self activate.	aWorld startSteppingSubmorphsOf: self.! !!SystemWindow methodsFor: 'open/close' stamp: 'RAA 6/2/2000 10:46'!openInWorldExtent: extent	"This msg and its callees result in the window being activeOnlyOnTop"	Smalltalk isMorphic ifFalse: [^ self openInMVCExtent: extent].	self openInWorld: self currentWorld extent: extent! !!SystemWindow methodsFor: 'top window' stamp: 'RAA 5/25/2000 10:27'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColorToUse.	model modelSleep.	self submorphsDo:		[:m | (m == closeBox or: [m == collapseBox])				ifTrue: ["Control boxes remain active, except in novice mode"						Preferences noviceMode ifTrue: [m lock]]				ifFalse: [m lock]].	self world ifNotNil:  "clean damage now, so dont merge this rect with new top window"		[self world == Display bestGuessOfCurrentWorld ifTrue: [self world displayWorld]]! !!SystemWindow methodsFor: 'drawing' stamp: 'RAA 6/12/2000 18:16'!makeMeVisible 	self world extent > (0@0) ifFalse: [^ self].	((self world bounds insetBy: (0@0 corner: self labelHeight asPoint))		containsPoint: self position) ifTrue: [^ self "OK -- at least my top left is visible"].	"window not on screen (probably due to reframe) -- move it now"	self isCollapsed		ifTrue: [self position: (RealEstateAgent assignCollapsePointFor: self)]		ifFalse: [self position: (RealEstateAgent initialFrameFor: self initialExtent: self extent world: self world) topLeft].! !!SystemWindow methodsFor: 'menu' stamp: 'RAA 6/3/2000 09:09'!fullScreen	| possibleBounds |	possibleBounds _ self world bounds.	(Preferences useGlobalFlaps and: [CurrentProjectRefactoring currentFlapsSuppressed not]) ifTrue:		[possibleBounds _ possibleBounds insetBy: 22].	self bounds: possibleBounds! !!SystemWindow methodsFor: 'menu' stamp: 'RAA 6/12/2000 09:01'!offerWindowMenu	| aMenu |	aMenu _ self buildWindowMenu.	model ifNotNil:		[model addModelItemsToWindowMenu: aMenu].	aMenu popUpEvent: self currentEvent in: self world! !!NewWorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 6/1/2000 18:24'!addMorph: aMorph frame: relFrame	| panelRect |	self addMorph: aMorph.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	paneRects _ paneRects copyReplaceFrom: 1 to: 0 with: (Array with: relFrame).	panelRect _ self panelRect.	(aMorph isKindOf: BorderedMorph) ifTrue: [aMorph borderWidth: 1].	aMorph 		"color: self paneColor;"	"since it's a world. skip this"		bounds: ((relFrame scaleBy: panelRect extent) translateBy: panelRect topLeft) truncated.! !!NewWorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 6/1/2000 18:30'!amendSteppingStatus! !!NewWorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 6/2/2000 12:30'!openInWorld: aWorld	| xxx |	"This msg and its callees result in the window being activeOnlyOnTop"	xxx _ RealEstateAgent initialFrameFor: self world: aWorld.	"Bob say: 'opening in ',xxx printString,' out of ',aWorld bounds printString.	6 timesRepeat: [Display flash: xxx andWait: 300]."	self bounds: xxx.	aWorld addMorph: self.	self activate.	aWorld startSteppingSubmorphsOf: self.! !!NewWorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 6/2/2000 08:47'!setStripeColorsFrom: paneColor	"Since our world may be *any* color, try to avoid really dark colors so title will show"	| revisedColor |	revisedColor _ paneColor atLeastAsLuminentAs: 0.1 .	self isActive ifTrue: [		stripes second 			color: revisedColor; 			borderColor: stripes second color darker.		stripes first 			color: stripes second borderColor darker;			borderColor: stripes first color darker.		^self	].	"This could be much faster"	stripes second 		color: revisedColor; 		borderColor: revisedColor.	stripes first 		color: revisedColor; 		borderColor: revisedColor! !!NewWorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 6/2/2000 08:33'!setWindowColor: incomingColor	| existingColor aColor |	incomingColor ifNil: [^ self].  "it happens"	aColor _ incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor 		or: [aColor = Color black]) ifTrue: [^ self].	existingColor _ self paneColorToUse.	existingColor ifNil: [^ self beep].	self setStripeColorsFrom: aColor		! !!NewWorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 6/2/2000 19:25'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds |	allowReframeHandles ifFalse: [^ self].	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) ifTrue:  [^ self].	((self world ifNil: [^ self]) firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[^ self  "Prevent multiple handles"]."Transcript show: event hand printString,'  ',event hand world printString,		'  ',self world printString,' ',self outermostWorldMorph printString; cr; cr."	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ self bounds				withSideOrCorner: ptName				setToPoint: localPt				minExtent: self minimumExtent.			self fastFramingOn 			ifTrue:				[self doFastWindowReframe: ptName]			ifFalse:				[self bounds: newBounds.				(Preferences roundedWindowCorners					and: [#(bottom right bottomRight) includes: ptName])					ifTrue:					["Complete kluge: causes rounded corners to get painted correctly,					in spite of not working with top-down displayWorld."					ptName = #bottom ifFalse:						[self invalidRect: (self bounds topRight - (6@0) extent: 7@7)].					ptName = #right ifFalse:						[self invalidRect: (self bounds bottomLeft - (0@6) extent: 7@7)].					self invalidRect: (self bounds bottomRight - (6@6) extent: 7@7)]]]		lastPointDo:			[:p | ].	self world addMorph: resizer.	resizer startStepping.! !!NewWorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 6/1/2000 18:21'!updatePaneColors	"Useful when changing from monochrome to color display"	self setStripeColorsFrom: self paneColorToUse.	"paneMorphs do: [:p | p color: self paneColorToUse]."	"since pane is a world, skip this"! !!NewWorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 6/1/2000 18:33'!wantsSteps		^true! !!TextMorphEditor methodsFor: 'events' stamp: 'RAA 6/2/2000 10:54'!recognizeCharactersWhileMouseIn: box	"Recognize hand-written characters and put them into the receiving TextMorph.  Invokes Alan's character recognizer.  box is in world coordinates."	| aRecognizer |	Cursor marker showWhile:		[aRecognizer _ CharRecog new textMorph: morph.		aRecognizer recognizeAndDispatch:			[:char | morph handleInteraction:				[char == BS					ifTrue:						[self simulatedBackspace]					ifFalse:						[self simulatedKeystroke: char]] fromEvent: nil.			morph updateFromParagraph.			Display doOneCycleMorphic]		until:			[(box containsPoint: Sensor cursorPoint) not]]! !!TextURL methodsFor: 'as yet unclassified' stamp: 'RAA 5/19/2000 11:01'!actOnClickFor: anObject	"Do what you can with this URL.  Later a web browser."	| response m |	(url beginsWith: 'sqPr://') ifTrue: [		Project thumbnailFromUrl: (url copyFrom: 8 to: url size).		^self		"should not get here, but what the heck"	].	"if it's a web browser, tell it to jump"	anObject isWebBrowser		ifTrue: [anObject jumpToUrl: url. ^ true]		ifFalse: [((anObject respondsTo: #model) and: [anObject model isWebBrowser])				ifTrue: [anObject model jumpToUrl: url. ^ true]].		"if it's a morph, see if it is contained in a web browser"		(anObject isKindOf: Morph) ifTrue: [			m _ anObject.			[ m ~= nil ] whileTrue: [				(m isWebBrowser) ifTrue: [					m  jumpToUrl: url.					^true ].				(m hasProperty: #webBrowserView) ifTrue: [					m model jumpToUrl: url.					^true ].				m _ m owner. ]		].	"no browser in sight.  ask if we should start a new browser"	(self confirm: 'open a browser to view this URL?') ifTrue: [		Scamper openOnUrl: url.		^ true ].	"couldn't display in a browser.  Offer to put up just the source"	response _ (PopUpMenu labels: 'View web page as source\Cancel' withCRs)		startUpWithCaption: 'Couldn''t find a web browser.  Viewpage as source?'.	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:31'!beIsolated	"Establish this project as an isolation layer.	Further method changes made here will be revoked when you leave the project."	myProject beIsolated.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:02'!changeBackgroundColor	self changeColorTarget: myWorld selector: #color: originalColor: myWorld color.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:03'!changeColorTarget: aMorph selector: aSymbol originalColor: aColor	^ ColorPickerMorph new		sourceHand: myHand;		target: aMorph;		selector: aSymbol;		originalColor: aColor;		addToWorld: myWorld			near: (aMorph					ifNil: [Rectangle center: myHand position extent: 20]					ifNotNil: [aMorph == myWorld								ifTrue: [aMorph viewBox bottomLeft + (20@-20) extent: 200]								ifFalse: [aMorph fullBounds]]);		yourself! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 19:17'!cleanUpWorld	(SelectionMenu confirm:'This will remove all windows except thosecontaining unsubmitted text edits, and willalso remove all non-window morphs (otherthan flaps) found on the desktop.  Are yousure you want to do this?')		ifFalse: [^ self].	myWorld allNonFlapRelatedSubmorphs do:		[:m | m delete].	(SystemWindow windowsIn: myWorld satisfying: [:w | w model canDiscardEdits])		do: [:w | w delete]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/26/2000 11:17'!createStandardPartsBin	myHand presenter createStandardPartsBin! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:43'!detachableScriptingSpace	ScriptingSystem newScriptingSpace openInWorld: myWorld! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:18'!inspectWorldModel	| insp |	insp _ InspectorBrowser openAsMorphOn: myWorld model.	myWorld addMorph: insp; startStepping: insp! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/26/2000 11:17'!launchCustomPartsBin	myHand presenter launchCustomPartsBin! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/1/2000 17:51'!loadProject	| stdFileMenuResult |	"Put up a Menu and let the user choose a '.project' file to load.  Create a thumbnail and jump into the project."	Project canWeLoadAProjectNow ifFalse: [^ self].	stdFileMenuResult _ ((StandardFileMenu new) pattern: '*.project'; 		oldFileFrom: FileDirectory default ) 			startUpWithCaption: 'Select a File:'.	stdFileMenuResult ifNil: [^ nil].	ProjectViewMorph openFromStreamBlock: [		stdFileMenuResult directory oldFileNamed: stdFileMenuResult name	]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/26/2000 10:47'!lookForSlips	Smalltalk changes lookForSlips! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/12/2000 18:28'!menu: titleString	| menu |	(menu _ MenuMorph entitled: titleString) 		defaultTarget: self; 		addStayUpItem.	self colorForDebugging: menu.	^menu! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 17:31'!mvcProjectsAllowed	^Preferences mvcProjectsAllowed and: [Smalltalk includesKey: #StandardSystemView]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 07:42'!newMorphOfClass: morphClass event: evt	"Attach a new morph of the given class to the invoking hand."	| m |	m _ morphClass new.	m installModelIn: myWorld.  "a chance to install model pointers"	m wantsToBeOpenedInWorld		ifTrue:[myWorld addMorph: m]		ifFalse:[evt hand attachMorph: m].	myWorld startSteppingSubmorphsOf: m.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/26/2000 08:43'!openChangeSorter1	ChangeSorter new morphicWindow openInWorld: myWorld! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/26/2000 08:43'!openChangeSorter2	DualChangeSorter new morphicWindow openInWorld: myWorld! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/12/2000 18:14'!openEmail	"open an email interface"	Celeste open! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:52'!openFileList	FileList openAsMorph openInWorld: myWorld! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:55'!openIRC	"open an interface to Internet Relay Chat"	IRCConnection new openView; openDirectMessagesObserver! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 17:32'!openMVCProject	ProjectViewMorph newMVCProject openInWorld.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 17:34'!openMorphicProject	(ProjectViewMorph newMorphicProjectOn: nil) openInWorld.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:50'!openSelectorBrowser	SelectorBrowser new morphicWindow openInWorld! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:53'!openTranscript	(Transcript openAsMorphLabel: 'Transcript') openInWorld: myWorld! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:51'!openWorkspace	Workspace new openAsMorphLabel: 'Workspace' inWorld: myWorld! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 10:18'!printWorldOnFile	"Ask the user for a filename and print the world as postscript."	| fileName rotateFlag |	fileName _ ('SqueakScreen') asFileName.	fileName _ FillInTheBlank request: 'File name? (".eps" will be added to end)' 			initialAnswer: fileName.	fileName size == 0 ifTrue: [^ self beep].	(fileName endsWith: '.eps') ifFalse: [fileName _ fileName,'.eps'].	rotateFlag _ ((PopUpMenu labels:'portrait (tall)landscape (wide)')			startUpWithCaption: 'Choose orientation...') = 2.	(FileStream newFileNamed: fileName)		nextPutAll: (EPSCanvas morphAsPostscript: myWorld rotated: rotateFlag); close.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/3/2000 09:30'!propagateChanges.	"The changes made in this isolated project will be propagated to projects above."	myProject propagateChanges.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 17:55'!quitSession	Smalltalk		snapshot: (self confirm: 'Save changes before quitting?' orCancel: [^ self])		andQuit: true! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:35'!readMorphFromAFile	"Produce a morph from a file -- either a saved .morph file or a graphics file"	| morphOrList ff aName f m |	aName _ Utilities chooseFileWithSuffixFromList:(#('.morph'), Utilities graphicsFileSuffixes) withCaption: 'Choose a fileto load'.	aName ifNil: [^ self].  "User made no choice"	aName == #none ifTrue: [^ self inform: 'Sorry, no suitable files found(names should end with .morph, .gif,.bmp, .jpeg, .jpe, .jp, or .form)'].	(aName asLowercase endsWith: '.morph')		ifTrue:			[ff _ FileStream oldFileNamed: aName.			morphOrList _ ff fileInObjectAndCode.		"code filed in is the Model class"			"the file may contain either a single morph or an array of morphs"			myWorld addMorphsAndModel: morphOrList]		ifFalse:			[f _ Form fromFileNamed: aName.			f ifNil: [^ self error: 'unrecognized image file format'].			m _ myHand drawingClass new form: f.			myHand attachMorph: m]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 17:54'!saveAndQuit	Smalltalk snapshot: true andQuit: true! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 17:53'!saveSession	Smalltalk snapshot: true andQuit: false! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:13'!saveWorldInFile	"Save the world's submorphs, model, and stepList in a file.  "	| fileName fileStream aClass |	fileName _ FillInTheBlank request: 'File name for this morph?'.	fileName isEmpty ifTrue: [^ self].  "abort"	"Save only model, stepList, submorphs in this world"	myWorld submorphsDo: [:m |		m allMorphsDo: [:subM | subM prepareToBeSaved]].	"Amen"	fileStream _ FileStream newFileNamed: fileName, '.morph'.	aClass _ myWorld model ifNil: [nil] ifNotNil: [myWorld model class].	fileStream fileOutClass: aClass andObject: myWorld.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:53'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result oldDepth |	oldDepth _ Display depth.	(result _ (SelectionMenu selections: Display supportedDisplayDepths) startUpWithCaption:'Choose a display depth(it is currently ' , oldDepth printString , ')') ifNotNil: [Display newDepth: result].	(Smalltalk isMorphic and: [(Display depth < 4) ~= (oldDepth < 4)])		ifTrue:			["Repaint windows since they look better all white in depth < 4"			(SystemWindow windowsIn: myWorld satisfying: [:w | true]) do:				[:w |				oldDepth < 4					ifTrue: [w restoreDefaultPaneColor]					ifFalse: [w updatePaneColors]]]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 19:21'!splitNewMorphList: list depth: d	| middle c prev next out |	d <= 0 ifTrue:[^Array with: list].	middle _ list size // 2 + 1.	c _ (list at: middle) name first.	prev _ middle - 1.	[prev > 0 and:[(list at: prev) name first = c]] 		whileTrue:[prev _ prev - 1].	next _ middle + 1.	[next <= list size and:[(list at: next) name first = c]]		whileTrue:[next _ next + 1].	"Choose the better cluster"	(middle - prev) < (next - middle)		ifTrue:[middle _ prev+1]		ifFalse:[middle _ next].	middle = 1 ifTrue:[middle _ next].	middle >= list size ifTrue:[middle _ prev+1].	(middle = 1 or:[middle >= list size]) ifTrue:[^Array with: list].	out _ WriteStream on: Array new.	out nextPutAll: (self splitNewMorphList: (list copyFrom: 1 to: middle-1) depth: d-1).	out nextPutAll: (self splitNewMorphList: (list copyFrom: middle to: list size) depth: d-1).	^out contents.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/2/2000 10:54'!startMessageTally	(self confirm: 'MessageTally will start now,and stop when the cursor goesto the top of the screen') ifTrue:		[MessageTally spyOn:			[[Sensor primMousePt y > 0] whileTrue: [Display doOneCycleMorphic]]]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/2/2000 10:54'!startThenBrowseMessageTally	(self confirm: 'MessageTally will start now,and stop when the cursor goesto the top of the screen') ifTrue:		[TimeProfileBrowser onBlock:			[[Sensor primMousePt y > 0] whileTrue: [Display doOneCycleMorphic]]]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 19:02'!world: aWorld project: aProject hand: aHand	myWorld _ aWorld.	myProject _ aProject.	myHand _ aHand.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 5/24/2000 18:29'!worldMenuHelp	| aList aMenu cnts explanation |	"self currentWorld primaryHand worldMenuHelp"	aList _ OrderedCollection new.	#(helpMenu changesMenu openMenu debugMenu projectMenu scriptingMenu windowsMenu playfieldMenu appearanceMenu) 		with:	#('help' 'changes' 'open' 'debug' 'projects' 'authoring tools' 'windows & flaps' 'playfield options' 'appearance') do:		[:sel :title | aMenu _ self perform: sel.			aMenu items do:				[:it | (((cnts _ it contents) = 'keep this menu up') or: [cnts size = 0])					ifFalse: [aList add: (cnts, ' - ', title)]]].	aList _ aList asSortedCollection: [:a :b | a asLowercase < b asLowercase].	explanation _ String streamContents: [:aStream | aList do:		[:anItem | aStream nextPutAll: anItem; cr]].	(StringHolder new contents: explanation)		openLabel: 'Where in the world menu is...'! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 5/25/2000 07:42'!alphabeticalMorphMenu	| list splitLists menu firstChar lastChar subMenu |	list _ Morph withAllSubclasses select:[:m | m includeInNewMorphMenu].	list _ list asArray sortBy:[:c1 :c2| c1 name < c2 name].	splitLists _ self splitNewMorphList: list depth: 3.	menu _ MenuMorph new defaultTarget: self.	1 to: splitLists size do:[:i|		i = 1 ifTrue:[firstChar _ $A]			ifFalse:[firstChar _ ((splitLists at: i-1) last name first asInteger + 1) asCharacter].		i = splitLists size			ifTrue:[lastChar _ $Z]			ifFalse:[lastChar _ (splitLists at: i) last name first].		subMenu _ MenuMorph new.		(splitLists at: i) do:[:cl|			subMenu add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl].		menu add: firstChar asString,' - ', lastChar asString subMenu: subMenu.	].	^menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/6/2000 17:03'!appearanceMenu	"Build the appearance menu for the world."	| screenCtrl |	screenCtrl _ ScreenController new.	^self fillIn: (self menu: 'appearance...') from: {		{'window colors...' . { Preferences . #windowSpecificationPanel} . 'Lets you specify colors for standard system windows.'}.		{'system fonts...' . { self . #standardFontDo} . 'Choose the standard fonts to use for code, lists, menus, window titles, etc.'}.		{'text highlight color...' . { Preferences . #chooseTextHighlightColor} . 'Choose which color should be used for text highlighting in Morphic.'}.		{'insertion point color...' . { Preferences . #chooseInsertionPointColor} . 'Choose which color to use for the text insertion point in Morphic.'}.		nil.		{#menuColorString . { Preferences . #toggleMenuColorPolicy} . 'Governs whether menu colors should be derived from the desktop color.'}.		{#roundedCornersString . { Preferences . #toggleRoundedCorners} . 'Governs whether morphic windows and menus should have rounded corners.'}.		nil.		{'full screen on' . { screenCtrl . #fullScreenOn} . 'puts you in full-screen mode, if not already there.'}.		{'full screen off' . { screenCtrl . #fullScreenOff} . 'if in full-screen mode, takes you out of it.'}.		nil.		{'set display depth...' . {self. #setDisplayDepth} . 'choose how many bits per pixel.'}.		{'set desktop color...' . {self. #changeBackgroundColor} . 'choose a uniform color to use as desktop background.'}.		{'set gradient color...' . { myWorld . #setGradientColor:} . 'choose second color to use as gradient for desktop background.'}.		{'use texture background' . { myWorld . #setStandardTexture} . 'apply a graph-paper-like texture background to the desktop.'}.		nil.		{'clear turtle trails from desktop' . { myWorld . #clearTurtleTrails} . 'remove any pigment laid down on the desktop by objects moving with their pens down.'}.	}! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/12/2000 18:27'!buildWorldMenu	"Build the meta menu for the world."	| menu |	menu _ MenuMorph new defaultTarget: self.	self colorForDebugging: menu.	menu addStayUpItem.	self fillIn: menu from: {		{'previous project' . { myWorld . #goBack } }.		{'jump to project...' . { myWorld . #jumpToProject } }.		{'save project on file...' . { myWorld  . #saveOnFile } }.		{'load project from file...' . { self  . #loadProject } }.		nil.		{'restore display' . { Display . #restoreMorphicDisplay } }.		nil.	}.	Preferences simpleMenus ifFalse: [		self fillIn: menu from: { 			{'open...' . { self  . #openWindow } }.			{'windows & flaps...' . { self  . #windowsDo } }.			{'changes...' . { self  . #changesDo } }.		}.	].	self fillIn: menu from: { 		{'help...' . { self  . #helpDo } }.		{'appearance...' . { self  . #appearanceDo } }.	}.	Preferences simpleMenus ifFalse: [		self fillIn: menu from: {			{'do...' . { Utilities . #offerCommonRequests} }.		}.	].	self fillIn: menu from: { 		nil.		{'new morph...' . { self  . #newMorph } }.		{'authoring tools...' . { self  . #scriptingDo } }.		{'playfield options...' . { self  . #playfieldDo } }.		{'projects...' . { self  . #projectDo } }.	}.	Preferences simpleMenus ifFalse: [		self fillIn: menu from: { 			{'print PS to file...' . { self  . #printWorldOnFile } }.			{'debug...' . { self  . #debugDo } }.		}.	].	self fillIn: menu from: { 		nil.		{'save' . { self  . #saveSession } }.		{'save as...' . { Smalltalk . #saveAs } }.		{'save and quit' . { self  . #saveAndQuit } }.		{'quit' . { self  . #quitSession } }.	}.	^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/6/2000 17:05'!changesMenu	"Build the changes menu for the world."	| menu |	menu _ self menu: 'changes...'.	self fillIn: menu from: {		{ 'file out current change set' . { Utilities . #fileOutChanges}.				'Write the current change set out to a file whose name reflects the change set name and the current date & time.'}.		{ 'create new change set...' . { ChangeSorter . #newChangeSet}. 'Create a new change set and make it the current one.'}.		{ 'browse changed methods' . { Smalltalk . #browseChangedMessages}.  'Open a message-list browser showing all methods in the current change set'}.		{ 'check change set for slips' . { Smalltalk changes . #lookForSlips}.				'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'}.		nil.		{ 'simple change sorter' . {self. #openChangeSorter1}.  'Open a 3-paned changed-set viewing tool'}.		{ 'dual change sorter' . {self. #openChangeSorter2}.				'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'}.		nil.		{ 'browse recent submissions' . { Utilities . #browseRecentSubmissions}.				'Open a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'}.		{ 'recently logged changes...' . { ChangeList . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.'}.		{ 'recent log file...' . { Smalltalk . #writeRecentToFile}.				'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.'}.		nil.		{ 'save world as morph file' . {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.'}.		nil.	}.	myProject isIsolated ifTrue: [		self fillIn: menu from: { 			{ 'propagate changes upward' . {self. #propagateChanges}.				'The changes made in this isolated project will propagate to projects up to the next isolation layer.'}.		}.	] ifFalse: [		self fillIn: menu from: { 			{ 'isolate changes of this project' . {self. #beIsolated}.				'Isolate this project and its subprojects from the rest of the system.  Changes to methods here will be revoked when you leave this project.'}.		}.	].	^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/12/2000 18:28'!colorForDebugging: aMenu	"aMenu color: self myMenuColor"! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 5/26/2000 11:05'!debugMenu	| menu |	menu _ self menu: 'debug...'.	^self fillIn: menu from: { 		{ 'inspect world' . { myWorld . #inspect } }.		{ 'explore world' . { myWorld . #explore } }.		{ 'inspect model' . { self . #inspectWorldModel } }.			" { 'talk to world...' . { self . #typeInMessageToWorld } }."		{ 'start MessageTally' . { self . #startMessageTally } }.		{ 'start/browse MessageTally' . { self . #startThenBrowseMessageTally } }.		nil.			"(self hasProperty: #errorOnDraw) ifTrue:  Later make this come up only when needed."		{ 'start drawing again' . { myWorld . #resumeAfterDrawError } }.		{ 'start stepping again' . { myWorld . #resumeAfterStepError } }.		nil.		{ 'call #tempCommand' . { myHand . #callTempCommand } }.		{ 'define #tempCommand' . { myHand . #defineTempCommand } }.	}! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 5/26/2000 08:30'!fillIn: aMenu from: dataForMenu	dataForMenu do: [ :itemData |		itemData ifNil: [			aMenu addLine		] ifNotNil: [			(itemData first isKindOf: Symbol) ifTrue: [				aMenu 					addUpdating: itemData first 					target: self 					selector: #doMenuItem: 					argumentList: {itemData second}.			] ifFalse: [				aMenu 					add: itemData first 					target: self 					selector: #doMenuItem: 					argumentList: {itemData second}.			].			itemData size >= 3 ifTrue: [				aMenu balloonTextForLastItem: itemData third			].		].	].	^aMenu! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/6/2000 17:08'!helpMenu	"Build the help menu for the world."	| screenCtrl |	screenCtrl _ ScreenController new.	^self fillIn: (self menu: 'help...') from:	{		{'about this system...'. {Smalltalk. #aboutThisSystem}. 'current version information.'}.		{'update code from server'. {Utilities. #updateFromServer}. 'load latest code updates via the internet'}.		{'preferences...'. {Preferences. #openPreferencesInspector}. 'view and change various options.'}.		nil.		{'command-key help'. { Utilities . #openCommandKeyHelp}. 'summary of keyboard shortcuts.'}.		{'world menu help'. { self . #worldMenuHelp}. 'helps find menu items buried in submenus.'}.			"{'info about flaps' . { Utilities . #explainFlaps}. 'describes how to enable and use flaps.'}."		{'font size summary' . { Utilities . #fontSizeSummary}.  'summary of names and sizes of available fonts.'}.		{'useful expressions' . { Utilities . #openStandardWorkspace}. 'a window full of useful expressions.'}.		{'graphical imports' . { Smalltalk . #viewImageImports}.  'view the global repository called ImageImports; you can easily import external graphics into ImageImports via the FileList'}.		{'standard graphics library' . { ScriptingSystem . #inspectFormDictionary}.  'lets you view and change the system''s standard library of graphics.'}.		nil.		{#gridOnString . { myHand . #setGridding}. 'turn gridding on or off.'}.		{'set grid size...' . { myHand . #setGridSize}.  'specify the size of the grid.'}.		{'telemorphic...' . {self. #remoteDo}.  'commands for doing multi-machine "telemorphic" experiments'}.		{#soundEnablingString . { Preferences . #toggleSoundEnabling}. 'turning sound off will completely disable Squeak''s use of sound.'}.		{'definition for...' . { Utilities . #lookUpDefinition}.  'if connected to the internet, use this to look up the definition of an English word.'}.		nil.		{'set author initials...' . { screenCtrl . #setAuthorInitials }. 'supply initials to be used to identify the author of code and other content.'}.		{'vm statistics' . { screenCtrl . #vmStatistics}.  'obtain some intriguing data about the vm.'}.		{'space left' . { screenCtrl . #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}.	}! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/2/2000 08:48'!myMenuColor	| c |	c _ myWorld color.	c isColor ifTrue: [^c atLeastAsLuminentAs: 0.2].	^Color white! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/6/2000 17:09'!newMorph	| menu subMenu catDict shortCat class |	menu _ self menu: 'Add a new morph'.	menu 		add: 'from paste buffer' action: #pasteMorph;		add: 'from a file...' target: self action: #readMorphFromAFile;			"menu add: 'from alphabetical list...' action: #newMorphFromAlphabeticalList."		add: 'from alphabetical list' subMenu: self alphabeticalMorphMenu;		add: 'grab patch from screen' action: #grabDrawingFromScreen;		add: 'make new drawing' target: self action: #newDrawingFromMenu;		add: 'make link to project...' target: self action: #projectThumbnail;		addLine.	catDict _ Dictionary new.	SystemOrganization categories do:		[:cat |		((cat beginsWith: 'Morphic-')				and: [(#('Morphic-Menus' 'Morphic-Support') includes: cat) not])		ifTrue:			[shortCat _ cat copyFrom: 'Morphic-' size+1 to: cat size.			(SystemOrganization listAtCategoryNamed: cat) do:				[:cName | class _ Smalltalk at: cName.				((class inheritsFrom: Morph)					and: [class includeInNewMorphMenu])					ifTrue:					[(catDict includesKey: shortCat) 					ifTrue: [(catDict at: shortCat) addLast: class]					ifFalse: [catDict at: shortCat put: (OrderedCollection with: class)]]]]].	catDict keys asSortedCollection do:		[:categ |		subMenu _ MenuMorph new.		((catDict at: categ) asSortedCollection: [:c1 :c2 | c1 name < c2 name]) do:			[:cl | subMenu add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl].		menu add: categ subMenu: subMenu].	self doPopUp: menu.! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/6/2000 17:10'!openMenu	"Build the open window menu for the world."	| menu |	menu _ self menu: 'open...'.	self fillIn: menu from: {		{'browser' . { Browser . #openBrowser} }.		{'package browser' . { PackageBrowser . #openBrowser} }.		{'method finder' . { self . #openSelectorBrowser} }.		{'workspace' . {self . #openWorkspace} }.		{'file list' . {self . #openFileList} }.		{'file...' . { FileList . #openFileDirectly} }.		{'transcript' . {self . #openTranscript} }.		{'inner world' . { WorldWindow . #test1} }.		nil.		{'simple change sorter' . {self . #openChangeSorter1} }.		{'dual change sorter' . {self . #openChangeSorter2} }.		nil.		{'email reader' . {self . #openEmail} }.		{'web browser' . { Scamper . #openAsMorph} }.		{'IRC chat' . {self . #openIRC} }.		nil.	}.	self mvcProjectsAllowed ifTrue: [		self fillIn: menu from: { {'mvc project' . {self. #openMVCProject} } }	].	^self fillIn: menu from: { 		{'morphic project' . {self. #openMorphicProject} }.	}.! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 5/24/2000 22:34'!playfieldMenu	^ myWorld playfieldOptionsMenu! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/1/2000 17:52'!projectMenu	"Build the project menu for the world."	| menu |	menu _ self menu: 'projects...'.	self fillIn: menu from: {		{ 'save project on file...' . { myWorld . #saveOnFile } }.		{ 'load project from file...' . { self . #loadProject } }.		nil.	}.	self mvcProjectsAllowed ifTrue: [		self fillIn: menu from: {			{ 'create new mvc project'. { self . #openMVCProject } }.		}	].	self fillIn: menu from: { 		{ 'create new morphic project' . { self . #openMorphicProject } }.		nil.		{ 'go to previous project' . { Project . #returnToPreviousProject } }.		{ 'go to next project' . { Project . #advanceToNextProject } }.		{ 'jump to project...' . { myWorld . #jumpToProject } }.		nil.		{ 'save on server (also makes a local copy)' . { myProject . #storeOnServer } }.		{ 'saveAs' . { myProject . #saveAs } }.		{ 'see if server version is more recent...' . { myProject . #loadFromServer } }.	}.	Preferences simpleMenus ifFalse: [		self fillIn: menu from: { 			nil.			{ 'save for future revert' . { myProject . #saveForRevert } }.			{ 'revert to saved copy' . { myProject . #revert } }.		}.	].	^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 5/26/2000 11:13'!remoteMenu	"Build the Telemorphic menu for the world."	^self fillIn: (self menu: 'Telemorphic') from: {		{ 'local host address' . { myHand . #reportLocalAddress } }.		{ 'connect remote user' . { myHand . #connectRemoteUser } }.		{ 'disconnect remote user' . { myHand . #disconnectRemoteUser } }.		{ 'disconnect all remote users' . { myHand . #disconnectAllRemoteUsers } }.	}! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 5/26/2000 11:34'!scriptingMenu	"Build the scripting menu for the world."	^self fillIn: (self menu: 'authoring tools...') from: { 		{ 'standard parts bin' . { self . #createStandardPartsBin}. 'A bin of standard parts, from which you can drag out useful morphs.'}.		{ 'custom parts bin' . { self . #launchCustomPartsBin}. 'A customized bin of parts.  To define what the custom parts bin is, edit any existing parts bin and tell it to be saved as the custom parts bin.'}.		{ 'view trash contents' . { myHand . #openScrapsBook}. 'The place where all your trashed morphs go.'}.		{ 'empty trash can' . { Utilities . #emptyScrapsBook}. 'Empty out all the morphs that have accumulated in the trash can.'}.		{ 'new scripting area' . { self . #detachableScriptingSpace}. 'A window set up for simple scripting.'}.		nil.		{ 'unlock locked objects' . { myWorld . #unlockContents}. 'If any items on the world desktop are currently locked, unlock them.'}.		{ 'unhide hidden objects' . { myHand . #showHiders}. 'If any items on the world desktop are currently hidden, make them visible.'}.	}! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 5/26/2000 11:32'!windowsMenu	"Build the windows menu for the world."	^self fillIn: (self menu: 'windows & flaps...') from: {  		{ 'find window' . { myHand . #findWindow }. 'Presents a list of all windows; if you choose one from the list, it becomes the active window.'}.		{ 'find changed browsers...' . { myHand . #findDirtyBrowsers }. 'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.		{ 'find changed windows...' . { myHand . #findDirtyWindows }. 'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.		nil.		{ 'collapse all windows' . { myHand . #collapseAll }. 'Reduce all open windows to collapsed forms that only show titles.'}.		{ 'expand all windows' . { myHand . #expandAll }. 'Expand all collapsed windows back to their expanded forms.'}.		nil.		{ 'delete unchanged windows' . { myHand . #closeUnchangedWindows }. 'Deletes all windows that do not have unsaved text edits.'}.		{ 'delete non-windows' . { myHand . #deleteNonWindows }. 'Deletes all non-window morphs lying on the world.'}.		{ 'delete both of the above' . { self .#cleanUpWorld }. 'deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'}.		nil.		{ #staggerPolicyString . { self . #toggleWindowPolicy }. 'stagger: new windows positioned so you can see a portion of each one.		tile: new windows positioned so that they do not overlap others, if possible.'}.		nil.		{ #suppressFlapsString . { self . #toggleFlapSuppressionInProject }. 'Governs whether flaps should be shown in this project'}.		nil.		{ 'new global flap...'  . { Utilities . #addGlobalFlap }. 'Create a new flap that will be shared by all morphic projects'}.		{ 'new project flap...'  . { Utilities . #addLocalFlap }. 'Create a new flap to be used only in this project.'}.		nil.		{ 'about flaps...' . { Utilities . #explainFlaps }. 'Gives a window full of details about how to use flaps.'}.		{ #useGlobalFlapsString . { self. #toggleWhetherToUseGlobalFlaps }. 'Governs whether a universal set of "global" flaps should be used in all morphic projects that currently are showing flaps.'}.	}! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 5/26/2000 10:05'!doMenuItem: aCollection	^Display		useMorphicWorld: myWorld 		during: [aCollection first perform: aCollection second]! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 5/26/2000 08:35'!gridOnString	^myHand gridOnString! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 5/26/2000 10:18'!menuColorString	^ Preferences menuColorString! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 5/26/2000 10:18'!roundedCornersString	^ Preferences roundedCornersString! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 5/26/2000 08:35'!soundEnablingString	^ Preferences soundEnablingString! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 5/26/2000 11:31'!staggerPolicyString	^ Preferences staggerPolicyString! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 5/26/2000 11:30'!suppressFlapsString	^ Utilities suppressFlapsString! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 5/26/2000 11:30'!toggleFlapSuppressionInProject	Utilities toggleFlapSuppressionInProject! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 5/26/2000 11:29'!toggleWhetherToUseGlobalFlaps	Utilities toggleWhetherToUseGlobalFlaps! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 5/26/2000 11:32'!toggleWindowPolicy	Preferences toggleWindowPolicy! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 5/26/2000 11:28'!useGlobalFlapsString	^ Utilities useGlobalFlapsString! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 5/26/2000 10:25'!appearanceDo	"Build and show the appearance menu for the world."	self doPopUp: self appearanceMenu! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 5/26/2000 10:26'!changesDo	"Build the changes menu for the world."	self doPopUp: self changesMenu! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 5/26/2000 10:26'!debugDo	self doPopUp: self debugMenu! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 6/12/2000 09:13'!doPopUp: aMenu	aMenu popUpForHand: myHand in: myWorld.! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 5/26/2000 10:26'!helpDo	"Build and show the help menu for the world."	self doPopUp: self helpMenu! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 5/26/2000 10:26'!openWindow	self doPopUp: self openMenu! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 5/26/2000 10:26'!playfieldDo	"Build the playfield menu for the world."	self doPopUp: myWorld playfieldOptionsMenu! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 5/26/2000 10:26'!projectDo	"Build and show the project menu for the world."	self doPopUp: self projectMenu! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 5/26/2000 10:26'!remoteDo	self doPopUp: self remoteMenu! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 5/26/2000 10:27'!scriptingDo	self doPopUp: self scriptingMenu! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 5/26/2000 10:27'!standardFontDo	"Build and show the standard font menu"	self doPopUp: Preferences fontConfigurationMenu! !!TheWorldMenu methodsFor: 'popups' stamp: 'RAA 5/26/2000 10:27'!windowsDo	"Build the windows menu for the world."	self doPopUp: self windowsMenu! !!TransferMorphAnimation methodsFor: 'initialization' stamp: 'RAA 6/2/2000 16:43'!on: aTransferMorph	self flag: #bob.		"there was a reference to World, but the class seems to be unused"	self color: Color transparent.	transferMorph _ aTransferMorph.	transferMorph addDependent: self.	Display getCurrentMorphicWorld addMorph: self	"or perhaps aTransferMorph world"! !!TranslucentProgessMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/1/2000 17:40'!drawOn: aCanvas	| revealPercentage revealingStyle revealingColor revealingBounds revealToggle x baseColor revealTimes secondsRemaining scanner stringToDraw where fontToUse |	revealTimes _ (self valueOfProperty: #revealTimes) ifNil: [^self].	revealPercentage _ (revealTimes first / revealTimes second) asFloat.	revealingStyle _ self revealingStyle.	x _ self valueOfProperty: #progressStageNumber ifAbsent: [1].	baseColor _ Color perform: (#(red blue green magenta cyan yellow) atPin: x).	revealingColor _ baseColor alpha: 0.2.	revealingStyle = 3 ifTrue: [	"wrap and change color"		revealPercentage > 1.0 ifTrue: [			revealingColor _ baseColor alpha: (0.2 + (revealingStyle / 10) min: 0.5).		].		revealPercentage _ revealPercentage fractionPart.	].	revealingStyle = 2 ifTrue: [	"peg at 75 and blink"		revealPercentage > 0.75 ifTrue: [			revealToggle _ self valueOfProperty: #revealToggle ifAbsent: [true].			self setProperty: #revealToggle toValue: revealToggle not.			revealToggle ifTrue: [revealingColor _ baseColor alpha: 0.8.].		].		revealPercentage _ revealPercentage min: 0.75.	].	revealingBounds _ bounds withLeft: bounds left + (bounds width * revealPercentage) truncated.	aCanvas 		fillRectangle: revealingBounds		color: revealingColor.	secondsRemaining _ (revealTimes second - revealTimes first / 1000) rounded.	secondsRemaining > 0 ifTrue: [		fontToUse _ StrikeFont familyName: 'ComicBold' size: 24.		scanner _ DisplayScanner			quickPrintOn: aCanvas form 			box: bounds 			font: fontToUse 			color: Color black.		stringToDraw _ secondsRemaining printString.		where _ bounds corner - ((scanner stringWidth: stringToDraw) @ scanner lineHeight).		scanner 			drawString: stringToDraw 			at: where.		scanner _ DisplayScanner			quickPrintOn: aCanvas form 			box: bounds 			font: fontToUse 			color: Color white.		scanner 			drawString: stringToDraw 			at: where - (1@1).	]. ! !!TranslucentProgessMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/23/2000 11:19'!revealingStyle">>>>	1 = original, no change after 100%	2 = hold at last 25% and blink until done	3 = wrap around from 100% back to 0 and go again. change color after first<<<<"	^3! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 6/12/2000 09:01'!yellowButtonActivity: shiftKeyState	| menu |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[menu setInvokingView: self.		menu popUpEvent: self activeHand lastEvent in: self world]! !!Utilities class methodsFor: 'miscellaneous' stamp: 'RAA 5/25/2000 10:23'!storeTextWindowContentsToFileNamed: aName	"Utilities storeTextWindowContentsToFileNamed: 'TextWindows'"	| windows aDict assoc aRefStream textToUse aTextView |	"there is a reference to World, but this method seems to be unused"	aDict _ Dictionary new.	Smalltalk isMorphic		ifTrue:			[windows _ Display bestGuessOfCurrentWorld submorphs select: [:m | m isKindOf: SystemWindow].			windows do:				[:w | assoc _ w titleAndPaneText.				assoc ifNotNil:					[w holdsTranscript ifFalse:						[aDict add: assoc]]]]		ifFalse:			[windows _ ScheduledControllers controllersSatisfying:				[:c | (c model isMemberOf: StringHolder) or: [c model isKindOf: Workspace]].			windows do:				[:aController | 					aTextView _ aController view subViews detect: [:m | m isKindOf: PluggableTextView] ifNone: [nil].					textToUse _ aTextView						ifNil:		[aController model contents]						ifNotNil:	[aTextView controller text].  "The latest edits, whether accepted or not"					aDict at: aController view label put: textToUse]].	aDict size = 0 ifTrue: [^ self inform: 'no windows found to export.'].	aRefStream _ ReferenceStream fileNamed: aName.	aRefStream nextPut: aDict.	aRefStream close.	self inform: 'Done!!  ', aDict size printString, ' window(s) exported.'! !!Utilities class methodsFor: 'flaps' stamp: 'RAA 5/24/2000 19:35'!menuFlap	| aFlap aFlapTab aHolder verticalHolder aMenu |	aFlap _ PasteUpMorph newSticky color: Color transparent; extent: self currentWorld width @ 264; borderWidth: 0; padding: 0.	aFlapTab _ FlapTab new referent: aFlap.	aFlapTab color: Color brown lighter.	aFlapTab assumeString: 'Menus' font: Preferences standardFlapFont orientation: #horizontal color: Color blue muchLighter.	aFlapTab setToPopOutOnMouseOver: true.	aFlapTab edgeToAdhereTo: #top; inboard: false.	aFlapTab position: ((Display width - aFlapTab width) // 2) @ 0.	aFlap setProperty: #flap toValue: true.	aFlap color: (Color blue muchLighter alpha: 0.6).	aFlap extent: self currentWorld width @ 267.	aHolder _ AlignmentMorph newRow beSticky beTransparent.	#(openMenu helpMenu windowsMenu (changesMenu debugMenu ) (playfieldMenu scriptingMenu )) do:		[:elem |			(elem isKindOf: Array)				ifTrue:					[verticalHolder _ AlignmentMorph newColumn beSticky beTransparent.					verticalHolder hResizing: #shrinkWrap; inset: 0; centering: #center.					elem do:						[:aMenuSymbol |							verticalHolder addMorphBack: ((aMenu _ self currentHand getWorldMenu: aMenuSymbol) beSticky; stayUp: true).							aMenu beSticky.							aMenu borderWidth: 1.							aMenu submorphs second delete].					aHolder addMorphBack: verticalHolder]				ifFalse:					[aHolder addMorphBack: ((aMenu _ self currentHand getWorldMenu: elem) beSticky; stayUp: true).					aMenu submorphs second delete.					aMenu beSticky.					aMenu borderWidth: 1]].	aFlap addMorphBack: aHolder.	^ aFlapTab! !!Utilities class methodsFor: 'flaps' stamp: 'RAA 5/25/2000 10:27'!replaceMenuFlap	"if there is a global menu flap, replace it with an updated one."	| aFlapTab |	aFlapTab _ self globalFlapTabsIfAny detect:		[:aTab | (aTab submorphs size > 0) and:  [(aTab submorphs first isKindOf: TextMorph) and: [(aTab submorphs first contents string copyWithout: $ ) = 'Menus']]] ifNone: [^ self].	self removeFlapTab: aFlapTab keepInList: false.	self addGlobalFlap: self menuFlap.	Smalltalk isMorphic ifTrue: [Display bestGuessOfCurrentWorld addGlobalFlaps]"Utilities replaceMenuFlap"! !!Utilities class methodsFor: 'flaps' stamp: 'RAA 6/3/2000 09:09'!suppressFlapsString	^ (CurrentProjectRefactoring currentFlapsSuppressed)		ifFalse: ['hide flaps']		ifTrue: ['show flaps']! !!Utilities class methodsFor: 'flaps' stamp: 'RAA 6/3/2000 10:57'!toggleFlapSuppressionInProject	Preferences useGlobalFlaps ifFalse:		[^ self inform: 'CAUTION!!  Global flaps are currently disabled, and must be reenabled for this option to be meaningful.'].	CurrentProjectRefactoring currentToggleFlapsSuppressed.	Display restoreMorphicDisplay.! !!Utilities class methodsFor: 'text styles and fonts' stamp: 'RAA 6/11/2000 19:16'!promptForFont: aPrompt andSendTo: aTarget withSelector: aSelector        "Utilities promptForFont: 'Choose system font:' andSendTo: Utilities withSelector: #setSystemFontTo:"        "NOTE: Morphic ONLY!!!!.  Derived from a method written by Robin Gibson"        | menu subMenu |        menu _ MenuMorph entitled: aPrompt.        Utilities actualTextStyles keys do: [:styleName|                subMenu _ self fontMenuForStyle: styleName target: aTarget selector: aSelector.                menu add: styleName subMenu: subMenu.                menu lastItem font: ((TextStyle named: styleName) fontOfSize: 18)].        menu popUpForHand: self currentHand! !!WaveletCodec methodsFor: 'subclass responsibilities' stamp: 'RAA 6/2/2000 11:06'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	| frameBase coeffs maxVal minVal c scale nullCount frameI outFrameSize threshold sm outStream cMin val |	threshold _ 2000.	fwt ifNil:		[samplesPerFrame _ self samplesPerFrame.		nLevels _ 8.		"Here are some sample mother wavelets, with the compression achieved on a		sample of my voice at a threshold of 2000:									compression achieved "		alpha _ 0.0.  beta _ 0.0.		"12.1"		alpha _ 1.72.  beta _ 1.51.	"14.0"		alpha _ -1.86.  beta _ -1.53.	"14.4"		alpha _ 1.28.  beta _ -0.86.	"15.9"		alpha _ -1.15.  beta _ 0.69.	"16.0"		fwt _ FWT new.		fwt nSamples: samplesPerFrame nLevels: nLevels.		fwt setAlpha: alpha beta: beta].	(outStream _ WriteStream on: dstByteArray from: dstIndex to: dstByteArray size)		nextNumber: 4 put: frameCount;		nextNumber: 4 put: samplesPerFrame;		nextNumber: 4 put: nLevels;		nextNumber: 4 put: alpha asIEEE32BitWord;		nextNumber: 4 put: beta asIEEE32BitWord.	frameBase _ srcIndex.	1 to: frameCount do:		[:frame | 		"Copy float values into the wavelet sample array"				fwt samples: ((frameBase to: frameBase + samplesPerFrame-1) 				collect: [:i | (srcSoundBuffer at: i) asFloat]).		"Compute the transform"		fwt transformForward: true.		frameI _ outStream position+1.  "Reserve space for frame size"		outStream nextNumber: 2 put: 0.		"Determine and output the scale for this frame"		coeffs _ fwt coeffs.		maxVal _ 0.0.  minVal _ 0.0.		5 to: coeffs size do:			[:i | c _ coeffs at: i.			c > maxVal ifTrue: [maxVal _ c].			c < minVal ifTrue: [minVal _ c]].		scale _ (maxVal max: minVal negated) / 16000.0.  "Will scale all to -16k..16k: 15 bits"		outStream nextNumber: 4 put: scale asIEEE32BitWord.		"Copy scaled values, with run-coded sequences of 0's, to destByteArray"		nullCount _ 0.		cMin _ threshold / scale.		5 to: coeffs size do:			[:i | c _ (coeffs at: i) / scale.			c abs < cMin			ifTrue: ["Below threshold -- count nulls."					nullCount _ nullCount + 1]			ifFalse: ["Above threshold -- emit prior null count and this sample."					nullCount > 0 ifTrue:						[nullCount <= 112						ifTrue: [outStream nextNumber: 1 put: nullCount-1]						ifFalse: [outStream nextNumber: 2 put: (112*256) + nullCount-1].						nullCount _ 0].						val _ c asInteger + 16384 + 32768.  "Map -16k..16k into 32k..64k"						outStream nextNumber: 2 put: val]].					nullCount > 0 ifTrue:						[nullCount <= 112						ifTrue: [outStream nextNumber: 1 put: nullCount-1]						ifFalse: [outStream nextNumber: 2 put: (112*256) + nullCount-1]].		outFrameSize _ outStream position+1 - frameI - 2.  "Write frame size back at the beginning"		(WriteStream on: dstByteArray from: frameI to: dstByteArray size)			nextNumber: 2 put: outFrameSize.		frameBase _ frameBase + samplesPerFrame]."This displays a temporary indication of compression achieved"sm _ TextMorph new contents: (((frameBase - srcIndex) *2.0 / (outStream position+1 - dstIndex) truncateTo: 0.1) printString , ' : 1') asText allBold.sm position: Sensor cursorPoint + (-20@30).Display getCurrentMorphicWorld addMorph: sm.Display doOneCycleNowMorphic.sm delete.	outStream position > dstByteArray size ifTrue:		["The calling routine only provides buffer space for compression of 2:1 or better.  If you are just testing things, you can increase it to, eg, codeFrameSize _ frameSize*3, which would be sufficient for a threshold of 0 (lossless conversion)."		self error: 'Buffer overrun'].	^ Array with: frameBase - srcIndex			with: outStream position+1 - dstIndex! !!WiWPasteUpMorph methodsFor: 'initialization' stamp: 'RAA 5/24/2000 10:31'!hostWindow: x	hostWindow _ x.	worldState canvas: nil.	"safer to start from scratch"	self viewBox: hostWindow panelRect.! !!WiWPasteUpMorph methodsFor: 'initialization' stamp: 'RAA 5/25/2000 15:11'!viewBox: newViewBox	| vb |	worldState resetDamageRecorder.	"since we may have moved, old data no longer valid"	((vb _ self viewBox) == nil or: [vb ~= newViewBox])		ifTrue: [worldState canvas: nil].	worldState viewBox: newViewBox.	bounds _ newViewBox.	worldState assuredCanvas.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	worldState handsDo: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !!WiWPasteUpMorph methodsFor: 'activation' stamp: 'RAA 5/25/2000 15:11'!becomeTheActiveWorldWith: evt	| outerWorld |	World == self ifTrue: [^ self].	worldState resetDamageRecorder.	"since we may have moved, old data no longer valid"	hostWindow setStripeColorsFrom: Color green.	worldState canvas: nil.	"safer to start from scratch"	displayChangeSignatureOnEntry _ Display displayChangeSignature.	"Messy stuff to clear flaps from outer world"	Utilities globalFlapTabs do: [:f | f changed].	outerWorld _ World.	World _ self.		self installFlaps.	World _ outerWorld.		outerWorld displayWorld.	World _ self.	self viewBox: hostWindow panelRect.	self startSteppingSubmorphsOf: self.	self changed.	pendingEvent _ nil.	evt ifNotNil: [self primaryHand handleEvent: (evt setHand: self primaryHand)].! !!WiWPasteUpMorph methodsFor: 'activation' stamp: 'RAA 5/25/2000 15:11'!revertToParentWorldWithEvent: evt	"RAA 27 Nov 99 - if the display changed while we were in charge, parent may need to redraw"	worldState resetDamageRecorder.	"Terminate local display"	World _ parentWorld.	World assuredCanvas.	World installFlaps.	hostWindow setStripeColorsFrom: Color red.	(displayChangeSignatureOnEntry = Display displayChangeSignature) ifFalse: [		World fullRepaintNeeded; displayWorld	].	evt ifNotNil: [World restartWorldCycleWithEvent: evt].! !!WiWPasteUpMorph methodsFor: 'update cycle' stamp: 'RAA 5/25/2000 15:27'!doDeferredUpdating	"If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	self resetViewBox.	^ true! !!WiWPasteUpMorph methodsFor: 'update cycle' stamp: 'RAA 6/3/2000 09:49'!restartWorldCycleWithEvent: evt	"redispatch that click in outer world"	pendingEvent _ evt.	CurrentProjectRefactoring currentSpawnNewProcessAndTerminateOld: true! !!WiWPasteUpMorph methodsFor: 'drawing' stamp: 'RAA 5/25/2000 15:09'!invalidRect: damageRect	self isTheActiveWorld		ifTrue: [worldState recordDamagedRect: damageRect]		ifFalse: [super invalidRect: (damageRect intersect: bounds)]! !!WiWPasteUpMorph methodsFor: 'drawing' stamp: 'RAA 5/25/2000 08:04'!restoreDisplay	Display restoreMorphicDisplay.	"I don't actually expect this to be called"! !!WiWPasteUpMorph methodsFor: 'geometry' stamp: 'RAA 5/24/2000 10:50'!resetViewBox	| c |	(c _ worldState canvas) == nil ifTrue: [^self resetViewBoxForReal].	c form == Display ifFalse: [^self resetViewBoxForReal].	c origin = (0@0) ifFalse: [^self resetViewBoxForReal].	c clipRect extent = (self viewBox intersect: parentWorld viewBox) extent ifFalse: [^self resetViewBoxForReal].			! !!WiWPasteUpMorph methodsFor: 'geometry' stamp: 'RAA 6/6/2000 17:42'!resetViewBoxForReal	| newClip |	self viewBox ifNil: [^self].	newClip _ self viewBox intersect: parentWorld viewBox.	worldState canvas: (		Display getCanvas			copyOffset:  0@0			clipRect: newClip	)! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 15:45'!displayWorld	"RAA 27 Nov 99 - if we are not active, then the parent should do the drawing"	self flag: #bob.			"probably not needed"	World == self ifTrue: [^super displayWorld].	parentWorld ifNotNil: [^parentWorld displayWorld].	^super displayWorld		"in case MVC needs it"! !!MVCWiWPasteUpMorph methodsFor: 'initialization' stamp: 'RAA 5/25/2000 15:10'!viewBox: newViewBox	| vb |	worldState resetDamageRecorder.	"since we may have moved, old data no longer valid"	((vb _ self viewBox) == nil or: [vb ~= newViewBox])		ifTrue: [worldState canvas: nil].	worldState viewBox: newViewBox.	self bounds: newViewBox.		"works better here than simply storing into bounds"	worldState assuredCanvas.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	worldState handsDo: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !!MVCWiWPasteUpMorph methodsFor: 'activation' stamp: 'RAA 5/24/2000 10:30'!becomeTheActiveWorldWith: evt	worldState canvas: nil.	"safer to start from scratch"	self installFlaps.! !!MVCWiWPasteUpMorph methodsFor: 'drawing' stamp: 'RAA 5/24/2000 11:32'!invalidRect: damageRect	worldState recordDamagedRect: damageRect! !!MVCWiWPasteUpMorph methodsFor: 'geometry' stamp: 'RAA 5/24/2000 10:47'!resetViewBox	| c |	(c _ worldState canvas) == nil ifTrue: [^self resetViewBoxForReal].	c form == Display ifFalse: [^self resetViewBoxForReal].	c origin = (0@0) ifFalse: [^self resetViewBoxForReal].	c clipRect extent = self viewBox extent ifFalse: [^self resetViewBoxForReal].			! !!MVCWiWPasteUpMorph methodsFor: 'geometry' stamp: 'RAA 6/6/2000 17:15'!resetViewBoxForReal	self viewBox ifNil: [^self].	worldState canvas: (		(Display getCanvas)			copyOffset:  0@0			clipRect: self viewBox	)! !!WonderlandCameraMorph methodsFor: 'initialization' stamp: 'RAA 6/3/2000 10:56'!initialize	super initialize.	lastCursorPoint _ 0 @ 0.	CurrentProjectRefactoring currentAddGuard: self.	"Teddy"	self mode: #view.	self outline: POSimplePolygon new! !!WorldState methodsFor: 'initialization' stamp: 'RAA 5/25/2000 15:15'!initialize	hands _ Array new.	damageRecorder_ DamageRecorder new.	stepList _ OrderedCollection new.	lastStepTime _ 0.! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 5/24/2000 13:13'!checkIfUpdateNeeded	damageRecorder updateIsNeeded ifTrue: [^true].	hands do: [:h | (h hasChanged and: [h needsToBeDrawn]) ifTrue: [^true]].	^false  "display is already up-to-date"! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 6/6/2000 17:30'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: canvas].  "draw hands onto world canvas"	false ifTrue: [  "*make this true to flash damaged areas for testing*"		aWorld flashRects: allDamage color: Color black].	canvas finish.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [allDamage do: [:r | Display forceToScreen: r]]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 6/6/2000 17:30'!displayWorldAsTwoTone: aWorld submorphs: submorphs color: color	"Display the world in living black-and-white. (This is typically done to save space.)"	| f |	f _ ColorForm extent: aWorld viewBox extent depth: 1.	f colors: (Array with: color dominantColor with: Color black).	self canvas: f getCanvas.	"force the entire canvas to be redrawn"	aWorld fullRepaintNeeded.	self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "redraw on offscreen canvas"	canvas showAt: aWorld viewBox origin.  "copy redrawn areas to Display"	Display forceDisplayUpdate.	self canvas: nil.  "forget my canvas to save space"! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 5/24/2000 12:16'!displayWorldSafely: aWorld	"Update this world's display and keep track of errors during draw methods."	| oldHandler errCtx errMorph |	oldHandler _ Processor activeProcess errorHandler.	[aWorld displayWorld] ifError: [:err :rcvr |		"Handle a drawing error"		errCtx _ thisContext.		[			errCtx _ errCtx sender.			"Search the sender chain to find the morph causing the problem"			[errCtx notNil and:[(errCtx receiver isKindOf: Morph) not]] 				whileTrue:[errCtx _ errCtx sender].			"If we're at the root of the context chain then we have a fatal drawing problem"			errCtx == nil ifTrue:[^self handleFatalDrawingError: err].			errMorph _ errCtx receiver.			"If the morph causing the problem has already the #drawError flag set,			then search for the next morph above in the caller chain."			errMorph hasProperty: #errorOnDraw		] whileTrue.		errMorph setProperty: #errorOnDraw toValue: true.		"Install the old error handler, so we can re-raise the error"		Processor activeProcess errorHandler: oldHandler.		rcvr error: err.	].! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 6/6/2000 17:32'!doDeferredUpdatingFor: aWorld	| properDisplay |	"If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	properDisplay _ canvas notNil and: [canvas form == Display].	aWorld == World ifTrue: [  "this world fills the entire Display"		properDisplay ifFalse: [			aWorld viewBox: Display boundingBox.	"do first since it may clear canvas"			self canvas: Display getCanvas.		]	] ifFalse: [  "this world is inside an MVC window"		(properDisplay and: [canvas origin = aWorld viewBox origin]) ifFalse: [			self canvas:				(Display getCanvas					copyOffset: aWorld viewBox origin clipRect: aWorld viewBox)		]	].	^ true! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 5/24/2000 11:56'!doOneCycleFor: aWorld	self interCyclePause: MinCycleLapse.	self doOneCycleNowFor: aWorld.! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 5/24/2000 12:03'!doOneCycleInBackground	"Do one cycle of the interactive loop. This method is called repeatedly when this world is not the active window but is running in the background."self halt.		"not ready for prime time"	"process user input events, but only for remote hands"	self handsDo: [:h |		(h isKindOf: RemoteHandMorph) ifTrue: [			activeHand _ h.			h processEvents.			activeHand _ nil]].	self runStepMethods.	self displayWorldSafely.! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 6/7/2000 10:16'!doOneCycleNowFor: aWorld	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	self flag: #bob.		"need to consider remote hands in lower worlds"	"process user input events"	self handsDo: [:h |		activeHand _ h.		h processEvents.		activeHand _ nil	].	aWorld runStepMethods.		"there are currently some variations here"	self displayWorldSafely: aWorld.! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 5/24/2000 11:59'!doOneSubCycleFor: aWorld	"Like doOneCycle, but preserves activeHand."	| currentHand |	currentHand _ activeHand.	self doOneCycleFor: aWorld.	activeHand _ currentHand! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 6/10/2000 10:41'!drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas thatwere redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect |	rectList _ damageRecorder invalidRectsFullBounds: aWorld viewBox.	damageRecorder reset.	aWorld updateTrailsForm.	n _ submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	rectList do: [:r |		true		ifTrue:			["Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:				[mm _ submorphs at: i.				((mm fullBounds intersects: r) and: [mm visible]) ifTrue:					[morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]].				i _ i+1].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:				[c _ aWorld pseudoDraw: rectToFill on: aCanvas].			[morphs isEmpty] whileFalse:				[(rect _ rects removeLast) == rectToFill ifFalse:					[c _ aCanvas copyClipRect: (rectToFill _ rect)].				morphs removeLast fullDrawOn: c].			morphs reset.  rects reset]		ifFalse: [c _ aWorld pseudoDraw: r on: aCanvas.				submorphs reverseDo: [:m | m fullDrawOn: c]]		].	^ rectList! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 5/24/2000 10:16'!handleFatalDrawingError: errMsg	"Handle a fatal drawing error."	Smalltalk isMorphic ifFalse:[^self error: errMsg]. "Can still handle it from MVC"	Display deferUpdates: false. "Just in case"	self primitiveError: errMsg.	"Hm... we should jump into a 'safe' worldState here, but how do we find it?!!"! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 5/24/2000 10:54'!interCyclePause: milliSecs	"delay enough that the next interaction cycle won't happen too soon after the original; thus, if all the system is doing is polling for interaction, the overall CPU usage of Squeak will be low"	| currentTime wait |	currentTime _ Time millisecondClockValue.	lastCycleTime ifNotNil: [ 		wait _ lastCycleTime + milliSecs - currentTime.		wait > 0 ifTrue: [ 			wait < milliSecs  "big waits happen after a snapshot"				ifTrue: [DisplayScreen checkForNewScreenSize.						(Delay forMilliseconds: wait) wait ]. ]. ].	lastCycleTime _ currentTime! !!WorldState methodsFor: 'stepping' stamp: 'RAA 5/24/2000 11:09'!cleanseStepListForWorld: aWorld	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."	| deletions morphToStep |	deletions _ nil.	stepList do: [:entry |		morphToStep _ entry at: 1.		morphToStep world == aWorld			ifFalse:				[deletions ifNil: [deletions _ OrderedCollection new].				deletions addLast: morphToStep]].	deletions ifNotNil:		[deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].! !!WorldState methodsFor: 'stepping' stamp: 'RAA 6/7/2000 10:11'!runLocalStepMethodsIn: aWorld	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now deletions wakeupTime morphToStep |	stepList size = 0 ifTrue: [^ self].	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	deletions _ nil.	"Note: Put the following into an error handler to prevent errors happening on stepping"	[stepList do: [:entry |		wakeupTime _ entry at: 2.		morphToStep _ entry at: 1.		(morphToStep world == aWorld or: [(morphToStep ownerThatIsA: HandMorph) notNil])			ifTrue:				[wakeupTime <= now					ifTrue:						[morphToStep stepAt: now.						entry at: 2 put: now + morphToStep stepTime]]			ifFalse:				[deletions ifNil: [deletions _ OrderedCollection new]. 				deletions addLast: morphToStep]]]	 ifError: [:err :rcvr |		self stopStepping: morphToStep. "Stop this guy right now"		morphToStep setProperty: #errorOnStep toValue: true. "Remember stepping"		Processor activeProcess errorHandler: nil. "So we don't handle this guy twice"		rcvr error: err. "And re-raise the error from here so the stack is still valid"].	deletions ifNotNil:		[deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].	lastStepTime _ now! !!WorldState methodsFor: 'stepping' stamp: 'RAA 6/7/2000 10:14'!runStepMethodsIn: aWorld	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	self runLocalStepMethodsIn: aWorld.	aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ].! !!WorldState methodsFor: 'stepping' stamp: 'RAA 5/24/2000 11:25'!startStepping: aMorph	"Add the given morph to the step list. Do nothing if it is already being stepped."	(self isStepping: aMorph) ifTrue: [^self].	self adjustWakeupTimesIfNecessary.	stepList add:		(Array with: aMorph with: Time millisecondClockValue).! !!WorldState methodsFor: 'canvas' stamp: 'RAA 6/6/2000 17:29'!assuredCanvas	(canvas isNil or: [(canvas extent ~= viewBox extent) or: [canvas form depth ~= Display depth]])		ifTrue:			["allocate a new offscreen canvas the size of the window"			self canvas: (Display defaultCanvasClass extent: viewBox extent)].	^ self canvas! !!WorldState methodsFor: 'canvas' stamp: 'RAA 5/25/2000 15:12'!doFullRepaint	damageRecorder doFullRepaint! !!WorldState methodsFor: 'canvas' stamp: 'RAA 5/24/2000 11:31'!recordDamagedRect: damageRect	damageRecorder ifNotNil: [damageRecorder recordInvalidRect: damageRect]! !!WorldState methodsFor: 'canvas' stamp: 'RAA 5/25/2000 15:10'!resetDamageRecorder	damageRecorder reset! !!WorldState methodsFor: 'hands' stamp: 'RAA 5/24/2000 12:19'!activeHand: aHandMorph	"still needed until event loop with old code goes away"	activeHand _ aHandMorph! !!WorldState methodsFor: 'hands' stamp: 'RAA 5/24/2000 12:08'!addHand: aHandMorph	"Add the given hand to the list of hands for this world."	hands _ hands copyWith: aHandMorph.! !!WorldState methodsFor: 'hands' stamp: 'RAA 5/24/2000 10:13'!handsDo: aBlock	^ hands do: aBlock! !!WorldState methodsFor: 'hands' stamp: 'RAA 5/24/2000 12:09'!handsReverseDo: aBlock	^ hands reverseDo: aBlock! !!WorldState methodsFor: 'hands' stamp: 'RAA 5/24/2000 12:05'!removeHand: aHandMorph	"Remove the given hand from the list of hands for this world."	(hands includes: aHandMorph) ifFalse: [^self].	hands _ hands copyWithout: aHandMorph.	activeHand == aHandMorph ifTrue: [activeHand _ nil].! !!WorldState methodsFor: 'hands' stamp: 'RAA 5/24/2000 12:56'!selectHandsToDrawForDamage: damageList	"Select the set of hands that must be redrawn because either (a) the hand itself has changed or (b) the hand intersects some damage rectangle."	| result hBnds |	result _ OrderedCollection new.	hands do: [:h |		h needsToBeDrawn ifTrue: [			h hasChanged				ifTrue: [result add: h]				ifFalse: [					hBnds _ h fullBounds.					(damageList detect: [:r | r intersects: hBnds] ifNone: [nil])						ifNotNil: [result add: h]]]].	^ result! !!WorldState class methodsFor: 'class initialization' stamp: 'RAA 5/25/2000 15:15'!new	^super new initialize	! !!WorldWindow methodsFor: 'as yet unclassified' stamp: 'RAA 5/25/2000 08:15'!openInWorld: aWorld	"This msg and its callees result in the window being activeOnlyOnTop"	self bounds: (RealEstateAgent initialFrameFor: self world: aWorld).	self firstSubmorph position: (self left + 1) @ (self top + self labelHeight).	aWorld addMorph: self.	self activate.	aWorld startSteppingSubmorphsOf: self! !WorldState removeSelector: #damageRecorder!WorldState removeSelector: #displayWorldSafely!WorldState removeSelector: #doOneCycle!WorldState removeSelector: #doOneCycleNow!WorldState removeSelector: #doOneSubCycle!WorldState removeSelector: #hands:!WorldState removeSelector: #initForWorld!WorldState removeSelector: #lastCycleTime!WorldState removeSelector: #lastCycleTime:!WorldState removeSelector: #lastStepTime!WorldState removeSelector: #lastStepTime:!WorldState removeSelector: #stepList!WorldState removeSelector: #stepList:!!TheWorldMenu reorganize!('as yet unclassified' beIsolated changeBackgroundColor changeColorTarget:selector:originalColor: cleanUpWorld createStandardPartsBin detachableScriptingSpace inspectWorldModel launchCustomPartsBin loadProject lookForSlips menu: mvcProjectsAllowed newMorphOfClass:event: openChangeSorter1 openChangeSorter2 openEmail openFileList openIRC openMVCProject openMorphicProject openSelectorBrowser openTranscript openWorkspace printWorldOnFile propagateChanges quitSession readMorphFromAFile saveAndQuit saveSession saveWorldInFile setDisplayDepth splitNewMorphList:depth: startMessageTally startThenBrowseMessageTally world:project:hand: worldMenuHelp)('construction' alphabeticalMorphMenu appearanceMenu buildWorldMenu changesMenu colorForDebugging: debugMenu fillIn:from: helpMenu myMenuColor newMorph openMenu playfieldMenu projectMenu remoteMenu scriptingMenu windowsMenu)('action' doMenuItem: gridOnString menuColorString roundedCornersString soundEnablingString staggerPolicyString suppressFlapsString toggleFlapSuppressionInProject toggleWhetherToUseGlobalFlaps toggleWindowPolicy useGlobalFlapsString)('popups' appearanceDo changesDo debugDo doPopUp: helpDo openWindow playfieldDo projectDo remoteDo scriptingDo standardFontDo windowsDo)!!MenuMorph methodsFor: 'control' stamp: 'tk 7/20/2000 14:17'!notObsolete: aMenuItem	"Provide backward compatibility with messages being sent to the Hand.  Remove this when no projects made prior to 2.9 are likely to be used.  If this method and its call are removed early, the worst that can happen is a notifier when invoking an item in an obsolete menu."	(HandMorph canUnderstand: (aMenuItem selector)) ifTrue: [^ true]. 	"a modern one"	self inform: 'This world menu is obsolete.Please dismiss the menu and open a new one.'.	^ false! !!MenuMorph methodsFor: 'control' stamp: 'tk 7/20/2000 14:14'!invokeItem: aMenuItem event: evt	"Perform the action associated with the given menu item."	| sel target args selArgCount |	aMenuItem isEnabled ifFalse: [^ self].	lastSelection _ aMenuItem.	"to do: report lastSelection"	sel _ aMenuItem selector.	target _ aMenuItem target.	target class == HandMorph ifTrue: [(self notObsolete: aMenuItem) ifFalse: [^ self]].	args _ aMenuItem arguments.	selArgCount _ sel numArgs.	Cursor normal showWhile: [  "show cursor in case item opens a new MVC window"		selArgCount = 0			ifTrue: [target perform: sel]			ifFalse: [				selArgCount = args size					ifTrue: [target perform: sel withArguments: args]					ifFalse: [target perform: sel withArguments: (args copyWith: evt)]]].! !MenuMorph removeSelector: #notObsolete!Project class removeSelector: #activeProcess!Project initialize!Project removeSelector: #interruptName:!Project removeSelector: #leaveThisWorld!Project removeSelector: #maybeForkInterrupt!Project removeSelector: #resumeProcess:!Project removeSelector: #spawnNewProcess!Project removeSelector: #spawnNewProcessAndTerminateOld:!Project removeSelector: #spawnNewProcessIfThisIsUI:!PostscriptCanvas class removeSelector: #worldAsPostscriptRotated:!PasteUpMorph removeSelector: #adjustWakeupTimes!PasteUpMorph removeSelector: #adjustWakeupTimesIfNecessary!PasteUpMorph removeSelector: #canvas:!PasteUpMorph removeSelector: #damageRecorder!PasteUpMorph removeSelector: #doDeferredUpdating!PasteUpMorph removeSelector: #drawInvalidAreasOn:!PasteUpMorph removeSelector: #hands:!PasteUpMorph removeSelector: #interCyclePause:!PasteUpMorph removeSelector: #lastCycleTime!PasteUpMorph removeSelector: #lastCycleTime:!PasteUpMorph removeSelector: #lastStepTime!PasteUpMorph removeSelector: #lastStepTime:!PasteUpMorph removeSelector: #stepList!PasteUpMorph removeSelector: #stepList:!PasteUpMorph removeSelector: #stillAlive!PasteUpMorph removeSelector: #stillAlive:!MenuMorph removeSelector: #popUpAt:forHand:!HandMorph removeSelector: #absorbUpdatesFromServer!HandMorph removeSelector: #alphabeticalMorphMenu!HandMorph removeSelector: #appearanceDo!HandMorph removeSelector: #appearanceMenu!HandMorph removeSelector: #beIsolated!HandMorph removeSelector: #browseChangedMessages!HandMorph removeSelector: #changeBackgroundColor!HandMorph removeSelector: #changesDo!HandMorph removeSelector: #changesMenu!HandMorph removeSelector: #cleanUpWorld!HandMorph removeSelector: #debugDo!HandMorph removeSelector: #debugMenu!HandMorph removeSelector: #fileForRecentLog!HandMorph removeSelector: #helpDo!HandMorph removeSelector: #helpMenu!HandMorph removeSelector: #inspectWorldModel!HandMorph removeSelector: #loadProject!HandMorph removeSelector: #newMorph!HandMorph removeSelector: #newMorphOfClass:event:!HandMorph removeSelector: #openBrowser!HandMorph removeSelector: #openChangeSorter:!HandMorph removeSelector: #openChangesLog!HandMorph removeSelector: #openEmail!HandMorph removeSelector: #openFileList!HandMorph removeSelector: #openIRC!HandMorph removeSelector: #openMVCProject!HandMorph removeSelector: #openMenu!HandMorph removeSelector: #openMorphicProject!HandMorph removeSelector: #openRecentChanges!HandMorph removeSelector: #openSelectorBrowser!HandMorph removeSelector: #openTranscript!HandMorph removeSelector: #openWebBrowser!HandMorph removeSelector: #openWindow!HandMorph removeSelector: #openWorkspace!HandMorph removeSelector: #openWorldInWindow!HandMorph removeSelector: #playfieldDo!HandMorph removeSelector: #playfieldMenu!HandMorph removeSelector: #printWorldOnFile!HandMorph removeSelector: #projectDo!HandMorph removeSelector: #projectMenu!HandMorph removeSelector: #propagateChanges!HandMorph removeSelector: #quitSession!HandMorph removeSelector: #readMorphFromAFile!HandMorph removeSelector: #remoteDo!HandMorph removeSelector: #remoteMenu!HandMorph removeSelector: #saveAndQuit!HandMorph removeSelector: #saveAs!HandMorph removeSelector: #saveSession!HandMorph removeSelector: #saveWorldInFile!HandMorph removeSelector: #scriptingDo!HandMorph removeSelector: #scriptingMenu!HandMorph removeSelector: #setDisplayDepth!HandMorph removeSelector: #splitNewMorphList:depth:!HandMorph removeSelector: #standardFontDo!HandMorph removeSelector: #startMessageTally!HandMorph removeSelector: #startThenBrowseMessageTally!HandMorph removeSelector: #unlockContents!HandMorph removeSelector: #unlockWorldContents!HandMorph removeSelector: #windowsDo!HandMorph removeSelector: #windowsMenu!HandMorph removeSelector: #worldMenuHelp!"Postscript:"Project uiProcess.		"get class var initialized"!