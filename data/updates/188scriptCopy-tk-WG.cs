'From Squeak 2.1 of June 30, 1998 on 13 August 1998 at 5:13:44 pm'!!Parser methodsFor: 'error correction' stamp: 'tk 8/11/1998 21:52'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction fullSearch: tryHard 	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ tryHard		ifFalse: [ Symbol possibleSelectorsFor: proposedKeyword ]		ifTrue: [ Symbol morePossibleSelectorsFor: proposedKeyword ].	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).	tryHard ifFalse:		[aStream cr; nextPutAll: 'try harder'.		lines _ lines copyWith: (alternatives size + firstLine + 1)].		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	tryHard not & (choice > lines last) ifTrue:		[^ self correctSelector: proposedKeyword wordIntervals: spots				exprInterval: expInt ifAbort: abortAction fullSearch: true ]. 	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	((proposedKeyword last ~~ $:) and: [correctSelector last == $:]) ifTrue: [		^ abortAction value].	^ correctSelector.! !!PartsBinMorph methodsFor: 'extraction support' stamp: 'tk 8/13/1998 16:52'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. Otherwise, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner = self ifTrue:			[^ openToDragNDrop				ifTrue: [root]				ifFalse: [root fullCopy isPartsDonor: false]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'tk 8/8/1998 17:41'!repelsMorph: aMorph event: ev	isPartsBin == true ifTrue: [^ true].	openToDragNDrop ifFalse: [^ true].	((Preferences valueOfFlag: #SystemWindowsDroppable) not and: [		aMorph isKindOf: SystemWindow]) ifTrue: [^ false].	(self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].	^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'tk 8/8/1998 17:42'!wantsDroppedMorph: aMorph event: evt^ ((self openToDragNDrop and: [self isPartsBin not]) and: [	self bounds containsPoint: evt cursorPoint]) and: [		((Preferences valueOfFlag: #SystemWindowsDroppable) not and: [			aMorph isKindOf: SystemWindow]) not]! !!StandardSystemView methodsFor: 'framing' stamp: 'tk 8/11/1998 16:22'!expand	"If the receiver is collapsed, change its view to be that of all of its 	subviews, not its label alone. "	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame expandBy: borderWidth.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews _ nil.			self setWindow: nil.			self resizeTo: newFrame.			self displayDeEmphasized.			model modelWakeUp]! !!Symbol class methodsFor: 'access' stamp: 'tk 8/11/1998 22:12'!possibleSelectorsFor: misspelled	"Answer an ordered collection of possible corrections for the misspelled selector in order of likelyhood."	| numArgs table lookupString list binary |	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs _ lookupString numArgs.	numArgs < 0 ifTrue: [ ^ OrderedCollection new: 0 ].	table _ (SelectorTables at: (numArgs + 1 min: SelectorTables size))				at: (lookupString at: 1) asciiValue - "($a asciiValue - 1)" 96.	list _ lookupString correctAgainst: table.	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [		binary _ misspelled, ':'.		"try for missing colon"		Symbol hasInterned: binary ifTrue: [:him | list addFirst: him]].	^ list! !