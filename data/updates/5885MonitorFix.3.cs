'From Squeak3.7beta of ''1 April 2004'' [latest update: #5878] on 14 April 2004 at 1:13:21 pm'!Object subclass: #Monitor	instanceVariableNames: 'mutex ownerProcess defaultQueue queueDict queuesMutex nestingLevel '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!Delay subclass: #MonitorDelay	instanceVariableNames: 'monitor queue'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!MonitorDelay commentStamp: 'NS 4/13/2004 16:51' prior: 0!This is a specialization of the class Delay that is used for the implementation of the class Monitor.!!Monitor methodsFor: 'synchronization' stamp: 'NS 4/14/2004 13:13'!critical: aBlock	"Critical section.	Executes aBlock as a critical section. At any time, only one process can be executing code 	in a critical section.	NOTE: All the following synchronization operations are only valid inside the critical section 	of the monitor!!"	| result |	[self enter.	result _ aBlock value] ensure: [self exit].	^ result.! !!Monitor methodsFor: 'signaling-specific' stamp: 'NS 4/13/2004 15:12'!signal: aSymbolOrNil	"One process waiting for the given event is woken up. If there is no process waiting 	for this specific event, a process waiting for the default event gets resumed."	| queue |	self checkOwnerProcess.	queue _ self queueFor: aSymbolOrNil.	queue isEmpty ifTrue: [queue _ self defaultQueue].	self signalQueue: queue.! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 13:40'!checkOwnerProcess	self isOwnerProcess		ifFalse: [self error: 'Monitor access violation'].! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 13:37'!enter	self isOwnerProcess ifTrue: [		nestingLevel _ nestingLevel + 1.	] ifFalse: [		mutex wait.		ownerProcess _ Processor activeProcess.		nestingLevel _ 1.	].! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 13:38'!exit	nestingLevel _ nestingLevel - 1.	nestingLevel < 1 ifTrue: [		ownerProcess _ nil.		mutex signal	].! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 16:32'!exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil	| lock delay |	queuesMutex 		critical: [lock _ anOrderedCollection addLast: Semaphore new].	self exit.	anIntegerOrNil isNil ifTrue: [		lock wait	] ifFalse: [		delay _ MonitorDelay signalLock: lock afterMSecs: anIntegerOrNil inMonitor: self queue: anOrderedCollection.		lock wait.		delay unschedule.	].	self enter.! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 16:14'!privateCleanup	queuesMutex critical: [		defaultQueue isEmpty ifTrue: [defaultQueue _ nil].		queueDict ifNotNil: [			queueDict copy keysAndValuesDo: [:id :queue | 				queue isEmpty ifTrue: [queueDict removeKey: id]].			queueDict isEmpty ifTrue: [queueDict _ nil].		].	].! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 16:10'!signalAllInQueue: anOrderedCollection	queuesMutex critical: [		anOrderedCollection do: [:lock | lock signal].		anOrderedCollection removeAllSuchThat: [:each | true].	].! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 16:34'!signalLock: aSemaphore inQueue: anOrderedCollection	queuesMutex critical: [		aSemaphore signal.		anOrderedCollection remove: aSemaphore ifAbsent: [].	].! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 16:10'!signalQueue: anOrderedCollection	queuesMutex critical: [		anOrderedCollection isEmpty ifTrue: [^ self].		anOrderedCollection removeFirst signal.	].! !!Monitor methodsFor: 'initialize-release' stamp: 'NS 4/13/2004 16:12'!initialize	mutex _ Semaphore forMutualExclusion.	queuesMutex _ Semaphore forMutualExclusion.	nestingLevel _ 0.! !!MonitorDelay methodsFor: 'private' stamp: 'NS 4/13/2004 16:26'!setDelay: anInteger forSemaphore: aSemaphore monitor: aMonitor queue: anOrderedCollection	monitor _ aMonitor.	queue _ anOrderedCollection.	self setDelay: anInteger forSemaphore: aSemaphore.! !!MonitorDelay methodsFor: 'private' stamp: 'NS 4/13/2004 16:22'!signalWaitingProcess	"The delay time has elapsed; signal the waiting process."	beingWaitedOn _ false.	monitor signalLock: delaySemaphore inQueue: queue.! !!MonitorDelay class methodsFor: 'instance creation' stamp: 'NS 4/13/2004 16:25'!signalLock: aSemaphore afterMSecs: anInteger inMonitor: aMonitor queue: anOrderedCollection	anInteger < 0 ifTrue: [self error: 'delay times cannot be negative'].	^ (self new setDelay: anInteger forSemaphore: aSemaphore monitor: aMonitor queue: anOrderedCollection) schedule! !Monitor removeSelector: #clearOwnerProcess!Monitor removeSelector: #lastSemaphoreInQueue:!Monitor removeSelector: #normalizeQueue:!Monitor removeSelector: #normalizeQueueAndReturnIfEmpty:!Monitor removeSelector: #setOwnerProcess!Object subclass: #Monitor	instanceVariableNames: 'mutex ownerProcess nestingLevel defaultQueue queueDict queuesMutex'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!