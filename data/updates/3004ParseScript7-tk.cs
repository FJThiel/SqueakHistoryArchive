'From Squeak2.9alpha of 16 June 2000 [latest update: #3049] on 30 November 2000 at 11:41:46 am'!!LiteralNode methodsFor: 'tiles' stamp: 'tk 11/29/2000 13:32'!asMorphicSyntaxIn: parent	| row |	row _ parent addColumn: #literal on: self.	(key isMemberOf: Association) ifFalse: [		row layoutInset: 1.		^ row addMorphBack: (row addString: key storeString)].	key key isNil ifTrue: [		^ row addTextRow: ('###',key value soleInstance name)	] ifFalse: [		^ row addTextRow: ('##', key key)	].	! !!Player methodsFor: 'scripts-kernel' stamp: 'tk 11/30/2000 11:26'!newScriptorAround: aPhraseTileMorph	"Sprout a scriptor around aPhraseTileMorph, thus making a new script"	| aScriptEditor aUserScript ut tw blk |	self isFlagshipForClass ifFalse:		[self flag: #deferred.  "This really has to change, esp in card world"		^ aPhraseTileMorph].	aUserScript _ self class permanentUserScriptFor: self unusedScriptName player: self.	aScriptEditor _ aUserScript instantiatedScriptEditor.	ut _ costume world valueOfProperty: #universalTiles ifAbsent: [false].	ut ifTrue: [aScriptEditor install.	"to get a default script there"		aScriptEditor useNewTiles.		aPhraseTileMorph ifNotNil: [			tw _ aScriptEditor findA: TwoWayScrollPane.			blk _ tw scroller firstSubmorph "MethodNode" lastSubmorph "BlockNode".			blk addMorphFront: aPhraseTileMorph.			"aPhraseTileMorph position: self topLeft + (7@14)"			aPhraseTileMorph accept]]		ifFalse: [			aPhraseTileMorph 				ifNotNil: [aScriptEditor phrase: aPhraseTileMorph]	"does an install"				ifNil: [aScriptEditor install]].	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'tk 11/30/2000 11:16'!showSourceInScriptor	"Remove tile panes, if any, and show textual source instead"	| aCodePane |	self isTextuallyCoded ifFalse: [self becomeTextuallyCoded].		"Mostly to fix up grandfathered ScriptEditors"	self submorphs allButFirst do: [:m | m delete].	aCodePane _ MethodHolder isolatedCodePaneForClass: playerScripted class selector: scriptName.	showingMethodPane _ true.	self addMorphBack: aCodePane.	(Display bestGuessOfCurrentWorld valueOfProperty: #universalTiles ifAbsent: [false]) 		ifTrue: [self useNewTilesNow].	"grab aCodePane, get model, and remove it" 	self currentWorld startSteppingSubmorphsOf: self! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 11/30/2000 10:59'!useNewTiles	"At the next request for textual script, use new tiles instead.  Make that request."	Display bestGuessOfCurrentWorld setProperty: #universalTiles toValue: true.	 	"for all scriptors and viewers"	Preferences enable: #capitalizedReferences.	self showSourceInScriptor. ! !!StringMorphEditor methodsFor: 'all' stamp: 'tk 11/29/2000 13:54'!keyStroke: evt	"This is hugely inefficient, but it seems to work, and it's unlikely it will ever need	to be any more efficient -- it's only intended to edit single-line strings."	| char priorEditor oldSel newSel |	(((char _ evt keyCharacter) = Character enter) or: [(char = Character cr)			or: [char = $s and: [evt commandKeyPressed]]])				ifTrue: [owner doneWithEdits; acceptContents.	self flag: #arNote. "Probably unnecessary"						evt hand releaseKeyboardFocus.						^ self delete].		(char = $l and: [evt commandKeyPressed]) ifTrue:   "cancel"		[owner cancelEdits.		evt hand releaseKeyboardFocus.		^ self delete].	oldSel _ self editor selectionInterval.	super keyStroke: evt.	owner interimContents: self contents asString.	newSel _ self editor selectionInterval.	priorEditor _ self editor.  "Save editor state"	self releaseParagraph.  "Release paragraph so it will grow with selection."	self paragraph.      "Re-instantiate to set new bounds"	self installEditorToReplace: priorEditor.  "restore editor state"	oldSel = newSel ifTrue:		["There is a bug that causes characters to be misplaced when the second		character typed is wider than the first.  This fixes it (ugh)."		self editor selectFrom: newSel first + 1 to: newSel last + 1].! !!SyntaxMorph methodsFor: 'initialization' stamp: 'tk 11/28/2000 19:57'!openInWindow	| window widget sel |	sel _ ''.	self firstSubmorph allMorphs do: [:rr | 			(rr isKindOf: StringMorph) ifTrue: [sel _ sel, rr contents]].	window _ (SystemWindow labelled: 'Tiles for ', self parsedInClass printString, '>>',sel).	widget _ self inAScrollPane.	window		addMorph: widget		frame: (0@0 extent: 1.0@1.0).	window openInWorldExtent: (		self extent + (20@40) min: (Display boundingBox extent * 0.8) rounded	)! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 11/29/2000 13:39'!cleanupAfterItDroppedOnMe	"A tile just dropped into me.  Clean up"	self layoutChanged.	"Auto-accept on drop if in a scriptor"	self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 11/30/2000 11:30'!morphToDropInPasteUp: aPasteUp	| actualObject itsSelector aScriptor anEditor adjustment handy tw blk |	"If property #beScript is true, create a scriptor around me."	(self valueOfProperty: #beScript ifAbsent: [false]) ifFalse: [^ self].	self removeProperty: #beScript.	(actualObject _ self actualObject) ifNil: [^ self].	actualObject assureUniClass.	itsSelector _ self userScriptSelector.	aScriptor _ (itsSelector ~~ nil and: [itsSelector size > 0])		ifTrue:	"user script"			[actualObject isFlagshipForClass				ifFalse: 					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: self.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					[(aPasteUp world valueOfProperty: #universalTiles ifAbsent: [false]) not &					(actualObject class userScriptForPlayer: actualObject selector: itsSelector) 						isTextuallyCoded ifTrue:							[^ aPasteUp scriptorForTextualScript: itsSelector ofPlayer: actualObject].					adjustment _ 0@0.					aScriptor _ actualObject scriptEditorFor: itsSelector]]		ifFalse:			["It's a system-defined selector; construct an anonymous scriptor around it"			itsSelector _ nil.			adjustment _ 60 @ 20.			actualObject newScriptorAround: self].	handy _ aPasteUp primaryHand.	aScriptor ifNotNil: [		aScriptor position: handy position - adjustment.		aPasteUp addMorphFront: aScriptor.	"do this early so can find World"		(tw _ aScriptor findA: TwoWayScrollPane) ifNil: [			aScriptor useNewTiles.			itsSelector ifNil: ["blank script"				tw _ aScriptor findA: TwoWayScrollPane.				blk _ tw scroller firstSubmorph "MethodNode" lastSubmorph "BlockNode".				blk addMorphFront: self.				"self position: self topLeft + (7@14)"]]].	aScriptor showSourceInScriptor. 	(aScriptor isMemberOf: ScriptEditorMorph) ifTrue:		[aScriptor playerScripted expungeEmptyUnRenamedScripts].	^ aScriptor ifNil: [self]! !!SyntaxMorph methodsFor: 'selection' stamp: 'tk 11/29/2000 13:48'!wantsKeyboardFocusFor: aSubmorph	"only let strings edit on shift-click.  Editing on ordinary click defeats the brown selection and tile dragging."	^ self world primaryHand lastEvent shiftPressed! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 11/28/2000 20:19'!addBlockArg: aMorph	"Add a temporary to a block or the method.  Return true if succeed"	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	"***NOTE: This method should be combined with addTempVar:"	| tempHolder tt var nn |	owner isMethodNode ifTrue: [		^ (self addTempVar: aMorph)].	"Node for them is not inside the block"		"If exists, drop the temp in this block and let use extend it."	tt _ self firstSubmorph.	tempHolder _ tt firstSubmorph isSyntaxMorph 				ifTrue: [(tt nodeClassIs: BlockArgsNode) 							ifTrue: [tt] ifFalse: [nil]]				ifFalse: [nil].	nn _ aMorph parseNode key.	"name"	tempHolder ifNil: ["make whole row"		tempHolder _ self addRow: #blockarg1 on: (BlockArgsNode new).		self addMorphFront: tempHolder.		aMorph parseNode name: nn key: nn code: nil.		var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.		var layoutInset: 1.		var addMorphBack: (self addString: nn).		self cleanupAfterItDroppedOnMe.		^ true].	tempHolder submorphsDo:		[:m | "if present. caller adds the temp as a new line of code to be extended"		m isSyntaxMorph and: [m parseNode key = nn ifTrue: [^ false]]].			"If this variable is not present, add it"	aMorph parseNode name: nn key: nn code: nil.	tempHolder addMorphBack: (tempHolder transparentSpacerOfSize: 4@4).	var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.	var layoutInset: 1.	var addMorphBack: (StringMorph contents: nn).	var cleanupAfterItDroppedOnMe.	^ true! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 11/29/2000 14:06'!addString: literalOrVarName	| sMorph |	"Create and return an UpdatingStringMorph containing the value.  Use an UpdatingStringMorph, so it can inform its owner when it has been edited."	sMorph _ UpdatingStringMorph contents: literalOrVarName.	sMorph target: self; putSelector: #acceptIgnoring:; useStringFormat.	"keep the getSelector being nil"	^ sMorph! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 11/28/2000 20:21'!addTempVar: aMorph 	"know we are a block inside a MethodNode" 	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	| tempHolder ii tt var nn |	tempHolder _ (ii _ owner submorphIndexOf: self) = 1				ifFalse: [tt _ owner submorphs at: ii - 1.						(tt isSyntaxMorph and: [tt nodeClassIs: MethodTempsNode])					 		ifTrue: [tt] ifFalse: [nil]]				ifTrue: [nil].	nn _ aMorph parseNode key.	"name"	tempHolder ifNil: [		tempHolder _ owner addRow: #tempVariable on: MethodTempsNode new.		owner addMorph: tempHolder inFrontOf: self.		aMorph parseNode name: nn key: nn code: nil.		aMorph parseNode asMorphicSyntaxIn: tempHolder.		tempHolder cleanupAfterItDroppedOnMe.		^ true].	tempHolder submorphsDo:		[:m | m isSyntaxMorph and: [m parseNode key = nn ifTrue: [^ false]]].	aMorph parseNode name: nn key: nn code: nil.	tempHolder addMorphBack: (tempHolder transparentSpacerOfSize: 4@4).	var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.	var layoutInset: 1.	var addMorphBack: (self addString: nn).	var cleanupAfterItDroppedOnMe.	^ true! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 11/28/2000 20:22'!addTextRow: aStringLikeItem	| row |	(row _ self class row: #text on: nil) borderWidth: 1.	row addMorph: (self addString: (aStringLikeItem copyWithout: Character cr)).	self addMorphBack: row.	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 11/28/2000 20:22'!addToken: aString type: aColorOrSymbol on: aNode	^ (self addColumn: aColorOrSymbol on: aNode)		layoutInset: 1;		addMorphBack: (self addString: aString)! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 11/28/2000 20:05'!printOn: strm indent: level 	| lev nodeClass first |	"Tree walk and produce text of the code.  #ST80.  Just do it in one big ugly method."	lev _ level.	(nodeClass _ parseNode class) == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner isMethodNode ifFalse: [strm nextPut: $[.  lev _ lev+1]]].				"normal block has []"	nodeClass == MessageNode ifTrue: [		color = (SyntaxMorph translateColor: #message) ifTrue: [strm nextPut: $( ]].	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; space].	first _ true.	submorphs do: [:sub |		sub isSyntaxMorph ifTrue: [			nodeClass == CascadeNode & first not ifTrue: [				color = (SyntaxMorph translateColor: #cascade2) ifTrue: [strm nextPut: $;; space ]].			nodeClass == BlockArgsNode ifTrue: [strm nextPut: $:].			sub printOn: strm indent: lev.			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not	& 				(sub parseNode class == ReturnNode) not					ifTrue: [strm nextPut: $.].			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not					ifTrue: [strm crtab: lev]				ifFalse: [self isMethodNode ifTrue: [strm crtab: lev] ifFalse: [strm space]].			first _ false].		(sub isKindOf: StringMorph) ifTrue: [strm nextPutAll: sub contents].		"return indent for ifTrue: ifFalse:"].	nodeClass == MessageNode ifTrue: [		color = (SyntaxMorph translateColor: #message) ifTrue: [strm nextPut: $) ]].	nodeClass  == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner isMethodNode ifFalse: [strm nextPut: $] ]]].				"normal block has []"	nodeClass == BlockArgsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodNode ifTrue: [		strm contents last "ugh!!" == $. ifTrue: [strm skip: -1]].	"erase last period"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/28/2000 19:55'!changeSound: upDown	| ind arg st soundChoices index it current |	"move in the list of sounds.  Adjust arg tile after me"	ind _ owner submorphs indexOf: self.	arg _ owner submorphs atWrap: ind+1.	arg isSyntaxMorph ifFalse: [^ self].	st _ arg submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	soundChoices _ #('silence').  "default, if no SampledSound class"	Smalltalk at: #SampledSound ifPresent:		[:sampledSound | soundChoices _ sampledSound soundNames].	current _ st contents copyFrom: 2 to: st contents size-1.	"remove string quotes"	index _ soundChoices indexOf: current.	index > 0 ifTrue:		[st contents: (it _ soundChoices atWrap: index + upDown) printString.		self playSoundNamed: it].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/28/2000 19:56'!event: evt arrow: arrowMorph upDown: delta		| st aList index now want instVar |	st _ submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	(self nodeClassIs: LiteralNode) ifTrue: [ "+/- 1"		st contents: (self decompile asNumber + delta) printString.		^ self acceptIfInScriptor.	"maybe set parseNode's key"].	(self nodeClassIs: VariableNode) ifTrue: [ "true/false"		st contents: (self decompile asString = 'true') not printString.		^ self acceptIfInScriptor.	"maybe set parseNode's key"].	(self nodeClassIs: SelectorNode) ifTrue: [		aList _ #(+ - * / // \\ min: max:).		index _ aList indexOf: self decompile asString.		index  > 0 ifTrue: [			self setBalloonText: 				(ScriptingSystem helpStringForOperator: (aList atWrap: index + delta)).			st contents: (aList atWrap: index + 1).			^ self acceptIfInScriptor].		aList _ #(= ~= > >= isDivisibleBy: < <=).		index _ aList indexOf: self decompile asString.		index  > 0 ifTrue: [			self setBalloonText: 				(ScriptingSystem helpStringForOperator: (aList atWrap: index + delta)).			st contents: (aList atWrap: index + 1).			^ self acceptIfInScriptor].		"rec or arg type = #number 				ifFalse: [^ st contents: (#(= ~=) atWrap: index + delta)]."		'beep:' = self decompile asString ifTrue: ["replace sound arg"			self changeSound: delta.			^ self acceptIfInScriptor].		].	(self nodeClassIs: SelectorNode) ifTrue: ["kinds of assignment"		((now _ self decompile asString) beginsWith: 'set') ifTrue: ["a setX: 3"			want _ 1+delta.  instVar _ (now allButFirst: 3) allButLast].		(now endsWith: 'IncreaseBy:') ifTrue: ["a xIncreaseBy: 3      a setX: (a getX +3)."			want _ 2+delta.  instVar _ now allButLast: 11].		(now endsWith: 'DecreaseBy:') ifTrue: ["a xDecreaseBy: 3      a setX: (a getX -3)."			want _ 3+delta.  instVar _ now allButLast: 11].		(now endsWith: 'MultiplyBy:') ifTrue: ["a xMultiplyBy: 3      a setX: (a getX *3)."			want _ 4+delta.  instVar _ now allButLast: 11].		want ifNil: [^ self].		instVar _ instVar asLowercase.		want _ #(1 2 3 4) atWrap: want.		want = 1 ifTrue: [st contents: 'set', instVar capitalized, ':'].	"setter method is present"		want = 2 ifTrue: [st contents: instVar, 'IncreaseBy:'].			"notUnderstood will create the method if needed"		want = 3 ifTrue: [st contents: instVar, 'DecreaseBy:'].			"notUnderstood will create the method if needed"		want = 4 ifTrue: [st contents: instVar, 'MultiplyBy:'].			"notUnderstood will create the method if needed"				^ self acceptIfInScriptor].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/28/2000 14:12'!offerPopUp	"Put up a halo to allow user to change Literals (Integer, true), Selector (beep: sound, +,-,*,//,\\, r:g:b:, setX: incX: decX: for any X,), Variable (Color),    not AssignmentNode (_ inc dec), 	Extend arrows on each literal, variable, and message, (block that is by itself).	Retract arrows on each literal or variable, or message or block that is an argument.	Any literal can be changed by Shift-clicking and typing."	| panel any upDown retract extend colorPatch edge outside |	(self hasProperty: #myPopup) ifTrue: [^ self].  "already has one"	((outside _ self rootTile owner) isKindOf: AlignmentMorph) ifTrue: [^ self].	  "can't put panel in right place"	any _ false.	(upDown _ self upDownArrows) ifNotNil: [any _ true].	(retract _ self retractArrow) ifNotNil: [any _ true].	(extend _ self extendArrow) ifNotNil: [any _ true].	(colorPatch _ self colorPatch) ifNotNil: [any _ true].	any ifFalse: [^ self].	panel _ RectangleMorph new color: Color transparent; borderWidth: 0.	upDown ifNotNil: [		panel addMorphBack: upDown first.		upDown first align: upDown first topLeft with: panel topLeft.		panel addMorphBack: upDown second.		upDown second align: upDown second topLeft with: upDown first bottomLeft].	colorPatch ifNotNil: [		panel addMorphBack: colorPatch.		colorPatch align: colorPatch topLeft 					with: panel topLeft].	retract ifNotNil: [		edge _ panel submorphs size = 0 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: retract.		retract align: retract topLeft with: (edge+2) @ (panel top + 3)].	extend ifNotNil: [		edge _ panel submorphs size = 0 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: extend.		extend align: extend topLeft with: (edge+2) @ (panel top + 3)].	panel on: #mouseLeave send: #maybeDeletePopup: to: self.	panel align: panel topLeft with: self topRight.	panel extent: panel submorphs last bottomRight - panel topLeft.	self setProperty: #myPopup toValue: panel.	outside addMorphFront: panel.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 11/28/2000 20:32'!retract	| rec |	"replace this message with its receiver.  I am the message node."	rec _ submorphs detect: [:mm | mm isSyntaxMorph] ifNone: [^ nil].	(rec nodeClassIs: MessagePartNode) ifTrue: [^ nil].	self valueOfProperty: #myPopup ifPresentDo:		[:panel | panel delete. self removeProperty: #myPopup].	owner replaceSubmorph: self by: rec.	rec acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 11/29/2000 14:08'!accept	"Turn my current state into the text of a method.  Compile it in my class."	| cls |	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ self].  "not in a script"		^ self rootTile accept  "always accept at the root"].	(cls _ self parsedInClass) ifNil: [^ self].	cls compile: self decompile notifying: nil.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 11/28/2000 20:09'!acceptIgnoring: aString	"If I am inside a ScriptEditorMorph, tell my root to accept the new changes.  Ignore the argument, which is the string whose conents just changed."	self acceptIfInScriptor! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'tk 11/29/2000 13:54'!lostFocusWithoutAccepting	"The message is sent when the user, having been in an editing episode on the receiver, changes the keyboard focus -- typically by clicking on some editable text somewhere else -- without having accepted the current edits."	self autoAcceptOnFocusLoss ifTrue: [self doneWithEdits; acceptContents]! !