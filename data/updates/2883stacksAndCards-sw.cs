'From Squeak2.9alpha of 5 August 2000 [latest update: #2925] on 31 October 2000 at 8:50:07 pm'!"Change Set:		stacksAndCardsDate:			31 October 2000Author:			Scott WallaceBrings a simple stack-and-card architecture to Morphic.  And a few other things, including:¥ Option to see textual source in place in Scriptor.¥ Finder-like list views in pasteup morphs.¥ Viewer for any object.¥ Scriptable buttons, with scripts residing as methods of the containing 'background' uniclass, and with all salient aspects (including when to act) controllable from the viewer.¥ A new reference scheme, whereby object references in user scripts can be made to look 'right', as in	Car turnBy: Steer heading(To turn on the new reference scheme, set the preference #capitalizedReferences to true.)¥ New 'viewing' halo handle for Playfields.¥ New 'choose new graphic' halo handle for Sketchs."Smalltalk at: #References put: IdentityDictionary new.!AlignmentMorph subclass: #ObjectRepresentativeMorph	instanceVariableNames: 'objectRepresented '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!ObjectRepresentativeMorph subclass: #ClassRepresentativeMorph	instanceVariableNames: 'classRepresented '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!ObjectRepresentativeMorph subclass: #ListViewLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!BorderedMorph subclass: #PasteUpMorph	instanceVariableNames: 'presenter model cursor padding backgroundMorph turtleTrailsForm turtlePen lastTurtlePositions isPartsBin autoLineLayout indicateCursor resizeToFit wantsMouseOverHalos worldState griddingOn '	classVariableNames: 'DisableDeferredUpdates MinCycleLapse StillAlive '	poolDictionaries: ''	category: 'Morphic-Worlds'!Model subclass: #Player	instanceVariableNames: 'costume costumes '	classVariableNames: 'BiggestSubclassNumber TimeOfError '	poolDictionaries: 'References '	category: 'Morphic-Scripting'!Player subclass: #CardPlayer	instanceVariableNames: 'privateMorphs '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Stacks'!!CardPlayer commentStamp: '<historical>' prior: 0!CardPlayer	Instance variables of the Uniclass represent the data in the "fields" of each card in the stack.	Each Instance variable is some kind of value holder.	The code for the *buttons* on the background resides in the CardPlayer uniclass.	!CardPlayer class	instanceVariableNames: 'variableDocks '!AlignmentMorph subclass: #ScriptEditorMorph	instanceVariableNames: 'scriptName firstTileRow timeStamp playerScripted handWithTile showingMethodPane '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!Object subclass: #SlotInformation	instanceVariableNames: 'type documentation floatPrecision variableDock variableDefinition '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!BookMorph subclass: #StackMorph	instanceVariableNames: 'cards '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Stacks'!!StackMorph commentStamp: 'sw 5/11/2000 11:46' prior: 0!The instance variables of interest here -- some are presently inherited from PasteupMoprh --dataInstances            this is the stack's entire data-basebackgroundscurrentDataInstance    Points to an element of dataInstancesuserFrameRectangleThe primary abstraction here iis the Background and its instances.  I'd like to call this thing, which is kind of a Stack and a kind of database, The Background definition is the PlayfieldWe swap playfields in a Book.  Therefore, a Stack is like a book and a Playfield is like a background.!Object subclass: #StandardScriptingSystem	instanceVariableNames: ''	classVariableNames: 'ClassVarNamesInUse CustomPartsBin FormDictionary HelpStrings ReservedScriptNames StandardPartsBin StandardSlotInfo SystemSlotDictionary TypeColorDictionary '	poolDictionaries: ''	category: 'Morphic-Scripting'!TileMorph subclass: #SymbolListTile	instanceVariableNames: 'choices dataType '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting Tiles'!UpdatingSimpleButtonMorph subclass: #ScriptableButton	instanceVariableNames: 'scriptSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!!ScriptableButton commentStamp: 'sw 10/24/2000 08:01' prior: 0!A button intended for use with the card architecture and the user-scripting system.!ScriptableButton class	instanceVariableNames: ''!ThreePhaseButtonMorph subclass: #UpdatingThreePhaseButtonMorph	instanceVariableNames: 'getSelector getArgument '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!Smalltalk renameClassNamed: #VariableDocker as: #VariableDock!Object subclass: #VariableDock	instanceVariableNames: 'variableName type definingMorph morphGetSelector morphPutSelector playerGetSelector playerPutSelector defaultValue '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Stacks'!!VariableDock commentStamp: 'sw 10/30/2000 08:45' prior: 0!Represents a variable held in a Player on behalf of a Morph.  When a new Player gets installed in the Morph, variables representing the old player need to be committed to the old player's storage, if not already done, and then new values for the variables need to be obtained from the new Player.  The VariableDock does the actual data transfer.variableName 		A Symbol.  The name by which this variable known in the bearer,  a Cardtype 				An object representing the variable's type.  Initially, we, like the rest						use a Symbol to represent this.						Presently #string #number #boolean #object #reference #sound etc.definingMorph		The morph that requested storage of this variablemorphGetSelector	The message to be sent to the morph to obtain the variable's valuemorphPutSelector	The message to be sent to the morph to put a new var value into itowningClass			The Uniclass of which this is an instance variableplayerGetSelector 	The message to be sent to the Player to obtain its current stored valueplayerPutSelector 	The message to be sent to the Player to set a new stored valuedefaultValue		The value to set for the variable by defaultfloatPrecision		e.g. 0, 0.1, 0.001.  Only relevant for numeric-type variables!!Object methodsFor: 'accessing' stamp: 'sw 10/17/2000 11:15'!presenter	"Answer the presenter object associated with the receiver.  For morphs, there is in effect a clear containment hierarchy of presenters (accessed via their association with PasteUpMorphs); for arbitrary objects the hook is simply via the current world, at least at present."	^ self currentWorld presenter! !!Object methodsFor: 'testing' stamp: 'sw 10/16/2000 10:41'!beViewed	"Open up a viewer on the receiver.  The Presenter is invited to decide just how to present this viewer"	self presenter viewObject: self! !!Object methodsFor: 'testing' stamp: 'sw 10/16/2000 11:01'!costumes	"Answer a list of costumes associated with the receiver.  The appearance of this method in class Object serves only as a backstop, probably only transitionally"	^ nil! !!Object methodsFor: 'testing' stamp: 'sw 10/27/2000 06:58'!knownName	"If a formal name has been handed out for this object, answer it, else nil"		^ Preferences capitalizedReferences		ifTrue:			[References keyAtValue: self ifAbsent: [nil]]		ifFalse:			[nil]! !!Object methodsFor: 'testing' stamp: 'sw 10/27/2000 17:52'!nameForViewer	"Answer a name to be shown in a Viewer that is viewing the receiver"	| aName |	(aName _ self uniqueNameForReferenceOrNil) ifNotNil: [^ aName].	^ (self printString copyWithout: Character cr) withNoLineLongerThan:  20! !!Object methodsFor: 'printing' stamp: 'sw 10/17/2000 11:16'!reportableSize	"Answer a string that reports the size of the receiver -- useful for showing in a list view, for example"	^ (self basicSize + self class instSize) printString! !!Object methodsFor: 'user interface' stamp: 'sw 10/16/2000 11:11'!launchTileToRefer	"Create a tile to reference the receiver, and attach it to the hand"	self currentHand attachMorph: self tileToRefer! !!Object methodsFor: 'system primitives' stamp: 'sw 10/16/2000 10:59'!className	"Answer a string characterizing the receiver's class, for use in list views for example"	^ self class name asString! !!Object methodsFor: 'system primitives' stamp: 'sw 10/16/2000 11:04'!creationStamp	"Answer a string which reports the creation particulars of the receiver.  Intended perhaps for list views, but this is presently a feature not easily accessible"	^ '<no creation stamp>'! !!Object methodsFor: 'system primitives' stamp: 'sw 10/16/2000 11:09'!instVarNamed: aString	"Return the value of the instance variable in me with that name.  Slow and unclean, but very useful. "	^ self instVarAt: (self class allInstVarNames indexOf: aString asString)! !!Object methodsFor: 'system primitives' stamp: 'sw 10/16/2000 11:10'!instVarNamed: aString put: aValue	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful. "	^ self instVarAt: (self class allInstVarNames indexOf: aString asString) put: aValue! !!Object methodsFor: 'system primitives' stamp: 'sw 10/17/2000 11:12'!oopString	"Answer a string that represents the oop of the receiver"	^ self asOop printString! !!Object methodsFor: 'macpal' stamp: 'sw 10/24/2000 07:04'!objectRepresented	"most objects represent themselves; this provides a hook for aliases to grab on to"	^ self! !!Object methodsFor: 'viewer' stamp: 'sw 10/16/2000 10:35'!assureUniClass	"If the receiver is not yet an instance of a uniclass, create a uniclass for it and make the receiver become an instance of that class."	| anInstance |	self belongsToUniClass ifTrue: [^ self].	anInstance _ self class instanceOfUniqueClass.	self become: (self as: anInstance class).	^ anInstance! !!Object methodsFor: 'viewer' stamp: 'sw 10/16/2000 10:41'!belongsToUniClass	"Answer whether the receiver belongs to a uniclass.  For the moment (this is not entirely satisfactory) this is precisely equated with the classname ending in a digit"	^ self class name endsWithDigit! !!Object methodsFor: 'viewer' stamp: 'sw 10/27/2000 10:47'!categoriesForViewer: aViewer	"Answer a list of symbols representing the categories of methods/inst vars for the receiver, for the given viewer.  The deeper functionality here has yet to be ported forward from earlier demos."	| filter ivs |	true ifTrue: [^ self class organization categories].	filter _ aViewer filteringScheme.	(filter == #minimal) ifTrue: [^ self class  minimalViewerCategoriesIn: aViewer].	(filter == #myOwn) ifTrue: [^ self class rootViewerCategoriesIn: aViewer].	(filter == #eToy) ifTrue: [^ self class etoyViewerCategoriesIn: aViewer].	(filter == #custom) ifTrue: [^ self class customViewerCategoriesIn: aViewer].	(filter == #most) ifTrue: [^ self class mostViewerCategoriesIn: aViewer].	(filter == #standard) ifTrue: [^ self class standardViewerCategoriesIn: aViewer].	(filter == #all) ifTrue: [^ self class allViewerCategoriesIn: aViewer].	(filter == (ivs _ #instanceVariables)) ifTrue: [^ Array with: ivs].! !!Object methodsFor: 'viewer' stamp: 'sw 10/25/2000 07:19'!categoryElementsFor: aCategorySymbol	"Just a start.  Answer a list of tuples that characterize the elements in the given category.  Every class in the receiver's superclass chain which implements #additionsToViewerCategories is given the chance to add elements to the category.  In this first version, only methods with 0 or 1 arguments are included, because of the limitations of PhraseTileMorphs.  Later, the entire method vocabulary of a category will be incorporated, and we will use type hints for the arguments, and we will support a way that methods with return-value types can have type-appropriate readouts for their values, etc."	| aList org |	org _  self class organization.	aList _ (org listAtCategoryNamed: aCategorySymbol) select:		[:anElement | anElement numArgs < 2].	^ aList collect:		[:sel | 			sel numArgs == 0				ifTrue:					[Array with: #command with: sel with: 'help here later']				ifFalse:					[Array with: #command with: sel with: 'help here later' with: #string]]! !!Object methodsFor: 'viewer' stamp: 'sw 10/25/2000 07:20'!chooseNewNameForReference	"Offer an opportunity for the receiver, presumed already to be known in the References registry, to be renamed"	|  nameSym current newName |	current _ References keyAtValue: self ifAbsent: [^ self error: 'not found in References'].	newName _ FillInTheBlank request: 'Please enter new name' initialAnswer: current.	"Want to user some better way of determining the validity of the chosen identifier, and also want to give more precise diagnostic if the string the user types in is not acceptable.  Work to be done here."	newName isEmpty ifTrue: [^ nil].	((Scanner isLiteralSymbol: newName) and: [(newName includes: $:) not])		ifTrue:			[nameSym _ newName capitalized asSymbol.			(((References includesKey:  nameSym) not and:				[(Smalltalk includesKey: nameSym) not]) and:						[(ScriptingSystem allKnownClassVariableNames includes: nameSym) not])					ifTrue:						[(References associationAt: current) key: nameSym.						References rehash.						^ nameSym]].	self inform: 'Sorry, that name is not available.'.	^ nil! !!Object methodsFor: 'viewer' stamp: 'sw 10/25/2000 17:27'!commandPhraseFor: commandSpec inViewer: aViewer	"Translate commandSpec into a PhraseTileMorph.  Put balloon help into the phrase.  This work derives from the original e-toy work, where its code was specific to the Player/Morph architecture; it is now elevated to class Object, but really only reliably works when the viewee is indeed  a Player."	| aRow resultType cmd argType argTile selfTile aPhrase balloonTextSelector stat inst |	resultType _ (commandSpec at: 1).	cmd _ (commandSpec at: 2).	commandSpec size = 3		ifTrue:			[aPhrase _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player]		ifFalse: "commandSpec size is four"			[argType _ commandSpec at: 4.			aPhrase _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player				argType: argType.			argTile _ self tileForArgType: argType inViewer: aViewer.			argTile position: aPhrase lastSubmorph position.			aPhrase lastSubmorph addMorph: argTile].	(self belongsToUniClass and:			[self class includesSelector: cmd])		ifTrue: [balloonTextSelector _ #userScript].	aPhrase operatorTile balloonTextSelector: (balloonTextSelector ifNil: [cmd]).	aPhrase markAsPartsDonor.	selfTile _ aViewer tileForSelf.	selfTile position: aPhrase firstSubmorph position.	aPhrase firstSubmorph addMorph: selfTile.	aRow _ ViewerRow newRow borderWidth: 0; color: aViewer color.	aRow elementSymbol: cmd asSymbol.	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 4@2; beTransparent).	aRow addMorphBack: (aViewer infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	false "(names includes: cmd)" ifTrue:		[aPhrase userScriptSelector: cmd.		aPhrase beTransparent.		aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.		aRow addMorphBack: (stat _ (inst _ self scriptInstantiationForSelector: cmd) statusControlMorph).		inst updateStatusMorph: stat.].	aRow beSticky; disableDragNDrop.	^ aRow! !!Object methodsFor: 'viewer' stamp: 'sw 2/14/2000 14:24'!defaultNameStemForInstances	"Answer a basis for names of default instances of the receiver.  The default is to let the class specify, but certain instances will want to override.  (PasteUpMorphs serving as Worlds come to mind"	^ self class defaultNameStemForInstances! !!Object methodsFor: 'viewer' stamp: 'sw 10/27/2000 17:51'!elementTypeFor: aStringOrSymbol	"Answer a symbol characterizing what kind of element aStringOrSymbol represents.  Realistically, at present, this always just returns #systemScript; a prototyped but not-incorporated architecture supported use of a leading colon to characterize an inst var of a system class, and for the moment we still see its remnant here."	^ (aStringOrSymbol first == $:) ifTrue: [#systemSlot] ifFalse: [#systemScript]! !!Object methodsFor: 'viewer' stamp: 'sw 10/27/2000 17:51'!infoFor: anElement inViewer: aViewer	"The user made a gesture asking for info/menu relating to me.  Some of the messages dispatched here are not yet available in this image"	| aMenu elementType |	elementType _ self elementTypeFor: anElement.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement inViewer: aViewer].	self flag: #deferred.  "Use a traditional MenuMorph, and reinstate the pacify thing"	aMenu _ MenuMorph new defaultTarget: aViewer.	#(	('implementors'			browseImplementorsOf:)		('senders'				browseSendersOf:)		('versions'				browseVersionsOf:)		-		('browse full'			browseMethodFull:)		('inheritance'			browseMethodInheritance:)		-		('about this method'		aboutMethod:)) do:			[:pair |				pair = '-'					ifTrue:						[aMenu addLine]					ifFalse:						[aMenu add: pair first target: aViewer selector: pair second argument: anElement]].	aMenu addLine.	aMenu defaultTarget: self.	#(	('destroy script'		removeScript:)		('rename script'		renameScript:)		('pacify script'		pacifyScript:)) do:			[:pair |				aMenu add: pair first target: self selector: pair second argument: anElement].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].  "in case it was a slot -- weird, transitional"	aMenu addTitle: anElement asString, ' (', elementType, ')'.	aMenu popUpInWorld: self currentWorld. ! !!Object methodsFor: 'viewer' stamp: 'sw 10/25/2000 18:30'!initialTypeForSlotNamed: aName	"Answer the initial type to be ascribed to the given instance variable"	^ #object! !!Object methodsFor: 'viewer' stamp: 'sw 10/24/2000 11:36'!newScriptorAround: aPhraseTileMorph	"Sprout a scriptor around aPhraseTileMorph, thus making a new script.  This is where generalized scriptors will be threaded in"	^ nil! !!Object methodsFor: 'viewer' stamp: 'sw 10/25/2000 18:10'!offerViewerMenuFor: aViewer event: evt	"Offer the primary Viewer menu to the user.  Copied up from Player code, but most of the functions suggested here don't work for non-Player objects, many aren't even defined, some relate to exploratory sw work not yet reflected in the current corpus.  Think of this as a beginning!!"	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu title: '**CAUTION -- UNDER CONSTRUCTION!!**', self nameForViewer.	(aViewer affordsUniclass and: [self belongsToUniClass not]) ifTrue:		[aMenu add: 'give me a Uniclass' action: #assureUniClass.		aMenu addLine].	aMenu add: 'rename me' target: aViewer selector: #chooseNewNameForReference.	self belongsToUniClass ifTrue:		[aMenu add: 'add a new instance variable' target: self selector: #addInstanceVariableIn: argument: aViewer.		aMenu add: 'add a new script' target: aViewer selector: #newPermanentScriptIn: argument: aViewer.		aMenu addLine.		aMenu add: 'make my class be first-class' target: self selector: #makeFirstClassClassIn: argument: aViewer.		aMenu add: 'move my changes up to my superclass' target: self action: #promoteChangesToSuperclass.		aMenu addLine].	aMenu add: 'toggle scratch pane' target: aViewer selector: #toggleScratchPane.	aMenu add: 'make a nascent script for me' target: aViewer selector: #makeNascentScript.	aMenu add: 'tear off a tile' target: self selector: #launchTileToRefer.	aMenu addLine.	aMenu add: 'inspect me' target: self selector: #inspect.	aMenu add: 'inspect my class' target: self class action: #inspect.	aMenu add: 'references to me' target: aViewer action: #browseReferencesToObject.	aMenu addLine.	aMenu add: 'browse full' action: #browseOwnClassFull.	aMenu add: 'browse hierarchy' action: #browseOwnClassHierarchy.	aMenu add: 'browse protocol' action: #browseOwnClassProtocol.	aMenu add: 'browse sub-protocol' action: #browseOwnClassSubProtocol.	aMenu addLine.	aMenu add: 'set user level...' target: aViewer action: #setUserLevel.	aMenu addLine.	aMenu add: 'inspect this Viewer' target: aViewer action: #inspect.	aMenu popUpEvent: evt in: aViewer currentWorld! !!Object methodsFor: 'viewer' stamp: 'sw 10/25/2000 17:42'!offerViewerMenuForEvt: anEvent morph: aMorph	"Offer the viewer's primary menu to the user.  aMorph is some morph within the viewer itself, the one within which a mousedown triggered the need for this menu, and it is used only to retrieve the Viewer itself"	self offerViewerMenuFor: (aMorph ownerThatIsA: StandardViewer) event: anEvent! !!Object methodsFor: 'viewer' stamp: 'sw 10/24/2000 10:53'!tileForArgType: typeSymbol inViewer: aViewer	"Answer a tile to represent an argument of the given type; the viewer argument is actually used, but nowadays in only a vacuous sense that should be excised, since the viewer does not use anything about itself in its subsequent code"	| aColor aPlayer |	typeSymbol == #player ifTrue:		[aPlayer _ self presenter			ifNotNil:				[self presenter standardPlayer]			ifNil:  "It happens, if costume is not currently in a world"				[self].		^ aViewer tileForPlayer:  aPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #menu ifTrue: [^ MenuTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	typeSymbol == #buttonPhase ifTrue: [^ SymbolListTile new choices: #(buttonDown whilePressed buttonUp) dataType:  typeSymbol].	self error: 'Unrecognized type'! !!Object methodsFor: 'viewer' stamp: 'sw 10/5/2000 09:35'!tilePhrasesForCategory: aCategory inViewer: aViewer	"Return an array of phrases for the category"	^ (self tilePhrasesSpecsForCategory: aCategory) collect:		[:aSpec |			aSpec first == #slot				ifTrue:					[aViewer phraseForSlot: aSpec]				ifFalse:					[self commandPhraseFor: aSpec inViewer: aViewer]]! !!Object methodsFor: 'viewer' stamp: 'sw 10/5/2000 09:34'!tilePhrasesSpecsForCategory: aCategory	"Return an array of slot and script names and info for use in a viewer on the receiver.  These can be of two flavors - command and slot."	^ (self usablePhraseSpecsIn: (self categoryElementsFor: aCategory asSymbol))"The format of the specs is illustrated by:	(slot heading 'the direction'	number	 readWrite player getHeading player setHeading:)	(command wearCostumeOf: 'change appearance to look like' player)"! !!Object methodsFor: 'viewer' stamp: 'sw 10/17/2000 11:27'!uniqueInstanceVariableNameLike: aString excluding: takenNames	"Answer a nice instance-variable name to be added to the receiver which resembles aString, making sure it does not coincide with any element in takenNames"	| okBase uniqueName usedNames |	usedNames _ self class allInstVarNamesEverywhere.	usedNames removeAllFoundIn: self class instVarNames.	usedNames addAll: takenNames.	okBase _ Utilities wellFormedInstanceVariableNameFrom: aString.	uniqueName _ Utilities keyLike: okBase satisfying: 		[:aKey | (usedNames includes: aKey) not].	^ uniqueName! !!Object methodsFor: 'viewer' stamp: 'sw 10/17/2000 11:29'!uniqueNameForReference	"Answer a nice name by which the receiver can be referred to by other objects.  At present this uses a global References dictionary to hold the database of references, but in due course this will need to acquire some locality"	| aName nameSym stem knownClassVars |	(References includesIdentity: self) ifTrue: [^ References keyAtValue: self].	stem _ (self knownName ifNil: [self defaultNameStemForInstances asString]) capitalized.	knownClassVars _ ScriptingSystem allKnownClassVariableNames.	aName _ Utilities keyLike:  stem satisfying:		[:jinaLake |			nameSym _ jinaLake asSymbol.			 ((References includesKey:  nameSym) not and:				[(Smalltalk includesKey: nameSym) not]) and:						[(knownClassVars includes: nameSym) not]].	References at: (aName _ aName asSymbol) put: self.	^ aName! !!Object methodsFor: 'viewer' stamp: 'sw 10/17/2000 11:29'!uniqueNameForReferenceOrNil	"If the receiver has a unique name for reference, return it here, else return nil"	^ References keyForIdentity: self! !!Object methodsFor: 'viewer' stamp: 'sw 10/24/2000 07:08'!usablePhraseSpecsIn: aList	"Filter aList, returning a subset list of apt phrases"	^ aList! !!Behavior methodsFor: 'printing' stamp: 'sw 10/13/2000 12:59'!defaultNameStemForInstances	"Answer a basis for external names for default instances of the receiver.  For classees, the class-name itself is a good one."	^ self name! !!ClassDescription methodsFor: 'instance variables' stamp: 'sw 10/23/2000 18:05'!allInstVarNamesEverywhere	"Answer the set of inst var names used by the receiver, all superclasses, and all subclasses"	| aList |	aList _ OrderedCollection new.	(self allSuperclasses , self withAllSubclasses asOrderedCollection) do:		[:cls | aList addAll: cls instVarNames].	^ aList asSet	"BorderedMorph allInstVarNamesEverywhere"! !!Dictionary methodsFor: 'testing' stamp: 'sw 2/14/2000 14:34'!includesIdentity: anObject	"Answer whether anObject is one of the values of the receiver.  Contrast #includes: in which there is only an equality check, here there is an identity check"	self do: [:each | anObject == each ifTrue: [^ true]].	^ false! !!Dictionary methodsFor: 'testing' stamp: 'sw 3/23/2000 01:12'!keyForIdentity: anObject	"If anObject is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check"	self associationsDo: [:assoc | assoc value == anObject ifTrue: [^ assoc key]].	^ nil! !!Inspector methodsFor: 'menu commands' stamp: 'sw 10/24/2000 07:01'!fieldListMenu: aMenu	"Arm the supplied menu with items for the field-list of the receiver"	| sel |	((((sel _ self selection) isMemberOf: Array) or: [sel isMemberOf: OrderedCollection]) and: [sel size >= 1])		ifTrue:			[^ self fieldListMenuForCollection: aMenu].	aMenu addList: #(		('inspect (i)'						inspectSelection)		('explore (I)'						exploreSelection)		-		('method refs to this inst var'		referencesToSelection)		('methods storing into this inst var'	defsOfSelection)		('objects pointing to this value'		objectReferencesToSelection)		-		('browse full (b)'					browseMethodFull)		('browse class'						browseClass)		('browse hierarchy'					classHierarchy)		-		('inst var refs...'					browseInstVarRefs)		('inst var defs...'					browseInstVarDefs)		('class var refs...'					classVarRefs)		('class variables'					browseClassVariables)		('class refs (N)'						browseClassRefs)		-		('copy name'						copyName)				('basic inspect'						inspectBasic)).	Smalltalk isMorphic ifTrue:		[aMenu addList: #(			-			('tile for this value	(t)'			tearOffTile)"			('alias for this value'			aliasForValue)""			('watcher for this slot'			watcherForSlot)"			('viewer for this value (v)'		viewerForValue))].	^ aMenu! !!Inspector methodsFor: 'menu commands' stamp: 'sw 10/23/2000 18:25'!tearOffTile	"Tear off a tile that refers to the receiver's selection, and place it in the mophic hand"	| objectToRepresent |	objectToRepresent _ self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	self currentHand attachMorph: (TileMorph new referTo: objectToRepresent)	! !!Inspector methodsFor: 'menu commands' stamp: 'sw 10/23/2000 18:27'!viewerForValue	"Open up a viewer on the value of the receiver's current selection"	| objectToRepresent |	objectToRepresent _ self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	objectToRepresent beViewed	! !!Morph methodsFor: 'accessing' stamp: 'sw 10/27/2000 17:33'!beUnsticky	"If the receiver is marked as sticky, make it now be unsticky"	extension ifNotNil:		[extension sticky: false]! !!Morph methodsFor: 'accessing' stamp: 'sw 10/27/2000 17:42'!isShared	"Answer whether the receiver has the #shared property.  This property allows it to be treated as a 'background' item"	^ self hasProperty: #shared! !!Morph methodsFor: 'access properties' stamp: 'sw 10/3/2000 11:20'!valueOfProperty: propName ifPresentDo: aBlock	"If the receiver has a property of the given name, evaluate aBlock on behalf of the value of that property"	extension == nil ifTrue: [^ self].	^ aBlock value: (extension valueOfProperty: propName ifAbsent: [^ self])! !!Morph methodsFor: 'thumbnail' stamp: 'sw 10/26/2000 08:32'!demandsThumbnailing	"Answer whether the receiver, if in a thumbnailable parts bin, wants to be thumbnailed whether or not size requires it"	^ false! !!Morph methodsFor: 'thumbnail' stamp: 'sw 10/31/2000 09:05'!readoutForField: fieldSym	"Provide a readout that will show the value of the slot/pseudoslot of the receiver generated by sending fieldSym to the receiver"	| aContainer |	"still need to get this right"	aContainer _ AlignmentMorph newColumn.	aContainer inset: 0; hResizing: #rigid; vResizing: #shrinkWrap.	aContainer addMorphBack: (StringMorph new contents: (self perform: fieldSym) asString).	^ aContainer! !!Morph methodsFor: 'thumbnail' stamp: 'sw 10/26/2000 08:34'!representativeNoTallerThan: maxHeight norWiderThan: maxWidth thumbnailHeight: thumbnailHeight	"Return a morph representing the receiver but which is no taller than aHeight.  If the receiver is already small enough, just return it, else return a MorphThumbnail companioned to the receiver, enforcing the maxWidth.  If the receiver personally *demands* thumbnailing, do it even if there is no size-related reason to do it."	self demandsThumbnailing ifFalse:		[self permitsThumbnailing ifFalse: [^ self].		(self height <= maxHeight and: [self width <= maxWidth]) ifTrue: [^ self]].	^ MorphThumbnail new extent: maxWidth @ (thumbnailHeight min: self height); morphRepresented: self! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 10/26/2000 13:06'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	| aWindow partsBinCase cmd aStack |	self formerOwner: nil.	self formerPosition: nil.	cmd _ self valueOfProperty: #undoGrabCommand.	cmd ifNotNil:[aMorph rememberCommand: cmd.				self removeProperty: #undoGrabCommand].	(partsBinCase _ aMorph isPartsBin) ifFalse:		[self isPartsDonor: false].	(aWindow _ aMorph ownerThatIsA: SystemWindow) ifNotNil:		[aWindow isActive ifFalse:			[aWindow activate]].	(self isInWorld and: [partsBinCase not]) ifTrue:		[self world startSteppingSubmorphsOf: self].	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."	(self holdsSeparateDataForEachInstance and: [(aStack _ self stack) notNil])		ifTrue:			[aStack reassessBackgroundShape]! !!Morph methodsFor: 'naming' stamp: 'sw 10/31/2000 09:28'!downshiftedNameOfObjectRepresented	"Answer the downshiped version of the external name of the object represented"	^ self nameOfObjectRepresented asLowercase! !!Morph methodsFor: 'naming' stamp: 'sw 10/31/2000 09:24'!nameOfObjectRepresented	"Answer the external name of the object represented"	^ self externalName! !!Morph methodsFor: 'naming' stamp: 'sw 10/27/2000 17:47'!tryToRenameTo: aName	"A new name has been submited; make sure it's appropriate, and react accordingly.  This circumlocution provides the hook by which the simple renaming of a field can result in a change to variable names in a stack, etc.  There are some problems to worry about here."	| aStack |	(self holdsSeparateDataForEachInstance and: [(aStack _ self stack) notNil])		ifTrue:			[self topRendererOrSelf setNameTo: aName.			aStack reassessBackgroundShape]		ifFalse:			[self renameTo: aName]! !!Morph methodsFor: 'menus' stamp: 'sw 10/27/2000 05:37'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	self maybeAddCollapseItemTo: aMenu.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer:.	aMenu addLine.	aMenu add: 'copy Postscript' action: #clipPostscript.	aMenu add: 'print PS to file...' target: self selector: #printPSToFile.	self player ifNotNil:		[aMenu addLine.		aMenu add: 'make a sibling instance' target: self action: #makeNewPlayerInstance:.		aMenu balloonTextForLastItem: 'Makes another morph whose player is of the same class as this one.  Both siblings will share the same scripts'].	aMenu addLine.	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addDropShadowMenuItems: aMenu hand: aHandMorph.	self potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' target: self action: #embedInto:].	aMenu defaultTarget: self.	aMenu addUpdating: #lockedString action: #lockUnlockMorph.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu		defaultTarget: self;		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction.	aMenu addLine.	owner isStackBackground ifTrue:		[self isShared			ifFalse:				[aMenu add: 'put onto Background' target: self action: #putOnBackground]			ifTrue:				[aMenu add: 'remove from Background' target: self action: #putOnForeground.				self couldHoldSeparateDataForEachInstance ifTrue:					[self holdsSeparateDataForEachInstance						ifFalse:							[aMenu add: 'start holding separate data for each instance' target: self action: #makeHoldSeparateDataForEachInstance]						ifTrue:							[aMenu add: 'stop holding separate data for each instance' target: self action: #stopHoldingSeparateDataForEachInstance].							aMenu add: 'be default value on new card' target: self action: #setAsDefaultValueForNewCard.							(self hasProperty: #thumbnailImage)								ifTrue:									[aMenu add: 'stop using for reference thumbnail' target: self action: #stopUsingForReferenceThumbnail]								ifFalse:									[aMenu add: 'start using for reference thumbnail' target: self action: #startUsingForReferenceThumbnail]]].				aMenu addLine].	aMenu defaultTarget: self topRendererOrSelf.	aMenu add: 'draw new path' action: #definePath.	(self hasProperty: #pathPoints) ifTrue:		[aMenu add: 'follow path' action: #followPath.		aMenu add: 'delete path' action: #deletePath].	(owner == nil) ifFalse:		[aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'sw 10/27/2000 17:34'!chooseNewGraphicFromHalo	"Allow the user to select a changed graphic to replace the one in the receiver"	self currentWorld abandonAllHalos.	self chooseNewGraphicCoexisting: true! !!Morph methodsFor: 'menus' stamp: 'sw 10/27/2000 06:39'!putOnBackground	"Place the receiver, formerly private to its card, onto the shared background.  If the receiver needs data carried on its behalf by the card, such data will be represented on every card."	(self hasProperty: #shared) ifTrue: [^ self].  "Already done"	self setProperty: #shared toValue: true.	self stack ifNotNil: [self stack reassessBackgroundShape]! !!Morph methodsFor: 'menus' stamp: 'sw 10/26/2000 11:50'!putOnForeground	"Place the receiver, formerly on the background, onto the foreground.  If the receiver needs data carried on its behalf by the card, those data will be lost, so in this case get user confirmation before proceeding."	self holdsSeparateDataForEachInstance "later add the refinement of not putting up the following confirmer if only a single instance of the current background's uniclass exists"		ifTrue:			[self confirm: 'Caution -- every card of this backgroundformerly had its own value for thisitem.  If you put it on the foreground,the values  of this item on all othercards will be lost'				orCancel: [^ self]].	self removeProperty: #shared.	self pasteUpMorph reassessBackgroundShape.	"still work to be done here!!"! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 10/31/2000 06:04'!balloonHelpTextForHandle: aHandle	"Answer a string providing balloon help for the given halo handle"	|  itsSelector |	itsSelector _ aHandle eventHandler firstMouseSelector.	#(	(addFullHandles							'More halo handles')		(addSimpleHandles						'Fewer halo handles')		(chooseEmphasisOrAlignment				'Emphasis & alignment')		(chooseFont								'Change font')		(chooseNewGraphicFromHalo				'Choose a new graphic')		(chooseStyle								'Change style')		(dismiss									'Remove')		(doDebug:with:							'Debug')		(doDirection:with:						'Choose forward direction')		(doDup:with:							'Duplicate')		(doMenu:with:							'Menu')		(doGrab:with:							'Pick up')		(doRecolor:with:							'Change color')		(editButtonsScript						'See the script for this button')		(editDrawing							'Repaint')		(maybeDoDup:with:						'Duplicate')		(makeNascentScript						'Make a scratch script')		(makeNewDrawingWithin				'Paint new object')		(mouseDownInCollapseHandle:with:		'Collapse morph')		(mouseDownOnHelpHandle:				'Help')		(openViewerForArgument				'Open a Viewer for me')		(paintBackground						'Paint background')		(prepareToTrackCenterOfRotation:with:	'Set center of rotation')		(presentViewMenu						'Present the Viewing menu')		(startDrag:with:							'Move')		(startGrow:with:							'Change size') 		(startRot:with:							'Rotate')		(startScale:with:							'Change scale') 		(tearOffTile								'Make a tile representing this object')		(trackCenterOfRotation:with:				'Set center of rotation')) 	do:		[:pair | itsSelector == pair first ifTrue: [^ pair last]].	(itsSelector == #mouseDownInDimissHandle:with:) ifTrue:		[^ Preferences preserveTrash			ifTrue:				['Move to trash']			ifFalse:				['Remove from screen']].	^ 'unknown halo handle'! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 10/26/2000 12:11'!okayToAddGrabHandle	"Answer whether a halo on the receiver should offer a grab handle.  This provides a hook for making it harder to deconstruct some strucures even momentarily"	^ self holdsSeparateDataForEachInstance not ! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 3/23/2000 13:50'!setBalloonText: stringOrText maxLineLength: aLength	"Set receiver's balloon help text. Pass nil to remove the help."	(extension isNil and: [stringOrText isNil]) ifTrue: [^ self].	self assureExtension balloonText: (stringOrText		ifNil: [nil]		ifNotNil: [stringOrText asString withNoLineLongerThan: aLength])! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 10/9/2000 16:56'!wantsScriptorHaloHandle	"Answer whether the receiver would like to have a Scriptor halo handle put up on its behalf.  Initially, only the ScriptableButton says yes"	^ false! !!Morph methodsFor: 'player' stamp: 'sw 10/27/2000 17:38'!currentDataValue	"Answer the data value associated with the receiver.  Useful in conjunction with default-value setting"	^ nil! !!Morph methodsFor: 'player' stamp: 'sw 10/6/2000 07:37'!variableDocks	"Answer a list of VariableDocker objects for docking up my data with an instance held in my containing playfield.  The simple presence of some objects on a Playfield will result in the maintenance of instance data on the corresponding Card.  This is a generalization of the HyperCard 'field' idea.  If there is already a cachedVariableDocks cached, use that.  For this all to work happily, one must be certain to invalidate the #cachedVariableDocks cache when that's appropriate."	^ self valueOfProperty: #cachedVariableDocks ifAbsent: [#()]! !!Morph methodsFor: 'scripting' stamp: 'sw 10/25/2000 17:20'!asEmptyPermanentScriptor	"Answer a new empty permanent scriptor derived from info deftly secreted in the receiver.  Good grief"	| aScriptor aPlayer |	aPlayer _ self valueOfProperty: #player.	aPlayer assureUniClass.	aScriptor _  aPlayer newScriptorAround: nil.	aScriptor position: (self world primaryHand position - (10 @ 10)).	aPlayer updateAllViewersAndForceToShow: #scripts.	^ aScriptor! !!Morph methodsFor: 'scripting' stamp: 'sw 10/9/2000 16:46'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putSelector	"Answer a readout tile representing the given part's value, given the putter, getter, and type information"	| aColor aTile displayer |	aColor _ Color lightGray lighter.	aTile _ typeSymbol == #number		ifTrue:			[NumericReadoutTile new typeColor: aColor]		ifFalse:				[typeSymbol == #sound				ifTrue:					[SoundReadoutTile new typeColor: aColor]				ifFalse:					[typeSymbol == #buttonPhase						ifTrue:							[SymbolListTile new choices: #(buttonDown whilePressed buttonUp) dataType:  typeSymbol]						ifFalse:							[StringReadoutTile new typeColor: aColor]]]. 	displayer _ UpdatingStringMorph new		getSelector: getSelector;		target: self player;		growable: true;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	(typeSymbol == #number)		ifTrue:			 [((#(cursor  "etc...") includes: partName) and: [self isKindOf: GraphMorph])				ifTrue:					[displayer floatPrecision: 0.1]				ifFalse:					[(self player slotInfo includesKey: partName)  "i.e., a user-defined numeric slot"						ifTrue:							[displayer floatPrecision: (self player slotInfoAt: partName) floatPrecision]]].	typeSymbol == #string		ifTrue:			[displayer useStringFormat.			displayer growable: true]		ifFalse:			[(typeSymbol == #sound)				ifTrue: 	[displayer useStringFormat]				ifFalse:	[displayer useDefaultFormat]].	aTile addMorphBack: displayer.	((putSelector ~~ #unused) and: [#(number sound boolean buttonPhase) includes: typeSymbol])  ifTrue: [aTile addArrows].	aTile setLiteralInitially: (self scriptPerformer perform: getSelector).	^ aTile! !!Morph methodsFor: 'scripting' stamp: 'sw 10/18/2000 10:32'!viewAfreshIn: aPasteUp showingScript: aScriptName at: aPosition	"Obtain a smartly updated ScriptEditor for the given script name and zap it into place at aPosition"	| anEditor |	self player updateAllViewersAndForceToShow: #scripts.	anEditor _ self player scriptEditorFor: aScriptName.	aPasteUp ifNotNil: [aPasteUp addMorph: anEditor].	anEditor position: aPosition.	anEditor currentWorld startSteppingSubmorphsOf: anEditor! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/27/2000 17:36'!couldHoldSeparateDataForEachInstance	"Answer whether this type of morph is inherently capable of holding separate data for each instance ('card data')"	^ false! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/27/2000 17:37'!creationStamp	"Answer the creation stamp stored within the receiver, if any"	^ self valueOfProperty: #creationStamp ifAbsent: [super creationStamp]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/24/2000 05:52'!defaultValueOrNil	"If the receiver has a property named #defaultValue, return that property's value, else return nil"	^ self valueOfProperty: #defaultValue ifAbsent: [nil]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/25/2000 06:57'!defaultVariableName	"If the receiver is of the sort that wants a variable maintained on its behalf in the 'card' data, then return a variable name to be used for that datum.  What is returned here is only a point of departure in the forthcoming negotiation"	^ Utilities wellFormedInstanceVariableNameFrom: (self valueOfProperty: #variableName ifAbsent: [self externalName])! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/23/2000 14:49'!goToNextCardInStack	"Tell my stack to advance to the next page"	self stackDo: [:aStack | aStack goToNextCardInStack]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/23/2000 14:52'!goToPreviousCardInStack	"Tell my stack to advance to the previous card"		self stackDo: [:aStack | aStack goToPreviousCardInStack]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/27/2000 17:41'!holdsSeparateDataForEachInstance	"Answer whether the receiver is currently behaving as a 'background field', i.e., whether it is marked as shared (viz. occurring on the background of a stack) *and* is marked as holding separate data for each instance"	^ self isShared and: [self hasProperty: #holdsSeparateDataForEachInstance]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/23/2000 14:40'!isStackBackground	"Answer whether the receiver serves as a background of a stack"	^ false! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/9/2000 16:48'!listViewLineForFieldList: aFieldList	"Answer a ListLineView object which describes the receiver"	| aLine |	aLine _ ListViewLine new objectRepresented: self.	aFieldList do:		[:fieldSym | aLine addMorphBack: (self readoutForField: fieldSym).		aLine addTransparentSpacerOfSize: (7 @ 0)].	^ aLine! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/27/2000 17:43'!makeHoldSeparateDataForEachInstance	"Mark the receiver as holding separate data for each instance (i.e., like a 'background field') and reassess the shape of the corresponding background so that it will be able to accommodate this arrangement."	self setProperty: #holdsSeparateDataForEachInstance toValue: true.	self pasteUpMorph reassessBackgroundShape! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/26/2000 11:37'!noteNegotiatedName: uniqueName for: requestedName	"This works, kind of, for morphs that have a single variable.  Still holding out for generality of morphs being able to have multiple variables, but need a driving example"	self setProperty: #variableName toValue: uniqueName.	self setProperty: #setterSelector toValue: (Utilities setterSelectorFor: uniqueName).	self setNameTo: uniqueName! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/9/2000 06:43'!objectViewed	"Answer the morph associated with the player that the structure the receiver currently finds itself within represents."	^ (self outermostMorphThat: [:o | o isKindOf: Viewer orOf: ScriptEditorMorph]) objectViewed! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/24/2000 06:30'!setAsDefaultValueForNewCard	"Set the receiver's current value as the one to be used to supply the default value for a variable on a new card.  This implementation does not support multiple variables per morph, which is problematical"	self setProperty: #defaultValue toValue: self currentDataValue deepCopy! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/27/2000 17:46'!slotSpecifications	"A once and possibly future feature; retained here for backward-compatibility bulletproofing."	^ #()! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/27/2000 06:46'!stack	"Answer the nearest containing Stack, or, if none, a stack in the current project, and if still none, nil.  The extra messines is because uninstalled backgrounds won't have backpointers to their stack."	| aStack |	(aStack _ self ownerThatIsA: StackMorph) ifNotNil: [^ aStack].	^ Project current currentStack! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/23/2000 14:38'!stackDo: aBlock	"If the receiver has a stack, evaluate aBlock on its behalf"	| aStack |	(aStack _ self ownerThatIsA: StackMorph) ifNotNil:		[^ aBlock value: aStack]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/26/2000 13:28'!stopHoldingSeparateDataForEachInstance	"Make the receiver no longer hold separate data for each instance"	self removeProperty: #holdsSeparateDataForEachInstance.	self pasteUpMorph reassessBackgroundShape! !!Morph methodsFor: 'printing' stamp: 'sw 10/27/2000 17:47'!textToPaste	"If the receiver has text to offer pasting, answer it, else answer nil"	^ nil! !!Morph methodsFor: 'debug and other' stamp: 'sw 10/24/2000 06:19'!addViewingItemsTo: aMenu	"Add viewing-related items to the given menu"! !!Morph methodsFor: 'debug and other' stamp: 'sw 10/27/2000 17:34'!buildDebugMenu: aHand	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"	| aMenu aPlayer |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	(self hasProperty: #errorOnDraw) ifTrue:		[aMenu add: 'start drawing again' action: #resumeAfterDrawError.		aMenu addLine].	(self hasProperty: #errorOnStep) ifTrue:		[aMenu add: 'start stepping again' action: #resumeAfterStepError.		aMenu addLine].	aMenu add: 'inspect morph' action: #inspectInMorphic:.	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.	Smalltalk isMorphic ifFalse:		[aMenu add: 'inspect morph (in MVC)' action: #inspect].     aMenu add: 'explore morph' target: self selector: #explore.	(aPlayer _ self player) ifNotNil:		[aMenu add: 'inspect player' target: aPlayer action: #inspect.		Smalltalk isMorphic ifFalse: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic:]].	aMenu addLine.	aMenu add: 'browse morph class' target: self selector: #browseHierarchy.	aPlayer ifNotNil: 		[aMenu add: 'browse player class' target: aPlayer action: #inspect].	self addViewingItemsTo: aMenu.	aMenu 		addLine;		add: 'make own subclass' action: #subclassMorph;		add: 'internal name ' action: #choosePartName;		add: 'save morph in file'  action: #saveOnFile;		addLine;		add: 'call #tempCommand' action: #callTempCommand;		add: 'define #tempCommand' action: #defineTempCommand;		addLine;		add: 'control-menu...' target: self selector: #invokeMetaMenu:;		add: 'edit balloon help' action: #editBalloonHelpText.	^ aMenu! !!Morph methodsFor: 'debug and other' stamp: 'sw 10/27/2000 17:45'!reportableSize	"Answer a size worth reporting as the receiver's size in a list view"	| total |	total _ super reportableSize.	submorphs do:		[:m | total _ total + m reportableSize].	^ total! !!Morph methodsFor: 'visual properties' stamp: 'sw 10/7/2000 10:16'!cornerStyle	"Answer the style, #square or #rounded, of corners.  This is a backstop implementation for morphs that don't do rounded corners."	^ #square! !!Morph methodsFor: 'rounding' stamp: 'sw 10/27/2000 17:46'!roundedCornersString	"Answer the string to put in a menu that will invite the user to switch to the opposite corner-rounding mode"	^ (self wantsRoundedCorners		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'rounded corners'! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 10/13/2000 13:01'!makePageControlsFrom: controlSpecs	"From the controlSpecs, create a set of page control and return them -- this method does *not* add the controls to the receiver."	| c aButton col row b lastGuy |	c _ (color saturation > 0.1) ifTrue: [color slightlyLighter] ifFalse: [color slightlyDarker].	aButton _ SimpleButtonMorph new target: self; borderWidth: 1; borderColor: Color veryLightGray; color: c.	col _ AlignmentMorph newColumn.	col color: c; borderWidth: 0; inset: 0.	col hResizing: #spaceFill; vResizing: #shrinkWrap; extent: 5@5.	row _ AlignmentMorph newRow.	row color: c; borderWidth: 0; inset: 0.	row hResizing: #spaceFill; vResizing: #shrinkWrap; extent: 5@5.	controlSpecs do: [:spec |		spec == #spacer			ifTrue:				[row addTransparentSpacerOfSize: (10 @ 0)]			ifFalse:				[spec == #variableSpacer					ifTrue:						[row addMorphBack: AlignmentMorph newVariableTransparentSpacer]					ifFalse:						[b _ aButton fullCopy						label: spec first;						actionSelector: spec second;						borderWidth: 0;	 					setBalloonText: spec third.						row addMorphBack: b.						(((lastGuy _ spec last asLowercase) includesSubString: 'menu') or:								[lastGuy includesSubString: 'designations'])							ifTrue: [b actWhen: #buttonDown]]]].  "pop up menu on mouseDown"		col addMorphBack: row.	^ col! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 10/13/2000 12:59'!defaultNameStemForNewPages	"Answer a stem onto which to build default names for fresh pages"	^ 'page'! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 10/13/2000 13:00'!insertPageColored: aColor	"Insert a new page for the receiver, using the given color as its background color"	| sz newPage bw bc |	currentPage == nil		ifTrue:			[sz _ pageSize.			bw _ 0.			bc _ Color blue muchLighter]		ifFalse:			[sz _ currentPage extent.			bw _ currentPage borderWidth.			bc _ currentPage borderColor].	newPagePrototype		ifNil:			[newPage _ PasteUpMorph new extent: sz; color: aColor.			newPage borderWidth: bw; borderColor: bc]		ifNotNil: [Cursor wait showWhile: 				[newPage _ newPagePrototype veryDeepCopy]].	newPage setNameTo: self defaultNameStemForNewPages.	newPage resizeToFit: false.	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 10/13/2000 13:01'!insertPageSilentlyAtEnd	"Create a new page at the end of the book.  Do not turn to it."	| sz newPage bw bc cc | 	currentPage == nil		ifTrue: [sz _ pageSize.			bw _ 0.			bc _ Color blue muchLighter.			cc _ color]		ifFalse: [sz _ currentPage extent.			bw _ currentPage borderWidth.			bc _ currentPage borderColor.			cc _ currentPage color].	newPagePrototype		ifNil: [newPage _ PasteUpMorph new extent: sz; color: cc.			newPage borderWidth: bw; borderColor: bc]		ifNotNil: [Cursor wait showWhile: 				[newPage _ newPagePrototype veryDeepCopy]].	newPage setNameTo: self defaultNameStemForNewPages.	newPage resizeToFit: false.	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]	"had been none"		ifFalse: [pages add: newPage after: pages last].	^ newPage! !!HaloMorph methodsFor: 'private' stamp: 'sw 10/26/2000 11:40'!addNameBeneath: outerRectangle string: aString	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."	| nameMorph namePosition w |	w _ self world ifNil:[target world].	nameMorph _ NameStringInHalo contents: aString.	nameMorph color: Color magenta.	nameMorph useStringFormat; target: innerTarget; putSelector: #tryToRenameTo:.	namePosition _ outerRectangle bottomCenter -		((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).	nameMorph position: (namePosition min: w viewBox bottomRight - nameMorph extent y + 2).	nameMorph balloonTextSelector: #objectNameInHalo.	self addMorph: nameMorph.	^ nameMorph! !!HaloMorph methodsFor: 'handles' stamp: 'sw 10/27/2000 17:21'!addChooseGraphicHandle: haloSpec	"If the tagret is a sketch morph, add a halo handle allowing the user to select a new graphic"	(innerTarget isKindOf: SketchMorph) ifTrue:		[self addHandle: haloSpec				on: #mouseDown send: #chooseNewGraphicFromHalo to: innerTarget]! !!HaloMorph methodsFor: 'handles' stamp: 'sw 10/27/2000 17:22'!addGrabHandle: haloSpec	"If appropriate, add the black halo handle for picking up the target"	innerTarget okayToAddGrabHandle ifTrue:		[self addHandle: haloSpec on: #mouseDown send: #doGrab:with: to: self]! !!HaloMorph methodsFor: 'handles' stamp: 'sw 10/9/2000 16:57'!addScriptHandle: haloSpec	"If the halo's innerTarget claims it wants a Script handle, add one to the receiver, forming it as per haloSpec"	innerTarget wantsScriptorHaloHandle ifTrue:		[self addHandle: haloSpec				on: #mouseUp send: #editButtonsScript to: innerTarget]! !!HaloMorph methodsFor: 'handles' stamp: 'sw 10/23/2000 18:19'!addViewingHandle: haloSpec	"If appropriate, add a special Viewing halo handle to the receiver"	(innerTarget isKindOf: PasteUpMorph) ifTrue:		[self addHandle: haloSpec				on: #mouseDown send: #presentViewMenu to: innerTarget].! !!ImageMorph methodsFor: 'accessing' stamp: 'sw 10/24/2000 05:53'!setNewImageFrom: formOrNil	"Change the receiver's image to be one derived from the supplied form.  If nil is supplied, clobber any existing image in the receiver, and in its place put a default graphic, either the one known to the receiver as its default value, else a squeaky mouse"	|  defaultImage |	formOrNil ifNotNil: [^ self image: formOrNil].	defaultImage _ self defaultValueOrNil ifNil: [ScriptingSystem squeakyMouseForm].	self image: defaultImage! !!ImageMorph methodsFor: 'other' stamp: 'sw 10/23/2000 18:22'!couldHoldSeparateDataForEachInstance	"Answer whether the receiver can potentially hold separate data for each instance"	^ true! !!ImageMorph methodsFor: 'other' stamp: 'sw 10/23/2000 18:22'!currentDataValue	"Answer the current data value of the receiver, to be stored in each card instance if appropriate"	^ image! !!ImageMorph methodsFor: 'other' stamp: 'sw 10/25/2000 06:58'!variableDocks	"Answer a list of VariableDock objects for docking up my data with an instance held in my containing playfield"	^ Array with: (VariableDock new variableName: self defaultVariableName type: #form definingMorph: self morphGetSelector: #image morphPutSelector: #setNewImageFrom:)! !!Object class methodsFor: 'instance creation' stamp: 'sw 10/16/2000 10:58'!instanceOfUniqueClass	"Answer an instance of a unique subclass of the receiver"	^ self instanceOfUniqueClassWithInstVarString: '' andClassInstVarString: ''! !!HierarchyBrowser class methodsFor: 'as yet unclassified' stamp: 'sw 10/23/2000 18:20'!newFor: aClass labeled: aLabel	"Open a new HierarchyBrowser on the given class, using aLabel as the window title."	|  newBrowser |	newBrowser _ HierarchyBrowser new initHierarchyForClass: aClass.	Browser openBrowserView: (newBrowser openSystemCatEditString: nil)		label: aLabel"HierarchyBrowser newFor: Boolean labeled: 'Testing'"! !!MethodHolder class methodsFor: 'instance creation' stamp: 'sw 10/27/2000 17:28'!isolatedCodePaneForClass: aClass selector: aSelector	"Answer a MethodMorph on the given class and selector"	| aCodePane aMethodHolder |	aMethodHolder _ self new.	aMethodHolder methodClass: aClass methodSelector: aSelector.	aCodePane _ MethodMorph on: aMethodHolder text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aMethodHolder addDependent: aCodePane.	aCodePane borderWidth: 2; color: Color white.	aCodePane scrollBarOnLeft: false.	aCodePane width: 300.	^ aCodePane! !!MethodHolder class methodsFor: 'instance creation' stamp: 'sw 10/23/2000 18:55'!makeIsolatedCodePaneForClass: aClass selector: aSelector	"Create, and place in the morphic Hand, an isolated code pane bearing source code for the given class and selector"	(self isolatedCodePaneForClass: aClass selector: aSelector) openInHand! !!Morph class methodsFor: 'scripting' stamp: 'sw 10/27/2000 10:33'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #(		(#basic (			(slot x 'The x coordinate' number readWrite player getX player setX:)			(slot y  	'The y coordinate' number readWrite	player 	getY player setY:)			(slot heading  'Which direction the object is facing.  0 is straight up' number readWrite player getHeading player setHeading:)			(command forward: 'Moves the object forward in the direction it is heading' number)			(command turn: 'Change the heading of the object by the specified amount' number)			(command beep: 'Make the specified sound' sound)))		(#'color & border' (			(slot color 'The color of the object' color readWrite player getColor  player  setColor:)			(slot colorUnder 'The color under the center of the object' color readOnly player getColorUnder unused  unused )			(slot borderColor 'The color of the object''s border' color readWrite player getBorderColor player  setBorderColor:)			(slot borderWidth 'The width of the object''s border' number readWrite player getBorderWidth player setBorderWidth:)			(slot roundedCorners 'Whether corners should be rounded' boolean readWrite player getRoundedCorners player setRoundedCorners:)))		(geometry (			(slot  scaleFactor 'Yeah, the scale factor' number readWrite player getScaleFactor player setScaleFactor:)			(slot  left   'The left edge, yeah' number readWrite player getLeft  player  setLeft:)			(slot right  'The right edge, yeah' number readWrite player getRight  player  setRight:)			(slot  top  'The top edge' number readWrite player getTop  player  setTop:) 			(slot  bottom  'The bottom edge' number readWrite player getBottom  player  setBottom:) 			(slot  width  'The width' number readWrite player getWidth  player  setWidth:)			(slot  height  'The height' number readWrite player getHeight  player  setHeight:) 			(slot x   'The x coordinate' number readWrite player  getX   player setX:)			(slot y   'The y coordinate' number readWrite player  getY  player setY:)			(slot heading  'Which direction the object is facing.  0 is straight up' number readWrite player getHeading  player setHeading:)))		(miscellaneous (			(command doMenuItem: 'do the menu item' menu) 			(command show 'show the guy')			(command hide 'hide the guy')			(command wearCostumeOf: 'wear the costume of...' player)			(command startScript: 'start the given script ticking' string)			(command stopScript: 'make the given script be "normal"' string)			(command pauseScript: 'make the given script be "paused"' string)			(slot copy 'returns a copy of this object' player readOnly player getNewClone	 unused unused)			(slot elementNumber 'my index in my container' number readWrite player getIndexInOwner player setIndexInOwner:)))		(motion (			(slot x 'The x coordinate' number readWrite player getX player setX:)			(slot y  	'The y coordinate' number readWrite	player 	getY player setY:)			(slot heading  'Which direction the object is facing.  0 is straight up' number readWrite player getHeading player setHeading:)			(command forward: 'Moves the object forward in the direction it is heading' number)			(slot obtrudes 'whether the object sticks out over its container''s edge' boolean readOnly player getObtrudes unused unused) 			(command moveToward: 'move toward the given object' player) 			(command turn: 'Change the heading of the object by the specified amount' number)			(command bounce: 'bounce off the edge if hit' sound) 			(command wrap 'wrap off the edge if appropriate') 			(command followPath 'follow the yellow brick road') 			(command goToRightOf: 'place this object to the right of another' player)))		(#'pen use' (			(slot penColor 'the color of ink used by the pen' color readWrite player getPenColor player setPenColor:) 			(slot penSize 'the width of the pen' number readWrite player getPenSize player setPenSize:) 			(slot penDown 'whether the pen is currently down' boolean readWrite player getPenDown player setPenDown:)))		(#tests (			(slot isOverColor 'whether any part of the object is over the given color' boolean	readOnly player dummy unused unused) 			(slot isUnderMouse 'whether the object is under the current mouse position' boolean readOnly	player getIsUnderMouse unused unused)			(slot colorSees	'whether the given color sees the given color' boolean readOnly	player dummy	unused	unused)			(slot obtrudes 'whether the object sticks out over its container''s edge' boolean readOnly player getObtrudes unused unused))))! !!Morph class methodsFor: 'scripting' stamp: 'sw 10/27/2000 17:35'!helpContributions	"Answer a list of pairs of the form (<symbol> <help message> ) to contribute to the system help dictionary"	"NB: Many of the items here are not needed any more since they're specified as part of command definitions now.  Someone needs to take the time to go through the list and remove items no longer needed.  But who's got that kind of time?"	^ #(		(acceptScript:for:			'submit the contents of the given script editor as the code defining the given selector')		(actorState			'return the ActorState object for the receiver, creating it if necessary')		(addInstanceVariable			'start the interaction for adding a new instance variable to the receiver')		(addPlayerMenuItemsTo:hand:			'add player-specific menu items to the given menu, on behalf of the given hand.  At present, these are only commands relating to the turtle')		(addYesNoToHand			'Press here to tear off a  TEST/YES/NO unit which you can drop into your script')		(allScriptEditors			'answer a list off the extant ScriptEditors for the receiver')		(amount			'The amount of displacement')		(angle				'The angular displacement')		(anonymousScriptEditorFor:			'answer a new ScriptEditor object to serve as the place for scripting an anonymous (unnamed, unsaved) script for the receiver')		(append:			'add an object to this container')		(assignDecrGetter:setter:amt:			'evaluate the decrement variant of assignment')		(assignGetter:setter:amt:			'evaluate the vanilla variant of assignment')		(assignIncrGetter:setter:amt:			'evalute the increment version of assignment')		(assignMultGetter:setter:amt:			'evaluate the multiplicative version of assignment')		(assureEventHandlerRepresentsStatus			'make certain that the event handler associated with my current costume is set up to conform to my current script-status')		(assureExternalName			'If I do not currently have an external name assigned, get one now')		(assureUniClass			'make certain that I am a member a uniclass (i.e. a unique subclass); if I am not, create one now and become me into an instance of it')		(availableCostumeNames			'answer a list of strings representing the names of all costumes currently available for me')		(availableCostumesForArrows			'answer a list of actual, instantiated costumes for me, which can be cycled through as the user hits a next-costume or previous-costume button in a viewer')		(beep:			'make the specified sound')		(borderColor			'The color of the object''s border')		(borderWidth			'The width of the object''s border')		(bottom			'My bottom edge, measured downward from the top edge of the world')		(bounce:			'If object strayed beyond the boundaries of its container, make it reflect back into it, making the specified noise while doing so.')		(bounce			'If object strayed beyond the boundaries of its container, make it reflect back into it')		(chooseTrigger'When this script should run."normal" means "only when called"')		(clearTurtleTrails			'Clear all the pen trails in the interior.')		(color				'The object''s interior color')		(colorSees			'Whether a given color in the object is over another given color')		(colorUnder			'The color under the center of the object')		(copy			'Return a new object that is very much like this one')		(cursor				'The index of the chosen element')		(deleteCard			'Delete the current card.')		(dismiss			'Click here to dismiss me')		(elementNumber			'My element number as seen by my owner')		(firstPage			'Go to first page of book')		(followPath				'Retrace the path the object has memorized, if any.')		(forward:			'Moves the object forward in the direction it is heading') 		(goto:			'Go to the specfied book page')		(goToNextCardInStack			'Go to the next card')		(goToPreviousCardInStack			'Go to the previous card.')		(goToRightOf:			'Align the object just to the right of any specified object.')		(heading			'Which direction the object is facing.  0 is straight up') 		(height				'The distance between the top and bottom edges of the object')		(hide			'Make the object so that it does not display and cannot handle input')		(initiatePainting				'Initiate painting of a new object in the standard playfield.')		(initiatePaintingIn:			'Initiate painting of a new object in the given place.')		(isOverColor			'Whether any part of this object is directly over the specified color')		(isUnderMouse			'Whether any part of this object is beneath the current mouse-cursor position')		(lastPage			'Go to the last page of the book.')		(left			'My left edge, measured from the left edge of the World')		(leftRight			'The horizontal displacement')		(liftAllPens			'Lift the pens on all the objects in my interior.')		(lowerAllPens			'Lower the pens on all the objects in my interior.')		(mouseX			'The x coordinate of the mouse pointer')		(mouseY			'The y coordinate of the mouse pointer')		(moveToward:			'Move in the direction of another object.')		(insertCard			'Create a new card.')		(nextPage			'Go to next page.')		(numberAtCursor			'The number held by the object at the chosen element')		(objectNameInHalo			'Object''s name -- To change: click here, edit, hit ENTER')		(obtrudes			'Whether any part of the object sticks out beyond its container''s borders')		(offerScriptorMenu			'Owner and script name.Press to get a menu')		(pauseScript:			'Make a running script become paused.')		(penDown			'Whether the object''s pen is down (true) or up (false)')		(penColor			'The color of the object''s pen')		(penSize				'The size of the object''s pen')		(playerSeeingColorPhrase			'The player who "sees" a given color')		(previousPage			'Go to previous page')		(show			'If object was hidden, make it show itself again.')		(startScript:			'Make a script start running.')		(stopScript:			'Make a script stop running.')		(top			'My top edge, measured downward from the top edge of the world')		(right			'My right edge, measured from the left edge of the world')		(roundUpStrays			'Bring all out-of-container subparts back into view.')		(scaleFactor			'The amount by which the object is scaled')		(stopScript:			'make the specified script stop running')		(try			'Run this command once.')		(tryMe			'Click here to run this script once; hold button down to run repeatedly.')		(turn:							'Change the heading of the object by the specified amount')		(unhideHiddenObjects			'Unhide all hidden objects.')		(upDown			'The vertical displacement')		(userScript			'This is a script defined by you.')		(userSlot			'This is an instance variable defined by you.  Click here to change its type')		(valueAtCursor			'The chosen element')		(wearCostumeOf:			'Wear the same kind of costume as the other object')		(width				'The distance between the left and right edges of the object')		(wrap			'If object has strayed beond the boundaries of its container, make it reappear from the opposite edge.')		(x			'The x coordinate, measured from the left of the container')		(y			'The y-coordinate, measured upward from the bottom of the container')		)! !!BalloonMorph class methodsFor: 'private' stamp: 'sw 10/26/2000 09:44'!getBestLocation: vertices for: morph corner: cornerName	"Try four rel locations of the balloon for greatest unclipped area.   12/99 sma"	| rect maxArea verts rectCorner morphPoint mbc a mp dir bestVerts result usableArea |	rect _ vertices first rect: (vertices at: 5).	maxArea _ -1.	verts _ vertices.	usableArea _ (morph world ifNil: [self currentWorld]) viewBox.	1 to: 4 do: [:i |		dir _ #(vertical horizontal) atWrap: i.		verts _ verts collect: [:p | p flipBy: dir centerAt: rect center].		rectCorner _ #(bottomLeft bottomRight topRight topLeft) at: i.		morphPoint _ #(topCenter topCenter bottomCenter bottomCenter) at: i.		a _ ((rect			align: (rect perform: rectCorner)			with: (mbc _ morph boundsForBalloon perform: morphPoint))				intersect: usableArea) area.		(a > maxArea or: [a = rect area and: [rectCorner = cornerName]]) ifTrue:			[maxArea _ a.			bestVerts _ verts.			mp _ mbc]].	result _ bestVerts collect: [:p | p + (mp - bestVerts first)] "Inlined align:with:".	^ result! !!ImageMorph class methodsFor: 'instance creation' stamp: 'sw 10/23/2000 18:21'!fromString: aString 	"Create a new ImageMorph which displays the input string in the standard button font"	^ self fromString: aString font: Preferences standardButtonFont! !!ImageMorph class methodsFor: 'instance creation' stamp: 'sw 10/23/2000 18:21'!fromString: aString font: aFont	"Create a new ImageMorph showing the given string in the given font"	^ self new image: (StringMorph contents: aString font: aFont) imageForm! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/17/2000 11:35'!categoriesForViewer	"Answer a list of symbols representing the categories to offer in the viewer, in order"	^ objectRepresented class organization categories! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/31/2000 09:31'!categoryElementsFor: aCategorySymbol	"Answer a list of tuples that characterize the elements in the given category.  Every class in the receiver's superclass chain which implements #additionsToViewerCategories is given the chance to add elements to the category"	| aList org |	org _  objectRepresented class organization.	aList _ (org listAtCategoryNamed: aCategorySymbol) select:		[:anElement | anElement numArgs < 2].	^ aList collect:		[:sel | 			sel numArgs == 0				ifTrue:					[Array with: #command with: sel with: 'help here later']				ifFalse:					[Array with: #command with: sel with: 'help here later' with: #string]]! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/31/2000 09:22'!nameOfObjectRepresented	"Answer the external name of the object represented"	^ objectRepresented externalName! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/17/2000 11:42'!objectRepresented	"Answer the object represented by the receiver"	^ objectRepresented! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/17/2000 11:43'!objectRepresented: anObject	"Set the receiver's representee.  This clears out any preexisting state in the receiver"	objectRepresented _ anObject.	self removeAllMorphs.	hResizing _ #shrinkWrap.  vResizing _ #shrinkWrap.	self addMorphBack: (StringMorph new contents: anObject name asString).	self setNameTo: anObject name	! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/17/2000 11:44'!objectRepresented: anObject labelString: aLabel	"Set the receiver's representee as indicated, and use the given label to tag it"	objectRepresented _ anObject.	self removeAllMorphs.	hResizing _ #shrinkWrap.  vResizing _ #shrinkWrap.	self addMorphBack: (StringMorph new contents: aLabel asString).	self setNameTo: aLabel asString	! !!ListViewLine methodsFor: 'list view line' stamp: 'sw 10/23/2000 18:27'!listViewLineForFieldList: aFieldList	"Answer a list view line containing data representing the items in aFieldList"	^ objectRepresented == self		ifFalse:			[objectRepresented listViewLineForFieldList: aFieldList]		ifTrue:			[super listViewLineForFieldList: aFieldList]! !!ListViewLine methodsFor: 'object represented' stamp: 'sw 10/31/2000 07:52'!objectRepresented: anObject	"Set the object represented by the receiver to be as requested"	objectRepresented _ anObject.	hResizing _ #shrinkWrap.  vResizing _ #shrinkWrap.	self setNameTo: anObject name.	self removeAllMorphs.! !!PasteUpMorph methodsFor: 'initialization' stamp: 'sw 10/18/2000 10:51'!newPlayerInstance	"Answer a naked player instance given that one does not yet exist; hence, launch a uniclass and answer an instance of it.  cf inherited version."	^ CardPlayer instanceOfUniqueClass! !!PasteUpMorph methodsFor: 'display' stamp: 'sw 10/18/2000 10:54'!printOn: aStream	"Reimplemented to add a tag showing that the receiver is currently functioning as a 'world', if it is"	super printOn: aStream.	self isWorldMorph ifTrue: [aStream nextPutAll: ' [world]']! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/24/2000 13:53'!acceptDroppingMorph: dropped event: evt	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"	| mm tfm aMorph |	aMorph _ self morphToDropFrom: dropped.	self isWorldMorph		ifTrue:			["Add the given morph to this world and start stepping it if it wants to be."			self addMorphFront: aMorph.			(aMorph fullBounds intersects: self viewBox) ifFalse:				[self beep.  aMorph position: self bounds center]]		ifFalse:			[self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).			self changed.			self layoutChanged].	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self autoLineLayout ifTrue: [self fixLayout].	aMorph allMorphsDo:  "Establish any penDown morphs in new world"		[:m | m player ifNotNil:			[m player getPenDown ifTrue:				[((mm _ m player costume) notNil and: [(tfm _ mm owner transformFrom: self) notNil])					ifTrue: [self noteNewLocation: (tfm localPointToGlobal: mm referencePosition)									forPlayer: m player]]]].	self isPartsBin		ifTrue:			[aMorph isPartsDonor: true.			aMorph stopSteppingSelfAndSubmorphs.			aMorph suspendEventHandler]		ifFalse:			[self world startSteppingSubmorphsOf: aMorph].	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	self showingListView ifTrue:		[self sortAndPositionSubmorphs.		self horizontallyAlignSubmorphSubparts.		self currentWorld abandonAllHalos]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/31/2000 09:29'!horizontallyAlignSubmorphSubparts	"Horizontally align de subparts of de submorphs into columns"	| sample maxWidths |	"Maddeningly, seems to work correctly often but not always"	submorphs size == 0 ifTrue: [^ self].	sample _ submorphs first.   "one of those line-layout things"	maxWidths _ sample submorphs collect: [:m | m fullBounds width].		submorphs do:		[:m | m submorphs doWithIndex:			[:subsub :index |				maxWidths at: index put: ((maxWidths at: index) max: (subsub fullBounds width))]].	submorphs do:		[:m | m submorphs doWithIndex:			[:subSub :index |				subSub width: (maxWidths at: index)]]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/24/2000 07:39'!morphToDropFrom: aMorph	"Given a morph being carried by the hand, which the hand is about to drop, answer the actual morph to be deposited.  Normally this would be just the morph itself, but several unusual cases arise, which this method is designed to service."	| aNail representee handy posBlock tempPos |	handy _ self primaryHand.	posBlock _ [:z | 			tempPos _ handy position - (handy targetOffset - aMorph formerPosition * (z extent / aMorph extent)) rounded.			self pointFromWorld: tempPos].	self alwaysShowThumbnail		ifTrue: [aNail _ aMorph						representativeNoTallerThan: self maxHeightToAvoidThumbnailing						norWiderThan: self maximumThumbnailWidth						thumbnailHeight: self heightForThumbnails.			aNail == aMorph				ifFalse: [aNail						position: (posBlock value: aNail)].			^ aNail].	((aMorph isKindOf: MorphThumbnail)			and: [(representee _ aMorph morphRepresented) owner == nil])		ifTrue: [representee				position: (posBlock value: representee).			^ representee].	self showingListView ifTrue:		[^ aMorph listViewLineForFieldList: (self valueOfProperty: #fieldListSelectors)].	self automaticPhraseExpansion		ifFalse: [^ aMorph].	(aMorph hasProperty: #newPermanentScript)		ifTrue: [^ aMorph asEmptyPermanentScriptor].	(aMorph isKindOf: PhraseTileMorph)		ifFalse: [^ aMorph].	^ aMorph morphToDropInPasteUp: self! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 10/31/2000 07:03'!layoutChanged	"The receiver's layout changed; inform above and below"		self showingListView ifFalse: [super layoutChanged].	(self valueOfProperty: #SqueakPage) ifNotNil: [		self setProperty: #pageDirty toValue: true].		"I am the morph of a SqueakPage, I have changed and 		need to be written out again"! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 10/30/2000 18:12'!addPenMenuItems: menu hand: aHandMorph	"Add a pen-trails-within submenu to the given menu"	| subMenu |	subMenu _ MenuMorph new defaultTarget: self.	self addPenTrailsMenuItemsTo: subMenu.	menu add: 'pens trails within...' subMenu: subMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 10/30/2000 18:12'!addPenTrailsMenuItemsTo: aMenu	| oldTarget |	"Add items relating to pen trails to aMenu"	oldTarget _ aMenu defaultTarget.	aMenu defaultTarget: self.	aMenu add: 'clear pen trails' action: #clearTurtleTrails.	aMenu add: 'all pens up' action: #liftAllPens.	aMenu add: 'all pens down' action: #lowerAllPens.	aMenu defaultTarget: oldTarget! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 10/23/2000 14:41'!addStackMenuItems: menu hand: aHandMorph	"Add appropriate stack-related items to the given menu"	self isStackBackground		ifTrue:			[menu add: 'card & stack...' target: self action: #presentCardAndStackMenu]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 10/25/2000 06:18'!playfieldOptionsMenu	"Answer an auxiliary menu with options specific to playfields -- too many to be housed in the main menu"	| aMenu isWorld |	isWorld _ self isWorldMorph.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu add: 'save on file...' action: #saveOnFile.	aMenu add: 'save as SqueakPage at url...' action: #saveOnURL.	aMenu add: 'update all from resources' action: #updateAllFromResources.	(self valueOfProperty: #classAndMethod) ifNotNil:		[aMenu add: 'broadcast as documentation' action: #saveDocPane].	aMenu add: 'round up strays' action: #roundUpStrays.	aMenu balloonTextForLastItem:  'Bring back all objects whose current coordinates keep them from being visible, so that at least a portion of each of my interior objects can be seen.'.	aMenu addLine.	aMenu add: 'shuffle contents' action: #shuffleSubmorphs.	aMenu balloonTextForLastItem: 'Rearranges my contents in random order'.	self griddingOn		ifTrue: [aMenu add: 'turn gridding off' action: #griddingOnOff.				aMenu add: (self gridVisible ifTrue: ['hide'] ifFalse: ['show']) , ' grid'						action: #gridVisibleOnOff.				aMenu add: 'set grid spacing...' action: #setGridSpec]		ifFalse: [aMenu add: 'turn gridding on' action: #griddingOnOff].	aMenu addLine.	#(	(autoLineLayoutString	toggleAutoLineLayout			'whether submorphs should automatically be laid out in lines')		(indicateCursorString	toggleIndicateCursor			'whether the "current" submorph should be indicated with a dark black border')		(isPartsBinString		toggleIsPartsBin			'whether dragging an object from the interior should produce a COPY of the object')		(isOpenForDragNDropString	toggleDragNDrop			'whether objects can be dropped into and dragged out of me')		(mouseOverHalosString	toggleMouseOverHalos			'whether objects should put up halos when the mouse is over them')		(autoExpansionString	toggleAutomaticPhraseExpansion			'whether tile phrases, dropped on me, should automatically sprout Scriptors around them')		(originAtCenterString	toggleOriginAtCenter			'whether the cartesian origin of the playfield should be at its lower-left corner or at the center of the playfield')		(showThumbnailString	toggleAlwaysShowThumbnail			'whether large objects should be represented by thumbnail miniatures of themselves')		(fenceEnabledString	toggleFenceEnabled			'whether moving objects should stop at the edge of their container')		(batchPenTrailsString	toggleBatchPenTrails 			'if true, detailed movement of pens between display updates is ignored.  Thus multiple line segments drawn within a script may not be seen individually.')	) do:			[:triplet |				(isWorld and: [#(toggleAutoLineLayout toggleIndicateCursor toggleIsPartsBin toggleAlwaysShowThumbnail) includes: triplet second]) ifFalse:					[aMenu addUpdating: triplet first action: triplet second.					aMenu balloonTextForLastItem: triplet third]]. 	aMenu addUpdating: #autoViewingString action: #toggleAutomaticViewing.	aMenu balloonTextForLastItem:  'governs whether, when an object is touched inside me, a viewer should automatically be launched for it.'.	((isWorld not or: [self backgroundSketch notNil]) or: [presenter isNil])		ifTrue:			[aMenu addLine].	isWorld ifFalse:		[aMenu add: 'set thumbnail height...' action: #setThumbnailHeight.		aMenu balloonTextForLastItem: 'if currently showing thumbnails governs the standard height for them'.		aMenu add: 'behave like a Holder' action: #becomeLikeAHolder.		aMenu balloonTextForLastItem: 'Set properties to make this object nicely set up to hold frames of a scripted animation.'].	self backgroundSketch ifNotNil:		[aMenu add: 'delete background painting' action: #deleteBackgroundPainting.		aMenu balloonTextForLastItem: 'delete the graphic that forms the background for this me.'].	presenter ifNil:		[aMenu add: 'make detachable' action: #makeDetachable.		aMenu balloonTextForLastItem: 'Allow this area to be separately governed by its own controls.'].	aMenu addLine.	aMenu add: 'use standard texture' action: #setStandardTexture.	aMenu balloonTextForLastItem: 'use a pale yellow-and-blue background texture here.'.	aMenu add: 'make graph paper...' action: #makeGraphPaper.	aMenu balloonTextForLastItem: 'Design your own graph paper and use it as the background texture here.'.	aMenu addTitle: 'playfield options...'.	^ aMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 10/26/2000 11:32'!presentCardAndStackMenu	"Put up a menu holding card/stack-related options."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.			aMenu addStayUpItem.	aMenu addTitle: 'card und stack'.	aMenu add: 'add new card' action: #insertCard.	aMenu add: 'delete this card' action: #deleteCard.	aMenu add: 'go to next card' action: #goToNextCardInStack.	aMenu add: 'go to previous card' action: #goToPreviousCardInStack.	aMenu addLine.	aMenu add: 'show foreground objects' action: #showForegroundObjects.	aMenu add: 'show background objects' action: #showBackgroundObjects.	aMenu add: 'show designations' action: #showDesignationsOfObjects.	aMenu add: 'explain designations'  action: #explainDesignations.	aMenu popUpInWorld: (self world ifNil: [self currentWorld])! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 10/30/2000 18:13'!presentViewMenu	"Answer an auxiliary menu with options specific to viewing playfields -- this is put up from the provisional 'view' halo handle, on pasteup morphs only."	| aMenu isWorld |	isWorld _ self isWorldMorph.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	self addViewingItemsTo: aMenu.	aMenu addLine.	#(	"(autoLineLayoutString	toggleAutoLineLayout			'whether submorphs should automatically be laid out in lines')"		(indicateCursorString	toggleIndicateCursor			'whether the "current" submorph should be indicated with a dark black border')		(resizeToFitString		toggleResizeToFit			'whether I should automatically strive exactly to fit my contents')		(behaveLikeAHolderString	toggleBehaveLikeAHolder			'whether auto-line-layout, resize-to-fit, and indicate-cursor should be set to true; useful for animation control, etc.')		(isPartsBinString		toggleIsPartsBin			'whether dragging an object from the interior should produce a COPY of the object')		(isOpenForDragNDropString	toggleDragNDrop			'whether objects can be dropped into and dragged out of me')		(mouseOverHalosString	toggleMouseOverHalos			'whether objects should put up halos when the mouse is over them')		(autoExpansionString	toggleAutomaticPhraseExpansion			'whether tile phrases, dropped on me, should automatically sprout Scriptors around them')		(originAtCenterString	toggleOriginAtCenter			'whether the cartesian origin of the playfield should be at its lower-left corner or at the center of the playfield')		(showThumbnailString	toggleAlwaysShowThumbnail			'whether large objects should be represented by thumbnail miniatures of themselves')		(fenceEnabledString	toggleFenceEnabled			'whether moving objects should stop at the edge of their container')		(autoViewingString		toggleAutomaticViewing			'governs whether, when an object is touched inside me, a viewer should automatically be launched for it.')		(griddingString			griddingOnOff			'whether gridding should be used in my interior')		(gridVisibleString		gridVisibleOnOff			'whether the grid should be shown when gridding is on')	) do:			[:triplet |				(isWorld and: [#(toggleAutoLineLayout toggleIndicateCursor toggleIsPartsBin toggleAlwaysShowThumbnail toggleAutomaticViewing ) includes: triplet second]) ifFalse:					[aMenu addUpdating: triplet first action: triplet second.					aMenu balloonTextForLastItem: triplet third]]. 	aMenu addLine.	aMenu add: 'round up strays' action: #roundUpStrays.	aMenu balloonTextForLastItem:  'Bring back all objects whose current coordinates keep them from being visible, so that at least a portion of each of my interior objects can be seen.'.	aMenu add: 'shuffle contents' action: #shuffleSubmorphs.	aMenu balloonTextForLastItem: 'Rearranges my contents in random order'.	aMenu add: 'set grid spacing...' action: #setGridSpec.	aMenu balloonTextForLastItem: 'Set the spacing to be used when gridding is on'.	isWorld ifFalse:		[aMenu add: 'set thumbnail height...' action: #setThumbnailHeight.		aMenu balloonTextForLastItem: 'if currently showing thumbnails governs the standard height for them'].	self backgroundSketch ifNotNil:		[aMenu add: 'delete background painting' action: #deleteBackgroundPainting.		aMenu balloonTextForLastItem: 'delete the graphic that forms the background for this me.'].	aMenu addLine.	self addPenTrailsMenuItemsTo: aMenu.	aMenu addLine.	aMenu add: 'use standard texture' action: #setStandardTexture.	aMenu balloonTextForLastItem: 'use a pale yellow-and-blue background texture here.'.	aMenu add: 'make graph paper...' action: #makeGraphPaper.	aMenu balloonTextForLastItem: 'Design your own graph paper and use it as the background texture here.'.	aMenu addTitle: 'viewing options for "', self externalName, '"'.	aMenu popUpForHand: self activeHand in: self world! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/24/2000 13:51'!autoLineLayout: aBoolean	"Make the receiver be viewed with auto-line-layout, which means that its submorphs will be laid out left-to-right and then top-to-bottom in the manner of a word processor, or (if aBoolean is false,) cease applying auto-line-layout"	aBoolean ifTrue:		[self viewingNormally ifTrue: [self saveBoundsOfSubmorphs]].	autoLineLayout _ aBoolean! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/17/2000 12:02'!behaveLikeAHolderString	"Answer a string to be displayed in a menu to characterize whether the receiver is currently behaving like a holder"	^ (self behavingLikeAHolder ifTrue: ['<yes>'] ifFalse: ['<no>']), 'behave like a holder'! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/17/2000 12:04'!behaveLikeHolder: aBoolean 	"Change the receiver's viewing properties such that they conform to what we commonly call a Holder, viz: resize-to-fit, do auto-line-layout, and indicate the 'cursor'"	self resizeToFit: aBoolean; autoLineLayout: aBoolean; indicateCursor: aBoolean;		fixLayout; layoutChanged	! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/17/2000 12:04'!behavingLikeAHolder	"Answer whether the receiver is currently behaving like a Holder"	^ self resizeToFit and: [self indicateCursor and: [self autoLineLayout]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/18/2000 10:58'!resizeToFitString	"Answer a string, to be used in a self-updating menu, to represent whether the receiver is currently using resize-to-fit or not"	^ (self resizeToFit ifTrue: ['<yes>'] ifFalse: ['<no>']), 'resize to fit'! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/30/2000 18:06'!toggleAutoLineLayout	"Toggle the auto-line-layout setting"	autoLineLayout _ self autoLineLayout not.	autoLineLayout ifFalse: [self restoreBoundsOfSubmorphs].	self fixLayout.	self layoutChanged! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/23/2000 19:04'!toggleBehaveLikeAHolder	"Toggle whether or not the receiver is currently behaving like a holder"	self behaveLikeHolder: (self behavingLikeAHolder not)! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 10/23/2000 19:04'!toggleResizeToFit	"Toggle whether the receiver is set to resize-to-fit"	self resizeToFit: self resizeToFit not! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 10/17/2000 11:56'!backgroundSketch: aSketchMorphOrNil	"Set the receiver's background graphic as indicated.  If nil is supplied, remove any existing background graphic.  In any case, delete any preexisting background graphic."	backgroundMorph ifNotNil: [backgroundMorph delete].  "replacing old background"	aSketchMorphOrNil ifNil: [backgroundMorph _ nil.  ^ self].	backgroundMorph _ StickySketchMorph new form: aSketchMorphOrNil form.	backgroundMorph position: aSketchMorphOrNil position.	self addMorphBack: backgroundMorph.	aSketchMorphOrNil delete.	backgroundMorph lock.	backgroundMorph setProperty: #shared toValue: true.	^ backgroundMorph! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/26/2000 10:56'!beAStackBackground	"Transform the receiver into one that has stack-background behavior.  If just becoming a stack, allocate a uniclass to represent the cards (if one does not already exist"	self assuredPlayer assureUniClass.	self setProperty: #tabAmongFields toValue: true.	self setProperty: #stackBackground toValue: true.	self reassessBackgroundShape! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/19/2000 19:15'!currentDataInstance	"Answer the current data instance"	^ self player! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/31/2000 04:59'!explainDesignations	"Hand the user an object that contains explanations for the designation feedback used"	StackMorph designationsExplainer openInHand	"self currentWorld explainDesignations"! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/23/2000 16:03'!insertCard	"Insert a new card in the stack, with the receiver as its background, and have it become the current card of the stack"	self stackDo: [:aStack | aStack insertCardOfBackground: self]! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/19/2000 19:11'!installAsCurrent: anInstance	"Install anInstance as the one currently viewed in the receiver.  Dock up all the morphs in the receiver which contain data rooted in the player instance to the instance data.  Run any 'opening' scripts that pertain."	| fieldList itsFocus |	self player == anInstance ifTrue: [^ self].	fieldList _ self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]].	self currentWorld hands do:		[:aHand | (itsFocus _ aHand keyboardFocus) notNil ifTrue:			[(fieldList includes: itsFocus) ifTrue: [aHand newKeyboardFocus: nil]]].	self player uninstallFrom: self.  "out with the old"	anInstance installPrivateMorphsInto: self.	self changed.	anInstance costume: self.	self player: anInstance.	self player class variableDocks do:		[:aVariableDock | aVariableDock dockMorphUpToInstance: anInstance].	anInstance runAllOpeningScripts! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/26/2000 10:58'!isStackBackground	"Answer whether the receiver serves as a background of a stack"	^ (owner isKindOf: StackMorph) or: [self hasProperty: #stackBackground]	"This odd property-based check is because when a paste-up-morph is not the *current* background of a stack, it is maddeningly ownerlyess"! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/23/2000 17:02'!newCard	"Create a new card for the receiver and return it"	| aNewInstance |	self isStackBackground ifFalse: [^ self beep].  "bulletproof against deconstruction"	aNewInstance _ self player class baseUniclass new.	^ aNewInstance! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/26/2000 13:29'!reassessBackgroundShape	"A change has been made which may affect the instance structure of the Card uniclass that holds the instance state, which can also be thought of as the 'card data'."	| takenNames uniqueName requestedName  variableDocks docks |	"Caution: still to be done: the mechanism so that when a new instance variable is added, it gets initialized in all subinstances of the receiver's player, which are the cards of this shape.  One needs to take into account here the instance variable names coming in; those that are unchanged should keep their values, but those that have newly arrived should obtain their default values from the morphs on whose behalf they are being maintained in the model"	Cursor wait showWhile:		[variableDocks _ OrderedCollection new.  "This will be stored in the uniclass's class-side inst var #variableDocks"		takenNames _ OrderedCollection new.		(self submorphs select: [:aMorph | aMorph holdsSeparateDataForEachInstance]) do: 			[:aMorph |				docks _ aMorph variableDocks.  		"Each morph can request multiple variables.  		This complicates matters somewhat but creates a generality for Fabrk-like uses.		Each spec is an instance of VariableDock, and it provides a point of departure		for the negotiation between the PasteUp and its constitutent morphs"				docks do:					[:aVariableDock |						uniqueName _ self player uniqueInstanceVariableNameLike: (requestedName _ aVariableDock variableName) excluding: takenNames.						uniqueName ~= requestedName ifTrue:							[aVariableDock variableName: uniqueName.							aMorph noteNegotiatedName: uniqueName for: requestedName].						takenNames add: uniqueName].				variableDocks addAll: docks].				self player class setNewInstVarNames: 			(variableDocks collect: [:info | info variableName asString]).  "NB: sets up accessors, and removes obsolete ones"		self player class newVariableDocks: variableDocks]! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/18/2000 10:57'!relaxGripOnVariableNames	"Abandon any memory of specific variable names that should be preserved.  The overall situation here is not yet completely understood, and this relaxation is basically always done on each reassessment of the background shape nowadays.  But this doesn't feel quite right, because if the user has somehow intervened to specify certain name preference we should perhaps honored it.  Or perhaps that is no longer relevant.  ????"	self submorphs do:		[:m | m removeProperty: #variableName.		m removeProperty: #setterSelector].	self reassessBackgroundShape! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/18/2000 10:58'!reshapeBackground	"Abandon any memory of variable-name preferences, and reassess the shape of the background"	self relaxGripOnVariableNames.	self reassessBackgroundShape.! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/23/2000 19:00'!showBackgroundObjects	"Momentarily highlight just the background objects on the current playfield"	self isStackBackground ifFalse: [^ self].	self invalidRect: self bounds.	self currentWorld doOneCycle.	Display restoreAfter:		[self submorphsDo:			[:aMorph | (aMorph renderedMorph hasProperty: #shared)				ifTrue:					[Display border: (aMorph fullBoundsInWorld insetBy:  -6) width: 6 rule: Form over fillColor: Color blue]]]! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/23/2000 19:00'!showDesignationsOfObjects	"Momentarily show the designations of objects on the receiver"	| colorToUse aLabel |	self isStackBackground ifFalse: [^ self].		self submorphsDo: [:aMorph | 		aMorph renderedMorph holdsSeparateDataForEachInstance 			ifTrue:				[colorToUse _ Color orange.				aLabel _ aMorph externalName]			ifFalse:				[colorToUse _ aMorph isShared					ifFalse:	[Color red]					ifTrue:	[Color green].				aLabel _ nil].		Display border: (aMorph fullBoundsInWorld insetBy:  -6) width: 6 rule: Form over fillColor: colorToUse.		aLabel ifNotNil:			[aLabel asString displayOn: Display at: (aMorph fullBoundsInWorld bottomLeft + (0 @ 5))]].	Sensor anyButtonPressed		ifTrue:	[Sensor waitNoButton]		ifFalse:	[Sensor waitButton].	Display repaintMorphicDisplay! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/23/2000 19:00'!showForegroundObjects	"Temporarily highlight the foreground objects"	self isStackBackground ifFalse: [^ self].	Display restoreAfter:		[self submorphsDo:			[:aMorph | aMorph renderedMorph isShared				ifFalse:					[Display border: (aMorph fullBoundsInWorld insetBy:  -6) width: 6 rule: Form over fillColor: Color orange]]]! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 10/18/2000 11:01'!tabHitWithEvent: anEvent	"The tab key was hit. The keyboard focus has referred this event to me, though this perhaps seems rather backwards.  Anyway, the assumption is that I have the property #tabAmongFields, so now the task is to tab to the next field"	| currentFocus fieldList anIndex itemToHighlight |	currentFocus _ anEvent hand keyboardFocus.	fieldList _ self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]].	anIndex _ fieldList indexOf: currentFocus ifAbsent: [nil].	itemToHighlight _ fieldList atWrap: 		(anIndex ifNotNil: [anEvent shiftPressed ifTrue: [anIndex - 1] ifFalse: [anIndex + 1]]				ifNil: [1]).	anEvent hand newKeyboardFocus: itemToHighlight. self flag: #arNote. "really???"	itemToHighlight editor selectAll.	itemToHighlight invalidRect: itemToHighlight bounds ! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 10/24/2000 13:51'!allScriptors	"Answer a list of all active scriptors running on behalf of the receiver.  This is a hook used in past demos and with a future life which however presently is vacuous"	^ #()"	^ self allMorphs select: [:m | m isKindOf: Scriptor]"! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 10/23/2000 16:04'!containsCard: aCard	"Answer whether the given card belongs to the uniclass representing the receiver"	^ self isStackBackground and: [aCard isKindOf: self player class baseUniclass]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 3/23/2000 12:52'!startRunningAll	"Start running all scripted morphs.  Triggered by user hitting GO button"	self presenter flushPlayerListCache.  "Inefficient, but makes sure things come right whenever GO hit"	self presenter allExtantPlayers do: [:aPlayer | aPlayer costume residesInPartsBin ifFalse: [aPlayer startRunning]].	self allScriptors do:		[:aScriptor | aScriptor startRunningIfPaused].	self world updateStatusForAllScriptEditors! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 10/23/2000 19:03'!stepAll	"tick all the paused player scripts in the receiver"	self presenter allExtantPlayers do:		[:aPlayer | 			aPlayer startRunning; step; stopRunning].	self allScriptors do:		[:aScript | aScript startRunningIfPaused; step; pauseIfTicking].! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 10/24/2000 07:33'!stopRunningAll	"Reset all ticking scripts to be paused.  Triggered by user hitting STOP button"	self presenter allExtantPlayers do:		[:aPlayer |		aPlayer stopRunning].	self allScriptors do:		[:aScript | aScript pauseIfTicking].	self world updateStatusForAllScriptEditors! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 10/23/2000 19:12'!viewerFlapTabFor: anObject	"Open up a Viewer on aMorph in its own flap, creating it if necessary"	| bottomMost aPlayer aFlapTab |	bottomMost _ self top.	aPlayer _ anObject isMorph ifTrue: [anObject assuredPlayer] ifFalse: [anObject objectRepresented].	self flapTabs do:		[:aTab | (aTab isKindOf: ViewerFlapTab)			ifTrue:				[bottomMost _ aTab bottom max: bottomMost.				aTab scriptedPlayer == aPlayer					ifTrue:						[^ aTab]]].	"Not found; make a new one"	aFlapTab _ (Utilities newFlapTitled: anObject nameForViewer onEdge: #right inPasteUp: self)		as: ViewerFlapTab.	aFlapTab initializeFor: aPlayer topAt: bottomMost + 2.	aFlapTab referent color: (Color green muchLighter alpha: 0.5).	aFlapTab referent setProperty: #automaticPhraseExpansion toValue: true.	self addMorphFront: aFlapTab.	aFlapTab adaptToWorld: self.	^ aFlapTab! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 10/30/2000 17:27'!viewerFlapTabForObject: anObject	"Open up a Viewer on anObject in its own flap, creating it if necessary.  This is the viewer-for-any-object version of this method, but in the current corpus of code is not hooked up."	| bottomMost aFlapTab |	bottomMost _ 0.	self flapTabs do:		[:aTab | (aTab isKindOf: ViewerFlapTab)			ifTrue:				[bottomMost _ aTab bottom max: bottomMost.				aTab scriptedPlayer == anObject					ifTrue:						[^ aTab]]].	"Not found; make a new one"	aFlapTab _ (Utilities newFlapTitled: anObject externalName onEdge: #right) as: ViewerFlapTab.	aFlapTab initializeFor: anObject topAt: bottomMost + 2.	aFlapTab referent color: (Color green muchLighter alpha: 0.5).	aFlapTab referent setProperty: #automaticPhraseExpansion toValue: true.	self addMorphFront: aFlapTab.	aFlapTab adaptToWorld: self.	^ aFlapTab! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'sw 10/23/2000 17:54'!convertbosfcebbpmcpbttliairfidcuwwg0: varDict bosfcebbpmcpbttliairwwg0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'presenter' 'model' 'cursor' 'padding' 'backgroundMorph' 'turtleTrailsForm' 'turtlePen' 'lastTurtlePositions' 'isPartsBin' 'autoLineLayout' 'indicateCursor' 'resizeToFit' 'wantsMouseOverHalos' 'worldState' 'griddingOn').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('fileName' 'isStackLike' 'dataInstances' 'currentDataInstance' 'userFrameRectangle').  Possibly store their info in another variable?"! !!PasteUpMorph methodsFor: 'gridding' stamp: 'sw 10/17/2000 12:10'!gridVisibleString	"Answer a string to be used in a menu offering the opportunity to show or hide the grid"	^ (self gridVisible ifTrue: ['<yes>'] ifFalse: ['<no>']), 'show grid when gridding'! !!PasteUpMorph methodsFor: 'gridding' stamp: 'sw 10/17/2000 12:10'!griddingString	"Answer a string to use in a menu offering the user the opportunity to start or stop using gridding"	^ (self griddingOn ifTrue: ['<yes>'] ifFalse: ['<no>']), 'use gridding'! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/31/2000 07:08'!addViewingItemsTo: aMenu	"Add viewing items to the given menu"	#(	(viewingByIconString 			viewByIcon)		(viewingByNameString 			viewByName)		"(viewingBySizeString 			viewBySize)"		(viewingNonOverlappingString 	viewNonOverlapping)) do:			[:pair |  aMenu addUpdating: pair first target:  self action: pair second]! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/31/2000 06:25'!imposeListViewSortingBy: sortOrderSymbol retrieving: fieldListSelectors	"Establish a list view of the receiver's contents, sorting the contents by the criterion represented by sortOrderSymbol, and displaying readouts as indicated by the list of field selectors."	self setProperty: #sortOrder toValue: sortOrderSymbol.	self setProperty: #fieldListSelectors toValue: fieldListSelectors.	self showingListView ifFalse:		[self autoLineLayout ifFalse: [self saveBoundsOfSubmorphs].		self setProperty: #showingListView toValue: true].	self submorphs "important that it be a copy" do:		[:aMorph | 			self replaceSubmorph: aMorph by: (aMorph listViewLineForFieldList: fieldListSelectors)].	self sortAndPositionSubmorphs.	self horizontallyAlignSubmorphSubparts.	self layoutChanged! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/5/2000 06:42'!restoreBoundsOfSubmorphs	"restores the saved xy-positions and extents"	submorphs do:		[:aSubmorph |			aSubmorph valueOfProperty: #savedExtent ifPresentDo:				[:anExtent | aSubmorph extent: anExtent].			aSubmorph valueOfProperty: #savedPosition ifPresentDo:				[:aPosition | aSubmorph position: aPosition]]! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/18/2000 10:59'!saveBoundsOfSubmorphs	"store the current xy-positions and extents of submorphs for future use"	submorphs do:		[:aSubmorph |			aSubmorph setProperty: #savedExtent toValue: aSubmorph extent.			aSubmorph setProperty: #savedPosition toValue: aSubmorph position]! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/29/2000 17:22'!scriptSelectorToTriggerFor: aButtonMorph	"Answer a new selector which will bear the code for aButtonMorph in the receiver"	| buttonName selectorName |	buttonName _ aButtonMorph externalName.	selectorName _ ScriptingSystem acceptableScriptNameFrom: buttonName  forScriptCurrentlyNamed:  nil asScriptNameIn: self assuredPlayer world: self world.	buttonName ~= selectorName ifTrue:		[aButtonMorph setNameTo: selectorName].	^ selectorName! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/23/2000 19:01'!showingListView	"Answer whether the receiver is currently showing a list view"	^ self hasProperty: #showingListView! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/23/2000 19:01'!sortAndPositionSubmorphs	"The receiver is showing a list view; sort the subparts and how them appropriately"	self sortSubmorphsBy: (self valueOfProperty: #sortOrder).	submorphs doWithIndex:		[:aMorph :anIndex |			anIndex = 1				ifTrue:					[aMorph position: self position]				ifFalse:					[aMorph position: ((submorphs at: anIndex - 1) bottomLeft + (0 @ 2))]].		self layoutChanged! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/23/2000 19:02'!sortSubmorphsBy: sortOrderSymbol	"Sort the receiver's submorphs by the criterion indicated in the provided symbol"	submorphs _ (self submorphs asSortedCollection: [:a :b | (a perform: sortOrderSymbol) <= (b perform: sortOrderSymbol)]) asOrderedCollection! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/31/2000 06:31'!viewByIcon	"The receiver has been being viewed in some constrained layout view; now restore it to its normal x-y-layout view"	|  oldSubs |	self showingListView		ifTrue:			[oldSubs _ submorphs.			self removeAllMorphs.			autoLineLayout _ false.			oldSubs do:				[:aSubmorph |					self addMorphBack:  aSubmorph objectRepresented].			self restoreBoundsOfSubmorphs.			self removeProperty: #showingListView.			self layoutChanged]		ifFalse:			[autoLineLayout == true ifTrue: [self toggleAutoLineLayout]]		! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/31/2000 09:29'!viewByName	"Make the receiver show its subparts as a vertical list of lines of information, sorted by object name"	self imposeListViewSortingBy: #downshiftedNameOfObjectRepresented retrieving: #(nameOfObjectRepresented reportableSize  className oopString)! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/31/2000 07:08'!viewBySize	"Make the receiver show its subparts as a vertical list of lines of information, sorted by object size"	self imposeListViewSortingBy: #reportableSize retrieving: #(externalName reportableSize className oopString)! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/23/2000 19:16'!viewNonOverlapping	"Make the receiver show its contents as full-size morphs laid out left-to-right and top-to-bottom to be non-overlapping."	self viewingNormally ifTrue:		[self saveBoundsOfSubmorphs].	self showingListView ifTrue:		[self viewByIcon.		self removeProperty: #showingListView].	self autoLineLayout: true.	self fixLayout.	self layoutChanged! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/31/2000 06:30'!viewingByIconString	"Answer a string to show in a menu representing whether the receiver is currently viewing its subparts by icon or not"	^ (self showingListView or: [autoLineLayout == true])		ifFalse:	['<yes>view by icon']		ifTrue:	['<no>view by icon']! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/31/2000 09:28'!viewingByNameString	"Answer a string to show in a menu representing whether the receiver is currently viewing its subparts by name or not"	^ (self showingListView and: [(self valueOfProperty: #sortOrder ifAbsent: [nil]) == #downshiftedNameOfObjectRepresented])		ifTrue:	['<yes>view by name']		ifFalse:	['<no>view by name']! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/23/2000 19:14'!viewingBySizeString	"Answer a string to show in a menu representing whether the receiver is currently viewing its subparts by size or not"	^ (self showingListView and: [(self valueOfProperty: #sortOrder ifAbsent: [nil]) == #reportableSize])		ifTrue:	['<yes>view by size']		ifFalse:	['<no>view by size']! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/23/2000 19:15'!viewingNonOverlappingString	"Answer a string to show in a menu representing whether the receiver is currently viewing its subparts by non-overlapping-icon (aka auto-line-layout)"	^ (self showingListView or: [autoLineLayout ~~ true])		ifFalse:	['<yes>view with line layout']		ifTrue:	['<no>view with line layout']! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 10/24/2000 07:32'!viewingNormally	"Answer whether the receiver is being viewed normally, viz not in list-view or auto-line-layout"	^ (self showingListView or: [autoLineLayout == true]) not! !!PasteUpMorph class methodsFor: 'scripting' stamp: 'sw 10/23/2000 16:47'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ # ((playfield ((command initiatePainting 'Initiate painting of a new object in the standard playfield.')(slot mouseX 'The x coordinate of the mouse pointer' number readWrite player getMouseX  unused unused)(slot mouseY 'The y coordinate of the mouse pointer' number readWrite player getMouseY  unused unused)(command roundUpStrays 'Bring all out-of-container subparts back into view.')(slot numberAtCursor 'the number at the cursor' number readWrite player getNumberAtCursor player setNumberAtCursor: )(slot playerAtCursor 'the object currently at the cursor' player readWrite player getValueAtCursor  unused unused)(command unhideHiddenObjects 'Unhide all hidden objects.')))(collections ((slot cursor 'The index of the chosen element' number readWrite player getCursor player setCursorWrapped:)(slot playerAtCursor 'the object currently at the cursor' player readWrite player getValueAtCursor  unused unused)(slot firstElement  'The first object in my contents' player  readWrite player getFirstElement  player  setFirstElement:)(slot numberAtCursor 'the number at the cursor' number readWrite player getNumberAtCursor player setNumberAtCursor: )(command removeAll 'Remove all elements from the playfield')(command shuffleContents 'Shuffle the contents of the playfield')(command append: 'Add the object to my content' player)))(#'stack navigation' ((command goToNextCardInStack 'Go to the next card')(command goToPreviousCardInStack  'Go to the previous card')(command goToFirstCardInBackground 'Go to the first card of the current background')(command goToFirstCardOfStack 'Go to the first card of the entire stack')(command goToLastCardInBackground 'Go to the last card of the current background')(command goToLastCardOfStack 'Go to the last card of the entire stack')(command deleteCard 'Delete the current card')(command insertCard 'Create a new card')))(viewing ((slot viewingNormally 'whether contents are viewed normally' boolean readWrite player getViewingByIcon player setViewingByIcon: )))(#'pen trails' ((command liftAllPens 'Lift the pens on all the objects in my interior.')(command lowerAllPens  'Lower the pens on all the objects in my interior.')(command clearTurtleTrails 'Clear all the pen trails in the interior.'))))! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'sw 10/30/2000 07:03'!morphToDropInPasteUp: aPasteUp	"Answer the morph to drop in aPasteUp, given that the receiver is the putative droppee"	| actualObject itsSelector aScriptor anEditor adjustment handy |	self isCommand ifFalse: [^ self].	(actualObject _ self actualObject) ifNil: [^ self].	actualObject assureUniClass.	itsSelector _ self userScriptSelector.	aScriptor _ (itsSelector ~~ nil and: [itsSelector size > 0])		ifTrue:			[actualObject isFlagshipForClass				ifFalse: 					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: self.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					[(actualObject class userScriptForPlayer: actualObject selector: itsSelector) 						isTextuallyCoded ifTrue:							[^ aPasteUp scriptorForTextualScript: itsSelector ofPlayer: actualObject].					adjustment _ 0@0.					aScriptor _ actualObject scriptEditorFor: itsSelector]]		ifFalse:			["It's a system-defined selector; construct an anonymous scriptor around it"			adjustment _ 60 @ 20.			actualObject newScriptorAround: self].	handy _ aPasteUp primaryHand.	aScriptor ifNotNil: [aScriptor position: handy position - adjustment].	(aScriptor isMemberOf: ScriptEditorMorph) ifTrue:		[aScriptor playerScripted expungeEmptyUnRenamedScripts].	^ aScriptor ifNil: [self]! !!PhraseTileMorph methodsFor: 'tiles from method' stamp: 'sw 10/26/2000 14:45'!tilesFrom: msgNode in: aScriptor	"Construct a single line of tiles from a MessageNode of a parse tree.  For a single message send."	| tile pm sel instVar suff argNode selType |	self flag: #noteToTed.  "Ted: this is your code from 8/6/99, which is now broken before it could ever get used.  The method #scriptInfoFor: which it formerly called is gone; I've included its old content at the end in comments as a pointer.  sw 9/8/2000 09:44"	"latter-day note: sw 10/10/2000 11:25 - this is now reached by the from a menu item in the Scriptor menu, so this is where the capability needs to be revived"	true ifTrue: [^ self inform: 'Under Construction!!Not yet released!!.(sorry)'].	sel _ msgNode selector key.	(sel beginsWith: 'assign') ifTrue: [	"assignment"		instVar _ msgNode arguments first literalValue.		instVar _ (instVar copyFrom: 4 to: instVar size) withFirstCharacterDownshifted.		pm _ (CategoryViewer new) scriptedPlayer: aScriptor playerScripted; 			makeSetter: nil from: aScriptor playerScripted costume 			forPart: (Array with: instVar with: #number).	"makes a new Phrase"		suff _ (sel findTokens: ':') first.		suff _ (suff copyFrom: 7 to: suff size-6), ':'.		": Incr: Decr: Mult:"		pm submorphs second setAssignmentSuffix: suff.		pm submorphs third delete.		tile _ TilePadMorph new tilesFrom: msgNode arguments last in: aScriptor.		pm addMorphBack: tile.		^ pm].	(sel beginsWith: 'get') ifTrue: [	"getter"		instVar _ (sel copyFrom: 4 to: sel size) withFirstCharacterDownshifted.		pm _ (CategoryViewer new) scriptedPlayer: aScriptor playerScripted; 			makeGetter: nil from: aScriptor playerScripted costume 			forPart: (Array with: instVar with: #number).	"makes a new Phrase"		^ pm].	(#(ifTrue:ifFalse: ifFalse: ifTrue:) includes: sel) ifTrue: [		^ CompoundTileMorph new tilesFrom: msgNode in: aScriptor].	self addMorphBack: (TilePadMorph new tilesFrom: msgNode receiver in: aScriptor).	self addMorphBack: (TileMorph new selectorTile: msgNode in: aScriptor).	"selector"	(aScriptor playerScripted elementTypeFor: sel) == #systemScript ifTrue: [		selType _ (aScriptor playerScripted phraseSpecFor: 			(Array with: #command with: sel)) last].	msgNode arguments size > 0 ifTrue: [		argNode _ msgNode arguments last.		tile _ TileMorph new tilesFrom: argNode type: selType in: aScriptor.		self addMorphBack: tile]."Old code from Player, now superseded by an entirely new mechanism...phraseSpecFor: aPair	| info prefix |	info _ (prefix _ aPair first) == #slot		ifTrue:			[ScriptingSystem slotInfoFor: aPair second]		ifFalse:			[ScriptingSystem scriptInfoFor: aPair second].	^ (Array with: prefix), info"! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/23/2000 16:07'!deleteCard	"Tell the receiver's stack to delete the current card"	self costume stackDo: [:aStack | aStack deleteCard]! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/30/2000 07:12'!getRoundedCorners	"Anwer the rounded-corners attribute of my costume"	^ costume renderedMorph cornerStyle == #rounded! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/23/2000 16:12'!goToCard: aCard	"Install aCard as the new current card of the stack"	self stackDo: [:aStack | aStack goToCard: aCard]! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/23/2000 16:19'!goToFirstCardInBackground	"Send the stack to the first card of the current background"	costume stackDo: [:aStack | aStack goToFirstCardInBackground]! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/23/2000 16:19'!goToFirstCardOfStack	"Send the stack to the first card of the entire stack"	costume stackDo: [:aStack | aStack goToFirstCardOfStack]! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/23/2000 16:17'!goToLastCardInBackground	"Send the stack to the final card of the current background"	costume stackDo: [:aStack | aStack goToLastCardInBackground]! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/23/2000 16:20'!goToLastCardOfStack	"Send the stack to the last card of the entire stack"	costume stackDo: [:aStack | aStack goToLastCardOfStack]! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/23/2000 14:54'!goToNextCardInStack	"Install the next card into the receiver's stack"	self costume goToNextCardInStack! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/23/2000 16:13'!goToPreviousCardInStack	"Install the previous card into the receiver's stack"	self costume goToPreviousCardInStack! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/23/2000 16:14'!insertCard	"Insert a new card into the stack"	self costume stackDo: [:aStack | aStack insertCard]! !!Player methodsFor: 'card/stack commands' stamp: 'sw 10/30/2000 08:34'!setRoundedCorners: aBoolean	"Set the rounded-corners attribute as indicated"	costume renderedMorph cornerStyle: (aBoolean ifTrue: [#rounded] ifFalse: [#square])! !!Player methodsFor: 'name' stamp: 'sw 10/24/2000 07:28'!knownName	"Answer a name by which the receiver is known, or nil if none"	^ costume knownName! !!Player methodsFor: 'pen' stamp: 'sw 10/30/2000 17:13'!uniqueNameForReference	"Answer a unique name for referring to the receiver"	| itsReferent |	self flag: #deferred.  "The once-and-maybe-future ObjectRepresentativeMorph scheme is for the moment disenfranchised"	"(costume isKindOf: ObjectRepresentativeMorph) ifTrue:		[((itsReferent _ costume objectRepresented) isKindOf: Class)			ifTrue:				[^ itsReferent name].		itsReferent == Smalltalk ifTrue: [^ #Smalltalk].		itsReferent == ScriptingSystem ifTrue: [^ #ScriptingSystem]]."	^  super uniqueNameForReference! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/30/2000 11:18'!tileForArgType: typeSymbol	"Anwer a default tile to represent a datum of the given argument type"	| aColor |	typeSymbol == #player ifTrue:		[^ self tileForPlayer:  self presenter standardPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #menu ifTrue: [^ MenuTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	typeSymbol == #buttonPhase ifTrue: [^ SymbolListTile new choices: #(buttonDown whilePressed buttonUp) dataType: typeSymbol].	self error: 'Unrecognized type'! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/30/2000 13:17'!tileForArgType: typeSymbol inViewer: aViewer	"Answer a tile to represent a value of the given type in the given viewer"	| aColor aPlayer |	typeSymbol == #player ifTrue:		[aPlayer _ self presenter			ifNotNil:				[self presenter standardPlayer]			ifNil:  "It happens, if costume is not currently in a world"				[self].		^ aViewer tileForPlayer:  aPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #menu ifTrue: [^ MenuTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	typeSymbol == #buttonPhase ifTrue: [^ SymbolListTile new choices: #(buttonDown whilePressed buttonUp) dataType:  typeSymbol].	typeSymbol == #text ifTrue: [^ ("(TextMorph new contents: 'setup')" 'aborning' newTileMorphRepresentative) typeColor:  aColor].	self error: 'Unrecognized type'! !!Player methodsFor: 'slots-kernel' stamp: 'sw 10/24/2000 14:47'!typeForSlot: aSlotName	"Answer the data type for values of the instance variable of the given name"	(self slotInfo includesKey: aSlotName) ifTrue: [^ (self slotInfoAt: aSlotName) type].	^ (ScriptingSystem typeForSystemSlotNamed: aSlotName)		ifNil:			[self error: 'no type for slot named ', aSlotName]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 10/30/2000 07:08'!getActWhen	"Answer the #actWhen status of my costume, which is expected to be a button with an #actWhen protocol"	^ costume renderedMorph actWhen! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 10/30/2000 07:09'!getGetListSelector	"Answer the selector used by my costume (a list) to obtain a fresh copy of its list"	^ self costume renderedMorph getListSelector! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 10/30/2000 07:10'!getLabel	"Answer the label of my costume"	^ self costume renderedMorph label! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 10/30/2000 07:12'!getViewingByIcon	"Answer whether my costume is currently viewing by icon"	^ costume renderedMorph viewingNormally! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 10/13/2000 16:57'!setActWhen: val	"Tell the receiver's costume (hopefully a button!!) to set its actWhen parameter as indicated"	costume actWhen: val! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 10/30/2000 11:18'!setGetListSelector: sel	"Set the receiver's get-list-selector as indicated."	costume renderedMorph getListSelector: sel	! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 10/30/2000 08:33'!setLabel: aLab	"Set the receiver's costume's label as specified"	costume renderedMorph label: aLab! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 10/30/2000 08:35'!setViewingByIcon: aVal	"Set the user's  costume's view-by-icon attribute as indictated"	(aVal == false)		ifTrue:			["problematical - we always need *some* view"			costume renderedMorph viewByName]		ifFalse:			[costume renderedMorph viewByIcon]! !!Player methodsFor: 'slots-user' stamp: 'sw 10/24/2000 08:07'!initialValueForSlotOfType: aType	"Answer the default initial value to ascribe to a slot of the given type"	aType == #number ifTrue: [^ (1 to: 9) atRandom].	aType == #boolean ifTrue: [^ true].	aType == #player ifTrue: [^ self costume presenter standardPlayer].	aType == #color ifTrue: [^ Color random].	aType == #string ifTrue: [^ 'abc'].	aType == #sound ifTrue: [^ 'croak'].	aType == #point ifTrue: [^ 20 @ 30].	aType == #buttonPhase ifTrue: [^ #buttonUp].	^ nil! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 10/24/2000 14:32'!instantiatedUserScriptsDo: aBlock	"Evaluate aBlock on behalf of all the instantiated user scripts in the receiver"	| aState aCostume |	((aCostume _ self costume) notNil and: [(aState _ aCostume actorState) notNil]) ifTrue:		[aState instantiatedUserScriptsDictionary do: aBlock]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 10/26/2000 08:57'!newScriptEditorFor: aSelector usingPhraseTile: aPhraseTileMorph	"Sprout a scriptor for aSelector, using aPhraseTileMorph as its initial phrase."	| aUserScript aScriptEditor |	(self class selectors includes: aSelector) ifTrue: [self error: 'selector already exists'].	aUserScript _ self class permanentUserScriptFor: aSelector player: self.	aScriptEditor _ aUserScript instantiatedScriptEditor.	aPhraseTileMorph ifNotNil: [aScriptEditor phrase: aPhraseTileMorph].	aScriptEditor install.	aPhraseTileMorph ifNil: [aScriptEditor showSourceInScriptor].	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 10/25/2000 11:44'!newScriptorAround: aPhraseTileMorph	"Sprout a scriptor around aPhraseTileMorph, thus making a new script"	| aScriptEditor aUserScript |	self isFlagshipForClass ifFalse:		[self flag: #deferred.  "This really has to change, esp in card world"		^ aPhraseTileMorph].	aUserScript _ self class permanentUserScriptFor: self unusedScriptName player: self.	aScriptEditor _ aUserScript instantiatedScriptEditor.	aPhraseTileMorph ifNotNil:		[aScriptEditor phrase: aPhraseTileMorph].	aScriptEditor install.	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 10/30/2000 11:20'!scriptInstantiationForSelector: aSelector	"Answer a script instantiaion for the given selector, creating it at this time if necessary"	|  entry scriptDict classEntry |	scriptDict _ self actorState instantiatedUserScriptsDictionary.	entry _ scriptDict at: aSelector ifAbsent: [nil].	entry ifNil:		[classEntry _ self class userScriptForPlayer: self selector: aSelector.		entry _ ScriptInstantiation new player: self selector: aSelector status: classEntry status.		scriptDict at: aSelector put: entry].	^ entry! !!Player methodsFor: 'misc' stamp: 'sw 10/24/2000 14:29'!categoriesForViewer: aViewer	"Answer a list of category symbols to offer as alternatives in the viewer"	^ self categories! !!Player methodsFor: 'misc' stamp: 'sw 10/25/2000 23:16'!nameForViewer	"Answer the name to be used for the receiver in its Viewer"	^ self getName! !!Player methodsFor: 'misc' stamp: 'sw 10/25/2000 18:12'!offerViewerMenuFor: aViewer event: evt	"Put up the Viewer menu on behalf of the receiver."	| aMenu aWorld  |	aWorld _ aViewer world.	aMenu _ MenuMorph new defaultTarget: self.	costumes ifNotNil:		[(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume renderedMorph]])			ifTrue:				[aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes]].	aMenu addLine.	aMenu add: 'add a new instance variable' target: self action: #addInstanceVariable.	aMenu add: 'add a new script' target: aViewer action: #newPermanentScript.	aMenu add: 'expunge empty scripts' target: self action: #expungeEmptyScripts.	aMenu addLine.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	aMenu add: 'reveal me' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab me' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu addLine.	aMenu add: 'inspect morph' target: costume selector: #inspect.	aMenu add: 'inspect player' target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' target: self action: #browsePlayerClass.		aMenu add: 'inspect class' target: self class action: #inspect].	aMenu popUpEvent: evt in: aWorld! !!Player methodsFor: 'misc' stamp: 'sw 10/27/2000 06:38'!ordinalNumber	"Answer a number indicating the relative position of the receiver in its stack, if any, else 1"	| aStack |	^ (aStack _ self stack) ifNotNil: [aStack cardIndexOf: self] ifNil: [nil]! !!Player methodsFor: 'misc' stamp: 'sw 10/27/2000 06:37'!stack	"Answer the stack to which the receiver belongs.  This only searches via the costume's parent pointer, so there is no guarantee that the stack that is found actually contains the receiver in its card list"	^ costume ifNotNil: [costume stack]! !!Player methodsFor: 'misc' stamp: 'sw 10/30/2000 11:19'!uninstallFrom: aPlayfield	"The receiver is about to be supplanted by another instance which is about to be installed as the current 'card' in the playfield.  Exit gracefully"	self runAllClosingScripts.	self commitCardPlayerData! !!CardPlayer methodsFor: 'printing' stamp: 'sw 10/23/2000 17:58'!printOn: aStream	"Print out a human-readable representation of the receiver onto aStream"	super printOn: aStream.	self class instVarNames do:		[:aName | aStream nextPutAll: ', ', aName, ' = ', (self instVarNamed: aName) printString]! !!CardPlayer methodsFor: 'card data' stamp: 'sw 10/13/2000 16:46'!commitCardPlayerData	"Transport data back from the morphs that may be holding it into the instance variables that must hold it when the receiver is not being viewed"	| prior |	self class variableDocks do:		[:aDock | aDock storeMorphDataInInstance: self].	prior _ nil.	privateMorphs _ OrderedCollection new.	self costume ifNotNil:		[self costume submorphs do:			[:aMorph | aMorph renderedMorph isShared				ifFalse:					[aMorph setProperty: #priorMorph toValue: prior.					privateMorphs add: aMorph.					aMorph delete].			prior _ aMorph]]! !!CardPlayer methodsFor: 'card data' stamp: 'sw 10/23/2000 18:00'!installPrivateMorphsInto: aBackground	"The receiver is being installed as the current card in a given pasteup morph being used as a background.  Install the receiver's private morphs into that playfield"	| prior |	privateMorphs ifNotNil: [privateMorphs do:		[:aMorph |			prior _ aMorph valueOfProperty: #priorMorph ifAbsent: [nil].			(prior notNil and: [aBackground submorphs includes: prior])				ifTrue:					[aBackground addMorph: aMorph after: prior]				ifFalse:					[aBackground addMorphNearBack: aMorph].		aMorph removeProperty: #priorMorph]]! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 10/30/2000 07:04'!baseUniclass	"Answer the uniclass that new instances should be instances of; this protocol allows for individual cards of a background to have their own class"	| curr |	curr _ self.	[curr theNonMetaClass superclass name endsWithDigit]		whileTrue:			[curr _ curr superclass].	^ curr"CardPlayer100 baseUniclass CardPlayer100X baseUniclass"! !!Player class methodsFor: 'other' stamp: 'sw 10/13/2000 16:44'!wantsChangeSetLogging	"Log changes for Player itself, but not for automatically-created subclasses like Player1, Player2, but *do* log it for uniclasses that have been manually renamed."	^ self == Player or:		[(self name beginsWith: 'Player') not]! !!Player class methodsFor: 'scripts' stamp: 'sw 10/30/2000 07:06'!permanentUserScriptFor: aSelector player: aPlayer	"Create and answer a UserScript object for the given player (an instance of the receiver) and sseletor.  Save that UserScript in my (i.e. the class's) directory of scripts"	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	self flag: #deferred.  "That anonymous script will of course contain refs to aPlayer who may well not be the class's prototype.  So if it is then saved, there's a problem"	entry _ UserScript new initializePermanentScriptFor: aPlayer selector: aSelector.	scripts at: aSelector put: entry.	^ entry! !!Player class methodsFor: 'namespace' stamp: 'sw 10/27/2000 06:59'!compileReferenceAccessorFor: varName	"Compile reference accessors for the given variable.  If the #capitalizedReferences preference is true, then nothing is done here"	Preferences capitalizedReferences ifTrue: [^ self].	self class compileUnlogged: ((self referenceAccessorSelectorFor: varName), '	^ ', varName)		classified: 'reference' notifying: nil! !!CardPlayer class methodsFor: 'class properties' stamp: 'sw 10/13/2000 13:05'!isUniClass	"Answer, for the purpose of providing annotation in a method holder, whether the receiver is a uniClass."	^ self ~~ CardPlayer! !!CardPlayer class methodsFor: 'class properties' stamp: 'sw 10/13/2000 13:07'!officialClass	"Answer (for the purpose of copying mechanisms) the system class underlying the receiver."	^ CardPlayer! !!CardPlayer class methodsFor: 'user-defined inst vars' stamp: 'sw 10/13/2000 13:03'!compileAccessorsFor: varName	"Compile instance-variable accessor methods for the given variable name"	| nameString |	nameString _ varName asString capitalized.	self compileUnlogged: ('get', nameString, '	^ ', varName)		classified: 'access' notifying: nil.	self compileUnlogged: ('set', nameString, ': val	', varName, ' _ val')		classified: 'access' notifying: nil! !!CardPlayer class methodsFor: 'user-defined inst vars' stamp: 'sw 10/27/2000 17:09'!removeAccessorsFor: varName	"Remove the instance-variable accessor methods associated with varName"	| nameString |	nameString _ varName asString capitalized.	self removeSelectorUnlogged: ('get', nameString) asSymbol.	self removeSelectorUnlogged: ('set', nameString, ':') asSymbol! !!CardPlayer class methodsFor: 'user-defined inst vars' stamp: 'sw 10/13/2000 16:37'!setNewInstVarNames: listOfStrings	"Make listOfStrings be the new list of instance variable names for the receiver"	| disappearing firstAppearing instVarString instVarList |	instVarList _ self instVarNames asOrderedCollection.	disappearing _ instVarList copy.	disappearing removeAllFoundIn: listOfStrings.	disappearing do:		[:oldName | 	self removeAccessorsFor: oldName].	firstAppearing _ listOfStrings copy.	firstAppearing removeAllFoundIn: instVarList.	firstAppearing do:		[:newName | self compileAccessorsFor: newName].	instVarString _ String streamContents:		[:aStream | listOfStrings do: [:aString | aStream nextPutAll: aString; nextPut: $ ]].	superclass subclass: self name instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses! !!CardPlayer class methodsFor: 'logging' stamp: 'sw 10/13/2000 13:02'!acceptsLoggingOfCompilation	"Answer whether methods of the receiver should be logged when submitted."	^ #(CardPlayer) includes: self class theNonMetaClass name! !!CardPlayer class methodsFor: 'logging' stamp: 'sw 10/13/2000 16:45'!wantsChangeSetLogging	"Log changes for CardPlayer itself, but not for automatically-created subclasses like CardPlayer1, CardPlayer2, but *do* log it for uniclasses that have been manually renamed."	^ self == CardPlayer or:		[(self name beginsWith: 'CardPlayer') not]! !!CardPlayer class methodsFor: 'variable docks' stamp: 'sw 10/13/2000 16:36'!newVariableDocks: dockList	"Set the receiver's variableDocks to be the list provided in dockList.  Assimilate this new information into the receiver's slotInfo, which contains both automatically-generated variables such as the variable docks and also explicitly-user-specified variables"	self variableDocks: dockList.	self setSlotInfoFromVariableDocks! !!CardPlayer class methodsFor: 'variable docks' stamp: 'sw 10/9/2000 07:51'!setSlotInfoFromVariableDocks	"Get the slotInfo fixed up after a change in background shape.  Those instance variables that are proactively added by the user will persist, whereas those that are automatically generated will be updated"	| aDock newInfo |		self slotInfo copy do:  "Remove old automatically-created slots"		[:aSlotInfo | (aDock _ aSlotInfo variableDock) ifNotNil:			[slotInfo removeKey: aDock variableName]].	self variableDocks do:  "Generate fresh slots from variable docks"		[:dock |			newInfo _ SlotInformation new type: dock variableType.			newInfo variableDock: dock.			slotInfo at: dock variableName asSymbol put: newInfo]! !!CardPlayer class methodsFor: 'variable docks' stamp: 'sw 10/13/2000 16:39'!variableDocks	"Answer the list of variable docks in the receiver.  Initialize the variable-dock list if not already done."	variableDocks ifNil: [variableDocks _ OrderedCollection new].	^ variableDocks! !!CardPlayer class methodsFor: 'variable docks' stamp: 'sw 10/13/2000 16:39'!variableDocks: dockList	"Set the variable-dock list as indicated"	variableDocks _ dockList! !!PluggableListMorph methodsFor: 'initialization' stamp: 'sw 10/30/2000 11:17'!getListSelector: sel	"Set the receiver's getListSelector as indicated, and trigger a recomputation of the list"	getListSelector _ sel.	self changed! !!PluggableListMorph methodsFor: 'selection' stamp: 'sw 10/30/2000 11:16'!setGetListSelector: sel	"Set the the receiver's getListSelector as indicated.  For access via scripting"	getListSelector _ sel! !!PluggableTextMorph methodsFor: 'model access' stamp: 'sw 10/30/2000 13:31'!releaseCachedState	"Release cached state of the receiver"	(model ~~ self and: [model respondsTo: #releaseCachedState]) ifTrue:		[model releaseCachedState].	"CodeHolder let go of CompiledMethod"! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 10/30/2000 11:16'!tileForIt	"Return a tile referring to the object resulting form evaluating my current selection.  Not currently threaded in, but useful in earlier demos and possibly still of value."	| result |	self handleEdit:		[result _ textMorph editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [self flash]			ifFalse: [self currentHand attachMorph: result tileToRefer]]! !!PluggableTextMorphWithModel methodsFor: 'contents' stamp: 'sw 10/26/2000 14:37'!newTextContents: stringOrText	"Accept new text contents."	| newText aStack setter myText |	"Just underway; trying to make this work like TextMorph does, but not quite there yet."	newText _ stringOrText asText.	(myText _ textMorph text) = newText ifTrue: [^ self].  "No substantive change"	(self holdsSeparateDataForEachInstance and: [(aStack _ self stack) notNil])		ifTrue:			[setter _ self valueOfProperty: #setterSelector.			setter ifNotNil:				[(self valueOfProperty: #cardInstance) perform: setter with: newText]].	self world ifNotNil:		[self world startSteppingSubmorphsOf: self ].! !!PluggableTextMorphWithModel methodsFor: 'deletion' stamp: 'sw 10/26/2000 14:39'!delete	"Delete the receiver.  Since I have myself as a dependent, I need to remove it. which is odd in itself.  Also, the release of dependents will seemingly not be done if the *container* of the receiver is deleted rather than the receiver itself, a further problem"	self removeDependent: self.	super delete! !!PluggableTextMorphWithModel methodsFor: 'data dockup' stamp: 'sw 10/24/2000 14:52'!couldHoldSeparateDataForEachInstance	"Answer whethre the receiver is structurally capable of holding uniqe data for each ard instance"	^ true! !!PluggableTextMorphWithModel methodsFor: 'data dockup' stamp: 'sw 10/30/2000 11:14'!currentDataValue	"Answer the current data value of the receiver"	^ myContents! !!PluggableTextMorphWithModel methodsFor: 'data dockup' stamp: 'sw 10/25/2000 07:00'!variableDocks	"Answer a list of VariableDocks that will handle the interface between me and instance data stored on my behalf on a card"	^ Array with: (VariableDock new variableName: self defaultVariableName type: #text definingMorph: self morphGetSelector: #getMyText morphPutSelector: #setMyText:)! !!PluggableTextMorphWithModel class methodsFor: 'authoring prototype' stamp: 'sw 10/30/2000 11:14'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin"	| proto |	proto _ super authoringPrototype.	proto color: (Color r: 0.972 g: 0.972 b: 0.662).	^ proto! !!Preferences class methodsFor: 'halos' stamp: 'sw 10/30/2000 13:32'!haloSpecifications	"Answer a list of HaloSpecs that describe which halos are to be used, what they should look like, and where they should be situated"	^ Parameters at: #HaloSpecs ifAbsent:			[self installHaloTheme: #iconicHaloSpecifications.			^ Parameters at: #HaloSpecs]	"Preferences haloSpecifications"	"Preferences resetHaloSpecifications"! !!Preferences class methodsFor: 'halos' stamp: 'sw 10/30/2000 13:32'!iconicHaloSpecifications	"Answer an array that characterizes the locations, colors, icons, and selectors of the halo handles that may be used in the iconic halo scheme"	"Preferences resetHaloSpecifications"	^ #(	"  	selector				horiz		vert			color info						icon key		---------				------		-----------		-------------------------------		---------------"	(addCollapseHandle:		left			topCenter		(tan)							'Halo-Collapse')	(addPoohHandle:			right		center			(white)							'Halo-Pooh')	(addDebugHandle:		right		topCenter		(blue	veryMuchLighter)		'Halo-Debug')	(addDismissHandle:		left			top				(red		muchLighter)			'Halo-Dismiss')	(addRotateHandle:		left			bottom			(blue)							'Halo-Rot')	(addMenuHandle:		leftCenter	top				(red)							'Halo-Menu')	(addTileHandle:			left			bottomCenter	(lightBrown)					'Halo-Tile')	(addViewHandle:			left			center			(cyan)							'Halo-View')	(addGrabHandle:			center		top				(black)							'Halo-Grab')	(addDragHandle:			rightCenter	top				(brown)							'Halo-Drag')	(addDupHandle:			right		top				(green)							'Halo-Dup')		(addHelpHandle:			center		bottom			(lightBlue)						'Halo-Help')	(addGrowHandle:		right		bottom			(yellow)						'Halo-Scale')	(addScaleHandle:		right		bottom			(lightOrange)					'Halo-Scale')	(addScriptHandle:		rightCenter	bottom			(green muchLighter)			'Halo-Script')	(addPaintBgdHandle:		right		center			(lightGray)						'Halo-Paint')	(addViewingHandle:		leftCenter	bottom			(lightGreen lighter)				'Halo-View')	(addRepaintHandle:		right		center			(lightGray)						'Halo-Paint')	(addFontSizeHandle:		leftCenter	bottom			(lightGreen)						'Halo-FontSize')	(addFontStyleHandle:		center		bottom			(lightRed)						'Halo-FontStyle')	(addFontEmphHandle:	rightCenter	bottom			(lightBrown darker)				'Halo-FontEmph')	(addRecolorHandle:		right		bottomCenter	(magenta darker)				'Halo-Recolor')	(addChooseGraphicHandle:	right	bottomCenter	(green muchLighter)			'Halo-ChooseGraphic')		) ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 10/30/2000 18:09'!classNamesForStandardPartsBin	"Answer a list of class-name lists for insertion onto pages of a standard parts bin"	^#(		(RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph PasteUpMorph PaintInvokingMorph  StringMorph)		(JoystickMorph ClockMorph ScriptableButton SimpleSliderMorph PianoKeyboardMorph RecordingControlsMorph))! !!Presenter methodsFor: 'viewer' stamp: 'sw 10/30/2000 15:51'!viewObject: anObject	"Open up a viewer on the given object"	|  aViewer aRect aPoint nominalHeight aFlapTab flapLoc |	anObject isMorph ifTrue: [^ self viewMorph: anObject].  "historic morph/player implementation"	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	"19 sept 2000 - allow flaps in any paste up"	flapLoc _ associatedMorph "world".	Preferences viewersInFlaps ifTrue:		[aViewer setProperty: #noInteriorThumbnail toValue: true.		aViewer initializeFor: anObject barHeight: 0.		aViewer enforceTileColorPolicy.		flapLoc hideViewerFlapsOtherThanFor: anObject.		aFlapTab _ flapLoc viewerFlapTabFor: anObject.		aFlapTab referent submorphs do: 			[:m | (m isKindOf: Viewer) ifTrue: [m delete]].		aFlapTab referent addMorph: aViewer beSticky.		aViewer visible: true.		aFlapTab applyThickness: aViewer width + 25.		aFlapTab spanWorld.		aFlapTab showFlap. 		aViewer position: aFlapTab referent position.		flapLoc startSteppingSubmorphsOf: aFlapTab.		^ flapLoc startSteppingSubmorphsOf: aViewer].			aViewer initializeFor: anObject barHeight: 6.	aViewer enforceTileColorPolicy.	Preferences automaticViewerPlacement ifTrue:		[aPoint _ anObject bounds right @ 			(anObject center y - ((nominalHeight _ aViewer initialHeightToAllow) // 2)).		aRect _ (aPoint extent: (aViewer width @ nominalHeight)) translatedToBeWithin: flapLoc bounds.		aViewer position: aRect topLeft.		aViewer visible: true.		flapLoc startSteppingSubmorphsOf: aViewer.		"it's already in the world, somewhat coincidentally"		^ self].	anObject primaryHand attachMorph: (aViewer visible: true)! !!Project methodsFor: 'accessing' stamp: 'sw 10/27/2000 05:55'!currentStack: aStack	"Set the current stack as indicated; if the parameter supplied is nil, delete any prior memory of the CurrentStack"	aStack		ifNil:			[self removeParameter: #CurrentStack]		ifNotNil:			[self projectParameterAt: #CurrentStack put: aStack]! !!Project methodsFor: 'project parameters' stamp: 'sw 10/27/2000 06:46'!currentStack	"Answer the current stack of the current project.  Called basically as a bail-out when we can't find the stack in the owner chain of a morph, probably because it is on a background that is not currently installed.  This method will always return a stack that is in the world, or nil if no stack is found in the world.  Of course it would be nice to have multiple stacks concurrently open in the same world, but at the moment that is problematical."	| aStack curStack |	curStack _ self projectParameterAt: #CurrentStack.	curStack ifNotNil: [curStack isInWorld ifTrue: [^ curStack]].	(aStack _ world findA: StackMorph) ifNotNil:		[self currentStack: aStack].	^ aStack! !!Project methodsFor: 'project parameters' stamp: 'sw 10/30/2000 11:14'!projectParameterAt: aSymbol	"Answer the project parameter stored at the given symbol, or nil if none"	^ self projectParameters at: aSymbol ifAbsent: [nil]! !!Project methodsFor: 'project parameters' stamp: 'sw 10/30/2000 11:13'!projectParameterAt: aSymbol put: aValue	"Set the given project parameter to the given value"	^ self projectParameters at: aSymbol put: aValue! !!ReferenceMorph methodsFor: 'misc' stamp: 'sw 10/30/2000 11:11'!borderWidth: aWidth	"Set the receiver's border width as indicated, and trigger a fresh layout"	super borderWidth: aWidth.	self layoutChanged! !!ReferenceMorph methodsFor: 'menu' stamp: 'sw 10/25/2000 11:46'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the menu for the hand"	| sketch |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	self isCurrentlyTextual		ifTrue:			[aCustomMenu add: 'change label wording...' action: #changeTabText.			aCustomMenu add: 'use graphical label' action: #useGraphicalTab]		ifFalse:			[aCustomMenu add: 'use textual label' action: #useTextualTab.			aCustomMenu add: 'choose graphic...' action: #changeTabGraphic.			(sketch _ self findA: SketchMorph) ifNotNil:				[aCustomMenu add: 'repaint' target: sketch action: #editDrawing]]! !!ReferenceMorph methodsFor: 'menu' stamp: 'sw 3/23/2000 10:47'!preserveDetails	"The receiver is being switched to use a different format.  Preserve the existing details (e.g. wording if textual, grapheme if graphical) so that if the user reverts back to the current format, the details will be right"	self isCurrentlyTextual		ifTrue:			[self setProperty: #priorWording toValue: self existingWording.			self setProperty: #priorColor toValue: color.			self setProperty: #priorBorderWidth toValue: borderWidth]		ifFalse:			[self setProperty: #priorGraphic toValue: submorphs first form]! !!ReferenceMorph methodsFor: 'menu' stamp: 'sw 10/30/2000 11:11'!setLabelFontTo: aFont	"Change the receiver's label font to be as indicated"	| aLabel oldLabel |	aLabel _ StringMorph contents:  (oldLabel _ self findA: StringMorph) contents font: aFont.	self replaceSubmorph: oldLabel by: aLabel.	aLabel position: self position.	aLabel highlightColor: self highlightColor; regularColor: self regularColor.	aLabel lock.	self fitContents.	self layoutChanged.	(owner isKindOf: IndexTabs) ifTrue:		[self borderWidth: 0.		owner laySubpartsOutInOneRow.		isHighlighted ifTrue:			[self highlight]]! !!ReferenceMorph methodsFor: 'menu' stamp: 'sw 10/24/2000 14:39'!useTextualTab	"Use a textually-emblazoned tab"	| aLabel stringToUse font aColor |	self preserveDetails.	stringToUse _ self valueOfProperty: #priorWording ifAbsent: [self externalName].	font _ self valueOfProperty: #priorFont ifAbsent: [Preferences standardButtonFont].	aColor _ self valueOfProperty: #priorColor ifAbsent: [Color green darker].	aLabel _ StringMorph contents: stringToUse font: font.	self replaceSubmorph: submorphs first by: aLabel.	aLabel position: self position.	self color: aColor.	aLabel highlightColor: self highlightColor; regularColor: self regularColor.	aLabel lock.	self fitContents.	self layoutChanged.	(owner isKindOf: IndexTabs) ifTrue:		[self borderWidth: 0.		owner laySubpartsOutInOneRow.		isHighlighted ifTrue:			[self highlight]]! !!ReferenceMorph methodsFor: 'accessing' stamp: 'sw 10/30/2000 11:11'!isCurrentlyGraphical	"Answer whether the receiver is currently showing a graphical face"	| first |	^ submorphs size > 0 and:		[((first _ submorphs first) isKindOf: ImageMorph) or: [first isKindOf: SketchMorph]]! !!ReferenceMorph methodsFor: 'events' stamp: 'sw 10/24/2000 14:45'!mouseMove: evt	"The mouse moved while the butten was down in the receiver"	| aForm |	aForm _ self imageForm.	(self containsPoint: evt cursorPoint)		ifTrue:			[aForm reverse displayOn: Display]		ifFalse:			[aForm displayOn: Display]! !!ReferenceMorph methodsFor: 'events' stamp: 'sw 10/26/2000 14:41'!mouseUp: evt	"The mouse came up in the receiver; If the mouse is still within the receiver at this point, do the corresponding action"	| aColor |	(aColor _ self valueOfProperty: #oldColor) ifNotNil: [self color: aColor].	(self containsPoint: evt cursorPoint)		ifTrue: [self doButtonAction].	super mouseUp: evt "send to evt handler if any"! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 10/30/2000 16:01'!initialize	"Initialize the receiver with default characteristics and contents"	super initialize.	color _ ScriptingSystem colorBehindTiles.	orientation _ #vertical.	hResizing _ #spaceFill.	vResizing _ #shrinkWrap.	self setDefaultBorderCharacteristics.	firstTileRow _ 1.  "index of first tile-carrying submorph"	self addNewRow.	showingMethodPane _ false! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 10/18/2000 10:38'!buttonRowForEditor	"Answer a row of buttons that comprises the header at the top of the Scriptor"	| aRow aString aButtonMorph buttonFont aStatusMorph aButton aColumn |	buttonFont _ Preferences standardButtonFont.	aRow _ AlignmentMorph newRow color: Color transparent; inset: 0.	aRow hResizing: #shrinkWrap.	aRow addMorphFront:		(SimpleButtonMorph new			label: '!!' font: (StrikeFont familyName: #ComicBold size: 16);			target: self;			color: Color yellow;			borderWidth: 0;			actWhen: #whilePressed;			actionSelector: #tryMe;			balloonTextSelector: #tryMe).	aRow addTransparentSpacerOfSize: 6@10.	self addDismissButtonTo: aRow.	aRow addTransparentSpacerOfSize: 6@1.	aColumn _ AlignmentMorph newColumn beTransparent.	aColumn addTransparentSpacerOfSize: 0@4.	aButton _ UpdatingThreePhaseButtonMorph checkBox.	aButton		target: self;		actionSelector: #toggleWhetherShowingTiles;		getSelector: #showingMethodPane.	aButton setBalloonText: 'toggle between showing tiles and showing textual code'.	aColumn addMorphBack: aButton.	aRow addMorphBack: aColumn.	aRow addTransparentSpacerOfSize: 6@10.	aString _ playerScripted externalName, ' ', self scriptTitle.	aRow addMorphBack:		(aButtonMorph _ SimpleButtonMorph new useSquareCorners label: aString font: buttonFont; target: self; setNameTo: 'title').	aButtonMorph actWhen: #buttonDown; actionSelector: #offerScriptorMenu.	aButtonMorph borderColor: (Color fromRgbTriplet: #(0.065 0.258 1.0)).	aButtonMorph color: (self isAnonymous ifTrue: [Color blue muchLighter] ifFalse: [ScriptingSystem uniformTileInteriorColor]).	aButtonMorph balloonTextSelector: #offerScriptorMenu.	aRow addMorphBack: (aStatusMorph _ self scriptInstantiation statusControlMorph).	aRow addTransparentSpacerOfSize: 6@1.	aRow addMorphBack:		(IconicButton new borderWidth: 0;			labelGraphic: (ScriptingSystem formAtKey: 'AddTest'); color: Color transparent; 			actWhen: #buttonDown;			target: self;			actionSelector: #addYesNoToHand;			shedSelvedge;			balloonTextSelector: #addYesNoToHand).	aRow addTransparentSpacerOfSize: 12@10.	self addDestroyButtonTo: aRow.	self scriptInstantiation updateStatusMorph: aStatusMorph.	^ aRow! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 10/18/2000 10:22'!showSourceInScriptor	"Remove tile panes, if any, and show textual source instead"	| aCodePane |	self isTextuallyCoded ifFalse: [self becomeTextuallyCoded].  "Mostly to fix up grandfathered ScriptEditors"	self submorphs allButFirst do:		[:m | m delete].	aCodePane _ MethodHolder isolatedCodePaneForClass: playerScripted class selector: scriptName.	self addMorphBack: aCodePane.	showingMethodPane _ true.	self currentWorld startSteppingSubmorphsOf: self! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 10/30/2000 11:10'!tryMe	"Evaluate the given script on behalf of the scripted object"	self playerScripted perform: scriptName asSymbol! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 10/30/2000 11:10'!becomeTextuallyCoded	"If the receiver is not currently textually coded, make it become so now, and show its source in place in the Scriptor"	self isTextuallyCoded ifTrue: [^ self].	self saveScriptVersion.	self userScriptObject becomeTextuallyCoded.	(submorphs copyFrom: 2 to: submorphs size) do: [:m | m delete].	self color: Color veryVeryLightGray! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 10/30/2000 16:02'!offerScriptorMenu	"Put up a menu in response to the user's clicking in the menu-request area of the scriptor's heaer"	| aMenu  count |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: scriptName asString.	count _ self savedTileVersionsCount.		(self isTextuallyCoded and: [self showingMethodPane not]) ifTrue:		["Fix up old guys that  are not showing the code in place"		self showSourceInScriptor].	self showingMethodPane		ifFalse:				"currently showing tiles"			[aMenu add: 'show code textually' action: #showSourceInScriptor.			count > 1 ifTrue: 				[aMenu add: 'revert to tile version...' action:	#revertScriptVersion].			aMenu add: 'save this version'	action: #saveScriptVersion]		ifTrue:				"current showing textual source"			[count >= 1 ifTrue:				[aMenu add: 'revert to tile version' action: #revertToTileVersion].			aMenu add: 'make tiles from this code' action: #recreateTileVersion].	aMenu addList: #(		-		('fires per tick...'				chooseFrequency)		('destroy this script'				destroyScript)		('rename this script'				renameScript)		('explain status alternatives' 	explainStatusAlternatives)		('button to fire this script'		tearOfButtonToFireScript)).	aMenu popUpInWorld: self currentWorld.	"		('add parameter to this script'	addParameter)"! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 10/26/2000 14:47'!recreateTileVersion	"The receiver, currently showing textual code, is asked to create fresh tiles by decompiling the code of the textual script."	| parseTree |	true ifTrue: [^ self inform: 'No, this is really Under Construction!!Not yet available'].	parseTree _ Decompiler new decompile: scriptName		in: playerScripted class 		method: (playerScripted class compiledMethodAt: scriptName).	self tilesFrom: parseTree.	self flag: #noteToTed.   "Ted, see my notes in #tilesFrom:"	self install.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 10/18/2000 10:21'!revertToTileVersion	"The receiver, currently showing textual code,  is asked to revert to the last-saved tile version"	| aUserScript |	aUserScript _ playerScripted class userScriptForPlayer: playerScripted selector: scriptName.	aUserScript revertToLastSavedTileVersionFor: self.	self currentWorld startSteppingSubmorphsOf: self! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 10/30/2000 16:03'!savedTileVersionsCount	"Answer the number of saved tile versions that currently exist for this script"	^ (playerScripted class userScriptForPlayer: playerScripted selector: scriptName) savedTileVersionsCount! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 10/18/2000 10:13'!toggleWhetherShowingTiles	"Toggle between showing the method pane and showing the tiles pane"	self showingMethodPane		ifFalse:				"currently showing tiles"			[self showSourceInScriptor]		ifTrue:				"current showing textual source"			[self savedTileVersionsCount >= 1				ifTrue:					[self revertToTileVersion]				ifFalse:					[self beep]]! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'sw 10/30/2000 11:09'!showingMethodPane	"Answer whether the receiver is currently showing the textual method pane"	^ showingMethodPane ifNil: [showingMethodPane _ false]! !!ScriptEditorMorph methodsFor: 'copying' stamp: 'sw 10/9/2000 07:27'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	scriptName _ scriptName veryDeepCopyWith: deepCopier.	firstTileRow _ firstTileRow veryDeepCopyWith: deepCopier.	timeStamp _ timeStamp veryDeepCopyWith: deepCopier.	playerScripted _ playerScripted.		"Weakly copied"	handWithTile _ handWithTile.  "Just a cache"	showingMethodPane _ showingMethodPane.! !!ScriptEditorMorph methodsFor: 'object fileIn' stamp: 'sw 10/9/2000 07:38'!convertbosfcebbochvimlpsftph0: varDict bosfcebbochvimlpsftphs0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'scriptName' 'firstTileRow' 'timeStamp' 'playerScripted' 'handWithTile').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('showingMethodPane')  If a non-nil value is needed, please assign it."! !!ScriptInstantiation methodsFor: 'anonymity' stamp: 'sw 10/30/2000 11:08'!initializePermanentScriptFor: aPlayer selector: aSelector	"Initialize the receiver on behalf of the player, setting its status to #normal and giving it the given selector"	player _ aPlayer.	status _ #normal.	selector _ aSelector! !!ScriptInstantiation methodsFor: 'anonymity' stamp: 'sw 10/6/2000 06:06'!isAnonymous	"Anonymity is no longer supported, and the inst var underlying it has been removed, but this hook remains as its tombstone"	^ false! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'sw 10/8/2000 08:14'!actWhen	"acceptable symbols:  #buttonDown, #buttonUp, and #whilePressed"	^ actWhen! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 10/24/2000 05:55'!setNewFormFrom: formOrNil	"Set the receiver's form as indicated.   If nil is provided, then a default form will be used, possibly retrieved from the receiver's defaultValue property"	| defaultImage |	formOrNil ifNotNil: [^ self form: formOrNil].	defaultImage _ self defaultValueOrNil ifNil: [ScriptingSystem squeakyMouseForm].	self form: defaultImage! !!SketchMorph methodsFor: 'other' stamp: 'sw 10/30/2000 10:29'!couldHoldSeparateDataForEachInstance	"Answer whether this type of morph is inherently capable of holding separate data for each instance ('card data')  SketchMorphs answer true, because they can serve as 'picture-holding' fields"	^ true! !!SketchMorph methodsFor: 'other' stamp: 'sw 10/30/2000 10:28'!currentDataValue	"Answer the object which bears the current datum for the receiver"	^ originalForm! !!SketchMorph methodsFor: 'other' stamp: 'sw 10/25/2000 07:01'!variableDocks	"Answer a list of VariableDock objects for docking up my data with an instance held in my containing playfield"	^ Array with: (VariableDock new variableName: self defaultVariableName  type: #form definingMorph: self morphGetSelector: #form morphPutSelector: #setNewFormFrom:)! !!SlotInformation methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 10:15'!variableDock	"Answer the variable dock associated with the receiver, or nil if none"	^ variableDock! !!SlotInformation methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 10:16'!variableDock: vd	"Set the receiver's variableDock as indicated"	variableDock _ vd! !!SlotInformation methodsFor: 'object fileIn' stamp: 'sw 10/6/2000 08:06'!converttdf0: varDict tdfvv0: smartRefStrm	"These variables are automatically stored into the new instance #('type' 'documentation' 'floatPrecision').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('variableDock' 'variableDefinition')  If a non-nil value is needed, please assign it."! !!SmallInteger methodsFor: 'printing' stamp: 'sw 10/26/2000 09:01'!uniqueNameForReference	"Answer a nice name by which the receiver can be referred to by other objects.   For SmallIntegers, we can actually just use the receiver's own printString, though this is pretty strange in some ways."	^ self asString! !!StackMorph methodsFor: 'initialization' stamp: 'sw 10/30/2000 16:16'!initialize	"Initialize the stack"	| initialBackground |	super initialize.	initialBackground _ self findA: PasteUpMorph.  "yuk"	initialBackground extent: (640@480); beSticky.	initialBackground beAStackBackground.	self beUnsticky.	self setProperty: #controlsAtBottom toValue: true.	cards _ OrderedCollection with: initialBackground currentDataInstance."self currentHand attachMorph: StackMorph authoringPrototype"! !!StackMorph methodsFor: 'menu' stamp: 'sw 10/30/2000 10:11'!addBookMenuItemsTo: aMenu hand: aHandMorph	"Add book-related items to the given menu"	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous card' action: #goToPreviousCardInStack.	subMenu add: 'next card' action: #goToNextCardInStack.	subMenu add: 'go to card...' action: #goToCard.	subMenu add: 'insert a card' action: #insertCard.	subMenu add: 'delete this card' action: #deleteCard.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue:			[subMenu add: 'hide card controls' action: #hidePageControls.			subMenu add: 'fewer card controls' action: #fewerPageControls]		ifFalse:			[subMenu add: 'show card controls' action: #showPageControls].	subMenu addLine.	subMenu add: 'sound effect for all backgrounds' action: #menuPageSoundForAll:.	subMenu add: 'sound effect this background only' action: #menuPageSoundForThisPage:.	subMenu add: 'visual effect for all backgrounds' action: #menuPageVisualForAll:.	subMenu add: 'visual effect this background only' action: #menuPageVisualForThisPage:.	subMenu addLine.	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'uncache page sorter' action: #uncachePageSorter.	(self hasProperty: #dontWrapAtEnd)		ifTrue: [subMenu add: 'wrap after last page' selector: #setWrapPages: argument: true]		ifFalse: [subMenu add: 'stop at last page' selector: #setWrapPages: argument: false].	subMenu addLine.	subMenu add: 'search for text' action: #textSearch.	(self primaryHand pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	subMenu add: 'send all pages to server' action: #savePagesOnURL.	subMenu add: 'send this page to server' action: #saveOneOnURL.	subMenu add: 'reload all from server' action: #reload.	subMenu add: 'copy page url to clipboard' action: #copyUrl.	subMenu add: 'keep in one file' action: #keepTogether.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: 'book...' subMenu: subMenu! !!StackMorph methodsFor: 'menu' stamp: 'sw 10/23/2000 16:43'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'Stack'.	aMenu addStayUpItem.	aMenu addList: #(		('find...'								textSearch)		('show designations' 					showDesignationsOfObjects)		('explain designations'					explainDesignations)		('look inside'							openInsideLook)		-		('previous card' 						goToPreviousCardInStack)		('next card' 							goToNextCardInStack)		('first card' 							goToFirstCardOfStack)		('last card' 								goToLastCardOfStack)		('go to card...' 							goToCard)		-		('add a card of this background' 		insertCard)		('add a card of background...'		 	insertCardOfBackground)		('make a new background...' 			makeNewBackground)		-		('delete this card' 						deleteCard)		-		('scripts for this background'			browseCardClass)		-		('debug...'								offerStackDebugMenu)		('bookish items...' 						offerBookishMenu)).	aMenu addUpdating: #showingPageControlsString action: #toggleShowingOfPageControls.	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!StackMorph methodsFor: 'menu' stamp: 'sw 10/30/2000 10:03'!offerBookishMenu	"Offer a menu with book-related items in it"	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'Stack / Book'.	aMenu addStayUpItem.	aMenu addList:		#(('sort pages'			sortPages)		('uncache page sorter'	uncachePageSorter)).	(self hasProperty: #dontWrapAtEnd)		ifTrue: [aMenu add: 'wrap after last page' selector: #setWrapPages: argument: true]		ifFalse: [aMenu add: 'stop at last page' selector: #setWrapPages: argument: false].	aMenu addList:		#(('make bookmark'		bookmarkForThisPage)		('make thumbnail'		thumbnailForThisPage)).	aMenu addLine.	aMenu add: 'sound effect for all pages' action: #menuPageSoundForAll:.	aMenu add: 'sound effect this page only' action: #menuPageSoundForThisPage:.	aMenu add: 'visual effect for all pages' action: #menuPageVisualForAll:.	aMenu add: 'visual effect this page only' action: #menuPageVisualForThisPage:.	aMenu addLine.	(self primaryHand pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'   action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (self dragNDropEnabled ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #toggleDragNDrop.	aMenu add: 'make all pages this size' action: #makeUniformPageSize.	aMenu add: 'send all pages to server' action: #savePagesOnURL.	aMenu add: 'send this page to server' action: #saveOneOnURL.	aMenu add: 'reload all from server' action: #reload.	aMenu add: 'copy page url to clipboard' action: #copyUrl.	aMenu add: 'keep in one file' action: #keepTogether.	aMenu addLine.	aMenu add: 'load PPT images from slide #1' action: #loadImagesIntoBook.	aMenu add: 'background color for all pages...' action: #setPageColor.	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!StackMorph methodsFor: 'menu' stamp: 'sw 10/30/2000 10:06'!offerStackDebugMenu	"Put up a menu offering debugging items for the stack"	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'Stack debugging'.	aMenu addStayUpItem.	aMenu addList: #(		('reassess'								reassessBackgroundShape)		('relax grip on variable names'			relaxGripOnVariableNames)		('commit card data'						commitCardData)		-		('browse card uniclass'					browseCardClass)		('inspect card'							inspectCurrentCard)		('inspect background'					inspectCurrentBackground)		('inspect stack'							inspectCurrentStack)).	aMenu popUpInWorld: (self world ifNil: [self currentWorld])! !!StackMorph methodsFor: 'background' stamp: 'sw 10/26/2000 14:41'!backgroundWithCard: aCard	"Answer the background which contains aCard."	^ self backgrounds detect:		[:aBackground | aBackground containsCard: aCard] ifNone: [nil]! !!StackMorph methodsFor: 'background' stamp: 'sw 10/30/2000 10:04'!backgrounds	"Answer the list of backgrounds available in the receiver"	^ self pages! !!StackMorph methodsFor: 'background' stamp: 'sw 10/30/2000 10:07'!makeNewBackground	"Make a new background for the stack.  Obtain a name for it from the user.  It starts out life empty"	| aName aColor newPage |	aName _ FillInTheBlank request: 'What should we call this new background?' initialAnswer: 'alternateBackground'.	aName isEmptyOrNil ifTrue: [^ self].	aColor _ self color muchLighter.	newPage _ PasteUpMorph newSticky extent: currentPage extent; color: aColor.	newPage beAStackBackground.	newPage borderWidth: currentPage borderWidth; borderColor: currentPage borderColor.	newPage setNameTo: aName.	newPage resizeToFit: false.	pages isEmpty		ifTrue: [pages add: newPage]		ifFalse: [pages add: newPage after: currentPage].	cards add: newPage currentDataInstance after: currentPage currentDataInstance.	self nextPage.! !!StackMorph methodsFor: 'background' stamp: 'sw 10/30/2000 10:13'!reassessBackgroundShape	"Have the current page reconsider its cards' instance structure"	^ self currentPage reassessBackgroundShape ! !!StackMorph methodsFor: 'background' stamp: 'sw 10/30/2000 10:15'!reshapeBackground	"Abandon any memory of variable-name preferences for the current background, and reassess its instance structure"	^ self currentPage reshapeBackground ! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:24'!browseCardClass	"Browse the class of the current card"	| suffix |	suffix _ self currentCard class name numericSuffix.	HierarchyBrowser newFor: self currentCard class labeled: 'Background ', suffix asString! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:26'!cardIndexOf: aCard	"Answer the ordinal position of aCard in the receiver's list"	^ cards indexOf: aCard ifAbsent: [nil]! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:26'!cards	"Answer a list of the cards of the receiver, in order"	^ cards copy! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:27'!currentCard	"Answer the current card of the current background of the receiver"	^ currentPage currentDataInstance! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:08'!deleteCard	"Delete the current card from the stack"	| aCard |	aCard _ self currentCard.	cards size = 1 ifTrue: [^ self beep].	self goToNextCardInStack.	cards remove: aCard.! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:10'!deleteCard: aCard	"Delete the current card from the stack."	cards size = 1 ifTrue: [^ self beep].	(aCard == self currentCard) ifTrue: [^ self deleteCard].	cards remove: aCard ifAbsent: []! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:50'!goToCard	"prompt the user for an ordinal number, and use that as a basis for choosing a new card to install in the receiver"	| reply index |	reply _ FillInTheBlank request: 'Which card number? ' initialAnswer: '1'.	reply isEmptyOrNil ifTrue: [^ self].	((index _ reply asNumber) > 0 and: [index <= cards size])		ifFalse: [^ self inform: 'no such card'].	self goToCard: (cards at: index)! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/26/2000 09:11'!goToCard: destinationCard	"Install the indicated destinationCard as the current card in the receiver.  Any viewer currently open on the current card will get retargeted to look at the new one."	| aBackground existingCard oldViewers |	aBackground _ self backgroundWithCard: destinationCard.	existingCard _ aBackground currentDataInstance.	oldViewers _ existingCard ifNil: [#()] ifNotNil: [existingCard allOpenViewers].	aBackground installAsCurrent: destinationCard.	aBackground ~~ currentPage ifTrue:		["concern that need to run opening/closing scripts even when we're not going to a different background"		self goToPageMorph: aBackground].	oldViewers do: [:aViewer | aViewer retargetFrom: existingCard to: destinationCard]! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:49'!goToCardNumber: aCardNumber	"Install the card whose ordinal number is provided as the current card in the stack"	self goToCard: (cards at: aCardNumber)! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/30/2000 16:15'!goToFirstCardInBackground	"Install the initial card in the current background as the current card in the stack"	| kind |	kind _ currentPage player class baseUniclass.	self goToCard: (cards detect: [:aCard | aCard isKindOf: kind] ifNone: [^ self beep])! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:44'!goToFirstCardOfStack	"Install the initial card in the stack as the current card"	self goToCard: cards first! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/30/2000 16:15'!goToLastCardInBackground	"Install the final card in the current background as the current card"	| kind |	kind _ currentPage player class baseUniclass.	self goToCard: (cards reversed detect: [:aCard | aCard isKindOf: kind] ifNone: [^ self beep])! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 17:03'!goToLastCardOfStack	"Install the final card in the stack as the current card"	self goToCard: cards last! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 14:45'!goToNextCardInStack	"Make the card *after* the current card become the current card"	| anIndex newCard |	anIndex _ cards indexOf: currentPage currentDataInstance.	newCard _ cards atWrap: anIndex + 1.	self goToCard: newCard! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 15:01'!goToPreviousCardInStack	"Install the previous card as my current one"	| anIndex newCard |	anIndex _ cards indexOf: currentPage currentDataInstance.	newCard _ cards atWrap: anIndex - 1.	self goToCard: newCard! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:02'!insertCard	"Create a new card of the current background and make it become the current card"	self insertCardOfBackground: currentPage! !!StackMorph methodsFor: 'controls' stamp: 'sw 10/30/2000 10:05'!fullControlSpecs	"Answer specifications for the long form of iconic stack/book controls"	^ #(		spacer		variableSpacer		('-'			deleteCard					'Delete this card')		spacer		( 'Ç'		goToFirstCardOfStack			'First card')		spacer		( '<' 		goToPreviousCardInStack		'Previous card')		spacer		('¥'			invokeBookMenu 			'Click here to get a menu of options for this stack.')		spacer		('¦'			reshapeBackground  		'Reshape')		spacer		('¤'			showDesignationsOfObjects 	'Show designations')		spacer		('>'			goToNextCardInStack			'Next card')		spacer		( 'È'		goToLastCardOfStack			'Final card')		spacer		('+'			insertCard					'Add a new card after this one')		variableSpacer		('×'			fewerPageControls			'Fewer controls(if shift key pressed,deletes controls)'))! !!StackMorph methodsFor: 'controls' stamp: 'sw 10/30/2000 16:31'!pageControlsMorphFrom: controlSpecs	"Answer a controls morph derived from the spec supplied"	| controls |	controls _ super pageControlsMorphFrom: controlSpecs.	controls eventHandler: nil.  "not grabbable"	^ controls! !!StackMorph methodsFor: 'controls' stamp: 'sw 10/30/2000 10:09'!shortControlSpecs	"Answer specficiations for the shorter form of stack controls"	^ #(		spacer		variableSpacer		( '<'		goToPreviousCardInStack		'Previous card')		spacer		('¥'		invokeBookMenu 			'Click here to get a menu for this stack.')		spacer		('>'		goToNextCardInStack			'Next card')		variableSpacer		('×'	showMoreControls				'More controls(if shift key pressed,deletes controls)'))! !!StackMorph methodsFor: 'debugging' stamp: 'sw 10/30/2000 10:13'!inspectCurrentBackground	"Open an inspector on the corrent background.  Ideally should put include the background name in the inspector's title."	^ self currentPage inspectWithLabel: 'A Background'! !!StackMorph methodsFor: 'debugging' stamp: 'sw 10/23/2000 16:37'!inspectCurrentCard	"For debugging: open an Inspector on the receiver's current card"	^ self currentCard inspectWithLabel: 'A Card'! !!StackMorph methodsFor: 'debugging' stamp: 'sw 10/30/2000 10:09'!inspectCurrentStack	"Triggered from the stack-debug menu, open an Inspector on the receiver"	^ self inspectWithLabel: 'A Stack'! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/23/2000 16:27'!commitCardData	"Make certain that the player data are written back to the player instance"	^ self currentCard commitCardPlayerData ! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 10:10'!defaultNameStemForNewPages	"Answer the stem to use as the default for names of cards in the stack"	^ 'card'! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 10:03'!explainDesignations	"Give the user an explanation of what the designations mean"	self currentPage explainDesignations! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/23/2000 16:49'!insertCardOfBackground	"Prompt the user for choice of a background, and insert a new card of that background"	| bgs aMenu aBackground |	(bgs _ self backgrounds) size == 1 ifTrue:		[self inform: 'At this time, there IS only one kind ofbackground in this stack, so that''swhat you''ll get'.		^ self insertCard].	aMenu _ SelectionMenu		labels: 		(bgs collect: [:bg | bg externalName])		selections: 	bgs.	(aBackground _ aMenu startUp) ifNotNil:		[self insertCardOfBackground: aBackground]! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/23/2000 16:00'!insertCardOfBackground: aBackground	"Insert a new card of the given background and have it become the current card"	| newCard |	newCard _  aBackground newCard.	cards add: newCard after: self currentCard.	self goToCard: newCard! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 10:08'!openInsideLook	"Open an inside-look at the current page.  This is a previously-demoed feature not presently incorporated in released code,"	true ifTrue: [self notYetImplemented] ifFalse: [self currentPage openInsideLook]! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 10:04'!relaxGripOnVariableNames	"Have the current background relax its grip on existing variable name"	^ self currentPage relaxGripOnVariableNames ! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 10:10'!showDesignationsOfObjects	"Momentarily show which objects on the current card belong to which designation category"	self currentPage showDesignationsOfObjects! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/23/2000 17:37'!stackDo: aBlock	"Evaluate aBlock on behalf of the receiver stack"	^ aBlock value: self! !!StackMorph class methodsFor: 'viewer' stamp: 'sw 10/30/2000 16:13'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((#'stack navigation'			((command goToNextCardInStack 'Go to the next card')			(command goToPreviousCardInStack  'Go to the previous card')			(command goToFirstCardInBackground 'Go to the first card of the current background')			(command goToFirstCardOfStack 'Go to the first card of the entire stack')			(command goToLastCardInBackground 'Go to the last card of the current background')			(command goToLastCardOfStack 'Go to the last card of the entire stack')			(command deleteCard 'Delete the current card')			(command insertCard 'Create a new card'))))! !!StackMorph class methodsFor: 'authoring prototype' stamp: 'sw 10/9/2000 07:43'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book pageSize: (480 @ 320); color: (Color gray: 0.7).	book borderWidth: 1; borderColor: Color black.	book currentPage extent: book pageSize.	book showPageControls: book fullControlSpecs.	^ book"self currentHand attachMorph: StackMorph authoringPrototype"! !!StackMorph class methodsFor: 'authoring prototype' stamp: 'sw 10/31/2000 05:03'!designationsExplainer	"Answer a morph that contains designation explanation"	| aMorph aSwatch aTextMorph |	aMorph _ AlignmentMorph newColumn color: Color black; inset: 1.	#((green		'Shared items onBackground.Exact same itemshared by every card')	(orange'Data items onBackgroundEach card has itsown data')	(red'Instance-specificitemsuniqueto this card')) do:	[:aPair |		aSwatch _ AlignmentMorph new extent: 132 @80; color: (Color perform: aPair first); lock.		aSwatch hResizing: #rigid; vResizing: #rigid; inset: 0.		aSwatch borderColor: Color black.		aTextMorph _ TextMorph new string: aPair second fontName: 'ComicBold' size: 18.		aTextMorph width: 130.		aTextMorph centered.		aSwatch addMorphBack: aTextMorph.		aMorph addMorphBack: aSwatch].	^ aMorph	"StackMorph designationsExplainer openInHand"! !!StackMorph class methodsFor: 'navigation buttons' stamp: 'sw 10/27/2000 10:53'!nextCardButton	"Answer a button that advances the user to the next card in the stack"	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #goToNextCardInStack; label: '>'; color: Color yellow; borderWidth: 0.	aButton setNameTo: 'next'.	^ aButton! !!StackMorph class methodsFor: 'navigation buttons' stamp: 'sw 10/27/2000 10:53'!previousCardButton	"Answer a button that will take the user to the preceding card in the stack"	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #goToPreviousCardInStack; label: '<'; color: Color yellow ; borderWidth: 0.	aButton setNameTo: 'previous'.	^ aButton! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 10/30/2000 09:07'!smallBoldFont	"Answer a small bold font for use in some standard scripting-support structures"	^ StrikeFont familyName: #ComicBold size: 12! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 9/14/2000 21:29'!readFormsFromFileNamed: aFileName andStoreIntoGlobal: globalName	"Read the a FormDictionary in from a designated file on disk and save it in the designated global"	| aReferenceStream |	aReferenceStream _ ReferenceStream fileNamed: aFileName.	Smalltalk at: globalName put: aReferenceStream next.	aReferenceStream close	"ScriptingSystem readFormsFromFileNamed: 'SystemFormsFromFwdF.forms' andStoreIntoGlobal: #FormsTemp"	"ScriptingSystem saveForm:  (FormsTemp at: #StackElementDesignationHelp) atKey: #StackElementDesignationHelp"! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 10/30/2000 16:33'!allClassVarNamesInSystem	"Compute and answer a set of all the class variable names known to the sytem from any class"	| aList |	aList _ OrderedCollection new.	Object withAllSubclasses do:		[:c | aList addAll: c allClassVarNames].	^ aList asSet	"ScriptingSystem allClassVarNamesInSystem"! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 10/30/2000 16:37'!allKnownClassVariableNames	"Answer a set of all the knwon class variable names in the system.  This normally retrieves them from a cache, and at present there is no organized mechanism for invalidating the cache.  The idea is to avoid, in the References scheme, names that may create a conflict"	^ ClassVarNamesInUse ifNil: [ClassVarNamesInUse _ self allClassVarNamesInSystem]	"ClassVarNamesInUse _ nil.	Time millisecondsToRun: [ScriptingSystem allKnownClassVariableNames]"! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 10/30/2000 09:08'!referenceAt: aSymbol	"Answer the object referred to by aSymbol in the 'References' scheme of things, or nil if none"	^ References at: aSymbol ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 10/30/2000 09:33'!referenceAt: aSymbol put: anObject	"Store a reference to anObject at the given symbol in the References directory"	^ References at: aSymbol put: anObject! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 10/30/2000 16:47'!resetAllScriptingReferences	"Clear out all the elements in the References directory"		Smalltalk at: #References put: IdentityDictionary new	"ScriptingSystem resetAllScriptingReferences"! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 10/30/2000 16:45'!resetStaleScriptingReferences	"Remove all scripting references that are no longer needed"	References  removeUnreferencedKeys	"ScriptingSystem resetStaleScriptingReferences"! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 10/30/2000 09:07'!uniqueNameForReference	"Answer a more-or-less global name by which the receiver can be referred to in scripts"	^ #ScriptingSystem! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/30/2000 09:56'!colorForType: typeSymbol	"Answer the color to use to represent the given type symbol"	^ ((TypeColorDictionary		at: typeSymbol asSymbol		ifAbsent: [^ Color magenta muchLighter]) at: 1) lighter! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 10/30/2000 16:38'!initializeTypeColors	"Initialize the list of hard-coded type colors.  The list of types is nascent and there are some not-yet-deployed types mentioned.  Think of nothing here as sacred."	"ScriptingSystem initializeTypeColors"	TypeColorDictionary _ IdentityDictionary new.	#((command		(0.065 0.258 1.0)			(0.065 0.258 1.0))	(number		(0.8 0.4 0.2)				(1.0	0.6 0.2))	(boolean		(0.94 1.0 0.06)			(0.94 1.0 0.06))  		"some kind of yellowish"	(player			(1.0  0 0.065)			(1.0  0 0.065)) 	(string			(0.0 0.0 1.0)				(0.0 0.0 1.0))     	"not in use"	(color			(1.0  0 0.065)			(0.806 1.0 0.806))  	"some damn dark red"	(sound			(1.0 0.06 0.84)			(1.0 0.06 0.84))   	"a kind of magenta"	(buttonPhase	(0.806 1.0 0.806)			(0.806 1.0 0.806))	"arbitrary"	(menu			(0.4 0.4 0.4)				(0.4 0.4 0.4))		"arbitrary"	(object			(1.0 0.26 0.98)			(1.0 0.26 0.98))   	"backstop"	(rotationStyle	(1.0 0.26 0.98)			(1.0 0.26 0.98))   	"future"		(group			(0.0 0.0 1.0)				(0.0 0.0 1.0))		 "not in use"	(costume		(0.806 1.0 0.806)			(0.806 1.0 0.806))	 "not in use") do:		[:triplet | TypeColorDictionary at: triplet first put:			(Array 	with: 	((Color fromRgbTriplet: triplet second) mixed: self colorFudge with: ScriptingSystem uniformTileInteriorColor)					with:	(Color fromRgbTriplet: triplet third))]! !!String methodsFor: 'converting' stamp: 'sw 5/30/2000 14:58'!numericSuffix	^ self stemAndNumericSuffix last"'abc98' numericSuffix'98abc' numericSuffix"! !!String methodsFor: 'converting' stamp: 'sw 10/26/2000 10:00'!unparenthetically	"If the receiver starts with (..( and ends with matching )..), strip them"	| curr |	curr _ self.	[((curr first == $() and: [curr last == $)])] whileTrue:		[curr _ curr copyFrom: 2 to: (curr size - 1)].	^ curr"'((fred the bear))' unparenthetically"		! !!String methodsFor: 'converting' stamp: 'sw 10/6/2000 08:19'!withFirstCharacterDownshifted	"Answer an object like the receiver but with first character downshifted if necesary"	"'MElViN' withFirstCharacterDownshifted"	"#Will withFirstCharacterDownshifted"	| answer |	answer _ self asString.	answer at: 1 put:		(answer at: 1) asLowercase.	^ answer as: self class! !!TextFieldMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 09:03'!currentDataValue	"Answer the current data value held by the receiver"	^ self contents! !!TextFieldMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 16:52'!initialize	"set up the field"	| tm |	super initialize.	self color: Color veryLightGray lighter.	self addMorph: (tm _ TextMorph new).	tm fillingOnOff.  "filling on"! !!TextFieldMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/26/2000 09:14'!variableDocks	"Answer a list of VariableDock objects for docking up my data with an instance held in my containing playfield"	self flag: #noteToTed.  "Last I looked this may have not yet worked.  I was trying to make your TextFieldMorphs work within the preliminary stack/card framework for a demo, but ran out of gas.  Uncertain where this stands, and uncertain exactly should be the foundation for 'text fields' for our brave new world"	^ Array with: (VariableDock new variableName: self defaultVariableName  type: #text definingMorph: self morphGetSelector: #contents morphPutSelector: #contents:)! !!TextFieldMorph class methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 09:02'!authoringPrototype 	"Answer an instance of the receiver that can serve as a prototype for authoring"	| proto |	proto _ super authoringPrototype.	proto setProperty: #shared toValue: true.	proto extent: 170 @ 30.	proto color: Color veryLightGray lighter.	proto contents: 'on a clear day you can...'..	^ proto! !!TextMorph methodsFor: 'accessing' stamp: 'sw 10/30/2000 09:02'!couldHoldSeparateDataForEachInstance	"Answer whether this type of morph is inherently capable of holding separate data for each instance ('card data')"	^ true! !!TextMorph methodsFor: 'accessing' stamp: 'sw 10/30/2000 09:01'!currentDataValue	"Answer the current data value held by the receiver"	^ text! !!TextMorph methodsFor: 'accessing' stamp: 'sw 5/31/2000 01:18'!newContents: stringOrText fromCard: aCard	"Accept new text contents."	| newText setter |	newText _ stringOrText asText.	text = newText ifTrue: [^ self].  "No substantive change"	text ifNotNil: [		text embeddedMorphs do: [ :m | m delete ] ].	text _ newText.	"add all morphs off the visible region; they'll be moved into the right place when they become visible.  (this can make the scrollable area too large, though)"	stringOrText asText embeddedMorphs do: [ :m | 		self addMorph: m. 		m position: (-1000@0)].	self releaseParagraph.  "update the paragraph cache"	self paragraph.  "re-instantiate to set bounds"	self holdsSeparateDataForEachInstance		ifTrue:			[setter _ self valueOfProperty: #setterSelector.			setter ifNotNil:				[aCard perform: setter with: newText]].	self world ifNotNil:		[self world startSteppingSubmorphsOf: self ].! !!TextMorph methodsFor: 'accessing' stamp: 'sw 10/27/2000 07:01'!setNewContentsFrom: stringOrTextOrNil	"Using stringOrTextOrNil as a guide, set the receiver's contents afresh.  If the input parameter is nil, the a default value stored in a property of the receiver, if any, will supply the new initial content.  This method is only called when a VariableDock is attempting to put a new value.  This is still messy and ill-understood and not ready for prime time."	| defaultValue |	stringOrTextOrNil ifNotNil: [^ self newContents: stringOrTextOrNil fromCard: (self valueOfProperty: #cardInstance)].   "Well, totally yuk -- emergency measure late on eve of demo"	defaultValue _ self valueOfProperty: #defaultValue ifAbsent: ['------'].	self contents: defaultValue deepCopy wrappedTo: self width! !!TextMorph methodsFor: 'accessing' stamp: 'sw 10/25/2000 07:02'!variableDocks	"Answer a list of VariableDock objects for docking up my data with an instance held in my containing playfield"	^ Array with: (VariableDock new variableName: self defaultVariableName type: #text definingMorph: self morphGetSelector: #contents morphPutSelector: #setNewContentsFrom:)! !!TextMorph methodsFor: 'editing' stamp: 'sw 10/13/2000 17:00'!cornerStyle: ignored	"set the receiver's corner style as indicated.  TextMorphs don't know what to make of this, but are gracious enough not to generate an error"! !!TheWorldMenu methodsFor: 'construction' stamp: 'sw 10/31/2000 20:39'!windowsMenu        "Build the windows menu for the world."        ^ self fillIn: (self menu: 'windows & flaps...') from: {                  { 'find window' . { #myWorld . #findWindow: }. 'Presents a list of all windows; if you choose one from the list, it becomes the active window.'}.                { 'find changed browsers...' . { #myWorld . #findDirtyBrowsers: }. 'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.                { 'find changed windows...' . { #myWorld . #findDirtyWindows: }. 'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.			 nil.                { #staggerPolicyString . { self . #toggleWindowPolicy }. 'stagger: new windows positioned so you can see a portion of each one.                tile: new windows positioned so that they do not overlap others, if possible.'}.                nil.                { 'collapse all windows' . { #myWorld . #collapseAll }. 'Reduce all open windows to collapsed forms that only show titles.'}.                { 'expand all windows' . { #myWorld . #expandAll }. 'Expand all collapsed windows back to their expanded forms.'}.                nil.                { 'delete unchanged windows' . { #myWorld . #closeUnchangedWindows }. 'Deletes all windows that do not have unsaved text edits.'}.                { 'delete non-windows' . { #myWorld . #deleteNonWindows }. 'Deletes all non-window morphs lying on the world.'}.                { 'delete both of the above' . { self .#cleanUpWorld }. 'deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'}.                nil.                { #suppressFlapsString . { self . #toggleFlapSuppressionInProject }. 'Governs whether flaps should be shown in this project'}.                { #useGlobalFlapsString . { self. #toggleWhetherToUseGlobalFlaps }. 'Governs whether a universal set of "global" flaps should be used in all morphic projects that currently are showing flaps.'}.                nil.                { 'new global flap...'  . { Utilities . #addGlobalFlap }. 'Create a new flap that will be shared by all morphic projects'}.                { 'new project flap...'  . { Utilities . #addLocalFlap }. 'Create a new flap to be used only in this project.'}.                { 'add stack-tools flap'  . { Utilities . #addStackToolsFlap }. 'Add a flap in this project that offers tools for creating stacks and cards.'}.				nil.                { 'about flaps...' . { Utilities . #explainFlaps }. 'Gives a window full of details about how to use flaps.'}.        }! !!ThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/26/2000 13:50'!morphToView	"If the receiver is viewing some object, answer a morph can be thought of as being viewed;  A gesture is made toward generalizing this beyond the morph/player regime, in that a plain blue rectangle is returned rather than simply failing if the referent is not itself displayable."	objectToView ifNil: [^ nil].	^ objectToView isMorph		ifTrue:			[objectToView]		ifFalse:			[(objectToView isKindOf: Player)				ifTrue:					[objectToView costume]				ifFalse:					[RectangleMorph new color: Color blue]]! !!TileMorph methodsFor: 'initialization' stamp: 'sw 9/28/2000 12:27'!referTo: anObject	"Make the receiver be an object-reference tile whose referent is anObject"	type _ #objRef.	typeColor _ ScriptingSystem colorForType: anObject basicType.	actualObject _ anObject.	self line1: anObject uniqueNameForReference! !!TileMorph methodsFor: 'initialization' stamp: 'sw 10/30/2000 08:58'!retargetFrom: oldPlayer to: newPlayer	"Change the receiver so that if formerly it referred to oldPlayer, it refers to newPlayer instead"	| newLabel |	(type == #objRef  and: [actualObject == oldPlayer]) ifTrue:		[actualObject _ newPlayer.		[newLabel _ actualObject externalName.		self isPossessive ifTrue:			[newLabel _ newLabel, '''s'].		self line1: newLabel]]! !!TileMorph methodsFor: 'initialization' stamp: 'sw 10/11/2000 04:15'!setLiteral: anObject	"Set the receiver's literal to be anObject.  Create a readout morph and add it to the receiver, deleting any existing one that may be there."	| m already |	already _ submorphs detect: [:aSubMorph  | aSubMorph isKindOf: UpdatingStringMorph] ifNone: [nil].	already ifNotNil: [already delete].	type _ #literal.	m _ UpdatingStringMorph contents: ' ' font: ScriptingSystem fontForTiles.	m target: self; getSelector: #literal; putSelector: #literal:.	(anObject isKindOf: String orOf: Text) ifTrue: [m useStringFormat].	self addMorphBack: m.	self setLiteralInitially: anObject.! !!TileMorph methodsFor: 'initialization' stamp: 'sw 10/30/2000 16:54'!setObjectRef: aString actualObject: anObject	"Set the receiver to bear an object reference to the given object.  aString is historical and no longer used"	type _ #objRef.	actualObject _ anObject.	self line1: anObject nameForViewer! !!TileMorph methodsFor: 'code generation' stamp: 'sw 10/30/2000 16:57'!storeCodeOn: aStream indent: tabCount	"Store code representing the receiver onto the stream, with the given amount of indentation"	| op playerBearingCode |	playerBearingCode _ self playerBearingCode.  "Must determine whom is scripted for what follows to work; if it's ever nil, we've got trouble"	type = #expression ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: operatorOrExpression;			nextPut: $)].	type = #literal ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: literal printString;			nextPut: $)].	type == #objRef ifTrue:		[^ (playerBearingCode == actualObject)			ifTrue:				["If the object is the method's own 'self' then we MUST, rather than just MAY, put out 'self' rather than the referencer call, though the latter will temporarily work if only one instance of the uniclass exists."				aStream nextPutAll: 'self']			ifFalse:				[Preferences capitalizedReferences "Global dictionary References"					ifTrue:						[self flag: #deferred.  "Start deploying the meesage-receiver hints soon"						aStream nextPutAll: actualObject uniqueNameForReference]					ifFalse:						"old class-inst-var-based scheme used  Feb 1998 to Oct 2000, and indeed						ongoing in school year 2000-01 at the open school"						[aStream nextPutAll: 'self class '.						aStream nextPutAll: (playerBearingCode class referenceSelectorFor: actualObject)]]].	type = #operator ifTrue:		[((UpdatingOperators includesKey: operatorOrExpression) and:		 [self precedingTileType = #slotRef])			ifTrue: [op _ UpdatingOperators at: operatorOrExpression]			ifFalse: [op _ operatorOrExpression].		^ op isEmpty			ifTrue: [aStream position: aStream position - 1]			ifFalse: [aStream nextPutAll: op]]."The following branch has long been disused	type = #slotRef ifTrue:		[self isThisEverCalled.		refType _ self slotRefType.		refType = #get ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities getterSelectorFor: slotName)].		refType = #set ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities setterSelectorFor: slotName);				nextPut: $:].		refType = #update ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName;				nextPutAll: ': ';				nextPutAll: targetName;				space;				nextPutAll: slotName]]"! !!TileMorph methodsFor: 'private' stamp: 'sw 10/30/2000 09:00'!line1: line1	"Emblazon the receiver with the requested label.  If the receiver already has a label, make the new label be of the same class"	| m desiredW classToUse lab |	classToUse _ (lab _ self labelMorph) ifNotNil: [lab class] ifNil: [StringMorph].	self removeAllMorphs.	m _ classToUse contents: line1 font: ScriptingSystem fontForTiles.	desiredW _ m width + 6.	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	m position: self center - (m extent // 2).	self addMorph: m.! !!AssignmentTileMorph methodsFor: 'arrow' stamp: 'sw 10/13/2000 12:58'!addArrowsIfAppropriate	"If the receiver's slot is of an appropriate type, add arrows to the tile.  The list of types wanting arrows is at this point simply hard-coded."	(#(number sound boolean menu buttonPhase) includes: dataType)  ifTrue: [self addArrows]! !!SymbolListTile methodsFor: 'initialization' stamp: 'sw 10/30/2000 09:04'!choices: choiceList dataType: aDataType	"Initialize the receiver with the given choice-list and data type"	choices _ choiceList.	dataType _ aDataType.	literal _ choiceList first! !!SymbolListTile methodsFor: 'user interface' stamp: 'sw 10/24/2000 10:52'!arrowAction: delta	"Do what is appropriate when an arrow on the tile is pressed; delta will be +1 or -1"	| index |	owner ifNil: [^ self].	literal ifNotNil:		[(index _ choices indexOf: literal) > 0			ifTrue:				[self literal: (choices atWrap: index + delta).				self labelMorph setBalloonText: (ScriptingSystem helpStringForOperator: literal).				self acceptNewLiteral.				self labelMorph informTarget]]! !!SymbolListTile methodsFor: 'user interface' stamp: 'sw 10/24/2000 10:15'!literal: anObject	"Set the receiver's literal as indicated"	literal _ anObject.	self updateLiteralLabel.	self labelMorph informTarget! !!UpdatingSimpleButtonMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 08:56'!step	"If appropriate update the receiver's label"	| newString |	super step.	wordingProvider ifNotNil:		[newString _ wordingProvider perform: wordingSelector.		newString = self label ifFalse: [self labelString: newString; changed]]! !!UpdatingSimpleButtonMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 08:57'!stepTime	"Answer the desired time between steps in milliseconds.  If the receiver has a wordingProvider that may dynamically provide changed wording for the label, step once every 1.5 seconds"	^ wordingProvider ifNotNil: [1500] ifNil: [super stepTime]! !!UpdatingSimpleButtonMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 08:55'!wantsSteps	"Answer whether the receiver wishes to be sent the #step message.  In the current case, this decision depends on whether there is a wordingProvider which can dynamically provide fresh wording for the button's label"	^ wordingProvider notNil! !!ScriptableButton methodsFor: 'label' stamp: 'sw 10/30/2000 11:02'!label	"Answer a string representing the label of the receiver, returning an empty string if necessary"	| aStringMorph |	^ (aStringMorph _ self findA: StringMorph)		ifNil:		['']		ifNotNil:	[aStringMorph contents]! !!ScriptableButton methodsFor: 'label' stamp: 'sw 10/30/2000 10:59'!label: aString	"Set the receiver's label as indicated"	| aLabel |	(aLabel _ self findA: StringMorph)		ifNotNil:			[aLabel contents: aString]		ifNil:			[aLabel _ StringMorph contents: aString font: TextStyle defaultFont.			self addMorph: aLabel].	self extent: aLabel extent + (borderWidth + 6).	aLabel position: self center - (aLabel extent // 2).	aLabel lock! !!ScriptableButton methodsFor: 'label' stamp: 'sw 10/30/2000 10:56'!label: aString font: aFontOrNil	"Set the receiver's label and font as indicated"	| oldLabel m aFont |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	aFont _ aFontOrNil ifNil: [Preferences standardButtonFont].	m _ StringMorph contents: aString font: aFont.	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!ScriptableButton methodsFor: 'label' stamp: 'sw 10/30/2000 11:02'!setLabel	"Invoked from a menu, let the user change the label of the button"	| newLabel |	newLabel _ FillInTheBlank		request:'Enter a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel font: nil].! !!ScriptableButton methodsFor: 'script' stamp: 'sw 10/26/2000 08:52'!editButtonsScript	"The user has touched my Scriptor halo-handle.  Bring up a Scriptor on the script of the button."	| cardsPasteUp cardsPlayer anEditor |	cardsPasteUp _ self pasteUpMorph.	(cardsPlayer _ cardsPasteUp assuredPlayer) assureUniClass.	anEditor _ scriptSelector			ifNil:				[scriptSelector _ cardsPasteUp scriptSelectorToTriggerFor: self.				cardsPlayer newScriptEditorFor: scriptSelector usingPhraseTile: nil]			ifNotNil:				[(cardsPlayer class selectors includes: scriptSelector)					ifTrue:						[cardsPlayer scriptEditorFor: scriptSelector]					ifFalse:						["Method somehow got removed; I guess we start aftresh"						scriptSelector _ nil.						^ self editButtonsScript]].	self currentHand attachMorph: anEditor.! !!ScriptableButton methodsFor: 'script' stamp: 'sw 10/10/2000 08:09'!wantsScriptorHaloHandle	"Answer whether the receiver would like to have a Scriptor halo handle put up on its behalf.  Initially, only the ScriptableButton says yes"	^ true! !!ScriptableButton methodsFor: 'miscellaneous' stamp: 'sw 10/30/2000 16:07'!demandsThumbnailing	"Answer whether the receiver, if in a thumbnailable parts bin, wants to be thumbnailed whether or not size requires it.  This is set to true here because the recent event rework somehow made it possible for a scriptable button to be draggable from a parts bin otherwise, maddeningly"	^ true! !!ScriptableButton methodsFor: 'action' stamp: 'sw 10/9/2000 06:28'!doButtonAction	"The user has pressed the button.  Dispatch to the actual user script, if any."	scriptSelector ifNil: [^ super doButtonAction].	self pasteUpMorph player perform: scriptSelector! !!ScriptableButton class methodsFor: 'viewer' stamp: 'sw 10/24/2000 07:59'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((button (			(slot label 'The wording on the button' string readWrite player getLabel player setLabel:)			(slot color 'The color of the object' color readWrite player getColor  player  setColor:)			(slot height  'The height' number readWrite player getHeight  player  setHeight:) 			(slot borderColor 'The color of the object''s border' color readWrite player getBorderColor player  setBorderColor:)			(slot borderWidth 'The width of the object''s border' number readWrite player getBorderWidth player setBorderWidth:)			(slot  height  'The height' number readWrite player getHeight  player  setHeight:)			(slot roundedCorners 'Whether corners should be rounded' boolean readWrite player getRoundedCorners player setRoundedCorners:) 			(slot actWhen 'When the script should fire' buttonPhase  readWrite player getActWhen player setActWhen: ))))! !!ScriptableButton class methodsFor: 'name' stamp: 'sw 10/30/2000 10:29'!defaultNameStemForInstances	"Answer the default name stem to use for instances of the receiver"	^ 'button'! !!ScriptableButton class methodsFor: 'authoring prototype' stamp: 'sw 10/30/2000 16:06'!authoringPrototype	"Answer a scriptable button that can serve as a prototype for a parts bin"	^ super authoringPrototype		borderWidth: 1;		borderColor: Color black;		useRoundedCorners;		color: Color yellow;		label: 'Press me';		setNameTo: 'script1';		yourself"ScriptableButton authoringPrototype openInHand"! !!UserScript methodsFor: 'script editor' stamp: 'sw 10/26/2000 08:40'!instantiatedScriptEditor	"return the current script editor, creating it if necessary"	self isAnonymous ifTrue:		[currentScriptEditor _ ScriptEditorMorph new playerScripted: player].	self isTextuallyCoded ifTrue:			[^ (player costume pasteUpMorph ifNil: [player costume "the world, backstop"]) scriptorForTextualScript: selector ofPlayer: player].	currentScriptEditor ifNil:		[currentScriptEditor _ (player class includesSelector: selector) 			ifTrue: [ScriptEditorMorph new 				fromExistingMethod: selector 				forPlayer: player]			ifFalse: [ScriptEditorMorph new				setMorph: player costume				scriptName: selector].		status == #ticking ifTrue: [player costume arrangeToStartStepping]].		^ currentScriptEditor! !!UserScript methodsFor: 'versions' stamp: 'sw 10/10/2000 11:04'!revertScriptVersionFrom: anEditor	"Let user choose which prior tile version to revert to, and revert to it"	| aMenu result |	formerScriptEditors isEmptyOrNil ifTrue: [^ self beep].	formerScriptEditors size == 1		ifTrue:			[result _ formerScriptEditors first]		ifFalse:			[aMenu _ SelectionMenu labelList: (formerScriptEditors collect: [:e | e timeStamp])				selections: formerScriptEditors.			result _ aMenu startUp].	result ifNotNil:		[self revertScriptVersionFrom: anEditor installing: result]! !!UserScript methodsFor: 'versions' stamp: 'sw 10/30/2000 08:54'!revertScriptVersionFrom: anEditor installing: aSavedEditor	"Replace anEditor with a brought-up-to-date version of aSavedEditor"	| aPosition oldOwner |	aPosition _ anEditor position.	oldOwner _ anEditor topRendererOrSelf owner.	anEditor delete.	currentScriptEditor _ aSavedEditor bringUpToDate install.	player costume viewAfreshIn: oldOwner showingScript: selector at: aPosition! !!UserScript methodsFor: 'versions' stamp: 'sw 10/10/2000 11:07'!revertToLastSavedTileVersionFor: anEditor	"revert to the last saved tile version"	formerScriptEditors isEmptyOrNil ifFalse:		[self revertScriptVersionFrom: anEditor installing: formerScriptEditors last]! !!UserScript methodsFor: 'versions' stamp: 'sw 10/30/2000 08:54'!savedTileVersionsCount	"Answer the number of saved tile versions of the script"	^ formerScriptEditors ifNil: [0] ifNotNil: [formerScriptEditors size]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 10/6/2000 22:47'!wellFormedInstanceVariableNameFrom: aString	"Answer a legal instance variable name, derived from aString"	| cleansedString |	cleansedString _ aString select: [:ch | ch isDigit or: [ch isLetter]].	(cleansedString size == 0 or: [cleansedString first isDigit])		ifTrue: [cleansedString _ 'a', cleansedString]		ifFalse:	[cleansedString _ cleansedString withFirstCharacterDownshifted].	[self isLegalInstVarName: cleansedString] whileFalse:		[cleansedString _ cleansedString, 'x'].	^ cleansedString"Utilities wellFormedInstanceVariableNameFrom:  '234 xx\ Uml /ler42342380-4'"! !!Utilities class methodsFor: 'flaps' stamp: 'sw 10/27/2000 10:54'!addStackToolsFlap	"Add a flap with stack tools in it"	| aFlap aFlapTab aTextMorph aSketch  aMorph |	"Utilities reinstateDefaultFlaps. Utilities addStackToolsFlap"	aFlap _ self newPartsFlapPage beSticky.	aFlap setProperty: #maximumThumbnailWidth toValue: 80.	aFlap setProperty: #flap toValue: true.	aFlap color: (Color green muchLighter lighter alpha: 0.3).	aFlapTab _ FlapTab new referent: aFlap.	aFlapTab assumeString: 'Stack Tools' font: Preferences standardFlapFont orientation: #horizontal color: Color brown lighter lighter.	aFlapTab edgeToAdhereTo: #bottom; inboard: false.	aFlapTab setToPopOutOnDragOver: false.	aFlapTab setToPopOutOnMouseOver: false.	aFlap addMorphBack: StackMorph authoringPrototype.	aTextMorph _ TextMorph authoringPrototype.	aTextMorph contents: 'backgroundlabel' asText.  	aTextMorph beAllFont: (StrikeFont familyName: #NewYork size: 18).	aTextMorph color: Color brown.	aTextMorph setProperty: #shared toValue: true.	aFlap addMorphBack: aTextMorph.	"Ted's fields, maybe good point of departure...	aTextMorph _ TextFieldMorph authoringPrototype.	aTextMorph setProperty: #shared toValue: true.	aFlap addMorphBack: aTextMorph."	aFlap addMorphBack: ScriptableButton authoringPrototype markAsPartsDonor beSticky.	"NB: Here is where we will put the prototype(s) for background/foreground fields; for the moment, vanilla TextMorphs are used, with the scrolling PTMWM temporarily commented out pending some more work.  A successor to Ted's TextFieldMorph, or some new kind of carefully-thought-through morph that will generally serve the community as the archetypal 'Field', is ultimately needed"	#(TextMorph "PluggableTextMorphWithModel") do:		[:sym |			aMorph _ (Smalltalk at: sym) authoringPrototype.			aMorph contents: 'background field' asText allBold.			aMorph setProperty: #shared toValue: true.			aMorph setNameTo: (sym == #TextMorph ifTrue: ['field1'] ifFalse: ['scrollingField1']).			aMorph setProperty: #holdsSeparateDataForEachInstance toValue: true.			aFlap addMorphBack: aMorph].	"aFlap addMorphBack: ScriptableListMorph authoringPrototype beSticky -- SOON!!"		#(CedarPic) do:		[:sym | 			aSketch _ SketchMorph newSticky form: (ScriptingSystem formAtKey: sym).			aSketch setProperty: #shared toValue: true.			aSketch setProperty: #holdsSeparateDataForEachInstance toValue: true.			aFlap addMorphBack: aSketch].	"aCardReference _ CardReference authoringProtoype beSticky.	aCardReference card: Card new.  "	aFlap addMorphBack: StackMorph previousCardButton markAsPartsDonor.	aFlap addMorphBack: StackMorph nextCardButton markAsPartsDonor.	#( PaintInvokingMorph "ImageMorph  RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph SimpleSliderMorph") do:		[:sym | aFlap addMorphBack: (Smalltalk at: sym) authoringPrototype].	aFlap addMorphBack: TrashCanMorph new markAsPartsDonor.	aFlap addMorphBack: ScriptingSystem scriptControlButtons markAsPartsDonor.	aFlap replaceTallSubmorphsByThumbnails.	aFlap fixLayout.	aFlapTab position: ((2 * (self currentWorld width // 3)) @ (self currentWorld height - aFlapTab height)).	aFlap setProperty: #flap toValue: true.	aFlap color: (Color red muchLighter "alpha: 0.2").	aFlap extent: self currentWorld width @ 100.		self currentWorld addMorphFront: aFlapTab.  	"a local flap, but we could as easily make it global by:		self addGlobalFlap: aFlapTab.  self currentWorld addGlobalFlaps"! !!Utilities class methodsFor: 'flaps' stamp: 'sw 10/30/2000 18:08'!standardBottomFlap	"Answer a fully-instantiated flap named 'Supplies' to be placed at the bottom of the screen"	|  aFlapTab aPage |	aPage _ self newPartsFlapPage.	aPage setProperty: #maximumThumbnailWidth toValue: 80.	aFlapTab _ FlapTab new referent: aPage beSticky.	aFlapTab color: Color red lighter.	aFlapTab setToPopOutOnDragOver: true.	aFlapTab setToPopOutOnMouseOver: true.	aFlapTab assumeString: 'Supplies' font: Preferences standardFlapFont orientation: #horizontal color: Color red lighter.	aFlapTab edgeToAdhereTo: #bottom; inboard: false.	aPage extent: self currentWorld width @ 100.	aPage addMorphBack: Command undoRedoButtons markAsPartsDonor.	aPage addMorphBack: TrashCanMorph new markAsPartsDonor.	aPage addMorphBack: ScriptingSystem scriptControlButtons markAsPartsDonor.	#(PaintInvokingMorph RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ) do:		[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].	aPage addMorphBack: ScriptingSystem prototypicalHolder.	aPage addMorphBack: RectangleMorph roundRectPrototype.	#(ImageMorph ScriptableButton SimpleSliderMorph		PasteUpMorph   BookMorph TabbedPalette 		JoystickMorph  ) do:		[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].	aPage addMorphBack: Morph new previousPageButton markAsPartsDonor.	aPage addMorphBack: Morph new nextPageButton markAsPartsDonor.	aPage addMorphBack: ScriptingSystem holderWithAlphabet markAsPartsDonor.	aPage addMorphBack: (ClockMorph authoringPrototype showSeconds: false) step.	aPage replaceTallSubmorphsByThumbnails.	aPage fixLayout.	aFlapTab position: ((Display width - aFlapTab width) // 2 @ (self currentWorld height - aFlapTab height)).	aPage beFlap: true.	aPage color: (Color red muchLighter "alpha: 0.2").	aPage extent: self currentWorld width @ 100.		^ aFlapTab! !!VariableDock methodsFor: 'initialization' stamp: 'sw 10/26/2000 13:33'!dockMorphUpToInstance: anInstance	"Dock my defining morph up to the given player instance.  NB: The odious #cardInstance mechanism used here was a last-minute stopgap for some demo, which surely should not be allowed to survive."	definingMorph setProperty: #cardInstance toValue: anInstance.	definingMorph perform: morphPutSelector with: (anInstance perform: playerGetSelector)! !!VariableDock methodsFor: 'initialization' stamp: 'sw 10/30/2000 08:52'!storeMorphDataInInstance: anInstance	"Store the morph instance data represented by the receiver into the card instance provided.  This is done by retrieving the datum value from the morph that holds it on the card, and putting it into the card instance"	anInstance perform: playerPutSelector with: (definingMorph perform: morphGetSelector)! !!VariableDock methodsFor: 'initialization' stamp: 'sw 10/30/2000 08:52'!variableName: aSymbol type: aType definingMorph: aMorph morphGetSelector: getterSymbol morphPutSelector: putterSymbol	"Initialize the receiver as indicated"	variableName _ aSymbol asSymbol.	type _ aType.	definingMorph _ aMorph.	morphGetSelector _ getterSymbol.	morphPutSelector _ putterSymbol.	self computePlayerGetterAndSetterSelectors! !!VariableDock methodsFor: 'getters and setters' stamp: 'sw 10/30/2000 10:55'!computePlayerGetterAndSetterSelectors	"Compute and remember the getter and setter selectors for obtaining and setting values from the player instance"	playerGetSelector _ Utilities getterSelectorFor: variableName.	playerPutSelector _ Utilities setterSelectorFor: variableName! !!VariableDock methodsFor: 'name' stamp: 'sw 10/30/2000 08:52'!variableName	"Answer the variable name represented by the receiver"	^ variableName! !!VariableDock methodsFor: 'name' stamp: 'sw 10/30/2000 08:51'!variableName: aSymbol	"Set the receiver's variableName as indicated, and recompute corresponding getters and setters"	variableName _ aSymbol asSymbol.	self computePlayerGetterAndSetterSelectors! !!VariableDock methodsFor: 'type and default value' stamp: 'sw 10/30/2000 08:52'!defaultValue: aValue	"Set the receiver's default value as indicated"	defaultValue _ aValue! !!VariableDock methodsFor: 'type and default value' stamp: 'sw 10/29/2000 17:40'!variableType	"Answer the data type of the receiver"	^ type! !!VariableDock methodsFor: 'printing' stamp: 'sw 10/30/2000 08:50'!printOn: aStream	"Print a description of the receiver onto the given stream"	super printOn: aStream.	variableName ifNotNil: [aStream nextPutAll: (' (var name = ', variableName, ')')].	type ifNotNil: [aStream nextPutAll: (' (type = ', type, ')')]! !!Viewer methodsFor: 'as yet unclassified' stamp: 'sw 10/30/2000 17:03'!filteringScheme	"The filteringScheme dictates how the viewer will obtain the subparts to show.  In the first implementation, we used the following choices:		minimal		specially-designated methods in root class + everything defined in uniclass		standard	a canonical point of departure		most		everything up to but not including Object		custom		everything up to but not including some limit class designated by user		myOwn		exactly the methods of defined in my own class (like existing Smalltalk browsers)		all			everything from root class right up to Object"	"Later we may want individual category viewers to have their own choice here, but for now we have a single control for the entire outer viewer??"	| determiner |	(determiner _ self ownerThatIsA: StandardViewer) ifNil: [^ #standard].	^ determiner filteringScheme! !!Viewer methodsFor: 'as yet unclassified' stamp: 'sw 10/25/2000 08:30'!objectViewed	"Answer the graphical object to which the receiver's phrases apply"	^ (scriptedPlayer isKindOf: Player)		ifTrue:			[scriptedPlayer costume]		ifFalse:			[scriptedPlayer]! !!Viewer methodsFor: 'as yet unclassified' stamp: 'sw 10/6/2000 22:41'!retargetFrom: oldPlayer to: newPlayer	"Retarget the receiver so that instead of viewing oldPlayer, it now views newPlayer, which are expected to be different instances of the same uniclass"	scriptedPlayer == oldPlayer		ifTrue:			[self allMorphs do:  "nightmarishly special-cased, sorry"				[:aMorph | 					(aMorph isKindOf: Viewer) ifTrue:  "includes self"						[aMorph scriptedPlayer: newPlayer].					((aMorph isKindOf: UpdatingStringMorph) and: [aMorph target == oldPlayer]) ifTrue:						[aMorph target: newPlayer].					(aMorph isKindOf: TileMorph) ifTrue:						[aMorph retargetFrom: oldPlayer to: newPlayer]]]! !!Viewer methodsFor: 'queries' stamp: 'sw 10/27/2000 13:20'!aboutMethod: aSelector	"Give the user documentation for the selector"	| aClass help |	aClass _ scriptedPlayer class classThatUnderstands: aSelector.	help _ aClass firstCommentAt: aSelector.	help ifNotNil:		[self inform: (help string withNoLineLongerThan: 25)]! !!Viewer methodsFor: 'queries' stamp: 'sw 10/27/2000 11:32'!browseImplementorsOf: aSelector	"Open a browser on implementors of aSelector"	Smalltalk browseAllImplementorsOf: aSelector! !!Viewer methodsFor: 'queries' stamp: 'sw 10/30/2000 17:00'!browseMethodFull: aSelector	"Open a traditional browser on aSelector, in whatever class implements aSelector"	| aClass |	aClass _ scriptedPlayer class classThatUnderstands: aSelector.	Browser fullOnClass: aClass selector: aSelector! !!Viewer methodsFor: 'queries' stamp: 'sw 10/27/2000 11:38'!browseMethodInheritance: aSelector	"Open an inheritance browser on aSelector"	| aClass |	aClass _ scriptedPlayer class classThatUnderstands: aSelector.	Utilities methodHierarchyBrowserForClass: aClass selector: aSelector! !!Viewer methodsFor: 'queries' stamp: 'sw 10/27/2000 11:33'!browseSendersOf: aSelector	"Open a browser on senders of aSelector"	Smalltalk browseAllCallsOn: aSelector! !!Viewer methodsFor: 'queries' stamp: 'sw 10/30/2000 17:00'!browseVersionsOf: aSelector	"Open a browser on versions of aSelector"	| aClass |	aClass _ scriptedPlayer class classThatUnderstands: aSelector.	Utilities browseVersionsForClass: aClass selector: aSelector! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/5/2000 10:03'!chooseCategory	"The mouse went down on the receiver; pop up a list of category choices"	| aList aMenu reply aLinePosition lineList |	aList _ scriptedPlayer categoriesForViewer: self.	aLinePosition _ aList indexOf: #miscellaneous ifAbsent: [nil].	lineList _ aLinePosition ifNil: [#()] ifNotNil: [Array with: aLinePosition].	aMenu _ CustomMenu labels: aList lines: lineList selections: aList.	reply _ aMenu startUpWithCaption: 'category'.	reply ifNil: [^ self].	self categoryChoice: reply asSymbol! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 10/9/2000 16:54'!infoButtonFor: aScriptOrSlotSymbol	"Answer a fully-formed morph that will serve as the 'info button' alongside an entry corresponding to the given slot or script symbol"	| aButton balloonTextSelector |	balloonTextSelector _ nil.	((scriptedPlayer isKindOf: Player) and: [scriptedPlayer slotInfo includesKey: aScriptOrSlotSymbol asSymbol])		ifTrue: [balloonTextSelector _ #userSlot].	(scriptedPlayer belongsToUniClass and:			[scriptedPlayer class includesSelector: aScriptOrSlotSymbol])		ifTrue: [balloonTextSelector _ #userScript].	aButton _ SimpleButtonMorph new.	aButton target: scriptedPlayer;		actionSelector: #infoFor:inViewer:;		arguments: (Array with: aScriptOrSlotSymbol with: self);		label: '¥' font: (StrikeFont familyName: #ComicBold size: 12);		color: Color transparent;		borderWidth: 0;		actWhen: #buttonDown.	balloonTextSelector		ifNotNil:	[aButton balloonTextSelector: balloonTextSelector]		ifNil:		[aButton setBalloonText: 'Press here to get a menu'].	^ aButton! !!StandardViewer methodsFor: 'categories' stamp: 'sw 10/30/2000 09:05'!filteringScheme	"Answer the filtering scheme to be used in the receiver.  This architecture, rather fully prototyped earlier, is not yet really incorporated in the current corpus of released code, but will kick in later hopefully"	| schemeToUse what |	schemeToUse _		self valueOfProperty: #filteringScheme ifAbsent: 			[what _ Preferences defaultUserLevel == 1				ifTrue:	[#minimal]				ifFalse:	[#most].			self setProperty: #filteringScheme toValue: what.			what].	^ schemeToUse! !!StandardViewer methodsFor: 'categories' stamp: 'sw 10/5/2000 09:27'!likelyCategoryToShow	"Choose a category to show based on what's already showing and on some predefined heuristics"	| possible |	possible _ (scriptedPlayer categoriesForViewer: self) asOrderedCollection.	self categoryMorphs do:		[:m | possible remove: m currentCategory ifAbsent: []].	((possible includes: #'instance variables') and: [scriptedPlayer hasUserDefinedSlots])		ifTrue:	[^ #'instance variables'].	((possible includes: #scripts) and: [scriptedPlayer hasUserDefinedScripts])		ifTrue:	[^ #'scripts'].	#(basic #'color & border') do:		[:preferred | (possible includes: preferred) ifTrue: [^ preferred]].	^ possible size > 0		ifTrue:			[possible first]		ifFalse:			[#basic]! !!StandardViewer methodsFor: 'initialization' stamp: 'sw 10/30/2000 16:50'!addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean	"Add the header morph to the receiver, using anInteger as a guide for its height, and if aBoolean is true, include a dismiss buton for it"	| header aFont aButton aTextMorph nail wrpr costs headWrapper inner |	header _ AlignmentMorph newRow color: self color muchLighter; centering: #center.	aFont _ Preferences standardButtonFont.	aBoolean ifTrue:		[header addMorph: (aButton _ SimpleButtonMorph new label: 'O' font: aFont).		aButton target: self;				color:  Color tan;				actionSelector: #dismiss;				setBalloonText: 'remove this entire Viewer from the screendon''t worry -- nothing will be lost!!.'.		header addTransparentSpacerOfSize: 4@1].	aButton _ IconicButton new borderWidth: 0;			labelGraphic: (ScriptingSystem formAtKey: #AddCategoryViewer); color: Color transparent; 			actWhen: #buttonDown;			target: self;			actionSelector: #addCategoryViewer;			setBalloonText: 'click here to addanother category pane';			shedSelvedge.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 4@1.	costs _ scriptedPlayer costumes.	costs ifNotNil:	[(costs size > 1 or: [costs size = 1 and: [costs first ~~ scriptedPlayer costume]]) ifTrue:		[header addUpDownArrowsFor: self.		(wrpr _ header submorphs last) submorphs second setBalloonText: 'switch to previous costume'.			wrpr submorphs first  setBalloonText: 'switch to next costume']].		(self hasProperty: #noInteriorThumbnail)		ifFalse:			[nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume]		ifTrue:			[inner _ ImageMorph new image: (ScriptingSystem formAtKey: 'Menu').			nail _ RectangleMorph new beTransparent extent: inner extent.			nail addMorph: inner lock].	nail on: #mouseDown send: #offerViewerMenuForEvt:morph: to: scriptedPlayer.	header addMorphBack: nail.	nail setBalloonText: 'click here to get a menuthat will allow you toadd an instance variable,,tear off a tile, etc..'.	(self hasProperty: #noInteriorThumbnail)		ifFalse:			[nail borderWidth: 3; borderColor: #raised].	header addTransparentSpacerOfSize: 5@5."	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'S' font: (aFont _ StrikeFont familyName: #ComicBold size: 16);  color: Color transparent; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		header addMorphBack: aButton.	header addTransparentSpacerOfSize: 8@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'I' font: aFont;  color: Color transparent; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 5@5."	self viewsMorph ifTrue: [scriptedPlayer costume assureExternalName].	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #nameForViewer;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	self viewsMorph ifTrue:		[aTextMorph putSelector: #setName:.		aTextMorph setProperty: #okToTextEdit toValue: true].	aTextMorph step.	header  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s name.'.		header beSticky.	anInteger > 0		ifTrue:			[headWrapper _ AlignmentMorph newColumn color: self color.			headWrapper addTransparentSpacerOfSize: (0 @ anInteger).			headWrapper addMorphBack: header.			self addMorph: headWrapper]		ifFalse:			[self addMorph: header]! !!StandardViewer methodsFor: 'initialization' stamp: 'sw 10/25/2000 23:30'!affordsUniclass	"Answer true iff the receiver operates on behalf of an object that is, or could become, a member of a Uniclass"	| viewee |	^ (viewee _ self objectViewed) belongsToUniClass or: 			[((viewee isKindOf: Integer) not and: 				[(viewee isKindOf: Behavior) not]) and:					[self userLevel > 0]]! !!StandardViewer methodsFor: 'initialization' stamp: 'sw 10/26/2000 09:42'!userLevel	"Answer the user level for this viewer, which can be used in figuring out what to display in the viewer.  Initially, we make little use of this, but in past prototypes, and in future deployments, it may be handy."	^ self valueOfProperty: #userLevel ifAbsent: [1]! !!StandardViewer methodsFor: 'initialization' stamp: 'sw 10/30/2000 09:06'!viewsMorph	"Answer whether the receiver views a morph.  Traditional viewers up until late 2000 *all* viewed morphs (as per the morph/player architecture), but viewers on non-morph/players have now become possible"	^ scriptedPlayer isMorph! !TilePadMorph class removeSelector: #brightColorFor:!TilePadMorph class removeSelector: #brightColorForType:!TilePadMorph class removeSelector: #colorForType:!TilePadMorph class removeSelector: #initialize!TilePadMorph class removeSelector: #unbrightColorFor:!TileMorph removeSelector: #beAnObjectReferenceTo:!TextMorph removeSelector: #cornerStyle!TextMorph removeSelector: #requestedVariableDefinitions!TextFieldMorph removeSelector: #requestedVariableDefinitions!SystemDictionary removeSelector: #doOnlyOnce:!SystemDictionary removeSelector: #rearmOneShot!StandardScriptingSystem removeSelector: #classRepresentativesExample!SlotInformation removeSelector: #variableDefinition:!SketchMorph removeSelector: #requestedVariableDefinitions!SimpleButtonMorph class removeSelector: #additionsToViewerCategories!ScriptInstantiation removeSelector: #anonymous:!ScriptInstantiation removeSelector: #initializeAnonymousScriptFor:!ScriptInstantiation removeSelector: #initializePermanentScriptFor:!ReferenceMorph removeSelector: #changeLabelFont!ReferenceMorph removeSelector: #invalidateBeckoningFeedback!Preferences class removeSelector: #newReferenceScheme!PluggableTextMorphWithModel removeSelector: #externalName!PluggableTextMorphWithModel removeSelector: #requestedVariableDefinitions!!PluggableTextMorphWithModel reorganize!('initialization' initialize)('contents' getMyText newTextContents: setMyText:)('deletion' delete)('name')('data dockup' couldHoldSeparateDataForEachInstance currentDataValue variableDocks)!CardPlayer class removeSelector: #backgroundMorph!CardPlayer class removeSelector: #backgroundMorph:!CardPlayer class removeSelector: #convertsmfiosncsecssvb0:smfiosncsecssv0:!CardPlayer class removeSelector: #invalidateVariableDefinitions!CardPlayer class removeSelector: #invalidateVariableDocks!CardPlayer class removeSelector: #privateScripts!CardPlayer class removeSelector: #privateScripts:!CardPlayer class removeSelector: #scripts:!CardPlayer class removeSelector: #setSlotInfoFromVariableDefinitions!CardPlayer class removeSelector: #variableDefinitions!CardPlayer class removeSelector: #variableDefinitions:!!CardPlayer class reorganize!('class properties' isUniClass officialClass)('user-defined inst vars' compileAccessorsFor: removeAccessorsFor: setNewInstVarNames:)('logging' acceptsLoggingOfCompilation wantsChangeSetLogging)('variable docks' newVariableDocks: setSlotInfoFromVariableDocks variableDocks variableDocks:)!Player class removeSelector: #anonymousUserScriptFor:player:!Player removeSelector: #addSlotNamedLike:withValue:!Player removeSelector: #anonymousScriptEditorFor:!Player removeSelector: #createNewCard!Player removeSelector: #firstCard!Player removeSelector: #getGetListSelector:!Player removeSelector: #getListSelector!Player removeSelector: #getListSelector:!Player removeSelector: #getViewingNormally!Player removeSelector: #goToFirstCardInStack!Player removeSelector: #goToNextCard!Player removeSelector: #goToPreviousCard!Player removeSelector: #lastCard!Player removeSelector: #newCard!Player removeSelector: #nextCard!Player removeSelector: #offerViewerMenuForEvt:morph:!Player removeSelector: #permanentScriptEditorFor:!Player removeSelector: #previousCard!Player removeSelector: #setListSelector:!Player removeSelector: #setViewingNormally:!Player removeSelector: #thumbnailMenuEvt:forMorph:!Player removeSelector: #tilePhrasesForCategory:inViewer:!PasteUpMorph removeSelector: #becomeStack!PasteUpMorph removeSelector: #behaveLikeAHolderStrilng!PasteUpMorph removeSelector: #goToNextCard!PasteUpMorph removeSelector: #goToPreviousCard!PasteUpMorph removeSelector: #ibbleacceptDroppingMorph:event:!PasteUpMorph removeSelector: #isStackLike!PasteUpMorph removeSelector: #morphsForInstanceData!PasteUpMorph removeSelector: #restorePasteUpView!PasteUpMorph removeSelector: #restoreSavedBounds!PasteUpMorph removeSelector: #scriptPerformer!PasteUpMorph removeSelector: #toggleBehaveLikeHolder!PasteUpMorph removeSelector: #toggleRebehaveLikeHolder!PasteUpMorph removeSelector: #viewingByIcon!!PasteUpMorph reorganize!('initialization' initialize newPlayerInstance releaseCachedState)('classification' isFlap isWorldMorph world)('cursor' cursor cursor: cursorWrapped: numberAtCursor rectifyCursor selectedRect valueAtCursor valueAtCursor:)('display' canHaveFillStyles color: drawOn: drawSubmorphsOn: gradientFillColor: printOn: pseudoDraw:on: setGradientColor:)('dropping/grabbing' acceptDroppingMorph:event: automaticPhraseExpansion automaticViewing horizontallyAlignSubmorphSubparts justDroppedInto:event: morphToDropFrom: originAtCenter positionNear:forExtent:adjustmentSuggestion: repelsMorph:event: wantsDroppedMorph:event:)('layout' addCenteredAtBottom:offset: fixLayout insertionIndexFor: laySubpartsOutInOneRow layoutChanged layoutRow:lastRowBase: rowBaseFor:lastRowBase: rowMorphsStartingAt:)('menu & halo' addAddHandMenuItemsForHalo:hand: addCustomMenuItems:hand: addPenMenuItems:hand: addPenTrailsMenuItemsTo: addPlayfieldMenuItems:hand: addScalingMenuItems:hand: addStackMenuItems:hand: autoExpansionString autoLineLayoutString autoViewingString batchPenTrailsString buildDebugMenu: defersHaloOnClickTo: defineApplicationView defineFactoryView deleteBalloonTarget: fenceEnabledString indicateCursorString isOpenForDragNDropString isPartsBinString mouseOverHalosString originAtCenterString playfieldOptionsMenu presentCardAndStackMenu presentPlayfieldMenu presentViewMenu saveOnFile showApplicationView showExpandedView showFactoryView showFullView showReducedView showThumbnailString transformToShow: wantsDirectionHandles wantsHaloFor: wantsHaloFromClick)('model' createCustomModel model modelOrNil setModel:)('options' autoLineLayout autoLineLayout: automaticViewing: batchPenTrails batchPenTrails: becomeLikeAHolder behaveLikeAHolderString behaveLikeHolder behaveLikeHolder: behavingLikeAHolder fenceEnabled fenceEnabled: indicateCursor indicateCursor: isPartsBin isPartsBin: replaceTallSubmorphsByThumbnails resizeToFit resizeToFit: resizeToFitString setPartsBinStatusTo: setThumbnailHeight toggleAlwaysShowThumbnail toggleAutoLineLayout toggleAutomaticPhraseExpansion toggleAutomaticViewing toggleBatchPenTrails toggleBehaveLikeAHolder toggleFenceEnabled toggleIndicateCursor toggleIsPartsBin toggleMouseOverHalos toggleOriginAtCenter toggleResizeToFit updateSubmorphThumbnails wantsMouseOverHalos wantsMouseOverHalos:)('painting' backgroundSketch backgroundSketch: deleteBackgroundPainting makeNewDrawingWithin paintBackground paintingBoundsAround: reasonablePaintingExtent)('pen' clearTurtleTrails createOrResizeTrailsForm drawPenTrailFor:from:to: liftAllPens lowerAllPens noteNewLocation:forPlayer: notePenDown:forPlayer:at: trailMorph updateTrailsForm)('scripting' allTileScriptingElements isCandidateForAutomaticViewing scriptorForTextualScript:ofPlayer:)('stack/card' beAStackBackground currentDataInstance defaultNameStemForInstances doWrap explainDesignations insertCard installAsCurrent: isStackBackground newCard reassessBackgroundShape relaxGripOnVariableNames reshapeBackground showBackgroundObjects showDesignationsOfObjects showForegroundObjects tabHitWithEvent:)('misc' abandonCostumeHistory allScriptEditors allScriptors alwaysShowThumbnail cachedOrNewThumbnailFrom: cartesianOrigin closedViewerFlapTabs containsCard: demandsBoolean fullBounds heightForThumbnails hideViewerFlapsOtherThanFor: impartPrivatePresenter innocuousName invalidRect: isPlayfieldLike makeDetachable maxHeightToAvoidThumbnailing maximumThumbnailWidth mouseX mouseY nameForCopyIfAlreadyNamed: padding: position: prepareToBeSaved presenter replaceSubmorph:by: residesInPartsBin roundUpStrays shouldGetStepsFrom: smallThumbnailForPageSorter startRunningAll step stepAll stepTime stopRunningAll thumbnailForPageSorter unhideHiddenObjects updateStatusForAllScriptEditors viewerFlapTabFor: viewerFlapTabForObject: wantsKeyboardFocusFor:)('object fileIn' convertbosfcebbfgccpmcpbttloiairfidcuw0:bosfcebbfgccpmcpbttloiairfidcuww0: convertbosfcebbfgccpmcpbttloiairfidcuwp0:bosfcebbfgccpmcpbttloiairfidcuww0: convertbosfcebbfgccpmcpbttloiairfidcuww0:bosfcebbpmcpbttliairfidcuww0: convertbosfcebbfgccpmcpbttloiairfidcuww0:bosfcebbpmcpbttloiairfidcuww0: convertbosfcebbpmcpbttliairfidcuww0:bosfcebbpmcpbttliairfidcuwwg0: convertbosfcebbpmcpbttliairfidcuwwg0:bosfcebbpmcpbttliairwwg0: convertbosfcebbpmcpbttloiairfidcuww0:bosfcebbpmcpbttliairfidcuww0:)('flaps' accommodateFlap: addGlobalFlaps assureFlapTabsFitOnScreen bringFlapTabsToFront correspondingFlapTab deleteAllFlapArtifacts deleteGlobalFlapArtifacts flapTabs localFlapTabs offsetForAccommodating:onEdge: paintingFlapTab removeAccommodationForFlap:)('project state' activeHand canvas firstHand hands handsDo: isStepping: isStepping:selector: listOfSteppingMorphs modelWakeUp stepListSize stepListSummary steppingMorphsNotInWorld viewBox viewBox:)('update cycle' startBackgroundProcess)('stepping' cleanseStepList runLocalStepMethods runStepMethods startStepping: startStepping:at:selector:arguments:stepTime: stopStepping: stopStepping:selector:)('world state' abandonAllHalos activeHand: addAllMorphs: addHand: addMorph:centeredNear: addMorphsAndModel: allMorphsDo: allNonFlapRelatedSubmorphs assureNotPaintingElse: assuredCanvas beWorldForProject: chooseClickTarget colorAt:belowMorph: deEmphasizeViewMVC: deleteAllHalos displayWorld displayWorldAsTwoTone displayWorldNonIncrementally displayWorldSafely doOneCycle doOneCycleInBackground doOneSubCycle dragThroughOnDesktop: embeddedProjectDisplayMode exit extent: flashRects:color: fullContainsPoint: fullRepaintNeeded goBack haloMorphOrNil haloMorphs handleFatalDrawingError: initForProject: install installAsActiveSubprojectIn:at:titled: installAsActiveSubprojectIn:titled: installFlaps jumpToProject nextPage open openWithTitle:cautionOnClose: optimumExtentFromAuthor paintArea paintAreaFor: paintBox paintBoxOrNil patchAt:without:andNothingAbove: pauseEventRecorder previousPage privateMoveBy: privateOuterDisplayWorld referencePlayfield removeHand: repairEmbeddedWorlds restoreDisplay restoreFlapsDisplay saveAsWorld selectHandsToDrawForDamage: sketchEditorOrNil sleep someHalo specialNameInModelFor: standardPlayerHit standardSystemController startSteppingSubmorphsOf: triggerClosingScripts triggerOpeningScripts veryDeepCopyWith:)('accessing' beFlap:)('project' project releaseSqueakPages storeProjectsAsSegments)('interaction loop' doOneCycleNow keyStroke:)('WiW support' restartWorldCycleWithEvent: validateMouseEvent:)('private' morphicLayerNumber privateFullMoveBy:)('Nebraska' addRemoteClient: hasRemoteServer releaseRemoteServer remoteServer remoteServer: removeRemoteClient: transferRemoteServerFrom:)('gridding' gridModulus gridModulus: gridOrigin gridOrigin: gridPoint: gridSpec gridSpecPut: gridVisible gridVisibleOnOff gridVisibleString griddingOn griddingOnOff griddingString setGridSpec)('undo' clearCommandHistory commandHistory)('alarms-scheduler' addAlarm:withArguments:for:at: removeAlarm:for:)('submorphs-add/remove' addMorphInLayer:)('viewing' addViewingItemsTo: imposeListViewSortingBy:retrieving: restoreBoundsOfSubmorphs saveBoundsOfSubmorphs scriptSelectorToTriggerFor: showingListView sortAndPositionSubmorphs sortSubmorphsBy: viewByIcon viewByName viewBySize viewNonOverlapping viewingByIconString viewingByNameString viewingBySizeString viewingNonOverlappingString viewingNormally)('event handling' handlesKeyboard: handlesMouseDown: morphToGrab: mouseDown: mouseUp:)('world menu' addUndoItemsTo: buildWorldMenu: closeUnchangedWindows collapseAll collapseNonWindows connectRemoteUser connectRemoteUserWithName:picture:andIPAddress: deleteNonWindows detachableScriptingSpace disconnectAllRemoteUsers disconnectRemoteUser drawingClass expandAll findDirtyBrowsers: findDirtyWindows: findWindow: getWorldMenu: grabDrawingFromScreen: invokeWorldMenu: keystrokeInWorld: makeNewDrawing: newDrawingFromMenu: openScrapsBook: putUpDesktopMenu: reportLocalAddress yellowButtonClickOnDesktopWithEvent:)!ImageMorph removeSelector: #requestedVariableDefinitions!Morph removeSelector: #holdsDataForEachInstance!Morph removeSelector: #nextCardButton!Morph removeSelector: #previousCardButton!Morph removeSelector: #requestedVariableDefinitions!Morph removeSelector: #setDefaultValue!Morph removeSelector: #striveForWidth:!!ProtoObject reorganize!('testing' ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: isInMemory isNil pointsTo:)('comparing' == identityHash ~~)('system primitives' become: cannotInterpret: doesNotUnderstand: nextInstance nextObject)('objects from disk' rehash)('debugging' doOnlyOnce: flag: rearmOneShot)!Smalltalk removeClassNamed: #DataMorph!"Postscript:"Preferences resetHaloSpecifications.StandardScriptingSystem initialize.TilePadMorph initialize.ScriptingSystem initializeTypeColors.Preferences addPreference: #capitalizedReferences category: #scripting default:  false balloonHelp: 'if true, then object references in scripts will appear as capitalized names, a scheme which makes scripts look ''right'' but which still requires some engineering'.Morph subclass: #TilePadMorph	instanceVariableNames: 'type '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting Tiles'. "removes the disused class var here at end to avoid prompting the user during the update"!