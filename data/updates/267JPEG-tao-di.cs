'From Squeak 2.2beta of Sept 11, 1998 on 15 September 1998 at 10:26:46 am'!"Change Set:		JPEGDate:			27 October 1997Author:			Tim Olson[Updated 9/15/1998 - Dan IngallsIntegrated with FileList options.Cleaned up SketchMorph interface to ImageImports.Generally made it all compatible with Squeak 2.1, 2.2.Made httpShowGif: work in Morphic.Made FormInspectView scale its contents to fit the frame.NOTE:  All references to GIFImports have been changed to ImageImports]This change set adds a JPEG decompressor as a subclass of Kazuki Yasumatsu's ImageReadWriter class.  While it is named JPEGReadWriter, currently it can only read (decompress) JPEG images.  The code is based upon the freely-redistributable C code written by members of the Independent Joint Photographic Experts Group (IJPEG).  It should be able to handle most JPEG images.  If you find an image that it cannot handle, please let me know about it so I can fix it.  The code is not tremendously fast, but it is usable for reasonably-sized images.Even with a 16-bit color display, some high-quality images will show banding.  This is due to the system colormap used by Squeak.  For better quality display, the image should use some sort of Floyd-Steinberg dithering to minimize color error.  I have not added this to the decompressor, because it returns a full-color (32-bit) form.  The dithering should occur downstream of this, when the image is downsampled for display.In addition to the JPEG decompressor, I have modified Kazuki's ImageReadWriter base class to be able to select the appropriate decoder based upon sending a #understandsImageFormat message to itself and each of its subclasses, and detecting the first one that responds with true.  I have also modified most of the uses of 'GIF' in the system to use this mechanism so that any image file format that is understood by a subclass of ImageReadWriter can be read in, placed in the ImageImports, etc.If you already have GIFImports in your image, this fileIn will add them to a newly-created ImageImports, then remove the GIFImports key from the SystemDictionary."!Object subclass: #ImageReadWriter	instanceVariableNames: 'stream '	classVariableNames: 'ImageNotStoredSignal MagicNumberErrorSignal '	poolDictionaries: ''	category: 'Graphics-Files'!Object subclass: #JPEGColorComponent	instanceVariableNames: 'id hSampleFactor vSampleFactor dctSize qTableIndex dcTableIndex acTableIndex widthInBlocks heightInBlocks mcuWidth mcuHeight mcuBlocks currentX currentY priorDCValue '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Files'!Object subclass: #JPEGHuffmanTable	instanceVariableNames: 'bits values mincode maxcode valptr lookaheadBits lookaheadSymbol '	classVariableNames: 'BitBufferSize Lookahead '	poolDictionaries: ''	category: 'Graphics-Files'!ImageReadWriter subclass: #JPEGReadWriter	instanceVariableNames: 'width height components currentComponents qTable hACTable hDCTable bitBuffer bitsInBuffer lookahead restartInterval restartsToGo mcuWidth mcuHeight mcusPerRow mcuRowsInScan mcuMembership mcuSampleBuffer mcuImageBuffer majorVersion minorVersion dataPrecision densityUnit xDensity yDensity ss se ah al sosSeen '	classVariableNames: 'ConstBits DCTK1 DCTK2 DCTK3 DCTK4 DCTSize DCTSize2 FIXn0n298631336 FIXn0n34414 FIXn0n390180644 FIXn0n541196100 FIXn0n71414 FIXn0n765366865 FIXn0n899976223 FIXn1n175875602 FIXn1n40200 FIXn1n501321110 FIXn1n77200 FIXn1n847759065 FIXn1n961570560 FIXn2n053119869 FIXn2n562915447 FIXn3n072711026 FloatSampleOffset HuffmanTableSize JFIFMarkerParser JPEGNaturalOrder MaxSample Pass1Bits QTableScaleFactor QuantizationTableSize SampleOffset '	poolDictionaries: ''	category: 'Graphics-Files'!ImageReadWriter subclass: #PCXReadWriter	instanceVariableNames: 'version encoding colorPlanes isGrayScale width height bitsPerPixel colorPalette rowByteSize '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Files'!!EToySystem class methodsFor: 'development support' stamp: 'di 9/14/1998 10:02'!loadJanForms	"EToySystem loadJanForms"	| aReferenceStream newFormDict |	aReferenceStream _ ReferenceStream fileNamed: 'JanForms'.	newFormDict _ aReferenceStream next.	aReferenceStream close.	newFormDict associationsDo:		[:assoc | Smalltalk imageImports add: assoc]! !!FileList methodsFor: 'file list menu' stamp: 'di 9/15/1998 10:02'!importImage	"Import the given image file and store the resulting Form in the global dictionary	ImageImports, at a key consisting of the short filename up to the first period.  "	| key image |	key _ fileName sansPeriodSuffix.	image _ Form fromFileNamed: self fullName.	Smalltalk imageImports at: key put: image.! !!FileList methodsFor: 'file list menu' stamp: 'di 9/15/1998 07:44'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix = 'form') | (suffix = '*') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports').		selectors addAll: #(openImageInWindow importImage)].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges putUpdate)].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	^ Array with: labels with: lines with: selectors! !!FileList methodsFor: 'file list menu' stamp: 'di 9/15/1998 10:03'!openImageInWindow	"Handle four file formats: GIF, JPG, Form stoteOn: (run coded), and BMP.	Fail if file format is not recognized."	| image |	image _ Form fromFileNamed: self fullName.	World		ifNil: [FormView open: image named: fileName]		ifNotNil: [World addMorph: (SketchMorph new form: image)].! !!Form class methodsFor: 'instance creation' stamp: 'di 9/15/1998 09:47'!fromFileNamed: fileName	"Read a Form or ColorForm from given file in any of four formats."	| file fileCode |	file _ (FileStream readOnlyFileNamed: fileName) binary.	fileCode _ file next.	fileCode = 1 ifTrue:		["Old Squeakform format"		^ self new readFromOldFormat: file].	fileCode = 2 ifTrue:		["New Squeak form format"		^ self new readFrom: file].	fileCode = $B asciiValue ifTrue:		[file skip: - 1.		^ self fromBMPFile: file].	file close.	"Try for JPG, GIF, or PCX..."	^ Smalltalk imageReaderClass formFromFileNamed: fileName! !!HTTPSocket class methodsFor: 'examples' stamp: 'tao 10/26/97 23:21'!httpJpeg: url	"Fetch the given URL, parse it using the JPEG reader, and return the resulting Form."	| doc ggg |	doc _ self httpGet: url.	doc binary; reset.	(ggg _ Smalltalk jpegReaderClass new) setStream: doc.	^ ggg nextImage.! !!HTTPSocket class methodsFor: 'examples' stamp: 'di 9/15/1998 08:22'!httpShowGif: url	"Display the picture retrieved from the given URL, which is assumed to be a GIF file. See examples in httpGif:."	| nameTokens image |	nameTokens _ url findTokens: '/'.	image _ self httpGif: url.	World ifNil: [FormView open: image named: nameTokens last]		ifNotNil: [World addMorph: (SketchMorph new form: image)]! !!HTTPSocket class methodsFor: 'examples' stamp: 'tao 10/26/97 23:21'!httpShowJpeg: url	"Display the picture retrieved from the given URL, which is assumed to be a JPEG file. See examples in httpGif:."	| nameTokens |	nameTokens _ url findTokens: '/'.	FormView open: (self httpJpeg: url) named: nameTokens last.! !!ImageReadWriter commentStamp: '<historical>' prior: 0!Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.I am an abstract class to provide for encoding and/or decoding an image ona stream.Instance Variables:	stream		<ReadStream | WriteStream>	stream for imagestoragesClass Variables:	ImageNotStoredSignal		<Signal>	image not storederror signal	MagicNumberErrorSignal		<Signal>	magic number errorsignalSubclasses must implement the following messages:	accessing		nextImage		nextPutImage:	testing		canUnderstand         (added tao 10/26/97)!!ImageReadWriter methodsFor: 'accessing'!nextImage	"Dencoding an image on stream and answer the image."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'accessing'!nextPutImage: anImage	"Encoding anImage on stream."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'stream access'!atEnd	^stream atEnd! !!ImageReadWriter methodsFor: 'stream access'!close	"close if you can"	(stream respondsTo: #close) ifTrue: [			stream closed ifFalse: [stream close]]! !!ImageReadWriter methodsFor: 'stream access'!contents	^stream contents! !!ImageReadWriter methodsFor: 'stream access'!cr	^stream nextPut: Character cr asInteger! !!ImageReadWriter methodsFor: 'stream access'!lf	"PPM and PBM are used LF as CR."	^stream nextPut: Character lf asInteger! !!ImageReadWriter methodsFor: 'stream access'!next	^stream next! !!ImageReadWriter methodsFor: 'stream access'!next: size	^stream next: size! !!ImageReadWriter methodsFor: 'stream access'!nextLong	"Read a 32-bit quantity from the input stream."	^(stream next bitShift: 24) + (stream next bitShift: 16) +		(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextLongPut: a32BitW	"Write out a 32-bit integer as 32 bits."	stream nextPut: ((a32BitW bitShift: -24) bitAnd: 16rFF).	stream nextPut: ((a32BitW bitShift: -16) bitAnd: 16rFF).	stream nextPut: ((a32BitW bitShift: -8) bitAnd: 16rFF).	stream nextPut: (a32BitW bitAnd: 16rFF).	^a32BitW! !!ImageReadWriter methodsFor: 'stream access'!nextPut: aByte	^stream nextPut: aByte! !!ImageReadWriter methodsFor: 'stream access'!nextPutAll: aByteArray	^stream nextPutAll: aByteArray! !!ImageReadWriter methodsFor: 'stream access'!nextWord	"Read a 16-bit quantity from the input stream."	^(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextWordPut: a16BitW	"Write out a 16-bit integer as 16 bits."	stream nextPut: ((a16BitW bitShift: -8) bitAnd: 16rFF).	stream nextPut: (a16BitW bitAnd: 16rFF).	^a16BitW! !!ImageReadWriter methodsFor: 'stream access' stamp: 'tao 10/23/97 18:00'!peekFor: aValue	^stream peekFor: aValue! !!ImageReadWriter methodsFor: 'stream access'!position	^stream position! !!ImageReadWriter methodsFor: 'stream access'!position: anInteger	^stream position: anInteger! !!ImageReadWriter methodsFor: 'stream access'!size	^stream size! !!ImageReadWriter methodsFor: 'stream access'!skip: anInteger	^stream skip: anInteger! !!ImageReadWriter methodsFor: 'stream access'!space	^stream nextPut: Character space asInteger! !!ImageReadWriter methodsFor: 'stream access'!tab	^stream nextPut: Character tab asInteger! !!ImageReadWriter methodsFor: 'private'!changePadOfBits: bits width: width height: height depth: depth from: oldPadto: newPad	"Change padding size of bits."	| srcRowByteSize dstRowByteSize newBits srcRowBase rowEndOffset |	(#(8 16 32) includes: oldPad)		ifFalse: [^self error: 'Invalid pad: ', oldPad printString].	(#(8 16 32) includes: newPad)		ifFalse: [^self error: 'Invalid pad: ', newPad printString].	srcRowByteSize _ width * depth + oldPad - 1 // oldPad * (oldPad / 8).	srcRowByteSize * height = bits size		ifFalse: [^self error: 'Incorrect bitmap array size.'].	dstRowByteSize _ width * depth + newPad - 1 // newPad * (newPad / 8).	newBits _ ByteArray new: dstRowByteSize * height.	srcRowBase _ 1.	rowEndOffset _ dstRowByteSize - 1.	1 to: newBits size by: dstRowByteSize do:		[:dstRowBase |		newBits replaceFrom: dstRowBase			to: dstRowBase + rowEndOffset			with: bits			startingAt: srcRowBase.		srcRowBase _ srcRowBase + srcRowByteSize].	^newBits! !!ImageReadWriter methodsFor: 'private'!hasMagicNumber: aByteArray	| position |	position _ stream position.	((stream size - position) >= aByteArray size and:	[(stream next: aByteArray size)  = aByteArray])		ifTrue: [^true].	stream position: position.	^false! !!ImageReadWriter methodsFor: 'private'!on: aStream	"Read it all into memory and use that as a stream to read from.  TK29 May 96"	(aStream respondsTo: #binary) ifTrue: [aStream binary].	stream _ ReadWriteStream with: (aStream contentsOfEntireFile).	stream reset.! !!ImageReadWriter methodsFor: 'private'!unpackBits: bits depthTo8From: depth with: width height: height pad: pad	"Unpack bits of depth 1, 2, or 4 image to it of depth 8 image."	| bitMask pixelInByte bitsWidth upBitsWidth stopWidth	 trailingSize upBits bitIndex upBitIndex val |	(#(1 2 4) includes: depth)		ifFalse: [^self error: 'depth must be 1, 2, or 4'].	(#(8 16 32) includes: pad)		ifFalse: [^self error: 'pad must be 8, 16, or 32'].	bitMask _ (1 bitShift: depth) - 1.	pixelInByte _ 8 / depth.	bitsWidth _ width * depth + pad - 1 // pad * (pad / 8).	upBitsWidth _ width * 8 + pad - 1 // pad * (pad / 8).	stopWidth _ width * depth + 7 // 8.	trailingSize _ width - (stopWidth - 1 * pixelInByte).	upBits _ ByteArray new: upBitsWidth * height.	1 to: height do: [:i |		bitIndex _ i - 1 * bitsWidth.		upBitIndex _ i - 1 * upBitsWidth.		1 to: stopWidth - 1 do: [:j |			val _ bits at: (bitIndex _ bitIndex + 1).			upBitIndex _ upBitIndex + pixelInByte.			1 to: pixelInByte do: [:k |				upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).				val _ val bitShift: depth negated]].		val _ (bits at: (bitIndex _ bitIndex + 1))				bitShift: depth negated * (pixelInByte - trailingSize).		upBitIndex _ upBitIndex + trailingSize.		1 to: trailingSize do: [:k |			upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).			val _ val bitShift: depth negated]].	^ upBits! !!ImageReadWriter methodsFor: 'testing' stamp: 'tao 10/27/97 09:26'!understandsImageFormat	"Test to see if the image stream format is understood by this decoder.	This should be implemented in each subclass of ImageReadWriter so that	a proper decoder can be selected without ImageReadWriter having to know	about all possible image file types."	^ false! !!GIFReadWriter methodsFor: 'accessing' stamp: 'di 9/15/1998 09:53'!understandsImageFormat	^('abc' collect: [:x | stream next asCharacter]) = 'GIF'! !!ImageReadWriter class methodsFor: 'instance creation'!on: aStream	"Answer an instance of the receiver for encoding and/or decoding images on the given."	^ self new on: aStream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'di 9/14/1998 09:48'!formFromFileNamed: fileName	"Answer a ColorForm stored on the file with the given name."	| reader readerClass form stream |	stream _ FileStream readOnlyFileNamed: fileName.	readerClass _ self withAllSubclasses		detect: [:subclass | stream reset. (subclass new on: stream) understandsImageFormat]		ifNone: [self error: 'image format not recognized'].	reader _ readerClass new on: stream reset.	Cursor read showWhile: [		form _ reader nextImage.		reader close].	^ form! !!ImageReadWriter class methodsFor: 'image reading/writing'!putForm: aForm onFileNamed: fileName	"Store the given form on a file of the given name."	| writer |	writer _ self on: (FileStream newFileNamed: fileName) binary.	Cursor write showWhile: [writer nextPutImage: aForm].	writer close.! !!JPEGColorComponent commentStamp: '<historical>' prior: 0!I represent a single component of color in JPEG YCbCr color space.  I can accept a list of blocks in my component from the current MCU, then stream the samples from this block for use in color conversion.  I also store the running DC sample value for my component, used by the Huffman decoder. !!JPEGColorComponent reorganize!('accessing' acTableIndex acTableIndex: dcTableIndex dcTableIndex: heightInBlocks heightInBlocks: id id: mcuWidth:mcuHeight:dctSize: priorDCValue: qTableIndex qTableIndex: totalMcuBlocks updateDCValue: widthInBlocks widthInBlocks:)('sample streaming' initializeSampleStreamBlocks: nextSample resetSampleStream)!!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:21'!acTableIndex	^acTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!acTableIndex: anInteger	acTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:21'!dcTableIndex	^dcTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!dcTableIndex: anInteger	dcTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!heightInBlocks	^heightInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!heightInBlocks: anInteger	heightInBlocks _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:09'!id	^id! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:09'!id: anObject	id _ anObject! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:29'!mcuWidth: mw mcuHeight: mh dctSize: ds	mcuWidth _ mw.	mcuHeight _ mh.	dctSize _ ds.	hSampleFactor _ mcuWidth // widthInBlocks.	vSampleFactor _ mcuHeight // heightInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:15'!priorDCValue: aNumber	priorDCValue _ aNumber! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:43'!qTableIndex	^qTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!qTableIndex: anInteger	qTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:18'!totalMcuBlocks	^ heightInBlocks * widthInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:16'!updateDCValue: aNumber	priorDCValue _ priorDCValue + aNumber.	^priorDCValue! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!widthInBlocks	^widthInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!widthInBlocks: anInteger	widthInBlocks _ anInteger! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!initializeSampleStreamBlocks: aCollection	mcuBlocks _ aCollection.	self resetSampleStream! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 14:23'!nextSample	| dx dy blockIndex sampleIndex sample |	dx _ currentX // hSampleFactor.	dy _ currentY // vSampleFactor.	blockIndex _ dy // dctSize * widthInBlocks + (dx // dctSize) + 1.	sampleIndex _ dy \\ dctSize * dctSize + (dx \\ dctSize) + 1.	sample _ (mcuBlocks at: blockIndex) at: sampleIndex.	currentX _ currentX + 1.	currentX < (mcuWidth * dctSize)		ifFalse:			[currentX _ 0.			currentY _ currentY + 1].	^ sample! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!resetSampleStream	currentX _ 0.	currentY _ 0! !!JPEGHuffmanTable commentStamp: '<historical>' prior: 0!I represent the table of values used to decode Huffman entropy-encoded bitstreams.  From the JFIF file header entropy values, I build a derived table of codes and values for faster decoding.!!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!bits: anObject	bits _ anObject! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:31'!lookaheadBits	^lookaheadBits! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:38'!lookaheadSymbol	^lookaheadSymbol! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:59'!maxcode	^maxcode! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!values: anObject	values _ anObject! !!JPEGHuffmanTable methodsFor: 'computation' stamp: 'tao 10/24/97 12:28'!makeDerivedTables	| huffSize huffCode code si index lookbits |	mincode _ Array new: 16.	maxcode _ Array new: 17.	valptr _ Array new: 17.	huffSize _ OrderedCollection new.	1 to: 16 do: [:l | 1 to: (bits at: l) do: [:i | huffSize add: l]].	huffSize add: 0.	code _ 0.	huffCode _ Array new: huffSize size.	si _ huffSize at: 1.	index _ 1.	[(huffSize at: index) ~= 0] whileTrue:		[[(huffSize at: index) = si] whileTrue:			[huffCode at: index put: code.			index _ index + 1.			code _ code + 1].		code _ code << 1.		si _ si + 1].	index _ 1.	1 to: 16 do:		[:l |		(bits at: l) ~= 0			ifTrue:				[valptr at: l put: index.				mincode at: l put: (huffCode at: index).				index _ index + (bits at: l).				maxcode at: l put: (huffCode at: index-1)]			ifFalse:				[maxcode at: l put: -1]].	maxcode at: 17 put: 16rFFFFF.	lookaheadBits _ (Array new: 1 << Lookahead) atAllPut: 0.	lookaheadSymbol _ Array new: 1 << Lookahead.	index _ 1.	1 to: Lookahead do:		[:l |		1 to: (bits at: l) do:			[:i |			lookbits _ (huffCode at: index) << (Lookahead - l) + 1.			(1 << (Lookahead - l) to: 1 by: -1) do:				[:ctr |				lookaheadBits at: lookbits put: l.				lookaheadSymbol at: lookbits put: (values at: index).				lookbits _ lookbits + 1].			index _ index + 1]]! !!JPEGHuffmanTable methodsFor: 'computation' stamp: 'tao 10/21/97 22:44'!valueForCode: code length: length	^ values at: ((valptr at: length) + code - (mincode at: length))! !!JPEGHuffmanTable class methodsFor: 'initialization' stamp: 'tao 10/21/97 11:06'!initialize	Lookahead _ 8.	BitBufferSize _ 16! !!JPEGHuffmanTable class methodsFor: 'constants' stamp: 'tao 10/21/97 22:15'!lookahead	^ Lookahead! !!JPEGReadWriter commentStamp: '<historical>' prior: 0!I am a subclass of ImageReadWriter that understands JFIF file streams, and can decode JPEG images.This code is based upon the Independent Joint Photographic Experts Group (IJPEG) software, originally written in C by Tom Lane, Philip Gladstone, Luis Ortiz, Jim Boucher, Lee Crocker, Julian Minguillon, George Phillips, Davide Rossi, Ge' Weijers, and other members of the Independent JPEG Group.!!JPEGReadWriter reorganize!('public access' nextImage setStream:)('preferences' useFloatingPoint)('testing' understandsImageFormat)('marker parsing' initialSOSSetup okToIgnoreMarker: parseAPPn parseDecoderRestartInterval parseFirstMarker parseHuffmanTable parseNOP parseNextMarker parseQuantizationTable parseStartOfFile parseStartOfInput parseStartOfScan perScanSetup skipMarker)('huffman encoding' decodeBlockInto:component:dcTable:acTable: decodeByteWithTable: decodeMCU fillBuffer getBits: peekBits: processRestart scaleAndSignExtend:inFieldWidth:)('dct' dctFloatRangeLimit: dctIntRangeLimit: idctBlockFloat:component: idctBlockInt:component: idctMCU scaleQuantizationTable:)('colorspace conversion' colorConvertFloatYCbCrMCU colorConvertGrayscaleMCU colorConvertIntYCbCrMCU colorConvertMCU sampleFloatRangeLimit: sampleRangeLimit:)('accessing' hACTable hDCTable qTable)('error handling' notSupported:)!!JPEGReadWriter methodsFor: 'public access' stamp: 'tao 10/26/97 23:34'!nextImage	| form xStep yStep x y |	sosSeen _ false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form _ Form extent: (width @ height) depth: 32.	xStep _ mcuWidth * DCTSize.	yStep _ mcuHeight * DCTSize.	y _ 0.	('decompressing ' , width printString , 'x' , height printString , ' JPEG image...')		displayProgressAt: Sensor cursorPoint		from: 1 to: mcuRowsInScan		during:			[:bar |			1 to: mcuRowsInScan do:				[:row |				bar value: row.				x _ 0.				1 to: mcusPerRow do:					[:col |					self decodeMCU.					self idctMCU.					self colorConvertMCU.					mcuImageBuffer displayOn: form at: (x @ y).					x _ x + xStep].				y _ y + yStep]].	^ form! !!JPEGReadWriter methodsFor: 'public access' stamp: 'tao 10/26/97 21:41'!setStream: aStream	"Feed it in from an existing source"	stream _ aStream! !!JPEGReadWriter methodsFor: 'preferences' stamp: 'tao 10/26/97 22:09'!useFloatingPoint	^ false! !!JPEGReadWriter methodsFor: 'testing' stamp: 'tao 10/27/97 09:27'!understandsImageFormat	"test to see if the image stream format is understood by this decoder"	[self parseFirstMarker] ifError: [:err :rcvr | ^ false].	^ true! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:47'!initialSOSSetup	mcuWidth _ (components detectMax: [:c | c widthInBlocks]) widthInBlocks.	mcuHeight _ (components detectMax: [:c | c heightInBlocks]) heightInBlocks.	components do:		[:c |		c mcuWidth: mcuWidth mcuHeight: mcuHeight dctSize: DCTSize].	hACTable , hDCTable do: [:t | t ifNotNil: [t makeDerivedTables]].	bitBuffer _ 0.	bitsInBuffer _ 0.	lookahead _ JPEGHuffmanTable lookahead.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:31'!okToIgnoreMarker: aMarker	^ ((16rE0 to: 16rEF) includes: aMarker) "unhandled APPn markers"		or: [aMarker = 16rDC or: [aMarker = 16rFE]] "DNL or COM markers"! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:47'!parseAPPn	| length buffer thumbnailLength markerStart |	markerStart _ self position.	length _ self nextWord.	buffer _ self next: 4.	(buffer asString = 'JFIF') ifFalse: [self error: 'APP header is incorrect'].	self next.	majorVersion _ self next.	minorVersion _ self next.	densityUnit _ self next.	xDensity _ self nextWord.	yDensity _ self nextWord.	thumbnailLength _ self next * self next * 3.	length _ length - (self position - markerStart).	length = thumbnailLength ifFalse: [self error: 'APP0 thumbnail length is incorrect.'].	self next: length! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/20/97 13:36'!parseDecoderRestartInterval	| length |	length _ self nextWord.	length = 4 ifFalse: [self error: 'DRI length incorrect'].	restartInterval _ self nextWord.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/20/97 22:31'!parseFirstMarker	self next = 16rFF ifFalse: [self error: 'JFIF marker expected'].	self next = 16rD8 ifFalse: [self error: 'SOI marker expected'].	self parseStartOfInput.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:49'!parseHuffmanTable	| length markerStart index bits count huffVal isACTable hTable |	markerStart _ self position.	length _ self nextWord.	[self position - markerStart >= length] whileFalse:		[index _ self next.		isACTable _ (index bitAnd: 16r10) ~= 0.		index _ (index bitAnd: 16r0F) + 1.		index > HuffmanTableSize			ifTrue: [self error: 'image has more than ', HuffmanTableSize printString,				' quantization tables'].		bits _ self next: 16.		count _ bits sum.		(count > 256 or: [(count > (length - (self position - markerStart)))])			ifTrue: [self error: 'Huffman Table count is incorrect'].		huffVal _ self next: count.		(hTable _ JPEGHuffmanTable new)			bits: bits;			values: huffVal.		isACTable			ifTrue:				[self hACTable at: index put: hTable]			ifFalse:				[self hDCTable at: index put: hTable]].! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:32'!parseNOP	"don't need to do anything, here"! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:40'!parseNextMarker	| byte discardedBytes |	discardedBytes _ 0.	[(byte _ self next) = 16rFF] whileFalse: [ self debug. discardedBytes _ discardedBytes + 1].		[[(byte _ self next) = 16rFF] whileTrue. byte = 16r00] whileTrue:		[discardedBytes _ discardedBytes + 2].	discardedBytes > 0 ifTrue: [self notify: 'warning: extraneous data discarded'].	self perform:		(JFIFMarkerParser			at: byte			ifAbsent:				[(self okToIgnoreMarker: byte)					ifTrue: [#skipMarker]					ifFalse: [self error: 'marker ', byte hex , ' cannot be handled']])! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/26/97 21:31'!parseQuantizationTable	| length markerStart n prec value table |	markerStart _ self position.	length _ self nextWord.	[self position - markerStart >= length] whileFalse:		[value _ self next.		n _ (value bitAnd: 16r0F) + 1.		prec _ (value >> 4) > 0.		n > QuantizationTableSize			 ifTrue: [self error: 'image has more than ',				QuantizationTableSize printString,				' quantization tables'].		table _ Array new: DCTSize2.		1 to: DCTSize2 do:			[:i |			value _ (prec				ifTrue: [self nextWord]				ifFalse: [self next]).			table at: (JPEGNaturalOrder at: i) put: value].		self useFloatingPoint ifTrue: [self scaleQuantizationTable: table].		self qTable at: n put: table]! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:07'!parseStartOfFile	| length markerStart value n |	markerStart _ self position.	length _ self nextWord.	dataPrecision _ self next.	dataPrecision = 8		ifFalse: [self error: 'cannot handle ', dataPrecision printString, '-bit components'].	height _ self nextWord.	width _ self nextWord.	n _ self next.	(height = 0) | (width = 0) | (n = 0) ifTrue: [self error: 'empty image'].	(length - (self position - markerStart)) ~= (n * 3)		ifTrue: [self error: 'component length is incorrect'].	components _ Array new: n.	1 to: components size do:		[:i |		components			at: i			put:				(JPEGColorComponent new					id: self next;					"heightInBlocks: (((value _ self next) >> 4) bitAnd: 16r0F);					widthInBlocks: (value bitAnd: 16r0F);"					widthInBlocks: (((value _ self next) >> 4) bitAnd: 16r0F);					heightInBlocks: (value bitAnd: 16r0F);					qTableIndex: self next + 1)]! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 17:38'!parseStartOfInput	restartInterval _ 0.	densityUnit _ 0.	xDensity _ 1.	yDensity _ 1! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/26/97 21:53'!parseStartOfScan	| length n id value dcNum acNum comp |	length _ self nextWord.	n _ self next.	(length ~= (n*2 + 6)) | (n < 1) ifTrue: [self error: 'SOS length is incorrect'].	currentComponents _ Array new: n.	1 to: n do: [:i |		id _ self next.		value _ self next.		dcNum _ (value >> 4) bitAnd: 16r0F.		acNum _ value bitAnd: 16r0F.		comp _ components detect: [:c | c id = id].		comp			dcTableIndex: dcNum+1;			acTableIndex: acNum+1.		currentComponents at: i put: comp].	ss _ self next.	se _ self next.	value _ self next.	ah _ (value >> 4) bitAnd: 16r0F.	al _ value bitAnd: 16r0F.	self initialSOSSetup.	self perScanSetup.	sosSeen _ true! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 21:57'!perScanSetup	mcusPerRow _ (width / (mcuWidth * DCTSize)) ceiling.	mcuRowsInScan _ (height / (mcuHeight * DCTSize)) ceiling.	(currentComponents size = 3 or: [currentComponents size = 1])		ifFalse: [self error: 'JPEG color space not recognized'].	mcuMembership _ OrderedCollection new.	currentComponents withIndexDo:		[:c :i |		c priorDCValue: 0.		mcuMembership addAll: ((1 to: c totalMcuBlocks) collect: [:b | i])].	mcuSampleBuffer _ (1 to: mcuMembership size) collect: [:i | Array new: DCTSize2].	currentComponents withIndexDo:		[:c :i |			c initializeSampleStreamBlocks:				((1 to: mcuMembership size)					select: [:j | i = (mcuMembership at: j)]					thenCollect: [:j | mcuSampleBuffer at: j])].	mcuImageBuffer _ Form		extent: (mcuWidth @ mcuHeight) * DCTSize		depth: (currentComponents size = 1 ifTrue: [8] ifFalse: [32]).	restartsToGo _ restartInterval.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 16:27'!skipMarker	| length markerStart |	markerStart _ self position.	length _ self nextWord.	self next: length - (self position - markerStart)! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/22/97 17:10'!decodeBlockInto: anArray component: aColorComponent dcTable: huffmanDC acTable: huffmanAC	| byte i zeroCount |	byte _ self decodeByteWithTable: huffmanDC.	byte ~= 0 ifTrue: [byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte].	byte _ aColorComponent updateDCValue: byte.	anArray atAllPut: 0.	anArray at: 1 put: byte.	i _ 2.	[i <= DCTSize2] whileTrue:		[byte _ self decodeByteWithTable: huffmanAC.		zeroCount _ byte >> 4.		byte _ byte bitAnd: 16r0F.		byte ~= 0			ifTrue:				[i _ i + zeroCount.				byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte.				anArray at:	 (JPEGNaturalOrder at: i) put: byte]			ifFalse:				[zeroCount = 15 ifTrue: [i _ i + zeroCount] ifFalse: [^ self]].		i _ i + 1]		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:24'!decodeByteWithTable: aHuffmanTable	| look nb length code |	look _ self peekBits: lookahead.	(look >= 0 and: [(nb _ aHuffmanTable lookaheadBits at: look+1) ~= 0])		ifTrue:			[self getBits: nb.			^ aHuffmanTable lookaheadSymbol at: look+1].	length _ 1.	code _ self getBits: length.	[code > (aHuffmanTable maxcode at: length)] whileTrue:		[code _ code << 1 + (self getBits: 1).		length _ length + 1].	length > 16 ifTrue: [self error: 'bad encoding value in bit stream'].	^ aHuffmanTable valueForCode: code length: length.				! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/23/97 13:50'!decodeMCU	| comp |	(restartInterval ~= 0 and: [restartsToGo = 0]) ifTrue: [self processRestart].	mcuMembership withIndexDo:		[:ci :i |		comp _ currentComponents at: ci.		self			decodeBlockInto: (mcuSampleBuffer at: i)			component: comp			dcTable: (hDCTable at: comp dcTableIndex)			acTable: (hACTable at: comp acTableIndex)].	restartsToGo _ restartsToGo - 1.! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:56'!fillBuffer	| byte |	[bitsInBuffer <= 16]		whileTrue:			[byte _ self next.			(byte = 16rFF and: [(stream peekFor: 16r00) not])					ifTrue:						[stream position: stream position - 1.						^0].			bitBuffer _ bitBuffer << 8 bitOr: byte.			bitsInBuffer _ bitsInBuffer + 8].	^ bitsInBuffer! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:54'!getBits: requestedBits	| value |	requestedBits > bitsInBuffer		ifTrue:			[self fillBuffer.			requestedBits > bitsInBuffer				ifTrue:					[self error: 'not enough bits available to decode']].	value _ bitBuffer >> (bitsInBuffer - requestedBits).	bitBuffer _ bitBuffer bitAnd: (1 << (bitsInBuffer - requestedBits) -1).	bitsInBuffer _ bitsInBuffer - requestedBits.	^ value		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 12:46'!peekBits: requestedBits	requestedBits > bitsInBuffer		ifTrue:			[self fillBuffer.			requestedBits > bitsInBuffer ifTrue: [^ -1]].	^ bitBuffer >> (bitsInBuffer - requestedBits)		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 19:40'!processRestart	bitBuffer _ 0.	bitsInBuffer _ 0.	self parseNextMarker.	currentComponents do: [:c | c priorDCValue: 0].	restartsToGo _ restartInterval.! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/22/97 09:43'!scaleAndSignExtend: aNumber inFieldWidth: w	^ aNumber < (1 << (w - 1))		ifTrue: [aNumber + (1 << w) negated + 1]		ifFalse: [aNumber]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 15:16'!dctFloatRangeLimit: value	^ (value / 8.0) + FloatSampleOffset.! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 15:35'!dctIntRangeLimit: value	^ (value + SampleOffset max: 0) min: MaxSample.! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:34'!idctBlockFloat: anArray component: aColorComponent	| t0 t1 t2 t3 t4 t5 t6 t7 t10 t11 t12 t13 z5 z10 z11 z12 z13 qt ws |	qt _ self qTable at: (aColorComponent qTableIndex).	ws _ Array new: DCTSize2.	"Pass 1: process columns from input, store into work array"	1 to: DCTSize do: [:i |		t0 _ (anArray at: i) * (qt at: i).		t1 _ (anArray at: (DCTSize*2 + i)) * (qt at: (DCTSize*2 + i)).		t2 _ (anArray at: (DCTSize*4 + i)) * (qt at: (DCTSize*4 + i)).		t3 _ (anArray at: (DCTSize*6 + i)) * (qt at: (DCTSize*6 + i)).		t10 _ t0 + t2.		t11 _ t0 - t2.		t13 _ t1 + t3.		t12 _ (t1 - t3) * DCTK1 - t13.		t0 _ t10 + t13.		t3 _ t10 - t13.		t1 _ t11 + t12.		t2 _ t11 - t12.		t4 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).		t5 _ (anArray at: (DCTSize*3 + i)) * (qt at: (DCTSize*3 + i)).		t6 _ (anArray at: (DCTSize*5 + i)) * (qt at: (DCTSize*5 + i)).		t7 _ (anArray at: (DCTSize*7 + i)) * (qt at: (DCTSize*7 + i)).		z13 _ t6 + t5.		z10 _ t6 - t5.		z11 _ t4 + t7.		z12 _ t4 - t7.		t7 _ z11 + z13.		t11 _ (z11 - z13) * DCTK1.		z5 _ (z10 + z12) * DCTK2.		t10 _ DCTK3 * z12 - z5.		t12 _ DCTK4 * z10 + z5.		t6 _ t12 - t7.		t5 _ t11 - t6.		t4 _ t10 + t5.		ws at: i put: t0 + t7.		ws at: (DCTSize*7 + i) put: t0 - t7.		ws at: (DCTSize + i) put: t1 + t6.		ws at: (DCTSize*6 + i) put: t1 - t6.		ws at: (DCTSize*2 + i) put: t2 + t5.		ws at: (DCTSize*5 + i) put: t2 - t5.		ws at: (DCTSize*4 + i) put: t3 + t4.		ws at: (DCTSize*3 + i) put: t3 - t4].		"Pass 2: process rows from the workspace"	(0 to: DCTSize2-DCTSize by: DCTSize) do: [:i |		t10 _ (ws at: (i+1)) + (ws at: (i+5)).		t11 _ (ws at: (i+1)) - (ws at: (i+5)).		t13 _ (ws at: (i+3)) + (ws at: (i+7)).		t12 _ ((ws at: (i+3)) - (ws at: (i+7))) * DCTK1 - t13.		t0 _ t10 + t13.		t3 _ t10 - t13.		t1 _ t11 + t12.		t2 _ t11 - t12.		z13 _ (ws at: (i+6)) + (ws at: (i+4)).		z10 _ (ws at: (i+6)) - (ws at: (i+4)).		z11 _ (ws at: (i+2)) + (ws at: (i+8)).		z12 _ (ws at: (i+2)) - (ws at: (i+8)).		t7 _ z11 + z13.		t11 _ (z11 - z13) * DCTK1.		z5 _ (z10 + z12) * DCTK2.		t10 _ DCTK3 * z12 - z5.		t12 _ DCTK4 * z10 + z5.		t6 _ t12 - t7.		t5 _ t11 - t6.		t4 _ t10 + t5.		"final output stage: scale down by a factor of 8 and range-limit"		anArray at: (i+1) put: (self dctFloatRangeLimit: (t0 + t7)).		anArray at: (i+8) put: (self dctFloatRangeLimit: (t0 - t7)).		anArray at: (i+2) put: (self dctFloatRangeLimit: (t1 + t6)).		anArray at: (i+7) put: (self dctFloatRangeLimit: (t1 - t6)).		anArray at: (i+3) put: (self dctFloatRangeLimit: (t2 + t5)).		anArray at: (i+6) put: (self dctFloatRangeLimit: (t2 - t5)).		anArray at: (i+5) put: (self dctFloatRangeLimit: (t3 + t4)).		anArray at: (i+4) put: (self dctFloatRangeLimit: (t3 - t4))]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 18:13'!idctBlockInt: anArray component: aColorComponent	|  qt ws anACTerm dcval z1 z2 z3 z4 z5 t0 t1 t2 t3 t10 t11 t12 t13 |	qt _ self qTable at: (aColorComponent qTableIndex).	ws _ Array new: DCTSize2.	"Pass 1: process columns from anArray, store into work array"	1 to: DCTSize do:		[:i |		anACTerm _ (1 to: DCTSize-1)			detect: [:row | (anArray at: (row * DCTSize + i)) ~= 0]			ifNone: [nil].		anACTerm isNil			ifTrue:				[dcval _ (anArray at: i) * (qt at: 1) << Pass1Bits.				(0 to: DCTSize-1) do: [:j | ws at: (j * DCTSize + i) put: dcval]]			ifFalse:				[z2 _ (anArray at: (DCTSize * 2 + i)) * (qt at: (DCTSize * 2 + i)).				z3 _ (anArray at: (DCTSize * 6 + i)) * (qt at: (DCTSize * 6 + i)).				z1 _ (z2 + z3) * FIXn0n541196100.				t2 _ z1 + (z3 * FIXn1n847759065 negated).				t3 _ z1 + (z2 * FIXn0n765366865).				z2 _ (anArray at: i) * (qt at: i).				z3 _ (anArray at: (DCTSize * 4 + i)) * (qt at: (DCTSize * 4 + i)).				t0 _ (z2 + z3) << ConstBits.				t1 _ (z2 - z3) << ConstBits.				t10 _ t0 + t3.				t13 _ t0 - t3.				t11 _ t1 + t2.				t12 _ t1 - t2.				t0 _ (anArray at: (DCTSize * 7 + i)) * (qt at: (DCTSize * 7 + i)).				t1 _ (anArray at: (DCTSize * 5 + i)) * (qt at: (DCTSize * 5 + i)).				t2 _ (anArray at: (DCTSize * 3 + i)) * (qt at: (DCTSize * 3 + i)).				t3 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).				z1 _ t0 + t3.				z2 _ t1 + t2.				z3 _ t0 + t2.				z4 _ t1 + t3.				z5 _ (z3 + z4) * FIXn1n175875602.				t0 _ t0 * FIXn0n298631336.				t1 _ t1 * FIXn2n053119869.				t2 _ t2 * FIXn3n072711026.				t3 _ t3 * FIXn1n501321110.				z1 _ z1 * FIXn0n899976223 negated.				z2 _ z2 * FIXn2n562915447 negated.				z3 _ z3 * FIXn1n961570560 negated.				z4 _ z4 * FIXn0n390180644 negated.				z3 _ z3 + z5.				z4 _ z4 + z5.				t0 _ t0 + z1 + z3.				t1 _ t1 +z2 +z4.				t2 _ t2 + z2 + z3.				t3 _ t3 + z1 + z4.				ws at: i put: (t10 + t3) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 7 + i) put: (t10 - t3) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 1 + i) put: (t11 + t2) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 6 + i) put: (t11 - t2) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 2 + i) put: (t12 + t1) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 5 + i) put: (t12 - t1) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 3 + i) put: (t13 + t0) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 4 + i) put: (t13 - t0) >> (ConstBits - Pass1Bits)]].	"Pass 2: process rows from work array, store back into anArray"	(0 to: DCTSize2-DCTSize by: DCTSize) do:		[:i |		z2 _ ws at: i + 3.		z3 _ ws at: i + 7.		z1 _ (z2 + z3) * FIXn0n541196100.		t2 _ z1 + (z3 * FIXn1n847759065 negated).		t3 _ z1 + (z2 * FIXn0n765366865).		t0 _ (ws at: (i + 1)) + (ws at: (i + 5)) << ConstBits.		t1 _ (ws at: (i + 1)) - (ws at: (i + 5)) << ConstBits.		t10 _ t0 + t3.		t13 _ t0 - t3.		t11 _ t1 + t2.		t12 _ t1 -t2.		t0 _ ws at: (i + 8).		t1 _ ws at: (i + 6).		t2 _ ws at: (i + 4).		t3 _ ws at: (i + 2).		z1 _ t0 + t3.		z2 _ t1 + t2.		z3 _ t0 + t2.		z4 _ t1 + t3.		z5 _ (z3 + z4) * FIXn1n175875602.		t0 _ t0 * FIXn0n298631336.		t1 _ t1 * FIXn2n053119869.		t2 _ t2 * FIXn3n072711026.		t3 _ t3 * FIXn1n501321110.		z1 _ z1 * FIXn0n899976223 negated.		z2 _ z2 * FIXn2n562915447 negated.		z3 _ z3 * FIXn1n961570560 negated.		z4 _ z4 * FIXn0n390180644 negated.		z3 _ z3 + z5.		z4 _ z4 + z5.		t0 _ t0 + z1 + z3.		t1 _ t1 + z2 + z4.		t2 _ t2 + z2 + z3.		t3 _ t3 + z1 + z4.		anArray at: (i + 1) put: (self dctIntRangeLimit: (t10 + t3) >> (ConstBits + Pass1Bits + 3)).		anArray at: (i + 8) put: (self dctIntRangeLimit: (t10 - t3) >> (ConstBits + Pass1Bits + 3)).		anArray at: (i + 2) put: (self dctIntRangeLimit: (t11 + t2) >> (ConstBits + Pass1Bits + 3)).		anArray at: (i + 7) put: (self dctIntRangeLimit: (t11 - t2) >> (ConstBits + Pass1Bits + 3)).		anArray at: (i + 3) put: (self dctIntRangeLimit: (t12 + t1) >> (ConstBits + Pass1Bits + 3)).		anArray at: (i + 6) put: (self dctIntRangeLimit: (t12 - t1) >> (ConstBits + Pass1Bits + 3)).		anArray at: (i + 4) put: (self dctIntRangeLimit: (t13 + t0) >> (ConstBits + Pass1Bits + 3)).		anArray at: (i + 5) put: (self dctIntRangeLimit: (t13 - t0) >> (ConstBits + Pass1Bits + 3))].! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 21:25'!idctMCU	| comp |	self useFloatingPoint		ifTrue:			[mcuMembership withIndexDo:				[:ci :i |				comp _ currentComponents at: ci.				self idctBlockFloat: (mcuSampleBuffer at: i) component: comp]]		ifFalse:			[mcuMembership withIndexDo:				[:ci :i |				comp _ currentComponents at: ci.				self idctBlockInt: (mcuSampleBuffer at: i) component: comp]]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:16'!scaleQuantizationTable: table	| index |	index _ 1.	1 to: DCTSize do:		[:row |		1 to: DCTSize do:			[:col |			table at: index				put: ((table at: index) * (QTableScaleFactor at: row) *					(QTableScaleFactor at: col)) rounded.			index _ index + 1]].	^ table! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 18:53'!colorConvertFloatYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream _ currentComponents at: 1.	cbSampleStream _ currentComponents at: 2.	crSampleStream _ currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ ySampleStream nextSample.		cb _ cbSampleStream nextSample - FloatSampleOffset.		cr _ crSampleStream nextSample - FloatSampleOffset.		red _ self sampleFloatRangeLimit: (y + (1.40200 * cr)).		green _ self sampleFloatRangeLimit: (y - (0.34414 * cb) - (0.71414 * cr)).		blue _ self sampleFloatRangeLimit: (y + (1.77200 * cb)).		bits at: i put: (red << 16) + (green << 8) + blue].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/24/97 09:34'!colorConvertGrayscaleMCU	| ySampleStream y bits |	ySampleStream _ currentComponents at: 1.	ySampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ (ySampleStream nextSample).		bits at: i put: (y<<16) + (y<<8) + y].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 21:05'!colorConvertIntYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream _ currentComponents at: 1.	cbSampleStream _ currentComponents at: 2.	crSampleStream _ currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ ySampleStream nextSample.		cb _ cbSampleStream nextSample - SampleOffset.		cr _ crSampleStream nextSample - SampleOffset.		red _ self sampleRangeLimit: (y + ((FIXn1n40200 * cr) >> 16)).		green _ self sampleRangeLimit: (y - ((FIXn0n34414 * cb) >> 16) - ((FIXn0n71414 * cr) >> 16)).		blue _ self sampleRangeLimit: (y + ((FIXn1n77200 * cb) >> 16)).		bits at: i put: (red << 16) + (green << 8) + blue].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 21:27'!colorConvertMCU	^ currentComponents size = 3		ifTrue:			[self useFloatingPoint				ifTrue: [self colorConvertFloatYCbCrMCU]				ifFalse: [self colorConvertIntYCbCrMCU]]		ifFalse: [self colorConvertGrayscaleMCU]! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 15:43'!sampleFloatRangeLimit: aNumber	^ (aNumber rounded max: 0) min: MaxSample! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 15:42'!sampleRangeLimit: aNumber	^ (aNumber max: 0) min: MaxSample! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!hACTable	hACTable ifNil: [hACTable _ Array new: HuffmanTableSize].	^ hACTable! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!hDCTable	hDCTable ifNil: [hDCTable _ Array new: HuffmanTableSize].	^ hDCTable! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 08:46'!qTable	qTable ifNil: [qTable _ Array new: QuantizationTableSize].	^ qTable! !!JPEGReadWriter methodsFor: 'error handling' stamp: 'tao 10/19/97 12:25'!notSupported: aString	self error: aString , ' is not currently supported'! !!JPEGReadWriter class methodsFor: 'initialization' stamp: 'tao 10/26/97 16:27'!initialize	"general constants"	DCTSize _ 8.	MaxSample _ (2 raisedToInteger: DCTSize) - 1.	SampleOffset _ MaxSample // 2.	FloatSampleOffset _ SampleOffset asFloat.	DCTSize2 _ DCTSize squared.	QuantizationTableSize _ 4.	HuffmanTableSize _ 4.	"floating-point Inverse Discrete Cosine Transform (IDCT) constants"	ConstBits _ 13.	Pass1Bits _ 2.	DCTK1 _ 2 sqrt.	DCTK2 _ 1.847759065.	DCTK3 _ 1.082392200.	DCTK4 _ -2.613125930.	"fixed-point Inverse Discrete Cosine Transform (IDCT) constants"	FIXn0n298631336 _ 2446.	FIXn0n390180644 _ 3196.	FIXn0n541196100 _ 4433.	FIXn0n765366865 _ 6270.	FIXn0n899976223 _ 7373.	FIXn1n175875602 _ 9633.	FIXn1n501321110 _ 12299.	FIXn1n847759065 _ 15137.	FIXn1n961570560 _ 16069.	FIXn2n053119869 _ 16819.	FIXn2n562915447 _ 20995.	FIXn3n072711026 _ 25172.	"fixed-point color conversion constants"	FIXn0n34414 _ 22554.	FIXn0n71414 _ 46802.	FIXn1n40200 _ 91881.	FIXn1n77200 _  116130.	"reordering table from JPEG zig-zag order"	JPEGNaturalOrder _ #(		1 2 9 17 10 3 4 11		18 25 33 26 19 12 5 6		13 20 27 34 41 49 42 35		28 21 14 7 8 15 22 29		36 43 50 57 58 51 44 37		30 23 16 24 31 38 45 52		59 60 53 46 39 32 40 47		54 61 62 55 48 56 63 64).	"scale factors for the values in the Quantization Tables"	QTableScaleFactor _ (0 to: DCTSize-1) collect:		[:k | k = 0			ifTrue: [1.0]			ifFalse: [(k * Float pi / 16) cos * 2 sqrt]].	"dictionary of marker parsers"	(JFIFMarkerParser _ Dictionary new)		add: (16r01 -> #parseNOP);		add: (16rC0 -> #parseStartOfFile);		add: (16rC4 -> #parseHuffmanTable);		addAll: ((16rD0 to: 16rD7) collect: [:m | Association key: m value: #parseNOP]);		add: (16rD8 -> #parseStartOfInput);		add: (16rD9 -> #parseEndOfInput);		add: (16rDA -> #parseStartOfScan);		add: (16rDB -> #parseQuantizationTable);		add: (16rDD -> #parseDecoderRestartInterval);		add: (16rE0 -> #parseAPPn);		add: (16rE1 -> #parseAPPn)! !!Morph methodsFor: 'menus' stamp: 'di 9/14/1998 10:04'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	self player ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	aMenu add: 'open viewer' action: #openViewerForArgument.	(self isKindOf: MorphThumbnail) ifFalse:		[aMenu add: 'make alias' action: #makeAliasForArgument].	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [Smalltalk imageImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	self colorSettable ifTrue:		[aMenu add: 'change color...' action: #changeColor].	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!HandMorph methodsFor: 'meta menu' stamp: 'di 9/15/1998 07:58'!chooseNewFormForSketchMorph	"Only available when argument is a SketchMorph"	| reply |	reply _ (SelectionMenu selections: Smalltalk imageImports keys asSortedCollection) startUpWithCaption: 'Which element of ImageImports?'.	reply == nil ifTrue: [^ self].	argument form: (Smalltalk imageImports at: reply)! !!ImageMorph methodsFor: 'menu commands' stamp: 'di 9/15/1998 09:58'!readFromFile	| fileName |	fileName _ FillInTheBlank		request: 'Please enter the image file name'		initialAnswer: 'fileName'.	fileName isEmpty ifTrue: [^ self].	self image: (Form fromFileNamed: fileName).! !!PCXReadWriter methodsFor: 'accessing' stamp: 'tao 10/6/97 10:11'!nextImage	"Read in the next PCX image from the stream."	| bytes form |	self readHeader.	bytes _ self readBody.	colorPalette _ self readPalette.	self close.	form _ ColorForm extent: width@height depth: bitsPerPixel.	(Form new hackBits: bytes) displayOn: (Form new hackBits: form bits).	form colors: colorPalette.	^ form! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 08:38'!nextWord	^self next + (self next bitShift: 8)! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 10:07'!readBody	| array scanLine rowBytes position byte count pad |	pad _ #(0 3 2 1) at: (width \\ 4 + 1).	array _ ByteArray new: ((width + pad) * height * bitsPerPixel) // 8.	scanLine _ ByteArray new: rowByteSize.	position _ 1.	1 to: height do:		[:line |		rowBytes _ 0.		[rowBytes < rowByteSize] whileTrue:			[byte _ self next.			byte < 16rC0				ifTrue:					[rowBytes _ rowBytes + 1.					scanLine at: rowBytes put: byte]				ifFalse:					[count _ byte - 16rC0.					byte _ self next.					1 to: count do: [:i | scanLine at: rowBytes + i put: byte].					rowBytes _ rowBytes + count]].		array			replaceFrom: position			to: position + width - 1			with: scanLine			startingAt: 1.		position _ position + width + pad].	^ array! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 09:42'!readHeader	| xMin xMax yMin yMax |	self next.	"skip over manufacturer field"	version _ self next.	encoding _ self next.	bitsPerPixel _ self next.	xMin _ self nextWord.	yMin _ self nextWord.	xMax _ self nextWord.	yMax _ self nextWord.	width _ xMax - xMin + 1.	height _ yMax - yMin + 1.	self next: 4. "skip over device resolution"	self next: 49. "skip over EGA color palette"	colorPlanes _ self next.	rowByteSize _ self nextWord.	isGrayScale _ (self next: 2) = 2.	self next: 58. "skip over filler".! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 08:29'!readPalette	| r g b array |	self next = 12 ifFalse: [self error: 'no Color Palette!!'].	array _ Array new: (1 bitShift: bitsPerPixel).	1 to: array size do:		[:i |		r _ self next.  g _ self next.  b _ self next.		array at: i put: (Color r: r g: g b: b range: 255)].	^ array.! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/14/1998 10:14'!viewImageImports	"Open an inspector on forms imported from Image files."	Smalltalk viewImageImports! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/15/1998 10:16'!helpMenu 	"Answer the help menu to be put up as a screen submenu"	^ SelectionMenu labelList:		#(	'preferences...'			'update code from server'			'about this system...'			'command-key help'			'useful expressions'			'set author initials...'			'set desktop color...'			'set display depth...'			'full screen on'			'full screen off' ) , 			(Array with: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])) , 		#(	'view image imports'			'space left'			'vm statistics' 			'durable help menu')		lines: #(2 5 8 11 14)		selections: #(editPreferences  absorbUpdatesFromServer aboutThisSystem openCommandKeyHelp openStandardWorkspace setAuthorInitials setDesktopColor setDisplayDepth fullScreenOn fullScreenOff soundOnOrOff viewImageImports garbageCollect vmStatistics durableHelpMenu)"ScreenController new helpMenu startUp"! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/14/1998 10:12'!majorShrink    "Smalltalk majorShrink; abandonSources; lastRemoval"	"This method throws out lots of the system that is not needed for, eg, operation in a hand-held PC.  The shrink process is being improved and, in conjunction with removeAllUnSentMessages, yields an image around 600k in size."	self minorShrink.	"Remove references to a few classes to be deleted, so that they won't leave obsolete versions around."	FileList removeSelector: #fileIntoNewChangeSet.	ChangeSet class compile: 'defaultName		^ ''Changes'' ' classified: 'initialization'.	ScreenController removeSelector: #openChangeManager.	ScreenController removeSelector: #exitProject.	ScreenController removeSelector: #openProject.	ScreenController removeSelector: #viewImageImports.	"Now delete lots of classes.."	(SystemOrganization categories select: [:c | 'Morphic*' match: c]) reverseDo:		[:c | SystemOrganization removeSystemCategory: c].	SystemOrganization removeSystemCategory: 'System-Network'.	SystemOrganization removeSystemCategory: 'System-Monitoring'.	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	SystemOrganization removeSystemCategory: 'Graphics-Files'.	SystemOrganization removeSystemCategory: 'Interface-Projects'.	SystemOrganization removeSystemCategory: 'Object Storage'.	SystemOrganization removeSystemCategory: 'System-Sound'.	Smalltalk removeClassNamed: #Circle.	Smalltalk removeClassNamed: #Arc.	Smalltalk removeClassNamed: #FormSetFont.	Smalltalk removeClassNamed: #FontSet.	Smalltalk removeClassNamed: #InstructionPrinter.	Smalltalk removeClassNamed: #ChangeSorter.	Smalltalk removeClassNamed: #DualChangeSorter.	Smalltalk removeClassNamed: #EmphasizedMenu.	Smalltalk removeClassNamed: #MessageTally.	Smalltalk removeClassNamed: #BitEditor.	StringHolder class removeSelector: #originalWorkspaceContents.	CompiledMethod removeSelector: #symbolic.	TextConstants removeKey: #ClairVaux ifAbsent: [].  "deletes a couple of fonts"	TextStyle allInstancesDo:		[:ts | (ts instVarAt: 1) size > 2 ifTrue:  "Only need two fonts"			[ts instVarAt: 1 put: ((ts instVarAt: 1) copyFrom: 1 to: 2)]].	ListParagraph initialize.	PopUpMenu initialize.	StandardSystemView initialize.	Smalltalk noChanges.	ChangeSorter classPool at: #AllChangeSets 		put: (OrderedCollection with: Smalltalk changes).	[self removeAllUnSentMessages > 0] whileTrue.	Smalltalk allClassesDo: [:c | c zapOrganization].	Symbol rehash.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/14/1998 10:12'!minorShrink	"This method throws out lots of the system that is not needed, although not quite as much as majorShrink. In particular, it retains Morphic, Sound, graphics file readers, and the networking classes."	"Smalltalk minorShrink"	(Smalltalk confirm:'About to delete some infrequently used classes andmethods from your image; do you wish to continue?')		ifFalse: [^ self].	"virtual machine construction and Smalltalk-to-C translator:"	Smalltalk discardVMConstructionClasses.	"old Form editor:"	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	Form removeSelector: #edit.	(Smalltalk includesKey: #FormView) ifTrue: [		(Smalltalk at: #FormView)			compile: 'defaultControllerClass  ^ NoController'			classified: 'controller access'].	Smalltalk removeClassNamed: #FormEditorView.	Smalltalk removeClassNamed: #FormEditor.	SystemOrganization removeSystemCategory: 'Graphics-Paths'.	"bit editor (remove Form editor first):"	Form removeSelector: #bitEdit.	Form removeSelector: #bitEditAt:scale:.	StrikeFont removeSelector: #edit:.	Smalltalk removeClassNamed: #FormButtonCache.	Smalltalk removeClassNamed: #FormMenuController.	Smalltalk removeClassNamed: #FormMenuView.	Smalltalk removeClassNamed: #BitEditor.	"inspector for Dictionaries of Forms"	Dictionary removeSelector: #inspectFormsWithLabel:.	SystemDictionary removeSelector: #viewImageImports.	ScreenController removeSelector: #viewImageImports.	Smalltalk removeClassNamed: #FormHolderView.	Smalltalk removeClassNamed: #FormInspectView.	"curve fitting:"	(Smalltalk includesKey: #FormEditor)		ifTrue: [(Smalltalk at: #FormEditor) removeSelector: #curve].	Smalltalk removeClassNamed: #CurveFitter.	Smalltalk removeClassNamed: #LinearFit.	Smalltalk removeClassNamed: #Spline.	"experimental hand-drawn character recoginizer:"	ParagraphEditor removeSelector: #recognizeCharacters.	ParagraphEditor removeSelector: #recognizer:.	ParagraphEditor removeSelector: #recognizeCharactersWhileMouseIn:.	Smalltalk removeClassNamed: #CharRecog.	"experimental updating object viewer:"	Object removeSelector: #evaluate:wheneverChangeIn:.	Smalltalk removeClassNamed: #ObjectViewer.	Smalltalk removeClassNamed: #ObjectTracer.	"HTML formatted fileout support:"	StandardFileStream removeSelector: #asHtml.	Smalltalk removeClassNamed: #HtmlFileStream.	"miscellaneous classes:"	Smalltalk removeClassNamed: #Array2D.	Smalltalk removeClassNamed: #DriveACar.	Smalltalk removeClassNamed: #EventRecorder.	Smalltalk removeClassNamed: #FFT.	Smalltalk removeClassNamed: #FindTheLight.	Smalltalk removeClassNamed: #PluggableTest.	Smalltalk removeClassNamed: #SharedQueue.	Smalltalk removeClassNamed: #SystemMonitor.	(Smalltalk confirm: 'Remove all sounds from the SampledSound library?')		ifTrue: [(Smalltalk at: #SampledSound) initialize].	"post-removal cleanups"	Smalltalk removeEmptyMessageCategories.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Symbol rehash.! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:42'!imageImports	"Answer the global dictionary of image imports, creating it if necessary.  7/24/96 sw"	"Smalltalk viewImageImports"	(self includesKey: #ImageImports)		ifFalse:			[self at: #ImageImports put: Dictionary new].	^ self at: #ImageImports! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:26'!imageReaderClass	"Answer, if present, a class to handle the importing of various graphic image files	from disk. If none, return nil.   tao 10/26/97"	| aClass |	^ ((aClass _ self at: #ImageReadWriter ifAbsent: [nil]) isKindOf: Class)		ifTrue:			[aClass]		ifFalse:			[nil]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:23'!jpegReaderClass	"Answer, if present, a class to handle the importing of JPEG files from disk. If none, return nil.   9/18/96 sw"	| aClass |	^ ((aClass _ self at: #JPEGReadWriter ifAbsent: [nil]) isKindOf: Class)		ifTrue:			[aClass]		ifFalse:			[nil]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:53'!viewImageImports	"Open up a special Form inspector on the dictionary of image imports."	self imageImports inspectFormsWithLabel: 'Image Imports'! !!FormInspectView methodsFor: 'as yet unclassified' stamp: 'di 9/15/1998 10:47'!displayView 	"Display the form as a value in an inspector.  8/11/96 sw"	"Defeated form scaling for HS FormInspector.  8/20/96 di"	| oldOffset scale |	Display fill: self insetDisplayBox fillColor: Color white.	model selectionIndex == 0 ifTrue: [^ self].	oldOffset _ model selection offset.	offset == nil ifFalse: [model selection offset: offset asPoint].	scale _ self insetDisplayBox extent / model selection extent.	scale _ (scale x min: scale y) min: 1.	model selection		displayOn: Display		transformation: (WindowingTransformation			scale: scale asPoint			translation: self displayTransformation translation)		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	model selection offset: oldOffset! !Form class removeSelector: #fromFile:!JPEGHuffmanTable initialize!JPEGReadWriter initialize!ScreenController removeSelector: #viewGIFImports!SystemDictionary removeSelector: #gifImports!SystemDictionary removeSelector: #viewGIFImports!"Postscript:Replace the global GIFImports by ImageImports."(Smalltalk includesKey: #GIFImports) ifTrue:		[Smalltalk at: #ImageImports put: (Smalltalk at: #GIFImports).		Smalltalk removeKey: #GIFImports].ScreenController initialize.!