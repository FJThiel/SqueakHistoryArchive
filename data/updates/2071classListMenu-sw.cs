'From Squeak2.8alpha of 13 January 2000 [latest update: #2066] on 6 May 2000 at 12:04:15 am'!"Change Set:		classListMenu-swDate:			6 May 2000Author:			Scott WallaceAdds new features to the class-list menu of browsers:(1)  subclass template -- places a template for declaring a subclass of the selected class into the code pane.(2)  unreference instance variables -- investigate instance variables of the selected class and its superclasses and report all that are unreferenced.(3)  new instance -- hands you a new instance of the selected class.  If it is a morphic class, you get a morph attached to the hand.  In typical other cases, you get an Inspector opened on an object belonging to the given class.Includes Markus Denker's extension of MenuMorph.addList to allow it to intepret a - as a request for a line."!!Behavior methodsFor: 'instance creation' stamp: 'sw 5/4/2000 20:47'!initializedInstance	"Answer an instance of the receiver which in some sense is initialized.  In the case of Morphs, this will yield an instance that can be attached to the Hand after having received the same kind of basic initialization that would be obtained from an instance chosen from the 'new morph' menu.   Return nil if the receiver is reluctant for some reason to return such a thing"	^ self new! !!Behavior methodsFor: 'user interface' stamp: 'sw 4/4/2000 11:22'!allUnreferencedInstanceVariables	"Return a list of the instance variables known to the receiver which are not referenced in the receiver or any of its subclasses OR superclasses"	| any definingClass |	^ self allInstVarNames copy reject:		[:ivn | any _ false.		definingClass _ self classThatDefinesInstanceVariable: ivn.		definingClass withAllSubclasses do:			[:class |  any ifFalse:				[(class whichSelectorsAccess: ivn asSymbol) do: 					[:sel | sel ~~ #DoIt ifTrue: [any _ true]]]].			any]! !!ClassDescription methodsFor: 'instance variables' stamp: 'sw 5/27/1999 16:46'!classThatDefinesInstanceVariable: instVarName	(instanceVariables notNil and: [instanceVariables includes: instVarName asString]) ifTrue: [^ self]. 	^ superclass ifNotNil: [superclass classThatDefinesInstanceVariable: instVarName]! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 5/5/2000 00:30'!makeNewInstance	| aClass nonMetaClass anInstance |	(aClass _ self selectedClassOrMetaClass) ifNil: [^ self].	nonMetaClass _ aClass theNonMetaClass.	anInstance _ nonMetaClass initializedInstance.	anInstance ifNil: [^ self inform: 'Sorry, cannot make an instance of ', nonMetaClass name].	(Smalltalk isMorphic and: [anInstance isMorph])		ifTrue:			[self currentHand attachMorph: anInstance]		ifFalse:			[anInstance inspectWithLabel: 'An instance of ', nonMetaClass name]! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 3/22/2000 23:04'!selectedMessageCategoryName	"Answer the name of the message category of the message of the currently selected context."	^ self selectedClass organization categoryOfElement: self selectedMessageName! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 5/5/2000 09:23'!showUnreferencedInstVars	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"	| cls aList aReport |	(cls _ self selectedClass) ifNil: [^ self].	aList _ cls allUnreferencedInstanceVariables.	aList size == 0 ifTrue: [^ self inform: 'There are no unreferencedinstance variables in', cls name].	aReport _ String streamContents:		[:aStream |			aStream nextPutAll: 'Unreferenced instance variable(s) in ', cls name; cr.			aList do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList) startUpWithCaption: 'Unreferencedinstance variables in ', cls name! !!Browser methodsFor: 'accessing' stamp: 'sw 5/4/2000 20:22'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass _ self selectedClassOrMetaClass)			ifNil:				[Class template: self selectedSystemCategoryName]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue: [^ self selectedClassOrMetaClass definition].	editSelection == #editComment 		ifTrue: [(theClass _ self selectedClass) ifNil: [^ ''].				comment _ theClass comment.				comment size = 0				ifTrue: [^ 'This class has not yet been commented.']				ifFalse: [^ comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue: [^ self selectedClassOrMetaClass sourceCodeTemplate].	editSelection == #editMessage		ifTrue:			[currentCompiledMethod _ latestCompiledMethod.			^ self selectedMessage].	editSelection == #byteCodes ifTrue:		[^ (self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName)			symbolic asText].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'class list' stamp: 'sw 4/5/2000 10:54'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className |	classListIndex _ anInteger.	self setClassOrganizer.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self classCommentIndicated		ifTrue: []		ifFalse: [editSelection _ anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex == 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass]].	contents _ nil.	self selectedClass isNil		ifFalse: [className _ self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self contentsChanged! !!Browser methodsFor: 'class functions' stamp: 'sw 5/4/2000 20:24'!classListMenu: aMenu 	^ aMenu addList: #(		-		('browse class'				buildClassBrowser)		('browse full (b)'			browseMethodFull)		('printOut'					printOutClass)		('fileOut'					fileOutClass)		-		('hierarchy'				hierarchy)		('definition'					editClass)		('comment'					editComment)		-		('spawn hierarchy (h)'		spawnHierarchy)		('spawn protocol'			spawnProtocol)		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class'				removeClass)		-		('unsent methods'			browseUnusedMethods)		('unreferenced inst vars'	showUnreferencedInstVars)		('subclass template'			makeNewSubclass)		('new instance'				ÃmakeNewInstance)		-		('find method...'				findMethod)		('fetch documentation'		fetchClassDocPane))! !!Browser methodsFor: 'class functions' stamp: 'sw 5/4/2000 20:19'!makeNewSubclass	self selectedClassOrMetaClass ifNil: [^ self].	self okToChange ifFalse: [^ self].	editSelection _ #newClass.	self contentsChanged! !!MenuMorph methodsFor: 'construction' stamp: 'md 12/15/1999 12:44'!addList: listOfPairs	"Add the given items to this menu, where each item is a pair (<string> <actionSelector>)..  ILf an element of the list is simply the symobl $-, add a line to the receiver."	listOfPairs do: [:pair |		#- = pair			ifTrue: [self addLine]			ifFalse: [self add: pair first action: pair last]]! !!ProtoObject class methodsFor: 'as yet unclassified' stamp: 'sw 5/5/2000 09:31'!initializedInstance	^ nil! !!Object class methodsFor: 'instance creation' stamp: 'sw 5/5/2000 09:30'!initializedInstance	^ self new! !!Boolean class methodsFor: 'instance creation' stamp: 'sw 5/5/2000 00:31'!initializedInstance	^ nil! !!Class class methodsFor: 'instance creation' stamp: 'sw 4/27/2000 16:20'!templateForSubclassOf: priorClassName category: systemCategoryName 	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"	^ priorClassName asString, ' subclass: #NameOfSubclass	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , systemCategoryName asString , ''''! !!ContextPart class methodsFor: 'instance creation' stamp: 'sw 5/5/2000 00:30'!initializedInstance	^ nil! !!UndefinedObject class methodsFor: 'instance creation' stamp: 'sw 5/5/2000 09:32'!initializedInstance	^ nil! !