'From Squeak3.6 of ''6 October 2003'' [latest update: #5424] on 20 October 2003 at 5:10:14 pm'!"Change Set:		PNMReadWriterDate:			15 October 2003Author:			Javier Diaz ReinosoI am a subclass of ImageReadWriter that decodes portable anymap file formats(pbm, pgm, ppm and  pam) images.I accept the #origin pragma for SE files as described in:Algoritms For Image Processing And Computer Vision. J. R. ParkerDon't work with 2 bytes samples (16 bit grays, > 32 bits color, etc...), pam files preliminary support."!ImageReadWriter subclass: #PNMReadWriter	instanceVariableNames: 'first type origin cols rows depth maxValue tupleType pragma '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Files'!!PNMReadWriter commentStamp: 'jdr 10/20/2003 17:08' prior: 0!I am a subclass of ImageReadWriter that decodes portable anymap file formats(pbm, pgm, ppm and  pam) images.I accept the #origin pragma for SE files as described in:Algoritms For Image Processing And Computer Vision. J. R. ParkerDon't work with 2 bytes samples (16 bit grays, > 32 bits color, etc...), pam files preliminary support.f _ ImageReadWriter formFromFileNamed: 'Tools:Squeak3.4:Carmen.ppm'.f morphEditSubmitted by Javier Diaz Reinoso, Oct/2003!]style[(361 18 2 26 3 11 1 43)f1,cblack;f1,f1b,f1,f1b,f1,f1b,f1!!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 17:19'!cleanLine	"upTo LF or CR, tab as space"	| line loop b |	line _ WriteStream with: ''.	loop _ true.	[loop] whileTrue: [		b _ stream next.		b ifNil:[			loop _ false		"EOS"		]		ifNotNil: [			(b = (Character cr) or:[b = Character lf]) ifTrue:[				loop _ false.			]			ifFalse:[				b = (Character tab) ifTrue:[b _ Character space].				line nextPut: b.			]		]	].	^line contents! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/15/2003 12:20'!getTokenPbm: aCollection	"get a number, return rest of collection"	| line tokens token |	tokens _ aCollection.	tokens size = 0 ifTrue:[		[			line _ self pbmGetLine.			line ifNil:[^{nil . nil}].			tokens _ line findTokens: ' '.			tokens size = 0		] whileTrue:[].	].	"Transcript cr; show: tokens asString."	token _ tokens removeFirst.	^{token asInteger . tokens}! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 16:39'!nextImage	"read one image"	| data p |	first ifNil:[		first _ false.		data _ stream contentsOfEntireFile.		stream _ (RWBinaryOrTextStream with: data) reset.	]	ifNotNil:[		type < 4 ifTrue:[			self error:'Plain PBM, PGM or PPM have only one image'		].	].	stream ascii.	p _ stream next.	type _ (stream next) asInteger - 48.	(p = $P and:[type > 0 and:[type < 8]]) ifFalse:[		self error:'Not a PNM file'	].	type = 7 ifTrue:[		self readHeaderPAM	]	ifFalse: [		self readHeader	].	type caseOf: {		[1] 	->	[^self readPlainBW].		[2] 	->	[^self readPlainGray].		[3] 	->	[^self readPlainRGB].		[4] 	->	[^self readBWreverse: false].		[5] 	->	[^self readGray].		[6] 	->	[^self readRGB].		[7] 	->	[	"PAM"					(tupleType asUppercase) caseOf: {						['BLACKANDWHITE'] 		-> [^self readBWreverse: true].						['GRAYSCALE'] 			-> [^self readGray].						['RGB'] 					-> [^self readRGB].						['RGB_ALPHA'] 			-> [^self error:'Not implemented'].						['GRAYSCALE_ALPHA'] 	-> [^self error:'Not implemented'].					} otherwise: [^self readData].				]	}! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/10/2003 15:09'!pbmGetLine	"Get the next non-comment line from the PBM stream	Look for 'pragmas' - commands hidden in the comments"	 	| line |	[		line _ self cleanLine.		line ifNil: [^nil].		(line size > 0 and:[(line at: 1) = $#]) ifTrue:[			self pbmParam: line.		].		(line size = 0) or:[(line at: 1) = $#]	] 	whileTrue: [].	^line! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/10/2003 15:11'!pbmParam: line	"Look for a parameter hidden in a comment"	| key tokens |	tokens _ line findTokens: ' '.	key _ (tokens at: 1) asLowercase.	(key = '#origin' and:[tokens size = 3]) ifTrue:[	"ORIGIN key word"		"This is for SE files as described in:		Algoritms For Image Processing And Computer Vision. J. R. Parker"		origin _ ((tokens at: 2) asInteger) @ ((tokens at: 3) asInteger)	].! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/10/2003 17:17'!r: r g: g b: b for: depth	"integer value according depth"	| val |	depth = 16 ifTrue: [		val _ (r << 10) + (g << 5) + b.	]	ifFalse:[		val _ (r << 16) + (g << 8) + b.	].	^val! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 15:49'!readBWreverse: flagXor	"B&W for PAM"	| val form bytesRow nBytes |	stream binary.	form _ Form extent: cols@rows depth: 1.	nBytes _ (cols/8) ceiling.	bytesRow _ (cols/32) ceiling * 4.	0 to: rows-1 do: [:y | | i |		i _ 1 + (bytesRow*y).		0 to: nBytes-1 do: [:x |			val _ stream next.			flagXor ifTrue:[val _ val bitXor: 16rFF].			form bits byteAt: i put: val.			i _ i+1.		]	].	^form! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/11/2003 16:56'!readData	"generic data"	| data nBits nBytes val sample |	stream binary.	data _ OrderedCollection new.	nBits _ maxValue floorLog:2.	nBytes _ (nBits+1) >> 3.	(nBits+1 rem: 8) > 0 ifTrue:[nBytes _ nBytes+1].	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			val _ 0.			1 to: nBytes do: [				sample _ stream next.				val _ val << 8 + sample.			].			data add: val.		]	].	^data! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 15:44'!readGray	"gray form"	| val form poker |	maxValue > 255 ifTrue:[self error:'Gray value > 8 bits not supported in Squeak'].	stream binary.	form _ Form extent: cols@rows depth: depth.	poker _ BitBlt current bitPokerToForm: form.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			val _ stream next.			poker pixelAt: x@y put: val.		]	].	^form! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/15/2003 15:44'!readHeader	"read header for pbm, pgm or ppm"	| tokens aux d c  |	tokens _ OrderedCollection new.	aux _ self getTokenPbm: tokens.	cols _ aux at: 1. tokens _ aux at: 2.	aux _ self getTokenPbm: tokens.	rows _ aux at: 1. tokens _ aux at: 2.	(type = 1 or:[type = 4]) ifTrue:[		maxValue _ 1	]	ifFalse: [		aux _ self getTokenPbm: tokens.		maxValue _ aux at: 1. tokens _ aux at: 2.	].	d _ {1 . 2 . 4 . 	8 . 		16 . 32}.	c _ {2 . 4 . 16 . 256 . 32768 . 16777216}. 	(type = 3 or:[type = 6]) ifTrue: [		maxValue >= 65536 ifTrue:[			self error:'Pixmap > 48 bits not supported in PPM'		].		maxValue >= 256 ifTrue:[			self error:'Pixmap > 32 bits are not supported in Squeak'		].		maxValue < 32 ifTrue:[depth _ 16] ifFalse:[depth _ 32].	]	ifFalse: [		depth _ nil.		1 to: c size do:[:i| ((c at: i) > maxValue and:[depth = nil]) ifTrue:[depth_d at: i]].	].	Transcript cr; show: 'PBM file class ', type asString, ' size ', cols asString, ' x ', 		rows asString, ' maxValue =', maxValue asString, ' depth=', depth asString.! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/15/2003 12:35'!readHeaderPAM	"read pam header, not tested"	| loop line tokens key val |	tupleType _ ''.	loop _ true.	loop whileTrue:[		line _ self pbmGetLine.		tokens _ line findTokens: ' '.		tokens size = 2 ifTrue:[			key _ tokens at: 1 asUppercase.			val _ tokens at: 2.			key caseOf: {				['WIDTH'] 		-> [cols _ val asInteger].				['HEIGHT'] 		-> [rows _ val asInteger].				['DEPTH'] 		-> [depth _ val asInteger].				['MAXVAL']		-> [maxValue _ val asInteger].				['TUPLETYPE']	-> [tupleType _ tupleType, ' ', val].				['ENDHDR']		-> [loop _ false].			}		]	].	Transcript cr; show: 'PAM file class ', type asString, ' size ', cols asString, ' x ', 		rows asString, ' maxValue =', maxValue asString, ' depth=', depth asString.! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 16:03'!readPlainBW	"plain BW"	| val form poker |	form _ Form extent: cols@rows depth: depth.	poker _ BitBlt current bitPokerToForm: form.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			[val _ stream next. (val = $0 or:[val = $1])] whileFalse:[				val ifNil:[self error:'End of file reading PBM'].			].			poker pixelAt: x@y put: (val asInteger).		]	].	^form! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 15:44'!readPlainGray	"plain gray"	| val form poker aux tokens |	form _ Form extent: cols@rows depth: depth.	poker _ BitBlt current bitPokerToForm: form.	tokens _ OrderedCollection new.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			aux _ self getTokenPbm: tokens.			val _ aux at: 1. tokens _ aux at: 2.			poker pixelAt: x@y put: val.		]	].	^form! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/15/2003 12:49'!readPlainRGB	"RGB form, use 32 bits"	| val form poker tokens aux |	maxValue > 255 ifTrue:[self error:'RGB value > 32 bits not supported in Squeak'].	form _ Form extent: cols@rows depth: 32.	poker _ BitBlt current bitPokerToForm: form.	tokens _ OrderedCollection new.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x | | r g b|			aux _ self getTokenPbm: tokens. r _ aux at: 1. tokens _ aux at: 2.			aux _ self getTokenPbm: tokens. g _ aux at: 1. tokens _ aux at: 2.			aux _ self getTokenPbm: tokens. b _ aux at: 1. tokens _ aux at: 2.			val _ self r: r g: g b: b for: depth.			poker pixelAt: x@y put: val.		]	].	^form! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/15/2003 12:48'!readRGB	"RGB form, use 16/32 bits"	| val form poker sample shift |	maxValue > 255 ifTrue:[self error:'RGB value > 32 bits not supported in Squeak'].	stream binary.	form _ Form extent: cols@rows depth: depth.	poker _ BitBlt current bitPokerToForm: form.	depth = 32 ifTrue:[shift _ 8] ifFalse:[shift _ 5].	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			val _ 0.			1 to: 3 do: [:i |				sample _ stream next.				val _ val << shift + sample.			].			poker pixelAt: x@y put: val.		]	].	^form! !!PNMReadWriter methodsFor: 'writing' stamp: 'jdr 10/16/2003 16:08'!nextPutBW: aForm reverse: flagXor	| myType val nBytes bytesRow |	cols _ aForm width.	rows _ aForm height.	depth _ aForm depth.	"stream position: 0."	aForm depth = 1 ifTrue:[myType _ $4] ifFalse:[myType _ $5].	self writeHeader: myType.	stream binary.	nBytes _ (cols/8) ceiling.	bytesRow _ (cols/32) ceiling * 4.	0 to: rows-1 do: [:y | | i |		i _ 1 + (bytesRow*y).		0 to: nBytes-1 do: [:x |			val _ aForm bits byteAt: i.			flagXor ifTrue:[val _ val bitXor: 16rFF].			stream nextPut: val.			i _ i+1.		]	].! !!PNMReadWriter methodsFor: 'writing' stamp: 'jdr 10/16/2003 16:08'!nextPutGray: aForm	| myType peeker val |	cols _ aForm width.	rows _ aForm height.	depth _ aForm depth.	"stream position: 0."	aForm depth = 1 ifTrue:[myType _ $4] ifFalse:[myType _ $5].	self writeHeader: myType.	peeker _ BitBlt current bitPeekerFromForm: aForm.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			val _ peeker pixelAt: x@y.			stream nextPut: val.		]	].! !!PNMReadWriter methodsFor: 'writing' stamp: 'jdr 10/16/2003 14:22'!nextPutImage: aForm	aForm unhibernate.	aForm depth	 caseOf: {		[1] 		-> [self nextPutBW: aForm reverse: false].		[16] 	-> [self nextPutRGB: aForm].		[32] 	-> [self nextPutRGB: aForm].	} otherwise: [		(aForm respondsTo: #colors) ifTrue:[			aForm colors ifNil: [				self nextPutGray: aForm			]			ifNotNil: [				self nextPutRGB: aForm			]		]		ifFalse:[			self nextPutGray: aForm		]	]! !!PNMReadWriter methodsFor: 'writing' stamp: 'jdr 10/16/2003 16:08'!nextPutRGB: aForm	| myType peeker f shift mask |	cols _ aForm width.	rows _ aForm height.	depth _ aForm depth.	f _ aForm.	depth < 16 ifTrue:[		f _ aForm asFormOfDepth: 32.		depth _ 32.	].	myType _ $6.	"stream position: 0."	self writeHeader: myType.	depth = 32 ifTrue:[shift _ 8. mask _ 16rFF] ifFalse:[shift _ 5. mask _ 16r1F].	peeker _ BitBlt current bitPeekerFromForm: f.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x | | p r g b |			p _ peeker pixelAt: x@y.			b _ p bitAnd: mask. p _ p >> shift.			g _ p bitAnd: mask. p _ p >> shift.			r _ p bitAnd: mask.			stream nextPut: r.			stream nextPut: g.			stream nextPut: b.		]	].! !!PNMReadWriter methodsFor: 'writing' stamp: 'jdr 10/15/2003 15:48'!writeHeader: myType	"this is ascii"	stream nextPut: ($P asciiValue).	stream nextPut: (myType asciiValue).	stream nextPut: 10.		"nl"	pragma ifNotNil:[		stream nextPutAll: (pragma asByteArray).	].	stream nextPutAll: (cols printString) asByteArray.	stream nextPut: 32.		" "	stream nextPutAll: (rows printString) asByteArray.	stream nextPut: 10.		"nl"	depth > 1 ifTrue: [| d c maxV |		d _ {1 . 2 . 4  . 8   . 16 . 32}.		c _ {1 . 3 . 15 . 255 . 31 . 255}. 		maxV _ nil.		1 to: d size do:[:i| ((d at: i) = depth and:[maxV = nil]) ifTrue:[maxV _ c at: i]].		stream nextPutAll: (maxV printString) asByteArray.		stream nextPut: 10.		"nl"	]	! !!PNMReadWriter methodsFor: 'testing' stamp: 'jdr 10/11/2003 14:52'!understandsImageFormat	"P1 to P7"	| p  |	p _ stream next asCharacter.	type _ stream next - 48.	^(p = $P and:[type > 0 and:[type < 8]])	! !!PNMReadWriter methodsFor: 'accessing' stamp: 'jdr 10/16/2003 14:52'!origin	^origin! !!PNMReadWriter methodsFor: 'accessing' stamp: 'jdr 10/15/2003 15:35'!pragma: s	pragma _ s! !!PNMReadWriter methodsFor: 'accessing' stamp: 'jdr 10/10/2003 18:04'!stream: s	stream _ s! !!PNMReadWriter methodsFor: 'accessing' stamp: 'jdr 10/16/2003 14:53'!tupleType	^tupleType! !!PNMReadWriter class methodsFor: 'testing' stamp: 'jdr 10/11/2003 14:49'!testFromSEFile: filename	"read SE file, check origin		PNMReadWriter testFromSEFile: 'Tools:Squeak3.4:eliseSE.pbm'.	"	| prw f |	prw _ self new.	prw stream: (FileStream readOnlyFileNamed: filename).	f _ prw nextImage.	f morphEdit.	prw inspect! !!PNMReadWriter class methodsFor: 'testing' stamp: 'jdr 10/16/2003 17:22'!testFromString	"read SE file from string		PNMReadWriter testFromString	"	| prw f s |	prw _ self new.	s _ 'P1#origin 1 03 11	01'.	prw stream: (ReadStream on: s from: 1 to: (s size)).	f _ prw nextImage.	f morphEdit.	Transcript cr;show:'Origin=', prw origin asString; cr.! !!PNMReadWriter class methodsFor: 'testing' stamp: 'jdr 10/20/2003 17:05'!testMultiFile: filename	"write two files from user, then read		PNMReadWriter testMultiFile: 'Tools:Squeak3.6:outMulti.pbm'.	"	| prw f |	prw _ self new.	prw stream: ((FileStream newFileNamed: filename) binary).	prw pragma: '#Squeak test', String lf.	f _ Form fromUser. prw nextPutImage: f. 	f _ Form fromUser.prw nextPutImage: f.		prw close.	prw stream: (FileStream readOnlyFileNamed: filename).	f _ prw nextImage. (SketchMorph withForm: f) openInWorld.	f _ prw nextImage. (SketchMorph withForm: f) openInWorld.! !!PNMReadWriter class methodsFor: 'testing' stamp: 'jdr 10/15/2003 15:43'!testToSEFile: filename	"write SE file with origin		PNMReadWriter testToSEFile: 'Tools:Squeak3.4:outSE.pbm'.	"	| prw f |	prw _ self new.	prw stream: ((FileStream newFileNamed: filename) binary).	prw pragma: '#origin 10 10', String lf.	f _ Form fromUser.	prw nextPutImage: f! !