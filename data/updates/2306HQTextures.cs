'From Squeak2.8alpha of 16 February 2000 [latest update: #2304] on 9 June 2000 at 7:41:41 pm'!"Change Set:		HQTexturesDate:			9 June 2000Author:			Andreas RaabThe change set allows the definition of explicit high quality textures when using Morphs as a texture in 3D. The need for such high quality textures comes from the (unfortunate) requirement of all current 3D hardware to deal with textures that are powers of two only. Although that's kinda stupid we gotta play by their rules here.The dilemma occurs when considering a morph which is, say, 384@384 wide. Downsampling to 256@256 does require less space (good for limited VRAM/AGP resources on the card) but can lead to bad, bad distortions. Upscaling to 512@512 on the other hand requires four times as much space. But it looks just beautiful then. So with this change set we have a choice of what to use and the tradeoffs are made explicit with a new menu entry in the Wonderland wrapper morphs.As a side effect, the change set introduces a method for scaling arbitrary forms through the best available method (which is using bilinear interpolation if possible, and if not, to use WarpBlt instead)." !!Float methodsFor: 'testing' stamp: 'ar 6/9/2000 18:56'!isPowerOfTwo	"Return true if the receiver is an integral power of two.	Floats never return true here."	^false! !!Form methodsFor: 'copying' stamp: 'ar 6/9/2000 18:59'!contentsOfArea: aRect 	"Return a new form which derives from the portion of the original form delineated by aRect."	^self contentsOfArea: aRect 		into: (self class extent: aRect extent depth: depth).! !!Form methodsFor: 'copying' stamp: 'ar 6/9/2000 19:00'!contentsOfArea: aRect into: newForm 	"Return a new form which derives from the portion of the original form delineated by aRect."	^ newForm copyBits: aRect from: self at: 0@0		clippingBox: newForm boundingBox rule: Form over fillColor: nil! !!Form methodsFor: 'displaying' stamp: 'ar 6/9/2000 19:13'!displayInterpolatedOn: aForm	"Display the receiver on aForm, using interpolation if necessary.		Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine |	self extent = aForm extent ifTrue:[^self displayOn: aForm].	Smalltalk at: #B3DRenderEngine 		ifPresent:[:engineClass| engine _ (engineClass defaultForPlatformOn: aForm)].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aForm boundingBox;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	"Otherwise use the 3D engine for our purposes"	engine viewport: aForm boundingBox.	engine material: (B3DMaterial new emission: Color white).	engine texture: self.	engine render: (B3DIndexedQuadMesh new plainTextureRect).	engine finish.! !!B3DTexture methodsFor: 'accessing' stamp: 'ar 6/9/2000 19:16'!contentsOfArea: aRect 	"Return a new form which derives from the portion of the original form delineated by aRect."	^self contentsOfArea: aRect 		into: ((self class extent: aRect extent depth: depth)				wrap: self wrap;				envMode: self envMode;				interpolate: self interpolate;				yourself)! !!ExternalScreen methodsFor: 'texture support' stamp: 'ar 6/9/2000 19:27'!textureHandleOf: aTexture	| textureForm |	aTexture ifNil:[^-1].	textureForm _ self allocateOrRecycleTexture: aTexture.	textureForm ifNil:[^-1].	"Update textureForm if aTexture is dirty"	aTexture hasBeenModified ifTrue:[		"Use the best method we have"		aTexture displayInterpolatedOn: textureForm.		aTexture hasBeenModified: false].	^textureForm getExternalHandle! !!Integer methodsFor: 'testing' stamp: 'ar 6/9/2000 18:56'!isPowerOfTwo	"Return true if the receiver is an integral power of two."	^ (self bitAnd: self-1) = 0! !!Integer methodsFor: 'truncation and round off' stamp: 'ar 6/9/2000 19:16'!asLargerPowerOfTwo	"Convert the receiver into a power of two which is not less than the receiver"	self isPowerOfTwo		ifTrue:[^self]		ifFalse:[^1 bitShift: (self highBit)]! !!Integer methodsFor: 'truncation and round off' stamp: 'ar 6/9/2000 18:56'!asPowerOfTwo	"Convert the receiver into a power of two"	^self asSmallerPowerOfTwo! !!Integer methodsFor: 'truncation and round off' stamp: 'ar 6/9/2000 19:16'!asSmallerPowerOfTwo	"Convert the receiver into a power of two which is not larger than the receiver"	self isPowerOfTwo		ifTrue:[^self]		ifFalse:[^1 bitShift: (self highBit - 1)]! !!Morph methodsFor: 'texture support' stamp: 'ar 6/9/2000 19:39'!asTexture	"Represent the receiver as a Wonderland texture."	| canvas texture dirty hqTexture texExtent tempForm |	hqTexture _ self valueOfProperty: #highQualityTexture ifAbsent:[false].	dirty _ self valueOfProperty: #textureIsDirty ifAbsent:[false].	texture _ self valueOfProperty: #wonderlandTexture.	"Determine the size we expect the texture to be.	Note: This size must never be less than the receiver's since	this will lead to (unwanted) clipping."	texExtent _ self extent.	hqTexture ifTrue:[		"High quality textures round up to next power of two"		texExtent _ texExtent x asLargerPowerOfTwo @ texExtent y asLargerPowerOfTwo.	].	(texture == nil or:[texture extent ~= texExtent]) ifTrue:[		self removeProperty: #wonderlandTexture.		texture _ nil. "Clean up for GC"		texture _ B3DTexture extent: texExtent depth: 32.		texture interpolate: false.		texture wrap: false.		texture envMode: 0.		dirty _ true].	dirty ifTrue:[		canvas _ texture getCanvas.		canvas translateBy: self topLeft negated			during:[:tempCanvas| self fullDrawOn: tempCanvas].		self removeProperty: #textureIsDirty.		"High quality textures need an extra pass here"		(texExtent ~= self extent) ifTrue:[			tempForm _ texture contentsOfArea: (0@0 extent: self extent).			tempForm displayInterpolatedOn: texture].	].	self setProperty: #wonderlandTexture toValue: texture.	^ texture! !!WonderlandWrapperMorph methodsFor: 'menu' stamp: 'ar 6/9/2000 19:17'!addCustomMenuItems: aCustomMenu hand: aHand	super addCustomMenuItems: aCustomMenu hand: aHand.	aCustomMenu addLine.	aCustomMenu addUpdating: #getHQTextureState action: #toggleHQTextureState.	aCustomMenu addUpdating: #getActiveTextureState action: #toggleActiveTextureState.	aCustomMenu addUpdating: #getTextureAdjust action: #toggleTextureAdjust.	aCustomMenu add:'set user point of view' action:#setUserPointOfView.! !!WonderlandWrapperMorph methodsFor: 'menu' stamp: 'ar 6/9/2000 19:30'!getHQTextureState	| tex |	tex _ myActor getTexturePointer.	(tex isMorph and:[(tex valueOfProperty: #highQualityTexture) == true])		ifTrue:[^'disable high quality texture']		ifFalse:[^'enable high quality texture']! !!WonderlandWrapperMorph methodsFor: 'menu' stamp: 'ar 6/9/2000 19:31'!toggleHQTextureState	| tex |	tex _ myActor getTexturePointer.	tex isMorph ifFalse:[^self].	(tex valueOfProperty: #highQualityTexture) == true		ifTrue:[tex setProperty: #highQualityTexture toValue: false]		ifFalse:[tex setProperty: #highQualityTexture toValue: true].	tex changed.! !