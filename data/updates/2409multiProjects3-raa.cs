'From Squeak2.9alpha of 13 June 2000 [latest update: #2407] on 16 June 2000 at 9:51:20 am'!"Change Set:            multiProjects3Date:                   13 June 2000Author:                 Bob ArningSuitable for 2.9alpha ONLYSome post-2401 fixes for MVC, global flaps and a few coordinate transformationsAfter filing in, the global menu flap will be updated with        Utilities updateMenuFlapso that the menus therein will conform to the reorganized world menu code"!Notification subclass: #RequestCurrentWorldNotification        instanceVariableNames: ''        classVariableNames: ''        poolDictionaries: ''        category: 'System-Exceptions Kernel'!!Object methodsFor: 'world hacking' stamp: 'RAA 6/14/2000 18:12'!couldOpenInMorphic        "is there an obvious morphic world in which to open a new morph?"        ^World notNil or: [RequestCurrentWorldNotification signal notNil]! !!Browser methodsFor: 'initialize-release' stamp: 'RAA 6/14/2000 18:06'!openEditString: aString        "Create a pluggable version of all the views for a Browser, including views and controllers."        | systemCategoryListView classListView         messageCategoryListView messageListView browserCodeView topView switchView underPane y optionalButtonsView annotationPane |        self couldOpenInMorphic ifTrue: [^ self openAsMorphEditing: aString].        "Sensor leftShiftDown ifTrue: [^ self openAsMorphEditing: aString].                uncomment-out for testing morphic browser embedded in mvc project"        topView _ StandardSystemView new model: self.        topView borderWidth: 1. "label and minSize taken care of by caller"        systemCategoryListView _ PluggableListView on: self                list: #systemCategoryList                selected: #systemCategoryListIndex                changeSelected: #systemCategoryListIndex:                menu: #systemCategoryMenu:                keystroke: #systemCatListKey:from:.        systemCategoryListView window: (0 @ 0 extent: 50 @ 70).        topView addSubView: systemCategoryListView.        classListView _ PluggableListView on: self                list: #classList                selected: #classListIndex                changeSelected: #classListIndex:                menu: #classListMenu:                keystroke: #classListKey:from:.        classListView window: (0 @ 0 extent: 50 @ 62).        topView addSubView: classListView toRightOf: systemCategoryListView.        switchView _ self buildInstanceClassSwitchView.        switchView borderWidth: 1.        topView addSubView: switchView below: classListView.        messageCategoryListView _ PluggableListView on: self                list: #messageCategoryList                selected: #messageCategoryListIndex                changeSelected: #messageCategoryListIndex:                menu: #messageCategoryMenu:.        messageCategoryListView window: (0 @ 0 extent: 50 @ 70).        topView addSubView: messageCategoryListView toRightOf: classListView.        messageListView _ PluggableListView on: self                list: #messageList                selected: #messageListIndex                changeSelected: #messageListIndex:                menu: #messageListMenu:shifted:                keystroke: #messageListKey:from:.        messageListView window: (0 @ 0 extent: 50 @ 70).        messageListView menuTitleSelector: #messageListSelectorTitle.        topView addSubView: messageListView toRightOf: messageCategoryListView.        Preferences useAnnotationPanes                ifTrue:                        [annotationPane _ PluggableTextView on: self                                text: #annotation accept: nil                                readSelection: nil menu: nil.                        annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).                        topView addSubView: annotationPane below: systemCategoryListView.                        underPane _ annotationPane.                        y _ 110 - self optionalAnnotationHeight]                ifFalse: [                        underPane _ systemCategoryListView.                        y _ 110].        Preferences optionalButtons ifTrue:                [optionalButtonsView _ self buildOptionalButtonsView.                optionalButtonsView borderWidth: 1.                topView addSubView: optionalButtonsView below: underPane.                underPane _ optionalButtonsView.                y _ y - self optionalButtonHeight].        browserCodeView _ PluggableTextView on: self                         text: #contents accept: #contents:notifying:                        readSelection: #contentsSelection menu: #codePaneMenu:shifted:.        browserCodeView window: (0@0 extent: 200@y).        topView addSubView: browserCodeView below: underPane.        aString ifNotNil: [browserCodeView editString: aString.                        browserCodeView hasUnacceptedEdits: true].        topView setUpdatablePanesFrom: #(systemCategoryList classList messageCategoryList messageList).        ^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'RAA 6/14/2000 18:07'!openMessageCatEditString: aString        "Create a pluggable version of the views for a Browser that just shows one message category."        | messageCategoryListView messageListView browserCodeView topView annotationPane underPane y optionalButtonsView |        self couldOpenInMorphic ifTrue: [^ self openAsMorphMsgCatEditing: aString].        topView _ (StandardSystemView new) model: self.        topView borderWidth: 1.                "label and minSize taken care of by caller"        messageCategoryListView _ PluggableListView on: self                list: #messageCatListSingleton                selected: #indexIsOne                 changeSelected: #indexIsOne:                menu: #messageCategoryMenu:.        messageCategoryListView window: (0 @ 0 extent: 200 @ 12).        topView addSubView: messageCategoryListView.        messageListView _ PluggableListView on: self                list: #messageList                selected: #messageListIndex                changeSelected: #messageListIndex:                menu: #messageListMenu:shifted:                keystroke: #messageListKey:from:.        messageListView menuTitleSelector: #messageListSelectorTitle.        messageListView window: (0 @ 0 extent: 200 @ 70).        topView addSubView: messageListView below: messageCategoryListView.        Preferences useAnnotationPanes                ifTrue:                        [annotationPane _ PluggableTextView on: self                                text: #annotation accept: nil                                readSelection: nil menu: nil.                        annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).                        topView addSubView: annotationPane below: messageListView.                        underPane _ annotationPane.                        y _ (200 - 12 - 70) - self optionalAnnotationHeight]                ifFalse:                        [underPane _ messageListView.                        y _ (200 - 12 - 70)].        Preferences optionalButtons ifTrue:                [optionalButtonsView _ self buildOptionalButtonsView.                optionalButtonsView borderWidth: 1.                topView addSubView: optionalButtonsView below: underPane.                underPane _ optionalButtonsView.                y _ y - self optionalButtonHeight].        browserCodeView _ PluggableTextView on: self                         text: #contents accept: #contents:notifying:                        readSelection: #contentsSelection menu: #codePaneMenu:shifted:.        browserCodeView window: (0@0 extent: 200@y).        topView addSubView: browserCodeView below: underPane.        aString ifNotNil: [browserCodeView editString: aString.                        browserCodeView hasUnacceptedEdits: true].        topView setUpdatablePanesFrom: #(messageCatListSingleton messageList).        ^ topView! !!Debugger methodsFor: 'private' stamp: 'RAA 6/13/2000 17:36'!resumeProcess: aTopView        Smalltalk isMorphic ifFalse: [aTopView erase].        savedCursor ifNotNil: [Sensor currentCursor: savedCursor].        isolationHead ifNotNil:                [failedProject enterForEmergencyRecovery.                isolationHead invoke. isolationHead _ nil].        interruptedProcess suspendedContext method                        == (Process compiledMethodAt: #terminate)                ifFalse:                [contextStackIndex > 1                        ifTrue: [interruptedProcess popTo: self selectedContext]                        ifFalse: [interruptedProcess install: self selectedContext].                Smalltalk isMorphic                        ifTrue: [Project resumeProcess: interruptedProcess]                        ifFalse: [ScheduledControllers                                                activeControllerNoTerminate: interruptedController                                                andProcess: interruptedProcess]].        "if old process was terminated, just terminate current one"        interruptedProcess _ nil. "Before delete, so release doesn't terminate it"        Smalltalk isMorphic                ifTrue: [aTopView delete. Display repaintMorphicDisplayNow]                ifFalse: [aTopView controller closeAndUnscheduleNoErase].        Smalltalk installLowSpaceWatcher.  "restart low space handler"        Processor terminateActive! !!Dictionary methodsFor: 'user interface' stamp: 'RAA 6/14/2000 18:24'!inspectFormsWithLabel: aLabel        "Open a Form Dictionary inspector on the receiver, with the given label."        | viewClass aList aGraphicalMenu |                self couldOpenInMorphic                ifTrue:                        [aList _ self collect: [:f | f].                        aList isEmpty ifTrue: [^ self inform: 'Empty!!'].                        aGraphicalMenu _ GraphicalDictionaryMenu new                                 initializeFor: nil                                fromDictionary: self.                        ^ HandMorph attach: (aGraphicalMenu wrappedInWindowWithTitle: aLabel)].        viewClass _ PluggableTextView.        Smalltalk at: #FormInspectView                ifPresent: [:formInspectView | viewClass _ formInspectView].        ^ DictionaryInspector                openOn: self                withEvalPane: true                withLabel: aLabel                valueViewClass: viewClass! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 6/14/2000 17:05'!changeMorphicWorldTo: aWorldOrNil        self flag: #bob.                OuterMorphicWorld _ World _ aWorldOrNil.! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 6/14/2000 17:04'!getCurrentMorphicWorld        ^RequestCurrentWorldNotification signal ifNil: [                (self morphicWorldAt: Sensor cursorPoint) ifNil: [                        self getOuterMorphicWorld                ].        ]! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 6/13/2000 12:00'!morphicWorldAt: aPoint        | roots outer |        outer _ self getOuterMorphicWorld ifNil: [^nil].        roots _ outer rootMorphsAt: aPoint.  "root morphs in world"        roots isEmpty ifTrue: [^outer].        ^((roots first morphsAt: aPoint)                 detect: [ :each | true]                ifNone: [roots first]) world! !!DisplayScreen methodsFor: 'OBSOLETE' stamp: 'RAA 6/14/2000 17:07'!obsolete        self error: 'CurrentMorphicWorld and CurrentWorldIsMeaningful are going away'.        self flag: #bob.! !!EventHandler methodsFor: 'object fileIn' stamp: 'RAA 6/14/2000 15:10'!convertmmmmmmmmmmmmmmkkv0: varDict mmmmmmmmmmmmmmkkvssdd0: smartRefStrm        "These variables are automatically stored into the new instance #('mouseDownRecipient' 'mouseDownSelector' 'mouseStillDownRecipient' 'mouseStillDownSelector' 'mouseUpRecipient' 'mouseUpSelector' 'mouseEnterRecipient' 'mouseEnterSelector' 'mouseLeaveRecipient' 'mouseLeaveSelector' 'mouseEnterDraggingRecipient' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingRecipient' 'mouseLeaveDraggingSelector' 'keyStrokeRecipient' 'keyStrokeSelector' 'valueParameter').        This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."        "New variables: #('startDragRecipient' 'startDragSelector' 'doubleClickSelector' 'doubleClickRecipient')  If a non-nil value is needed, please assign it."! !!Inspector class methodsFor: 'instance creation' stamp: 'RAA 6/14/2000 18:20'!openOn: anObject withEvalPane: withEval withLabel: label                self couldOpenInMorphic ifTrue:                [^ self openAsMorphOn: anObject withEvalPane: withEval                        withLabel: label valueViewClass: nil].        ^ self openOn: anObject                 withEvalPane: withEval                 withLabel: label                 valueViewClass: PluggableTextView! !!Morph methodsFor: 'initialization' stamp: 'RAA 6/14/2000 18:09'!openInWorld        "Add this morph to the world.  If in MVC, then provide a Morphic window for it."        self couldOpenInMorphic                ifTrue: [self openInWorld: self currentWorld]                ifFalse: [self openInMVC]! !!Morph methodsFor: 'structure' stamp: 'RAA 6/13/2000 15:01'!primaryHand        | outer |        outer _ self outermostWorldMorph ifNil: [^ nil].        ^ outer activeHand ifNil: [outer firstHand]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'RAA 6/13/2000 11:47'!morphsAtGlobal: aPoint        "Return a collection of all morphs in this morph structure that contain the given point, possibly including the receiver itself.  The order is deepest embedding first."        ^ self morphsAt: (self pointFromWorld: aPoint) addTo: OrderedCollection new! !!Morph methodsFor: 'WiW support' stamp: 'RAA 6/13/2000 11:54'!worldUnderCursor        "will ultimately allow one Hand to service multiple worlds"        ^Display morphicWorldAt: Sensor cursorPoint! !!FlapTab methodsFor: 'positioning' stamp: 'RAA 6/14/2000 19:43'!fitOnScreen        | constrainer |        constrainer _ (owner == nil or: [owner viewBox == nil])                                        ifTrue: [self bounds]                                        ifFalse: [owner viewBox].        self orientation == #vertical ifTrue: [                self top: ((self top min: (constrainer bottom- self height)) max: constrainer top).        ] ifFalse: [                self left: ((self left min: (constrainer right - self width)) max: constrainer left).        ].        self positionObject: self atEdgeOf: constrainer.! !!FlapTab methodsFor: 'positioning' stamp: 'RAA 6/14/2000 19:35'!positionObject: anObject        "anObject could be myself or my referent"        | container |        (container _ (self world ifNil: [self currentWorld]) viewBox) ifNil: [^ self].        "Could consider container _ referent pasteUpMorph, to allow flaps on things other than the world, but for the moment, let's skip it!!"        ^self positionObject: anObject atEdgeOf: container! !!FlapTab methodsFor: 'positioning' stamp: 'RAA 6/14/2000 19:35'!positionObject: anObject atEdgeOf: container        "anObject could be myself or my referent"        edgeToAdhereTo == #left ifTrue: [^ anObject left: container left].        edgeToAdhereTo == #right ifTrue: [^ anObject right: container right].        edgeToAdhereTo == #top ifTrue: [^ anObject top: container top].        edgeToAdhereTo == #bottom ifTrue: [^ anObject bottom: container bottom]! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 6/13/2000 11:48'!dragOverListAt: p        |  roots mList mm root |        roots _ self worldUnderCursor rootMorphsAtGlobal: p.  "root morphs in world"        roots isEmpty                ifTrue: [^EmptyArray]                ifFalse: [root _ roots first].        mList _ root morphsAtGlobal: p.        mList size > 0 ifTrue:                ["NOTE: We really only want the top morph and all its owners"                mm _ mList first.                mList _ OrderedCollection new.                [mm == root] whileFalse:                        [mList addLast: mm.                        mm _ mm owner].                mList add: root].        ^ mList! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 6/13/2000 14:47'!dropMorphsEvent: evt        "Drop all the morphs this hand is currently holding in response to the given event."        "Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drops into the world."        | newOwner morphToDrop localPt grabbedMorph pos worldUnderCursor |        worldUnderCursor _ self worldUnderCursor.        worldUnderCursor ifNil: [^ self].        self changed.        self submorphsReverseDo: [:m |                "drop in reverse order to maintain back-to-front ordering"                addedFlexAtGrab == true                        ifTrue: [pos _ m firstSubmorph position.                                        grabbedMorph _ m removeFlexShell.                                        self privateRemoveMorph: grabbedMorph.                                        grabbedMorph position: pos  "undo offset from removeFlexShell"]                        ifFalse: [grabbedMorph _ m].                newOwner _ self dropTargetFor: grabbedMorph event: evt.                newOwner ifNil:  "Drop not allowed"                        [self rejectDropMorph: grabbedMorph event: evt.                        addedFlexAtGrab == true                        ifTrue: [self privateRemoveMorph: m.                                        addedFlexAtGrab _ false].                        ^ self]."Transcript show: newOwner printString; cr."                morphToDrop _ newOwner morphToDropFrom: grabbedMorph.                 morphToDrop == grabbedMorph ifFalse: [submorphs size == 1 ifTrue:                        [self privateRemoveMorph: m.                        m privateOwner: nil.                        addedFlexAtGrab _ false]].                "the above says: the thing to drop is not what I was carrying; silently vaporize what I was carrying lest it cause trouble later; keep the owner/submorph relationship invariant, but don't go through the standard delete protocol"                localPt _ newOwner globalPointToLocal: self position.                addedFlexAtGrab == true                        ifTrue: [morphToDrop position: localPt                                                + (morphToDrop position - (m transform globalPointToLocal: self position)).                                        self privateRemoveMorph: m.                                        addedFlexAtGrab _ false]                        ifFalse: [morphToDrop position: (newOwner globalPointToLocal: morphToDrop position)].                newOwner acceptDroppingMorph: morphToDrop event: evt.                morphToDrop justDroppedInto: newOwner event: evt.                morphToDrop owner = self ifTrue: [self world addMorphFront: m]].        self layoutChanged.        formerOwner _ nil.        formerPosition _ nil! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 6/13/2000 11:11'!dropTargetFor: aMorph event: evt        "Return the morph that the given morph is to be dropped onto.  Return nil if we must repel the morph.  Return the world, if no other morph wants the dropping morph."        | root coreSample w localPoint |         w _ self worldUnderCursor.        aMorph willingToBeEmbeddedUponLanding ifFalse: [^ w].        localPoint _ w globalPointToLocal: evt cursorPoint.        root _ nil.        w submorphsReverseDo: [:m |                ((m fullContainsPoint: localPoint) and:                 [(m isKindOf: HaloMorph) not]) ifTrue: [root _ m]].        root == nil ifTrue: [^ w].        coreSample _ root morphsAt: localPoint.        coreSample do:                [:m |                        (m repelsMorph: aMorph event: evt) ifTrue:                                [^ nil]].        coreSample do:                [:m |                        (m wantsDroppedMorph: aMorph event: evt) ifTrue: [^ m]].        ^ w! !!HandMorph methodsFor: 'world menu' stamp: 'RAA 6/13/2000 12:56'!worldMenuBuilder                ^TheWorldMenu new                 world: self worldUnderCursor                 project: (self worldUnderCursor project ifNil: [Project current])       "mvc??"                hand: self ! !!HandMorph methodsFor: 'world hacking' stamp: 'RAA 6/13/2000 11:57'!worldUnderCursor        "will ultimately allow one Hand to service multiple worlds"        ^(owner ifNil: [^super worldUnderCursor]) worldUnderCursor! !!MenuItemMorph methodsFor: 'accessing' stamp: 'RAA 6/14/2000 18:45'!adaptToWorld: aWorld        super adaptToWorld: aWorld.        (target isKindOf: Presenter) ifTrue: [^self target: aWorld presenter].        (target isKindOf: TheWorldMenu) ifTrue: [^target adaptToWorld: aWorld].        target isMorph ifTrue: [                target isWorldMorph ifTrue: [self target: aWorld].                target isHandMorph ifTrue: [self target: aWorld primaryHand]        ].! !!MenuMorph methodsFor: 'accessing' stamp: 'RAA 6/16/2000 09:31'!titleGuesstimate        submorphs isEmpty ifTrue: [^nil].        (submorphs first isKindOf: AlignmentMorph) ifFalse: [^nil].        submorphs first submorphsDo: [ :each |                (each isKindOf: StringMorph) ifTrue: [^each contents]        ].        ^nil! !!PackageBrowser methodsFor: 'package list' stamp: 'RAA 6/14/2000 18:22'!openEditString: aString        "Create a pluggable version of all the views for a Browser, including views and controllers."        "PackageBrowser openBrowser"        | packageListView systemCategoryListView classListView messageCategoryListView          messageListView browserCodeView topView switchView annotationPane underPane y optionalButtonsView |        self couldOpenInMorphic ifTrue: [^ self openAsMorphEditing: aString].        topView := (StandardSystemView new) model: self.        topView borderWidth: 1.                "label and minSize taken care of by caller"        packageListView := PluggableListView on: self                list: #packageList                selected: #packageListIndex                changeSelected: #packageListIndex:                menu: #packageMenu:.        packageListView window: (0 @ 0 extent: 20 @ 70).        topView addSubView: packageListView.        systemCategoryListView := PluggableListView on: self                list: #systemCategoryList                selected: #systemCategoryListIndex                changeSelected: #systemCategoryListIndex:                menu: #systemCategoryMenu:.        systemCategoryListView window: (20 @ 0 extent: 30 @ 70).        topView addSubView: systemCategoryListView.        classListView := PluggableListView on: self                list: #classList                selected: #classListIndex                changeSelected: #classListIndex:                menu: #classListMenu:.        classListView window: (0 @ 0 extent: 50 @ 62).        topView addSubView: classListView toRightOf: systemCategoryListView.        switchView := self buildInstanceClassSwitchView.        switchView borderWidth: 1.        topView addSubView: switchView below: classListView.        messageCategoryListView := PluggableListView on: self                list: #messageCategoryList                selected: #messageCategoryListIndex                changeSelected: #messageCategoryListIndex:                menu: #messageCategoryMenu:.        messageCategoryListView window: (0 @ 0 extent: 50 @ 70).        topView addSubView: messageCategoryListView toRightOf: classListView.        messageListView := PluggableListView on: self                list: #messageList                selected: #messageListIndex                changeSelected: #messageListIndex:                menu: #messageListMenu:shifted:                keystroke: #messageListKey:from:.        messageListView window: (0 @ 0 extent: 50 @ 70).        topView addSubView: messageListView toRightOf: messageCategoryListView.        Preferences useAnnotationPanes                ifTrue:                        [annotationPane _ PluggableTextView on: self                                text: #annotation accept: nil                                readSelection: nil menu: nil.                        annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).                        topView addSubView: annotationPane below: packageListView.                        underPane _ annotationPane.                        y _ 110 - self optionalAnnotationHeight]                ifFalse: [                        underPane _ packageListView.                        y _ 110].        Preferences optionalButtons ifTrue:                [optionalButtonsView _ self buildOptionalButtonsView.                optionalButtonsView borderWidth: 1.                topView addSubView: optionalButtonsView below: underPane.                underPane _ optionalButtonsView.                y _ y - self optionalButtonHeight].        browserCodeView := PluggableTextView on: self                         text: #contents accept: #contents:notifying:                        readSelection: #contentsSelection menu: #codePaneMenu:shifted:.        browserCodeView window: (0@0 extent: 200@y).        topView addSubView: browserCodeView below: underPane.        aString ifNotNil: [browserCodeView editString: aString.                        browserCodeView hasUnacceptedEdits: true].        ^ topView! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'RAA 6/13/2000 13:44'!morphToDropFrom: aMorph        | ownersChoice aNail representee handy posBlock tempPos |        handy _ self primaryHand.        posBlock _ [ :z |                tempPos _ handy position - (                        (handy targetOffset - handy formerPosition) * (z extent / aMorph extent)                ) rounded.                self pointFromWorld: tempPos        ].        owner ifNotNil: [                ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self.                ownersChoice ifNotNil: [^ ownersChoice]        ].        self alwaysShowThumbnail ifTrue: [                aNail _ aMorph                         representativeNoTallerThan: self maxHeightToAvoidThumbnailing                         norWiderThan: self maximumThumbnailWidth                         thumbnailHeight: self heightForThumbnails.                aNail == aMorph ifFalse: [                        aNail position: (posBlock value: aNail)                ].                ^ aNail        ].        ((aMorph isKindOf: MorphThumbnail) and:                                 [(representee _ aMorph morphRepresented) owner == nil]) ifTrue: [                representee position: (posBlock value: representee).                ^ representee        ].        self expandPhrasesToScripts ifFalse: [^ aMorph].        (aMorph hasProperty: #newPermanentScript) ifTrue: [                ^ self emptyPermanentScriptorFrom: aMorph        ].        (aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].        ^aMorph morphToDropInPasteUp: self! !!PasteUpMorph methodsFor: 'misc' stamp: 'RAA 6/13/2000 12:57'!invalidRect: damageRect        "Clip damage reports to my bounds, since drawing is clipped to my bounds."        self == self outermostWorldMorph                 ifTrue: [worldState recordDamagedRect: damageRect]                ifFalse: [super invalidRect: (damageRect intersect: bounds)]! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'RAA 6/13/2000 14:58'!morphToDropInPasteUp: aPasteUp        | actualObject itsSelector aScriptor anEditor adjustment aUserScript handy |        self isCommand ifFalse: [^ self].        (actualObject _ self actualObject) ifNil: [^ self].        actualObject assureUniClass.        itsSelector _ self userScriptSelector.        aScriptor _ (itsSelector ~~ nil and: [itsSelector size > 0]) ifTrue: [                actualObject isFlagshipForClass ifFalse: [                "We can set the status for our instantiation of this script, but cannot allow script editing"                                        anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: self.                                        adjustment _ 50 @ 40.                                        anEditor                ] ifTrue: [                "old note: ambiguous case: if there's a script editor on the world,                 drop down a button, else drop down the script editor"                        aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.                        aUserScript isTextuallyCoded ifTrue: [                                ^ aPasteUp scriptorForTextualScript: itsSelector ofPlayer: actualObject                        ].                        ((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:                                        [anEditor owner == aPasteUp])                                ifFalse: [                                        adjustment _ 50 @ 30.                                        anEditor                                ] ifTrue: [                                        adjustment _ 60 @ 20.                                        actualObject permanentScriptEditorFor: self                                ]                ]        ] ifFalse: [ "It's a system-defined selector; construct an anonymous scriptor around it"                adjustment _ 60 @ 20.                actualObject permanentScriptEditorFor: self        ].        handy _ aPasteUp primaryHand.        aScriptor position: handy position - adjustment.        (aScriptor isMemberOf: ScriptEditorMorph) ifTrue: [                aScriptor playerScripted expungeEmptyUnRenamedScripts        ].        ^aScriptor! !!Preferences class methodsFor: 'factored pref panel' stamp: 'RAA 6/14/2000 18:23'!openFactoredPanelWithWidth: aWidth        "Preferences openFactoredPanelWithWidth: 325"        | tabbedPalette controlPage window playfield aColor aFont  maxEntriesPerCategory tabsMorph anExtent |        aFont _ StrikeFont familyName: 'NewYork' size: 19.        aColor _ Color r: 0.645 g: 1.0 b: 1.0.        tabbedPalette _ TabbedPalette newSticky.        (tabsMorph _ tabbedPalette tabsMorph) color: aColor darker; highlightColor: Color red regularColor: Color brown darker darker.        maxEntriesPerCategory _ 0.        "tabbedPalette addTabFor: self helpPaneForFactoredPanel font: aFont.  LATER!!"        self factoredCategories do:                [:aCat |                        controlPage _ AlignmentMorph newColumn beSticky color: aColor.                        controlPage borderColor: aColor; inset: 4.                        aCat second do:                                [:aPrefSymbol |                                        controlPage addMorphBack:                                                (Preferences buttonRepresenting: aPrefSymbol wording: aPrefSymbol color: nil)].                        controlPage setNameTo: aCat first asString.                        aCat first == #halos ifTrue:                                [self addHaloControlsTo: controlPage].                        tabbedPalette addTabFor: controlPage font: aFont.                        maxEntriesPerCategory _ maxEntriesPerCategory max: aCat second size].        tabbedPalette selectTabNamed: 'general'.        tabsMorph rowsNoWiderThan: aWidth.        playfield _ Morph newSticky.        anExtent _ aWidth @ (25 + tabsMorph height + (20 * maxEntriesPerCategory)).        playfield extent: anExtent.        playfield color: aColor.        playfield addMorphBack: tabbedPalette.        self couldOpenInMorphic                ifTrue:                        [window _ (SystemWindow labelled: 'Preferences') model: nil.                        window bounds: ((100@100- ((0@window labelHeight) + window borderWidth))                                                                extent: (playfield extent + (2 * window borderWidth))).                        window addMorph: playfield frame: (0@0 extent: 1@1).                        window updatePaneColors.                        window setProperty: #minimumExtent toValue: (anExtent + (2@2)).                        window position: 200 @ 20.                        self currentHand attachMorph: window.                        self currentWorld startSteppingSubmorphsOf: window]                ifFalse:                        [(window _ MVCWiWPasteUpMorph newWorldForProject: nil) addMorph: playfield.                        window startSteppingSubmorphsOf: playfield.                        MorphWorldView openOn: window  label: 'Preferences' extent: window fullBounds extent]! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/14/2000 16:58'!findAFolderToStoreProjectIn        "Alan wants something prettier with a default"        ^PluggableFileList getFolderDialog openLabel: 'Select a folder on a server:'! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/14/2000 16:57'!storeOnServerInnards        | servers pair newVersion resp newName local folder |        "Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."        "write locally"        self exportSegment.        (FileStream oldFileNamed: self name, '.pr') compressFile.        "Find out what version"        (servers _ self serverList) isEmpty                 ifTrue: [folder _ self findAFolderToStoreProjectIn ifNil: [^ self].                        servers _ Array with: folder.                        urlList _ Array with: folder realUrl, '/'.                        pair _ Array with: nil with: -1]                ifFalse: [pair _ self class mostRecent: self name onServer: servers first].        (newVersion _ self newVersion: pair) ifNil: [^ self].        newName _ self name, '|', newVersion, '.pr'.        local _ FileStream oldFileNamed: self name, '.pr.gz'.        resp _ servers first putFile: local named: newName retry: false.        resp ifFalse: [self inform: 'the primary server of this project seems to be down'.  ^ self].        version _ newVersion.   "committed"        "Later, store with same name on secondary servers.  Still can be race conditions.  All machines will go through the server list in the same order."        "2 to: servers size do: [:aServer | aServer putFile: local named: newName]."        "Rename disk file to be the final name"        local reset.        local localName = newName                 ifFalse: [FileDirectory default rename: local localName toBe: newName]                ifTrue: [local close].! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 6/14/2000 19:22'!assignCollapseFrameFor: aSSView         "Offer up a location along the left edge of the screen for a collapsed SSView. Make sure it doesn't overlap any other collapsed frames."        | grid otherFrames topLeft viewBox collapsedFrame extent newFrame verticalBorderDistance top |        grid _ 8.        verticalBorderDistance _ 8.        aSSView isMorph ifTrue: [                otherFrames _ (SystemWindow windowsIn: aSSView world satisfying: [:w | w ~= aSSView])                                                collect: [:w | w collapsedFrame]                                                thenSelect: [:rect | rect notNil].                        viewBox _ aSSView world viewBox]                ifFalse:                         [otherFrames _ ScheduledControllers scheduledWindowControllers                                                collect: [:aController | aController view ~= aSSView ifTrue: [aController view collapsedFrame]]                                                thenSelect: [:rect | rect notNil].                        viewBox _ Display boundingBox].        collapsedFrame _ aSSView collapsedFrame.        extent _ collapsedFrame notNil                                ifTrue: [collapsedFrame extent]                                ifFalse: [aSSView isMorph                                        ifTrue: [aSSView getRawLabel width + aSSView labelWidgetAllowance @ (aSSView labelHeight + 2)]                                        ifFalse: [(aSSView labelText extent x + 70) @ aSSView labelHeight                                                        min: aSSView labelDisplayBox extent                                        ]                                ].        collapsedFrame notNil                ifTrue: [(otherFrames anySatisfy: [:f | collapsedFrame intersects: f])                                ifFalse: ["non overlapping"                                        ^ collapsedFrame]].        top _ viewBox top + verticalBorderDistance.        [topLeft _ viewBox left @ top.        newFrame _ topLeft extent: extent.        newFrame bottom <= (viewBox height - verticalBorderDistance)]                whileTrue:                         [(otherFrames anySatisfy: [:w | newFrame intersects: w])                                ifFalse: ["no overlap"                                        ^ newFrame].                        top _ top + grid].        "If all else fails... (really to many wins here)"        ^ 0 @ 0 extent: extent! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 6/14/2000 19:22'!assignCollapsePointFor: aSSView        "Offer up a location along the left edge of the screen for a collapsed SSView.        Make sure it doesn't overlap any other collapsed frames."        | grid otherFrames y free topLeft viewBox |        grid _ 24.  "should be mult of 8, since manual move is gridded by 8"        aSSView isMorph                ifTrue: [otherFrames _ (SystemWindow windowsIn: aSSView world satisfying: [:w | true])                                        collect: [:w | w collapsedFrame]                                        thenSelect: [:rect | rect notNil].                                viewBox _ aSSView world viewBox]                ifFalse: [otherFrames _ ScheduledControllers scheduledWindowControllers                                        collect: [:aController | aController view collapsedFrame]                                        thenSelect: [:rect | rect notNil].                                viewBox _ Display boundingBox].        y _ viewBox top.        [(y _ y + grid) <= (viewBox height - grid)]                whileTrue:                [topLeft _ viewBox left@y.                free _ true.                otherFrames do: [:w | free _ free & (topLeft ~= w topLeft)].                free ifTrue: [^ topLeft]].        "If all else fails..."        ^ 0 @ 0! !!RequestCurrentWorldNotification methodsFor: 'as yet unclassified' stamp: 'RAA 6/14/2000 17:03'!defaultAction        self resume: nil! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'RAA 6/13/2000 11:49'!step        | hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii where |        hand _ handWithTile ifNil: [self primaryHand].        (hand lastEvent redButtonPressed)                ifTrue:                [hand submorphCount > 0 ifTrue:                        [insertion _ hand firstSubmorph.                        insHt _ insertion height.                        self removeSpaces.                        where _ self globalPointToLocal: insertion fullBounds topLeft.                        i _ (ii _ self indexOfMorphAbove: where) min: submorphs size-1."Q add: {self. where. i. ii}."                        prevBot _ i <= 0 ifTrue: [(self innerBounds) top]                                        ifFalse: [(self submorphs at: i) bottom].                        nxtHt _ (submorphs isEmpty                                        ifTrue: [insertion]                                        ifFalse: [self submorphs at: i+1]) height.                        d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]                                        ifFalse: [0 max: (insertion top - prevBot min: nxtHt)].                        "Top and bottom spacer heights cause continuous motion..."                        c1 _ Color green.  c2 _ Color transparent.                        ht2 _ d*insHt//nxtHt.                        space1 _ Morph newBounds: (0@0 extent: 30@(insHt-ht2))                                        color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).                        self privateAddMorph: space1 atIndex: (i+1 max: 1).                        space2 _ Morph newBounds: (0@0 extent: 30@ht2)                                        color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).                        self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1)]]                ifFalse:                [self stopStepping.                self removeSpaces.                self allMorphsDo: [:m |                        (m isKindOf: TileMorph) ifTrue: [                                m color: (ScriptingSystem unbrightColorFor: m color)]]]! !!StandardSystemView methodsFor: 'framing' stamp: 'RAA 6/14/2000 17:27'!initialFrame        "Find a plausible initial screen area for the receiver, taking into account user preference, the size needed, and other windows currently on the screen.  5/22/96 sw: let RealEstateAgent do it for us"        ^ RealEstateAgent initialFrameFor: self world: nil! !!StandardSystemView methodsFor: 'displaying' stamp: 'RAA 6/14/2000 17:27'!makeMeVisible        | newLoc portRect |        ((Display boundingBox insetBy: (0@0 corner: self labelHeight asPoint))                containsPoint: self displayBox topLeft) ifTrue: [^ self "OK -- my top left is visible"].        "window not on screen (probably due to reframe) -- move it now"        newLoc _ self isCollapsed                ifTrue: [RealEstateAgent assignCollapsePointFor: self]                ifFalse: [(RealEstateAgent initialFrameFor: self world: nil) topLeft].        portRect _ newLoc + self labelOffset                                extent: self windowBox extent - self labelOffset.        self resizeTo: portRect.        self setLabelRegion.! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'RAA 6/14/2000 16:50'!openAndEnter: aProject         "Answer an instance of me for the argument, aProject. It is created on the        display screen."        | topView |        topView _ self new model: aProject.        topView minimumSize: 50 @ 30.        topView borderWidth: 2.        topView window: (RealEstateAgent initialFrameFor: topView world: self currentWorld).        ScheduledControllers schedulePassive: topView controller.        aProject enter: false revert: false saveForRevert: false! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'RAA 6/14/2000 17:21'!isMorphic        "Answer true if the user interface is running in Morphic rathern than         MVC.  By convention the gloabl variable World is set to nil when MVC is         running.  ScheduledControllers could be set to nil when Morphic is         running, but this symmetry is not yet in effect."        ^ World ~~ nil "or: [RequestCurrentWorldNotification signal notNil]"! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/15/2000 10:16'!adaptToWorld: aWorld        myWorld _ aWorld.        myProject _ nil.                "figure it out if and when needed. maybe make it easier to find"        myHand _ aWorld primaryHand.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/15/2000 10:18'!beIsolated        "Establish this project as an isolation layer.        Further method changes made here will be revoked when you leave the project."        self projectForMyWorld beIsolated.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/15/2000 10:17'!projectForMyWorld        ^myProject ifNil: [myProject _ myWorld project]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/15/2000 10:18'!propagateChanges.        "The changes made in this isolated project will be propagated to projects above."        self projectForMyWorld propagateChanges.! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/14/2000 18:55'!appearanceMenu        "Build the appearance menu for the world."        | screenCtrl |        screenCtrl _ ScreenController new.        ^self fillIn: (self menu: 'appearance...') from: {                {'window colors...' . { Preferences . #windowSpecificationPanel} . 'Lets you specify colors for standard system windows.'}.                {'system fonts...' . { self . #standardFontDo} . 'Choose the standard fonts to use for code, lists, menus, window titles, etc.'}.                {'text highlight color...' . { Preferences . #chooseTextHighlightColor} . 'Choose which color should be used for text highlighting in Morphic.'}.                {'insertion point color...' . { Preferences . #chooseInsertionPointColor} . 'Choose which color to use for the text insertion point in Morphic.'}.                nil.                {#menuColorString . { Preferences . #toggleMenuColorPolicy} . 'Governs whether menu colors should be derived from the desktop color.'}.                {#roundedCornersString . { Preferences . #toggleRoundedCorners} . 'Governs whether morphic windows and menus should have rounded corners.'}.                nil.                {'full screen on' . { screenCtrl . #fullScreenOn} . 'puts you in full-screen mode, if not already there.'}.                {'full screen off' . { screenCtrl . #fullScreenOff} . 'if in full-screen mode, takes you out of it.'}.                nil.                {'set display depth...' . {self. #setDisplayDepth} . 'choose how many bits per pixel.'}.                {'set desktop color...' . {self. #changeBackgroundColor} . 'choose a uniform color to use as desktop background.'}.                {'set gradient color...' . { #myWorld . #setGradientColor:} . 'choose second color to use as gradient for desktop background.'}.                {'use texture background' . { #myWorld . #setStandardTexture} . 'apply a graph-paper-like texture background to the desktop.'}.                nil.                {'clear turtle trails from desktop' . { #myWorld . #clearTurtleTrails} . 'remove any pigment laid down on the desktop by objects moving with their pens down.'}.        }! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/14/2000 18:56'!buildWorldMenu        "Build the meta menu for the world."        | menu |        menu _ MenuMorph new defaultTarget: self.        self colorForDebugging: menu.        menu addStayUpItem.        self fillIn: menu from: {                {'previous project' . { #myWorld . #goBack } }.                {'jump to project...' . { #myWorld . #jumpToProject } }.                {'save project on file...' . { #myWorld  . #saveOnFile } }.                {'load project from file...' . { self  . #loadProject } }.                nil.                {'restore display' . { Display . #restoreMorphicDisplay } }.                nil.        }.        Preferences simpleMenus ifFalse: [                self fillIn: menu from: {                         {'open...' . { self  . #openWindow } }.                        {'windows & flaps...' . { self  . #windowsDo } }.                        {'changes...' . { self  . #changesDo } }.                }.        ].        self fillIn: menu from: {                 {'help...' . { self  . #helpDo } }.                {'appearance...' . { self  . #appearanceDo } }.        }.        Preferences simpleMenus ifFalse: [                self fillIn: menu from: {                        {'do...' . { Utilities . #offerCommonRequests} }.                }.        ].        self fillIn: menu from: {                 nil.                {'new morph...' . { self  . #newMorph } }.                {'authoring tools...' . { self  . #scriptingDo } }.                {'playfield options...' . { self  . #playfieldDo } }.                {'projects...' . { self  . #projectDo } }.        }.        Preferences simpleMenus ifFalse: [                self fillIn: menu from: {                         {'print PS to file...' . { self  . #printWorldOnFile } }.                        {'debug...' . { self  . #debugDo } }.                }.        ].        self fillIn: menu from: {                 nil.                {'save' . { self  . #saveSession } }.                {'save as...' . { Smalltalk . #saveAs } }.                {'save and quit' . { self  . #saveAndQuit } }.                {'quit' . { self  . #quitSession } }.        }.        ^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/15/2000 10:18'!changesMenu        "Build the changes menu for the world."        | menu |        menu _ self menu: 'changes...'.        self fillIn: menu from: {                { 'file out current change set' . { Utilities . #fileOutChanges}.                                'Write the current change set out to a file whose name reflects the change set name and the current date & time.'}.                { 'create new change set...' . { ChangeSorter . #newChangeSet}. 'Create a new change set and make it the current one.'}.                { 'browse changed methods' . { Smalltalk . #browseChangedMessages}.  'Open a message-list browser showing all methods in the current change set'}.                { 'check change set for slips' . { Smalltalk changes . #lookForSlips}.                                'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'}.                nil.                { 'simple change sorter' . {self. #openChangeSorter1}.  'Open a 3-paned changed-set viewing tool'}.                { 'dual change sorter' . {self. #openChangeSorter2}.                                'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'}.                nil.                { 'browse recent submissions' . { Utilities . #browseRecentSubmissions}.                                'Open a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'}.                { 'recently logged changes...' . { ChangeList . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.'}.                { 'recent log file...' . { Smalltalk . #writeRecentToFile}.                                'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.'}.                nil.                { 'save world as morph file' . {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.'}.                nil.        }.        self projectForMyWorld isIsolated ifTrue: [                self fillIn: menu from: {                         { 'propagate changes upward' . {self. #propagateChanges}.                                'The changes made in this isolated project will propagate to projects up to the next isolation layer.'}.                }.        ] ifFalse: [                self fillIn: menu from: {                         { 'isolate changes of this project' . {self. #beIsolated}.                                'Isolate this project and its subprojects from the rest of the system.  Changes to methods here will be revoked when you leave this project.'}.                }.        ].        ^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/16/2000 09:50'!colorForDebugging: aMenu        "aMenu color: self myMenuColor"        "aMenu color: Color lightRed"! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/14/2000 18:57'!debugMenu        | menu |        menu _ self menu: 'debug...'.        ^self fillIn: menu from: {                 { 'inspect world' . { #myWorld . #inspect } }.                { 'explore world' . { #myWorld . #explore } }.                { 'inspect model' . { self . #inspectWorldModel } }.                        " { 'talk to world...' . { self . #typeInMessageToWorld } }."                { 'start MessageTally' . { self . #startMessageTally } }.                { 'start/browse MessageTally' . { self . #startThenBrowseMessageTally } }.                nil.                        "(self hasProperty: #errorOnDraw) ifTrue:  Later make this come up only when needed."                { 'start drawing again' . { #myWorld . #resumeAfterDrawError } }.                { 'start stepping again' . { #myWorld . #resumeAfterStepError } }.                nil.                { 'call #tempCommand' . { #myHand . #callTempCommand } }.                { 'define #tempCommand' . { #myHand . #defineTempCommand } }.        }! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/14/2000 19:04'!helpMenu        "Build the help menu for the world."        | screenCtrl |        screenCtrl _ ScreenController new.        ^self fillIn: (self menu: 'help...') from:        {                {'about this system...'. {Smalltalk. #aboutThisSystem}. 'current version information.'}.                {'update code from server'. {Utilities. #updateFromServer}. 'load latest code updates via the internet'}.                {'preferences...'. {Preferences. #openPreferencesInspector}. 'view and change various options.'}.                nil.                {'command-key help'. { Utilities . #openCommandKeyHelp}. 'summary of keyboard shortcuts.'}.                {'world menu help'. { self . #worldMenuHelp}. 'helps find menu items buried in submenus.'}.                        "{'info about flaps' . { Utilities . #explainFlaps}. 'describes how to enable and use flaps.'}."                {'font size summary' . { Utilities . #fontSizeSummary}.  'summary of names and sizes of available fonts.'}.                {'useful expressions' . { Utilities . #openStandardWorkspace}. 'a window full of useful expressions.'}.                {'graphical imports' . { Smalltalk . #viewImageImports}.  'view the global repository called ImageImports; you can easily import external graphics into ImageImports via the FileList'}.                {'standard graphics library' . { ScriptingSystem . #inspectFormDictionary}.  'lets you view and change the system''s standard library of graphics.'}.                nil.                {#gridOnString . { #myHand . #setGridding}. 'turn gridding on or off.'}.                {'set grid size...' . { #myHand . #setGridSize}.  'specify the size of the grid.'}.                {'telemorphic...' . {self. #remoteDo}.  'commands for doing multi-machine "telemorphic" experiments'}.                {#soundEnablingString . { Preferences . #toggleSoundEnabling}. 'turning sound off will completely disable Squeak''s use of sound.'}.                {'definition for...' . { Utilities . #lookUpDefinition}.  'if connected to the internet, use this to look up the definition of an English word.'}.                nil.                {'set author initials...' . { screenCtrl . #setAuthorInitials }. 'supply initials to be used to identify the author of code and other content.'}.                {'vm statistics' . { screenCtrl . #vmStatistics}.  'obtain some intriguing data about the vm.'}.                {'space left' . { screenCtrl . #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}.        }! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/6/2000 17:10'!openMenu        "Build the open window menu for the world."        | menu |        menu _ self menu: 'open...'.        self fillIn: menu from: {                {'browser' . { Browser . #openBrowser} }.                {'package browser' . { PackageBrowser . #openBrowser} }.                {'method finder' . { self . #openSelectorBrowser} }.                {'workspace' . {self . #openWorkspace} }.                {'file list' . {self . #openFileList} }.                {'file...' . { FileList . #openFileDirectly} }.                {'transcript' . {self . #openTranscript} }.                {'inner world' . { WorldWindow . #test1} }.                nil.                {'simple change sorter' . {self . #openChangeSorter1} }.                {'dual change sorter' . {self . #openChangeSorter2} }.                nil.                {'email reader' . {self . #openEmail} }.                {'web browser' . { Scamper . #openAsMorph} }.                {'IRC chat' . {self . #openIRC} }.                nil.        }.        self mvcProjectsAllowed ifTrue: [                self fillIn: menu from: { {'mvc project' . {self. #openMVCProject} } }        ].        ^self fillIn: menu from: {                 {'morphic project' . {self. #openMorphicProject} }.        }.! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/14/2000 19:05'!projectMenu        "Build the project menu for the world."        | menu |        menu _ self menu: 'projects...'.        self fillIn: menu from: {                { 'save project on file...' . { #myWorld . #saveOnFile } }.                { 'load project from file...' . { self . #loadProject } }.                nil.        }.        self mvcProjectsAllowed ifTrue: [                self fillIn: menu from: {                        { 'create new mvc project'. { self . #openMVCProject } }.                }        ].        self fillIn: menu from: {                 { 'create new morphic project' . { self . #openMorphicProject } }.                nil.                { 'go to previous project' . { Project . #returnToPreviousProject } }.                { 'go to next project' . { Project . #advanceToNextProject } }.                { 'jump to project...' . { #myWorld . #jumpToProject } }.                nil.                { 'save on server (also makes a local copy)' . { #myProject . #storeOnServer } }.                { 'saveAs' . { #myProject . #saveAs } }.                { 'see if server version is more recent...' . { #myProject . #loadFromServer } }.        }.        Preferences simpleMenus ifFalse: [                self fillIn: menu from: {                         nil.                        { 'save for future revert' . { #myProject . #saveForRevert } }.                        { 'revert to saved copy' . { #myProject . #revert } }.                }.        ].        ^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/14/2000 19:04'!remoteMenu        "Build the Telemorphic menu for the world."        ^self fillIn: (self menu: 'Telemorphic') from: {                { 'local host address' . { #myHand . #reportLocalAddress } }.                { 'connect remote user' . { #myHand . #connectRemoteUser } }.                { 'disconnect remote user' . { #myHand . #disconnectRemoteUser } }.                { 'disconnect all remote users' . { #myHand . #disconnectAllRemoteUsers } }.        }! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/14/2000 18:57'!scriptingMenu        "Build the scripting menu for the world."        ^self fillIn: (self menu: 'authoring tools...') from: {                 { 'standard parts bin' . { self . #createStandardPartsBin}. 'A bin of standard parts, from which you can drag out useful morphs.'}.                { 'custom parts bin' . { self . #launchCustomPartsBin}. 'A customized bin of parts.  To define what the custom parts bin is, edit any existing parts bin and tell it to be saved as the custom parts bin.'}.                { 'view trash contents' . { #myHand . #openScrapsBook}. 'The place where all your trashed morphs go.'}.                { 'empty trash can' . { Utilities . #emptyScrapsBook}. 'Empty out all the morphs that have accumulated in the trash can.'}.                { 'new scripting area' . { self . #detachableScriptingSpace}. 'A window set up for simple scripting.'}.                nil.                { 'unlock locked objects' . { #myWorld . #unlockContents}. 'If any items on the world desktop are currently locked, unlock them.'}.                { 'unhide hidden objects' . { #myHand . #showHiders}. 'If any items on the world desktop are currently hidden, make them visible.'}.        }! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/14/2000 19:04'!windowsMenu        "Build the windows menu for the world."        ^self fillIn: (self menu: 'windows & flaps...') from: {                  { 'find window' . { #myHand . #findWindow }. 'Presents a list of all windows; if you choose one from the list, it becomes the active window.'}.                { 'find changed browsers...' . { #myHand . #findDirtyBrowsers }. 'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.                { 'find changed windows...' . { #myHand . #findDirtyWindows }. 'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.                nil.                { 'collapse all windows' . { #myHand . #collapseAll }. 'Reduce all open windows to collapsed forms that only show titles.'}.                { 'expand all windows' . { #myHand . #expandAll }. 'Expand all collapsed windows back to their expanded forms.'}.                nil.                { 'delete unchanged windows' . { #myHand . #closeUnchangedWindows }. 'Deletes all windows that do not have unsaved text edits.'}.                { 'delete non-windows' . { #myHand . #deleteNonWindows }. 'Deletes all non-window morphs lying on the world.'}.                { 'delete both of the above' . { self .#cleanUpWorld }. 'deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'}.                nil.                { #staggerPolicyString . { self . #toggleWindowPolicy }. 'stagger: new windows positioned so you can see a portion of each one.                tile: new windows positioned so that they do not overlap others, if possible.'}.                nil.                { #suppressFlapsString . { self . #toggleFlapSuppressionInProject }. 'Governs whether flaps should be shown in this project'}.                nil.                { 'new global flap...'  . { Utilities . #addGlobalFlap }. 'Create a new flap that will be shared by all morphic projects'}.                { 'new project flap...'  . { Utilities . #addLocalFlap }. 'Create a new flap to be used only in this project.'}.                nil.                { 'about flaps...' . { Utilities . #explainFlaps }. 'Gives a window full of details about how to use flaps.'}.                { #useGlobalFlapsString . { self. #toggleWhetherToUseGlobalFlaps }. 'Governs whether a universal set of "global" flaps should be used in all morphic projects that currently are showing flaps.'}.        }! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 6/15/2000 10:18'!doMenuItem: aCollection        | realTarget |        ^[                realTarget _ aCollection first.                realTarget == #myWorld ifTrue: [realTarget _ myWorld].                realTarget == #myHand ifTrue: [realTarget _ myHand].                realTarget == #myProject ifTrue: [realTarget _ self projectForMyWorld].                realTarget perform: aCollection second        ]                 on: RequestCurrentWorldNotification                do: [ :ex | ex resume: myWorld ]! !!Utilities class methodsFor: 'flaps' stamp: 'RAA 6/16/2000 09:08'!currentMenuFlap        "answer the global menu flap or nil."        ^self globalFlapTabsIfAny detect: [:aTab |                 (aTab submorphs size > 0) and:  [(aTab submorphs first isKindOf: TextMorph) and:                 [(aTab submorphs first contents string copyWithout: $ ) = 'Menus']]        ] ifNone: [nil]! !!Utilities class methodsFor: 'flaps' stamp: 'RAA 6/16/2000 09:08'!replaceMenuFlap        "if there is a global menu flap, replace it with an updated one."        | aFlapTab |        aFlapTab _ self currentMenuFlap ifNil: [^ self].        self removeFlapTab: aFlapTab keepInList: false.        self addGlobalFlap: self menuFlap.        Smalltalk isMorphic ifTrue: [Display bestGuessOfCurrentWorld addGlobalFlaps]"Utilities replaceMenuFlap"! !!Utilities class methodsFor: 'flaps' stamp: 'RAA 6/16/2000 09:43'!updateMenuFlap        | aFlap selectors newMenu newMenuTitle oldMenu |        aFlap _ (self currentMenuFlap ifNil: [^self]) referent.        selectors _ #(openMenu helpMenu windowsMenu changesMenu                 debugMenu playfieldMenu scriptingMenu ).        selectors do: [:menuSelector |                (newMenu _ self currentHand getWorldMenu: menuSelector)                        beSticky;                        stayUp: true.                newMenu submorphs second delete.        "remove the stay up item"                newMenu borderWidth: 1.                (newMenuTitle _ newMenu titleGuesstimate) ifNotNil: [                        oldMenu _ aFlap                                 findDeepSubmorphThat: [ :each |                                        (each isKindOf: MenuMorph) and:                                                 [each titleGuesstimate = newMenuTitle]                                ]                                 ifAbsent: [nil].                        oldMenu ifNotNil: [                                oldMenu owner                                        replaceSubmorph: oldMenu                                         by: newMenu.                        ].                ].        ].        ^ aFlap! !!MVCWiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/13/2000 11:53'!worldUnderCursor        ^self! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 6/13/2000 12:56'!doDeferredUpdatingFor: aWorld        | properDisplay |        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."        PasteUpMorph disableDeferredUpdates ifTrue: [^ false].        (Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"        properDisplay _ canvas notNil and: [canvas form == Display].        aWorld == World ifTrue: [  "this world fills the entire Display"                properDisplay ifFalse: [                        aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"                        self canvas: Display getCanvas.                ]        ] ifFalse: [  "this world is inside an MVC window"                (properDisplay and: [canvas clipRect = aWorld viewBox]) ifFalse: [                        self canvas:                                (Display getCanvas                                        copyOffset: 0@0 "aWorld viewBox origin" clipRect: aWorld viewBox)                ]        ].        ^ true! !WiWPasteUpMorph removeSelector: #invalidRect:!DisplayScreen removeSelector: #useMorphicWorld:during:!Object removeSelector: #isTheActiveWorld!"Postscript:Fix the global menu flap"Utilities updateMenuFlap!