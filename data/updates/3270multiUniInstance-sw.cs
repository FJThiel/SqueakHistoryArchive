'From Squeak2.9alpha of 5 August 2000 [latest update: #3327] on 31 January 2001 at 1:11:17 am'!"Change Set:		multiUniInstance-swDate:			31 January 2001Author:			Scott WallaceNumerous fixes, enhancements, and a couple of new tools in support of the presence of multiple instances of the same scripted uniclass."!Object subclass: #ObjectWithDocumentation	instanceVariableNames: 'authoringStamp documentation properties '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Protocols'!ObjectWithDocumentation subclass: #MethodInterface	instanceVariableNames: 'selector argumentSpecifications resultSpecification userLevel attributeKeywords defaultStatus defaultFiresPerTick '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Protocols'!!MethodInterface commentStamp: 'sw 1/26/2001 23:25' prior: 0!A MethodInterface describes the interface for a single method.  The most generic form is not bound to any particular class or object but rather describes an idealized interface.	selector					A symbol - the selector being described	argumentSpecifications	A list of specifications for the formal arguments of the method	resultSpecification 		A characterization of the return value of the method	userLevel					attributeKeywords		A list of symbols, comprising keywords that the user wishes to								associate with this method	defaultStatus			The status to apply to new instances of the class by default	defaultFiresPerTick		How many fires per tick, by default, should be allowed if ticking.!MethodInterface subclass: #UniclassScript	instanceVariableNames: 'playerClass currentScriptEditor formerScriptingTiles isTextuallyCoded '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!!UniclassScript commentStamp: 'sw 1/30/2001 13:20' prior: 0!Represents a script of uniclass.  Holds the ScriptEditorMorph structures for the current version of a user-defined tile script, as well as previous versions thereof.playerClass				The actual uniclass with which this script is associated.	selector					The script''s selectordefaultStatus			The status to apply to new instances of the class by defaultdefaultFiresPerTick		How many fires per tick, by default, should be allowed if ticking.currentScriptEditor		The current version of the ScriptEditorMorph for the scriptformerScriptingTiles		A collection of pairs, (<timeStamp>  (list of morphs))  each pair characterizing a prior tile version!UnscriptedPlayer subclass: #UnscriptedCardPlayer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!ObjectWithDocumentation subclass: #ValueSpecification	instanceVariableNames: 'selector protocol '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Protocols'!ValueSpecification subclass: #ResultSpecification	instanceVariableNames: 'companionSetterSelector refetchFrequency '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Protocols'!ObjectWithDocumentation subclass: #Variable	instanceVariableNames: 'defaultValue floatPrecision variableName variableType '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Protocols'!!Object methodsFor: 'viewer' stamp: 'sw 1/22/2001 15:20'!renameScript: oldSelector	"prompt the user for a new selector and apply it.  Presently only works for players"	self notYetImplemented! !!Morph methodsFor: 'copying' stamp: 'sw 1/15/2001 19:34'!duplicate	"Make and return a duplicate of the receiver"	| newMorph aName w |	self okayToDuplicate ifFalse: [^ self].	aName _ (w _ self world) ifNotNil:		[w nameForCopyIfAlreadyNamed: self].	newMorph _ self veryDeepCopy.	aName ifNotNil: [newMorph setNameTo: aName].	newMorph arrangeToStartStepping.	newMorph privateOwner: nil. "no longer in world"	newMorph isPartsDonor: false. "no longer parts donor"	^ newMorph! !!Morph methodsFor: 'copying' stamp: 'sw 1/20/2001 00:28'!fullCopyWithoutFormerOwner	"Like fullCopy, but does not copy over the former owner, which could bring a huge amount of extraneous baggage with it."	| dict new anOwner |	anOwner _ self formerOwner.	self removeProperty: #formerOwner.	dict _ IdentityDictionary new: 1000.	new _ self copyRecordingIn: dict.	new allMorphsDo: [:m | m updateReferencesUsing: dict].	anOwner ifNotNil: [self formerOwner: anOwner].	^ new! !!Morph methodsFor: 'copying' stamp: 'sw 1/12/2001 22:51'!usableSiblingInstance	"Return another similar morph whose Player is of the same class as mine"	|  aName usedNames newPlayer newMorph topRenderer |	self flag: #noteToTed.  "I think this may have deviated majorly from your mainstream veryDeepCopy work, so there will probably be some problems entailed"	(topRenderer _ self topRendererOrSelf) == self ifFalse: [^ topRenderer usableSiblingInstance].	self player assureUniClass.	newMorph _ self veryDeepCopyWithoutPlayer.	newPlayer _ self player class new costume: newMorph.	newPlayer copyAddedStateFrom: self player.	newPlayer resetCostumeList.	self isFlexMorph ifTrue: [newMorph renderedMorph player: newPlayer]. "???"	newMorph actorState: (self player actorState shallowCopy initializeFor: newPlayer).	(aName _ self knownName) == nil ifTrue:		[self player ~~ nil ifTrue: [aName _ newMorph innocuousName]].			"Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ (self world ifNil: [OrderedCollection new] ifNotNil: [self world allKnownNames]) copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	newMorph privateOwner: nil.	(newMorph renderedMorph eventHandler ~~ nil) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	self presenter flushPlayerListCache.	^ newMorph! !!Morph methodsFor: 'copying' stamp: 'sw 1/30/2001 21:35'!veryDeepCopyWithoutPlayer	"Make a very deep copy of the receiver but do not include its player in it -- obliterate it wherever it occurs, then make the very deep copy, then restore it where needed in the original"	| hold copy holdState renderedMorph playerOfRenderedMorph |	hold _ self player.	holdState _ self actorStateOrNil.	holdState ifNotNil: [self actorState: nil].	(renderedMorph _ self renderedMorph) ~~ self		ifTrue: [playerOfRenderedMorph _ renderedMorph player.				renderedMorph player: nil.]		ifFalse:	[nil].	self player: nil.	copy _ self veryDeepCopy.		"My player should not be there, and the formerOwner thing should no longer be		a problem owing to Andreas's recent fixes for that"	holdState ifNotNil:		[copy actorState: (holdState copyWithPlayerReferenceNilled)].	self player: hold.	playerOfRenderedMorph ifNotNil: [renderedMorph player: playerOfRenderedMorph].	holdState ifNotNil: [self actorState: holdState].	^ copy! !!Morph methodsFor: 'naming' stamp: 'sw 1/29/2001 02:49'!updateAllScriptingElements	"A sledge-hammer sweep from the world down to make sure that all live scripting elements are up to date.  Presently in eclipse, not sent at the moment."	| aPasteUp |	(aPasteUp _ self topPasteUp) ifNotNil:		[aPasteUp allTileScriptingElements do: [:m | m bringUpToDate]]! !!Morph methodsFor: 'menus' stamp: 'sw 1/29/2001 02:50'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables aPlayer |	aMenu addLine.	self maybeAddCollapseItemTo: aMenu.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer:.	aMenu addLine.	aMenu add: 'copy Postscript' action: #clipPostscript.	aMenu add: 'print PS to file...' target: self selector: #printPSToFile.	(aPlayer _ self topRendererOrSelf player) ifNotNil:		[aMenu addLine.		aMenu add: 'make a sibling instance' target: self action: #makeNewPlayerInstance:.		aMenu balloonTextForLastItem: 'Makes another morph whose player is of the same class as this one.  Both siblings will share the same scripts'.		aMenu add: 'make multiple siblings...' target: self action: #makeMultipleSiblings:.		aMenu balloonTextForLastItem: 'Make any number of sibling instances all at once'.		(aPlayer belongsToUniClass and: [aPlayer class instanceCount > 1]) ifTrue:			[aMenu add: 'make all siblings look like me' target: self action: #makeSiblingsLookLikeMe:.			aMenu balloonTextForLastItem: 'make all my sibling instances look like me.'.			aMenu add: 'bring all siblings to my location' target: self action: #bringAllSiblingsToMe:.			aMenu balloonTextForLastItem: 'find all sibling instances and bring them to me'.			aMenu add: 'apply status to all siblngs' target: self action: #applyStatusToAllSiblings:.			aMenu balloonTextForLastItem: 'apply the current status of all of my scripts to the scripts of all my siblings']].	aMenu addLine.	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addDropShadowMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	aMenu addUpdating: #hasClipSubmorphsString target: self selector: #changeClipSubmorphs argumentList: #().	aMenu addLine.	self potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' target: self action: #embedInto:].	aMenu defaultTarget: self.	aMenu addUpdating: #lockedString action: #lockUnlockMorph.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu		defaultTarget: self;		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction.	aMenu addLine.	(owner notNil and: [owner isStackBackground]) ifTrue:		[self isShared			ifFalse:				[aMenu add: 'put onto Background' target: self action: #putOnBackground]			ifTrue:				[aMenu add: 'remove from Background' target: self action: #putOnForeground.				self couldHoldSeparateDataForEachInstance ifTrue:					[self holdsSeparateDataForEachInstance						ifFalse:							[aMenu add: 'start holding separate data for each instance' target: self action: #makeHoldSeparateDataForEachInstance]						ifTrue:							[aMenu add: 'stop holding separate data for each instance' target: self action: #stopHoldingSeparateDataForEachInstance].							aMenu add: 'be default value on new card' target: self action: #setAsDefaultValueForNewCard.							(self hasProperty: #thumbnailImage)								ifTrue:									[aMenu add: 'stop using for reference thumbnail' target: self action: #stopUsingForReferenceThumbnail]								ifFalse:									[aMenu add: 'start using for reference thumbnail' target: self action: #startUsingForReferenceThumbnail]]].				aMenu addLine].	aMenu defaultTarget: self topRendererOrSelf.	aMenu add: 'draw new path' action: #definePath.	(self hasProperty: #pathPoints) ifTrue:		[aMenu add: 'follow path' action: #followPath.		aMenu add: 'delete path' action: #deletePath].	(owner == nil) ifFalse:		[aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'meta-actions' stamp: 'sw 1/29/2001 02:50'!applyStatusToAllSiblings: evt	"Apply the statuses of all my scripts to the script status of all my siblings"	| aPlayer |	(aPlayer _ self topRendererOrSelf player) belongsToUniClass ifFalse: [self error: 'not uniclass'].	aPlayer instantiatedUserScriptsDo: 		[:aScriptInstantiation | aScriptInstantiation assignStatusToAllSiblings]! !!Morph methodsFor: 'meta-actions' stamp: 'sw 1/19/2001 18:10'!bringAllSiblingsToMe: evt	"bring all siblings of the receiver's player found in the same container to the receiver's location."	| aPlayer aPosition aContainer |	(aPlayer _ self topRendererOrSelf player) belongsToUniClass ifFalse: [self error: 'not uniclass'].	aPosition _ self topRendererOrSelf position.	aContainer _ self topRendererOrSelf owner.	(aPlayer class allInstances copyWithout: aPlayer) do:		[:each |			(aContainer submorphs includes: each costume) ifTrue:				[each costume  position: aPosition]]! !!Morph methodsFor: 'meta-actions' stamp: 'sw 1/15/2001 00:23'!makeMultipleSiblings: evt	"Make multiple siblings, first prompting the user for how many"	| result |	result _ FillInTheBlank request: 'how many siblings do you want?' initialAnswer: '2'.	result isEmptyOrNil ifTrue: [^ self].	result first isDigit ifFalse: [^ self beep].	self topRendererOrSelf makeSiblings: result asInteger.! !!Morph methodsFor: 'meta-actions' stamp: 'sw 1/29/2001 17:11'!makeSiblings: count	"Make multiple sibling, and return the list"	| aPosition anInstance listOfNewborns |	aPosition _ self position.	listOfNewborns _ (1 to: count asInteger) asArray collect: 		[:anIndex |			anInstance _ self usableSiblingInstance.			owner addMorphFront: anInstance.			aPosition _ aPosition + (10@10).			anInstance position: aPosition.			anInstance].	self currentWorld startSteppingSubmorphsOf: self topRendererOrSelf owner.	^ listOfNewborns! !!Morph methodsFor: 'meta-actions' stamp: 'sw 1/12/2001 22:47'!makeSiblingsLookLikeMe: evt	"Make all my siblings wear the same costume that I am wearing."	| aPlayer |	(aPlayer _ self topRendererOrSelf player) belongsToUniClass ifFalse: [self error: 'not uniclass'].	aPlayer class allInstancesDo:		[:anInstance | anInstance == aPlayer ifFalse:			[anInstance wearCostumeOf: aPlayer]]! !!CompoundTileMorph methodsFor: 'miscellaneous' stamp: 'sw 1/20/2001 00:30'!tileRows	"Answer a list of tile rows, in this case just one though it's compound"	^ Array with: (Array with: self fullCopyWithoutFormerOwner)! !!Morph class methodsFor: 'scripting' stamp: 'sw 1/31/2001 01:24'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #(		(#basic (			(slot x 'The x coordinate' number readWrite player getX player setX:)			(slot y  	'The y coordinate' number readWrite	player 	getY player setY:)			(slot heading  'Which direction the object is facing.  0 is straight up' number readWrite player getHeading player setHeading:)			(command forward: 'Moves the object forward in the direction it is heading' number)			(command turn: 'Change the heading of the object by the specified amount' number)			(command beep: 'Make the specified sound' sound)))		"note: if you change the thing below you also need to change #tileScriptCommands."		(#scripts (			(command emptyScript 'an empty script'))		)		(#'color & border' (			(slot color 'The color of the object' color readWrite player getColor  player  setColor:)			(slot colorUnder 'The color under the center of the object' color readOnly player getColorUnder unused  unused )			(slot luminanceUnder 'The luminance under the center of the object' number readOnly player getLuminanceUnder unused unused)			(slot saturationUnder 'The saturation under the center of the object' number readOnly player getSaturationUnder unused unused)			(slot brightnessUnder 'The brightness under the center of the object' number readOnly player getBrightnessUnder unused unused)			(slot borderColor 'The color of the object''s border' color readWrite player getBorderColor player  setBorderColor:)			(slot borderWidth 'The width of the object''s border' number readWrite player getBorderWidth player setBorderWidth:)			(slot roundedCorners 'Whether corners should be rounded' boolean readWrite player getRoundedCorners player setRoundedCorners:)))		(geometry (			(slot  scaleFactor 'Yeah, the scale factor' number readWrite player getScaleFactor player setScaleFactor:)			(slot  left   'The left edge, yeah' number readWrite player getLeft  player  setLeft:)			(slot right  'The right edge, yeah' number readWrite player getRight  player  setRight:)			(slot  top  'The top edge' number readWrite player getTop  player  setTop:) 			(slot  bottom  'The bottom edge' number readWrite player getBottom  player  setBottom:) 			(slot  width  'The width' number readWrite player getWidth  player  setWidth:)			(slot  height  'The height' number readWrite player getHeight  player  setHeight:) 			(slot x   'The x coordinate' number readWrite player  getX   player setX:)			(slot y   'The y coordinate' number readWrite player  getY  player setY:)			(slot heading  'Which direction the object is facing.  0 is straight up' number readWrite player getHeading  player setHeading:)))		(miscellaneous (			(command doMenuItem: 'do the menu item' menu) 			(command show 'show the guy')			(command hide 'hide the guy')			(command wearCostumeOf: 'wear the costume of...' player)			(command startScript: 'start the given script ticking' string)			(command stopScript: 'make the given script be "normal"' string)			(command pauseScript: 'make the given script be "paused"' string)			(command tellAllSiblings: 'send a message to all siblings' string)			(slot copy 'returns a copy of this object' player readOnly player getNewClone	 unused unused)			(slot elementNumber 'my index in my container' number readWrite player getIndexInOwner player setIndexInOwner:)))		(motion (			(slot x 'The x coordinate' number readWrite player getX player setX:)			(slot y  	'The y coordinate' number readWrite	player 	getY player setY:)			(slot heading  'Which direction the object is facing.  0 is straight up' number readWrite player getHeading player setHeading:)			(command forward: 'Moves the object forward in the direction it is heading' number)			(slot obtrudes 'whether the object sticks out over its container''s edge' boolean readOnly player getObtrudes unused unused) 			(command moveToward: 'move toward the given object' player) 			(command turn: 'Change the heading of the object by the specified amount' number)			(command bounce: 'bounce off the edge if hit' sound) 			(command wrap 'wrap off the edge if appropriate') 			(command followPath 'follow the yellow brick road') 			(command goToRightOf: 'place this object to the right of another' player)))		(#'pen use' (			(slot penColor 'the color of ink used by the pen' color readWrite player getPenColor player setPenColor:) 			(slot penSize 'the width of the pen' number readWrite player getPenSize player setPenSize:) 			(slot penDown 'whether the pen is currently down' boolean readWrite player getPenDown player setPenDown:)))		(#tests (			(slot isOverColor 'whether any part of the object is over the given color' boolean	readOnly player seesColor: unused unused) 			(slot isUnderMouse 'whether the object is under the current mouse position' boolean readOnly	player getIsUnderMouse unused unused)			(slot colorSees	'whether the given color sees the given color' boolean readOnly	player color:sees:	unused	unused)			(slot touchesA	'whether I touch something that looks like...' boolean readOnly player touchesA:	unused	unused)			(slot obtrudes 'whether the object sticks out over its container''s edge' boolean readOnly player getObtrudes unused unused))))! !!Morph class methodsFor: 'scripting' stamp: 'sw 1/30/2001 14:30'!helpContributions	"Answer a list of pairs of the form (<symbol> <help message> ) to contribute to the system help dictionary"	"NB: Many of the items here are not needed any more since they're specified as part of command definitions now.  Someone needs to take the time to go through the list and remove items no longer needed.  But who's got that kind of time?"	^ #(		(acceptScript:for:			'submit the contents of the given script editor as the code defining the given selector')		(actorState			'return the ActorState object for the receiver, creating it if necessary')		(addInstanceVariable			'start the interaction for adding a new instance variable to the receiver')		(addPlayerMenuItemsTo:hand:			'add player-specific menu items to the given menu, on behalf of the given hand.  At present, these are only commands relating to the turtle')		(addYesNoToHand			'Press here to tear off a  TEST/YES/NO unit which you can drop into your script')		(allScriptEditors			'answer a list off the extant ScriptEditors for the receiver')		(amount			'The amount of displacement')		(angle				'The angular displacement')		(anonymousScriptEditorFor:			'answer a new ScriptEditor object to serve as the place for scripting an anonymous (unnamed, unsaved) script for the receiver')		(append:			'add an object to this container')		(assignDecrGetter:setter:amt:			'evaluate the decrement variant of assignment')		(assignGetter:setter:amt:			'evaluate the vanilla variant of assignment')		(assignIncrGetter:setter:amt:			'evalute the increment version of assignment')		(assignMultGetter:setter:amt:			'evaluate the multiplicative version of assignment')		(assureEventHandlerRepresentsStatus			'make certain that the event handler associated with my current costume is set up to conform to my current script-status')		(assureExternalName			'If I do not currently have an external name assigned, get one now')		(assureUniClass			'make certain that I am a member a uniclass (i.e. a unique subclass); if I am not, create one now and become me into an instance of it')		(availableCostumeNames			'answer a list of strings representing the names of all costumes currently available for me')		(availableCostumesForArrows			'answer a list of actual, instantiated costumes for me, which can be cycled through as the user hits a next-costume or previous-costume button in a viewer')		(beep:			'make the specified sound')		(borderColor			'The color of the object''s border')		(borderWidth			'The width of the object''s border')		(bottom			'My bottom edge, measured downward from the top edge of the world')		(bounce:			'If object strayed beyond the boundaries of its container, make it reflect back into it, making the specified noise while doing so.')		(bounce			'If object strayed beyond the boundaries of its container, make it reflect back into it')		(chooseTrigger'When this script should run."normal" means "only when called"')		(clearTurtleTrails			'Clear all the pen trails in the interior.')		(color				'The object''s interior color')		(colorSees			'Whether a given color in the object is over another given color')		(colorUnder			'The color under the center of the object')		(copy			'Return a new object that is very much like this one')		(cursor				'The index of the chosen element')		(deleteCard			'Delete the current card.')		(dismiss			'Click here to dismiss me')		(elementNumber			'My element number as seen by my owner')		(firstPage			'Go to first page of book')		(followPath				'Retrace the path the object has memorized, if any.')		(forward:			'Moves the object forward in the direction it is heading') 		(goto:			'Go to the specfied book page')		(goToNextCardInStack			'Go to the next card')		(goToPreviousCardInStack			'Go to the previous card.')		(goToRightOf:			'Align the object just to the right of any specified object.')		(heading			'Which direction the object is facing.  0 is straight up') 		(height				'The distance between the top and bottom edges of the object')		(hide			'Make the object so that it does not display and cannot handle input')		(initiatePainting				'Initiate painting of a new object in the standard playfield.')		(initiatePaintingIn:			'Initiate painting of a new object in the given place.')		(isOverColor			'Whether any part of this object is directly over the specified color')		(isUnderMouse			'Whether any part of this object is beneath the current mouse-cursor position')		(lastPage			'Go to the last page of the book.')		(left			'My left edge, measured from the left edge of the World')		(leftRight			'The horizontal displacement')		(liftAllPens			'Lift the pens on all the objects in my interior.')		(lowerAllPens			'Lower the pens on all the objects in my interior.')		(mouseX			'The x coordinate of the mouse pointer')		(mouseY			'The y coordinate of the mouse pointer')		(moveToward:			'Move in the direction of another object.')		(insertCard			'Create a new card.')		(nextPage			'Go to next page.')		(numberAtCursor			'The number held by the object at the chosen element')		(objectNameInHalo			'Object''s name -- To change: click here, edit, hit ENTER')		(obtrudes			'Whether any part of the object sticks out beyond its container''s borders')		(offerScriptorMenu			'Scriptee and script name.Press to get a menu')		(pauseScript:			'Make a running script become paused.')		(penDown			'Whether the object''s pen is down (true) or up (false)')		(penColor			'The color of the object''s pen')		(penSize				'The size of the object''s pen')		(playerSeeingColorPhrase			'The player who "sees" a given color')		(previousPage			'Go to previous page')		(show			'If object was hidden, make it show itself again.')		(startScript:			'Make a script start running.')		(stopScript:			'Make a script stop running.')		(top			'My top edge, measured downward from the top edge of the world')		(right			'My right edge, measured from the left edge of the world')		(roundUpStrays			'Bring all out-of-container subparts back into view.')		(scaleFactor			'The amount by which the object is scaled')		(stopScript:			'make the specified script stop running')		(tellAllSiblings:			'send a message to all of my sibling instances')		(try			'Run this command once.')		(tryMe			'Click here to run this script once; hold button down to run repeatedly')		(turn:							'Change the heading of the object by the specified amount')		(unhideHiddenObjects			'Unhide all hidden objects.')		(upDown			'The vertical displacement')		(userScript			'This is a script defined by you.')		(userSlot			'This is an instance variable defined by you.  Click here to change its type')		(valueAtCursor			'The chosen element')		(wearCostumeOf:			'Wear the same kind of costume as the other object')		(width				'The distance between the left and right edges of the object')		(wrap			'If object has strayed beond the boundaries of its container, make it reappear from the opposite edge.')		(x			'The x coordinate, measured from the left of the container')		(y			'The y-coordinate, measured upward from the bottom of the container')		)! !!ObjectWithDocumentation methodsFor: 'documentation' stamp: 'sw 12/1/2000 22:34'!documentation	"Answer the receiver's documentation"	^ documentation ifNil: ['no documentation available, sorry']! !!ObjectWithDocumentation methodsFor: 'documentation' stamp: 'sw 12/1/2000 22:34'!documentation: maneno	"Set the receiver's documentation"	documentation _ maneno! !!ObjectWithDocumentation methodsFor: 'documentation' stamp: 'sw 1/26/2001 16:15'!documentationOrNil	"Answer the contents of the receiver's documentation slot"	^ documentation! !!ObjectWithDocumentation methodsFor: 'documentation' stamp: 'sw 1/26/2001 16:57'!editDescription	"Allow the user to see and edit the documentation for this object"	| reply |	reply _ FillInTheBlank		multiLineRequest: 'Kindly edit the description'		centerAt: Sensor cursorPoint		initialAnswer: self documentation		answerHeight: 200.	reply ifNil: [^ self].  "User cancelled out of the dialog"	reply isEmptyOrNil ifFalse: [self documentation: reply]! !!ObjectWithDocumentation methodsFor: 'documentation' stamp: 'sw 1/29/2001 09:28'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	authoringStamp _ Utilities changeStampPerSe! !!MethodInterface methodsFor: 'attribute keywords' stamp: 'sw 1/26/2001 16:31'!attributeKeywords	"Answer a list of attribute keywords associated with the receiver"	^ attributeKeywords ifNil: [attributeKeywords _ OrderedCollection new]! !!MethodInterface methodsFor: 'attribute keywords' stamp: 'sw 1/26/2001 16:32'!flagAttribute: aSymbol	"Mark the receiver as having the given category-keyword"	(self attributeKeywords includes: aSymbol) ifFalse: [attributeKeywords add: aSymbol]! !!MethodInterface methodsFor: 'attribute keywords' stamp: 'sw 1/26/2001 16:33'!flagAttributes: attributeSymbolList	"Mark the receiver has being flagged with all the symbols in the list provided"	attributeSymbolList do: [:aSym | self flagAttribute: aSym]! !!MethodInterface methodsFor: 'attribute keywords' stamp: 'sw 1/26/2001 16:34'!isFlaggedAs: aSymbol	"Answer whether the receiver is flagged with the given trait"	^ self attributeKeywords includes: aSymbol! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 1/26/2001 16:46'!initialize	"Initialize the receiver"	super initialize.	attributeKeywords _ OrderedCollection new.	defaultStatus _ #normal.	defaultFiresPerTick _ 1.! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 1/26/2001 16:39'!initializeFor: aSelector	"Initialize the receiver to have the given selector"	selector _ aSelector.	attributeKeywords _ OrderedCollection new.	defaultStatus _ #normal.	defaultFiresPerTick _ 1.! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 1/26/2001 23:20'!initializeFromEToyCommandSpec: tuple category: aCategorySymbol	"tuple holds an old etoy command-item spec, of the form found in #additionsToViewerCategories methods.   Initialize the receiver to hold the same information"	selector _ tuple second.	self documentation: tuple third.	aCategorySymbol ifNotNil: [self flagAttribute: aCategorySymbol].	tuple size > 3 ifTrue:		[argumentSpecifications _ OrderedCollection with:			(Variable new variableType: tuple fourth)]	! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 1/30/2001 20:14'!initializeFromEToySlotSpec: tuple	"tuple holds an old etoyslot-item spec, of the form found in #additionsToViewerCategories methodds.   Initialize the receiver to hold the same information"	| setter |	selector _ tuple seventh.	self documentation: tuple third.	resultSpecification _ ResultSpecification new.	resultSpecification resultType: tuple fourth.	((tuple fifth == #readWrite) and: [((tuple size >= 9) and: [(setter _ tuple at: 9) ~~ #unused])]) ifTrue:		[resultSpecification companionSetterSelector: setter].		"slot amount 'The amount of displacement' number readOnly player getAmount unused unused"	! !!MethodInterface methodsFor: 'access' stamp: 'sw 1/23/2001 18:37'!selector	"Answer the receiver's selector"	^ selector! !!MethodInterface methodsFor: 'status' stamp: 'sw 1/23/2001 17:16'!defaultStatus	"Answer the receiver's default defaultStatus"	^ defaultStatus! !!MethodInterface methodsFor: 'status' stamp: 'sw 1/23/2001 17:00'!defaultStatus: aStatus	"Set the receiver's defaultStatus as indicated"	defaultStatus _ aStatus! !!ObjectWithDocumentation class methodsFor: 'instance creation' stamp: 'sw 12/11/2000 15:36'!new	"Create a new instance of the receiver, and initialize it"	^ super new initialize! !!PasteUpMorph methodsFor: 'initialization' stamp: 'sw 1/30/2001 22:45'!newPlayerInstance	"Answer a naked CardPlayer instance given that one does not yet exist; hence, launch a uniclass and answer an instance of it.  cf inherited version."	^ UnscriptedCardPlayer newUserInstance! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 1/12/2001 20:02'!printScriptSummary	"Put up a window with summaries of all scripts in the world"	self presenter reportPlayersAndScripts"self currentWorld printScriptSummary"! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 1/14/2001 03:04'!showStatusOfAllScripts	"Put up a window that shows, and allows you to change, the status of all scripts"	self presenter toolToViewScriptInstantiations! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'sw 1/20/2001 00:30'!tileRows	"Answer a list of tile rows -- in this case exactly one row -- representing the receiver.  The fullCopy is deeply problematical here in the presence of the formerOwner property, so it the latter is temporarily set aside"	^ Array with: (Array with: self fullCopyWithoutFormerOwner)! !!Player methodsFor: 'costume' stamp: 'sw 1/12/2001 22:38'!renderedCostume: aMorph	"Make aMorph be the receiver's rendered costume; if flexing is currently in effect, make the new morph be flexed correspondingly"	| renderedMorph known anEventHandler w |	renderedMorph _ costume renderedMorph.	renderedMorph == aMorph ifTrue: [^ self].	self rememberCostume: renderedMorph.	renderedMorph changed.	w _ renderedMorph world.	"Copy 'player state' (e.g., state which should be associated with the player but is stored in the morph itself these days) from the old rendered morph the new morph."	aMorph rotationStyle: renderedMorph rotationStyle.	aMorph forwardDirection: renderedMorph forwardDirection.	"Note: referencePosition is *not* state but #moveTo: behavior"	aMorph referencePosition: renderedMorph referencePosition.	anEventHandler _ renderedMorph eventHandler.	costume isFlexMorph		ifTrue:			[costume adjustAfter:				[costume replaceSubmorph: renderedMorph by: aMorph]]		ifFalse:			[costume owner ifNotNil: [costume owner replaceSubmorph: costume by: aMorph].			aMorph player: self.			aMorph actorState: costume actorState.			(known _ costume knownName) ifNotNil:				[aMorph setNameTo: known].			costume _ aMorph.			w ifNotNil:				[w stopStepping: renderedMorph.				w startStepping: aMorph]].	aMorph eventHandler: anEventHandler.	aMorph changed! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/30/2001 14:30'!infoFor: anElement inViewer: aViewer	"The user made a gesture asking for info/menu relating"	| aMenu selector reply elementType |	elementType _ self elementTypeFor: anElement.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement inViewer: aViewer].		self flag: #deferred.  "Use a traditional MenuMorph, and reinstate the pacify thing"	aMenu _ MVCMenuMorph new.	aMenu defaultTarget: aMenu.	(elementType == #userScript)		ifTrue: 			[aMenu add: 'destroy "', anElement, '"' selector: #selectMVCItem: argument: #removeScript.			aMenu add: 'rename  "', anElement, '"' selector: #selectMVCItem: argument:  #renameThisScript.			aMenu add: 'textual scripting pane'  selector: #selectMVCItem: argument: #makeIsolatedCodePaneFor.			aMenu add: 'edit balloon help' selector: #selectMVCItem: argument: #editDescription.			"aMenu add: 'pacify "', anElement, '"' action: #pacifyScript"].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: anElement asString, ' (', elementType, ')'.	selector _ anElement asSymbol.	reply _  aMenu invokeAt: aViewer primaryHand position in: aViewer world.	reply == nil ifTrue: [^ self].	reply == #removeScript ifTrue: [^ self removeScript: selector fromWorld: aViewer world].	reply == #renameThisScript ifTrue: [^ self renameScript:  selector].	reply == #makeIsolatedCodePaneFor ifTrue: 		[MethodHolder makeIsolatedCodePaneForClass: self class selector: selector].	reply == #editDescription ifTrue:		[(self class userScriptForPlayer: self selector: selector) editDescription.		self updateAllViewers].	reply == #pacifyScript ifTrue: [^ self pacifyScript: selector]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/29/2001 02:49'!isEmptyTileScript: aScriptName	"Answer the script of the given name is an empty tile script"	| aUserScript |	aUserScript _ self class userScriptForPlayer: self selector: aScriptName.	aUserScript isTextuallyCoded ifTrue:		[^ false].	^ (aUserScript instantiatedScriptEditorForPlayer: self) isEmpty! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/23/2001 11:16'!newScriptEditorFor: aSelector usingPhraseTile: aPhraseTileMorph	"Sprout a scriptor for aSelector, using aPhraseTileMorph as its initial phrase."	| aUserScript aScriptEditor |	(self class selectors includes: aSelector) ifTrue: [self error: 'selector already exists'].	aUserScript _ self class permanentUserScriptFor: aSelector player: self.	aScriptEditor _ aUserScript instantiatedScriptEditor.	aPhraseTileMorph ifNotNil: [aScriptEditor phrase: aPhraseTileMorph].	aScriptEditor install.	aPhraseTileMorph ifNil: [aScriptEditor showSourceInScriptor].	self class allSubInstancesDo: [:anInst | anInst scriptInstantiationForSelector: aUserScript selector].		"The above assures the presence of a ScriptInstantiation for the new selector in all siblings"	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/23/2001 18:36'!newScriptorAround: aPhraseTileMorph	"Sprout a scriptor around aPhraseTileMorph, thus making a new script"	| aScriptEditor aUniclassScript ut tw blk |	aUniclassScript _ self class permanentUserScriptFor: self unusedScriptName player: self.	aScriptEditor _ aUniclassScript instantiatedScriptEditorForPlayer: self.	ut _ costume world valueOfProperty: #universalTiles ifAbsent: [false].	ut ifTrue: [aScriptEditor install.	"to get a default script there"		aScriptEditor useNewTiles.		aPhraseTileMorph ifNotNil:			[tw _ aScriptEditor findA: TwoWayScrollPane.			blk _ tw scroller firstSubmorph "MethodNode" lastSubmorph "BlockNode".			blk addMorphFront: aPhraseTileMorph.			"aPhraseTileMorph position: self topLeft + (7@14)"			aPhraseTileMorph accept]]		ifFalse:			[aPhraseTileMorph 				ifNotNil: [aScriptEditor phrase: aPhraseTileMorph]	"does an install"				ifNil: [aScriptEditor install]].	self class allSubInstancesDo: [:anInst | anInst scriptInstantiationForSelector: aUniclassScript selector].		"The above assures the presence of a ScriptInstantiation for the new selector in all siblings"	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/19/2001 15:12'!pacifyScript: aSymbol	"Make sure the script represented by the symbol doesn't do damage by lingering in related structures on the morph side"	| editor aHandler aUserScript |	aUserScript _ self class userScriptForPlayer: self selector: aSymbol.	aUserScript ifNil: [self flag: #deferred.  ^ self beep].  	"Maddeningly, without this line here the thing IS nil and the debugger is in a bad state	(the above note dates from 1/12/99 ?!!"	editor _ aUserScript instantiatedScriptEditor.	editor scriptInstantiation status: #normal.	self class allInstancesDo:		[:aPlayer | aPlayer actorState instantiatedUserScriptsDictionary removeKey: aSymbol.		(aHandler _ aPlayer costume renderedMorph eventHandler) ifNotNil:			[aHandler forgetDispatchesTo: aSymbol]]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/22/2001 15:19'!renameScript: oldSelector	"The user has asked to rename the script formerly known by oldSelector; obtain a new selector from the user, check it out, and if all is well, ascribe the new name as appropriate"	| reply newSelector aUserScript |	self flag: #deferred.  "Relax the below, yes?"	aUserScript _ self class userScriptForPlayer: self selector: oldSelector.	aUserScript isTextuallyCoded ifTrue:		[self inform: 'Sorry, for now you can only rename tiled scripts'.		^ self].	reply _   FillInTheBlank request: 'Script Name' initialAnswer: oldSelector. 	reply size == 0 ifTrue: [^ self].	reply = oldSelector ifTrue:[^ self beep].	newSelector _ ScriptingSystem acceptableScriptNameFrom: reply  forScriptCurrentlyNamed:  oldSelector asScriptNameIn: self world: costume world.	(self currentWorld hasProperty: #universalTiles) 		ifTrue:			["allow colons"			(reply copyWithout: $:) = newSelector 				ifTrue: [newSelector _ reply asSymbol]				ifFalse: [self inform: 'name will be modified']].		self renameScript: oldSelector newSelector: newSelector! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/30/2001 18:53'!renameScript: oldSelector newSelector: newSelector	"Rename the given script to have the new selector"	|  aUserScript aScriptEditor anInstantiation |	aUserScript _ self class userScriptForPlayer: self selector: oldSelector.	aScriptEditor _ aUserScript instantiatedScriptEditor.	aScriptEditor renameScriptTo: newSelector.	aUserScript bringUpToDate.	self class removeScriptNamed: oldSelector.	self class atSelector: newSelector putScriptEditor: aScriptEditor.	self class allSubInstancesDo:		[:aPlayer |			anInstantiation _ aPlayer scriptInstantiationForSelector: oldSelector.			anInstantiation changeSelectorTo: newSelector.			aPlayer costume actorState instantiatedUserScriptsDictionary				removeKey: oldSelector;				at: newSelector put: anInstantiation.			anInstantiation assureEventHandlerRepresentsStatus].		self updateAllViewersAndForceToShow: 'scripts'! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/30/2001 18:58'!scriptEditorFor: aSelector	"Answer the receiver's script editor for aSelector"	| aScriptEditor |	aScriptEditor _ (self class userScriptForPlayer: self selector: aSelector) instantiatedScriptEditor.	aScriptEditor updateToPlayer: self.	aScriptEditor bringUpToDate.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/29/2001 11:57'!scriptInstantiationForSelector: aSelector	"Answer a script instantiation for the given selector, creating it at this time if necessary"	|  entry scriptDict classEntry |	scriptDict _ self actorState instantiatedUserScriptsDictionary.	entry _ scriptDict at: aSelector ifAbsent: [nil].	entry ifNil:		[classEntry _ self class userScriptForPlayer: self selector: aSelector.		entry _ ScriptInstantiation new player: self selector: aSelector status: classEntry defaultStatus.		scriptDict at: aSelector put: entry].	^ entry! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/19/2001 15:15'!scriptorsForSelector: aSelector inWorld: aWorld	"Answer, for the purpose of deletion, a list of all scriptor objects for the given selector that are associated with any member of the receiver's uniclass"	| scriptors |	aWorld ifNil: [^ OrderedCollection new].	scriptors _ (aWorld allMorphs select:		[:m | (((m isKindOf: ScriptEditorMorph) and: [m playerScripted class == self class]) and: [m scriptName == aSelector])] thenCollect: [:m | m topEditor]) asSet.	^ scriptors asArray! !!Player methodsFor: 'scripts-standard' stamp: 'sw 1/28/2001 16:52'!tellAllSiblings: aMessageSelector	"Send the given message selector to all my sibling instances, but not to myself"	self belongsToUniClass ifTrue:		[(self class allSubInstances copyWithout: self) do:			[:anInstance | anInstance perform: aMessageSelector]]! !!Player methodsFor: 'misc' stamp: 'sw 1/19/2001 15:28'!allOpenViewersOnReceiverAndSiblings	"Answer a list of all the viewers open on the receiver and any of its sibling instances.  Include viewers in closed flaps"	| aWorld all |	(aWorld _ self costume world) ifNil: [^ #()].	all _ aWorld allMorphs.	aWorld closedViewerFlapTabs do:		[:aTab | all addAll: aTab referent allMorphs].	^ all select:		[:m | (m isKindOf: StandardViewer) and: [m scriptedPlayer class == self class]]! !!Player methodsFor: 'misc' stamp: 'sw 1/29/2001 21:57'!grabScriptorForSelector: itsSelector in: aWorld	"Grab the scriptor for the given selector and place it in the hand"	aWorld currentHand attachMorph: (self scriptEditorFor: itsSelector) ! !!Player methodsFor: 'misc' stamp: 'sw 1/19/2001 17:55'!isFlagshipForClass	"Answer whether the receiver is the so-called flagshipInstance for the uniclass.  A dying thing"	self flag: #noteToTed.	"SyntaxMorph has the only remaining call to this; once that's been converted over, this method, and #flagshipInstance as well, can be remobved"	^ self class flagshipInstance == self! !!Player methodsFor: 'misc' stamp: 'sw 1/19/2001 17:44'!openUnderlyingScriptorFor: aSelector	"Open the underlying scriptor for the given selector"	self grabScriptorForSelector: aSelector in: self currentWorld! !!Player methodsFor: 'misc' stamp: 'sw 1/19/2001 15:35'!updateAllViewers	"The receiver's structure has changed, so viewers on it and its siblings need to be reconstituted."	| aPresenter |	(aPresenter _ self costume presenter) ifNil: [^ self].	self allOpenViewersOnReceiverAndSiblings do:		[:aViewer | aPresenter updateViewer: aViewer]! !!Player methodsFor: 'misc' stamp: 'sw 1/19/2001 15:36'!updateAllViewersAndForceToShow: aCategory	"The receiver's structure has changed, so viewers on it and all its siblings need to be reconstituted."	| aPresenter |	(aPresenter _ self costume presenter) ifNil: [^ self].	self allOpenViewersOnReceiverAndSiblings do:		[:aViewer | aPresenter updateViewer: aViewer forceToShow: aCategory]! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 1/23/2001 11:08'!addDocumentationForScriptsTo: aStream	"Add documentation for every script in the receiver to the stream"	self scripts do:		[:aScript |			aScript selector ifNotNil:				[aStream cr; cr.				self printMethodChunk: aScript selector withPreamble: false on: aStream moveSource: false toFile: nil.				aStream position: (aStream position - 2)]].	self scripts size == 0 ifTrue:		[aStream cr; tab; nextPutAll: 'has no scripts']! !!Player class methodsFor: 'scripts' stamp: 'sw 1/23/2001 18:46'!atSelector: aSelector putScriptEditor: aScriptEditor	"Place the given script editor in my directory of script editors, at the given selector"	| selSym  aUniclassScript |	selSym _ aSelector asSymbol.	scripts ifNil: [scripts _ IdentityDictionary new].	aUniclassScript _ scripts at: selSym ifAbsent: [nil].	aUniclassScript ifNil:		[aUniclassScript _ UniclassScript new playerClass: aScriptEditor playerScripted class selector: selSym.		scripts at: selSym put: aUniclassScript].	aUniclassScript currentScriptEditor: aScriptEditor! !!Player class methodsFor: 'scripts' stamp: 'sw 1/23/2001 18:31'!permanentUserScriptFor: aSelector player: aPlayer	"Create and answer a UserScript object for the given player (an instance of the receiver) and selector.  Save that UniclassScript in my (i.e. the class's) directory of scripts"	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	entry _ UniclassScript new playerClass: aPlayer class selector: aSelector.	scripts at: aSelector put: entry.	^ entry! !!Player class methodsFor: 'scripts' stamp: 'sw 1/25/2001 10:29'!userScriptForPlayer: aPlayer selector: aSelector	"Answer the user script for the player (one copy for all instances of the uniclass) and selector"	|  entry existingEntry |	scripts ifNil: [scripts _ IdentityDictionary new].	existingEntry _ scripts at: aSelector ifAbsent: [nil].	(existingEntry isKindOf: UniclassScript)		ifFalse:			[entry _ UniclassScript new playerClass: aPlayer class selector: aSelector.			scripts at: aSelector put: entry.			existingEntry ifNotNil: "means it is a grandfathered UserScript that needs conversion"				[entry convertFromUserScript: existingEntry]]		ifTrue:			[entry _ existingEntry].	^ entry! !!Presenter methodsFor: 'playerList' stamp: 'sw 1/12/2001 16:58'!allPlayersWithUniclasses	"Answer a list of all players known to the receiver that have uniclasses"	^ self allExtantPlayers select: [:p | p belongsToUniClass]! !!Presenter methodsFor: 'playerList' stamp: 'sw 1/23/2001 11:11'!reportPlayersAndScripts	"Open a window which contains a report on players and their scripts"	| aList aString |	(aList _ self uniclassesAndCounts) size == 0 ifTrue: [^ self inform: 'there are no scripted players'].	aString _ String streamContents:		[:aStream |			aList do:				[:aPair | aStream nextPutAll: aPair first name, ' -- ', aPair second printString, ' instance',		(aPair second > 1 ifTrue: ['s'] ifFalse: ['']) , ', named '.					aPair first allInstancesDo: [:inst | aStream space; nextPutAll: inst externalName].					aStream cr].			aStream cr.			aList do:				[:aPair |					aStream cr.					aStream nextPutAll: '--------------------------------------------------------------------------------------------'.					aStream cr; nextPutAll: aPair first name.					aPair first addDocumentationForScriptsTo: aStream]].	(StringHolder new contents: aString)		openLabel: 'All scripts of all players in this world'"self currentWorld presenter reportPlayersAndScripts"! !!Presenter methodsFor: 'playerList' stamp: 'sw 1/12/2001 18:10'!uniclassesAndCounts	"Answer a list of all players known to the receiver that have uniclasses"	^ (self allPlayersWithUniclasses collect: [:aPlayer | aPlayer class]) asSet asArray collect:		[:aClass | Array			with:	aClass			with:	aClass instanceCount]	"self currentWorld presenter uniclassesAndCounts"! !!ScriptActivationButton methodsFor: 'as yet unclassified' stamp: 'sw 1/19/2001 18:27'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand.  To avoid a nasty inheritance problem, this method does NOT call super"	aCustomMenu addUpdating: #hasDragAndDropEnabledString action: #changeDragAndDrop.	aCustomMenu add: 'put in a window' action: #embedInWindow.	aCustomMenu addUpdating: #stickinessString target: self action: #toggleStickiness.	aCustomMenu add: 'adhere to edge...' action: #adhereToEdge.	aCustomMenu addList: 			#(('border color...' changeBorderColor:)			('border width...' changeBorderWidth:)).	aCustomMenu addUpdating: #roundedCornersString target: self action: #toggleCornerRounding.	borderColor == #raised ifFalse: [aCustomMenu add: 'raised bevel' action: #borderRaised].	borderColor == #inset ifFalse: [aCustomMenu add: 'inset bevel' action: #borderInset].	self addLabelItemsTo: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'open underlying scriptor' target: target selector: #openUnderlyingScriptorFor: argument: arguments first! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 1/19/2001 18:13'!updateToPlayer: newPlayer	"Make certain that the script name and the names of actors within are up to date"	| currentName titleMorph |	playerScripted ifNil: ["likely a naked test/yes/no fragment!!" ^ self].	newPlayer == playerScripted ifTrue: [^ self].  "Already points to him"	self allMorphs do:		[:m | (m isKindOf: TileMorph) ifTrue:			[m retargetFrom: playerScripted to: newPlayer.			m bringUpToDate]].	playerScripted _ newPlayer.	currentName _ playerScripted externalName.	submorphs size = 0 ifTrue: [^ self].	self firstSubmorph "align" submorphsDo: [:m | "try quick way"				m knownName = 'title' ifTrue: [titleMorph _ m]].	titleMorph ifNil:		[titleMorph _ self firstSubmorph findDeepSubmorphThat: [:m | m knownName = 'title'] 								ifAbsent: [nil]].	titleMorph ifNotNil:		[titleMorph label: currentName, ' ', self scriptName font: ScriptingSystem fontForTiles]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/23/2001 10:53'!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"		self presentScriptStatusPopUp! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/30/2001 14:29'!editMethodDescription	"Edit the balloon help associated with the script"	self userScriptObject editDescription! !!ScriptEditorMorph methodsFor: 'save & revert' stamp: 'sw 1/30/2001 12:18'!savedTileVersionsCount	"Answer the number of saved tile versions that currently exist for this script"	^ self userScriptObject savedTileVersionsCount! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/30/2001 13:34'!becomeTextuallyCoded	"If the receiver is not currently textually coded, make it become so now, and show its source in place in the Scriptor"	self isTextuallyCoded ifTrue: [^ self].	self saveScriptVersion.	self userScriptObject becomeTextuallyCoded.	(submorphs copyFrom: 2 to: submorphs size) do: [:m | m delete]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/30/2001 12:15'!modernize	"If the receiver appears to date from the past, try to fix it up"		(self isTextuallyCoded and: [self showingMethodPane not]) ifTrue:		["Fix up old guys that  are not showing the code in place"		self showSourceInScriptor]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/30/2001 18:23'!offerScriptorMenu	"Put up a menu in response to the user's clicking in the menu-request area of the scriptor's heaer"	| aMenu  count |	self modernize.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: scriptName asString.	count _ self savedTileVersionsCount.	self showingMethodPane		ifFalse:				"currently showing tiles"			[aMenu add: 'show code textually' action: #showSourceInScriptor.			count > 0 ifTrue: 				[aMenu add: 'revert to tile version...' action:	 #revertScriptVersion].			aMenu add: 'save this version'	action: #saveScriptVersion]		ifTrue:				"current showing textual source"			[count >= 1 ifTrue:				[aMenu add: 'revert to tile version' action: #revertToTileVersion].			aMenu add: 'make tiles from this code' action: #recreateTileVersion].	Preferences noviceMode ifFalse: ["just for now, not for kids"		aMenu add: 'use new universal tiles' action: #useNewTiles].				aMenu addList: #(		-		('destroy this script'					destroyScript)		('rename this script'					renameScript)		-		('fires per tick...'					chooseFrequency)		('explain status alternatives' 		explainStatusAlternatives)		('hand me a tile for self'			tileForSelf)		('edit balloon help for this script'	editMethodDescription)		('button to fire this script'			tearOfButtonToFireScript)		 ).	aMenu popUpInWorld: self currentWorld.	"		('add parameter to this script'	addParameter)"! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/30/2001 18:56'!reinsertSavedTiles: savedTiles	"Revert the scriptor to show the saved tiles"	self submorphs doWithIndex: [:m :i | i > 1 ifTrue: [m delete]].	self addAllMorphs: savedTiles.	self allMorphsDo: [:m | m isTileScriptingElement ifTrue: [m bringUpToDate]].	self install.	self showingMethodPane: false! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/22/2001 15:22'!renameScript	"Rename the current script.  Invoked at user menu request"	playerScripted renameScript: self scriptName! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/22/2001 15:45'!renameScriptTo: newSelector	"Rename the receiver's script so that it has given new selector"	| labelButton |	scriptName _ newSelector.	labelButton _ self firstSubmorph submorphs seventh.	labelButton label: (playerScripted externalName, ' ', self scriptTitle) font: Preferences standardButtonFont.	self install! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/30/2001 18:27'!tileForSelf	"Return a tile representing the player who is current the 'self' of this script"	| aTileMorph |	aTileMorph _ TileMorph new		setObjectRef: nil "disused parm" actualObject: playerScripted;		typeColor: (ScriptingSystem colorForType: #player); yourself.	aTileMorph enforceTileColorPolicy.	aTileMorph openInHand! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 1/28/2001 16:06'!changeSelectorTo: aNewSelector	"Change the selector associated with the receiver to the new one provided"	selector _ aNewSelector! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 1/15/2001 01:28'!assignStatusToAllSiblings	"Let all sibling instances of my player have the same status that I do"	(player class allInstances copyWithout: player) do:		[:aPlayer |			(aPlayer scriptInstantiationForSelector: selector) status: status]! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 1/15/2001 01:58'!assignStatusToAllSiblingsIn: aStatusViewer	"Let all sibling instances of my player have the same status that I do"	self assignStatusToAllSiblings.	self currentWorld presenter updateContentsFor: aStatusViewer ! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 1/19/2001 02:32'!offerMenuIn: aStatusViewer	"Put up a menu."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	(player class instanceCount > 1) ifTrue:		[aMenu add: 'propagate status to siblings' selector: #assignStatusToAllSiblingsIn: argument: aStatusViewer.		aMenu balloonTextForLastItem: 'Make the status of this script in all of my sibling instances be the same as the status you see here'].	aMenu add: 'grab this object' target: player selector: #grabPlayerIn: argument: self currentWorld.	aMenu add: 'open this script''s scriptor' target: player selector: #grabScriptorForSelector:in: argumentList: {selector. aStatusViewer world}.	aMenu popUpInWorld: self currentWorld! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 1/19/2001 17:45'!playersExternalName	"Answer the external name of my player"	^ player externalName! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 1/29/2001 02:51'!printOn: aStream	"Print the receiver on aStream"	super printOn: aStream.	aStream nextPutAll: ' for #', selector asString! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 1/15/2001 19:33'!statusControlRowIn: aStatusViewer	"Answer a row morph that reports my status and lets the user change it"	| aRow aMorph buttonWithPlayerName |	aRow _ AlignmentMorph newRow beTransparent.	buttonWithPlayerName _ UpdatingSimpleButtonMorph new.	buttonWithPlayerName target: self; wordingSelector: #playersExternalName; actionSelector: #offerMenuIn:; arguments: {aStatusViewer}; beTransparent; actWhen: #buttonDown.	buttonWithPlayerName setBalloonText: 'This is the name of the player to which this script belongs; if you click here, you will get a menu of interesting options pertaining to this player and script'.	aRow addMorphBack: buttonWithPlayerName.	aRow addTransparentSpacerOfSize: 10@0.	aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.	aMorph _ UpdatingStringMorph on: self selector: #selector.	aMorph color: Color brown lighter; useStringFormat.	aMorph setBalloonText: 'This is the name of a script'.	aRow addMorphBack: aMorph.	aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.	aRow addTransparentSpacerOfSize: 10@0.	aRow addMorphBack: self statusControlMorph.	aRow submorphsDo: [:m | m wantsSteps ifTrue: [m step]].	^ aRow! !!ScriptInstantiation methodsFor: 'status control' stamp: 'sw 1/23/2001 10:59'!presentScriptStatusPopUp	"Put up a menu of status alternatives and carry out the request"	| aMenu reply standardStati  m |	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging opening closing "keyStroke").	aMenu _ SelectionMenu labelList:  #(		'normal'		" -- run when called"				'paused' 		"ready to run all the time"		'ticking'		"run all the time"		'mouseDown'	"run when mouse goes down on me"		'mouseStillDown'	"while mouse still down"		'mouseUp'		"when mouse comes back up"		'mouseEnter'	"when mouse enters my bounds, button up"		'mouseLeave'	"when mouse exits my bounds, button up"		'mouseEnterDragging'	"when mouse enters my bounds, button down"		'mouseLeaveDragging'	"when mouse exits my bounds, button down"		'opening'	"when I am being opened"		'closing'	"when I am being closed"	"	'keyStroke'	run when user hits a key"		'what do these mean?'		'apply my status to all siblings'		)		lines: #(1 3 6 10 12 13)		selections: (standardStati, #(explainStatusAlternatives assignStatusToAllSiblings)).	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply == #explainStatusAlternatives ifTrue: [^ self explainStatusAlternatives].	reply == #assignStatusToAllSiblings ifTrue: [^ self assignStatusToAllSiblings].	reply ifNotNil: 		[self status: reply.  "Gets event handlers fixed up"		reply == #paused ifTrue:			[m _ player costume.			(m isKindOf: SpeakerMorph) ifTrue: [m stopSound]].		self updateAllStatusMorphs]! !!ScriptStatusControl methodsFor: 'initialization' stamp: 'sw 1/23/2001 10:54'!initializeFor: aScriptInstantiation	"Answer a control that will serve to reflect and allow the user to change the status of the receiver"	|  statusReadout |	self hResizing: #shrinkWrap.	scriptInstantiation _ aScriptInstantiation.	tickPauseButtonsShowing _ false.	tickPauseWrapper _ AlignmentMorph newColumn beTransparent; yourself.	self addMorphBack: tickPauseWrapper.	self addMorphBack: (statusReadout _ UpdatingSimpleButtonMorph new).	statusReadout setNameTo: 'trigger'.	statusReadout target: aScriptInstantiation; wordingSelector: #status; actionSelector: #presentScriptStatusPopUp.	statusReadout setBalloonText: 'when this script should run'.	statusReadout actWhen: #buttonDown.	self assurePauseTickControlsShow.	aScriptInstantiation updateStatusMorph: self! !!StandardScriptingSystem methodsFor: 'script-control' stamp: 'sw 1/23/2001 11:39'!scriptControlButtons	"Answer a composite object that serves to control the stop/stop/go status of a Presenter"	| wrapper |	wrapper _ AlignmentMorph newRow setNameTo: 'script controls'.	wrapper vResizing: #shrinkWrap.	wrapper hResizing: #shrinkWrap.	wrapper addMorph: self stopButton.	wrapper addMorphBack: self stepButton.	wrapper addMorphBack: self goButton.	wrapper beTransparent.	^ wrapper! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'sw 1/19/2001 17:48'!morphToDropInPasteUp: aPasteUp	"If property #beScript is true, create a scriptor around me."	| actualObject itsSelector aScriptor anEditor adjustment handy tw blk |	self flag: #noteToTed.  "I changed PhraseTileMorph's version of this method to eliminate the flagshipInstance annoyance, and the below needs to be changed accordingly -- look at my method and notice diffs.  Besides eliminating the flagshipInstance test, one needs to be sure that the thing dropped is adjusted to reflect which instance of the uniclass is at hand.  sw 1/19/2001 02:30"	(self valueOfProperty: #beScript ifAbsent: [false]) ifFalse: [^ self].	self removeProperty: #beScript.	(actualObject _ self actualObject) ifNil: [^ self].	actualObject assureUniClass.	itsSelector _ self userScriptSelector.	aScriptor _ (itsSelector ~~ nil and: [itsSelector size > 0])		ifTrue:	"user script"			[actualObject isFlagshipForClass				ifFalse: 					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: self.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					[(aPasteUp world valueOfProperty: #universalTiles ifAbsent: [false]) not &					(actualObject class userScriptForPlayer: actualObject selector: itsSelector) 						isTextuallyCoded ifTrue:							[^ aPasteUp scriptorForTextualScript: itsSelector ofPlayer: actualObject].					adjustment _ 0@0.					aScriptor _ actualObject scriptEditorFor: itsSelector]]		ifFalse:			["It's a system-defined selector; construct an anonymous scriptor around it"			itsSelector _ nil.			adjustment _ 60 @ 20.			actualObject newScriptorAround: self].	handy _ aPasteUp primaryHand.	aScriptor ifNotNil: [		aScriptor position: handy position - adjustment.		aPasteUp addMorphFront: aScriptor.	"do this early so can find World"		(tw _ aScriptor findA: TwoWayScrollPane) ifNil: [			aScriptor useNewTiles.			itsSelector ifNil: ["blank script"				tw _ aScriptor findA: TwoWayScrollPane.				blk _ tw scroller firstSubmorph "MethodNode" lastSubmorph "BlockNode".				blk addMorphFront: self.				"self position: self topLeft + (7@14)"]]].	aScriptor showSourceInScriptor. 	(aScriptor isKindOf: ScriptEditorMorph) ifTrue:		[aScriptor playerScripted expungeEmptyUnRenamedScripts].	^ aScriptor ifNil: [self]! !!UniclassScript methodsFor: 'initialization' stamp: 'sw 1/30/2001 11:37'!convertFromUserScript: aUserScript	"The argument represents an old UserScript object.  convert it over"	defaultStatus _ aUserScript status.	isTextuallyCoded _ aUserScript isTextuallyCoded.	currentScriptEditor _ aUserScript currentScriptEditor.	formerScriptingTiles _  aUserScript formerScriptEditors ifNotNil:		[aUserScript formerScriptEditors collect:			[:aScriptEditor |				Array with: aScriptEditor timeStamp with: aScriptEditor submorphs allButFirst]]! !!UniclassScript methodsFor: 'initialization' stamp: 'sw 1/26/2001 16:44'!initialize	"Initialize the receiver by setting its inst vars to default values"	super initialize.	isTextuallyCoded _ false! !!UniclassScript methodsFor: 'initialization' stamp: 'sw 1/23/2001 18:28'!playerClass: aPlayerClass selector: aSelector	"Set the playerClass and selector of the receiver"	playerClass _ aPlayerClass.	selector _ aSelector! !!UniclassScript methodsFor: 'script editor' stamp: 'sw 1/30/2001 20:08'!bringUpToDate	"Bring all versions of the receiver's tile-script source up to date"	currentScriptEditor ifNotNil: [currentScriptEditor bringUpToDate].	formerScriptingTiles isEmptyOrNil ifFalse:		[formerScriptingTiles do:			[:aPair | aPair second do:				[:aMorph | (aMorph allMorphs select: [:s | s isTileScriptingElement]) do:					[:el | el bringUpToDate]]]]! !!UniclassScript methodsFor: 'script editor' stamp: 'sw 1/23/2001 17:12'!currentScriptEditor: anEditor	"Set the receiver's currentScriptEditor as indicated"	currentScriptEditor _ anEditor! !!UniclassScript methodsFor: 'script editor' stamp: 'sw 1/30/2001 14:50'!instantiatedScriptEditor	"Return the current script editor, creating it if necessary"	| aPlayer |	currentScriptEditor ifNil:		[aPlayer _ playerClass someInstance.		currentScriptEditor _ ScriptEditorMorph new				setMorph: aPlayer costume				scriptName: selector.		self isTextuallyCoded ifTrue:			[currentScriptEditor showSourceInScriptor].		defaultStatus == #ticking ifTrue:			[aPlayer costume arrangeToStartStepping]].		^ currentScriptEditor! !!UniclassScript methodsFor: 'script editor' stamp: 'sw 1/29/2001 22:02'!instantiatedScriptEditorForPlayer: aPlayer	"Return the current script editor, creating it if necessary"	currentScriptEditor ifNil:		[currentScriptEditor _ (playerClass includesSelector: selector) 			ifTrue: [ScriptEditorMorph new 				fromExistingMethod: selector 				forPlayer: aPlayer]			ifFalse: [ScriptEditorMorph new				setMorph: aPlayer costume				scriptName: selector].		defaultStatus == #ticking ifTrue:			[aPlayer costume arrangeToStartStepping]].		^ currentScriptEditor! !!UniclassScript methodsFor: 'script editor' stamp: 'sw 1/30/2001 13:05'!releaseCachedState	"release all non-showing scriptors.  What do we do about versions????"	self isTextuallyCoded ifTrue:		[formerScriptingTiles _ OrderedCollection new].	currentScriptEditor ifNil: [^ self].	true ifTrue: [^ self].	"<<< to test the reconstruction of scripts, change to false"	currentScriptEditor world ifNil: ["not showing"		currentScriptEditor _ nil]! !!UniclassScript methodsFor: 'textually coded' stamp: 'sw 1/30/2001 14:47'!becomeTextuallyCoded	"Transform the receiver into one which is textually coded"	isTextuallyCoded _ true! !!UniclassScript methodsFor: 'textually coded' stamp: 'sw 1/23/2001 17:14'!isTextuallyCoded	"Answer whether the receiver is textually coded"	^ isTextuallyCoded! !!UniclassScript methodsFor: 'versions' stamp: 'sw 1/30/2001 13:39'!revertScriptVersionFrom: anEditor	"Let user choose which prior tile version to revert to, and revert to it"	| aMenu chosenStampAndTileList |	formerScriptingTiles isEmptyOrNil ifTrue: [^ self beep].	formerScriptingTiles size == 1		ifTrue:			[chosenStampAndTileList _ formerScriptingTiles first]		ifFalse:			[aMenu _ SelectionMenu labelList: (formerScriptingTiles collect: [:e | e first])				selections: formerScriptingTiles.			chosenStampAndTileList _ aMenu startUp].	chosenStampAndTileList ifNotNil:		[anEditor reinsertSavedTiles: chosenStampAndTileList second.		isTextuallyCoded _ false]! !!UniclassScript methodsFor: 'versions' stamp: 'sw 1/30/2001 13:38'!revertToLastSavedTileVersionFor: anEditor	"revert to the last saved tile version"	formerScriptingTiles isEmptyOrNil ifFalse:		[anEditor reinsertSavedTiles: formerScriptingTiles last second].	isTextuallyCoded _ false! !!UniclassScript methodsFor: 'versions' stamp: 'sw 1/30/2001 13:03'!saveScriptVersion: timeStamp	"Save the tile script version by appending a pair of the form		<time stamp>     <morph list>to my list of former scripting tiles.  The morph-list will get copied back into the Scriptor following restoration."	((currentScriptEditor notNil and: [currentScriptEditor showingMethodPane not]) and:		[currentScriptEditor submorphs size > 1]) ifTrue:			[formerScriptingTiles ifNil: [formerScriptingTiles _ OrderedCollection new].			formerScriptingTiles add:				(Array with: timeStamp					with: (currentScriptEditor submorphs allButFirst collect: [:m | m fullCopyWithoutFormerOwner])).			formerScriptingTiles size > 100 ifTrue: [^ self halt: 'apparent runaway versions']]! !!UniclassScript methodsFor: 'versions' stamp: 'sw 1/30/2001 11:31'!savedTileVersionsCount	"Answer the number of saved tile versions of the script"	^ formerScriptingTiles ifNil: [0] ifNotNil: [formerScriptingTiles size]! !!UnscriptedPlayer methodsFor: 'uniclass' stamp: 'sw 1/30/2001 22:43'!assureUniClass	"Create a uniclass and become the receiver into it"	| anInstance |	anInstance _ self rootClassForUniclasses instanceOfUniqueClass.	anInstance initializeCostumesFrom: self.	self become: anInstance.	^ anInstance! !!UnscriptedPlayer methodsFor: 'uniclass' stamp: 'sw 1/30/2001 22:42'!rootClassForUniclasses	"Answer the class that should be subclassed when the receiver is made into a uniclass"	^ Player! !!UnscriptedCardPlayer methodsFor: 'root class' stamp: 'sw 1/30/2001 22:42'!rootClassForUniclasses	"Answer the class that should be subclassed when the receiver is made into a uniclass"	^ CardPlayer! !!UserScript methodsFor: 'script editor' stamp: 'sw 1/25/2001 10:32'!currentScriptEditor	"Answer the currentScriptEditor value"	^ currentScriptEditor! !!UserScript methodsFor: 'script editor' stamp: 'sw 1/25/2001 10:32'!formerScriptEditors	"Answer the formerScriptEditors value"	^ formerScriptEditors! !!UserScript methodsFor: 'updating' stamp: 'sw 1/22/2001 16:45'!updateToPlayer: aPlayer	"Set aPlayer as the current player referenced by the receiver and its script editor"	(currentScriptEditor notNil and: [currentScriptEditor ~~ #textuallyCoded]) ifTrue:		[currentScriptEditor updateToPlayer: aPlayer].	player _ aPlayer! !!Utilities class methodsFor: 'identification' stamp: 'sw 1/29/2001 09:28'!changeStampPerSe	"Answer a string to be pasted into source code to mark who changed it and when."	^ (self authorInitialsPerSe ifNil: ['']) , ' ' , Date today mmddyyyy, ' ',		((String streamContents: [:s | Time now print24: true on: s]) copyFrom: 1 to: 5)! !!ResultSpecification methodsFor: 'companion setter' stamp: 'sw 12/11/2000 14:34'!companionSetterSelector: aSetterSelector	"Set the receiver's companionSetterSelector as indicated"	companionSetterSelector _ aSetterSelector! !!ResultSpecification methodsFor: 'result type' stamp: 'sw 1/30/2001 20:14'!resultType: aType	"Set the receiver's resultType as specified"	protocol _ aType! !!Variable methodsFor: 'name' stamp: 'sw 12/11/2000 14:07'!variableName	"Answer the variable name of the receiver"	^ variableName! !!Variable methodsFor: 'type' stamp: 'sw 12/11/2000 14:06'!variableType	"Anser the variable type of the receiver"	^ variableType! !!Variable methodsFor: 'type' stamp: 'sw 12/11/2000 14:06'!variableType: aType	"Set the receiver's variable type as requested"	variableType _ aType! !!Variable methodsFor: 'value' stamp: 'sw 12/11/2000 14:06'!defaultValue	"Answer the default value to be supplied to the receiver"	^ defaultValue! !!Viewer methodsFor: 'as yet unclassified' stamp: 'sw 1/26/2001 15:26'!newPermanentScript	"Create a new, empty script and attach it to the hand"	| aMorph |	self scriptedPlayer assureUniClass.	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'newScript').	aMorph setProperty: #newPermanentScript toValue: true.	aMorph setProperty: #newPermanentPlayer toValue: self scriptedPlayer.	self primaryHand attachMorph: aMorph! !UserScript removeSelector: #donorActor:ownActor:!UserScript removeSelector: #initializeForPlayer:afterShallowCopyFrom:!!UnscriptedCardPlayer reorganize!('root class' rootClassForUniclasses)!!UnscriptedPlayer reorganize!('uniclass' assureUniClass rootClassForUniclasses)('queries' belongsToUniClass hasUserDefinedScripts hasUserDefinedSlots wantsSteps)('as yet unclassified' copyUniClass)!TileMorph removeSelector: #donorActor:ownActor:!ScriptStatusControl removeSelector: #isTileScriptingElement!ScriptInstantiation removeSelector: #chooseTriggerFrom:!ScriptInstantiation removeSelector: #offerMenu!ScriptInstantiation removeSelector: #offerMenu:!ScriptEditorMorph removeSelector: #donorActor:ownActor:!ScriptEditorMorph removeSelector: #printOn:!ScriptEditorMorph removeSelector: #renameScript:!!ScriptEditorMorph reorganize!('initialization' bringUpToDate initialize phrase: playerScripted: scriptName:phrase: setDefaultBorderCharacteristics setMorph: setMorph:scriptName: startOutEmptyForScriptName: updateToPlayer:)('access' morph myMorph objectViewed scriptInstantiation scriptName: titleMorph)('dropping/grabbing' acceptDroppingMorph:event: dismissViaHalo handlesDragOver: handlesMouseOver: handlesMouseOverDragging: indexOfMorphAbove: isCandidateForAutomaticViewing mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: prepareToUndoDropOf: removeSpaces repelsMorph:event: step stepTime wantsDroppedMorph:event: willingToBeDiscarded)('buttons' actuallyDestroyScript addDestroyButtonTo: addDismissButtonTo: addYesNoToHand buttonRowForEditor chooseFrequency chooseTrigger destroyScript dismiss editMethodDescription editScriptTextually install installWithNewLiteral makeIsolatedCodePane playerScripted replaceRow1 scriptName scriptTitle scriptee showSourceInScriptor tryMe updateStatus updateStatusMorph: useNewTiles)('save & revert' revertToTileVersion saveScriptVersion savedTileVersionsCount)('other' appendTileRows: becomeTextuallyCoded browseScripts codeString colorWhenRunning explainStatusAlternatives hasScriptInvoking:ofPlayer: hasScriptReferencing:ofPlayer: hibernate isEmpty isTextuallyCoded isTileScriptingElement markEdited methodString minWidth modernize modernizeScript offerScriptorMenu reinsertSavedTiles: renameScript renameScriptTo: revertScriptVersion setTimeStamp storeCodeOn:indent: tearOfButtonToFireScript tileForSelf tileRows timeStamp toggleWhetherShowingTiles topEditor unhibernate useNewTilesNow userScriptObject worldMorphsDo: xxxminHeight)('private' addNewRow enclosingEditor insertTileRow:after: labelForButton removeEmptyRows rowInsertionIndexFor: scriptEdited)('textually-coded scripts' addTextualScript: showingMethodPane showingMethodPane:)('copying' veryDeepFixupWith: veryDeepInner:)('frequency' setFrequencyTo: typeInFrequency)('tiles from method' fromExistingMethod:forPlayer: recreateTileVersion tilesFrom:)!ScriptActivationButton removeSelector: #ddCustomMenuItems:hand:!Player class removeSelector: #copyStateFrom:!Player removeSelector: #copyStateFrom:!Player removeSelector: #justClonedFrom:!MethodInterface class removeSelector: #methodInterfaceFor:!MethodInterface class removeSelector: #storeInterface:forSelector:!!ObjectWithDocumentation class reorganize!('instance creation' new)!MethodInterface removeSelector: #categoryKeywords!MethodInterface removeSelector: #flagCategory:!MethodInterface removeSelector: #fullSelector!Morph removeSelector: #grabFlagshipInstance:!Morph removeSelector: #justClonedFrom:!Morph removeSelector: #scriptRenamedFrom:to:forClass:!Morph removeSelector: #viewerForPlayerClass:!"Postscript:"(Player class allSubInstances select: [:c | c isSystemDefined not]) do:	[:aUniclass |		aUniclass scripts do:			[:aUserScript | (aUserScript player isKindOf: Player)				ifFalse:					[aUserScript player: aUniclass someInstance.					Transcript cr; show: 'fixed up userScript ', (aUserScript selector ifNil: ['<nil selector>']), ' for ', aUniclass name]]].StandardScriptingSystem initialize.!