'From Squeak3.3alpha of 18 January 2002 [latest update: #4976] on 3 October 2002 at 2:24:53 am'!"Change Set:		decimalPlaces-swDate:			3 October 2002Author:			Scott WallacePublished as 4979decimalPlaces-sw.cs to 3.3a.¥ When the user text-edits the value in an UpdatingStringMorph that holds a numeric value (e.g. in a Viewer or Watcher,) the user's type-in is now parsed to determine how many decimal places to show in that readout from then on.  Thanks to Kim Rose for this suggestion.¥ When an UpdatingStringMorph has a particular number of decimal-places specified, that number of decimal places is now always actually shown.  Formerly integers were shown without decimal points completely, whatever the number of decimal places specified, and trailing zeros were generally not shown.  Now, if you have asked for two decimal places, the readout will always show precisely two digits after the decimal point.¥ When the user asserts a particular number of decimal places in a readout for an etoy built-in variable such as x or width, that preference is remembered and used whenever that variable is subsequently viewed.¥ When an arrow-setter phrase is torn off from a viewer, if it pertains to a numeric variable for which a decimal-places preference has been expressed, that preference is reflected on the constant tile in the spawned assignment phrase.¥ The #heading pseudo-slot is no longer gratuitously rounded.¥ The main viewer-entry menu (activated by clicking on the menu icon next to a variable name in a viewer) now contains a set-decimal-places item for *all* numeric-valued variables, not just for user-defined instance variables."!!NumberType commentStamp: 'sw 10/3/2002 02:18' prior: 0!NumberType is a data type representing a numeric value.!!Morph methodsFor: 'e-toy support' stamp: 'sw 9/13/2002 17:44'!decimalPlacesForGetter: aGetter	"Answer the decimal places I prefer for showing a slot with the given getter, or nil if none"	| decimalPrefs |	decimalPrefs _ self renderedMorph valueOfProperty: #decimalPlacePreferences ifAbsent: [^ nil].	^ decimalPrefs at: aGetter ifAbsent: [nil]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 9/13/2002 16:46'!defaultFloatPrecisionFor: aGetSelector	"Answer a number indicating the default float precision to be used in a numeric readout for which the receiver provides the data.   Individual morphs can override this.  Showing fractional values for readouts of getCursor was in response to an explicit request from ack"	(self renderedMorph decimalPlacesForGetter: aGetSelector) ifNotNilDo: [:places | ^ (Utilities floatPrecisionForDecimalPlaces: places)].	(#(getCursor getNumericValue getNumberAtCursor getCursorWrapped getScaleFactor) includes: aGetSelector)		ifTrue:			[^ 0.01].	^ 1! !!Morph methodsFor: 'e-toy support' stamp: 'sw 9/13/2002 17:45'!noteDecimalPlaces: aNumber forGetter: aGetter	"Make a mental note of the user's preference for a particular number of decimal places to be associated with the slot with the given getter"	(self renderedMorph valueOfProperty: #decimalPlacePreferences ifAbsentPut: [IdentityDictionary new])		at: aGetter put: aNumber! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 9/14/2002 12:27'!makeSetter: selectorAndTypePair event: evt from: aMorph	"Classic tiles: make a Phrase that comprises a setter of a slot, and hand it to the user."	| argType m argTile selfTile argValue actualGetter |	argType _ selectorAndTypePair second.	actualGetter _ selectorAndTypePair first asSymbol.	m _ PhraseTileMorph new setAssignmentRoot: (Utilities inherentSelectorForGetter: actualGetter)		type: #command		rcvrType: #Player		argType: argType		vocabulary: self currentVocabulary.	argValue _ self scriptedPlayer perform: selectorAndTypePair first asSymbol.	(argValue isKindOf: Player)		ifTrue:			[argTile _ argValue tileReferringToSelf]		ifFalse:			[argTile _ ScriptingSystem tileForArgType: argType.			((argType == #Number) and: [argValue isKindOf: Number])				ifTrue:					[(scriptedPlayer decimalPlacesForGetter: actualGetter) ifNotNilDo:						[:places | (argTile findA: UpdatingStringMorph) decimalPlaces: places]]. 			argTile setLiteral: argValue; updateLiteralLabel].	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	m openInHand! !!Number methodsFor: 'printing' stamp: 'sw 9/13/2002 17:50'!printShowingDecimalPlaces: placesDesired	"Print the receiver showing precisely the given number of places desired .  If the placesDesired provided is positive, a decimal point and that many digits after the decimal point will always be shown.  If the placesDesired is zero, a whole number will be shown, without a decimal point.  This method could probably be greatly optimized -- improvements welcomed."	| aString |	placesDesired <= 0 ifTrue: [^ self rounded printString].	aString _ ((self asFloat roundTo: (Utilities floatPrecisionForDecimalPlaces: placesDesired)) asString), ((String new: placesDesired) atAllPut: $0).	^ aString copyFrom: 1 to: ((aString indexOf: $.) + placesDesired)"23 printShowingDecimalPlaces: 223.5698 printShowingDecimalPlaces: 2-234.567 printShowingDecimalPlaces: 523.4567 printShowingDecimalPlaces: 0"! !!NumberType methodsFor: 'tiles' stamp: 'sw 9/15/2002 16:45'!addExtraItemsToMenu: aMenu forSlotSymbol: slotSym	"If the receiver has extra menu items to add to the slot menu, here is its chance to do it.  The defaultTarget of the menu is the player concerned."	aMenu add: 'decimal places...' selector: #setPrecisionFor: argument: slotSym.	aMenu balloonTextForLastItem: 'Lets you choose how many decimal places should be shown in readouts for this variable'! !!NumberType methodsFor: 'tiles' stamp: 'sw 9/15/2002 16:50'!addUserSlotItemsTo: aMenu slotSymbol: slotSym	"Optionally add items to the menu that pertain to a user-defined slot of the given symbol"	"aMenu add: 'decimal places...' selector: #setPrecisionFor: argument: slotSym	NB: This item is now generically added for system as well as user slots, so the addition is now done in NubmerType.addExtraItemsToMenu:forSlotSymbol:"! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/15/2002 12:03'!getHeading	"Answer the heading of the object, *formerly* ;-) always given as a whole number"	^ self getHeadingUnrounded "rounded"! !!Player methodsFor: 'slots-user' stamp: 'sw 9/15/2002 16:48'!setPrecisionFor: slotName	"Set the precision for the given slot name"	| aList aMenu reply val aGetter places |	aGetter _ Utilities getterSelectorFor: slotName.	places _ Utilities decimalPlacesForFloatPrecision: (self defaultFloatPrecisionFor: aGetter).	aList _ #('0' '1' '2' '3' '4' '5' '6').	aMenu _ SelectionMenu labels: aList selections: (aList collect: [:m | m asNumber]).	reply _ aMenu startUpWithCaption: 'How many decimal places? (currently ', places asString, ')'.	reply ifNotNil:		[(self slotInfo includesKey: slotName) 			ifTrue:				["it's a user slot"				(self slotInfoAt: slotName) floatPrecision: (Utilities floatPrecisionForDecimalPlaces: reply).				self class allInstancesDo:					[:anInst |						reply == 0 ifFalse:							[((val _ anInst instVarNamed: slotName asString) isKindOf: Integer)								ifTrue:									[anInst instVarNamed: slotName asString put: val asFloat]].						anInst updateAllViewers]]			ifFalse:				["it's specifying a preference for precision on a system-defined numeric slot"				self noteDecimalPlaces: reply forGetter: aGetter.				self updateAllViewers]]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 9/15/2002 16:51'!slotInfoButtonHitFor: aGetterSymbol inViewer: aViewer	"The user made a gesture asking for slot menu for the given getter symbol in a viewer; put up the menu."	| aMenu slotSym aType typeVocab |	slotSym _ Utilities inherentSelectorForGetter: aGetterSymbol.	aType _ self typeForSlotWithGetter: aGetterSymbol asSymbol.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: (slotSym asString, ' (', aType, ')').	(typeVocab _ Vocabulary vocabularyForType: aType) addWatcherItemsToMenu: aMenu forGetter: aGetterSymbol.	(self slotInfo includesKey: slotSym)		ifTrue:			[aMenu add: 'change data type' selector: #chooseSlotTypeFor: argument: aGetterSymbol.			typeVocab addUserSlotItemsTo: aMenu slotSymbol: slotSym.			aMenu add: 'remove "', slotSym, '"' selector: #removeSlotNamed: argument: slotSym.			aMenu add: 'rename  "', slotSym, '"' selector: #renameSlot: argument: slotSym.			aMenu addLine].	typeVocab addExtraItemsToMenu: aMenu forSlotSymbol: slotSym.  "e.g. Player type adds hand-me-tiles"	aMenu add: 'show categories....' target: aViewer selector: #showCategoriesFor: argument: aGetterSymbol.	self addIdiosyncraticMenuItemsTo: aMenu forSlotSymol: slotSym.	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: #yourself].	aMenu popUpForHand: aViewer primaryHand in: aViewer world! !!Player methodsFor: 'misc' stamp: 'sw 9/13/2002 17:52'!decimalPlacesForGetter: aGetter	"Answer the number of decimal places wanted when displaying the getter's value.  Answer nil if this object does not have a personal preference regarding this getter."	^ costume decimalPlacesForGetter: aGetter! !!Player methodsFor: 'misc' stamp: 'sw 9/13/2002 17:53'!noteDecimalPlaces: aNumber forGetter: aGetter	"Note the given preference of decimal places for the given getter"	costume noteDecimalPlaces: aNumber forGetter: aGetter! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/13/2002 17:55'!decimalPlaces	"Answer the number of decimal places to show."	| places |	(places _ self valueOfProperty: #decimalPlaces) ifNotNil: [^ places].	self setProperty: #decimalPlaces toValue: (places _ Utilities decimalPlacesForFloatPrecision: self floatPrecision).	^ places! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/13/2002 17:58'!decimalPlaces: aNumber	"Set the receiver's number of decimal places to be shown.  If my target is a morph or a player, tell it about the change, in case it wants to remember it."	self setProperty: #decimalPlaces toValue: aNumber.	self pvtFloatPrecision: (Utilities floatPrecisionForDecimalPlaces: aNumber).	(target isKindOf: Morph orOf: Player) ifTrue:		[target noteDecimalPlaces: aNumber forGetter: getSelector]! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/13/2002 17:57'!floatPrecision: aPrecision	"Set the receiver's number of decimal places to correspond with the given precision.  The preferred protocol here is #decimalPlaces:, which conforms to the UI for this, but #floatPrecision: is retained for backward compatibility."	self decimalPlaces: (Utilities decimalPlacesForFloatPrecision: aPrecision)! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/11/2002 14:44'!format	"Answer the receiver's format: #default or #string"	^ format ifNil: [format _ #default]! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/13/2002 17:58'!pvtFloatPrecision: aNumber	"Private - Set the floatPrecision instance variable to the given number"	floatPrecision _ aNumber! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 9/11/2002 14:46'!acceptValueFromTarget: v	"Accept a value from the target"	lastValue _ v.	self format == #string ifTrue: [^ v asString].	(format == #default and: [v isNumber]) ifTrue:		[^ v printShowingDecimalPlaces: self decimalPlaces].	^ v printString! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 9/12/2002 22:17'!informTarget	"Obtain a value from my contents, and tell my target about it"	| newValue typeIn |	((target ~~ nil) and: [putSelector ~~ nil]) ifTrue:		[typeIn _ contents.		(newValue _ self valueFromContents) ifNotNil:			[self checkTarget.			target perform: putSelector with: newValue.			target isMorph ifTrue: [target changed]].			self fitContents.			(format == #default and: [newValue isNumber]) ifTrue:				[self setDecimalPlacesFromTypeIn: typeIn]]! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 9/12/2002 22:35'!setDecimalPlacesFromTypeIn: typeIn	"The user has typed in a number as the new value of the receiver.  Glean off decimal-places-preference from the type-in"	| decimalPointPosition tail places |	decimalPointPosition _ typeIn indexOf: $. ifAbsent: [nil].	places _ 0.	decimalPointPosition		ifNotNil:			[tail _ typeIn copyFrom: decimalPointPosition + 1 to: typeIn size.			[places < tail size and: [(tail at: (places + 1)) isDigit]]				whileTrue:					[places _ places + 1]].			self decimalPlaces: places! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 9/11/2002 09:57'!setDecimalPlaces: places	"Set the number of decimal places, and update the display."	self decimalPlaces: places.	self acceptValueFromTarget: lastValue! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 9/13/2002 18:01'!setPrecision	"Allow the user to specify a number of decimal places.  This UI is invoked from a menu.  Nowadays the precision can be set by simple type-in, making this menu approach mostly obsolete.  However, it's still useful for read-only readouts, where type-in is not allowed."	| aMenu |	aMenu _ MenuMorph new.	aMenu addTitle: 'How many decimal places? (currently ', self decimalPlaces asString, ')'.	0 to: 5 do:		[:places |			aMenu add: places asString target: self selector: #setDecimalPlaces: argument: places].	aMenu popUpInWorld! !!UpdatingNumericStringMorph methodsFor: 'target access' stamp: 'sw 9/13/2002 17:54'!acceptValueFromTarget: v	"Accept a value from my target"	^ super acceptValueFromTarget: ((self format == #default and: [v isNumber])		ifTrue: 			[| t | 			t _ v.			min ifNotNil: [t _ t max: min].			max ifNotNil: [t _ t min: max]]		ifFalse:			[v])! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 9/13/2002 18:02'!decimalPlacesForFloatPrecision: precision	"Answer the number of decimal places that correspond to the given floatPrecision"	^ (#(1 0.1 0.01 0.001 0.0001 0.00001 0.000001 0.0000001 0.00000001 0.000000001) indexOf: precision) - 1"#(1 0.1 0.01 0.001 0.0001 0.00001 0.000001 0.0000001 0.00000001 0.000000001) collect: [:prec | Utilities decimalPlacesForFloatPrecision: prec]"! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 9/11/2002 10:15'!floatPrecisionForDecimalPlaces: places	"Answer the floatPrecision that corresponds to the given number of decimal places"	^ #(1 0.1 0.01 0.001 0.0001 0.00001 0.000001 0.0000001 0.00000001 0.000000001) at: (places + 1)"(0 to: 6) collect: [:i | Utilities floatPrecisionForDecimalPlaces: i]"! !