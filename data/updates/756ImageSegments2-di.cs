'From Squeak 2.3 of January 14, 1999 on 25 March 1999 at 12:09:54 am'!"Change Set:		ImageSegments2Date:			24 March 1999Author:			Dan IngallsThis changeSet provides code for saving and loading image segments.	It is implemented in a class called ImageSegment.	It can do a fast deepCopy of some object, OB, by evaluating, eg,		(ImageSegment new roots: (Array with: OB)) segmentCopyIt also implements a facility for recovering from faults due to the replacement	of classes by root stubs that will reload a class from a remote segment.	Changed Interpreter>>lookupMethodInClass: to test for methodDict == nil	In this case it will send cannotInterpret: to self with the original message.	Added Smalltalk specialObjectsArray at: 35 put: #cannotInterpret: for the above.	Added two methods, induceMDFault and recoverFromMDFault to test this	Added a handler for cannotInterpret: for the above as well.	See the comment in ClassDescription>>induceMDFaultThis version provides much faster remapping of oops in the storeSegment."!Object subclass: #ImageSegment	instanceVariableNames: 'arrayOfRoots segment outPointers '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Storage'!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows freeContexts interruptCheckCounter displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize BlockContextProto CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClassMask CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero CtxtTempFrameStart DoAssertionChecks Done ExternalObjectsArray FalseObject FloatProto GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextSize MarkBit MethodContextProto MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotInterpret SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SizeMask SmallBlockContext SmallMethodContext SmallContextSize SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!Object methodsFor: 'error handling' stamp: 'di 3/19/1999 10:31'!cannotInterpret: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but a null methodDictionary was encountered while looking up the message selector.  Hopefully this is the result of encountering a stub for a swapped out class which induces this exception on purpose.""If this is the result of encountering a swap-out stub, then simulating the lookup in Smalltalk should suffice to install the class properly, and the message may be resent."	| handler errorString |	(self class lookupSelector: aMessage selector) == nil ifFalse:		["Simulated lookup succeeded -- resend the message."		^ aMessage sentTo: self].	"Could not recover by simulated lookup -- it's an error"	errorString _ 'MethodDictionary fault'.	(handler _ Processor activeProcess errorHandler) notNil		ifTrue: [handler value: errorString value: self]		ifFalse: [Debugger openContext: thisContext					label: errorString					contents: thisContext shortStack].	^ aMessage sentTo: self! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 3/23/1999 08:51'!includesSelector: aSymbol 	"Overridden to handle methodDictionary faults"	methodDict == nil ifTrue: [self recoverFromMDFault].	^ methodDict includesKey: aSymbol! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 3/23/1999 16:51'!induceMDFault	"Stache a copy of the methodDict in the organization slot (hack!!),	and set the methodDict to nil.  This will induce an MD fault on any message send."	organization _ Array with: methodDict with: organization.	methodDict _ nil.	self flushCache"Here are some do-its to exercise this facility.  The idea is to induce a fault in nearly every class in the system.  Any class in active use will immediately fault and cause itself to be restored to a normal state.  The last expression below then tallies the classes that have not yet been restored, and therefore that must not have been in use.  This approach can be useful in removing unnecessary classes by empirical measurement.  Smalltalk allClasses size 883 | ok | Smalltalk allClasses do:	[:c | ok _ true.	#(Array Object Class Message Dictionary) do:		[:n | ((Smalltalk at: n) == c or:			[(Smalltalk at: n) inheritsFrom: c]) ifTrue: [ok _ false]].	ok ifTrue: [Transcript cr; show: c name.				c induceMDFault]].(Smalltalk allClasses select: [:c | (c instVarNamed: 'methodDict') == nil]) size 697"! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 3/23/1999 12:28'!recoverFromMDFault	(organization isMemberOf: Array) ifFalse: [self error: 'oops'].	methodDict _ organization first.	organization _ organization second.! !!ImageSegment commentStamp: 'di 3/23/1999 00:09' prior: 0!I represent a segment of Squeak address space.  I am created from an array of root objects.  After storing, my segment contains every object accessible from my roots but not otherwise accessible from anywhere else in the system.  Within my segment are indices into my table of outPointers.I may exist in several phases:Phase 0 (just created):arrayOfRoots segment outPointers are all as created by the roots: initialization message.  Nothing else has changed about the Squeak system.Phase 1 (stubbed):Each of the original roots has been transmuted into an ImageSegmentRootStub that refers back to this image segment.  At this point the original objects in the segment will all be garbageCollected, and the image will shrink to roughly its original size (the objects having been replaced by the segment word array).Phase 2 (stubbed on disk):The segment itself (and probably all the Symbols in the outPointers) may be written out to disk and replaced by a file pointer.  At this point the image will shrink to roughly its original size minus the size of the segment.Phase 3 (exported):The table of outPointers may be enternalized in such a manner that it can be exported to a foreign image (with its segment file).  In this form the segment can be read from, eg, a URL, and installed with the resulting value being the original array of root objects, with former outPointers bound in some appropriate manner to existing objects in the host system..!!ImageSegment methodsFor: 'as yet unclassified' stamp: 'di 3/24/1999 23:10'!deepCopyTest: aRootArray	| t1 t2 copy |	t1 _ Time millisecondsToRun: [self roots: aRootArray].	t2 _ Time millisecondsToRun: [copy _ self segmentCopy].	Transcript cr; print: segment size * 4; nextPutAll: ' bytes stored with ';		print: outPointers size; show: ' outpointers in '; print: t1; show: 'ms.'.	Transcript cr; nextPutAll: 'Reconstructed in '; print: t2; show: 'ms.'.	^ copy! !!ImageSegment methodsFor: 'as yet unclassified' stamp: 'di 3/22/1999 23:38'!loadSegmentFrom: segmentWordArray withOutPointers: outPointerArray	"This primitive will install a binary image segment and return as its value the array of roots of the tree of objects represented.  Upon successful completion, the wordArray will have been transmuted into an object of zero length.  If this primitive should fail, it will have destroyed the contents of the segment wordArray."	<primitive: 99>	"successful completion returns the array of roots"	^ nil			"failure returns nil"! !!ImageSegment methodsFor: 'as yet unclassified' stamp: 'di 3/24/1999 22:58'!roots: aRootArray 	| segmentWordArray outPointerArray segSize |	arrayOfRoots _ aRootArray.	segSize _ 50000.		[segmentWordArray _ WordArray new: segSize.	outPointerArray _ Array new: segSize // 20.	(self storeSegmentFor: arrayOfRoots			into: segmentWordArray			withOutPointers: outPointerArray) == nil]		whileTrue: [segmentWordArray _ outPointerArray _ nil.					segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.! !!ImageSegment methodsFor: 'as yet unclassified' stamp: 'di 3/24/1999 23:04'!segmentCopy	^ self loadSegmentFrom: segment copy withOutPointers: outPointers! !!ImageSegment methodsFor: 'as yet unclassified' stamp: 'di 3/22/1999 23:39'!storeSegmentFor: rootsArray into: segmentWordArray withOutPointers: outPointerArray	"This primitive will store a binary image segment (in the same format as the Squeak image file) of the receiver and every object in its proper tree of subParts (ie, that is not refered to from anywhere else outside the tree).  Note: all elements of the reciever are treated as roots indetermining the extent of the tree.  All pointers from within the tree to objects outside the tree will be copied into the array of outpointers.  In their place in the image segment will be an oop equal to the offset in the outpointer array (the first would be 4). but with the high bit set."	"The primitive expects the array and wordArray to be more than adequately long.  In this case it returns normally, and truncates the two arrays to exactly the right size.  If either array is too small, the primitive will fail, but in no other case."	<primitive: 98>	"successful completion returns self"	^ nil			"failure returns nil"! !!ObjectMemory methodsFor: 'header access' stamp: 'di 3/18/1999 19:38'!formatOf: oop"       0      no fields        1      fixed fields only (all containing pointers)        2      indexable fields only (all containing pointers)        3      both fixed and indexable fields (all containing pointers)        4      both fixed and indexable weak fields (all containing pointers).        5      unused        6      indexable word fields only (no pointers)        7      unused     8-11      indexable byte fields only (no pointers) (low 2 bits are low 2 bits of size)   12-15     compiled methods:                   # of literal oops specified in method header,                   followed by indexable bytes (same interpretation of low 2 bits as above)"	^ ((self baseHeader: oop) >> 8) bitAnd: 16rF! !!Interpreter methodsFor: 'message sending' stamp: 'di 3/23/1999 10:08'!lookupMethodInClass: class	| currentClass dictionary found rclass |	self inline: false.	currentClass _ class.	[currentClass ~= nilObj]		whileTrue:		[dictionary _ self fetchPointer: MessageDictionaryIndex ofObject: currentClass.		dictionary = nilObj ifTrue:			["MethodDict pointer is nil (hopefully due a swapped out stub)				-- raise exception #cannotInterpret:."			self pushRemappableOop: currentClass.			self createActualMessage.  "may cause GC!!"			currentClass _ self popRemappableOop.			messageSelector _ self splObj: SelectorCannotInterpret.			^ self lookupMethodInClass: (self superclassOf: currentClass)].		found _ self lookupMethodInDictionary: dictionary.		found ifTrue: [^ currentClass].		currentClass _ self superclassOf: currentClass].	"Could not find #doesNotUnderstand: -- unrecoverable error."	messageSelector = (self splObj: SelectorDoesNotUnderstand) ifTrue:		[self error: 'Recursive not understood error encountered'].	"Cound not find a normal message -- raise exception #doesNotUnderstand:"	self pushRemappableOop: class.	self createActualMessage.  "may cause GC!!"	rclass _ self popRemappableOop.	messageSelector _ self splObj: SelectorDoesNotUnderstand.	^ self lookupMethodInClass: rclass! !!Interpreter methodsFor: 'image segment in/out' stamp: 'di 3/24/1999 22:37'!copyObj: oop toSegment: segmentWordArray addr: lastSeg stopAt: stopAddr saveOopAt: oopPtr headerAt: hdrPtr	"Copy this object into the segment beginning at lastSeg.	Install a forwarding pointer, and save oop and header.	Fail if out of space.  Return the next segmentAddr if successful."	"Copy the object..."	| extraSize bodySize |	successFlag ifFalse: [^ lastSeg].	extraSize _ self extraHeaderBytes: oop.	bodySize _ self sizeBitsOf: oop.	(lastSeg + extraSize + bodySize) >= stopAddr		ifTrue: [^ self primitiveFail].	self transfer: extraSize + bodySize // 4  "wordCount"		from: oop - extraSize		to: lastSeg+4.	self forward: oop to: (lastSeg+4 + extraSize - segmentWordArray)		savingOopAt: oopPtr andHeaderAt: hdrPtr.	"Return new end of segment"	^ lastSeg + extraSize + bodySize! !!Interpreter methodsFor: 'image segment in/out' stamp: 'di 3/24/1999 16:10'!forward: oop to: newOop savingOopAt: oopPtr andHeaderAt: hdrPtr	"Make a new entry in the table of saved oops."	self longAt: oopPtr put: oop.					"Save the oop"	self longAt: hdrPtr put: (self longAt: oop).	"Save the old header word"	"Put a forwarding pointer in the old object, flagged with forbidden header type"	self longAt: oop put: newOop + HeaderTypeFree.! !!Interpreter methodsFor: 'image segment in/out' stamp: 'di 3/22/1999 23:28'!oopHasOKclass: oop	"Similar to oopHasOkayClass:, except that it only returns true or false."	| oopClass formatMask behaviorFormatBits oopFormatBits |	(self isIntegerObject: oop) ifTrue: [^ true].	((0 < oop) & (oop < endOfMemory)) ifFalse: [^ false].	((oop \\ 4) = 0) ifFalse: [^ false].	(oop + (self sizeBitsOf: oop)) < endOfMemory ifFalse: [^ false].	oopClass _ self fetchClassOf: oop.	(self isIntegerObject: oopClass) ifTrue: [^ false].	((0 < oopClass) & (oopClass < endOfMemory)) ifFalse: [^ false].	((oopClass \\ 4) = 0) ifFalse: [^ false].	(oopClass + (self sizeBitsOf: oopClass)) < endOfMemory ifFalse: [^ false].	((self isPointers: oopClass) and: [(self lengthOf: oopClass) >= 3]) ifFalse: [^ false].	(self isBytes: oop)		ifTrue: [ formatMask _ 16rC00 ]  "ignore extra bytes size bits"		ifFalse: [ formatMask _ 16rF00 ].	behaviorFormatBits _ (self formatOfClass: oopClass) bitAnd: formatMask.	oopFormatBits _ (self baseHeader: oop) bitAnd: formatMask.	behaviorFormatBits = oopFormatBits ifFalse: [^ false].	^ true! !!Interpreter methodsFor: 'image segment in/out' stamp: 'di 3/24/1999 16:53'!primitiveFailAfterCleanup: outPointerArray	"If the storeSegment primitive fails, it must clean up first."	| i lastAddr |   "Store nils throughout the outPointer array."	lastAddr _ outPointerArray + (self lastPointerOf: outPointerArray).	i _ outPointerArray + BaseHeaderSize.	[i <= lastAddr] whileTrue:		[self longAt: i put: nilObj.		i _ i + 4].	self primitiveFail! !!Interpreter methodsFor: 'image segment in/out' stamp: 'di 3/24/1999 08:30'!primitiveLoadImageSegment	"This primitive is called from Squeak as...		<imageSegment> loadSegmentFrom: aWordArray withOutPointers: anArray.""This primitive will load a binary image segment created by primitiveStoreImageSegment.  It expects the outPointer array to be of the proper size, and the wordArray to be well formed.  It will return as its value the original array of roots, and the erstwhile segmentWordArray will have been truncated to a size of zero.  If this primitive should fail, the segmentWordArray will, sadly, have been reduced to an unrecognizable and unusable jumble.  But what more could you have done with it anyway?"	| outPointerArray segmentWordArray endSeg segOop fieldPtr fieldOop doingClass lastPtr extraSize mapOop lastOut outPtr hdrTypeBits header |	outPointerArray _ self stackValue: 0.	lastOut _ outPointerArray + (self lastPointerOf: outPointerArray).	segmentWordArray _ self stackValue: 1.	endSeg _ segmentWordArray + (self sizeBitsOf: segmentWordArray) - BaseHeaderSize.	"Essential type checks"	((self formatOf: outPointerArray) = 2				"Must be indexable pointers"		and: [(self formatOf: segmentWordArray) = 6])	"Must be indexable words"		ifFalse: [^ self primitiveFail].	"Proceed through the segment, remapping pointers..."	segOop _ self oopFromChunk: segmentWordArray + BaseHeaderSize.	[segOop <= endSeg] whileTrue:		[((self baseHeader: segOop) bitAnd: CompactClassMask) = 0			ifTrue: ["This object has a class field -- start with that."					fieldPtr _ segOop - 4.  doingClass _ true]			ifFalse: ["No class field -- start with first data field"					fieldPtr _ segOop + BaseHeaderSize.  doingClass _ false].		lastPtr _ segOop + (self lastPointerOf: segOop).	"last field"		lastPtr > endSeg ifTrue: [^ self primitiveFail "out of bounds"].		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop _ self longAt: fieldPtr.			doingClass ifTrue:				[hdrTypeBits _ self headerType: fieldPtr.				fieldOop _ fieldOop - hdrTypeBits].			(self isIntegerObject: fieldOop)				ifTrue:					["Integer -- nothing to do"					fieldPtr _ fieldPtr + 4]				ifFalse:					[(fieldOop bitAnd: 3) = 0 ifFalse: [^ self primitiveFail "bad oop"].					(fieldOop bitAnd: 16r80000000) = 0						ifTrue: ["Internal pointer -- add segment offset"								mapOop _ fieldOop + segmentWordArray]						ifFalse: ["External pointer -- look it up in outPointers"								outPtr _ outPointerArray + (fieldOop bitAnd: 16r7FFFFFFF).								outPtr > lastOut ifTrue: [^ self primitiveFail "out of bounds"].								mapOop _ self longAt: outPtr].					doingClass						ifTrue: [self longAt: fieldPtr put: mapOop + hdrTypeBits.								fieldPtr _ fieldPtr + 8.								doingClass _ false]						ifFalse: [self longAt: fieldPtr put: mapOop.								fieldPtr _ fieldPtr + 4]]].		segOop _ self objectAfter: segOop].	"Again, proceed through the segment checking consistency..."	segOop _ self oopFromChunk: segmentWordArray + BaseHeaderSize.	[segOop <= endSeg] whileTrue:		[(self oopHasOKclass: segOop) ifFalse: [^ self primitiveFail "inconsistency"].		fieldPtr _ segOop + BaseHeaderSize.		"first field"		lastPtr _ segOop + (self lastPointerOf: segOop).	"last field"		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop _ self longAt: fieldPtr.			(self oopHasOKclass: fieldOop) ifFalse: [^ self primitiveFail "inconsistency"].			fieldPtr _ fieldPtr + 4].		segOop _ self objectAfter: segOop].	"Truncate the segment word array to size = zero"	extraSize _ self extraHeaderBytes: segmentWordArray.	hdrTypeBits _ self headerType: segmentWordArray.	extraSize = 8		ifTrue: [self longAt: segmentWordArray-extraSize put: BaseHeaderSize + hdrTypeBits]		ifFalse: [header _ self longAt: segmentWordArray.				self longAt: segmentWordArray					put: header - (header bitAnd: SizeMask) + BaseHeaderSize].	.		"and return the roots array which was first in the segment"	self pop: 3 thenPush: (self oopFromChunk: segmentWordArray + BaseHeaderSize)! !!Interpreter methodsFor: 'image segment in/out' stamp: 'di 3/24/1999 17:47'!primitiveStoreImageSegment	"This primitive is called from Squeak as...		<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray withOutPointers: anArray.""This primitive will store a binary image segment (in the same format as the Squeak image file) of the receiver and every object in its proper tree of subParts (ie, that is not refered to from anywhere else outside the tree).  All pointers from within the tree to objects outside the tree will be copied into the array of outpointers.  In their place in the image segment will be an oop equal to the offset in the outPointer array (the first would be 4). but with the high bit set.""The primitive expects the array and wordArray to be more than adequately long.  In this case it returns normally, and truncates the two arrays to exactly the right size.  To simplify truncation, both incoming arrays are required to be 256 bytes or more long (ie with 3-word headers).  If either array is too small, the primitive will fail, but in no other case.During operation of the primitive, it is necessary to convert from both internal and external oops to their mapped values.  To make this fast, the headers of the original objects in question are replaced by the mapped values (and this is noted by adding the forbidden XX header type).  Tables are kept of both kinds of oops, as well as of the original headers for restoration.To be specific, there are two similar two-part tables, the outpointer array, and one in the upper fifth of the segmentWordArray.  Each grows oops from the bottom up, and preserved headers from halfway up.In case of either success or failure, the headers must be restored.  In the event of primitive failure, the table of outpointers must also be nilled out (since the garbage in the high half will not have been discarded."	| outPointerArray segmentWordArray savedYoungStart lastOut lastIn firstIn lastSeg endSeg segOop fieldPtr fieldOop mapOop doingClass lastPtr extraSize hdrTypeBits arrayOfRoots hdrBaseIn hdrBaseOut header firstOut |	outPointerArray _ self stackValue: 0.	segmentWordArray _ self stackValue: 1.	arrayOfRoots _ self stackValue: 2.	"Essential type checks"	((self formatOf: arrayOfRoots) = 2				"Must be indexable pointers"		and: [(self formatOf: outPointerArray) = 2				"Must be indexable pointers"		and: [(self formatOf: segmentWordArray) = 6]])	"Must be indexable words"		ifFalse: [^ self primitiveFail].	((self headerType: outPointerArray) = HeaderTypeSizeAndClass	"Must be 3-word header"		and: [(self headerType: segmentWordArray) = HeaderTypeSizeAndClass])	"Must be 3-word header"		ifFalse: [^ self primitiveFail].	"Use the top half of outPointers for saved headers."	firstOut _ outPointerArray + BaseHeaderSize.	lastOut _ firstOut - 4.	hdrBaseOut _ outPointerArray + ((self lastPointerOf: outPointerArray) // 8 * 4). "top half"	lastSeg _ segmentWordArray.	endSeg _ segmentWordArray + (self sizeBitsOf: segmentWordArray) - 4.	"Allocate top 1/8 of segment for table of internal oops and saved headers"	firstIn _ endSeg - ((self sizeBitsOf: segmentWordArray) // 32 * 4).  "Take 1/8 of seg"	lastIn _ firstIn - 4.	hdrBaseIn _ firstIn + ((self sizeBitsOf: segmentWordArray) // 64 * 4). "top half"	"First mark the rootArray and all root objects."	self longAt: arrayOfRoots put: ((self longAt: arrayOfRoots) bitOr: MarkBit).	lastPtr _ arrayOfRoots + (self lastPointerOf: arrayOfRoots).	fieldPtr _ arrayOfRoots + BaseHeaderSize.	[fieldPtr <= lastPtr] whileTrue:		[fieldOop _ self longAt: fieldPtr.		(self isIntegerObject: fieldOop) ifFalse:			[self longAt: fieldOop put: ((self longAt: fieldOop) bitOr: MarkBit)].		fieldPtr _ fieldPtr + 4].	"Then do a mark pass over all objects.  This will stop at our marked roots,	thus leaving our segment unmarked in their shadow."	savedYoungStart _ youngStart.	youngStart _ self startOfMemory.  "process all of memory"	self markPhase.	youngStart _ savedYoungStart.		"Finally unmark the rootArray and all root objects."	self longAt: arrayOfRoots put: ((self longAt: arrayOfRoots) bitAnd: AllButMarkBit).	fieldPtr _ arrayOfRoots + BaseHeaderSize.	[fieldPtr <= lastPtr] whileTrue:		[fieldOop _ self longAt: fieldPtr.		(self isIntegerObject: fieldOop) ifFalse:			[self longAt: fieldOop put: ((self longAt: fieldOop) bitAnd: AllButMarkBit)].		fieldPtr _ fieldPtr + 4].	"All external objects, and only they, are now marked.	Copy the array of roots into the segment, and forward its oop."	lastIn _ lastIn + 4.	lastIn >= hdrBaseIn ifTrue: [lastIn _ lastIn - 4.  successFlag _ false].	lastSeg _ self copyObj: arrayOfRoots toSegment: segmentWordArray addr: lastSeg stopAt: firstIn saveOopAt: lastIn headerAt: hdrBaseIn + (lastIn - firstIn).	successFlag ifFalse:		[self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.		^ self primitiveFailAfterCleanup: outPointerArray].	"Now run through the segment fixing up all the pointers.	Note that more objects will be added to the segment as we make our way along."	segOop _ self oopFromChunk: segmentWordArray + BaseHeaderSize.	[segOop <= lastSeg] whileTrue:		[((self baseHeader: segOop) bitAnd: CompactClassMask) = 0			ifTrue: ["This object has a class field -- start with that."					fieldPtr _ segOop - 4.  doingClass _ true]			ifFalse: ["No class field -- start with first data field"					fieldPtr _ segOop + BaseHeaderSize.  doingClass _ false].		lastPtr _ segOop + (self lastPointerOf: segOop).	"last field"		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop _ self longAt: fieldPtr.			doingClass ifTrue:				[hdrTypeBits _ fieldOop bitAnd: TypeMask.				fieldOop _ fieldOop - hdrTypeBits].			(self isIntegerObject: fieldOop)				ifTrue: ["Just an integer -- nothing to do"						fieldPtr _ fieldPtr + 4]				ifFalse:				[header _ self longAt: fieldOop.				(header bitAnd: TypeMask) = HeaderTypeFree					ifTrue: ["Has already been forwarded -- this is the link"							mapOop _ header bitAnd: AllButTypeMask]					ifFalse:					[((self longAt: fieldOop) bitAnd: MarkBit) = 0						ifTrue:							["Points to an unmarked obj -- an internal pointer.							Copy the object into the segment, and forward its oop."							lastIn _ lastIn + 4.							lastIn >= hdrBaseIn ifTrue: [lastIn _ lastIn - 4.  successFlag _ false].							lastSeg _ self copyObj: fieldOop toSegment: segmentWordArray addr: lastSeg stopAt: firstIn saveOopAt: lastIn headerAt: hdrBaseIn + (lastIn - firstIn).							successFlag ifFalse:								["Out of space in segment"								self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.								^ self primitiveFailAfterCleanup: outPointerArray].							mapOop _ (self longAt: fieldOop) bitAnd: AllButTypeMask]						ifFalse:							["Points to a marked obj -- an external pointer.							Map it as a tagged index in outPointers, and forward its oop."							lastOut _ lastOut + 4.							lastOut >= hdrBaseOut ifTrue:								["Out of space in outPointerArray"								lastOut _ lastOut - 4.								self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.								^ self primitiveFailAfterCleanup: outPointerArray]..							mapOop _ lastOut - outPointerArray bitOr: 16r80000000.							self forward: fieldOop to: mapOop								savingOopAt: lastOut andHeaderAt: hdrBaseOut + (lastOut - firstOut)]].					"Replace the oop by its mapped value"					doingClass						ifTrue: [self longAt: fieldPtr put: mapOop + hdrTypeBits.								fieldPtr _ fieldPtr + 8.								doingClass _ false]						ifFalse: [self longAt: fieldPtr put: mapOop.								fieldPtr _ fieldPtr + 4].]].		segOop _ self objectAfter: segOop].	self restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut.	"Truncate the outPointerArray..."	((outPointerArray + (self lastPointerOf: outPointerArray) - lastOut) < 12		or: [(endSeg - lastSeg) < 12]) ifTrue:			["Not enough room to insert simple 3-word headers"			^ self primitiveFailAfterCleanup: outPointerArray].	extraSize _ self extraHeaderBytes: segmentWordArray.	hdrTypeBits _ self headerType: segmentWordArray.	"Copy the 3-word wordArray header to establish a free chunk."	self transfer: 3		from: segmentWordArray - extraSize		to: lastOut+4.	"Adjust the size of the original as well as the free chunk."	self longAt: lastOut+4		put: outPointerArray + (self lastPointerOf: outPointerArray) - lastOut - extraSize + hdrTypeBits.	self longAt: outPointerArray-extraSize		put: lastOut - firstOut + 8 + hdrTypeBits.	"Note that pointers have been stored into roots table"	self beRootIfOld: outPointerArray.	"Truncate the image segment..."	"Copy the 3-word wordArray header to establish a free chunk."	self transfer: 3		from: segmentWordArray - extraSize		to: lastSeg+4.	"Adjust the size of the original as well as the free chunk."	self longAt: segmentWordArray-extraSize		put: lastSeg - segmentWordArray + BaseHeaderSize + hdrTypeBits.	self longAt: lastSeg+4		put: endSeg - lastSeg - extraSize + hdrTypeBits.	self pop: 3  "...leaving the reciever on the stack as return value"! !!Interpreter methodsFor: 'image segment in/out' stamp: 'di 3/24/1999 22:24'!restoreHeadersFrom: firstIn to: lastIn from: hdrBaseIn and: firstOut to: lastOut from: hdrBaseOut	"Restore headers smashed by forwarding links"	| tablePtr oop header |	tablePtr _ firstIn.	[tablePtr <= lastIn] whileTrue:		[oop _ self longAt: tablePtr.		header _ self longAt: hdrBaseIn + (tablePtr-firstIn).		self longAt: oop put: header.		tablePtr _ tablePtr + 4].	tablePtr _ firstOut.	[tablePtr <= lastOut] whileTrue:		[oop _ self longAt: tablePtr.		header _ self longAt: hdrBaseOut + (tablePtr-firstOut).		self longAt: oop put: header.		tablePtr _ tablePtr + 4].		"Clear all mark bits"	oop _ self firstObject.	[oop < endOfMemory] whileTrue:		[(self isFreeObject: oop) ifFalse:			[self longAt: oop put: ((self longAt: oop) bitAnd: AllButMarkBit)].		oop _ self objectAfter: oop].! !!ObjectMemory class methodsFor: 'initialization' stamp: 'di 3/19/1999 14:22'!initialize	"ObjectMemory initialize"	"Translation flags (booleans that control code generation via conditional translation):"	DoAssertionChecks _ false.  "generate assertion checks"	self initializeSpecialObjectIndices.	self initializeObjectHeaderConstants.	LargeContextSize _ 156.	CtxtTempFrameStart _ 6.  "Copy of TempFrameStart in Interp"	NilContext _ 1.  "the oop for the integer 0; used to mark the end of context lists"	MinimumForwardTableBytes _ 16000.  "bytes reserved for forwarding table (8 bytes/entry)"	RemapBufferSize _ 25.	RootTableSize _ 2500.  "number of root table entries (4 bytes/entry)"	"tracer actions"	StartField _ 1.	StartObj _ 2.	Upward _ 3.	Done _ 4.! !!ObjectMemory class methodsFor: 'initialization' stamp: 'di 3/19/1999 09:44'!initializeSpecialObjectIndices	"Initialize indices into specialObjects array."	NilObject _ 0.	FalseObject _ 1.	TrueObject _ 2.	SchedulerAssociation _ 3.	ClassBitmap _ 4.	ClassInteger _ 5.	ClassString _ 6.	ClassArray _ 7.	"SmalltalkDictionary _ 8."  "Do not delete!!"	ClassFloat _ 9.	ClassMethodContext _ 10.	ClassBlockContext _ 11.	ClassPoint _ 12.	ClassLargePositiveInteger _ 13.	TheDisplay _ 14.	ClassMessage _ 15.	ClassCompiledMethod _ 16.	TheLowSpaceSemaphore _ 17.	ClassSemaphore _ 18.	ClassCharacter _ 19.	SelectorDoesNotUnderstand _ 20.	SelectorCannotReturn _ 21.	TheInputSemaphore _ 22.	SpecialSelectors _ 23.	CharacterTable _ 24.	SelectorMustBeBoolean _ 25.	ClassByteArray _ 26.	ClassProcess _ 27.	CompactClasses _ 28.	TheTimerSemaphore _ 29.	TheInterruptSemaphore _ 30.	FloatProto _ 31.	SelectorCannotInterpret _ 34.	MethodContextProto _ 35.	BlockContextProto _ 37.	ExternalObjectsArray _ 38.	ClassPseudoContext _ 39.	ClassTranslatedMethod _ 40.	TheFinalizationSemaphore _ 41.! !!Interpreter class methodsFor: 'initialization' stamp: 'di 3/16/1999 21:40'!initializePrimitiveTable 	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveArrayBecomeOneWay)	"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveStoreStackp)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveBlockCopy)		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveStoreImageSegment)		(99 primitiveLoadImageSegment)		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFlushCacheByMethod)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)			"Squeak 2.2 and earlier use 119.  Squeak 2.3 and later use 116.			Both are supported for backward compatibility."		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 primStringfindSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveInstVarsPutFromStack) "Never used except in Disney tests.  Remove after 2.3 release."		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!Interpreter class methodsFor: 'translation' stamp: 'di 3/24/1999 08:31'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]"	"Interpreter patchInterp: 'Squeak VM PPC'"	| cg |	BitBltSimulation initialize.	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: BitBltSimulation.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	BitBltSimulation declareCVarsIn: cg.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	{FFTPlugin. FloatArrayPlugin. Matrix2x3Plugin. 	BalloonEngineBase. BalloonEnginePlugin} do:[:plugin|		plugin initialize.		cg addClass:plugin.		plugin declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!PopUpChoiceMorph methodsFor: 'copying' stamp: 'di 3/24/1999 09:57'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target].arguments _ arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].getItemsArgs _ getItemsArgs collect: [:each |	deepCopier references at: each ifAbsent: [each]].choiceArgs ifNotNil: [choiceArgs _ choiceArgs collect: [:each |	deepCopier references at: each ifAbsent: [each]]].! !!SystemDictionary methodsFor: 'special objects' stamp: 'di 3/19/1999 09:20'!recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	Smalltalk virtual machine.  Its contents are critical and unchecked,	so don't even think of playing here unless you know what you are doing."	| newArray |	newArray _ Array new: 42.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (Smalltalk associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk. 	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18)  "(low space Semaphore)".	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.  "*unused*"	"An array of the 32 selectors that are compiled as special bytecodes,	paired alternately with the number of arguments each takes."	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 blockCopy: 1 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30)   "(delay Semaphore)".	newArray at: 31 put: (self specialObjectsArray at: 31)   "(user input Semaphore)".	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	newArray at: 36 put: (MethodContext new: CompiledMethod fullFrameSize).	newArray at: 37 put: nil.	newArray at: 38 put: (BlockContext new: CompiledMethod fullFrameSize).	newArray at: 39 put: Array new.  "array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	newArray at: 42 put: Semaphore new. "finalization Semaphore"	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows freeContexts interruptCheckCounter displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize BlockContextProto CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClassMask CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero CtxtTempFrameStart DoAssertionChecks Done ExternalObjectsArray FalseObject FloatProto GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextSize MarkBit MethodContextProto MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotInterpret SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SizeMask SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!ObjectMemory initialize!"Postscript:Install the selector for null methodDictionary faults"Smalltalk specialObjectsArray at: 35 put: #cannotInterpret:.!