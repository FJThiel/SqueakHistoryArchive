'From Squeak2.9alpha of 17 July 2000 [latest update: #2901] on 26 October 2000 at 5:12:55 pm'!"Change Set:		moreProxiesDate:			26 October 2000Author:			Bob Arning- ensure proper substitution of DiskProxy for Project when publishing projects that refer to other projects- shave a little time off publishing by starting with a bigger segment and not garbage collecting after every failed attempt"!!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 10/26/2000 17:07'!copyFromRoots: aRootArray sizeHint: segSizeHint	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize rootSet uniqueRoots |	aRootArray ifNil: [self errorWrongState].	(Symbol classPool at: #SelectorTables) first first class == WeakArray ifTrue: [		Symbol useArrayTables].	"Hold onto Symbols.  Done only once."	rootSet _ IdentitySet new: aRootArray size * 3.	uniqueRoots _ OrderedCollection new.	1 to: aRootArray size do: [:ii |	"Don't include any roots twice"		(rootSet includes: (aRootArray at: ii)) 			ifFalse: [				uniqueRoots addLast: (aRootArray at: ii).				rootSet add: (aRootArray at: ii)]			ifTrue: [userRootCnt ifNotNil: ["adjust the count"						ii <= userRootCnt ifTrue: [userRootCnt _ userRootCnt - 1]]]].	arrayOfRoots _ uniqueRoots asArray.	rootSet _ uniqueRoots _ nil.	"be clean"	userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].	arrayOfRoots do: [:aRoot | (aRoot respondsTo: #indexIfCompact) ifTrue: [		aRoot indexIfCompact > 0 ifTrue: [			self error: 'Compact class ', aRoot name, ' cannot be a root']].		aRoot _ nil].	"clean up"	outPointers _ nil.	"may have used this instance before"	segSize _ segSizeHint > 0 ifTrue: [segSizeHint *3 //2] ifFalse: [50000].	["Guess a reasonable segment size"	segmentWordArray _ WordArrayForSegment new: segSize.	[outPointerArray _ Array new: segSize // 20] ifError: [		state _ #tooBig.  ^ self].	"Smalltalk garbageCollect."	"OK, I did!! Remove this when everyone is using the new VM"	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 10/26/2000 17:09'!copySmartRootsExport: rootArray 	"Use SmartRefStream to find the object.  Make them all roots.  Create the segment in memory.  Project should be in first five objects in rootArray."	| newRoots list segSize symbolHolder dummy replacements |	Smalltalk forgetDoIts.  	symbolHolder _ Symbol allInstances.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy insideASegment: true.	"So Uniclasses will be traced"	dummy rootObject: rootArray.	"inform him about the root"	dummy nextPut: rootArray.	SmartRefStream new uniClassInstVarsRefs: dummy.		"catalog the extra objects in UniClass inst vars.  Put into dummy"	"refs _ dummy references."	arrayOfRoots _ self smartFillRoots: dummy.	replacements _ dummy blockers.	dummy project ifNil: [self error: 'lost the project!!'].	dummy project class == DiskProxy ifTrue: [self error: 'saving the wrong project'].	dummy _ nil.	"force GC?"		"Creation of the segment happens here"	"try using one-quarter of memory to publish (will get bumped later)"	self copyFromRoots: arrayOfRoots sizeHint: (Smalltalk garbageCollect // 4 // 4).	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods, blocks from outPointers"	list _ self compactClassesArray.	outPointers _ outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil].		"substitute new object in outPointers"		(replacements includesKey: (outPointers at: ii)) ifTrue: [			outPointers at: ii put: (replacements at: (outPointers at: ii))]].	symbolHolder.! !!Project methodsFor: 'file in/out' stamp: 'RAA 10/26/2000 16:58'!objectForDataStream: refStrm	| uu dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	"Use a copy with no parent, previous or next to reduce extra stuff copied"	refStrm project == self ifTrue: [^ self copy setParent: nil].	dp _ (uu _ self url) size > 0 ifTrue: [		DiskProxy global: #Project selector: #namedUrl: args: {uu}.	] ifFalse: [		DiskProxy global: #Project selector: #named: args: {self name}	].	refStrm replace: self with: dp.	^ dp! !