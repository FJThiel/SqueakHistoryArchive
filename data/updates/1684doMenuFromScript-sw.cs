'From Squeak2.6 of 11 October 1999 [latest update: #1682] on 1 December 1999 at 3:17:09 pm'!"Change Set:		doMenuFromScript-swDate:			1 December 1999Author:			Scott WallaceAdds the ability, in the end-user scripting system, for any menu item pertaining to the scriptee to be invoked.  Thus, any menu item that you see in a morph's halo menu can now be invoked either directly from its Viewer or programmatically from a script.Debug items are normally excluded from the list of choices offered on an invoke-menu tile; to get them included, manually modify Preferences method #debugMenuItemsInvokableFromScripts.Incidentally, adds a 'bring to front' menu item to every morph's halo menu, in symmetry with the 'send to back' item.Incidentally, also incorporates a bulletproofing fix into FlapTab.positionObject:, which was missing from early versions of update 1678."!TileMorph subclass: #MenuTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!!Morph methodsFor: 'menus' stamp: 'sw 12/1/1999 13:21'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	aMenu add: 'copy Postscript' action: #clipPostscript.	aMenu add: 'print PS to file...' target: self selector: #printPSToFile.	self player ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	"Add the fill style items"	self addFillStyleMenuItems: aMenu hand: aHandMorph.	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu addLine.	aMenu defaultTarget: self topRendererOrSelf.	aMenu add: 'draw new path' action: #definePath.	(self hasProperty: #pathPoints) ifTrue:		[aMenu add: 'follow path' action: #followPath.		aMenu add: 'delete path' action: #deletePath].	(owner == nil) ifFalse:		[aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'sw 12/1/1999 14:58'!adhereToEdge	| menu result |	menu _ MVCMenuMorph new defaultTarget: self.	#(top right bottom left topLeft topRight bottomRight bottomLeft none) do:		[:anEdge |			menu add: anEdge action: anEdge.			((anEdge == #left) | (anEdge == #bottomLeft))				ifTrue:					[menu addLine]].	result _ menu invokeAt: self currentHand position in: self currentWorld.	result ifNotNil: [self setToAdhereToEdge: result]! !!Morph methodsFor: 'menus' stamp: 'sw 11/23/1999 14:20'!allMenuWordings	| tempMenu |	tempMenu _ self currentHand buildMorphHandleMenuFor: self.	tempMenu allMorphsDo: [:m | m step].  "Get wordings current"	^ tempMenu allWordings! !!Morph methodsFor: 'menus' stamp: 'sw 11/26/1999 17:56'!doMenuItem: menuString	| aMenu anItem aNominalEvent aHand |	aMenu _ (aHand _ self currentHand) buildMorphHandleMenuFor: self.	aMenu allMorphsDo: [:m | m step].  "Get wordings current"	anItem _ aMenu itemWithWording: menuString.	anItem ifNil:		[^ self player scriptingError: 'Menu item not found: ', menuString].	aHand setArgument: self.	aNominalEvent _  MorphicEvent new		setMousePoint: 0@0		buttons: Sensor primMouseButtons		lastEvent: aHand lastEvent		hand: aHand.	anItem invokeWithEvent: aNominalEvent! !!Morph methodsFor: 'menus' stamp: 'sw 11/22/1999 12:13'!menuItemAfter: menuString	| allWordings |	allWordings _ self allMenuWordings.	^ allWordings atWrap: ((allWordings indexOf: menuString) + 1)! !!Morph methodsFor: 'menus' stamp: 'sw 11/22/1999 12:14'!menuItemBefore: menuString	| allWordings |	allWordings _ self allMenuWordings.	^ allWordings atWrap: ((allWordings indexOf: menuString) - 1)! !!AssignmentTileMorph methodsFor: 'arrow' stamp: 'sw 11/22/1999 11:14'!addArrowsIfAppropriate	"If the receiver's slot is of an appropriate type, add arrows to the tile"	(#(number sound boolean menu) includes: dataType)  ifTrue: [self addArrows]! !!FlapTab methodsFor: 'positioning' stamp: 'sw 11/30/1999 13:14'!positionObject: anObject	"anObject could be myself or my referent"	| container |	(container _ self currentWorld viewBox) ifNil: [^ self].	"Could consider container _ referent pasteUpMorph, to allow flaps on things other than the world, but for the moment, let's skip it!!"	(edgeToAdhereTo == #left) ifTrue:		[^ anObject left: container left].	(edgeToAdhereTo == #right) ifTrue:		[^ anObject right: container right].	(edgeToAdhereTo == #top) ifTrue:		[^ anObject top: container top].	(edgeToAdhereTo == #bottom) ifTrue:		[^ anObject bottom: container bottom]! !!MenuMorph methodsFor: 'accessing' stamp: 'sw 12/1/1999 13:05'!allWordings	| verboten |	"Answer a collection of the wordings of all items and subitems, omitting debug menu"	verboten _ Preferences debugMenuItemsInvokableFromScripts 		ifTrue:	[nil]		ifFalse:	['debug...'].	^ self allWordingsNotInSubMenu: verboten! !!MenuMorph methodsFor: 'accessing' stamp: 'sw 11/23/1999 12:58'!allWordingsNotInSubMenu: verbotenSubmenuContents	| aList aSubMenu |	"Answer a collection of the wordings of all items and subitems, but omit the stay-up item, and also any items in a submenu whose tag is given by erbotenSubmenuContents"	aList _ OrderedCollection new.	self items do:		[:anItem |			(anItem selector == #toggleStayUp:) ifFalse:				[(aSubMenu _ anItem subMenu)					ifNotNil:						[(anItem contents asString = verbotenSubmenuContents)							ifFalse:								[aList addAll: aSubMenu allWordings]]					ifNil:						[aList add: anItem contents asString]]].	^ aList! !!MenuMorph methodsFor: 'accessing' stamp: 'sw 11/22/1999 10:25'!itemWithWording: wording	| aString aSubmenu subItem |	"If any of the receiver's items or submenu items have the given wording (case-blind comparison done), then return it, else return nil."	aString _ wording asString asLowercase.	self items do:		[:anItem |			(anItem contents asString asLowercase = aString) ifTrue: [^ anItem].			(aSubmenu _ anItem subMenu) ifNotNil:				[(subItem _ aSubmenu itemWithWording: wording) ifNotNil: [^ subItem]]].	^ nil! !!MenuTile commentStamp: 'sw 11/22/1999 11:26' prior: 0!A tile representing a menu item!!MenuTile methodsFor: 'as yet unclassified' stamp: 'sw 11/22/1999 11:54'!arrowAction: delta	| phrase aPlayer newItem |	(phrase _ self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	aPlayer _ phrase associatedPlayer.	newItem _ delta > 0		ifTrue:			[aPlayer menuItemAfter: literal]		ifFalse:			[aPlayer menuItemBefore: literal].	self literal: newItem.	self layoutChanged! !!MenuTile methodsFor: 'as yet unclassified' stamp: 'sw 11/22/1999 12:15'!handlesMouseDown: evt	^ true! !!MenuTile methodsFor: 'as yet unclassified' stamp: 'sw 12/1/1999 13:17'!initialize	super initialize.	self addArrows; setLiteral: 'send to back'.	submorphs first useStringFormat! !!MenuTile methodsFor: 'as yet unclassified' stamp: 'sw 12/1/1999 13:13'!mouseDown: evt	| aPoint aMenu reply |	aPoint _ evt cursorPoint.	nArrowTicks _ 0.	upArrow ifNotNil:		[(upArrow boundsInWorld containsPoint: aPoint) ifTrue: [^ self].		(downArrow boundsInWorld containsPoint: aPoint) ifTrue: [^ self]].	aMenu _ SelectionMenu selections: (self ownerThatIsA: PhraseTileMorph) associatedPlayer costume allMenuWordings.	reply _ aMenu startUp.	reply ifNotNil: [self literal: reply; layoutChanged]! !!MenuTile methodsFor: 'as yet unclassified' stamp: 'sw 11/22/1999 11:27'!resultType	^ 'menu'! !!MenuTile methodsFor: 'as yet unclassified' stamp: 'sw 11/22/1999 12:10'!trumpsMouseDown: evt	"Return true if this morph wants to handle mouse down events even when the mouse is pressed under a submorph that also wishes to preepmpt mouse down events. Complete the comment."	^ true! !!Morph class methodsFor: 'misc' stamp: 'sw 12/1/1999 13:50'!categoryContributions	"Answer a list of arrays which characterize the elements in various viewer categories for the etoy system.  Implementors of this method are statically polled to contribute this information when the scripting system reinitializes its scripting info, which typically only happens after a structural change.	Each array returned has two elements.  The first is the category name, and the second is a an array of <elementType> <elementName> pairs, where <elementType is #slot or #script"	^ #(		('basic' ((slot x) (slot y) (slot heading) (script forward:)				 (script turn:) (script beep:) ))		('color & border'( (slot color) (slot colorUnder) (slot borderColor) (slot borderWidth)))		('geometry'  ((slot scaleFactor) (slot left) (slot right) (slot top) (slot bottom) (slot width) (slot height) (slot x) (slot y) (slot heading)))		('miscellaneous' ((script doMenuItem:) (script show) (script hide) (script wearCostumeOf:) (script startScript:) (script stopScript:) (script pauseScript:)))		('motion' ((slot x) (slot y) (slot heading) (script forward:) (script moveToward:) (script turn:) (script bounce:) (script wrap) (script followPath) (script goToRightOf:)))		('pen use' ((slot penColor) (slot penSize) (slot penDown)))		('tests' ((slot isOverColor) (slot isUnderMouse) (slot colorSees))))! !!Morph class methodsFor: 'misc' stamp: 'sw 11/30/1999 08:52'!helpContributions	"Answer a list of pairs of the form		<symbol> <help message> 	to contribute to the system help dictionary"	^ #(		(acceptScript:for:			'submit the contents of the given script editor as the code defining the given selector')		(actorState			'return the ActorState object for the receiver, creating it if necessary')		(addInstanceVariable			'start the interaction for adding a new instance variable to the receiver')		(addPlayerMenuItemsTo:hand:			'add player-specific menu items to the given menu, on behalf of the given hand.  At present, these are only commands relating to the turtle')		(addSlotNamedLike:withValue:			'add a slot with a unique name derived from the first parameter, giving it the second parameter as its initial value')		(addYesNoToHand			'Press here to tear off a  TEST/YES/NO unit which you can drop into your script')		(allScriptEditors			'answer a list off the extant ScriptEditors for the receiver')		(amount			'The amount of displacement')		(angle				'The angular displacement')		(anonymousScriptEditorFor:			'answer a new ScriptEditor object to serve as the place for scripting an anonymous (unnamed, unsaved) script for the receiver')		(assignDecrGetter:setter:amt:			'evaluate the decrement variant of assignment')		(assignGetter:setter:amt:			'evaluate the vanilla variant of assignment')		(assignIncrGetter:setter:amt:			'evalute the increment version of assignment')		(assignMultGetter:setter:amt:			'evaluate the multiplicative version of assignment')		(assureEventHandlerRepresentsStatus			'make certain that the event handler associated with my current costume is set up to conform to my current script-status')		(assureExternalName			'If I do not currently have an external name assigned, get one now')		(assureUniClass			'make certain that I am a member a uniclass (i.e. a unique subclass); if I am not, create one now and become me into an instance of it')		(availableCostumeNames			'answer a list of strings representing the names of all costumes currently available for me')		(availableCostumesForArrows			'answer a list of actual, instantiated costumes for me, which can be cycled through as the user hits a next-costume or previous-costume button in a viewer')		(beep:			'make the specified sound')		(borderColor			'The color of the object''s border')		(borderWidth			'The width of the object''s border')		(bottom			'My bottom edge, measured downward from the top edge of the world')		(bounce:			'If object strayed beyond the boundaries of its container, make it reflect back into it, making the specified noise while doing so.')		(chooseTrigger'When this script should run."normal" means "only when called"')		(clearTurtleTrails			'Clear all the pen trails in the interior.')		(color				'The object''s interior color')		(colorSees			'Whether a given color in the object is over another given color')		(colorUnder			'The color under the center of the object')		(cursor				'The index of the chosen element')		(deleteCard			'Delete the current card.')		(dismiss			'Click here to dismiss me')		(firstPage			'Go to first page of book')		(followPath				'Retrace the path the object has memorized, if any.')		(forward:			'Moves the object forward in the direction it is heading') 		(goto:			'Go to the specfied book page')		(goToNextCard			'Go to the next card')		(goToPreviousCard			'Go to the previous card.')		(goToRightOf:			'Align the object just to the right of any specified object.')		(heading			'Which direction the object is facing.  0 is straight up') 		(height				'The distance between the top and bottom edges of the object')		(hide			'Make the object so that it does not display and cannot handle input')		(initiatePainting				'Initiate painting of a new object in the standard playfield.')		(initiatePaintingIn:			'Initiate painting of a new object in the given place.')		(isOverColor			'Whether any part of this object is directly over the specified color')		(isUnderMouse			'Whether any part of this object is beneath the current mouse-cursor position')		(lastPage			'Go to the last page of the book.')		(left			'My left edge, measured from the left edge of the World')		(leftRight			'The horizontal displacement')		(liftAllPens			'Lift the pens on all the objects in my interior.')		(lowerAllPens			'Lower the pens on all the objects in my interior.')		(mouseX			'The x coordinate of the mouse pointer')		(mouseY			'The y coordinate of the mouse pointer')		(moveToward:			'Move in the direction of another object.')		(newCard			'Create a new card.')		(nextPage			'Go to next page.')		(objectNameInHalo			'Object''s name -- To change: click here, edit, hit ENTER')		(offerScriptorMenu			'Owner and script name.Press to get a menu')		(pauseScript:			'Make a running script become paused.')		(penDown			'Whether the object''s pen is down (true) or up (false)')		(penColor			'The color of the object''s pen')		(penSize				'The size of the object''s pen')		(previousPage			'Go to previous page')		(show			'If object was hidden, make it show itself again.')		(startScript:			'Make a script start running.')		(stopScript:			'Make a script stop running.')		(top			'My top edge, measured downward from the top edge of the world')		(right			'My right edge, measured from the left edge of the world')		(roundUpStrays			'Bring all out-of-container subparts back into view.')		(scaleFactor			'The amount by which the object is scaled')		(stopScript:			'make the specified script stop running')		(try			'Run this command once.')		(tryMe			'Click here to run this script once; hold button down to run repeatedly.')		(turn:							'Change the heading of the object by the specified amount')		(unhideHiddenObjects			'Unhide all hidden objects.')		(upDown			'The vertical displacement')		(userScript			'This is a script defined by you.  Click here to rename or delete it')		(userSlot			'This is an instance variable defined by you.  Click here to change its type')		(valueAtCursor			'The chosen element')		(wearCostumeOf:			'Wear the same kind of costume as the other object')		(width				'The distance between the left and right edges of the object')		(wrap			'If object has strayed beond the boundaries of its container, make it reappear from the opposite edge.')		(x			'The x coordinate, measured from the left of the container')		(y			'The y-coordinate, measured upward from the bottom of the container')		)! !!Morph class methodsFor: 'misc' stamp: 'sw 11/22/1999 11:14'!scriptInfo	"Answer a list of arrays which characterize etoy script commands understood by this kind of morph -- in addition to those already defined by superclasses.  Implementors of this method are statically polled to contribute this information when the scripting system reinitializes its scripting info, which typically only happens after a structural change."	^ #((command beep: sound)		(command bounce: sound)		(command forward: number)		(command followPath)		(command goToRightOf: player)		(command doMenuItem: menu)		(command hide)		(command makeNewDrawingIn: player)		(command moveToward: player)		(command pauseScript: string)		(command show)		(command startScript: string)		(command stopScript: string)		(command turn: number)		(command wearCostumeOf: player)		(command wrap))! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/22/1999 11:27'!tileForArgType: typeSymbol	| aColor |	typeSymbol == #player ifTrue:		[^ self tileForPlayer:  self presenter standardPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #menu ifTrue: [^ MenuTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/22/1999 11:27'!tileForArgType: typeSymbol inViewer: aViewer	| aColor aPlayer |	typeSymbol == #player ifTrue:		[aPlayer _ self presenter			ifNotNil:				[self presenter standardPlayer]			ifNil:  "It happens, if costume is not currently in a world"				[self].		^ aViewer tileForPlayer:  aPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #menu ifTrue: [^ MenuTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!Player methodsFor: 'slots-kernel' stamp: 'sw 11/22/1999 10:08'!worldTilePhrasesSpecsForCategory: aCategory	"Return an array of slot and script names and info for use in a viewer on the receiver, in the situation where the receiver's costume is the World.   Categories 'instance variables' and 'scripts'  will already have been taken care of and need not be dealt with here."	| aList categoryString |	categoryString _ aCategory asString.	aList _ #().	(categoryString = 'basic') ifTrue:		[aList _ #((script beep:) (script doMenuItem:))].	(categoryString = 'color & border') ifTrue:		[aList _ #((slot color))].	(categoryString = 'miscellaneous') ifTrue:		[aList _ #((script startScript:) (script stopScript:) (script pauseScript:))].	(categoryString = 'pen trails') ifTrue:		[aList _ #((script liftAllPens) (script lowerAllPens) (script clearTurtleTrails))].	(categoryString = 'playfield') ifTrue:		[aList _ #((script initiatePainting) (slot cursor) (slot valueAtCursor) (slot mouseX) (slot mouseY)(script roundUpStrays) (script unhideHiddenObjects))].	^ aList collect: [:aPair | self phraseSpecFor: aPair]! !!Player methodsFor: 'scripts-execution' stamp: 'sw 12/1/1999 13:12'!scriptingError: aMessage	"An error arose, characterized by aMessage, when a script was being run.  For the moment, we report it to the transcript only"	Transcript cr; show: 'Scripting error for ', self externalName, ': ', aMessage! !!Player methodsFor: 'scripts-standard' stamp: 'sw 11/22/1999 10:09'!doMenuItem: menuString	self costume doMenuItem: menuString! !!Player methodsFor: 'scripts-standard' stamp: 'sw 11/22/1999 11:50'!menuItemAfter: menuString	^ self costume menuItemAfter: menuString! !!Player methodsFor: 'scripts-standard' stamp: 'sw 11/22/1999 11:55'!menuItemBefore: menuString	^ self costume menuItemBefore: menuString! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'sw 12/1/1999 13:04'!debugMenuItemsInvokableFromScripts	"If true, then items occurring in an object's debug menu will be included in the alternatives offered as arguments to a doMenuItem: tile in the scripting system"	^ false! !!StandardScriptingSystem methodsFor: 'tile colors' stamp: 'sw 11/22/1999 11:28'!initializeTypeColors	"ScriptingSystem initializeTypeColors"	TypeColorDictionary _ IdentityDictionary new.	#(		(command		(0.065 0.258 1.0)		(0.065 0.258 1.0))	(number		(0.8 0.4 0.2)			(1.0	0.6 0.2))	(boolean		(0.94 1.0 0.06)		(0.94 1.0 0.06))  		"some kind of yellowish"	(player			(1.0  0 0.065)		(1.0  0 0.065)) 	(color			(1.0  0 0.065)		(0.806 1.0 0.806))  	"some damn dark red"	(sound			(1.0 0.06 0.84)		(1.0 0.06 0.84))   	"a kind of magenta"	(menu			(0.4 0.4 0.4)			(0.4 0.4 0.4))		"arbitrary"	(object			(1.0 0.26 0.98)		(1.0 0.26 0.98))   		(rotationStyle	(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(string			(0.0 0.0 1.0)			(0.0 0.0 1.0))      "not in use"	(group			(0.0 0.0 1.0)			(0.0 0.0 1.0))		 "not in use"	(costume		(0.806 1.0 0.806)	(0.806 1.0 0.806))		 "not in use")			do:		[:t | TypeColorDictionary at: t first put:			(Array 	with: 	((Color fromRgbTriplet: t second) mixed: self colorFudge with: ScriptingSystem uniformTileInteriorColor)					with:	(Color fromRgbTriplet: t third))]! !"Postscript:"StandardScriptingSystem initialize.ScriptingSystem initializeTypeColors.!