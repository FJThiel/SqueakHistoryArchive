'From Squeak3.1alpha of 5 February 2001 [latest update: #3767] on 3 March 2001 at 3:54:49 pm'!"Change Set:		syntax11Date:			3 March 2001Author:			Bob Arning- fix a few of the problems converting new syntax morphs back to ST code-- reply-- blank block argsstill to do is the new #collect:"!!SyntaxMorph methodsFor: 'initialization' stamp: 'RAA 3/1/2001 08:52'!returnNode: aNode expression: expr	| row expMorph sMorph aNoiseString |	row _ self addRow: #return on: aNode.	self alansTest1 ifTrue: [		row setSpecialOuterTestFormat.		aNoiseString _ ' Reply '.		sMorph _ self aSimpleStringMorphWith: aNoiseString.		sMorph 			emphasis: 1;			color: (self colorForKeywords: aNoiseString and: aNoiseString);			setProperty: #syntacticallyCorrectContents toValue: '^'.		row addMorphBack: sMorph.	] ifFalse: [		row addToken: '^ ' type: #upArrow on: aNode.	].	expMorph _ expr asMorphicSyntaxIn: row.	self alansTest1 ifTrue: [		(expMorph hasProperty: #deselectedColor) ifFalse: [expMorph setConditionalPartStyle].	].	expr addCommentToMorph: row.	^row! !!SyntaxMorph methodsFor: 'initialization' stamp: 'tk 1/19/2001 13:29'!sample: arg1"a comment"| temp1 |temp1 _ 5.temp1 yourself.temp1 min: arg1.! !!SyntaxMorph methodsFor: 'printing' stamp: 'RAA 3/3/2001 15:51'!printOn: strm indent: level	| lev nodeClass parens cnt argString |	"Tree walk and produce text of the code.  #ST80.  Just do it in one big ugly method."	lev _ level.	(nodeClass _ parseNode class) == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner isMethodNode ifFalse: [strm nextPut: $[.  lev _ lev+1]]].				"normal block has []"	nodeClass == VariableNode ifTrue: ["nil out any old association"		parseNode key class == Association ifTrue: [			parseNode name: (parseNode name) key: nil code: (parseNode code)]].	(nodeClass == MessageNode or: [nodeClass == CascadeNode]) ifTrue: [		parseNode receiver ifNotNil: [parens _ true.  strm nextPut: $( ]].	"has a receiver"	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; space].	nodeClass == MethodNode ifTrue: [		(self findA: SelectorNode) ifNil: [			(self getHeader: strm) ifFalse: [^ self]]].		"might fail"	cnt _ 0.	submorphs do: [:sub |		sub isSyntaxMorph ifTrue: [cnt _ cnt + 1.			(nodeClass == CascadeNode "and: [sub isCascadePart]") ifTrue:				[cnt > 2 ifTrue: [strm nextPutAll: '; ']].			nodeClass == BlockArgsNode ifTrue: [				(argString _ sub decompile) isEmpty ifFalse: [					strm nextPut: $:; nextPutAll: argString				].			] ifFalse: [				sub printOn: strm indent: lev.	"<<<<### install the subnode"			].			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not	&				(sub parseNode class == ReturnNode) not					ifTrue: [strm nextPut: $.].			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not				ifTrue: [strm crtab: lev]				ifFalse: [self isMethodNode ifTrue: [strm crtab: lev] ifFalse: [strm space]].			].		(sub isKindOf: StringMorph) ifTrue: [			self printSimpleStringMorph: sub on: strm		].		"return indent for ifTrue: ifFalse:"].	parens == true ifTrue: [strm nextPut: $) ].	"has a receiver"	nodeClass  == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner isMethodNode ifFalse: [strm nextPut: $] ]]].				"normal block has []"	nodeClass == BlockArgsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodNode ifTrue: [		strm contents last "ugh!!" == $. ifTrue: [strm skip: -1]].  "erase last period"! !!SyntaxMorph methodsFor: 'menus' stamp: 'RAA 3/1/2001 08:43'!addMorphBack: m"m setProperty: #howAdded toValue: thisContext longStack."	^super addMorphBack: m! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 3/1/2001 08:40'!alansMessageNode: aNode receiver: receiver selector: selector keywords: key arguments: args	| row receiverMorph testAndReceiver anotherSelf 		wordyMorph template |	template _ self alansTemplateStyleFor: key.	receiver ifNotNil: ["i.e. not a cascade"		anotherSelf _ self constructSelfVariant: receiver and: key.		anotherSelf ifNotNil: [			wordyMorph _ self addString: anotherSelf special: false.			wordyMorph setProperty: #wordyVariantOfSelf toValue: true.			self addMorph: wordyMorph. 			self layoutInset: 1.			^self		].		testAndReceiver _ self.		template = 1 ifTrue: [			testAndReceiver _ self addRow: #keyword1 on: nil.			self setSpecialOuterTestFormat.			testAndReceiver addNoiseString: 'Test'		].		false "template = 2" ifTrue: [			testAndReceiver _ self addRow: #keyword1 on: nil.			"self setSpecialOuterTestFormat."			testAndReceiver addNoiseString: 'Repeat for'		].		receiverMorph _ receiver asMorphicSyntaxIn: testAndReceiver.		template = 1 ifTrue: [receiverMorph setConditionalPartStyle].	].	"unary messages"	args size = 0 ifTrue: [		"((receiverMorph notNil) and: [receiverMorph nodeClassIs: MessageNode]) ifTrue: [			self addMorphBack: self tokenVerticalSeparator		]."		row _ (self addUnaryRow: key style: #unary) layoutInset: 1.		^ row parseNode: selector	].	"binary messages"	key last = $: ifFalse: [		^self alanBinaryPostRcvr: aNode key: key args: args	].	"keyword messages"	receiverMorph ifNotNil: [receiverMorph setConditionalPartStyle].	self setSpecialOuterTestFormat.	self		alanKeywordMessage: aNode 		isAConditional: template 		key: key 		args: args! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 3/1/2001 09:04'!blockNodeCollect: aNode arguments: arguments statements: statements	| row column c2 r2 r3 |	column _ self addColumn: #blockCollectOnly on: nil "aNode".	column layoutInset: (self alansTest1 ifTrue: [1] ifFalse: [2@-1]).	aNode addCommentToMorph: column.	arguments size > 0 ifTrue: [		row _ column addRow: #blockarg1 on: (BlockArgsNode new).		row addNoiseString: 'collect using' emphasis: 1.		r3 _ row addRow: #blockarg1b on: nil "aNode".		r3 setConditionalPartStyle.		arguments do: [:arg | 			r3 addToken: arg name type: #blockarg2 on: arg		]	].	r2 _ column addRow: #block on: aNode.	r2 addNoiseString: 'from' emphasis: 1.	c2 _ r2 addColumn: #block on: aNode.	statements do: [ :each | 		(each asMorphicSyntaxIn: c2) borderWidth: 1.		each addCommentToMorph: c2	].	^ column! !