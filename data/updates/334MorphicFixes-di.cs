'From Squeak 2.2 of Sept 23, 1998 on 1 October 1998 at 3:58:09 pm'!"Change Set:		MorphicFixes-diDate:			30 September 1998Author:			Dan IngallsMakes the default color for DropShadows be black.Makes HandMorph>>grabMorph: work properly when grabbing from a flexed context.Makes implementors of wantsDroppedMorph:event: transform global coordinates.Makes black and brown-handled moves work properly in flexed contexts.Makes command-drag work properly in flexed contexts.Makes colorUnder work properly in flexed contexts, 	at least to the extent that fullDrawOn has not been overridden.Improves accuracy of flexMorph bounds and responsiveness during flexing.Makes color:sees: and touchesColor: work correctly in flexes."!!CompositeTransform methodsFor: 'transformations' stamp: 'di 10/1/1998 13:51'!invert: aPoint	^ globalTransform invert: (localTransform invert: aPoint)! !!Morph methodsFor: 'drawing' stamp: 'di 9/30/1998 15:34'!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].	submorphs isEmpty ifFalse:		["draw back-to-front"		submorphs reverseDo: [:m | m fullDrawOn: aCanvas]].  ! !!Morph methodsFor: 'drawing' stamp: 'di 10/1/1998 11:42'!fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere	"Like fullDrawOn:, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns true if it has hit stopMorph, and should stop."	(aCanvas isVisible: self fullBounds) ifFalse: [^ false].	(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].	submorphs isEmpty ifFalse:		["draw back-to-front"		submorphs reverseDo:			[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ true]]				ifFalse: [(m fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere)								ifTrue: [^ true]]]].  	^ false! !!Morph methodsFor: 'drawing' stamp: 'di 10/1/1998 11:53'!imageFormWithout: stopMorph andStopThere: stopThere	"Like imageForm, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns a pair of the imageForm and a boolean that is true		if it has hit stopMorph, and display should stop."	| canvas rect hitStop |	rect _ self fullBounds.	canvas _ FormCanvas extent: rect extent depth: Display depth.	hitStop _ self fullDrawOn: (canvas copyOffset: rect topLeft negated)					without: stopMorph andStopThere: stopThere.	^ Array with: (canvas form offset: rect topLeft)			with: hitStop! !!Morph methodsFor: 'geometry' stamp: 'di 9/30/1998 10:37'!pointFromWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFrom: self world) transform: aPoint.! !!Morph methodsFor: 'geometry' stamp: 'di 9/30/1998 12:11'!positionInWorld	^ self pointInWorld: self position.! !!Morph methodsFor: 'geometry eToy' stamp: 'di 10/1/1998 15:10'!color: sensitiveColor sees: soughtColor	"Return true if any of my pixels of sensitiveColor intersect with pixels of soughtColor."	| myImage sensitivePixelMask map patchBelowMe tfm morphAsFlexed i1 |	"Make a mask with black where sensitiveColor is, white elsewhere"	tfm _ self transformFrom: self world.	morphAsFlexed _ tfm isIdentity		ifTrue: [self]		ifFalse: [TransformationMorph new					flexing: self clone					byTransformation: tfm].	myImage _ morphAsFlexed imageForm offset: 0@0.	sensitivePixelMask _ Form extent: myImage extent depth: 1.	map _ Bitmap new: (1 bitShift: (myImage depth min: 15)).	map at: (i1 _ sensitiveColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: sensitivePixelMask boundingBox		from: myImage form at: 0@0 colorMap: map.	"get an image of the world below me"	patchBelowMe _ self world patchAt: morphAsFlexed fullBounds								without: self andNothingAbove: false."sensitivePixelMask displayAt: 0@0.patchBelowMe displayAt: 100@0."	"intersect world pixels of the color we're looking for with the sensitive pixels"	map at: i1 put: 0.  "clear map and reuse it"	map at: (soughtColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: patchBelowMe boundingBox		from: patchBelowMe at: 0@0 clippingBox: patchBelowMe boundingBox		rule: Form and fillColor: nil map: map."sensitivePixelMask displayAt: 200@0."	^ (sensitivePixelMask tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'geometry eToy' stamp: 'di 10/1/1998 15:54'!touchesColor: soughtColor	"Return true if any of my pixels overlap pixels of soughtColor."	| map patchBelowMe shadowForm tfm morphAsFlexed |	"Make a sahdow mask with black in my shape, white elsewhere"	tfm _ self transformFrom: self world.	morphAsFlexed _ tfm isIdentity		ifTrue: [self]		ifFalse: [TransformationMorph new					flexing: self clone					byTransformation: tfm].	shadowForm _ morphAsFlexed shadowForm offset: 0@0.	"get an image of the world below me"	patchBelowMe _ (self world patchAt: morphAsFlexed fullBounds								without: self andNothingAbove: false) offset: 0@0."shadowForm displayAt: 0@0.patchBelowMe displayAt: 100@0."	"intersect world pixels of the color we're looking for with our shape."	map _ Bitmap new: (1 bitShift: (patchBelowMe depth min: 15)).	map at: (soughtColor indexInMap: map) put: 1.	shadowForm copyBits: patchBelowMe boundingBox		from: patchBelowMe		at: 0@0		clippingBox: patchBelowMe boundingBox		rule: Form and		fillColor: nil		map: map."shadowForm displayAt: 200@0."	^ (shadowForm tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 9/30/1998 10:43'!wantsDroppedMorph: aMorph event: evt	"Return true if the receiver wishes to accept the given morph, which is being dropped by a hand in response to the given event. The default implementation returns false.NOTE: the event is assumed to be in global (world) coordinates."	^ (self valueOfProperty: #openToDragAndDrop) == true! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/30/1998 10:38'!wantsDroppedMorph: aMorph event: evt	(currentPage bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifFalse: [^ false].	^ super wantsDroppedMorph: aMorph event: evt! !!DropShadowMorph methodsFor: 'initialization' stamp: 'di 9/30/1998 08:21'!initialize	super initialize.	self color: Color black.	shadowOffset _ 3@3! !!HaloMorph methodsFor: 'private' stamp: 'di 9/30/1998 11:32'!doDrag: evt with: dragHandle	target setConstrainedPositionFrom:		(target pointFromWorld: evt cursorPoint - positionOffset).! !!HaloMorph methodsFor: 'private' stamp: 'di 9/30/1998 12:07'!startDrag: evt with: dragHandle	"Drag my target without removing it from its owner."	self removeAllHandlesBut: dragHandle.	positionOffset _ dragHandle center - target positionInWorld.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 9/30/1998 10:44'!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drops into the world."	| newOwner morphToDrop tfm localPt |	owner ifNil: [^ self].	self changed.	self submorphsReverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		newOwner _ self dropTargetFor: m event: evt.		newOwner ifNil:  "Drop not allowed"			[^ self rejectDropMorph: m event: evt].		morphToDrop _ newOwner morphToDropFrom: m. 		morphToDrop == m ifFalse: [submorphs size == 1 ifTrue:			[self privateRemoveMorph: m.			m privateOwner: nil]].		"the above says: the thing to drop is not what I was carrying; silently vaporize what I was carrying lest it cause trouble later; keep the owner/submorph relationship invariant, but don't go through the standard delete protocol"		tfm _ newOwner transformFromWorld.		localPt _ tfm transform: self position.		morphToDrop position: localPt + (morphToDrop position - self position).		newOwner acceptDroppingMorph: morphToDrop event: evt.		morphToDrop justDroppedInto: newOwner event: evt.		morphToDrop owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 9/30/1998 12:39'!grabMorph: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor localPt |	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike ifTrue:		[editor _ m topEditor].	localPt _ m pointFromWorld: self position.	(m owner isKindOf: DropShadowMorph)		ifTrue:			[self grabMorph: m owner]		ifFalse:			[m aboutToBeGrabbedBy: self.			m position: self position + (m position - localPt).			gridOn ifTrue: [m position: (m position grid: grid)].			self addMorphBack: m].	editor ifNotNil: [editor scriptEdited]! !!HandMorph methodsFor: 'special gestures' stamp: 'di 9/30/1998 12:06'!specialDrag: evt	"Special drag (cmd-mouse on the Macintosh) allows a morph to be dragged without grabbing it and thus without removing it from its owner or changing its z-order." 	| halo |	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	mouseDownMorph		ifNil:    ["Waiting for more than 5 pixels move to start drag"				(self position dist: targetOffset) > 5					ifTrue: [(halo _ self world haloMorphOrNil) ifNil: [^ self].							mouseDownMorph _ halo target.							targetOffset _ targetOffset - mouseDownMorph positionInWorld.							halo removeAllHandlesBut: nil]]		ifNotNil: [mouseDownMorph setConstrainedPositionFrom:					(mouseDownMorph pointFromWorld: self position - targetOffset)].! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/30/1998 10:38'!wantsDroppedMorph: aMorph event: evt	(self isPartsBin or: [self openToDragNDrop]) not ifTrue: [^ false].	(self bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifFalse: [^ false].	((aMorph isKindOf: SystemWindow) and: [Preferences allowSysWindowEmbedding not])		ifTrue:	[^ false].	^ true ! !!TabbedPalette methodsFor: 'user-interface' stamp: 'di 9/30/1998 10:39'!wantsDroppedMorph: aMorph event: evt	(tabsMorph bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifTrue:		[^ false  "unless it's a book, perhaps, someday"].	^ currentPage wantsDroppedMorph: aMorph event: evt! !!TextContainer methodsFor: 'container protocol' stamp: 'di 9/30/1998 23:17'!rectanglesAt: lineY height: lineHeight	"Return a list of rectangles that are at least minWidth wide	in the specified horizontal strip of the shadowForm.	Cache the results for later retrieval if the owner does not change."	| hProfile rects thisWidth thisX count pair outerWidth lineRect lineForm |	pair _ Array with: lineY with: lineHeight.	rects _ rectangleCache at: pair ifAbsent: [nil].	rects ifNotNil: [^ rects].	outerWidth _ minWidth + (2*OuterMargin).	self shadowForm.  "Compute the shape".	lineRect _ 0@(lineY - shadowForm offset y)					extent: shadowForm width@lineHeight.	lineForm _ shadowForm copy: lineRect.	"Check for a full line -- frequent case"	(lineForm tallyPixelValues at: 2) = lineRect area	ifTrue:		[rects _ Array with: (shadowForm offset x@lineY extent: lineRect extent)]	ifFalse:		["No such luck -- scan the horizontal profile for segments of minWidth"		hProfile _ lineForm xTallyPixelValue: 1 orNot: false.		rects _ OrderedCollection new.		thisWidth _ 0.  thisX _ 0.		1 to: hProfile size do:			[:i | count _ hProfile at: i.			count >= lineHeight ifTrue:				[thisWidth _ thisWidth + 1]				ifFalse:				[thisWidth >= outerWidth ifTrue:					[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)].				thisWidth _ 0. thisX _ i]].		thisWidth >= outerWidth ifTrue:				[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)]].	rects _ rects collect: [:r | r insetBy: OuterMargin@0].	rectangleCache at: pair put: rects.	^ rects! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/1/1998 15:54'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds,	and to translate, rotate and scale as appropriate."	| clippingCanvas sourceQuad imageForm imageQuad warp innerRect |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	transform isPureTranslation		ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]]		ifFalse:		[innerRect _ self innerBounds.		sourceQuad _ transform sourceQuadFor: innerRect.		submorphs reverseDo:			[:m | imageForm _ m imageFormDepth: aCanvas depth.			imageQuad _ sourceQuad collect: [:p | p - imageForm offset].			warp _ aCanvas warpFrom: imageQuad toRect: innerRect.			warp cellSize: smoothing;  "installs a colormap if smoothing > 1"				sourceForm: imageForm;				warpBits]]	! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/1/1998 11:53'!fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere	"Like fullDrawOn:, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns true if it has hit stopMorph, and should stop."	| clippingCanvas sourceQuad imageForm imageQuad warp innerRect pair hitStop |	(aCanvas isVisible: self bounds) ifFalse: [^ false].	self drawOn: aCanvas.	transform isPureTranslation		ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo:			[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ true]]				ifFalse: [(m fullDrawOn: clippingCanvas without: stopMorph andStopThere: stopThere)								ifTrue: [^ true]]]]		ifFalse:		[innerRect _ self innerBounds.		sourceQuad _ transform sourceQuadFor: innerRect.		submorphs reverseDo:			[:m | m == stopMorph ifTrue: [stopThere ifTrue: [^ true]].			pair _ m imageFormWithout: stopMorph andStopThere: stopThere.			imageForm _ pair first.			hitStop _ pair second.			imageQuad _ sourceQuad collect: [:p | p - imageForm offset].			warp _ aCanvas warpFrom: imageQuad toRect: innerRect.			warp cellSize: smoothing;  "installs a colormap if smoothing > 1"				sourceForm: imageForm;				warpBits.			hitStop ifTrue: [stopThere ifTrue: [^ true]]]].	^ false! !!TransformationMorph methodsFor: 'initialization' stamp: 'di 9/30/1998 23:12'!flexing: aMorph byTransformation: tfm	"Initialize me with position and bounds of aMorph,	and with an offset that provides centered rotation."	(aMorph isKindOf: TransformationMorph)		ifTrue: [aMorph submorphsDo: [:m | self addMorph: m clone]]		ifFalse: [self addMorph: aMorph].	transform _ tfm.	self chooseSmoothing.	self layoutChanged.! !!TransformationMorph methodsFor: 'change reporting' stamp: 'di 9/30/1998 15:12'!layoutChanged	"Recompute bounds as a result of change"	self hasSubmorphs ifTrue:		[bounds _ (Rectangle merging:					(self submorphs collect:						[:m | transform invertRect: m fullBounds]))				expandBy: 1].	super layoutChanged! !!TransformationMorph methodsFor: 'private' stamp: 'di 9/30/1998 22:49'!adjustAfter: changeBlock 	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| oldRefPos |	oldRefPos _ self referencePosition.	changeBlock value.	self chooseSmoothing.	self penUpWhile: [self position: self position + (oldRefPos - self referencePosition)].	self layoutChanged.	owner ifNotNil: [owner invalidRect: bounds]! !!TransformationMorph methodsFor: 'private' stamp: 'di 9/30/1998 22:48'!chooseSmoothing	"Choose appropriate smoothing, after a change of scale or rotation."	(self scale < 1.0 or: [self angle ~= (self angle roundTo: Float pi / 2.0)])		ifTrue: [smoothing _ 2]		ifFalse: [smoothing _ 1]! !!WorldMorph methodsFor: 'sensing' stamp: 'di 10/1/1998 12:02'!colorAt: aPoint belowMorph: aMorph	"Return the color of the pixel immediately behind the given morph at the given point."	^ (self patchAt: (aPoint extent: 1@1) without: aMorph andNothingAbove: true)		colorAt: 0@0! !!WorldMorph methodsFor: 'sensing' stamp: 'di 10/1/1998 12:01'!patchAt: patchRect without: stopMorph andNothingAbove: stopThere	"Return a complete rendering of this patch of the display screen	without stopMorph, and possibly without anything above it."	| c |	c _ FormCanvas extent: patchRect extent depth: Display depth.	c _ c copyOrigin: patchRect topLeft negated clipRect: (0@0 extent: patchRect extent).	(self bounds containsRect: patchRect) ifFalse:		["Need to fill area outside bounds with black."		c form fillColor: Color black].	(self bounds intersects: patchRect) ifFalse:		["Nothing within bounds to show."		^ c form].	c fillColor: color.  "Fill bounds with world color."	submorphs reverseDo:		[:m | (m fullDrawOn: c without: stopMorph andStopThere: stopThere)				ifTrue: [^ c form]].  	hands reverseDo: [:h |		h submorphsReverseDo:		[:m | m == stopMorph			ifTrue: [stopThere ifTrue: [^ c form]]			ifFalse: [(m fullDrawOn: c without: stopMorph andStopThere: stopThere)						ifTrue: [^ c form]]]].  	^ c form! !Morph removeSelector: #morphsIn:!Morph removeSelector: #morphsIn:addTo:!TransformMorph removeSelector: #morphsIn:addTo:!WorldMorph removeSelector: #patchAt:belowMorph:!