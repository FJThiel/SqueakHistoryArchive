'From Squeak 2.0 of May 22, 1998 on 26 May 1998 at 9:47:46 pm'!"Change Set:		serversInRoot-diDate:			27 May 1998Author:			Dan IngallsCauses the FileList to display all known ServerDirectories along with other mounted volumes when the root [ ] is chosen in the fileList.  This lets you browse directly to remote sites without having to use a menu command.  Returning to the root and the local disk also works properly.Also fixed a number of bugs in remote directory browsing...You can now see file names with embedded blanksYou can browse up and down the remote directory structureAlso fixes 'add server' and adds 'remove server'."!!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:05'!askServerInfo	"Get the user to create a ServerDirectory for a new server.  Fill in and say Accept."	| template |	template _ '"Please fill in the following info, then select all text and choose DoIt."| aa | aa _ ServerDirectory new.aa server: ''st.cs.uiuc.edu''.    "host"aa user: ''anonymous''.aa password: ''yourEmail@school.edu''.aa directory: ''/Smalltalk/Squeak/Goodies''.aa url: ''''.    "<- this is optional.  Only used when *writing* update files."ServerDirectory addServer: aa named: ''UIUCArchive''.  "<- known by this name in Squeak"'.	(StringHolder new contents: template) openLabel: 'FTP Server Form'	! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:35'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries sizePad newList allFiles |	entries _ directory entries.	sizePad _ (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList _ sortMode == #name  "case-insensitive compare"		ifTrue: [(SortedCollection new: 30) sortBlock: [:x :y | (x compare: y) <= 2]]		ifFalse: [(SortedCollection new: 30) sortBlock: [:x :y | (x compare: y) >= 2]].	allFiles _ pat = '*'.	entries do:		[:entry | "<name><creationTime><modificationTime><dirFlag><fileSize>"		(allFiles or: [pat match: entry first]) ifTrue:			[newList add: (self fileNameFormattedFrom: entry sizePad: sizePad)]].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes"		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	^ newList! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:08'!removeServer	| choice names |	names _ ServerDirectory serverNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	ServerDirectory removeServerNamed: choice! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 16:49'!volumeListIndex: index	"Select the volume name having the given index."	| delim path |	volListIndex _ index.	index = 1 		ifTrue: [self directory: (FileDirectory on: '')]		ifFalse: [delim _ directory pathNameDelimiter.				path _ String streamContents: [:strm |					2 to: index do: [:i |						strm nextPutAll: (volList at: i) withBlanksTrimmed.						i < index ifTrue: [strm nextPut: delim]]].				self directory: (directory on: path)].	brevityState _ #FileList.	self changed: #fileList.	self changed: #contents.! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:07'!volumeMenu: aMenu	^ aMenu		labels:'add server...remove server...'		lines: # ()		selections: #(askServerInfo removeServer)! !!FileList methodsFor: 'file list' stamp: 'di 5/26/1998 20:22'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex _ anInteger.	listIndex = 0 		ifTrue: [fileName _ nil]		ifFalse:			[item _ self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name _ item copyFrom: 1 to: item size - self folderString size.					listIndex _ 0.					brevityState _ #FileList.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [self directory: (directory directoryNamed: name)]]				ifFalse: [fileName _ item]].  "open the file selected"	brevityState _ #needToGetBrief.	self changed: #fileListIndex.	self changed: #contents.! !!FileList methodsFor: 'private' stamp: 'di 5/26/1998 20:39'!fileNameFromFormattedItem: item	"Extract fileName and folderString from a formatted fileList item string"	| i |	(i _ item indexOf: $( ifAbsent: [0]) = 0 ifTrue: [^ item withBlanksTrimmed].	^ (item copyReplaceFrom: i to: (item findLast: [:c | c = $)]) with: '') withBlanksTrimmed! !!FileList methodsFor: 'private' stamp: 'di 5/26/1998 20:56'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first and last 1000 characters. Don't create a file if it doesn't already exist."	| f fileSize first2000 |	listIndex = 0 ifTrue: [^ self defaultContents].	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	(brevityFlag not or: [(fileSize _ f size) <= 30000])		ifTrue: [^ f contentsOfEntireFile].	"if brevityFlag is true, don't display long files when first selected"	first2000 _ f next: 2000.	f close.	^ 'File ''', fileName, ''' is ', fileSize printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 2000 characters...------------------------------------------', first2000 , '------------------------------------------... end of the first 2000 characters.'! !!ServerDirectory methodsFor: 'accessing' stamp: 'di 5/26/1998 20:53'!fullPath: serverAndDirectory	"Parse and save a full path"	| start bare |	bare _ serverAndDirectory.	bare size > 7 ifTrue: [ 		start _ (bare copyFrom: 1 to: 8) asLowercase.		(start beginsWith: 'ftp://') 			ifTrue: [type _ #ftp.				bare _ bare copyFrom: 7 to: bare size].		(start beginsWith: 'http://') 			ifTrue: [type _ #http.				bare _ bare copyFrom: 8 to: serverAndDirectory size]].	server _ bare copyUpTo: self pathNameDelimiter.	bare size > (server size + 1) 		ifTrue: [directory _ bare copyFrom: server size + 1 to: bare size]		ifFalse: [directory _ ''].! !!ServerDirectory methodsFor: 'file directory' stamp: 'di 5/26/1998 21:46'!entries	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name><creationTime><modificationTime><dirFlag><fileSize>)."	| ftpEntries thisYear tokens dateInSeconds longy |	"We start with ftp directory entries of the form...d---------   1 owner    group               0 Apr 27 22:01 blasttest
----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM    1        2   3           4                 5    6  7    8       9   -- token index"	ftpEntries _ self getDirectory contentsOfEntireFile findTokens: FTPSocket crLf.	thisYear _ Date today year.	^ ftpEntries collect:		[:ftpEntry | tokens _ ftpEntry findTokens: ' '.		tokens size >= 9		ifTrue:		[tokens size > 9 ifTrue:			[longy _ tokens at: 9.			10 to: tokens size do: [:i | longy _ longy , ' ' , (tokens at: i)].			tokens at: 9 put: longy].		dateInSeconds _ ((tokens at: 8) includes: $:)			ifTrue: ["Date has no year -- assume this year"					(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: thisYear) asSeconds +					(Time readFrom: (ReadStream on: (tokens at: 8))) asSeconds]			ifFalse: [(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: (tokens at: 8) asNumber) asSeconds].		Array with: (tokens at: 9)  "file name"			with: dateInSeconds "creation date"			with: dateInSeconds "modification time"			with: tokens first first = $d "is-a-directory flag"			with: tokens fifth asNumber "file size"]		ifFalse:		[nil]]		thenSelect: [:entry | entry notNil]! !FileDirectory removeSelector: #folderString!FileList removeSelector: #openServer!FileList removeSelector: #showLocalDir!ServerDirectory removeSelector: #folderString!