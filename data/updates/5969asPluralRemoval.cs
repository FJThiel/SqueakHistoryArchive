'From Squeak3.7beta of ''1 April 2004'' [latest update: #5963] on 29 June 2004 at 1:33:35 pm'!"Change Set:		asPluralRemovalDate:			29 June 2004Author:			Yoshiki OhshimaRemove asPlural."!!Object methodsFor: 'accessing' stamp: 'yo 6/29/2004 11:39'!at: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue:		[self class isVariable			ifTrue: [self errorSubscriptBounds: index]			ifFalse: [self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'yo 6/29/2004 13:08'!at: index put: value 	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[self class isVariable			ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]]			ifFalse: [self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'private' stamp: 'yo 6/29/2004 11:37'!errorNotIndexable	"Create an error notification that the receiver is not indexable."	self error: ('Instances of {1} are not indexable' translated format: {self class name})! !!Collection methodsFor: 'private' stamp: 'yo 6/29/2004 13:14'!errorNotKeyed	self error: ('Instances of {1} do not respond to keyed accessing messages.' translated format: {self class name})! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'yo 6/29/2004 13:31'!writeClassRenameMethod: sel was: oldName fromInstVars: oldList 	"The class coming is unknown.  Ask the user for the existing class it maps to.  If got one, write a method, and restart the obj fileIn.  If none, write a dummy method and get the user to complete it later.  "	| tell choice newName answ code oldVer newList newVer instSel |	self flag: #bobconv.	tell := 'Reading an instance of ' , oldName 				, '.Which modern class should it translate to?'.	answ := (PopUpMenu 				labels: 'Let me type the name nowLet me think about itLet me find a conversion file on the disk') 					startUpWithCaption: tell.	answ = 1 		ifTrue: 			[tell := 'Name of the modern class {1} should translate to:' translated format: {oldName}.			choice := FillInTheBlank request: tell.	"class name"			choice size = 0 				ifTrue: [answ := 'conversion method needed']				ifFalse: 					[newName := choice.					answ := Smalltalk at: newName asSymbol								ifAbsent: ['conversion method needed'].					answ class == String 						ifFalse: [renamed at: oldName asSymbol put: answ name]]].	answ = 3 | (answ = 0) 		ifTrue: 			[self close.			^'conversion method needed'].	answ = 2 ifTrue: [answ := 'conversion method needed'].	answ = 'conversion method needed' 		ifTrue: 			[self close.			newName := 'PutNewClassHere'].	answ class == String 		ifFalse: 			[oldVer := self versionSymbol: (structures at: oldName).			newList := (Array with: answ classVersion) , answ allInstVarNames.			newVer := self versionSymbol: newList.			instSel := 'convert' , oldVer , ':' , newVer , ':'].	code := WriteStream on: (String new: 500).	code		nextPutAll: sel;		cr.	answ class == String 		ifFalse: 			[code				cr;				tab;				nextPutAll: 'reshaped at: #' , oldName , ' put: #' , instSel , '.'.			code				cr;				tab;				tab;				nextPutAll: '"Be sure to define that conversion method in class ' 							, answ name , '"'].	code		cr;		tab;		nextPutAll: '^ ' , newName.	"Return new class"	self class compile: code contents classified: 'conversion'.	newName = 'PutNewClassHere' 		ifTrue: 			[self 				inform: 'Please complete the following method and then read-in the object file again.'.			self systemNavigation browseAllImplementorsOf: sel asSymbol].	self flag: #violateBasicLayerPrinciples.	"SmartRefStream should not refer to UI!!!!!!!!!! (sd)"	"The class version number only needs to change under one specific circumstance.  That is when the first letters of the instance variables have stayed the same, but their meaning has changed.  A conversion method is needed, but this system does not know it.  	If this is true for class Foo, define classVersion in Foo class.  	Beware of previous object fileouts already written after the change in meaning, but before bumping the version number.  They have the old (wrong) version number, say 2.  If this is true, your method must be able to test the data and successfully read files that say version 2 but are really 3."	^answ! !String removeSelector: #asPlural!