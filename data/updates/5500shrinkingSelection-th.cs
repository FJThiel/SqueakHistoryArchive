'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5423] on 21 October 2003 at 4:21:01 pm'!"Change Set:		shrinkingSelectionDate:			20 September 2002Author:			Torge Husfeldtv0.4 - back to normal changesetRemoved need to rename instvars ofand thus recompile ParagraphEditor.Made new behavior the default.v0.3 - Moved to SAR-Format Should remove most of the compatibility issuesv0.2 - ParenBlinking compatibility Changed class definition of ParagraphEditor to play nicely with Avi's ParenBlinking Package. Note that the other way round things still get broken. i.e when you first file in ShrinkingSelection and than Avi's ParenBlinking you will have to execute the postscript found at the end of this cs again in order to have a stable system.v0.1 - initialDoes a complete overhaul of cursor movement in ParagraphEditors.Adds two preferences:#selectionsMayShrink#wordStyleCursorMovementWhen left alone everything should work the same as before.When the first is set to true, cursor movement will be able to shrink a selection by changing its direction.When the second is set to true, cursor movement will adhere to displayed lines rather than logical lines. Difference only visible in paragraphs with automatically wrapped lines.[moved the additon of the preferences to the postscript (je)]"!!CharacterBlock methodsFor: 'comparing' stamp: 'th 9/17/2002 11:54'!max: aCharacterBlock	aCharacterBlock ifNil:[^self].	^aCharacterBlock > self		ifTrue:[ aCharacterBlock]		ifFalse:[self].! !!CharacterBlock methodsFor: 'comparing' stamp: 'th 9/17/2002 11:54'!min: aCharacterBlock	aCharacterBlock ifNil:[^self].	^aCharacterBlock < self		ifTrue:[ aCharacterBlock]		ifFalse:[self].! !!Paragraph methodsFor: 'selecting' stamp: 'th 9/19/2002 17:27'!extendSelectionMark: markBlock pointBlock: pointBlock 	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes."	true 		ifTrue:[^self mouseMovedFrom: pointBlock					pivotBlock: markBlock					showingCaret:(pointBlock = markBlock)]		ifFalse:		[	| beginBlock endBlock |			beginBlock _ markBlock min: pointBlock.			endBlock _ markBlock max: endBlock.				(self characterBlockAtPoint: Sensor cursorPoint) <= beginBlock				ifTrue: [^self mouseMovedFrom: beginBlock 							pivotBlock: endBlock							showingCaret: (beginBlock = endBlock)]				ifFalse: [^self mouseMovedFrom: endBlock 							pivotBlock: beginBlock							showingCaret: (beginBlock = endBlock)]		]! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'th 10/21/2003 15:49'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	stopBlock _ paragraph defaultCharacterBlock.	self pointBlock: stopBlock copy.	beginTypeInBlock _ nil.	UndoInterval _ otherInterval _ 1 to: 0.	self setEmphasisHere.	selectionShowing _ false.	initialText _ paragraph text copy! !!ParagraphEditor methodsFor: 'scrolling' stamp: 'th 9/17/2002 12:01'!scrollBy: heightToMove	"Move the paragraph by heightToMove, and reset the text selection."	^ paragraph scrollBy: heightToMove withSelectionFrom: self startBlock to: self stopBlock! !!ParagraphEditor methodsFor: 'sensor access' stamp: 'th 9/19/2002 18:24'!processRedButton	"The user pressed a red mouse button, meaning create a new text 	selection. Highlighting the selection is carried out by the paragraph 	itself. Double clicking causes a selection of the area between the nearest 	enclosing delimitors."	|  selectionBlocks clickPoint oldDelta oldInterval previousMarkBlock previousPointBlock |	clickPoint _ sensor cursorPoint.	(view containsPoint: clickPoint) ifFalse: [^ self].	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [^ self].	oldInterval _ self selectionInterval.	previousMarkBlock _ self markBlock.	previousPointBlock _ self pointBlock.	oldDelta _ paragraph scrollDelta.	sensor leftShiftDown		ifFalse:			[self deselect.			self closeTypeIn.			selectionBlocks _ paragraph mouseSelect: clickPoint]		ifTrue:			[selectionBlocks _ paragraph extendSelectionMark: self markBlock pointBlock: self pointBlock.			self closeTypeIn].	selectionShowing _ true.	self markBlock: (selectionBlocks at: 1).	self pointBlock: (selectionBlocks at: 2).	(self hasCaret		and: [previousMarkBlock = self markBlock and: [previousPointBlock = self pointBlock]])		ifTrue: [self selectWord].	oldDelta ~= paragraph scrollDelta "case of autoscroll"			ifTrue: [self updateMarker].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/19/2002 18:12'!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	self hasSelection ifFalse: [self flash.  ^ returnBlock value]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/20/2002 11:21'!paste	"Paste the text from the shared buffer over the current selection and 	redisplay if necessary.  Undoer & Redoer: undoAndReselect."	self replace: self selectionInterval with: self clipboardText and:		[self selectAt: self pointIndex]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/19/2002 18:27'!selectedSymbol	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"	| aString |	self hasCaret ifTrue: [^ nil].	aString _ self selection string copyWithoutAll:		{Character space.  Character cr.  Character tab}.	aString size == 0 ifTrue: [^ nil].	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].	^ nil! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/18/2002 17:28'!setAlignment: aSymbol	| attr interval |	attr _ TextAlignment perform: aSymbol.	interval _ self encompassLine: self selectionInterval.	paragraph replaceFrom: interval first to: interval last with:		((paragraph text copyFrom: interval first to: interval last) addAttribute: attr) displaying: true.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/19/2002 18:27'!setSearchString	"Make the current selection, if any, be the current search string."	self hasCaret ifTrue: [view flash. ^ self].	self setSearch:  self selection string! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:07'!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis. Emphasis change amounts to a font change.  Keeps typeahead."	| keyCode attribute oldAttributes index thisSel colors extras |		 "control 0..9 -> 0..9"	keyCode _ ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.	oldAttributes _ paragraph text attributesAt: self pointIndex forStyle: paragraph textStyle.	thisSel _ self selection.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 5) ifTrue:		[attribute _ TextFontChange fontNumber: keyCode].	keyCode = 6 ifTrue:		[colors _ #(black magenta red yellow green blue cyan white).		extras _ ((self class name = #TextMorphEditor) and: 			[(self morph isKindOf: TextMorphForEditView) not]) "not a system window"				ifTrue: [#()]				ifFalse: [#('Link to comment of class' 'Link to definition of class' 						'Link to hierarchy of class' 'Link to method')].		index _ (PopUpMenu labelArray: colors , #('choose color...' 'Do it' 'Print it'), 			extras, #('be a web URL link' 			'Edit hidden info' 'Copy hidden info')							lines: (Array with: colors size +1)) startUp.		index = 0 ifTrue: [^ true].		index <= colors size		ifTrue:			[attribute _ TextColor color: (Color perform: (colors at: index))]		ifFalse:			[index _ index - colors size - 1.	"Re-number!!!!!!"			index = 0 ifTrue: [attribute _ self chooseColor].			index = 1 ifTrue: [attribute _ TextDoIt new.				thisSel _ attribute analyze: self selection asString].			index = 2 ifTrue: [attribute _ TextPrintIt new.				thisSel _ attribute analyze: self selection asString].			(extras size = 0) & (index > 2) ifTrue: [index _ index + 5].	"skip those"			index = 3 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Comment'].			index = 4 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Definition'].			index = 5 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Hierarchy'].			index = 6 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString].			index = 7 ifTrue: [attribute _ TextURL new. 				thisSel _ attribute analyze: self selection asString].			index = 8 ifTrue: ["Edit hidden info"				thisSel _ self hiddenInfo.	"includes selection"				attribute _ TextEmphasis normal].			index = 9 ifTrue: ["Copy hidden info"				self copyHiddenInfo.  ^ true].	"no other action"		thisSel ifNil: [^ true]].	"Could not figure out what to link to"		].	(keyCode between: 7 and: 11) ifTrue:		[sensor leftShiftDown		ifTrue:			[keyCode = 10 ifTrue: [attribute _ TextKern kern: -1].			keyCode = 11 ifTrue: [attribute _ TextKern kern: 1]]		ifFalse:			[attribute _ TextEmphasis perform:					(#(bold italic narrow underlined struckOut) at: keyCode - 6).			oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]]].	(keyCode = 0) ifTrue:		[attribute _ TextEmphasis normal].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere _ Text addAttribute: attribute toArray: oldAttributes.			^ true].	self replaceSelectionWith: (thisSel asText addAttribute: attribute).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/20/2002 11:41'!duplicate: characterStream	"Paste the current selection over the prior selection, if it is non-overlapping and	 legal.  Flushes typeahead.  Undoer & Redoer: undoAndReselect."	sensor keyboard.	self closeTypeIn.	(self hasSelection and: [self isDisjointFrom: otherInterval])		ifTrue: "Something to duplicate"			[self replace: otherInterval with: self selection and:				[self selectAt: self pointIndex]]		ifFalse:			[view flash].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:01'!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char _ sensor keyboard.	self closeTypeIn.	startIndex _ self startIndex.	stopIndex _ self stopIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: char ifAbsent: [ ^true ].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	text _ paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:31'!hiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Return the entire string that was used by Cmd-6 to create this text attribute.  Usually enclosed in < >."	| attrList |	attrList _ paragraph text attributesAt: (self pointIndex +self markIndex)//2 forStyle: paragraph textStyle.	attrList do: [:attr |		(attr isKindOf: TextAction) ifTrue:			[^ self selection asString, '<', attr info, '>']].	"If none of the above"	attrList do: [:attr |		attr class == TextColor ifTrue:			[^ self selection asString, '<', attr color printString, '>']].	^ self selection asString, '[No hidden info]'! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:28'!inOutdent: characterStream delta: delta	"Add/remove a tab at the front of every line occupied by the selection. Flushes typeahead.  Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| cr realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |	sensor keyboard.  "Flush typeahead"	cr _ Character cr.	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart _ self startIndex.	realStop _ self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and:				[realStart < 2 or: [(paragraph string at: realStart - 1) == cr]])		ifTrue:			[delta < 0				ifTrue:					[view flash]				ifFalse:					[self replaceSelectionWith: Character tab asSymbol asText.					self selectAt: realStart + 1].			^true].	lines _ paragraph lines.	startLine _ paragraph lineIndexOfCharacterIndex: realStart.	stopLine _ paragraph lineIndexOfCharacterIndex: (realStart max: realStop).	start _ (lines at: startLine) first.	stop _ (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart _ realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation _ (startLine to: stopLine) inject: 1000 into:		[:m :l |		m _ m min: (paragraph indentationOfLineIndex: l ifBlank: [:tabs | 1000])].				size _  stop + 1 - start.	numLines _ stopLine + 1 - startLine.	inStream _ ReadStream on: paragraph string from: start to: stop.	newString _ String new: size + ((numLines * delta) max: 0).	outStream _ ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart _ (realStart + delta) max: start].	realStop _ realStop + outStream position - size.	"Prepare for another iteration"	indentation _ indentation + delta.	size _ outStream position.	inStream _ outStream setFrom: 1 to: size.	outStream == nil		ifTrue: 	"tried to outdent but some line(s) were already left flush"			[view flash]		ifFalse:			[self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString _ outStream contents].			self replaceSelectionWith: newString asText].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:21'!makeProjectLink: characterStream 	""	| attribute oldAttributes thisSel |		sensor keyboard.	oldAttributes _ paragraph text attributesAt: self pointIndex forStyle: paragraph textStyle.	thisSel _ self selection.	attribute _ TextSqkProjectLink new. 	thisSel _ attribute analyze: self selection asString.	thisSel ifNil: [^ true].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere _ Text addAttribute: attribute toArray: oldAttributes.			^ true].	self replaceSelectionWith: (thisSel asText addAttribute: attribute).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:48'!pasteInitials: characterStream 	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self replace: self selectionInterval with: (Text fromString: Utilities changeStamp) and: [self selectAt: self stopIndex].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:07'!setEmphasis: emphasisSymbol	"Change the emphasis of the current selection."	| oldAttributes attribute |	oldAttributes _ paragraph text attributesAt: self pointIndex forStyle: paragraph textStyle.	(emphasisSymbol == #plain) 		ifTrue:			[attribute _ TextEmphasis normal]		ifFalse:			[attribute _ TextEmphasis perform: emphasisSymbol.			oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	self replaceSelectionWith: (self selection addAttribute: attribute)! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:20'!shiftEnclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char _ sensor keyboard.	char = $9 ifTrue: [ char _ $( ].	char = $, ifTrue: [ char _ $< ].	char = $[ ifTrue: [ char _ ${ ].	char = $' ifTrue: [ char _ $" ].	char asciiValue = 27 ifTrue: [ char _ ${ ].	"ctrl-["	self closeTypeIn.	startIndex _ self startIndex.	stopIndex _ self stopIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: char ifAbsent: [1].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	text _ paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:00'!swapChars: characterStream 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  "	| currentSelection aString chars |	sensor keyboard.		"flush the triggering cmd-key character"	(chars _ self selection) size == 0		ifTrue:			[currentSelection _ self pointIndex.			self selectMark: currentSelection - 1 point: currentSelection]		ifFalse:			[chars size == 2				ifFalse:					[view flash.  ^ true]				ifTrue:					[currentSelection _ self pointIndex - 1]].	aString _ self selection string.	self replaceSelectionWith: (Text string: aString reversed emphasis: emphasisHere).	self selectAt: currentSelection + 1.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:08'!cursorDown: characterStream 	"Private - Move cursor from position in current line to same position in	next line. If next line too short, put at end. If shift key down,	select."	self closeTypeIn: characterStream.	self 		moveCursor:[:position | self				sameColumn: position				newLine:[:line | line + 1]				forward: true]		forward: true		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 10/21/2003 16:15'!cursorEnd: characterStream 	"Private - Move cursor end of current line."	| string |	self closeTypeIn: characterStream.	string _ paragraph text string.	self		moveCursor:			[:position | Preferences wordStyleCursorMovement				ifTrue:[| answer |					answer _ (paragraph lines at:(paragraph lineIndexOfCharacterIndex: position)) last.					answer = string size ifTrue:[answer + 1]ifFalse:[answer]]				ifFalse:[					string						indexOf: Character cr						startingAt: position						ifAbsent:[string size + 1]]]		forward: true		specialBlock:[:dummy | string size + 1].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/20/2002 12:14'!cursorHome: characterStream 	"Private - Move cursor from position in current line to beginning of	current line. If control key is pressed put cursor at beginning of text"	| string |	string _ paragraph text string.	self		moveCursor: [ :position | Preferences wordStyleCursorMovement				ifTrue:[					(paragraph lines at:(paragraph lineIndexOfCharacterIndex: position)) first]				ifFalse:[					(string						lastIndexOf: Character cr						startingAt: position - 1						ifAbsent:[0]) + 1]]		forward: false		specialBlock: [:dummy | 1].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/19/2002 20:07'!cursorLeft: characterStream 	"Private - Move cursor left one character if nothing selected, otherwise 	move cursor to beginning of selection. If the shift key is down, start 	selecting or extending current selection. Don't allow cursor past 	beginning of text"	self closeTypeIn: characterStream.	self		moveCursor:[:position | position - 1 max: 1]		forward: false		specialBlock:[:position | self previousWord: position].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:09'!cursorPageDown: characterStream 	self closeTypeIn: characterStream.	self 		moveCursor: [:position |			self				sameColumn: position				newLine:[:lineNo | lineNo + self pageHeight]				forward: true]		forward: true		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:09'!cursorPageUp: characterStream 	self closeTypeIn: characterStream.	self 		moveCursor: [:position |			self				sameColumn: position				newLine:[:lineNo | lineNo - self pageHeight]				forward: false]		forward: false		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/19/2002 20:01'!cursorRight: characterStream 	"Private - Move cursor right one character if nothing selected, 	otherwise move cursor to end of selection. If the shift key is down, 	start selecting characters or extending already selected characters. 	Don't allow cursor past end of text"	self closeTypeIn: characterStream.	self		moveCursor: [:position | position + 1]		forward: true		specialBlock:[:position | self nextWord: position].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:15'!cursorUp: characterStream "Private - Move cursor from position in current line to same position inprior line. If prior line too short, put at end"	self closeTypeIn: characterStream.	self		moveCursor: [:position | self				sameColumn: position				newLine:[:line | line - 1]				forward: false]		forward: false		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/20/2002 11:22'!argAdvance: characterStream	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.  Does not affect the undoability of the 	 	previous command."	| start |	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	start _ paragraph text findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [start _ paragraph text size + 1].	self selectAt: start + 2.	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 10/21/2003 15:46'!backWord: characterStream 	"If the selection is not a caret, delete it and leave it in the backspace buffer.	 Else if there is typeahead, delete it.	 Else, delete the word before the caret."	| startIndex |	sensor keyboard.	characterStream isEmpty		ifTrue:			[self hasCaret				ifTrue: "a caret, delete at least one character"					[startIndex _ 1 max: self markIndex - 1.					[startIndex > 1 and:						[(paragraph text at: startIndex - 1) asCharacter tokenish]]						whileTrue:							[startIndex _ startIndex - 1]]				ifFalse: "a non-caret, just delete it"					[startIndex _ self markIndex].			self backTo: startIndex]		ifFalse:			[characterStream reset].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/19/2002 18:23'!backspace: characterStream 	"Backspace over the last character."	| startIndex |	sensor leftShiftDown ifTrue: [^ self backWord: characterStream].	characterStream isEmpty		ifTrue:			[startIndex _ self markIndex +				(self hasCaret ifTrue: [0] ifFalse: [1]).			[sensor keyboardPressed and:			 [sensor keyboardPeek asciiValue = 8]] whileTrue: [				"process multiple backspaces"				sensor keyboard.				startIndex _ 1 max: startIndex - 1.			].			self backTo: startIndex]		ifFalse:			[sensor keyboard.			characterStream skip: -1].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/20/2002 11:25'!crWithIndent: characterStream 	"Replace the current text selection with CR followed by as many tabs	as on the current line (+/- bracket count) -- initiated by Shift-Return."	| char s i tabCount |	sensor keyboard.		"flush character"	s _ paragraph string.	i _ self stopIndex.	tabCount _ 0.	[(i _ i-1) > 0 and: [(char _ s at: i) ~= Character cr]]		whileTrue:  "Count tabs and brackets (but not a leading bracket)"		[(char = Character tab and: [i < s size and: [(s at: i+1) ~= $[ ]]) ifTrue: [tabCount _ tabCount + 1].		char = $[ ifTrue: [tabCount _ tabCount + 1].		char = $] ifTrue: [tabCount _ tabCount - 1]].	characterStream crtab: tabCount.  "Now inject CR with tabCount tabs"	^ false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/18/2002 11:39'!forwardDelete: characterStream	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex _ self mark.	startIndex > paragraph text size ifTrue:		[sensor keyboard.		^ false].	self hasSelection ifTrue:		["there was a selection"		sensor keyboard.		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval deepCopy.	upara _ UndoParagraph deepCopy.	stopIndex := startIndex.	(sensor keyboard asciiValue = 127 and: [sensor leftShiftDown])		ifTrue: [stopIndex := (self nextWord: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/19/2002 18:25'!querySymbol: characterStream	"Invoked by Ctrl-q to query the Symbol table and display alternate symbols.	 See comment in completeSymbol:lastOffering: for details."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	"keep typeahead"	self hasCaret		ifTrue: "Ctrl-q typed when a caret"			[self perform: #completeSymbol:lastOffering: withArguments:				((UndoParagraph == paragraph and: [UndoMessage sends: #undoQuery:lastOffering:])					ifTrue: [UndoMessage arguments] "repeated Ctrl-q"					ifFalse: [Array with: nil with: nil])] "initial Ctrl-q"		ifFalse: "Ctrl-q typed when statements were highlighted"			[view flash].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/19/2002 17:34'!simulatedBackspace	"Backspace over the last character, derived from hand-char recognition.  2/5/96 sw"	| startIndex |	startIndex _ self markIndex + (self hasSelection ifTrue: [1] ifFalse: [0]).	startIndex _ 1 max: startIndex - 1.	self backTo: startIndex.	^ false! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/19/2002 17:36'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit _ beginTypeInBlock		ifNil: [self openTypeIn. UndoSelection _ self nullText. self stopIndex]		ifNotNil: [self startOfTyping].	self setMark: startIndex.	startIndex < saveLimit ifTrue:		[newBackovers _ self startOfTyping - startIndex.		beginTypeInBlock _ self startIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	self unselect! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/19/2002 17:40'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Typing commands can call 'closeTypeIn: aCharacterStream' instead of this to	 save typeahead.  Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin stop |	beginTypeInBlock == nil ifFalse:		[(UndoMessage sends: #noUndoer) ifTrue: "should always be true, but just in case..."			[begin _ self startOfTyping.			stop _ self stopIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval _ begin to: stop - 1].		beginTypeInBlock _ nil]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/17/2002 16:23'!insertTypeAhead: typeAhead	typeAhead position = 0 ifFalse:		[self zapSelectionWith: (Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		self unselect]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/18/2002 16:48'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInBlock == nil ifTrue:		[UndoSelection _ self nullText.		self undoer: #noUndoer with: 0.		beginTypeInBlock _ self startIndex]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/19/2002 18:26'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead _ WriteStream on: (String new: 128).	[sensor keyboardPressed] whileTrue: 		[self deselect.		 [sensor keyboardPressed] whileTrue: 			[char _ sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue:				[self doneTyping.				self setEmphasisHere.				^self selectAndScroll; updateMarker].			self openTypeIn].		self hasSelection ifTrue: "save highlighted characters"			[UndoSelection _ self selection]. 		self zapSelectionWith: 			(Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		self unselect.		sensor keyboardPressed ifFalse: 			[self selectAndScroll.			sensor keyboardPressed				ifFalse: [self updateMarker]]]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/18/2002 16:49'!setEmphasisHere	emphasisHere _ (paragraph text attributesAt: (self pointIndex - 1 max: 1) forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/17/2002 16:23'!simulatedKeystroke: char	"Accept char as if it were struck on the keyboard.  This version does not yet deal with command keys, and achieves update in the receiver's typically inactive window via the sledge-hammer of uncache-bits."	self deselect.	self openTypeIn.	self markBlock = self pointBlock ifFalse: [UndoSelection _ self selection].	self zapSelectionWith:		(Text string: char asString emphasis: emphasisHere).	self userHasEdited.	self unselect.	self selectAndScroll.	self updateMarker.	view ifNotNil:		[view topView uncacheBits		"in mvc, this makes sure the recognized character shows up in the pane right now; in morphic, a different mechanism is used for the same effect -- see TextMorphEditor method #recognizeCharactersWhileMouseIn:"]! !!ParagraphEditor methodsFor: 'undoers' stamp: 'th 9/19/2002 18:46'!undoQuery: hintText lastOffering: selectorOrNil	"Undo ctrl-q.  selectorOrNil (if not nil) is the previously offered selector.	 hintText is the original hint.  Redoer: completeSymbol."	self zapSelectionWith: UndoSelection.	self undoMessage: (Message selector: #completeSymbol:lastOffering: arguments: UndoMessage arguments) forRedo: true.	self selectAt: self stopIndex! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/20/2002 11:41'!recomputeInterval	"The same characters are selected but their coordinates may have changed."	self computeIntervalFrom: self mark to: self pointIndex - 1! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/18/2002 17:30'!reverseSelection	"Reverse the valence of the current selection highlighting."	selectionShowing _ selectionShowing not.	paragraph reverseFrom: self markBlock to: self pointBlock! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/19/2002 18:47'!selectAndScroll	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle endBlock |	self select.	endBlock _ self stopBlock.	lineHeight _ paragraph textStyle lineGrid.	clippingRectangle _ paragraph clippingRectangle.	deltaY _ endBlock top - clippingRectangle top.	deltaY >= 0 		ifTrue: [deltaY _ endBlock bottom - clippingRectangle bottom max: 0].						"check if stopIndex below bottom of clippingRectangle"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/19/2002 18:48'!selectAndScrollToTop	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle |	self select.	lineHeight _ paragraph textStyle lineGrid.	clippingRectangle _ paragraph clippingRectangle.	deltaY _ self stopBlock top - clippingRectangle top.	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:37'!adjustSelection: directionBlock	"Helper function for Cursor movement. Always moves point thus allowing selections to shrink. "	"See also expandSelection:"	"Accepts a one argument Block that computes the new postion given an old one."	| newPosition |	newPosition _ directionBlock value: self pointIndex.	self selectMark: self markIndex point: newPosition.	^true.! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/20/2002 11:20'!afterSelectionInsertAndSelect: aString	self insertAndSelect: aString at: self pointIndex ! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/17/2002 16:11'!computeIntervalFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	self setMark: start.	self setPoint: stop + 1.! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 17:21'!encompassLine: anInterval	"Return an interval that encompasses the entire line"	| string left right |	string _ paragraph text string.	left _ (string lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	right _ (string indexOf: Character cr startingAt: anInterval last + 1 ifAbsent: [string size + 1]) - 1.	^left to: right! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 16:50'!selectFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(start = self startIndex and: [stop + 1 = self stopIndex]) ifFalse:		[self deselect.		self selectInvisiblyFrom: start to: stop].	self selectAndScroll! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:17'!selectInvisiblyMark: mark point: point	"Select the designated characters, inclusive.  Make no visual changes."	^ self computeIntervalFrom: mark to: point! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 17:17'!selectLine	"Make the receiver's selection, if it currently consists of an insertion point only, encompass the current line."	self hasSelection ifTrue:[^self].	self selectInterval: (self encompassLine: self selectionInterval)! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:18'!selectMark: mark point: point	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(mark =  self markIndex and: [point + 1 = self pointIndex]) ifFalse:		[self deselect.		self selectInvisiblyMark: mark point: point].	self selectAndScroll! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 18:49'!selectPrecedingIdentifier	"Invisibly select the identifier that ends at the end of the selection, if any."	| string sep stop tok |	tok _ false.	string _ paragraph text string.	stop _ self stopIndex - 1.	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop _ stop - 1].	sep _ stop.	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok _ true. sep _ sep - 1].	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 16:51'!selectWord	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level leftDelimiters rightDelimiters	string here hereChar start stop |	string _ paragraph text string.	here _ self pointIndex.	(here between: 2 and: string size)		ifFalse: ["if at beginning or end, select entire string"			^self selectFrom: 1 to: string size].	leftDelimiters _ '([{<''"'.	rightDelimiters _ ')]}>''"'.	openDelimiter _ string at: here - 1.	match _ leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: 			["delimiter is on left -- match to the right"			start _ here.			direction _ 1.			here _ here - 1.			closeDelimiter _ rightDelimiters at: match]		ifFalse: 			[openDelimiter _ string at: here.			match _ rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: 					["delimiter is on right -- match to the left"					stop _ here - 1.					direction _ -1.					closeDelimiter _ leftDelimiters at: match]				ifFalse: ["no delimiters -- select a token"					direction _ -1]].	level _ 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: 			[hereChar _ string at: (here _ here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: 									[start _ 1.									"go right if hit string start"									direction _ 1]]						ifFalse: [direction < 0								ifTrue: 									[start _ here + 1.									"go right if hit non-token"									direction _ 1]								ifFalse: [level _ 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level _ level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level _ level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here _ here + direction].	direction > 0		ifTrue: [self selectFrom: start to: here - 1]		ifFalse: [self selectFrom: here + 1 to: stop]! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 18:48'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where _ paragraph text findString: FindText startingAt: self stopIndex				caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [self zapSelectionWith: ChangeText].	indices nextPut: where.	self selectAndScroll.	^ true! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/18/2002 16:53'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	|  home indices wasTypedKey |	home _ self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: "Choose as FindText..."		[FindText _ UndoSelection.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		paragraph == UndoParagraph ifTrue: "... else set it now as follows."			[UndoInterval ~= home ifTrue: [self selectInterval: UndoInterval]. "blink"			ChangeText _ ((UndoMessage sends: #undoCutCopy:) and: [self hasSelection])				ifTrue: [FindText] "== objects signal no model-locking by 'undo copy'"				ifFalse: [self selection]]]. "otherwise, change text is last-replaced text"	(wasTypedKey _ FindText size = 0)		ifTrue: "just inserted at a caret"			[home _ self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText _ ChangeText] "... and search for it, without replacing"		ifFalse: "Show where the search will start"			[home last = self selectionInterval last ifFalse:				[self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices _ WriteStream on: (Array new: 20). "an array to store change locs"	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	indices isEmpty ifTrue:  "none found"		[self flash.		wasTypedKey ifFalse: [^self]].	(many | wasTypedKey) ifFalse: "after undo, select this replacement"		[home _ self startIndex to:			self startIndex + UndoSelection size - 1].	self undoer: #undoAgain:andReselect:typedKey: with: indices contents with: home with: wasTypedKey! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 18:16'!completeSymbol: hintText lastOffering: selectorOrNil	"Invoked by Ctrl-q when there is only a caret.		Do selector-completion, i.e., try to replace the preceding identifier by a		selector that begins with those characters & has as many keywords as possible.	 	Leave two spaces after each colon (only one after the last) as space for		arguments.  Put the caret after the space after the first keyword.  If the		user types Ctrl-q again immediately, choose a different selector.	 Undoer: #undoQuery:lastOffering:; Redoer: itself.	If redoing, just redisplay the last offering, selector[OrNil]."	| firstTime input prior caret newStart sym kwds outStream |	firstTime _ self isRedoing		ifTrue: [prior _ sym _ selectorOrNil. true]		ifFalse: [hintText isNil].	firstTime		ifTrue: "Initial Ctrl-q (or redo)"								[caret _ self startIndex.			self selectPrecedingIdentifier.			input _ self selection]		ifFalse: "Repeated Ctrl-q"			[caret _ UndoInterval first + hintText size.			self selectInvisiblyFrom: UndoInterval first to: UndoInterval last.			input _ hintText.			prior _ selectorOrNil].	(input size ~= 0 and: [sym ~~ nil or:			[(sym _ Symbol thatStarts: input string skipping: prior) ~~ nil]])		ifTrue: "found something to offer"			[newStart _ self startIndex.			outStream _ WriteStream on: (String new: 2 * sym size).			1 to: (kwds _ sym keywords) size do:				[:i |				outStream nextPutAll: (kwds at: i).				i = 1 ifTrue: [caret _ newStart + outStream contents size + 1].				outStream nextPutAll:					(i < kwds size ifTrue: ['  '] ifFalse: [' '])].			UndoSelection _ input.			self deselect; zapSelectionWith: outStream contents asText.			self undoer: #undoQuery:lastOffering: with: input with: sym]		ifFalse: "no more matches"			[firstTime ifFalse: "restore original text & set up for a redo"				[UndoSelection _ self selection.				self deselect; zapSelectionWith: input.				self undoer: #completeSymbol:lastOffering: with: input with: prior.				Undone _ true].			view flash].	self selectAt: caret! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/18/2002 16:49'!exchangeWith: prior	"If the prior selection is non-overlapping and legal, exchange the text of	 it with the current selection and leave the currently selected text selected	 in the location of the prior selection (or leave a caret after a non-caret if it was	 exchanged with a caret).  If both selections are carets, flash & do nothing.	 Don't affect the paste buffer.  Undoer: itself; Redoer: Undoer."	| start stop before selection priorSelection delta altInterval |	start _ self startIndex.	stop _ self stopIndex - 1.	((prior first <= prior last) | (start <= stop) "Something to exchange" and:			[self isDisjointFrom: prior])		ifTrue:			[before _ prior last < start.			selection _ self selection.			priorSelection _ paragraph text copyFrom: prior first to: prior last.			delta _ before ifTrue: [0] ifFalse: [priorSelection size - selection size].			self zapSelectionWith: priorSelection.			self selectFrom: prior first + delta to: prior last + delta.			delta _ before ifTrue: [stop - prior last] ifFalse: [start - prior first].			self zapSelectionWith: selection.			altInterval _ prior first + delta to: prior last + delta.			self undoer: #exchangeWith: with: altInterval.			"If one was a caret, make it otherInterval & leave the caret after the other"			prior first > prior last ifTrue: [self selectAt: UndoInterval last + 1].			otherInterval _ start > stop				ifTrue: [self selectAt: altInterval last + 1. UndoInterval]				ifFalse: [altInterval]]		ifFalse:			[view flash]! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/18/2002 16:34'!isDisjointFrom: anInterval	"Answer true if anInterval is a caret not touching or within the current	 interval, or if anInterval is a non-caret that does not overlap the current	 selection."	| fudge |	fudge _ anInterval size max:1.	^(anInterval last + fudge < self startIndex or:			[anInterval first - fudge >= self stopIndex])! !!ParagraphEditor methodsFor: 'private' stamp: 'th 11/24/2002 17:13'!lines	"Other than my member paragraph i compute lines based on logical	line breaks, not optical (which may change due to line wrapping of the editor)"	| lines string index lineIndex stringSize |	string _ paragraph text string.	"Empty strings have no lines at all. Think of something."	string isEmpty ifTrue:[^{#(1 0 0)}].	stringSize _ string size.	lines _ OrderedCollection new: (string size // 15).	index _ 0.	lineIndex _ 0.	string linesDo:[:line |		lines addLast: (Array			with: (index _ index + 1)			with: (lineIndex _ lineIndex + 1)			with: (index _ index + line size min: stringSize))].	"Special workaround for last line empty."	string last == Character cr	"lines last last < stringSize" ifTrue:[lines addLast:{stringSize +1. lineIndex+1. stringSize}].	^lines! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 19:57'!moveCursor: directionBlock forward: forward specialBlock: specialBlock	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| shift indices newPosition |	shift _ sensor leftShiftDown.	indices _ self setIndices: shift forward: forward.	newPosition _ directionBlock value: (indices at: #moving).	(sensor commandKeyPressed or:[sensor controlKeyPressed])		ifTrue: [newPosition _ specialBlock value: newPosition].	sensor keyboard.	shift		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/20/2002 11:09'!pageHeight	| howManyLines visibleHeight totalHeight ratio |	howManyLines _ paragraph numberOfLines.	visibleHeight _ self visibleHeight.	totalHeight _ self totalTextHeight.	ratio _ visibleHeight / totalHeight.	^(ratio * howManyLines) rounded - 2! !!ParagraphEditor methodsFor: 'private' stamp: 'th 10/21/2003 16:16'!sameColumn: start newLine: lineBlock forward: isForward	"Private - Compute the index in my text	with the line number derived from lineBlock,"	" a one argument block accepting the old line number.	The position inside the line will be preserved as good as possible"	"The boolean isForward is used in the border case to determine if	we should move to the beginning or the end of the line."	| wordStyle column currentLine offsetAtTargetLine targetEOL lines currentLineNumber targetLineNumber |	wordStyle _ Preferences wordStyleCursorMovement.	wordStyle		ifTrue: [			lines _ paragraph lines.			currentLineNumber  _ paragraph lineIndexOfCharacterIndex: start.			currentLine _ lines at: currentLineNumber]		ifFalse: [			lines _ self lines.			currentLine _ lines				detect:[:lineInterval | lineInterval last >= start]				ifNone:[lines last].			currentLineNumber _ currentLine second].	column _ start - currentLine first.	targetLineNumber _ ((lineBlock value: currentLineNumber) max: 1) min: lines size.	offsetAtTargetLine _ (lines at: targetLineNumber) first.	targetEOL _ (lines at: targetLineNumber) last + (targetLineNumber == lines size ifTrue:[1]ifFalse:[0]).	targetLineNumber == currentLineNumber	"No movement or movement failed. Move to beginning or end of line."		ifTrue:[^isForward			ifTrue:[targetEOL]			ifFalse:[offsetAtTargetLine]].	^offsetAtTargetLine + column min: targetEOL.! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 19:02'!setIndices: shiftPressed forward: forward	"Little helper method that sets the moving and fixed indices according to some flags."	| indices |	indices _ Dictionary new.	(shiftPressed and:[Preferences selectionsMayShrink])		ifTrue: [			indices at: #moving put: self pointIndex.			indices at: #fixed put: self markIndex		] ifFalse: [			forward				ifTrue:[					indices at: #moving put: self stopIndex.					indices at: #fixed put: self startIndex.				] ifFalse: [					indices at: #moving put: self startIndex.					indices at: #fixed put: self stopIndex.				]		].	^indices! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:22'!hasCaret	^self markBlock = self pointBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:22'!hasSelection	^self hasCaret not! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:13'!mark	^ self markBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!markBlock	^ stopBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!markBlock: aCharacterBlock	stopBlock _ aCharacterBlock.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 12:31'!markIndex	^ self markBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!pointBlock	^ startBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!pointBlock: aCharacterBlock	startBlock _ aCharacterBlock.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 12:31'!pointIndex	^ self pointBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 17:28'!selection	"Answer the text in the paragraph that is currently selected."	^paragraph text copyFrom: self startIndex to: self stopIndex - 1 ! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:10'!selectionAsStream	"Answer a ReadStream on the text in the paragraph that is currently 	selected."	^ReadWriteStream		on: paragraph string		from: self startIndex		to: self stopIndex - 1! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 16:18'!selectionInterval	"Answer the interval that is currently selected."	^self startIndex to: self stopIndex - 1 ! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:02'!setMark: anIndex	self markBlock: (paragraph characterBlockForIndex: anIndex)! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:02'!setPoint: anIndex	self pointBlock: (paragraph characterBlockForIndex: anIndex)! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:10'!startBlock	^ self pointBlock min: self markBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:10'!startBlock: aCharacterBlock	self markBlock: aCharacterBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 14:27'!startIndex	^ self startBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:14'!stopBlock	^ self pointBlock max: self markBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:10'!stopBlock: aCharacterBlock	self pointBlock: aCharacterBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 14:27'!stopIndex	^ self stopBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:23'!unselect	self markBlock: self pointBlock copy.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:12'!zapSelectionWith: aText	"Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and otherInterval.	 Do not set up for undo."	| start stop |	self deselect.	start _ self startIndex.	stop _ self stopIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph			replaceFrom: start			to: stop - 1			with: aText			displaying: true.		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval]! !!FillInTheBlankController methodsFor: 'basic control sequence' stamp: 'th 9/17/2002 16:46'!controlInitialize	model acceptOnCR ifFalse: [^ super controlInitialize].	self setMark: self markBlock stringIndex.	self setPoint: self pointBlock stringIndex.	self initializeSelection.	beginTypeInBlock _ nil.! !!PluggableTextController methodsFor: 'transcript' stamp: 'th 9/20/2002 11:26'!scrollIn: scrollRect	"Altered from selectAndScroll so can use with null clipRect"	"Scroll until the selection is in the view and then highlight it."	| deltaY |	deltaY _ self stopBlock top - scrollRect top.	deltaY >= 0 		ifTrue: [deltaY _ self stopBlock bottom - scrollRect bottom max: 0].						"check if stopIndex below bottom of scrollRect"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + paragraph lineGrid - 1) * deltaY sign]! !!PluggableTextController methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:37'!selectForTopFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	self selectFrom: start to: stop scroll: #selectAndScrollToTop! !!PluggableTextController methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:37'!selectFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	self selectFrom: start to: stop scroll: #selectAndScroll! !!PluggableTextController methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:35'!selectFrom: start to: stop scroll: scrollCommand	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(start = self startIndex and: [stop + 1 = self stopIndex]) ifFalse:		[view superView ifNotNil: [self deselect].		self selectInvisiblyFrom: start to: stop].	view superView ifNotNil: [self perform: scrollCommand]! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'RAA 5/6/2001 14:48'!composeAllLines	[currCharIndex <= theText size and: 			[(currentY + defaultLineHeight) <= theContainer bottom]] whileTrue: [		nowSliding ifTrue: [			self slideOneLineDown ifNil: [^nil].		] ifFalse: [			self composeOneLine ifNil: [^nil].		]	].! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'th 11/18/2002 19:13'!composeAllRectangles: rectangles	| charIndexBeforeLine numberOfLinesBefore reasonForStopping |	actualHeight _ defaultLineHeight.	charIndexBeforeLine _ currCharIndex.	numberOfLinesBefore _ lines size.	reasonForStopping _ self composeEachRectangleIn: rectangles.	currentY _ currentY + actualHeight.	currentY > theContainer bottom ifTrue: [		"Oops -- the line is really too high to fit -- back out"		currCharIndex _ charIndexBeforeLine.		lines size - numberOfLinesBefore timesRepeat: [lines removeLast].		^self	].		"It's OK -- the line still fits."	maxRightX _ maxRightX max: scanner rightX.	1 to: rectangles size - 1 do: [ :i |		"Adjust heights across rectangles if necessary"		(lines at: lines size - rectangles size + i)			lineHeight: lines last lineHeight			baseline: lines last baseline	].	isFirstLine _ false.	reasonForStopping == #columnBreak ifTrue: [^nil].	currCharIndex > theText size ifTrue: [		^nil		"we are finished composing"	].	! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'RAA 5/7/2001 10:11'!composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks	wantsColumnBreaks _ argWantsColumnBreaks.	lines _ argLinesCollection.	theTextStyle _ argTextStyle.	theText _ argText.	theContainer _ argContainer.	deltaCharIndex _ argDelta.	currCharIndex _ startCharIndex _ argStart.	stopCharIndex _ argStop.	prevLines _ argPriorLines.	currentY _ argStartY.	defaultLineHeight _ theTextStyle lineGrid.	maxRightX _ theContainer left.	possibleSlide _ stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding _ false.	prevIndex _ 1.	scanner _ CompositionScanner new text: theText textStyle: theTextStyle.	scanner wantsColumnBreaks: wantsColumnBreaks.	isFirstLine _ true.	self composeAllLines.	isFirstLine ifTrue: ["No space in container or empty text"		self 			addNullLineWithIndex: startCharIndex			andRectangle: (theContainer topLeft extent: 0@defaultLineHeight)	] ifFalse: [		self fixupLastLineIfCR	].	^{lines asArray. maxRightX}! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'RAA 5/4/2001 18:09'!fixupLastLineIfCR"This awful bit is to ensure that if we have scanned all the text and the last character is a CR that there is a null line at the end of lines. Sometimes this was not happening which caused anomalous selections when selecting all the text. This is implemented as a post-composition fixup because I couldn't figure out where to put it in the main logic."	(theText size > 1 and: [theText last = Character cr]) ifFalse: [^self].	self addNullLineForIndex: theText size + 1.! !!TextMorphEditor methodsFor: 'attributes' stamp: 'th 9/19/2002 18:19'!changeEmphasisOrAlignment	| aList reply  code align menuList startIndex |	self flag: #arNote. "Move this up once we get rid of MVC"	startIndex _ self startIndex.	aList _ #(plain bold italic narrow underlined struckOut leftFlush centered rightFlush justified).		align _ paragraph text alignmentAt: startIndex 		ifAbsent:[paragraph textStyle alignment].	code _ paragraph text emphasisAt: startIndex.	menuList _ WriteStream on: Array new.	menuList nextPut: (code = 0 ifTrue:['<on>plain'] ifFalse:['<off>plain']).	menuList nextPutAll: (#(bold italic underlined struckOut) collect:[:emph|		(code anyMask: (TextEmphasis perform: emph) emphasisCode)			ifTrue:['<on>', emph]			ifFalse:['<off>',emph]]).	((paragraph text attributesAt: startIndex forStyle: paragraph textStyle)		anySatisfy:[:attr| attr isKern and:[attr kern < 0]]) 			ifTrue:[menuList nextPut:'<on>narrow']			ifFalse:[menuList nextPut:'<off>narrow'].	menuList nextPutAll: (#(leftFlush centered rightFlush justified) collectWithIndex:[:type :i|		align = (i-1)			ifTrue:['<on>',type]			ifFalse:['<off>',type]]).	aList _ #(plain bold italic underlined struckOut narrow leftFlush centered rightFlush justified).	reply _ (SelectionMenu labelList: menuList contents lines: #(1 6) selections: aList) startUpWithoutKeyboard.	reply ~~ nil ifTrue:		[(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue:				[self setAlignment: reply.				paragraph composeAll.				self recomputeInterval]			ifFalse:				[self setEmphasis: reply.				paragraph composeAll.				self recomputeSelection.				self mvcRedisplay]].	^ true! !!TextMorphEditor methodsFor: 'attributes' stamp: 'th 9/19/2002 18:20'!changeTextFont	"Present a menu of available fonts, and if one is chosen, apply it to the current selection."	| curFont newFont attr startIndex |	startIndex _ self startIndex.	curFont _ (paragraph text fontAt: startIndex withStyle: paragraph textStyle).	newFont _ StrikeFont fromUser: curFont.	newFont ifNil:[^self].	attr _ TextFontReference toFont: newFont.	paragraph text addAttribute: attr from: startIndex to: (self stopIndex-1 min: paragraph text size).	paragraph composeAll.	self recomputeInterval.	morph changed.! !!TextMorphEditor methodsFor: 'attributes' stamp: 'th 9/19/2002 18:30'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply curFont menuList |true ifTrue:[^self changeTextFont].	self flag: #arNote. "Move this up once we get rid of MVC"	curFont _ (paragraph text fontAt: self startIndex withStyle: paragraph textStyle) fontNameWithPointSize.	aList _ paragraph textStyle fontNamesWithPointSizes.	menuList _ aList collect:[:fntName|		fntName = curFont ifTrue:['<on>',fntName] ifFalse:['<off>',fntName]].	reply _ (SelectionMenu labelList: menuList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!TextMorphEditor methodsFor: 'events' stamp: 'th 9/18/2002 11:15'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint |	oldInterval _ self selectionInterval.	clickPoint _ evt cursorPoint.	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [		pivotBlock _ paragraph characterBlockAtPoint: clickPoint.		self markBlock: pivotBlock.		self pointBlock: pivotBlock.		evt hand releaseKeyboardFocus: self.		^ self].	evt shiftPressed		ifFalse:			[self closeTypeIn.			pivotBlock _ paragraph characterBlockAtPoint: clickPoint.			self markBlock: pivotBlock.			self pointBlock: pivotBlock.]		ifTrue:			[self closeTypeIn.			self mouseMove: evt].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'th 9/17/2002 16:45'!mouseMove: evt 	"Change the selection in response to moue-down drag"	pivotBlock ifNil: [^ self].  "Patched during clickAt: repair"	self pointBlock: (paragraph characterBlockAtPoint: (evt cursorPoint)).	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'th 9/19/2002 18:29'!mouseUp: evt	"An attempt to break up the old processRedButton code into threee phases"	oldInterval ifNil: [^ self].  "Patched during clickAt: repair"	(self hasCaret 		and: [oldInterval = self selectionInterval])		ifTrue: [self selectWord].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'th 9/20/2002 11:26'!selectAndScrollToTop	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY rect deltaX |	lineHeight _ paragraph textStyle lineGrid.	rect _ morph owner bounds.	deltaY _ self stopBlock top - rect top.	deltaY ~= 0 ifTrue: [		deltaX _ 0.		deltaY _ (deltaY abs + lineHeight - 1 truncateTo: lineHeight) negated.		morph editView scrollBy: deltaX@deltaY]! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'th 9/19/2002 18:17'!storeSelectionInParagraph	paragraph selectionStart: self startBlock selectionStop: self stopBlock! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'th 9/19/2002 18:21'!zapSelectionWith: aText	"**overridden to inhibit old-style display"	| start stop |	self deselect.	start _ self startIndex.	stop _ self stopIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph replaceFrom: start to: stop - 1			with: aText displaying: false.  "** was true in super"		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval].	self userHasEdited  " -- note text now dirty"! !ParagraphEditor removeSelector: #cursorPageJump:down:!"Postscript:"Preferences addPreference: #wordStyleCursorMovement category: #general default: true balloonHelp: 'If set to true cursor movement in Text will move along displayed lines rather than logical lines'.Preferences addPreference: #selectionsMayShrink category: #general default: true balloonHelp: 'If set to true the selected region will shrink when the cursor changes direction'.!