'From Squeak3.1alpha of 4 February 2001 [latest update: #3809] on 7 March 2001 at 3:53:44 pm'!"Change Set:		DeepCopier3-tkDate:			7 March 2001Author:			Ted KaehlerDeepCopier needs to check that certain instance variables are handled correctly in veryDeepInner:.  Make the check for this when a class is filed out.  	Previously, it was made at every ten minutes when a veryDeepCopy was called.  This formerly did allImplememtors, which brings in all segments."!!DeepCopier commentStamp: 'tk 3/7/2001 13:34' prior: 0!I do veryDeepCopy.  It is a complete tree copy using a dictionary.  Any object that is in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy.  See Object|veryDeepCopy which calls (self veryDeepCopyWith: aDeepCopier).The dictionary of objects that have been seen holds the correspondance (uniClass -> new uniClass).When a tree of morphs points at a morph outside of itself, that morph should not be copied.  Use our own kind of weak pointers for the potentially outside morphs.   Default is that any new class will have all of its fields deeply copied.  If a field needs to be weakly copied, define veryDeepInner: and veryDeepFixupWith:.     veryDeepInner: has the loop that actually copies the fields.  If a class defines its own copy of veryDeepInner: (to leave some fields out), then veryDeepFixupWith: will be called on that object at the end.  veryDeepInner: can compute an alternate object to put in a field.  (Object veryDeepCopyWith: discovers which superclasses did not define veryDeepInner:, and very deep copies the variables defined in those classes).	To decide of a class needs veryDeepInner: and veryDeepFixupWith:, ask this about an instance:  If I duplicate this object, does that mean that I also want duplicates of the things it holds onto?  If yes, (i.e. a paragraph does want a new copy of its text) then do nothing.  If no, (i.e. an undo command does not want to copy the objects it acts upon), then define veryDeepInner: and veryDeepFixupWith:.	Here is an analysis for the specific case of a morph being held by another morph.  Does field X contain a morph?  If not, no action needed.Is the morph in field X already a submorph of the object?  Is it down lower in the submorph tree?	If so, no action needed.Could the morph in field X every appear on the screen (be a submorph of some other morph)?	If not, no action needed.	If it could, you must write the methods veryDeepFixupWith:   and   veryDeepInner:, and in them, refrain from sending veryDeepCopyWith: to the contents of field X.Rule:  If a morph stores a uniClass class (Player 57) as an object in a field, the new uniClass will not be stored there.   Each uniClass instance does have a new class created for it.  (fix this by putting the old class in references and allow lookup?  Wrong if encounter it before seeing an instance?)Rule: If object A has object C in a field, and A says (^ C) for the copy, but object B has A in a normal field and it gets deepCopied, and A in encountered first, then there will be two copies of C.  (just be aware of it)Dependents are now fixed up.  Suppose a model has a dependent view.  In the DependentFields dictionary, model -> (view ...).  	If only the model is copied, no dependents are created (no one knows about the new model).  	If only the view is copied, it is inserted into DependentFields on the right side.  model -> (view  copiedView ...).  	If both are copied, the new model has the new view as its dependent.	If additional things depend on a model that is copied, the caller must add them to its dependents.!!ChangeSet methodsFor: 'private' stamp: 'tk 3/7/2001 14:06'!fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed."	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #change) ifTrue: [ "fat definition only needed for changes"		stream command: 'H3'; nextChunkPut: (self fatDefForClass: class); cr; command: '/H3'.		DeepCopier new checkClass: class.	"If veryDeepCopy weakly copies some inst 			vars in this class, warn author when new ones are added." 	] ifFalse: [		(self atClass: class includes: #add) ifTrue: [ "use current definition for add"			stream command: 'H3'; nextChunkPut: class definition; cr; command: '/H3'.			DeepCopier new checkClass: class.	"If veryDeepCopy weakly copies some inst 				vars in this class, warn author when new ones are added." 		].	].	(self atClass: class includes: #comment) ifTrue:		[class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass.		stream cr].! !!Class methodsFor: 'fileIn/Out' stamp: 'tk 3/7/2001 13:57'!fileOutAsHtml: useHtml	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: self name, FileDirectory dot, 'html') asHtml]		ifFalse: [FileStream newFileNamed: self name, FileDirectory dot, 'st'].	fileStream header; timeStamp.	self sharedPools size > 0 ifTrue: [		self shouldFileOutPools			ifTrue: [self fileOutSharedPoolsOn: fileStream]].	self fileOutOn: fileStream moveSource: false toFile: 0.	fileStream trailer; close.	"DeepCopier new checkVariables."! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/7/2001 15:40'!checkBasicClasses	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it.  	DeepCopier new checkVariables	"	| str str2 objCls morphCls modelCls playerCls |	str _ '|veryDeepCopyWith: or veryDeepInner: is out of date.'.	(objCls _ self objInMemory: #Object) ifNotNil: [		objCls instSize = 0 ifFalse: [self error: 			'Many implementers of veryDeepCopyWith: are out of date']].	(morphCls _ self objInMemory: #Morph) ifNotNil: [		morphCls superclass == Object ifFalse: [self error: 'Morph', str].		(morphCls instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 				'fullBounds' 'color' 'extension') 			ifFalse: [self error: 'Morph', str]].	"added ones are OK"	str2 _ 'Player|copyUniClass and DeepCopier|mapUniClasses are out of date'.	Behavior instVarNames = #('superclass' 'methodDict' 'format' )		ifFalse: [self error: str2].	ClassDescription instVarNames = #('instanceVariables' 'organization' )		ifFalse: [self error: str2].	Class instVarNames = #('subclasses' 'name' 'classPool' 'sharedPools' 'environment' 'category' )		ifFalse: [self error: str2].	(modelCls _ self objInMemory: #Model) ifNotNil: [		modelCls superclass == Object ifFalse: [self error: str2].		modelCls class instVarNames = #() ifFalse: [self error: str2]].	(playerCls _ self objInMemory: #Player) ifNotNil: [		playerCls superclass == modelCls ifFalse: [self error: str2].		playerCls class instVarNames = #('scripts' 'slotInfo')			ifFalse: [self error: str2]].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/7/2001 15:42'!checkClass: aClass	| meth |	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it."	self checkBasicClasses.	"Unlikely, but important to catch when it does happen."	"Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  So check that the last one is mentioned in the copy method."	(aClass includesSelector: #veryDeepInner:) ifTrue: [ 		((aClass compiledMethodAt: #veryDeepInner:) writesField: aClass instSize) ifFalse: [			aClass instSize > 0 ifTrue: [				self warnIverNotCopiedIn: aClass sel: #veryDeepInner:]]].	(aClass includesSelector: #veryDeepCopyWith:) ifTrue: [		meth _ aClass compiledMethodAt: #veryDeepCopyWith:.		(meth size > 20) & (meth literals includes: #veryDeepCopyWith:) not ifTrue: [			(meth writesField: aClass instSize) ifFalse: [				self warnIverNotCopiedIn: aClass sel: #veryDeepCopyWith:]]].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/7/2001 13:38'!checkDeep	"Write exceptions in the Transcript.  Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  This check is only run by hand once in a while to make sure nothing was forgotten.  (Please do not remove this method.)	DeepCopier new checkDeep 	"| mm |Transcript cr; show: 'Instance variables shared with the original object when it is copied'.(Smalltalk allClassesImplementing: #veryDeepInner:) do: [:aClass | 	(mm _ aClass instVarNames size) > 0 ifTrue: [		(aClass instSize - mm + 1) to: aClass instSize do: [:index |			((aClass compiledMethodAt: #veryDeepInner:) writesField: index) ifFalse: [				Transcript cr; show: aClass name; space; 					show: (aClass allInstVarNames at: index)]]]].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/7/2001 15:39'!checkVariables	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it.  	DeepCopier new checkVariables	"	| str str2 meth objCls morphCls modelCls playerCls |	str _ '|veryDeepCopyWith: or veryDeepInner: is out of date.'.	(objCls _ self objInMemory: #Object) ifNotNil: [		objCls instSize = 0 ifFalse: [self error: 			'Many implementers of veryDeepCopyWith: are out of date']].	(morphCls _ self objInMemory: #Morph) ifNotNil: [		morphCls superclass == Object ifFalse: [self error: 'Morph', str].		(morphCls instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 				'fullBounds' 'color' 'extension') 			ifFalse: [self error: 'Morph', str]].	"added ones are OK"	"Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  So check that the last one is mentioned in the copy method."	(Smalltalk allClassesImplementing: #veryDeepInner:) do: [:aClass | 		((aClass compiledMethodAt: #veryDeepInner:) writesField: aClass instSize) ifFalse: [			aClass instSize > 0 ifTrue: [				self warnIverNotCopiedIn: aClass sel: #veryDeepInner:]]].	(Smalltalk allClassesImplementing: #veryDeepCopyWith:) do: [:aClass | 		meth _ aClass compiledMethodAt: #veryDeepCopyWith:.		(meth size > 20) & (meth literals includes: #veryDeepCopyWith:) not ifTrue: [			(meth writesField: aClass instSize) ifFalse: [				self warnIverNotCopiedIn: aClass sel: #veryDeepCopyWith:]]].	str2 _ 'Player|copyUniClass and DeepCopier|mapUniClasses are out of date'.	Behavior instVarNames = #('superclass' 'methodDict' 'format' )		ifFalse: [self error: str2].	ClassDescription instVarNames = #('instanceVariables' 'organization' )		ifFalse: [self error: str2].	Class instVarNames = #('subclasses' 'name' 'classPool' 'sharedPools' 'environment' 'category' )		ifFalse: [self error: str2].	(modelCls _ self objInMemory: #Model) ifNotNil: [		modelCls superclass == Object ifFalse: [self error: str2].		modelCls class instVarNames = #() ifFalse: [self error: str2]].	(playerCls _ self objInMemory: #Player) ifNotNil: [		playerCls superclass == modelCls ifFalse: [self error: str2].		playerCls class instVarNames = #('scripts' 'slotInfo')			ifFalse: [self error: str2]].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/7/2001 13:44'!initialize: size	references _ IdentityDictionary new: size.	uniClasses _ IdentityDictionary new.	"UniClass -> new UniClass"	"self isItTimeToCheckVariables ifTrue: [self checkVariables]."		"no more checking at runtime"! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/7/2001 15:29'!objInMemory: ClassSymbol	| cls |	"Test if this global is in memory and return it if so."	cls _ Smalltalk at: ClassSymbol ifAbsent: [^ nil].	^ cls isInMemory ifTrue: [cls] ifFalse: [nil].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/7/2001 15:46'!warnIverNotCopiedIn: aClass sel: sel	"Warn the user to update veryDeepCopyWith: or veryDeepInner:"	self inform: ('An instance variable was added to to class ', aClass name, ',\and it is not copied in the method ', sel, '.\Please rewrite it to handle all instance variables.\See DeepCopier class comment.') withCRs.	Browser openMessageBrowserForClass: aClass selector: sel editString: nil.! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'tk 3/7/2001 13:57'!fileOut	| fileName stream |	fileName := FillInTheBlank request: 'Enter the file name' initialAnswer:''.	stream := FileStream newFileNamed: fileName.	sourceSystem isEmpty ifFalse:[		stream nextChunkPut: sourceSystem printString;cr ].	self fileOutOn: stream.	stream cr; cr.	self classes do:[:cls|		cls needsInitialize ifTrue:[			stream cr; nextChunkPut: cls name,' initialize']].	stream cr.	stream close.	"DeepCopier new checkVariables."! !