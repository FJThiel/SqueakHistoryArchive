'From Squeak2.9alpha of 12 June 2000 [latest update: #2489] on 15 August 2000 at 1:43:25 pm'!"Change Set:		macVMUpdatesJMMDate:			3 August 2000Author:			John M McIntosh johnmci@smalltalkconsulting.comQuite a number of changes are folded into this change set which address the VM on the Macintosh.1) A fix for the macintosh Socket plugin to quickly abort a connect if the port is invalid2) A fix to abort a connection if a disconnect flows at the same time3) Dropped the OT libraries from the 68K version.4) The SqueakTermination routine will run on a force quit, or when the code gets unloaded to cleanup any plugin issues (aka Socket code failing to close OT after VM failure)5) I've added Finder Icons for Squeak and fixed up a number of issues with Squeak on the Macintosh. No close box, balloon help in finder, version string, etc.6) A step towards Carbonization was done (not yet complete). Accessors are now used, p2cstr/c2pstr usage was reviewed, scrap manger rewritten, menu logic examined.7) Full screen support for macintosh browsers was added8) Fixed issue with wrong path to plugins directory9) Fixed issue with switching applications using cmd-tab under full screen10) Cleaned up some stuff in the readme11) Rebuilt the PPC Squeak App Project was corruptAlso...1) Weak link the open transport libraries for PPC, to enable running the VM on older OS 7.x machines that don't have Open Transport installed.2) Fix for FFI interface3) Fix for Browser Full Screen support in NetScape, and sandbox async file primitive4) Support for event driven image."!!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 8/14/2000 19:54'!macArchiveBinaryFile	"Answer the binary contents of a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be a folder containing the project files."	"To create the text for this method evaulate:		| in out |		in _ (FileStream oldFileNamed: 'projectArchive.sit') binary.		out _ WriteStream on: (String new: 100000).		out nextPutAll: '#('.		[in atEnd] whileFalse: [out nextPutAll: in next printString; space].		out skip: -1.		out nextPutAll: ')'.		in close.		ParagraphEditor clipboardTextPut: out contents asText	  and then do paste into this method."	^ #(83 116 117 102 102 73 116 32 40 99 41 49 57 57 55 45 49 57 57 56 32 65 108 97 100 100 105 110 32 83 121 115 116 101 109 115 44 32 73 110 99 46 44 32 104 116 116 112 58 47 47 119 119 119 46 97 108 97 100 100 105 110 115 121 115 46 99 111 109 47 83 116 117 102 102 73 116 47 13 10 26 0 5 16 0 0 111 173 0 0 0 114 0 8 0 0 0 114 136 201 0 43 0 5 1 24 2 0 0 0 0 0 0 0 165 165 165 165 1 0 0 61 0 0 172 94 103 33 181 100 42 6 0 0 0 0 0 0 13 31 0 0 0 0 0 13 218 2 0 0 7 218 0 0 2 139 0 0 0 0 15 0 77 121 80 108 117 103 105 110 46 112 114 111 106 0 1 186 192 77 77 80 82 67 87 73 69 1 0 4 47 0 245 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 43 27 0 0 9 179 0 0 0 0 15 0 66 193 212 194 19 180 140 109 220 205 78 57 63 90 66 84 57 156 71 10 240 179 194 234 180 76 49 136 61 86 193 33 87 165 51 39 174 141 114 32 57 229 43 22 87 128 72 84 38 117 129 4 182 215 234 186 97 240 130 6 7 168 37 149 122 3 125 3 195 87 185 151 254 22 251 249 238 210 167 130 219 121 155 186 134 229 95 75 152 58 93 250 123 38 106 43 222 218 75 149 20 150 219 56 44 81 228 23 54 251 165 214 237 251 0 192 205 43 113 64 228 181 201 133 51 84 209 66 37 59 176 144 234 4 186 142 81 128 228 2 55 216 158 134 41 177 194 7 95 252 212 255 73 83 237 231 200 33 245 234 99 190 79 33 76 97 115 253 35 55 46 42 13 118 116 73 161 215 249 23 162 74 26 161 34 208 52 177 148 31 2 225 128 147 212 218 175 235 77 215 179 45 41 42 83 138 73 222 20 4 247 49 227 152 237 224 96 210 249 218 162 93 24 168 187 8 67 87 106 36 240 23 14 253 32 32 233 250 182 103 110 104 23 208 218 230 121 74 225 57 124 53 128 60 111 91 170 168 211 245 68 13 214 181 216 230 12 119 31 218 154 171 103 239 30 230 22 188 226 29 238 162 224 59 253 70 31 56 103 224 36 245 159 238 139 104 201 201 132 39 227 128 0 62 234 60 136 63 255 195 11 172 202 17 37 216 84 146 63 219 54 56 151 166 38 241 106 221 197 103 27 237 182 165 6 183 114 101 218 141 240 64 148 45 222 37 21 103 254 127 46 56 173 37 215 210 155 156 143 214 184 249 118 238 209 196 193 63 132 149 152 85 92 181 13 27 221 176 225 145 152 79 7 62 97 181 120 39 91 165 74 115 184 46 199 3 192 153 218 145 229 140 225 48 115 235 24 105 61 157 168 6 39 4 200 157 182 175 112 130 106 48 11 175 17 0 192 51 97 61 92 231 192 128 4 202 158 82 84 178 6 244 58 194 143 198 197 84 245 194 178 69 38 193 153 99 228 73 197 137 51 95 234 74 220 141 111 161 135 191 121 33 201 254 51 7 28 164 179 195 57 17 73 210 193 161 123 149 11 73 41 75 25 196 86 100 212 137 148 255 191 61 249 212 167 243 124 178 252 243 230 210 105 103 137 88 244 8 170 166 127 33 239 33 76 177 46 165 94 119 60 57 69 82 53 93 97 113 18 211 180 59 221 195 107 202 4 125 117 172 218 169 252 32 46 1 54 41 228 135 201 89 109 105 202 112 20 196 166 41 173 208 173 27 148 202 143 245 25 142 72 111 18 240 135 44 9 113 199 4 252 36 142 207 253 43 184 119 116 86 138 249 177 138 141 63 33 191 93 190 139 209 129 212 216 83 151 194 200 24 252 41 196 242 80 71 41 30 226 43 28 209 35 219 218 177 65 128 188 55 183 237 64 231 242 161 168 189 135 114 61 217 9 64 19 4 196 99 134 88 34 235 184 97 44 234 25 195 176 83 127 209 207 190 234 196 243 14 19 177 134 74 190 120 202 207 65 100 1 59 62 46 48 80 135 3 9 73 242 18 57 109 183 245 222 178 216 183 84 76 56 208 27 8 158 248 66 214 155 165 188 137 94 194 111 156 211 2 200 53 127 166 203 170 79 164 98 8 33 169 242 184 152 189 171 140 226 112 193 38 34 179 149 178 39 37 88 11 56 158 240 172 153 69 71 107 203 187 140 154 176 235 8 151 194 172 241 194 59 173 162 204 166 181 114 97 224 92 71 116 144 235 121 221 159 124 218 189 170 239 83 135 28 243 178 223 131 227 17 146 169 220 93 31 64 246 60 114 194 162 48 94 192 255 37 210 128 223 90 148 255 167 134 204 96 230 126 180 73 114 139 161 17 171 76 130 56 199 160 130 180 229 165 79 185 10 128 134 241 79 80 147 118 89 165 116 61 94 67 177 61 154 226 10 230 26 219 235 251 35 12 194 40 38 35 252 251 191 11 198 3 254 127 229 204 232 61 105 255 53 135 108 128 24 78 193 229 23 109 141 167 141 113 72 6 184 7 83 149 143 141 161 13 193 130 105 121 159 72 83 255 218 246 207 168 2 188 251 220 106 202 121 24 137 85 236 151 184 191 38 29 12 123 142 42 244 196 40 124 66 26 203 78 220 166 73 142 150 63 166 17 119 99 243 166 176 210 220 215 118 253 59 143 35 122 222 50 58 29 51 211 19 174 220 236 227 198 71 227 70 156 97 25 76 78 210 252 109 98 200 134 0 148 114 221 154 66 23 196 248 37 253 225 184 18 33 116 236 252 67 236 135 114 205 157 120 160 155 132 133 60 83 40 206 205 65 122 27 3 244 137 119 158 91 42 59 189 57 230 202 3 71 214 181 17 91 237 71 219 25 87 69 187 54 79 222 40 229 9 229 71 160 174 72 187 107 25 142 156 159 128 201 103 230 130 228 230 37 21 220 76 245 164 173 70 236 120 248 32 0 235 8 226 156 150 195 159 49 115 251 27 199 242 115 185 77 140 190 205 244 7 223 191 94 162 200 1 170 101 82 196 36 62 145 104 149 184 123 177 153 15 220 14 50 253 40 5 192 198 227 129 195 234 3 23 1 199 104 182 67 51 17 31 177 252 147 96 76 24 221 202 12 236 136 115 123 75 165 115 55 2 242 194 9 252 13 250 160 95 132 217 253 162 222 168 205 117 26 224 163 41 136 164 32 42 40 60 7 24 87 230 249 31 58 236 150 135 184 249 22 205 31 97 180 112 137 182 250 89 4 221 38 113 74 247 168 206 215 112 54 174 17 124 134 22 229 141 40 117 220 60 36 142 159 28 196 12 79 250 234 136 200 220 192 151 253 59 63 143 176 44 197 118 7 251 9 88 225 69 165 197 229 146 92 13 230 142 60 188 7 204 81 241 42 116 68 128 100 171 169 163 137 188 9 17 212 4 231 195 226 170 216 196 24 94 172 65 211 52 75 97 206 167 143 24 61 168 230 229 31 239 42 70 74 67 179 96 52 199 96 80 117 42 122 92 36 146 138 21 213 65 96 75 175 232 31 107 43 33 91 231 154 123 5 24 28 139 122 138 127 91 147 185 79 21 150 196 39 242 145 196 148 195 22 235 187 30 46 175 109 249 30 33 44 231 138 19 255 207 171 119 184 201 171 190 52 6 187 143 13 176 206 38 141 52 54 14 234 19 13 72 228 115 134 239 231 78 161 68 240 39 189 238 92 137 134 220 92 228 98 165 0 223 127 16 233 228 150 150 183 157 213 170 18 108 187 193 244 40 94 214 27 214 103 133 11 23 106 140 153 150 249 216 192 173 245 226 15 71 223 152 10 15 241 34 209 142 177 116 19 237 153 115 235 149 33 51 8 136 185 42 26 124 13 143 64 6 191 151 249 2 34 136 141 198 23 227 78 45 51 175 180 143 131 177 93 122 47 116 190 243 99 42 32 159 106 87 251 223 159 179 37 63 143 200 173 119 171 27 79 79 149 2 209 224 156 255 224 213 5 208 114 14 166 128 135 141 222 107 146 148 60 212 87 95 249 62 108 29 151 193 171 48 111 202 218 27 135 180 253 254 184 223 129 63 91 60 123 221 98 165 199 70 36 4 155 209 197 95 213 90 27 172 67 75 182 52 134 225 138 50 128 100 245 153 1 73 95 228 92 254 186 19 225 208 85 38 151 24 215 131 149 191 230 74 57 107 248 227 229 111 209 108 16 211 152 104 163 251 128 215 147 85 150 15 43 134 83 159 42 239 54 28 40 73 52 207 84 129 239 98 214 179 21 102 137 178 110 247 152 202 120 33 245 91 121 128 234 177 58 4 101 109 183 205 222 157 164 79 7 109 210 19 253 233 66 110 212 180 156 55 124 37 83 157 36 52 71 108 27 185 118 84 11 222 1 186 180 176 54 75 2 134 10 200 41 247 243 115 198 166 236 142 190 189 239 126 125 106 88 219 213 89 86 112 164 28 237 40 73 163 214 41 167 51 226 144 185 109 128 31 24 46 11 81 151 124 82 134 29 127 35 25 190 38 212 98 223 126 203 32 60 74 103 251 72 156 19 78 206 72 239 13 5 249 184 234 54 28 128 245 0 249 90 69 3 123 98 160 210 186 41 73 17 3 28 112 129 216 217 199 108 97 59 3 225 73 152 69 217 146 229 62 27 45 119 23 226 20 9 145 94 46 115 121 134 233 179 133 155 94 199 108 100 28 131 175 206 140 90 173 14 18 76 19 202 83 159 22 214 223 144 183 119 149 129 120 70 181 99 68 133 35 149 192 17 182 40 216 129 186 185 222 109 72 135 219 119 115 196 249 44 150 83 58 212 26 210 154 53 109 49 36 39 146 188 84 202 107 117 165 30 161 103 160 138 30 154 85 67 10 214 221 117 225 102 176 143 120 211 187 176 196 245 60 28 179 165 154 167 22 55 97 242 45 252 235 170 218 20 43 72 243 201 54 123 101 20 33 48 168 180 233 60 232 203 7 66 56 124 146 214 112 254 140 37 96 243 38 179 116 69 25 227 129 70 166 160 195 95 119 149 251 212 214 138 62 183 247 149 85 11 116 61 189 17 187 149 100 21 248 121 103 245 72 14 36 248 191 128 103 91 132 118 39 131 121 52 247 206 93 47 82 113 11 31 148 91 121 169 110 211 31 34 248 177 165 90 108 123 99 171 35 104 32 238 176 63 65 30 99 58 169 225 58 211 237 4 229 142 123 59 108 223 136 197 220 218 91 179 0 121 93 76 67 65 204 151 161 33 65 74 212 79 82 70 71 34 30 120 110 193 0 36 170 193 44 45 143 228 131 205 150 244 160 150 106 22 65 152 121 20 125 25 104 52 133 104 165 184 88 121 83 121 93 99 250 114 15 118 56 143 178 96 88 189 162 5 211 244 73 153 40 207 205 71 138 167 60 186 201 213 118 68 181 199 75 78 195 34 132 17 127 183 98 72 65 22 255 140 196 232 205 157 2 110 42 175 37 4 30 101 25 242 48 107 25 105 159 30 213 210 157 118 121 51 157 187 180 131 3 44 5 185 15 215 79 162 2 26 65 168 188 175 126 122 46 117 97 63 225 223 18 22 211 203 44 218 82 158 29 119 110 57 91 14 143 66 109 2 240 56 94 247 35 47 101 146 49 98 29 193 204 226 150 16 203 189 11 251 203 208 29 186 250 218 53 107 74 41 140 45 140 4 31 27 113 69 36 188 128 46 81 132 34 77 101 50 169 28 156 133 164 129 253 215 241 194 174 172 194 42 220 190 205 227 223 125 42 185 109 222 61 100 144 193 147 66 193 232 72 220 164 225 179 24 189 206 106 11 94 84 43 63 244 25 229 114 152 79 232 252 147 54 43 138 6 104 248 81 78 162 136 226 36 206 113 106 248 66 115 193 28 216 164 130 112 222 54 251 213 143 169 214 127 195 37 79 48 191 31 239 222 47 54 197 188 194 74 4 90 50 70 38 100 59 49 223 218 178 37 231 49 12 152 217 227 91 99 20 154 159 152 122 106 149 86 103 187 70 156 1 251 186 172 207 166 67 51 147 24 159 0 66 193 212 209 173 202 54 121 186 247 106 241 139 248 136 144 151 199 247 80 188 144 101 75 21 223 57 158 220 219 236 232 23 100 202 212 173 34 206 147 90 245 218 205 94 143 37 178 123 245 10 207 222 177 255 205 243 59 2 92 205 14 246 210 227 42 114 60 115 43 247 225 110 54 179 180 171 8 226 94 227 206 84 12 108 245 165 220 186 62 202 190 198 31 48 221 104 253 145 8 22 239 235 157 224 89 115 154 66 225 233 26 132 65 101 103 113 198 133 195 218 235 163 15 66 48 130 138 254 104 191 21 132 73 188 3 18 49 233 212 33 173 203 85 255 167 237 129 60 173 232 204 54 14 112 18 11 20 121 253 133 205 30 128 169 42 1 114 138 184 35 247 111 197 232 255 8 125 197 39 27 123 188 217 183 113 101 115 55 200 76 41 136 182 194 36 115 226 46 180 223 15 180 184 199 127 207 175 183 18 108 253 224 68 225 189 230 145 197 113 58 99 64 169 236 231 55 89 138 194 172 139 126 15 235 114 7 190 146 185 206 38 26 160 116 201 4 85 157 75 151 138 219 4 150 5 192 67 120 123 231 151 29 125 34 237 37 125 175 14 219 63 40 148 37 198 227 142 220 5 165 190 80 20 226 226 188 106 110 189 68 213 83 144 111 161 33 212 140 77 52 244 117 247 254 247 134 221 112 95 223 125 162 95 247 113 127 148 138 20 251 103 234 125 73 19 94 81 44 249 114 11 173 196 15 63 229 13 115 251 195 11 98 206 183 202 33 193 89 219 11 110 155 116 53 252 253 48 32 153 170 120 19 185 239 38 248 134 53 99 79 234 178 251 112 68 87 151 119 91 159 228 132 234 207 90 233 251 86 23 140 87 198 204 228 239 33 97 205 23 105 57 191 169 94 234 175 182 54 157 209 165 39 1 23 153 99 4 83 250 118 150 110 225 141 205 108 23 85 157 117 151 134 213 237 178 162 80 51 220 165 2 220 8 167 35 52 225 141 195 156 254 21 76 95 231 237 249 231 199 223 249 56 16 105 49 246 179 86 86 199 222 103 162 50 165 41 77 133 132 4 246 90 221 161 237 175 20 1 224 5 208 134 151 85 245 81 241 166 113 128 176 170 18 208 148 167 107 165 84 201 247 77 110 178 243 212 76 28 185 151 25 3 254 91 135 233 7 181 194 191 189 100 178 100 20 92 126 239 85 113 127 203 20 251 252 161 1 63 35 197 97 30 51 62 136 236 104 162 216 84 86 49 130 181 92 215 169 183 20 181 106 88 75 233 118 139 43 234 2 58 27 15 194 152 140 103 217 39 100 170 4 96 201 205 75 153 189 203 211 117 177 25 176 204 93 16 68 7 53 84 183 210 189 91 68 187 188 136 34 168 145 152 249 26 42 26 225 31 239 15 249 137 120 247 29 172 107 103 137 180 207 217 121 27 149 32 90 137 141 176 165 165 165 165 1 0 0 64 0 0 172 94 103 33 181 100 23 240 0 0 0 114 0 0 25 110 0 0 0 0 0 16 49 217 0 0 7 90 0 0 2 148 0 0 0 0 15 0 77 121 80 108 117 103 105 110 54 56 75 46 112 114 111 106 0 1 220 45 77 77 80 82 67 87 73 69 1 0 4 110 0 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 37 135 0 0 9 73 0 0 0 0 15 0 66 193 212 169 9 210 149 55 104 18 166 123 198 254 115 231 189 56 26 63 233 107 89 215 26 41 64 39 168 254 239 247 106 245 213 179 37 162 85 150 47 25 75 142 73 147 42 103 39 18 89 87 185 158 183 144 191 121 197 58 247 237 47 168 4 250 221 80 196 140 250 2 153 82 24 7 101 152 165 56 154 236 133 124 32 161 65 134 202 240 234 38 74 220 207 29 183 187 78 143 128 78 228 25 224 83 50 226 241 200 15 193 111 178 15 246 78 206 228 147 246 197 203 10 10 242 105 41 4 66 205 9 1 225 252 22 138 140 209 6 181 240 179 154 27 24 6 94 118 33 215 71 251 65 6 46 194 156 224 245 152 248 245 163 117 106 184 81 55 44 43 63 12 15 131 173 177 63 58 108 90 116 237 57 130 18 45 207 39 168 184 124 14 234 151 77 158 24 238 174 149 45 154 30 127 131 200 231 47 199 96 208 217 78 147 104 4 219 175 174 33 142 236 210 130 219 100 211 116 254 15 231 119 8 95 0 178 98 122 210 142 229 104 67 70 12 175 141 92 58 110 110 125 213 36 115 84 117 144 245 75 148 181 55 130 172 219 99 192 169 188 102 174 245 3 98 201 249 187 198 155 60 173 205 234 41 227 58 211 109 39 124 98 234 206 156 15 73 86 25 233 109 125 254 184 178 214 178 133 136 246 117 48 173 55 248 26 8 190 78 97 200 67 23 26 223 148 9 135 229 250 93 43 221 207 238 48 11 146 126 167 202 57 129 122 208 16 68 11 171 85 193 55 197 75 206 6 101 225 159 104 37 53 24 149 113 98 108 118 35 180 159 124 25 241 188 82 51 147 186 228 19 144 214 103 241 33 199 95 1 89 148 121 49 217 177 30 75 206 83 68 131 49 235 210 72 87 124 132 117 54 28 248 36 131 82 144 238 147 41 18 75 146 21 97 35 176 24 27 156 45 171 65 232 213 217 183 86 97 199 127 122 105 229 192 146 21 171 163 104 83 164 85 85 159 97 16 133 250 117 123 35 109 109 221 183 95 120 25 237 167 23 213 43 6 178 186 44 154 201 162 86 26 136 87 11 90 163 230 224 102 104 162 19 246 228 233 218 91 12 199 141 183 74 205 224 12 153 150 177 85 0 41 202 28 63 57 160 34 129 152 15 10 240 140 213 45 91 151 230 63 252 32 81 62 58 251 113 147 52 74 212 214 30 114 32 135 185 204 7 224 181 26 172 91 169 81 65 140 201 52 185 195 170 193 233 103 214 112 109 65 219 94 83 253 182 167 152 47 211 90 104 203 34 241 216 55 162 73 128 24 254 18 243 43 51 199 224 93 181 216 4 195 100 21 1 142 111 89 99 181 120 228 69 89 150 166 67 160 133 83 74 25 120 228 202 151 213 197 238 169 7 25 75 215 132 139 13 128 148 42 185 174 244 128 76 188 161 166 164 16 51 147 115 251 235 205 105 232 86 142 76 237 244 167 29 43 177 248 156 194 246 97 15 7 255 213 141 41 156 105 175 207 13 3 192 68 119 2 85 97 230 126 53 40 79 97 45 221 168 205 66 34 36 28 180 173 22 22 180 51 194 56 193 255 243 75 101 57 141 155 154 6 150 42 8 180 204 128 177 95 60 122 220 131 125 225 225 49 227 224 60 187 72 148 80 225 109 173 250 161 103 80 190 248 119 106 225 182 172 156 189 14 39 39 172 51 134 119 87 74 119 174 13 184 80 179 206 211 203 197 4 98 108 88 244 9 167 90 0 179 111 74 175 93 37 151 71 255 226 242 57 3 70 223 10 238 143 109 72 108 218 5 38 140 97 70 133 196 185 229 124 137 190 203 76 81 53 60 4 82 244 201 125 216 66 13 237 218 214 208 120 143 242 251 23 135 220 72 32 82 237 68 189 70 62 224 254 70 62 224 229 134 119 188 130 31 152 255 212 226 149 189 221 60 223 148 73 202 157 18 249 54 56 126 101 207 255 58 91 68 133 67 118 98 230 235 242 45 38 75 183 17 235 204 212 204 222 45 249 140 101 163 86 59 125 195 111 43 228 127 205 120 199 85 241 203 115 36 38 114 138 200 134 12 65 52 23 170 58 186 89 15 23 144 208 141 125 252 131 154 213 103 133 164 20 24 181 20 212 220 255 114 55 158 205 47 147 146 107 120 61 236 170 84 104 212 61 32 201 252 208 92 120 214 182 30 6 28 5 1 22 67 109 244 114 222 27 168 58 178 108 199 187 12 57 225 72 255 253 245 130 250 31 222 250 246 10 101 46 52 182 55 251 253 245 81 49 245 105 93 45 82 221 74 249 125 1 22 82 12 24 109 64 86 153 199 117 92 85 16 118 131 199 159 35 198 115 25 194 53 204 76 60 91 61 99 94 137 235 45 223 47 205 83 53 161 9 165 132 157 86 145 51 163 200 190 148 205 153 118 167 140 3 86 133 127 81 179 26 56 173 105 221 157 174 25 29 252 191 134 231 205 247 66 63 40 168 20 174 40 253 99 88 50 93 57 46 77 42 38 230 44 152 237 96 246 158 174 127 80 223 21 171 208 218 64 83 60 6 39 178 161 246 16 149 28 35 238 182 210 44 48 166 87 16 17 60 128 20 135 242 84 199 79 197 192 216 159 45 88 172 97 28 155 254 95 247 229 19 84 119 64 208 127 23 119 239 50 27 133 55 86 37 222 63 40 63 237 92 219 43 139 185 171 144 78 174 41 45 134 33 179 81 222 241 244 47 230 107 206 53 93 206 223 25 220 198 187 145 188 22 208 189 21 158 201 29 156 207 162 236 106 151 65 58 250 220 39 200 228 244 143 101 56 32 72 194 32 92 161 170 95 226 91 247 74 68 91 243 111 13 53 30 159 155 43 194 142 72 76 100 240 231 155 202 2 170 87 103 101 137 13 158 138 204 152 21 128 163 227 158 239 113 74 203 205 138 28 253 172 176 47 237 128 246 167 129 252 181 12 189 44 9 25 249 55 100 198 20 247 11 221 58 43 244 154 235 66 177 195 182 215 227 81 34 233 12 208 171 215 60 228 237 247 68 237 254 101 72 11 189 214 132 0 237 192 83 247 146 44 29 115 128 161 61 99 89 134 224 142 199 58 193 76 75 167 233 190 242 240 211 62 140 149 132 19 231 30 187 11 119 216 16 130 123 220 109 76 105 8 8 51 177 93 127 176 168 236 224 185 239 147 241 252 89 235 117 89 232 240 134 105 5 97 209 251 211 122 163 130 146 101 27 0 163 26 227 99 143 189 100 252 184 92 204 15 249 41 66 137 162 186 236 108 107 110 37 6 27 122 43 43 183 9 177 188 52 107 174 190 52 142 8 234 72 246 140 207 86 16 62 58 111 246 174 164 206 167 225 25 226 156 194 36 44 43 216 74 52 246 175 115 93 50 77 141 193 52 62 121 123 202 32 231 159 172 154 127 94 71 139 59 99 60 95 93 5 219 230 131 152 119 71 166 108 172 186 159 236 122 151 241 89 190 225 248 70 6 59 222 41 63 1 165 51 242 86 140 13 190 182 4 62 76 202 29 142 235 136 247 213 221 89 87 129 198 64 125 243 139 125 99 248 77 77 161 154 149 206 132 228 19 219 21 20 117 100 106 17 25 129 82 47 223 238 149 91 209 180 62 152 199 225 74 120 88 182 193 105 50 55 18 249 249 177 21 79 110 42 239 129 88 200 29 133 34 98 15 45 175 191 221 140 248 216 149 245 89 166 178 80 182 78 190 69 50 222 205 239 161 190 224 7 58 209 212 252 3 217 253 195 183 64 52 49 155 161 91 219 253 14 98 134 170 152 67 190 151 34 0 244 30 29 40 140 166 74 48 227 156 179 126 37 235 250 104 255 27 136 65 183 130 244 43 240 35 123 226 134 15 235 124 3 209 133 214 35 208 2 203 15 238 71 79 163 249 77 38 232 160 127 174 99 90 151 104 248 47 21 102 40 10 75 7 38 213 12 191 187 208 175 51 104 120 67 247 117 94 241 128 200 6 166 210 115 55 169 169 217 14 21 75 98 182 140 181 241 103 66 242 210 58 92 215 100 223 168 223 224 23 185 68 213 123 36 81 24 49 168 209 69 245 79 245 26 172 28 132 233 201 18 122 188 2 206 212 185 33 163 205 123 122 253 31 107 244 225 171 154 126 238 192 76 97 3 130 6 136 89 106 53 55 117 226 25 20 196 35 147 112 210 205 162 106 50 158 32 159 46 222 213 182 51 197 240 80 51 244 161 110 150 205 10 210 29 211 191 134 8 62 165 173 11 212 161 149 21 59 192 148 10 206 136 162 153 70 254 239 231 184 38 59 63 15 77 159 36 158 37 220 110 219 185 101 189 130 102 113 59 89 8 251 111 16 111 199 206 9 183 37 71 67 15 254 146 122 128 22 246 172 83 255 83 89 0 246 254 92 199 238 49 177 50 56 60 7 47 70 50 98 209 93 12 210 64 75 186 162 82 59 16 42 28 252 150 217 13 179 131 109 44 168 155 109 124 107 172 34 39 56 93 136 156 226 51 195 139 240 86 22 205 163 244 246 122 13 115 134 172 202 203 8 83 178 251 160 6 219 89 67 181 18 209 214 63 231 59 24 227 158 23 7 240 58 71 177 7 113 158 183 64 244 85 7 107 227 60 68 82 254 89 181 121 244 154 127 239 164 100 253 201 24 40 247 95 2 117 74 39 105 8 93 65 60 200 39 164 174 113 104 28 234 29 2 248 240 139 89 240 62 145 199 95 144 239 95 112 133 161 248 7 69 77 160 179 10 214 118 130 47 36 196 113 185 107 12 184 128 166 184 156 240 64 39 22 137 148 42 166 209 186 106 148 29 222 181 182 12 140 98 107 232 202 192 126 214 67 12 90 3 7 248 95 36 76 59 188 66 63 98 47 55 72 103 196 189 55 155 89 36 43 7 171 26 228 14 129 26 180 143 57 83 243 131 55 10 86 141 23 182 84 53 42 118 71 72 221 140 17 103 43 14 243 168 38 236 161 104 222 196 131 99 100 2 95 182 238 89 158 129 168 152 135 33 197 190 201 123 56 211 17 219 71 63 164 17 28 210 229 135 70 215 21 37 111 40 118 238 71 231 185 92 225 238 138 15 196 191 125 76 175 41 229 73 155 45 56 91 234 166 249 104 4 179 127 38 179 30 101 157 148 54 199 109 249 21 239 65 56 118 173 182 77 172 225 67 185 168 180 146 85 179 50 125 131 216 129 42 197 47 124 221 171 199 98 155 4 245 181 64 165 225 148 159 88 65 126 225 27 188 72 65 126 66 80 88 14 250 23 35 36 212 224 92 173 32 66 193 212 120 244 150 156 45 75 143 253 186 160 103 148 110 138 210 209 163 125 11 126 208 172 225 255 129 97 133 7 117 173 34 14 198 74 241 119 114 179 69 78 241 172 212 89 124 91 120 8 205 235 82 98 142 194 32 245 179 201 44 162 110 214 68 254 158 4 147 19 254 191 118 156 232 12 254 184 209 40 217 121 173 182 158 0 168 203 19 227 183 248 42 166 119 134 20 184 72 174 2 197 58 133 29 213 233 74 101 1 85 71 25 150 55 32 225 207 234 168 1 132 48 188 104 84 53 145 212 222 88 12 164 128 218 29 207 78 77 249 16 88 28 232 164 142 192 159 5 8 135 38 217 75 132 1 169 131 180 254 194 85 160 186 146 180 24 82 91 133 163 169 12 134 152 70 138 133 74 186 173 245 88 137 116 233 235 3 118 28 107 126 133 54 54 53 235 170 9 149 65 194 190 72 136 43 247 87 106 245 14 28 216 174 131 61 75 2 32 48 18 90 42 185 42 139 107 94 143 236 239 204 214 131 5 194 198 84 239 253 129 60 182 156 134 15 194 224 152 87 64 148 238 6 49 222 188 124 178 199 34 127 212 174 139 147 19 174 19 177 25 35 173 239 20 162 133 142 35 21 226 49 117 215 117 82 150 137 206 32 224 106 132 88 229 130 225 121 252 199 118 93 193 14 161 171 76 13 36 30 78 89 226 51 243 117 178 220 71 194 253 155 147 117 169 112 214 170 151 80 176 47 113 137 200 71 128 223 66 205 149 141 14 174 254 215 224 212 209 129 71 42 114 80 117 179 6 107 207 86 126 92 5 186 201 125 182 1 242 50 66 210 232 200 192 245 137 242 31 142 235 147 161 97 3 161 124 80 122 86 211 86 19 222 78 188 48 94 226 5 28 139 115 71 189 71 214 76 63 3 208 118 242 103 42 218 166 31 193 172 90 1 221 207 45 41 132 69 109 253 53 20 18 46 39 129 112 108 97 15 218 100 16 0 87 235 39 246 68 156 112 218 135 240 49 235 29 171 113 255 41 197 77 237 159 181 64 19 122 215 56 164 218 187 2 68 137 251 240 202 132 181 223 81 212 100 47 233 101 78 16 141 85 48 151 108 6 121 86 47 13 210 187 225 178 157 228 22 177 139 131 77 189 136 67 214 106 21 35 156 24 206 241 20 160 172 42 105 163 82 42 95 198 28 128 214 182 183 18 226 9 84 238 73 67 7 6 79 149 143 81 6 165 26 204 217 230 127 245 25 64 156 2 31 40 230 31 152 83 16 27 19 48 88 183 13 234 44 214 230 142 115 130 245 184 253 244 91 188 169 175 129 42 172 27 94 36 204 250 103 164 187 225 237 171 117 127 191 201 200 10 17 53 9 251 134 12 155 134 192 93 150 96 13 18 25 200 160 243 9 207 137 253 198 235 76 86 159 204 94 141 69 7 244 119 142 65 54 80 199 204 199 217 168 184 53 128 33 0 165 165 165 165 1 0 0 59 0 16 181 174 127 194 181 175 1 132 0 0 13 31 0 0 27 191 0 0 0 0 0 11 26 238 0 0 2 170 0 0 1 124 0 0 0 0 15 0 83 113 117 101 97 107 65 112 112 46 114 0 1 48 155 84 69 88 84 67 87 73 69 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 104 0 0 0 0 15 0 66 193 212 165 47 158 104 38 183 219 249 217 33 168 151 12 136 53 189 184 158 14 233 171 185 188 252 36 85 186 68 105 32 221 147 163 179 129 148 246 162 31 24 235 185 98 218 101 160 56 155 179 209 51 153 16 169 186 131 139 49 67 115 239 159 135 201 102 194 30 232 134 74 94 72 73 53 209 51 0 164 170 218 80 239 206 105 215 91 90 51 83 245 201 43 25 56 235 71 7 130 202 80 0 66 193 212 157 170 210 35 52 27 93 136 197 106 52 54 31 166 122 205 231 32 32 112 160 40 138 126 3 77 99 4 251 242 199 125 87 169 103 99 226 123 60 70 128 113 18 28 85 6 189 121 109 31 26 249 161 83 169 157 62 74 239 8 51 45 186 94 58 49 252 46 209 169 153 202 106 248 205 178 15 4 139 59 160 209 168 125 168 73 48 103 120 110 199 109 171 159 179 239 33 94 118 136 247 133 234 179 177 46 218 151 77 116 44 159 93 94 44 99 70 93 125 137 53 84 131 32 59 239 13 28 34 65 92 91 104 119 79 119 174 134 219 228 67 30 37 182 200 207 220 0 237 187 20 146 233 200 152 182 39 167 14 242 53 180 240 195 154 154 94 91 182 52 134 249 136 119 67 194 147 228 97 60 211 48 22 65 190 202 99 103 114 208 10 131 161 3 87 31 64 250 4 254 133 169 217 77 183 225 106 142 240 240 180 146 248 39 192 170 88 102 69 95 13 89 148 174 206 78 162 131 133 161 167 150 32 158 248 178 173 101 227 217 102 143 206 171 62 75 41 237 239 9 58 126 14 226 107 122 250 208 40 209 10 252 105 101 26 155 10 18 126 136 104 210 186 8 64 134 82 245 212 110 151 241 61 69 16 181 128 165 251 123 137 63 121 161 161 183 56 176 164 4 136 161 23 48 88 225 129 48 129 37 151 67 233 215 152 90 89 82 27 227 240 224 102 238 138 80 14 201 181 17 19 136 193 127 207 108 171 212 101 238 237 175 10 248 251 8 248 107 203 87 203 119 235 140 103 161 208 168 170 55 199 88 185 214 52 170 233 214 179 94 170 196 230 181 174 40 0 165 165 165 165 1 0 0 62 0 0 181 174 119 219 181 185 225 57 0 0 25 110 0 0 42 153 0 0 0 0 0 14 137 138 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 65 112 112 46 114 115 114 99 0 1 143 11 114 115 114 99 82 83 69 68 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 40 91 0 0 14 106 0 0 0 0 15 0 66 193 213 6 123 44 59 72 124 72 72 197 27 247 40 106 77 28 82 191 109 233 234 129 68 172 64 151 92 137 13 162 117 79 181 249 241 160 208 186 214 66 28 19 21 229 44 238 147 88 235 125 13 184 172 223 44 83 195 9 154 194 15 150 13 190 23 231 60 188 187 19 21 90 103 2 113 50 92 122 190 9 242 217 183 73 253 194 178 78 32 39 167 118 78 53 110 178 29 121 67 99 76 185 176 234 243 228 234 18 225 157 55 242 172 156 73 228 115 188 232 185 12 237 237 47 109 50 243 149 120 56 20 119 13 7 204 103 32 236 214 83 136 196 46 188 244 255 10 233 104 43 30 150 64 137 215 224 35 171 137 137 144 202 1 133 73 137 100 243 150 204 13 219 29 188 168 159 8 110 245 142 209 179 37 55 226 135 41 34 130 44 27 244 147 18 12 214 54 140 90 228 178 134 197 182 156 178 68 192 105 160 128 45 69 7 188 215 223 215 95 34 229 109 189 233 34 253 118 35 55 136 50 192 232 147 177 200 67 198 153 239 108 125 139 12 168 45 12 246 121 91 221 64 56 132 17 35 92 130 105 126 22 189 4 21 95 76 120 195 142 20 90 186 48 73 254 175 241 134 23 206 13 131 125 31 40 57 144 47 237 143 160 23 210 155 121 43 226 147 170 11 2 70 178 96 67 226 104 37 36 251 43 141 2 106 193 65 229 43 240 231 248 200 158 37 80 188 237 89 36 115 225 16 249 57 158 78 130 41 120 26 36 160 34 77 91 71 116 68 0 134 182 21 59 144 103 120 146 219 66 254 6 192 70 26 167 175 92 105 21 104 182 29 152 121 126 233 109 1 212 70 41 139 234 79 119 248 60 132 31 227 64 106 148 125 100 81 51 40 129 164 215 22 201 225 109 16 250 128 18 147 15 146 214 214 85 66 230 195 32 179 198 237 61 204 154 172 19 99 38 49 151 90 95 40 145 12 186 176 59 15 94 144 29 131 150 178 145 146 9 7 183 237 173 223 154 234 130 57 225 36 62 241 66 31 108 209 236 142 136 254 139 170 157 226 167 97 218 45 183 66 141 50 11 129 250 14 97 63 216 90 123 86 188 186 144 225 192 51 243 141 30 103 208 134 13 149 239 68 196 133 215 16 21 71 175 62 221 44 50 187 63 45 212 32 161 134 112 196 154 119 247 7 10 203 19 206 234 219 223 162 194 210 101 77 1 1 108 151 255 112 30 143 81 62 26 243 115 99 226 178 236 199 156 203 66 222 234 138 105 100 132 149 57 24 196 235 151 197 146 30 229 88 59 69 129 239 208 112 52 78 164 16 97 201 58 205 29 158 169 71 169 93 131 38 182 113 204 213 124 229 109 95 60 67 147 37 21 49 60 46 24 203 207 198 110 251 209 179 43 201 60 195 54 188 221 135 30 197 3 114 214 191 64 51 254 68 204 205 128 73 241 73 134 188 198 19 155 1 47 4 133 181 196 62 18 20 86 126 171 91 200 41 20 20 196 101 84 47 226 183 130 145 36 57 33 185 3 247 88 124 47 172 220 249 175 224 161 76 47 253 154 126 129 7 141 159 38 214 48 196 200 159 68 40 252 221 131 227 251 189 179 150 155 209 66 74 205 62 88 63 90 233 14 107 95 88 153 13 8 230 210 226 62 116 33 170 162 100 2 175 71 193 196 65 59 247 222 210 111 90 210 34 59 224 185 198 90 43 36 134 173 144 146 230 100 148 158 166 107 35 83 59 199 82 228 211 213 230 221 128 155 64 31 201 70 86 187 75 33 18 184 177 218 158 72 201 11 22 104 226 248 145 228 190 31 150 180 102 108 46 193 89 118 203 48 64 143 48 232 19 194 93 156 127 14 149 213 163 161 196 95 206 87 145 240 73 81 25 148 99 99 137 205 39 89 205 225 22 158 246 71 231 1 173 104 193 178 180 171 210 169 44 248 223 89 165 135 190 99 140 73 214 192 63 37 153 218 4 217 123 199 195 239 154 161 145 203 248 157 49 21 105 215 192 205 131 235 254 179 181 236 188 178 222 89 245 5 16 203 7 25 7 203 79 160 92 235 80 35 249 170 211 161 228 37 109 51 250 50 199 184 102 219 153 233 20 132 228 98 52 184 127 239 92 51 202 120 168 138 66 101 221 11 6 146 77 90 129 50 12 0 193 81 79 240 182 192 199 111 62 101 171 107 82 51 124 34 112 13 144 179 52 251 17 100 170 126 5 47 135 77 154 74 115 228 166 12 217 143 107 15 215 93 177 235 63 109 26 37 46 24 134 0 236 52 215 199 123 26 0 59 14 254 121 58 174 117 250 136 249 127 184 242 154 146 232 108 226 84 64 37 246 123 245 13 133 83 112 16 170 1 111 172 161 228 142 219 62 201 240 2 178 146 157 11 107 194 242 127 13 91 39 63 242 71 135 210 117 214 203 168 128 169 123 197 188 188 158 148 0 195 186 168 191 242 48 46 84 29 194 210 255 108 7 56 208 180 56 228 229 165 205 35 224 66 203 208 242 147 110 225 232 54 18 66 158 178 126 23 25 81 168 178 186 43 73 200 245 216 44 172 222 147 94 131 213 34 116 131 167 11 241 201 53 87 83 144 211 154 40 237 126 65 156 149 78 239 140 96 192 147 77 208 101 254 232 20 142 86 198 7 221 6 68 76 229 79 148 74 153 132 117 194 141 42 10 106 65 251 210 150 131 74 181 115 123 57 26 32 228 185 160 126 58 13 106 74 62 219 160 35 211 116 58 105 203 132 89 248 111 119 188 169 25 80 210 67 79 139 148 177 195 25 157 138 157 45 4 58 217 200 20 53 30 68 197 58 238 6 238 126 153 225 6 194 95 54 245 250 8 92 187 43 150 230 59 15 241 115 77 143 79 22 107 149 235 235 250 199 157 204 163 87 59 54 150 250 92 74 104 162 26 245 189 48 226 252 37 241 3 143 156 195 19 173 11 192 101 101 40 152 161 155 147 253 131 144 122 41 120 105 132 232 188 123 33 95 138 188 153 132 68 223 18 195 156 197 25 20 214 187 20 215 110 14 163 136 112 228 198 38 96 228 254 140 109 243 142 65 253 196 238 142 196 178 254 112 171 157 156 23 85 213 51 197 89 169 216 66 28 162 139 67 197 60 4 1 146 253 129 9 98 255 16 131 107 186 174 150 82 173 227 153 148 129 93 221 139 148 60 167 140 8 242 121 171 170 61 234 132 242 178 204 10 46 228 66 8 139 193 132 137 122 43 0 150 177 116 204 208 39 108 18 159 81 107 50 186 77 168 130 182 105 15 129 86 93 115 23 95 0 85 109 38 241 124 17 96 211 214 60 68 98 134 25 106 29 41 170 155 239 41 172 107 38 105 59 82 7 61 248 140 185 122 98 175 242 227 37 216 23 110 106 89 134 8 94 154 219 121 244 207 245 4 227 52 221 137 64 246 175 70 171 96 199 197 158 71 24 159 98 201 142 142 114 3 207 26 109 146 101 170 244 152 109 0 183 49 34 172 225 255 0 16 123 152 112 154 114 165 34 179 20 54 227 63 234 29 224 218 250 216 212 0 190 224 16 235 40 136 137 183 50 74 103 232 50 174 92 188 32 209 186 83 10 185 161 137 174 7 147 181 13 59 122 117 4 51 198 19 97 140 40 23 179 164 108 84 180 197 116 150 229 237 188 118 50 65 45 191 92 159 36 131 132 171 199 83 152 236 168 188 168 177 220 157 17 201 7 27 220 151 51 103 163 179 170 78 222 237 227 243 184 24 175 102 193 58 210 126 213 205 143 198 120 24 200 37 243 192 62 23 209 182 74 110 93 254 196 54 89 4 245 116 16 155 120 20 67 59 84 153 101 23 245 237 126 142 102 74 205 204 158 5 153 54 76 28 118 124 236 250 99 109 6 216 103 135 246 223 150 11 150 105 203 50 5 182 91 220 101 66 167 80 86 2 211 235 126 189 204 34 107 239 147 102 155 103 251 150 211 213 221 83 213 237 244 160 53 142 238 148 137 73 195 11 198 241 85 164 81 169 231 85 18 121 180 36 201 159 110 173 39 116 98 120 75 95 6 54 50 85 224 108 4 174 121 11 134 133 49 41 77 100 68 163 31 91 250 81 217 154 243 146 241 199 33 132 242 109 136 156 60 216 68 217 47 152 57 55 61 22 215 61 15 187 69 227 172 61 156 167 181 242 15 159 202 148 154 11 12 88 167 205 100 48 72 122 81 41 115 219 93 213 4 188 40 186 223 79 93 76 128 101 130 102 191 2 69 157 157 165 231 38 45 163 251 67 230 230 142 217 135 129 133 226 139 176 195 166 166 106 84 23 90 22 122 61 163 168 77 43 183 220 192 91 43 77 162 39 223 122 26 79 39 4 32 193 28 187 158 250 208 144 89 114 81 188 16 16 247 68 157 165 103 157 234 5 234 145 202 42 69 193 80 178 209 10 37 139 71 110 86 17 231 241 242 13 55 175 228 223 182 82 138 61 128 74 122 75 76 121 253 244 18 122 33 116 214 234 27 211 118 120 76 116 91 64 127 43 142 20 80 214 39 111 202 88 151 220 124 74 215 51 54 23 32 228 110 125 41 37 27 148 248 120 54 138 146 28 163 242 99 132 167 168 51 83 74 216 197 12 112 212 215 51 148 122 90 36 243 245 53 232 195 238 170 184 225 113 252 180 159 183 234 42 120 62 87 68 179 176 239 173 47 190 233 239 66 107 80 237 100 227 41 149 220 149 156 186 247 62 74 224 208 114 178 35 190 231 138 252 198 193 204 120 99 103 133 118 7 195 233 115 113 213 255 99 190 166 13 185 213 218 188 213 139 125 239 224 74 187 189 92 65 200 50 127 143 9 154 191 208 89 193 121 203 155 64 130 117 96 220 65 114 60 169 102 164 98 225 174 243 104 162 111 144 250 154 57 129 145 123 220 42 12 96 72 1 89 255 17 130 105 177 108 104 95 180 199 73 22 86 113 230 94 150 183 8 53 235 86 148 208 127 243 69 140 231 218 60 227 255 143 172 4 44 70 193 123 241 108 224 16 202 215 25 39 132 84 142 182 109 81 252 8 19 95 37 194 242 108 140 160 244 159 35 156 192 108 144 210 211 169 164 215 19 25 75 30 141 85 32 237 139 42 134 97 37 37 186 35 238 5 120 246 7 156 224 24 237 157 156 9 9 14 47 88 118 118 86 21 96 205 56 165 10 181 123 211 15 152 218 152 189 120 104 11 161 31 131 229 170 137 38 32 182 40 214 99 126 120 151 104 86 200 31 54 44 66 240 191 154 115 208 219 146 61 151 19 73 166 246 230 110 37 55 96 140 113 47 218 32 228 144 57 133 194 77 7 160 76 84 149 52 250 178 239 223 59 103 12 25 125 238 167 31 5 226 252 97 89 111 15 255 147 125 208 154 74 239 108 20 210 209 145 233 54 39 199 247 150 112 176 8 182 218 133 198 22 102 174 153 84 120 192 235 190 225 164 131 90 147 199 113 218 89 201 205 10 2 18 12 40 65 131 66 193 190 156 6 225 118 204 143 0 38 164 60 101 99 212 125 161 250 41 188 73 160 224 212 76 173 76 2 187 200 24 164 46 147 238 241 109 247 207 25 71 2 12 164 104 32 158 4 229 91 142 55 178 30 184 29 105 83 203 121 71 49 7 22 246 11 208 169 81 140 157 106 85 147 2 100 99 186 217 41 225 69 18 232 179 8 56 58 220 40 194 255 57 125 8 199 140 201 174 149 51 16 193 240 157 127 235 56 152 72 17 223 120 109 145 192 73 27 179 153 103 118 146 42 144 166 15 161 176 53 48 64 140 186 18 4 158 193 92 232 177 39 52 153 26 229 217 188 181 6 144 156 102 45 136 41 215 244 89 5 203 232 251 3 164 109 54 254 124 174 103 175 3 62 88 131 200 150 204 217 238 179 86 106 230 171 180 78 136 174 152 196 127 209 218 209 15 96 14 199 98 203 80 236 187 249 212 150 74 162 9 53 203 115 137 19 32 100 186 178 16 37 60 150 201 36 143 218 101 204 150 159 64 42 72 38 198 235 82 140 134 180 96 229 155 165 85 251 26 176 109 136 72 221 41 191 144 34 151 62 178 90 238 134 182 81 11 211 210 39 56 80 38 125 70 89 20 219 177 148 9 138 54 131 198 37 192 103 231 31 9 211 88 197 221 25 203 84 108 55 89 137 210 98 94 34 38 61 165 136 181 0 160 140 87 200 79 126 147 86 134 22 190 232 222 11 190 78 175 44 9 213 96 122 73 135 85 198 160 47 250 8 136 228 41 176 5 232 55 85 36 69 244 160 93 61 136 201 125 21 228 251 14 10 98 22 207 245 116 100 175 61 35 84 200 249 177 108 243 121 53 39 120 234 103 255 143 110 126 168 71 236 162 23 149 170 111 206 41 73 158 98 98 13 2 221 246 183 211 220 132 255 239 214 31 254 24 253 8 95 153 173 34 221 207 252 47 179 216 81 64 129 15 209 120 248 155 44 220 102 86 19 3 179 193 89 177 160 38 118 126 196 66 247 7 80 51 32 17 127 78 237 60 255 168 23 160 73 172 254 208 254 71 158 196 123 227 38 65 27 150 177 197 115 68 130 247 150 105 114 160 236 231 217 25 52 78 206 99 159 151 110 35 197 204 96 188 149 95 232 18 243 130 236 198 248 98 34 95 91 202 172 171 157 158 127 142 247 179 59 66 167 161 122 66 150 30 13 130 188 140 20 246 20 37 142 57 118 253 18 105 194 86 148 253 173 88 168 135 95 59 234 128 24 230 167 171 169 77 229 91 6 69 104 216 58 197 9 18 132 230 183 207 66 74 8 112 110 94 24 150 78 123 89 229 184 2 81 134 244 79 248 53 193 31 253 202 88 68 220 128 241 106 22 153 233 198 254 17 146 142 16 81 50 51 0 101 133 159 201 195 157 53 38 59 110 133 190 249 102 215 166 16 55 164 150 179 38 180 148 30 125 22 174 107 61 167 197 102 30 232 107 101 111 58 190 89 129 130 188 137 215 166 20 153 99 124 209 151 10 146 217 177 91 27 34 207 25 4 104 109 188 231 25 57 73 108 74 52 188 47 99 77 237 52 18 221 254 200 4 78 250 98 5 55 219 72 72 31 120 0 58 86 57 87 245 88 143 242 158 79 117 29 179 121 213 254 156 58 35 112 204 8 192 53 218 207 195 10 102 12 188 155 168 14 215 99 145 144 177 80 120 92 30 54 230 164 119 238 211 129 42 215 39 152 147 183 181 169 192 47 128 206 40 83 43 58 241 152 54 212 156 228 113 240 181 110 9 15 46 60 69 53 122 108 241 73 83 202 196 230 58 26 10 219 228 194 199 135 6 173 164 117 134 108 92 196 215 247 110 130 29 134 137 161 222 84 39 62 31 110 116 112 206 123 199 199 237 252 118 179 135 171 57 136 75 82 226 197 229 28 180 60 252 117 74 139 95 71 213 244 217 65 121 43 122 158 18 12 229 67 235 156 151 171 246 6 161 128 244 94 169 195 174 110 157 92 70 153 166 113 239 76 98 126 62 14 119 123 46 47 96 10 61 65 96 174 87 225 7 28 149 187 56 4 86 207 68 21 143 164 133 216 218 87 187 66 144 210 26 19 104 12 150 141 66 50 182 185 164 162 190 70 23 123 232 135 122 123 55 145 121 212 212 191 241 166 124 130 80 194 10 44 221 214 2 146 179 97 247 231 244 29 204 217 222 100 201 252 159 153 176 153 78 228 148 230 242 186 147 8 73 180 16 227 249 153 21 145 11 227 71 86 228 16 78 148 145 107 88 26 62 233 251 81 150 33 167 13 193 131 242 151 159 170 86 109 3 203 247 249 214 194 100 219 17 16 144 137 46 58 64 40 31 109 187 161 169 61 101 187 51 43 28 233 41 100 62 190 35 1 86 152 188 183 68 245 192 58 244 56 149 20 235 255 56 22 36 11 169 149 220 237 115 199 218 118 187 20 193 28 31 151 42 127 149 253 8 46 77 240 192 184 118 202 13 102 82 148 0 124 11 233 97 99 44 70 220 177 158 27 122 34 19 103 231 206 96 165 76 37 131 55 170 108 151 211 27 242 186 160 55 12 3 117 74 246 70 195 205 201 19 135 53 168 29 73 195 17 67 233 226 158 231 81 167 75 205 92 153 237 114 122 129 18 110 177 223 228 241 58 102 166 5 197 44 132 167 201 157 107 234 49 196 1 66 3 113 28 238 87 150 61 114 126 167 87 137 89 146 0 165 165 165 165 1 0 0 68 0 0 180 207 51 128 181 189 226 134 0 0 27 191 0 0 44 147 0 0 0 0 0 20 84 80 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 114 115 114 99 0 1 144 155 114 115 114 99 82 83 69 68 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 239 0 0 1 132 0 0 0 0 15 0 66 193 212 138 117 6 34 162 108 101 231 6 20 91 211 56 193 219 89 220 33 219 10 195 107 75 152 5 27 231 106 224 142 60 45 193 142 214 233 14 116 218 141 132 10 253 224 183 220 48 100 75 105 115 100 58 24 65 73 53 43 9 24 117 55 209 99 16 95 190 99 139 64 96 131 245 235 34 197 75 251 106 137 186 37 199 182 65 145 224 189 151 42 49 60 136 249 112 27 146 95 156 43 113 237 121 159 219 232 36 101 100 248 139 40 222 64 17 37 204 6 245 69 115 89 251 53 161 238 119 54 47 205 32 11 161 189 214 41 73 64 65 33 92 118 40 77 216 4 149 217 7 201 245 235 86 237 164 200 189 117 230 116 107 118 170 61 223 87 215 191 152 215 135 27 118 63 53 155 182 195 105 207 193 179 201 218 173 44 255 23 209 54 230 70 230 191 170 234 88 218 162 254 78 0 189 235 143 71 235 73 235 254 111 62 176 1 192 120 117 233 198 124 97 48 141 160 86 119 43 75 157 248 106 129 58 2 138 121 236 40 181 223 107 196 83 239 212 11 211 127 168 143 47 98 148 49 65 103 247 66 181 174 18 91 114 28 133 222 196 8 15 185 138 199 16 49 121 100 60 53 118 156 115 92 137 25 33 182 229 180 213 254 169 96 83 215 169 204 94 243 222 9 94 160 247 94 122 37 144 169 65 198 106 21 183 95 43 230 159 165 45 106 208 10 183 244 10 91 100 191 121 203 98 18 140 48 208 186 4 45 116 28 122 1 255 18 215 180 191 11 143 156 175 17 24 171 99 175 34 58 73 171 24 150 134 114 231 150 15 114 22 171 228 166 58 243 129 190 22 67 30 35 158 209 154 102 96 165 165 165 165 1 0 0 62 0 0 174 236 103 92 181 189 232 220 0 0 42 153 0 0 68 95 0 0 0 0 0 14 51 139 0 0 64 92 0 0 11 165 0 0 0 0 15 0 83 113 117 101 97 107 80 80 67 46 112 114 111 106 0 1 61 76 77 77 80 82 67 87 73 69 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 72 39 0 0 60 122 0 0 11 183 0 0 0 0 15 0 66 193 212 151 230 44 187 242 126 170 58 34 133 163 140 183 17 157 122 10 120 46 3 129 230 154 177 115 132 128 182 187 38 26 132 152 33 12 7 131 174 149 235 137 13 190 113 230 55 119 28 49 56 198 94 127 90 153 107 242 36 68 27 154 187 180 69 140 206 26 71 166 8 123 175 77 107 21 185 159 148 70 60 141 207 94 91 1 75 250 44 159 109 17 175 129 6 138 253 250 0 74 198 150 247 182 206 220 236 60 206 154 100 62 253 110 189 234 155 249 114 57 131 142 187 188 217 2 79 40 155 230 81 101 106 30 191 176 241 146 99 208 119 7 189 217 216 127 161 17 127 60 70 31 132 58 174 79 232 217 137 63 144 81 136 251 89 122 168 220 150 69 93 55 138 123 244 15 78 250 139 42 34 75 175 189 58 113 219 132 23 144 114 144 226 248 49 44 176 111 110 27 177 122 41 118 212 115 218 95 158 41 238 107 146 198 107 21 83 5 213 131 39 113 64 13 189 159 162 124 125 61 235 69 129 82 154 185 160 235 86 24 127 202 205 205 50 102 232 25 88 54 66 252 242 29 209 82 237 53 146 106 203 1 248 244 52 202 125 248 82 90 71 70 0 246 231 140 145 245 153 168 183 154 244 88 109 43 137 126 155 40 214 187 96 218 215 117 80 181 196 76 59 22 190 91 247 65 56 100 196 25 80 129 230 108 147 182 44 197 105 108 197 88 237 199 188 30 182 89 255 162 97 92 5 128 243 151 1 205 196 171 114 26 162 222 199 160 148 57 236 192 34 16 87 13 80 46 53 131 72 66 73 62 132 45 97 55 101 14 15 200 248 18 119 243 214 203 58 100 249 184 183 119 44 238 174 3 196 252 113 77 169 16 223 212 242 234 144 47 236 214 136 40 153 213 24 233 65 63 215 59 44 7 183 198 70 76 171 185 17 8 145 180 41 117 73 5 147 241 238 181 70 241 79 190 35 156 63 71 98 125 236 77 152 148 150 139 64 127 105 75 243 111 150 147 253 157 148 145 228 143 57 183 134 109 130 99 50 110 238 156 170 71 96 206 154 167 86 99 98 44 191 65 222 188 240 246 153 64 219 199 102 44 160 96 214 116 129 152 69 32 245 98 249 144 6 8 99 255 54 220 198 89 24 144 152 255 208 62 123 3 170 180 80 0 190 155 126 61 110 112 207 62 33 74 71 167 2 1 130 15 33 32 54 14 136 27 128 220 86 215 233 136 62 0 240 222 223 255 42 222 234 175 207 65 247 247 144 216 40 236 188 18 204 157 152 91 62 92 46 154 78 84 82 110 81 210 204 52 239 182 232 68 46 245 198 31 36 21 23 26 141 97 167 58 138 98 190 49 198 81 237 122 91 106 124 126 9 113 124 201 95 190 216 131 228 79 115 232 1 44 87 89 69 216 17 175 75 213 147 74 54 75 204 187 102 245 23 75 23 44 88 39 112 229 50 181 149 126 205 149 153 179 27 49 12 4 189 159 80 109 128 125 0 238 66 85 224 246 51 34 253 209 92 15 47 57 89 6 149 155 136 59 86 82 240 33 153 251 87 222 109 169 126 22 13 171 153 102 77 120 84 143 230 23 119 84 93 44 142 41 186 18 53 65 159 43 254 144 40 218 2 42 74 148 131 29 71 54 11 126 232 212 52 141 227 133 47 84 197 187 2 38 126 194 137 157 230 71 130 143 247 160 91 188 49 78 32 190 58 159 180 252 133 78 26 248 164 108 55 237 216 18 202 249 220 205 119 253 44 245 33 250 19 135 115 24 56 88 17 2 0 220 80 226 14 142 97 191 199 34 34 238 33 216 221 184 198 60 128 238 246 32 251 65 6 109 223 140 146 25 17 197 100 30 152 20 149 186 0 42 61 104 117 21 82 80 75 100 189 109 242 191 215 128 186 166 239 248 29 63 136 193 6 42 117 23 22 82 129 92 98 148 79 201 155 165 102 215 96 103 74 138 123 1 189 158 45 252 88 127 202 51 67 53 170 152 214 202 31 86 226 86 77 244 245 219 140 97 138 11 230 28 243 241 162 6 86 200 47 214 241 94 83 225 55 205 251 100 214 120 207 158 147 121 199 30 139 221 3 108 1 22 140 118 52 64 220 185 203 14 44 172 236 95 217 91 138 142 75 233 188 119 38 23 21 138 45 50 176 141 124 80 144 188 18 146 179 1 180 95 26 101 240 234 237 22 112 210 238 230 123 25 139 30 87 91 52 79 75 208 1 242 74 243 85 157 38 199 2 201 188 130 194 29 213 85 24 88 146 31 53 237 100 125 16 142 183 125 70 129 183 193 205 78 155 90 27 155 200 181 59 28 238 57 50 44 197 16 36 208 169 28 242 1 201 48 204 176 245 159 95 144 101 146 87 167 226 61 0 56 199 144 240 231 176 142 125 107 47 114 250 185 189 161 36 147 62 164 91 145 214 130 9 156 133 147 94 72 24 102 148 215 161 13 126 157 43 112 58 14 153 26 39 14 241 133 151 91 23 169 72 110 48 20 64 45 39 187 109 114 79 132 22 82 163 60 63 244 117 205 182 220 238 111 229 57 142 197 232 223 99 90 56 89 79 109 238 38 245 28 76 162 158 72 196 3 213 143 143 211 203 188 134 132 5 223 187 91 181 45 205 40 88 148 114 47 64 242 67 225 119 130 217 150 250 122 118 139 84 188 9 94 212 182 238 185 216 184 121 19 158 41 234 171 193 105 48 126 63 136 69 207 29 252 49 24 58 55 111 165 188 233 28 238 238 57 37 38 245 229 231 158 241 242 72 184 87 191 109 121 253 198 245 50 174 72 92 14 210 219 122 92 200 35 231 104 203 175 7 213 155 230 14 117 179 118 167 255 104 103 142 211 136 248 250 220 153 228 103 82 57 64 136 61 144 251 210 38 38 157 169 43 14 240 210 241 156 148 226 228 156 88 216 133 143 65 49 28 108 97 199 168 8 0 97 241 32 159 110 122 192 48 220 183 71 106 105 201 79 201 0 164 223 188 55 140 238 54 204 214 105 95 207 254 239 18 110 62 168 188 27 139 142 177 22 154 49 199 250 245 58 203 56 181 152 115 252 230 44 212 199 43 185 176 99 221 200 61 162 79 85 36 243 139 210 188 59 99 200 187 126 142 145 17 220 245 119 68 84 162 116 186 194 75 197 250 102 248 63 239 253 56 233 47 174 171 105 204 171 89 101 250 96 23 3 87 217 105 230 19 51 97 7 46 30 60 74 69 69 88 23 81 4 52 136 176 198 204 92 26 97 72 247 220 29 108 167 62 154 195 172 254 78 218 166 71 217 227 244 160 98 233 26 111 10 218 130 121 196 130 163 215 51 246 196 68 118 152 238 144 206 231 254 142 98 238 40 92 92 146 83 245 112 138 203 210 126 185 235 243 61 252 157 74 151 48 211 166 9 162 105 155 135 152 63 75 84 61 92 72 180 165 182 152 186 41 216 52 197 42 143 123 41 221 126 189 158 88 203 114 190 194 81 46 187 175 190 190 50 238 248 221 150 157 43 51 35 36 108 250 13 148 238 83 94 172 251 224 97 17 7 93 12 213 107 70 157 201 226 151 156 252 58 60 20 105 99 78 52 189 164 156 135 111 132 67 171 30 2 166 254 84 20 104 120 227 246 205 81 139 160 163 93 5 6 64 119 255 70 78 211 191 92 136 198 209 165 205 151 245 147 57 124 58 73 154 148 91 149 137 85 84 242 56 254 7 113 98 148 17 132 142 121 195 98 223 156 22 240 51 99 89 236 54 55 213 86 195 90 155 114 142 169 159 71 172 161 253 25 67 222 223 14 107 220 225 240 242 206 37 231 184 240 124 23 46 226 175 108 49 107 191 36 63 84 35 42 94 50 25 160 23 60 253 107 100 128 24 97 69 154 229 242 247 29 221 123 178 175 225 141 103 15 21 61 177 107 177 86 169 98 50 89 143 239 49 148 20 199 108 143 83 111 45 92 213 246 252 185 58 134 171 85 243 71 91 0 63 206 255 131 230 216 102 248 161 133 121 136 131 142 6 18 239 252 55 35 110 211 55 77 190 142 253 45 113 254 119 81 113 138 96 12 174 232 247 182 40 228 186 238 144 30 74 61 1 28 242 251 184 9 16 8 134 194 217 80 246 177 33 90 32 145 218 167 178 144 237 198 64 226 212 25 140 79 66 163 144 43 186 40 193 161 70 95 57 35 226 232 164 114 111 48 110 222 1 172 131 157 94 150 177 139 138 252 54 68 219 27 97 49 117 243 102 185 223 85 44 107 132 138 174 206 107 61 239 9 37 90 225 98 50 180 97 53 188 11 28 48 171 228 81 63 19 215 31 109 166 132 147 50 255 11 167 247 84 40 102 62 98 72 91 228 34 46 79 59 185 233 129 229 97 163 43 107 202 207 169 189 47 43 126 146 206 188 90 119 237 233 76 98 114 35 77 99 227 246 84 89 53 65 207 118 204 88 87 114 235 2 112 251 129 69 83 24 86 247 112 74 120 8 254 241 197 6 118 38 196 29 227 219 11 23 188 62 53 199 121 29 82 199 175 88 230 18 22 241 177 185 88 165 3 50 252 215 57 236 230 15 45 192 54 20 169 52 74 71 224 9 114 223 201 14 6 205 176 35 186 240 1 205 52 34 144 209 178 68 254 153 229 149 6 150 249 229 159 202 41 233 65 38 117 17 215 189 88 137 107 44 82 139 133 208 255 50 178 47 221 236 173 108 220 92 7 254 247 219 34 33 27 27 224 1 22 107 107 220 72 208 192 117 91 205 60 193 190 27 213 122 43 192 122 247 67 211 247 118 38 14 71 0 128 152 51 96 7 115 217 99 171 27 72 104 217 28 234 67 202 49 53 231 168 92 245 216 254 245 29 103 147 107 164 190 232 31 136 55 210 69 125 95 51 249 88 171 4 73 138 47 159 17 123 73 25 148 206 113 62 139 4 110 202 66 122 146 162 168 109 232 56 91 157 233 66 193 68 152 211 83 22 229 25 115 96 19 39 178 37 252 70 193 249 222 169 147 151 82 217 157 118 208 136 228 151 124 135 49 32 159 44 238 40 125 26 69 69 122 230 103 91 160 63 126 79 81 133 20 90 33 126 221 61 78 43 25 180 30 249 91 11 24 176 130 135 198 9 61 11 176 83 203 40 175 218 102 183 19 43 102 142 62 186 120 14 92 115 128 140 194 194 196 95 178 61 146 71 117 3 145 125 35 147 122 220 44 240 22 76 161 47 36 150 42 12 40 180 247 122 139 107 233 138 33 203 156 197 55 203 95 100 197 241 72 184 21 239 202 97 128 138 163 101 181 139 149 87 132 208 19 62 169 179 24 243 144 177 123 230 124 238 187 20 27 101 97 89 170 1 240 129 91 245 181 107 18 61 87 92 215 81 223 246 63 151 87 251 93 242 37 69 49 23 107 197 242 32 101 232 190 232 209 7 208 8 64 216 168 222 9 186 236 97 2 228 88 201 126 68 37 31 117 253 37 109 127 69 194 149 198 113 150 195 37 167 51 20 46 130 102 128 20 143 204 47 214 30 193 228 204 63 211 44 33 88 141 80 19 175 2 60 210 144 179 20 223 13 165 19 99 22 187 18 45 63 180 18 12 252 213 236 128 175 127 162 167 239 179 226 131 195 81 214 109 220 52 211 28 243 102 222 176 37 56 255 168 178 92 234 127 221 157 246 99 235 81 212 97 2 33 90 197 83 242 22 224 206 196 166 226 168 194 64 231 101 48 43 52 99 230 22 90 71 123 145 8 32 206 71 139 248 15 28 24 55 25 236 238 202 153 209 114 50 169 149 4 227 6 175 49 172 232 222 68 204 182 180 155 235 133 33 72 99 6 213 165 47 15 45 15 245 30 113 125 15 92 190 126 247 245 254 156 22 2 103 101 18 13 125 30 157 188 227 192 188 81 82 143 38 122 228 224 140 184 93 249 104 213 146 125 210 37 6 89 3 218 48 228 248 36 151 235 187 148 46 181 193 152 5 147 119 55 224 107 161 92 64 229 71 178 232 114 199 140 134 190 84 39 153 142 244 228 116 111 217 223 82 56 124 26 114 10 176 131 249 105 182 34 145 36 231 235 159 187 141 25 77 132 158 157 154 132 168 202 161 137 164 55 52 127 167 38 166 254 31 43 139 3 8 215 194 109 216 220 212 77 10 4 74 119 67 216 50 234 14 96 42 64 72 245 116 85 252 34 171 110 62 42 242 164 177 5 129 54 204 121 14 69 68 143 216 110 92 236 138 83 237 4 174 204 112 232 164 50 235 44 247 13 35 132 110 65 146 66 133 181 239 135 166 149 172 182 192 249 33 97 119 108 3 81 95 163 38 160 18 49 112 58 86 120 92 29 6 124 54 51 127 142 141 33 162 207 33 49 112 213 205 135 201 29 19 126 130 109 28 12 66 102 56 198 116 161 20 142 21 13 227 192 5 163 38 86 158 245 50 176 13 81 118 143 215 168 113 253 193 186 187 12 110 7 168 209 180 105 173 228 148 11 189 213 98 117 62 96 65 253 223 34 119 241 164 250 151 11 95 102 115 159 244 193 181 195 172 0 32 170 173 80 104 74 91 218 183 4 88 209 13 62 231 2 128 8 239 5 139 33 50 65 167 163 187 23 20 82 37 204 38 63 112 217 21 197 175 152 8 82 122 68 115 254 250 0 231 84 54 241 226 116 124 138 8 167 53 144 119 52 82 128 66 193 213 26 23 49 177 39 244 174 39 157 3 137 108 174 7 220 60 164 247 161 126 77 121 39 197 200 249 63 65 195 7 52 53 209 205 136 26 5 41 27 165 232 192 210 190 33 0 143 96 126 157 47 241 188 121 217 38 229 170 155 72 16 16 129 53 130 122 3 248 61 9 189 232 247 55 49 166 104 71 164 62 58 22 109 109 175 133 52 114 208 235 220 96 70 25 129 47 142 162 211 51 234 79 143 138 168 181 154 145 123 5 121 231 189 102 34 218 165 165 21 78 248 82 95 235 158 235 79 251 91 137 29 133 119 28 173 54 243 28 16 65 20 111 112 225 34 155 66 203 1 28 203 151 138 193 97 240 176 104 121 61 193 4 154 92 59 16 162 99 160 219 39 0 97 34 42 102 145 103 114 119 74 120 41 225 178 162 27 188 240 18 155 112 115 227 215 5 28 120 163 161 70 87 240 240 62 173 216 157 81 122 139 80 232 235 16 103 242 54 178 65 253 148 219 255 184 30 112 24 153 131 176 79 143 253 27 232 251 30 225 139 83 35 44 13 141 140 11 116 31 152 200 83 240 189 139 227 206 2 5 22 146 127 31 194 160 57 97 76 232 152 245 241 17 219 162 15 78 191 165 84 111 9 40 190 142 101 84 31 196 204 191 90 79 129 119 209 133 127 202 139 163 196 253 111 69 14 137 128 153 155 154 215 91 91 97 57 221 112 251 250 240 73 54 37 243 245 253 212 110 208 41 50 34 52 4 64 125 225 5 84 186 195 112 93 176 26 131 59 251 39 162 201 14 20 230 64 69 226 216 130 62 198 181 197 239 75 233 248 157 85 115 34 73 227 115 152 168 1 134 95 60 224 142 72 47 158 66 101 173 173 207 216 95 194 62 241 229 255 90 223 230 206 105 55 239 69 198 139 239 27 96 131 113 37 119 24 126 244 118 51 201 79 61 171 99 242 8 209 103 172 180 237 8 198 94 172 200 152 166 38 164 66 76 212 136 140 224 186 244 46 182 204 214 210 72 119 234 88 39 15 203 194 213 86 63 56 8 212 162 103 161 232 216 28 107 190 149 239 158 35 119 91 90 119 72 124 2 126 235 153 16 82 69 49 26 242 56 143 229 65 195 145 118 110 4 237 227 152 19 1 128 74 3 88 49 198 106 20 151 169 12 224 141 113 51 205 138 228 122 33 1 184 62 152 240 252 102 112 255 15 181 1 90 176 194 59 190 178 126 196 4 121 49 37 53 126 26 7 233 77 215 60 52 77 65 76 232 85 243 193 223 124 140 124 253 210 162 66 18 192 241 213 179 76 71 158 216 40 71 46 69 104 221 13 182 30 92 162 199 71 27 103 87 38 63 2 96 183 180 5 35 230 28 235 1 55 23 177 26 238 238 186 164 121 205 160 158 17 121 208 149 151 36 227 25 168 218 112 115 233 44 250 123 145 194 108 10 184 84 144 75 228 244 159 253 67 112 190 63 120 113 242 34 152 23 21 229 73 173 197 194 173 245 162 199 55 45 96 80 238 55 177 1 12 209 44 41 108 181 187 131 132 251 25 131 116 146 227 46 63 202 156 19 89 135 161 248 170 196 211 33 184 234 70 12 19 117 132 191 127 61 10 147 158 60 126 180 55 68 18 220 192 47 63 245 174 46 138 46 71 136 245 234 80 146 66 181 124 105 103 176 198 63 251 158 248 108 40 103 115 233 133 249 249 200 155 179 217 219 252 180 193 165 16 19 69 104 6 16 160 67 104 41 102 150 66 0 151 170 145 161 115 81 100 184 27 189 139 193 249 67 194 132 44 164 155 155 10 126 101 192 37 167 73 94 219 14 41 75 213 203 153 101 74 243 41 226 119 2 105 16 225 214 188 244 49 224 189 251 172 103 127 252 146 67 197 224 143 145 248 254 105 192 215 131 10 8 35 203 250 74 59 153 2 158 253 108 100 167 234 154 101 41 135 195 137 240 163 225 249 218 156 198 69 231 240 76 83 98 233 95 150 209 58 99 55 127 142 248 92 148 159 214 12 152 117 67 89 105 214 186 249 88 241 57 102 91 58 35 68 173 127 26 75 229 181 64 5 144 5 30 168 240 110 178 115 133 40 51 90 183 166 234 5 2 45 159 47 91 146 95 27 79 178 109 27 183 62 249 231 2 60 225 185 207 56 38 152 216 167 23 39 76 115 135 85 13 133 72 84 71 93 39 229 28 130 195 211 137 185 6 89 74 2 78 142 137 122 216 61 2 148 118 32 229 31 60 40 46 249 28 17 127 240 243 79 229 13 1 96 124 197 181 185 41 225 85 177 92 245 232 91 114 142 184 166 59 84 80 226 144 81 103 189 18 208 187 39 35 67 3 92 229 171 161 181 93 46 190 133 17 9 37 6 18 165 253 244 78 171 101 185 154 224 249 220 23 218 177 181 1 162 199 12 159 144 196 0 145 242 129 64 172 31 60 0 111 236 106 143 140 240 23 147 7 180 246 197 128 162 93 69 124 179 32 188 75 188 45 158 218 165 195 185 111 116 108 26 214 250 252 127 64 171 215 67 175 252 181 165 161 194 195 81 96 239 94 153 180 210 196 254 225 159 214 162 179 167 24 23 242 87 68 105 196 95 252 190 131 209 157 163 226 249 141 126 117 65 74 193 223 128 64 187 86 82 15 217 6 133 187 83 164 208 104 217 222 201 31 161 146 73 2 63 89 2 186 75 34 130 173 107 168 156 140 143 128 98 219 14 14 149 146 136 152 49 229 31 107 115 148 224 44 210 204 127 149 162 41 48 203 87 30 151 56 178 19 71 227 24 142 217 26 175 26 247 34 35 163 6 24 25 116 248 59 102 24 120 164 84 58 98 159 140 122 184 216 9 166 177 48 155 148 224 172 239 33 84 163 29 66 80 128 150 189 147 178 102 133 87 121 231 21 211 0 120 42 157 55 221 85 152 212 134 109 86 207 56 137 210 202 207 30 166 92 122 180 66 162 26 168 43 150 78 5 255 228 122 178 170 149 208 120 82 44 151 208 3 53 224 151 122 49 115 247 180 194 11 85 162 66 235 179 87 106 85 121 55 4 89 243 199 147 118 156 230 5 131 22 103 42 131 169 216 144 81 255 107 63 173 102 154 44 196 201 109 44 31 96 96 227 180 224 252 245 57 188 209 138 67 194 114 250 77 244 124 227 77 149 53 246 208 200 12 183 7 187 42 185 110 24 132 100 56 23 33 254 32 86 61 196 193 160 187 221 163 249 12 156 102 150 158 172 185 173 55 159 37 57 105 144 133 192 140 179 17 215 181 195 120 133 207 160 169 41 48 33 62 109 229 103 176 117 108 176 4 116 25 72 76 167 45 152 55 253 188 174 162 7 147 77 218 123 130 104 179 117 137 200 91 29 246 145 149 21 80 98 209 178 195 140 194 244 127 238 244 99 117 72 52 16 247 199 228 12 98 91 146 27 169 23 237 117 163 245 141 214 8 64 145 178 82 33 7 119 148 2 136 43 111 117 62 181 163 57 135 58 125 56 109 244 207 2 28 197 188 189 160 131 130 64 83 236 2 62 2 229 221 48 77 180 167 80 115 146 239 62 14 160 99 109 93 157 179 131 179 244 65 46 76 99 237 60 67 147 156 6 103 18 215 116 171 170 162 20 154 109 239 138 118 194 221 178 21 55 1 104 105 10 11 175 195 123 167 57 52 237 251 32 93 17 15 206 99 61 71 172 53 235 139 125 80 214 90 202 163 67 30 148 92 230 71 78 118 234 56 240 61 16 171 238 199 220 69 104 155 38 79 130 180 88 50 20 23 9 47 104 96 97 55 15 185 64 29 118 106 208 127 21 14 83 17 234 49 188 178 45 171 229 96 193 216 165 105 206 50 134 145 200 149 27 36 121 181 249 20 198 200 159 239 136 192 144 41 251 241 236 190 209 10 157 23 118 230 253 252 115 248 63 2 138 127 106 183 241 45 32 241 172 177 79 255 186 61 7 81 72 118 141 189 60 245 231 168 42 198 18 157 16 122 162 153 1 180 181 59 33 28 97 221 94 72 211 72 10 62 137 62 234 107 49 65 224 120 196 216 51 130 100 169 60 172 8 99 240 221 204 135 189 44 127 144 33 75 41 115 62 169 49 114 47 6 82 226 204 97 116 146 39 170 228 173 224 25 204 71 154 158 24 165 125 85 110 170 131 27 114 15 249 213 211 132 74 125 32 145 225 26 47 109 123 19 166 140 125 151 214 97 2 209 243 64 176 97 136 100 147 206 94 243 34 109 156 220 221 231 63 29 102 204 165 42 221 5 194 184 128 199 48 87 100 78 89 160 143 169 155 46 128 204 26 128 191 6 132 86 196 101 215 165 28 53 67 38 231 28 159 61 173 255 93 59 235 42 10 221 100 111 110 86 245 30 55 209 208 108 181 204 39 140 157 214 194 45 28 92 42 174 98 206 98 130 222 161 164 248 238 122 171 99 182 10 255 238 93 245 223 3 52 97 159 171 48 152 33 125 165 99 52 2 170 167 210 229 162 2 101 15 20 42 163 198 253 89 228 155 25 55 115 236 28 58 124 183 18 188 73 27 233 228 14 255 228 81 6 83 251 7 224 13 0 85 79 78 48 190 82 187 152 114 13 162 92 104 4 21 93 26 106 32 224 113 134 86 205 90 203 226 195 12 146 184 95 136 226 216 204 117 24 232 14 211 169 13 9 111 229 67 69 112 98 254 122 185 1 58 140 28 161 101 26 25 131 108 226 128 197 116 105 201 127 86 36 178 52 42 222 253 36 177 154 129 240 14 22 178 97 244 26 77 170 136 21 149 201 117 5 99 117 175 48 67 205 160 121 127 62 225 234 16 237 178 156 129 31 79 73 129 188 87 211 18 89 246 83 7 44 116 165 75 24 150 218 150 167 194 13 202 125 36 118 116 125 226 228 156 71 248 247 179 124 113 189 229 138 251 101 78 137 76 194 240 141 66 211 196 40 158 189 146 106 199 67 56 217 41 125 224 117 54 89 38 200 59 254 4 92 41 157 90 98 54 235 247 216 231 111 156 89 244 39 204 86 197 215 221 230 200 146 248 251 38 25 115 76 142 194 233 136 79 91 174 97 235 251 237 190 81 19 246 38 191 137 172 113 74 36 22 181 93 123 79 19 66 38 124 139 196 35 123 3 49 231 121 163 212 141 238 132 63 42 110 242 194 245 85 78 5 111 135 230 175 90 214 147 232 197 187 48 29 108 160 76 2 15 193 185 89 234 190 207 60 233 122 60 216 80 127 65 117 138 190 125 188 53 114 221 169 169 175 139 253 100 124 39 55 162 25 21 39 90 178 139 0 63 102 69 28 153 205 217 129 52 121 173 243 105 54 28 25 58 5 113 161 42 152 65 217 144 176 39 172 152 199 133 79 108 10 183 176 234 153 219 231 54 212 204 169 30 45 56 113 97 228 103 112 150 225 234 107 191 82 16 11 120 154 19 209 72 78 112 7 151 175 249 128 67 28 114 68 23 23 73 151 61 51 95 248 197 70 222 147 31 28 204 136 74 103 66 198 17 103 196 44 121 101 218 230 85 254 118 76 47 106 18 141 66 73 64 204 59 170 31 109 97 79 122 11 246 189 62 203 179 49 14 222 151 66 103 170 121 8 193 65 158 8 222 25 177 230 170 46 123 0 240 79 74 129 77 227 60 183 233 108 184 81 134 154 107 10 140 193 197 98 203 28 29 16 54 189 224 14 33 27 112 87 79 171 205 170 96 172 100 229 135 84 102 114 83 36 99 229 196 4 211 66 150 109 93 152 104 113 2 140 248 150 61 67 117 229 126 146 202 7 117 186 134 224 252 223 109 159 170 39 57 253 39 113 74 21 81 129 145 162 22 45 100 12 146 121 207 107 197 4 50 73 165 37 158 67 54 186 24 203 235 0 40 24 187 184 155 108 205 197 15 106 117 15 137 58 212 81 248 167 144 112 99 59 40 36 202 204 192 200 50 164 17 62 124 27 196 229 130 16 49 140 209 69 76 19 176 20 140 211 233 226 206 91 223 227 107 227 73 62 21 102 138 187 15 239 174 118 198 57 223 122 10 0 13 165 207 78 10 245 188 149 138 81 188 231 178 68 207 206 241 15 51 89 173 40 158 72 212 83 172 46 19 224 183 145 135 58 68 181 184 210 8 50 171 109 229 32 118 2 15 42 22 187 126 196 213 158 26 146 117 142 34 63 62 21 150 88 75 149 107 202 188 226 169 60 224 126 84 46 234 211 56 249 64 46 156 212 136 199 147 231 70 245 128 64 220 78 88 207 181 152 129 4 54 141 208 148 230 223 198 117 182 34 206 102 254 36 196 241 18 175 25 75 211 251 53 91 123 111 143 53 225 141 168 183 165 28 211 93 105 26 84 91 116 233 65 56 185 50 206 205 166 47 128 139 238 157 250 35 255 251 48 93 53 218 170 33 158 45 184 110 211 40 113 123 155 107 74 201 174 51 185 250 100 210 132 124 53 233 24 94 14 50 22 2 77 255 247 109 4 116 181 161 34 30 143 141 105 235 91 12 203 238 117 140 42 56 21 163 156 60 194 216 200 183 250 213 167 26 228 166 176 200 169 227 97 90 181 99 232 199 26 236 62 112 185 180 14 184 45 88 156 177 136 192 119 93 6 36 166 137 250 29 121 146 149 92 213 44 147 121 148 144 165 165 165 165 1 0 0 62 0 0 172 94 90 110 181 189 233 4 0 0 44 147 0 0 88 244 0 0 0 0 0 14 144 195 0 0 63 8 0 0 11 75 0 0 0 0 15 0 83 113 117 101 97 107 54 56 75 46 112 114 111 106 0 1 128 103 77 77 80 82 67 87 73 69 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 42 61 0 0 8 218 0 0 0 0 15 0 66 193 212 177 152 127 146 222 243 33 86 175 90 50 8 89 67 135 128 225 194 42 53 134 152 55 133 135 136 33 183 123 78 193 40 238 152 168 15 204 239 102 162 158 6 156 250 77 207 43 183 245 111 54 191 184 72 149 77 216 236 28 126 201 139 146 140 60 40 22 254 107 14 40 203 212 179 210 156 10 32 101 162 109 194 3 175 101 30 68 133 193 245 158 199 213 48 40 77 75 182 102 20 200 76 171 41 85 90 28 195 241 227 138 213 210 231 76 108 143 94 126 146 87 228 76 92 219 141 226 26 149 49 51 75 122 29 248 81 141 15 101 129 226 235 41 238 225 254 50 182 118 214 108 141 213 194 250 221 240 143 29 98 96 34 96 126 242 134 235 130 129 197 224 170 99 40 143 112 16 150 28 143 113 233 183 246 235 24 94 179 6 87 113 220 237 151 176 117 16 50 104 4 17 8 251 147 101 118 139 101 78 112 156 120 128 11 193 221 238 176 136 140 62 123 253 189 157 46 29 74 72 192 125 5 33 157 151 16 69 163 253 22 36 229 89 3 177 189 69 171 184 142 176 223 0 8 95 54 204 207 232 94 178 238 144 197 145 68 124 94 169 156 253 183 238 218 248 130 184 32 198 49 252 34 84 167 35 91 75 65 234 64 96 137 115 34 10 176 173 241 81 73 2 44 226 125 210 101 50 100 79 190 59 120 199 191 235 17 217 87 36 149 137 45 143 80 123 57 222 227 99 81 39 195 90 122 25 127 82 182 6 198 117 145 130 60 43 103 149 121 100 117 94 248 101 252 57 161 87 0 112 136 229 152 38 17 198 49 54 118 31 35 76 196 172 190 214 43 123 55 116 167 84 234 205 166 125 40 174 165 226 133 68 114 115 116 69 32 211 51 32 184 162 213 152 251 166 125 76 186 37 79 237 24 20 62 87 247 251 186 86 75 101 198 115 144 220 87 133 219 44 37 7 7 133 0 27 0 149 11 171 142 174 8 226 16 6 2 11 145 46 212 170 240 230 7 144 105 200 205 152 218 122 35 36 112 140 20 71 26 70 85 227 27 22 195 72 116 136 138 199 101 204 32 151 165 161 47 165 102 39 210 157 241 68 181 184 105 15 231 185 208 0 31 117 121 35 115 240 105 223 24 59 102 31 33 80 106 210 26 231 77 235 147 39 13 241 52 38 78 12 30 119 90 40 143 125 205 99 240 192 109 52 205 13 132 4 236 89 18 72 63 195 202 52 219 135 189 13 110 98 210 49 176 97 233 41 74 20 187 71 236 241 197 3 104 107 173 16 140 110 159 110 158 118 48 183 20 239 64 144 235 123 223 212 152 65 193 180 186 186 43 146 117 241 107 246 92 80 50 85 20 5 25 154 139 66 164 8 189 211 92 143 58 225 3 82 140 144 166 158 35 245 180 152 113 223 26 215 130 214 140 75 192 149 247 36 210 197 67 104 143 78 14 61 165 55 88 90 88 238 10 190 72 52 140 19 207 88 168 149 189 164 196 114 19 157 117 215 51 82 117 41 196 203 179 1 24 101 130 173 10 15 102 208 75 46 143 165 48 141 198 64 97 26 223 57 43 184 164 56 166 234 45 127 189 28 82 130 44 27 164 214 98 2 249 194 164 139 170 59 212 77 234 193 224 56 209 178 251 156 135 70 224 233 152 50 59 177 129 133 87 224 189 41 7 221 29 101 170 129 82 228 178 215 37 239 224 7 187 245 193 105 24 255 116 236 174 115 114 213 89 220 234 166 6 17 150 235 125 81 140 79 25 136 99 57 88 124 107 240 225 86 65 255 206 61 98 241 114 156 76 212 251 29 72 77 251 62 25 90 209 180 231 8 222 148 128 161 88 222 126 246 64 222 5 105 86 219 0 182 64 27 171 178 255 3 183 155 166 104 206 167 72 201 18 127 80 205 16 153 28 94 159 1 227 244 220 88 103 67 228 110 120 248 244 145 6 159 68 198 227 3 243 182 160 99 51 59 114 151 188 130 207 76 137 203 221 24 94 112 71 99 123 21 0 250 76 158 46 166 214 109 238 24 58 240 5 7 167 41 25 43 112 93 190 130 174 10 139 159 255 219 94 141 165 23 150 175 248 82 115 18 152 218 202 57 93 129 94 119 132 79 243 230 25 124 201 35 76 172 80 206 141 36 132 255 122 173 145 197 248 79 82 105 5 244 123 202 89 123 7 243 250 21 122 39 115 13 154 195 142 189 58 90 133 17 173 170 162 78 125 13 96 150 156 190 104 196 100 234 208 131 68 153 92 113 150 196 163 87 128 156 33 125 167 230 235 214 67 7 215 29 165 246 255 193 129 234 84 88 124 205 99 49 30 169 21 6 128 235 89 5 208 231 193 177 81 239 215 222 189 150 244 129 163 253 133 175 33 193 230 244 249 86 209 137 44 121 45 8 22 25 116 104 46 215 34 137 76 242 86 162 164 80 11 203 208 160 255 190 255 111 81 137 231 249 74 155 112 98 146 214 189 215 81 245 154 19 213 220 36 238 244 63 132 155 161 215 195 134 103 45 182 253 10 250 159 142 234 222 196 122 57 173 222 213 104 44 148 108 170 0 120 223 174 13 237 85 171 148 11 95 22 153 87 154 29 134 208 212 122 206 170 81 202 59 41 220 148 28 74 178 49 236 89 74 103 26 125 200 155 200 197 162 199 117 186 119 122 20 178 231 157 219 220 180 174 181 181 85 216 153 26 63 237 2 64 239 13 80 90 154 204 119 177 101 68 98 168 78 81 180 60 126 103 203 126 61 125 71 38 7 143 21 104 208 125 242 10 7 48 189 195 174 0 235 218 29 3 108 39 4 52 93 159 149 239 128 130 205 234 161 178 211 187 124 146 108 7 138 186 131 180 116 8 100 125 110 109 245 253 153 242 95 147 21 227 201 232 20 247 29 119 7 99 150 205 97 246 58 166 247 134 21 129 83 119 254 220 34 88 67 196 98 116 30 20 236 64 80 153 27 60 53 122 89 187 139 182 220 54 187 52 135 18 232 217 255 248 124 105 123 115 29 67 50 190 11 23 49 56 146 91 253 221 174 25 241 243 244 96 83 92 203 4 219 30 210 212 236 227 89 52 5 63 255 40 162 204 122 160 135 136 247 161 241 186 81 193 159 106 102 17 35 137 196 232 23 150 138 186 236 77 150 59 57 251 174 184 171 91 153 213 134 243 25 161 183 171 28 111 195 9 76 75 198 132 252 169 74 130 252 39 178 214 152 154 147 5 72 192 40 72 56 53 88 221 120 36 204 226 208 44 157 233 241 248 31 79 149 210 73 64 132 130 29 75 47 7 177 71 72 119 25 236 206 124 116 59 152 212 149 145 215 135 199 117 234 152 19 101 160 235 206 109 122 38 21 58 65 19 142 103 203 0 166 67 222 220 226 38 219 166 1 107 124 144 25 236 188 254 220 129 209 142 215 148 17 184 168 200 241 68 107 90 165 195 254 138 131 186 15 48 74 167 26 176 204 10 60 182 69 249 142 156 66 57 235 179 143 132 238 180 76 163 208 65 208 249 112 207 57 253 43 39 50 21 62 211 8 92 102 87 86 117 47 32 193 68 165 94 27 245 80 56 130 152 255 131 236 59 170 80 224 159 58 78 41 201 194 7 165 58 5 62 145 192 59 40 73 136 138 57 255 197 245 236 101 6 36 222 237 53 44 177 4 177 137 50 119 106 15 210 83 40 77 212 42 35 26 204 239 144 110 240 154 70 177 84 171 66 233 8 16 223 97 255 153 145 96 248 164 29 31 88 174 128 129 40 228 40 208 231 253 198 163 29 196 27 77 98 228 244 111 90 24 177 159 86 233 129 23 241 62 49 69 145 31 38 139 102 248 177 233 127 222 42 53 8 17 143 81 154 240 3 7 89 101 214 127 174 121 126 236 58 13 176 148 163 94 96 7 165 36 80 36 49 135 8 0 37 30 45 60 120 65 62 221 220 140 203 3 62 188 4 95 220 235 91 54 192 247 193 32 137 162 63 59 114 102 233 64 133 52 140 242 198 68 218 84 164 220 213 71 225 196 213 50 251 167 124 129 57 176 212 232 228 184 129 21 221 118 64 91 245 77 9 131 231 143 209 65 138 133 128 32 8 49 108 224 119 209 252 33 33 53 222 36 23 66 153 92 162 80 145 127 40 160 232 96 212 132 211 50 78 10 103 22 141 177 247 90 188 1 63 220 121 149 112 128 219 193 149 209 2 238 45 77 187 230 147 51 64 206 153 17 13 51 50 24 34 102 232 133 178 238 123 69 66 92 133 157 68 73 122 129 11 173 97 212 249 193 71 8 180 78 185 22 76 160 236 33 234 141 95 35 37 103 31 123 50 133 85 160 164 12 123 114 194 113 49 168 68 191 8 31 126 125 83 171 78 191 29 237 204 43 154 39 194 229 132 20 144 227 53 193 186 145 195 193 173 222 57 30 68 138 15 226 239 45 87 216 236 85 54 149 210 171 78 154 47 102 246 14 108 108 93 49 15 21 159 18 149 1 20 36 234 70 60 184 192 8 254 219 135 240 23 169 74 86 146 166 91 82 127 178 20 146 162 134 195 206 47 196 50 40 166 202 186 220 95 16 143 151 27 14 31 254 208 146 199 142 249 131 36 222 25 6 220 39 89 131 191 10 208 29 57 182 88 228 2 64 85 69 156 249 222 215 148 156 167 207 154 189 202 248 6 31 225 99 59 18 6 103 27 184 80 175 52 68 1 65 230 59 49 82 74 183 240 96 108 154 35 67 123 67 87 55 236 245 95 255 203 248 184 160 39 53 2 179 194 21 39 67 189 8 195 228 150 185 176 149 79 118 238 214 78 39 106 8 93 180 126 12 198 74 165 7 170 53 14 110 168 151 171 238 100 83 71 182 153 48 222 223 120 131 28 10 33 182 176 202 235 135 30 109 192 208 92 66 7 40 79 208 209 207 100 81 222 163 136 198 146 97 124 230 40 130 156 229 190 77 103 239 86 163 64 147 97 121 96 65 238 168 241 89 151 237 29 10 93 169 197 251 184 45 107 225 147 65 11 112 57 190 236 149 79 200 159 182 185 165 245 192 66 193 212 149 39 12 130 178 116 169 232 97 228 102 217 16 110 18 255 95 85 27 44 25 106 16 102 236 46 204 36 95 242 224 207 181 116 140 122 54 211 165 222 55 224 116 154 180 131 40 126 227 219 33 33 104 229 41 105 162 182 20 154 178 131 12 79 141 153 57 189 119 181 124 187 30 49 122 68 129 138 1 65 237 162 66 138 14 48 232 18 174 50 221 24 163 14 144 187 101 195 124 242 190 36 142 193 165 255 89 148 164 80 237 240 160 156 179 52 255 24 198 238 117 96 224 23 49 98 174 83 58 130 27 192 132 203 148 74 248 120 178 80 208 182 134 60 22 149 161 234 97 132 104 183 210 96 82 236 210 136 8 167 229 82 126 252 143 182 54 159 148 63 95 98 188 94 117 119 64 175 154 90 42 23 162 76 102 86 60 157 58 6 146 182 165 68 141 173 189 132 23 80 70 14 78 14 198 73 175 108 108 24 185 251 227 32 145 67 121 206 119 126 220 193 9 52 155 214 136 89 118 59 53 36 43 247 171 41 78 209 106 124 224 69 38 110 22 173 205 98 156 159 50 76 116 219 63 142 45 54 204 191 172 52 203 112 212 39 123 130 34 96 52 130 124 141 53 202 194 120 248 17 220 28 241 129 107 197 185 155 69 24 25 170 249 249 232 52 69 8 12 157 50 127 184 200 41 113 255 102 21 96 61 239 243 212 81 111 188 137 225 39 234 172 138 10 12 176 196 196 42 78 245 110 72 93 75 117 251 119 223 61 45 23 174 252 165 171 235 24 157 227 231 96 17 218 62 110 80 155 235 228 148 98 187 74 32 202 158 114 53 10 133 77 38 85 52 92 66 46 201 143 194 108 210 153 190 24 218 217 138 168 201 192 57 39 213 203 150 132 206 37 23 200 46 13 251 191 46 154 8 174 163 89 197 176 205 53 123 43 156 114 44 181 28 230 242 97 147 56 235 32 254 149 77 147 125 1 99 122 66 237 145 94 143 155 77 131 213 16 135 32 203 157 159 53 206 88 126 70 148 51 55 28 146 89 30 178 93 29 227 110 234 177 71 101 20 1 76 243 62 85 229 141 154 136 51 218 178 28 203 149 22 23 230 67 194 228 181 220 5 158 6 4 128 163 60 61 23 170 97 78 223 70 147 112 156 117 160 94 207 27 84 71 231 224 129 164 170 222 38 17 149 164 244 59 22 236 252 165 246 181 242 254 96 144 252 70 135 181 251 233 84 103 92 24 201 75 70 92 153 180 230 127 140 89 70 76 132 148 149 42 25 178 199 105 233 224 106 130 138 144 209 159 100 178 18 217 79 11 30 224 74 56 223 253 65 36 248 194 230 40 183 2 4 105 183 43 130 249 103 188 6 109 150 133 199 5 179 84 10 74 87 167 28 95 206 233 246 2 193 184 103 140 208 89 242 108 0 90 253 25 95 161 37 123 128 72 1 13 188 209 141 10 136 213 239 207 161 79 181 129 165 182 43 143 189 246 77 160 254 231 229 112 47 253 205 204 254 63 199 185 155 41 2 111 122 121 76 14 120 124 130 126 143 28 183 135 248 66 71 59 65 255 94 243 150 24 184 206 242 121 151 158 105 192 167 188 227 128 117 109 47 153 103 230 21 175 131 153 59 157 215 90 249 36 27 192 186 190 219 27 95 111 223 40 219 72 5 45 243 180 62 169 216 232 54 220 115 116 249 139 19 131 198 64 231 34 27 195 76 20 189 58 3 22 126 180 44 221 101 39 101 187 139 21 26 181 174 143 132 87 100 161 192 31 94 194 220 170 185 231 193 33 251 147 251 15 99 90 109 187 211 80 144 86 179 152 211 127 151 20 99 155 138 141 47 251 130 223 20 60 113 184 101 88 201 52 79 173 175 241 48 8 109 4 16 241 212 136 105 221 135 196 233 175 100 31 119 220 66 216 20 128 159 218 233 11 156 154 232 124 160 103 138 12 65 215 98 62 208 111 215 53 9 161 186 187 100 4 47 57 159 230 102 88 230 7 247 176 208 116 163 101 182 46 51 40 188 212 163 140 1 138 149 213 139 88 91 199 130 143 140 44 157 197 120 223 229 45 141 52 178 54 239 251 205 84 17 89 219 190 162 247 28 171 64 106 10 184 122 175 113 76 167 68 62 84 136 167 156 25 22 113 14 109 106 116 156 40 216 184 146 113 222 82 195 78 237 184 1 182 51 177 170 206 204 233 133 55 249 174 115 231 202 148 218 170 139 53 248 18 165 97 125 83 106 29 88 66 1 87 102 44 223 137 172 190 1 16 142 35 91 118 76 247 164 80 74 23 171 251 96 151 154 212 17 3 0 241 184 31 216 5 81 150 136 28 234 100 157 102 198 76 42 253 169 160 128 67 76 111 221 145 240 63 189 242 225 181 194 28 9 232 226 113 26 148 140 164 148 21 205 69 119 108 29 62 53 21 63 177 240 109 103 46 53 215 116 84 156 149 52 187 0 166 55 7 100 181 58 21 58 139 21 123 44 41 182 225 76 221 128 173 224 52 143 79 181 211 28 177 12 118 117 219 88 222 94 142 71 240 96 203 50 47 182 157 96 38 143 12 222 123 234 241 118 177 196 212 106 78 27 156 194 179 247 162 98 123 246 46 113 170 135 163 241 45 195 152 1 219 181 68 7 93 178 114 77 227 58 21 139 19 39 30 233 131 96 231 122 98 99 68 14 97 5 244 129 37 190 93 115 238 199 193 104 221 239 185 196 181 5 138 228 253 103 198 89 158 178 37 133 66 40 225 31 37 202 90 111 71 185 102 243 26 215 254 199 186 212 125 107 204 76 31 108 176 151 154 93 241 171 243 207 250 209 109 204 51 12 123 54 195 74 16 230 254 71 174 150 80 225 16 87 4 190 249 22 83 85 71 71 129 148 163 195 207 199 202 123 73 180 202 134 151 250 159 224 103 20 233 1 210 222 207 242 221 38 139 118 83 133 2 236 77 195 234 4 151 195 196 108 108 245 167 176 142 176 177 93 79 1 123 201 21 230 189 34 198 212 199 19 205 211 48 109 208 42 124 129 90 161 133 19 206 6 29 229 103 145 144 226 247 99 75 179 148 182 184 162 49 109 43 25 143 31 217 246 10 109 202 137 117 21 233 230 209 176 120 53 12 161 95 113 1 123 106 219 88 95 30 215 248 120 8 91 177 182 117 112 13 158 186 121 176 168 156 132 242 137 221 201 19 56 115 84 129 149 220 184 0 125 40 117 98 42 161 7 46 22 139 185 33 78 175 13 0 163 119 133 123 164 7 73 236 56 78 95 234 52 187 0 166 91 190 245 40 246 251 255 154 215 237 170 114 201 181 151 249 4 12 137 183 88 211 208 153 129 59 143 120 9 155 137 138 232 174 122 158 5 230 26 57 22 105 9 191 145 67 31 56 237 243 117 49 132 160 155 48 105 147 117 247 182 187 221 233 253 199 119 28 120 27 15 1 234 49 251 229 125 46 250 216 83 253 255 115 247 114 195 121 25 215 66 91 43 214 21 214 178 63 125 103 27 27 92 140 226 140 100 227 56 76 110 112 20 64 58 84 126 140 217 107 108 54 85 181 194 228 227 163 226 29 179 232 150 105 128 254 158 9 18 222 176 120 159 67 144 16 112 90 119 209 235 109 220 117 184 61 202 45 217 113 32 157 162 170 119 255 100 96 42 134 33 127 137 193 88 70 150 124 234 189 240 142 224 195 106 22 29 176 135 231 163 183 137 218 4 122 196 189 204 95 123 48 16 45 24 174 86 228 158 139 230 25 124 199 131 65 156 164 153 133 119 114 68 98 150 88 135 199 14 222 148 208 164 56 45 41 20 47 89 159 218 11 245 66 122 128 226 134 78 1 183 134 158 216 248 156 73 204 210 24 180 255 123 242 62 11 218 242 89 0 231 47 12 35 116 68 89 208 242 64 39 106 170 245 19 94 138 182 204 168 126 134 41 98 194 243 120 82 121 27 134 88 124 67 175 57 142 176 153 149 132 228 37 54 250 244 21 103 237 219 140 199 191 116 220 128 169 124 141 162 38 185 231 190 8 127 137 243 176 33 67 173 249 128 228 57 134 57 221 1 133 14 249 99 233 117 244 137 97 127 42 146 20 183 175 57 37 25 175 138 201 228 185 211 189 233 249 63 202 80 206 163 125 214 30 233 188 114 61 158 2 124 84 0 183 245 232 86 106 179 84 255 12 85 143 161 127 203 138 104 241 56 183 192 251 220 189 194 157 122 55 220 116 45 88 120 59 189 26 220 242 212 35 211 103 157 183 151 140 20 198 116 93 156 82 2 120 12 210 175 238 91 189 132 119 1 193 36 46 56 131 174 175 169 142 152 24 54 95 89 131 212 211 87 255 200 144 141 70 82 201 244 216 216 11 239 176 200 64 118 102 89 121 128 169 245 185 70 243 253 137 225 95 94 134 229 248 189 124 52 42 30 146 83 176 76 82 95 134 123 218 111 248 226 3 81 200 238 248 151 231 255 102 0 215 33 201 128 45 27 157 217 158 67 100 203 10 43 109 212 251 191 61 33 103 148 55 153 248 116 122 221 7 171 238 89 233 110 71 80 247 212 248 160 242 95 104 103 42 141 174 17 147 213 67 31 36 70 219 94 101 213 186 194 24 235 49 113 195 13 216 170 102 85 134 16 84 139 120 139 6 52 42 151 75 113 127 100 85 113 219 240 190 190 215 164 166 5 12 182 101 182 163 131 107 94 15 174 58 95 243 204 102 150 166 40 234 215 255 205 152 44 106 27 45 195 67 239 123 188 214 118 87 23 183 143 228 149 218 42 74 206 131 110 13 25 129 178 132 41 63 165 133 86 85 93 184 35 241 189 187 235 159 201 131 101 168 43 237 99 58 232 185 26 217 241 18 75 177 147 79 139 83 131 168 129 189 163 100 174 158 60 240 21 15 142 173 106 195 229 68 137 255 141 134 27 114 100 186 54 62 246 219 90 181 121 59 169 236 112 78 114 14 180 27 172 118 185 175 28 177 29 247 107 5 117 101 133 84 225 208 147 123 215 21 201 252 91 134 25 114 190 112 139 190 2 184 200 139 146 4 237 209 235 16 248 6 96 251 244 183 210 34 107 250 170 56 121 64 15 65 123 159 8 255 6 44 188 17 8 12 222 32 181 58 22 175 114 66 69 230 94 158 197 223 246 164 54 164 185 130 25 226 133 93 159 112 220 119 170 42 27 250 252 172 18 214 13 95 208 102 17 162 9 11 148 178 227 139 109 164 205 81 152 103 189 97 37 86 81 102 139 97 96 177 137 96 205 110 2 3 53 97 70 130 137 218 96 149 122 214 109 125 198 118 128 70 155 154 211 233 40 100 36 235 74 199 249 211 136 19 206 75 129 45 4 36 156 97 248 7 29 117 9 193 200 228 198 40 249 137 247 160 237 101 135 175 148 231 95 205 14 179 173 96 150 247 48 239 7 123 177 103 150 1 188 131 247 94 68 68 197 30 190 121 158 118 25 31 114 145 154 210 20 55 53 112 28 122 90 97 158 142 153 47 236 85 92 111 173 32 124 213 241 246 95 36 106 29 21 246 228 238 200 208 49 132 243 218 240 241 142 3 16 123 177 102 29 212 114 65 217 39 169 36 30 149 221 17 239 171 204 48 138 214 168 247 4 49 109 199 42 26 203 157 11 200 226 252 87 58 40 125 246 209 55 19 86 169 152 171 118 132 203 108 147 162 30 112 144 121 108 119 230 92 42 44 186 247 146 229 56 108 30 118 227 229 159 183 235 163 102 179 198 48 181 180 174 130 90 82 82 111 89 224 234 123 103 120 64 17 199 103 237 5 122 171 103 221 118 194 133 219 105 40 89 39 89 24 181 150 167 10 187 97 27 134 123 48 70 154 23 200 12 196 245 220 32 99 145 93 6 117 103 5 127 188 25 121 184 11 143 5 161 83 34 163 19 254 127 169 231 142 95 250 183 29 57 26 57 48 108 65 153 7 120 129 181 140 206 126 104 231 241 87 249 19 10 80 33 201 242 144 183 181 14 216 126 25 23 35 128 17 189 227 64 253 50 222 124 209 7 120 181 240 130 74 228 204 29 179 180 0 119 233 226 75 163 110 142 16 88 24 45 13 1 33 68 229 42 208 26 145 130 240 59 198 106 219 232 118 217 182 154 115 171 85 216 86 130 123 236 230 210 74 163 239 215 248 215 44 113 201 106 184 173 32 100 26 253 35 43 171 165 163 35 108 166 172 30 61 43 92 222 107 130 77 220 219 95 60 42 3 211 206 107 72 174 194 18 2 175 133 115 46 236 45 182 157 201 64 199 21 16 153 248 38 96 233 91 124 198 170 184 231 30 26 190 15 51 217 198 105 237 27 53 88 59 216 65 83 57 43 55 165 164 50 55 252 87 117 68 231 89 237 197 142 20 234 166 99 126 118 98 131 240 251 12 77 120 45 111 238 213 160 237 88 70 207 51 188 228 77 60 29 0 165 165 165 165 1 0 0 68 0 0 172 94 103 33 181 189 233 50 0 0 68 95 0 0 0 0 0 0 0 0 0 20 106 241 0 0 70 124 0 0 12 120 0 0 0 0 15 0 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 112 114 111 106 0 1 103 111 77 77 80 82 67 87 73 69 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 43 99 0 0 9 203 0 0 0 0 15 0 66 193 213 34 167 232 170 96 73 254 125 109 219 131 194 97 162 154 217 163 104 180 221 226 255 201 58 46 180 119 133 29 41 107 72 18 142 65 144 87 147 1 39 99 55 162 244 45 254 153 74 216 143 148 119 123 172 87 50 210 254 209 91 223 139 49 190 203 199 82 157 242 107 205 31 5 107 123 240 228 163 127 238 186 34 138 48 173 91 0 138 88 40 69 244 109 205 61 223 123 106 111 48 19 174 211 244 72 159 121 122 244 47 77 114 147 244 232 186 141 89 120 165 27 157 189 213 163 177 109 122 53 14 4 143 0 226 142 45 215 106 198 39 255 121 224 62 239 49 66 81 120 2 154 195 130 239 203 69 135 165 81 196 142 113 134 236 145 227 169 209 161 178 77 51 146 50 76 39 107 53 141 51 102 165 91 136 34 115 63 159 85 207 49 61 220 63 103 19 7 197 31 105 54 186 248 3 112 205 59 182 17 41 40 46 222 114 56 237 250 178 35 7 118 6 132 212 13 143 61 140 237 215 51 154 254 215 11 35 13 237 223 241 199 18 182 147 7 161 137 166 103 144 134 133 191 129 110 127 26 141 240 44 248 171 112 157 222 106 132 205 212 150 183 225 129 55 129 203 51 135 235 195 117 221 239 217 0 63 172 204 41 115 78 238 189 133 241 136 54 241 174 13 49 210 91 65 75 1 174 150 134 120 81 191 237 169 218 148 109 154 172 134 175 244 215 229 77 26 80 28 228 34 88 252 74 226 184 178 246 180 172 102 52 183 134 106 130 186 52 170 104 60 0 109 125 5 109 253 205 128 137 19 147 24 15 171 163 236 209 162 158 217 94 115 93 92 202 200 194 91 21 90 240 214 232 216 200 110 105 87 97 128 116 83 91 94 53 244 193 107 15 31 74 174 90 171 179 27 52 100 42 158 116 191 219 55 75 114 84 51 93 16 66 9 96 220 87 49 182 2 50 126 211 199 36 246 57 173 205 213 198 131 196 26 143 9 139 113 57 158 84 0 118 109 128 47 163 38 163 70 243 231 68 232 177 89 4 1 89 137 106 189 105 184 131 163 139 192 241 176 102 233 215 209 213 68 50 233 17 108 168 45 79 76 175 179 139 153 183 201 128 223 112 115 36 70 38 152 52 116 11 87 89 221 89 83 203 114 38 253 89 106 82 224 100 188 214 121 12 112 144 3 210 133 26 20 30 53 27 236 51 189 130 186 97 69 104 237 98 10 179 174 217 146 163 4 1 128 145 232 124 231 133 88 252 198 207 148 15 220 71 62 15 183 180 222 252 217 30 253 89 18 24 176 190 127 91 215 250 42 169 82 56 103 63 33 13 170 113 121 200 25 172 4 189 115 20 114 103 4 241 119 131 34 67 206 223 89 122 57 30 66 216 244 246 227 108 116 147 68 204 143 188 135 99 191 239 212 65 180 156 67 156 49 92 218 4 157 87 136 79 221 3 174 8 109 140 177 168 42 239 108 41 238 206 99 29 157 16 99 187 106 44 186 128 54 106 115 141 105 95 26 217 128 228 12 235 19 45 35 123 90 191 62 50 49 74 82 136 130 234 221 125 222 109 143 72 23 25 79 191 47 14 176 213 224 27 99 111 172 27 87 60 204 188 25 216 92 127 6 231 119 88 45 108 98 176 138 191 126 77 200 176 5 113 149 100 182 17 111 130 136 141 34 202 183 125 78 60 61 137 235 70 26 24 104 36 78 196 227 167 47 35 212 111 90 180 20 29 58 183 149 1 255 72 181 35 14 186 111 17 144 209 87 99 234 86 175 34 26 135 128 117 215 250 52 9 244 42 26 33 214 55 46 217 189 252 58 99 217 117 3 168 225 245 154 182 205 197 61 207 194 63 206 76 175 225 68 39 110 139 236 196 190 132 34 87 166 50 61 136 156 197 230 243 69 234 22 128 36 0 236 152 51 63 207 7 12 227 23 220 175 38 62 168 7 108 150 148 202 248 208 186 58 106 161 120 196 116 52 196 122 108 105 212 82 255 23 109 137 167 255 169 215 183 253 38 105 200 85 148 191 211 3 212 161 26 118 212 67 90 147 228 199 46 203 210 0 181 127 217 174 36 158 29 156 120 4 206 100 172 79 49 197 143 46 28 166 48 191 207 3 0 135 42 202 62 3 62 90 131 248 229 115 4 186 92 153 159 47 54 150 206 252 130 109 90 61 87 44 80 242 181 135 99 98 52 150 207 87 217 29 13 182 162 107 94 248 102 145 55 2 26 126 20 119 76 77 253 151 94 166 73 105 103 164 107 21 47 215 54 250 219 155 125 224 198 182 247 227 1 136 61 90 252 202 160 249 79 136 167 220 38 226 11 145 88 7 75 65 221 25 95 13 226 145 30 172 166 109 103 150 250 122 233 137 199 232 245 117 100 100 183 79 10 160 25 159 49 122 95 135 179 239 188 230 196 156 168 244 47 237 215 207 187 239 166 252 215 128 92 117 4 29 203 94 154 117 77 130 131 39 202 220 50 208 170 6 13 244 3 91 192 201 8 193 146 56 19 112 208 120 223 195 240 29 196 171 150 191 118 190 194 101 186 139 159 187 187 58 75 215 104 65 7 113 184 142 70 102 34 229 37 102 247 92 197 103 62 13 232 40 179 176 188 184 252 98 98 106 237 139 116 242 218 57 224 172 86 244 228 164 180 174 58 138 86 143 46 36 30 186 46 200 243 19 115 115 195 149 181 10 235 41 3 49 132 46 154 18 172 212 169 133 34 163 146 125 160 244 1 150 212 115 90 197 167 190 203 94 187 49 62 240 104 178 147 224 145 162 196 44 140 126 178 213 105 118 242 27 90 53 2 203 195 140 183 230 157 178 78 120 209 138 45 52 86 42 141 85 107 212 122 120 122 145 235 140 67 77 16 74 233 46 32 198 174 91 223 71 39 136 26 48 116 73 87 234 227 50 178 246 123 11 116 187 185 108 138 59 223 43 113 6 15 69 139 196 144 121 183 29 134 237 154 17 235 5 234 19 103 92 230 45 30 90 38 132 104 251 63 68 203 118 199 56 31 74 179 250 66 120 186 175 6 118 153 236 214 176 79 171 202 163 186 167 75 115 236 231 24 103 31 211 129 51 116 182 36 56 211 165 219 49 214 177 144 117 241 214 138 182 108 46 202 182 250 164 106 4 49 214 180 141 22 147 230 172 158 87 129 238 90 255 129 66 158 203 155 41 132 111 120 17 64 93 169 103 229 62 108 185 95 13 165 20 102 111 166 138 84 120 222 113 139 186 204 16 185 205 169 38 240 39 233 33 51 247 89 127 206 64 84 22 188 219 77 46 189 51 143 217 252 159 50 194 4 102 102 66 184 91 17 134 21 96 151 217 238 185 33 55 123 95 105 233 15 65 93 162 23 242 98 249 187 16 5 197 21 59 184 75 71 144 48 74 217 200 113 119 29 110 90 227 102 42 225 246 153 214 148 11 219 165 145 224 19 187 7 106 16 249 68 82 66 86 171 161 133 101 251 175 125 180 118 254 119 236 71 234 51 78 183 90 1 79 91 206 6 48 177 132 201 194 155 143 206 114 133 174 107 6 251 76 180 203 233 15 223 168 71 8 184 115 114 133 67 229 199 78 34 205 84 34 198 226 205 109 174 152 47 155 216 229 103 176 60 110 190 185 105 191 136 223 226 30 91 55 236 59 165 84 20 164 137 154 142 59 164 207 32 12 73 102 63 40 54 228 35 220 219 187 62 225 197 29 183 198 148 79 233 6 194 185 95 42 203 82 207 82 67 252 2 93 40 142 66 223 135 137 123 224 15 13 196 179 105 227 122 198 51 232 168 79 196 174 116 98 239 218 7 223 200 136 225 67 219 191 168 119 144 168 19 255 46 209 29 126 190 47 252 240 214 23 139 235 137 61 211 159 81 80 18 152 159 55 224 25 18 232 90 23 177 167 228 98 189 68 105 187 165 155 173 14 18 56 253 163 63 78 57 106 125 81 154 56 128 6 19 252 186 225 68 89 108 1 221 173 150 87 205 165 124 195 192 199 194 119 79 225 45 218 165 64 29 246 33 95 36 22 121 133 122 52 58 10 170 15 203 208 48 243 23 252 12 236 203 168 97 135 187 84 251 231 12 203 229 70 152 249 207 26 26 23 150 84 225 241 67 222 246 133 49 68 194 175 119 150 61 19 235 88 233 14 48 236 109 193 101 246 34 82 152 6 24 43 129 57 164 141 225 44 54 145 213 197 178 111 179 140 192 30 229 71 248 206 230 150 10 129 69 135 25 24 245 54 128 33 123 245 185 103 186 241 145 182 226 246 193 185 120 10 173 21 213 146 18 204 241 228 106 10 64 218 238 241 175 7 43 176 110 211 148 172 141 109 134 57 182 4 142 210 112 55 176 238 226 171 73 185 172 47 126 115 73 55 1 246 149 213 246 139 90 135 28 137 50 6 151 240 190 128 192 206 13 170 6 87 237 48 108 129 166 201 180 132 6 238 35 148 62 85 221 238 102 153 135 179 235 59 169 150 119 30 152 218 214 167 251 204 254 64 179 59 155 59 67 25 195 202 238 101 131 36 233 21 76 64 63 249 229 40 194 34 105 56 114 101 196 252 129 71 22 54 74 103 155 182 231 157 125 254 184 32 218 139 49 220 189 157 124 19 247 225 194 49 100 204 149 104 14 210 166 105 17 247 23 173 136 104 235 8 219 56 127 83 116 46 96 225 67 179 203 248 25 200 178 77 79 6 169 2 125 100 43 8 39 62 225 194 49 155 84 76 237 61 52 91 181 31 211 184 62 122 222 33 103 62 37 211 76 228 63 27 181 197 66 127 235 115 156 186 60 183 66 177 188 222 38 170 4 56 95 136 41 25 8 9 80 206 194 203 201 138 230 33 247 251 92 111 213 143 155 111 13 191 171 42 50 253 254 106 60 191 99 69 233 171 186 120 97 215 21 224 192 19 12 182 46 169 218 22 71 58 229 134 211 162 140 56 9 132 219 9 246 86 76 250 184 145 66 41 110 137 207 251 174 106 15 51 2 69 24 119 169 60 210 183 243 63 157 141 209 65 137 90 173 51 237 67 234 149 46 170 68 195 116 229 235 76 145 137 75 32 145 192 4 11 207 139 214 61 141 28 220 14 171 84 86 221 79 160 210 147 82 161 66 178 99 124 213 164 18 254 143 187 107 108 68 20 255 164 208 206 100 133 131 124 242 186 239 188 103 103 12 157 33 177 120 150 167 231 65 102 81 226 82 87 82 173 30 149 225 244 230 57 112 248 32 13 239 140 142 98 74 169 231 78 217 117 237 124 135 61 42 92 140 220 83 189 138 38 18 106 17 178 126 57 63 196 246 233 135 91 28 254 99 187 39 186 24 39 88 100 133 33 190 72 194 115 131 63 64 112 216 30 79 245 5 239 81 134 208 36 206 14 226 202 151 130 203 195 149 75 6 134 30 10 174 77 159 251 38 15 78 123 176 53 10 255 163 152 252 174 61 243 13 114 129 90 242 17 62 42 158 100 221 165 198 66 170 16 74 234 128 161 218 148 146 48 111 224 3 180 82 103 36 65 218 179 15 237 143 117 199 121 192 238 60 199 62 24 160 142 162 179 194 251 238 29 214 139 91 147 239 48 66 193 212 212 92 40 192 184 153 105 152 86 17 212 232 68 121 74 252 27 41 180 234 24 75 100 22 64 229 30 70 100 197 7 155 187 92 243 14 250 239 201 76 115 227 164 210 182 117 213 145 47 5 2 219 196 209 162 83 249 48 207 176 30 178 143 112 4 51 254 214 63 45 44 3 215 164 57 200 182 124 158 86 58 153 100 113 29 53 0 56 205 56 10 157 99 25 31 250 152 243 182 139 66 131 233 29 50 185 222 108 208 133 204 42 40 184 159 46 161 7 42 122 248 18 153 138 235 244 206 228 1 122 184 80 235 158 70 142 232 19 121 197 69 229 245 153 7 128 7 190 121 148 7 246 118 50 63 105 147 213 94 36 62 54 218 73 62 250 9 60 170 153 136 77 142 109 252 157 150 86 175 146 67 16 83 18 180 236 167 236 113 8 126 155 146 176 202 148 98 211 238 33 74 249 99 111 238 204 86 4 53 192 207 47 200 84 146 84 48 79 125 188 55 81 252 5 19 109 216 114 7 234 235 213 27 170 123 199 200 74 226 13 7 241 21 51 23 127 227 22 134 135 165 253 156 99 113 206 204 206 91 217 16 158 137 29 178 19 44 153 110 177 128 107 51 139 72 244 240 29 12 227 43 175 3 10 154 186 190 125 142 203 49 72 191 8 40 6 184 57 155 53 3 80 67 150 146 199 229 174 141 115 109 211 96 28 54 23 193 212 174 72 103 130 171 219 161 146 1 94 115 78 220 108 145 65 224 80 92 118 62 224 149 172 63 67 69 217 157 105 215 138 34 187 118 122 127 57 20 12 224 217 70 209 202 178 106 146 33 246 152 24 98 68 128 221 40 194 221 11 169 59 103 71 213 60 212 196 35 205 61 91 141 119 237 204 82 113 84 103 243 94 149 83 140 186 168 214 254 201 164 136 37 126 100 57 87 13 216 203 99 54 63 217 219 119 7 83 124 195 241 81 156 196 51 215 20 67 133 198 91 215 124 39 160 132 145 199 210 7 207 230 248 206 7 242 38 237 241 92 243 130 95 98 154 224 169 49 122 228 1 141 167 105 53 125 90 179 130 146 134 21 3 1 241 45 173 104 133 81 187 71 152 172 208 115 142 162 59 5 160 124 60 22 90 196 38 99 42 200 232 106 111 29 11 76 153 157 152 186 198 13 0 129 208 204 217 49 21 34 42 197 121 217 67 20 254 247 159 111 124 250 6 99 140 79 110 69 20 89 105 249 248 253 128 36 1 144 29 230 245 84 67 99 200 239 121 124 254 220 206 26 22 87 182 19 190 118 203 244 60 97 19 198 47 11 96 51 37 250 245 245 13 187 244 57 98 109 197 79 191 62 145 94 118 121 114 126 98 228 26 39 129 113 123 243 32 190 129 149 93 99 255 175 8 186 126 210 208 128 143 55 96 250 145 32 61 213 109 192 17 61 83 224 61 9 150 179 19 215 195 126 237 244 174 164 115 105 100 195 192 56 89 129 241 213 60 133 90 175 248 87 243 167 149 159 70 176 106 209 92 64 12 49 252 168 120 254 4 68 107 8 48 93 45 201 14 18 91 37 57 84 109 59 245 93 23 215 48 177 68 39 93 180 24 34 112 89 188 34 238 225 71 172 228 228 118 221 85 186 163 21 62 100 232 248 240 80 221 241 146 53 182 6 169 107 55 197 132 99 97 65 1 233 244 182 58 9 190 48 66 124 204 75 30 116 64 238 161 164 22 105 195 71 189 146 65 192 65 5 130 27 38 121 200 75 234 51 237 254 246 190 145 212 19 40 156 58 0 252 105 100 151 232 121 203 255 156 62 236 23 43 91 18 212 15 123 150 127 254 181 179 37 233 25 186 9 113 248 36 175 202 142 5 164 233 91 110 171 79 54 157 149 245 212 60 39 246 54 131 184 233 68 40 0 6 197 89 240 202 199 13 108 89 221 81 104 226 82 42 108 36 17 22 88 239 183 185 69 100 140 151 99 62 124 22 168 230 236 3 149 192 50 241 96 96 248 91 108 111 31 232 230 19 119 115 203 206 244 97 30 45 182 34 188 73 192 171 59 50 239 174 231 24 199 183 78 231 247 253 76 15 129 255 226 150 124 50 1 71 19 50 238 122 5 67 167 11 209 11 251 221 13 117 211 240 47 133 236 253 248 185 100 69 18 15 32 218 38 123 198 185 105 81 78 187 164 225 107 205 124 189 71 169 130 135 138 232 99 210 53 53 28 63 178 211 234 136 39 140 215 11 201 245 33 30 68 85 23 242 99 34 12 168 231 10 71 145 2 113 175 189 121 210 195 222 40 132 197 74 142 48 100 111 119 255 214 168 40 5 160 59 197 143 146 77 21 88 135 76 131 168 82 60 5 91 82 124 186 198 198 17 108 94 144 41 55 64 251 198 249 95 224 91 63 131 84 55 201 87 121 113 148 146 234 184 233 166 75 102 26 105 30 126 169 125 9 185 94 11 166 92 58 45 97 114 73 121 228 55 0 8 51 75 33 215 202 17 185 25 148 247 98 59 84 69 222 173 201 67 206 160 2 13 65 235 173 225 253 171 111 170 136 227 9 36 199 40 88 244 240 163 218 251 218 62 67 65 141 155 113 165 171 89 67 163 110 0 132 30 76 118 33 145 4 138 86 118 38 120 156 80 191 6 193 91 184 82 70 250 109 127 227 234 171 202 22 18 10 184 69 108 39 139 237 22 72 191 112 62 186 47 122 15 195 10 80 146 219 100 255 136 88 153 88 39 135 7 38 76 132 166 111 25 153 63 196 105 163 211 19 202 52 212 138 235 209 222 235 187 83 122 66 172 242 114 66 249 26 118 81 47 212 242 146 124 149 222 205 129 139 200 232 2 210 210 54 16 25 116 150 114 197 56 83 235 215 142 14 174 51 147 106 6 140 197 170 196 151 97 235 148 13 255 4 5 137 88 32 104 57 35 188 106 230 144 205 245 151 176 27 203 230 252 123 58 130 131 172 157 55 144 71 136 214 115 9 128 158 236 43 173 241 208 93 75 131 128 53 207 117 110 225 28 154 130 182 84 200 55 32 240 161 232 204 248 246 187 145 26 59 78 92 22 67 221 228 70 227 182 228 171 192 77 175 160 216 234 19 30 58 118 39 95 134 205 51 143 203 25 108 218 182 10 180 80 178 152 90 100 101 115 168 132 223 13 27 23 61 62 35 57 156 105 169 185 146 76 5 147 33 110 111 75 26 52 203 115 235 89 36 71 138 164 103 174 251 152 15 125 145 15 87 238 226 212 96 70 46 205 181 245 85 9 205 160 3 143 204 146 187 66 6 53 166 2 255 147 95 133 215 130 22 224 106 196 220 128 15 40 222 181 31 186 196 195 27 165 85 221 100 211 54 197 49 242 50 196 60 0 5 181 254 172 170 62 61 157 26 135 225 119 120 16 69 96 135 30 106 54 191 247 225 73 4 5 133 240 85 99 146 114 20 70 208 185 207 115 87 239 4 255 82 234 158 78 142 224 143 202 171 226 156 242 92 134 103 249 104 125 97 31 163 28 58 176 50 165 214 168 95 202 97 197 252 55 9 80 231 155 202 217 107 77 153 114 125 95 46 229 167 195 90 7 183 19 53 198 10 198 72 3 191 254 105 71 150 3 196 148 134 17 211 38 195 158 115 208 71 6 49 168 6 38 226 234 174 70 214 131 220 228 246 74 75 99 15 199 180 198 222 124 168 31 157 67 119 68 65 101 69 94 138 9 163 57 126 21 239 67 175 253 235 81 105 24 147 197 46 211 137 137 153 191 5 228 95 1 77 217 179 18 121 94 184 202 92 6 24 28 55 209 6 186 34 41 247 37 239 168 170 26 78 45 152 16 42 226 152 89 46 99 138 168 47 111 60 26 94 251 142 17 48 179 199 26 35 191 102 15 16 211 49 220 2 235 170 212 93 73 111 14 146 106 121 169 162 133 16 208 183 82 172 78 106 104 72 204 183 43 118 151 196 142 186 234 0 146 48 38 33 69 245 246 109 109 240 117 53 159 78 43 204 248 232 191 40 156 9 15 119 115 34 14 38 62 108 110 14 73 174 120 250 251 64 112 128 64 57 164 76 201 47 89 91 178 129 45 165 92 119 111 27 222 235 4 206 46 133 88 207 21 10 50 82 14 214 101 241 93 199 175 178 249 27 56 220 164 176 77 226 165 188 178 207 5 13 4 132 107 102 198 216 229 105 176 223 61 68 91 201 36 198 153 19 2 95 36 11 63 112 214 152 245 140 222 246 48 101 238 91 152 163 2 8 50 36 99 124 5 165 209 18 230 41 38 252 205 186 12 7 36 77 76 151 17 154 47 80 246 161 253 191 146 247 57 167 199 23 245 191 54 59 173 26 220 108 233 57 204 194 62 255 65 131 229 99 229 216 122 13 129 95 181 154 220 79 4 53 17 15 184 75 85 78 190 109 8 88 18 133 102 155 216 71 169 158 203 99 187 54 66 69 44 179 232 144 160 38 231 56 31 216 54 80 205 244 233 231 181 128 110 105 161 163 57 96 207 179 82 193 66 217 73 118 175 138 156 48 194 186 232 110 167 42 157 126 126 55 155 216 255 181 240 122 163 161 248 138 32 125 236 26 33 234 72 101 79 72 191 117 106 91 26 86 200 194 143 32 211 255 168 198 212 26 191 33 14 189 237 48 10 116 134 230 188 50 19 68 219 100 10 168 129 166 2 94 61 5 65 234 5 16 191 224 201 69 95 239 173 36 186 36 60 236 55 240 145 166 235 72 152 43 190 172 170 83 166 109 248 136 83 108 131 39 225 11 156 235 34 250 125 183 62 109 83 111 236 48 71 58 87 17 59 117 225 186 157 163 147 148 197 145 237 221 239 134 54 247 92 9 128 212 36 80 240 254 210 236 213 102 246 245 182 118 115 16 40 201 57 23 210 188 35 118 83 239 13 248 69 45 251 23 254 187 238 66 6 22 155 6 78 10 255 134 46 127 148 103 252 76 139 242 32 97 134 111 238 19 10 39 237 107 205 78 82 55 143 27 66 245 178 39 79 133 16 57 109 165 128 237 10 95 106 74 114 36 155 175 151 238 67 146 65 55 29 244 175 195 89 187 131 90 42 200 20 154 75 133 37 185 185 85 77 38 15 177 231 8 88 28 178 63 58 52 17 204 136 21 120 22 69 113 193 253 180 64 3 193 29 211 192 153 13 140 35 70 230 3 204 182 91 143 247 59 0 201 40 97 36 239 132 147 92 39 180 180 32 65 64 127 146 156 209 122 248 191 214 132 65 234 146 172 181 57 64 32 97 168 195 202 79 233 50 72 133 62 239 94 87 125 14 156 101 64 139 146 33 67 0 74 202 141 6 75 26 173 103 145 205 8 208 210 3 164 79 202 135 128 101 50 218 143 190 51 155 35 228 128 18 235 77 3 182 126 69 84 40 25 249 126 110 2 232 34 48 14 117 1 213 42 60 70 15 221 193 47 51 85 20 255 75 235 25 20 17 141 245 166 173 18 39 238 201 192 55 218 30 172 110 4 230 74 141 189 125 194 226 12 246 252 82 49 14 244 14 46 78 29 105 10 77 152 232 237 38 192 25 170 155 18 148 173 190 196 40 23 3 34 55 194 252 4 223 195 56 30 55 248 97 14 129 42 215 25 196 167 103 161 186 2 8 222 49 134 198 48 13 214 115 117 110 172 178 195 171 31 227 151 117 139 139 215 195 237 255 87 231 152 167 91 14 18 221 252 254 185 63 119 117 51 23 52 119 213 119 68 85 182 60 181 229 70 78 186 193 246 93 70 68 229 131 39 253 41 85 42 22 82 100 174 163 227 52 38 167 68 158 185 132 165 67 141 75 142 252 229 135 80 253 213 78 155 56 8 126 22 238 90 219 60 196 234 200 216 250 28 67 209 219 189 50 121 244 150 25 250 192 190 159 30 112 168 83 149 247 193 207 109 36 55 57 35 202 48 88 27 94 209 168 29 71 96 221 139 107 147 102 85 240 157 219 98 149 54 222 39 197 106 167 160 229 61 32 66 68 231 15 132 215 148 43 166 100 102 196 99 102 242 236 141 146 74 166 223 107 164 75 132 150 167 14 239 222 195 167 76 63 115 221 218 38 232 243 143 13 30 235 233 166 162 41 224 144 103 132 57 55 176 184 21 62 154 157 243 174 126 238 64 45 22 216 135 165 13 158 65 73 149 170 128 228 201 159 191 49 220 38 140 132 55 223 148 95 173 23 147 21 184 103 52 226 11 115 15 60 52 57 232 182 84 217 173 37 202 98 252 163 53 184 135 189 255 22 62 248 100 73 53 110 125 132 84 191 17 210 244 188 67 110 226 97 221 7 162 198 200 178 169 50 67 181 175 195 166 227 196 8 187 195 167 176 187 196 59 31 52 30 79 195 131 213 73 227 223 179 170 79 31 75 37 53 235 248 183 234 255 153 36 56 56 124 7 143 79 200 147 57 30 87 164 191 158 40 76 97 128 117 105 184 126 73 201 36 232 191 143 166 231 221 197 172 153 154 5 210 177 51 117 86 80 10 61 145 59 101 213 232 150 10 199 0 169 77 30 218 235 21 220 189 95 98 168 165 242 218 198 37 122 58 73 121 33 14 82 252 234 212 194 253 240 13 155 23 72 89 253 230 168 72 4 104 6 249 118 225 232 179 52 224 70 102 10 245 92 145 233 31 139 211 89 16 203 126 42 162 69 53 198 143 174 7 135 74 167 91 198 203 127 93 73 183 128 77 12 18 84 62 161 39 40 119 12 22 110 245 76 24 125 203 215 65 85 174 146 19 81 214 11 123 101 48 175 158 62 107 30 104 147 129 40 196 255 163 237 124 238 22 215 124 10 147 110 130 20 69 160 244 92 149 255 29 251 254 140 149 231 176 182 53 122 253 246 242 13 216 135 155 255 14 150 29 110 111 76 77 153 73 159 73 255 87 194 240 229 39 237 175 146 18 130 39 5 96 153 210 211 111 163 134 131 182 59 177 58 107 105 81 52 97 58 125 165 212 52 23 117 52 49 35 139 70 69 228 138 196 202 59 118 205 6 192 53 246 42 109 24 77 167 91 85 59 31 72 208 204 110 245 189 236 91 228 240 193 185 14 76 119 0 2 10 243 55 152 181 255 177 166 196 13 204 158 41 7 208 140 16 188 75 98 0)! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 8/14/2000 19:55'!macAsyncFilePrimsFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "AsynchFilePlugin.h"#include <devices.h>#if !!TARGET_API_MAC_CARBON#define DisposeIOCompletionUPP(userUPP) DisposeRoutineDescriptor(userUPP)#endif/* initialize/shutdown */int asyncFileInit() { return true; }int asyncFileShutdown() {} /* End of adjustments for pluginized VM *//*  Experimental support for asynchronous file reading and writing.  When a read or write operation is initiated, control is returned to Squeak  immediately. A semaphore is signaled when the operation completes, at which  time the client can find out how many bytes were actually read or written  and copy the results of the read operation from the file buffer into a Squeak  buffer. Only one operation may be in progress on a given file at a given time,  but operations on different files may be done in parallel.  The semaphore is signalled once for each transfer operation that is successfully  started, even if that operation later fails. Write operations always write  their entire buffer if they succeed, but read operations may transfer less than  their buffer size if they are started less than a buffer''s size from the end  of the file.    The state of a file is kept in the following structure, which is stored directly  in a Squeak ByteArray object:    typedef struct {	  int				sessionID;	  AsyncFileState	*state;    } AsyncFile;  The session ID is used to detect stale files--files that were open  when the image was saved. The state pointer of such files is meaningless.  Async file handles use the same session ID as ordinary file handles.  Note: These primitives are experimental!! They need not be implemented on  every platform, and they may be withdrawn or replaced in a future release.*/#include <Errors.h>#include <Files.h>#include <Strings.h>/* Async file handle (defined in header file):*/typedef struct {	ParamBlockRec pb;  /* must be first */	long	refNum;	int		writable;	int		semaIndex;	int		status;	int		bytesTransferred;	int		bufferSize;	char 	*bufferPtr;} AsyncFileState;/*** Status Values ***/#define IDLE			0#define LAST_OP_FAILED	1#define BUSY			2/*** Imported Variables ***/extern int successFlag;extern int thisSession;/*** Local Vaiables ***/IOCompletionUPP asyncFileCompletionProc = nil;/*** Exported Functions ***/int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** Local Functions ***/int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount);pascal void asyncFileCompletionRoutine(AsyncFileState *state);int asyncFileInitPB(AsyncFileState *state, int fPosition);int asyncFileValid(AsyncFile *f);int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount) {  /* Allocate a new buffer of the given size if necessary. If the current buffer	 is already allocated and of the desired size, do nothing. */	if ((state->bufferPtr !!= nil) && (state->bufferSize == byteCount)) {		return;  /* buffer is already allocated and of the desired size */	}	/* free old buffer, if any */	if (state->bufferPtr !!= nil) {		DisposePtr(state->bufferPtr);		state->bufferSize = 0;		state->bufferPtr = nil;	}	/* allocate new buffer */	state->bufferPtr = NewPtr(byteCount);	if (state->bufferPtr == nil) {		state->bufferSize = 0;		return success(false);  /* could not allocate a buffer of size count */	}	state->bufferSize = byteCount;}pascal void asyncFileCompletionRoutine(AsyncFileState *state) {  /* Called when an I/O request completes. Decides what to do based on the given state.	 Note that the first part of the state record is the I/O parameter block. */	OSErr err;	err = state->pb.ioParam.ioResult;	if ((err !!= noErr) && (err !!= eofErr)) {		/* Note: eofErr indicates that fewer than the count bytes were transfered when		   reading because the end-of-file was encountered first; it isn''t a real error. */		state->status = LAST_OP_FAILED;		state->bytesTransferred = 0;		signalSemaphoreWithIndex(state->semaIndex);		return;	}	state->bytesTransferred = state->pb.ioParam.ioActCount;	state->status = IDLE;	signalSemaphoreWithIndex(state->semaIndex);}int asyncFileInitPB(AsyncFileState *state, int fPosition) {	memset(&state->pb, 0, sizeof(ParamBlockRec));	state->pb.ioParam.ioCompletion = asyncFileCompletionProc;	state->pb.ioParam.ioRefNum = state->refNum;	state->pb.ioParam.ioBuffer = state->bufferPtr;	state->pb.ioParam.ioReqCount = state->bufferSize;	state->pb.ioParam.ioPosMode = fsFromStart;	state->pb.ioParam.ioPosOffset = (fPosition < 0) ? 0 : fPosition;	state->status = BUSY;	state->bytesTransferred = 0;}int asyncFileValid(AsyncFile *f) {	return (		(f !!= NULL) &&		(f->sessionID == thisSession) &&		(f->state !!= NULL) &&		(((AsyncFileState *) f->state)->refNum !!= 0));}/*** Exported Functions ***/int asyncFileClose(AsyncFile *f) {  /* Close the given asynchronous file. */	AsyncFileState *state;	short int volRefNum;	OSErr err;	if (!!asyncFileValid(f)) return;  /* already closed */	state = f->state;	err = GetVRefNum(state->refNum, &volRefNum);	success(err == noErr);	err = FSClose(state->refNum);	success(err == noErr);	if (successFlag) err = FlushVol(NULL, volRefNum);	success(err == noErr);    if (asyncFileCompletionProc !!= nil)        DisposeIOCompletionUPP(asyncFileCompletionProc);  	asyncFileCompletionProc = nil;	if (state->bufferPtr !!= nil) DisposePtr(state->bufferPtr);	DisposePtr((void *) f->state);	f->state = nil;	f->sessionID = 0;}int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex) {  /* Opens the given file using the supplied AsyncFile structure to record	 its state. Fails with no side effects if f is already open. Files are	 always opened in binary mode. */	int i;	Str255 cFileName;	short int fileRefNum;	AsyncFileState *state;	OSErr err;	/* don''t open an already open file */	if (asyncFileValid(f)) return success(false);	/* build complete routine descriptor, if necessary */	if (asyncFileCompletionProc == nil) {		asyncFileCompletionProc = NewIOCompletionProc((pascal void (*) (union ParamBlockRec *) )asyncFileCompletionRoutine);	}	/* copy the file name into a null-terminated C string */	if (fileNameSize > 255) return success(false);		sqFilenameFromString(cFileName, fileNamePtr, fileNameSize);	if (!!plugInAllowAccessToFilePath((char *) cFileName, fileNameSize)) {		return success(false);	}	CopyCStringToPascal((const char *)cFileName,cFileName);	f->sessionID = 0;	if (writeFlag) {		/* first try to open an existing file read/write: */		err = HOpenDF(0,0,cFileName, fsRdWrPerm, &fileRefNum); 		if (err !!= noErr) {			/* file does not exist; must create it. */			err = HCreate(0, 0, cFileName,''R*ch'',''TEXT''); 			if (err !!= noErr) return success(false);			err = HOpenDF(0,0,cFileName,fsRdWrPerm, &fileRefNum);			if (err !!= noErr) return success(false);		}	} else {		/* open the file read-only  */		err = HOpenDF(0,0,cFileName, fsRdPerm, &fileRefNum); 		if (err !!= noErr) return success(false);	}	f->state = (AsyncFileState *) NewPtr(sizeof(AsyncFileState));	/* allocate state record */	if (f->state == nil) {		FSClose(fileRefNum);		return success(false);	}	f->sessionID = thisSession;	state = (AsyncFileState *) f->state;	state->refNum = fileRefNum;	state->writable = writeFlag;	state->semaIndex = semaIndex;	state->status = IDLE;	state->bytesTransferred = 0;	state->bufferSize = 0;	state->bufferPtr = nil;}int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize) {  /* Copy up to bufferSize bytes from the buffer of the last read operation	 into the given Squeak buffer, and return the number of bytes copied.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed	Note that a read operation may read fewer bytes than requested if, for	example, there are fewer than the requested number of bytes between the	starting file position of the read operation and the end-of-file. */	AsyncFileState *state;	int bytesRead;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	/* copy the file buffer into the squeak buffer */	bytesRead = (bufferSize < state->bytesTransferred) ? bufferSize : state->bytesTransferred;	memcpy((char *) bufferPtr, state->bufferPtr, bytesRead);	return bytesRead;}int asyncFileReadStart(AsyncFile *f, int fPosition, int count) {  /* Start an asynchronous operation to read count bytes from the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileReadResult() to	 find out if the operation succeeded and to get the data that was read. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, count);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	asyncFileInitPB(state, fPosition);	err = PBReadAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}int asyncFileRecordSize() {	return sizeof(AsyncFile);}int asyncFileWriteResult(AsyncFile *f) {  /* Return the number of bytes copied by the last write operation.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed */	AsyncFileState *state;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	return state->bytesTransferred;}int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize) {  /* Start an asynchronous operation to write bufferSize bytes to the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileWriteResult() to	 find out if the operation succeeded and how many bytes were actually written. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	if (!!state->writable) return success(false);	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, bufferSize);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	/* copy the squeak buffer into the file buffer */	memcpy(state->bufferPtr, (char *) bufferPtr, bufferSize);	asyncFileInitPB(state, fPosition);	err = PBWriteAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 8/14/2000 19:56'!macBrowserPluginFile	^ '//Thing busted 2000 July 26th// squeak quit restart has issues with change file open///********** Notes on Browser Plugin VM ************How it Works:The browser plugin VM allows Squeak to be run as a plug-in underversion 4.0 and later of either Netscape Navigator or Internet Explorer.To use it, you must translate a version of interp.c with the browser pluginhooks. These hooks work by causing the VM to save the state of the currentSqueak process and return control from the interpret() after a shortperiod of time (e.g., 1/10th second or 1/60th). This allows the browser to processevents and perform other tasks. Eventually, the browser calls NPP_HandleEvent()with a NULL event, thus re-entering the Squeak interpret loop. The key toefficiency is to not return control to the browser too often, since thebrowser is quite slow to send the next null event. The VM does thisby polling for events itself; if there are no events in the OS queue,then it return control to the browser much less often.Note for fullscreen support NPP_HandleEvent does not return control, it consumes events from waitnextevent. When fullscreen mode is turn off then control is returned to the browser.Relationship of this file to sqMacWindow.c:One can think of this file as specializing and extending sqMacWindow.cfor running within a browser. Certain methods in  sqMacWindow.c arereplaced by functions defined here. The originals are removed fromsqMacWindow.c by defining the PLUGIN flag in that file when compiling.Here is a list of the functions overridden:	ioExit()	ioScreenSize()	ioSetFullScreen()	sqAllocateMemory()    plugInAllowAccessToFilePath()In addition, ioProcessEvents() becomes a noop and main() is completelyomitted when sqMacWindow.c is compiled for use in the browser plugin VM.June/July 2000 johnmci@smalltalkconsulting.com Reviewed code readded comments, added FullScreen Support				fixed issues with Carbon, general code cleaning.**********/#include "sq.h"#include "FilePlugin.h"#include "npapi.h"#include <Events.h>#include <Files.h>#include <Notification.h>#include <Strings.h>#include <MacWindows.h>#include <Movies.h>#include <Folders.h>#if TARGET_API_MAC_CARBON    #define EnableMenuItemCarbon(m1,v1)  EnableMenuItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableMenuItem(m1,v1);#else    #define EnableMenuItemCarbon(m1,v1)  EnableItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableItem(m1,v1);        inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}          inline Rect *GetRegionBounds(RgnHandle region, Rect * bounds) { *bounds = (*region)->rgnBBox; return &(*region)->rgnBBox;}        inline RgnHandle GetPortClipRegion(CGrafPtr port,RgnHandle clipRgn) {MacCopyRgn (port->clipRgn,clipRgn); return clipRgn;}          inline BitMap *GetQDGlobalsScreenBits(BitMap *bm){*bm = qd.screenBits; return &qd.screenBits; }        inline BitMap * GetPortBitMapForCopyBits (CGrafPtr w) { return &((GrafPtr)w)->portBits;}        inline pascal long InvalWindowRect(WindowRef  window,  const Rect * bounds) {InvalRect (bounds);}#endif/********** Compilation Options:**	ENABLE_URL_FETCH*	  Define this to compile primitives to fetch URL''s via the browser.**	  Warning: Fetching file URL''s through the URL fetch mechanism allows*	  potentially untrusted code to read files outside of the Squeak*	  file system "sandbox", a serious breach of privacy. *	  There are few uses for use for the browser URL fetch*	  mechanism, since you can always fetch URL''s from remote servers*	  using Squeak''s own HTTPSocket.***********/#define ENABLE_URL_FETCH  #define IMAGE_NAME "SqueakPlugin.image"#define VMPATH_SIZE 300/*** Exported Primitives ***/#ifdef ENABLE_URL_FETCH#pragma export onint primitivePluginBrowserReady(void);int primitivePluginDestroyRequest(void);int primitivePluginRequestFileHandle(void);int primitivePluginRequestState(void);int primitivePluginRequestURL(void);int primitivePluginRequestURLStream(void);#pragma export off#endif/* Constants */#define MAX_STRING_LENGTH 255#define MAX_ARG_STRING_LENGTH 100#define STATUS_BAD_HANDLE -1#define STATUS_IDLE 0#define STATUS_IN_PROGRESS 1#define STATUS_FAILED 2#define STATUS_SUCCEEDED 3#define STARTINGsqueakHeapMBytes 20/*** Imported Variables ***/extern int interruptKeycode;extern unsigned char *memory;extern WindowPtr stWindow;extern int fullScreenFlag;extern char documentName[];  /* full path to document file */extern char imageName[];  /* full path to image file */extern char shortImageName[];  /* just the image file name */extern char vmPath[];  /* full path to interpreter''s directory */extern struct VirtualMachine *interpreterProxy;extern int thisSession;  /* from sqFilePrims.c: *//*** Local Variables ***/int			exitRequested	= false;Rect    	gSavePortPortRect;RgnHandle   gSavePortClipRgn;CGrafPtr	gOldPort		= nil;int			interpStartTime	= 0;int			needsUpdate		= false;NPWindow* 	netscapeWindow	= nil;Str255		notificationMsg = "";NMRec		notifyRec;int			pluginArgCount	= 0;char		*pluginArgName[MAX_ARG_STRING_LENGTH];char		*pluginArgValue[MAX_ARG_STRING_LENGTH];Boolean     ignoreFirstEvent=false;int			squeakHeapMBytes = STARTINGsqueakHeapMBytes;  /* default heap size, override via the "memory" EMBED tag */char		squeakPluginImageName[] = IMAGE_NAME;NPP			thisInstance	= nil;WindowPtr gAFullscreenWindow = nil;#define URL_REQUEST_COUNT 100typedef struct {	int id;  /* used to associate a request with its outcome */	int status;	int semaIndex;	char fileName[MAX_STRING_LENGTH + 1];} URLRequestRecord;URLRequestRecord urlRequests[URL_REQUEST_COUNT];int nextRequestID = 1;/*** Functions Imported from sqMacWindow ***/int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);void ioSetFullScreenRestore();int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);/*** Local Functions ***/int  CaseInsensitiveMatch(char *s1, char *s2);void EndDraw(void);void ExitCleanup(void);int  FindIdleURLRequest(void);int  InitFilePaths(void);void InitURLRequestTable(void);int  IsPrefixedBy(char *s, char *prefix);void OpenFileReadOnly(SQFile *f, char *fileName);void ReadSqueakImage(void);void StartDraw(void);int  StringToInteger(char *s);int PathToPreferenceDir(char *pathName, long pathNameMax, long volumeID, long directoryID);void URLRequestCompleted(int notifyData, const char* fileName);int  URLRequestCreate(char *url, char *target, int semaIndex);void URLRequestDestroy(int requestHandle);void URLRequestFailed(int notifyData, int reason);char * URLRequestFileName(int requestHandle);int  URLRequestStatus(int requestHandle);/*** Initialize/Shutdown ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Initialize: * Provides global initialization for a plug-in, and returns an error value.  * * This function is called once when a plug-in is loaded, before the first instance * is created. Allocate any memory or resources shared by all * instances of your plug-in at this time. After the last instance has been deleted, * NPP_Shutdown will be called, where you can release any memory or * resources allocated by NPP_Initialize.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_Initialize(void) {	exitRequested = false;	needsUpdate = false;	netscapeWindow = nil;	pluginArgCount = 0;	squeakHeapMBytes = STARTINGsqueakHeapMBytes;	thisInstance = nil;	InitURLRequestTable();	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_GetJavaClass: * New in Netscape Navigator 3.0.  * * NPP_GetJavaClass is called during initialization to ask your plugin * what its associated Java class is. If you don''t have one, just return * NULL.  +++++++++++++++++++++++++++++++++++++++++++++++++*/jrefNPP_GetJavaClass(void){	return (jref) NULL;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Shutdown: * Provides global deinitialization for a plug-in.  *  * This function is called once after the last instance of your plug-in is destroyed. * Use this function to release any memory or resources shared across all * instances of your plug-in.  +++++++++++++++++++++++++++++++++++++++++++++++++*/void NPP_Shutdown(void) {	ExitCleanup();}/*** Instance Create/Destroy ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_New: * Creates a new instance of a plug-in and returns an error value.  *  * NPP_New creates a new instance of your plug-in with MIME type specified * by pluginType. The parameter mode is NP_EMBED if the instance was created * by an EMBED tag, or NP_FULL if the instance was created by a separate file. * You can allocate any instance-specific private data in instance->pdata at this * time. The NPP pointer is valid until the instance is destroyed.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_New(NPMIMEType pluginType, NPP instance, uint16 mode,  int16 argc, char* argn[], char* argv[], NPSavedData* saved) {	int i;	/* only one Squeak instance can be active at a time */	if (thisInstance !!= nil) return NPERR_GENERIC_ERROR;	for (i = 0; i < MAX_ARG_STRING_LENGTH; i++) {		pluginArgName[i] = pluginArgValue[i] = "";	}	/* record plugin arguments */	pluginArgCount = argc;	for (i = 0; (i < argc) && (i < MAX_ARG_STRING_LENGTH); i++) {		pluginArgName[i] = (char *) NPN_MemAlloc(strlen(argn[i]) + 1);		strcpy(pluginArgName[i], argn[i]);		pluginArgValue[i] = (char *) NPN_MemAlloc(strlen(argv[i]) + 1);		strcpy(pluginArgValue[i], argv[i]);		if (CaseInsensitiveMatch(pluginArgName[i], "memory")) {			squeakHeapMBytes = StringToInteger(pluginArgValue[i]);		}	}	memory = nil;	ReadSqueakImage();	if (!!memory) return NPERR_GENERIC_ERROR;	thisInstance = instance;	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Destroy: * Deletes a specific instance of a plug-in and returns an error value.  * NPP_Destroy is called when a plug-in instance is deleted, typically because the * user has left the page containing the instance, closed the window, or quit the * application. You should delete any private instance-specific information stored * in instance->pdata. If the instance being deleted is the last instance created * by your plug-in, NPP_Shutdown will subsequently be called, where you can * delete any data allocated in NPP_Initialize to be shared by all your plug-in''s * instances. Note that you should not perform any graphics operations in * NPP_Destroy as the instance''s window is no longer guaranteed to be valid.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_Destroy(NPP instance, NPSavedData** save) {	ExitCleanup();	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_SetWindow: * Sets the window in which a plug-in draws, and returns an error value.  *  * NPP_SetWindow informs the plug-in instance specified by instance of the * the window denoted by window in which the instance draws. This NPWindow * pointer is valid for the life of the instance, or until NPP_SetWindow is called * again with a different value. Subsequent calls to NPP_SetWindow for a given * instance typically indicate that the window has been resized. If either window * or window->window are NULL, the plug-in must not perform any additional * graphics operations on the window and should free any resources associated * with the window.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_SetWindow(NPP instance, NPWindow* window) {	NP_Port* port;	if (window == NULL) return NPERR_NO_ERROR;		netscapeWindow = window;	port = (NP_Port *) netscapeWindow->window;	stWindow = (WindowPtr) port->port;	needsUpdate	= true;	return NPERR_NO_ERROR;}/*** Streaming ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_NewStream: * Notifies an instance of a new data stream and returns an error value.  *  * NPP_NewStream notifies the instance denoted by instance of the creation of * a new stream specifed by stream. The NPStream* pointer is valid until the * stream is destroyed. The MIME type of the stream is provided by the * parameter type.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_NewStream(  NPP instance, NPMIMEType type,  NPStream *stream, NPBool seekable, uint16 *stype) {  /* Call to load the initial URL and to handle explicit URL fetch requests. */	*stype = NP_ASFILEONLY;  /* ask Netscape to cache file and call NPP_StreamAsFile */	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_DestroyStream: * Indicates the closure and deletion of a stream, and returns an error value.  *  * The NPP_DestroyStream function is called when the stream identified by * stream for the plug-in instance denoted by instance will be destroyed. You * should delete any private data allocated in stream->pdata at this time.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_DestroyStream(NPP instance, NPStream *stream, NPError reason) {	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_StreamAsFile: * Provides a local file name for the data from a stream.  *  * NPP_StreamAsFile provides the instance with a full path to a local file, * identified by fname, for the stream specified by stream. NPP_StreamAsFile is * called as a result of the plug-in requesting mode NP_ASFILEONLY or * NP_ASFILE in a previous call to NPP_NewStream. If an error occurs while * retrieving the data or writing the file, fname may be NULL.  +++++++++++++++++++++++++++++++++++++++++++++++++*/void NPP_StreamAsFile(NPP instance, NPStream *stream, const char* fname) {	if (fname !!= null) 		URLRequestCompleted((int) stream->notifyData, fname);	 else 		URLRequestFailed((int) stream->notifyData, 1);}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_WriteReady: * Returns the maximum number of bytes that an instance is prepared to accept * from the stream.  *  * NPP_WriteReady determines the maximum number of bytes that the * instance will consume from the stream in a subsequent call NPP_Write. This * function allows Netscape to only send as much data to the instance as the * instance is capable of handling at a time, allowing more efficient use of * resources within both Netscape and the plug-in.  +++++++++++++++++++++++++++++++++++++++++++++++++*/int32 NPP_WriteReady(NPP instance, NPStream *stream) {  /* not used, because we use ASFILEONLY mode */	return 100000;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Write: * Delivers data from a stream and returns the number of bytes written.  *  * NPP_Write is called after a call to NPP_NewStream in which the plug-in * requested a normal-mode stream, in which the data in the stream is delivered * progressively over a series of calls to NPP_WriteReady and NPP_Write. The * function delivers a buffer buf of len bytes of data from the stream identified * by stream to the instance. The parameter offset is the logical position of * buf from the beginning of the data in the stream.  *  * The function returns the number of bytes written (consumed by the instance). * A negative return value causes an error on the stream, which will * subsequently be destroyed via a call to NPP_DestroyStream.  *  * Note that a plug-in must consume at least as many bytes as it indicated in the * preceeding NPP_WriteReady call. All data consumed must be either processed * immediately or copied to memory allocated by the plug-in: the buf parameter * is not persistent.  +++++++++++++++++++++++++++++++++++++++++++++++++*/int32 NPP_Write(NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer) {  /* not used, because we use ASFILEONLY mode */	return len;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_URLNotify: * Notifies the instance of the completion of a URL request.  *  * NPP_URLNotify is called when Netscape completes a NPN_GetURLNotify or * NPN_PostURLNotify request, to inform the plug-in that the request, * identified by url, has completed for the reason specified by reason. The most * common reason code is NPRES_DONE, indicating simply that the request * completed normally. Other possible reason codes are NPRES_USER_BREAK, * indicating that the request was halted due to a user action (for example, * clicking the "Stop" button), and NPRES_NETWORK_ERR, indicating that the * request could not be completed (for example, because the URL could not be * found). The complete list of reason codes is found in npapi.h.  *  * The parameter notifyData is the same plug-in-private value passed as an * argument to the corresponding NPN_GetURLNotify or NPN_PostURLNotify * call, and can be used by your plug-in to uniquely identify the request.  +++++++++++++++++++++++++++++++++++++++++++++++++*/void NPP_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData) {	if (reason !!= NPRES_DONE) 		URLRequestFailed((int) notifyData, reason);}/*** Printing ***/void NPP_Print(NPP instance, NPPrint* printInfo) {	/* printing is not supported */}/*** Event Handling ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_HandleEvent: * Mac-only, but stub must be present for Windows * Delivers a platform-specific event to the instance.  *  * On the Macintosh, event is a pointer to a standard Macintosh EventRecord. * All standard event types are passed to the instance as appropriate. In general, * return TRUE if you handle the event and FALSE if you ignore the event.  * Note special logic for full screen support +++++++++++++++++++++++++++++++++++++++++++++++++*/int16 NPP_HandleEvent(NPP instance, void *rawEvent) {	EventRecord *eventPtr = (EventRecord*) rawEvent;	EventRecord	theEvent;	int				ok;	do {	    	if (exitRequested) {    		exitRequested = false;    		ExitCleanup();    		return false;    	}    	if ((thisInstance == nil) || (eventPtr == NULL)) {    		/* no instance or no event; do nothing */    		return false;    	}    	recordModifierButtons(eventPtr);    	switch (eventPtr->what) {    		case mouseDown:    			recordMouseDown(eventPtr);    		break;    		case keyDown:    		case autoKey:    			recordKeystroke(eventPtr);    		break;    		case updateEvt:    			needsUpdate = true;    		break;    		    		case nullEvent:    			/* interpret some bytecodes on every event */    			if (memory) {  /* but only if the VM has memory!! */    				StartDraw();    				interpret();    				EndDraw();    			}    		break;    	}    	if (needsUpdate && (netscapeWindow !!= nil) && (memory)) {    		if (fullScreenFlag) {    		    BeginUpdate((WindowPtr) eventPtr->message);     		}    		StartDraw();    		fullDisplayUpdate();  /* ask VM to call ioShowDisplay */    		EndDraw();    		if (fullScreenFlag) {    		    EndUpdate((WindowPtr) eventPtr->message);   			}    		needsUpdate = false;    	}    	if (ignoreFirstEvent  &&  fullScreenFlag) {    	    ignoreFirstEvent = false;    	    return true;    	}    	if (fullScreenFlag) {     	    ok = WaitNextEvent(everyEvent, &theEvent,0,null);            eventPtr = &theEvent;    	}	} while (fullScreenFlag);	return true;}/*** Drawing ***/void EndDraw(void) {	SetOrigin(gSavePortPortRect.left, gSavePortPortRect.top);	SetClip(gSavePortClipRgn);	SetPort((GrafPtr) gOldPort);}void StartDraw(void) {	NP_Port* port;	Rect clipRect;		port = (NP_Port *) netscapeWindow->window;	/* save old graphics port and switch to ours */	GetPort((GrafPtr *) &gOldPort);	SetPort((GrafPtr) port->port);	stWindow = (WindowPtr) port->port;	/* save old drawing environment */	GetPortBounds(port->port,&gSavePortPortRect);	GetClip(gSavePortClipRgn);	/* setup our drawing environment */	SetOrigin(port->portx, port->porty);	clipRect.top    = netscapeWindow->clipRect.top    + port->porty;	clipRect.left   = netscapeWindow->clipRect.left   + port->portx;	clipRect.bottom = netscapeWindow->clipRect.bottom + port->porty;	clipRect.right  = netscapeWindow->clipRect.right  + port->portx;	ClipRect(&clipRect);	BackColor(whiteColor);  /* needed to avoid funny colors */}/*** Image File Reading ***/void ReadSqueakImage(void) {	sqImageFile f;	char msg[500];	plugInInit(squeakPluginImageName);	InitFilePaths();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		strcpy(msg, "Could not open Squeak image file \"");		strcat(msg, imageName);		strcat(msg, "\"");		plugInNotifyUser(msg);		return;	}	readImageFromFileHeapSizeStartingAt(f, squeakHeapMBytes * 1024*1024, 0);	sqImageFileClose(f);	interruptKeycode = 515;  /* ctrl-C, since Netscape blocks cmd-. */	fullScreenFlag=false; //Note image can be saved with true}/*** URL Requests ***/int URLRequestCreate(char *url, char *target, int semaIndex) {  /* Start a URL request and return its index. Return -1 if there were     no idle request handles. */	int handle, notifyData;	long junk;	handle = FindIdleURLRequest();	if (handle < 0) return handle;	urlRequests[handle].id = nextRequestID++;	urlRequests[handle].status = STATUS_IN_PROGRESS;	urlRequests[handle].semaIndex = semaIndex;	/* temporarily return the grafPort to Netscape so it can display feedback: */	EndDraw();	notifyData = (urlRequests[handle].id << 8) + handle;	NPN_GetURLNotify(thisInstance, url, target, (void *) notifyData);	Delay(120, (unsigned long *) &junk);  /* workaround for a bug in Mac Netscape 4.7--						  back-to-back requests to a server sometimes fail						  when the server was heavily loaded Question is this value too long!!*/	StartDraw();	return handle;}void URLRequestDestroy(int requestHandle) {  /* Clear the url request with the given handle. */	if ((requestHandle < 0) || (requestHandle >= URL_REQUEST_COUNT)) {		return;	}	urlRequests[requestHandle].id = 0;	urlRequests[requestHandle].status = STATUS_IDLE;	urlRequests[requestHandle].semaIndex = 0;	urlRequests[requestHandle].fileName[0] = 0;}char * URLRequestFileName(int requestHandle) {  /* Return the filename associated with the url request with the given     handle. Return null if the request status is not STATUS_SUCCEEDED. */	if ((requestHandle < 0) ||		(requestHandle >= URL_REQUEST_COUNT) ||		(urlRequests[requestHandle].status !!= STATUS_SUCCEEDED)) {			return null;	}	return urlRequests[requestHandle].fileName;}int URLRequestStatus(int requestHandle) {  /* Return the status of the url request with the given handle. */	if ((requestHandle < 0) ||		(requestHandle >= URL_REQUEST_COUNT) ||		(urlRequests[requestHandle].status < STATUS_IN_PROGRESS)) {			return STATUS_BAD_HANDLE;	}	return urlRequests[requestHandle].status;}int FindIdleURLRequest(void) {  /* Return the index of an idle request or -1 if there are none. */	int i;	for (i = 0; i < URL_REQUEST_COUNT; i++) {		if (urlRequests[i].status == STATUS_IDLE) {			return i;		}	}	return -1;}void URLRequestCompleted(int notifyData, const char* fileName) {  /* Record that the given request has completed, caching the result in     the given file name. */	int handle = notifyData & 0xFF;	if ((handle < 0) || (handle >= URL_REQUEST_COUNT)) {		return;	}	if (urlRequests[handle].id == (notifyData >> 8)) {		strncpy(urlRequests[handle].fileName, fileName, MAX_STRING_LENGTH);		urlRequests[handle].status = STATUS_SUCCEEDED;		signalSemaphoreWithIndex(urlRequests[handle].semaIndex);	}}void URLRequestFailed(int notifyData, int reason) {  /* Record that the given URL request failed. */	int handle = notifyData & 0xFF;	if ((handle < 0) || (handle >= URL_REQUEST_COUNT)) {		return;	}	if (urlRequests[handle].id == (notifyData >> 8)) {		/* Note: For local files, we''re informed that there was a network		   error (but only after NPP_StreamAsFile has reported success).		   We could allow local files to be read through the URL request		   mechanism but NOT failing here if the status has already been		   set to success. But we don''t want to allow the URL mechanism		   to be used as a loophole to read files outside the sandbox, so		   we let this fail. */		if (urlRequests[handle].status !!= STATUS_SUCCEEDED) {			urlRequests[handle].status = STATUS_FAILED;			signalSemaphoreWithIndex(urlRequests[handle].semaIndex);		}	}}void InitURLRequestTable(void) {  /* Initialize the table of URL requests. */	int i;	for (i = 0; i < URL_REQUEST_COUNT; i++) {		URLRequestDestroy(i);	}	nextRequestID = 1;}/*** Squeak I/O Support and Memory Allocation ***/int ioExit(void) {  /* Request that we stop running plugin. */	ioSetFullScreenRestore();	plugInForceTimeToReturn();	exitRequested = true;}int ioScreenSize(void) {	int w = 10, h = 10;		if (netscapeWindow !!= nil) {		w = netscapeWindow->clipRect.right - netscapeWindow->clipRect.left;		h = netscapeWindow->clipRect.bottom - netscapeWindow->clipRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}/* Full Screen logic */Ptr gRestorableStateForScreen = nil;NP_Port	  gFullScreenNPPort;NPWindow  *oldNetscapeWindow,gFullScreenNPWindow;WindowPtr oldStWindow;int ioSetFullScreen(int fullScreen) {	short desiredWidth,desiredHeight;	    plugInForceTimeToReturn();	if (fullScreen) {	    if (fullScreenFlag) return;		desiredWidth = 0;		desiredHeight = 0;		oldNetscapeWindow = netscapeWindow;		oldStWindow = stWindow;		BeginFullScreen	(&gRestorableStateForScreen,nil,								 &desiredWidth,								 &desiredHeight,								 &gAFullscreenWindow,								 nil,								 fullScreenAllowEvents);		fullScreenFlag = true;		stWindow = gAFullscreenWindow;		gFullScreenNPPort.port = (CGrafPort *) gAFullscreenWindow;		gFullScreenNPPort.portx = 0;		gFullScreenNPPort.porty = 0;		gFullScreenNPWindow.window =  &gFullScreenNPPort;		gFullScreenNPWindow.x = 0;		gFullScreenNPWindow.y = 0;		gFullScreenNPWindow.width = desiredWidth;		gFullScreenNPWindow.height = desiredHeight;		gFullScreenNPWindow.clipRect.top = 0;		gFullScreenNPWindow.clipRect.left = 0;		gFullScreenNPWindow.clipRect.bottom = desiredHeight;		gFullScreenNPWindow.clipRect.right = desiredWidth;    	    	netscapeWindow = &gFullScreenNPWindow;    	ignoreFirstEvent = true; 	} else {	    if (!!fullScreenFlag) return;		fullScreenFlag = false;        ioSetFullScreenRestore();	}}void ioSetFullScreenRestore(){	if (gRestorableStateForScreen !!= nil) {		EndFullScreen(gRestorableStateForScreen,nil);	    if (gAFullscreenWindow == nil) 		    return;	    gRestorableStateForScreen = nil;	    netscapeWindow = oldNetscapeWindow;	    stWindow = oldStWindow;	}}void * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {  /* Allocate the Squeak object heap memory from the system heap. */#if TARGET_API_MAC_CARBON	return NewPtr(desiredHeapSize);#else	return NewPtrSys(desiredHeapSize);#endif}/*** File and Access Paths ***/int InitFilePaths(void) {	short vRefNum;	char imageInPreferenceFolder[256];	long dirID;	OSErr err;	FSSpec fileSpec;		/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	strcpy(shortImageName, squeakPluginImageName);	/* get the path to the sytem folder preference area*/	err = FindFolder(kOnSystemDisk, kPreferencesFolderType, kDontCreateFolder, &vRefNum, &dirID);	if (err !!= noErr) {		strcpy(imageName,"Problems finding System Preference folder");		return err;	}		// Look for folder, if not found abort */	strcpy(imageInPreferenceFolder,":Squeak:Internet:");	strcat(imageInPreferenceFolder,shortImageName);	CopyCStringToPascal(imageInPreferenceFolder,(unsigned char *) imageInPreferenceFolder);	err = FSMakeFSSpec(vRefNum, dirID,(unsigned char *) imageInPreferenceFolder , &fileSpec);	if (err !!= noErr) {		strcpy(imageName,"Problems finding Internet folder in Squeak Preference folder and SqueakPlugin.image");		return err;	}		/* set the vmPath */	PathToPreferenceDir(vmPath,VMPATH_SIZE,fileSpec.vRefNum,fileSpec.parID);	strcpy(imageName, vmPath);	strcat(imageName, shortImageName);}int PathToPreferenceDir(char *pathName, long pathNameMax, long volumeID, long directoryID) {	/* Fill in the given string with the full path from a root volume to	   to current preference directory.	*/	Str255 thisName;	CInfoPBRec pb;	int nextDirRefNum, pathLen;	/* initialize string copying state */	pathName[0] = 0;	pathLen = 0;	/* get refNum of working directory */	strcpy((char *) thisName, ":");	CopyCStringToPascal((const char *)thisName,thisName);	pb.hFileInfo.ioNamePtr = thisName;	pb.hFileInfo.ioVRefNum = volumeID;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = directoryID;	if (PBGetCatInfoSync(&pb) !!= noErr) {		nextDirRefNum = 0;	}	nextDirRefNum = pb.hFileInfo.ioDirID;	while (true) {		thisName[0] = 0;		pb.hFileInfo.ioFDirIndex = -1; /* map ioDirID -> name */		pb.hFileInfo.ioVRefNum = 0;		pb.hFileInfo.ioDirID = nextDirRefNum;		if (PBGetCatInfoSync(&pb) !!= noErr) {			break;  /* we''ve reached the root */		}    	CopyPascalStringToC((unsigned char *)thisName,(char *) thisName);		pathLen = PrefixPathWith(pathName, pathLen, pathNameMax,(char *) thisName);		nextDirRefNum = pb.dirInfo.ioDrParID;	}	return pathLen;}int IsPrefixedBy(char *s, char *prefix) {  /* Return true if the given string begins with or equals the given prefix. */	int i;	for (i = 0; prefix[i] !!= 0; i++) {		if (s[i] !!= prefix[i]) 			return false;	}	return true;}int plugInAllowAccessToFilePath(char *pathString, int pathStringLength) {  /* Return true if access to the given file is allowed. */	int i;	char path[2000];	/* copy path into C string */	if (pathStringLength >= 2000) return false;  /* path too long */	memcpy(path,pathString,pathStringLength+1);	path[pathStringLength] = '':'';	path[pathStringLength+1] = 0;	/* disallow relative path names that might access a parent folder */	for (i = 0; i < pathStringLength; i++) {		if ((path[i] == '':'') && (path[i+1] == '':'')) {			return false;		}	}	return IsPrefixedBy(path, vmPath);}/*** Optional URL Fetch Primitives ***/#ifdef ENABLE_URL_FETCHint primitivePluginBrowserReady(void) {	/* Args: none.	   Always return true on Macintosh. */	interpreterProxy->pop(1);	interpreterProxy->pushBool(1);}int primitivePluginDestroyRequest(void) {	/* Args: handle.	   Destroy the given request. */	int handle;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	URLRequestDestroy(handle);	interpreterProxy->pop(1);}int primitivePluginRequestFileHandle(void) {	/* Args: handle.	   Return a file handle for the completed request. Fail if	   the request handle is not valid or hasn''t successfully completed. */	int handle, fileObj;	char *fileName;	SQFile *filePtr;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	fileName = URLRequestFileName(handle);	if (fileName == null) {		interpreterProxy->success(false);		return null;	}	fileObj = interpreterProxy->instantiateClassindexableSize(		interpreterProxy->classByteArray(), sizeof(SQFile));	filePtr = (SQFile *) (fileObj + 4);	/* Note: OpenFileReadOnly() allows any file on the disk to be read via a file URL.	   However, we are using it for now because we are not sure where the Netscape cache	   folder will be--it''s folder might even be user-name dependent. sqFileOpen() will	   only allow opening files within the sandbox, which would be better. Here''s the	   sandbox-safe alternative:		  sqFileOpen(filePtr, (int) fileName, strlen(fileName), false);	*/	OpenFileReadOnly(filePtr, fileName);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(2);	interpreterProxy->push(fileObj);}int primitivePluginRequestState(void) {	/* Args: handle.	   Return true if the request succeeded, false if it failed, and nil if	   it is still in progress. Fail if the request handle is not valid. */	int handle;	int status;	int resultObj;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	status = URLRequestStatus(handle);	if (status == STATUS_BAD_HANDLE) {		interpreterProxy->success(false);		return null;	}	/* default return object: (nil means "in progress") */	resultObj = interpreterProxy->nilObject();	if (status == STATUS_FAILED) {		resultObj = interpreterProxy->falseObject();	}	if (status == STATUS_SUCCEEDED) {		resultObj = interpreterProxy->trueObject();	}	interpreterProxy->pop(2);	interpreterProxy->push(resultObj);}int primitivePluginRequestURL(void) {	/* Args: url, target, semaphoreIndex.	   Start a URL request to fetch the given URL to the given target.	   (See the Netscape Plugin programmer''s manual for possible targets.)	   Return a handle that can be used to identify this request. Fail if	   there are already too many outstanding requests. */	char *urlPtr;	char *targetPtr;	int semaIndex;	int urlObj, urlSize;	int targetObj, targetSize;	char url[MAX_STRING_LENGTH + 1];	char target[MAX_STRING_LENGTH + 1];	int i;	int handle;	semaIndex = interpreterProxy->stackIntegerValue(0);	targetObj = interpreterProxy->stackObjectValue(1);	urlObj = interpreterProxy->stackObjectValue(2);	interpreterProxy->success(interpreterProxy->isBytes(targetObj));	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	targetSize = interpreterProxy->stSizeOf(targetObj);	targetPtr = interpreterProxy->firstIndexableField(targetObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	/* copy target into a C string */	if (targetSize > MAX_STRING_LENGTH) targetSize = MAX_STRING_LENGTH;	for (i = 0; i < targetSize; i++) {		target[i] = targetPtr[i];	}	target[targetSize] = 0;	handle = URLRequestCreate(url, target, semaIndex);	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(4);	interpreterProxy->pushInteger(handle);}int primitivePluginRequestURLStream(void) {	/* Args: url, semaphoreIndex.	   Start a URL request to fetch the given URL. Return a handle that	   can be used to identify this request. Fail if there are already	   too many outstanding requests. */	int urlObj, urlSize, semaIndex;	char *urlPtr;	char url[MAX_STRING_LENGTH + 1];	int handle, i;	semaIndex = interpreterProxy->stackIntegerValue(0);	urlObj = interpreterProxy->stackObjectValue(1);	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	handle = URLRequestCreate(url, null, semaIndex);	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(3);	interpreterProxy->pushInteger(handle);}void OpenFileReadOnly(SQFile *f, char *fileName) {	/* Opens the given file for reading using the supplied sqFile	   structure. This is a simplified version of sqFileOpen() that	   avoids the "sandbox" access check, since the browser''s	   cache folder is outside the Squeak sandbox. That is why	   we only allow reading of this file. Sets the primitive	   failure flag if not successful. */	f->file = fopen(fileName, "rb");	f->writable = false;	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		interpreterProxy->success(false);		return;	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}	f->lastOp = 0;}#endif/*** Other ***/int CaseInsensitiveMatch(char *s1, char *s2) {  /* Return true if the two strings are the same, not considering case. */	int len, i, c1, c2;	len = strlen(s1);	if (strlen(s2) !!= len) return false;	for (i = 0; i < len; i++) {		c1 = s1[i];		c2 = s2[i];		if ((c1 >= ''a'') && (c1 <= ''z'')) {			c1 = c1 - (''a'' - ''A'');		}		if ((c2 >= ''a'') && (c2 <= ''z'')) {			c2 = c2 - (''a'' - ''A'');		}		if (c1 !!= c2) return false;	}	return true;}void ExitCleanup(void) {  /* Clean up and stop running plugin. */	if (thisInstance == nil) return;	thisInstance = nil;	plugInShutdown();	ioSetFullScreenRestore();	NPP_Initialize();  /* reset local variables */}int StringToInteger(char *s) {  /* Answer the integer resulting from converting the given     string, assumed to be decimal integer. */	int sign, n, i, ch;	sign = 1;	n = 0;	i = 0;	while ((ch = s[i++]) !!= 0) {		if ((ch == ''-'') && (i == 1)) {			sign = -1;		} else {			if ((ch >= ''0'') && (ch <= ''9'')) {				n = (10 * n) + (ch - ''0'');			} else {				return sign * n;			}		}	}	return sign * n;}/*** Interpreter Hooks ***/void plugInForceTimeToReturn(void) {  /* Ensure that the next call to pluginTimeToReturn() will return true. */	interpStartTime = TickCount() - 10000;}int plugInNotifyUser(char *msg) {  /* Notify the user that there was a problem starting Squeak. */	CopyCStringToPascal(msg,notificationMsg); /* copy message, since notification is asynchronous */	notifyRec.qType = nmType;	notifyRec.nmMark = false;			/* no mark in applications menu */	notifyRec.nmIcon = nil;				/* no menu bar icon */	notifyRec.nmSound = (Handle) -1;	/* -1 means system beep */	notifyRec.nmStr = notificationMsg;	notifyRec.nmResp = (NMUPP) -1;		/* -1 means remove notification when user confirms */	/* add to notification queue */	NMInstall(&notifyRec);}void plugInSetStartTime(void) {  /* Set that time at which interpret() was started. */	interpStartTime = TickCount();}int plugInTimeToReturn(void) {  /* Return true if it is time to return from interpret(). */    EventRecord evt;    int delta = TickCount() - interpStartTime;    if ((delta < 0) || (delta >= 20)) {        /* let Netscape have control every so often whether or           not there are pending events */        return true;    }    if ((delta & 0x3) == 0x3) {        /* check every 4 ticks; if pending events, return to the browser */        if (OSEventAvail(everyEvent, &evt)) return true;    }    return false;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 8/3/2000 15:02'!macDirectoryFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "FilePlugin.h"/* End of adjustments for pluginized VM */#include <Files.h>#include <Strings.h>/***	The interface to the directory primitive is path based.	That is, the client supplies a Squeak string describing	the path to the directory on every call. To avoid traversing	this path on every call, a cache is maintained of the last	path seen, along with the Mac volume and folder reference	numbers corresponding to that path.***//*** Constants ***/#define ENTRY_FOUND     0#define NO_MORE_ENTRIES 1#define BAD_PATH        2#define DELIMITOR '':''#define MAX_PATH 2000/*** Variables ***/char lastPath[MAX_PATH + 1];int  lastPathValid = false;int  lastRefNum = 0;int  lastVolNum = 0;/*** Functions ***/int convertToSqueakTime(int macTime);int equalsLastPath(char *pathString, int pathStringLength);int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr);int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr);int lookupVolume(char *volName, int *refNumPtr);int recordPath(char *pathString, int pathStringLength, int refNum, int volNum);int convertToSqueakTime(int macTime) {	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */	return macTime + (3 * 365 * 24 * 60 * 60);}int dir_Create(char *pathString, int pathStringLength) {	/* Create a new directory with the given path. By default, this	   directory is created in the current directory. Use	   a full path name such as "MyDisk:Working:New Folder" to	   create folders elsewhere. */	Str255 name;	HParamBlockRec pb;	int i;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return false;	}	for (i = 0; i < pathStringLength; i++) {		name[i] = pathString[i];	}	name[i] = 0; /* string terminator */	CopyCStringToPascal((const char *) name,name);	pb.fileParam.ioNamePtr = name;	pb.fileParam.ioVRefNum = 0;	pb.fileParam.ioDirID = 0;	return PBDirCreateSync(&pb) == noErr;}int dir_Delete(char *pathString, int pathStringLength) {	/* Delete the existing directory with the given path. */	int okay, refNum, volNum, i;	HParamBlockRec pb;	Str255 name;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return false;	}	for (i = 0; i < pathStringLength; i++) {		name[i] = pathString[i];	}	name[i] = 0; /* string terminator */	okay = lookupPath(pathString, pathStringLength, &refNum, &volNum);	if (!!okay) {		return false;	}	CopyCStringToPascal((const char *) name,name);	pb.fileParam.ioNamePtr = name;	pb.fileParam.ioVRefNum = volNum;	pb.fileParam.ioDirID = refNum;	return PBHDeleteSync(&pb) == noErr;}int dir_Delimitor(void) {	return DELIMITOR;}int dir_Lookup(char *pathString, int pathStringLength, int index,  /* outputs: */  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile) {	/* Lookup the index-th entry of the directory with the given path, starting	   at the root of the file system. Set the name, name length, creation date,	   creation time, directory flag, and file size (if the entry is a file).	   Return:	0 	if a entry is found at the given index	   			1	if the directory has fewer than index entries	   			2	if the given path has bad syntax or does not reach a directory	*/	int okay, newRefNum, newVolNum;	HVolumeParam volumeParams;	CInfoPBRec dirParams;	/* default return values */	*name             = 0;	*nameLength       = 0;	*creationDate     = 0;	*modificationDate = 0;	*isDirectory      = false;	*sizeIfFile       = 0;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return NO_MORE_ENTRIES;	}	if ((pathStringLength == 0)) {		/* get volume info */		volumeParams.ioNamePtr = (unsigned char *) name;		volumeParams.ioVRefNum = 0;		volumeParams.ioVolIndex = index;		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);			*isDirectory      = true;			*sizeIfFile       = 0;			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	} else {		/* get file or directory info */		if (!!equalsLastPath(pathString, pathStringLength)) {			/* lookup and cache the refNum for this path */			okay = lookupPath(pathString, pathStringLength, &newRefNum, &newVolNum);			if (okay) {				recordPath(pathString, pathStringLength, newRefNum, newVolNum);			} else {				return BAD_PATH;			}		}		dirParams.hFileInfo.ioNamePtr = (unsigned char *) name;		dirParams.hFileInfo.ioFVersNum = 0;		dirParams.hFileInfo.ioFDirIndex = index;		if (lastRefNum < 0) {			dirParams.hFileInfo.ioVRefNum = lastRefNum;			dirParams.hFileInfo.ioDirID = 0;		} else {			dirParams.hFileInfo.ioVRefNum = lastVolNum;			dirParams.hFileInfo.ioDirID = lastRefNum;		}		okay = PBGetCatInfoSync(&dirParams) == noErr;		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);			if ((dirParams.hFileInfo.ioFlAttrib & 16) !!= 0) {				*isDirectory  = true;				*sizeIfFile   = 0;			} else {				*isDirectory  = false;				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;			}			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	}}dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Set the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */	Str255 name;	FInfo finderInfo;	int i;	/* copy file name into a Pascal string */	if (filenameSize > 255) return false;	name[0] = filenameSize;	for (i = 1; i <= filenameSize; i++) {		name[i] = filename[i - 1];	}	if (HGetFInfo(0,0,name,  &finderInfo) !!= noErr) return false;	finderInfo.fdType = *((int *) fType);	finderInfo.fdCreator = *((int *) fCreator);	if (HSetFInfo(0,0,name,  &finderInfo) !!= noErr) return false;	return true;}int equalsLastPath(char *pathString, int pathStringLength) {	/* Return true if the lastPath cache is valid and the	   given Squeak string equals it. */	int i, ch;	if (!!lastPathValid ||		(pathStringLength > MAX_PATH)) {			return false;	}	for (i = 0; i < pathStringLength; i++) {		ch = lastPath[i];		if ((ch == 0) || (ch !!= pathString[i])) return false;	}	return lastPath[i] == 0;}int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr) {	/* Look up the next directory in a path starting from the folder and volume	   with the given reference numbers and setting *refNumPtr to the reference	   number of the resulting folder. Return true if this succeeds. */	CInfoPBRec pb;	Str255 tempName;	CopyCStringToPascal((const char *) name,tempName);	pb.hFileInfo.ioNamePtr = tempName;	pb.hFileInfo.ioFVersNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioVRefNum = volRefNum;	pb.hFileInfo.ioDirID = folderRefNum;	if (PBGetCatInfoSync(&pb) == noErr) {		*refNumPtr = pb.hFileInfo.ioDirID;		return true;	}	return false;}int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr) {	/* Resolve the given path and return the resulting folder or volume	   reference number in *refNumPtr. Return false if the path is bad. */	char chunk[100];	int stIndex, chunkIndex, ch;	int okay, thisVolNum = 0, thisRefNum = 0;	int firstChunk = true, hasLeadingDelimitors = false;	stIndex = 0;	while (stIndex < pathStringLength) {		chunkIndex = 0;		while ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {			/* copy any leading delimitors */			chunk[chunkIndex++] = pathString[stIndex++];			hasLeadingDelimitors = true;		}		while ((stIndex < pathStringLength) && (pathString[stIndex] !!= DELIMITOR)) {			/* copy up to the next delimitor */			ch = chunk[chunkIndex++] = pathString[stIndex++];		}		if (firstChunk && (chunk[chunkIndex] !!= DELIMITOR)) {			/* Add a trailing delimiter to the first chunk of the			   path to indicate that it is a volume name. If the			   path starts with an initial delimitor, it will be			   interpreted as a path relative to the current working			   directory even with a trailing delimitor, which is			   exactly the behavior we want. */			chunk[chunkIndex++] = DELIMITOR;			if ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {				stIndex++;			}			firstChunk = false;		}		chunk[chunkIndex] = 0;  /* terminate this chunk */		if ((thisVolNum == 0) && !!hasLeadingDelimitors) {			okay = lookupVolume(chunk, &thisVolNum);			thisRefNum = 0;		} else {			okay = lookupDirectory(thisVolNum, thisRefNum, chunk, &thisRefNum);		}		if (!!okay) {			*refNumPtr = 0;			*volNumPtr = 0;			return false;		}	}	*refNumPtr = thisRefNum;	*volNumPtr = thisVolNum;	return true;}int lookupVolume(char *volName, int *refNumPtr) {	/* Look up the volume with the given name and set *refNumPtr	   to the reference number of the resulting volume.	   Return true if this succeeds. */	int okay;	HVolumeParam volumeParams;	Str255 tempVolName;	CopyCStringToPascal((const char *)volName,tempVolName);	volumeParams.ioNamePtr = (StringPtr) tempVolName;	volumeParams.ioVRefNum = 0;	volumeParams.ioVolIndex = -1;	okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;	if (okay) {		*refNumPtr = volumeParams.ioVRefNum;		return true;	}	return false;}int recordPath(char *pathString, int pathStringLength, int refNum, int volNum) {	/* Copy the given Squeak string into the lastPath cache. */	int i;	if (pathStringLength > MAX_PATH) {		lastPath[0] = 0; /* set to empty string */		lastPathValid = false;		lastRefNum = 0;		lastVolNum = 0;		return;	}	for (i = 0; i < pathStringLength; i++) {		lastPath[i] = pathString[i];	}	lastPath[i] = 0; /* string terminator */	lastPathValid = true;	lastRefNum = refNum;	lastVolNum = volNum;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 8/3/2000 15:03'!macJoystickAndTabletFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "JoystickTabletPlugin.h"/* initialize/shutdown */int joystickShutdown() {}/* End of adjustments for pluginized VM */#include <DeskBus.h>#include <Devices.h>#include <Timer.h>/* Joystick Record */#define MOUSESTICK_SIGNATURE 0x4A656666#define MAX_STICKS 4typedef struct {	short			rawX;				/* absolute stick position */	short			rawY;	unsigned char	buttons;	char			private1;	short			cursorX;			/* cursor position */	short			cursorY;	char			oldStickType;	char			private2;	char			stickOn;			/* true if stick is connected */	char			private3;	char			stickControlsCursor;	char			applicationAware;	/* settings change with application changes */	char			private4[152];} MouseStickRec;typedef struct {	long			signature;	char			private1[18];	short			stickCount;	char			private2[22];	MouseStickRec	stick[MAX_STICKS];} MouseStickSetRec, *MouseStickSetPtr;/* Tablet Record (see  Apple Tech. Note 266, version 2) */#define MAX_TRANSDUCERS 4typedef struct {    char	DOFTrans;			/* degrees of freedom and transducer type */    char	orientFlag;			/* type of orientation information */    short	pressLevels;		/* pressure support and number of levels */    unsigned short xScale;		/* x scale factor for screen mapping */    short	xTrans;				/* x translation factor for screen */    unsigned short yScale;		/* y scale factor for screen mapping */    short	yTrans;				/* y translation factor for screen */    unsigned char flags;		/* proximity, update flag, and # buttons */    unsigned char pressThresh;	/* pressure threshold - normally unused */    short	buttonMask;			/* button mask of driver-reserved buttons */    short	errorFlag;			/* error code generated */    short	buttons;			/* buttons pressed */    short	tangPress;			/* tangential pressure level */    short	pressure;			/* normal pressure level */    long	timeStamp;			/* ticks at latest update */    long	xCoord;				/* x coordinate in resolution units */    long	yCoord;				/* y coordinate in resolution units */    long	zCoord;				/* z coordinate in resolution units */    short	xTilt;				/* x tilt */    short	yTilt;				/* y tilt */    short	unused[8];			/* remainder of unused attitude matrix */} TransducerRec, *TransducerRecPtr;typedef struct {    char	version;			/* version of this data format */    char	semaphore;			/* for future use -- tells if drvr is enabled */    char	cursors;			/* number of cursors with tablet */    char	updateFlags;		/* flags used when updating structure */    short	angleRes;			/* metric bit & angular resolution */    short	spaceRes;			/* spatial resolution of the tablet */    long	xDimension;			/* x dimension in resolution units */    long	yDimension;			/* y dimension in resolution units */    long	zDimension;			/* z dimension in resolution units */    long	xDisplace;			/* x displacement - minimum x value */    long	yDisplace;			/* y displacement - minimum y value */    long	zDisplace;			/* z displacement - minimum z value */    long	reserved;			/* reserved */    long	tabletID;			/* contains ''TBLT'' identifying the device */	TransducerRec transducer[MAX_TRANSDUCERS];} TabletRec, *TabletRecPtr;/*** Variables ***/MouseStickSetPtr joySticks = nil;	/* pointer to a joystick set or nil */TabletRecPtr tablet = nil;  		/* pointer to a tablet record or nil */int joystickInit(void) {	/* If a joystick is plugged in and its control panel is installed,	   initialize the global pointer ''joySticks'' to the joystick set	   data structure. Otherwise, set it to nil.	*/#if TARGET_API_MAC_CARBON	joySticks = nil;  /* set to nil in case we don''t find any joysticks */	return false;#else	ADBDataBlock adbGetInfo;	MouseStickSetPtr sticks;	int count, i;	joySticks = nil;  /* set to nil in case we don''t find any joysticks */	count = CountADBs();	for (i = 1; i <= count; i++) {		GetADBInfo(&adbGetInfo, GetIndADB(&adbGetInfo, i));		sticks = (MouseStickSetPtr) adbGetInfo.dbDataAreaAddr;		if ((sticks !!= nil) && (sticks->signature == MOUSESTICK_SIGNATURE)) {			joySticks = sticks;			return true;		}	}	return true;#endif}int joystickRead(int stickIndex) {	/* Return input word for the joystick with the given index (in range [1..2]	   on the Macintosh; other platforms may vary). This word is encoded as follows:		<onFlag (1 bit)><buttonFlags (5 bits)><x-value (11 bits)><y-value (11 bits)>	   The highest four bits of the input word are zero. If the onFlag bit is zero,	   there is no joystick at the given index. This may be because no joystick	   is connected or the joystick control panel is not installed. In such,	   cases, the entire word will be zero. A maximum of two joysticks are supported	   by Gravis''s current version of the control panel. The x and y values are	   11-bit signed values in the range [-1024..1023] representing the raw (unencoded)	   joystick position. The MouseStick II only uses the approximate range [-650..650].	   The range and center values of poorly adjusted joysticks may vary; the client	   software should provide a way to adjust the center and scaling to correct.	*/	MouseStickRec stickData;	int buttons, xBits, yBits;	if ((joySticks == nil) || (stickIndex < 1) || (stickIndex > 2) ||		(stickIndex > joySticks->stickCount)) {			return 0;  /* no joystick at the given index */	}	stickData = joySticks->stick[stickIndex - 1];  /* 1-based index */	buttons = ~stickData.buttons & 0x1F;	xBits = (0x400 + stickData.rawX) & 0x7FF;	yBits = (0x400 + stickData.rawY) & 0x7FF;	return (1 << 27) | (buttons << 22) | (yBits << 11) | xBits;}int tabletInit(void);int tabletInit(void) {	/* Open the tablet driver and initialize the global pointer to its status	   record. Return true if a tablet exists, false otherwise. */#if TARGET_API_MAC_CARBON    return false;#else	CntrlParam	pb;	short		driverRefNum;	if (OpenDriver("\p.Wacom", &driverRefNum) !!= noErr) {		return false;	}	pb.ioCRefNum = driverRefNum;	pb.csCode = 20;  /* requests the address of the current tablet record */	if (PBStatusSync((ParmBlkPtr) (&pb)) !!= noErr) {		return false;	}	tablet = *((TabletRecPtr *) &pb.csParam);	return tablet->tabletID == 0x54424c54;  /* verify that id is ''TBLT'' */#endif }int tabletGetParameters(int cursorIndex, int result[]) {	/* Fill in the integer array ''result'' with tablet parameter information.	   For cursor-specific parameters, such as the number of pressure levels,	   return the information for the cursor with the given index, an integer	   between 1 and tablet->cursors. */	TransducerRecPtr cursorPtr;	int cursor;	/* open tablet if necessary; return false if no tablet */	if (tablet == nil) {		if (!!tabletInit()) return false;	}	cursor = cursorIndex - 1;	if ((cursor < 0)  || (cursor >= tablet->cursors)) {		return false;	}	cursorPtr = &tablet->transducer[cursor];	result[0] = tablet->xDimension;	result[1] = tablet->yDimension;	result[2] = tablet->spaceRes;	result[3] = tablet->cursors;  /* number of cursors */	result[4] = cursor + 1;	result[5] = cursorPtr->xScale;	result[6] = cursorPtr->xTrans;	result[7] = cursorPtr->yScale;	result[8] = cursorPtr->yTrans;	result[9] = cursorPtr->pressLevels;	result[10] = cursorPtr->pressThresh;	if (tablet->angleRes == 0) {		result[11] = 0;  /* no pen tilt support */	} else {		result[11] = tablet->angleRes >> 1;  /* number of pen tilt levels */	}	return true;}int tabletRead(int cursorIndex, int result[]) {	/* Fill in the integer array ''result'' with the current data	   the cursor with the given index, an integer between 1 and	   tablet->cursors. Note that the timestamp changes only	   when some new data has arrived from the tablet. */	TransducerRecPtr cursorPtr;	int cursor;	/* open tablet if necessary; return false if no tablet */	if (tablet == nil) {		if (!!tabletInit()) return false;	}	cursor = cursorIndex - 1;	if ((cursor < 0)  || (cursor >= tablet->cursors)) {		return false;	}	cursorPtr = &tablet->transducer[cursor];	result[0] = cursor + 1;	result[1] = cursorPtr->timeStamp;	result[2] = cursorPtr->xCoord;	result[3] = cursorPtr->yCoord;	result[4] = cursorPtr->zCoord;	result[5] = cursorPtr->xTilt;	result[6] = cursorPtr->yTilt;	result[7] = (cursorPtr->DOFTrans & 0x30) >> 4;  /* cursor type; 1-pen, 2-puck, 3-eraser */	result[8] = cursorPtr->buttons;	result[9] = cursorPtr->pressure;	result[10] = cursorPtr->tangPress;	result[11] = cursorPtr->flags;	return true;}int tabletResultSize(void) {	/* Return the size of the integer array required to hold the results of	   either a tabletGetParameters() or tabletRead() call. The VM allocates	   an array of this length and passes it as a parameter to be filled in. */	return 12;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 8/3/2000 15:04'!macNetworkFile	^ '#include <ConditionalMacros.h>#if TARGET_CPU_PPC#if TARGET_API_MAC_CARBON	#define OTCARBONAPPLICATION 1#endif#include <OpenTransport.h>#include <OpenTptInternet.h>#include <OpenTptClient.h>#include <stropts.h>#include <Gestalt.h>#include <TextUtils.h>#include <files.h>#if !!TARGET_API_MAC_CARBON    #ifndef NewOTNotifyUPP    	typedef struct OTConfiguration* OTConfigurationRef;    	#define OTNotifyUPP OTNotifyProcPtr     	#define NewOTNotifyUPP(userRoutine) userRoutine    	#define DisposeOTNotifyUPP(userRoutine)    #endif#endif#include "sq.h"#include "SocketPlugin.h"/*  May 1st 2000	An Open Transport 2.0 version of source code for TCP/IP & UDP support	Some of this the code was descended from Apple sample source written by: Eric Okholm	However getting it to work was done by	John M Mcintosh of Corporate Smalltalk Consulting Ltd	johnmci@smalltalkconsulting.com 	http://www.smalltalkconsulting.com 	In May of 2000 under contract to Disney		Some of the original source code was written by John Maloney of Disney thoughout the 1990''s		The basic intent was to make the code fully interrupt driven	No limits.... Well maybe we throttle read buffers to some parcel of memory to prevent us	from using all the memory on the box. Sends depend on lowerlayer buffering/flow control.	Testing from a 500Mhz PowerBook showed we could saturate a 100MB ethernet when sending data oneway.		UDP and TCP/IP are all supported.	Note for TCP we turn on two options IP_REUSEADDR, and IP_KEEPALIVE.	We do NOT handle T_EXDATA  data		V1.0 May 18th 2000, JMM (TCP/IP and UDP)	V1.1 May 19th 2000, JMM Cleanup	V1.2 may 20th 2000, JMM UDP free buffer cleanup, relook at resolver terminate to fix crash	V1.3 may 23rd 2000, JMM fix T_UDERR crash	V1.3.1 may 24th 2000, JMM UDP work	V1.3.2 may 25th 2000, JMM socket options work	V1.3.3 may 27th 2000, JMM rewrote resolver	V1.3.4 Jun 7th 2000, JMM some integration	V1.3.5 Jun 9th 2000, JMM Dan Ingalls found some interesting bugs with a T_GODATA on T_CONNECT.	V1.3.6 Jun 10th 2000, JMM fix a fatal but in close/close pattern I made on the 9th.	V1.3.7 Aug 1st 2000, JMM Some carbon work, reviewed open non-existent port logic fix so unavailable port causes immediate failure		Notes beware semaphore''s lurk for socket support. Three semaphores lives in Smalltalk, waiting for	connect/disconnect/listen, sending data, and receiving data. When to tap the semaphore is based on	inferences driven from the smalltalk code. We really need a call to tell us intent.		waitForDisconnectUntil:	    via closeAndDestroy: after primSocketCloseConnection:	    	waitForDataUntil:	    Usually before primitiveSocketReceiveDataBufCount: after checking SocketReceiveDataAvailable	    	waitForSendDoneUntil:	    via sendData: or sendSomeData:startIndex;count: before calls to primitiveSocketSendDataBufCount	    	waitForConnectionUntil:	    via waitForAcceptUntil and many places afer doing primitiveSocketConnectToPort*/								/*** Socket Type Constants ***/#define TCPSocketType 0#define UDPSocketType 1#define TCPListenerSocketType 2   //These are special to enable the right options for listening. Not Exposed to Smalltalk#define UDPListenerSocketType 3   //Very special not really linked to an EP structure.  Not Exposed to Smalltalk/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3#define RESOLVER_NAMETOADDR     4#define RESOLVER_ADDRTONAME     5/*** TCP Socket Status Constants ***/#define InvalidSocket           -1#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4	// Overall program statesenum{	kProgramRunning		= 1,	kProgramDone		= 2};	// Bit numbers in EPInfo stateFlags fieldsenum{	kOpenInProgressBit				= 0,  	kUnConnected    				= 1,	kWaitingForConnection           = 2,	kConnected                      = 3,	kSendIsBlocked                  = 4,    kOtherEndClosed                 = 5,    kThisEndClosed                  = 6,	kPassconBit                     = 7};	// Bit numbers in EPInfo stateFlags2 fieldsenum{	kFlushDisconnectInProgressBit	= 0,	kMakeEPIdle                     = 1,	kEPIsBroken                     = 2,	kReadFlowControl                = 3,	kPassconNeeded                  = 4,	kTapSemaphore                   = 5,	kTapSemaphoreReadData           = 6,	kTapSemaphoreWriteData          = 7};	// Bit numbers in EPInfo stateFlags3 fieldsenum{    kKeepAliveOptionNeeded          = 0,    kSleepKilledMe                  = 1}; enum{	kOTVersion111				= 0x01110000,	kOTVersion112				= 0x01120000,	kOTVersion113				= 0x01130000,	kOTVersion130				= 0x01300000};const kTCPKeepAliveInMinutes		= 10;		// 10 minutes  keep aliveconst kReadBuffersToAllocate	    = 50;		// Memory Allocation issue how big, this means 50x mtu size * 4 But for 68K we do 1/2 size	// Endpoint Info Structurestruct EPInfo{	EndpointRef		erf;				//	actual endpoint	OTLink			link;				//	link into an OT LIFO (atomic)	OTLink          globalLink;         //  link that follows all allocated EPs    SInt32          outstandingSends;   //  number of sends outstanding    OTList          readBuffers;        //  Read buffers    SInt32          bytesPendingToRead; //  bytes outstanding to read	SInt32			semaIndex;			//	semaphore index	SInt32          readSemaIndex;      //  read semaphore	SInt32          writeSemaIndex;     //  write semaphore	SInt32          UDPMaximumSize;     //  max size if a UDP endpoint	SInt32			lastError;          //  last error code	UInt8			stateFlags;			//	various status fields	UInt8			stateFlags2;		//	various status fields	UInt8			stateFlags3;		//	various status fields	UInt8           socketType;         //  type of socket, tcp, udp, or tcp/udp listener	InetAddress     localAddress;       //  local address at bind time (ignored used call to get current)	InetAddress     remoteAddress;      //  remote address at connect (ignored used call to get current)	Boolean         UDPMoreFlag;        //  UDP more of datagram flag set    };typedef struct EPInfo EPInfo;struct ReadBuffer                       // Structure to contain read data.{	OTLink			fNext;				//	link into an OT FIFO 	UInt32          readBufferSize;	UInt32			readBufferOriginalSize;  	char *          readBufferData;	char *          readBufferPtr;      //Sliding pointer used to partial read buffer.    InetAddress     UDPAddress;         //UDP address	Boolean         UDPMoreFlag;        //UDP more of datagram flag set};typedef struct ReadBuffer ReadBuffer;struct TKeepAliveOpt                    {	UInt32		len;	OTXTILevel	level;	OTXTIName	name;	UInt32		status;	UInt32		tcpKeepAliveOn;	UInt32		tcpKeepAliveTimer;};typedef struct TKeepAliveOpt TKeepAliveOpt;struct TLingerOpt                    {	UInt32		len;	OTXTILevel	level;	OTXTIName	name;	UInt32		status;	UInt32		tcpLingerOn;	UInt32		tcpLingerTimer;};typedef struct TLingerOpt TLingerOpt;/*** Variables ***/extern struct VirtualMachine *interpreterProxy;EPInfo*				gDNSResolver;               //Our resolverSInt32				gDNSResolverStatus 			= RESOLVER_UNINITIALIZED;SInt32				gDNSResolverError			= noErr;SInt32			    gDNSResolverSemaIndex;      //This gets changed at startup time.InetHostInfo		gDNSHostInfo;InetDomainName 		gDNSAddrStr;                //Length of domain names? Old code was 512, but specs say 256.InetHost			gDNSAddr;SInt32              gDNSLookupType;OTConfigurationRef	gCfgMastertcp				= NULL;OTConfigurationRef	gCfgMasterudp				= NULL;OTConfigurationRef	gCfgMasterListener			= NULL;OTLIFO				gFreeReadBuffersLIFO;    	//  Buffers that are free to read intoOTLIFO*				gFreeReadBuffers			= &gFreeReadBuffersLIFO;UInt32				gmtuSize 					= 1024; //This gets changed at startup time.SInt32				gthisNetSession 			= 0;    //This gets changed at startup time.SInt32				gMaxConnections				= 0;    //This gets changed at startup time.UInt32				gOTVersion;                         //Gets set to OT version, to help us with special cases.SInt32				gProgramState				= 0;    //This gets changed at startup time.OTLIFO				gIdleEPLIFO[3];OTLIFO*				gIdleEPs[3];SInt32              gIdleEPCounter[3];OTLIFO				gBrokenEPLIFO;OTLIFO*				gBrokenEPs					= &gBrokenEPLIFO;OTLIFO				gAllEPLIFO;OTLIFO*				gAllEPs					    = &gAllEPLIFO;OTNotifyUPP DNSNotifierUPP,NotifierSocketUPP,NotifierSocketUDPUPP,NotifierSocketListenerUPP;/*** Private TCP Socket Functions ***//*** Private Resolver Functions ***/static void 		ResolverInitialize();static void		    ResolverTerminate(void);static void 		ResolverStart ();/*** Other Private Functions ***/void               CFMTerminate (void);static Boolean	   DestroyAllOpenSockets(void);static Boolean	   SocketValid(SocketPtr s);static Boolean     PortNumberValid(InetPort port) ;static SInt32      unmapStatus(EPInfo *);static void        Recycle();static void        makeEPIdle(EPInfo *epi);static void        purgeReadBuffers(EPInfo *epi);static void        makeEPBrokenThenIdle(EPInfo* epi,OTResult error);static void        makeEPBroken(EPInfo* epi,OTResult error);static EPInfo*     getOrMakeMeAnEP(UInt8 aSocketType);static Boolean     makeMeAnEP(UInt8 aSocketType);static void        attemptToCloseAndDeleteThisEP (EPInfo *epi);static void		   makeEPUnconnected(EPInfo* epi);static void        SetEPLastError(EPInfo* epi,OTResult error);static void        TapAllInterestedSemaphores(EPInfo *epi);int 				socketInit(void);int 				socketShutdown(void);static pascal void  DNSNotifier(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocket(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocketUDP(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocketListener(void* context, OTEventCode event, OTResult result, void* cookie);static void         internalSocketCreate(SocketPtr s, SInt32 netType, SInt32  socketType, SInt32 recvBufSize, SInt32 sendBufSize, SInt32 semaIndex, SInt32 readSemaIndex, SInt32 writeSemaIndex, UInt8 aExtraSocketHint);static Boolean		EPOpen(EPInfo* epi);static Boolean 		EPClose(EPInfo*);static void         DoListenAccept(EPInfo* acceptor,EPInfo* theServer);static void         DoConnect(EPInfo* epi,InetHost addr, InetPort port);static void         DoBind(EPInfo* epi,InetHost addr, InetPort port,UInt8 aExtraSocketHint, OTQLen queueDepth );static UInt32       ReadData(EPInfo* epi, char* specialBuffer, UInt32 specialBufferSize);static OTResult     SendData(EPInfo* epi, char* buffer, UInt32 size);static OSStatus     doAbortConnection(EPInfo* epi);static void         NoCopyReceiveWalkingBufferChain(EPInfo *epi,OTBufferInfo *bufferInfo);static UInt32       readBytes(EPInfo* epi,char *buf,UInt32 adjustedBufSize);static UInt32       readBytesUDP(EPInfo* epi,InetAddress *fromAddress, int *moreFlag, char *buf,UInt32 adjustedBufSize);static SInt32	    lookupOptionName(EPInfo *epi, Boolean trueIfGet, char *aString, UInt32 value, SInt32 *result);static OTResult     SetFourByteOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetOneByteOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetKeepAliveOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetLingerOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);// Some diagnostic routinesvoid JMMLogMessage(Str255 input);void JMMLogMessageAndNumber(Str255 msg,long number);void JMMWriteLog();/*** Network Functions ***/int socketInit() {	//	//Don''t actually do any network work until we are newworked initialized	//This prevents kicking off internet dialup connections until needed	//	return true;}int socketShutdown() {	CFMTerminate();	return true;}int sqNetworkInit(int resolverSemaIndex) {	//	//  Initialize the network and return 0 if successful	//  Loads Open transport, allocates memory for read buffers and various other tasks	//		SInt32              i;	OSStatus            err = noErr;	InetInterfaceInfo   interfaceInformation;	UInt8               aSocketType;    ReadBuffer          *readBufferObject;    long				check68KorPPC;	    	if (gthisNetSession !!= 0) return 0;  /* noop if network is already initialized */		err = InitOpenTransport(); 	if (err) {		return -1;	}			err = Gestalt(gestaltOpenTptVersions, (long*) &gOTVersion);		if (err || (gOTVersion < kOTVersion112))	{		// Please install Open Transport 1.1.2 or later		// This might change to 1.3 since tech notes talked about 		// previous versions having problems with acksend logic.		//		return -111;	}		err = Gestalt(gestaltSysArchitecture, (long*) &check68KorPPC);	gProgramState = kProgramRunning;    //     //Setup the head of the idle queues    //    	for (i=0;i<3;i++) {	    gIdleEPs[i] = &gIdleEPLIFO[i];	    gIdleEPs[i]->fHead	   = NULL;	    gIdleEPCounter[i]      = 0;	}	gBrokenEPs->fHead 		= NULL;	gFreeReadBuffers->fHead = NULL;	gAllEPs->fHead          = NULL;			gMaxConnections			= 24; // Build 8 of each of listeners, tcp, udp.	    DNSNotifierUPP = NewOTNotifyUPP(DNSNotifier);    NotifierSocketUPP = NewOTNotifyUPP(NotifierSocket);    NotifierSocketUDPUPP = NewOTNotifyUPP(NotifierSocketUDP);    NotifierSocketListenerUPP = NewOTNotifyUPP(NotifierSocketListener);		gDNSResolver = (EPInfo*) OTAllocMem(sizeof(EPInfo));	if (gDNSResolver == NULL) return -1;			gDNSResolverSemaIndex = resolverSemaIndex;	ResolverInitialize();		/* Get MTU and default selected host address */		OTInetGetInterfaceInfo (&interfaceInformation,kDefaultInetInterface);    gmtuSize = interfaceInformation.fIfMTU;    		//	//	Open endpoints 	//	gCfgMastertcp = OTCreateConfiguration(kTCPName);	if (gCfgMastertcp == NULL) return -3;		gCfgMasterudp = OTCreateConfiguration(kUDPName);	if (gCfgMasterudp == NULL) return -4;		gCfgMasterListener = OTCreateConfiguration("tilisten, tcp"); //Note use of special tilisten logic	if (gCfgMasterListener == NULL) return -5;		//	//Build all our EPs, lots of work happens lower down asyncronously	//	aSocketType = TCPSocketType;	for (i = 0; i < gMaxConnections; i++)	{		makeMeAnEP(aSocketType);		aSocketType = ++aSocketType > 2 ? TCPSocketType : aSocketType;	} 		//	//Build storage objects for read buffers	//How much memory to allocate still is a mystery	//    for (i=0;i<kReadBuffersToAllocate ;i++) {         readBufferObject = OTAllocMem(sizeof(ReadBuffer));        if (readBufferObject == nil) {       	    interpreterProxy->success(false);            return -25;        }                 OTMemzero(readBufferObject,sizeof(ReadBuffer));        if (gestalt68k == check68KorPPC)         	readBufferObject->readBufferOriginalSize = (gmtuSize > 0) ? gmtuSize*2 : 1024;        else        	readBufferObject->readBufferOriginalSize = (gmtuSize > 0) ? gmtuSize*4 : 1024;                readBufferObject->readBufferData = readBufferObject->readBufferPtr = OTAllocMem(readBufferObject->readBufferOriginalSize);        if ( readBufferObject->readBufferData == nil) {       	    interpreterProxy->success(false);            return -25;        }        OTLIFOEnqueue(gFreeReadBuffers, &readBufferObject->fNext);    }	/* Success!! Create a session ID that is unlikely to be	   repeated. Zero is never used for a valid session number.	*/	gthisNetSession = clock() + time(NULL);	if (gthisNetSession == 0) gthisNetSession = 1;  /* don''t use 0 */		return 0;}void CFMTerminate (void)    /* termination either via a CFM or Squeak call*/{     sqNetworkShutdown();}void sqNetworkShutdown(void) {	/* shut down the network */    	if (gthisNetSession == 0) return;  /* noop if network is already shut down */	gthisNetSession = 0;	gProgramState = kProgramDone;	DestroyAllOpenSockets();	CloseOpenTransport(); }/*** Resolver Functions ***/static void	ResolverInitialize() {	OSStatus err;		//	//	Prepare to open internet services	//  to invoke DNR services	//		OTMemzero(gDNSResolver, sizeof(EPInfo));	    gDNSResolver->erf = OTOpenInternetServices(kDefaultInternetServicesPath, 0, &err);    gDNSResolver->semaIndex = gDNSResolverSemaIndex;		if (err !!= kOTNoError) {		gDNSResolverStatus = RESOLVER_ERROR;		gDNSResolverError = err;		return;	}	gDNSResolverStatus = RESOLVER_SUCCESS;	gDNSResolverError = kOTNoError;    err =  OTSetAsynchronous(gDNSResolver->erf);    err =  OTSetNonBlocking(gDNSResolver->erf);    err =  OTInstallNotifier(gDNSResolver->erf, DNSNotifierUPP, gDNSResolver);}static void ResolverStart () {	OSStatus err;	//	// Invoke DNR service Async, this meants the DNSNotifier will handle the actual 	// lookup and work, flags like the gDNSResolverStatus are used to indicate back	// to Squeak when the work is done	//	if (gDNSResolver->erf == NULL) //Sleep fix, other endpoints are more explicit about this issue. 	    ResolverInitialize();	    	gDNSResolverStatus  = RESOLVER_BUSY;	switch (gDNSLookupType) {		case RESOLVER_NAMETOADDR: {		    err = OTInetStringToAddress((InetSvcRef)gDNSResolver->erf, gDNSAddrStr, &gDNSHostInfo);			break;		}		case RESOLVER_ADDRTONAME: {			err = OTInetAddressToName((InetSvcRef)gDNSResolver->erf, gDNSAddr, gDNSAddrStr);			break;		}    }	if (err !!= kOTNoError)  {		gDNSResolverStatus = RESOLVER_ERROR;		gDNSResolverError = err;	}}void ResolverTerminate(void) {    //JMM if the resolver is opening what happens? 	gDNSResolverStatus = RESOLVER_UNINITIALIZED;   	if (gDNSResolver->erf == NULL) return;	EPClose(gDNSResolver);	OTMemzero(gDNSResolver, sizeof(EPInfo));}void sqResolverAbort(void) {	//	// Abort this running resolver request	//	if (gDNSResolverStatus == RESOLVER_BUSY) {		ResolverTerminate();		ResolverInitialize();	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	//	// copy the name found by the last address lookup into the given string 	//		OTMemcpy(nameForAddress, gDNSAddrStr, (UInt32) nameSize);	}int sqResolverAddrLookupResultSize(void) {	//	// return the length of the looked up name	//	return (long) strlen(gDNSAddrStr);}int sqResolverError(void) {	//	// Return OT error number	//	return gDNSResolverError; }int sqResolverLocalAddress(void) {    //    // Watch out for dynamic changing of this information, so don''t cache    //	InetInterfaceInfo interfaceInformation;	OTInetGetInterfaceInfo (&interfaceInformation,kDefaultInetInterface);	gDNSResolverStatus = RESOLVER_SUCCESS;	gDNSResolverError  = noErr;	return (long) interfaceInformation.fAddress;}int sqResolverNameLookupResult(void) {	//	// Return address from last lookup	//    	return (int) gDNSAddr;}void sqResolverStartAddrLookup(int address) {	//	// start process to lookup name from address	//    	if (gDNSResolverStatus == RESOLVER_BUSY) return;	gDNSAddr            = (InetHost) address;    gDNSLookupType      = RESOLVER_ADDRTONAME;	ResolverStart();}void sqResolverStartNameLookup(char *hostName, int nameSize) {	//	// start process to lookup address from name	//    	UInt32 len; 	if (gDNSResolverStatus == RESOLVER_BUSY) return;	len = (UInt32) ((nameSize <= kMaxHostNameLen) ? nameSize : kMaxHostNameLen);  //Old limit was 500  but that appeared to be wrong	OTMemcpy(gDNSAddrStr, hostName, len);	gDNSAddrStr[len]    = ''\0'';    gDNSLookupType      = RESOLVER_NAMETOADDR;	ResolverStart();	}int sqResolverStatus(void) {	//	// return resolver status, this is different from resolver error code	// status is the same among implementations, error is implementation dependent	//    	return gDNSResolverStatus;}//================================// Socket logic //void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {				//	//Old call from old image using new VM	//Just make new call	//	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  		 s,  netType,  socketType, recvBufSize,  sendBufSize,  semaIndex,  semaIndex,  semaIndex);}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex)	{    netType; recvBufSize; sendBufSize;    //    //Create a socket given the supplied information    //We don''t bind the socket to a local port  until     //we do the connection. This of course could change?     //        internalSocketCreate( s, netType, socketType, recvBufSize,  sendBufSize, semaIndex, readSemaIndex, writeSemaIndex, (UInt8) socketType);}static void internalSocketCreate(  SocketPtr s, SInt32 netType, SInt32 socketType,  SInt32 recvBufSize, SInt32 sendBufSize, SInt32 semaIndex, SInt32 readSemaIndex, SInt32 writeSemaIndex, UInt8 aExtraSocketHint)	{  //  // Internal logic to open a socket for a connection or to listen  // Note how we ignore buffer sizes!!  //    EPInfo*     epi;    socketType; netType; recvBufSize; sendBufSize;        //    //Make the socket invalid and then get an idle EP    //Technically we only run out of EP when we run out of memory    //    	s->sessionID = 0;	if (gProgramState !!= kProgramRunning ) {			    interpreterProxy->success(false);        return;    }	epi = getOrMakeMeAnEP(aExtraSocketHint);	if (epi == NULL) {		interpreterProxy->success(false);		return;	}	epi->outstandingSends   = 0;	epi->bytesPendingToRead = 0;	epi->semaIndex          = semaIndex;	epi->readSemaIndex      = readSemaIndex;	epi->writeSemaIndex     = writeSemaIndex;	epi->stateFlags         = 0;	epi->stateFlags2        = 0;	epi->stateFlags3        = 0;	SetEPLastError(epi,noErr);	epi->socketType        = aExtraSocketHint;	OTInitInetAddress(&epi->remoteAddress, 0, 0);    OTInitInetAddress(&epi->localAddress, 0, 0);        if (aExtraSocketHint == UDPSocketType)        OTAtomicSetBit(&epi->stateFlags, kConnected); //udp is always connected     else        OTAtomicSetBit(&epi->stateFlags, kUnConnected);  	s->sessionID            = gthisNetSession;	s->socketType           = (aExtraSocketHint == UDPSocketType) ? UDPSocketType : TCPSocketType;	s->privateSocketPtr     = epi;}void sqSocketListenOnPort(SocketPtr s, int port) {    //    //Listen on port for a connection, this is not the approved method    //sqSocketListenOnPortBacklogSize is the best way if you are a server    //However this works ok for UDP and kinda for onetime connections in TCP    //    EPInfo* epi;	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	epi = (EPInfo *) s->privateSocketPtr;	if (s->socketType == TCPSocketType) {		DoBind(epi,0,(InetPort) port,TCPListenerSocketType,1);		if (epi->localAddress.fPort !!= port) {//We die if we don''t get the port we want            sqSocketDestroy(s);    	    interpreterProxy->success(false);		}	} else {//udp		DoBind(epi,0,(InetPort) port,UDPListenerSocketType,1);	}}void	sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize) {    EPInfo* epi;	SInt32 sema,readSema,writeSema;    //    //Listen on port for a connection, this is the best method if you are    //a server. Works in conjunction with accept. Shouldn''t drop connections    //OT''s special listener logic queues up the listen requestions    //	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	if (s->socketType == TCPSocketType) {		epi = (EPInfo *) s->privateSocketPtr;		sema = epi->semaIndex; readSema = epi->readSemaIndex; writeSema = epi->writeSemaIndex;	    makeEPIdle(epi); //Special case really need a listener EP, so put this EP back on the queue	    				 //This may seem odd but the epi is allocated before we know what type it is.	    				 //Would need to change Squeak to indicate type at creation!!		internalSocketCreate( s, 0, TCPSocketType, 0,  0, sema, readSema, writeSema, TCPListenerSocketType);		epi = (EPInfo *) s->privateSocketPtr;		DoBind(epi,0,(InetPort) port,TCPListenerSocketType,(OTQLen) backlogSize);		if (epi->localAddress.fPort !!= port) {//The port we wanted must match, otherwise we die		    sqSocketDestroy(s);    	    interpreterProxy->success(false);		}	} else {//udp not allowed       	    interpreterProxy->success(false);	}}void	sqSocketAcceptFromRecvBytesSendBytesSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex){	//	//Old call from old image using new VM	//Just make new call	//	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			 s,  serverSocket,  recvBufSize,  sendBufSize,  semaIndex,  semaIndex,  semaIndex);		}void	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {	//	//Accept incoming request from a listener	//We take information from the listener, create a new socket	//and accept the incoming call	//	    EPInfo* epiSocket;    EPInfo* epiServerSocket;    Boolean	doLeave;	if (!!SocketValid(serverSocket)) return;	if (serverSocket->socketType == TCPSocketType) {            internalSocketCreate( s, 0, TCPSocketType, recvBufSize,  sendBufSize, semaIndex, readSemaIndex, writeSemaIndex, TCPSocketType);		    epiSocket = (EPInfo *) s->privateSocketPtr;    		DoBind(epiSocket,0,0,TCPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE		    OTAtomicSetBit(&epiSocket->stateFlags2, kPassconNeeded);		    epiServerSocket = (EPInfo *) serverSocket->privateSocketPtr;			OTAtomicSetBit(&epiServerSocket->stateFlags, kWaitingForConnection);			OTAtomicSetBit(&epiServerSocket->stateFlags, kUnConnected);            OTAtomicClearBit(&epiServerSocket->stateFlags, kConnected);    	    OTAtomicSetBit(&epiServerSocket->stateFlags2, kTapSemaphore);        	        	doLeave = OTEnterNotifier(epiServerSocket->erf);        	DoListenAccept(epiSocket,epiServerSocket);        	if (doLeave)        		OTLeaveNotifier(epiServerSocket->erf);	} else { //udp		interpreterProxy->success(false); 	}}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {    //    //Connect this socket to the given host addr and port    //    EPInfo* epi;	OTResult	epState;	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	epi = (EPInfo *) s->privateSocketPtr;	if (s->socketType == TCPSocketType) {    	DoBind(epi,(InetHost) addr,(InetPort) port,TCPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE which drives T_CONNECT/DoConnect	} else {//udp		epState = OTGetEndpointState(epi->erf);		if (epState == T_UNBND) {//Bind to remote, our side gets wildcarded    	    DoBind(epi,(InetHost) addr,(InetPort) port,UDPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE which drives T_CONNECT/DoConnect    	} else {//Already bound to a port/interface on our side    	    OTInitInetAddress(&epi->remoteAddress, (InetPort) port, (InetHost) addr);    	}	}}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	//	// Send data really fast	// We create a copy of the data and give it to OT to play with	// We can get flow controlled lower down, if no flow control then we	// tap the semiphore since from squeaks viewpoint data is sent, otherwise when flow control is lifted the	// semaphore is tapped in the notification routine	//	OTResult res ;    EPInfo* epi;    Boolean doLeave;    char * buffer; 	UInt32 adjustedBufSize = bufSize > 65536 ? 65536 : (UInt32) bufSize; //? Not sure if we really need to do this limiting.   		if (!!SocketValid(s)) return -1;		epi = (EPInfo *) s->privateSocketPtr;		// If send is blocked wait for unblocking	if (OTAtomicTestBit(&epi->stateFlags, kSendIsBlocked)) {	    return 0;	}    if (epi->socketType == UDPSocketType) {        //UDP adjust the buffer size again        adjustedBufSize = (adjustedBufSize > epi->UDPMaximumSize) ?   epi->UDPMaximumSize : adjustedBufSize;     }	buffer = OTAllocMem(adjustedBufSize);	if (buffer == nil) {		//Well maybe we back off and wait awhile? 		//If we run out of memory and stress the box, well death lurks.		adjustedBufSize = 256;		buffer = OTAllocMem(adjustedBufSize);		if (buffer == nil) {		    interpreterProxy->success(false); //Death did lurk	        SetEPLastError(epi, -1);	        return -1;	    } 	}			OTMemcpy(buffer,(void*) buf,adjustedBufSize);    	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_GODATA    res = SendData(epi,buffer,adjustedBufSize);  	  	if (doLeave)		OTLeaveNotifier(epi->erf);		  	if (res < 0 ){	    SetEPLastError(epi, res);		interpreterProxy->success(false); //JMM just for testing	    return 0;	}	return res;}////New primitive for sending UDP data to a particular host/port//Avoids race conditions between binding and send in Smalltalk//int sqSockettoHostportSendDataBufCount(SocketPtr s, int address, int port, int buf, int bufSize) { sqSocketConnectToPort(s, address, port); return sqSocketSendDataBufCount(s, buf, bufSize);}////Abort the socket//void sqSocketAbortConnection(SocketPtr s) {    EPInfo* epi;   OSStatus err; 	if (!!SocketValid(s)) return;    if (s->socketType == UDPSocketType) {		interpreterProxy->success(false);         return;    }	epi = (EPInfo *) s->privateSocketPtr;	err = doAbortConnection(epi);}////Acutal abort logic//We need to flush the queues//Then do a disconnect//static OSStatus doAbortConnection(EPInfo* epi) {   SInt32		count = 0;   OSStatus     err = kOTNoError; 	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 ) {		//Do flush and wait for it to happen		//Should make sync?		//		if (epi->outstandingSends !!= 0) {		    err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);		    while (count++ < 100 && (epi->outstandingSends !!= 0 || OTAtomicTestBit(&epi->stateFlags, kUnConnected) == false)) {			    OTIdle();            }	    }        makeEPBroken(epi,0);	    err = OTSndDisconnect(epi->erf, NULL);	}	    	if (err !!= kOTNoError) 	    return err;	else        return epi->lastError;}////Socket close logic//void sqSocketCloseConnection(SocketPtr s) {    EPInfo* epi;    OSStatus err; 	OTResult	epState;	OTResult	lookResult;    	if (!!SocketValid(s)) return;	epi = (EPInfo *) s->privateSocketPtr;    if (s->socketType == UDPSocketType) {//Handle udp and return        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);        OTAtomicClearBit(&epi->stateFlags, kConnected);        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);        OTAtomicSetBit(&epi->stateFlags, kUnConnected);        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);		err = OTUnbind(epi->erf);		if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.		    makeEPBroken(epi,err);		}	    TapAllInterestedSemaphores(epi);	    return;    }    OTAtomicSetBit(&epi->stateFlags, kThisEndClosed);    OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);	// old code is sync and doesn''t trigger semaphore 		epState = OTGetEndpointState(epi->erf);	if (epState == T_UNINIT || epState == T_UNBND ) {        OTAtomicSetBit(&epi->stateFlags, kThisEndClosed);        OTAtomicClearBit(&epi->stateFlags, kConnected);        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed); 	    TapAllInterestedSemaphores(epi);	    return;	}	else	    err = OTSndOrderlyDisconnect(epi->erf);	    	if (err == kOTNoError) {        if (OTAtomicTestBit(&epi->stateFlags, kOtherEndClosed)) {	        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);	        OTAtomicClearBit(&epi->stateFlags, kConnected);	        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);	        OTAtomicSetBit(&epi->stateFlags, kUnConnected);	        if (epi->outstandingSends !!= 0)	            doAbortConnection(epi);			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.			    makeEPBroken(epi,err);			}    	    TapAllInterestedSemaphores(epi);        }	} else {// Could get kOTLookErr with T_DISCONNECT pending 		lookResult = OTLook(epi->erf); 		if (err == kOTLookErr && lookResult == T_DISCONNECT) {        	err = OTRcvDisconnect(epi->erf, NULL);	        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);	        OTAtomicClearBit(&epi->stateFlags, kConnected);	        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);	        OTAtomicSetBit(&epi->stateFlags, kUnConnected);	        if (epi->outstandingSends !!= 0)	            doAbortConnection(epi);			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.			    makeEPBroken(epi,err);			}    	    TapAllInterestedSemaphores(epi);        }        else {            SetEPLastError(epi,err);    		makeEPBroken(epi,err);            TapAllInterestedSemaphores(epi);       }	}}////Destroy the socket here we must ensure we cleanup and put the //socket back on the idle or broken EP queue//void sqSocketDestroy(SocketPtr s) {    OTResult err;    EPInfo* epi;	OTResult	epState;    JMMWriteLog(); //Diagnostics, turned off, must fiddle recompile to turn on.        if (!!SocketValid(s)) return; 	epi = (EPInfo *) s->privateSocketPtr;    OTAtomicSetBit(&epi->stateFlags2, kMakeEPIdle); 	epState = OTGetEndpointState(epi->erf);	if (epState == T_UNINIT || epState == T_UNBND ) {	    makeEPIdle(epi); //Unbound already so make him idle.	} else {	    if (s->socketType == UDPSocketType)			err = OTUnbind(epi->erf);	    else 		    err = doAbortConnection(epi);			if (err !!= kOTNoError) {//kOTLookErr with T_DATA, book says response is to zap EP.		    makeEPBrokenThenIdle(epi,err);		}	}	s->sessionID = 0;	s->socketType = -1;	s->privateSocketPtr = nil;}////Check to see if bytes are available//int sqSocketReceiveDataAvailable(SocketPtr s)							{    EPInfo* epi;    static lastTickCount=0;	if (!!SocketValid(s)) return 0;    epi = (EPInfo *) s->privateSocketPtr;    if (epi->bytesPendingToRead > 0)         return 1;       if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) // New case if data pending but flow controlled then go get it        return 1;        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphoreReadData); //Note how we imply there will be interest in semaphore    return 0;}////Read data into the buffer supplied//int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {    EPInfo* epi; 	UInt32  bytesRead = 0;    Boolean doLeave;    	if (!!SocketValid(s)) return -1; 		epi = (EPInfo *) s->privateSocketPtr;         	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_DATA    bytesRead = readBytes(epi,(char *) buf,(UInt32) bufSize);    if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) {        if (bytesRead > 0)             ReadData(epi,NULL,0);         else            bytesRead = ReadData(epi,(char *) buf,(UInt32) bufSize); //special case attempt read into squeak buffer    }  	if (doLeave)		OTLeaveNotifier(epi->erf);   	return (int) bytesRead;}////New primitive to read UDP data and get data, host/port, and more flag//int sqSocketReceiveUDPDataBufCountaddressportmoreFlag(SocketPtr s, int buf, int bufSize,  int *address,  int *port, int *moreFlag) {    EPInfo* epi; 	UInt32 bytesRead = 0;    Boolean doLeave;    InetAddress fromAddress;        OTMemzero(&fromAddress,sizeof(InetAddress));    *address  = 0;    *port = 0;    *moreFlag = 0;    	if (!!SocketValid(s)) return -1;		epi = (EPInfo *) s->privateSocketPtr;         	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_DATA    bytesRead   = readBytesUDP(epi,&fromAddress, moreFlag, (char *) buf,(UInt32) bufSize);    *address    = fromAddress.fHost;    *port       = fromAddress.fPort;    if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) {         if (bytesRead > 0)             ReadData(epi,NULL,0);         else {            bytesRead = ReadData(epi,(char *) buf,(UInt32) bufSize);//special case attempt read into squeak buffer            *address    = epi->remoteAddress.fHost; //Also we happen to know the address just when into this area            *port       = epi->remoteAddress.fPort; //JMM more flag?            *moreFlag   = epi->UDPMoreFlag;        }    }  	if (doLeave)		OTLeaveNotifier(epi->erf);   	return (int) bytesRead;}int sqSocketLocalAddress(SocketPtr s) {    EPInfo* epi;    	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;    return (int) (epi->localAddress.fHost == 0) ? sqResolverLocalAddress() : epi->localAddress.fHost;}int sqSocketLocalPort(SocketPtr s) {    EPInfo* epi;    	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;		return epi->localAddress.fPort;}int sqSocketRemoteAddress(SocketPtr s) {    EPInfo*     epi;    TBind       remoteBind;    InetAddress remoteAddr;    SInt32        counter=0;    OSStatus    err;	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;	if (OTAtomicTestBit(&epi->stateFlags, kUnConnected) && 	    !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)) return 0;	    if (epi->socketType == UDPSocketType) {        return (int) epi->remoteAddress.fHost;    }        //It seems the only reliable way to get the address    //Is to make a call    //    OTMemzero(&remoteBind,sizeof(TBind));    OTMemzero(&remoteAddr,sizeof(InetAddress));    remoteBind.addr.buf = (UInt8 *) &remoteAddr;    remoteBind.addr.maxlen = sizeof(InetAddress);    err = OTGetProtAddress(epi->erf,0,&remoteBind);    while (counter++ < 10 && remoteAddr.fHost == 0) {        OTIdle();    }        if (err !!= kOTNoError)         return 0;    else        return (int) remoteAddr.fHost;}int sqSocketRemotePort(SocketPtr s) {    EPInfo* epi;    TBind       remoteBind;    InetAddress remoteAddr;    SInt32        counter=0;    OSStatus    err;	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;	if (OTAtomicTestBit(&epi->stateFlags, kUnConnected) && 	    !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)) return 0;	    if (epi->socketType == UDPSocketType) {        return epi->remoteAddress.fPort;    }        //It seems the only reliable way to get the port    //Is to make a call    //    OTMemzero(&remoteBind,sizeof(TBind));    OTMemzero(&remoteAddr,sizeof(InetAddress));    remoteBind.addr.buf = (UInt8 *) &remoteAddr;    remoteBind.addr.maxlen = sizeof(InetAddress);    err = OTGetProtAddress(epi->erf,0,&remoteBind);    while (counter++ < 10 && remoteAddr.fHost == 0) {        OTIdle();    }        if (err !!= kOTNoError)         return 0;    else        return remoteAddr.fPort;}int sqSocketSendDone(SocketPtr s) {    EPInfo* epi;	if (!!SocketValid(s)) return 1;	epi = (EPInfo *) s->privateSocketPtr;    if (OTAtomicTestBit(&epi->stateFlags, kSendIsBlocked)) {	    OTAtomicSetBit(&epi->stateFlags2, kTapSemaphoreWriteData); //Note the implied intent to use the semaphore        return 0;    }    else {        return 1;    }}int sqSocketError(SocketPtr s) {    EPInfo* epi;     	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;    if (OTAtomicTestBit(&epi->stateFlags, kUnConnected)  &&         !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)         && epi->lastError == 0)	    return kENOTCONNErr; // old code would return unconnectederror if unconnected	else	    return (epi->lastError);}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return InvalidSocket;	return unmapStatus((EPInfo *) s->privateSocketPtr);}static SInt32 unmapStatus(EPInfo *s) {    if (OTAtomicTestBit(&s->stateFlags3, kSleepKilledMe))         {return  InvalidSocket;        }    if (OTAtomicTestBit(&s->stateFlags, kThisEndClosed))         {return  ThisEndClosed;        }    if (OTAtomicTestBit(&s->stateFlags, kOtherEndClosed))         {return  OtherEndClosed;        }    if (OTAtomicTestBit(&s->stateFlags, kConnected))         { return  Connected;        }    if (OTAtomicTestBit(&s->stateFlags, kWaitingForConnection))         {return  WaitingForConnection;        }    if (OTAtomicTestBit(&s->stateFlags, kUnConnected))         {return  Unconnected;        }   return 0;}static Boolean SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == gthisNetSession) && 		(s->socketType == TCPSocketType || s->socketType == UDPSocketType) &&		(!!OTAtomicTestBit(&(((EPInfo *)s->privateSocketPtr)->stateFlags3), kSleepKilledMe)) )		    return true;	interpreterProxy->success(false);	return false;}static Boolean PortNumberValid(InetPort port) {	if (port <= 65535) {		return true;	}	interpreterProxy->success(false);	return false;}//Used to signal all semaphores when we''ve closed the socket//I guess the read/write/disconnect threads really want to know//static void TapAllInterestedSemaphores(EPInfo *epi) {    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);     if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreReadData)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->readSemaIndex);     if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex); 				}static Boolean DestroyAllOpenSockets(void) {	EPInfo      *epi;	OTLink*		link;    ReadBuffer *aBuffer;	//	//	Start closing connector endpoints.	//	While we could be rude and just close the endpoints, 	//	we try to be polite and wait for all outstanding connections	//	to finish before closing the endpoints.   The is a bit easier	//	on the server which won''t end up keeping around control blocks	//	for dead connections which it doesn''t know are dead.  Alternately,	//	we could just send a disconnect, but this seems cleaner.	//	(void)OTLIFOStealList(gBrokenEPs);	(void)OTLIFOStealList(gIdleEPs[0]);	(void)OTLIFOStealList(gIdleEPs[1]);	(void)OTLIFOStealList(gIdleEPs[2]);	    link = OTLIFODequeue(gAllEPs);    while (link !!= NULL) {        epi = OTGetLinkObject(link, EPInfo, globalLink);     	attemptToCloseAndDeleteThisEP(epi);        link = OTLIFODequeue(gAllEPs);    }	//	//	If the lists are empty now, then all endpoints have been successfully closed,	//	so the client is stopped now.  (Actually we hope that is the case)	//	    //    //Free up all the other resources    //    link = OTLIFODequeue(gFreeReadBuffers);    while (link !!= NULL) {    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);        OTFreeMem(aBuffer->readBufferData);        OTFreeMem(aBuffer);         link = OTLIFODequeue(gFreeReadBuffers);    }    ResolverTerminate();	OTFreeMem((char*)gDNSResolver);	gIdleEPs[0]->fHead		= NULL;	gIdleEPs[1]->fHead		= NULL;	gIdleEPs[2]->fHead		= NULL;	gBrokenEPs->fHead 		= NULL;	OTDestroyConfiguration(gCfgMastertcp);	OTDestroyConfiguration(gCfgMasterudp);	OTDestroyConfiguration(gCfgMasterListener);	DisposeOTNotifyUPP(DNSNotifierUPP);	DisposeOTNotifyUPP(NotifierSocketUPP);	DisposeOTNotifyUPP(NotifierSocketUDPUPP);	DisposeOTNotifyUPP(NotifierSocketListenerUPP);	return true;}////	DoBind////	This routine either binds to a wild card address and specfic port if //  we are doing a listen, otherwise we bind to a wild card address and //  wild card port if we are starting a connection to a remote host.//  J M M NOTE A more complex version could use port and addr//  Note we don''t bind to the local socket until here, we could when //  The socket is created, but that leads to odd issues.//static void DoBind(EPInfo* epi,InetHost addr, InetPort port,UInt8 aExtraSocketHint,OTQLen queueDepth ){	OSStatus 	err;	TBind 		bindReq, bindResult;	InetAddress	inAddr,bindAddr;		switch (aExtraSocketHint) {        case TCPSocketType: {            // for a connection        	//	Bind the endpoint to a wildcard address         	//	(assign us a port, we don''t care which one).        	//  NOTE A more complex version could use port and addr            OTInitInetAddress(&epi->remoteAddress, port, addr);            OTInitInetAddress(&epi->localAddress, 0, kOTAnyInetAddress);        	OTInitInetAddress(&inAddr, 0, 0);            break;        }        case UDPSocketType: {             // for a connection        	//	Bind the endpoint to earlier supplied information            OTInitInetAddress(&epi->remoteAddress, port, addr);        	OTInitInetAddress(&inAddr, 0, 0);            break;        }        case TCPListenerSocketType: {            // For a listen, bind wild card address, but supplied port.            // Note the passed in addr should be zero            // Note a more complex version could supply the address            OTInitInetAddress(&epi->remoteAddress, 0, kOTAnyInetAddress);            OTInitInetAddress(&epi->localAddress, port, addr);        	OTInitInetAddress(&inAddr,port, addr);            break;        }        case UDPListenerSocketType: {            // For a listen, bind wild card address, but supplied port.            // Note the passed in addr should be zero            // Note a more complex version could supply the address            OTInitInetAddress(&epi->remoteAddress, 0, kOTAnyInetAddress);            OTInitInetAddress(&epi->localAddress, port, addr);        	OTInitInetAddress(&inAddr,port, addr);            break;        }	} 	bindReq.addr.len    	= sizeof(InetAddress);	bindReq.addr.buf    	= (unsigned char*) &inAddr;	bindReq.qlen        	= queueDepth; //Note queue depth for listening 	bindResult.addr.maxlen	= sizeof(InetAddress); 	bindResult.addr.len   	= sizeof(InetAddress);	bindResult.addr.buf    	= (unsigned char*) &bindAddr;	epi->stateFlags     	= 0;	epi->stateFlags2   		= 0;	epi->stateFlags3    	= 0;	epi->bytesPendingToRead = 0;	SetEPLastError(epi,noErr);	if (aExtraSocketHint == TCPSocketType|| aExtraSocketHint == TCPListenerSocketType) {        OTAtomicSetBit(&epi->stateFlags, kUnConnected);        OTAtomicSetBit(&epi->stateFlags, kWaitingForConnection);        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);    }		err = OTBind(epi->erf, &bindReq, &bindResult); // resume at T_BINDCOMPLETE		// for bindReq on listen what is queueDepth now? 	// bindReq.qlen could have changed	// But... No why to feed this back to the client!!		if (err !!= kOTNoError) {    	SetEPLastError(epi,err);        makeEPUnconnected(epi);    	return;	}		OTMemcpy(&epi->localAddress,bindResult.addr.buf,sizeof(InetAddress)); //Pickup local address	return;}////	DoConnect////	This routine attempts establish a new connection to the given//	address and port.  //  Called via the notifier at interrupt time.//static void DoConnect(EPInfo* epi,InetHost addr, InetPort port){	OSStatus err;	TCall sndCall;	InetAddress inAddr;		//	Don''t want new connections if already shutting down.	if (gProgramState !!= kProgramRunning ) return;			OTInitInetAddress(&inAddr, port, addr);	OTMemzero(&sndCall, sizeof(TCall));	sndCall.addr.len 	= sizeof(InetAddress);					sndCall.addr.buf	= (unsigned char*) &inAddr;		err = OTConnect(epi->erf, &sndCall, NULL); //resume at T_CONNECT	if (err !!= kOTNoDataErr) {    	SetEPLastError(epi,err);        makeEPUnconnected(epi);		return;	}}////	DoListenAccept////	The handling of a T_LISTEN is greatly simplified by use//	of the tilisten module, which serializes inbound connections.//	This means that when doing an OTAccept we won''t get a kOTLookErr//	because another inbound connection arrived and created a T_LISTEN.//	Without the tilisten module, we have to use the "8 step //	listen/accept/disconnect method", which is documented elsewhere.//static void DoListenAccept(EPInfo* acceptor,EPInfo* theServer){	TCall		call;	InetAddress	caddr;	OTResult	lookResult;	OSStatus	err;				OTMemzero(&call, sizeof(TCall));	call.addr.maxlen = sizeof(InetAddress);	call.addr.buf = (unsigned char*) &caddr;			err = OTListen(theServer->erf, &call);	if (err !!= kOTNoError) {		//		//	Only two errors are expected at this point.		//	One would be a kOTNoDataErr, indicating the inbound connection		//	was unavailable, temporarily hidden by a higher priority streams		//	message, etc.   The more likely error is a kOTLookErr, 		//	which indicates a T_DISCONNECT on the OTLook()		//	happens when the call we were going to process disconnected.		//	In that case, go away and wait for the next T_LISTEN event.		//		if (err == kOTNoDataErr) return;					lookResult = OTLook(theServer->erf); 		if (err == kOTLookErr && lookResult == T_DISCONNECT)        	err = OTRcvDisconnect(theServer->erf, NULL);		else 		    SetEPLastError(theServer,lookResult);		return;		}		acceptor->remoteAddress = caddr;		err = OTAccept(theServer->erf, acceptor->erf, &call);	//	//	Note an kOTIndOutErr can occur if we are listening on the EP and handling 	//  off to the same EP. Sorry use the listento:backlogqueue: logic instead    //	if (err !!= kOTNoError) {		//		//	Again, we have to be able to handle the connection being disconnected		//	while we were trying to accept it.		//		lookResult = OTLook(theServer->erf);		if (err == kOTLookErr && lookResult == T_DISCONNECT)         	err = OTRcvDisconnect(theServer->erf, NULL);		else 		    SetEPLastError(theServer,lookResult);	}}////	EPOpen:////	A front end to OTAsyncOpenEndpoint.//	A status bit is set so we know there is an open in progress.//	It is cleared when the notifier gets a T_OPENCOMPLETE where the context//	pointer is this EPInfo.  Until that happens, this EPInfo can''t be cleaned//	up and released.//static Boolean EPOpen(EPInfo* epi){	OSStatus err;		OTAtomicSetBit(&epi->stateFlags, kOpenInProgressBit);	SetEPLastError(epi,kOTNoError);    epi->UDPMaximumSize = 0; //Remember to figure out the max UDP size.    	switch (epi->socketType) {	    case TCPSocketType: {		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMastertcp), 0, NULL, NotifierSocketUPP, epi); 	        break;	    }	    case UDPSocketType: {	        TEndpointInfo endPointInformation;		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMasterudp), 0, &endPointInformation, NotifierSocketUDPUPP, epi); 		    epi->UDPMaximumSize = (endPointInformation.tsdu == T_INFINITE) ? 64*1024 : endPointInformation.tsdu;	        break;	    }	    case TCPListenerSocketType: {		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMasterListener), 0, NULL, NotifierSocketListenerUPP, epi); 	        break;	    }	}	if (err !!= kOTNoError) {		SetEPLastError(epi,err);		OTAtomicClearBit(&epi->stateFlags, kOpenInProgressBit);		return false;	}	return (epi->lastError == kOTNoError);}////	EPClose////	This routine is a front end to OTCloseProvider.   //	Centralizing closing of endpoints makes debugging and instrumentation easier.  //static Boolean EPClose(EPInfo* epi){	OSStatus err;		//	//	If an endpoint is still being opened, we can''t close it yet.	//	There is no way to cancel an OTAsyncOpenEndpoint, so we just	//	have to wait for the T_OPENCOMPLETE event at the notifier.	//	if ( OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit) )		return false;		    	//	//	If the OTAsyncOpenEndpoint failed, the endpoint ref will be NULL,	//	and we don''t need to close it now. Also can be NULL or should be NULL if sleeping happened.	//	if (epi->erf == NULL || OTAtomicClearBit(&epi->stateFlags3, kSleepKilledMe)) {	    epi->erf = NULL;		return true;	}			if (epi->outstandingSends == 0) {    	err = OTCloseProvider(epi->erf);    	epi->erf = NULL;    	return true;    }    	    //	//	If we get to this point, the endpoint did an OTSnd() with AckSends,	//	and the T_MEMORYRELEASED event hasn''t been returned yet.  In order	//	to make sure we get the event, we flush the stream and then do an	//	OTDisconnect().   This should get the memory freed so we can close	//	the endpoint safely.   Note, we set a flag so we don''t do this 	//	more than once on an endpoint.	//  J M M I''m not sure we''ll ever get here since a flush should have been done higher up	//	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )	{		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);		if (err !!= kOTNoError)			{} 	}	return false;}////	Recycle:////	This routine shouldn''t be necessary, but it is helpful to work around both//	problems in OpenTransport and bugs in this program.   Basicly, whenever an//	unexpected error occurs which shouldn''t be fatal to the program, the EPInfo//	is queued on the BrokenEP queue.  When recycle is called,//  it will attempt to close the associated endpoint and open//	a new one to replace it using the same EPInfo structure.   This process of//	closing an errant endpoint and opening a replacement is probably the most//	reliable way to make sure that this program and OpenTransport can recover//	from unexpected happenings in a clean manner.////  Mind you it can be invoked to cleanup UDP sockets that aren''t closed //  properly due to pending traffice on a busy port.//  Solution mentioned in books is to close the EP.//static void Recycle(){	OTLink* 	list = OTLIFOStealList(gBrokenEPs);	OTLink*		link;	EPInfo*		epi;	while ( (link = list) !!= NULL ) {		list = link->fNext;		epi = OTGetLinkObject(link, EPInfo, link);		if (!!EPClose(epi)) {			OTLIFOEnqueue(gBrokenEPs, &epi->link);			continue;		}		if (gProgramState == kProgramRunning)		    EPOpen(epi);		 else		    makeEPIdle(epi);	}}//// Make the EP idle, it either goes on an idle queue or gets broken.//static void    makeEPIdle(EPInfo *epi) {    purgeReadBuffers(epi);        if (OTAtomicClearBit(&epi->stateFlags2, kEPIsBroken)) {        OTLIFOEnqueue(gBrokenEPs, &epi->link);     } else {	    OTLIFOEnqueue(gIdleEPs[epi->socketType], &epi->link);    	    OTAtomicAdd32(1, &gIdleEPCounter[epi->socketType]);    }}static void attemptToCloseAndDeleteThisEP (EPInfo *epi) {    purgeReadBuffers(epi); 	if (!!EPClose(epi)) {		//	Can''t close this endpoint yet, so skip it.	} else 	    OTFreeMem((char*)epi);}static EPInfo* getOrMakeMeAnEP(UInt8 aSocketType) {	EPInfo      *epi;    OTLink		*link;    SInt32      i;        Recycle();  //Ensure broken EP get fixed up    if (gIdleEPCounter[aSocketType] < 5)   //Magic Number ensure we have at least 5 EP available.        makeMeAnEP(aSocketType);            link = OTLIFODequeue(gIdleEPs[aSocketType]);	if (link == NULL) {		for(i=0;i<10;i++) {OTIdle();};		return getOrMakeMeAnEP(aSocketType); //JMM recursive bug lurks	}	   	OTAtomicAdd32(-1, &gIdleEPCounter[aSocketType]);	epi = OTGetLinkObject(link, EPInfo, link);		if (OTAtomicTestBit(&epi->stateFlags3, kSleepKilledMe)) {	//	//A broken epi on the idle stack, now the only way we can 	//get here (I think) is to have gone to sleep which breaks	//all the end points. To clean up we must now fix them	//So make it idle, of course it''s broken	//Then recursive call to get another one	//This continues until we get a good one	//  	    makeEPIdle(epi);	    return getOrMakeMeAnEP(aSocketType);	}    return epi;}////This is where EP are actually made and opened//EP opening is async//static Boolean makeMeAnEP (UInt8 aSocketType) {	EPInfo      *epi;		epi = (EPInfo*) OTAllocMem(sizeof(EPInfo));	if (epi == NULL) return false;   //Death lurks	OTMemzero(epi, sizeof(EPInfo));  //zero it out which makes all the pointers null    epi->socketType = aSocketType;    OTLIFOEnqueue(gAllEPs, &epi->globalLink);	return EPOpen(epi);}static void makeEPUnconnected(EPInfo *epi) {	OTAtomicClearBit(&epi->stateFlags, kWaitingForConnection);	OTAtomicSetBit(&epi->stateFlags, kUnConnected);    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) //tap to clear waitforconnection on error        interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);}static void makeEPConnected(EPInfo *epi) {	OTAtomicClearBit(&epi->stateFlags, kWaitingForConnection);	OTAtomicClearBit(&epi->stateFlags, kUnConnected);    OTAtomicSetBit(&epi->stateFlags, kConnected);    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) //tap to clear waitforconnection        interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);}static void makeEPBrokenThenIdle(EPInfo* epi,OTResult error) {    makeEPBroken(epi,error);    makeEPIdle(epi);}static void makeEPBroken(EPInfo* epi,OTResult error) {    SetEPLastError(epi,error);    OTAtomicSetBit(&epi->stateFlags2, kEPIsBroken);}static void SetEPLastError(EPInfo* epi,OTResult error) {    if (error < 0) {		JMMLogMessageAndNumber("\p NonZero Error For ",epi->semaIndex);		JMMLogMessageAndNumber("\p NonZero Error Is  ",error);    }    epi->lastError = error;}//	ReadData:////	This routine attempts to read all available data from an endpoint.//	it is not necessary for the program to handle//	getting back a T_DATA notification DURING an OTRcv() call, as would be//	the case if we read from outside the notifier.   We must read until we//	get a kOTNoDataErr in order to clear the T_DATA event so we will get//	another notification of T_DATA in the future.//  Note we use EnterNotifier to make this possible////	Note for the curious we attempted to use no-copy receives to get data.  This obligates//	the program to return the buffers to OT asap.  BUT we found we overran memory!!//  So we reverted to more expensive copies into buffers we have preallocated////  Perhaps a seperate routine for UDP would make sense?//  Note May 30/00 we added a special read when we exhaust the internal buffer pool//  But data is still pending we allow you to read into the squeak buffer directly//static UInt32 ReadData(EPInfo* epi,char *specialReadBuffer,UInt32 specialReadSize) {	OTResult  	res;	OTFlags	  	flags;	OTResult	epState;	OTLink		*link;    ReadBuffer 	*readBufferObject,simulatedReadBuffer;    InetAddress UDPdataFromAddress;    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreReadData)) //tap to clear waitfordata Data Data Data        interpreterProxy->signalSemaphoreWithIndex(epi->readSemaIndex);            if (specialReadSize > 0) { //Special case drop into squeak buffer, make a simulated buffer object        OTMemzero(&simulatedReadBuffer,sizeof(ReadBuffer));        simulatedReadBuffer.readBufferData = specialReadBuffer;        simulatedReadBuffer.readBufferSize = simulatedReadBuffer.readBufferOriginalSize = specialReadSize;        readBufferObject = &simulatedReadBuffer;    } else {       link = OTLIFODequeue(gFreeReadBuffers);                	if (link == NULL) {           	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl);  //NO free buffers we are flow controled        	return;     	}    	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);        OTAtomicClearBit(&epi->stateFlags2, kReadFlowControl);      }        OTMemzero(&UDPdataFromAddress,sizeof(InetAddress));    	while (true) {        		readBufferObject->readBufferPtr = readBufferObject->readBufferData;		   	    if (epi->socketType == UDPSocketType) {   	        TUnitData 	UDPDataInBound;   	        OTFlags     flagMeaningMore;            OSStatus    error;                	    UDPDataInBound.addr.maxlen = sizeof(InetAddress);    	    UDPDataInBound.addr.len    = sizeof(InetAddress);    	    UDPDataInBound.addr.buf    = (UInt8*) &readBufferObject->UDPAddress;    	    UDPDataInBound.opt.maxlen  = 0;    	    UDPDataInBound.opt.len     = 0;    	    UDPDataInBound.opt.buf     = NULL;    	    UDPDataInBound.udata.maxlen = readBufferObject->readBufferOriginalSize;    	    UDPDataInBound.udata.len    = readBufferObject->readBufferOriginalSize;    	    UDPDataInBound.udata.buf    = (UInt8*)readBufferObject->readBufferData;	    	        error =  OTRcvUData(epi->erf, &UDPDataInBound, &flagMeaningMore);	        	        if (error !!= kOTNoError) {	            res = error;	        } else {	            if (UDPDataInBound.addr.len == 0) //Remember UDP address	                readBufferObject->UDPAddress = UDPdataFromAddress;	            else	                UDPdataFromAddress = readBufferObject->UDPAddress;	                	            epi->UDPMoreFlag = readBufferObject->UDPMoreFlag = (flagMeaningMore > 0) ? true: false;	            res = (SInt32) UDPDataInBound.udata.len; 	            OTMemcpy(&epi->remoteAddress,&readBufferObject->UDPAddress,sizeof(InetAddress));  	        }   	    } else {//A less complicated tcp read   	        res = OTRcv(epi->erf, readBufferObject->readBufferData, readBufferObject->readBufferOriginalSize, &flags);   	    }   	    		//		//	Note, check for 0 because can get a real 0 length receive		//	in some protocols (not in TCP), which is different from		//	getting back a kOTNoDataErr.		//		if (res >= 0) {            if (specialReadSize > 0)                 return (UInt32) res; //Note special case                            readBufferObject->readBufferSize = (UInt32) res;                        OTAddLast(&epi->readBuffers,&readBufferObject->fNext); //Put the buffer on the read queue        	OTAtomicAdd32(res, &epi->bytesPendingToRead);            link = OTLIFODequeue(gFreeReadBuffers);                            	if (link == NULL) {               	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl); //Our read flow control, OT will block lower down            	return;         	}        	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);   			continue; //Loop around and get more bytes if available		}		else {            if (specialReadSize == 0)                 OTLIFOEnqueue(gFreeReadBuffers, &readBufferObject->fNext); //Read above didn''t work so put it back on free queue		}				if (res == kOTNoDataErr) {			//			//	Since ReadData is only called from inside the notifier			//	we don''t have to worry about having missed a T_DATA 			//	during the OTRcv.			//  Note use of EnterNotifier logic			//			if (specialReadSize > 0)			    OTAtomicClearBit(&epi->stateFlags2, kReadFlowControl); 			return 0;		}		if (res == kOTLookErr) {			res = OTLook(epi->erf);			if (res == T_ORDREL || res == T_DISCONNECT) {				//	If we got the T_ORDREL, we won''t get any more inbound data.				//	We return and wait for the notifier to get the T_ORDREL notification.				//	Upon getting it, we will notice we still need to send data and do so.				//	The T_ORDREL has to be cleared before we can send. 				//				return 0 ;			}			if (res == T_GODATA) {			    if (specialReadSize == 0) {    			    link = OTLIFODequeue(gFreeReadBuffers);                    	if (link == NULL) {                       	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl);                    	return 0 ;                 	}                	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);            	} else {            	    return 0;            	}			    continue; //OT Flow control lifted keep reading. JMM			}		} else {			epState = OTGetEndpointState(epi->erf);			if (res == kOTOutStateErr && epState == T_INREL) {				//				//	Occasionally this problem will happen due to what appears				//	to be an OpenTransport notifier reentrancy problem.   				//	What has occured is that a T_ORDREL event happened and 				//	was processed during ReadData().   This is proven by being				//	in the T_INREL state without having done a call to				//	OTRcvOrderlyDisconnect() here.   It appears to be a benign 				//	situation, so the way to handle it is to understand that no				//	more data is going to arrive and go ahead and being our response				//	to the client.				//				break;			}		break; //Ok error so break out of loop		}	}    return 0;	}//// NOT USED HISTORICAL REASONS// /*static void NoCopyReceiveWalkingBufferChain(EPInfo *epi,OTBufferInfo *bufferInfo){   OSStatus     err;   OTBuffer     *thisBuffer;   UInt32       count;   ReadBuffer   *readBufferObject;           thisBuffer = bufferInfo->fBuffer;    err = noErr;    while (err == noErr && thisBuffer !!= nil) {        count = thisBuffer->fLen;    	OTAtomicAdd32(count, &epi->bytesPendingToRead);		readBufferObject = OTAllocMem(sizeof(ReadBuffer));        if (readBufferObject == nil) {			SysBeep(5);            err = -1;            break;        }         OTMemzero(readBufferObject,sizeof(ReadBuffer));        readBufferObject->readBufferData = readBufferObject->readBufferPtr = OTAllocMem(count);        if ( readBufferObject->readBufferData == nil) {			SysBeep(5);             err = -1;            break;        }         readBufferObject->readBufferOriginalSize = readBufferObject->readBufferSize = count;        OTMemcpy(readBufferObject->readBufferData,thisBuffer->fData,count);        OTAddLast(&epi->readBuffers,&readBufferObject->fNext);        thisBuffer = thisBuffer->fNext;    }   // Clean up.  We MUST release the OTBuffer chain to Open Transport    // so that it crelease the OTBuffer chain to Open Transport    // so that it can reuse it., OTReleaseBuffer does not tolerate   // the parameter being nil, so we check for that case first.    if (bufferInfo->fBuffer !!= nil) {      OTReleaseBuffer(bufferInfo->fBuffer);   }}*///// Read Bytes from the buffers// Called by Squeak to get the data//static UInt32  readBytes(EPInfo* epi,char *buf,UInt32 adjustedBufSize){    //    // Read bytes from buffers    // use recursion to fill buf to adjustedBufSize or     // til we have no buffers left    // By using enterNotifier higher up we avoid race on the readBuffers list    //        UInt32 		increment,bytesRead = 0;    ReadBuffer *aBuffer;        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    if (aBuffer == nil) return 0;        if (aBuffer->readBufferSize > adjustedBufSize) {        bytesRead = adjustedBufSize;    	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy((char *) buf,aBuffer->readBufferPtr,bytesRead);        aBuffer->readBufferPtr += bytesRead;        aBuffer->readBufferSize -= bytesRead;        OTAddFirst(&epi->readBuffers,&aBuffer->fNext);        return bytesRead;    }    else {        bytesRead = aBuffer->readBufferSize;       	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy(buf,aBuffer->readBufferPtr,bytesRead);        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);        increment = readBytes(epi,buf+bytesRead,adjustedBufSize-bytesRead);        bytesRead += increment;        return bytesRead;   }}static UInt32  readBytesUDP(EPInfo* epi,InetAddress *fromAddress, int * moreFlag, char *buf,UInt32 adjustedBufSize){    //    // Read bytes from buffers    // For UDP we just drop in the read buffer and address    // Don''t fill the entire buffer no recursion.    // By using enterNotifier higher up we avoid race on the readBuffers list    //        UInt32      bytesRead = 0;    ReadBuffer  *aBuffer;        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    if (aBuffer == nil) return 0;        if (aBuffer->readBufferSize > adjustedBufSize) {        bytesRead = adjustedBufSize;    	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy((char *) buf,aBuffer->readBufferPtr,bytesRead);        aBuffer->readBufferPtr += bytesRead;        aBuffer->readBufferSize -= bytesRead;        OTMemcpy(fromAddress,&aBuffer->UDPAddress,sizeof(InetAddress));        *moreFlag = aBuffer->UDPMoreFlag;        OTAddFirst(&epi->readBuffers,&aBuffer->fNext);        return bytesRead;    }    else {        bytesRead = aBuffer->readBufferSize;       	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy(buf,aBuffer->readBufferPtr,bytesRead);        OTMemcpy(fromAddress,&aBuffer->UDPAddress,sizeof(InetAddress));        *moreFlag = aBuffer->UDPMoreFlag;        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);        return bytesRead;   }}//Cleanup logic//static void purgeReadBuffers(EPInfo *epi) {    ReadBuffer *aBuffer;            //    //Put buffers for this epi back on the free queue    //    aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);        while (aBuffer !!= NULL) {        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    }    epi->bytesPendingToRead = 0;}////	Send the Bytes (Really fast, we hope)//static SInt32 SendData(EPInfo* epi,char* buffer, UInt32 size){	OTResult res;	struct OTData *dataPtr;  	//	//	Make sure we record that we are starting a send so we don''t try to close	//	the endpoint before a T_MEMORYRELEASED event is returned.	//	OTAtomicAdd32(1, &epi->outstandingSends);		if (epi->socketType == UDPSocketType) {		TUnitData UDPDataOutBound;	    UDPDataOutBound.addr.maxlen  = sizeof(InetAddress);	    UDPDataOutBound.addr.len     = sizeof(InetAddress);	    UDPDataOutBound.addr.buf     = (UInt8*) &epi->remoteAddress;	    UDPDataOutBound.opt.maxlen   = 0;	    UDPDataOutBound.opt.len      = 0;	    UDPDataOutBound.opt.buf      = NULL;	    UDPDataOutBound.udata.maxlen = size;	    UDPDataOutBound.udata.len    = size;	    UDPDataOutBound.udata.buf    = (UInt8*)buffer;	            res =  OTSndUData(epi->erf,&UDPDataOutBound);         if (res == kOTNoError ) return (SInt32) size;                // Other Errors could be kOTFlowErr or kOTBadDataErr	}	else { //TCP Send    	//    	//	In OT 1.1.2 and previous versions, there is a bug with AckSends    	//	which occurs when the same buffer is sent more than once.   In an attempt    	//	to go fast and not allocate memory, TCP may write an IP and TCP header    	//	into the data buffer which is sent.   If the buffer is sent more than once    	//	without being refreshed, the data may be corrupted.   To work around this,    	//	send the data via an OTData structure, using the gather-write mechanism.    	//	The problem does not occur in this code path, and this will not hinder performance.    	//	The problem will be fixed in the next Open Transport release following 1.1.2.    	//    	//  Note the MAC OS 8.1 docs alude to a bug before 1.3 where acksends    	//  cause problems if a disconnect flows just right. Unsure if this    	//  will be an issue    	//    	    	if (gOTVersion < kOTVersion113) {    		dataPtr = OTAllocMem(sizeof(OTData));    		if (dataPtr == NULL) { //Death lurks I''m sure    		    OTAtomicAdd32(-1, &epi->outstandingSends);                OTFreeMem(buffer);                return 0;            }    		dataPtr->fNext = NULL;    		dataPtr->fData = buffer;    		dataPtr->fLen  = size;    		res = OTSnd(epi->erf, dataPtr, kNetbufDataIsOTData, 0);    		    		//Note in the notification routine we cleanup the allocated dataPtr AND buffer.    	}    	else    	{    		res = OTSnd(epi->erf, buffer, size, 0);    		    		//JMM how to handle kENOMEMErr no memory right now error    		//Book says to back off and wait but must do a timer or something    		//Right now we''ll fail the primitive higher up since the error code is bad    	}    }	if (res == size) return (SInt32) size;	if (res >= 0) {		//		//	Implied kOTFlowErr since not all data was accepted.		//  But maybe we aren''t blocked yet so keep sending		//		return res;	} else	{	// res < 0	 		OTAtomicAdd32(-1, &epi->outstandingSends);        OTFreeMem(buffer);        	    if ((epi->socketType !!= UDPSocketType) && (gOTVersion < kOTVersion113) )	       	OTFreeMem(dataPtr); 	   		if (res == kOTFlowErr) {		    //		    // Flow control back off and wait for T_GODATA		    //        	OTAtomicSetBit(&epi->stateFlags, kSendIsBlocked);			return 0;		}				if (res == kOTLookErr) {			res = OTLook(epi->erf);			if (res == T_ORDREL || res == T_GODATA || res == T_DISCONNECT)			{				//	Wait to get the T_ORDREL at the notifier and handle it there.				//	Then we will resume sending.				//  Same applies for other events				//                //JMM test?                	OTAtomicSetBit(&epi->stateFlags, kSendIsBlocked);				return 0;			} else 			    	return res; 		} else 		    return res;		}}////Set the options//int sqSocketSetOptionsoptionNameStartoptionNameSizeoptionValueStartoptionValueSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int optionValueT, int optionValueSize, int *result)	{    EPInfo*     epi;    OTResult    error;    char        optionName[80],optionValue[80];    SInt32      anInteger;    	*result = 0;	if (!!SocketValid(s)) return -1;    epi = (EPInfo *) s->privateSocketPtr;	OTMemcpy(optionName,(char *) optionNameT,optionNameSize);	optionName[optionNameSize] = 0x00;	    OTMemcpy(optionValue,(char *) optionValueT,optionValueSize);    optionValue[optionValueSize] = 0x00;    CopyCStringToPascal(optionValue,(unsigned char *) optionValue);    StringToNum((ConstStr255Param) optionValue,&anInteger);       	   error = lookupOptionName(epi, false, (char *) &optionName, anInteger,(long *) result);   return error;}////Get the options//int sqSocketGetOptionsoptionNameStartoptionNameSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int *result)	{    EPInfo*     epi;    OTResult    error;    char        optionName[80];   	*result = 0;	if (!!SocketValid(s)) return -1;    epi = (EPInfo *) s->privateSocketPtr;	OTMemcpy(optionName,(char *) optionNameT,optionNameSize);  //NEED to fiddle with error number JMM to say readonly notvalid etc.	optionName[optionNameSize] = 0x00;	     	   error = lookupOptionName(epi, true, (char *) &optionName, NULL,(long *)  result);   return error;}// A Number of routines to set/get options, first figureout the flags, then call the routine// To set or get the options. static SInt32	lookupOptionName(EPInfo *epi, Boolean trueIfGet, char *aString, UInt32 value, SInt32 *result) {	if (strcmp("TCP_MAXSEG",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_MAXSEG,value,result);};	if (strcmp("TCP_NODELAY",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_NODELAY,value,result);};	if (strcmp("TCP_ABORT_THRESHOLD",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_ABORT_THRESHOLD,value,result);};	if (strcmp("TCP_CONN_NOTIFY_THRESHOLD",aString)==0) {return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_CONN_NOTIFY_THRESHOLD,value,result);};	if (strcmp("TCP_CONN_ABORT_THRESHOLD",aString)==0) 	{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_CONN_ABORT_THRESHOLD,value,result);};	if (strcmp("TCP_NOTIFY_THRESHOLD",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_NOTIFY_THRESHOLD,value,result);};	if (strcmp("TCP_URGENT_PTR_TYPE",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_URGENT_PTR_TYPE,value,result);};	if (strcmp("UDP_CHECKSUM",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_UDP,UDP_CHECKSUM,value,result);};	if (strcmp("SO_DEBUG",aString)==0) 			    	{return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_DEBUG,value,result);};	if (strcmp("SO_REUSEADDR",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_REUSEADDR,value,result);;};	if (strcmp("SO_REUSEPORT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_REUSEADDR,value,result);};	if (strcmp("SO_DONTROUTE",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_DONTROUTE,value,result);};	if (strcmp("SO_BROADCAST",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_BROADCAST,value,result);};	if (strcmp("SO_SNDBUF",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_SNDBUF,value,result);};	if (strcmp("SO_RCVBUF",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_RCVBUF,value,result);};	if (strcmp("SO_KEEPALIVE",aString)==0) 			   {return SetKeepAliveOption(epi,trueIfGet,INET_TCP,TCP_KEEPALIVE,value,result);};	if (strcmp("SO_OOBINLINE",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_OOBINLINE,value,result);};	if (strcmp("SO_PRIORITY",aString)==0) 			     {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_TOS,value,result);};	if (strcmp("SO_LINGER",aString)==0) 			      {return SetLingerOption(epi,trueIfGet,XTI_GENERIC,XTI_LINGER,value,result);};	if (strcmp("SO_RCVLOWAT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_RCVLOWAT,value,result);};	if (strcmp("SO_SNDLOWAT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_SNDLOWAT,value,result);};			if (strcmp("IP_OPTIONS",aString)==0) 			    { }; //JMM What to do here?		if (strcmp("IP_TTL",aString)==0) 			         {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_TTL,value,result);};		if (strcmp("IP_HDRINCL",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_HDRINCL,value,result);}; //NOT SUPPORT FOR IP		if (strcmp("IP_RCVOPTS",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVOPTS,value,result);};		if (strcmp("IP_RCVDSTADDR",aString)==0) 			{return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVDSTADDR,value,result);};		if (strcmp("IP_MULTICAST_IF",aString)==0) 			{return SetFourByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_IF,value,result);};		if (strcmp("IP_MULTICAST_TTL",aString)==0) 			 {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_TTL,value,result);};		if (strcmp("IP_MULTICAST_LOOP",aString)==0) 	     {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_LOOP,value,result);};	/*	if (strcmp("IP_ADD_MEMBERSHIP",aString)==0) 	    { return SetJMMByteOption(epi,trueIfGet,INET_IP,IP_ADD_MEMBERSHIP,value,result);};		if (strcmp("IP_DROP_MEMBERSHIP",aString)==0) 	    { return SetJMMByteOption(epi,trueIfGet,INET_IP,IP_DROP_MEMBERSHIP,value,result);};		if (strcmp("IP_BROADCAST_IF",aString)==0) 	        {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_BROADCAST_IF,value,result);};		if (strcmp("IP_RCVIFADDR",aString)==0) 	            {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVIFADDR,value,result);};	*/    *result = 0;    return -1;}static OTResult SetFourByteOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   UInt8    optBuffer[kOTFourByteOptionSize];   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;      /* Set up the option buffer to specify the option and value to set. */   option->len  = kOTFourByteOptionSize;   option->level= level;   option->name = name;   option->status = 0;   option->value[0] = value;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(optBuffer);   request.opt.maxlen=sizeof(optBuffer);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(optBuffer);      if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}								    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = option->value[0];   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }                return (err);}static OTResult SetOneByteOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   UInt8    optBuffer[kOTFourByteOptionSize];   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;      /* Set up the option buffer to specify the option and value to set. */   option->len  = kOTOneByteOptionSize;   option->level= level;   option->name = name;   option->status = 0;   *(unsigned char *)option->value = value;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= kOTOneByteOptionSize;   request.opt.maxlen=sizeof(optBuffer);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(optBuffer);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = (UInt32) (*(unsigned char *)option->value);   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}static OTResult SetKeepAliveOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   TKeepAliveOpt  optBuffer;   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;         if (value == 0)       optBuffer.tcpKeepAliveOn = T_NO;   else        optBuffer.tcpKeepAliveOn = T_YES;           optBuffer.tcpKeepAliveTimer = value;				   /* Set up the option buffer to specify the option and value to set. */   option->len  = sizeof(TKeepAliveOpt);   option->level= level;   option->name = name;   option->status = 0;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(TKeepAliveOpt);   request.opt.maxlen=sizeof(TKeepAliveOpt);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(TKeepAliveOpt);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = optBuffer.tcpKeepAliveTimer;   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}		    static OTResult SetLingerOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   TLingerOpt  optBuffer;   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;         if (value == 0)       optBuffer.tcpLingerOn = T_NO;   else        optBuffer.tcpLingerOn = T_YES;           optBuffer.tcpLingerTimer = value;				   /* Set up the option buffer to specify the option and value to set. */   option->len  = sizeof(TKeepAliveOpt);   option->level= level;   option->name = name;   option->status = 0;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(TKeepAliveOpt);   request.opt.maxlen=sizeof(TKeepAliveOpt);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(TKeepAliveOpt);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = optBuffer.tcpLingerTimer;   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}////	Notifier:////	Most of the interesting networking code in this program for the resolver resides inside //	this notifier.   In order to run asynchronously and as fast as possible,//	things are done inside the notifier whenever possible.  Since almost//	everything is done inside the notifier, there was little need for specical//	synchronization code.////	Note: The only events which are expected from the DNR are T_DNRSTRINGTOADDRCOMPLETE,//	T_DNRADDRTONAMECOMPLETE, and of close sleep/reconfigure notifications.////static pascal void DNSNotifier(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	JMMLogMessageAndNumber("\p DNS Event  ",event);	JMMLogMessageAndNumber("\p DNS Result ",result);	JMMLogMessageAndNumber("\p Id ",epi->semaIndex);		//	//	Once the program is shutting down, most events would be uninteresting.	//	if (gProgramState !!= kProgramRunning)			return;			//	//	Within the notifier, all action is based on the event code.	//	In this notifier, fatal errors all break out of the switch to the bottom.	//	As long as everything goes as expected, the case returns rather than breaks.	//	switch (event)	{		//		//	T_DNRSTRINGTOADDRCOMPLETE:		//		//	This event occurs when the DNR has finished an attempt to translate		//	the server''s name into an IP address we can use to connect to.		//		case T_DNRSTRINGTOADDRCOMPLETE:		{			gDNSResolverError = result;			if (result !!= kOTNoError) {				gDNSResolverStatus = RESOLVER_ERROR;    			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);				return;			}			gDNSAddr = gDNSHostInfo.addrs[0];			gDNSResolverStatus = RESOLVER_SUCCESS;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			return;		}				//		//	T_DNRADDRTONAMECOMPLETE:		//		//	This event occurs when the DNR has finished an attempt to translate		//	the  an IP address into a server name.		//		case T_DNRADDRTONAMECOMPLETE:		{			gDNSResolverError = result;			if (result !!= kOTNoError) {				gDNSResolverStatus = RESOLVER_ERROR;    			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);				return;			}			gDNSResolverStatus = RESOLVER_SUCCESS;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			return;		}									//		//	kOTProviderWillClose:		//		//	This event occurs when the user changes TCP/IP in the control panel		//		case kOTProviderWillClose:		case kOTProviderIsClosed:		{			gDNSResolverError = kOTProviderWillClose;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			ResolverTerminate(); 			gDNSResolverStatus = RESOLVER_SUCCESS; //Cheat!! Keep Squeak happy later we fix the resolver EP.			return;		}				//		//	default:		//		//	There are events which we don''t handle, but we don''t expect to see		//	any of them.  In the production version of the program, we ignore the event and try to keep running.		//		default:		{			return;		}	}}////	Notifier for socket: Please note we have another notifier for sockets that do multiple listens//  And a different notifier for UDP sockets, however the intesting thing is that we can call/// This routine from othe other as a simple form of inheritence.////	Most of the interesting networking code in this program for socket support resides inside //	this notifier.   In order to run asynchronously and as fast as possible,//	things are done inside the notifier whenever possible.  Since almost//	everything is done inside the notifier, there was little need for specical//	synchronization code.////	IMPORTANT NOTE:  Normal events defined by XTI (T_LISTEN, T_CONNECT, etc)//	and OT completion events (T_OPENCOMPLETE, T_BINDCOMPLETE, etc.) are not//	reentrant.  That is, whenever our notifier is invoked with such an event,//	the notifier will not be called again by OT for another normal or completion//	event until we have returned out of the notifier - even if we make OT calls//	from inside the notifier.   This is a useful synchronization tool.//	However, there are two kinds of events which will cause the notifier to //	be reentered.   One is T_MEMORYRELEASED, which always happens instantly.//	The other are state change events like kOTProviderWillClose.//static pascal void NotifierSocket(void* context, OTEventCode event, OTResult result, void* cookie){	OSStatus err;	OTResult epState;	EPInfo* epi = (EPInfo*) context;		JMMLogMessageAndNumber("\p Event  ",event);	JMMLogMessageAndNumber("\p Result ",result);	JMMLogMessageAndNumber("\p Id ",epi->semaIndex);	//	//	Once the program is shutting down, most events would be uninteresting.	//	However, we still need T_OPENCOMPLETE and T_MEMORYRELEASED events since	//	we can''t call CloseOpenTransport until all OTAsyncOpenEndpoints and	//	OTSends with AckSends have completed.   So those specific events	//	are still accepted.	//	if (gProgramState !!= kProgramRunning) {		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED)) {			return;		}	}			//	//	Within the notifier, all action is based on the event code.	//	In this notifier, fatal errors all break out of the switch to the bottom.	//	As long as everything goes as expected, the case returns rather than breaks.	//	switch (event)	{		//		//	kStreamIoctlEvent:		//		//	This event is returned when an I_FLUSH ioctl has completed.		//	The flush was done in an attempt to get back all T_MEMORYRELEASED events		//	for outstanding OTSnd() calls with Ack Sends.   For good measure, we		//	send a disconnect now.   Errors are ignored at this point since it is		//	possible that the connection will already be gone, etc.		//		case kStreamIoctlEvent:		{			if (OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit) !!= 0) {			    OTAtomicClearBit(&epi->stateFlags2, kFlushDisconnectInProgressBit);				(void) OTSndDisconnect(epi->erf, NULL);			}			return;		}		//		//	T_ACCEPTCOMPLETE:		//		//	This event is received by the listener endpoint only when we open a port with a listen.   		//	The acceptor endpoint will get a T_PASSCON event instead.		//		case T_ACCEPTCOMPLETE:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {				makeEPUnconnected(epi);        		return;            }            makeEPConnected(epi);			return;		}		//		//	T_BINDCOMPLETE:		//		//	This event is returned when an endpoint has been bound to a wildcard addr.		//  Bind happens when we open a connection to a remote location.		//	No errors are expected.   		//		case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {            	makeEPUnconnected(epi);				return;			}			if (epi->remoteAddress.fHost !!= 0) 			    DoConnect(epi,epi->remoteAddress.fHost, epi->remoteAddress.fPort);			return;		}				//		//	T_CONNECT:		//		//	This event is returned when a connection is established to the server.		//	The program must call OTRcvConnect() to get the conenction information		//	and clear the T_CONNECT event from the stream.  Since OTRcvConnect()		//	returns immediately (rather than via a completion event to the notifier)		//	we can use local stack structures for parameters.		//		case T_CONNECT:		{			TCall call;						            SetEPLastError(epi,result);			if (result !!= kOTNoError) {				makeEPUnconnected(epi);  				return;			}						// Address of endpoint that has connection			// This could be different from original request			// Due to hand off to different EP say you connect to 			// port 80, but you end up on 49160						call.addr.maxlen = sizeof(InetAddress);			call.addr.buf = (unsigned char*) &epi->remoteAddress;  			call.opt.maxlen = 0;			call.opt.buf = NULL;			call.udata.maxlen = 0;			call.udata.buf = NULL;						err = OTRcvConnect(epi->erf, &call);			SetEPLastError(epi,err);			if (err !!= kOTNoError) {			    if (err == kOTLookErr) {			        OSStatus	lookStatus;			        lookStatus = OTLook(epi->erf);			        if (lookStatus == T_DISCONNECT) {               			err = OTRcvDisconnect(epi->erf, NULL);        	    		if (err !!= kOTNoError) {        		    		if (err == kOTNoDisconnectErr) {                    			err = OTRcvConnect(epi->erf, &call);                    			SetEPLastError(epi,err);                       			makeEPUnconnected(epi);       		    		        return;       		    		    }			            } else {                			err = OTRcvConnect(epi->erf, &call);                			SetEPLastError(epi,err);                   			makeEPUnconnected(epi);   		    		        return;			            }			        }			        if (lookStatus == T_GODATA) { // HUH            			err = OTRcvConnect(epi->erf, &call);            			SetEPLastError(epi,err);               			makeEPConnected(epi);	    		        return;			        }			    }                //JMM book says may return kOTNoDataErr (no connecton yet) or a kOTLookErr with T_DISCONNECT                // BUT we had got T_GODATA WHY?                 				makeEPUnconnected(epi);				return;			}						makeEPConnected(epi);			return;				// Wait for a T_DATA...		}				//		//	T_LISTEN:		//		case T_LISTEN:		{			DoListenAccept(epi,epi);			return;		}		//		//	T_DATA:		//		//	The main rule for processing T_DATA''s is to remember that once you have		//	a T_DATA, you won''t get another one until you have read to a kOTNoDataErr.		//	The advanced rule is to remember that you could get another T_DATA		//	during an OTRcv() which will eventually return kOTNoDataErr, presenting		//	the application with a synchronization issue to be most careful about.		//			//	In this application, since an OTRcv() calls are made from inside the notifier,		//	this particular synchronization issue doesn''t become a problem.		//		case T_DATA:		{			if (!!OTAtomicTestBit(&epi->stateFlags2, kPassconNeeded)) {			    ReadData(epi,NULL,0);			    return;			 }			 else {    			//    			//	Here we work around a small OpenTransport bug.    			//	It turns out, since this program does almost everything from inside the notifier,    			//	that during a T_UNBINDCOMPLETE we can put an EPInfo back into the idle list.    			//	If that notification is interrupted by a T_LISTEN at the notifier, we could    			//	end up starting a new connection on the endpoint before OT unwinds the stack    			//	out of the code which delivered the T_UNBINDCOMPLETE.   OT has some specific    			//	code to protect against a T_DATA arriving before the T_PASSCON, but in this    			//	case it gets confused and the events arrive out of order.   If we try to    			//	do an OTRcv() at this point we will get a kOTStateChangeErr because the endpoint    			//	is still locked by the earlier OTAccept call until the T_PASSCON is delivered    			//	to us.   This is fairly benign and can be worked around easily.  What we do    			//	is note that the T_PASSCON hasn''t arrived yet and defer the call to ReadData()    			//	until it does.    			//    			if ( OTAtomicSetBit(&epi->stateFlags, kPassconBit) !!= 0 )    			{    			    ReadData(epi,NULL,0);    			    return;    			}    		}		}							//		//	T_PASSCON:		//		//	This event happens on the accepting endpoint, not the listening endpoint.		//	At this point the connection is fully established and we can begin the		//	process of downloading data.  Note that due to a problem in OT it is 		//	possible for a T_DATA to beat a T_PASSCON to the notifier.  When this		//	happens we note it in the T_DATA case and then start processing the 		//	data here.  		//		case T_PASSCON:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {               	OTAtomicSetBit(&epi->stateFlags, kPassconBit);   				makeEPUnconnected(epi);				return;			}			   			makeEPConnected(epi);                		    if ( OTAtomicSetBit(&epi->stateFlags, kPassconBit) !!= 0 ){				//				//	A T_DATA previously beat the T_PASSCON to our notifier.				//	Here we help OT out by having deferred data processing until now.				//			    ReadData(epi,NULL,0);			}			return;		}		//		// T_MEMORYRELEASED		// lower level has finished with buffer						case T_MEMORYRELEASED:		{		    if (cookie == nil) return;			OTAtomicAdd32(-1, &epi->outstandingSends);				    	if (epi->socketType == UDPSocketType) {		        OTFreeMem(cookie);	    	} else {//tcp		    	if (gOTVersion < kOTVersion113) {		    		struct OTData *data=cookie;		    		OTFreeMem(data->fData);		    		OTFreeMem(data);		    	} else {		        	OTFreeMem(cookie);		        }	        }	        			    return;		}					//		//	T_DISCONNECT:		//		//	An inbound T_DISCONNECT event usually indicates that the other side of the		//	connection did an abortive disconnect (as opposed to an orderly release).		//	It also can be generated by the transport provider on the system (e.g. tcp)		//	when it decides that a connection is no longer in existance.		//		//	We receive the disconnect, but this program ignores the associated reason (NULL param).		//	It is possible to get back a kOTNoDisconnectErr from the OTRcvDisconnect call.		//	This can happen when either (1) the disconnect on the stream is hidden by a 		//	higher priority message, or (2) something has flushed or reset the disconnect		//	event in the meantime.   This is not fatal, and the appropriate thing to do is		//	to pretend the T_DISCONNECT event never happened.   Any other error is unexpected		//	and needs to be reported so we can fix it.  Next, unbind the endpoint so we can		//	reuse it for a new inbound connection.		//			//	It is possible to get an error on the unbind due to a bug in OT 1.1.1 and earlier.		//	The best thing to do for that is close the endpoint and open a new one to replace it.		//	We do this back in the main thread so we don''t have to deal with synchronization problems.		//		case T_DISCONNECT:		{			epState = OTGetEndpointState(epi->erf);			err = OTRcvDisconnect(epi->erf, NULL);						if (epState == T_OUTCON) { //01Aug2000 fix for bad port, will get disconnect on outgoing connection                makeEPUnconnected(epi);			}			if (err !!= kOTNoError) {				if (err == kOTNoDisconnectErr) return;			    makeEPBroken(epi,err);				return;			}			                ///                //Both sides now have closed                 //                        OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);						err = OTUnbind(epi->erf);    	    TapAllInterestedSemaphores(epi);			if (err !!= kOTNoError) {			    makeEPBroken(epi,err);			}			return;		}				//		//	T_GODATA:		//		//	This event is received when flow control is lifted.   We are under flow control		//	whenever OTSnd() returns a kOTFlowErr or accepted less bytes than we attempted		//	to send.  		//		//	Note, it is also possible to get a T_GODATA without having invoke flow control.		//	Be safe and prepare for this. 		//		case T_GODATA:		{            if (OTAtomicClearBit(&epi->stateFlags, kSendIsBlocked)) { 	           if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData))  	              interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex);            };			return;		}				//		//	T_OPENCOMPLETE:		//		//	This event occurs when an OTAsyncOpenEndpoint() completes.   Note that this event,		//	just like any other async call made from outside the notifier, can occur during		//	the call to OTAsyncOpenEndpoint().  That is, in the main thread the program did		//	the OTAsyncOpenEndpoint(), and the notifier is invoked before control is returned		//	to the line of code following the call to OTAsyncOpenEndpoint().   This is one		//	event we need to keep track of even if we are shutting down the program since there		//	is no way to cancel outstanding OTAsyncOpenEndpoint() calls.		//		case T_OPENCOMPLETE:		{			TOptMgmt 			optReq;			TOption             opt;			OTAtomicClearBit(&epi->stateFlags, kOpenInProgressBit);			if (result == kOTNoError)				epi->erf = (EndpointRef) cookie;			else {				makeEPBrokenThenIdle(epi,result);				return;			}			if (gProgramState !!= kProgramRunning) return;										//			//	Set to blocking mode so we don''t have to deal with kEAGAIN errors.			//	Async/blocking is the best mode to write an OpenTransport application in.			//			err = OTSetBlocking(epi->erf);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);				return;			}						//			//	Set to AckSends so OT doesn''t slow down to copy data sent out.			//	However, this requires special care when closing endpoints, so don''t use			//	AckSends unless you are prepared for this.   Never, ever, close an endpoint			//	when a send has been done but the T_MEMORYRELEASED event hasn''t been returned yet.			//			err = OTAckSends(epi->erf);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);				return;			}						//			//	Option Management			//			//	Turn on ip_reuseaddr so we don''t have port conflicts in general.			//	We use local stack structures here since the memory for the 			//	option request structure is free upon return.   If we were to request			//	the option return value, we would have to use static memory for it.			//			optReq.flags			= T_NEGOTIATE;			optReq.opt.len			= kOTFourByteOptionSize;			optReq.opt.buf			= (unsigned char *) &opt;						opt.len					= sizeof(TOption);			opt.level				= INET_IP;			opt.name				= IP_REUSEADDR;			opt.status				= 0;			opt.value[0]			= 1;			            if (epi->socketType == TCPSocketType)                 OTAtomicSetBit(&epi->stateFlags3, kKeepAliveOptionNeeded);                			err = OTOptionManagement(epi->erf, &optReq, NULL);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);			}						//			//	Code path resumes at T_OPTMGMTCOMPLETE			//						return;		}				//		//	T_OPTMGMTCOMPLETE:		//		//	An OTOptionManagement() call has completed.  These are used on all		//	endpoints to set IP_REUSEADDR.   It is also used for all endpoints		//	other than the listener to set TCP_KEEPALIVE which helps recover		//	server resources if the other side crashes or is unreachable.		//		case T_OPTMGMTCOMPLETE:		{			TOptMgmt 			optReq;			if (result !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,result);				return;			}			            if (OTAtomicClearBit(&epi->stateFlags3, kKeepAliveOptionNeeded)) {                                TKeepAliveOpt		opt;				//				//	Turn on TCP_KEEPALIVE so we can recover from connections which have				//	gone away which we don''t know about.  				//				optReq.flags			= T_NEGOTIATE;				optReq.opt.len			= sizeof(TKeepAliveOpt);				optReq.opt.buf			= (unsigned char *) &opt;								opt.len					= sizeof(TKeepAliveOpt);				opt.level				= INET_TCP;				opt.name				= TCP_KEEPALIVE;				opt.status				= 0;				opt.tcpKeepAliveOn		= 1;				opt.tcpKeepAliveTimer	= kTCPKeepAliveInMinutes;									err = OTOptionManagement(epi->erf, &optReq, NULL);				if (err !!= kOTNoError) {    			    makeEPBrokenThenIdle(epi,result);                }                return;            }						            makeEPIdle(epi);  //This is where more EP enter the queue of available EPs.            			return;			// now wait 		}		//		//	T_ORDREL:		//		//	This event occurs when an orderly release has been received on the stream.		//		case T_ORDREL:		{			err = OTRcvOrderlyDisconnect(epi->erf);						if (err !!= kOTNoError) {				//				//	It is possible for several reasons for the T_ORDREL to have disappeared,				//	or be temporarily hidden, when we attempt the OTRcvOrderlyDisconnect().				//	The best thing to do when this happens is pretend that the event never				//	occured.   We will get another notification of T_ORDREL if the event				//	becomes unhidden later.  Any other form of error is unexpected and 				//	is reported back so we can correct it.				//				if (err == kOTNoReleaseErr)					return;				//Can get OTLookErr with T_DISCONNECT    		   makeEPBroken(epi,err);			}				if (OTAtomicTestBit(&epi->stateFlags, kThisEndClosed)) {                                ///                //Both sides now have closed                //                                OTAtomicSetBit(&epi->stateFlags, kUnConnected);			    	        OTAtomicClearBit(&epi->stateFlags, kConnected);                OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			                OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);											epState = OTGetEndpointState(epi->erf);				if (epState !!= T_IDLE) {            	    TapAllInterestedSemaphores(epi);				    return;				}				err = OTUnbind(epi->erf);        	    TapAllInterestedSemaphores(epi);				if (err !!= kOTNoError) {				    makeEPBroken(epi,err);				}				    		    return;            } else {    			OTAtomicSetBit(&epi->stateFlags, kOtherEndClosed);			}						//			//	Sometimes our data sends get stopped with a kOTLookErr			//	because of a T_ORDREL from the other side (which doesn''t close			//	the connection, it just means they are done sending data).			//	If so, we still end up in the notifier with the T_ORDREL event,			//	but we won''t resume sending data unless we explictly check			//	here whether or not we need to do so.			//             //JMM Test this?             if (OTAtomicClearBit(&epi->stateFlags, kSendIsBlocked)) {  		    	if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData))                	interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex);            };			return;		}				//		//	T_UNBINDCOMPLETE:		//		//	This event occurs on completion of an OTUnbind().		//	The endpoint is ready for reuse on a new inbound connection.		//	Note that the OTLIFO structure has atomic queue and dequeue,		//	which can be helpful for synchronization protection.  		//		case T_UNBINDCOMPLETE:		{			if (result !!= kOTNoError) {				//				//	Unbind errors can occur as a result of a bug in OT 1.1.1 and earlier				//	versions.   The best recovery is to put the endpoint in the broken				//	list for recycling with a clean, new endpoint.				//  Since we only support 1.1.2 we don''t expect to run this code.				//			    makeEPBroken(epi,result);				return;			}			return;		}						//		//	T_DISCONNECTCOMPLETE:		//		//	This event occurs on completion of an OTSndDisconnect().		//	Called when we abort a socket		//		case T_DISCONNECTCOMPLETE: {			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) {			    makeEPBroken(epi,err);			}			purgeReadBuffers(epi);		            TapAllInterestedSemaphores(epi); 			if (OTAtomicTestBit(&epi->stateFlags2, kMakeEPIdle)) { //Make EP idle if marked as such only happens via destroy. 			    makeEPIdle(epi);			}			epi->stateFlags = 0;			epi->stateFlags2 = 0;			epi->stateFlags3 = 0;            SetEPLastError(epi,result);        	OTAtomicSetBit(&epi->stateFlags, kUnConnected);			return;		}				//		//Sleep sleep sleep all end points get trashed.		//		case kOTProviderWillClose: // reconfig stack disconnect and close		{		    makeEPBroken(epi,-12345678);            if(OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit)) return;            OTSetSynchronous(epi->erf);			        // set endpoint to sync	        	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )        		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);            OTSndDisconnect(epi->erf, NULL);            OTUnbind(epi->erf);            OTCloseProvider(epi->erf);            OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);			            OTAtomicSetBit(&epi->stateFlags3, kSleepKilledMe);            TapAllInterestedSemaphores(epi); 		    return;		}		case kOTProviderIsClosed: //Sleep lurks		{		    makeEPBroken(epi,-12345678);            OTSetSynchronous(epi->erf);			        // set endpoint to sync	        	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )        		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);            OTCloseProvider(epi->erf);            OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);			            OTAtomicSetBit(&epi->stateFlags3, kSleepKilledMe);            TapAllInterestedSemaphores(epi); 			return;		}		//		//	default:		//		//	There are events which we don''t handle, but we don''t expect to see		//	any of them.   When running in debugging mode while developing a program,		//	we exit with an informational alert.   Later, in the production version		//	of the program, we ignore the event and try to keep running.		//		default:		{			return;		}	}}////	Notifier for listen socket://static pascal void NotifierSocketListener(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	if (gProgramState !!= kProgramRunning)	{		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED))		{			return;		}	}	JMMLogMessageAndNumber("\p Listener Event  ",event);	JMMLogMessageAndNumber("\p Listener Result ",result);	JMMLogMessageAndNumber("\p Listener Id ",epi->semaIndex);		switch (event)	{		//		//	T_BINDCOMPLETE:		//		//	We only bind the listener endpoint, and bind failure is a fatal error.  		//	Acceptor endpoints are bound within the OTAccept() call when they get a connection.		//		case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError)   				makeEPUnconnected(epi);      			return;		}						//		//	T_LISTEN:		//		case T_LISTEN:		{            SetEPLastError(epi,result);   			makeEPConnected(epi);			return;		}		//		//	T_ACCEPTCOMPLETE:		//		//	This event is received by the listener endpoint only.   		//	The acceptor endpoint will get a T_PASSCON event instead.		//		case T_ACCEPTCOMPLETE:		{            SetEPLastError(epi,result);			return;		}				//		//	default:		//		//	There are events which we don''t handle, pass them onwards		//		default:		{            NotifierSocket(context,  event,  result, cookie);			return;		}	}}////	Notifier for UDP listen socket://static pascal void NotifierSocketUDP(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	OSStatus err;	JMMLogMessageAndNumber("\p DNS Event  ",event);	JMMLogMessageAndNumber("\p DNS Result ",result);	JMMLogMessageAndNumber("\p Id ",epi->semaIndex);	if (gProgramState !!= kProgramRunning) {		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED)) {			return;		}	}			switch (event)	{		//Some sort of UDP send error, too late to tell anyone?		//		case T_UDERR: {      		TUDErr 		uderr;		    InetAddress errorAddress;                        uderr.addr.maxlen   = sizeof(InetAddress);            uderr.addr.len      = sizeof(InetAddress);            uderr.addr.buf      = (UInt8 *) &errorAddress;            uderr.opt.maxlen    = 0;            uderr.opt.len       = 0;            uderr.opt.buf       = NULL;   		    err =  OTRcvUDErr(epi->erf, &uderr);            if (err !!= kOTNoError)   				makeEPBroken(epi,err);			            SetEPLastError(epi,uderr.error);		    return;		}				//		//	T_DATA:		//		//  Got milk?		//				case T_DATA: {			ReadData(epi,NULL,0);		    return;		}				//		//	T_BINDCOMPLETE:		//		//	This event is returned when an endpoint has been bound.		//	No errors are expected.   		//				case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {   				makeEPUnconnected(epi);				return;			}   			makeEPConnected(epi);			return;		}		//		//	default:		//		//	There are events which we don''t handle, pass them onwards to the regular notifier		//				default:		{            NotifierSocket(context,  event,  result, cookie);			return;		}    }}short	        gJMMFile=0;OTTimeStamp 	JMMStartTimeStamp;OTLIFO			JMMLogBufferLIFO;    	//  Buffers that are free to read intoOTLIFO*			JMMLogBufferBuffers			= &JMMLogBufferLIFO; void JMMWriteLog() {	OSErr			error;	OTLink* 	    list = OTReverseList(OTLIFOStealList(JMMLogBufferBuffers));	OTLink*		    link;	ReadBuffer      *aBuffer;	long           dummySize;	char			CH=0x0D;	if (true) return;		error = HCreate(0,0,"\pJMMFOOBAR.txt",''TEXT'',''TEXT'');	error = HOpenDF(0,0,"\pJMMFOOBAR.txt",fsRdWrPerm,&gJMMFile);	error = SetFPos(gJMMFile,fsFromLEOF,0);	while ( (link = list) !!= NULL ) {		list = link->fNext;    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);    	error = FSWrite(gJMMFile,(long *)&aBuffer->readBufferSize,aBuffer->readBufferData);    	dummySize = 1;    	error = FSWrite(gJMMFile,&dummySize,&CH);	}	error = FSClose(gJMMFile);		while ( (link = list) !!= NULL ) {		list = link->fNext;    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);        OTFreeMem(aBuffer->readBufferData);        OTFreeMem(aBuffer); 	}	}void JMMLogMessage(Str255 input) {	Str255 			timeString;	long 			timeStringLength,inputLength;	UInt32			duration;	ReadBuffer      *readBufferObject;		if (true) return;		if (gJMMFile == 0) {		gJMMFile = 1;		OTGetTimeStamp(&JMMStartTimeStamp);		JMMLogBufferBuffers->fHead 		= NULL;	}		duration = OTElapsedMilliseconds(&JMMStartTimeStamp);	NumToString(duration,timeString);	timeStringLength = (unsigned char) timeString[0];	inputLength = (unsigned char) input[0];		readBufferObject = OTAllocMem(sizeof(ReadBuffer));	if (readBufferObject == NULL) return;	OTMemzero(readBufferObject,sizeof(ReadBuffer));		readBufferObject->readBufferData = OTAllocMem(60);	if (readBufferObject->readBufferData == NULL) {	    OTFreeMem(readBufferObject);	    return;	}		OTMemcpy(readBufferObject->readBufferData,timeString+1,timeStringLength);	OTMemcpy(readBufferObject->readBufferData+timeStringLength,input+1,inputLength);	readBufferObject->readBufferSize= timeStringLength+inputLength;    OTLIFOEnqueue(JMMLogBufferBuffers, &readBufferObject->fNext);	}void JMMLogMessageAndNumber(Str255 msg,long number) {	Str255 buffer,numberString;	long msgLength,numberLength;		if (true) return;		NumToString(number,numberString);	numberLength = (unsigned char) numberString[0];	msgLength = (unsigned char) msg[0];		OTMemcpy(buffer+1,msg+1,msgLength);	OTMemcpy(buffer+1+msgLength,numberString+1,numberLength);	buffer[0] = (unsigned char) msgLength+numberLength;	JMMLogMessage(buffer);}/*The Open Transport TCP/IP software modules provide a RawIP interface to the IP protocolhostname of '''' lookup fails This is OK? Same on linux and old mac versionJMM look at tlook page, not sure if we have completely understood itJMM is it legal to send a zero byte buffer need case for this?/* According to the XTI spec ("Section 4.6 Events and TLOOK Error indication"), the SndOrderlyDisconnect and RcvOrderlyDisconnect calls can fail because of a pending T_DISCONNECT event. This is XTI trying to tell you that the a connection on that endpoint broke. This can happen in this asynchronous wacky world of networks and your program will have to call a RcvDisconnect to acknowledge that your endpoint dropped.You might want to check out the OTI spec, which, although it is not always written in the most lucid fashion, does contain valuable information for those involved in OpenTransport programming.Further Information:Title: X/OPEN TRANSPORT INTERFACE (XTI) VER 2 [ 1.0 ed]Author: X/OPEN ISBN #: 0133534596A Prior to Open Transport 1.3, there was no supported way of calling Open Transport from CFM-68K code. With the introduction of Open Transport 1.3, it is now possible to call the Open Transport client interface from CFM-68K code. The Open Transport 1.3 SDK includes stub libraries and a document, "Open Tpt CFM68K Dev. Note", which explains Open Transport''s support for CFM-68K. which is supporte for syste 7.x but you can''t install!! No standalone installer exists. Coping the OT files kinda works*/#else/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "SocketPlugin.h"/* initialize/shutdown */int socketInit() { return true; }int socketShutdown() { sqNetworkShutdown(); }/* End of adjustments for pluginized VM */#include <Events.h>#include <Devices.h>#include <Processes.h>#include <Traps.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "MacTCP.h"#include "AddressXLation.h"/*** Socket Type Constants ***/#define TCPSocketType 		0#define UDPSocketType 		1#define ListenerQueueType	2/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3/* Resolver State */typedef struct {	int				semaIndex;	int				status;	int				error;	int				localAddress;	int				remoteAddress;	struct hostInfo	hostInfo;} ResolverStatusRec, *ResolverStatusPtr;/*** TCP Socket Status Constants ***/#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4/*** TCP Socket State ***/#define SendBufferSize	(8 * 1024)#define RecvBufferSize	(8 * 1024)typedef struct {	TCPiopb		tcpPB;				/* TCP parameter block for open/send (must be first) */	TCPiopb		closePB;			/* TCP parameter block for close */	StreamPtr	tcpStream;			/* TCP stream */	void *		next;				/* next socket in a linked list of open sockets */	int			semaIndex;	int			connectStatus;	void *		nextInListenerQueue; /* next socket in a ListenderQueue waiting socket list */	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;//xxx	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} TCPSockRec, *TCPSockPtr;typedef struct {	TCPiopb		tcpPB;	TCPSockPtr	mySocket;	struct wdsEntry wds[2];	char		data[SendBufferSize];} TCPSendBuf, *TCPSendBufPtr;#define SendBufCount 8TCPSendBuf sendBufPool[SendBufCount];int nextSendBuf = 0;typedef struct {	int			localAddress;	int			localPort;	int			closed;				/* set true by close or abort */	int			semaIndex;			/* semaphore of the server socket */	int			desiredQueueLength;	TCPSockPtr	waitingSockets;} ListenerQueueRec, *ListenerQueuePtr;/*** UDP Socket Status Constants ***/#define UnknowRemoteAddrAndPort	0#define Ready					1/*** UDP Socket State ***/typedef struct {	void *		next;				/* next socket in a linked list of open sockets */	int			remoteAddress;	int			remotePort;	int			semaIndex;	int			connectStatus;	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} UDPSockRec, *UDPSockPtr;/*** Variables ***/extern struct VirtualMachine *interpreterProxy;short				macTCPRefNum = 0;int					mtuSize = 1024;TCPSockPtr 			openTCPSockets = nil;UDPSockPtr			openUDPSockets = nil;ResolverStatusRec 	resolver = {0, 0, 0, 0, 0, 0, 0};UniversalProcPtr	myExitHandlerProc = nil;UniversalProcPtr	oldExitHandlerProc = nil;ResultUPP			resolverDoneProc = nil;TCPIOCompletionUPP	tcpCloseDoneProc = nil;TCPIOCompletionUPP	tcpConnectDoneProc = nil;TCPNotifyUPP		tcpNotifyProc = nil;TCPIOCompletionUPP	tcpSendDoneProc = nil;UDPNotifyUPP		udpNotifyProc = nil;UDPIOCompletionUPP	udpSendDoneProc = nil;int					thisNetSession = 0;/*** Private TCP Socket Functions ***/void *		TCPSockCreate(void);void		TCPSockDestroy(TCPSockPtr s);void		TCPSockRemoveFromOpenList(TCPSockPtr s);int			TCPSockLocalAddress(TCPSockPtr s);int			TCPSockLocalPort(TCPSockPtr s);int			TCPSockRemoteAddress(TCPSockPtr s);int			TCPSockRemotePort(TCPSockPtr s);void		TCPSockConnectTo(TCPSockPtr s, int addr, int port);void		TCPSockListenOn(TCPSockPtr s, int port);void		TCPSockAbortConnection(TCPSockPtr s);void		TCPSockCloseConnection(TCPSockPtr s);int			TCPSockDataAvailable(TCPSockPtr s);int			TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize);int			TCPSockSendData(TCPSockPtr s, char *buf, int bufSize);/*** Private ListenerQueue Socket Functions ***/void		FillListenerQueue(ListenerQueuePtr listener);TCPSockPtr	FindConnectedSocket(ListenerQueuePtr listener);TCPSockPtr	FindZombieSocket(ListenerQueuePtr listener);void		RemoveSocketFromListenerQueue(TCPSockPtr sockToRemove, ListenerQueuePtr listener);ListenerQueuePtr ListenerQueueCreate(TCPSockPtr tcpSocket, int port, int backlogSize);void		ListenerQueueDestroy(ListenerQueuePtr listener);int			ListenerQueueStatus(ListenerQueuePtr listener);/*** Private UDP Socket Functions ***/void *		UDPSockCreate(void);void		UDPSockDestroy(UDPSockPtr s);void		UDPSockRemoveFromOpenList(UDPSockPtr s);int			UDPSockLocalAddress(UDPSockPtr s);int			UDPSockLocalPort(UDPSockPtr s);int			UDPSockRemoteAddress(UDPSockPtr s);int			UDPSockRemotePort(UDPSockPtr s);void		UDPSockConnectTo(UDPSockPtr s, int addr, int port);void		UDPSockListenOn(UDPSockPtr s, int port);int			UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize);int			UDPSockSendData(UDPSockPtr s, char *buf, int bufSize);/*** Other Private Functions ***/void		DestroyAllOpenSockets(void);void		InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr);void		InstallExitHandler(void);void		MyExitHandler(void);int			PortNumberValid(int port);pascal void	ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr);int			ResolverInitialize(int resolverSemaIndex);void		ResolverTerminate(void);int			SocketValid(SocketPtr s);void		TCPCloseCompletionRoutine(struct TCPiopb *s);void		TCPConnectCompletionRoutine(struct TCPiopb *s);pascal void	TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg);void		TCPSendCompletionRoutine(struct TCPiopb *s);/*** Network Functions ***/void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {  interpreterProxy->success(false);}int sqSockettoHostportSendDataBufCount(SocketPtr s, int address, int port, int buf, int bufSize) {  interpreterProxy->success(false);}int sqSocketGetOptionsoptionNameStartoptionNameSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int *result)	{  interpreterProxy->success(false);}void	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {  interpreterProxy->success(false);}int sqSocketReceiveUDPDataBufCountaddressportmoreFlag(SocketPtr s, int buf, int bufSize,  int *address,  int *port, int *moreFlag) {  interpreterProxy->success(false);}int sqSocketSetOptionsoptionNameStartoptionNameSizeoptionValueStartoptionValueSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int optionValueT, int optionValueSize, int *result)	{  interpreterProxy->success(false);}int sqNetworkInit(int resolverSemaIndex) {	/* initialize the network and return 0 if successful */	int localAddr;	UDPiopb paramBlock;	OSErr err = noErr;	if (thisNetSession !!= 0) return 0;  /* noop if network is already initialized */	/* open network driver */	macTCPRefNum = 0;	err = OpenDriver("\p.IPP", &macTCPRefNum);	if (err !!= noErr) {		return -1;	}	/* open resolver */	err = ResolverInitialize(resolverSemaIndex);	if (err !!= noErr) {		ResolverTerminate();		return -1;	}	/* get local address */	localAddr = sqResolverLocalAddress();	if (sqResolverError() !!= noErr) {		ResolverTerminate();		return -1;	}	/* compute MTU (maximum transfer unit) size */	memset(&paramBlock, 0, sizeof(paramBlock));	paramBlock.csCode = UDPMaxMTUSize;	paramBlock.csParam.mtu.remoteHost = localAddr;	paramBlock.ioCRefNum = macTCPRefNum;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err == noErr) {		mtuSize = paramBlock.csParam.mtu.mtuSize;	} else {		mtuSize = 1024;  /* guess */		ResolverTerminate();		return -1;	}	resolverDoneProc	= NewResultProc(ResolverCompletionRoutine);	tcpCloseDoneProc 	= NewTCPIOCompletionProc(TCPCloseCompletionRoutine);	tcpConnectDoneProc	= NewTCPIOCompletionProc(TCPConnectCompletionRoutine);	tcpNotifyProc		= NewTCPNotifyProc(TCPNotificationRoutine);	tcpSendDoneProc		= NewTCPIOCompletionProc(TCPSendCompletionRoutine);	InstallExitHandler();	/* Success!! Create a session ID that is unlikely to be	   repeated. Zero is never used for a valid session number.	*/	thisNetSession = clock() + time(NULL);	if (thisNetSession == 0) thisNetSession = 1;  /* don''t use 0 */	return 0;}void sqNetworkShutdown(void) {	/* shut down the network */	if (thisNetSession == 0) return;  /* noop if network is already shut down */	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	thisNetSession = 0;}/*** Squeak Generic Socket Functions ***/void sqSocketAbortConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockAbortConnection((TCPSockPtr) s->privateSocketPtr);		return;	}	if (s->socketType == ListenerQueueType) {		((ListenerQueuePtr) s->privateSocketPtr)->closed = true; /* set closed flag */		return;	}	success(false);}void sqSocketCloseConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockCloseConnection((TCPSockPtr) s->privateSocketPtr);		return;	}	if (s->socketType == ListenerQueueType) {		((ListenerQueuePtr) s->privateSocketPtr)->closed = true; /* set closed flag */		return;	}	success(false);}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->connectStatus;	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->connectStatus;	}	if (s->socketType == ListenerQueueType) {		return ListenerQueueStatus((ListenerQueuePtr) s->privateSocketPtr);	}	success(false);}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockConnectTo((TCPSockPtr) s->privateSocketPtr, addr, port);		return;	}	if (s->socketType == UDPSocketType) {		UDPSockConnectTo((UDPSockPtr) s->privateSocketPtr, addr, port);		return;	}	success(false);}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {	TCPSockPtr tcpSock = nil;	UDPSockPtr udpSock = nil;	/* reference args to suppress compiler warnings about unused variables */	s; netType; recvBufSize; sendBufSize;	s->sessionID = 0;	if (socketType == TCPSocketType) {		tcpSock = TCPSockCreate();		if (tcpSock == nil) {			success(false);		} else {			tcpSock->semaIndex = semaIndex;			tcpSock->next = openTCPSockets;			openTCPSockets = tcpSock;			s->sessionID = thisNetSession;			s->socketType = TCPSocketType;			s->privateSocketPtr = tcpSock;		}		return;	}	if (s->socketType == UDPSocketType) {		udpSock = UDPSockCreate();		if (udpSock == nil) {			success(false);		} else {			udpSock->semaIndex = semaIndex;			udpSock->next = openUDPSockets;			openUDPSockets = udpSock;			s->sessionID = thisNetSession;			s->socketType = UDPSocketType;			s->privateSocketPtr = udpSock;		}		return;	}	success(false);}void sqSocketDestroy(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockDestroy((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		UDPSockDestroy((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		ListenerQueueDestroy((ListenerQueuePtr) s->privateSocketPtr);	}	s->sessionID = 0;	s->socketType = -1;	s->privateSocketPtr = nil;}int sqSocketError(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->lastError;	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->lastError;	}	if (s->socketType == ListenerQueueType) {		return 0;  /* ListenerQueue''s themselves never get an error */	}}void sqSocketListenOnPort(SocketPtr s, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockListenOn((TCPSockPtr) s->privateSocketPtr, port);		return;	}	if (s->socketType == UDPSocketType) {		UDPSockListenOn((UDPSockPtr) s->privateSocketPtr, port);		return;	}	success(false);}int sqSocketLocalAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalAddress((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockLocalAddress((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		return ((ListenerQueuePtr) s->privateSocketPtr)->localAddress;	}	success(false);}int sqSocketLocalPort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalPort((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockLocalPort((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		return ((ListenerQueuePtr) s->privateSocketPtr)->localPort;	}	success(false);}int sqSocketReceiveDataAvailable(SocketPtr s) {	if (!!SocketValid(s)) return 0;	if (s->socketType == TCPSocketType) {		return TCPSockDataAvailable((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->dataAvailable;	}	success(false);}int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRecvData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	if (s->socketType == UDPSocketType) {		return UDPSockRecvData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	success(false);}int sqSocketRemoteAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemoteAddress((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockRemoteAddress((UDPSockPtr) s->privateSocketPtr);	}	success(false);}int sqSocketRemotePort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemotePort((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockRemotePort((UDPSockPtr) s->privateSocketPtr);	}	success(false);}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockSendData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	if (s->socketType == UDPSocketType) {		return UDPSockSendData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	success(false);}int sqSocketSendDone(SocketPtr s) {	if (!!SocketValid(s)) return 1;	if (s->socketType == TCPSocketType) {		return !!((TCPSockPtr) s->privateSocketPtr)->sendInProgress;	}	if (s->socketType == UDPSocketType) {		return !!((UDPSockPtr) s->privateSocketPtr)->sendInProgress;	}	success(false);}/*** Resolver Functions ***/void sqResolverAbort(void) {	int semaIndex;	/* abort the current request */	if (resolver.status == RESOLVER_BUSY) {		semaIndex = resolver.semaIndex;		ResolverTerminate();		ResolverInitialize(semaIndex);	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	/* copy the name found by the last address lookup into the given string */	memcpy(nameForAddress, resolver.hostInfo.cname, nameSize);}int sqResolverAddrLookupResultSize(void) {	return strlen(resolver.hostInfo.cname);}int sqResolverError(void) {	return resolver.error;}int sqResolverLocalAddress(void) {	struct GetAddrParamBlock paramBlock;	if (resolver.localAddress == 0) {		resolver.remoteAddress = 0;		memset(&paramBlock, 0, sizeof(struct GetAddrParamBlock));		paramBlock.ioResult = 1;		paramBlock.csCode = ipctlGetAddr;		paramBlock.ioCRefNum = macTCPRefNum;		PBControlSync((ParmBlkPtr) &paramBlock);		if (paramBlock.ioResult == noErr) {			resolver.status = RESOLVER_SUCCESS;			resolver.localAddress = paramBlock.ourAddress;			resolver.error = noErr;		} else {			resolver.status = RESOLVER_ERROR;			resolver.error = paramBlock.ioResult;		}	} else {		resolver.status = RESOLVER_SUCCESS;		resolver.error = noErr;	}	return resolver.localAddress;}int sqResolverNameLookupResult(void) {	/* return the result of the last successful lookup */	return resolver.remoteAddress;}void sqResolverStartAddrLookup(int address) {	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = AddrToName(address, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}void sqResolverStartNameLookup(char *hostName, int nameSize) {	char name[501];	int len; 	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	len = ((nameSize <= 500) ? nameSize : 500);	memcpy(name, hostName, len);	name[len] = ''\0'';	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = StrToAddr(name, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;		resolver.remoteAddress = resolver.hostInfo.addr[0];	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}int sqResolverStatus(void) {	return resolver.status;}/*** Private Resolver Functions ***/int ResolverInitialize(int resolverSemaIndex) {	if (resolver.status !!= RESOLVER_UNINITIALIZED) {		ResolverTerminate();	}	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;	resolver.error = OpenResolver(nil);	if (resolver.error !!= noErr) {		resolver.status = RESOLVER_ERROR;		return resolver.error;	}	resolver.semaIndex = resolverSemaIndex;	resolver.status = RESOLVER_SUCCESS;	return noErr;}static pascal void ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr) {	ResolverStatusPtr r = (ResolverStatusPtr) userDataPtr;	if ((r == null) || (r->status !!= RESOLVER_BUSY)) return;	/* completion routine */	if (r->hostInfo.rtnCode == noErr) {		r->status = RESOLVER_SUCCESS;		r->remoteAddress = hostInfoPtr->addr[0];	} else {		r->status = RESOLVER_ERROR;		r->error = hostInfoPtr->rtnCode;	}	signalSemaphoreWithIndex(r->semaIndex);}void ResolverTerminate(void) {	CloseResolver();	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;}/*** Squeak TCP Socket Listen/Accept Functions ***/ListenerQueuePtr ListenerQueueCreate(TCPSockPtr tcpSocket, int port, int backlogSize) {	ListenerQueuePtr listener;	/* allocate a new ListenerQueue */	listener = (ListenerQueuePtr) malloc(sizeof(ListenerQueueRec));	if (listener == nil) return nil;	/* initialize it */	listener->localAddress = TCPSockLocalAddress(tcpSocket);	listener->localPort = port;	listener->closed = false;	listener->semaIndex = tcpSocket->semaIndex;	listener->desiredQueueLength = (backlogSize < 1) ? 1 : backlogSize;	listener->waitingSockets = nil;	/* add the given socket to the new ListenerQueue */	tcpSocket->nextInListenerQueue = listener->waitingSockets;	listener->waitingSockets = tcpSocket;	TCPSockListenOn(tcpSocket, listener->localPort);	/* create additional waiting sockets in necessary to fill the ListenerQueue */	FillListenerQueue(listener);	return listener;}void ListenerQueueDestroy(ListenerQueuePtr listener) {	TCPSockPtr thisSock, nextSock;	/* destroy all sockets in this ListenerQueue''s waiting socket list */	thisSock = listener->waitingSockets;	while (thisSock !!= nil) {		nextSock = thisSock->nextInListenerQueue;		TCPSockDestroy(thisSock);		thisSock = nextSock;	}	/* clear a few fields, just in case of a dangling reference */	listener->closed = true;	listener->semaIndex = 0;	listener->waitingSockets = nil;	/* free the ListenerQueue */	free(listener);}int ListenerQueueStatus(ListenerQueuePtr listener) {	TCPSockPtr sock;	if (listener == nil) {		success(false);		return Unconnected;	}	if (listener->closed) return Unconnected;	/* check for zombie sockets; if there is one, clean up the queue */	if (FindZombieSocket(listener) !!= nil) {		FillListenerQueue(listener);  /* removes zombies and refills queue */	}	/* scan queue for a connected socket */	sock = FindConnectedSocket(listener);	return (sock == nil) ? WaitingForConnection : Connected;}void FillListenerQueue(ListenerQueuePtr listener) {	TCPSockPtr sock, newSock;	int count, socksToAdd;	/* remove from the queue and destroy any zombie sockets */	while ((sock = FindZombieSocket(listener)) !!= nil) {		RemoveSocketFromListenerQueue(sock, listener);		TCPSockDestroy(sock);	}	/* count the number of remaining sockets */	count = 0;	sock = listener->waitingSockets;	while (sock !!= nil) {		count++;		sock = sock->nextInListenerQueue;	}	/* create enough new sockets up to fill ListenerQueue to desired size */	socksToAdd = listener->desiredQueueLength - count;	while (socksToAdd > 0) {		newSock = TCPSockCreate();		if (newSock!!= nil) {			/* set semaphore of the new socket*/			newSock->semaIndex = listener->semaIndex;			/* record new socket in openTCPSockets */			newSock->next = openTCPSockets;			openTCPSockets = newSock;			/* add new socket to the listener queue and start it listening */			newSock->nextInListenerQueue = listener->waitingSockets;			listener->waitingSockets = newSock;			TCPSockListenOn(newSock, listener->localPort);		}		socksToAdd--;	}}TCPSockPtr FindConnectedSocket(ListenerQueuePtr listener) {  /* Return the first connected socket in the given ListenerQueue,     or nil if there isn''t one. */	TCPSockPtr sock;	sock = listener->waitingSockets;	while (sock !!= nil) {		if (sock->connectStatus == Connected) return sock;		sock = sock->nextInListenerQueue;	}	return nil;}TCPSockPtr FindZombieSocket(ListenerQueuePtr listener) {  /* Return the first socket in the given ListenerQueue that is not connected or     waiting for a connection (we call this a zombie), or nil if there isn''t one.     Zombies are created when a connection is made but broken again before an     accept has been done. Since a zombie are no longer waiting for a connection,     it takes the place of listening socket. If the queue became filled with zombies     no connections could get through. Thus, zombies must be eliminated. As the     saying goes: "the only good zombie is a dead zombie." */	TCPSockPtr sock;	sock = listener->waitingSockets;	while (sock !!= nil) {		if ((sock->connectStatus !!= WaitingForConnection) &&			(sock->connectStatus !!= Connected)) return sock;		sock = sock->nextInListenerQueue;	}	return nil;}void sqSocketAcceptFromRecvBytesSendBytesSemaID(  SocketPtr s, SocketPtr serverSocket,  int recvBufSize, int sendBufSize, int semaIndex) {  /* Accept a connection for the given server socket. The server socket must     have been turned into a listener queue via sqSocketListenOnPortBacklogSize().     If successful, s is initialized to newly connected socket using the     given paramenters, and a new listening socket will be created and added     to the ListenerQueue to maintain the desired queue length. Note that MacTCP     allows multiple sockets to be listening on the same port number and, indeed,     this is the only way to support the Unix socket notion of a socket backlog. */	ListenerQueuePtr listener;	TCPSockPtr connectedSock;	/* server socket must be a valid ListenerQueue */	if ((serverSocket == nil) ||		(serverSocket->sessionID !!= thisNetSession) ||		(serverSocket->socketType !!= ListenerQueueType) ||		(serverSocket->privateSocketPtr == nil)) {			success(false);			return;	}	/* result socket must be a new, unintialized socket */	if ((s == nil) ||		(s->sessionID !!= 0) ||		(s->socketType !!= 0) ||		(s->privateSocketPtr !!= nil)) {			success(false);			return;	}	/* look for a connected socket */	listener = (ListenerQueuePtr) serverSocket->privateSocketPtr;	connectedSock = FindConnectedSocket(listener);	if (connectedSock == nil) {		success(false);	} else {		/* remove connected socket from the listener queue */		RemoveSocketFromListenerQueue(connectedSock, listener);		/* fill in the result socket handle */		connectedSock->semaIndex = semaIndex;		s->sessionID = thisNetSession;		s->socketType = TCPSocketType;		s->privateSocketPtr = connectedSock;	}	/* ensure that the queue has the desired number of listenening sockets */	FillListenerQueue(listener);}void RemoveSocketFromListenerQueue(TCPSockPtr sockToRemove, ListenerQueuePtr listener) {	TCPSockPtr lastSock, thisSock;	if (sockToRemove == nil) return;	if (listener->waitingSockets == sockToRemove) {		listener->waitingSockets = sockToRemove->nextInListenerQueue;		sockToRemove->nextInListenerQueue = nil;		return;	}	lastSock = listener->waitingSockets;	thisSock = lastSock->nextInListenerQueue;	while (thisSock !!= nil) {		if (thisSock == sockToRemove) {			lastSock->nextInListenerQueue = sockToRemove->nextInListenerQueue;			sockToRemove->nextInListenerQueue = nil;			return;		}		lastSock = thisSock;		thisSock = lastSock->nextInListenerQueue;	}}void sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize) {	TCPSockPtr tcpSocket;	ListenerQueuePtr listener;	/* s must be an TCP socket that is initialized but unconnected */	if ((!!SocketValid(s)) || (s->socketType !!= TCPSocketType)) {		success(false);		return;	}	tcpSocket = (TCPSockPtr) s->privateSocketPtr;	if (tcpSocket->connectStatus !!= Unconnected) {		success(false);		return;	}	/* make sure the port number is in range */	if (!!PortNumberValid(port)) {;		success(false);		return;	}	/* create a new listener on the given with the given backlog size */	listener = ListenerQueueCreate((TCPSockPtr) s->privateSocketPtr, port, backlogSize);	if (listener == nil) {		success(false);		return;	}	/* mutate s into a listener socket: replace the original TCP socket in s with	   the new listener, and change the type of s to ListenerQueueType */	s->socketType = ListenerQueueType;	s->privateSocketPtr = listener;}/*** Private TCP Socket Functions ***/void * TCPSockCreate(void) {	TCPiopb paramBlock;	TCPSockPtr s = nil;	int minRcvBufSize, rcvBufSize;	OSErr err = noErr;	rcvBufSize = RecvBufferSize;	minRcvBufSize = (4 * mtuSize) + 1024;	if (rcvBufSize < minRcvBufSize) rcvBufSize = minRcvBufSize;	s = (TCPSockPtr) malloc(sizeof(TCPSockRec) + rcvBufSize);	if (s == nil) return nil;  /* allocation failed */	memset(s, 0, sizeof(TCPSockRec) + rcvBufSize);	InitTCPCmd(TCPCreate, nil, &paramBlock);	paramBlock.csParam.create.rcvBuff = s->rcvBuf;	paramBlock.csParam.create.rcvBuffLen = rcvBufSize;	paramBlock.csParam.create.notifyProc = tcpNotifyProc;	paramBlock.csParam.create.userDataPtr = (Ptr) s;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		free(s);		return nil;	}	s->tcpStream = paramBlock.tcpStream;	return s;}int TCPSockDataAvailable(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return false;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.amtUnreadData > 0;}void TCPSockDestroy(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return;  /* already destroyed */	}	InitTCPCmd(TCPRelease, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	TCPSockRemoveFromOpenList(s);	s->tcpStream = nil;	free(s);}int TCPSockLocalAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localHost;}int TCPSockLocalPort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localPort;}int TCPSockRemoteAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remoteHost;}int TCPSockRemotePort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remotePort;}void TCPSockRemoveFromOpenList(TCPSockPtr s) {	TCPSockPtr thisSock, nextSock, previousSock;	previousSock = nil;	for (thisSock = openTCPSockets; thisSock !!= nil; thisSock = nextSock) {		nextSock = thisSock->next;		if (thisSock == s) {			if (previousSock == nil) {				openTCPSockets = nextSock;			} else {				previousSock->next = nextSock;			}			break;		}		previousSock = thisSock;	}}void TCPSockConnectTo(TCPSockPtr s, int addr, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPActiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.remoteHost = addr;	s->tcpPB.csParam.open.remotePort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockListenOn(TCPSockPtr s, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPPassiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.localPort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockCloseConnection(TCPSockPtr s) {	/* Note: This operation uses a dedicated parameter block so that it	   can be invoked even in the previous send is not yet complete.	   It will eventually use a completion routine to delete the	   socket automatically. For now, this is the client''s responsibility.	*/	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPClose, s->tcpStream, &s->closePB);//	s->closePB.ioCompletion = tcpCloseDoneProc;	s->connectStatus = ThisEndClosed; // xxx remove when making this async	s->lastError = PBControlSync((ParmBlkPtr) &s->closePB);}void TCPSockAbortConnection(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPAbort, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	s->connectStatus = Unconnected;}int TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize) {	TCPiopb paramBlock;  /* use local parameter block since send may be using one in socket */	OSErr err = noErr;	int bytesRead;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	if (!!TCPSockDataAvailable(s)) return 0;  /* no data available */	InitTCPCmd(TCPRcv, s->tcpStream, &paramBlock);	paramBlock.csParam.receive.commandTimeoutValue = 1; /* finish in one second, data or not */	paramBlock.csParam.receive.rcvBuff = buf;	paramBlock.csParam.receive.rcvBuffLen = bufSize;	s->lastError = noErr;	err = PBControlSync((ParmBlkPtr) &paramBlock);  /* synchronous */	if (err == noErr) {		bytesRead = paramBlock.csParam.receive.rcvBuffLen;	} else {		/* if err == commandTimeout, no data was available */		bytesRead = 0;		if (!!((err == commandTimeout) || (err == connectionClosing))) {			s->lastError = err;		}	}	s->dataAvailable = (bytesRead !!= 0);  /* if we got data, there may be more */	return bytesRead;}int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize);int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	int sendCount;	struct wdsEntry wds[2];	buf;  /* xxx avoid compiler complaint about unreferenced vars */	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;//xxx	memcpy(s->sendBuf, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	wds[0].length = sendCount;//xxx		wds[0].ptr = s->sendBuf;	wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.send.wdsPtr = (Ptr) &wds;	s->tcpPB.csParam.send.pushFlag = true;	s->sendInProgress = true;	s->tcpPB.ioCompletion = tcpSendDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}int TCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	TCPSendBufPtr sendBuf;	int sendCount;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	sendBuf = &sendBufPool[nextSendBuf++];	if (nextSendBuf >= SendBufCount) nextSendBuf = 0;	sendBuf->mySocket = s;	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;	memcpy(sendBuf->data, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	sendBuf->wds[0].length = sendCount;	sendBuf->wds[0].ptr = sendBuf->data;	sendBuf->wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &sendBuf->tcpPB);	sendBuf->tcpPB.csParam.send.wdsPtr = (Ptr) &sendBuf->wds;	sendBuf->tcpPB.csParam.send.pushFlag = true;	sendBuf->tcpPB.ioCompletion = tcpSendDoneProc;	s->sendInProgress = true;	s->lastError = PBControlAsync((ParmBlkPtr) &sendBuf->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}/*** Private General Utilities ***/void DestroyAllOpenSockets(void) {	while (openTCPSockets !!= nil) {		TCPSockDestroy(openTCPSockets);  /* removes socket from the list */	}	while (openUDPSockets !!= nil) {		UDPSockDestroy(openUDPSockets);  /* removes socket from the list */	}}void InstallExitHandler(void) {	/* Install a handler to release all open sockets when terminating this	   application. The handler will be called even if you type ''es'' to	   MacsBug or use Command-Option-Escape for force the program to exit.	   The handler is only installed the first time the network is initialized.	*/	if (oldExitHandlerProc == nil) {		oldExitHandlerProc = GetToolTrapAddress(_ExitToShell);		myExitHandlerProc = 			NewRoutineDescriptor((ProcPtr) MyExitHandler, kPascalStackBased, GetCurrentISA());		SetToolTrapAddress(myExitHandlerProc, _ExitToShell);	}}void MyExitHandler(void) {	SetCurrentA5();	if (thisNetSession == 0) return;  /* noop if network is already shut down */	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	ExitToShell();}int PortNumberValid(int port) {	if (port < 0xFFFF) {		return true;	}	success(false);	return false;}int SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == thisNetSession)) {			if (s->socketType == TCPSocketType) {				if (((TCPSockPtr) s->privateSocketPtr)->tcpStream !!= nil) {					return true;				}			}			return true;	}	success(false);	return false;}/*** Private TCP Utilities ***/void InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr) {	memset(paramBlkPtr, 0, sizeof(TCPiopb));	paramBlkPtr->csCode = cmd;	paramBlkPtr->tcpStream = tcpStream;	paramBlkPtr->ioCRefNum = macTCPRefNum;	paramBlkPtr->ioResult = 1;}void TCPCloseCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		if (s->connectStatus == OtherEndClosed) {			s->connectStatus = Unconnected;		} else {			s->connectStatus = ThisEndClosed;		}	}	signalSemaphoreWithIndex(s->semaIndex);}void TCPConnectCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		s->connectStatus = Connected;	} else {		s->connectStatus = Unconnected;	}	signalSemaphoreWithIndex(s->semaIndex);}pascal void TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg) {	/* called when data arrives or stream status changes */	/* reference args to suppress compiler warnings about unused variables */	s; terminReason; icmpMsg;	if (eventCode == TCPDataArrival) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->dataAvailable = true;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPClosing) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		if (tcpSock->connectStatus == ThisEndClosed) {			tcpSock->connectStatus = Unconnected;		} else {			tcpSock->connectStatus = OtherEndClosed;		}		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPTerminate) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->connectStatus = Unconnected;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}}void TCPSendCompletionRoutine(struct TCPiopb *pbPtr) {//xxx	TCPSockPtr s = (TCPSockPtr) pbPtr;TCPSockPtr s = ((TCPSendBufPtr) pbPtr)->mySocket;	s->lastError = s->tcpPB.ioResult;	s->sendInProgress = false;	signalSemaphoreWithIndex(s->semaIndex);}/*** Private UDP Socket Functions (not yet implemented) ***/void * UDPSockCreate(void) {	return nil;}void UDPSockDestroy(UDPSockPtr s) {	s;}int UDPSockLocalAddress(UDPSockPtr s) {	s;}int UDPSockLocalPort(UDPSockPtr s) {	s;}int UDPSockRemoteAddress(UDPSockPtr s) {	s;}int UDPSockRemotePort(UDPSockPtr s) {	s;}void UDPSockConnectTo(UDPSockPtr s, int addr, int port) {	s; addr; port;}void UDPSockListenOn(UDPSockPtr s, int port) {	s; port;}int UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize) {	s; buf; bufSize;}int UDPSockSendData(UDPSockPtr s, char *buf, int bufSize) {	s; buf; bufSize;}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 8/3/2000 15:05'!macSerialAndMIDIPortFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "SerialPlugin.h"#include "MidiPlugin.h"/* initialize/shutdown */int midiInit() { return true; }int midiShutdown() {}int serialPortInit() { return true; }int serialPortShutdown() {	serialPortClose(0);	serialPortClose(1);}/* helper function for MIDI module */int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIParameterSet(int whichParameter, int newValue) {	sqMIDIParameter(whichParameter, true, newValue);}int sqMIDIParameterGet(int whichParameter) {	sqMIDIParameter(whichParameter, false, 0);}/* End of adjustments for pluginized VM */#include <CommResources.h>#include <CRMSerialDevices.h>#include <Devices.h>#include <QuickTimeComponents.h>#include <QuickTimeMusic.h>#include <Serial.h>#include <Strings.h>/*** Constants ***/#define INPUT_BUF_SIZE 1000#define FIRST_DRUM_KIT 16385/*** Imported Variables ***/extern int successFlag;/*** Serial Ports ***/#define MAX_PORTS 4short inRefNum[MAX_PORTS] = {0, 0, 0, 0};short outRefNum[MAX_PORTS] = {0, 0, 0, 0};char inputBuffer[MAX_PORTS][INPUT_BUF_SIZE];/* Quicktime MIDI note allocator and channels */NoteAllocator na = nil;NoteChannel channel[16] = {	nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil};/* Initial instruments: drums on channel 10, piano on all other channels */int channelInstrument[16] = {	1, 1, 1, 1, 1, 1, 1, 1, 1, FIRST_DRUM_KIT, 1, 1, 1, 1, 1, 1};/* Quicktime MIDI parser state */enum {idle, want1of2, want2of2, want1of1, sysExclusive};int state = idle;int argByte1 = 0;int argByte2 = 0;int lastCmdByte = nil;/* number of argument bytes for each MIDI command */char argumentBytes[128] = {	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	3, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};/*** Private Functions ***/int portIsOpen(int portNum);int portNames(int portNum, char *portName, char *inName, char *outName);int serialPortCount(void);int setHandshakeOptions(int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int setMidiClockRate(int portNum, int interfaceClockRate);/*** Quicktime MIDI Support Functions ***/void closeQuicktimeMIDIPort(void);void openQuicktimeMIDIPort(void);void performMIDICmd(int cmdByte, int arg1, int arg2);void processMIDIByte(int aByte);void startMIDICommand(int cmdByte);int serialPortCount(void) {  /* Return the number of serial ports available on this machine */ 	CRMRec		commRec; 	CRMRecPtr	thisRecPtr; 	int			count = 0; 	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    }    if (count > MAX_PORTS) count = MAX_PORTS; 	return count; }int portIsOpen(int portNum) {	if ((portNum < 0) || (portNum > 1)) return false;	return outRefNum[portNum] !!= 0;}int portNames(int portNum, char *portName, char *inName, char *outName) {/* Fill in the user name and input and output port names for the given   port number. Note that ports are numbered starting with zero. */ 	CRMRec			commRec; 	CRMRecPtr		thisRecPtr; 	CRMSerialPtr	serialPtr; 	int				count = 0;  	portName[0] = inName[0] = outName[0] = 0;	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		if (count == portNum) {			serialPtr = (CRMSerialPtr) thisRecPtr->crmAttributes;			CopyPascalStringToC((void *) *(serialPtr->name),portName);			CopyPascalStringToC((void *) *(serialPtr->inputDriverName),inName);			CopyPascalStringToC((void *) *(serialPtr->outputDriverName),outName); 		} 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    } }int setHandshakeOptions(  int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Set the given port''s handshaking parameters. */	SerShk handshakeOptions;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	handshakeOptions.fInX = false;	handshakeOptions.fDTR = false;	if (inFlowCtrl == 1) handshakeOptions.fInX = true;  /* XOn/XOff handshaking */	if (inFlowCtrl == 2) handshakeOptions.fDTR = true;  /* hardware handshaking */	handshakeOptions.fXOn = false;	handshakeOptions.fCTS = false;	if (outFlowCtrl == 1) handshakeOptions.fXOn = true;  /* XOn/XOff handshaking */	if (outFlowCtrl == 2) handshakeOptions.fCTS = true;  /* hardware handshaking */	handshakeOptions.xOn  = xOnChar;	/* XOn character */	handshakeOptions.xOff = xOffChar;	/* XOff character */	handshakeOptions.errs = 0;			/* clear errors mask bits */	handshakeOptions.evts = 0;			/* clear event enable mask bits */	osErr = Control(outRefNum[portNum], 14, &handshakeOptions);	if (osErr !!= noErr) {		success(false);	}}int setMidiClockRate(int portNum, int interfaceClockRate) {/* Put the given port into MIDI mode, which uses a clock supplied   by an external MIDI interface adaptor to determine the baud rate.   Possible external clock rates: 31.25 KHz, 0.5 MHz, 1 MHz, or 2 MHz. */	char midiParam = 15;  /* dummy value */	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	if (interfaceClockRate ==   31250) midiParam = 0x00;	if (interfaceClockRate ==  500000) midiParam = 0x40;	if (interfaceClockRate == 1000000) midiParam = 0x80;	if (interfaceClockRate == 2000000) midiParam = 0xC0;	if (midiParam == 15) {		return success(false);  /* bad interfaceClockRate */	}	osErr = Control(outRefNum[portNum], 15, &midiParam);	if (osErr !!= noErr) {		return success(false);	}}/*** Serial Port Functions ***/int serialPortClose(int portNum) {	int osErr;	if ((portNum < 0) || (portNum > 1)) {		return success(false); /* bad port number */	}	if (!!portIsOpen(portNum)) {		return;  /* already closed */	}	osErr = KillIO(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(inRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	inRefNum[portNum] = 0;	outRefNum[portNum] = 0;}int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Open the given serial port using the given settings. The baud rate can be   any number between about 224 and 57600; the driver will pick a clock   divisor that will generate the closest available baud rate. */	short int options, baudRateParam;	char userName[256], inName[256], outName[256];	int osErr;	if ((portNum < 0) || (portNum > 1) || portIsOpen(portNum)) {		return success(false); /* bad port number or port already open */	}	options = baud9600;	switch (stopBitsType) {	case 0:		options += stop15;		break;	case 1:		options += stop10;		break;	case 2:		options += stop20;		break;	default:		return success(false);	}	switch (parityType) {	case 0:		options += noParity;		break;	case 1:		options += oddParity;		break;	case 2:		options += evenParity;		break;	default:		return success(false);	}	switch (dataBits) {	case 5:		options += data5;		break;	case 6:		options += data6;		break;	case 7:		options += data7;		break;	case 8:		options += data8;		break;	default:		return success(false);	}	portNames(portNum, userName, inName, outName);	CopyCStringToPascal((const char *)outName,(unsigned char *) outName);	osErr = OpenDriver((unsigned char *)outName, &outRefNum[portNum]);	if (osErr !!= noErr) {		return success(false);	}	CopyCStringToPascal((const char *)inName,(unsigned char *)inName);	osErr = OpenDriver((unsigned char *)inName, &inRefNum[portNum]);	if (osErr !!= noErr) {		CloseDriver(outRefNum[portNum]);		return success(false);	}	/* set the handshaking options */	setHandshakeOptions(portNum, inFlowCtrl, outFlowCtrl, xOnChar, xOffChar);	/* install a larger input buffer */	osErr = SerSetBuf(inRefNum[portNum], &inputBuffer[portNum][0], INPUT_BUF_SIZE);	if (osErr !!= noErr) {		success(false);	}	/* set data bits, parity type, and stop bits */	osErr = SerReset(outRefNum[portNum], options);	if (osErr !!= noErr) {		success(false);	}	/* set the baud rate (e.g., the value 9600 gives 9600 baud) */	baudRateParam = baudRate;	osErr = Control(outRefNum[portNum], 13, &baudRateParam);	if (osErr !!= noErr) {		success(false);	}	if (!!successFlag) {		CloseDriver(inRefNum[portNum]);		CloseDriver(outRefNum[portNum]);		inRefNum[portNum] = 0;		outRefNum[portNum] = 0;	}}int serialPortReadInto(int portNum, int count, int bufferPtr) {/* Read up to count bytes from the given serial port into the given byte array.   Read only up to the number of bytes in the port''s input buffer; if fewer bytes   than count have been received, do not wait for additional data to arrive.   Return zero if no data is available. */	long int byteCount;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = SerGetBuf(inRefNum[portNum], &byteCount);  /* bytes available */	if (osErr !!= noErr) {		return success(false);	}	if (byteCount > count) byteCount = count;  /* read at most count bytes */	osErr = FSRead(inRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}int serialPortWriteFrom(int portNum, int count, int bufferPtr) {/* Write count bytes from the given byte array to the given serial port''s   output buffer. Return the number of bytes written. This implementation is   synchronous: it doesn''t return until the data has been sent. However, other   implementations may return before transmission is complete. */	long int byteCount = count;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = FSWrite(outRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}/*** MIDI Parameters (used with sqMIDIParameter function) ***/#define sqMIDIInstalled				1/* Read-only. Return 1 if a MIDI driver is installed, 0 if not.   On OMS-based MIDI drivers, this returns 1 only if the OMS   system is properly installed and configured. */#define sqMIDIVersion				2/* Read-only. Return the integer version number of this MIDI driver.   The version numbering sequence is relative to a particular driver.   That is, version 3 of the Macintosh MIDI driver is not necessarily   related to version 3 of the Win95 MIDI driver. */#define sqMIDIHasBuffer				3/* Read-only. Return 1 if this MIDI driver has a time-stamped output   buffer, 0 otherwise. Such a buffer allows the client to schedule   MIDI output packets to be sent later. This can allow more precise   timing, since the driver uses timer interrupts to send the data   at the right time even if the processor is in the midst of a   long-running Squeak primitive or is running some other application   or system task. */#define sqMIDIHasDurs				4/* Read-only. Return 1 if this MIDI driver supports an extended   primitive for note-playing that includes the note duration and   schedules both the note-on and the note-off messages in the   driver. Otherwise, return 0. */#define sqMIDICanSetClock			5/* Read-only. Return 1 if this MIDI drivers clock can be set   via an extended primitive, 0 if not. */#define sqMIDICanUseSemaphore		6/* Read-only. Return 1 if this MIDI driver can signal a semaphore   when MIDI input arrives. Otherwise, return 0. If this driver   supports controller caching and it is enabled, then incoming   controller messages will not signal the semaphore. */#define sqMIDIEchoOn				7/* Read-write. If this flag is set to a non-zero value, and if   the driver supports echoing, then incoming MIDI events will   be echoed immediately. If this driver does not support echoing,   then queries of this parameter will always return 0 and   attempts to change its value will do nothing. */#define sqMIDIUseControllerCache	8/* Read-write. If this flag is set to a non-zero value, and if   the driver supports a controller cache, then the driver will   maintain a cache of the latest value seen for each MIDI controller,   and control update messages will be filtered out of the incoming   MIDI stream. An extended MIDI primitive allows the client to   poll the driver for the current value of each controller. If   this driver does not support a controller cache, then queries   of this parameter will always return 0 and attempts to change   its value will do nothing. */#define sqMIDIEventsAvailable		9/* Read-only. Return the number of MIDI packets in the input queue. */#define sqMIDIFlushDriver			10/* Write-only. Setting this parameter to any value forces the driver   to flush its I/0 buffer, discarding all unprocessed data. Reading   this parameter returns 0. Setting this parameter will do nothing   if the driver does not support buffer flushing. */#define sqMIDIClockTicksPerSec		11/* Read-only. Return the MIDI clock rate in ticks per second. */#define sqMIDIHasInputClock			12/* Read-only. Return 1 if this MIDI driver timestamps incoming   MIDI data with the current value of the MIDI clock, 0 otherwise.   If the driver does not support such timestamping, then the   client must read input data frequently and provide its own   timestamping. *//*** MIDI Functions ***/int sqMIDIClosePort(int portNum) {/* Close the given MIDI port. Do nothing if the port is not open.   Fail if there is no port of the given number.*/	int serialPorts;		serialPorts = serialPortCount();	if (portNum == serialPorts) {		closeQuicktimeMIDIPort();		return;	} else {		return serialPortClose(portNum);	}}int sqMIDIGetClock(void) {/* Return the current value of the clock used to schedule MIDI events.   The MIDI clock is assumed to wrap at or before half the maximum   positive SmallInteger value. This allows events to be scheduled   into the future without overflowing into LargePositiveIntegers.    This implementation does not support event scheduling, so it   just returns the value of the Squeak millisecond clock. */	return ioMicroMSecs();}int sqMIDIGetPortCount(void) {/* Return the number of available MIDI interfaces, including both   hardware ports and software entities that act like ports. Ports   are numbered from 0 to N-1, where N is the number returned by this   primitive. */	return serialPortCount() + 1;  /* serial ports + QuickTime Synth */}int sqMIDIGetPortDirectionality(int portNum) {/* Return an integer indicating the directionality of the given   port where: 1 = input, 2 = output, 3 = bidirectional. Fail if   there is no port of the given number. */		int serialPorts;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		return 2;	} else {		return 3;	}}int sqMIDIGetPortName(int portNum, int namePtr, int length) {/* Copy the name of the given MIDI port into the string at the given   address. Copy at most length characters, and return the number of   characters copied. Fail if there is no port of the given number.*/	char userName[256], inName[256], outName[256];	int serialPorts, count;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		strcpy(userName, "QuickTime MIDI");	} else {		portNames(portNum, userName, inName, outName);	}	count = strlen(userName);	if (count > length) count = length;	memcpy((void *) namePtr, userName, count);	return count;}int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate) {/* Open the given port, if possible. If non-zero, readSemaphoreIndex   specifies the index in the external objects array of a semaphore   to be signalled when incoming MIDI data is available. Note that   not all implementations support read semaphores (this one does   not); see sqMIDICanUseSemaphore. The interfaceClockRate parameter   specifies the clock speed for an external MIDI interface   adaptor on platforms that use such adaptors (e.g., Macintosh).   Fail if there is no port of the given number.*/	int serialPorts;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		openQuicktimeMIDIPort();		return;	}	serialPortOpen(portNum, 9600, 1, 0, 8, 0, 0, 0, 0);	if (successFlag) {		setMidiClockRate(portNum, interfaceClockRate);		if (!!successFlag) {			serialPortClose(portNum);		}	}}int sqMIDIParameter(int whichParameter, int modify, int newValue) {/* Read or write the given MIDI driver parameter. If modify is 0,   then newValue is ignored and the current value of the specified   parameter is returned. If modify is non-zero, then the specified   parameter is set to newValue. Note that many MIDI driver parameters   are read-only; attempting to set one of these parameters fails.   For boolean parameters, true = 1, false = 0. */	if (modify == 0) {		switch(whichParameter) {		case sqMIDIInstalled:			return 1;			break;		case sqMIDIVersion:			return 100;			break;		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:		case sqMIDIEchoOn:		case sqMIDIUseControllerCache:			return 0;			break;		case sqMIDIEventsAvailable:			return 1;  /* pretend that events are always available */			break;		case sqMIDIFlushDriver:			return 0;			break;		case sqMIDIClockTicksPerSec:			return 1000;			break;		case sqMIDIHasInputClock:			return 0;			break;		default:			return success(false);		}	} else {		switch(whichParameter) {		case sqMIDIInstalled:		case sqMIDIVersion:		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:			return success(false);			break;		case sqMIDIEchoOn:			/* noop; echoing not supported */			break;		case sqMIDIUseControllerCache:			/* noop; controller cache not supported */			break;		case sqMIDIEventsAvailable:			return success(false);			break;		case sqMIDIFlushDriver:			/* noop; buffer flushing not supported */			break;		case sqMIDIClockTicksPerSec:			return success(false);			break;		default:			return success(false);		}	}}int sqMIDIPortReadInto(int portNum, int count, int bufferPtr) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Copy up to (length - 4) bytes   of incoming MIDI data into that buffer, preceded by a 4-byte   timestamp in the units of the MIDI clock, most significant byte   first. Implementations that do not support timestamping of   incoming data as it arrives (see sqMIDIHasInputClock) simply   set the timestamp to the value of the MIDI clock when this   function is called. Return the total number of bytes read,   including the timestamp bytes. Return zero if no data is   available. Fail if the buffer is shorter than five bytes,   since there must be enough room for the timestamp plus at   least one data byte. */	int bytesRead;	if (count < 5) return success(false);	bytesRead = serialPortReadInto(portNum, count - 4, bufferPtr + 4);	if (bytesRead == 0) return 0;	*((int *) bufferPtr) = sqMIDIGetClock();  /* set timestamp */	return bytesRead + 4;}int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Send its contents to the given   port when the MIDI clock reaches the given time. If time equals   zero, then send the data immediately. Implementations that do   not support a timestamped output queue, such as this one, always   send the data immediately; see sqMIDIHasBuffer. */	int serialPorts, i;	unsigned char *bytePtr;		serialPorts = serialPortCount();	if (portNum > serialPorts) return success(false);	if (portNum == serialPorts) {		if (!!na) return success(false);  /* QuickTime port not open */		bytePtr = (unsigned char *) bufferPtr;		for (i = 0; i < count; i++) {			processMIDIByte(*bytePtr++);		}		return count;	}	return serialPortWriteFrom(portNum, count, bufferPtr);}/*** Quicktime MIDI Support Functions ***/void closeQuicktimeMIDIPort(void) {	int i;	if (!!na) return;	for (i = 0; i < 16; i++) {		/* dispose of note channels */		if (channel[i]) NADisposeNoteChannel(na, channel[i]);		channel[i] = nil;	}	CloseComponent(na);  /* close note allocator */}void openQuicktimeMIDIPort(void) {	ComponentResult err;	NoteRequest nr;	NoteChannel nc;	int i;	closeQuicktimeMIDIPort();	na = OpenDefaultComponent(''nota'', 0);	if (!!na) return;	for (i = 0; i < 16; i++) {		nr.info.polyphony = 11;					/* max simultaneous tones */		nr.info.typicalPolyphony = 0x00010000;	/* typical simultaneous tones */		NAStuffToneDescription(na, 1, &nr.tone);		err = NANewNoteChannel(na, &nr, &nc);		if (err || !!nc) {			closeQuicktimeMIDIPort();			return;		}		NAResetNoteChannel(na, nc);		NASetInstrumentNumber(na, nc, channelInstrument[i]);		channel[i] = nc;	}	state = idle;	argByte1 = 0;	argByte2 = 0;	lastCmdByte = nil;	return;}void performMIDICmd(int cmdByte, int arg1, int arg2) {	/* Perform the given MIDI command with the given arguments. */	int ch, cmd, val, instrument, bend;	ch = cmdByte & 0x0F;	cmd = cmdByte & 0xF0;	if (cmd == 128) {  /* note off */		NAPlayNote(na, channel[ch], arg1, 0);	}	if (cmd == 144) {  /* note on */		NAPlayNote(na, channel[ch], arg1, arg2);	}	if (cmd == 176) {  /* control change */		if ((arg1 >= 32) && (arg1 <= 63)) {			val = arg2 << 1;  /* LSB of controllers 0-31 */		} else {			val = arg2 << 8;  /* scale MSB to QT controller range */		}		NASetController(na, channel[ch], arg1, val);	}	if (cmd == 192) {  /* program change */		if (ch == 9) {			instrument = FIRST_DRUM_KIT + arg1;  /* if channel 10, select a drum set */		} else {			instrument = arg1 + 1;		}		NASetInstrumentNumber(na, channel[ch], instrument);		channelInstrument[ch] = instrument;	}	if (cmd == 224) {  /* pitch bend */		bend = ((arg2 << 7) + arg1) - (64 << 7);		bend = bend / 32;  /* default sensitivity = +/- 2 semitones */		NASetController(na, channel[ch], kControllerPitchBend, bend);	}}void processMIDIByte(int aByte) {	/* Process the given incoming MIDI byte and perform any completed commands. */	if (aByte > 247) return;  /* skip all real-time messages */	switch (state) {	case idle:		if (aByte >= 128) {			/* start a new command using the action table */			startMIDICommand(aByte);		} else {			/* data byte arrived in idle state: use running status if possible */			if (lastCmdByte == nil) {				return;  /* last command byte is not defined; just skip this byte */			} else {				/* process this data as if it had the last command byte in front of it */				startMIDICommand(lastCmdByte);				/* the previous line put us into a new state; we now do a recursive			   	   call to process the data byte in this new state. */				processMIDIByte(aByte);				return;			}		}		break;	case want1of2:		argByte1 = aByte;		state = want2of2;		break;	case want2of2:		argByte2 = aByte;		performMIDICmd(lastCmdByte, argByte1, argByte2);		state = idle;		break;	case want1of1:		argByte1 = aByte;		performMIDICmd(lastCmdByte, argByte1, 0);		state = idle;		break;	case sysExclusive:		if (aByte < 128) {			/* skip a system exclusive data byte */		} else {			if (aByte < 248) {				/* a system exclusive message can be terminated by any non-real-time command byte */				state = idle;				if (aByte !!= 247) {					processMIDIByte(aByte);	/* if not endSysExclusive, byte is the start the next command */				}			}		}		break;	}}void startMIDICommand(int cmdByte) {	/* Start processing a MIDI message beginning with the given command byte. */	int argCount;	argCount = argumentBytes[cmdByte - 128];	switch (argCount) {	case 0:						/* start a zero argument command (e.g., a real-time message) */		/* Stay in the current state and don''t change active status.		   Real-time messages may arrive between data bytes without disruption. */		performMIDICmd(cmdByte, 0, 0);		break;	case 1:						/* start a one argument command */		lastCmdByte = cmdByte;		state = want1of1;		break;	case 2:						/* start a two argument command */		lastCmdByte = cmdByte;		state = want1of2;		break;	case 3:						/* start a variable length ''system exclusive'' command */		/* a system exclusive command clears running status */		lastCmdByte = nil;		state = sysExclusive;		break;	}}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 8/14/2000 19:56'!macWindowFile	^ '#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include <sound.h>#include "sq.h"#include <DriverServices.h>/*** Compilation Options:**	define PLUGIN		to compile code for Netscape or IE Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE//Aug 7th 2000,JMM Added logic for interrupt driven dispatching#if TARGET_API_MAC_CARBON    #define EnableMenuItemCarbon(m1,v1)  EnableMenuItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableMenuItem(m1,v1);#else    #ifndef NewAEEventHandlerUPP    	#define NewAEEventHandlerUPP NewAEEventHandlerProc     #endif    #define EnableMenuItemCarbon(m1,v1)  EnableItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableItem(m1,v1);        inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}          inline BitMap *GetQDGlobalsScreenBits(BitMap *bm){*bm = qd.screenBits; return &qd.screenBits; }        inline BitMap * GetPortBitMapForCopyBits (CGrafPtr w) { return &((GrafPtr)w)->portBits;}        inline pascal long InvalWindowRect(WindowRef  window,  const Rect * bounds) {InvalRect (bounds);}#endif/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/* The following prototype is missing from the CW11 header files: */pascal void ExitToShell(void);/*** Variables -- Imported from Browser Plugin Module ***/#ifdef PLUGINextern int pluginArgCount;extern char *pluginArgName[100];extern char *pluginArgValue[100];#endif/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image file */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document file */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define MAX_EVENT_BUFFER 1024int inputSemaphoreIndex = 0;/* if non-zero the event semaphore index */sqInputEvent eventBuffer[MAX_EVENT_BUFFER];int eventBufferGet = 0;int eventBufferPut = 0;#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */int cachedButtonState = 0;	/* buffered mouse button and modifier state for							   last mouse click even if button has since gone up;							   this cache is kept until the next time ioGetButtonState()							   is called to avoid missing short clicks */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath);void MenuBarHide(void);void MenuBarRestore(void);int PathToWorkingDir(char *pathName, int pathNameMax);int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);void SqueakTerminate();void ExitCleanup();/* event capture */sqInputEvent *nextEventPut(void);int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);int recordMouseEvent(EventRecord *theEvent, int theButtonState);int recordKeyboardEvent(EventRecord *theEvent, int keyType);int MouseModifierState(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon);static pascal OSErr HandleOpenDocEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon);static pascal OSErr HandlePrintDocEvent(const AEDescList *aevt, AEDescList *reply, UInt32 refCon);static pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerUPP(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerUPP(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerUPP(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(const AEDescList *aevt, AEDescList *reply, UInt32 refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	FInfo		finderInformation;		reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) return errAEEventNotHandled;;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;		if (shortImageName[0] !!= 0) {		goto done;	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;		err = FSpGetFInfo(&fileSpec,&finderInformation);	if (err) goto done;			CopyPascalStringToC(fileSpec.name,shortImageName);	if (!!(IsImageName(shortImageName) || finderInformation.fdType == ''STim'') || finderInformation.fdType == ''STch'') {		/* record the document name, but run the default image in VM directory */		if (finderInformation.fdType == ''SOBJ'')			StoreFullPathForLocalNameInto(shortImageName, documentName, DOCUMENT_NAME_SIZE);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowRef		wp;	int				isDeskAccessory;	wp = FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = GetWindowKind(wp) < 0;	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableMenuItemCarbon(editMenu, 1);		EnableMenuItemCarbon(editMenu, 3);		EnableMenuItemCarbon(editMenu, 4);		EnableMenuItemCarbon(editMenu, 5);		EnableMenuItemCarbon(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableMenuItemCarbon(editMenu, 1);		DisableMenuItemCarbon(editMenu, 3);		DisableMenuItemCarbon(editMenu, 4);		DisableMenuItemCarbon(editMenu, 5);		DisableMenuItemCarbon(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	Rect    bounds;	ok = WaitNextEvent(everyEvent, &theEvent,0,null);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				if(inputSemaphoreIndex) {					recordMouseEvent(&theEvent,MouseModifierState(&theEvent));					return false;				}				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyDown);					break;				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;						case keyUp:				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyUp);				}			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				GetPortBounds(GetWindowPort(stWindow),&bounds);				InvalWindowRect(stWindow,&bounds);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;						case osEvt: 				if (((theEvent.message>>24)& 0xFF) == suspendResumeMessage) {									//JMM July 4th 2000					//Fix for menu bar tabbing, thanks to Javier Diaz-Reinoso for pointing this out					//					if (fullScreenFlag) {						if ((theEvent.message & resumeFlag) == 0) {							MenuBarRestore();						}						else {							MenuBarHide();						}					}				}				break;		}	}	else {		if(inputSemaphoreIndex) {			recordMouseEvent(&theEvent,MouseModifierState(&theEvent));		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);#if !!TARGET_API_MAC_CARBON			OpenDeskAcc(name);#endif 			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:#if !!TARGET_API_MAC_CARBON			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}#endif		break;	}}void HandleMouseDown(EventRecord *theEvent) {    BitMap      bmap;	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:#if !!TARGET_API_MAC_CARBON			SystemClick(theEvent, theWindow);#endif		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			GetQDGlobalsScreenBits(&bmap);			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &bmap.bounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				if(inputSemaphoreIndex) {					recordMouseEvent(theEvent,MouseModifierState(theEvent));					break;				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}#if TARGET_API_MAC_CARBONvoid InitMacintosh(void) {	FlushEvents(everyEvent, 0);	InitCursor();}void MenuBarHide(void) { 	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */    menuBarRegion = (RgnHandle) 1;    HideMenuBar();}void MenuBarRestore(void) {	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */    ShowMenuBar();    menuBarRegion = nil;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {}void FreeClipboard(void) {}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;       	clipSize = clipboardSize(); 	charsToMove = (count < clipSize) ? count : clipSize;    err = GetScrapFlavorData(scrap,kScrapFlavorTypeText,(long *) &charsToMove,(char *) byteArrayIndex + startIndex);    if (err !!= noErr) {         FreeClipboard();        return 0;           }	return charsToMove;}int clipboardSize(void) {	long count;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;           err = GetScrapFlavorSize (scrap, kScrapFlavorTypeText, &count); 	if (err !!= noErr) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ScrapRef scrap;	OSErr err;	err = ClearCurrentScrap();    err = GetCurrentScrap (&scrap);	err = PutScrapFlavor ( scrap, kScrapFlavorTypeText, kScrapFlavorMaskNone , count,  (const void *) (byteArrayIndex + startIndex));}#else void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */  	WindowPtr win; 		if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	LMSetMBarHeight(menuBarHeight);		win = FrontWindow();	if (win) {		CalcVis(win);		CalcVisBehind(win,menuBarRegion);	}	HiliteMenu(0);	DisposeRgn(menuBarRegion);		menuBarRegion = nil;	DrawMenuBar();}/*** Clipboard Support (text only for now) ***/Handle			clipboardBuffer = nil;void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;    //JMM locking    HLock(clipboardBuffer); 	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}    HUnlock(clipboardBuffer); 	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}#endifvoid SetUpMenus(void) {	long decideOnQuitMenu;		InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();#if TARGET_API_MAC_CARBON    Gestalt( gestaltMenuMgrAttr, &decideOnQuitMenu);    if (!!(decideOnQuitMenu & gestaltMenuMgrAquaLayoutMask))	        AppendMenu(fileMenu, "\pQuit");#else	AppendResMenu(appleMenu, ''DRVR'');    AppendMenu(fileMenu, "\pQuit");#endif 	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, false, 0);}void SetWindowTitle(char *title) {    Str255 tempTitle;	CopyCStringToPascal(title,tempTitle);	SetWTitle(stWindow, tempTitle);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int asciiChar, modifierBits, keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = modifierMap[(theEvent->modifiers >> 8) & 0x1F];	if ((modifierBits & shiftKeyBit)) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	keystate = (modifierBits << 8) | asciiChar;	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState = MouseModifierState(theEvent);	cachedButtonState = cachedButtonState | buttonState;}int MouseModifierState(EventRecord *theEvent) {	int stButtons;	stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {  /* is false if button is down */		stButtons = 4;		/* red button by default */		if ((theEvent->modifiers & optionKey) !!= 0) {			stButtons = 2;	/* yellow button if option down */		}		if ((theEvent->modifiers & cmdKey) !!= 0) {			stButtons = 1;	/* blue button if command down */		}	} 	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	return ((modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7));}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordMouseEvent(EventRecord *theEvent, int theButtonState) {	sqMouseEvent *evt;		evt = (sqMouseEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeMouse;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	/* then the buttons */	evt->buttons = theButtonState & 0x07;	/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordKeyboardEvent(EventRecord *theEvent, int keyType) {	int stButtons = 0;	int asciiChar, modifierBits;	sqKeyboardEvent *evt, *extra;	evt = (sqKeyboardEvent*) nextEventPut();	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = MouseModifierState(theEvent); //Capture mouse/option states	if ((modifierBits & shiftKeyBit)) {  /* handle command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	/* first the basics */	evt->type = EventTypeKeyboard;	evt->timeStamp = ioMSecs();	/* now the key code */	/* press code must differentiate */	evt->charCode = (theEvent->message & keyCodeMask) >> 8;	evt->pressCode = keyType;	evt->modifiers = modifierBits;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;	/* generate extra character event */	if (keyType == EventKeyDown) {		extra = (sqKeyboardEvent*)nextEventPut();		*extra = *evt;		extra->charCode = asciiChar;		extra->pressCode = EventKeyChar;	}	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}static sqInputEvent *nextEventPut(void) {	sqInputEvent *evt;	evt = eventBuffer + eventBufferPut;	eventBufferPut = (eventBufferPut + 1) % MAX_EVENT_BUFFER;	if (eventBufferGet == eventBufferPut) {		/* buffer overflow; drop the last event */		eventBufferGet = (eventBufferGet + 1) % MAX_EVENT_BUFFER;	}	return evt;}int ioSetInputSemaphore(int semaIndex) {	inputSemaphoreIndex = semaIndex;	return 1;}int ioGetNextEvent(sqInputEvent *evt) {	if (eventBufferGet == eventBufferPut) {		ioProcessEvents();	}	if (eventBufferGet == eventBufferPut) 		return 1;	*evt = eventBuffer[eventBufferGet];	eventBufferGet = (eventBufferGet+1) % MAX_EVENT_BUFFER;	return 1;}/*** Mac Specific External Primitive Support ***//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName) {	char pluginDirPath[1000];	CFragConnectionID libHandle;	Ptr mainAddr;	Str255 errorMsg,tempPluginName;	OSErr err;    	/* first, look in the "<Squeak VM directory>Plugins" directory for the library */	strcpy(pluginDirPath, vmPath);	strcat(pluginDirPath, "Plugins");	libHandle = LoadLibViaPath(pluginName, pluginDirPath);	if (libHandle !!= nil) return (int) libHandle;	/* second, look directly in Squeak VM directory for the library */	libHandle = LoadLibViaPath(pluginName, vmPath);	if (libHandle !!= nil) return (int) libHandle;        /* Lastly look for it as a shared import library */        CopyCStringToPascal(pluginName,tempPluginName);    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kLoadCFrag, &libHandle, &mainAddr, errorMsg);	if (err == noErr) 	    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kFindCFrag, &libHandle, &mainAddr, errorMsg);	if (libHandle !!= nil) return (int) libHandle;    	return nil;}/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle) {	CFragSymbolClass ignored;	Ptr functionPtr = 0;	OSErr err;    Str255 tempLookupName;    	if (!!moduleHandle) return 0;	/* get the address of the desired primitive function */	CopyCStringToPascal(lookupName,tempLookupName);	err = FindSymbol(		(CFragConnectionID) moduleHandle, (unsigned char *) tempLookupName,		&functionPtr, &ignored);	if (err) return 0;	return (int) functionPtr;}/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle) {	CFragConnectionID libHandle;	OSErr err;	if (!!moduleHandle) return 0;	libHandle = (CFragConnectionID) moduleHandle;	err = CloseConnection(&libHandle);	return 0;}CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath) {	short 				vRefNum;	long				ignore;	CInfoPBRec 			pb;	FSSpec				fileSpec;	Str255				problemLibName,fileSpecName,tempPlugindirPath;    Ptr					junk;	CFragConnectionID	libHandle = 0;	OSErr				err = noErr;	/* get the default volume */	HGetVol( nil, &vRefNum, &ignore);	/* get the directory ID for the given path */	CopyCStringToPascal(pluginDirPath,tempPlugindirPath);	pb.hFileInfo.ioNamePtr = tempPlugindirPath;	pb.hFileInfo.ioVRefNum = 0;  /* use the default volume */	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	err = PBGetCatInfoSync(&pb);	if (err) return nil; /* bad plugin directory path */	/* make a file spec for the given file name in the plugin directory */	CopyCStringToPascal(libName,fileSpecName);	FSMakeFSSpec(vRefNum,pb.hFileInfo.ioDirID,fileSpecName,&fileSpec);	err = GetDiskFragment(		&fileSpec, 0, kCFragGoesToEOF, nil, kLoadCFrag, &libHandle, &junk, problemLibName);	if (err) return nil;	return libHandle;}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}#ifndef PLUGINint ioExit(void) {	ioShutdownAllModules();	MenuBarRestore();	ExitToShell();}#endifint ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	if ((cachedButtonState & 0x7) !!= 0) {		int result = cachedButtonState;		cachedButtonState = 0;  /* clear cached button state */		return result;	}	cachedButtonState = 0;  /* clear cached button state */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioHasDisplayDepth(int depth) {	/* Return true if this platform supports the given color display depth. */	switch (depth) {	case 1:	case 2:	case 4:	case 8:	case 16:	case 32:		return true;	}	return false;}int ioMicroMSecsExpensive(void);int ioMicroMSecsExpensive(void) {	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}#if TARGET_CPU_PPCBoolean HasUpTime (void);Boolean HasUpTime (void){    return ( (Ptr) UpTime !!= (Ptr) kUnresolvedCFragSymbolAddress);}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */		AbsoluteTime nanoThings;		if (HasUpTime()) {	    nanoThings = UpTime();	    return AbsoluteToDuration(nanoThings);    } else {	    return ioMicroMSecsExpensive();	}}#elseint ioMicroMSecs(void) {    return ioMicroMSecsExpensive();}#endifint ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	return ioMicroMSecs();}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	const int nextPollOffsetCheck = (CLOCKS_PER_SEC/30);	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + nextPollOffsetCheck;	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * ioProcessEvents(), which gives other applications a chance to run.	 */    microSeconds;    	ioProcessEvents();  /* process all pending events */}#ifndef PLUGINint ioScreenSize(void) {	int w = 10, h = 10;    Rect portRect;    	if (stWindow !!= nil) {        GetPortBounds(GetWindowPort(stWindow),&portRect);		w =  portRect.right -  portRect.left;		h =  portRect.bottom - portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}#endifint ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag) {	/* Set the window to the given width, height, and color depth. Put the window	   into the full screen mode specified by fullscreenFlag. */	/* Note: Changing display depth is not yet, and may never be, implemented	   on the Macintosh, where (a) it is considered inappropriate and (b) it may	   not even be a well-defined operation if the Squeak window spans several	   displays (which display''s depth should be changed?). */	depth;	ioSetFullScreen(fullscreenFlag);	if (!!fullscreenFlag) {		SizeWindow(stWindow, width, height, true);	}}#ifndef PLUGINint ioSetFullScreen(int fullScreen) {	Rect screen,portRect;	BitMap bmap;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;				GetQDGlobalsScreenBits(&bmap);    screen = bmap.bounds;    	if (fullScreen) {		MenuBarHide();		GetPortBounds(GetWindowPort(stWindow),&portRect);		oldWidth =  portRect.right -  portRect.left;		oldHeight =  portRect.bottom -  portRect.top;		width  = screen.right - screen.left; 		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}#endifint ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPortWindowPort(stWindow);	CopyBits((BitMap *) *stPixMap, GetPortBitMapForCopyBits(GetWindowPort(stWindow)), &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Initializing the path to Working Dir ***/int PathToWorkingDir(char *pathName, int pathNameMax) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	Str255 thisName;	CInfoPBRec pb;	int nextDirRefNum, pathLen;	/* initialize string copying state */	pathName[0] = 0;	pathLen = 0;	/* get refNum of working directory */	strcpy((char *) thisName, ":");	CopyCStringToPascal((const char *)thisName,thisName);	pb.hFileInfo.ioNamePtr = thisName;	pb.hFileInfo.ioVRefNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	if (PBGetCatInfoSync(&pb) !!= noErr) {		nextDirRefNum = 0;	}	nextDirRefNum = pb.hFileInfo.ioDirID;	while (true) {		thisName[0] = 0;		pb.hFileInfo.ioFDirIndex = -1; /* map ioDirID -> name */		pb.hFileInfo.ioVRefNum = 0;		pb.hFileInfo.ioDirID = nextDirRefNum;		if (PBGetCatInfoSync(&pb) !!= noErr) {			break;  /* we''ve reached the root */		}    	CopyPascalStringToC((unsigned char *)thisName,(char *) thisName);		pathLen = PrefixPathWith(pathName, pathLen, pathNameMax,(char *) thisName);		nextDirRefNum = pb.dirInfo.ioDrParID;	}	return pathLen;}int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		return pathNameSize;	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = '':'';  /* insert delimitor */	return pathNameSize + offset;}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	fullImagePath;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	SetUpClipboard();	SetUpPixmap();}int plugInShutdown(void) {	ioShutdownAllModules();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}#ifndef PLUGINint plugInAllowAccessToFilePath(char *pathString, int pathStringLength) {  /* Grant permission to all files. */	pathString; pathStringLength;	return true;}#endif/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	/* Note: 1.3x images will try to read the image as a document because they	   expect attribute #1 to be the document name. A 1.3x image can be patched	   using a VM of 2.6 or earlier. */	if (id == 1) return imageName;	if (id == 2) return documentName;#ifdef PLUGIN	/* When running in browser, return the EMBED tag info */	if ((id > 2) && (id <= (2 + (2 * pluginArgCount)))) {		int i = id - 3;		if ((i & 1) == 0) {  /* i is even */			return pluginArgName[i/2];		} else {			return pluginArgValue[i/2];		}	}#endif	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	Str255 tempPascalFileName;	CopyCStringToPascal(fileName,tempPascalFileName);	if (strchr(mode, ''w'') !!= null) 	    err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);	 else	    err = HOpenDF(0,0,tempPascalFileName,fsRdPerm, &fRefNum);	    	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = HCreate(0,0,tempPascalFileName,  ''FAST'', ''STim'');		if (err2 == 0) {			err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);		}	}	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}#ifndef PLUGINvoid * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* Application allocates Squeak object heap memory from its own heap. */	minHeapSize;	MaxBlock();	return NewPtr(desiredHeapSize);}#endif/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	SetEventMask(everyEvent); // also get key up events	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 500000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 50K to that.)	    	    JMM Note changed to 500 for Open Transport support on 68K machines	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSizeStartingAt(f, availableMemory, 0);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}#endifvoid SqueakTerminate() {#ifdef PLUGIN	ExitCleanup();#else	ioShutdownAllModules();#endif}#if !!TARGET_API_MAC_CARBON////	CopyPascalStringToC converts the source pascal string to a destination//	C string as it copies. //void CopyPascalStringToC(ConstStr255Param src, char* dst){	if ( src !!= NULL )	{		short   length  = *src++;			while ( length > 0 ) 		{			*dst++ = *(char*)src++;			--length;		}	}	*dst = ''\0'';}////	CopyCStringToPascal converts the source C string to a destination//	pascal string as it copies. The dest string will//	be truncated to fit into an Str255 if necessary.//  If the C String pointer is NULL, the pascal string''s length is set to zero//void CopyCStringToPascal(const char* src, Str255 dst){	short 	length  = 0;		// handle case of overlapping strings	if ( (void*)src == (void*)dst )	{		unsigned char*		curdst = &dst[1];		unsigned char		thisChar;						thisChar = *(const unsigned char*)src++;		while ( thisChar !!= ''\0'' ) 		{			unsigned char	nextChar;						// use nextChar so we don''t overwrite what we are about to read			nextChar = *(const unsigned char*)src++;			*curdst++ = thisChar;			thisChar = nextChar;						if ( ++length >= 255 )				break;		}	}	else if ( src !!= NULL )	{		unsigned char*		curdst = &dst[1];		short 				overflow = 255;		// count down so test it loop is faster		register char		temp;			// Can''t do the K&R C thing of while (*s++ = *t++) because it will copy trailing zero		// which might overrun pascal buffer.  Instead we use a temp variable.		while ( (temp = *src++) !!= 0 ) 		{			*(char*)curdst++ = temp;							if ( --overflow <= 0 )				break;		}		length = 255 - overflow;	}	dst[0] = length;}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 8/11/2000 16:50'!readmeFile	^ 'Building the Squeak Virtual MachineThe Macintosh virtual machine is built using the following source files:	sq.h				-- shared definitions included in all .c files	sqConfig.h			-- platform configuration settings	sqMachDep.h		-- machine dependent macros to support threaded code	sqPlatformSpecific.h -- platform specific macros and definitions	sqVirtualMachine.h	-- support for dynamic primitives	sqADPCMPrims.c		-- ADCPM sound compression primitives	sqFilePrims.c		-- file primitives	sqMacAsyncFilePrims.c -- Mac asynchronous file I/O	sqMacDirectory.c	-- Mac directory enumerations	sqMacJoystickAndTablet.c -- Mac support for Wacom tablets and Gravis MouseStickII joystick	sqMacNetwork.c		-- Mac networking primitives	sqMacSerialAndMIDIPort.c -- Mac serial and MIDI port primitives	sqMacSound.c		-- Mac audio output primitives	sqMacWindow.c		-- Mac window and event handling; main program	sqMiscPrims.c		-- miscellaneous automatically generated primitives	sqNamedPrims.c		-- support for named primitives	sqSoundPrims.c		-- automatically generated sound synthesis primitives	sqOldSoundPrims.c	-- old versions of sound primitives for backward compatibility	sqVirtualMachine.c	-- support for dynamic primitives	interp.c				-- automatically generated code for the virtual machineIn addition to these files, a number of .h and .c files are generated when Squeak generates a new interpreter. The exact set of files depends on which sets of primitives are included. In general, all the files created by this process should be visible to the CW project and all the generated .c files should be added to the CW project. Don''t worry--the linker will tell you if you forget something.The platform specific files are sqMacXXX.c, totaling about 2000 lines of code when this document was originally written. All other code is written to standard ANSI libraries and should port easily to other C environments.The file sqMacMinimal.c can be used a porting guide. This ~1100 line file stubs out all non-essential support functions and, together with sqFilePrims.c, allows one to build a functioning virtual machine that only lacks non-essential I/O functions (including support for file directory enumeration, which is not really essential!!). The small size of this file demonstrates how little code is really needed to get Squeak running on a new platform.Thanks to Ian Piumarta, the C header files are identical across all the major Squeak platforms.The code assumes that C ints and pointers are 4 bytes and double floats are 8 bytes; these assumptions are checked at start up time. Float objects in the image are stored in the IEEE standard byte ordering for double-precision floats on all platforms; macros in sq.h can be defined to swap bytes into and out of the platform native float format if necessary. (To ensure proper word alignment, one typically has to copy a Squeak Float object into a C "double" variable before operating on it; byte swapping can be done while doing this copy for little or no additional cost.)The files interp.c, sqSoundPrims.c, and sqMiscPrims.c are generated automatically, so changes to these files will be lost when they are next generated. It is fine to make ephemeral changes to these file for the purpose of debugging or statistics gathering. To generate the interpreter, see the "translation" category in Interpreter class. To generate sqSoundPrims.c, see the class method "cCodeForSoundPrimitives" in AbstractSound.The current VM was compiled with Metrowerks CodeWarrior 11. Earlier, I used Semantec Think C 6.0, but discovered a few bugs in their libraries having to do with 8-byte versus 4-byte integers. These bugs have probably been fixed by now.This code has also been compiled under the MPW "Mr. C" Macintosh compiler by Hans-Martin Mosner (hmm@heeg.de) with only one minor change: you will need to create an empty "MacHeaders.h" file. You may get some harmless compiler warnings and, for peak performance, the method that patches the dispatch loop must also be changed. Hans-Martin says: "The whole VM seems to be marginally slower than the delivered VM, but it is significantly smaller."The virtual machine uses the following libraries:	Libraries for 68K Project:		dnr.c		InterfaceLib		MathLibCFM68K (4i/8d).Lib		MSL C.CFM68K Far(4i/8d).Lib		MWCFM68KRuntime.Lib		Profiler68kCFM.lib		QuickTimeLib				//Optional only to build OT version of 68K do not include in regular build		OpenTpt68kATalkLib		OpenTpt68kClientLib		OpenTpt68kInetLib		OpenTpt68kUtilLib	Libraries for PowerPC Project:		InterfaceLib		MathLib		MSL C.PPC.Lib		MWCRuntime.Lib		profilerPPC.lib		QuickTimeLib		DeviceServicesLib (for UpTime)		OpenTptInetPPC.o		OpenTptInternetLib		OpenTransportExtnPPC.o		OpenTransportLibThe 68K Mac networking code also requires three files from Apple''s MacTCP developer''s kit:	MacTCP.h	AddressXlation.h	dnr.cFor convenience, these files are included.The shipping 68K version of Squeak uses the older MacTCP interface. You can alter the sqMacNetwork.c file and compile your own 68K verion of Squeak that uses the new Open Transport version, but the availability of the 68K version of Open Transport V1.3 is limited to 68040 machines that run system 8.1. You can run this configuration on a 68030 using system 7.5.x but Apple does not support that configuration.To build a fat binary, build the 68K version first, and make sure that the file "Squeak VM 68K" is included in the PowerPC project. Then build the PowerPC version. CodeWarrior will include the 68K interpreter in the resource fork of the output file, resulting in an interpreter that runs on either 68K or PowerPC Macs. (JMM) Note I had some problems building the FAT application with CW11 I had to copy the SqueakApp.rsrc items over to the application after it was built, these resources aren''t copied from the 68K application like the documentation says they should.To get an additional speedup, the object code for the bytecode dispatch loop of the PPC version can be patched using the method "patchInterp:" in Interpreter class.Note: In order to support dynamically loaded primitives, we have switched to using Code Fragement Manager model for the 68K VM. This has several ramifications:  1. You now need to use the CFM versions of the library files. The 68K project file has been updated accordingly.  2. You cannot run the 68K VM under the emulator on the PowerPC (Apple doesn''t support CFM apps under the 68K emulator).  3. You need to be sure that version 4.0 or later of "CFM-68K Runtime Enabler" is in the Extensions folder of the system folder on your 68K Mac. *** Warning: Older versions of "CFM-68K Runtime Enabler" had bugs that will probably prevent Squeak from even starting!! ***.CarbonWe do not include a Carbon ready project at this time. Much of the work to make a Carbon application is done, however we are still missing versions of the sound plugin and the serialMidi plugin which are Carbon compliant. Building Named Primitive PluginsI''ve included a pair of sample projects for building Squeak primitive plugins. As usual, you must build the 68K version first, then the FAT one. If you don''t need a FAT version, you can remove the 68K project from the PPC one.Pluginized VMSqueak 2.8 introduces the "pluginized VM". In the interest of getting a Mac version of the 2.8 out as quickly and with as little chance of introducing bugs as possible, I''ve made the bare minimal changes to the Mac support files. For this reason, all the Mac primitives that were previously linked into the VM must still be built into the VM as "internal" primitives. That is because many of them still access a few VM functions and variables directly, rather than calling through the interpreter proxy, which they must in order to run in an external plugin. One can still override these builtin primitives with an external plugin and, of course, newly built plugins can be created as external or internal plugins. When the dust settles, it will be easy to make the final few changes required.Building Squeak as a Browser PluginI''ve included an archive containing a CW project file and various supporting files for building the Squeak VM as plugin for Netscape or Internet Explorer on the Mac. The plugin works with versions 4.0 or later of either browser. However, the primitives that can be used to ask the browser to fetch a URL do not work in versions of IE earlier than 5.0. There are also two resource files the contain the strings needed to tell the browser about the plugin--its name, version, and the mime and file extensions it recognizes.To build this, you will need a copy of the Netscape Plugin SDK, available for free at their web site. The required support files are:	jri.h	jritypes.h	jri_md.h	npapi.h	npmac.cpp	npupp.hThe installation and use of Squeak as a browser plugin is somewhat beyond the scope of this readme file. The basic idea is that the Squeak image started by the browser lives in a pre-defined directory ("System Folder:Preferences:Squeak:Internet" by default) with predefined name (e.g., "squeak.image"). The browser plugin can only read and write files within the Internet directory and directories contained within it. This is called Squeak file system "sand box". The browser captures most of the command key combination, so you have to use the menus rather than your favorite Squeak command key shortcuts. {Note that using the full screen option allows you to again use the command key combinations and has better performance characteristics.} The browser also captures cmd-., so the interrupt key when running under the browser is control-C. The most flexible way to invoke Squeak is through the HTML "EMBED" command. This allows arbitrary arguments to be made available to Squeak. The "memory" EMBED tag can be used to tell Squeak how much memory is required by a given Squeaklet.To build a browser plugin VM, do the following:  1. translate a browser plugin version of the interpreter (using Interpreter>translateForBrowserPlugin:).  2. edit the file sqMacWindow.c and uncomment the #define of "PLUGIN"  3. edit the file platform.exports and uncomment the #define of "PLUGIN"  4. build the plugin using the supplied browser plugin projectIf you build your own project file, note that IE requires that the main entry point be "main" rather than CW''s usual "__start". (Netscape doesn''t care, so it took me a long time to figure out why it wasn''t working under IE!!) The supplied project produces a PPC-only plugin.	-- John Maloney, May 25, 2000,	-- Changes John M McIntosh Aug 2, 2000'! !