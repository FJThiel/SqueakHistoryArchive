'From Squeak 2.5 of August 6, 1999 on 17 September 1999 at 1:34:41 pm'!"Change Set:		MoreVRML-arDate:			17 September 1999Author:			Andreas RaabMore VRML stuff and a couple of fixes/modifications all over the place."!B3DGeometry subclass: #B3DIndexedMesh	instanceVariableNames: 'vertices vtxNormals vtxColors vtxTexCoords faces faceNormals bBox '	classVariableNames: 'FlagFanStart FlagStripStart VRML97BoxCache VRML97ConeCache VRMLCylCache VRMLSphereCache '	poolDictionaries: ''	category: 'Balloon-3D-Meshes'!Object subclass: #VRMLStream	instanceVariableNames: 'theStream backups '	classVariableNames: 'DigitValues NonFirstChars NonRestChars SeparatorChars '	poolDictionaries: ''	category: 'VRML-Definition'!!B3DIndexedMesh methodsFor: 'converting' stamp: 'ar 9/17/1999 12:37'!asSimpleMesh	"Convert the receiver into a very simple mesh representation"	| simpleFaces oldFace newVtx newFace newVertices pos |	simpleFaces _ WriteStream on: (Array new: faces size).	newVertices _ WriteStream on: (Array new: 10).	1 to: faces size do:[:i|		oldFace _ faces at: i.		newVertices reset.		1 to: oldFace size do:[:j|			pos _ oldFace at: j.			newVtx _ B3DSimpleMeshVertex new.			newVtx position: (vertices at: pos).			vtxNormals == nil ifFalse:[newVtx normal: (vtxNormals at: pos)].			vtxColors == nil ifFalse:[newVtx color: (vtxColors at: pos)].			vtxTexCoords == nil ifFalse:[newVtx texCoord: (vtxTexCoords at: pos)].			newVertices nextPut: newVtx].		newFace _ B3DSimpleMeshFace withAll: newVertices contents.		simpleFaces nextPut: newFace].	^B3DSimpleMesh withAll: simpleFaces contents! !!B3DIndexedMesh methodsFor: 'testing' stamp: 'ar 9/16/1999 23:32'!hasVertexColors	^vtxColors notNil! !!B3DIndexedMesh class methodsFor: 'class initialization' stamp: 'ar 9/16/1999 23:02'!flushVRMLCache	"B3DIndexedMesh flushVRMLCache"	VRML97BoxCache _	VRML97ConeCache _	VRMLCylCache _	VRMLSphereCache _	nil.! !!B3DIndexedMesh class methodsFor: 'vrml97 prototypes' stamp: 'ar 9/16/1999 22:12'!vrml97Box	"Return a mesh representing a VRML97 Box"	^VRML97BoxCache ifNil:[		VRML97BoxCache _ (B3DSimpleMesh withAll: self vrmlCreateBoxFaces) asIndexedMesh]! !!B3DIndexedMesh class methodsFor: 'vrml97 prototypes' stamp: 'ar 9/16/1999 22:15'!vrml97Cone	"Return a mesh representing a VRML97 Cone"	^self vrml97Cone: true bottom: true.! !!B3DIndexedMesh class methodsFor: 'vrml97 prototypes' stamp: 'ar 9/16/1999 22:14'!vrml97Cone: doSide bottom: doBottom	"Return a mesh representing a VRML97 Cone"	| idx |	idx _ 0.	doBottom ifTrue:[idx _ idx + 2].	doSide ifTrue:[idx _ idx + 1].	VRML97ConeCache == nil ifTrue:[		VRML97ConeCache _ Array new: 3.		1 to: 3 do:[:i|			VRML97ConeCache at: i put:				(self 					vrmlCreateCone: (i anyMask: 1) 					bottom: (i anyMask: 2))]].	^VRML97ConeCache at: idx! !!B3DIndexedMesh class methodsFor: 'vrml97 prototypes' stamp: 'ar 9/16/1999 22:15'!vrml97Cylinder	"Return a mesh representing a VRML97 Cylinder"	^self vrml97Cylinder: true bottom: true top: true.! !!B3DIndexedMesh class methodsFor: 'vrml97 prototypes' stamp: 'ar 9/16/1999 22:14'!vrml97Cylinder: doSide bottom: doBottom top: doTop	"Return a mesh representing a VRML97 Cylinder"	| idx |	idx _ 0.	doTop ifTrue:[idx _ idx + 4].	doBottom ifTrue:[idx _ idx + 2].	doSide ifTrue:[idx _ idx + 1].	idx = 0 ifTrue:[^nil].	VRMLCylCache == nil ifTrue:[		VRMLCylCache _ Array new: 7.		1 to: 7 do:[:i|			VRMLCylCache at: i put:				(self 					vrmlCreateCylinder: (i anyMask: 1) 					bottom: (i anyMask: 2) 					top: (i anyMask: 4))]].	^VRMLCylCache at: idx! !!B3DIndexedMesh class methodsFor: 'vrml97 prototypes' stamp: 'ar 9/16/1999 22:21'!vrml97Sphere	"Return a mesh representing a VRML97 Sphere"	^VRMLSphereCache ifNil:[		VRMLSphereCache _ (B3DSimpleMesh withAll: self vrmlCreateSphereFaces) asIndexedMesh].! !!B3DIndexedMesh class methodsFor: 'vrml support' stamp: 'ar 9/16/1999 22:07'!vrmlCreateBottomFaces	| face steps dir m lastVtx nextVtx faceList midVtx |	steps _ self vrmlSteps.	faceList _ WriteStream on: (Array new: steps).	dir _ 0@0@1.	m _ (B3DRotation angle: (360.0 / steps) axis: (0@-1@0)) asMatrix4x4.	lastVtx _ B3DSimpleMeshVertex new.	lastVtx position: 0@-1@1.	lastVtx normal: 0@-1@0.	lastVtx texCoord: 0.5@1.	1 to: steps do:[:i|		face _ B3DSimpleMeshFace new: 3.		face at: 1 put: lastVtx.		dir _ (m localPointToGlobal: dir) normalized.		nextVtx _ B3DSimpleMeshVertex new.		nextVtx position: dir x @ -1 @ dir z.		nextVtx normal: 0@-1@0.		nextVtx texCoord: (dir x @ dir z) * 0.5 + 0.5.		midVtx _ nextVtx copy.		midVtx position: 0@-1@0.		midVtx texCoord:  0.5@0.5.		face at: 2 put: nextVtx.		face at: 3 put: midVtx.		faceList nextPut: face.		lastVtx _ nextVtx].	^faceList contents! !!B3DIndexedMesh class methodsFor: 'vrml support' stamp: 'ar 9/16/1999 22:11'!vrmlCreateBoxFaces	| vtx face vtxSpec faceList |	faceList _ WriteStream on: (Array new: 6).	"front and back face"	vtxSpec _ #(	((-1 -1) (0 1))	(( 1 -1) (1 1))		(( 1  1) (1 0))	((-1  1) (0 0))).	"front"	face _ B3DSimpleMeshFace new: 4.	vtxSpec doWithIndex:[:spec :idx|		vtx _ B3DSimpleMeshVertex new.		vtx position: spec first first @ spec first second @ -1.		vtx normal: 0@0@-1.		vtx texCoord: spec second first @ spec second second.		face at: idx put: vtx.	].	faceList nextPut: face.	"back"	face _ B3DSimpleMeshFace new: 4.	vtxSpec doWithIndex:[:spec :idx|		vtx _ B3DSimpleMeshVertex new.		vtx position: spec first first @ spec first second @ 1.		vtx normal: 0@0@1.		vtx texCoord: 1 - spec second first @ spec second second.		face at: idx put: vtx.	].	faceList nextPut: face.	"top"	face _ B3DSimpleMeshFace new: 4.	vtxSpec doWithIndex:[:spec :idx|		vtx _ B3DSimpleMeshVertex new.		vtx position: spec first first @ 1 @ spec first second.		vtx normal: 1@0@0.		vtx texCoord: spec second first @ spec second second.		face at: idx put: vtx.	].	faceList nextPut: face.	"bottom"	face _ B3DSimpleMeshFace new: 4.	vtxSpec doWithIndex:[:spec :idx|		vtx _ B3DSimpleMeshVertex new.		vtx position: spec first first @ -1 @ spec first second.		vtx normal: -1@0@0.		vtx texCoord: spec second first @ (1 - spec second second).		face at: idx put: vtx.	].	faceList nextPut: face.	vtxSpec _ #(	((-1 -1) (0 1))	((-1  1) (1 1))		(( 1  1) (1 0))	(( 1 -1) (0 0))).	"right"	face _ B3DSimpleMeshFace new: 4.	vtxSpec doWithIndex:[:spec :idx|		vtx _ B3DSimpleMeshVertex new.		vtx position: 1 @ spec first first @ spec first second.		vtx normal: 1@0@0.		vtx texCoord: spec second first @ spec second second.		face at: idx put: vtx.	].	faceList nextPut: face.	"left"	face _ B3DSimpleMeshFace new: 4.	vtxSpec doWithIndex:[:spec :idx|		vtx _ B3DSimpleMeshVertex new.		vtx position: -1 @ spec first first @ spec first second.		vtx normal: -1@0@0.		vtx texCoord: 1 - spec second first @ spec second second.		face at: idx put: vtx.	].	faceList nextPut: face.	^faceList contents! !!B3DIndexedMesh class methodsFor: 'vrml support' stamp: 'ar 9/16/1999 22:16'!vrmlCreateCone: doSide bottom: doBottom	| faces |	faces _ #().	doSide ifTrue:[faces _ faces, self vrmlCreateConeFaces].	doBottom ifTrue:[faces _ faces, self vrmlCreateBottomFaces].	^(B3DSimpleMesh withAll: faces) asIndexedMesh! !!B3DIndexedMesh class methodsFor: 'vrml support' stamp: 'ar 9/16/1999 22:07'!vrmlCreateConeFaces	| face steps dir m lastVtx nextVtx topVtx faceList |	steps _ self vrmlSteps.	faceList _ WriteStream on: (Array new: steps).	dir _ 0@0@1.	m _ (B3DRotation angle: (360.0 / steps) axis: (0@-1@0)) asMatrix4x4.	lastVtx _ B3DSimpleMeshVertex new.	lastVtx position: 0@-1@1.	lastVtx normal: dir.	lastVtx texCoord: 0@1.	1 to: steps do:[:i|		face _ B3DSimpleMeshFace new: 3.		face at: 1 put: lastVtx.		dir _ (m localPointToGlobal: dir) normalized.		nextVtx _ B3DSimpleMeshVertex new.		nextVtx position: dir x @ -1 @ dir z.		nextVtx normal: dir.		nextVtx texCoord: (i / steps asFloat) @ 1.		topVtx _ nextVtx copy.		topVtx position: 0@1@0.		topVtx texCoord:  lastVtx texCoord x @ 0.		face at: 2 put: nextVtx.		face at: 3 put: topVtx.		faceList nextPut: face.		lastVtx _ nextVtx].	^faceList contents! !!B3DIndexedMesh class methodsFor: 'vrml support' stamp: 'ar 9/16/1999 22:05'!vrmlCreateCylinder: doSide bottom: doBottom top: doTop	| faces |	faces _ #().	doSide ifTrue:[faces _ faces, self vrmlCreateCylinderFaces].	doBottom ifTrue:[faces _ faces, self vrmlCreateBottomFaces].	doTop ifTrue:[faces _ faces, self vrmlCreateTopFaces].	^(B3DSimpleMesh withAll: faces) asIndexedMesh! !!B3DIndexedMesh class methodsFor: 'vrml support' stamp: 'ar 9/16/1999 22:07'!vrmlCreateCylinderFaces	| face steps dir m lastVtx nextVtx topVtx lastTopVtx faceList |	steps _ self vrmlSteps.	faceList _ WriteStream on: (Array new: steps).	dir _ 0@0@1.	m _ (B3DRotation angle: (360.0 / steps) axis: (0@-1@0)) asMatrix4x4.	lastVtx _ B3DSimpleMeshVertex new.	lastVtx position: 0@-1@1.	lastVtx normal: dir.	lastVtx texCoord: 0@1.	lastTopVtx _ lastVtx copy.	lastTopVtx position: 0@1@1.	lastTopVtx texCoord: 0@0.	1 to: steps do:[:i|		face _ B3DSimpleMeshFace new: 4.		face at: 1 put: lastVtx.		face at: 4 put: lastTopVtx.		dir _ (m localPointToGlobal: dir) normalized.		nextVtx _ B3DSimpleMeshVertex new.		nextVtx position: dir x @ -1 @ dir z.		nextVtx normal: dir.		nextVtx texCoord: (i / steps asFloat) @ 1.		topVtx _ nextVtx copy.		topVtx position: dir x @ 1 @  dir z.		topVtx texCoord:  (i / steps asFloat) @ 0.		face at: 2 put: nextVtx.		face at: 3 put: topVtx.		faceList nextPut: face.		lastVtx _ nextVtx.		lastTopVtx _ topVtx].	^faceList contents! !!B3DIndexedMesh class methodsFor: 'vrml support' stamp: 'ar 9/16/1999 22:58'!vrmlCreateSphereFaces	"B3DIndexedMesh vrmlCreateSphereFaces"	| faceList vtx steps m1 m2 baseDir vtxList vertices dir lastVtx nextVtx face |	steps _ self vrmlSteps.	faceList _ WriteStream on: (Array new: steps * steps).	"<--- vertex construction --->"	m1 _ (B3DRotation angle: 360.0 / steps axis: 0@-1@0) asMatrix4x4.	m2 _ (B3DRotation angle: 180.0 / steps axis: 1@0@0) asMatrix4x4.	baseDir _ 0@1@0.	vtxList _ Array new: steps + 1.	0 to: steps do:[:i|		i = steps ifTrue:[baseDir _ 0@-1@0]. "Make closed for sure"		vertices _ Array new: steps + 1.		vtxList at: i+1 put: vertices.		dir _ baseDir.		0 to: steps do:[:j|			j = steps ifTrue:[dir _ baseDir]. "Make closed for sure"			vtx _ B3DSimpleMeshVertex new.			vtx position: dir; normal: dir.			vtx texCoord: (j / steps asFloat) @ (i / steps asFloat).			vertices at: j+1 put: vtx.			dir _ (m1 localPointToGlobal: dir) normalized.		].		baseDir _ (m2 localPointToGlobal: baseDir) normalized.	].	"<--- face construction --->"	"Construct first round separately as triangles"	lastVtx _ vtxList at: 1.	nextVtx _ vtxList at: 2.	1 to: steps do:[:i|		face _ B3DSimpleMeshFace new: 3.		face at: 1 put: (lastVtx at: i).		face at: 2 put: (nextVtx at: i+1).		face at: 3 put: (nextVtx at: i).		faceList nextPut: face].	"Construct the next rounds as quads"	2 to: steps-1 do:[:i|		lastVtx _ vtxList at: i.		nextVtx _ vtxList at: i+1.		1 to: steps do:[:j|			face _ B3DSimpleMeshFace new: 4.			face at: 1 put: (lastVtx at: j).			face at: 2 put: (lastVtx at: j+1).			face at: 3 put: (nextVtx at: j+1).			face at: 4 put: (nextVtx at: j).			faceList nextPut: face]].	"Construct the last round separately as triangles"	lastVtx _ vtxList at: steps.	nextVtx _ vtxList at: steps+1.	1 to: steps do:[:i|		face _ B3DSimpleMeshFace new: 3.		face at: 1 put: (lastVtx at: i).		face at: 2 put: (lastVtx at: i+1).		face at: 3 put: (nextVtx at: i).		faceList nextPut: face].	^faceList contents! !!B3DIndexedMesh class methodsFor: 'vrml support' stamp: 'ar 9/16/1999 22:08'!vrmlCreateTopFaces	| face steps dir m lastVtx nextVtx faceList midVtx |	steps _ self vrmlSteps.	faceList _ WriteStream on: (Array new: steps).	dir _ 0@0@1.	m _ (B3DRotation angle: (360.0 / steps) axis: (0@-1@0)) asMatrix4x4.	lastVtx _ B3DSimpleMeshVertex new.	lastVtx position: 0@1@1.	lastVtx normal: 0@1@0.	lastVtx texCoord: 0.5@0.	1 to: steps do:[:i|		face _ B3DSimpleMeshFace new: 3.		face at: 1 put: lastVtx.		dir _ (m localPointToGlobal: dir) normalized.		nextVtx _ B3DSimpleMeshVertex new.		nextVtx position: dir x @ 1 @ dir z.		nextVtx normal: 0@1@0.		nextVtx texCoord: (dir x @ dir z) * (0.5 @ -0.5) + 0.5.		midVtx _ nextVtx copy.		midVtx position: 0@1@0.		midVtx texCoord:  0.5@0.5.		face at: 2 put: nextVtx.		face at: 3 put: midVtx.		faceList nextPut: face.		lastVtx _ nextVtx].	^faceList contents! !!B3DIndexedMesh class methodsFor: 'vrml support' stamp: 'ar 9/16/1999 22:15'!vrmlSteps	"Return the number of steps for rotational objects"	^16! !!B3DIndexedTriangleMesh methodsFor: 'displaying' stamp: 'ar 9/16/1999 23:40'!renderOn: aRenderer	self hasVertexColors ifTrue:[		aRenderer trackAmbientColor: true.		aRenderer trackDiffuseColor: true].	aRenderer		drawIndexedTriangles: faces			vertices: vertices			normals: vtxNormals			colors: vtxColors			texCoords: vtxTexCoords.! !!B3DRotation methodsFor: 'arithmetic' stamp: 'ar 9/17/1999 12:43'!normalize	"Normalize the receiver. Note that the actual angle (a) determining the amount of 	rotation is fixed, since we do not want to modify angles. This leads to:		a^2 + b^2 + c^2 + d^2 = 1.		b^2 + c^2 + d^2 = 1 - a^2.	Note also that the angle (a) can not exceed 1.0 (due its creation by cosine) and	if it is 1.0 we have exactly the unit quaternion ( 1, [ 0, 0, 0]).	"	| oneMinusASquared length |	oneMinusASquared := 1.0 - (self a squared).	(oneMinusASquared < 1.0e-10) ifTrue:[^self setIdentity].	length := ((self b squared + self c squared + self d squared) / oneMinusASquared) sqrt.	length = 0.0 ifTrue:[^self setIdentity].	self b: self b / length.	self c: self c / length.	self d: self d / length.! !!B3DSimpleMesh methodsFor: 'enumerating' stamp: 'ar 9/17/1999 12:38'!do: aBlock	1 to: self size do:[:i| aBlock value: (self at: i)]! !!B3DSimpleMesh methodsFor: 'converting' stamp: 'ar 9/17/1999 12:31'!transformedBy: aMatrix	"Return a copy of the receiver with its vertices transformed by the given matrix"	| newFaces|	newFaces _ Array new: self size.	1 to: self size do:[:i| newFaces at: i put: ((self at: i) transformedBy: aMatrix)].	^self class withAll: newFaces! !!B3DSimpleMeshFace methodsFor: 'enumerating' stamp: 'ar 9/17/1999 12:38'!do: aBlock	1 to: self size do:[:i| aBlock value: (self at: i)]! !!B3DSimpleMeshFace methodsFor: 'converting' stamp: 'ar 9/17/1999 12:31'!transformedBy: aMatrix	"Return a copy of the receiver with its vertices transformed by the given matrix"	| newVtx |	newVtx _ Array new: self size.	1 to: self size do:[:i| newVtx at: i put: ((self at: i) transformedBy: aMatrix)].	^self class withAll: newVtx! !!B3DSimpleMeshVertex methodsFor: 'printing' stamp: 'ar 9/16/1999 22:48'!printOn: aStream	aStream nextPutAll:'['; print: position; nextPutAll:']'.! !!B3DSimpleMeshVertex methodsFor: 'converting' stamp: 'ar 9/17/1999 13:30'!transformedBy: aMatrix	"Return a copy of the receiver with its vertices transformed by the given matrix"	| transformer copy |	transformer _ B3DVertexTransformer new.	transformer loadIdentity.	transformer transformBy: aMatrix.	copy _ self copy.	copy position: (transformer transformPosition: position).	normal == nil		ifFalse:[copy normal: (transformer transformDirection: normal) safelyNormalize].	^copy! !!Hierarchical methodsFor: 'parent-child' stamp: 'ar 9/17/1999 12:28'!allChildrenDo: aBlock	"Execute aBlock for all children of the receiver"	myChildren do:[:child|		aBlock value: child.		child allChildrenDo: aBlock].! !!Hierarchical methodsFor: 'parent-child' stamp: 'ar 9/17/1999 12:28'!withAllChildrenDo: aBlock	"Execute aBlock for all children of and the receiver itself"	aBlock value: self.	myChildren do:[:child|		child withAllChildrenDo: aBlock.	].! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 9/17/1999 00:30'!parseScene: aVRMLStream	^self parseScene: aVRMLStream url:''! !!VRMLNodeParser methodsFor: 'scene parsing' stamp: 'ar 9/17/1999 00:30'!parseScene: aVRMLStream url: sceneURL	| version node |	version := aVRMLStream resetAndCheckVersion.	version isNil ifTrue:[^self error:'No VRML file'].	version first = '2.0' ifFalse:[^self error:'Wrong VRML version (',version first,')'].	version last = 'utf8' ifFalse:[^self error:'Wrong VRML character definition set (not utf8)'].	'Reading VRML file' 		displayProgressAt: Sensor cursorPoint		from: 0 to: 100		during:[:bar|			infoBar := bar.			scene := VRMLScene new.			scene fileURL: sceneURL.			[aVRMLStream skipSeparators.			aVRMLStream atEnd] whileFalse:[				node := self parseStatement: aVRMLStream.				node ifNotNil:[scene addNode: node].			].	].	^scene! !!VRMLNodeParser class methodsFor: 'instance creation' stamp: 'ar 9/17/1999 00:30'!parse: aStream url: sceneURL	^self new parseScene: aStream asVRMLStream url: sceneURL! !!VRMLNodeParser class methodsFor: 'instance creation' stamp: 'ar 9/17/1999 00:29'!parseFileNamed: aString	"VRMLNodeParser parseFileNamed:'C:\WDI-Website\Link 3D Models\08-17-99\vrml\test.wrl'"	"MessageTally spyOn:[		VRMLNodeParser 			parseFileNamed:'C:\WDI-Website\Link 3D Models\08-17-99\vrml\linkvrml97.WRL']"	| stream result |	stream := FileStream readOnlyFileNamed: aString.	stream size < 500000 "cache in memory"		ifTrue:[result _ self parse: (ReadStream on: stream contentsOfEntireFile) url: stream name]		ifFalse:[result := self parse: stream].	stream close.	^result! !!VRMLScene methodsFor: 'actions' stamp: 'ar 9/16/1999 23:27'!routeFrom: fromNode event: outEventName to: toNode event: inEventName	| inEvent outEvent list |true ifTrue:[^self]. "ar 9/16/1999: disabled for now"	outEvent _ (self definedNode: fromNode) outEventNamed: outEventName.	outEvent == nil ifTrue:[self error: outEventName,' is not a valid event'].	inEvent _ (self definedNode: toNode) inEventNamed: inEventName.	inEvent == nil ifTrue:[self error: inEventName,' is not a valid event'].	list _ (self actions at: fromNode ifAbsentPut:[Dictionary new])			at: outEvent ifAbsentPut:[Dictionary new].	(list at: toNode ifAbsentPut:[Set new]) add: inEvent.! !!VRMLStream methodsFor: 'initialize' stamp: 'ar 9/17/1999 00:20'!on: refStream	theStream := refStream.	backups := OrderedCollection new: 100.! !!VRMLStream methodsFor: 'initialize' stamp: 'ar 9/17/1999 00:20'!reset	backups := OrderedCollection new: 100.	theStream reset.! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 9/17/1999 00:20'!nextByte	| byte |	byte _ theStream next.	byte == nil		ifTrue:[^nil]		ifFalse:[^byte asInteger]! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 9/17/1999 00:19'!position	^theStream position! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 9/17/1999 00:19'!position: aNumber	theStream position: aNumber.! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 9/17/1999 00:20'!skip: n	theStream skip: n.! !!VRMLStream methodsFor: 'accessing' stamp: 'ar 9/17/1999 00:12'!skipSeparators	| char |	[(char := self nextChar) == nil ifTrue:[^self].	SeparatorChars includes: char asciiValue] whileTrue:[		char = $# ifTrue:[self skipLine].	].	self skip: -1.! !!VRMLStream methodsFor: 'character reading' stamp: 'ar 9/17/1999 00:08'!firstChar	| char |	self backup.	char := self utf8Char.	(char == nil or:[NonFirstChars includes: char asciiValue]) ifTrue:[		self restore.		^nil	] ifFalse:[		self discard.		^char	].! !!VRMLStream methodsFor: 'character reading' stamp: 'ar 9/17/1999 00:13'!restChar	| char |	self backup.	char := self utf8Char.	(char == nil or:[NonRestChars includes: char asciiValue]) ifTrue:[		self restore.		^nil	] ifFalse:[		self discard.		^char	].! !!VRMLStream methodsFor: 'character reading' stamp: 'ar 9/17/1999 00:08'!utf8Char	"Note: we silently clamp every char to US ASCII range"	| firstByte lastByte maskValue prevByte |	firstByte := lastByte := self nextByte.	firstByte == nil ifTrue:[^nil].	firstByte < 128 ifTrue:[^Character value: firstByte].	self halt.	"More than one byte"	maskValue := 2r00100000.	[prevByte := lastByte.	lastByte := self nextByte.	(firstByte bitAnd: maskValue) = 0] whileTrue:[		maskValue := maskValue bitShift: -1.	].	^Character value: (lastByte bitAnd: 2r00111111) + ((prevByte bitAnd: 1) bitShift: 6).! !!VRMLStream methodsFor: 'reading data' stamp: 'ar 9/17/1999 00:10'!readInt32	| negative intVal char |	self backup.	negative := false.	"Read sign"	char := self nextChar.	char isDigit ifFalse:[		char = $- ifTrue:[			negative := true		] ifFalse:[			char = $+ ifFalse:[ self restore. ^nil]].		char := self nextChar].	(char = $0 and:[self peekChar asLowercase = $x]) ifTrue:[		"hexadecimal notation"		self skip: 1.		intVal := self readInteger: 16.	] ifFalse:[		"decimal notation"		self skip: -1.		intVal := self readInteger: 10.	].	self discard.	^negative		ifTrue:[0 - intVal]		ifFalse:[intVal]! !!VRMLStream methodsFor: 'private-reading' stamp: 'ar 9/17/1999 00:01'!digitValueOf: char	^DigitValues at: char asciiValue + 1! !!VRMLStream methodsFor: 'private-reading' stamp: 'ar 9/17/1999 00:00'!readInteger: base 	"Optimized version of Integer>>readFrom:base: for the VRML stream"	| digit value neg startPos aStream char |	aStream _ self.	char _ aStream next.	char = $-		ifTrue:[	neg _ true.				char _ aStream next]		ifFalse:[	neg _ false.				char = $+ ifTrue:[char _ aStream next]].	value _ 0.	startPos _ aStream position-1.	[char == nil] whileFalse:[		digit _ self digitValueOf: char.		(digit < 0 or: [digit >= base]) ifTrue:[			aStream skip: -1.			aStream position = startPos ifTrue: [self error: 'At least one digit expected here'].			neg ifTrue: [^ 0 - value].			^ value		] ifFalse: [value _ value * base + digit].		char _ aStream next].	neg ifTrue: [^ 0 - value].	^ value! !!VRMLStream class methodsFor: 'class initialization' stamp: 'ar 9/17/1999 00:04'!initialize	"VRMLStream initialize"	NonFirstChars := Set new: 100.	NonFirstChars 		addAll: (16r30 to: 16r39);		addAll: (16r0 to: 16r20);		addAll: #(16r22 16r23 16r27 16r2B 16r2C 16r2D 16r2E 16r5B 16r5C 16r5D 16r7B 16r7D 16r7F).	NonRestChars := Set new: 100.	NonRestChars		addAll: (16r0 to: 16r20);		addAll: #(16r22 16r23 16r27 16r2C 16r2E 16r5B 16r5C 16r5D 16r7B 16r7D 16r7F).	SeparatorChars := Set new: 10.	SeparatorChars addAll: #(16r0D 16r0A 16r20 16r09 16r2C 16r23).	DigitValues _ Array new: 256.	DigitValues atAllPut: -1.	0 to: $9 asciiValue do:[:i|		DigitValues at: i+1 put: i - $0 asciiValue].	$A asciiValue to: $Z asciiValue do:[:i|		DigitValues at: i+1 put: i - $A asciiValue + 10].	0 to: 255 do:[:i|		(DigitValues at: i+1) = (Character value: i) digitValue			ifFalse:[^self error:'Digit value initialization failed'].	].! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/16/1999 19:52'!createActorFor: aMesh defaultName: aString	^self createActorFor: aMesh			name: (attributes at: #currentName ifAbsent:[aString])			suffix: ''! !!VRMLWonderlandBuilder methodsFor: 'building actors' stamp: 'ar 9/16/1999 23:23'!createActorFor: aMesh name: aString suffix: suffix	| actor |	actor _ myWonderland createSimpleActor: aMesh 					named: aString, suffix					parent: currentActor.	"actor setMaterial: (attributes at: #currentMaterial ifAbsent:[nil])."	aMesh == nil ifFalse:[attributes at: #currentShape put: actor].	^actor! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/16/1999 23:14'!doBox: node	| size box |	size _ (node attributeNamed:'size') value.	box _ B3DIndexedMesh vrml97Box.	self createActorFor: box defaultName:'box'.	currentActor resizeRightNow: size first @ size second @ size third undoable: false.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/16/1999 23:37'!doColor: node	| colors |	colors _ (node attributeNamed: 'color') value.	attributes at: #currentColors put: (colors collect:[:c| c asB3DColor])! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/16/1999 23:15'!doCone: node	| radius height doSide doBottom cone |	radius _ (node attributeNamed:'bottomRadius') value.	height _ (node attributeNamed:'height') value.	doSide _ (node attributeNamed:'side') value.	doBottom _ (node attributeNamed:'bottom') value.	cone _ B3DIndexedMesh vrml97Cone: doSide bottom: doBottom.	self createActorFor: cone defaultName:'cone'.	currentActor resizeRightNow: radius @ height @ radius undoable: false.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/16/1999 23:15'!doCylinder: node	| radius height doSide doBottom doTop cylinder |	radius _ (node attributeNamed:'radius') value.	height _ (node attributeNamed:'height') value.	doSide _ (node attributeNamed:'side') value.	doBottom _ (node attributeNamed:'bottom') value.	doTop _ (node attributeNamed:'top') value.	cylinder _ B3DIndexedMesh vrml97Cylinder: doSide bottom: doBottom top: doTop.	self createActorFor: cylinder defaultName:'cylinder'.	currentActor resizeRightNow: radius @ height @ radius undoable: false.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/16/1999 23:16'!doImageTexture: node	| attr texFileName tex |	"Create a new texture."	attr _ node attributeNamed: 'url'.	(attr notNil and:[attr value notNil]) 		ifTrue:[			texFileName _ (FileDirectory on: (FileDirectory dirPathFor: scene fileURL)) fullNameFor: attr value first.			(FileDirectory default fileExists: texFileName)				ifTrue:[tex _ myWonderland makeTextureFrom: texFileName].			attributes at: #currentTexture put: tex].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/16/1999 23:51'!doIndexedFaceSet: node	| attr faces points mesh |	attributes at: #currentPoints put: nil.	attr _ node attributeNamed: 'coord'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	points _ attributes at: #currentPoints.	points ifNil:[^self].	attr _ node attributeNamed: 'coordIndex'.	(attr notNil and:[attr value notNil]) 		ifTrue:[faces _ self facesFrom: attr value for: points].	faces ifNil:[^self].	mesh _ B3DSimpleMesh withAll: faces.	self assignIndexedNormals: node in: mesh.	self assignIndexedTexCoords: node in: mesh.	self assignIndexedColors: node in: mesh.	mesh _ mesh asIndexedTriangleMesh.	"Try to recycle the actors"	(currentActor == nil or:[currentActor hasMesh])		ifTrue:[self createActorFor: mesh]		ifFalse:[	currentActor setMesh: mesh.				attributes at: #currentShape put: currentActor].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/16/1999 20:09'!doLOD: node	| levels |	levels _ (node attributeNamed: 'level') value.	levels size > 0 ifTrue:[		levels last doWith: self.	].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/16/1999 23:24'!doShape: node	| attr shape |	attributes at: #currentTexture put: nil.	attributes at: #currentMaterial put: nil.	attributes at: #currentShape put: nil.	attr _ node attributeNamed: 'appearance'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	attr _ node attributeNamed: 'geometry'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	shape _ attributes at: #currentShape.	shape == nil ifFalse:[		shape setMaterial: (attributes at: #currentMaterial ifAbsent:[nil]).		shape setTexturePointer: (attributes at: #currentTexture ifAbsent:[nil])].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/16/1999 23:15'!doSphere: node	| radius sphere |	radius _ (node attributeNamed:'radius') value.	sphere _ B3DIndexedMesh vrml97Sphere.	self createActorFor: sphere defaultName:'sphere'.	currentActor resizeRightNow: radius @ radius @ radius undoable: false.! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 9/16/1999 20:19'!doSwitch: node	| choices which |	choices _ (node attributeNamed:'choices') value.	which _ (node attributeNamed: 'whichChoice') value + 1.	(which > 0 and:[which <= choices size])		ifTrue:[(choices at: which) doWith: self].! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 9/16/1999 23:37'!assignIndexedColors: node in: mesh	| attr colors colorIndex faces vertices |	attributes at: #currentColors put: nil.	attr _ node attributeNamed: 'color'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	colors _ attributes at: #currentColors.	(colors == nil or:[colors size = 0]) ifTrue:[^self].	attr _ (node attributeNamed: 'colorIndex') value.	attr size = 0 ifTrue:[attr _ (node attributeNamed:'coordIndex') value].	colorIndex _ ReadStream on: attr.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[colorIndex next = -1] whileTrue.		colorIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) color: (colors at: colorIndex next + 1).		].	].! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 9/16/1999 23:29'!assignIndexedNormals: node in: mesh	| attr normals nrmlIndex faces vertices |	attributes at: #currentNormals put: nil.	attr _ node attributeNamed: 'normal'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	normals _ attributes at: #currentNormals.	normals == nil ifTrue:[^self].	attr _ (node attributeNamed: 'normalIndex') value.	attr size = 0 ifTrue:[attr _ (node attributeNamed: 'coordIndex') value].	nrmlIndex _ ReadStream on: attr.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[nrmlIndex next = -1] whileTrue.		nrmlIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) normal: (normals at: nrmlIndex next + 1).		].	].! !!VRMLWonderlandBuilder methodsFor: 'building meshes' stamp: 'ar 9/16/1999 23:29'!assignIndexedTexCoords: node in: mesh	| attr faces vertices texCoords texIndex |	attributes at: #currentTexCoords put: nil.	attr _ node attributeNamed: 'texCoord'.	(attr notNil and:[attr value notNil]) 		ifTrue:[attr value doWith: self].	texCoords _ attributes at: #currentTexCoords.	texCoords == nil ifTrue:[^self].	attr _ (node attributeNamed: 'texCoordIndex') value.	attr size = 0 ifTrue:[attr _ (node attributeNamed:'coordIndex') value].	texIndex _ ReadStream on: attr.	faces _ mesh faces.	1 to: faces size do:[:i|		vertices _ (faces at: i) vertices.		[texIndex next = -1] whileTrue.		texIndex skip: -1.		1 to: vertices size do:[:index|			(vertices at: index) texCoord: (texCoords at: texIndex next + 1).		].	].! !VRMLStream initialize!