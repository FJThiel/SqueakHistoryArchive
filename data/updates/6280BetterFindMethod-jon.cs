'From Squeak3.7beta of ''1 April 2004'' [latest update: #5967] on 14 September 2004 at 9:01:55 am'!"Change Set:		BetterFindMethod-jonDate:			12 September 2004Author:			Jon HylandsA simple addition that lets you pare down huge lists of methods in large classes when you use 'findMethod'. If you select the 'Enter Wildcard' choice at the top of the menu, you will be prompted for a partial method name. If you don't have an asterick (*) anywhere in the string, one will automatically be added to the start and end of what you type.After that, the pared-down list of matching methods will be presented for selection as normal.Rev 2 - Added a second command to the menu, to go to the wildcard choice first without first presenting the entire menu. Also fixed it to jump directly to the method if only one wildcard match is found."!!Browser methodsFor: 'class functions' stamp: 'jon 9/14/2004 09:00'!classListMenu: aMenu shifted: shifted	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"	shifted		ifTrue:			[^ self shiftedClassListMenu: aMenu].	aMenu addList: #(		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		spawnHierarchy)		('browse protocol (p)'		browseFullProtocol)		-		('printOut'					printOutClass)		('fileOut'					fileOutClass)		-		('show hierarchy'			hierarchy)		('show definition'			editClass)		('show comment'			editComment)		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)		-		('find method...'				findMethod)		('find method wildcard...'				findMethodWithWildcard)		-		('more...'					offerShiftedClassListMenu)).	^ aMenu! !!Browser methodsFor: 'class functions' stamp: 'jon 9/12/2004 15:29'!findMethod	"Pop up a list of the current class's methods, and select the one chosen by the user"	| aClass selectors reply cat messageCatIndex messageIndex |	self classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	aClass := self selectedClassOrMetaClass.	selectors := aClass selectors asSortedArray.	selectors isEmpty ifTrue: [self inform: aClass name, ' has no methods.'. ^ self].	reply := (SelectionMenu		labelList: (Array with: 'Enter Wildcard'), selectors		lines: #(1)		selections: (Array with: 'EnterWildcard'), selectors) startUp.	reply == nil ifTrue: [^ self].	reply = 'EnterWildcard'		ifTrue: [			reply := FillInTheBlank request: 'Enter partial method name:'.			(reply isNil or: [reply isEmpty])				ifTrue: [^self].			(reply includes: $*)				ifFalse: [reply := '*', reply, '*'].			selectors := selectors select: [:each | reply match: each].			selectors isEmpty ifTrue: [self inform: aClass name, ' has no matching methods.'. ^ self].			reply := selectors size = 1				ifTrue: [selectors first]				ifFalse: [					(SelectionMenu						labelList: selectors						selections: selectors) startUp].			reply == nil ifTrue: [^ self]].	cat := aClass whichCategoryIncludesSelector: reply.	messageCatIndex := self messageCategoryList indexOf: cat.	self messageCategoryListIndex: messageCatIndex.	messageIndex := (self messageList indexOf: reply).	self messageListIndex: messageIndex! !!Browser methodsFor: 'class functions' stamp: 'jon 9/14/2004 08:36'!findMethodWithWildcard	"Pop up a list of the current class's methods, and select the one chosen by the user"	| aClass selectors reply cat messageCatIndex messageIndex |	self classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	aClass := self selectedClassOrMetaClass.	selectors := aClass selectors asSortedArray.	selectors isEmpty ifTrue: [self inform: aClass name, ' has no methods.'. ^ self].	reply := FillInTheBlank request: 'Enter partial method name:'.	(reply isNil or: [reply isEmpty])		ifTrue: [^self].	(reply includes: $*)		ifFalse: [reply := '*', reply, '*'].	selectors := selectors select: [:each | reply match: each].	selectors isEmpty ifTrue: [self inform: aClass name, ' has no matching methods.'. ^ self].	reply := selectors size = 1		ifTrue: [selectors first]		ifFalse: [			(SelectionMenu				labelList: selectors				selections: selectors) startUp].	reply == nil ifTrue: [^ self].	cat := aClass whichCategoryIncludesSelector: reply.	messageCatIndex := self messageCategoryList indexOf: cat.	self messageCategoryListIndex: messageCatIndex.	messageIndex := (self messageList indexOf: reply).	self messageListIndex: messageIndex! !