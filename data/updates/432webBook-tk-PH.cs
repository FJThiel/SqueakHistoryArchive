'From Squeak 2.2 of Sept 23, 1998 on 24 November 1998 at 2:23:54 pm'!nil subclass: #ObjectOut	instanceVariableNames: 'url page recursionFlag '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!ObjectOut subclass: #MorphObjectOut	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!Object subclass: #SqueakPage	instanceVariableNames: 'url title comment thumbnail contentsMorph creationTime creationAuthor lastChangeTime lastChangeAuthor policy dirty '	classVariableNames: 'MaxThumbnailWidthOrHeight RecentMaxNum RecentStem '	poolDictionaries: ''	category: 'Morphic-WebBooks'!Object subclass: #SqueakPageCache	instanceVariableNames: ''	classVariableNames: 'GlobalPolicy NextURL PageCache '	poolDictionaries: ''	category: 'Morphic-WebBooks'!!Object methodsFor: 'testing' stamp: 'tk 10/30/1998 15:10'!isInMemory	"All normal objects are."	^ true! !!Object methodsFor: 'class membership' stamp: 'tk 10/21/1998 12:38'!xxxClass	"For subclasses of nil, such as ObjectOut"	^ self class! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/3/1998 20:56'!saveOnURL	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| um pg |	pg _ self saveOnURLbasic.	um _ URLMorph newForURL: pg url.	um setURL: pg url page: pg.	um isBookmark: true.	self primaryHand attachMorph: um.! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/20/1998 11:47'!saveOnURL: suggestedUrlString	"Save myself on a SmartReferenceStream file.  If I don't already have a url, use the suggested one.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg _ self valueOfProperty: #SqueakPage) ifNil: [pg _ SqueakPage new]		ifNotNil: [pg contentsMorph ~~ self ifTrue: [				self inform: 'morph''s SqueakPage property is out of date'.				pg _ SqueakPage new]].	(url _ pg url) ifNil: [url _ pg urlNoOverwrite: suggestedUrlString].	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol _ pg policy) ifNil: [pol _ #neverWrite].	pg policy: #now; dirty: true.  pg write.	"force the write"	pg policy: pol.	^ pg! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/20/1998 10:27'!saveOnURLbasic	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg _ self valueOfProperty: #SqueakPage) ifNil: [pg _ SqueakPage new]		ifNotNil: [pg contentsMorph ~~ self ifTrue: [				self inform: 'morph''s SqueakPage property is out of date'.				pg _ SqueakPage new]].	(url _ pg url) ifNil: [		url _ 'ftp://server/books/myBook/page1.sp'.	"do better?"		url _ FillInTheBlank 				request: 'url of a place to store this object.Must begin with file:// or ftp://' 				initialAnswer: url.		url size == 0 ifTrue: [^ self beep]].	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol _ pg policy) ifNil: [pol _ #neverWrite].	pg policy: #now; dirty: true.  pg write.	"force the write"	pg policy: pol.	^ pg! !!BookMorph methodsFor: 'accessing' stamp: 'tk 11/3/1998 21:17'!pageNumberOf: aMorph	"Modified so that if the page IS in memory, other pages don't have to be brought in."	| ii pp |	ii _ 0.	1 to: pages size do: [:jj |		(pp _ pages at: jj) isInMemory ifTrue: [			pp = aMorph ifTrue: [ii _ jj]]].	ii = 0 ifTrue: [ii _ pages indexOf: aMorph].	"bring in every page"	^ ii! !!BookMorph methodsFor: 'accessing' stamp: 'tk 10/22/1998 15:47'!pages: aMorphList	pages _ aMorphList asOrderedCollection.	"It is tempting to force the first page to be the current page.  But then, two pages might be shown at once!!  Just trust the copying mechanism and let currentPage be copied correctly. --Ted."! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/23/1998 14:49'!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending newPage |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	oldPageNumber _ self pageNumberOf: currentPage.	oldPageNumber = 0 ifTrue: [oldPageNumber _ nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue:				[nil]			ifFalse:				[oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	self currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		currentPage fullReleaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	self snapToEdgeIfAppropriate.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["Nil at init time, for example" aWorld displayWorld].! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/3/1998 21:18'!goToPageMorph: aMorph	| ii |	ii _ self pageNumberOf: aMorph.	ii = 0 ifFalse: [self goToPage: ii].! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/5/1998 00:05'!nextPage	| i |	currentPage == nil ifTrue: [^ self goToPage: 1].	i _ (self pageNumberOf: currentPage) + 1.	self goToPage: i.! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/5/1998 00:06'!pageNumber.	^ self pageNumberOf: currentPage! !!BookMorph methodsFor: 'navigation' stamp: 'tk 11/23/1998 15:01'!previousPage	| ii |	ii _ (self pageNumberOf: currentPage) - 1.	ii = 0 ifTrue: [ii _ pages size].	self goToPage: ii.! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/23/1998 15:03'!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	subMenu add: 'send other pages to server' action: #savePagesOnURL.	aMenu add: 'book...' subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:24'!getStemUrl	"Try to find the old place where this book was stored.  Confirm with the user.  Else ask for new place."| initial pg url ll |initial _ ''.(pg _ currentPage valueOfProperty: #SqueakPage) ifNotNil: [	pg contentsMorph == currentPage ifTrue: [		initial _ pg url]].	"If this page has a url"pages doWithIndex: [:aPage :ind |	initial size = 0 ifTrue: [		aPage isInMemory ifTrue: [			(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [				initial _ pg url]]]].	"any page with a url"initial size = 0 ifTrue: [initial _ 'ftp://server/books/myBook/page1.sp'].url _ FillInTheBlank 		request: 'url of the place to store a typical page in this book.Must begin with file:// or ftp://' 		initialAnswer: initial.ll _ url findLast: [:char | char == $.].ll = 0 ifFalse: [url _ url copyFrom: 1 to: ll-1].	"remove .sp"^ (url splitInteger) at: 1		"remove trailing number"! !!BookMorph methodsFor: 'menu' stamp: 'tk 10/30/1998 14:38'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu addList:	#(			('sort pages'				sortPages)			('make bookmark'		bookmarkForThisPage)			('make thumbnail'		thumbnailForThisPage)			('remove control panel'	hidePageControls)		).	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	aMenu add: 'send other pages to server' action: #savePagesOnURL.	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel].! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:22'!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| pg stem |stem _ self getStemUrl.	"user must approve"stem size = 0 ifTrue: [^ self].pages doWithIndex: [:aPage :ind | 	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		pg _ aPage saveOnURL: stem,(ind printString),'.sp'.		]].pages do: [:aPage |	"does write the current page too"	(aPage isInMemory and: [(currentPage == aPage) not]) ifTrue: [		pg _ aPage valueOfProperty: #SqueakPage.		pg purge]].	"recover the space"! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/23/1998 16:31'!savePagesOnURL	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are already totally out will stay that way."	| response curr pg |	response _ (PopUpMenu labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)' withCRs)			startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' withCRs.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 0 ifTrue: [^ self].curr _ currentPage.pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		self goToPageMorph: aPage.		aPage saveOnURLbasic.	"ask user if no url"		]].self goToPageMorph: curr.pages do: [:aPage |	"does write the current page too"	(aPage isInMemory and: [(curr == aPage) not]) ifTrue: [		pg _ aPage valueOfProperty: #SqueakPage.		pg purge]].	"recover the space"! !!BookMorph methodsFor: 'other' stamp: 'tk 10/22/1998 15:42'!releaseCachedState	"Release the cached state of all my pages."	super releaseCachedState.	pages do: [:page | page fullReleaseCachedState].! !!ObjectOut commentStamp: '<historical>' prior: 0!I am a stand-in for an object that is out on the disk.  The object that is out on the disk is the head of a tree of objects that are out.  See SqueakPage.When any message is sent to me, I don't understand it, and bring in my true object.  I become myself with the objects and resend the message.  I may not represent the object nil.  The file is represented as a url, and that url may point at any file on the net.  page is a SqueakPage.If the cache already has an object, widely in use, that claims to be the object for my url, what do I do?  I can't become him, since others believe that he is the true object.  Run through memory and replace refs to me with refs to him.  Be careful not to trigger a fault.  Become me to a string, then find pointers and replace?[[[They don't want to end up holding an ObjectOut.  (would oscillate back and forth)  This is a problem.  A user could bring in two trees that both refer to a 3rd url.  (check with cache before installing any new ObjectOut) Two trees could be written to the same url.Or, I remain an ObjectOut, and keep getting notUnderstood, and keep returning the other guy.Or I smash the cache, and install MY page and object.  Other guy is a copy -- still in, but with no place in the cache.  When we both write to the same url, there will be trouble.]  No -- search and replace.]]]Note that my selectors and all my subclasses' selectors are not searched in Senders and Implementors.  Remember that!!!!ObjectOut reorganize!('fetch from disk' doesNotUnderstand: xxxFetch xxxFixup xxxSetUrl:page:)('object storage' comeFullyUpOnReload objectToStoreOnDataStream readDataFrom:size: storeDataOn: veryDeepCopyWith:)('basics' == become: identityHash isInMemory nextInstance nextObject pointsTo: rehash xxxClass xxxClone xxxInstVarAt: xxxInstVarAt:put:)('access' xxxUrl)!!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/20/1998 12:20'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| returnValue realObject |	recursionFlag == true ifTrue: [		true confirm: 'Object being fetched for a second time.This is an error that needs to be fixed.Do it anyway to recover the data?' orCancel: [		^ aMessage error: 'Recursive not understood error in ObjectOut']].		"We are not an object yet.  There is a problem in the fetching code."	recursionFlag _ true.	"fetch the object"	realObject _ self xxxFetch.		"watch out for the become!!"			"Now we ARE the realObject"	returnValue _ aMessage sentTo: realObject.	^ returnValue! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/16/1998 09:57'!xxxFetch	"Bring in my object and replace all references to me with references to him.  First try looking up my url in the pageCache.  Then try the page (and install it, under its url).  Then start from scratch with the url."	| truePage object existing |	existing _ SqueakPageCache pageCache at: url ifAbsent: [nil].	existing ifNotNil: [existing isContentsInMemory		ifTrue: [page _ truePage _ existing]].	"This url already has an object in this image"	truePage ifNil: [		truePage _ SqueakPageCache atURL: url oldPage: page].	object _ truePage isContentsInMemory 		ifTrue: [truePage contentsMorph]		ifFalse: [truePage fetchInformIfError].	"contents, not the page"			"Later, collect pointers to object and fix them up.  Not scan memory"	object ifNil: [^ 'Object could not be fetched.'].	"recursionFlag _ false."  	"while I still have a pointer to myself"	truePage contentsMorph: object.	page _ truePage.	self xxxFixup.	^ object	"the final object!!" ! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/15/1998 19:59'!xxxFixup	"There is already an object in memory for my url.  All pointers to me need to be pointers to him.  Can't use become, because other pointers to him must stay valid."	| real temp list |	real _ page contentsMorph.	real == self ifTrue: [page error: 'should be converted by now'].	temp _ self.	list _ (Smalltalk pointersTo: temp) asOrderedCollection.	list add: thisContext.  list add: thisContext sender.	list do: [:holder |		1 to: holder class instSize do:			[:i | (holder instVarAt: i) == temp ifTrue: [holder instVarAt: i put: real]].		1 to: holder basicSize do:			[:i | (holder basicAt: i) == temp ifTrue: [holder basicAt: i put: real]].		].	^ real! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 10/21/1998 13:01'!xxxSetUrl: aString page: aSqkPage	url _ aString.	page _ aSqkPage.! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 14:33'!comeFullyUpOnReload	"Normally this read-in object is exactly what we want to store"	^ self! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 14:33'!objectToStoreOnDataStream    "Return an object to store on a data stream (externalize myself)."    ^ self! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 14:37'!readDataFrom: aDataStream size: varsOnDisk	"Make self be an object based on the contents of aDataStream, which was generated by the object's storeDataOn: method. Return self."	| cntInstVars |	cntInstVars _ self xxxClass instSize.	self xxxClass isVariable		ifTrue: [self xxxClass error: 'needs updating']	"assume no variable subclasses"		ifFalse: [cntInstVars _ varsOnDisk].	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self xxxInstVarAt: i put: aDataStream next]."	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next]."	^ self! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 15:18'!storeDataOn: aDataStream	"Store myself on a DataStream. See also objectToStoreOnDataStream.	must send 'aDataStream beginInstance:size:'"	| cntInstVars |	cntInstVars _ self class instSize.	"cntIndexedVars _ self basicSize."	aDataStream		beginInstance: self xxxClass		size: cntInstVars "+ cntIndexedVars".	1 to: cntInstVars do:		[:i | aDataStream nextPut: (self xxxInstVarAt: i)]."	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]"! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 15:29'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new absent |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	class _ self xxxClass.	class isMeta ifTrue: [^ self].		"a class"	new _ self xxxClone.	"not a uniClass"	deepCopier references at: self put: new.	"remember"	"class is not variable"	index _ class instSize.	[index > 0] whileTrue: 		[sub _ self xxxInstVarAt: index.		(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])			ifNil: [new xxxInstVarAt: index put: (sub veryDeepCopyWith: deepCopier)]			ifNotNil: [new xxxInstVarAt: index put: subAss value].		index _ index - 1].	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/20/1998 15:30'!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	"This is just a comment, since this message is never looked up"	<primitive: 110>	self primitiveFailed! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/30/1998 15:11'!isInMemory	"We are a place holder for an object that is out."	^ false! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/4/1998 21:17'!nextInstance	"Primitive. Answer the next instance after the receiver in the 	enumeration of all instances of this class. Fails if all instances have been 	enumerated. Essential. See Object documentation whatIsAPrimitive."	<primitive: 78>	^nil! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/4/1998 21:17'!nextObject	"Primitive. Answer the next object after the receiver in the 	enumeration of all objects. Return 0 when all objects have been 	enumerated."	<primitive: 139>	self primitiveFailed.! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/4/1998 21:15'!pointsTo: anObject	"This method returns true if self contains a pointer to anObject,		and returns false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 14:40'!rehash	"Do nothing.  Here so sending this to a Set does not have to do a time consuming respondsTo:"! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/21/1998 12:28'!xxxClass	"Primitive. Answer the object which is the receiver's class. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 15:31'!xxxClone	<primitive: 148>	self primitiveFailed! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 15:19'!xxxInstVarAt: index 	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 73>	self primitiveFailed ! !!ObjectOut methodsFor: 'basics' stamp: 'tk 10/22/1998 14:39'!xxxInstVarAt: anInteger put: anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	self primitiveFailed ! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 11/20/1998 12:20'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| returnValue aMorph myUrl |	recursionFlag == true ifTrue: [		true confirm: 'Object being fetched for a second time.This is an error that needs to be fixed.Do it anyway to recover the data?' orCancel: [		^ aMessage error: 'Recursive not understood error in ObjectOut']].		"We are not an object yet.  There is a problem in the fetching code."	recursionFlag _ true.	myUrl _ url.	"can't use inst vars after become"	"fetch the object"	aMorph _ self xxxFetch.		"watch out for the become!!"			"Now we ARE a MORPH"	returnValue _ aMessage sentTo: aMorph.		"self == aMorph"	aMorph setProperty: #SqueakPage toValue: 			(SqueakPageCache pageCache at: myUrl).	^ returnValue! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 10/22/1998 15:43'!fullReleaseCachedState	"do nothing, especially don't bring in my object!!"! !!PasteUpMorph reorganize!('initialization' initialize)('cursor' cursor cursor: cursorAtEnd rectifyCursor selectedRect valueAtCursor valueAtCursor:)('display' canvasForSubmorphs: drawOn: padding)('dropping/grabbing' acceptDroppingMorph:event: allowSubmorphExtraction automaticPhraseExpansion automaticViewing morphToDropFrom: positionNear:forExtent:adjustmentSuggestion: repelsMorph:event: rootForGrabOf: rootMorphsAt: wantsDroppedMorph:event:)('layout' fixLayout insertionIndexFor: laySubpartsOutInOneRow layoutChanged layoutRow:lastRowBase: rowBaseFor:lastRowBase: rowMorphsStartingAt:)('menu & halo' addCustomMenuItems:hand: addOptionalHandlesTo:box: addPenMenuItems:hand: addPlayfieldMenuItems:hand: addStackMenuItems:hand: debuggingMenuFor: wantsHaloFor:)('model' createCustomModel model modelOrNil setModel:)('options' autoLineLayout autoLineLayout: automaticViewing: behaveLikeHolder indicateCursor indicateCursor: isPartsBin isPartsBin: openToDragNDrop openToDragNDrop: replaceTallSubmorphsByThumbnails resizeToFit resizeToFit: setPartsBinStatusTo: setThumbnailHeight toggleAlwaysShowThumbnail toggleAutoLineLayout toggleAutomaticPhraseExpansion toggleAutomaticViewing toggleIndicateCursor toggleIsPartsBin toggleMouseOverHalos toggleResizeToFit updateSubmorphThumbnails wantsMouseOverHalos wantsMouseOverHalos:)('painting' backgroundSketch backgroundSketch: makeNewDrawingWithin paintBackground paintingBoundsAround: reasonablePaintingExtent)('pen' clearTurtleTrails createOrResizeTrailsForm drawPenTrailFor:from:to: liftAllPens lowerAllPens trailMorph)('scripting' allTileScriptingElements emptyAnonymousScriptorFrom: expandPhrasesToScripts scriptorForTextualScript:ofPlayer:)('stack/card' becomeStack doWrap goToNextCard goToPreviousCard installAsCurrent: isStackLike morphsForInstanceData newCard scriptPerformer)('misc' abandonCostumeHistory allScriptEditors alwaysShowThumbnail color: demandsBoolean fullBounds heightForThumbnails impartPrivatePresenter invalidRect: isPlayfieldLike makeDetachable maxHeightToAvoidThumbnailing maximumThumbnailWidth mouseX mouseY navigateTo padding: prepareToBeSaved presenter presenter: removeScriptingControls replaceSubmorph:by: residesInPartsBin roundUpStrays slotNamesAndTypesForBank: smallThumbnailForPageSorter startRunningAll stepAll stopRunningAll thumbnailForPageSorter updateStatusForAllScriptEditors wantsKeyboardFocusFor:)('fileIn/Out')('object fileIn' convertbosfcep0:bosfcepcbbfgccpmcpbttloiairfidcu0: convertbosfcepc0:bosfcepcbbfgccpmcpbttloiairfidcu0: convertbosfcepcbbfgcc0:bosfcepcbbfgccpmcpbttloiairfidcu0: convertbosfcepcbbfgccpmcpbttloiairfidcuw0:bosfcepcbbfgccpmcpbttloiairfidcu0:)!!PasteUpMorph methodsFor: 'layout' stamp: 'tk 10/22/1998 13:55'!layoutChanged	super layoutChanged.	(self valueOfProperty: #SqueakPage) ifNotNil: [		self setProperty: #pageDirty toValue: true].		"I am the morph of a SqueakPage, I have changed and 		need to be written out again"! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'tk 11/23/1998 15:09'!addPlayfieldMenuItems: menu hand: aHandMorph	| subMenu prefix hasPalette |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'save as SqueakPage at url...' action: #saveOnURL.	subMenu add: 'navigate to...' action: #navigateTo.	subMenu add: 'round up strays' action: #roundUpStrays.	subMenu addLine.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	prefix _ (self hasProperty: #automaticPhraseExpansion) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'phrase expansion') action: #toggleAutomaticPhraseExpansion.	prefix _ (self hasProperty: #alwaysShowThumbnail) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'showing thumbnails') action: #toggleAlwaysShowThumbnail.	(self hasProperty: #alwaysShowThumbnail) ifTrue:		[subMenu add: 'set thumbnail height...' action: #setThumbnailHeight].	(hasPalette _ self standardPalette ~~ nil) ifTrue:		[prefix _ self automaticViewing ifTrue: ['stop '] ifFalse: ['start '].		subMenu add: (prefix, 'automatic viewing') action: #toggleAutomaticViewing].	subMenu addLine.	hasPalette ifTrue: [subMenu add: 'clear palette area' action: #clearPaletteArea].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	presenter ifNil:		[subMenu add: 'make detachable' action: #makeDetachable].	subMenu addLine.	subMenu add: 'use standard texture' action: #setStandardTexture.	subMenu add: 'make graph paper...' action: #makeGraphPaper.	subMenu addTitle: 'Playfield options'.	menu add: 'playfield options...' subMenu: subMenu.! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 10/1/1998 11:54'!setFileTypeToObject	"do nothing.  We don't have a file type"! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 10/2/1998 07:46'!asStream	"Return a RemoteFileStream (subclass of RWBinaryOrTextStream) on the contents of the remote file I represent.  For reading only."	^ self oldFileNamed: self fileName! !!SqueakPage commentStamp: '<historical>' prior: 0!A SqueakPage is holder for a page of morphs that live on the disk or on a server.A URLMorph is a thumbnail sized stand-in for the page.  Clicking on it gets the page.An ObjectOut is a fake object that stands for an object that is out on the disk.  (Like ObjectTracer or ObjectViewer.)A MorphObjectOut is a subclass that stands for a Morph that is out on the disk.To find out how to make the pages of any BookMorph go out to the disk (or a server), see 	http://minnow.cc.gatech.edu/SqueakDoc.1 then go to 'SqueakPages'.A SqueakPage is always in-memory.  Its contentsMorph will be 'become-ed' to a MorphObjectOut tombstone when it goes out.  (A page may or may not be in the cache.  First put it in, then ask it for the data.)  Sending any message to the contentsMorph triggers the fetch.  Many URLMorphs may hold onto one page.  A page has a thumbnail.  A URLMorph points at its page object.States of a SqueakPage, and the transitions to another state:1) have a url as a string.  Then: (URLMorph grabURL: 'file://Ted''s/books/tryThis/p1').  	Drop it into any morph.2) have a URLMorph, with page==nil.     Click it.  (makes an empty page, installs 	it in the global page cache)3) have a URLMorph with a SqueakPage, with contentsMorph==nil, 	but page is not in the cache (this is a rare case).  ask page contentsMorph.4) OUT: have a URLMorph with a SqueakPage, with contentsMorph being a MorphObjectOut, 	and its page is in the cache.  Sending the contentsMorph any message brings it in and	becomes it to the morph.  (fix up morph's pointer to the page.)5) Totally IN:  a morph, owned by a SqueakPage, has a page in the cache.  	The morph is clean.   	Whenever someone triggers a purge (when?), contentsMorph is becomed	to a MorphObjectOut. (go to 4)	Causing the morph to execute layoutChanged marks the morph as dirty.	(morph's property #pageDirty is set to true) (go to 6)6) Totally IN and dirty.  	Whenever any other page is fetched from the disk or the net, all other 	dirty pages are written and marked clean.  (go to 5)Note that the entire tree of submorphs goes out -- hundreds of objects.  Bringing the object back in brings in the SqueakPage, installs it in the cache.  Classes other than PasteUpMorph can easily be made to send their contents out if there is any need.Note that every book is now automatically a WebBook.  We simply give a page a url and tell it to purge.url		a stringtitle		comment		thumbnail		contentsMorph		(1) a pasteUpMorph with other morphs in it.					(2) a MorphObjectOut.  Sending any message brings it in. 					(3) nil if the page has never been in this image.creationTime		creationAuthor		lastChangeTime		lastChangeAuthor policy		#alwaysWrite, #neverWrite, #ask.  (cache can override with a global policy)			(Explicit writing by user has policy #neverWrite)dirty 		(Morph>>layoutChanged sends changed: #SqueakPage. If policy==#check, 				then the page sets dirty_true.)			(If policy==#alwaysWrite, then set dirty when the page is retrieved from the cache.)Class MorphObjectOut has an instance variable called page.All messages to an MorphObjectOut cause it to be brought in.  Except the messages needed to write the MorphObjectOut on the disk as part of a parent's being sent out.  (size, class, instSize, instVar:at:.  Can rename these and call from its own version of the writing routine.)	To purge, go through the clean pages, and any that have world not equal to this world, entomb them.  	(If an object in the subtree is held by an object outside the tree, it will remain,  And will be duplicated when the tree comes back in.  This is a problem already in normal uses of SmartRefStream.)!]style[(458 39 3184)f1,f1Rhttp://minnow.cc.gatech.edu/SqueakDoc.1;,f1!!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/2/1998 11:27'!contentsMorph	"Return what it is now.  If the morph is out on the disk, return nil.  Use fetchContents to get the data for sure."	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/30/1998 15:08'!fetchContents	"Make every effort to get contentsMorph."	self isContentsInMemory ifTrue: [^ contentsMorph].	^ self fetchInformIfError! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/2/1998 11:48'!fetchContentsIfAbsent: failBlock	"Make every effort to get contentsMorph.  Assume I am in the cache already."	| strm page temp temp2 |	SqueakPageCache write.		"sorry about the pause"	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [^ failBlock value].			page _ strm fileInObjectAndCode.	page isMorph ifTrue: [contentsMorph _ page].	"may be a bare morph"	"copy over the state"	temp _ url.	temp2 _ policy.	self copyAddedStateFrom: page.	url _ temp.	"don't care what it says"	temp2 ifNotNil: [policy _ temp2].		"use mine"	contentsMorph setProperty: #pageDirty toValue: nil.	self dirty: false.	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 11/20/1998 10:47'!fetchInformIfError	"Make every effort to get contentsMorph.  Put up a good notice if can't get it.  Assume page is in the cache already.  Overwrite the contentsMorph no matter what."	| strm page temp temp2 |	SqueakPageCache write.		"sorry about the pause"	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	"<<<<< Note Diff"		page _ strm fileInObjectAndCode.	page isMorph ifTrue: [contentsMorph _ page].	"may be a bare morph"	"copy over the state"	temp _ url.	temp2 _ policy.	self copyAddedStateFrom: page.	"including contentsMorph"	url _ temp.	"I know best!!"	temp2 ifNotNil: [policy _ temp2].		"use mine"	contentsMorph setProperty: #pageDirty toValue: nil.	self dirty: false.	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 10/30/1998 15:08'!isContentsInMemory	"Is my contentsMorph in memory, or is it an ObjectOut tombstone?  Be careful not to send it any message."	^ (contentsMorph xxxClass inheritsFrom: Object) and: [(contentsMorph == nil) not]! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 11/4/1998 20:34'!url	^ url! !!SqueakPage methodsFor: 'saving' stamp: 'tk 9/30/1998 22:40'!dirty: aBool	dirty _ aBool! !!SqueakPage methodsFor: 'saving' stamp: 'tk 10/8/1998 13:18'!policy	^ policy! !!SqueakPage methodsFor: 'saving' stamp: 'tk 9/30/1998 22:39'!policy: aSymbol	policy _ aSymbol! !!SqueakPage methodsFor: 'saving' stamp: 'tk 10/30/1998 15:08'!purge	"Replace my morph with a tombstone, if I am not in a world that is being shown."	| keep |	self isContentsInMemory ifFalse: [^ self].	contentsMorph ifNil: [^ self].  "out already"	url ifNil: [^ self].	"just to be safe"	keep _ World ~~ nil and: [contentsMorph world == World].	keep ifFalse: [		contentsMorph become: (MorphObjectOut new xxxSetUrl: url page: self)].		"Simple, isn't it!!"! !!SqueakPage methodsFor: 'saving' stamp: 'tk 11/23/1998 16:51'!write	"Decide whether to write this page on the disk."	| sf remoteFile |	policy == #neverWrite ifTrue: [^ self].		"demo mode, or write only when user explicitly orders it"	"All other policies do write:   #now"	contentsMorph ifNil: [^ self].	dirty _ dirty | ((contentsMorph valueOfProperty: #pageDirty) == true).		"set by layoutChanged"	dirty == true ifTrue: [ 		sf _ ServerDirectory new fullPath: url.		"check for shared password"		"contentsMorph allMorphsDo: [:m | m prepareToBeSaved].				done in objectToStoreOnDataStream"		Cursor wait showWhile: [			remoteFile _ sf newFileNamed: url.			remoteFile fileOutClass: nil andObject: self.			remoteFile close].		contentsMorph setProperty: #pageDirty toValue: nil.		dirty _ false].! !!SqueakPageCache commentStamp: '<historical>' prior: 0!A global cache of web pages known to this Squeak image.  Since there is a single, global page cache, it is implemented entirely as class methods.Once a page has an entry, keep it.  (url string -> A SqueakPage)  The SqueakPage has a thumbnail and other info, but may not have the contentsMorph.  The morph is purged when space is needed, and fetched from the server as needed.See SqueakPage's comment for the stages of in/out.!]style[(383 10 36)f1,f1LSqueakPage Comment;,f1!!SqueakPageCache class methodsFor: 'class initialization' stamp: 'tk 11/24/1998 14:22'!initialize	"SqueakPageCache initialize"	GlobalPolicy _ #neverWrite.	NextURL _ 1.	PageCache _ Dictionary new: 100.		"forgets urls of pages, but ObjectOuts still remember them"! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/2/1998 12:07'!atURL: aURLString	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	| pg |	^ PageCache at: aURLString ifAbsent: [		pg _ SqueakPage new.		"stamp _ Utilities authorInitialsPerSe ifNil: ['*']."		"pg author: stamp."		"Need to deal with inst vars if we turn out to be new!!"		"pg url: aURLString. 	done by atURL:put:"		self atURL: aURLString put: pg.		pg]! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/2/1998 12:06'!atURL: aURLString ifAbsent: failBlock	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	self halt.  "use atURL:"! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/20/1998 15:51'!atURL: aURLString oldPage: aPage	"Bring in page and return the object.  First try looking up my url in the pageCache.  Then try the page (and install it, under its url).  Then start from scratch with the url."	| myPage |	(myPage _ PageCache at: aURLString ifAbsent: [nil]) ifNotNil: [		^ myPage].	aPage url: aURLString.	"for consistancy"	PageCache at: aPage url put: aPage.	^ aPage! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/19/1998 17:24'!atURL: aURLString put: aSqueakPage	"Store the given page in the cache entry for the given URL."	aSqueakPage url: aURLString.	aSqueakPage contentsMorph ifNotNil: [		aSqueakPage contentsMorph setProperty: #SqueakPage toValue: aSqueakPage].	PageCache at: aURLString put: aSqueakPage.! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/30/1998 15:08'!doPagesInMemory: aBlock	"Evaluate aBlock for each page whose contentsMorph is in-memory.  Don't add or remove pages while in this loop."	PageCache do: [:sqkPage |		sqkPage isContentsInMemory ifTrue: [aBlock value: sqkPage]].! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/1/1998 13:02'!includesMorph: aPasteUp	PageCache do: [:squeakPage |		squeakPage contentsMorph == aPasteUp ifTrue: [^ true]].	^ false! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/20/1998 15:11'!pageCache	^ PageCache! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/1/1998 13:04'!pageForMorph: aPasteUp	PageCache do: [:squeakPage |		squeakPage contentsMorph == aPasteUp ifTrue: [^ squeakPage]].	^ nil! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/21/1998 12:48'!purge	"Replace morphs with tombstones in all pages that are clean and not being shown.  Write any dirty ones first, if allowed to."	GlobalPolicy == #neverWrite 		ifTrue: [PageCache doPagesInMemory: [:aPage | aPage purge]]			"Writing only done by user's command"		ifFalse: [			PageCache doPagesInMemory: [:aPage | aPage write; purge]].! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/21/1998 13:28'!purge: megs	"Replace morphs with tombstones in all pages that are clean and not being shown.  Do this until megs of new memory have been recovered.  Write any dirty ones first, if allowed to."	| goal |	goal _ Smalltalk garbageCollect + (megs * 1000000) asInteger.	PageCache doPagesInMemory: [:aPage | 		GlobalPolicy == #neverWrite ifFalse: [aPage write].		aPage purge.		Smalltalk garbageCollect > goal ifTrue: [^ true]].	"got enough"	^ false	"caller may want to tell the user to write out more pages"! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/22/1998 11:07'!write	"Write out all dirty pages"	GlobalPolicy == #neverWrite ifTrue: [^ self].	self doPagesInMemory: [:aPage | aPage write].! !!SystemDictionary methodsFor: 'retrieving' stamp: 'tk 9/29/1998 15:23'!allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."	"Answer a Collection of all the methods that call on aLiteral."	| aCollection special thorough aList |	#(23 48 'fred' (new open:label:)) size.		"Example above should find #open:label:, though it is deeply embedded here."	aCollection _ OrderedCollection new.	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:byte ].	thorough _ (aLiteral isMemberOf: Symbol)				and: ["Possibly search for symbols imbedded in literal arrays"					Preferences thoroughSenders].	Cursor wait showWhile: 		[self allBehaviorsDo: 			[:class |				aList _ thorough					ifTrue:			 			[(class thoroughWhichSelectorsReferTo: aLiteral special: special byte: byte)]					ifFalse:						[class whichSelectorsReferTo: aLiteral special: special byte: byte].				aList do: 					[:sel | sel ~~ #DoIt						ifTrue: [aCollection add: class name , ' ' , sel]]]].	^ aCollection! !!SystemTracer methodsFor: 'initialization' stamp: 'tk 10/20/1998 16:03'!initDict	writeDict _ Dictionary new: 256.	Smalltalk allClassesDo: 		[:class | 		class isBits 			ifTrue: 			[writeDict at: class put: (class isBytes ifTrue: [#writeBytes:]												ifFalse: [#writeWords:])]			ifFalse:			[writeDict at: class put: #writePointers:.			(class inheritsFrom: Set) | (class == Set) ifTrue:				[writeDict at: class put: #writeSet:].			(class inheritsFrom: IdentitySet) | (class == IdentitySet) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: IdentityDictionary) | (class == IdentityDictionary) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: MethodDictionary) | (class == MethodDictionary) ifTrue:				[writeDict at: class put: #writeMethodDictionary:]].				].	Smalltalk allBehaviorsDo: 		[:class | writeDict at: class class put: #writeBehavior:].	(ObjectTracer withAllSubclasses) do: 		[:class | writeDict at: class class put: #writeBehavior:].	(ObjectOut withAllSubclasses) do: 		[:class | writeDict at: class class put: #writeBehavior:].	writeDict at: PseudoContext class put: #writeBehavior:.	writeDict at: SmallInteger put: #writeClamped:.	writeDict at: CompiledMethod put: #writeMethod:.	writeDict at: Process put: #writeProcess:.	writeDict at: MethodContext put: #writeContext:.	writeDict at: BlockContext put: #writeContext:.! !!URLMorph commentStamp: '<historical>' prior: 0!This morph represents a URL for a SqueakPage. It displays the thumbnail for the associated page, if available. Used in page sorters and for bookmarks.This morph has several options:  a. It can act like a thumbnail for sorting (in which case it can be picked up and dragged) or it acts as a bookmark (in which case clicking on it activates it).  b. If it is a bookmorph, it can act on a particular book or it can act on whatever book it happens to be in at the time. The former is primarily used for making a graphical page index allowing random access to any page in the book.How to start.  Make a PasteUpMorph with any morphs in it.Decide where it should live, make a url string, and copy it.	'file://HardDisk/books/book1/myPage.morph'	'file://Ted''s/books/tryThis/p1.morph'	'ftp://doltest1.disney.com/squeak/test/p1.morph'	(ServerDirectory serverNamed: 'UpdatesAtDOL') pathNameChoose 'Save as Web Morph'Paste in the url.Drop the resulting thumbnail into some morph.See SqueakPage's comment for the stages of in/out.!]style[(988 10 36)f1,f1LSqueakPage Comment;,f1!!URLMorph methodsFor: 'event handling' stamp: 'tk 10/2/1998 08:58'!handlesMouseDown: evt	^ isBookmark! !!URLMorph methodsFor: 'event handling' stamp: 'tk 10/2/1998 08:55'!handlesMouseUp: evt	^ isBookmark! !!URLMorph methodsFor: 'event handling' stamp: 'tk 10/2/1998 08:58'!mouseDown: evt	"do nothing"! !!URLMorph methodsFor: 'event handling' stamp: 'tk 11/23/1998 17:36'!mouseUp: evt	| pg ow newPage mm |	"If inside a SqueakPage, replace it!!"	pg _ self enclosingPage.	pg ifNotNil: [		(ow _ pg contentsMorph owner) ifNotNil: [			pg contentsMorph delete.	"from its owner"			newPage _ SqueakPageCache atURL: url.			mm _ newPage fetchContents.			mm ifNotNil: [ow addMorph: mm.				page _ newPage].			^ self]].	"If I am a project, jump  -- not done yet"	"For now, just put new page on the hand"	newPage _ SqueakPageCache atURL: url.	mm _ newPage fetchInformIfError.	mm ifNotNil: [self primaryHand attachMorph: mm.		page _ newPage].! !!URLMorph methodsFor: 'updating' stamp: 'jm 6/17/1998 14:15'!pageHasChanged: aSqueakPage	"The given page has changed. Update this morph if it refers to the given page."	| thumbnail |	page == aSqueakPage ifFalse: [^ self].  "this change does not affect me"	thumbnail _ self thumbnailOrNil.	thumbnail ifNotNil: [		self extent: (thumbnail extent + 2).		self changed].! !!URLMorph methodsFor: 'private' stamp: 'tk 10/1/1998 13:05'!enclosingPage	"Answer the inner-most SqueakPage contents that contains this morph, or nil if there isn't one."	| m pg |	m _ owner.	[m == nil] whileFalse: [		(m isKindOf: PasteUpMorph) ifTrue: [			(pg _ SqueakPageCache pageForMorph: m) ifNotNil: [^ pg]].		m _ m owner].	^ nil! !!URLMorph methodsFor: 'private' stamp: 'tk 10/2/1998 08:20'!setURL: aURLString page: aSqueakPage	"Initialize the receiver for the given URL and page."	url _ aURLString.	page _ aSqueakPage.	page ifNotNil: [self pageHasChanged: page].! !!URLMorph methodsFor: 'private' stamp: 'tk 10/2/1998 12:07'!thumbnailOrNil	"Answer the thumbnail Form for the page this morph represents. Answer nil if no thumbnail is available."	page ifNil: [page _ SqueakPageCache atURL: url].	^ page thumbnail! !!URLMorph class methodsFor: 'instance creation' stamp: 'tk 10/2/1998 08:22'!grabURL: aURLString	"Create a URLMorph for this url.  Drop it and click it to get the SqueakPage."	World primaryHand attachMorph: ((self new) isBookmark: true; setURL: aURLString page: nil)! !!URLMorph class methodsFor: 'instance creation' stamp: 'tk 10/2/1998 12:08'!newForURL: aURLString	| pg |	pg _ SqueakPageCache atURL: aURLString.	^ self new setURL: aURLString page: pg! !SqueakPageCache initialize!