'From Squeak2.8alpha of 12 January 2000 [latest update: #2299] on 13 June 2000 at 12:48:21 am'!"Change Set:		altSyntaxTweaks2Date:			11 June 2000Author:			Numerous tweaks to the alternate syntax suggested by Alan for the short term...>* All variables to black italic (not actually italic here).>* Prefix keywords to veryDarkGray and bold.>* All other keywords to darkGray>* comments to brown>* Interior keywords that are being prefixed have the same emphasis>* Mimic the eToy system for now with regard to conditionals,>        ifTrue       into      Yes>        ifFalse       into       No>* In blocks, use 'with' instead of 'set', and retain the bar for now, so>         [:b :c |   ......  ]>becomes>         [With b c.  ..........]>* Use Answer in place of Return"!!BlockNode methodsFor: 'printing' stamp: 'di 6/13/2000 00:24'!printArgumentsOn: aStream indent: level	arguments size = 0 ifTrue: [^ self].	aStream dialect = #SQ00		ifTrue: [aStream withStyleFor: #setOrReturn do: [aStream nextPutAll: 'With'].				arguments do: 					[:arg | aStream space.					aStream withStyleFor: #blockArgument						do: [aStream nextPutAll: arg key]].				aStream nextPutAll: '. ']		ifFalse: [arguments do: 					[:arg | 					aStream nextPutAll: ':'.					aStream withStyleFor: #blockArgument						do: [aStream nextPutAll: arg key].					aStream nextPutAll: ' | ']].	"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1 ifTrue: [aStream crtab: level]! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/13/2000 00:34'!blockExpression	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."	| variableNodes temporaryBlockVariables |	variableNodes _ OrderedCollection new.	"Gather parameters."	(self matchToken: 'With') ifTrue:		[[self match: #period]			whileFalse: [variableNodes addLast: (encoder autoBind: self argumentName)]].	temporaryBlockVariables _ self temporaryBlockVariables.	self statements: variableNodes innerBlock: true.	parseNode temporaries: temporaryBlockVariables.	(self match: #rightBracket) ifFalse: [^ self expected: 'Period or right bracket'].	"The scope of the parameters and temporary block variables is no longer active."	temporaryBlockVariables do: [:variable | variable scope: -1].	variableNodes do: [:variable | variable scope: -1]! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/11/2000 15:27'!matchReturn	^ self matchToken: 'Answer'! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/11/2000 15:27'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>  	{selector, arguments, precedence}."	| args selector checkpoint |	doitFlag _ fromDoit.	fromDoit ifTrue:			[ctxt == nil				ifTrue: [^ {#DoIt. {}. 1}]				ifFalse: [^ {#DoItIn:. {encoder encodeVariable: 'homeContext'}. 3}]].	"NOTE: there is now an ambiguity between	keywordSelector (argName) -and- unarySelector (first expression).	Also, there is an amibuity (if there are no temp declarations) between	keywordSelector (argName) -and- PrefixKeyword (some expression).	We use duct tape for now."	(hereType == #word and: [tokenType == #leftParenthesis]) ifTrue:		[checkpoint _ self checkpoint.  "in case we have to back out"		selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #word				and: [tokenType == #leftParenthesis				and: [here first isLowercase						or: [(#('Test' 'Repeat' 'Answer') includes: here) not]]]]				whileTrue: 					[selector nextPutAll: self advance , ':'.  "selector part"					self advance.  "open paren"					(args size = 0 and: [tokenType ~~ #rightParenthesis]) ifTrue:						["This is really a unary selector on a method that						begins with a parenthesized expression.  Back out now"						self revertToCheckpoint: checkpoint.						^ {self advance asSymbol. {}. 1}].					args addLast: (encoder bindArg: self argumentName).			(self match: #rightParenthesis)						ifFalse: [^ self expected: 'right parenthesis']].			^ {selector contents asSymbol. args. 3}].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^ {selector. args. 2}].	^ self expected: 'Message pattern'! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/13/2000 00:31'!temporaries	" [ 'Use' (variable)* '.' ]"	| vars theActualText |	(self matchToken: #'Use') ifFalse: 		["no temps"		doitFlag ifTrue: [requestor				ifNil: [tempsMark _ 1]				ifNotNil: [tempsMark _ requestor selectionInterval first].			^ #()].		tempsMark _ prevMark + prevToken.		tempsMark > 0 ifTrue:			[theActualText _ source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark _ tempsMark + 1]].			^ #()].	vars _ OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #period) ifTrue: 		[tempsMark _ prevMark.		^ vars].	^ self expected: 'Period'! !!DialectStream methodsFor: 'as yet unclassified' stamp: 'di 6/13/2000 00:48'!withStyleFor: elementType do: aBlock	"For each element type, associate a color and emphasis"	elementType == #temporaryVariable ifTrue:		[^ self withColor: #black emphasis: #normal do: aBlock].	elementType == #methodArgument ifTrue:		[^ self withColor: #black emphasis: #normal do: aBlock].	elementType == #methodSelector ifTrue:		[^ self withColor: #black emphasis: #bold do: aBlock].	elementType == #blockArgument ifTrue:		[^ self withColor: #black emphasis: #normal do: aBlock].	elementType == #comment ifTrue:		[^ self withColor: #brown emphasis: #normal do: aBlock].	elementType == #variable ifTrue:		[^ self withColor: #black emphasis: #normal do: aBlock].	elementType == #literal	 ifTrue:		[^ self withColor: #blue emphasis: #normal do: aBlock].	elementType == #keyword ifTrue:		[^ self withColor: #darkGray emphasis: #bold do: aBlock].	elementType == #prefixKeyword ifTrue:		[^ self withColor: #veryDarkGray emphasis: #bold do: aBlock].	elementType == #setOrReturn ifTrue:		[^ self withColor: #black emphasis: #bold do: aBlock].	^ self withColor: #black emphasis: #normal do: aBlock! !!MessageNode methodsFor: 'macro transformations' stamp: 'di 6/11/2000 16:09'!noteSpecialSelector: selectorSymbol	" special > 0 denotes specially treated messages. "	"Deconvert initial keywords from SQ2K"	special _ #(:Test:Yes: :Test:No: :Test:Yes:No: :Test:No:Yes:				and: or:				:Until:do: :While:do: whileFalse whileTrue				:Repeat:to:do: :Repeat:to:by:do:				) indexOf: selectorSymbol.	special > 0 ifTrue: [^ self].	special _ MacroSelectors indexOf: selectorSymbol.! !!MessageNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:11'!printIfOn: aStream indent: level	aStream dialect = #SQ00 ifTrue:		["Convert to if-then-else"		(arguments last isJust: NodeNil) ifTrue:			[aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].			self printParenReceiver: receiver on: aStream indent: level + 1.			^ self printKeywords: #Yes: arguments: (Array with: arguments first)						on: aStream indent: level prefix: true].		(arguments last isJust: NodeFalse) ifTrue:			[self printReceiver: receiver on: aStream indent: level.			^ self printKeywords: #and: arguments: (Array with: arguments first)						on: aStream indent: level].		(arguments first isJust: NodeNil) ifTrue:			[aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].			self printParenReceiver: receiver on: aStream indent: level + 1.			^ self printKeywords: #No: arguments: (Array with: arguments last)						on: aStream indent: level prefix: true].		(arguments first isJust: NodeTrue) ifTrue:			[self printReceiver: receiver on: aStream indent: level.			^ self printKeywords: #or: arguments: (Array with: arguments last)						on: aStream indent: level].		aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].		self printParenReceiver: receiver on: aStream indent: level + 1.		^ self printKeywords: #Yes:No: arguments: arguments						on: aStream indent: level prefix: true].	receiver printOn: aStream indent: level + 1 precedence: precedence.	(arguments last isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifTrue: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments last isJust: NodeFalse) ifTrue:		[^ self printKeywords: #and: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments first isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifFalse: arguments: (Array with: arguments last)					on: aStream indent: level].	(arguments first isJust: NodeTrue) ifTrue:		[^ self printKeywords: #or: arguments: (Array with: arguments last)					on: aStream indent: level].	self printKeywords: #ifTrue:ifFalse: arguments: arguments					on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:08'!printKeywords: key arguments: args on: aStream indent: level	^ self printKeywords: key arguments: args on: aStream indent: level prefix: false! !!MessageNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:07'!printKeywords: key arguments: args on: aStream indent: level prefix: isPrefix	| keywords indent noColons arg kwd hasBrackets doCrTab |	args size = 0 ifTrue: [aStream space; nextPutAll: key. ^ self].	keywords _ key keywords.	noColons _ aStream dialect = #SQ00 and: [keywords first endsWith: ':'].	doCrTab _ args size > 2 or:		[{receiver} , args			inject: false			into: [:was :thisArg |				was or: [(thisArg isKindOf: BlockNode)					or: [(thisArg isKindOf: MessageNode) and: [thisArg precedence >= 3]]]]].	1 to: (args size min: keywords size) do:		[:i | arg _ args at: i.  kwd _ keywords at: i.		doCrTab			ifTrue: [aStream crtab: level+1. indent _ 1] "newline after big args"			ifFalse: [aStream space. indent _ 0].		noColons			ifTrue: [aStream withStyleFor: (isPrefix ifTrue: [#prefixKeyword] ifFalse: [#keyword])						do: [aStream nextPutAll: kwd allButLast; space].					hasBrackets _ (arg isKindOf: BlockNode) or: [arg isKindOf: BlockNode].					hasBrackets ifFalse: [aStream nextPutAll: '(']]			ifFalse: [aStream nextPutAll: kwd; space].		arg printOn: aStream indent: level + 1 + indent			 	precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).		noColons			ifTrue: [hasBrackets ifFalse: [aStream nextPutAll: ')']]]! !!MessageNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:09'!printOn: aStream indent: level	| printer leadingKeyword |	special > 0 ifTrue: [printer _ MacroPrinters at: special].	(special > 0)		ifTrue: [self perform: printer with: aStream with: level]		ifFalse: [selector key first = $:				ifTrue: [leadingKeyword _ selector key keywords first.						aStream nextPutAll: leadingKeyword; space.						self printReceiver: receiver on: aStream indent: level.						self printKeywords: (selector key allButFirst: leadingKeyword size + 1) arguments: arguments							on: aStream indent: level]				ifFalse: [(aStream dialect = #SQ00 and: [selector key == #do:])						ifTrue: ["Add prefix keyword"								aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Repeat '].								self printParenReceiver: receiver on: aStream indent: level + 1.								self printKeywords: selector key arguments: arguments									on: aStream indent: level prefix: true]						ifFalse: [self printReceiver: receiver on: aStream indent: level.								self printKeywords: selector key arguments: arguments									on: aStream indent: level]]]! !!MessageNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:12'!printToDoOn: aStream indent: level	| limitNode |	aStream dialect = #SQ00		ifTrue: ["Add prefix keyword"				aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Repeat '].				self printParenReceiver: receiver on: aStream indent: level + 1]		ifFalse: [self printReceiver: receiver on: aStream indent: level].	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode _ arguments first]		ifFalse: [limitNode _ arguments last value].	(selector key = #to:by:do:			and: [(arguments at: 2) isConstantNumber				and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level prefix: true]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level prefix: true]! !!MessageNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:12'!printWhileOn: aStream indent: level	aStream dialect = #SQ00		ifTrue: ["Add prefix keyword"				aStream withStyleFor: #prefixKeyword						do: [aStream nextPutAll: (selector key == #whileTrue:									ifTrue: ['While '] ifFalse: ['Until '])].				self printParenReceiver: receiver on: aStream indent: level + 1.				self printKeywords: #do: arguments: arguments					on: aStream indent: level prefix: true]		ifFalse: [self printReceiver: receiver on: aStream indent: level.				(arguments first isJust: NodeNil) ifTrue:						[selector _ SelectorNode new								key: (selector key == #whileTrue:									ifTrue: [#whileTrue] ifFalse: [#whileFalse])								code: #macro.						arguments _ Array new].				self printKeywords: selector key arguments: arguments					on: aStream indent: level]! !!MethodNode methodsFor: 'printing' stamp: 'di 6/13/2000 00:46'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream dialect = #SQ00					ifTrue: [(kwd endsWith: ':')							ifTrue: [aStream withStyleFor: #methodSelector									do: [aStream nextPutAll: kwd allButLast].									aStream nextPutAll: ' (']							ifFalse: [aStream withStyleFor: #methodSelector									do: [aStream nextPutAll: kwd].									aStream space]]					ifFalse: [aStream nextPutAll: kwd; space].				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				(aStream dialect = #SQ00 and: [kwd endsWith: ':'])					ifTrue: [aStream nextPutAll: ') ']					ifFalse: [aStream space]]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream dialect = #SQ00				ifTrue: [aStream withStyleFor: #setOrReturn do: [aStream nextPutAll: 'Use']]				ifFalse: [aStream nextPutAll: '|'].			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | aStream space; nextPutAll: temp key]].			aStream dialect = #SQ00				ifTrue: [aStream nextPutAll: '.']				ifFalse: [aStream nextPutAll: ' |']].	primitive > 0 ifTrue:			[(primitive between: 255 and: 519) ifFalse:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!ReturnNode methodsFor: 'printing' stamp: 'di 6/11/2000 15:28'!printOn: aStream indent: level	aStream dialect = #SQ00		ifTrue: ["Add prefix keyword"				aStream withStyleFor: #setOrReturn do: [aStream nextPutAll: 'Answer '].				expr printOn: aStream indent: level]		ifFalse: [aStream nextPutAll: '^ '.				expr printOn: aStream indent: level].	expr printCommentOn: aStream indent: level.! !