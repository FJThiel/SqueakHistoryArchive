'From Squeak2.6 of 13 October 1999 [latest update: #1748] on 2 January 2000 at 3:36:27 pm'!"Change Set:		LZ77Date:			2 January 2000Author:			Andreas RaabAdds LZ77 based compression (e.g. PKZip/GZip) to Squeak. GZip compression is available from the FileList ('compress file') but will take a *long* time without the plugin support. The quality and speed of compression is similar to that of other compressors from the LZ77 family.Note: I have run a regression test on 83,210 files (11,583,048,046 bytes; every accessible file on my hard disk) to make sure compression works as expected.""Remove some old classes we don't need anymore"Smalltalk removeClassNamed:#InflatePlugin.Smalltalk removeClassNamed:#GZipStream.Smalltalk removeClassNamed:#ZLibStream."Add two new pools"Smalltalk at: #ZipConstants ifAbsentPut:[Dictionary new].Smalltalk at: #GZipConstants ifAbsentPut:[Dictionary new].!InterpreterPlugin subclass: #InflatePlugin	instanceVariableNames: 'zipCollection zipReadLimit zipPosition zipState zipBitBuf zipBitPos zipSource zipSourcePos zipSourceLimit zipLitTable zipDistTable zipCollectionSize zipLitTableSize zipDistTableSize '	classVariableNames: 'MaxBits StateNoMoreData '	poolDictionaries: ''	category: 'Squeak-Plugins'!InflatePlugin subclass: #DeflatePlugin	instanceVariableNames: 'zipHashHead zipHashTail zipHashValue zipBlockPos zipBlockStart zipLiterals zipDistances zipLiteralFreq zipDistanceFreq zipLiteralCount zipLiteralSize zipMatchCount zipMatchLengthCodes zipDistanceCodes zipCrcTable zipExtraLengthBits zipExtraDistanceBits zipBaseLength zipBaseDistance '	classVariableNames: 'DeflateHashBits DeflateHashMask DeflateHashShift DeflateHashTableSize DeflateMaxDistance DeflateMaxDistanceCodes DeflateMaxLiteralCodes DeflateMaxMatch DeflateMinMatch DeflateWindowMask DeflateWindowSize '	poolDictionaries: ''	category: 'Squeak-Plugins'!InflatePlugin class	instanceVariableNames: ''!DeflatePlugin class	instanceVariableNames: ''!WriteStream subclass: #DeflateStream	instanceVariableNames: 'hashHead hashTail hashValue blockPosition blockStart '	classVariableNames: ''	poolDictionaries: 'ZipConstants '	category: 'System-Compression'!DeflateStream class	instanceVariableNames: ''!DeflateStream subclass: #ZipWriteStream	instanceVariableNames: 'literals distances literalFreq distanceFreq litCount matchCount encoder '	classVariableNames: 'VerboseLevel '	poolDictionaries: 'ZipConstants '	category: 'System-Compression'!ZipWriteStream class	instanceVariableNames: ''!FastInflateStream subclass: #GZipReadStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'GZipConstants '	category: 'System-Compression'!GZipReadStream class	instanceVariableNames: ''!ZipWriteStream subclass: #GZipWriteStream	instanceVariableNames: 'crc crcPosition bytesWritten '	classVariableNames: 'CrcTable '	poolDictionaries: 'GZipConstants '	category: 'System-Compression'!GZipWriteStream class	instanceVariableNames: ''!FastInflateStream subclass: #ZLibReadStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compression'!ZipWriteStream subclass: #ZLibWriteStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compression'!WriteStream subclass: #ZipEncoder	instanceVariableNames: 'bitBuffer bitPosition encodedStream '	classVariableNames: ''	poolDictionaries: 'ZipConstants '	category: 'System-Compression'!Object subclass: #ZipEncoderNode	instanceVariableNames: 'value frequency height bitLength code parent left right '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compression'!ZipEncoderNode class	instanceVariableNames: ''!Object subclass: #ZipEncoderTree	instanceVariableNames: 'bitLengths codes maxCode '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compression'!ZipEncoderTree class	instanceVariableNames: ''!!FileList methodsFor: 'file list menu' stamp: 'ar 1/2/2000 15:30'!compressFile	"Compress the currently selected file"	| zipped buffer unzipped |	unzipped _ directory readOnlyFileNamed: self fullName.	unzipped binary.	zipped _ directory newFileNamed: (fileName, FileDirectory dot, 'gz').	zipped binary.	zipped _ GZipWriteStream on: zipped.	buffer _ ByteArray new: 50000.	'Compressing ', self fullName displayProgressAt: Sensor cursorPoint		from: 0 to: unzipped size		during:[:bar|			[unzipped atEnd] whileFalse:[				bar value: unzipped position.				zipped nextPutAll: (unzipped nextInto: buffer)].			zipped close.			unzipped close].	self updateFileList! !!FileList methodsFor: 'file list menu' stamp: 'ar 1/2/2000 15:30'!itemsForAnyFile	^ #(('copy name to clipboard' 'rename' 'delete' 'compress')		()		(copyName renameFile deleteFile compressFile)		)! !!FileList methodsFor: 'file list menu' stamp: 'ar 1/2/2000 15:31'!saveGZipContents	"Save the contents of a gzipped file"	| zipped buffer unzipped |	unzipped _ directory newFileNamed: 		(fileName copyUpToLast: FileDirectory extensionDelimiter).	zipped _ GZipReadStream on: 		(directory readOnlyFileNamed: self fullName).	buffer _ String new: 50000.	'Extracting ', self fullName displayProgressAt: Sensor cursorPoint		from: 0 to: zipped sourceStream size		during:[:bar|			[zipped atEnd] whileFalse:[				bar value: zipped sourceStream position.				unzipped nextPutAll: (zipped nextInto: buffer)].			zipped close.			unzipped close].	self updateFileList! !!FileList methodsFor: 'file list menu' stamp: 'ar 1/2/2000 15:31'!viewGZipContents	"View the contents of a gzipped file"	| f |	f _ (directory readOnlyFileNamed: self fullName).	contents _ f contentsOfEntireFile.	Cursor wait showWhile:[contents _ (GZipReadStream on: contents) upToEnd].	contents replaceAll: Character lf with: Character cr.	(StringHolder new)		contents: contents;		openLabel:'Contents of ', fileName printString! !!InflatePlugin commentStamp: '<historical>' prior: 0!This plugin implements the one crucial function for efficiently decompressing streams.!!InflatePlugin methodsFor: 'primitives' stamp: 'ar 12/22/1999 00:04'!primitiveInflateDecompressBlock	"Primitive. Inflate a single block."	| oop rcvr |	self export: true.	interpreterProxy methodArgumentCount = 2 ifFalse:[^interpreterProxy primitiveFail].	"distance table"	oop _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: oop)		ifFalse:[^interpreterProxy primitiveFail].	zipDistTable _ interpreterProxy firstIndexableField: oop.	zipDistTableSize _ interpreterProxy slotSizeOf: oop.	"literal table"	oop _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: oop)		ifFalse:[^interpreterProxy primitiveFail].	zipLitTable _ interpreterProxy firstIndexableField: oop.	zipLitTableSize _ interpreterProxy slotSizeOf: oop.	"Receiver (InflateStream)"	rcvr _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isPointers: rcvr)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: rcvr) < 9		ifTrue:[^interpreterProxy primitiveFail].	"All the integer instvars"	zipReadLimit _ interpreterProxy fetchInteger: 2 ofObject: rcvr.	zipState _ interpreterProxy fetchInteger: 3 ofObject: rcvr.	zipBitBuf _ interpreterProxy fetchInteger: 4 ofObject: rcvr.	zipBitPos _ interpreterProxy fetchInteger: 5 ofObject: rcvr.	zipSourcePos _ interpreterProxy fetchInteger: 7 ofObject: rcvr.	zipSourceLimit _ interpreterProxy fetchInteger: 8 ofObject: rcvr.	interpreterProxy failed ifTrue:[^nil].	zipReadLimit _ zipReadLimit - 1.	zipSourcePos _ zipSourcePos - 1.	zipSourceLimit _ zipSourceLimit - 1.	"collection"	oop _ interpreterProxy fetchPointer: 0 ofObject: rcvr.	(interpreterProxy isIntegerObject: oop)		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy isBytes: oop)		ifFalse:[^interpreterProxy primitiveFail].	zipCollection _ interpreterProxy firstIndexableField: oop.	zipCollectionSize _ interpreterProxy byteSizeOf: oop.	"source"	oop _ interpreterProxy fetchPointer: 6 ofObject: rcvr.	(interpreterProxy isIntegerObject: oop)		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy isBytes: oop)		ifFalse:[^interpreterProxy primitiveFail].	zipSource _ interpreterProxy firstIndexableField: oop.	"do the primitive"	self zipDecompressBlock.	interpreterProxy failed ifFalse:[		"store modified values back"		interpreterProxy storeInteger: 2 ofObject: rcvr withValue: zipReadLimit + 1.		interpreterProxy storeInteger: 3 ofObject: rcvr withValue: zipState.		interpreterProxy storeInteger: 4 ofObject: rcvr withValue: zipBitBuf.		interpreterProxy storeInteger: 5 ofObject: rcvr withValue: zipBitPos.		interpreterProxy storeInteger: 7 ofObject: rcvr withValue: zipSourcePos + 1.		interpreterProxy pop: 2.	].! !!InflatePlugin methodsFor: 'inflating' stamp: 'ar 12/22/1999 15:14'!zipDecodeValueFrom: table size: tableSize	"Decode the next value in the receiver using the given huffman table."	| bits bitsNeeded tableIndex value index |	self var: #table declareC:'unsigned int *table'.	bitsNeeded _ (table at: 0) bitShift: -24.	"Initial bits needed"	bitsNeeded > MaxBits ifTrue:[interpreterProxy primitiveFail. ^0].	tableIndex _ 2.							"First real table"	[true] whileTrue:[		bits _ self zipNextBits: bitsNeeded.		"Get bits"		index _ tableIndex + bits - 1.		index >= tableSize ifTrue:[interpreterProxy primitiveFail. ^0].		value _ table at: index.					"Lookup entry in table"		(value bitAnd: 16r3F000000) = 0 ifTrue:[^value]. "Check if it is a leaf node"		"Fetch sub table"		tableIndex _ value bitAnd: 16rFFFF.	"Table offset in low 16 bit"		bitsNeeded _ (value bitShift: -24) bitAnd: 255. "Additional bits in high 8 bit"		bitsNeeded > MaxBits ifTrue:[interpreterProxy primitiveFail. ^0]].	^0! !!InflatePlugin methodsFor: 'inflating' stamp: 'ar 12/22/1999 00:04'!zipDecompressBlock	| value extra length distance oldPos oldBits oldBitPos dstPos srcPos max |	self inline: false.	max _ zipCollectionSize - 1.	[zipReadLimit < max and:[zipSourcePos <= zipSourceLimit]] whileTrue:[		"Back up stuff if we're running out of space"		oldBits _ zipBitBuf.		oldBitPos _ zipBitPos.		oldPos _ zipSourcePos.		value _ self zipDecodeValueFrom: zipLitTable size: zipLitTableSize.		value < 256 ifTrue:[ "A literal"			zipCollection at: (zipReadLimit _ zipReadLimit + 1) put: value.		] ifFalse:["length/distance or end of block"			value = 256 ifTrue:["End of block"				zipState _ zipState bitAnd: StateNoMoreData.				^0].			"Compute the actual length value (including possible extra bits)"			extra _ (value bitShift: -16) - 1.			length _ value bitAnd: 16rFFFF.			extra > 0 ifTrue:[length _ length + (self zipNextBits: extra)].			"Compute the distance value"			value _ self zipDecodeValueFrom: zipDistTable size: zipDistTableSize.			extra _ (value bitShift: -16).			distance _ value bitAnd: 16rFFFF.			extra > 0 ifTrue:[distance _ distance + (self zipNextBits: extra)].			(zipReadLimit + length >= max) ifTrue:[				zipBitBuf _ oldBits.				zipBitPos _ oldBitPos.				zipSourcePos _ oldPos.				^0].			dstPos _ zipReadLimit.			srcPos _ zipReadLimit - distance.			1 to: length do:[:i|				zipCollection at: dstPos+i put: (zipCollection at: srcPos+i)].			zipReadLimit _ zipReadLimit + length.		].	].! !!InflatePlugin methodsFor: 'inflating' stamp: 'ar 12/21/1999 23:06'!zipNextBits: n	| bits byte |	self inline: true.	[zipBitPos < n] whileTrue:[		byte _ zipSource at: (zipSourcePos _ zipSourcePos + 1).		zipBitBuf _ zipBitBuf + (byte << zipBitPos).		zipBitPos _ zipBitPos + 8].	bits _ zipBitBuf bitAnd: (1 << n)-1.	zipBitBuf _ zipBitBuf >> n.	zipBitPos _ zipBitPos - n.	^bits! !!DeflatePlugin methodsFor: 'primitives' stamp: 'ar 12/29/1999 22:21'!primitiveDeflateBlock	"Primitive. Deflate the current contents of the receiver."	| goodMatch chainLength lastIndex rcvr result |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 3		ifFalse:[^interpreterProxy primitiveFail].	goodMatch _ interpreterProxy stackIntegerValue: 0.	chainLength _ interpreterProxy stackIntegerValue: 1.	lastIndex _ interpreterProxy stackIntegerValue: 2.	rcvr _ interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	self cCode:'' inSmalltalk:[		zipMatchLengthCodes _ CArrayAccessor on: ZipWriteStream matchLengthCodes.		zipDistanceCodes _ CArrayAccessor on: ZipWriteStream distanceCodes].	(self loadDeflateStreamFrom: rcvr)		ifFalse:[^interpreterProxy primitiveFail].	result _ self deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch.	interpreterProxy failed ifFalse:[		"Store back modified values"		interpreterProxy storeInteger: 6 ofObject: rcvr withValue: zipHashValue.		interpreterProxy storeInteger: 7 ofObject: rcvr withValue: zipBlockPos.		interpreterProxy storeInteger: 13 ofObject: rcvr withValue: zipLiteralCount.		interpreterProxy storeInteger: 14 ofObject: rcvr withValue: zipMatchCount].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 4.		interpreterProxy pushBool: result.	].! !!DeflatePlugin methodsFor: 'primitives' stamp: 'ar 12/27/1999 20:42'!primitiveDeflateUpdateHashTable	"Primitive. Update the hash tables after data has been moved by delta."	| delta table tableSize tablePtr entry |	self export: true.	self var: #tablePtr declareC:'int *tablePtr'.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	delta _ interpreterProxy stackIntegerValue: 0.	table _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: table)		ifFalse:[^interpreterProxy primitiveFail].	tableSize _ interpreterProxy slotSizeOf: table.	tablePtr _ interpreterProxy firstIndexableField: table.	0 to: tableSize-1 do:[:i|		entry _ tablePtr at: i.		entry >= delta			ifTrue:[tablePtr at: i put: entry - delta]			ifFalse:[tablePtr at: i put: 0]].	interpreterProxy pop: 2. "Leave rcvr on stack"! !!DeflatePlugin methodsFor: 'primitives' stamp: 'ar 12/30/1999 14:38'!primitiveUpdateGZipCrc32	"Primitive. Update a 32bit CRC value."	| collection stopIndex startIndex crc length bytePtr |	self export: true.	self var: #crc declareC:'unsigned int crc'.	self var: #bytePtr declareC:'unsigned char *bytePtr'.	self var: #crcTable declareC:'unsigned int *crcTable'.	interpreterProxy methodArgumentCount = 4		ifFalse:[^interpreterProxy primitiveFail].	collection _ interpreterProxy stackObjectValue: 0.	stopIndex _ interpreterProxy stackIntegerValue: 1.	startIndex _ interpreterProxy stackIntegerValue: 2.	crc _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 3).	interpreterProxy failed ifTrue:[^0].	((interpreterProxy isBytes: collection) and:[stopIndex >= startIndex and:[startIndex > 0]])		ifFalse:[^interpreterProxy primitiveFail].	length _ interpreterProxy byteSizeOf: collection.	(stopIndex <= length) ifFalse:[^interpreterProxy primitiveFail].	bytePtr _ interpreterProxy firstIndexableField: collection.	self cCode:'' inSmalltalk:[zipCrcTable _ CArrayAccessor on: GZipWriteStream crcTable].	startIndex _ startIndex - 1.	stopIndex _ stopIndex - 1.	startIndex to: stopIndex do:[:i|		crc _ (zipCrcTable at: ((crc bitXor: (bytePtr at: i)) bitAnd: 255)) bitXor: (crc >> 8).	].	interpreterProxy pop: 5. "args + rcvr"	interpreterProxy push: (interpreterProxy positive32BitIntegerFor: crc).! !!DeflatePlugin methodsFor: 'primitives' stamp: 'ar 12/30/1999 15:54'!primitiveZipSendBlock	| distTree litTree distStream litStream rcvr result |	self export: true.	interpreterProxy methodArgumentCount = 4 		ifFalse:[^interpreterProxy primitiveFail].	distTree _ interpreterProxy stackObjectValue: 0.	litTree _ interpreterProxy stackObjectValue: 1.	distStream _ interpreterProxy stackObjectValue: 2.	litStream _ interpreterProxy stackObjectValue: 3.	rcvr _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self loadZipEncoderFrom: rcvr)		ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: distTree) and:[		(interpreterProxy slotSizeOf: distTree) >= 2])			ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: litTree) and:[		(interpreterProxy slotSizeOf: litTree) >= 2])			ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: litStream) and:[		(interpreterProxy slotSizeOf: litStream) >= 3])			ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isPointers: distStream) and:[		(interpreterProxy slotSizeOf: distStream) >= 3])			ifFalse:[^interpreterProxy primitiveFail].	self cCode:'' inSmalltalk:[		zipMatchLengthCodes _ CArrayAccessor on: ZipWriteStream matchLengthCodes.		zipDistanceCodes _ CArrayAccessor on: ZipWriteStream distanceCodes.		zipExtraLengthBits _ CArrayAccessor on: ZipWriteStream extraLengthBits.		zipExtraDistanceBits _ CArrayAccessor on: ZipWriteStream extraDistanceBits.		zipBaseLength _ CArrayAccessor on: ZipWriteStream baseLength.		zipBaseDistance _ CArrayAccessor on: ZipWriteStream baseDistance].	result _ self sendBlock: litStream with: distStream with: litTree with: distTree.	interpreterProxy failed ifFalse:[		interpreterProxy storeInteger: 1 ofObject: rcvr withValue: zipPosition.		interpreterProxy storeInteger: 4 ofObject: rcvr withValue: zipBitBuf.		interpreterProxy storeInteger: 5 ofObject: rcvr withValue: zipBitPos.	].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 5. "rcvr + args"		interpreterProxy pushInteger: result.	].! !!DeflatePlugin methodsFor: 'deflating' stamp: 'ar 12/29/1999 21:59'!compare: here with: matchPos min: minLength	"Compare the two strings and return the length of matching characters.	minLength is a lower bound for match lengths that will be accepted.	Note: here and matchPos are zero based."	| length |	self inline: true.	"First test if we can actually get longer than minLength"	(zipCollection at: here+minLength) = (zipCollection at: matchPos+minLength)		ifFalse:[^0].	(zipCollection at: here+minLength-1) = (zipCollection at: matchPos+minLength-1)		ifFalse:[^0].	"Then test if we have an initial match at all"	(zipCollection at: here) = (zipCollection at: matchPos)		ifFalse:[^0].	(zipCollection at: here+1) = (zipCollection at: matchPos+1)		ifFalse:[^1].	"Finally do the real comparison"	length _ 2.	[length < DeflateMaxMatch and:[		(zipCollection at: here+length) = (zipCollection at: matchPos+length)]]			whileTrue:[length _ length + 1].	^length! !!DeflatePlugin methodsFor: 'deflating' stamp: 'ar 12/29/1999 22:00'!deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch	"Continue deflating the receiver's collection from blockPosition to lastIndex.	Note that lastIndex must be at least MaxMatch away from the end of collection"	| here matchResult flushNeeded hereMatch hereLength newMatch newLength hasMatch |	self inline: false.	zipBlockPos > lastIndex ifTrue:[^false]. "Nothing to deflate"	zipLiteralCount >= zipLiteralSize ifTrue:[^true].	hasMatch _ false.	here _ zipBlockPos.	[here <= lastIndex] whileTrue:[		hasMatch ifFalse:[			"Find the first match"			matchResult _ self findMatch: here								lastLength: DeflateMinMatch-1								lastMatch: here								chainLength: chainLength								goodMatch: goodMatch.			self insertStringAt: here. "update hash table"			hereMatch _ matchResult bitAnd: 16rFFFF.			hereLength _ matchResult bitShift: -16].		"Look ahead if there is a better match at the next position"		matchResult _ self findMatch: here+1							lastLength: hereLength							lastMatch: hereMatch							chainLength: chainLength							goodMatch: goodMatch.		newMatch _ matchResult bitAnd: 16rFFFF.		newLength _ matchResult bitShift: -16.		"Now check if the next match is better than the current one.		If not, output the current match (provided that the current match		is at least MinMatch long)"		(hereLength >= newLength and:[hereLength >= DeflateMinMatch]) ifTrue:[			"Encode the current match"			flushNeeded _ self				encodeMatch: hereLength				distance: here - hereMatch.			"Insert all strings up to the end of the current match.			Note: The first string has already been inserted."			1 to: hereLength-1 do:[:i| self insertStringAt: (here _ here + 1)].			hasMatch _ false.			here _ here + 1.		] ifFalse:[			"Either the next match is better than the current one or we didn't			have a good match after all (e.g., current match length < MinMatch).			Output a single literal."			flushNeeded _ self encodeLiteral: (zipCollection at: here).			here _ here + 1.			(here <= lastIndex and:[flushNeeded not]) ifTrue:[				"Cache the results for the next round"				self insertStringAt: here.				hasMatch _ true.				hereMatch _ newMatch.				hereLength _ newLength].		].		flushNeeded ifTrue:[zipBlockPos _ here. ^true].	].	zipBlockPos _ here.	^false! !!DeflatePlugin methodsFor: 'deflating' stamp: 'ar 12/29/1999 22:00'!findMatch: here lastLength: lastLength lastMatch: lastMatch chainLength: maxChainLength goodMatch: goodMatch	"Find the longest match for the string starting at here.	If there is no match longer than lastLength return lastMatch/lastLength.	Traverse at most maxChainLength entries in the hash table.	Stop if a match of at least goodMatch size has been found."	| matchResult matchPos distance chainLength limit bestLength length |	self inline: false.	"Compute the default match result"	matchResult _ (lastLength bitShift: 16) bitOr: lastMatch.	"There is no way to find a better match than MaxMatch"	lastLength >= DeflateMaxMatch ifTrue:[^matchResult].	"Start position for searches"	matchPos _ zipHashHead at: (self updateHashAt: here + DeflateMinMatch - 1).	"Compute the distance to the (possible) match"	distance _ here - matchPos.	"Note: It is required that 0 < distance < MaxDistance"	(distance > 0 and:[distance < DeflateMaxDistance]) ifFalse:[^matchResult].	chainLength _ maxChainLength.	"Max. nr of match chain to search"	here > DeflateMaxDistance	"Limit for matches that are too old"		ifTrue:[limit _ here - DeflateMaxDistance]		ifFalse:[limit _ 0].	"Best match length so far (current match must be larger to take effect)"	bestLength _ lastLength.	[true] whileTrue:[		"Compare the current string with the string at match position"		length _ self compare: here with: matchPos min: bestLength.		"Truncate accidental matches beyound stream position"		(here + length > zipPosition) ifTrue:[length _ zipPosition - here].		"Ignore very small matches if they are too far away"		(length = DeflateMinMatch and:[(here - matchPos) > (DeflateMaxDistance // 4)])			ifTrue:[length _ DeflateMinMatch - 1].		length > bestLength ifTrue:["We have a new (better) match than before"			"Compute the new match result"			matchResult _ (length bitShift: 16) bitOr: matchPos.			bestLength _ length.			"There is no way to find a better match than MaxMatch"			bestLength >= DeflateMaxMatch ifTrue:[^matchResult].			"But we may have a good, fast match"			bestLength > goodMatch ifTrue:[^matchResult].		].		(chainLength _ chainLength - 1) > 0 ifFalse:[^matchResult].		"Compare with previous entry in hash chain"		matchPos _ zipHashTail at: (matchPos bitAnd: DeflateWindowMask).		matchPos <= limit ifTrue:[^matchResult]. "Match position is too old"	].! !!DeflatePlugin methodsFor: 'deflating' stamp: 'ar 12/29/1999 21:59'!insertStringAt: here	"Insert the string at the given start position into the hash table.	Note: The hash value is updated starting at MinMatch-1 since	all strings before have already been inserted into the hash table	(and the hash value is updated as well)."	| prevEntry |	self inline: true.	zipHashValue _ self updateHashAt: (here + DeflateMinMatch - 1).	prevEntry _ zipHashHead at: zipHashValue.	zipHashHead at: zipHashValue put: here.	zipHashTail at: (here bitAnd: DeflateWindowMask) put: prevEntry.! !!DeflatePlugin methodsFor: 'deflating' stamp: 'ar 12/29/1999 20:28'!updateHash: nextValue	"Update the running hash value based on the next input byte.	Return the new updated hash value."	^((zipHashValue bitShift: DeflateHashShift) bitXor: nextValue) bitAnd: DeflateHashMask.! !!DeflatePlugin methodsFor: 'deflating' stamp: 'ar 12/29/1999 20:29'!updateHashAt: here	"Update the hash value at position here (one based)"	^self updateHash: (zipCollection at: here)! !!DeflatePlugin methodsFor: 'encoding' stamp: 'ar 12/29/1999 20:37'!encodeLiteral: lit	"Encode the given literal"	self inline: true.	zipLiterals at: zipLiteralCount put: lit.	zipDistances at: zipLiteralCount put: 0.	zipLiteralFreq at: lit put: (zipLiteralFreq at: lit) + 1.	zipLiteralCount _ zipLiteralCount + 1.	^zipLiteralCount = zipLiteralSize "We *must* flush"		or:[(zipLiteralCount bitAnd: 16rFFF) = 0 "Only check every N kbytes"			and:[self shouldFlush]]! !!DeflatePlugin methodsFor: 'encoding' stamp: 'ar 12/29/1999 20:37'!encodeMatch: length distance: dist	"Encode the given match of length length starting at dist bytes ahead"	| literal distance |	self inline: true.	zipLiterals at: zipLiteralCount put: length - DeflateMinMatch.	zipDistances at: zipLiteralCount put: dist.	literal _ (zipMatchLengthCodes at: length - DeflateMinMatch).	zipLiteralFreq at: literal put: (zipLiteralFreq at: literal) + 1.	dist < 257		ifTrue:[distance _ zipDistanceCodes at: dist - 1]		ifFalse:[distance _ zipDistanceCodes at: 256 + (dist - 1 bitShift: -7)].	zipDistanceFreq at: distance put: (zipDistanceFreq at: distance) + 1.	zipLiteralCount _ zipLiteralCount + 1.	zipMatchCount _ zipMatchCount + 1.	^zipLiteralCount = zipLiteralSize "We *must* flush"		or:[(zipLiteralCount bitAnd: 16rFFF) = 0 "Only check every N kbytes"			and:[self shouldFlush]]! !!DeflatePlugin methodsFor: 'encoding' stamp: 'ar 12/30/1999 15:26'!nextZipBits: nBits put: value	"Require:		zipCollection, zipCollectionSize, zipPosition,		zipBitBuf, zipBitPos.	"	self inline: true.	(value >= 0 and:[(1 << nBits) > value])		ifFalse:[^interpreterProxy primitiveFail].	zipBitBuf _ zipBitBuf bitOr: (value bitShift: zipBitPos).	zipBitPos _ zipBitPos + nBits.	[zipBitPos >= 8 and:[zipPosition < zipCollectionSize]] whileTrue:[		zipCollection at: zipPosition put: (zipBitBuf bitAnd: 255).		zipPosition _ zipPosition + 1.		zipBitBuf _ zipBitBuf >> 8.		zipBitPos _ zipBitPos - 8].! !!DeflatePlugin methodsFor: 'encoding' stamp: 'ar 12/30/1999 18:15'!sendBlock: literalStream with: distanceStream with: litTree with: distTree	"Require: 		zipCollection, zipCollectionSize, zipPosition,		zipBitBuf, zipBitPos.	"	| oop litPos litLimit litArray distArray lit dist sum llBitLengths llCodes distBitLengths distCodes code extra litBlCount distBlCount |	self var: #litArray declareC:'unsigned char *litArray'.	self var: #distArray declareC:'unsigned int *distArray'.	self var: #llBitLengths declareC:'unsigned int *llBitLengths'.	self var: #llCodes declareC:'unsigned int *llCodes'.	self var: #distBitLengths declareC:'unsigned int *distBitLengths'.	self var: #distCodes declareC:'unsigned int *distCodes'.	oop _ interpreterProxy fetchPointer: 0 ofObject: literalStream.	litPos _ interpreterProxy fetchInteger: 1 ofObject: literalStream.	litLimit _ interpreterProxy fetchInteger: 2 ofObject: literalStream.	((interpreterProxy isIntegerObject: oop) not and:[litPos <= litLimit and:[		litLimit <= (interpreterProxy byteSizeOf: oop) and:[interpreterProxy isBytes: oop]]])			ifFalse:[^interpreterProxy primitiveFail].	litArray _ interpreterProxy firstIndexableField: oop.	oop _ interpreterProxy fetchPointer: 0 ofObject: distanceStream.	((interpreterProxy isIntegerObject: oop) not and:[		(interpreterProxy fetchInteger: 1 ofObject: distanceStream) = litPos and:[			(interpreterProxy fetchInteger: 2 ofObject: distanceStream) = litLimit]])				ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isWords: oop) and:[		litLimit <= (interpreterProxy slotSizeOf: oop)])			ifFalse:[^interpreterProxy primitiveFail].	distArray _ interpreterProxy firstIndexableField: oop.	oop _ interpreterProxy fetchPointer: 0 ofObject: litTree.	((interpreterProxy isIntegerObject: oop) not and:[interpreterProxy isWords: oop])		ifFalse:[^interpreterProxy primitiveFail].	litBlCount _ interpreterProxy slotSizeOf: oop.	llBitLengths _ interpreterProxy firstIndexableField: oop.	oop _ interpreterProxy fetchPointer: 1 ofObject: litTree.	((interpreterProxy isIntegerObject: oop) not and:[interpreterProxy isWords: oop])		ifFalse:[^interpreterProxy primitiveFail].	(litBlCount = (interpreterProxy slotSizeOf: oop))		ifFalse:[^interpreterProxy primitiveFail].	llCodes _ interpreterProxy firstIndexableField: oop.	oop _ interpreterProxy fetchPointer: 0 ofObject: distTree.	((interpreterProxy isIntegerObject: oop) not and:[interpreterProxy isWords: oop])		ifFalse:[^interpreterProxy primitiveFail].	distBlCount _ interpreterProxy slotSizeOf: oop.	distBitLengths _ interpreterProxy firstIndexableField: oop.	oop _ interpreterProxy fetchPointer: 1 ofObject: distTree.	((interpreterProxy isIntegerObject: oop) not and:[interpreterProxy isWords: oop])		ifFalse:[^interpreterProxy primitiveFail].	(distBlCount = (interpreterProxy slotSizeOf: oop))		ifFalse:[^interpreterProxy primitiveFail].	distCodes _ interpreterProxy firstIndexableField: oop.	interpreterProxy failed ifTrue:[^nil].	self nextZipBits: 0 put: 0. "Flush pending bits if necessary"	sum _ 0.	[litPos < litLimit and:[zipPosition + 4 < zipCollectionSize]] whileTrue:[		lit _ litArray at: litPos.		dist _ distArray at: litPos.		litPos _ litPos + 1.		dist = 0 ifTrue:["literal"			sum _ sum + 1.			lit < litBlCount ifFalse:[^interpreterProxy primitiveFail].			self nextZipBits: (llBitLengths at: lit) put: (llCodes at: lit).		] ifFalse:["match"			sum _ sum + lit + DeflateMinMatch.			lit < 256 ifFalse:[^interpreterProxy primitiveFail].			code _ zipMatchLengthCodes at: lit.			code < litBlCount ifFalse:[^interpreterProxy primitiveFail].			self nextZipBits: (llBitLengths at: code) put: (llCodes at: code).			extra _ zipExtraLengthBits at: code - 257.			extra = 0 ifFalse:[				lit _ lit - (zipBaseLength at: code - 257).				self nextZipBits: extra put: lit].			dist _ dist - 1.			dist < 16r8000 ifFalse:[^interpreterProxy primitiveFail].			dist < 256				ifTrue:[code _ zipDistanceCodes at: dist]				ifFalse:[code _ zipDistanceCodes at: 256 + (dist >> 7)].			code < distBlCount ifFalse:[^interpreterProxy primitiveFail].			self nextZipBits: (distBitLengths at: code) put: (distCodes at: code).			extra _ zipExtraDistanceBits at: code.			extra = 0 ifFalse:[				dist _ dist - (zipBaseDistance at: code).				self nextZipBits: extra put: dist].		].	].	interpreterProxy failed ifTrue:[^nil].	interpreterProxy storeInteger: 1 ofObject: literalStream withValue: litPos.	interpreterProxy storeInteger: 1 ofObject: distanceStream withValue: litPos.	^sum! !!DeflatePlugin methodsFor: 'encoding' stamp: 'ar 12/29/1999 22:00'!shouldFlush	"Check if we should flush the current block.	Flushing can be useful if the input characteristics change."	| nLits |	self inline: false.	zipLiteralCount = zipLiteralSize ifTrue:[^true]. "We *must* flush"	(zipLiteralCount bitAnd: 16rFFF) = 0 ifFalse:[^false]. "Only check every N kbytes"	zipMatchCount * 10 <= zipLiteralCount ifTrue:[		"This is basically random data. 		There is no need to flush early since the overhead		for encoding the trees will add to the overall size"		^false].	"Try to adapt to the input data.	We flush if the ratio between matches and literals	changes beyound a certain threshold"	nLits _ zipLiteralCount - zipMatchCount.	nLits <= zipMatchCount ifTrue:[^false]. "whow!! so many matches"	^nLits * 4 <= zipMatchCount! !!DeflatePlugin methodsFor: 'primitive support' stamp: 'ar 12/30/1999 15:28'!loadDeflateStreamFrom: rcvr	| oop |	self inline: false.	((interpreterProxy isPointers: rcvr) and:[		(interpreterProxy slotSizeOf: rcvr) >= 15]) ifFalse:[^false].	oop _ interpreterProxy fetchPointer: 0 ofObject: rcvr.	(interpreterProxy isIntegerObject: oop)		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy isBytes: oop)		ifFalse:[^interpreterProxy primitiveFail].	zipCollection _ interpreterProxy firstIndexableField: oop.	zipCollectionSize _ interpreterProxy byteSizeOf: oop.	zipPosition _ interpreterProxy fetchInteger: 1 ofObject: rcvr.	zipReadLimit _ interpreterProxy fetchInteger: 2 ofObject: rcvr.	"zipWriteLimit _ interpreterProxy fetchInteger: 3 ofObject: rcvr."	oop _ interpreterProxy fetchPointer: 4 ofObject: rcvr.	((interpreterProxy isIntegerObject: oop) or:[		(interpreterProxy isWords: oop) not]) ifTrue:[^false].	(interpreterProxy slotSizeOf: oop) = DeflateHashTableSize ifFalse:[^false].	zipHashHead _ interpreterProxy firstIndexableField: oop.	oop _ interpreterProxy fetchPointer: 5 ofObject: rcvr.	((interpreterProxy isIntegerObject: oop) or:[		(interpreterProxy isWords: oop) not]) ifTrue:[^false].	(interpreterProxy slotSizeOf: oop) = DeflateWindowSize ifFalse:[^false].	zipHashTail _ interpreterProxy firstIndexableField: oop.	zipHashValue _ interpreterProxy fetchInteger: 6 ofObject: rcvr.	zipBlockPos _ interpreterProxy fetchInteger: 7 ofObject: rcvr.	"zipBlockStart _ interpreterProxy fetchInteger: 8 ofObject: rcvr."	oop _ interpreterProxy fetchPointer: 9 ofObject: rcvr.	((interpreterProxy isIntegerObject: oop) or:[		(interpreterProxy isBytes: oop) not]) ifTrue:[^false].	zipLiteralSize _ interpreterProxy slotSizeOf: oop.	zipLiterals _ interpreterProxy firstIndexableField: oop.	oop _ interpreterProxy fetchPointer: 10 ofObject: rcvr.	((interpreterProxy isIntegerObject: oop) or:[		(interpreterProxy isWords: oop) not]) ifTrue:[^false].	(interpreterProxy slotSizeOf: oop) < zipLiteralSize ifTrue:[^false].	zipDistances _ interpreterProxy firstIndexableField: oop.	oop _ interpreterProxy fetchPointer: 11 ofObject: rcvr.	((interpreterProxy isIntegerObject: oop) or:[		(interpreterProxy isWords: oop) not]) ifTrue:[^false].	(interpreterProxy slotSizeOf: oop) = DeflateMaxLiteralCodes ifFalse:[^false].	zipLiteralFreq _ interpreterProxy firstIndexableField: oop.	oop _ interpreterProxy fetchPointer: 12 ofObject: rcvr.	((interpreterProxy isIntegerObject: oop) or:[		(interpreterProxy isWords: oop) not]) ifTrue:[^false].	(interpreterProxy slotSizeOf: oop) = DeflateMaxDistanceCodes ifFalse:[^false].	zipDistanceFreq _ interpreterProxy firstIndexableField: oop.	zipLiteralCount _ interpreterProxy fetchInteger: 13 ofObject: rcvr.	zipMatchCount _ interpreterProxy fetchInteger: 14 ofObject: rcvr.	^interpreterProxy failed not! !!DeflatePlugin methodsFor: 'primitive support' stamp: 'ar 12/30/1999 15:28'!loadZipEncoderFrom: rcvr	| oop |	self inline: false.	((interpreterProxy isPointers: rcvr) and:[		(interpreterProxy slotSizeOf: rcvr) >= 6]) ifFalse:[^false].	oop _ interpreterProxy fetchPointer: 0 ofObject: rcvr.	(interpreterProxy isIntegerObject: oop)		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy isBytes: oop)		ifFalse:[^interpreterProxy primitiveFail].	zipCollection _ interpreterProxy firstIndexableField: oop.	zipCollectionSize _ interpreterProxy byteSizeOf: oop.	zipPosition _ interpreterProxy fetchInteger: 1 ofObject: rcvr.	zipReadLimit _ interpreterProxy fetchInteger: 2 ofObject: rcvr.	"zipWriteLimit _ interpreterProxy fetchInteger: 3 ofObject: rcvr."	zipBitBuf _ interpreterProxy fetchInteger: 4 ofObject: rcvr.	zipBitPos _ interpreterProxy fetchInteger: 5 ofObject: rcvr.	^interpreterProxy failed not! !!InflatePlugin class methodsFor: 'class initialization' stamp: 'ar 12/21/1999 23:02'!initialize	"InflatePlugin initialize"	MaxBits _ 16.	StateNoMoreData _ 1.! !!InflatePlugin class methodsFor: 'translation' stamp: 'ar 12/22/1999 00:07'!declareCVarsIn: cg	cg var: 'zipCollection' declareC:'unsigned char *zipCollection'.	cg var: 'zipSource' declareC:'unsigned char *zipSource'.	cg var: 'zipLitTable' declareC:'unsigned int *zipLitTable'.	cg var: 'zipDistTable' declareC:'unsigned int *zipDistTable'.! !!DeflatePlugin class methodsFor: 'class initialization' stamp: 'ar 12/29/1999 20:54'!initialize	"DeflatePlugin initialize"	DeflateWindowSize _ 16r8000.	DeflateWindowMask _ DeflateWindowSize - 1.	DeflateMinMatch _ 3.	DeflateMaxMatch _ 258.	DeflateMaxDistance _ DeflateWindowSize.	DeflateHashBits _ 15.	DeflateHashTableSize _ 1 << DeflateHashBits.	DeflateHashMask _ DeflateHashTableSize - 1.	DeflateHashShift _ (DeflateHashBits + DeflateMinMatch - 1) // DeflateMinMatch.	DeflateMaxLiteralCodes _ ZipWriteStream maxLiteralCodes.	DeflateMaxDistanceCodes _ ZipWriteStream maxDistanceCodes.! !!DeflatePlugin class methodsFor: 'translation' stamp: 'ar 12/30/1999 18:27'!declareCVarsIn: cg	super declareCVarsIn: cg. "Required since we share some instVars"	cg var: 'zipHashHead' declareC:'unsigned int *zipHashHead'.	cg var: 'zipHashTail' declareC:'unsigned int *zipHashTail'.	cg var: 'zipLiterals' declareC:'unsigned char *zipLiterals'.	cg var: 'zipDistances' declareC:'unsigned int *zipDistances'.	cg var: 'zipLiteralFreq' declareC:'unsigned int *zipLiteralFreq'.	cg var: 'zipDistanceFreq' declareC:'unsigned int *zipDistanceFreq'.	cg var: 'zipMatchLengthCodes' declareC:		(String streamContents:[:s|			s nextPutAll:'unsigned int zipMatchLengthCodes[] = {'.			self printArray: ZipWriteStream matchLengthCodes on: s.			s nextPutAll:'}']).	cg var: 'zipDistanceCodes' declareC:		(String streamContents:[:s|			s nextPutAll:'unsigned int zipDistanceCodes[] = {'.			self printArray: ZipWriteStream distanceCodes on: s.			s nextPutAll:'}']).	cg var: 'zipCrcTable' declareC:		(String streamContents:[:s|			s nextPutAll:'unsigned int zipCrcTable[] = {'.			self printArray: GZipWriteStream crcTable on: s.			s nextPutAll:'}']).	cg var: 'zipExtraLengthBits' declareC:		(String streamContents:[:s|			s nextPutAll:'unsigned int zipExtraLengthBits[] = {'.			self printArray: ZipWriteStream extraLengthBits on: s.			s nextPutAll:'}']).	cg var: 'zipExtraDistanceBits' declareC:		(String streamContents:[:s|			s nextPutAll:'unsigned int zipExtraDistanceBits[] = {'.			self printArray: ZipWriteStream extraDistanceBits on: s.			s nextPutAll:'}']).	cg var: 'zipBaseLength' declareC:		(String streamContents:[:s|			s nextPutAll:'unsigned int zipBaseLength[] = {'.			self printArray: ZipWriteStream baseLength on: s.			s nextPutAll:'}']).	cg var: 'zipBaseDistance' declareC:		(String streamContents:[:s|			s nextPutAll:'unsigned int zipBaseDistance[] = {'.			self printArray: ZipWriteStream baseDistance on: s.			s nextPutAll:'}']).! !!DeflatePlugin class methodsFor: 'translation' stamp: 'ar 12/29/1999 22:27'!printArray: array on: aStream	| first |	first _ true.	1 to: array size do:[:i|		first 			ifTrue:[first _ false]			ifFalse:[aStream nextPutAll:', '].		i \\ 16 = 1 ifTrue:[aStream cr].		aStream print: (array at: i)].! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 1/2/2000 15:32'!next: anInteger putAll: aCollection	"Store the next anInteger elements from the given collection."	^self next: anInteger putAll: aCollection startingAt: 1! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 1/2/2000 15:32'!next: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	0 to: anInteger-1 do:[:i|		self nextPut: (aCollection at: startIndex + i).	].	^aCollection! !!PositionableStream methodsFor: 'converting' stamp: 'ar 1/2/2000 15:32'!asZLibReadStream	^ZLibReadStream on: collection from: position+1 to: readLimit! !!DeflateStream methodsFor: 'initialize-release' stamp: 'ar 12/29/1999 17:30'!flush	"Force compression"	self deflateBlock.! !!DeflateStream methodsFor: 'initialize-release' stamp: 'ar 12/31/1999 18:00'!initialize	blockStart _ nil.	blockPosition _ 0.	hashValue _ 0.	self initializeHashTables.! !!DeflateStream methodsFor: 'initialize-release' stamp: 'ar 12/29/1999 17:32'!initializeHashTables	hashHead _ WordArray new: 1 << HashBits.	hashTail _ WordArray new: WindowSize.! !!DeflateStream methodsFor: 'initialize-release' stamp: 'ar 12/29/1999 17:33'!on: aCollection	self initialize.	super on: (aCollection species new: WindowSize * 2).! !!DeflateStream methodsFor: 'initialize-release' stamp: 'ar 12/28/1999 17:34'!on: aCollection from: firstIndex to: lastIndex	"Not for DeflateStreams please"	^self shouldNotImplement! !!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:00'!goodMatchLength	"Return the length that is considered to be a 'good' match.	Higher values will result in better compression but take more time."	^MaxMatch "Best compression"! !!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:00'!hashChainLength	"Return the max. number of hash chains to traverse.	Higher values will result in better compression but take more time."	^4096 "Best compression"! !!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 17:33'!nextPutAll: aCollection	| start count max |	aCollection species = collection species		ifFalse:[			aCollection do:[:ch| self nextPut: ch].			^aCollection].	start _ 1.	count _ aCollection size.	[count = 0] whileFalse:[		position = writeLimit ifTrue:[self deflateBlock].		max _ writeLimit - position.		max > count ifTrue:[max _ count].		collection replaceFrom: position+1			to: position+max			with: aCollection			startingAt: start.		start _ start + max.		count _ count - max.		position _ position + max].	^aCollection! !!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/28/1999 17:35'!pastEndPut: anObject	self deflateBlock.	^self nextPut: anObject! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 20:24'!compare: here with: matchPos min: minLength	"Compare the two strings and return the length of matching characters.	minLength is a lower bound for match lengths that will be accepted.	Note: here and matchPos are zero based."	| length |	"First test if we can actually get longer than minLength"	(collection at: here+minLength+1) = (collection at: matchPos+minLength+1)		ifFalse:[^0].	(collection at: here+minLength) = (collection at: matchPos+minLength)		ifFalse:[^0].	"Then test if we have an initial match at all"	(collection at: here+1) = (collection at: matchPos+1)		ifFalse:[^0].	(collection at: here+2) = (collection at: matchPos+2)		ifFalse:[^1].	"Finally do the real comparison"	length _ 3.	[length <= MaxMatch and:[		(collection at: here+length) = (collection at: matchPos+length)]]			whileTrue:[length _ length + 1].	^length - 1! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/31/1999 18:00'!deflateBlock	"Deflate the current contents of the stream"	| flushNeeded lastIndex |	(blockStart == nil) ifTrue:[		"One time initialization for the first block"		1 to: MinMatch-1 do:[:i| self updateHashAt: i].		blockStart _ 0].	[blockPosition < position] whileTrue:[		(position + MaxMatch > writeLimit)			ifTrue:[lastIndex _ writeLimit - MaxMatch]			ifFalse:[lastIndex _ position].		flushNeeded _ self deflateBlock: lastIndex-1							chainLength: self hashChainLength							goodMatch: self goodMatchLength.		flushNeeded ifTrue:[			self flushBlock.			blockStart _ blockPosition].		"Make room for more data"		self moveContentsToFront].! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 18:05'!deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch	"Continue deflating the receiver's collection from blockPosition to lastIndex.	Note that lastIndex must be at least MaxMatch away from the end of collection"	| here matchResult flushNeeded hereMatch hereLength newMatch newLength hasMatch |	blockPosition > lastIndex ifTrue:[^false]. "Nothing to deflate"	hasMatch _ false.	here _ blockPosition.	[here <= lastIndex] whileTrue:[		hasMatch ifFalse:[			"Find the first match"			matchResult _ self findMatch: here								lastLength: MinMatch-1								lastMatch: here								chainLength: chainLength								goodMatch: goodMatch.			self insertStringAt: here. "update hash table"			hereMatch _ matchResult bitAnd: 16rFFFF.			hereLength _ matchResult bitShift: -16].		"Look ahead if there is a better match at the next position"		matchResult _ self findMatch: here+1							lastLength: hereLength							lastMatch: hereMatch							chainLength: chainLength							goodMatch: goodMatch.		newMatch _ matchResult bitAnd: 16rFFFF.		newLength _ matchResult bitShift: -16.		"Now check if the next match is better than the current one.		If not, output the current match (provided that the current match		is at least MinMatch long)"		(hereLength >= newLength and:[hereLength >= MinMatch]) ifTrue:[			self assert:[self validateMatchAt: here							from: hereMatch to: hereMatch + hereLength - 1].			"Encode the current match"			flushNeeded _ self				encodeMatch: hereLength				distance: here - hereMatch.			"Insert all strings up to the end of the current match.			Note: The first string has already been inserted."			1 to: hereLength-1 do:[:i| self insertStringAt: (here _ here + 1)].			hasMatch _ false.			here _ here + 1.		] ifFalse:[			"Either the next match is better than the current one or we didn't			have a good match after all (e.g., current match length < MinMatch).			Output a single literal."			flushNeeded _ self encodeLiteral: (collection byteAt: (here + 1)).			here _ here + 1.			(here <= lastIndex and:[flushNeeded not]) ifTrue:[				"Cache the results for the next round"				self insertStringAt: here.				hasMatch _ true.				hereMatch _ newMatch.				hereLength _ newLength].		].		flushNeeded ifTrue:[blockPosition _ here. ^true].	].	blockPosition _ here.	^false! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:45'!findMatch: here lastLength: lastLength lastMatch: lastMatch chainLength: maxChainLength goodMatch: goodMatch	"Find the longest match for the string starting at here.	If there is no match longer than lastLength return lastMatch/lastLength.	Traverse at most maxChainLength entries in the hash table.	Stop if a match of at least goodMatch size has been found."	| matchResult matchPos distance chainLength limit bestLength length |	"Compute the default match result"	matchResult _ (lastLength bitShift: 16) bitOr: lastMatch.	"There is no way to find a better match than MaxMatch"	lastLength >= MaxMatch ifTrue:[^matchResult].	"Start position for searches"	matchPos _ hashHead at: (self updateHashAt: here + MinMatch) + 1.	"Compute the distance to the (possible) match"	distance _ here - matchPos.	"Note: It is required that 0 < distance < MaxDistance"	(distance > 0 and:[distance < MaxDistance]) ifFalse:[^matchResult].	chainLength _ maxChainLength.	"Max. nr of match chain to search"	here > MaxDistance	"Limit for matches that are too old"		ifTrue:[limit _ here - MaxDistance]		ifFalse:[limit _ 0].	"Best match length so far (current match must be larger to take effect)"	bestLength _ lastLength.	["Compare the current string with the string at match position"	length _ self compare: here with: matchPos min: bestLength.	"Truncate accidental matches beyound stream position"	(here + length > position) ifTrue:[length _ position - here].	"Ignore very small matches if they are too far away"	(length = MinMatch and:[(here - matchPos) > (MaxDistance // 4)])		ifTrue:[length _ MinMatch - 1].	length > bestLength ifTrue:["We have a new (better) match than before"		"Compute the new match result"		matchResult _ (length bitShift: 16) bitOr: matchPos.		bestLength _ length.		"There is no way to find a better match than MaxMatch"		bestLength >= MaxMatch ifTrue:[^matchResult].		"But we may have a good, fast match"		bestLength > goodMatch ifTrue:[^matchResult].	].	(chainLength _ chainLength - 1) > 0] whileTrue:[		"Compare with previous entry in hash chain"		matchPos _ hashTail at: (matchPos bitAnd: WindowMask) + 1.		matchPos <= limit ifTrue:[^matchResult]. "Match position is too old"	].	^matchResult! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/28/1999 17:37'!flushBlock	"Flush a deflated block"! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:46'!insertStringAt: here	"Insert the string at the given start position into the hash table.	Note: The hash value is updated starting at MinMatch-1 since	all strings before have already been inserted into the hash table	(and the hash value is updated as well)."	| prevEntry |	hashValue _ self updateHashAt: (here + MinMatch).	prevEntry _ hashHead at: hashValue+1.	hashHead at: hashValue+1 put: here.	hashTail at: (here bitAnd: WindowMask)+1 put: prevEntry.! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:48'!updateHash: nextValue	"Update the running hash value based on the next input byte.	Return the new updated hash value."	^((hashValue bitShift: HashShift) bitXor: nextValue) bitAnd: HashMask.! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:47'!updateHashAt: here	"Update the hash value at position here (one based)"	^self updateHash: (collection byteAt: here)! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/28/1999 17:43'!validateMatchAt: pos from: startPos to: endPos	| here |	here _ pos.	startPos+1 to: endPos+1 do:[:i|		(collection at: i) = (collection at: (here _ here + 1))			ifFalse:[^self error:'Not a match']].	^true! !!DeflateStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:04'!encodeLiteral: literal	"Encode the given literal.	Return true if the current block needs to be flushed."	^false! !!DeflateStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:04'!encodeMatch: matchLength distance: matchDistance	"Encode a match of the given length and distance.	Return true if the current block should be flushed."	^false! !!DeflateStream methodsFor: 'private' stamp: 'ar 12/28/1999 17:58'!assert: aBlock	aBlock value ifFalse:[^self error: 'Assertion failed']! !!DeflateStream methodsFor: 'private' stamp: 'ar 12/29/1999 17:50'!moveContentsToFront	"Move the contents of the receiver to the front"	| delta |	delta _ (blockPosition - WindowSize).	delta <= 0 ifTrue:[^self].	"Move collection"	collection 		replaceFrom: 1 		to: collection size - delta 		with: collection 		startingAt: delta+1.	position _ position - delta.	"Move hash table entries"	blockPosition _ blockPosition - delta.	blockStart _ blockStart - delta.	self updateHashTable: hashHead delta: delta.	self updateHashTable: hashTail delta: delta.! !!DeflateStream methodsFor: 'private' stamp: 'ar 12/29/1999 20:15'!updateHashTable: table delta: delta	| pos |	<primitive:'primitiveDeflateUpdateHashTable'>	1 to: table size do:[:i|		"Discard entries that are out of range"		(pos _ table at: i) >= delta			ifTrue:[table at: i put: pos - delta]			ifFalse:[table at: i put: 0]].! !!DeflateStream class methodsFor: 'class initialization' stamp: 'ar 12/30/1999 00:24'!initialize	"DeflateStream initialize"	#(	WindowSize WindowMask 		MaxDistance MinMatch MaxMatch		HashBits HashMask HashShift	) do:[:sym|			ZipConstants declare: sym from: Undeclared.		].	WindowSize _ 16r8000.	WindowMask _ WindowSize - 1.	MaxDistance _ WindowSize.	MinMatch _ 3.	MaxMatch _ 258.	HashBits _ 15.	HashMask _ (1 << HashBits) - 1.	HashShift _ (HashBits + MinMatch - 1) // MinMatch.! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 00:38'!close	self deflateBlock.	self flushBlock: true.	encoder close.! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 00:40'!initialize	super initialize.	literals _ ByteArray new: WindowSize.	distances _ WordArray new: WindowSize.	literalFreq _ WordArray new: MaxLiteralCodes.	distanceFreq _ WordArray new: MaxDistCodes.	self initializeNewBlock.! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/29/1999 18:29'!initializeNewBlock	"Initialize the encoder for a new block of data"	literalFreq atAllPut: 0.	distanceFreq atAllPut: 0.	literalFreq at: EndBlock+1 put: 1.	litCount _ 0.	matchCount _ 0.! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 00:37'!on: aCollectionOrStream	encoder _ ZipEncoder on: aCollectionOrStream.	super on: ByteArray new.! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 00:39'!release	"We're done with compression. Do some cleanup."	literals _ distances _ literalFreq _ distanceFreq _ nil.! !!ZipWriteStream methodsFor: 'accessing' stamp: 'ar 12/30/1999 00:37'!encodedStream	^encoder encodedStream! !!ZipWriteStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 18:32'!forcedMethod	"Return a symbol describing an enforced method or nil if the method should	be chosen adaptively. Valid symbols are		#stored	- store blocks (do not compress)		#fixed	- use fixed huffman trees		#dynamic	- use dynamic huffman trees."	^nil! !!ZipWriteStream methodsFor: 'deflating' stamp: 'ar 12/30/1999 14:27'!deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch	"^DeflatePlugin doPrimitive:#primitiveDeflateBlock"	<primitive:'primitiveDeflateBlock'>	^super deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch! !!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:05'!encodeLiteral: lit	"Encode the given literal"	litCount _ litCount + 1.	literals at: litCount put: lit.	distances at: litCount put: 0.	literalFreq at: lit+1 put: (literalFreq at: lit+1) + 1.	^self shouldFlush! !!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:05'!encodeMatch: length distance: dist	"Encode the given match of length length starting at dist bytes ahead"	| literal distance |	dist > 0 		ifFalse:[^self error:'Distance must be positive'].	length < MinMatch 		ifTrue:[^self error:'Match length must be at least ', MinMatch printString].	litCount _ litCount + 1.	matchCount _ matchCount + 1.	literals at: litCount put: length - MinMatch.	distances at: litCount put: dist.	literal _ (MatchLengthCodes at: length - MinMatch + 1).	literalFreq at: literal+1 put: (literalFreq at: literal+1) + 1.	dist < 257		ifTrue:[distance _ DistanceCodes at: dist]		ifFalse:[distance _ DistanceCodes at: 257 + (dist - 1 bitShift: -7)].	distanceFreq at: distance+1 put: (distanceFreq at: distance+1) + 1.	^self shouldFlush! !!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:08'!flushBlock	^self flushBlock: false! !!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/30/1999 11:54'!flushBlock: lastBlock	"Send the current block"	| lastFlag bitsRequired method bitsSent	storedLength fixedLength dynamicLength 	blTree lTree dTree blBits blFreq |	lastFlag _ lastBlock ifTrue:[1] ifFalse:[0].	"Compute the literal/length and distance tree"	lTree _ ZipEncoderTree buildTreeFrom: literalFreq maxDepth: MaxBits.	dTree _ ZipEncoderTree buildTreeFrom: distanceFreq maxDepth: MaxBits.	"Compute the bit length tree"	blBits _ lTree bitLengths, dTree bitLengths.	blFreq _ WordArray new: MaxBitLengthCodes.	self scanBitLengths: blBits into: blFreq.	blTree _ ZipEncoderTree buildTreeFrom: blFreq maxDepth: MaxBitLengthBits.	"Compute the bit length for the current block.	Note: Most of this could be computed on the fly but it's getting	really ugly in this case so we do it afterwards."	storedLength _ self storedBlockSize.	fixedLength _ self fixedBlockSizeFor: lTree and: dTree.	dynamicLength _ self dynamicBlockSizeFor: lTree and: dTree 							using: blTree and: blFreq.	VerboseLevel > 1 ifTrue:[		Transcript cr; show:'Block sizes (S/F/D):';			space; print: storedLength // 8; 			nextPut:$/; print: fixedLength // 8; 			nextPut:$/; print: dynamicLength // 8; space; endEntry].	"Check which method to use"	method _ self forcedMethod.	method == nil ifTrue:[		method _ (storedLength < fixedLength and:[storedLength < dynamicLength]) 			ifTrue:[#stored]			ifFalse:[fixedLength < dynamicLength ifTrue:[#fixed] ifFalse:[#dynamic]]].	(method == #stored and:[blockStart < 0]) ifTrue:[		"Cannot use #stored if the block is not available"		method _ fixedLength < dynamicLength ifTrue:[#fixed] ifFalse:[#dynamic]].	bitsSent _ encoder bitPosition. "# of bits sent before this block"	bitsRequired _ nil.	(method == #stored) ifTrue:[		VerboseLevel > 0 ifTrue:[Transcript show:'S'].		bitsRequired _ storedLength.		encoder nextBits: 3 put: StoredBlock << 1 + lastFlag.		self sendStoredBlock].	(method == #fixed) ifTrue:[		VerboseLevel > 0 ifTrue:[Transcript show:'F'].		bitsRequired _ fixedLength.		encoder nextBits: 3 put: FixedBlock << 1 + lastFlag.		self sendFixedBlock].	(method == #dynamic) ifTrue:[		VerboseLevel > 0 ifTrue:[Transcript show:'D'].		bitsRequired _ dynamicLength.		encoder nextBits: 3 put: DynamicBlock << 1 + lastFlag.		self sendDynamicBlock: blTree 			literalTree: lTree 			distanceTree: dTree 			bitLengths: blBits].	bitsRequired = (encoder bitPosition - bitsSent)		ifFalse:[self error:'Bits size mismatch'].	lastBlock 		ifTrue:[self release]		ifFalse:[self initializeNewBlock].! !!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:08'!shouldFlush	"Check if we should flush the current block.	Flushing can be useful if the input characteristics change."	| nLits |	litCount = literals size ifTrue:[^true]. "We *must* flush"	(litCount bitAnd: 16rFFF) = 0 ifFalse:[^false]. "Only check every N kbytes"	matchCount * 10 <= litCount ifTrue:[		"This is basically random data. 		There is no need to flush early since the overhead		for encoding the trees will add to the overall size"		^false].	"Try to adapt to the input data.	We flush if the ratio between matches and literals	changes beyound a certain threshold"	nLits _ litCount - matchCount.	nLits <= matchCount ifTrue:[^false]. "whow!! so many matches"	^nLits * 4 <= matchCount! !!ZipWriteStream methodsFor: 'stored blocks' stamp: 'ar 12/30/1999 11:44'!sendStoredBlock	"Send an uncompressed block"	| inBytes |	inBytes _ blockPosition - blockStart.	encoder flushBits. "Skip to byte boundary"	encoder nextBits: 16 put: inBytes.	encoder nextBits: 16 put: (inBytes bitXor: 16rFFFF).	encoder flushBits.	1 to: inBytes do:[:i|		encoder nextPut: (collection byteAt: blockStart+i)].! !!ZipWriteStream methodsFor: 'stored blocks' stamp: 'ar 12/30/1999 00:42'!storedBlockSize	"Compute the length for the current block when stored as is"	^3 "block type bits" 		+ (8 - (encoder bitPosition + 3 bitAnd: 7) bitAnd: 7)"skipped bits to byte boundary"			+ 32 "byte length + chksum" 				+ (blockPosition - blockStart * 8) "actual data bits".! !!ZipWriteStream methodsFor: 'fixed blocks' stamp: 'ar 12/29/1999 18:18'!fixedBlockSizeFor: lTree and: dTree	"Compute the length for the current block using fixed huffman trees"	| bits extra |	bits _ 3 "block type".	"Compute the size of the compressed block"	0 to: NumLiterals do:[:i| "encoding of literals"		bits _ bits + ((literalFreq at: i+1) * (FixedLiteralTree bitLengthAt: i))].	NumLiterals+1 to: lTree maxCode+1 do:[:i| "Encoding of match lengths"		extra _ ExtraLengthBits at: i-NumLiterals.		bits _ bits + ((literalFreq at: i+1) * ((FixedLiteralTree bitLengthAt: i) + extra))].	0 to: dTree maxCode do:[:i| "encoding of distances"		extra _ ExtraDistanceBits at: i+1.		bits _ bits + ((distanceFreq at: i+1) * ((FixedDistanceTree bitLengthAt: i) + extra))].	^bits! !!ZipWriteStream methodsFor: 'fixed blocks' stamp: 'ar 12/29/1999 18:18'!sendFixedBlock	"Send a block using fixed huffman trees"	self sendCompressedBlock: FixedLiteralTree with: FixedDistanceTree.! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 01:55'!dynamicBlockSizeFor: lTree and: dTree using: blTree and: blFreq	"Compute the length for the current block using dynamic huffman trees"	| bits index extra treeBits freq |	bits _ 3 "block type" + 5 "literal codes length" + 5 "distance codes length".	"Compute the # of bits for sending the bit length tree"	treeBits _ 4. "Max index for bit length tree"	index _ MaxBitLengthCodes.	[index >= 4] whileTrue:[		(index = 4 or:[(blFreq at: (BitLengthOrder at: index)+1) > 0])			ifTrue:[treeBits _ treeBits + (index * 3).					index _ -1]			ifFalse:[index _ index - 1]].	"Compute the # of bits for sending the literal/distance tree.	Note: The frequency are already stored in the blTree"	0 to: 15 do:[:i| "First, the non-repeating values"		freq _ blFreq at: i+1.		freq > 0 ifTrue:[treeBits _ treeBits + (freq * (blTree bitLengthAt: i))]].	"Now the repeating values"	(Repeat3To6 to: Repeat11To138) with: #(2 3 7) do:[:i :addl|		freq _ blFreq at: i+1.		freq > 0 ifTrue:[			treeBits _ treeBits + (freq * ((blTree bitLengthAt: i) + addl "addl bits"))]].	VerboseLevel > 1 ifTrue:[		Transcript show:'['; print: treeBits; show:' bits for dynamic tree]'].	bits _ bits + treeBits.	"Compute the size of the compressed block"	0 to: NumLiterals do:[:i| "encoding of literals"		freq _ literalFreq at: i+1.		freq > 0 ifTrue:[bits _ bits + (freq * (lTree bitLengthAt: i))]].	NumLiterals+1 to: lTree maxCode do:[:i| "encoding of match lengths"		freq _ literalFreq at: i+1.		extra _ ExtraLengthBits at: i-NumLiterals.		freq > 0 ifTrue:[bits _ bits + (freq * ((lTree bitLengthAt: i) + extra))]].	0 to: dTree maxCode do:[:i| "encoding of distances"		freq _ distanceFreq at: i+1.		extra _ ExtraDistanceBits at: i+1.		freq > 0 ifTrue:[bits _ bits + (freq * ((dTree bitLengthAt: i) + extra))]].	^bits! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:55'!scanBitLength: bitLength repeatCount: repeatCount into: anArray	"Update the frequency for the aTree based on the given values"	| count |	count _ repeatCount.	bitLength = 0 ifTrue:[		[count >= 11] whileTrue:[			anArray at: Repeat11To138+1 put: (anArray at: Repeat11To138+1) + 1.			count _ (count - 138) max: 0].		[count >= 3] whileTrue:[			anArray at: Repeat3To10+1 put: (anArray at: Repeat3To10+1) + 1.			count _ (count - 10) max: 0].		count > 0 ifTrue:[anArray at: bitLength+1 put: (anArray at: bitLength+1) + count].	] ifFalse:[		anArray at: bitLength+1 put: (anArray at: bitLength+1) + 1.		count _ count - 1.		[count >= 3] whileTrue:[			anArray at: Repeat3To6+1 put: (anArray at: Repeat3To6+1) + 1.			count _ (count - 6) max: 0].		count > 0 ifTrue:[anArray at: bitLength+1 put: (anArray at: bitLength+1) + count].	].! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:55'!scanBitLengths: bits into: anArray	"Scan the trees and determine the frequency of the bit lengths.	For repeating codes, emit a repeat count."	| lastValue lastCount value |	bits size = 0 ifTrue:[^self].	lastValue _ bits at: 1.	lastCount _ 1.	2 to: bits size do:[:i|		value _ bits at: i.		value = lastValue 			ifTrue:[lastCount _ lastCount + 1]			ifFalse:[self scanBitLength: lastValue repeatCount: lastCount into: anArray.					lastValue _ value.					lastCount _ 1]].	self scanBitLength: lastValue repeatCount: lastCount into: anArray.! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!sendBitLength: bitLength repeatCount: repeatCount tree: aTree	"Send the given bitLength, repeating repeatCount times"	| count |	count _ repeatCount.	bitLength = 0 ifTrue:[		[count >= 11] whileTrue:[			self sendBitLength: Repeat11To138 tree: aTree.			encoder nextBits: 7 put: (count min: 138) - 11.			count _ (count - 138) max: 0].		[count >= 3] whileTrue:[			self sendBitLength: Repeat3To10 tree: aTree.			encoder nextBits: 3 put: (count min: 10) - 3.			count _ (count - 10) max: 0].		count timesRepeat:[self sendBitLength: bitLength tree: aTree].	] ifFalse:[		self sendBitLength: bitLength tree: aTree.		count _ count - 1.		[count >= 3] whileTrue:[			self sendBitLength: Repeat3To6 tree: aTree.			encoder nextBits: 2 put: (count min: 6) - 3.			count _ (count - 6) max: 0].		count timesRepeat:[self sendBitLength: bitLength tree: aTree].	].! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!sendBitLength: bitLength tree: aTree	"Send the given bitLength"	encoder nextBits: (aTree bitLengthAt: bitLength) 		put: (aTree codeAt: bitLength).! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!sendBitLengthTree: blTree	"Send the bit length tree"	| blIndex bitLength |	MaxBitLengthCodes to: 4 by: -1 do:[:maxIndex|		blIndex _ BitLengthOrder at: maxIndex.		bitLength _ blIndex <= blTree maxCode 			ifTrue:[blTree bitLengthAt: blIndex] ifFalse:[0].		(maxIndex = 4 or:[bitLength > 0]) ifTrue:[			encoder nextBits: 4 put: maxIndex - 4.			1 to: maxIndex do:[:j|				blIndex _ BitLengthOrder at: j.				bitLength _ blIndex <= blTree maxCode 					ifTrue:[blTree bitLengthAt: blIndex] ifFalse:[0].				encoder nextBits: 3 put: bitLength].			^self]].! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 00:48'!sendCompressedBlock: litTree with: distTree	"Send the current block using the encodings from the given literal/length and distance tree"	| sum |	sum _ encoder			sendBlock: (ReadStream on: literals from: 1 to: litCount)			with: (ReadStream on: distances from: 1 to: litCount)			with: litTree			with: distTree.	sum = (blockPosition - blockStart) ifFalse:[self error:'Wrong number of bytes'].! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/29/1999 18:19'!sendDynamicBlock: blTree literalTree: lTree distanceTree: dTree bitLengths: bits	"Send a block using dynamic huffman trees"	self sendLiteralTree: lTree distanceTree: dTree using: blTree bitLengths: bits.	self sendCompressedBlock: lTree with: dTree.! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!sendLiteralTree: lTree distanceTree: dTree using: blTree bitLengths: bits	"Send all the trees needed for dynamic huffman tree encoding"	| lastValue lastCount value |	encoder nextBits: 5 put: (lTree maxCode - 256).	encoder nextBits: 5 put: (dTree maxCode).	self sendBitLengthTree: blTree.	bits size = 0 ifTrue:[^self].	lastValue _ bits at: 1.	lastCount _ 1.	2 to: bits size do:[:i|		value _ bits at: i.		value = lastValue 			ifTrue:[lastCount _ lastCount + 1]			ifFalse:[self sendBitLength: lastValue repeatCount: lastCount tree: blTree.					lastValue _ value.					lastCount _ 1]].	self sendBitLength: lastValue repeatCount: lastCount tree: blTree.! !!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/30/1999 00:31'!initialize	"ZipWriteStream initialize"	#(		MaxBits MaxBitLengthBits EndBlock		StoredBlock FixedBlock DynamicBlock 		NumLiterals MaxLengthCodes MaxDistCodes MaxBitLengthCodes MaxLiteralCodes		Repeat3To6 Repeat3To10 Repeat11To138		ExtraLengthBits ExtraDistanceBits ExtraBitLengthBits BitLengthOrder		BaseLength MatchLengthCodes BaseDistance DistanceCodes 		FixedLiteralTree FixedDistanceTree	) do:[:sym|		ZipConstants declare: sym from: Undeclared.	].	VerboseLevel _ 0.	MaxBits _ 15.	MaxBitLengthBits _ 7.	EndBlock _ 256.	StoredBlock _ 0.	FixedBlock _ 1.	DynamicBlock _ 2.	NumLiterals _ 256.	MaxLengthCodes _ 29.	MaxDistCodes _ 30.	MaxBitLengthCodes _ 19.	MaxLiteralCodes _ NumLiterals + MaxLengthCodes + 1. "+ End of Block"	Repeat3To6 _ 16. "Repeat previous bit length 3-6 times (2 bits repeat count)"	Repeat3To10 _ 17. "Repeat previous bit length 3-10 times (3 bits repeat count)"	Repeat11To138 _ 18. "Repeat previous bit length 11-138 times (7 bits repeat count)"	self initializeExtraBits.	self initializeLengthCodes.	self initializeDistanceCodes.	self initializeFixedTrees.! !!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/29/1999 18:26'!initializeDistanceCodes	| dist |	BaseDistance _ WordArray new: MaxDistCodes.	DistanceCodes _ WordArray new: 512.	dist _ 0.	1 to: 16 do:[:code|		BaseDistance at: code put: dist.		1 to: (1 bitShift: (ExtraDistanceBits at: code)) do:[:n|			dist _ dist + 1.			DistanceCodes at: dist put: code-1]].	dist = 256 ifFalse:[self error:'Whoops?!!'].	dist _ dist >> 7.	17 to: MaxDistCodes do:[:code|		BaseDistance at: code put: dist << 7.		1 to: (1 bitShift: (ExtraDistanceBits at: code)-7) do:[:n|			dist _ dist + 1.			DistanceCodes at: 256 + dist put: code-1]].! !!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/29/1999 18:27'!initializeExtraBits	ExtraLengthBits _ 		WordArray withAll: #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0).	ExtraDistanceBits _ 		WordArray withAll: #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13).	ExtraBitLengthBits _ 		WordArray withAll: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 7).	BitLengthOrder _		WordArray withAll: #(16 17 18 0 8 7 9 6 10 5 11 4 12 3 13 2 14 1 15).! !!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/30/1999 14:25'!initializeFixedTrees	"ZipWriteStream initializeFixedTrees"	| counts nodes |	FixedLiteralTree _ ZipEncoderTree new.	FixedLiteralTree maxCode: 287.	counts _ WordArray new: MaxBits+1.	counts at: 7+1 put: 24.	counts at: 8+1 put: 144+8.	counts at: 9+1 put: 112.	nodes _ Array new: 288.	1 to: 288 do:[:i| nodes at: i put: (ZipEncoderNode value: i-1 frequency: 0 height: 0)].	0 to: 143 do:[:i| (nodes at: i+1) setBitLengthTo: 8].	144 to: 255 do:[:i| (nodes at: i+1) setBitLengthTo: 9].	256 to: 279 do:[:i| (nodes at: i+1) setBitLengthTo: 7].	280 to: 287 do:[:i| (nodes at: i+1) setBitLengthTo: 8].	FixedLiteralTree buildCodes: nodes counts: counts maxDepth: MaxBits.	FixedLiteralTree setValuesFrom: nodes.	FixedDistanceTree _ ZipEncoderTree new.	FixedDistanceTree maxCode: MaxDistCodes.	FixedDistanceTree		bitLengths: ((WordArray new: MaxDistCodes+1) atAllPut: 5)		codes: ((0 to: MaxDistCodes) collect:[:i| FixedDistanceTree reverseBits: i length: 5]).! !!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/29/1999 18:26'!initializeLengthCodes	| length |	BaseLength _ WordArray new: MaxLengthCodes.	MatchLengthCodes _ WordArray new: MaxMatch - MinMatch + 1.	length _ 0.	1 to: MaxLengthCodes - 1 do:[:code|		BaseLength at: code put: length.		1 to: (1 bitShift: (ExtraLengthBits at: code)) do:[:n|			length _ length + 1.			MatchLengthCodes at: length put: NumLiterals + code]].! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!baseDistance	^BaseDistance! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!baseLength	^BaseLength! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:42'!distanceCodes	^DistanceCodes! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!extraDistanceBits	^ExtraDistanceBits! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!extraLengthBits	^ExtraLengthBits! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:42'!matchLengthCodes	^MatchLengthCodes! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:53'!maxDistanceCodes	^MaxDistCodes! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:53'!maxLiteralCodes	^MaxLiteralCodes! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/29/1999 23:48'!compressAndDecompress: aFile using: tempName stats: stats	| fileSize tempFile result |	aFile == nil ifTrue:[^nil].	fileSize _ aFile size.	(fileSize < 1"00000" "or:[fileSize > 1000000]") ifTrue:[aFile close. ^nil].	Transcript cr; show:'Testing ', aFile name,' ... '.	tempFile _ StandardFileStream new open: tempName forWrite: true.	'Compressing ', aFile name,'...' displayProgressAt: Sensor cursorPoint		from: 1 to: aFile size during:[:bar|			result _ self regressionCompress: aFile into: tempFile notifiying: bar stats: stats].	result ifTrue:[		'Validating ', aFile name,'...' displayProgressAt: Sensor cursorPoint			from: 0 to: aFile size during:[:bar|				result _ self regressionDecompress: aFile from: tempFile notifying: bar stats: stats]].	aFile close.	tempFile close.	FileDirectory default deleteFileNamed: tempName ifAbsent:[].	result ~~ false ifTrue:[		Transcript show:' ok (', (result * 100 truncateTo: 0.01) printString,')'].	^result! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/29/1999 21:11'!logProblem: reason for: aFile	| errFile |	errFile _ FileStream fileNamed:'problems.log'.	errFile position: errFile size.	errFile cr; nextPutAll: aFile name;			cr; nextPutAll: reason.	errFile close.	Transcript show:' failed (', reason,')'.	aFile close.	^false! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/31/1999 17:48'!printRegressionStats: stats from: fd	| raw compressed numFiles |	raw _ stats at: #rawSize ifAbsent:[0].	raw = 0 ifTrue:[^self].	compressed _ stats at: #compressedSize ifAbsent:[0].	numFiles _ stats at: #numFiles ifAbsent:[0].	Transcript cr; nextPutAll: fd pathName.	Transcript crtab; nextPutAll:'Files compressed: ', numFiles asStringWithCommas.	Transcript crtab; nextPutAll:'Bytes compressed: ', raw asStringWithCommas.	Transcript crtab; nextPutAll:'Avg. compression ratio: ';		print: ((compressed / raw asFloat * 100.0) truncateTo: 0.01).	Transcript endEntry.! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/29/1999 23:44'!regressionCompress: aFile into: tempFile notifiying: progressBar stats: stats	"Compress aFile into tempFile"	| zip encoded buffer |	aFile binary.	aFile position: 0.	tempFile binary.	buffer _ ByteArray new: 4096.	zip _ self on: (ByteArray new: 10000).	encoded _ zip encodedStream.	[aFile atEnd] whileFalse:[		progressBar value: aFile position.		zip nextPutAll: (aFile nextInto: buffer).		encoded position > 0 ifTrue:[			tempFile nextPutAll: encoded contents.			encoded position: 0]].	zip close.	tempFile nextPutAll: encoded contents.	^true! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/29/1999 23:45'!regressionDecompress: aFile from: tempFile notifying: progressBar stats: stats	"Validate aFile as decompressed from tempFile"	| unzip rawSize compressedSize buffer1 buffer2 |	rawSize _ aFile size.	compressedSize _ tempFile size.	aFile ascii.	aFile position: 0.	tempFile ascii.	tempFile position: 0.	buffer1 _ String new: 4096.	buffer2 _ buffer1 copy.	unzip _ FastInflateStream on: tempFile.	[aFile atEnd] whileFalse:[		progressBar value: aFile position.		buffer1 _ aFile nextInto: buffer1.		buffer2 _ unzip nextInto: buffer2.		buffer1 = buffer2			ifFalse:[^self logProblem: 'contents ' for: aFile].	].	unzip next = nil ifFalse:[^self logProblem: 'EOF' for: aFile].	stats at: #rawSize put:		(stats at: #rawSize ifAbsent:[0]) + rawSize.	stats at: #compressedSize put:		(stats at: #compressedSize ifAbsent:[0]) + compressedSize.	^compressedSize asFloat / rawSize asFloat.! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/31/1999 17:48'!regressionTest "ZipWriteStream regressionTest"	"Compress and decompress everything we can 	find to validate that compression works as expected."	self regressionTestFrom: (FileDirectory default).! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/29/1999 23:46'!regressionTestFrom: fd	"ZipWriteStream regressionTestFrom: FileDirectory default"	"ZipWriteStream regressionTestFrom: (FileDirectory on:'')"	"ZipWriteStream regressionTestFrom: (FileDirectory on:'C:')"	| tempName stats |	Transcript clear.	stats _ Dictionary new.	tempName _ FileDirectory default fullNameFor: '$$sqcompress$$'.	FileDirectory default deleteFileNamed: tempName.	self regressionTestFrom: fd using: tempName stats: stats.! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/31/1999 17:47'!regressionTestFrom: fd using: tempName stats: stats	| files file fullName |	files _ fd fileNames asSortedCollection.	files do:[:fName|		file _ nil.		fullName _ fd fullNameFor: fName.		fullName = tempName ifFalse:[			file _ StandardFileStream new open: fullName forWrite: false].		self compressAndDecompress: file using: tempName stats: stats].	stats at: #numFiles put: (stats at: #numFiles ifAbsent:[0]) + files size.	files _ nil.	self printRegressionStats: stats from: fd.	fd directoryNames asSortedCollection do:[:dName|		self regressionTestFrom: (fd directoryNamed: dName) using: tempName stats: stats.	].! !!GZipReadStream methodsFor: 'initialize' stamp: 'ar 12/27/1999 15:37'!on: aCollection from: firstIndex to: lastIndex	"Check the header of the GZIP stream."	| method magic flags length |	super on: aCollection from: firstIndex to: lastIndex.	magic _ self nextBits: 16.	(magic = GZipMagic) 		ifFalse:[^self error:'Not a GZipped stream'].	method _ self nextBits: 8.	(method = GZipDeflated)		ifFalse:[^self error:'Bad compression method'].	flags _ self nextBits: 8.	(flags anyMask: GZipEncryptFlag) 		ifTrue:[^self error:'Cannot decompress encrypted stream'].	(flags anyMask: GZipReservedFlags)		ifTrue:[^self error:'Cannot decompress stream with unknown flags'].	"Ignore stamp, extra flags, OS type"	self nextBits: 16; nextBits: 16. "stamp"	self nextBits: 8. "extra flags"	self nextBits: 8. "OS type"	(flags anyMask: GZipContinueFlag) "Number of multi-part archive - ignored"		ifTrue:[self nextBits: 16]. 	(flags anyMask: GZipExtraField) "Extra fields - ignored"		ifTrue:[	length _ self nextBits: 16.				1 to: length do:[:i| self nextBits: 8]].	(flags anyMask: GZipNameFlag) "Original file name - ignored"		ifTrue:[[(self nextBits: 8) = 0] whileFalse].	(flags anyMask: GZipCommentFlag) "Comment - ignored"		ifTrue:[[(self nextBits: 8) = 0] whileFalse].! !!GZipReadStream class methodsFor: 'class initialization' stamp: 'ar 12/27/1999 15:37'!initialize	"GZipReadStream initialize"	#(		(GZipMagic 16r8B1F)		"GZIP magic number"		(GZipDeflated 8)			"Compression method"		(GZipAsciiFlag 16r01)		"Contents is ASCII"		(GZipContinueFlag 16r02)	"Part of a multi-part archive"		(GZipExtraField 16r04)	"Archive has extra fields"		(GZipNameFlag 16r08)	"Archive has original file name"		(GZipCommentFlag 16r10)	"Archive has comment"		(GZipEncryptFlag 16r20)	"Archive is encrypted"		(GZipReservedFlags 16rC0)"Reserved" 	) do:[:spec|		GZipConstants declare: spec first from: Undeclared.		GZipConstants at: spec first put: spec last.	].! !!GZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/29/1999 20:07'!on: aCollection	crc _ 16rFFFFFFFF.	crcPosition _ 1.	bytesWritten _ 0.	super on: aCollection.	self writeHeader.! !!GZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 11:45'!release	"Write crc and the number of bytes encoded"	super release.	self updateCrc.	crc _ crc bitXor: 16rFFFFFFFF.	encoder flushBits.	0 to: 3 do:[:i| encoder nextPut: (crc >> (i*8) bitAnd: 255)].	0 to: 3 do:[:i| encoder nextPut: (bytesWritten >> (i*8) bitAnd: 255)].! !!GZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 11:41'!writeHeader	"Write the GZip header"	encoder nextBits: 16 put: GZipMagic.	encoder nextBits: 8 put: GZipDeflated.	encoder nextBits: 8 put: 0. "No flags"	encoder nextBits: 32 put: 0. "no time stamp"	encoder nextBits: 8 put: 0. "No extra flags"	encoder nextBits: 8 put: 0. "No OS type"! !!GZipWriteStream methodsFor: 'private' stamp: 'ar 12/27/1999 17:12'!moveContentsToFront	"Need to update crc here"	self updateCrc.	super moveContentsToFront.	crcPosition _ position + 1.! !!GZipWriteStream methodsFor: 'private' stamp: 'ar 12/29/1999 20:09'!updateCrc	crcPosition <= position ifTrue:[		bytesWritten _ bytesWritten + position - crcPosition + 1.		crc _ self updateCrc: crc from: crcPosition to: position in: collection.		crcPosition _ position + 1].! !!GZipWriteStream methodsFor: 'private' stamp: 'ar 12/27/1999 21:17'!updateCrc: oldCrc from: start to: stop in: aCollection	| newCrc |	<primitive: 'primitiveUpdateGZipCrc32'>	newCrc _ oldCrc.	start to: stop do:[:i|		newCrc _ (CrcTable at: ((newCrc bitXor: (aCollection byteAt: i)) 				bitAnd: 255) + 1) bitXor: (newCrc bitShift: -8).	].	^newCrc! !!GZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/30/1999 14:35'!crcTable	^CrcTable! !!GZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/27/1999 16:55'!initialize	"GZipWriteStream initialize"	CrcTable _ #(16r00000000 16r77073096 16rEE0E612C 16r990951BA 16r076DC419  16r706AF48F 16rE963A535 16r9E6495A3 16r0EDB8832 16r79DCB8A4  16rE0D5E91E 16r97D2D988 16r09B64C2B 16r7EB17CBD 16rE7B82D07  16r90BF1D91 16r1DB71064 16r6AB020F2 16rF3B97148 16r84BE41DE  16r1ADAD47D 16r6DDDE4EB 16rF4D4B551 16r83D385C7 16r136C9856  16r646BA8C0 16rFD62F97A 16r8A65C9EC 16r14015C4F 16r63066CD9  16rFA0F3D63 16r8D080DF5 16r3B6E20C8 16r4C69105E 16rD56041E4  16rA2677172 16r3C03E4D1 16r4B04D447 16rD20D85FD 16rA50AB56B  16r35B5A8FA 16r42B2986C 16rDBBBC9D6 16rACBCF940 16r32D86CE3  16r45DF5C75 16rDCD60DCF 16rABD13D59 16r26D930AC 16r51DE003A  16rC8D75180 16rBFD06116 16r21B4F4B5 16r56B3C423 16rCFBA9599  16rB8BDA50F 16r2802B89E 16r5F058808 16rC60CD9B2 16rB10BE924  16r2F6F7C87 16r58684C11 16rC1611DAB 16rB6662D3D 16r76DC4190  16r01DB7106 16r98D220BC 16rEFD5102A 16r71B18589 16r06B6B51F  16r9FBFE4A5 16rE8B8D433 16r7807C9A2 16r0F00F934 16r9609A88E  16rE10E9818 16r7F6A0DBB 16r086D3D2D 16r91646C97 16rE6635C01  16r6B6B51F4 16r1C6C6162 16r856530D8 16rF262004E 16r6C0695ED  16r1B01A57B 16r8208F4C1 16rF50FC457 16r65B0D9C6 16r12B7E950  16r8BBEB8EA 16rFCB9887C 16r62DD1DDF 16r15DA2D49 16r8CD37CF3  16rFBD44C65 16r4DB26158 16r3AB551CE 16rA3BC0074 16rD4BB30E2  16r4ADFA541 16r3DD895D7 16rA4D1C46D 16rD3D6F4FB 16r4369E96A  16r346ED9FC 16rAD678846 16rDA60B8D0 16r44042D73 16r33031DE5  16rAA0A4C5F 16rDD0D7CC9 16r5005713C 16r270241AA 16rBE0B1010  16rC90C2086 16r5768B525 16r206F85B3 16rB966D409 16rCE61E49F  16r5EDEF90E 16r29D9C998 16rB0D09822 16rC7D7A8B4 16r59B33D17  16r2EB40D81 16rB7BD5C3B 16rC0BA6CAD 16rEDB88320 16r9ABFB3B6  16r03B6E20C 16r74B1D29A 16rEAD54739 16r9DD277AF 16r04DB2615  16r73DC1683 16rE3630B12 16r94643B84 16r0D6D6A3E 16r7A6A5AA8  16rE40ECF0B 16r9309FF9D 16r0A00AE27 16r7D079EB1 16rF00F9344  16r8708A3D2 16r1E01F268 16r6906C2FE 16rF762575D 16r806567CB  16r196C3671 16r6E6B06E7 16rFED41B76 16r89D32BE0 16r10DA7A5A  16r67DD4ACC 16rF9B9DF6F 16r8EBEEFF9 16r17B7BE43 16r60B08ED5  16rD6D6A3E8 16rA1D1937E 16r38D8C2C4 16r4FDFF252 16rD1BB67F1  16rA6BC5767 16r3FB506DD 16r48B2364B 16rD80D2BDA 16rAF0A1B4C  16r36034AF6 16r41047A60 16rDF60EFC3 16rA867DF55 16r316E8EEF  16r4669BE79 16rCB61B38C 16rBC66831A 16r256FD2A0 16r5268E236  16rCC0C7795 16rBB0B4703 16r220216B9 16r5505262F 16rC5BA3BBE  16rB2BD0B28 16r2BB45A92 16r5CB36A04 16rC2D7FFA7 16rB5D0CF31  16r2CD99E8B 16r5BDEAE1D 16r9B64C2B0 16rEC63F226 16r756AA39C  16r026D930A 16r9C0906A9 16rEB0E363F 16r72076785 16r05005713  16r95BF4A82 16rE2B87A14 16r7BB12BAE 16r0CB61B38 16r92D28E9B  16rE5D5BE0D 16r7CDCEFB7 16r0BDBDF21 16r86D3D2D4 16rF1D4E242  16r68DDB3F8 16r1FDA836E 16r81BE16CD 16rF6B9265B 16r6FB077E1  16r18B74777 16r88085AE6 16rFF0F6A70 16r66063BCA 16r11010B5C  16r8F659EFF 16rF862AE69 16r616BFFD3 16r166CCF45 16rA00AE278  16rD70DD2EE 16r4E048354 16r3903B3C2 16rA7672661 16rD06016F7  16r4969474D 16r3E6E77DB 16rAED16A4A 16rD9D65ADC 16r40DF0B66  16r37D83BF0 16rA9BCAE53 16rDEBB9EC5 16r47B2CF7F 16r30B5FFE9  16rBDBDF21C 16rCABAC28A 16r53B39330 16r24B4A3A6 16rBAD03605  16rCDD70693 16r54DE5729 16r23D967BF 16rB3667A2E 16rC4614AB8  16r5D681B02 16r2A6F2B94 16rB40BBE37 16rC30C8EA1 16r5A05DF1B  16r2D02EF8D).! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ar 1/2/2000 15:33'!next: anInteger putAll: aString startingAt: startIndex	"Store the next anInteger elements from the given collection."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	self primWrite: fileID from: aString startingAt: startIndex count: anInteger.	^aString! !!ZLibReadStream methodsFor: 'initialize' stamp: 'ar 12/27/1999 15:38'!on: aCollection from: firstIndex to: lastIndex	"Check the header of the ZLib stream."	| method byte |	super on: aCollection from: firstIndex to: lastIndex.	method _ self nextBits: 8.	(method bitAnd: 15) = 8 ifFalse:[^self error:'Unknown compression method'].	(method bitShift: -4) + 8 > 15 ifTrue:[^self error:'Invalid window size'].	byte _ self nextBits: 8.	(method bitShift: 8) + byte \\ 31 = 0 ifFalse:[^self error:'Incorrect header'].	(byte anyMask: 32) ifTrue:[^self error:'Need preset dictionary'].! !!ZLibWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/27/1999 15:48'!on: aCollection	super on: aCollection.	encoder nextBits: 8 put: 120. "deflate method with 15bit window size"	encoder nextBits: 8 put: 1. "check sum; no preset dictionary"! !!ZipEncoder methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 00:38'!close	self flush.	(encodedStream respondsTo: #close) ifTrue:[encodedStream close].! !!ZipEncoder methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 15:51'!commit	encodedStream next: position putAll: collection.	position _ readLimit _ 0.! !!ZipEncoder methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 15:51'!flush	self flushBits.	self commit.! !!ZipEncoder methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 00:10'!flushBits	"Flush currently unsent bits"	[bitPosition > 0] whileTrue:[		self nextPut: (bitBuffer bitAnd: 255).		bitBuffer _ bitBuffer bitShift: -8.		bitPosition _ bitPosition - 8].	bitPosition _ 0.! !!ZipEncoder methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 00:41'!on: aCollectionOrStream	aCollectionOrStream isStream 		ifTrue:[encodedStream _ aCollectionOrStream]		ifFalse:[	encodedStream _ WriteStream on: aCollectionOrStream].	super on: (ByteArray new: 4096).	bitPosition _ bitBuffer _ 0.! !!ZipEncoder methodsFor: 'accessing' stamp: 'ar 12/30/1999 00:45'!bitPosition	^encodedStream position + position * 8 + bitPosition.! !!ZipEncoder methodsFor: 'accessing' stamp: 'ar 12/30/1999 00:37'!encodedStream	^encodedStream! !!ZipEncoder methodsFor: 'accessing' stamp: 'ar 12/30/1999 00:09'!nextBits: nBits put: value	"Store a value of nBits"	"self assert:[value >= 0 and:[(1 bitShift: nBits) > value]]."	bitBuffer _ bitBuffer bitOr: (value bitShift: bitPosition).	bitPosition _ bitPosition + nBits.	[bitPosition >= 8] whileTrue:[		self nextPut: (bitBuffer bitAnd: 255).		bitBuffer _ bitBuffer bitShift: -8.		bitPosition _ bitPosition - 8].! !!ZipEncoder methodsFor: 'block encoding' stamp: 'ar 12/30/1999 18:39'!sendBlock: literalStream with: distanceStream with: litTree with: distTree	"Send the current block using the encodings from the given literal/length and distance tree"	| result |	result _ 0.	[literalStream atEnd] whileFalse:[		result _ result + (self privateSendBlock: literalStream						with: distanceStream with: litTree with: distTree).		self commit.	].	self nextBits: (litTree bitLengthAt: EndBlock) put: (litTree codeAt: EndBlock).	^result! !!ZipEncoder methodsFor: 'private' stamp: 'ar 12/30/1999 15:51'!pastEndPut: anObject	"Flush the current buffer and store the new object at the beginning"	self commit.	^self nextPut: anObject! !!ZipEncoder methodsFor: 'private' stamp: 'ar 12/30/1999 18:38'!privateSendBlock: literalStream with: distanceStream with: litTree with: distTree	"Send the current block using the encodings from the given literal/length and distance tree"	| lit dist code extra sum |	<primitive:'primitiveZipSendBlock'>	sum _ 0.	[lit _ literalStream next.	dist _ distanceStream next.	lit == nil] whileFalse:[		dist = 0 ifTrue:["lit is a literal"			sum _ sum + 1.			self nextBits: (litTree bitLengthAt: lit)				put: (litTree codeAt: lit).		] ifFalse:["lit is match length"			sum _ sum + lit + MinMatch.			code _ (MatchLengthCodes at: lit + 1).			self nextBits: (litTree bitLengthAt: code)				put: (litTree codeAt: code).			extra _ ExtraLengthBits at: code-NumLiterals.			extra = 0 ifFalse:[				lit _ lit - (BaseLength at: code-NumLiterals).				self nextBits: extra put: lit.			].			dist _ dist - 1.			dist < 256				ifTrue:[code _ DistanceCodes at: dist + 1]				ifFalse:[code _ DistanceCodes at: 257 + (dist bitShift: -7)].			"self assert:[code < MaxDistCodes]."			self nextBits: (distTree bitLengthAt: code)				put: (distTree codeAt: code).			extra _ ExtraDistanceBits at: code+1.			extra = 0 ifFalse:[				dist _ dist - (BaseDistance at: code+1).				self nextBits: extra put: dist.			].		].	].	^sum! !!ZipEncoderNode commentStamp: '<historical>' prior: 0!ZipEncoderNode represents a node in a huffman tree for encoding ZipStreams.Instance variables:	value 		<Integer>	- Encoded value	frequency	<Integer>	- Number of occurences of the encoded value	height 		<Integer>	- Height of the node in the tree	bitLength 	<Integer>	- bit length of the code	code		<Integer>	- Assigned code for this node	parent		<ZipEncoderNode>		- Parent of this node	left			<ZipEncoderNode>		- First child of this node	right		<ZipEncoderNode>		- Second child of this node!!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 19:41'!bitLength	^bitLength ifNil:[0]! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/30/1999 14:28'!code	^code ifNil:[0]! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 21:51'!code: aCode	self assert:[aCode >= 0 and:[(1 bitShift: bitLength) > aCode]].	code _ aCode.! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:36'!frequency	^frequency! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/28/1999 00:56'!frequency: aNumber	frequency _ aNumber! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/26/1999 10:44'!height	^height! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!left	^left! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 20:06'!left: aNode	aNode parent: self.	left _ aNode.! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!parent	^parent! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!parent: aNode	parent _ aNode! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!right	^right! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 20:06'!right: aNode	aNode parent: self.	right _ aNode.! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!value	^value! !!ZipEncoderNode methodsFor: 'encoding' stamp: 'ar 12/26/1999 11:49'!encodeBitLength: blCounts from: aTree	| index |	"Note: If bitLength is not nil then the tree must be broken"	bitLength == nil ifFalse:[self error:'Huffman tree is broken'].	parent = nil 		ifTrue:[bitLength _ 0]		ifFalse:[bitLength _ parent bitLength + 1].	self isLeaf ifTrue:[		index _ bitLength + 1.		blCounts at: index put: (blCounts at: index) + 1.	] ifFalse:[		left encodeBitLength: blCounts from: aTree.		right encodeBitLength: blCounts from: aTree.	].! !!ZipEncoderNode methodsFor: 'encoding' stamp: 'ar 12/27/1999 14:27'!rotateToHeight: maxHeight	"Rotate the tree to achieve maxHeight depth"	| newParent |	height < 4 ifTrue:[^self].	self left: (left rotateToHeight: maxHeight-1).	self right: (right rotateToHeight: maxHeight-1).	height _ (left height max: right height) + 1.	height <= maxHeight ifTrue:[^self].	(left height - right height) abs <= 2 ifTrue:[^self].	left height < right height ifTrue:[		right right height >= right left height ifTrue:[			newParent _ right.			self right: newParent left.			newParent left: self.		] ifFalse:[			newParent _ right left.			right left: newParent right.			newParent right: right.			self right: newParent left.			newParent left: self.		].	] ifFalse:[		left left height >= left right height ifTrue:[			newParent _ left.			self left: newParent right.			newParent right: self.		] ifFalse:[			newParent _ left right.			left right: newParent left.			newParent left: left.			self left: newParent right.			newParent right: self.		].	].	parent computeHeight.	^parent! !!ZipEncoderNode methodsFor: 'testing' stamp: 'ar 12/24/1999 23:17'!isLeaf	^left == nil! !!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/25/1999 21:50'!assert: aBlock	aBlock value ifFalse:[^self error:'Assertion failed']! !!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/26/1999 10:45'!computeHeight	^self isLeaf		ifTrue:[height _ 0]		ifFalse:[height _ (left computeHeight max: right computeHeight) + 1].! !!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/25/1999 18:14'!leafNodes	self isLeaf		ifTrue:[^Array with: self]		ifFalse:[^left leafNodes, right leafNodes]! !!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/26/1999 12:05'!setBitLengthTo: bl	bitLength _ bl! !!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/26/1999 10:46'!setValue: v frequency: f height: h	value _ v.	frequency _ f.	height _ h.! !!ZipEncoderNode methodsFor: 'printing' stamp: 'ar 12/26/1999 10:46'!printOn: aStream	super printOn: aStream.	aStream nextPut:$(;		nextPutAll:'value = '; print: value;		nextPutAll:', freq = '; print: frequency;		nextPutAll:', bitLength = '; print: bitLength;		nextPutAll:', code = '; print: code;		nextPutAll:', height = '; print: height; 	nextPut:$).! !!ZipEncoderNode class methodsFor: 'instance creation' stamp: 'ar 12/26/1999 10:47'!value: v frequency: f height: h	^self new setValue: v frequency: f height: h! !!ZipEncoderTree commentStamp: '<historical>' prior: 0!ZipEncoderTree represents a huffman tree for encoding ZipStreams.Instance variables:	bitLengths	<WordArray>	 - Bit lengths of each generated code	codes		<WordArray>	 - Codes for each value	maxCode		<Integer>	- Maximum value with non-zero frequency!!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:43'!bitLengthAt: index	^bitLengths at: index+1! !!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:32'!bitLengths	"Return an array of all bitLength values for valid codes"	^bitLengths! !!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:04'!codeAt: index	^codes at: index+1! !!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:24'!codes	"Return an array of all valid codes"	^codes! !!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/25/1999 17:15'!maxCode	^maxCode! !!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/25/1999 21:45'!maxCode: aNumber	maxCode _ aNumber.! !!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/30/1999 01:34'!buildCodes: nodeList counts: blCounts maxDepth: depth	"Build the codes for all nodes"	| nextCode code node length |	nextCode _ WordArray new: depth+1.	code _ 0.	1 to: depth do:[:bits|		code _ (code + (blCounts at: bits)) << 1.		nextCode at: bits+1 put: code].	self assert:[(code + (blCounts at: depth+1) - 1) = (1 << depth - 1)].	0 to: maxCode do:[:n|		node _ nodeList at: n+1.		length _ node bitLength.		length = 0 ifFalse:[			code _ nextCode at: length+1.			node code: (self reverseBits: code length: length).			nextCode at: length+1 put: code+1.		].	].! !!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/26/1999 10:42'!buildHierarchyFrom: aHeap	"Build the node hierarchy based on the leafs in aHeap"	| left right parent |	[aHeap size > 1] whileTrue:[		left _ aHeap removeFirst.		right _ aHeap removeFirst.		parent _ ZipEncoderNode value: -1 			frequency: (left frequency + right frequency)			height: (left height max: right height) + 1.		left parent: parent.		right parent: parent.		parent left: left.		parent right: right.		aHeap add: parent].	^aHeap removeFirst! !!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/30/1999 14:19'!buildTree: nodeList maxDepth: depth	"Build either the literal or the distance tree"	| heap rootNode blCounts |	heap _ Heap new: nodeList size // 3.	heap sortBlock: self nodeSortBlock.	"Find all nodes with non-zero frequency and add to heap"	maxCode _ 0.	nodeList do:[:dNode|		dNode frequency = 0 ifFalse:[			maxCode _ dNode value.			heap add: dNode]].	"The pkzip format requires that at least one distance code exists,	and that at least one bit should be sent even if there is only one	possible code. So to avoid special checks later on we force at least	two codes of non zero frequency."	heap size = 0 ifTrue:[		self assert:[maxCode = 0].		heap add: nodeList first.		heap add: nodeList second.		maxCode _ 1].	heap size = 1 ifTrue:[		nodeList first frequency = 0			ifTrue:[heap add: nodeList first]			ifFalse:[heap add: nodeList second].		maxCode _ maxCode max: 1].	rootNode _ self buildHierarchyFrom: heap.	rootNode height > depth ifTrue:[		rootNode _ rootNode rotateToHeight: depth.		rootNode height > depth ifTrue:[self error:'Cannot encode tree']].	blCounts _ WordArray new: depth+1.	rootNode encodeBitLength: blCounts from: self.	self buildCodes: nodeList counts: blCounts maxDepth: depth.	self setValuesFrom: nodeList.! !!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/30/1999 01:24'!buildTreeFrom: frequencies maxDepth: depth	"Build the receiver from the given frequency values"	| nodeList |	nodeList _ Array new: frequencies size.	1 to: frequencies size do:[:i|		nodeList at: i put: (ZipEncoderNode value: i-1 frequency: (frequencies at: i) height: 0)	].	self buildTree: nodeList maxDepth: depth.! !!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/26/1999 10:42'!nodeSortBlock	^[:n1 :n2|		n1 frequency = n2 frequency			ifTrue:[n1 height <= n2 height]			ifFalse:[n1 frequency <= n2 frequency]].! !!ZipEncoderTree methodsFor: 'private' stamp: 'ar 12/25/1999 00:00'!assert: aBlock	aBlock value ifFalse:[^self error:'Assertion failed']! !!ZipEncoderTree methodsFor: 'private' stamp: 'ar 12/30/1999 14:26'!bitLengths: blArray codes: codeArray	bitLengths _ blArray as: WordArray.	codes _ codeArray as: WordArray.	self assert:[(self bitLengthAt: maxCode) > 0].! !!ZipEncoderTree methodsFor: 'private' stamp: 'ar 12/26/1999 11:02'!reverseBits: code length: length	"Bit reverse the given code"	| result bit bits |	result _ 0.	bits _ code.	1 to: length do:[:i|		bit _ bits bitAnd: 1.		result _ result << 1 bitOr: bit.		bits _ bits >> 1].	^result! !!ZipEncoderTree methodsFor: 'private' stamp: 'ar 12/30/1999 14:26'!setValuesFrom: nodeList	self bitLengths: (nodeList collect:[:n| n bitLength] from: 1 to: maxCode+1)		codes: (nodeList collect:[:n| n code] from: 1 to: maxCode+1).! !!ZipEncoderTree class methodsFor: 'instance creation' stamp: 'ar 12/30/1999 01:25'!buildTreeFrom: frequencies maxDepth: depth	^self new buildTreeFrom: frequencies maxDepth: depth! !!Interpreter class methodsFor: 'translation' stamp: 'ar 1/2/2000 15:54'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]"	"Interpreter patchInterp: 'Squeak VM PPC'"	| cg |	BitBltSimulation initialize.	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: BitBltSimulation.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	BitBltSimulation declareCVarsIn: cg.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	{FFTPlugin. FloatArrayPlugin. Matrix2x3Plugin. 	BalloonEngineBase. BalloonEnginePlugin.	InflatePlugin. DeflatePlugin} do:[:plugin|		plugin initialize.		cg addClass:plugin.		plugin declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !InflatePlugin initialize!DeflatePlugin initialize!PositionableStream removeSelector: #asZLibStream!DeflateStream initialize!ZipWriteStream initialize!GZipReadStream initialize!GZipWriteStream initialize!