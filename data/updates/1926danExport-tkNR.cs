'From Squeak2.8alpha of 14 January 2000 [latest update: #1925] on 10 March 2000 at 3:39 pm'!"Change Set:		ProjectExportTweaksDate:			6 March 2000Author:			Dan Ingalls, Ted KaehlerSundry fixes to project export code.In addition to the postscript it is necessary to...	Browse to Space, PONG, Bumpin', gearing, Follow Path.	In each one, click on 'parts', then 'paint', then (toss).This should eliminate refs to ObsoletePartsViewers."!Model subclass: #Project	instanceVariableNames: 'world changeSet transcript parentProject previousProject displayDepth activeProcess exitFlag viewSize thumbnail nextProject guards projectParameters isolatedHead inForce classArray methodDictArray orgArray version urlList environment '	classVariableNames: 'CurrentProject GoalFreePercent GoalNotMoreThan UsingIsolation '	poolDictionaries: ''	category: 'System-Support'!Object subclass: #WonderlandStyle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Wonderland Misc'!!Behavior methodsFor: 'initialize-release' stamp: 'di 3/10/2000 08:40'!nonObsoleteClass	"Attempt to find and return the current version of this obsolete class"	| obsName |	obsName _ self name.	[obsName beginsWith: 'AnObsolete']		whileTrue: [obsName _ obsName copyFrom: 'AnObsolete' size + 1 to: obsName size].	^ Smalltalk at: obsName asSymbol! !!BlockNode methodsFor: 'printing' stamp: 'di 3/6/2000 20:52'!printTemporariesOn: aStream indent: level	(temporaries == nil or: [temporaries size = 0])		ifFalse: 			[aStream nextPut: $|.			temporaries do: 				[:arg | 				aStream					space;					withAttributes: (Preferences syntaxAttributesFor: #temporaryVariable)					do: [aStream nextPutAll: arg key]].			aStream nextPutAll: ' | '.			"If >0 args and >1 statement, put all statements on separate lines"			statements size > 1 ifTrue: [aStream crtab: level]]! !!Dictionary methodsFor: 'printing' stamp: 'di 6/20/97 09:10'!printOn: aStream	aStream nextPutAll: self class name, ' ('.	self associationsDo: [:element | element printOn: aStream. aStream space].	aStream nextPut: $)! !!DummyStream methodsFor: 'as yet unclassified' stamp: 'tk 3/6/2000 11:10'!originalContents	^ ''! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 3/6/2000 13:09'!copyFromRootsForExport: rootArray 	"Add to roots:  Any methods pointed to from the outside by blocks."	| newRoots list segSize symbolHolder |	arrayOfRoots _ rootArray.	Smalltalk forgetDoIts.  	symbolHolder _ Symbol allInstances.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	(newRoots _ self rootsIncludingPlayers) ifNotNil: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	"Creation of the segment happens here"	self copyFromRoots: arrayOfRoots sizeHint: 0.	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods, blocks from outPointers"	"classes of receivers of blocks"	list _ self compactClassesArray.	outPointers _ outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	"Zap sender of a homeContext. Can't send live stacks out."	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil]].	symbolHolder.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 3/6/2000 11:05'!rootsIncludingBlockMethods	"Return a new roots array with more objects.  (Caller should store into rootArray.) Any CompiledMethods that create blocks will be in outPointers if the block is held outside of this segment.  Put such methods into the roots list.  Then ask for the segment again."| extras myClasses gotIt |userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].extras _ OrderedCollection new.myClasses _ OrderedCollection new.arrayOfRoots do: [:aRoot | aRoot class class == Metaclass ifTrue: [					myClasses add: aRoot]].myClasses isEmpty ifTrue: [^ nil].	"no change"outPointers do: [:anOut | 	anOut class == CompiledMethod ifTrue: [		"specialized version of who"		gotIt _ false.		myClasses detect: [:class |			class selectorsDo: [:sel |				(class compiledMethodAt: sel) == anOut 					ifTrue: [extras add: anOut.  gotIt _ true]].			gotIt] 			ifNone: []		].	anOut _ nil].extras _ extras select: [:ea | (arrayOfRoots includes: ea) not].extras isEmpty ifTrue: [^ nil].	"no change"^ arrayOfRoots, extras! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 3/6/2000 11:04'!rootsIncludingBlocks	"For export segments only.  Return a new roots array with more objects.  (Caller should store into rootArray.)  Collect Blocks and external methods pointed to by them.  Put them into the roots list.  Then ask for the segment again."	| extras have |	userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].	extras _ OrderedCollection new.	outPointers do: [:anOut | 		anOut class == CompiledMethod ifTrue: [extras add: anOut].		(anOut class == BlockContext) ifTrue: [extras add: anOut].		(anOut class == MethodContext) ifTrue: [extras add: anOut].		anOut _ nil].	"don't hang onto it"	[have _ extras size.	 extras copy do: [:anOut |		(anOut class == BlockContext) ifTrue: [			anOut home ifNotNil: [				(extras includes: anOut home) ifFalse: [extras add: anOut home]]].		(anOut class == MethodContext) ifTrue: [			anOut method ifNotNil: [				(extras includes: anOut method) ifFalse: [extras add: anOut method]]]].	 have = extras size] whileFalse.	extras _ extras select: [:ea | (arrayOfRoots includes: ea) not].	extras isEmpty ifTrue: [^ nil].	"no change"	^ arrayOfRoots, extras! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 3/6/2000 17:22'!storeDataOn: aDataStream	"Don't wrote the array of Roots.  Also remember the structures of the classes of objects inside the segment."	| tempRoots tempOutP list |	state = #activeCopy ifFalse: [self error: 'wrong state'].		"real state is activeCopy, but we changed it will be right when coming in"	tempRoots _ arrayOfRoots.	tempOutP _ outPointers.	outPointers _ outPointers clone.	self prepareToBeSaved.	arrayOfRoots _ nil.	state _ #imported.	super storeDataOn: aDataStream.		"record my inst vars"	arrayOfRoots _ tempRoots.	outPointers _ tempOutP.	state _ #activeCopy.	aDataStream references at: #AnImageSegment put: false.		"flag that there is one in this write"	"Find the receivers of blocks in the segment.  Need to get the structure of their classes into structures.  Put the receivers into references."	(aDataStream byteStream isKindOf: DummyStream) ifTrue: [		list _ Set new.		arrayOfRoots do: [:ea | 			(ea class == BlockContext) | (ea class == MethodContext) ifTrue: [ 				list add: ea receiver class ]].		aDataStream references at: #BlockReceiverClasses put: list].! !!MethodNode methodsFor: 'printing' stamp: 'sw 11/17/1999 13:57'!printOn: aStream 	| args |	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[args _ ReadStream on: arguments.			self selector keywords do: 				[:s | 				aStream nextPutAll: s; space.				aStream withAttributes: (Preferences syntaxAttributesFor: #methodArgument)					do: [aStream nextPutAll: args next key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '| '.			aStream withAttributes: (Preferences syntaxAttributesFor: #temporaryVariable)				do:					[temporaries do: 						[:temp | 						aStream nextPutAll: temp key.						aStream space]].			aStream nextPut: $|].	primitive > 0 ifTrue:			[(primitive between: 255 and: 519) ifFalse:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!PasteUpMorph methodsFor: 'stepping' stamp: 'tk 3/7/2000 22:48'!cleanseStepList	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."	| deletions morphToStep |	deletions _ nil.	self stepList do: [:entry |		morphToStep _ entry at: 1.		morphToStep world == self			ifFalse:				[deletions ifNil: [deletions _ OrderedCollection new].				deletions addLast: morphToStep]].	deletions ifNotNil:		[deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].! !!Project methodsFor: 'menu messages' stamp: 'tk 2/29/2000 22:31'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil same old forceRevert response seg result |	self == CurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [CurrentProject makeThumbnail].	(revertFlag | saveForRevert | forceRevert) ifFalse: [		(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [			self storeToMakeRoom]].	World isMorph ifTrue: [World triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	Display newDepthNoRestore: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag		ifTrue: [nextProject _ CurrentProject]		ifFalse: [previousProject _ CurrentProject].	CurrentProject saveState.	(same _ CurrentProject topIsolated == self topIsolated) ifFalse: [		CurrentProject revoke].	CurrentProject _ self.	same ifFalse: [CurrentProject invoke].	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	World isMorph ifTrue:		[recorderOrNil _ World pauseEventRecorder].	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: World].			world triggerOpeningScripts]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		result _ old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	"Complete the enter: by launching a new process"	world isMorph		ifTrue:			[self spawnNewProcessAndTerminateOld: true]		ifFalse:			[showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController]! !!Project methodsFor: 'file in/out' stamp: 'tk 1/30/2000 20:04'!exportSegment	"Store my project out on the disk as an *exported* ImageSegment.  Put all outPointers in a form that can be resolved in the target image.  Name it <project name>.extSeg.	Player classes are included automatically."	^ self exportSegmentWithCatagories: #() classes: #()! !!Project methodsFor: 'file in/out' stamp: 'tk 3/10/2000 15:20'!exportSegmentWithCatagories: catList classes: classList	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."| is response str ans revertSeg roots holder |world == World ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer]].world fullReleaseCachedState. world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].holder _ Project allInstances.	"force them in to outPointers, where DiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ (Array with: self) asOrderedCollection, classList, (classList collect: [:cls | cls class]).catList do: [:sysCat | 	(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |		roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].is _ ImageSegment new copyFromRootsForExport: roots asArray.	"world, and all Players"is state = #tooBig ifTrue: [^ false].str _ ''.is segment size < 3000 ifTrue: [	str _ 'Segment is only ', is segment size printString, ' long.'].(is outPointers detect: [:out | out isMorph] ifNone: [nil]) ifNotNil: [	str _ str, '\Morphs are pointed at from the outside.' withCRs].(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		^ false].	ans = 3 ifTrue: [self halt: 'Segment not written']].is writeForExportWithSources: self name, '.pr'.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.^ true! !!Project methodsFor: 'file in/out' stamp: 'tk 2/29/2000 22:00'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg.  *** Caller must be holding (Project alInstances) to keep subprojects from going out. ***"| is response sizeHint |world == World ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ false].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer]].sizeHint _ self projectParameters at: #segmentSize ifAbsent: [0].is _ ImageSegment new copyFromRootsLocalFileFor: 			(Array with: world presenter with: world)	"world, and all Players"		 sizeHint: sizeHint.is state = #tooBig ifTrue: [^ false].is segment size < 2000 ifTrue: ["debugging" 	Transcript show: self name, ' only ', is segment size printString, 		'bytes in Segment.'; cr].self projectParameters at: #segmentSize put: is segment size.is extract; writeToFile: self name.^ true! !!Project methodsFor: 'file in/out' stamp: 'tk 3/1/2000 13:05'!storeSomeSegment	| cnt pList start proj gain |	"Try all projects to see if any is ready to go out.  Send at most three of them.  Previous one has to wait for a garbage collection before it can go out."	cnt _ 0.  gain _ 0.	pList _ Project allInstances.	start _ pList size atRandom.	"start in a random place"	start to: pList size + start do: [:ii | 		proj _ pList atWrap: ii.		proj storeSegment ifTrue: ["Yes, did send its morphs to the disk"			gain _ gain + (proj projectParameters at: #segmentSize 						ifAbsent: [0]).	"a guess"			"self beep."			(PluckedSound pitch: 261.625*4 dur: 1 loudness: 0.1) play.			(cnt _ cnt + 1) >= 2 ifTrue: [^ gain]]].	(PluckedSound pitch: 261.625*4 dur: 0.35 loudness: 0.1) play.	"high = none"	^ gain! !!Project methodsFor: 'file in/out' stamp: 'tk 3/1/2000 13:18'!storeToMakeRoom	| params memoryEnd goalFree cnt youngSpaceEnd free |	"Write out enough projects to fulfill the space goals.  Include the size of the project about to come in."	Smalltalk garbageCollectMost.	params _ Smalltalk getVMParameters.	memoryEnd	_ params at: 3.	youngSpaceEnd	_ params at: 2.	free _ memoryEnd - youngSpaceEnd.	GoalFreePercent ifNil: [GoalFreePercent _ 33].	GoalNotMoreThan ifNil: [GoalNotMoreThan _ 20000000].	goalFree _ GoalFreePercent asFloat / 100.0 * memoryEnd.	goalFree _ goalFree min: GoalNotMoreThan.	goalFree _ goalFree + (self projectParameters at: #segmentSize ifAbsent: [0]).		"enough room for new segment"	cnt _ 0.	[free > goalFree] whileFalse: [				free _ free + self storeSomeSegment.	"keep track without doing a full GC"				(cnt _ cnt + 2) > 5 ifTrue: [^ self]].	"don't get stuck in a loop"! !!ReferenceMorph methodsFor: 'accessing' stamp: 'tk 3/8/2000 17:39'!allNonSubmorphMorphs	"we hold extra morphs"	^ Array with: referent! !!SmartRefStream commentStamp: '<historical>' prior: 0!Ordinary ReferenceStreams assume that the layout of instance variables in an object on the disk is the same as the layout of that class in memory now.  And it assumes that the class has the same name as before.  SmartRefStream allows one to bring in objects whose instance variables or class name have changed.  1/13/97 tk>>>>See SmartRefStream.aComment for an example.<<<< The basic principal is that object conversion to a new version needs to be done after the fact.  SmartRefStream records the names of the instance variables of all outgoing classes.  Adjustments are done later when the file is read in.* Allows incoming object to have fewer instance variables than the current class.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure description, which is big.  * Writes triplets of (version, class structure array, object) on the file.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.		Note that aDictionary has (old inst var name -> value) * Prompts the user to write (or file in) a conversion method when needed.* Allows a change of instance vars in a superclass to be handled by just one conversion method.  Figures out what to do to the subclasses.* Allows mixing cole for filing in, and raw objects.  The file can start out in the normal fileOut format.  Definitions of new classes on the front and an object are at the end.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, #marked if internal call.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.  A class may be stored inside an ImageSegment that is stored by me.UniClasses are classes for the instance specific behavior of just one instance.  Subclasses of Player are an example.  When a UniClass is read in, and a class of the same name already exists, the incoming one is renamed.  ObjectScanner converts the filed in code.Values in instance variables of UniClasses are stored in the array that tells the class structure.  It is the fourth of the four top level objects.  #(version (class-structure) the-object ((#Player25 scripts slotInfo costumeDictionary) (#Player26 scripts slotInfo costumeDictionary))).There is a separate subclass for doing veryDeepCopy (in memory).  Currently, any object that has objectToStoreOnDataStream return an object other than self, does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.Some metaclasses are put into the structures table.  This is for when a block has a receiver that is a class.  See checkFatalReshape:.Future:* Someday will prompt for a new version number when there are new inst vars with same initials, and tell how to make conversion work when some files have already been written.!!SmartRefStream methodsFor: 'read write' stamp: 'tk 3/6/2000 17:06'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	structures _ Dictionary new.	superclasses _ Dictionary new.	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	self uniClassInstVarsRefs: dummy.	"catalog the extra objects in UniClass inst vars"	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	(refs includesKey: #AnImageSegment) 		ifFalse: [			refs keysDo: [:each | 				cls _ each class.				cls isObsolete ifTrue: [self error: 'Trying to write ', cls name].				cls class == Metaclass ifFalse: [					structures at: cls name put: false]]]		ifTrue: [self recordImageSegment: refs].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures keysDo: [:nm | 		cls _ (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	self saveClassInstVars.	"of UniClassses"	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 3/6/2000 17:13'!mapClass: incoming	"See if the old class named nm exists.  If so, return it.  If not, map it to a new class, and save the mapping in renamed.  "	| cls oldVer sel nm |	nm _ renamed at: incoming ifAbsent: [incoming].	"allow pre-mapping around collisions"	(nm endsWith: ' class') 		ifFalse: [cls _ Smalltalk at: nm ifAbsent: [nil].			cls ifNotNil: [^ cls]]  	"Known class.  It will know how to translate the instance."		ifTrue: [cls _ Smalltalk at: nm substrings first asSymbol ifAbsent: [nil].			cls ifNotNil: [^ cls class]]. 	"Known class.  It will know how to translate the instance."	oldVer _ self versionSymbol: (structures at: nm).	sel _ nm asString.	sel at: 1 put: (sel at: 1) asLowercase.	sel _ sel, oldVer.	"i.e. #rectangleoc4"	Symbol hasInterned: sel ifTrue: [:symb | 		(self class canUnderstand: sel asSymbol) ifTrue: [			cls _ self perform: sel asSymbol]].	"This class will take responsibility"	cls ifNotNil: [			renamed at: nm put: cls name.			^ cls].	"Never heard of it!!"	^ self writeClassRenameMethod: sel was: nm				fromInstVars: (structures at: nm).! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 3/6/2000 17:23'!recordImageSegment: refs	"Besides the objects being written out, record the structure of instances inside the image segment we are writing out."	| cls list |	refs keysDo: [:each | 		cls _ each class.		cls isObsolete ifTrue: [self error: 'Trying to write ', cls name].		cls class == Metaclass 			ifFalse: [structures at: cls name put: false.				(each isKindOf: ImageSegment) ifTrue: [					each outPointers do: [:out |						(out isKindOf: Class) ifTrue: [							structures at: out theNonMetaClass name put: false]]]]		].	list _ refs at: #BlockReceiverClasses ifAbsent: [^ self].	list do: [:meta | structures at: meta name put: false].		"Just the metaclasses whose instances are block receivers.  Otherwise metaclasses are not allowed."! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 3/6/2000 18:17'!saveClassInstVars	"Install the values of the instance variables of UniClasses.classInstVars is an array of arrays (#Player3 (Player3 class's inst varscripts) (Player3 class's inst var slotInfo) ...) "	| normal mySize list clsPoolIndex |	classInstVars _ OrderedCollection new: 100.	normal _ Object class instSize.	clsPoolIndex _ Object class allInstVarNames indexOf: 'classPool'.	self uniClasesDo: [:aUniClass |		list _ OrderedCollection new.		mySize _ aUniClass class instSize.		mySize = normal ifFalse:			[list add: aUniClass name.	"a symbol"			list add: 'Update to read classPool'.	"newconvention for saving the classPool"			list add: (aUniClass instVarAt: clsPoolIndex)"classPool".						"write actual value of nilinstead of Dictionary()"			normal + 1 to: mySize do: [:ii |				list addLast: (aUniClass instVarAt: ii)].			classInstVars add: list asArray]].	classInstVars _ classInstVars asArray.	! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 3/6/2000 17:15'!uniClasesDo: aBlock	"Examine structures and execute the block with each instance-specific class"	| cls |	structures keysDo: [:clsName | 		(clsName endsWith: ' class') ifFalse: [			(cls _ Smalltalk at: clsName) isSystemDefined ifFalse: [					aBlock value: cls]]]! !!SmartRefStream methodsFor: 'import image segment' stamp: 'tk 3/6/2000 11:32'!checkFatalReshape: setOfClasses	| suspects oldInstVars newInstVars bad className |	"Inform the user if any of these classes were reshaped.  A block has a method from the old system whose receiver is of this class.  The method's inst var references might be wrong.  OK if inst vars were only added."	setOfClasses isEmpty ifTrue: [^ self].	suspects _ OrderedCollection new.	setOfClasses do: [:aClass |		className _ renamed keyAtValue: aClass name ifAbsent: [aClass name].		oldInstVars _ (structures at: className) allButFirst.		"should be there"		newInstVars _ aClass allInstVarNames.		oldInstVars size > newInstVars size ifTrue: [bad _ true].		oldInstVars size = newInstVars size ifTrue: [			bad _ oldInstVars ~= newInstVars].		oldInstVars size < newInstVars size ifTrue: [			bad _ oldInstVars ~= (newInstVars copyFrom: 1 to: oldInstVars size)].		bad ifTrue: [suspects add: aClass]].	suspects isEmpty ifFalse: [		self inform: ('Imported foreign methods will run on instances of:\',			suspects asArray printString, 			'\whose shape has changed.  Errors may occur.') withCRs].! !!SystemDictionary methodsFor: 'objects from disk' stamp: 'tk 3/7/2000 18:40'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a reference to Smalltalk instead."	^ DiskProxy global: #Smalltalk selector: #yourself			args: #()! !!SystemDictionary methodsFor: 'objects from disk' stamp: 'tk 3/7/2000 18:40'!storeDataOn: aDataStream	"I don't get stored.  Use a DiskProxy"	self error: 'use a DiskProxy to store me'! !!UndoAction methodsFor: 'accessing' stamp: 'di 3/10/2000 08:40'!rectifyActorClassesInBlocks  "UndoAction allInstancesDo: [:ua | ua rectifyActorClassesInBlocks]"	"Rectify obsolete class refs held onto by UndoActions"	| ctxt obs |	ctxt _ wrappedAction home.	1 to: ctxt size do:		[:i | obs _ ctxt at: i.		((obs isKindOf: Behavior) and: [obs isObsolete])			ifTrue: [ctxt at: i put: obs nonObsoleteClass]]! !!Wonderland methodsFor: 'initialize-reset-release' stamp: 'di 3/10/2000 08:30'!rectifyActorClassList  "Wonderland allInstancesDo: [:w | w rectifyActorClassList]"	"Attempt to restore the actorClassList by replacing obsolete classes by current classes of the same name"	actorClassList _ actorClassList collect:		[:obs |		(obs name beginsWith: 'AnObsolete')			ifTrue: [obs nonObsoleteClass]			ifFalse: [obs]]! !!Wonderland class methodsFor: 'actor prototype mgmt' stamp: 'di 3/10/2000 08:49'!rectifyActorPrototypeClasses  "Wonderland rectifyActorPrototypeClasses"	"Rectify any obsolete prototype class references"	ActorPrototypeClasses keysDo:		[:key | (ActorPrototypeClasses at: key) isObsolete ifTrue:				[ActorPrototypeClasses at: key					put: (ActorPrototypeClasses at: key) nonObsoleteClass]]! !!WonderlandStyle methodsFor: 'object fileIn' stamp: 'tk 3/6/2000 12:11'!convertii0: varDict x0: smartRefStrm	"These variables are automatically stored into the new instance ().	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away ('instVarName1' 'instVarName2' ).  Possibly store their info in another variable?"! !"Postscript:Remove globals from the Flagship.Also attempt to excise many obsolete morphs.Should have no effect in other images.This DoIt only for writing projects before Environments are real.#(Doodoggie Trombpan Trumbear Clarbear	NightOnBaldMountain Bailey Trombear MandM MandMpage)	do: [:k | Smalltalk removeKey: k ifAbsent: []]."| cls |Morph allSubInstancesDo: 	[:m | m submorphsDo:		[:sm | sm class isObsolete ifTrue:			[m privateRemoveMorph: sm]]].WorldState allInstancesDo:	[:m | m stepList do:		[:sm | sm first class isObsolete ifTrue:			[m stopStepping: sm first]]]."Make system Organization in Evolve be the real one."Browser allInstancesDo: [:bb |	(bb instVarAt: 5) == SystemOrganization ifFalse: [		Smalltalk at: bb selectedClassName ifAbsent: [			bb systemOrganizer: SystemOrganization].	"deselects all"		cls _ bb selectedClass ifNotNil: [			bb instVarAt: 5 put: SystemOrganization.			bb selectCategoryForClass: cls.			bb selectClass: cls.			"are method and category all right?"]]].!