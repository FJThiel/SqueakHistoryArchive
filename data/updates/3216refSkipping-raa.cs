'From Squeak2.9alpha of 17 July 2000 [latest update: #3278] on 18 January 2001 at 4:47:54 pm'!"Change Set:		refSkippingDate:			18 January 2001Author:			Bob ArningModified handling of recursive references in ReferenceStream. When a known object is encountered for a second time in the stream, note the identity of that object rather than setting a single boolean flag since some of the sub-objects may be as yet unread AND may be of the sort that change on loading (like DiskProxy). The single flag was preventing the the reconstituted object from being stored."!!ReferenceStream methodsFor: 'writing' stamp: 'RAA 1/18/2001 11:51'!setStream: aStream	"PRIVATE -- Initialization method."	super setStream: aStream.	references _ IdentityDictionary new: 4096 * 5.	objects _ IdentityDictionary new: 4096 * 5.	fwdRefEnds _ IdentityDictionary new.	skipping _ IdentitySet new.	insideASegment _ false.	blockers ifNil: [blockers _ IdentityDictionary new].	"keep blockers we just passed in"! !!ReferenceStream methodsFor: 'writing' stamp: 'RAA 1/18/2001 11:51'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	super setStream: aStream reading: isReading.	"isReading ifFalse: [  when we are sure"	references _ IdentityDictionary new: 4096 * 5.	isReading ifTrue: [		objects _ IdentityDictionary new: 4096 * 5.		skipping _ IdentitySet new.		insideASegment _ false.		fwdRefEnds _ IdentityDictionary new].	blockers ifNil: [blockers _ IdentityDictionary new].	"keep blockers we just passed in"! !!ReferenceStream methodsFor: 'reading' stamp: 'RAA 1/18/2001 11:52'!beginReference: anObject	"Remember anObject as the object we read at the position recorded by	 noteCurrentReference:. This must be done after instantiating anObject but	 before reading any of its contents that might (directly or indirectly) refer to	 it. (It's ok to do this redundantly, which is convenient for #next.)	 Answer the reference position."	objects at: currentReference ifAbsent: [		objects at: currentReference put: anObject.		^ currentReference].	(skipping includes: currentReference) ifFalse: [		"If reading just to skip it, don't record this copy."		objects at: currentReference put: anObject	].	^ currentReference		"position relative to start of data portion of file"! !!ReferenceStream methodsFor: 'reading' stamp: 'RAA 1/18/2001 16:46'!next	"Answer the next object in the stream.  If this object was already read, don't re-read it.  File is positioned just before the object."	| curPosn skipToPosn haveIt theObject wasSkipping |	haveIt _ true.	curPosn _ byteStream position - basePos.	theObject _ objects at: curPosn ifAbsent: [haveIt _ false].		"probe in objects is done twice when coming from objectAt:.  This is OK."	skipToPosn _ fwdRefEnds at: curPosn ifAbsent: [nil].	haveIt ifFalse: [ ^ super next].	skipToPosn ifNotNil: [		"Skip over the object and return the already-read-in value."		byteStream position: skipToPosn + basePos		"make absolute"	] ifNil: [		"File is not positioned correctly.  Read object and throw it away."		wasSkipping _ skipping includes: curPosn.		skipping add: curPosn.		"fake _" super next.		wasSkipping ifFalse: [skipping remove: curPosn ifAbsent: []].	].	^ theObject		! !