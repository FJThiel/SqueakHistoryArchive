'From Squeak2.6 of 11 October 1999 [latest update: #1571] on 26 October 1999 at 5:18:22 pm'!"Change Set:		FlexDragDate:			21 October 1999Author:			Dan IngallsA number of changes that make dragging of objects around a flexed pasteup look and work nicer.Mainly if you pick up a morph from a flexed environment, it retains its flex while in the hand.A number of things required fixing such as double-clicking in flexed environments.One other unrelated fix:Cause canvas image: of 1-bit forms to use opaque white."!Morph subclass: #HandMorph	instanceVariableNames: 'eventSubscribers keyboardFocus mouseDownMorph mouseOverMorphs mouseOverTimes dragOverMorphs clickClient clickState firstClickEvent firstClickTime userInitials lastEvent eventTransform argument targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset grid gridOn remoteConnections transmitBuffer lastEventTransmitted lastWorldExtent menuTargetOffset hasChanged savedPatch suppressDrawing formerOwner formerPosition addedFlexAtGrab '	classVariableNames: 'DoubleClickTime NormalCursor PasteBuffer '	poolDictionaries: ''	category: 'Morphic-Kernel'!!DisplayTransform methodsFor: 'transforming rects' stamp: 'di 10/25/1999 12:49'!sourceQuadFor: aRectangle	^ aRectangle innerCorners collect: 		[:p | self globalPointToLocal: p]! !!CompositeTransform methodsFor: 'initialization' stamp: 'di 10/26/1999 17:08'!composedWith: aTransform	"Return a new transform that has the effect of transforming points first by the receiver and then by the argument."	self isIdentity ifTrue: [^ aTransform].	aTransform isIdentity ifTrue: [^ self].	^ CompositeTransform new globalTransform: self							localTransform: aTransform! !!CompositeTransform methodsFor: 'accessing' stamp: 'di 10/26/1999 17:06'!angle	^ localTransform angle + globalTransform angle! !!CompositeTransform methodsFor: 'accessing' stamp: 'di 10/26/1999 15:40'!offset	^ (self localPointToGlobal: 0@0) negated! !!CompositeTransform methodsFor: 'accessing' stamp: 'di 10/26/1999 15:39'!scale	^ localTransform scale * globalTransform scale! !!CompositeTransform methodsFor: 'converting' stamp: 'di 10/26/1999 17:03'!asMorphicTransform	"Squash a composite transform down to a simple one"	^ MorphicTransform offset: self offset angle: self angle scale: self scale! !!FormCanvas methodsFor: 'drawing' stamp: 'di 10/25/1999 09:07'!image: aForm at: aPoint sourceRect: sourceRect rule: rule 	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	shadowDrawing		ifTrue: [port colorMap: (Color maskingMap: aForm depth);					fillColor: shadowStipple]		ifFalse: [port colorMap: (aForm colormapIfNeededForDepth: form depth);					fillColor: nil].	port image: aForm at: aPoint + origin sourceRect: sourceRect		rule: ((form depth = 1 and: [rule = Form paint])				ifTrue: [self drawRule: Form over color: Color black]				ifFalse: [self drawRule: rule color: Color black])! !!Morph methodsFor: 'rotate scale and flex' stamp: 'di 10/25/1999 16:59'!addFlexShell	"Wrap a rotating and scaling shell around this morph."	| oldHalo flexMorph anActorState aName |	oldHalo _ self halo.	self owner addMorph:		(flexMorph _ self newTransformationMorph asFlexOf: self).	(anActorState _ self actorStateOrNil) ifNotNil:		[flexMorph actorState: anActorState.		self actorState: nil].	(aName _ self knownName) ifNotNil:		[flexMorph setNameTo: aName.		self setNameTo: nil].	self player ifNotNil:		[flexMorph player: self player.		self player rawCostume: flexMorph].	oldHalo ifNotNil: [oldHalo setTarget: flexMorph].	^ flexMorph! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 10/25/1999 17:56'!slideBackToFormerSituation: evt	| slideForm formerOwner formerPosition aWorld origin startPoint endPoint trans |	formerOwner _ evt hand formerOwner.	formerPosition _ evt hand formerPosition.	aWorld _ self world.	trans _ formerOwner transformFromWorld.	trans isPureTranslation 		ifTrue: [slideForm _ self imageForm offset: 0@0]		ifFalse: [slideForm _ ((TransformationMorph new asFlexOf: self) transform: trans)								imageForm offset: 0@0].	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	endPoint _ (trans localPointToGlobal: formerPosition) + origin.	owner privateRemoveMorph: self.	aWorld displayWorld.	slideForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt.! !!HandMorph methodsFor: 'double click support' stamp: 'di 10/21/1999 21:19'!checkForDoubleClick: evt	"Process the given mouse event to detect a click, double-click, or drag."	| t tfmEvt |	tfmEvt _ evt transformedBy: eventTransform.	clickState = #dragging ifTrue:		[clickClient drag: tfmEvt.		tfmEvt isMouseMove ifFalse: [self resetClickState].		^ self].	t _ Time millisecondClockValue - firstClickTime.	clickState = #firstClickDown ifTrue:		[(t > DoubleClickTime or:		 [(tfmEvt cursorPoint - firstClickEvent cursorPoint) r > 15]) ifTrue:			["consider it a drag if hand moves or timeout expires"			clickClient drag: firstClickEvent.			clickState _ #dragging.			^ self].		tfmEvt isMouseUp ifTrue:			[clickState _ #firstClickUp.			^ self]].	clickState = #firstClickUp ifTrue:		[tfmEvt isMouseDown ifTrue:			[clickClient doubleClick: firstClickEvent.			^ self resetClickState].		t > DoubleClickTime ifTrue:			[clickClient click: firstClickEvent.			^ self resetClickState]]! !!HandMorph methodsFor: 'double click support' stamp: 'di 10/21/1999 21:10'!resetClickState	"Reset the double-click detection state to normal (i.e., not waiting for a double-click)."	clickClient _ nil.	clickState _ #idle.	eventTransform _ MorphicTransform identity.	firstClickEvent _ nil.	firstClickTime _ nil.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 10/26/1999 16:51'!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drops into the world."	| newOwner morphToDrop tfm localPt grabbedMorph pos |	owner ifNil: [^ self].	self changed.	self submorphsReverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		addedFlexAtGrab == true			ifTrue: [pos _ m firstSubmorph position.					grabbedMorph _ m removeFlexShell.					self privateRemoveMorph: grabbedMorph.					grabbedMorph position: pos  "undo offset from removeFlexShell"]			ifFalse: [grabbedMorph _ m].		newOwner _ self dropTargetFor: grabbedMorph event: evt.		newOwner ifNil:  "Drop not allowed"			[self rejectDropMorph: grabbedMorph event: evt.			addedFlexAtGrab == true			ifTrue: [self privateRemoveMorph: m.					addedFlexAtGrab _ false].			^ self].		morphToDrop _ newOwner morphToDropFrom: grabbedMorph. 		morphToDrop == grabbedMorph ifFalse: [submorphs size == 1 ifTrue:			[self privateRemoveMorph: m.			m privateOwner: nil.			addedFlexAtGrab _ false]].		"the above says: the thing to drop is not what I was carrying; silently vaporize what I was carrying lest it cause trouble later; keep the owner/submorph relationship invariant, but don't go through the standard delete protocol"		tfm _ newOwner transformFromWorld.		localPt _ tfm globalPointToLocal: self position.		addedFlexAtGrab == true			ifTrue: [morphToDrop position: localPt			 			+ (morphToDrop position - (m transform globalPointToLocal: self position)).					self privateRemoveMorph: m.					addedFlexAtGrab _ false]			ifFalse: [morphToDrop position: localPt + (morphToDrop position - self position)].		newOwner acceptDroppingMorph: morphToDrop event: evt.		morphToDrop justDroppedInto: newOwner event: evt.		morphToDrop owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 10/26/1999 17:17'!grabMorph: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor localPt morphToGrab trans pos |	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike		ifTrue: [editor _ m topEditor].	(m owner isKindOf: DropShadowMorph)		ifTrue: [^ self grabMorph: m owner].	"Check if the morph will keep it's transform while grabbed"	m keepsTransform		ifTrue:[localPt _ self position]		ifFalse:[localPt _ m pointFromWorld: self position].	m aboutToBeGrabbedBy: self.	"Testing flexed drag..."	(formerOwner == nil		or: [m keepsTransform		or: [(trans _ formerOwner transformFromWorld) isPureTranslation]]) 		ifTrue: [m position: self position + (m position - localPt).				morphToGrab _ m.				addedFlexAtGrab _ false]		ifFalse: [pos _ m position.				morphToGrab _ m addFlexShell transform: trans asMorphicTransform.				m position: pos.  "revert offset from addFlexShell"				addedFlexAtGrab _ true].	gridOn ifTrue: [morphToGrab position: (morphToGrab position grid: grid)].	self addMorphBack: morphToGrab.	editor ifNotNil: [editor scriptEdited]! !!MorphicTransform methodsFor: 'converting' stamp: 'di 10/26/1999 17:03'!asMorphicTransform	^ self! !!TransformationMorph methodsFor: 'menu' stamp: 'di 10/25/1999 16:00'!removeFlexShell	"Remove the shell used to make a morph rotatable and scalable."	| oldHalo unflexed anActorState aName |	oldHalo _ self halo.	submorphs isEmpty ifTrue: [^ self delete].	unflexed _ self firstSubmorph.	self submorphs copy do: [:m |		m position: self center - (m extent // 2).		owner addMorph: m].	(anActorState _ self actorStateOrNil) ifNotNil:		[unflexed actorState: anActorState].	(aName _ self knownName) ifNotNil:		[unflexed setNameTo: aName].	unflexed player: self player.	self player ifNotNil:		[self player rawCostume: unflexed.		self player: nil].	oldHalo ifNotNil: [oldHalo setTarget: unflexed].	self delete.	^ unflexed! !MorphicTransform removeSelector: #sourceQuadFor:!