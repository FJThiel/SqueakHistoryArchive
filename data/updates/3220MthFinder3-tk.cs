'From Squeak2.9alpha of 16 June 2000 [latest update: #3282] on 19 January 2001 at 12:05:47 am'!"Change Set:		MthFinder3-tkDate:			18 January 2001Author:			Ted KaehlerChanges to the MethodFinder:Added the ability to find expressions with an unknown constant in them, such as (data1 + 3) or (data1 \\ 30).  Can also find a linear relationship in data.  The Squeak expression for a line is (#(5 2) polynomialEval: data1), which means the line (5x + 2).  Since it needs at least two data points, it can't be found from the upper pane of the Method Finder.  Try 	(MethodFinder new load: {  #(1). 7. #(2). 12} ) searchForOne firstMade the main search of the MethodFinder return an OrderedCollection instead of a String.  Handling results is easier.  A MethodFinder search is more usable when called from another program."!!MethodFinder methodsFor: 'initialize' stamp: 'tk 12/29/2000 13:38'!copy: mthFinder addArg: aConstant	| more |	"Copy inputs and answers, add an additional data argument to the inputs.  The same constant for every example".	more _ Array with: aConstant.	data _ mthFinder data collect: [:argList | argList, more].	answers _ mthFinder answers.	self load: nil.! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 12/27/2000 09:48'!initialize	"The methods we are allowed to use.  (MethodFinder new initialize) "	Approved _ Set new.	AddAndRemove _ Set new.	Blocks _ Set new.	"These modify an argument: longPrintOn: printOn: storeOn: sentTo: storeOn:base: printOn:base: absPrintExactlyOn:base: absPrintOn:base: absPrintOn:base:digitCount: writeOn: writeScanOn: possibleVariablesFor:continuedFrom:""Object"  	#("in class, instance creation" categoryForUniclasses chooseUniqueClassName initialInstance isSystemDefined newFrom: officialClass readCarefullyFrom:"accessing" at: basicAt: basicSize bindWithTemp: in: size yourself "testing" basicType ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: isColor isFloat isFraction isInMemory isInteger isMorph isNil isNumber isPoint isPseudoContext isText isTransparent isWebBrowser knownName notNil pointsTo: wantsSteps "comparing" = == closeTo: hash hashMappedBy: identityHash identityHashMappedBy: identityHashPrintString ~= ~~ "copying" clone copy shallowCopy "dependents access" canDiscardEdits dependents hasUnacceptedEdits "updating" changed changed: okToChange update: windowIsClosing "printing" fullPrintString isLiteral longPrintString printString storeString stringForReadout stringRepresentation "class membership" class isKindOf: isKindOf:orOf: isMemberOf: respondsTo: xxxClass "error handling" "user interface" addModelMenuItemsTo:forMorph:hand: defaultBackgroundColor defaultLabelForInspector fullScreenSize initialExtent modelWakeUp mouseUpBalk: newTileMorphRepresentative windowActiveOnFirstClick windowReqNewLabel: "system primitives" asOop instVarAt: instVarNamed: "private" "associating" -> "converting" as: asOrderedCollection asString "casing" caseOf: caseOf:otherwise: "binding" bindingOf: "macpal" contentsChanged currentEvent currentHand currentWorld flash ifKindOf:thenDo: instanceVariableValues scriptPerformer "flagging" flag: "translation support" "objects from disk" "finalization" ) do: [:sel | Approved add: sel].	#(at:add: at:modify: at:put: basicAt:put: "NOT instVar:at:""message handling" perform: perform:orSendTo: perform:with: perform:with:with: perform:with:with:with: perform:withArguments: perform:withArguments:inSuperclass: ) do: [:sel | AddAndRemove add: sel]."Boolean, True, False, UndefinedObject"  	#("logical operations" & eqv: not xor: |"controlling" and: ifFalse: ifFalse:ifTrue: ifTrue: ifTrue:ifFalse: or:"copying" "testing" isEmptyOrNil) do: [:sel | Approved add: sel]."Behavior" 	#("initialize-release""accessing" compilerClass decompilerClass evaluatorClass format methodDict parserClass sourceCodeTemplate subclassDefinerClass"testing" instSize instSpec isBits isBytes isFixed isPointers isVariable isWeak isWords"copying""printing" defaultNameStemForInstances printHierarchy"creating class hierarchy""creating method dictionary""instance creation" basicNew basicNew: new new:"accessing class hierarchy" allSubclasses allSubclassesWithLevelDo:startingLevel: allSuperclasses subclasses superclass withAllSubclasses withAllSuperclasses"accessing method dictionary" allSelectors changeRecordsAt: compiledMethodAt: compiledMethodAt:ifAbsent: firstCommentAt: lookupSelector: selectors selectorsDo: selectorsWithArgs: "slow but useful ->" sourceCodeAt: sourceCodeAt:ifAbsent: sourceMethodAt: sourceMethodAt:ifAbsent:"accessing instances and variables" allClassVarNames allInstVarNames allSharedPools classVarNames instVarNames instanceCount sharedPools someInstance subclassInstVarNames"testing class hierarchy" inheritsFrom: kindOfSubclass"testing method dictionary" canUnderstand: classThatUnderstands: hasMethods includesSelector: scopeHas:ifTrue: whichClassIncludesSelector: whichSelectorsAccess: whichSelectorsReferTo: whichSelectorsReferTo:special:byte: whichSelectorsStoreInto:"enumerating""user interface""private" indexIfCompact) do: [:sel | Approved add: sel]."ClassDescription"	#("initialize-release" "accessing" classVersion isMeta name theNonMetaClass"copying" "printing" classVariablesString instanceVariablesString sharedPoolsString"instance variables" checkForInstVarsOK: "method dictionary" "organization" category organization whichCategoryIncludesSelector:"compiling" acceptsLoggingOfCompilation wantsChangeSetLogging"fileIn/Out" definition"private" ) do: [:sel | Approved add: sel]."Class"	#("initialize-release" "accessing" classPool"testing""copying" "class name" "instance variables" "class variables" classVarAt: classVariableAssociationAt:"pool variables" "compiling" "subclass creation" "fileIn/Out" ) do: [:sel | Approved add: sel]. "Metaclass"	#("initialize-release" "accessing" isSystemDefined soleInstance"copying" "instance creation" "instance variables"  "pool variables" "class hierarchy"  "compiling""fileIn/Out"  nonTrivial ) do: [:sel | Approved add: sel]."Context, BlockContext"	#(receiver client method receiver tempAt: "debugger access" mclass pc selector sender shortStack sourceCode tempNames tempsAndValues"controlling"  "printing" "system simulation" "initialize-release" "accessing" hasMethodReturn home numArgs"evaluating" value value:ifError: value:value: value:value:value: value:value:value:value: valueWithArguments:"controlling"  "scheduling"  "instruction decoding"  "printing" "private"  "system simulation" ) do: [:sel | Approved add: sel].	#(value: "<- Association has it as a store" ) do: [:sel | AddAndRemove add: sel]."Message"	#("inclass, instance creation" selector: selector:argument: selector:arguments:"accessing" argument argument: arguments sends:"printing" "sending" ) do: [:sel | Approved add: sel].	#("private" setSelector:arguments:) do: [:sel | AddAndRemove add: sel]."Magnitude"	#("comparing" < <= > >= between:and:"testing" max: min: min:max: ) do: [:sel | Approved add: sel]."Date, Time"	#("in class, instance creation" fromDays: fromSeconds: fromString: newDay:month:year: newDay:year: today	"in class, general inquiries" dateAndTimeNow dayOfWeek: daysInMonth:forYear: daysInYear: firstWeekdayOfMonth:year: indexOfMonth: leapYear: nameOfDay: nameOfMonth:"accessing" day leap monthIndex monthName weekday year"arithmetic" addDays: subtractDate: subtractDays:"comparing""inquiries" dayOfMonth daysInMonth daysInYear daysLeftInYear firstDayOfMonth previous:"converting" asSeconds"printing" mmddyy mmddyyyy printFormat: printOn:format:"private" firstDayOfMonthIndex: weekdayIndex 	"in class, instance creation" fromSeconds: now 	"in class, general inquiries" dateAndTimeFromSeconds: dateAndTimeNow millisecondClockValue millisecondsToRun: totalSeconds"accessing" hours minutes seconds"arithmetic" addTime: subtractTime:"comparing""printing" intervalString print24 "converting") do: [:sel | Approved add: sel].	#("private" hours: hours:minutes:seconds: day:year: 		 ) do: [:sel | AddAndRemove add: sel]."Number"	#("in class" readFrom:base: "arithmetic" * + - / // \\ abs negated quo: reciprocal rem:"mathematical functions" arcCos arcSin arcTan arcTan: cos exp floorLog: ln log log: raisedTo: raisedToInteger: sin sqrt squared tan"truncation and round off" ceiling detentBy:atMultiplesOf:snap: floor roundTo: roundUpTo: rounded truncateTo: truncated"comparing""testing" even isDivisibleBy: isInf isInfinite isNaN isZero negative odd positive sign strictlyPositive"converting" @ asInteger asNumber asPoint asSmallAngleDegrees degreesToRadians radiansToDegrees"intervals" to: to:by: "printing" printStringBase: storeStringBase: ) do: [:sel | Approved add: sel]."Integer"	#("in class" primesUpTo:"testing" isPowerOfTwo"arithmetic" alignedTo:"comparing""truncation and round off" atRandom normalize"enumerating" timesRepeat:"mathematical functions" degreeCos degreeSin factorial gcd: lcm: take:"bit manipulation" << >> allMask: anyMask: bitAnd: bitClear: bitInvert bitInvert32 bitOr: bitShift: bitXor: lowBit noMask:"converting" asCharacter asColorOfDepth: asFloat asFraction asHexDigit"printing" asStringWithCommas hex hex8 radix:"system primitives" lastDigit replaceFrom:to:with:startingAt:"private" "benchmarks" ) do: [:sel | Approved add: sel]."SmallInteger, LargeNegativeInteger, LargePositiveInteger"	#("arithmetic" "bit manipulation" highBit "testing" "comparing" "copying" "converting" "printing" "system primitives" digitAt: digitLength "private" fromString:radix: ) do: [:sel | Approved add: sel].	#(digitAt:put: ) do: [:sel | AddAndRemove add: sel]."Float"	#("arithmetic""mathematical functions" reciprocalFloorLog: reciprocalLogBase2 timesTwoPower:"comparing" "testing""truncation and round off" exponent fractionPart integerPart significand significandAsInteger"converting" asApproximateFraction asIEEE32BitWord asTrueFraction"copying") do: [:sel | Approved add: sel]."Fraction, Random"	#(denominator numerator reduced next nextValue) do: [:sel | Approved add: sel].	#(setNumerator:denominator:) do: [:sel | AddAndRemove add: sel]."Collection"	#("accessing" anyOne"testing" includes: includesAllOf: includesAnyOf: includesSubstringAnywhere: isEmpty isSequenceable occurrencesOf:"enumerating" collect: collect:thenSelect: count: detect: detect:ifNone: detectMax: detectMin: detectSum: inject:into: reject: select: select:thenCollect:"converting" asBag asCharacterSet asSet asSortedArray asSortedCollection asSortedCollection:"printing""private" maxSize"arithmetic""math functions" average max median min range sum) do: [:sel | Approved add: sel].	#("adding" add: addAll: addIfNotPresent:"removing" remove: remove:ifAbsent: removeAll: removeAllFoundIn: removeAllSuchThat: remove:ifAbsent:) do: [:sel | AddAndRemove add: sel]."SequenceableCollection"	#("comparing" hasEqualElements:"accessing" allButFirst allButLast at:ifAbsent: atAll: atPin: atRandom: atWrap: fifth first fourth identityIndexOf: identityIndexOf:ifAbsent: indexOf: indexOf:ifAbsent: indexOf:startingAt:ifAbsent: indexOfSubCollection:startingAt: indexOfSubCollection:startingAt:ifAbsent: last second sixth third"removing""copying" , copyAfterLast: copyAt:put: copyFrom:to: copyReplaceAll:with: copyReplaceFrom:to:with: copyUpTo: copyUpToLast: copyWith: copyWithout: copyWithoutAll: forceTo:paddingWith: shuffled sortBy:"enumerating" collectWithIndex: findFirst: findLast: pairsCollect: with:collect: withIndexCollect: polynomialEval:"converting" asArray asDictionary asFloatArray asIntegerArray asStringWithCr asWordArray reversed"private" copyReplaceAll:with:asTokens: ) do: [:sel | Approved add: sel].	#( swap:with:) do: [:sel | AddAndRemove add: sel]."ArrayedCollection, Bag"	#("private" defaultElement "sorting" isSorted"accessing" cumulativeCounts sortedCounts sortedElements "testing" "adding" add:withOccurrences: "removing" "enumerating" 	) do: [:sel | Approved add: sel].	#( mergeSortFrom:to:by: sort sort: add: add:withOccurrences:"private" setDictionary ) do: [:sel | AddAndRemove add: sel]."Other messages that modify the receiver"	#(atAll:put: atAll:putAll: atAllPut: atWrap:put: replaceAll:with: replaceFrom:to:with:  removeFirst removeLast) do: [:sel | AddAndRemove add: sel].	self initialize2."MethodFinder new initialize.MethodFinder new organizationFiltered: Set"! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 12/29/2000 13:22'!load: dataWithAnswers	"Find a function that takes the data and gives the answers.  Odd list entries are data for it, even ones are the answers.  nil input means data and answers were supplied already.""  (MethodFinder new) load: #( (4 3) 7  (-10 5) -5  (-3 11) 8);		findMessage  "dataWithAnswers ifNotNil: [	data _ Array new: dataWithAnswers size // 2.	1 to: data size do: [:ii | data at: ii put: (dataWithAnswers at: ii*2-1)].	answers _ Array new: data size.	1 to: answers size do: [:ii | answers at: ii put: (dataWithAnswers at: ii*2)]].data do: [:list | 	(list isKindOf: SequenceableCollection) ifFalse: [		^ self inform: 'first and third items are not Arrays'].	].argMap _ (1 to: data first size) asArray.data do: [:list | list size = argMap size ifFalse: [		self inform: 'data arrays must all be the same size']].argMap size > 4 ifTrue: [self inform: 'No more than a receiver and three arguments allowed'].	"Really only test receiver and three args." thisData _ data copy.mapStage _ mapList _ nil.! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 1/18/2001 23:41'!verify	"Test a bunch of examples"	"	MethodFinder new verify    "Approved ifNil: [self initialize].	"Sets of allowed selectors"(MethodFinder new load: #( (0) 0  (30) 0.5  (45) 0.707106  (90) 1)	) searchForOne asArray = #('data1 degreeSin') ifFalse: [self error: 'should have found it'].(MethodFinder new load:  { { true. [3]. [4]}. 3.  { false. [0]. [6]}. 6}	) searchForOne asArray = #('data1 ifTrue: data2 ifFalse: data3') ifFalse: [		self error: 'should have found it'].(MethodFinder new load: {#(1). true. #(2). false. #(5). true. #(10). false}	) searchForOne asArray = #('data1 odd') ifFalse: [self error: 'should have found it'].		"will correct the date type of #true, and complain"(MethodFinder new load: #((4 2) '2r100'   (255 16) '16rFF'    (14 8) '8r16')	) searchForOne asArray = 		#('data1 radix: data2' 'data1 printStringBase: data2' 'data1 storeStringBase: data2')			  ifFalse: [self error: 'should have found it'].	(MethodFinder new load: {{Point x: 3 y: 4}. 4.  {Point x: 1 y: 5}. 5}	) searchForOne asArray = #('data1 y') ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #(('abcd') $a  ('TedK') $T)	) searchForOne asArray = #('data1 asCharacter' 'data1 first' 'data1 anyOne')		 ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #(('abcd' 1) $a  ('Ted ' 3) $d )	) searchForOne asArray = #('data1 at: data2' 'data1 atPin: data2' 'data1 atWrap: data2')		ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #(((12 4 8)) 24  ((1 3 6)) 10 )	) searchForOne asArray=  #('data1 sum') ifFalse: [self error: 'should have found it'].			"note extra () needed for an Array object as an argument"(MethodFinder new load: #((14 3) 11  (-10 5) -15  (4 -3) 7)	) searchForOne asArray = #('data1 - data2') ifFalse: [self error: 'should have found it'].(MethodFinder new load: #((4) 4  (-10) 10 (-3) 3 (2) 2 (-6) 6 (612) 612)	) searchForOne asArray = #('data1 abs') ifFalse: [self error: 'should have found it'].(MethodFinder new load: {#(4 3). true.  #(-7 3). false.  #(5 1). true.  #(5 5). false}	) searchForOne asArray = #('data1 > data2') ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #((5) 0.2   (2) 0.5)	) searchForOne asArray = #('data1 reciprocal') ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #((12 4 8) 2  (1 3 6) 2  (5 2 16) 8)	) searchForOne asArray = #()     " '(data3 / data2) ' want to be able to leave out args"  		ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #((0.0) 0.0  (1.5) 0.997495  (0.75) 0.681639)	) searchForOne asArray = #('data1 sin') ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #((7 5) 2   (4 5) 4   (-9 4) 3)	) searchForOne asArray = #('data1 \\ data2') ifFalse: [self error: 'should have found it'].	! !!MethodFinder methodsFor: 'access' stamp: 'tk 12/29/2000 13:39'!answers	^ answers! !!MethodFinder methodsFor: 'access' stamp: 'tk 12/29/2000 13:39'!data	^ data! !!MethodFinder methodsFor: 'access' stamp: 'tk 12/29/2000 13:20'!expressions	^ expressions! !!MethodFinder methodsFor: 'access' stamp: 'tk 1/4/2001 17:18'!selectors	"Note the inst var does not have an S on the end"	^ selector! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 12/29/2000 22:34'!allNumbers	"Return true if all answers and all data are numbers."	answers do: [:aa | aa isNumber ifFalse: [^ false]].	thisData do: [:vec |			vec do: [:nn | nn isNumber ifFalse: [^ false]]].	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/18/2001 22:45'!const	| const |	"See if (^ constant) is the answer"	"quick test"	((const _ answers at: 1) closeTo: (answers at: 2)) ifFalse: [^ false].	3 to: answers size do: [:ii | (const closeTo: (answers at: ii)) ifFalse: [^ false]].	expressions add: '^ ', const printString.	selector add: #yourself.	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:49'!constDiv	| const subTest got |	"See if (data1 // C) is the answer"	const _ ((thisData at: 1) at: 1) // (answers at: 1).  "May not be right!!"	got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:48'!constEquiv	| const subTest got |	"See if (data1 = C) or (data1 ~= C) is the answer"	"quick test"	((answers at: 1) class superclass == Boolean) ifFalse: [^ false].	2 to: answers size do: [:ii | 		((answers at: ii) class superclass == Boolean) ifFalse: [^ false]].	const _ (thisData at: 1) at: 1.	got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: ["try other polarity for ~~ "		(ii _ answers indexOf: (answers at: 1) not) > 0 ifTrue: [		const _ (thisData at: ii) at: 1.		got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not]]. 	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:46'!constLessThan	| const subTest got minConst maxConst tt |	"See if (data1 <= C) or (data1 >= C) is the answer"	"quick test"	((answers at: 1) class superclass == Boolean) ifFalse: [^ false].	2 to: answers size do: [:ii | 		((answers at: ii) class superclass == Boolean) ifFalse: [^ false]].	minConst _ Float infinity.  maxConst _ minConst negated.	answers withIndexDo: [:aa :ii |		aa ifTrue: [tt _ (thisData at: ii) at: 1.			minConst _ minConst min: tt.			maxConst _ maxConst max: tt]].	const _ (thisData at: 1) at: 1.	got _ (subTest _ MethodFinder new copy: self addArg: minConst) 				searchForOne isEmpty not.	got ifFalse: ["try other extreme for <= >= "		got _ (subTest _ MethodFinder new copy: self addArg: maxConst) 				searchForOne isEmpty not]. 	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:47'!constLinear	| const subTest got denom num slope offset |	"See if (data1 * C1) + C2 is the answer.  In the form  #(C2 C1) polynomialEval: data1 "	denom _ ((thisData at: 2) at: 1) - ((thisData at: 1) at: 1).	denom = 0 ifTrue: [^ false].   "will divide by it"	num _ (answers at: 2) - (answers at: 1).    slope := (num asFloat / denom) reduce.    offset := ((answers at: 2) - (((thisData at: 2) at: 1) * slope)) reduce.	const _ Array with: offset with: slope.	got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/18/2001 22:46'!constMod	| subTest low |	"See if mod, (data1 \\ C) is the answer"	low _ answers max.	low+1 to: low+20 do: [:const |		subTest _ MethodFinder new copy: self addArg: const.		(subTest testPerfect: #\\) ifTrue: [			expressions add: 'data1 \\ ', const printString.			selector add: #\\.			^ true]].	^ false! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:49'!constMult	| const subTest got |	"See if (data1 * C) is the answer"	((thisData at: 1) at: 1) = 0 ifTrue: [^ false].	const _ ((answers at: 1) asFloat / ((thisData at: 1) at: 1)) reduce.	got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:48'!constPlus	| const subTest got |	"See if (data1 + C) is the answer"	const _ (answers at: 1) - ((thisData at: 1) at: 1).	got _ (subTest _ MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodFinder methodsFor: 'search' stamp: 'tk 1/8/2001 18:18'!exceptions	"Handle some very slippery selectors.	asSymbol -- want to be able to produce it, but do not want to make every string submitted into a Symbol!!" 	| aSel |	answers first class == Symbol ifFalse: [^ self].	thisData first first class == String ifFalse: [^ self].	aSel _ #asSymbol.	(self testPerfect: aSel) ifTrue: [		selector add: aSel.		expressions add: (String streamContents: [:strm | 			strm nextPutAll: 'data', argMap first printString.			aSel keywords doWithIndex: [:key :ind |				strm nextPutAll: ' ',key.				(key last == $:) | (key first isLetter not)					ifTrue: [strm nextPutAll: ' data', 						(argMap at: ind+1) printString]]])].! !!MethodFinder methodsFor: 'search' stamp: 'tk 1/8/2001 18:35'!findMessage	"Control the search."	data do: [:alist |		(alist isKindOf: SequenceableCollection) ifFalse: [			^ OrderedCollection with: 'first and third items are not Arrays']].	Approved ifNil: [self initialize].	"Sets of allowed selectors"	expressions _ OrderedCollection new.	self search: true.	"multi"	expressions isEmpty ifTrue: [^ OrderedCollection with: 'no single method does that function'].	expressions class = String ifTrue: [^ OrderedCollection with: expressions]. 	^ expressions! !!MethodFinder methodsFor: 'search' stamp: 'tk 1/4/2001 14:10'!insertConstants	"see if one of several known expressions will do it. C is the constant we discover here."	"C  data1+C  data1*C  data1//C  (data1*C1 + C2) (data1 = C) (data1 ~= C) (data1 <= C) (data1 >= C)  (data1 mod C)"	thisData size >= 2 ifFalse: [^ self].	"need 2 examples"	(thisData at: 1) size = 1 ifFalse: [^ self].	"only one arg, data1"	self const ifTrue: [^ self].	self constEquiv ifTrue: [^ self].	" ==  ~= "	self constLessThan ifTrue: [^ self].	" <=  and  >= "	self allNumbers ifFalse: [^ self].	self constMod ifTrue: [^ self].	self constPlus ifTrue: [^ self].	self constMult ifTrue: [^ self].	self constDiv ifTrue: [^ self].	self constLinear ifTrue: [^ self].! !!MethodFinder methodsFor: 'search' stamp: 'tk 12/29/2000 12:54'!search: multi	"if Multi is true, collect all selectors that work."	| old |	selector _ OrderedCollection new.	"list of them"	old _ Preferences autoAccessors.	Preferences disableGently: #autoAccessors.	self simpleSearch.	multi not & (selector isEmpty not) ifTrue:		[old ifTrue: [Preferences enableGently: #autoAccessors].		^ selector].	[self permuteArgs] whileTrue:		[self simpleSearch.		multi not & (selector isEmpty not) ifTrue:			[old ifTrue: [Preferences enableGently: #autoAccessors].			^ selector]].	self insertConstants.	old ifTrue: [Preferences enableGently: #autoAccessors].	"(selector isEmpty not) ifTrue: [^ selector]].    expression is the answer, not a selector"	^ #()! !!MethodFinder methodsFor: 'search' stamp: 'tk 1/8/2001 17:53'!searchForOne	"Look for and return just one answer"	expressions _ OrderedCollection new.	self search: false.	"non-multi"	^ expressions			! !!MethodFinder methodsFor: 'search' stamp: 'tk 1/8/2001 18:17'!simpleSearch	"Run through first arg's class' selectors, looking for one that works."| class supers listOfLists |self exceptions.class _ thisData first first class."Cache the selectors for the receiver class"(class == cachedClass and: [cachedArgNum = ((argMap size) - 1)]) 	ifTrue: [listOfLists _ cachedSelectorLists]	ifFalse: [supers _ class withAllSuperclasses.		listOfLists _ OrderedCollection new.		supers do: [:cls |			listOfLists add: (cls selectorsWithArgs: (argMap size) - 1)].		cachedClass _ class.		cachedArgNum _ (argMap size) - 1.		cachedSelectorLists _ listOfLists].listOfLists do: [:selectorList |	selectorList do: [:aSel |		(selector includes: aSel) ifFalse: [			((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [				(self testPerfect: aSel) ifTrue: [					selector add: aSel.					expressions add: (String streamContents: [:strm | 						strm nextPutAll: 'data', argMap first printString.						aSel keywords doWithIndex: [:key :ind |							strm nextPutAll: ' ',key.							(key last == $:) | (key first isLetter not)								ifTrue: [strm nextPutAll: ' data', 									(argMap at: ind+1) printString]]])					]]]]].! !!MethodFinder class methodsFor: 'as yet unclassified' stamp: 'tk 1/8/2001 18:17'!methodFor: dataAndAnswers	"Return a Squeak expression that computes these answers.  (This method is called by the comment in the bottom pane of a MethodFinder.  Do not delete this method.)"	| resultOC selFinder resultString |	resultOC _ (self new) load: dataAndAnswers; findMessage.	resultString _ String streamContents: [:strm |		resultOC do: [:exp | strm nextPut: $(; nextPutAll: exp; nextPut: $); space]].	Smalltalk isMorphic ifTrue: [		selFinder _ (Display bestGuessOfCurrentWorld 				submorphThat: [:mm | mm class == SystemWindow and: 									[mm model isKindOf: SelectorBrowser]] 				ifNone: [^ resultString]) model.		selFinder searchResult: resultOC].	^ resultString! !!Number methodsFor: 'as yet unclassified'!reduce    "If self is close to an integer, return that integer"    ^ self! !!Float methodsFor: 'truncation and round off' stamp: 'tk 12/30/2000 20:04'!reduce    "If self is close to an integer, return that integer"    (self closeTo: self rounded) ifTrue: [^ self rounded]! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 1/8/2001 18:21'!listFromResult: resultOC	"ResultOC is of the form #('(data1 op data2)' '(...)'). Answer a sorted array."	(resultOC first beginsWith: 'no single method') ifTrue: [^ #()].	^ resultOC sortBy: [:a :b | 		(a copyFrom: 6 to: a size) < (b copyFrom: 6 to: b size)].! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 1/8/2001 18:37'!quickList	"Compute the selectors for the single example of receiver and args, in the very top pane" 	| data result resultArray newExp dataStrings mf dataObjects aa |	data _ contents asString.	"delete trailing period. This should be fixed in the Parser!!" 	[data last isSeparator] whileTrue: [data _ data allButLast]. 	data last = $. ifTrue: [data _ data allButLast]. 	"Eval"	mf _ MethodFinder new.	data _ mf cleanInputs: data.	"remove common mistakes"	dataObjects _ Compiler evaluate: '{', data, '}'. "#( data1 data2 result )" 	dataStrings _ (Compiler new parse: 'zort ' , data in: Object notifying: nil)				block statements allButLast collect:				[:node | String streamContents:					[:strm | (node isKindOf: MessageNode) ifTrue: [strm nextPut: $(].					node printOn: strm indent: 0.					(node isKindOf: MessageNode) ifTrue: [strm nextPut: $)].]].	dataObjects size < 2 ifTrue: [self inform: 'If you are giving an example of receiver, \args, and result, please put periods between the parts.\Otherwise just type one selector fragment' withCRs. ^#()]. 	dataObjects _ Array with: dataObjects allButLast with: dataObjects last. "#( (data1 data2) result )" 	result _ mf load: dataObjects; findMessage.	(result first beginsWith: 'no single method') ifFalse: [		aa _ self testObjects: dataObjects strings: dataStrings.		dataObjects _ aa second.  dataStrings _ aa third].	resultArray _ self listFromResult: result. 	resultArray isEmpty ifTrue: [self inform: result first].	dataStrings size = (dataObjects first size + 1) ifTrue:		[resultArray _ resultArray collect: [:expression |		newExp _ expression.		dataObjects first withIndexDo: [:lit :i |			newExp _ newExp copyReplaceAll: 'data', i printString							with: (dataStrings at: i)].		newExp, ' --> ', dataStrings last]]. 	^ resultArray! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 1/18/2001 22:49'!selectedMessageName	"Answer the name of the currently selected message."	| example tokens |	selectorIndex = 0 ifTrue: [^nil].	example _ selectorList at: selectorIndex.	tokens _ Scanner new scanTokens: example.	tokens size = 1 ifTrue: [^ tokens first].	tokens first == #^ ifTrue: [^ nil].	(tokens second includes: $:) ifTrue: [^ example findSelector].	Symbol hasInterned: tokens second ifTrue: [:aSymbol | ^ aSymbol].	^ nil! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 1/18/2001 23:15'!testObjects: dataObjects strings: dataStrings	| dataObjs dataStrs selectors classes didUnmodifiedAnswer answerMod do ds result ddo dds |	"Try to make substitutions in the user's inputs and search for the selector again.1 no change to answer.2 answer Array -> OrderedCollection.2 answer Character -> String4 answer Symbol or String of len 1 -> Character	For each of these, try straight, and try converting args:Character -> StringSymbol or String of len 1 -> Character	Return array with result, dataObjects, dataStrings.  Don't ever do a find on the same set of data twice."dataObjs _ dataObjects.  dataStrs _ dataStrings.selectors _ {#asString. #first. #asOrderedCollection}.classes _ {Character. String. Array}.didUnmodifiedAnswer _ false.selectors withIndexDo: [:ansSel :ansInd | "Modify the answer object"	answerMod _ false.	do _ dataObjs copyTwoLevel.  ds _ dataStrs copy.	(dataObjs last isKindOf: (classes at: ansInd)) ifTrue: [		((ansSel ~~ #first) or: [dataObjs last size = 1]) ifTrue: [			do at: do size put: (do last perform: ansSel).	"asString"			ds at: ds size put: ds last, ' ', ansSel.			result _ MethodFinder new load: do; findMessage.			(result first beginsWith: 'no single method') ifFalse: [				"found a selector!!"				^ Array with: result first with: do with: ds].				answerMod _ true]].	selectors allButLast withIndexDo: [:argSel :argInd | "Modify an argument object"			"for args, no reason to do Array -> OrderedCollection.  Identical protocol."		didUnmodifiedAnswer not | answerMod ifTrue: [		ddo _ do copyTwoLevel.  dds _ ds copy.		dataObjs first withIndexDo: [:arg :ind |			(arg isKindOf: (classes at: argInd))  ifTrue: [				((argSel ~~ #first) or: [arg size = 1]) ifTrue: [					ddo first at: ind put: ((ddo first at: ind) perform: argSel).	"asString"					dds at: ind put: (dds at: ind), ' ', argSel.					result _ MethodFinder new load: ddo; findMessage.					(result first beginsWith: 'no single method') ifFalse: [						"found a selector!!"						^ Array with: result first with: ddo with: dds]	.						didUnmodifiedAnswer not & answerMod not ifTrue: [						didUnmodifiedAnswer _ true].					]]]]].	].^ Array with: 'no single method does that function' with: dataObjs with: dataStrs! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 12/27/2000 09:53'!polynomialEval: thisX	| sum valToPower |	"Treat myself as the coeficients of a polynomial in X.  Evaluate it with thisX.  First element is the constant and last is the coeficient for the highest power."	"  #(1 2 3) polynomialEval: 2   "   "is 3*X^2 + 2*X + 1 with X = 2"	sum _ self first.	valToPower _ thisX.	2 to: self size do: [:ind | 		sum _ sum + ((self at: ind) * valToPower).		valToPower _ valToPower * thisX].	^ sum! !MethodFinder removeSelector: #answers:!MethodFinder removeSelector: #data:!