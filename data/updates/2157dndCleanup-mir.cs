'From Squeak2.8alpha of 16 February 2000 [latest update: #2151] on 17 May 2000 at 12:16:13 am'!"Change Set:		dndSelectionCleanupDate:			16 May 2000Author:			Michael Rueger (m.rueger@acm.org)This change set cleans up redundant code/inst vars and inconsistent method names for handling selections and drag&drop operations.It delegates the color settings to the Preferences class.It also introduces a more generic usage of TransferMorph, delegating the decision about dnd parameters and actions to the models where possible."!Morph subclass: #HandMorph	instanceVariableNames: 'eventSubscribers keyboardFocus mouseDownMorph mouseOverMorphs mouseOverTimes dragOverMorphs clickClient clickState firstClickEvent firstClickTime userInitials lastEvent eventTransform argument targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset grid gridOn remoteConnections transmitBuffer lastEventTransmitted lastWorldExtent menuTargetOffset hasChanged savedPatch suppressDrawing formerOwner formerPosition addedFlexAtGrab '	classVariableNames: 'DoubleClickTime DragStartTime NormalCursor PasteBuffer '	poolDictionaries: ''	category: 'Morphic-Kernel'!StringMorph subclass: #IndentingListItemMorph	instanceVariableNames: 'indentLevel isExpanded complexContents firstChild container nextSibling highlightedForDrop isBeingDragged '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!BorderedMorph subclass: #PasteUpMorph	instanceVariableNames: 'presenter model cursor padding backgroundMorph turtleTrailsForm turtlePen lastTurtlePositions openToDragNDrop isPartsBin autoLineLayout indicateCursor resizeToFit fileName isStackLike dataInstances currentDataInstance userFrameRectangle wantsMouseOverHalos worldState '	classVariableNames: 'DisableDeferredUpdates MinCycleLapse StillAlive '	poolDictionaries: ''	category: 'Morphic-Worlds'!ScrollPane subclass: #PluggableListMorph	instanceVariableNames: 'list selectedMorph selection getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect font lastKeystrokeTime lastKeystrokes lastClickTime doubleClickSelector potentialDropMorph '	classVariableNames: 'DoubleClickTime '	poolDictionaries: ''	category: 'Morphic-Windows'!PolygonMorph subclass: #PolygonMorphDashed	instanceVariableNames: 'secondBorderWidth secondBorderColor firstBorderStepWidth secondBorderStepWidth '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!PolygonMorphDashed commentStamp: '<historical>' prior: 0!Main comment stating the purpose of this class and relevant relationship to other classes.| m |m _ (PolygonMorphDashed			vertices: (Array with: 0@0 with: 200@200)			color: (Color transparent)			firstBorderWidth: 1			secondBorderWidth: 1			firstBorderColor: Color black			secondBorderColor: Color white			firstBorderStepWidth: 10			secondBorderStepWidth: 3).m addHandles.m openInWorld.Structure: instVar1		type -- comment about the purpose of instVar1 instVar2		type -- comment about the purpose of instVar2Any further useful comments about the general approach of this implementation.!ScrollPane subclass: #SimpleHierarchicalListMorph	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect expandedForm notExpandedForm columns sortingSelector getSelectionSelector setSelectionSelector potentialDropMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!Morph subclass: #TransferMorph	instanceVariableNames: 'transferType passenger draggedMorph source dropNotifyRecipient accepted resultRecipient copy '	classVariableNames: 'CopyPlusIcon '	poolDictionaries: ''	category: 'Morphic-Support'!TransferMorph class	instanceVariableNames: ''!Morph subclass: #TransferMorphAnimation	instanceVariableNames: 'transferMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!TransferMorphAnimation class	instanceVariableNames: ''!TransferMorphAnimation subclass: #TransferMorphLineAnimation	instanceVariableNames: 'polygon '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!Object methodsFor: 'converting'!asDraggableMorph	^StringMorph contents: self printString! !!Object methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 16:03'!acceptDroppingMorph: transferMorph event: evt inMorph: dstListMorph 	self subclassResponsibility! !!Object methodsFor: 'drag and drop' stamp: 'mir 5/16/2000 11:35'!dragAnimationFor: item transferMorph: transferMorph 	"Default do nothing"! !!Object methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 16:20'!dragPassengerFor: item inMorph: dragSource 	^item! !!Object methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 16:11'!dragTransferType	^nil! !!Object methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 16:05'!dragTransferTypeForMorph: dragSource 	^nil! !!Object methodsFor: 'drag and drop' stamp: 'mir 5/8/2000 17:19'!wantsDroppedMorph: aMorph event: anEvent inMorph: destinationLM 	^false! !!Canvas methodsFor: 'drawing' stamp: 'sr 4/27/2000 03:31'!line: pt1 to: pt2 width: w1 color: c1 stepWidth: s1 secondWidth: w2 secondColor: c2 secondStepWidth: s2 	"Draw a line using the given width, colors and steps; both steps can  	have different stepWidths (firstStep, secondStep), draw widths and  	colors."	| bigSteps offsetPoint dist p1p2Vec deltaBig delta1 delta2 lastPoint bigStep |	s1 = 0 & (s2 = 0) ifTrue: [^ self].	dist _ pt1 dist: pt2.	dist = 0 ifTrue: [^ self].	bigStep _ s1 + s2.	bigSteps _ dist / bigStep.	p1p2Vec _ pt2 - pt1.	deltaBig _ p1p2Vec / bigSteps.	delta1 _ deltaBig * (s1 / bigStep).	delta2 _ deltaBig * (s2 / bigStep).	dist <= s1		ifTrue: 			[self				line: pt1 rounded				to: pt2 rounded				width: w1				color: c1.			^ self].	0 to: bigSteps truncated - 1 do: 		[:bigStepIx | 		self			line: (pt1 + (offsetPoint _ deltaBig * bigStepIx)) rounded			to: (pt1 + (offsetPoint _ offsetPoint + delta1)) rounded			width: w1			color: c1.		self			line: (pt1 + offsetPoint) rounded			to: (pt1 + (offsetPoint + delta2)) rounded			width: w2			color: c2].	"if there was no loop, offsetPoint is nil"	lastPoint _ pt1 + ((offsetPoint ifNil: [0 @ 0])					+ delta2).	(lastPoint dist: pt2)		<= s1		ifTrue: [self				line: lastPoint rounded				to: pt2 rounded				width: w1				color: c1]		ifFalse: 			[self				line: lastPoint rounded				to: (lastPoint + delta1) rounded				width: w1				color: c1.			self				line: (lastPoint + delta1) rounded				to: pt2				width: w1				color: c2]! !!Morph methodsFor: 'drawing' stamp: 'panda 4/28/2000 11:59'!drawDropHighlightOn: aCanvas	self highlightedForDrop ifTrue: [		aCanvas frameRectangle: self fullBounds color: self dropHighlightColor].! !!Morph methodsFor: 'drawing' stamp: 'mir 5/5/2000 11:34'!fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"	self visible ifFalse: [^ self].	(self hasProperty: #errorOnDraw) ifTrue:[^self drawErrorOn: aCanvas].	aCanvas drawMorph: self.	self drawSubmorphsOn:aCanvas.	self drawDropHighlightOn: aCanvas! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 10:51'!allowSubmorphExtraction	"Return true if this morph allows its submorphs to be extracted just by grabbing them. This default implementation returns false."	^self dragNDropEnabled		or: [self dragEnabled]! !!Morph methodsFor: 'dropping/grabbing'!asDraggableMorph	^self! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:41'!disableDragNDrop	self enableDragNDrop: false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:50'!dragEnabled	"Get this morph's ability to add and remove morphs via drag-n-drop."	^(self valueOfProperty: #dragEnabled) == true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:48'!dragNDropEnabled	"Get this morph's ability to add and remove morphs via drag-n-drop."	^(self valueOfProperty: #dragNDropEnabled) == true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 18:36'!dragSelectionColor	^ Color magenta! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:51'!dropEnabled	"Get this morph's ability to add and remove morphs via drag-n-drop."	^(self valueOfProperty: #dropEnabled) == true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 10:52'!dropHighlightColor	^ Color blue! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 18:08'!dropSuccessColor	^ Color blue! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:50'!enableDrag: aBoolean	self setProperty: #dragEnabled toValue: aBoolean! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:41'!enableDragNDrop	self enableDragNDrop: true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:54'!enableDragNDrop: aBoolean	self enableDrag: aBoolean.	self enableDrop: aBoolean.	self setProperty: #dragNDropEnabled toValue: aBoolean! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:51'!enableDrop: aBoolean	self setProperty: #dropEnabled toValue: aBoolean! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 11:51'!highlightForDrop	self highlightForDrop: true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 12:01'!highlightForDrop: aBoolean	self setProperty: #highlightedForDrop toValue: aBoolean.	self changed! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 10:53'!highlightedForDrop	^(self valueOfProperty: #highlightedForDrop) == true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 12:02'!resetHighlightForDrop	self highlightForDrop: false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:46'!toggleDragNDrop	"Toggle this morph's ability to add and remove morphs via drag-n-drop."		self enableDragNDrop: self dragNDropEnabled not.! !!Morph methodsFor: 'dropping/grabbing'!transportedMorph	^self! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 10:51'!wantsDroppedMorph: aMorph event: evt	"Return true if the receiver wishes to accept the given morph, which is being dropped by a hand in response to the given event. The default implementation returns false.NOTE: the event is assumed to be in global (world) coordinates."	^self dragNDropEnabled		or: [self dropEnabled]! !!AlignmentMorph methodsFor: 'initialization'!initialize	super initialize.	borderWidth _ 0.	orientation _ #horizontal.	"#horizontal or #vertical  or #free"	centering _ #topLeft.		"#topLeft, #center, or #bottomRight"	hResizing _ #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	vResizing _ #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	inset _ 2.					"pixels inset within owner's bounds"	minCellSize _ 0.				"minimum space between morphs; useful for tables"	layoutNeeded _ true.	color _ Color r: 0.8 g: 1.0 b: 0.8.! !!AlignmentMorph methodsFor: 'accessing' stamp: 'panda 4/25/2000 15:44'!configureForKids	self disableDragNDrop.	super configureForKids! !!AlignmentMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:47'!rootForGrabOf: aMorph	| root |	self dragNDropEnabled ifFalse: [^ super rootForGrabOf: aMorph].	root _ aMorph.	[root == self] whileFalse:		[root owner = self ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!AlignmentMorph methodsFor: 'menu' stamp: 'panda 4/25/2000 15:47'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'orientation...' action: #chooseOrientation.	aCustomMenu add: (self dragNDropEnabled ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #toggleDragNDrop.! !!BookMorph methodsFor: 'initialization' stamp: 'panda 4/25/2000 15:44'!closeCurrentPageToDragNDrop	currentPage ifNotNil: [currentPage disableDragNDrop]! !!BookMorph methodsFor: 'initialization' stamp: 'panda 4/25/2000 15:41'!setInitialState	orientation _ #vertical.	centering _ #topLeft.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	inset _ 5.	color _ Color white.	pageSize _ 160@300.	self enableDragNDrop! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:47'!rootForGrabOf: aMorph	| root |	self dragNDropEnabled ifFalse: [^ super rootForGrabOf: aMorph].	(aMorph = currentPage or: [aMorph owner = self])		ifTrue: [^ self rootForGrabOf: self].	root _ aMorph.	[root = self] whileFalse:		[root owner == currentPage ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!BookMorph methodsFor: 'menu' stamp: 'panda 4/25/2000 15:47'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu hand controlsShowing |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addList:		#(('sort pages'			sortPages)		('uncache page sorter'	uncachePageSorter)).	(self hasProperty: #dontWrapAtEnd)		ifTrue: [aMenu add: 'wrap after last page' selector: #setWrapPages: argument: true]		ifFalse: [aMenu add: 'stop at last page' selector: #setWrapPages: argument: false].	aMenu addList:		#(('make bookmark'		bookmarkForThisPage)		('make thumbnail'		thumbnailForThisPage)).	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue:			[aMenu add: 'hide page controls' action: #hidePageControls.			aMenu add: 'fewer page controls' action: #fewerPageControls]		ifFalse:			[aMenu add: 'show page controls' action: #showPageControls].	aMenu addLine.	aMenu add: 'sound effect for all pages' action: #menuPageSoundForAll:.	aMenu add: 'sound effect this page only' action: #menuPageSoundForThisPage:.	aMenu add: 'visual effect for all pages' action: #menuPageVisualForAll:.	aMenu add: 'visual effect this page only' action: #menuPageVisualForThisPage:.	aMenu addLine.	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'   action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (self dragNDropEnabled ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #toggleDragNDrop.	aMenu add: 'make all pages this size' action: #makeUniformPageSize.	aMenu add: 'search for text' action: #textSearch.	aMenu add: 'send all pages to server' action: #savePagesOnURL.	aMenu add: 'send this page to server' action: #saveOneOnURL.	aMenu add: 'reload all from server' action: #reload.	aMenu add: 'copy page url to clipboard' action: #copyUrl.	aMenu add: 'keep in one file' action: #keepTogether.	aMenu addLine.	aMenu add: 'load PPT images from slide #1' action: #loadImagesIntoBook.	aMenu add: 'background color for all pages...' action: #setPageColor.	hand _ self world primaryHand.	aMenu popUpAt: hand position forHand: hand! !!FreeCellBoard methodsFor: 'layout' stamp: 'panda 4/25/2000 15:42'!cardCell	^PlayingCardDeck new		layout: #pile; 		orientation: #vertical;		enableDragNDrop;		color: Color transparent;		borderColor: (Color gray alpha: 0.5);		borderWidth: 2;		yourself! !!FreeCellBoard methodsFor: 'layout' stamp: 'panda 4/25/2000 15:42'!stack	^ PlayingCardDeck new color: Color transparent;	 layout: #stagger;	 orientation: #vertical;	 enableDragNDrop;	 stackingPolicy: #altStraight;	 stackingOrder: #descending;	 emptyDropPolicy: #any;	 target: self;	 cardDroppedSelector: #cardMoved;	 cardDraggedSelector: #dragCard:fromStack:;	 acceptCardSelector: #acceptCard:onStack:;	 cardDoubleClickSelector: #doubleClickInStack:OnCard:! !!IndentingListItemMorph methodsFor: 'mouse events' stamp: 'mir 5/5/2000 11:53'!acceptDroppingMorph: toDrop event: evt. 	complexContents acceptDroppingObject: toDrop complexContents.	toDrop delete.	self clearDropHighlighting.! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'mir 5/5/2000 11:43'!drawOn: aCanvas	| tRect sRect columnRect columnScanner columnData columnLeft colorToUse |	tRect := self toggleRectangle.	sRect := bounds withLeft: tRect right + 3.	self drawToggleOn: aCanvas in: tRect.	colorToUse _ complexContents preferredColor ifNil: [color].	(container columns isNil or: [(contents asString indexOf: Character tab) = 0]) ifTrue: [		aCanvas text: contents asString bounds: sRect font: font color: colorToUse.	] ifFalse: [		columnLeft _ sRect left.		columnScanner _ ReadStream on: contents asString.		container columns do: [ :width |			columnRect _ columnLeft @ sRect top extent: width @ sRect height.			columnData _ columnScanner upTo: Character tab.			columnData isEmpty ifFalse: [				aCanvas text: columnData bounds: columnRect font: font color: colorToUse.			].			columnLeft _ columnRect right + 5.		].	]! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'panda 4/28/2000 15:30'!children	| children |	children _ OrderedCollection new.	self childrenDo: [:each | children add: each].	^children! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'panda 4/28/2000 15:29'!childrenDo: aBlock	firstChild ifNotNil: [		firstChild withSiblingsDo: [ :aNode | aBlock value: aNode].	]! !!PasteUpMorph methodsFor: 'initialization' stamp: 'ar 5/16/2000 23:58'!initialize	owner _ nil.	submorphs _ EmptyArray.	borderWidth _ 1.	borderColor _ Color r: 0.861 g: 1.0 b: 0.722.	color _ Color r: 0.8 g: 1.0 b: 0.6.	bounds _ 0@0 corner: 50@40.	cursor _ 1.	padding _ 3.	autoLineLayout _ false.	self enableDragNDrop.	self isWorldMorph ifTrue: [self setProperty: #automaticPhraseExpansion toValue: true]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:48'!allowSubmorphExtraction	^self dragNDropEnabled and: [isPartsBin ~~ true]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:48'!repelsMorph: aMorph event: ev	(Preferences systemWindowEmbedOK not and:		[aMorph isKindOf: SystemWindow]) ifTrue: [^ false].	(aMorph isKindOf: Viewer) ifTrue: [^ false].	self dragNDropEnabled ifFalse: [^ true].	(self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].	^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:49'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. If parts bin, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner == self ifTrue:			[self isPartsBin				ifTrue:					[(root renderedMorph isKindOf: MorphThumbnail)						ifTrue:							[^ root renderedMorph morphRepresented veryDeepCopy position: root renderedMorph position]						ifFalse:							[^ root topRendererOrSelf veryDeepCopy restoreSuspendedEventHandler ]].			self dragNDropEnabled					ifTrue: [^ root]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 5/17/2000 00:00'!wantsDroppedMorph: aMorph event: evt	aMorph willingToBeEmbeddedUponLanding ifFalse: [^ false].	self visible ifFalse: [^ false].  "will be a call to #hidden again very soon"	self dragNDropEnabled ifFalse: [^ false].	(self bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifFalse: [^ false].	((aMorph isKindOf: SystemWindow) and: [Preferences systemWindowEmbedOK not])		ifTrue:	[^ false].	((aMorph isKindOf: BookPageSorterMorph) and: [self isWorldMorph not])		ifTrue:	[^ false].	(aMorph isKindOf: Viewer) ifTrue: [^ self isWorldMorph].	^ true! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'panda 4/25/2000 15:48'!isOpenForDragNDropString	^ self dragNDropEnabled		ifTrue:			['stop being open to drag & drop']		ifFalse:			['start being open to drag & drop']! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'panda 4/25/2000 14:49'!playfieldOptionsMenu	| aMenu isWorld |	isWorld _ self isWorldMorph.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu add: 'save on file...' action: #saveOnFile.	aMenu add: 'save as SqueakPage at url...' action: #saveOnURL.	aMenu add: 'update all from resources' action: #updateAllFromResources.	(self valueOfProperty: #classAndMethod) ifNotNil:		[aMenu add: 'broadcast as documentation' action: #saveDocPane].	aMenu add: 'round up strays' action: #roundUpStrays.	aMenu balloonTextForLastItem:  'Bring back all objects whose current coordinates keep them from being visible, so that at least a portion of each of my interior objects can be seen.'.	aMenu addLine.	#(	(autoLineLayoutString	toggleAutoLineLayout			'whether submorphs should automatically be laid out in lines')		(indicateCursorString	toggleIndicateCursor			'whether the "current" submorph should be indicated with a dark black border')		(isPartsBinString		toggleIsPartsBin			'whether dragging an object from the interior should produce a COPY of the object')		(isOpenForDragNDropString	toggleDragNDrop			'whether objects can be dropped into and dragged out of me')		(mouseOverHalosString	toggleMouseOverHalos			'whether objects should put up halos when the mouse is over them')		(autoExpansionString	toggleAutomaticPhraseExpansion			'whether tile phrases, dropped on me, should automatically sprout Scriptors around them')		(originAtCenterString	toggleOriginAtCenter			'whether the cartesian origin of the playfield should be at its lower-left corner or at the center of the playfield')		(showThumbnailString	toggleAlwaysShowThumbnail			'whether large objects should be represented by thumbnail miniatures of themselves')) do:			[:triplet |				(isWorld and: [#(toggleAutoLineLayout toggleIndicateCursor toggleIsPartsBin toggleAlwaysShowThumbnail) includes: triplet second]) ifFalse:					[aMenu addUpdating: triplet first action: triplet second.					aMenu balloonTextForLastItem: triplet third]]. 	isWorld ifFalse:		[aMenu add: 'set thumbnail height...' action: #setThumbnailHeight.		aMenu balloonTextForLastItem: 'if currently showing thumbnails governs the standard height for them'].	aMenu addUpdating: #autoViewingString action: #toggleAutomaticViewing.	aMenu balloonTextForLastItem:  'governs whether, when an object is touched inside me, a viewer should automatically be launched for it.'.	isWorld ifFalse:		[aMenu add: 'behave like a Holder' action: #becomeLikeAHolder.		aMenu balloonTextForLastItem: 'Set properties to make this object nicely set up to hold frames of a scripted animation.'].	self backgroundSketch ifNotNil:		[aMenu add: 'delete background painting' action: #deleteBackgroundPainting.		aMenu balloonTextForLastItem: 'delete the graphic that forms the background for this me.'].	presenter ifNil:		[aMenu add: 'make detachable' action: #makeDetachable.		aMenu balloonTextForLastItem: 'Allow this area to be separately governed by its own controls.'].	aMenu addLine.	aMenu add: 'use standard texture' action: #setStandardTexture.	aMenu balloonTextForLastItem: 'use a pale yellow-and-blue background texture here.'.	aMenu add: 'make graph paper...' action: #makeGraphPaper.	aMenu balloonTextForLastItem: 'Design your own graph paper and use it as the background texture here.'.	aMenu addTitle: 'playfield options...'.	^ aMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'panda 4/25/2000 15:49'!wantsHaloFor: aSubMorph	"Answer whether the receiver wishes for a mouse-over halo to be produced for aSubMorph"	^ wantsMouseOverHalos == true and:		 [self visible and:			[isPartsBin ~~ true and:				[self dragNDropEnabled ~~ false and:					[self isWorldMorph not or: [aSubMorph renderedMorph isLikelyRecipientForMouseOverHalos]]]]]	"The odd logic at the end of the above says...		*  If we're an interior playfield, then if we're set up for mouseover halos, show em.		*  If we're a World that's set up for mouseover halos, only show 'em if the putative				recipient is a SketchMorph.	This (old) logic was put in to suit a particular need in early e-toy days and seems rather strange now!!"! !!PasteUpMorph methodsFor: 'options' stamp: 'panda 4/25/2000 15:42'!setPartsBinStatusTo: aBoolean	isPartsBin _ aBoolean.	aBoolean ifFalse: [self enableDragNDrop].		"but note that we no longer reset openToDragNDrop to false upon making it a parts bin again"	isPartsBin		ifTrue:			[submorphs do:				[:m | m isPartsDonor: true.					m stopStepping.					m suspendEventHandler]]		ifFalse:			[submorphs do:				[:m | m isPartsDonor: false.					m restoreSuspendedEventHandler].			self world ifNotNil: [self world startSteppingSubmorphsOf: self]]! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'panda 4/25/2000 15:49'!handlesMouseDown: evt	| editor |	^ (editor _ self topEditor)		ifNil:			[false]		ifNotNil:			[editor dragNDropEnabled]! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'panda 4/25/2000 15:42'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'expand time' action: #expandTime.	aCustomMenu add: 'contract time' action: #contractTime.	(self valueOfProperty: #dragNDropEnabled) == true		ifTrue: [aCustomMenu add: 'close drag and drop' action: #disableDragNDrop]		ifFalse: [aCustomMenu add: 'open drag and drop' action: #enableDragNDrop].! !!Player methodsFor: 'slots-kernel' stamp: 'ar 5/17/2000 00:00'!commandPhraseFor: commandSpec inViewer: aViewer	| entry aRow resultType cmd names argType argTile selfTile aPhrase |	entry _ (commandSpec copy asOrderedCollection removeFirst; yourself) asArray.	names _ self class namedTileScriptSelectors.	resultType _ (entry at: 1).	cmd _ (entry at: 2).	entry size = 2		ifTrue:			[aPhrase _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player]		ifFalse: 			[argType _ entry at: 3.			aPhrase _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player				argType: argType.			argTile _ self tileForArgType: argType inViewer: aViewer.			argTile position: aPhrase lastSubmorph position.			aPhrase lastSubmorph addMorph: argTile].	(names includes: cmd) ifTrue: [aPhrase userScriptSelector: cmd].	aPhrase markAsPartsDonor.	selfTile _ aViewer tileForSelf.	selfTile position: aPhrase firstSubmorph position.	aPhrase firstSubmorph addMorph: selfTile.	aRow _ ViewerRow newRow borderWidth: 0; color: aViewer color.	aRow elementSymbol: cmd asSymbol.	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 4@2; beTransparent).	aRow addMorphBack: (aViewer infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	aRow beSticky; disableDragNDrop.	^ aRow! !!PluggableListMorph methodsFor: 'initialization' stamp: 'panda 4/28/2000 18:14'!list: listOfStrings 	| morphList h loc index |	scroller removeAllMorphs.	list _ listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [self setScrollDeltas.  ^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	font ifNil: [font _ Preferences standardListFont].	morphList _ list collect:		[:item | item isText			ifTrue: [StringMorph contents: item font: font emphasis: (item emphasisAt: 1)]			ifFalse: [StringMorph contents: item font: font]].	"Lay items out vertically and install them in the scroller"	h _ morphList first height "self listItemHeight".	loc _ 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc _ loc + (0@h)].	scroller addAllMorphs: morphList.	self installEventHandlerOn: morphList.	index _ self getCurrentSelectionIndex.	self selectedMorph: ((index = 0 or: [index > morphList size]) ifTrue: [nil] ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0! !!PluggableListMorph methodsFor: 'events' stamp: 'mir 5/16/2000 16:50'!mouseDown: evt	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].! !!PluggableListMorph methodsFor: 'events' stamp: 'panda 4/28/2000 18:25'!mouseEnterDragging: anEvent onItem: aMorph 	anEvent hand hasSubmorphs ifFalse: ["no d&d"		^ self].	(self wantsDroppedMorph: anEvent hand firstSubmorph event: anEvent )		ifTrue: 			[self potentialDropMorph: aMorph]! !!PluggableListMorph methodsFor: 'events' stamp: 'panda 4/28/2000 11:50'!mouseLeaveDragging: anEvent onItem: aMorph 	anEvent hand hasSubmorphs ifFalse: ["no d&d"		^ self].	(self wantsDroppedMorph: anEvent hand firstSubmorph event: anEvent )		ifTrue: 			[self resetPotentialDropMorph]! !!PluggableListMorph methodsFor: 'events' stamp: 'mir 5/16/2000 16:49'!mouseMove: evt	self selectionIndex: 0! !!PluggableListMorph methodsFor: 'events' stamp: 'mir 5/5/2000 18:27'!mouseStillDown: evt onItem: item 	| dist |	evt redButtonPressed		ifTrue: 			[dist _ (evt targetPoint - item position) abs.			(dist x max: dist y)				> 5				ifTrue: 					["eventStatus _ #dragging."					self drag: evt itemMorph: item]]! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 16:03'!acceptDroppingMorph: aMorph event: evt 	"This message is sent when a morph is dropped onto a morph that has     	agreed to accept the dropped morph by responding 'true' to the     	wantsDroppedMorph:Event: message. The default implementation just     	adds the given morph to the receiver."	"Here we let the model do its work."	self model		acceptDroppingMorph: aMorph		event: evt		inMorph: self.	self resetPotentialDropMorph! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'mir 5/16/2000 11:37'!drag: evt itemMorph: itemMorph 	| ddm |	evt hand hasSubmorphs		ifTrue: [^self].	itemMorph ~= self selection ifTrue: [self setSelectedMorph: itemMorph].	ddm _ TransferMorph withPassenger: (self model dragPassengerFor: itemMorph inMorph: self) from: self.	ddm dragTransferType: (self model dragTransferTypeForMorph: self).	Preferences dragNDropWithAnimation			ifTrue: [self model dragAnimationFor: itemMorph transferMorph: ddm].	evt hand grabMorph: ddm! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 16:40'!enableDragNDrop: aBoolean	super enableDragNDrop: aBoolean.	aBoolean ifTrue: [self installEventHandlerOn: scroller submorphs]! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 18:15'!installEventHandlerOn: morphList	| handler |	handler _ EventHandler new.	handler on: #mouseDown send: #mouseDown:onItem: to: self.	self dragEnabled		ifTrue: [handler				on: #mouseStillDown				send: #mouseStillDown:onItem:				to: self].	self dropEnabled		ifTrue: 			[handler				on: #mouseEnterDragging				send: #mouseEnterDragging:onItem:				to: self.			handler				on: #mouseLeaveDragging				send: #mouseLeaveDragging:onItem:				to: self].	morphList do: [:m | m eventHandler: handler].! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'panda 4/25/2000 16:11'!potentialDropMorph	^potentialDropMorph! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 18:22'!potentialDropMorph: aMorph	potentialDropMorph _ aMorph.	aMorph highlightForDrop! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 12:01'!resetPotentialDropMorph	potentialDropMorph ifNotNil: [		potentialDropMorph resetHighlightForDrop.		potentialDropMorph _ nil]! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'panda 4/25/2000 18:26'!wantsDroppedMorph: aMorph event: anEvent 	^ self model wantsDroppedMorph: aMorph event: anEvent inMorph: self! !!PolygonMorphDashed methodsFor: 'initialization' stamp: 'sr 4/25/2000 21:37'!vertices: verts color: c firstBorderWidth: bw1 secondBorderWidth: bw2 firstBorderColor: bc1 secondBorderColor: bc2 firstBorderStepWidth: bs1 secondBorderStepWidth: bs2 	super		vertices: verts		color: c		borderWidth: bw1		borderColor: bc1.	secondBorderWidth _ bw2.	secondBorderColor _ bc2.	firstBorderStepWidth _ bs1.	secondBorderStepWidth _ bs2! !!PolygonMorphDashed methodsFor: 'accessing' stamp: 'mir 5/5/2000 16:49'!secondBorderColor	^secondBorderColor! !!PolygonMorphDashed methodsFor: 'accessing' stamp: 'mir 5/5/2000 16:44'!secondBorderColor: aColor	secondBorderColor _ aColor! !!PolygonMorphDashed methodsFor: 'accessing' stamp: 'mir 5/5/2000 16:49'!swapColors	| oldBorderColor |	oldBorderColor _ self borderColor.	self borderColor: self secondBorderColor.	self secondBorderColor: oldBorderColor! !!PolygonMorphDashed methodsFor: 'drawing' stamp: 'sr 4/25/2000 21:28'!drawBorderOn: aCanvas 	"Display my border on the canvas."	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	(borderColor == nil		or: [borderColor isColor and: [borderColor isTransparent]])		ifTrue: [^ self].	lineColor _ borderColor.	bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised		ifTrue: 			[topLeftColor _ color lighter.			bottomRightColor _ color darker.			bevel _ true].	borderColor == #inset		ifTrue: 			[topLeftColor _ owner colorForInsets darker.			bottomRightColor _ owner colorForInsets lighter.			bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth + 1 // 2.	brush _ nil.	self		lineSegmentsDo: 			[:p1 :p2 | 			p1i _ p1 asIntegerPoint.			p2i _ p2 asIntegerPoint.			(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"				((p1i min: p2i)					max: bigClipRect origin)					<= ((p1i max: p2i)							min: bigClipRect corner)])				ifTrue: 					[bevel						ifTrue: [(p1i quadrantOf: p2i)								> 2								ifTrue: [lineColor _ topLeftColor]								ifFalse: [lineColor _ bottomRightColor]].					(borderWidth > 3 and: [borderColor isColor])						ifTrue: 							[brush == nil ifTrue: [brush _ (ColorForm dotOfSize: borderWidth)											colors: (Array with: Color transparent with: borderColor)].							aCanvas								line: p1i								to: p2i								brushForm: brush]						ifFalse: [aCanvas								line: p1i								to: p2i								width: borderWidth								color: borderColor								stepWidth: firstBorderStepWidth								secondWidth: secondBorderWidth								secondColor: secondBorderColor								secondStepWidth: secondBorderStepWidth]]]! !!PolygonMorphDashed class methodsFor: 'as yet unclassified' stamp: 'sr 4/27/2000 18:54'!animationExample	"PolygonMorphDashed animationExample"	| m numOfAnimationSteps start stop stepVec s delay delayAtAll point animation |	m _ self				vertices: {Display boundingBox origin. Display boundingBox corner}				color: Color transparent				firstBorderWidth: 2				secondBorderWidth: 2				firstBorderColor: Color black				secondBorderColor: Color white				firstBorderStepWidth: 10				secondBorderStepWidth: 10.	m lock.	m openInWorld.	World refreshWorld.	(Delay forSeconds: 1) wait.	numOfAnimationSteps _ 25.	delayAtAll _ 1.	start _ m vertices at: 1.	stop _ m vertices at: 2.	start = stop ifTrue: [^ self].	stepVec _ stop - start / (numOfAnimationSteps + 1).	s _ Array new: numOfAnimationSteps.	1 to: numOfAnimationSteps do: 		[:step | 		point _ start + (step * stepVec).		"avoid problems"		s at: step put: (point = stop				ifTrue: 					[					stop - (1 @ 1)]				ifFalse: [point])].	delay _ Delay forSeconds: delayAtAll / numOfAnimationSteps.	animation _ 			[1 to: s size do: 				[:j | 				"Move to the next point"				m vertices at: 1 put: (s at: j).				"update"				m computeBounds.				"not necessary here since forked"				"	World refreshWorld."				"for fast machines"				delay wait].			m delete].	animation fork! !!PolygonMorphDashed class methodsFor: 'instance creation' stamp: 'sr 4/25/2000 21:37'!vertices: verts color: c firstBorderWidth: bw1 secondBorderWidth: bw2 firstBorderColor: bc1 secondBorderColor: bc2 firstBorderStepWidth: bs1 secondBorderStepWidth: bs2 	^ self basicNew		vertices: verts		color: c		firstBorderWidth: bw1		secondBorderWidth: bw2		firstBorderColor: bc1		secondBorderColor: bc2		firstBorderStepWidth: bs1		secondBorderStepWidth: bs2! !!Preferences class methodsFor: 'parameters' stamp: 'panda 4/25/2000 15:42'!editAnnotations	"Preferences editAnnotations"	| aPanel ins outs current aMorph aWindow aButton info pair |	Smalltalk isMorphic		ifFalse:			[^ self inform: 'Sorry, you must be in a morphicproject to use this feature.'].	aPanel _ AlignmentMorph newRow extent: 300 @ 100.	ins _ AlignmentMorph newColumn extent: 150 @ 100.	ins enableDragNDrop; beSticky.	ins color: Color green muchLighter.	outs _ ins fullCopy.	outs color: Color red muchLighter.	aPanel addMorph: outs; addMorphFront: ins.	outs position: (ins position + (200 @ 0)).	current _ self defaultAnnotationRequests.	info _ self annotationInfo.	current do:		[:sym | pair _ info detect: [:aPair | aPair first == sym].		aMorph _ StringMorph new contents: pair first.		aMorph setBalloonText: pair last.		ins addMorphBack: aMorph].	info do:		[:aPair | 			(current includes: aPair first) 				ifFalse:					[aMorph _ StringMorph new contents: aPair first.					aMorph setBalloonText: aPair last.					outs addMorph: aMorph]].	aPanel layoutChanged.	aWindow _ SystemWindowWithButton new setLabel: 'Annotations'.	aButton _ SimpleButtonMorph new target: Preferences;		actionSelector: #acceptAnnotationsFrom:; arguments: (Array with: aWindow); label: 'apply'; borderWidth: 0; borderColor: Color transparent; color: Color transparent.	aButton submorphs first color: Color blue.	aButton setBalloonText: 'After moving all the annotations you want to the left (green) side, and all the ones you do NOT want to the right (pink) side, hit this "apply" button to have your choices take effect.'.	aWindow buttonInTitle: aButton; adjustExtraButton.	self currentHand attachMorph: (aPanel wrappedInWindow: aWindow)! !!Preferences class methodsFor: 'help' stamp: 'mir 5/16/2000 11:51'!helpMsgsAdditionDnd	^ #((dragNDropWithAnimation	'If true, drag&drop is animated.'))! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 5/5/2000 15:19'!dragNDropWithAnimation	^ self valueOfFlag: #dragNDropWithAnimation! !!Preferences class methodsFor: 'initial values' stamp: 'mir 5/16/2000 11:52'!initialValuesAdditionDnd	^ #( (dragNDropWithAnimation false (browsing ) ) )! !!Presenter methodsFor: 'palette & parts bin' stamp: 'panda 4/25/2000 15:44'!newPageForStandardPartsBin	| aPage |	aPage _ PasteUpMorph new extent:  361@175.	aPage color: Color white; padding: 6.	aPage autoLineLayout: true.	aPage isPartsBin: true; disableDragNDrop.	aPage setProperty: #alwaysShowThumbnail toValue: true.	^ aPage! !!Presenter methodsFor: 'palette & parts bin' stamp: 'panda 4/25/2000 15:44'!newStandardPartsBinTitled: aTitle includeControls: includeControls	| aBook aPage aSize |	aSize _ 360 @ 190.	aBook _ BookMorph new color: Color blue veryMuchLighter.	aBook borderWidth: 0.	aBook removeEverything.	aBook disableDragNDrop.	includeControls ifTrue:		[aBook addMorphBack: (aBook makeMinimalControlsWithColor: Color transparent title: aTitle)].	self classNamesForStandardPartsBin do:		[:aList |			aPage _ self newPageForStandardPartsBin.			aList do:				[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].			aPage replaceTallSubmorphsByThumbnails.			aPage fixLayout.			aBook insertPage: aPage pageSize: aSize].	self customPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	self tilesPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	aBook goToPage: 1.	aBook currentPage addMorphBack: RectangleMorph roundRectPrototype.	^ aBook! !!ScorePlayerMorph methodsFor: 'layout' stamp: 'panda 4/25/2000 15:42'!makePianoRoll	"Create a piano roll viewer for this score player."	| pianoRoll hand |	pianoRoll _ PianoRollScoreMorph new on: scorePlayer.	hand _ self world activeHand.	hand ifNil: [self world addMorph: pianoRoll]		ifNotNil: [hand attachMorph: pianoRoll.				hand lastEvent shiftPressed ifTrue:					["Special case for NOBM demo"					pianoRoll contractTime; contractTime; enableDragNDrop]].	pianoRoll startStepping.! !!ScreeningMorph methodsFor: 'initialization' stamp: 'panda 4/25/2000 15:42'!initialize	super initialize.	passingColor _ Color black.	passElseBlock _ true.	displayMode _ #showScreened.	self enableDragNDrop! !!ScreeningMorph methodsFor: 'geometry' stamp: 'panda 4/25/2000 15:43'!layoutChanged	screenForm _ nil.	submorphs size >= 2		ifTrue: [self disableDragNDrop]		ifFalse: [self enableDragNDrop].	submorphs size = 2 ifTrue:		[bounds _ ((self sourceMorph bounds merge: self screenMorph bounds) expandBy: 4)].	^ super layoutChanged! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 14:15'!mouseEnter: evt	| hand tile |	hand _ evt hand.	(hand submorphs size = 1 and: [hand lastEvent redButtonPressed]) ifTrue:		[tile _ hand firstSubmorph.		(self wantsDroppedMorph: tile event: evt) ifTrue:			[(tile isKindOf: PhraseTileMorph) ifTrue: [tile brightenTiles].			handWithTile _ hand.			self startStepping]].! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 14:15'!wantsDroppedMorph: aMorph event: evt	^ (aMorph isTileLike and: [aMorph resultType == #command]) and:		[self isTextuallyCoded not]! !!BooleanScriptEditor methodsFor: 'as yet unclassified' stamp: 'ar 5/17/2000 00:04'!wantsDroppedMorph: aMorph event: evt	((aMorph isKindOf: PhraseTileMorph) and:		[submorphs size == 1]) ifTrue: [^ false].	^ aMorph isTileLike and: [aMorph resultType ~~ #command]! !!ScriptEvaluatorMorph methodsFor: 'initialization' stamp: 'panda 4/25/2000 15:43'!initializeFor: aPhraseTileMorph	| lm aStatus |	self playerScripted: aPhraseTileMorph actualObject.	scriptName _ aPhraseTileMorph userScriptSelector.	self removeAllMorphs.	self addMorphFront: (lm _ AlignmentMorph newRow).	lm color: Color transparent; inset: 0.	lm vResizing: #shrinkWrap.	lm addMorphBack: (ScriptingSystem tryButtonFor: aPhraseTileMorph).	lm addTransparentSpacerOfSize: 6@1.	lm addMorphBack: aPhraseTileMorph beSticky.	lm addTransparentSpacerOfSize: 4@1.		aStatus _ (playerScripted scriptInstantiationForSelector: scriptName) status.	lm addMorphBack:			(SimpleButtonMorph new label: aStatus font: Preferences standardButtonFont;				setNameTo: 'trigger';				target: self;				actWhen: #buttonDown;				actionSelector: #chooseTrigger).	lm addTransparentSpacerOfSize: 4@1.	self addDismissButtonTo: lm.	self disableDragNDrop.	lm enableDragNDrop! !!ScriptEvaluatorMorph methodsFor: 'drag and drop' stamp: 'panda 4/25/2000 14:15'!wantsDroppedMorph: aMorph event: evt	^ false   "though later we could drop onto formal args in the header"! !!SimpleHierarchicalListMorph methodsFor: 'initialization'!initialize	super initialize.	self on: #mouseStillDown send: #mouseStillDown:onItem: to: self! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'panda 4/28/2000 15:33'!list: aCollection	| wereExpanded morphList |	wereExpanded _ self currentlyExpanded.	scroller removeAllMorphs.	(aCollection isNil or: [aCollection isEmpty]) ifTrue: [^ self selectedMorph: nil].	morphList _ self 			morphsFromCollection: aCollection 			allowSorting: false			withExpandedItems: wereExpanded.	self insertNewMorphs: morphList.	self installEventHandlerOn: morphList! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'panda 4/28/2000 15:33'!expand: aMorph to: level	| allChildren |	aMorph toggleExpandedState.	allChildren _ OrderedCollection new: 10.	aMorph recursiveAddTo: allChildren.	allChildren do: [:each | 		((each canExpand			and: [each isExpanded not])			and: [level > 0])			ifTrue: [self expand: each to: level-1]].	self installEventHandlerOn: allChildren! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'panda 4/28/2000 15:33'!expandAll: aMorph except: aBlock	| allChildren |	(aBlock value: aMorph complexContents)		ifFalse: [^self].	aMorph toggleExpandedState.	allChildren _ OrderedCollection new: 10.	aMorph recursiveAddTo: allChildren.	allChildren do: [:each | 		(each canExpand			and: [each isExpanded not])			ifTrue: [self expandAll: each except: aBlock]].	self installEventHandlerOn: allChildren! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'panda 4/28/2000 15:34'!mouseDown: event onItem: aMorph	| oldState |	(aMorph inToggleArea: event) ifTrue: [		"self setSelectedMorph: aMorph."		event yellowButtonPressed ifTrue: [			oldState _ aMorph isExpanded.			scroller submorphs copy do: [ :each |				(each canExpand and: [each isExpanded = oldState]) ifTrue: [					each toggleExpandedState.					self installEventHandlerOn: each children.				].			].		] ifFalse: [			aMorph toggleExpandedState.			self installEventHandlerOn: aMorph children.		].		self adjustSubmorphPositions.		^self	].	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [aMorph == selectedMorph])		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'mir 5/8/2000 17:16'!mouseEnterDragging: anEvent onItem: aMorph 	anEvent hand hasSubmorphs ifFalse: ["no d&d"		^ self].	(self wantsDroppedMorph: anEvent hand firstSubmorph event: anEvent )		ifTrue: 			[self potentialDropMorph: aMorph]! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'panda 4/28/2000 11:50'!mouseLeaveDragging: anEvent onItem: aMorph 	anEvent hand hasSubmorphs ifFalse: ["no d&d"		^ self].	(self wantsDroppedMorph: anEvent hand firstSubmorph event: anEvent )		ifTrue: 			[self resetPotentialDropMorph]! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'mir 5/8/2000 14:17'!mouseStillDown: evt onItem: item 	| dist |	evt redButtonPressed		ifTrue: 			[dist _ (evt targetPoint - item position) abs.			(dist x max: dist y)				> 5				ifTrue: 					["eventStatus _ #dragging."					self drag: evt itemMorph: item]]! !!SimpleHierarchicalListMorph methodsFor: 'selection' stamp: 'panda 4/25/2000 18:56'!selectedMorph	^selectedMorph! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'mir 5/8/2000 17:22'!acceptDroppingMorph: aMorph event: evt	self model		acceptDroppingMorph: aMorph		event: evt		inMorph: self.	self resetPotentialDropMorph! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'mir 5/16/2000 11:36'!drag: evt itemMorph: itemMorph 	| ddm |	evt hand hasSubmorphs		ifTrue: [^self].	itemMorph ~= self selectedMorph ifTrue: [self setSelectedMorph: itemMorph].	ddm _ TransferMorph withPassenger: (self model dragPassengerFor: itemMorph inMorph: self) from: self.	ddm dragTransferType: (self model dragTransferTypeForMorph: self).	Preferences dragNDropWithAnimation			ifTrue: [self model dragAnimationFor: itemMorph transferMorph: ddm].	evt hand grabMorph: ddm! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 16:36'!enableDragNDrop: aBoolean	super enableDragNDrop: aBoolean.	aBoolean ifTrue: [self installEventHandlerOn: scroller submorphs]! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'mir 5/8/2000 15:49'!enableDrop: aBoolean	super enableDrop: aBoolean.	aBoolean ifTrue: [self installEventHandlerOn: scroller submorphs]! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'mir 5/8/2000 15:50'!installEventHandlerOn: morphList	| handler |	handler _ EventHandler new.	handler on: #mouseDown send: #mouseDown:onItem: to: self.	self dragEnabled		ifTrue: [handler				on: #mouseStillDown				send: #mouseStillDown:onItem:				to: self].	self dropEnabled		ifTrue: 			[handler				on: #mouseEnterDragging				send: #mouseEnterDragging:onItem:				to: self.			handler				on: #mouseLeaveDragging				send: #mouseLeaveDragging:onItem:				to: self].	morphList do: [:m | m eventHandler: handler].! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 17:39'!potentialDropMorph	^potentialDropMorph! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'mir 5/8/2000 15:37'!potentialDropMorph: aMorph	potentialDropMorph _ aMorph.	aMorph highlightForDrop! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'mir 5/8/2000 15:38'!resetPotentialDropMorph	potentialDropMorph ifNotNil: [		potentialDropMorph resetHighlightForDrop.		potentialDropMorph _ nil]! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 17:38'!wantsDroppedMorph: aMorph event: anEvent 	^ self model wantsDroppedMorph: aMorph event: anEvent inMorph: self! !!SoundDemoMorph methodsFor: 'as yet unclassified' stamp: 'panda 4/25/2000 15:43'!initialize	super initialize.	orientation _ #vertical.	centering _ #center.	hResizing _ #spaceFill.	vResizing _ #spaceFill.	inset _ 3.	color _ Color lightGray.	self borderWidth: 2.	self addMorph: self makeControls.	soundColumn _ AlignmentMorph newColumn.	soundColumn enableDragNDrop.	self addMorphBack: soundColumn.	self extent: 118@150.! !!TabbedPalette methodsFor: 'user-interface' stamp: 'panda 4/25/2000 15:49'!repelsMorph: aMorph event: ev	self visible ifFalse: [^ false].	^self dragNDropEnabled not! !!TransferMorph methodsFor: 'testing' stamp: 'mir 5/5/2000 14:39'!shouldCopy	^copy! !!TransferMorph methodsFor: 'private' stamp: 'mir 5/16/2000 11:14'!animationForMoveSuccess: success 	| start stop slideForm |	success		ifTrue: [			^self			"start _ self source bounds origin.			stop _ self draggedMorph bounds center"]		ifFalse: [			start _ self draggedMorph bounds center.			stop _ self source bounds origin].	start = stop ifTrue: [^ self].	slideForm _ self imageForm.	slideForm offset: 0 @ 0.	slideForm		slideFrom: start		to: stop		nSteps: 12		delay: 20! !!TransferMorph methodsFor: 'private' stamp: 'mir 5/16/2000 11:36'!initDraggedMorph	| plusMorph |	draggedMorph ifNil: [		draggedMorph _ self passenger asDraggableMorph.		self shouldCopy ifTrue: [			plusMorph _ ImageMorph new image: CopyPlusIcon.			draggedMorph addMorph: plusMorph.			plusMorph position: plusMorph width negated@0].		draggedMorph position: self position.		self extent: draggedMorph fullBounds extent.		self addMorph: draggedMorph]! !!TransferMorph methodsFor: 'private' stamp: 'mir 5/14/2000 00:11'!privateFullMoveBy: delta 	super privateFullMoveBy: delta.	self changed: #position! !!TransferMorph methodsFor: 'accessing' stamp: 'mir 5/5/2000 14:39'!copy	copy _ true! !!TransferMorph methodsFor: 'accessing' stamp: 'panda 4/28/2000 16:11'!dragTransferType	^transferType! !!TransferMorph methodsFor: 'accessing' stamp: 'panda 4/28/2000 16:11'!dragTransferType: aSymbol	transferType _ aSymbol! !!TransferMorph methodsFor: 'accessing' stamp: 'mir 5/5/2000 17:34'!draggedMorph	draggedMorph ifNil: [self initDraggedMorph].	^draggedMorph! !!TransferMorph methodsFor: 'accessing' stamp: 'panda 4/25/2000 16:31'!draggedMorph: aMorph	draggedMorph _ aMorph! !!TransferMorph methodsFor: 'accessing' stamp: 'sr 4/16/2000 18:52'!dropNotifyRecipient	^dropNotifyRecipient! !!TransferMorph methodsFor: 'accessing' stamp: 'panda 4/25/2000 16:14'!dropNotifyRecipient: anObject	dropNotifyRecipient _ anObject! !!TransferMorph methodsFor: 'accessing' stamp: 'mir 5/5/2000 14:39'!move	copy _ false! !!TransferMorph methodsFor: 'accessing' stamp: 'sr 4/16/2000 18:52'!passenger	^passenger! !!TransferMorph methodsFor: 'accessing' stamp: 'sr 4/16/2000 18:53'!passenger: anObject	passenger _ anObject! !!TransferMorph methodsFor: 'accessing' stamp: 'sr 4/16/2000 11:55'!source	^source! !!TransferMorph methodsFor: 'accessing' stamp: 'sr 4/16/2000 18:53'!source: anObject	source _ anObject! !!TransferMorph methodsFor: 'initialization' stamp: 'mir 5/16/2000 11:11'!initialize	super initialize.	self extent: 0@0.	accepted _ false.	copy _ false.	self color: Color veryLightGray! !!TransferMorph methodsFor: 'dropping/grabbing' stamp: 'mir 5/15/2000 18:10'!aboutToBeGrabbedBy: aHand 	"The receiver is being grabbed by a hand.                        	Perform necessary adjustments (if any) and return the actual morph    	  that should be added to the hand."	"Since this morph has been initialized automatically with bounds origin   	  0@0, we have to move it to aHand position."	self align: self bounds bottomLeft with: aHand position.	self draggedMorph.	self align: self bounds bottomLeft with: aHand position.! !!TransferMorph methodsFor: 'dropping/grabbing'!justDroppedInto: targetMorph event: anEvent 	"If only world wants this TransferMorph, treat it as unaccepted (see also >>delete)."	super justDroppedInto: targetMorph event: anEvent.	accepted _ targetMorph ~= self world.	self animationForMoveSuccess: accepted.	accepted ifTrue: [self dropNotifyRecipient ifNotNil: [self dropNotifyRecipient dropAcceptedMorph: self from: targetMorph]].	self delete! !!TransferMorph methodsFor: 'dropping/grabbing' stamp: 'sr 4/16/2000 18:53'!result: result 	^ self result: result from: nil! !!TransferMorph methodsFor: 'dropping/grabbing' stamp: 'sr 4/16/2000 15:08'!result: aResult from: aResultGenerator 	"Send aResult of the drop operation computed by aResultGenerator to a   	resultRecipient, if it exists."	self resultRecipient ifNotNil: [self resultRecipient dropResult: aResult from: aResultGenerator]! !!TransferMorph methodsFor: 'submorphs-add/remove' stamp: 'mir 5/15/2000 18:05'!delete	"See also >>justDroppedInto:event:."	accepted ifFalse: [self dropNotifyRecipient ifNotNil: [self dropNotifyRecipient dropRejectedMorph: self]].	self changed: #deleted.	self breakDependents.	super delete! !!TransferMorph class methodsFor: 'instance creation' stamp: 'sr 4/13/2000 21:52'!withPassenger: anObject 	^ self withPassenger: anObject from: nil! !!TransferMorph class methodsFor: 'instance creation' stamp: 'mir 5/6/2000 21:21'!withPassenger: anObject from: source 	| ddm |	ddm _ self new.	ddm passenger: anObject.	ddm source: source.	Sensor shiftPressed ifTrue: [ddm copy].	^ ddm! !!TransferMorph class methodsFor: 'class initialization' stamp: 'mir 5/5/2000 14:49'!initIcons	"TransferMorph initIcons"	CopyPlusIcon _ Form		extent: 16@16		depth: 8		fromArray: #( 0 0 65535 0 0 0 16768220 4278190080 0 0 16768220 4278190080 0 255 4294958300 4294967040 0 65500 3705461980 3705462015 0 65500 3705461980 3705462015 0 255 4294958300 4294967295 0 0 16768220 4278190080 0 0 16768220 4278190080 0 0 65535 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)		offset: 0@0! !!TransferMorph class methodsFor: 'class initialization' stamp: 'mir 5/5/2000 14:48'!initialize	"TransferMorph initialize"	self initIcons! !!TransferMorphAnimation methodsFor: 'update' stamp: 'mir 5/15/2000 18:05'!update: aSymbol		aSymbol == #deleted		ifTrue: [self delete].	aSymbol == #position		ifTrue: [self updateAnimation].	self changed! !!TransferMorphAnimation methodsFor: 'update' stamp: 'mir 5/15/2000 18:02'!updateAnimation! !!TransferMorphAnimation methodsFor: 'initialization' stamp: 'mir 5/15/2000 18:06'!on: aTransferMorph	self color: Color transparent.	transferMorph _ aTransferMorph.	transferMorph addDependent: self.	World currentWorld addMorph: self! !!TransferMorphAnimation methodsFor: 'accessing' stamp: 'mir 5/14/2000 00:10'!transferMorph	^transferMorph! !!TransferMorphAnimation class methodsFor: 'instance creation' stamp: 'mir 5/14/2000 00:07'!on: aTransferMorph	^self new on: aTransferMorph! !!TransferMorphLineAnimation methodsFor: 'initialization' stamp: 'mir 5/16/2000 11:40'!initPolygon	| polygonVertices |	polygonVertices _ Array with: self transferMorph source bounds center with: self transferMorph bounds center.	polygon _ PolygonMorphDashed				vertices: polygonVertices				color: Color transparent				firstBorderWidth: 1				secondBorderWidth: 1				firstBorderColor: Color black				secondBorderColor: Color white				firstBorderStepWidth: 10				secondBorderStepWidth: 10.	self addMorph: polygon"	aniMorph _ PluginAnimationMorph on: polygon.	aniMorph animation: [:currentState :animatedMorph | 			animatedMorph vertices at: 2 put: self transferMorph source center.			animatedMorph computeBounds.			animatedMorph swapColors]"! !!TransferMorphLineAnimation methodsFor: 'initialization' stamp: 'mir 5/14/2000 00:12'!on: aTransferMorph	super on: aTransferMorph.	self initPolygon! !!TransferMorphLineAnimation methodsFor: 'update' stamp: 'mir 5/15/2000 18:02'!updateAnimation	polygon vertices at: 2 put: self transferMorph center.	polygon computeBounds! !!WeekMorph methodsFor: 'all' stamp: 'ar 5/17/2000 00:06'!initialize	super initialize.	self		inset: 0;		color: Color transparent;		orientation: #horizontal;		disableDragNDrop;		height: 19;		week: Date today week month: Date today month! !!WonderlandCameraMorph methodsFor: 'menu' stamp: 'panda 4/25/2000 15:49'!getDragAndDropState	self dragNDropEnabled		ifTrue:[^'close to drag and drop']		ifFalse:[^'open to drag and drop']! !!WonderlandCameraMorph methodsFor: 'menu' stamp: 'panda 4/25/2000 15:43'!toggleDragAndDropState	self dragNDropEnabled		ifTrue:[self disableDragNDrop]		ifFalse:[self enableDragNDrop]! !WonderlandCameraMorph removeSelector: #openToDragAndDrop!TransferMorph initialize!ScriptEvaluatorMorph removeSelector: #wantsDroppedMorph:!BooleanScriptEditor removeSelector: #wantsDroppedMorph:!ScriptEditorMorph removeSelector: #wantsDroppedMorph:!IndexTabs removeSelector: #openToDragNDrop!PasteUpMorph removeSelector: #openToDragNDrop!PasteUpMorph removeSelector: #openToDragNDrop:!PasteUpMorph removeSelector: #toggleOpenToDragNDrop!MorphicModel removeSelector: #openToDragNDrop!MorphicModel removeSelector: #wantsDroppedMorph:event:!IndentingListItemMorph removeSelector: #clearDropHighlighting!IndentingListItemMorph removeSelector: #handlesMouseDown:!IndentingListItemMorph removeSelector: #handlesMouseOver:!IndentingListItemMorph removeSelector: #handlesMouseOverDragging:!IndentingListItemMorph removeSelector: #mouseDown:!IndentingListItemMorph removeSelector: #mouseEnter:!IndentingListItemMorph removeSelector: #mouseEnterDragging:!IndentingListItemMorph removeSelector: #mouseLeave:!IndentingListItemMorph removeSelector: #mouseLeaveDragging:!IndentingListItemMorph removeSelector: #noLongerBeingDragged!IndentingListItemMorph removeSelector: #wantsDroppedMorph:event:!StringMorph subclass: #IndentingListItemMorph	instanceVariableNames: 'indentLevel isExpanded complexContents firstChild container nextSibling '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!Morph subclass: #HandMorph	instanceVariableNames: 'eventSubscribers keyboardFocus mouseDownMorph mouseOverMorphs mouseOverTimes dragOverMorphs clickClient clickState firstClickEvent firstClickTime userInitials lastEvent eventTransform argument targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset grid gridOn remoteConnections transmitBuffer lastEventTransmitted lastWorldExtent menuTargetOffset hasChanged savedPatch suppressDrawing formerOwner formerPosition addedFlexAtGrab '	classVariableNames: 'DoubleClickTime NormalCursor PasteBuffer '	poolDictionaries: ''	category: 'Morphic-Kernel'!AlignmentMorph removeSelector: #allowSubmorphExtraction!AlignmentMorph removeSelector: #openCloseDragNDrop!AlignmentMorph removeSelector: #openToDragNDrop!AlignmentMorph removeSelector: #openToDragNDrop:!AlignmentMorph removeSelector: #wantsDroppedMorph:event:!Morph removeSelector: #closeDragAndDrop!Morph removeSelector: #openDragAndDrop!"Postscript:".Preferences absorbAdditions.!