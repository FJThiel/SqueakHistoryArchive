'From Squeak 2.0 of May 22, 1998 on 2 June 1998 at 4:28:28 pm'!"Change Set:		jhmTranslucencyDate:			2 June 1998Author:			John MaloneyA first cut at support translucent colors in Morphic,based on code by Michael Stevens. There are a numberof unresolved issues having to do with translucency, including:  1. If any pixel is painted multiple times, it gets gradually    darker. This results in various artifacts such as darker    bands in the middle of ellipses and strange effects during    resizing.  2. The hand caching code must be disabled in 32-bits.  3. It is slightly more expensive to decide what combination     rule to use; this affects performance at all depths. The     slowdown seems to be under five percent.  4. Images cannot be translucent.  5. Translucency only works with when the Display is in     32-bit mode. It would be nice if it worked at 16 bits and     it might potentially be useful at 8 bits, at least for translucent     grays. (There may not be enough color gradations in 8-bits     to get good color blending.)"!!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:38'!clipRect	^ clipRect translateBy: origin negated! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:38'!extent	^ Display extent! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:39'!form	^ Display! !!Canvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 06:59'!image: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self		image: aForm		at: aPoint		sourceRect: (0@0 extent: aForm extent)		rule: Form paint.! !!Canvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 06:48'!line: pt1 to: pt2 brushForm: brush	"Noop here; overridden by non-trivial canvases."! !!Color methodsFor: 'conversions' stamp: 'jm 6/2/1998 14:56'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val rgbBlack32 |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack _ 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val _ (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		rgbBlack32 _ 16rFF000001.  "closest black for 32-bit depth, with opaque alpha"		"eight bits per component; top 8 bits set to all ones (opaque)"		val _ (((rgb bitShift: -6) bitAnd: 16rFF0000) bitOr:			 ((rgb bitShift: -4) bitAnd: 16r00FF00)) bitOr:			 ((rgb bitShift: -2) bitAnd: 16r0000FF).		^ val = 0 ifTrue: [rgbBlack32] ifFalse: [16rFF000000 + val]].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val _ (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val _ (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:41'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	| rect fillC borderC |	rect _ r.	c isTransparent		ifTrue: [fillC _ nil]		ifFalse: [fillC _ self drawColor: c].	borderColor isTransparent		ifTrue: [			fillC == nil ifTrue: [^ self].  "both border and fill are transparent"			borderC _ nil.			rect _ rect insetBy: borderWidth]		ifFalse: [borderC _ self drawColor: borderColor].	port combinationRule:		(self drawRule: Form over color: c borderColor: borderColor).	port fillOval: (rect translateBy: origin)		color: fillC		borderWidth: borderWidth		borderColor: borderC.! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:33'!fillRectangle: r color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port fillRect: r color: (self drawColor: c) offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 15:41'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	| rule |	rule _ self drawRule: Form over color: fillColor borderColor: borderColor.	port combinationRule: rule.	borderColor isTransparent ifFalse: [		"draw border of rectangle"		(r area > 10000 or: [fillColor isTransparent or: [rule = Form blend]]) ifTrue: [			port frameRect: (r translateBy: origin)				borderWidth: borderWidth				borderColor: (self drawColor: borderColor).		] ifFalse: [			"for small rectangles, it's faster to fill the entire outer rectangle than to compute and fill the border rects"			port fillRect: r color: (self drawColor: borderColor) offset: origin]].	"fill the inside"	fillColor isTransparent ifFalse: [		port 	fillRect: (r insetBy: borderWidth)				color: (self drawColor: fillColor)				offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!frameRectangle: r width: w color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port frameRect: (r translateBy: origin)			borderWidth: w			borderColor: (self drawColor: c)].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!line: pt1 to: pt2 brushForm: brush	| offset |	offset _ origin.	port sourceForm: brush; fillColor: nil;		combinationRule: (self drawRule: Form paint color: Color black);		sourceRect: brush boundingBox;		colorMap: (brush colormapIfNeededForDepth: self depth);		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!line: pt1 to: pt2 width: w color: c	| offset |	offset _ origin - (w // 2) asPoint.	port sourceForm: nil;		fillColor: (self drawColor: c);		combinationRule: (self drawRule: Form over color: c);		width: w; height: w;		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!paragraph: para bounds: bounds color: c	| scanner |	scanner _ port displayScannerFor: para		foreground: (self drawColor: c)		background: Color transparent		rule: (self drawRule: Form paint color: c)		halftone: (shadowDrawing ifTrue: [self drawColor: c] ifFalse: [nil]).	para displayOn: self using: scanner at: (bounds topLeft + origin).! !!FormCanvas methodsFor: 'drawing' stamp: 'di 11/3/97 14:36'!text: s bounds: boundsRect font: fontOrNil color: c	| scanner |	scanner _ QuickPrint newOn: form				box: ((boundsRect translateBy: origin) intersect: clipRect) truncated				font: fontOrNil				color: (shadowDrawing ifTrue: [shadowStipple] ifFalse: [c]).	scanner drawString: s at: boundsRect topLeft + origin! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 15:27'!drawRule: defaultRule color: color	"Answer the BitBlt combination rule for the given default rule and color. If this canvas is in shadow-drawing mode, answer 'paint'. If the color is translucent, answer 'blend'. Otherwise, answer the given default rule."	shadowDrawing ifTrue: [^ Form paint].	form depth < 32 ifTrue: [^ defaultRule].	(color isColor and: [color alpha < 1.0])		ifTrue: [^ Form blend]		ifFalse: [^ defaultRule].! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 15:32'!drawRule: defaultRule color: color1 borderColor: color2	"Answer the BitBlt combination rule for the given default rule and colors. If this canvas is in shadow-drawing mode, answer 'paint'. If either color is translucent, answer 'blend'. Otherwise, answer the given default rule."	shadowDrawing ifTrue: [^ Form paint].	form depth < 32 ifTrue: [^ defaultRule].	(color1 isColor and: [color1 alpha < 1.0]) ifTrue: [^ Form blend].	(color2 isColor and: [color2 alpha < 1.0]) ifTrue: [^ Form blend].	^ defaultRule! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 06:40'!setOrigin: aPoint clipRect: aRectangle	super setOrigin: aPoint clipRect: aRectangle.	port clipRect: aRectangle.! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 06:41'!stipple: newStipple	shadowStipple _ newStipple.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:46'!test1	"FormCanvas test1"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color black).	canvas line: 10@10 to: 50@30 width: 1 color: (Color red).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color green).	canvas point: 100@100 color: (Color black).	canvas text: 'Hello, World!!' at: 40@40 font: nil color: (Color cyan).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color magenta).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color cyan).	canvas frameOval: ((40@80) corner: (61@121)) color: (Color blue).	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: (Color red alpha: 0.2).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightYellow).	canvas showAt: 0@0.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:11'!test2	"FormCanvas test2"	| baseCanvas p canvas |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	[Sensor anyButtonPressed] whileFalse: [		canvas _ baseCanvas copyOffset: (Sensor cursorPoint - p).		canvas fillColor: Color white.		canvas line: 10@10 to: 50@30 width: 1 color: Color red.		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.		canvas point: 100@100 color: Color black.		canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.		canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.		canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.		canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.		canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.		canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.		canvas showAt: 0@0].! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:14'!test3	"FormCanvas test3"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: Color white.	canvas _ canvas copyForShadowDrawingOffset: 10@10.	canvas line: 10@10 to: 50@30 width: 1 color: Color red.	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.	canvas point: 100@100 color: Color black.	canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.	canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.	canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.	canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.	canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.	canvas showAt: 0@0.! !!Morph methodsFor: 'accessing' stamp: 'jm 6/2/1998 15:54'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	^ color isColor and: [color alpha < 1.0]! !!BorderedMorph methodsFor: 'accessing' stamp: 'jm 6/2/1998 15:55'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	(color isColor and: [color alpha < 1.0]) ifTrue: [^ true].	(borderColor isColor and: [borderColor alpha < 1.0]) ifTrue: [^ true].	^ false! !!GradientFillMorph methodsFor: 'all' stamp: 'jm 6/2/1998 15:57'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	(color isColor and: [color alpha < 1.0]) ifTrue: [^ true].	(fillColor2 isColor and: [fillColor2 alpha < 1.0]) ifTrue: [^ true].	^ false! !!HandMorph methodsFor: 'drawing' stamp: 'jm 6/2/1998 16:06'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching myBnds shadowCanvas |	self suppressDisplay ifTrue: [^ self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue: [		cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	myBnds _ super fullBounds.  "my full bounds without my shadow"	self updateCacheCanvasDepth: aCanvas depth.	cacheCanvas ifNil: [		"could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	"Note: it's 3x faster to fill a rectangle rather than draw the shadow of a Form"	cachedCanvasHasHoles		ifTrue: [shadowCanvas image: cacheCanvas form at: myBnds origin]		ifFalse: [shadowCanvas fillRectangle: myBnds color: color].	"draw morphs in front of the shadow using the cached Form"	aCanvas image: cacheCanvas form at: myBnds origin.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'jm 6/2/1998 16:05'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| myBnds rectList c |	depth = 32 ifTrue: [		self allMorphsDo: [:m |			m hasTranslucentColor ifTrue: [				cacheCanvas _ nil.				cachedCanvasHasHoles _ nil.				^ self]]].	myBnds _ super fullBounds.  "my full bounds without my shadow"	(cacheCanvas == nil or: [cacheCanvas extent ~= myBnds extent]) ifTrue: [		cacheCanvas _ FormCanvas extent: myBnds extent depth: depth.		c _ cacheCanvas copyOffset: myBnds origin negated.		submorphs reverseDo: [:m | m fullDrawOn: c].		cachedCanvasHasHoles _ (cacheCanvas form tallyPixelValues at: 1) > 0.		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: myBnds extent).	damageRecorder reset.	rectList do: [:r |		c _ cacheCanvas copyOrigin: myBnds origin negated clipRect: r.		c fillColor: Color transparent.  "clear to transparent"		submorphs reverseDo: [:m | m fullDrawOn: c]].! !!TextMorph methodsFor: 'drawing' stamp: 'jm 6/2/1998 06:51'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size	ifTrue:		["make null text frame visible"		aCanvas fillRectangle: bounds color: Color lightRed]	ifFalse:		[aCanvas paragraph: self paragraph bounds: bounds color: color].! !!TextMorphForEditView methodsFor: 'all' stamp: 'jm 6/2/1998 06:52'!drawOn: aCanvas	self setDefaultContentsIfNil.	aCanvas paragraph: self paragraph bounds: bounds color: color.! !!TranslucentColor methodsFor: 'printing' stamp: 'jm 6/2/1998 08:26'!storeOn: aStream	super storeOn: aStream.	aStream		skip: -1;	  "get rid of trailing )"		nextPutAll: ' alpha: ';		nextPutAll: self alpha printString;		nextPutAll: ')'.! !!TranslucentColor methodsFor: 'conversions' stamp: 'jm 6/2/1998 08:35'!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works at a bit-depth of 32; this color will appear opaque at all other depths."	| basicPixelWord |	basicPixelWord _ super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !FormCanvas removeSelector: #image:at:!FormCanvas removeSelector: #newParagraph:bounds:color:!FormCanvas class removeSelector: #test4!FormCanvas class removeSelector: #test5!FormCanvas class removeSelector: #test!