'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5548] on 16 November 2003 at 2:45:19 pm'!"Change Set:		Babel-MoreTranslations-dgdDate:			16 November 2003Author:			Diego Gomez Deck <DiegoGomezDeck@ConsultAr.com>A small changeset that completes the biggest one already included.  With this changeset the 3.7a and the Small-Land image got synchronized related to translation stuff.8 conflicts was solved. Most of them was trivial changes in 5240MCP-Complete and one, not trivial, was in TextMorphEditor>>changeEmphasisOrAlignment"!!Color methodsFor: 'Morphic menu' stamp: 'dgd 10/17/2003 12:10'!addFillStyleMenuItems: aMenu hand: aHand from: aMorph	"Add the items for changing the current fill style of the receiver"	aMenu add: 'change color...' translated target: self selector: #changeColorIn:event: argument: aMorph! !!Morph methodsFor: 'genie-menu' stamp: 'dgd 10/17/2003 12:12'!addGenieMenuItems: aMenu hand: aHandMorph	"If the receiver wishes the Genie menu items, add a line to the menu and then those Genie items, else do nothing"	aMenu addLine.	aMenu add: 'change gesture dictionary' translated action: #changeGestureDictionary.	self gestureDictionary ifNotNil:		[aMenu add: 'inspect gesture dictionary' translated action: #inspectGestureDictionary.		self hasNotExportedGestureDictionary ifFalse: 			[aMenu add: 'make own copy of gesture dictionary' translated 				action: #makeOwnCopyOfGestureDictionary.			aMenu add: 'make own sub-gesture dictionary' translated 				action: #makeOwnSubGestureDictionary]].! !!Morph methodsFor: 'layout-menu' stamp: 'dgd 10/19/2003 11:23'!layoutMenuPropertyString: aSymbol from: currentSetting 	| onOff wording |	onOff := aSymbol == currentSetting				ifTrue: ['<on>']				ifFalse: ['<off>'].	""	wording := String				streamContents: [:stream | 					| index | 					index := 1.					aSymbol						keysAndValuesDo: [:idx :ch | ch isUppercase								ifTrue: [""stream nextPutAll: (aSymbol copyFrom: index to: idx - 1) asLowercase.									stream nextPutAll: ' '.									index := idx]].					index < aSymbol size						ifTrue: [stream nextPutAll: (aSymbol copyFrom: index to: aSymbol size) asLowercase]].	""	^ onOff , wording translated! !!Morph methodsFor: 'menus' stamp: 'dgd 10/17/2003 22:51'!adhereToEdge	| menu |	menu _ MenuMorph new defaultTarget: self.	#(top right bottom left - center - topLeft topRight bottomRight bottomLeft - none)		do: [:each |			each == #-				ifTrue: [menu addLine]				ifFalse: [menu add: each asString translated selector: #setToAdhereToEdge: argument: each]].	menu popUpEvent: self currentEvent in: self world! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:03'!bookmarkForThisPage	"If this book exists on a server, make the reference via a URL"	| bb url um |	(url _ self url) ifNil: [		bb _ SimpleButtonMorph new target: self.		bb actionSelector: #goToPageMorph:fromBookmark:.		bb label: 'Bookmark' translated.		bb arguments: (Array with: currentPage with: bb).		self primaryHand attachMorph: bb.		^ bb].	currentPage url ifNil: [currentPage saveOnURLbasic].	um _ URLMorph newForURL: currentPage url.	um setURL: currentPage url page: currentPage sqkPage.	(SqueakPage stemUrl: url) = (SqueakPage stemUrl: currentPage url) 		ifTrue: [um book: true]		ifFalse: [um book: url].  	"remember which book"	um isBookmark: true; label: 'Bookmark' translated.	um borderWidth: 1; borderColor: #raised.	um color: (Color r: 0.4 g: 0.8 b: 0.6).	self primaryHand attachMorph: um.	^ um! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:04'!buildThreadOfProjects	| thisPVM projectNames threadName |	projectNames _ pages collect: [ :each |		(thisPVM _ each findA: ProjectViewMorph) ifNil: [			nil		] ifNotNil: [			{thisPVM project name}.		].	].	projectNames _ projectNames reject: [ :each | each isNil].	threadName _ FillInTheBlank 		request: 'Please name this thread.' translated 		initialAnswer: (			self valueOfProperty: #nameOfThreadOfProjects ifAbsent: ['Projects on Parade' translated]		).	threadName isEmptyOrNil ifTrue: [^self].	InternalThreadNavigationMorph 		know: projectNames as: threadName;		openThreadNamed: threadName atIndex: nil.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:05'!copyUrl	"Copy this page's url to the clipboard"	| str |	str _ currentPage url ifNil: [str _ 'Page does not have a url.  Send page to server first.' translated].	Clipboard clipboardText: str asText.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:06'!getStemUrl	"Try to find the old place where this book was stored. Confirm with the 	user. Else ask for new place."	| initial pg url knownURL |	knownURL _ false.	initial _ ''.	(pg _ currentPage valueOfProperty: #SqueakPage)		ifNotNil: [pg contentsMorph == currentPage				ifTrue: [initial _ pg url.					knownURL _ true]].	"If this page has a url"	pages		doWithIndex: [:aPage :ind | initial isEmpty				ifTrue: [aPage isInMemory						ifTrue: [(pg _ aPage valueOfProperty: #SqueakPage)								ifNotNil: [initial _ pg url]]]].	"any page with a url"	initial isEmpty		ifTrue: [initial _ ServerDirectory defaultStemUrl , '1.sp'].	"A new legal place"	url _ knownURL		ifTrue: [initial]		ifFalse: [FillInTheBlank request: 'url of the place to store a typical page in this book.Must begin with file:// or ftp://' translated initialAnswer: initial].	^ SqueakPage stemUrl: url! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 12:59'!goToPage	| pageNum |	pageNum _ FillInTheBlank request: 'Page?' translated initialAnswer: '0'.	pageNum isEmptyOrNil ifTrue: [^true].	self goToPage: pageNum asNumber.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:39'!menuPageSoundFor: target event: evt	| tSpec menu |	tSpec _ self transitionSpecFor: target.	menu _ (MenuMorph entitled: ('Choose a sound(it is now {1})' translated format:{tSpec first asString translated})) defaultTarget: target.	SampledSound soundNames do:		[:soundName |		menu add: soundName asString translated target: target			selector: #setProperty:toValue:			argumentList: (Array with: #transitionSpec								with: (tSpec copy at: 1 put: soundName; yourself))].	menu popUpEvent: evt in: self world! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:39'!menuPageVisualFor: target event: evt	| tSpec menu subMenu directionChoices |	tSpec _ self transitionSpecFor: target.	menu _ (MenuMorph entitled: ('Choose an effect(it is now {1})' translated format:{tSpec second asString translated})) defaultTarget: target.	TransitionMorph allEffects do:		[:effect |		directionChoices _ TransitionMorph directionsForEffect: effect.		directionChoices isEmpty		ifTrue: [menu add: effect asString translated target: target					selector: #setProperty:toValue:					argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: #none))]		ifFalse: [subMenu _ MenuMorph new.				directionChoices do:					[:dir |					subMenu add: dir asString translated target: target						selector: #setProperty:toValue:						argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: dir))].				menu add: effect asString translated subMenu: subMenu]].	menu popUpEvent: evt in: self world! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:14'!reload	"Fetch the pages of this book from the server again.  For all pages that have not been modified, keep current ones.  Use new pages.  For each, look up in cache, if time there is equal to time of new, and its in, use the current morph.	Later do fancy things when a page has changed here, and also on the server."	| url onServer onPgs sq which |	(url _ self valueOfProperty: #url) ifNil: ["for .bo index file"	url _ FillInTheBlank 		request: 'url of the place where this book''s index is stored.Must begin with file:// or ftp://' translated		initialAnswer: (self getStemUrl, '.bo').	url notEmpty ifTrue: [self setProperty: #url toValue: url]				ifFalse: [^ self]].	onServer _ self class new fromURL: url.	"Later: test book times?"	onPgs _ onServer pages collect: [:out |		sq _ SqueakPageCache pageCache at: out url ifAbsent: [nil].		(sq notNil and: [sq contentsMorph isInMemory])			ifTrue: [((out sqkPage lastChangeTime > sq lastChangeTime) or: 					  [sq contentsMorph isNil]) 						ifTrue: [SqueakPageCache atURL: out url put: out sqkPage.							out]						ifFalse: [sq contentsMorph]]			ifFalse: [SqueakPageCache atURL: out url put: out sqkPage.				out]].	which _ (onPgs findFirst: [:pg | pg url = currentPage url]) max: 1.	self newPages: onPgs currentIndex: which.		"later stay at current page"	self setProperty: #modTime toValue: (onServer valueOfProperty: #modTime).	self setProperty: #allText toValue: (onServer valueOfProperty: #allText).	self setProperty: #allTextUrls toValue: (onServer valueOfProperty: #allTextUrls).! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:16'!saveIndexOfOnly: aPage	"Modify the index of this book on a server.  Read the index, modify the entry for just this page, and write back.  See saveIndexOnURL. (page file names must be unique even if they live in different directories.)"	| mine sf remoteFile strm remote pageURL num pre index after dict allText allTextUrls fName |	mine _ self valueOfProperty: #url.	mine ifNil: [^ self saveIndexOnURL].	Cursor wait showWhile: [strm _ (ServerFile new fullPath: mine)].	strm ifNil: [^ self saveIndexOnURL].	strm class == String ifTrue: [^ self saveIndexOnURL].	strm exists ifFalse: [^ self saveIndexOnURL].	"write whole thing if missing"	strm _ strm asStream.	strm class == String ifTrue: [^ self saveIndexOnURL].	remote _ strm fileInObjectAndCode.	dict _ remote first.	allText _ dict at: #allText ifAbsent: [nil].	"remote, not local"	allTextUrls _ dict at: #allTextUrls ifAbsent: [nil].	allText size + 1 ~= remote size ifTrue: [self error: '.bo size mismatch.  Please tell Ted what you just did to this book.' translated].	(pageURL _ aPage url) ifNil: [self error: 'just had one!!' translated].	fName _ pageURL copyAfterLast: $/.	2 to: remote size do: [:ii | 		((remote at: ii) url findString: fName startingAt: 1 						caseSensitive: false) > 0 ifTrue: [index _ ii].	"fast"		(remote at: ii) xxxReset].	index ifNil: ["new page, what existing page does it follow?"		num _ self pageNumberOf: aPage.		1 to: num-1 do: [:ii | (pages at: ii) url ifNotNil: [pre _ (pages at: ii) url]].		pre ifNil: [after _ remote size+1]			ifNotNil: ["look for it on disk, put me after"				pre _ pre copyAfterLast: $/.				2 to: remote size do: [:ii | 					((remote at: ii) url findString: pre startingAt: 1 								caseSensitive: false) > 0 ifTrue: [after _ ii+1]].				after ifNil: [after _ remote size+1]].		remote _ remote copyReplaceFrom: after to: after-1 with: #(1).		allText ifNotNil: [			dict at: #allText put: (allText copyReplaceFrom: after-1 to: after-2 with: #(())).			dict at: #allTextUrls put: (allTextUrls copyReplaceFrom: after-1 to: after-2 with: #(()))].		index _ after].	remote at: index put: (aPage sqkPage copyForSaving).	(dict at: #modTime ifAbsent: [0]) < Time totalSeconds ifTrue:		[dict at: #modTime put: Time totalSeconds].	allText ifNotNil: [		(dict at: #allText) at: index-1 put: (aPage allStringsAfter: nil).		(dict at: #allTextUrls) at: index-1 put: pageURL].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: remote.		"remoteFile close"].! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:18'!saveOnUrlPage: pageMorph	"Write out this single page in this book onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	| stem ind response rand newPlace dir |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.' translated.		^ self].	"Don't give the chance to put in a different place.  Assume named by number"	((self valueOfProperty: #url) isNil and: [pages first url notNil]) ifTrue: [		response _ (PopUpMenu labels: 'Old bookNew book sharing old pages' translated)				startUpWithCaption: 'Modify the old book, or make a newbook sharing its pages?' translated.		response = 2 ifTrue: [			"Make up new url for .bo file and confirm with user."  "Mark as shared"			[rand _ String new: 4.			1 to: rand size do: [:ii |				rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].			(newPlace _ self getStemUrl) isEmpty ifTrue: [^ self].			newPlace _ (newPlace copyUpToLast: $/), '/BK', rand, '.bo'.			dir _ ServerFile new fullPath: newPlace.			(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"			self setProperty: #url toValue: newPlace].		response = 0 ifTrue: [^ self]].	stem _ self getStemUrl.	"user must approve"	stem isEmpty ifTrue: [^ self].	ind _ pages identityIndexOf: pageMorph ifAbsent: [self error: 'where is the page?' translated].	pageMorph isInMemory ifTrue: ["not out now"			pageMorph saveOnURL: stem,(ind printString),'.sp'].	self saveIndexOfOnly: pageMorph.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:20'!savePagesOnURL	"Write out all pages in this book onto a server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are not in memory will stay that way.  The local disk could be the server."	| response list firstTime newPlace rand dir bookUrl |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.' translated.		^ self].	self getAllText.	"stored with index later"	response _ (PopUpMenu labels: 'Use page numbersType in file namesSave in a new place (using page numbers)Save in a new place (typing names)Save new book sharing old pages' translated)			startUpWithCaption: 'Each page will be a file on the server.  Do you want to page numbers be the names of the files? or name each one yourself?' translated.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 5 ifTrue: [		"Make up new url for .bo file and confirm with user."  "Mark as shared"		[rand _ String new: 4.		1 to: rand size do: [:ii |			rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].		(newPlace _ self getStemUrl) isEmpty ifTrue: [^ self].		newPlace _ (newPlace copyUpToLast: $/), '/BK', rand, '.bo'.		dir _ ServerFile new fullPath: newPlace.		(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"		self setProperty: #url toValue: newPlace.		self saveAsNumberedURLs. 		bookUrl _ self valueOfProperty: #url.		(SqueakPage stemUrl: bookUrl) = 			(SqueakPage stemUrl: currentPage url) ifTrue: [				bookUrl _ true].		"not a shared book"		(URLMorph grabURL: currentPage url) book: bookUrl.		^ self].	response = 0 ifTrue: [^ self]."self reserveUrlsIfNeeded.	Need two passes here -- name on one, write on second"pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage presenter ifNotNil: [aPage presenter flushPlayerListCache].		aPage saveOnURLbasic.		]].	"ask user if no url"list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).firstTime _ (self valueOfProperty: #url) isNil.self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	URLMorph grabForBook: self.	self setProperty: #futureUrl toValue: nil].	"clean up"! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 12:58'!textSearch	"search the text on all pages of this book"	| wanted wants list str |	list _ self valueOfProperty: #searchKey ifAbsent: [#()].	str _ String streamContents: [:strm | 			list do: [:each | strm nextPutAll: each; space]].	wanted _ FillInTheBlank request: 'words to search for.  Order is not important.Beginnings of words are OK.' translated		initialAnswer: str.	wants _ wanted findTokens: Character separators.	wants isEmpty ifTrue: [^ self].	self getAllText.		"save in allText, allTextUrls"	^ self findText: wants	"goes to the page and highlights the text"! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'dgd 10/26/2003 13:21'!addControls	| bb r aButton str |	r _ AlignmentMorph newRow color: Color transparent; borderWidth: 0; layoutInset: 0.	r wrapCentering: #center; cellPositioning: #topCenter; 			hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	bb _ SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (self wrapperFor: (bb label: 'Okay' translated;	actionSelector: #acceptSort)).	bb _ SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (self wrapperFor: (bb label: 'Cancel' translated;	actionSelector: #delete)).	r addTransparentSpacerOfSize: 8 @ 0.	r addMorphBack: (self wrapperFor: (aButton _ UpdatingThreePhaseButtonMorph checkBox)).	aButton		target: self;		actionSelector: #togglePartsBinStatus;		arguments: #();		getSelector: #getPartsBinStatus.	str _ StringMorph contents: 'Parts bin' translated.	r addMorphBack: (self wrapperFor: str lock).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'dgd 10/26/2003 13:22'!closeButtonOnly	"Replace my default control panel with one that has only a close button."	| b r |	self firstSubmorph delete.  "remove old control panel"	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; layoutInset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r wrapCentering: #topLeft.	r addMorphBack: (b label: 'Close' translated; actionSelector: #delete).	self addMorphFront: r.! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'dgd 10/26/2003 13:23'!objectForDataStream: refStrm	"I am about to be written on an object file.  It would be bad to write a whole BookMorph out.  Store a string that is the url of the book or page in my inst var."	| clone bookUrl bb stem ind |	(bookMorph class == String) & (page class == String) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph isNil) & (page class == String) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph isNil) & (page url notNil) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph isNil) & (page url isNil) ifTrue: [		self error: 'page should already have a url' translated.		"find page's book, and remember it"		"bookMorph _ "].		clone _ self clone.	(bookUrl _ bookMorph url)		ifNil: [bookUrl _ self valueOfProperty: #futureUrl].	bookUrl 		ifNil: [	bb _ RectangleMorph new.	"write out a dummy"			bb bounds: bounds.			refStrm replace: self with: bb.			^ bb]		ifNotNil: [clone instVarNamed: 'bookMorph' put: bookUrl].	page url ifNil: [			"Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."		stem _ SqueakPage stemUrl: bookUrl.		ind _ bookMorph pages identityIndexOf: page.		page reserveUrl: stem,(ind printString),'.sp'].	clone instVarNamed: 'page' put: page url.	refStrm replace: self with: clone.	^ clone! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'dgd 10/26/2003 13:23'!objectsInMemory	"See if page or bookMorph need to be brought in from a server."	| bookUrl bk wld try |	bookMorph ifNil: ["fetch the page"		page class == String ifFalse: [^ self].	"a morph"		try _ (SqueakPageCache atURL: page) fetchContents.		try ifNotNil: [page _ try].		^ self].	bookMorph class == String ifTrue: [		bookUrl _ bookMorph.		(wld _ self world) ifNil: [wld _ Smalltalk currentWorld].		bk _ BookMorph isInWorld: wld withUrl: bookUrl.		bk == #conflict ifTrue: [			^ self inform: 'This book is already open in some other project' translated].		bk == #out ifTrue: [			(bk _ BookMorph new fromURL: bookUrl) ifNil: [^ self]].		bookMorph _ bk].	page class == String ifTrue: [		page _ (bookMorph pages detect: [:pg | pg url = page] 					ifNone: [bookMorph pages first])].! !!FlapTab methodsFor: 'edge' stamp: 'dgd 10/17/2003 22:36'!setEdgeToAdhereTo	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	#(left top right bottom) do:		[:sym | aMenu add: sym asString translated target: self selector:  #setEdge: argument: sym].	aMenu popUpEvent: self currentEvent in: self world! !!OrientedFillStyle methodsFor: 'Morphic menu' stamp: 'dgd 10/17/2003 22:35'!addFillStyleMenuItems: aMenu hand: aHand from: aMorph	"Add the items for changing the current fill style of the receiver"	aMenu add: 'change origin' translated target: self selector: #changeOriginIn:event: argument: aMorph.	aMenu add: 'change orientation' translated target: self selector: #changeOrientationIn:event: argument: aMorph.! !!BitmapFillStyle methodsFor: 'Morphic menu' stamp: 'dgd 10/17/2003 22:34'!addFillStyleMenuItems: aMenu hand: aHand from: aMorph	"Add the items for changing the current fill style of the receiver"	aMenu add: 'choose new graphic' translated target: self selector: #chooseNewGraphicIn:event: argument: aMorph.	aMenu add: 'grab new graphic' translated target: self selector: #grabNewGraphicIn:event: argument: aMorph.	super addFillStyleMenuItems: aMenu hand: aHand from: aMorph.! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'dgd 10/17/2003 22:37'!addFillStyleMenuItems: aMenu hand: aHand from: aMorph	"Add the items for changing the current fill style of the receiver"	self isRadialFill ifTrue:[		aMenu add: 'linear gradient' translated target: self selector: #beLinearGradientIn: argument: aMorph.	] ifFalse:[		aMenu add: 'radial gradient' translated target: self selector: #beRadialGradientIn: argument: aMorph.	].	aMenu addLine.	aMenu add: 'change first color' translated target: self selector: #changeFirstColorIn:event: argument: aMorph.	aMenu add: 'change second color' translated target: self selector: #changeSecondColorIn:event: argument: aMorph.	aMenu addLine.	super addFillStyleMenuItems: aMenu hand: aHand from: aMorph.! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'dgd 10/17/2003 22:48'!addWorldHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu, given that the receiver is a World"	| unlockables |	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	self addWorldToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addPlayerItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addStackItemsTo: aMenu.	self adMiscExtrasTo: aMenu.	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aMenu hand: aHandMorph].	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: ('unlock "{1}"' translated format:{unlockables first externalName})action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' translated action: #unlockContents.		aMenu add: 'unlock...' translated action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!Preferences class methodsFor: 'misc' stamp: 'dgd 10/17/2003 12:14'!soundEnablingString	^ self soundsEnabled		ifFalse:			['turn sound on' translated]		ifTrue:			['turn sound off' translated]! !!TextMorphEditor methodsFor: 'attributes' stamp: 'dgd 11/16/2003 14:23'!changeEmphasisOrAlignment	| aList reply  code align menuList startIndex |	self flag: #arNote. "Move this up once we get rid of MVC"	startIndex _ self startIndex.	aList _ #(plain bold italic narrow underlined struckOut leftFlush centered rightFlush justified).		align _ paragraph text alignmentAt: startIndex 		ifAbsent:[paragraph textStyle alignment].	code _ paragraph text emphasisAt: startIndex.	menuList _ WriteStream on: Array new.	menuList nextPut: (code isZero ifTrue:['<on>'] ifFalse:['<off>']), 'plain' translated.	menuList nextPutAll: (#(bold italic underlined struckOut) collect:[:emph|		(code anyMask: (TextEmphasis perform: emph) emphasisCode)			ifTrue:['<on>', emph asString translated]			ifFalse:['<off>',emph asString translated]]).	((paragraph text attributesAt: startIndex forStyle: paragraph textStyle)		anySatisfy:[:attr| attr isKern and:[attr kern < 0]]) 			ifTrue:[menuList nextPut:'<on>', 'narrow' translated]			ifFalse:[menuList nextPut:'<off>', 'narrow' translated].	menuList nextPutAll: (#(leftFlush centered rightFlush justified) collectWithIndex:[:type :i|		align = (i-1)			ifTrue:['<on>',type asString translated]			ifFalse:['<off>',type asString translated]]).	aList _ #(plain bold italic underlined struckOut narrow leftFlush centered rightFlush justified).	reply _ (SelectionMenu labelList: menuList contents lines: #(1 6) selections: aList) startUpWithoutKeyboard.	reply notNil ifTrue:		[(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue:				[self setAlignment: reply.				paragraph composeAll.				self recomputeInterval]			ifFalse:				[self setEmphasis: reply.				paragraph composeAll.				self recomputeSelection.				self mvcRedisplay]].	^ true! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'dgd 10/17/2003 22:50'!setPrecision	"Allow the user to specify a number of decimal places.  This UI is invoked from a menu.  Nowadays the precision can be set by simple type-in, making this menu approach mostly obsolete.  However, it's still useful for read-only readouts, where type-in is not allowed."	| aMenu |	aMenu _ MenuMorph new.	aMenu addTitle: ('How many decimal places? (currently {1})' translated format: {self decimalPlaces}).	0 to: 5 do:		[:places |			aMenu add: places asString target: self selector: #setDecimalPlaces: argument: places].	aMenu popUpInWorld! !