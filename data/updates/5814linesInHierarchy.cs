'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5657] on 8 March 2004 at 8:47:19 pm'!"Change Set:		linesInHierarchyDate:			28 December 2002Author:			Steven SwerlingAdd a preference called showLinesInHierarchyViews. When true, faint lines are drawn in hierarchy views to make it more clear how the elements in the view are related. Added this version: Added drawing optimizations to the last version of this changeset, and a color fix. Also, incorporates Ned Konz's fix for list items that have icons (for the StarBrowser).19 Feb 2004 (Ned Konz):More geometry tweaks to avoid wrong line drawing.8 Mar 2004 (Ned Konz):Fixed up color again.Moved instance variables.Now caches toggle forms in a class instance variable instead of on instance side."!!IndentingListItemMorph commentStamp: '<historical>' prior: 0!An IndentingListItemMorph is a StringMorph that draws itself with an optional toggle at its left, as part of the display of the SimpleHierarchicalListMorph.It will also display lines around the toggle if the #showLinesInHierarchyViews Preference is set.Instance variables:indentLevel <SmallInteger> 	the indent level, from 0 at the root and increasing by 1 at each level of the hierarchy.isExpanded <Boolean>		true if this item is expanded (showing its children)complexContents <ListItemWrapper>	an adapter wrapping my represented item that can answer its children, etc.	firstChild <IndentingListItemMorph|nil>	my first child, or nil if none	container <SimpleHierarchicalListMorph>	my container	nextSibling <IndentingListItemMorph|nil>	the next item in the linked list of siblings, or nil if none.Contributed by Bob Arning as part of the ObjectExplorer package.Don't blame him if it's not perfect.  We wanted to get it out for people to play with.!ScrollPane subclass: #SimpleHierarchicalListMorph	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect expandedForm notExpandedForm columns sortingSelector getSelectionSelector setSelectionSelector potentialDropMorph lineColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!SimpleHierarchicalListMorph class	instanceVariableNames: 'notExpandedForm expandedForm '!!Color methodsFor: 'transformations' stamp: 'nk 3/8/2004 09:43'!atMostAsLuminentAs: aFloat	| revisedColor |	revisedColor _ self.	[revisedColor luminance > aFloat] whileTrue: [revisedColor _ revisedColor slightlyDarker].	^revisedColor! !!IndentingListItemMorph methodsFor: 'accessing' stamp: 'nk 3/8/2004 09:14'!isFirstItem	^owner submorphs first == self! !!IndentingListItemMorph methodsFor: 'accessing' stamp: 'nk 3/8/2004 09:15'!isSoleItem	^self isFirstItem and: [ owner submorphs size = 1 ]! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'nk 3/8/2004 11:25'!drawLineToggleToTextOn: aCanvas lineColor: lineColor hasToggle: hasToggle	"If I am not the only item in my container, draw the line between:		- my toggle (if any) or my left edge (if no toggle)		- and my text left edge"	| myBounds myCenter hLineY hLineLeft |	self isSoleItem ifTrue: [ ^self ].	myBounds := self toggleBounds.	myCenter := myBounds center.	hLineY := myCenter y.	hasToggle		ifTrue: [hLineLeft := myBounds right - 3]		ifFalse: [hLineLeft := myCenter x - 1].	"Draw line from toggle to text"	aCanvas		line: hLineLeft @ hLineY		to: myBounds right + 0 @ hLineY		width: 1		color: lineColor! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'nk 3/8/2004 11:43'!drawLinesOn: aCanvas lineColor: lineColor 	| hasToggle |	hasToggle _ self hasToggle.	"Draw line from toggle to text"	self drawLineToggleToTextOn: aCanvas lineColor: lineColor hasToggle: hasToggle.	"Draw the line from my toggle to the nextSibling's toggle"	self nextSibling ifNotNil: [ self drawLinesToNextSiblingOn: aCanvas lineColor: lineColor hasToggle: hasToggle ].	"If I have children and am expanded, draw a line to my first child"	(self firstChild notNil and: [ self isExpanded ])		ifTrue: [ self drawLinesToFirstChildOn: aCanvas lineColor: lineColor]! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'nk 3/8/2004 11:44'!drawLinesToFirstChildOn: aCanvas lineColor: lineColor 	"Draw line from me to next sibling"	| vLineX vLineTop vLineBottom childBounds childCenter |	childBounds := self firstChild toggleBounds.	childCenter := childBounds center.	vLineX := childCenter x - 1.	vLineTop := bounds bottom.	self firstChild hasToggle		ifTrue: [vLineBottom := childCenter y - 7]		ifFalse: [vLineBottom := childCenter y].	aCanvas		line: vLineX @ vLineTop		to: vLineX @ vLineBottom		width: 1		color: lineColor! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'nk 3/8/2004 11:41'!drawLinesToNextSiblingOn: aCanvas lineColor: lineColor hasToggle: hasToggle	| myBounds nextSibBounds vLineX myCenter vLineTop vLineBottom |	myBounds := self toggleBounds.	nextSibBounds := self nextSibling toggleBounds.	myCenter := myBounds center.	vLineX := myCenter x - 1.	hasToggle		ifTrue: [vLineTop := myCenter y + 5]		ifFalse: [vLineTop := myCenter y].	self nextSibling hasToggle		ifTrue: [vLineBottom := nextSibBounds top + 2 ]		ifFalse: [vLineBottom :=  nextSibBounds center y ].	"Draw line from me to next sibling"	aCanvas		line: vLineX @ vLineTop		to: vLineX @ vLineBottom		width: 1		color: lineColor! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'nk 7/10/2002 11:53'!drawOn: aCanvas	| tRect sRect columnRect columnScanner columnData columnLeft colorToUse |	tRect := self toggleRectangle.	sRect := bounds withLeft: tRect right + 4.	self drawToggleOn: aCanvas in: tRect.	colorToUse _ complexContents preferredColor ifNil: [color].	(container columns isNil or: [(contents asString indexOf: Character tab) = 0]) ifTrue: [		aCanvas drawString: contents asString in: sRect font: self fontToUse color: colorToUse.	] ifFalse: [		columnLeft _ sRect left.		columnScanner _ ReadStream on: contents asString.		container columns do: [ :width |			columnRect _ columnLeft @ sRect top extent: width @ sRect height.			columnData _ columnScanner upTo: Character tab.			columnData isEmpty ifFalse: [				aCanvas drawString: columnData in: columnRect font: self fontToUse color: colorToUse.			].			columnLeft _ columnRect right + 5.		].	]! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'nk 2/19/2004 18:19'!drawToggleOn: aCanvas in: aRectangle	| aForm centeringOffset |	complexContents hasContents ifFalse: [^self].	aForm _ isExpanded 		ifTrue: [container expandedForm]		ifFalse: [container notExpandedForm].	centeringOffset _ ((aRectangle height - aForm extent y) / 2.0) rounded.	^aCanvas 		paintImage: aForm 		at: (aRectangle topLeft translateBy: 0 @ centeringOffset).! !!IndentingListItemMorph methodsFor: 'private' stamp: 'nk 2/19/2004 18:29'!hasToggle	^ complexContents hasContents! !!IndentingListItemMorph methodsFor: 'private' stamp: 'nk 12/5/2002 15:16'!toggleBounds	^self toggleRectangle! !!SimpleHierarchicalListMorph methodsFor: 'accessing' stamp: 'nk 3/8/2004 09:55'!lineColor	"Answer a good color to use for drawing the lines that connect members of the hierarchy view.	Used the cached color, or derive it if necessary by finding the first owner (up to my root) that is not transparent, then picking a contrasting color.	Fall back to veryLightGray if all my owners are transparent."	| coloredOwner targetLuminance ownerColor darken |	lineColor ifNotNil: [ ^lineColor ].	coloredOwner _ self firstOwnerSuchThat: [ :o | o isWorldOrHandMorph not and: [ o color isTransparent not ]].	coloredOwner ifNil: [ ^Color veryLightGray ].	ownerColor _ coloredOwner color.	darken _ ownerColor luminance > 0.5.	targetLuminance _ ownerColor luminance + (darken ifTrue: [ -0.2 ] ifFalse: [ 0.2 ]).	^darken		ifTrue: [ ownerColor atMostAsLuminentAs: targetLuminance ]		ifFalse: [ ownerColor atLeastAsLuminentAs: targetLuminance ]	! !!SimpleHierarchicalListMorph methodsFor: 'accessing' stamp: 'sps 12/28/2002 02:27'!lineColor: aColor	^lineColor _ aColor! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'sps 12/22/2002 00:03'!drawLinesOn: aCanvas	| lColor |	lColor _ self lineColor.	aCanvas 		transformBy: scroller transform		clippingTo: scroller innerBounds		during:[:clippedCanvas |			scroller submorphs do: [ :submorph |				( 					(submorph isExpanded) or: [					(clippedCanvas isVisible: submorph fullBounds) or: [					(submorph nextSibling notNil and: [clippedCanvas isVisible: submorph nextSibling]) 				]]) ifTrue:[					submorph drawLinesOn: clippedCanvas lineColor: lColor.				]			].		]		smoothing: scroller smoothing.! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'sps 12/22/2002 00:05'!drawOn: aCanvas	super drawOn: aCanvas.	selectedMorph ifNotNil:		[aCanvas fillRectangle:			(((scroller transformFrom: self) invertBoundsRect: selectedMorph bounds)						intersect: scroller bounds)				color: color blacker].	Preferences showLinesInHierarchyViews ifTrue:[		self drawLinesOn: aCanvas.	].! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'nk 3/8/2004 10:05'!expandedForm	^self class expandedForm! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'nk 3/8/2004 10:06'!notExpandedForm	^self class notExpandedForm! !!SimpleHierarchicalListMorph class methodsFor: 'instance creation' stamp: 'nk 3/8/2004 10:05'!expandedForm	expandedForm ifNotNil: [ expandedForm depth ~= Display depth ifTrue: [ expandedForm _ nil ]].	^expandedForm ifNil: [expandedForm _ 			(Form				extent: 10@9				depth: 8				fromArray: #( 4294967295 4294967295 4294901760 4294967295 4294967295 4294901760 4278255873 16843009 16842752 4294902089 1229539657 33488896 4294967041 1229539585 4294901760 4294967295 21561855 4294901760 4294967295 4278321151 4294901760 4294967295 4294967295 4294901760 4294967295 4294967295 4294901760)				offset: 0@0)					asFormOfDepth: Display depth;					replaceColor: Color white withColor: Color transparent;					yourself	].! !!SimpleHierarchicalListMorph class methodsFor: 'instance creation' stamp: 'nk 3/8/2004 10:06'!notExpandedForm	notExpandedForm ifNotNil: [ notExpandedForm depth ~= Display depth ifTrue: [ notExpandedForm _ nil ]].	^notExpandedForm ifNil: [notExpandedForm _ 			(Form				extent: 10@9				depth: 8				fromArray: #( 4294967041 4294967295 4294901760 4294967041 33554431 4294901760 4294967041 1224867839 4294901760 4294967041 1229521407 4294901760 4294967041 1229539585 4294901760 4294967041 1229521407 4294901760 4294967041 1224867839 4294901760 4294967041 33554431 4294901760 4294967041 4294967295 4294901760)				offset: 0@0)					asFormOfDepth: Display depth;					replaceColor: Color white withColor: Color transparent;					yourself	].! !!TransformMorph methodsFor: 'accessing' stamp: 'sps 11/29/2002 17:03'!smoothing	^smoothing! !SimpleHierarchicalListMorph class	instanceVariableNames: 'expandedForm notExpandedForm'!ScrollPane subclass: #SimpleHierarchicalListMorph	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect columns sortingSelector getSelectionSelector setSelectionSelector potentialDropMorph lineColor'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!!SimpleHierarchicalListMorph reorganize!('accessing' columns columns: lineColor lineColor: sortingSelector:)('debug and other' installModelIn:)('drawing' drawLinesOn: drawOn: expandedForm highlightSelection notExpandedForm unhighlightSelection)('dropping/grabbing' acceptDroppingMorph:event: potentialDropMorph potentialDropMorph: resetPotentialDropMorph wantsDroppedMorph:event:)('event handling' handlesKeyboard: handlesMouseOverDragging: itemFromPoint: keyStroke: mouseDown: mouseEnter: mouseEnterDragging: mouseLeaveDragging: mouseMove: mouseUp: startDrag:)('events' expand:to: expandAll expandAll: expandAll:except: toggleExpandedState:event:)('events-processing' handleMouseMove:)('geometry' extent: scrollDeltaHeight)('initialization' autoDeselect: currentlyExpanded indentingItemClass initialize list: listItemHeight on:list:selected:changeSelected:menu:keystroke:)('keyboard navigation' arrowKey: getSelectionIndex setSelectionIndex: toggleExpandedState:)('model access' getList)('obsolete' mouseDown:onItem: mouseEnterDragging:onItem: mouseLeaveDragging:onItem: removeObsoleteEventHandlers startDrag:onItem:)('selection' getCurrentSelectionItem maximumSelection minimumSelection selectedMorph selectedMorph: selection: selectionIndex: selectionOneOf: setSelectedMorph:)('updating' update:)('private' addMorphsTo:from:allowSorting:withExpandedItems:atLevel: addSubmorphsAfter:fromCollection:allowSorting: adjustSubmorphPositions insertNewMorphs: noteRemovalOfAll:)!IndentingListItemMorph removeSelector: #drawLineToggleToTextOn:lineColor:!IndentingListItemMorph removeSelector: #drawLinesToNextSiblingOn:lineColor:!IndentingListItemMorph removeSelector: #lineColor!IndentingListItemMorph removeSelector: #recomputeAllForList:addingTo:withExpandedItems:!IndentingListItemMorph removeSelector: #recomputeForList:addingTo:withExpandedItems:!!IndentingListItemMorph reorganize!('accessing' balloonText canExpand children firstChild indentLevel isExpanded isExpanded: isFirstItem isSoleItem nextSibling nextSibling:)('converting' withoutListWrapper)('drag and drop' acceptDroppingMorph:event:)('drawing' drawLineToggleToTextOn:lineColor:hasToggle: drawLinesOn:lineColor: drawLinesToFirstChildOn:lineColor: drawLinesToNextSiblingOn:lineColor:hasToggle: drawOn: drawToggleOn:in: unhighlight)('enumeration' childrenDo:)('halos and balloon help' boundsForBalloon)('initialization' initWithContents:prior:forList:indentLevel: initialize)('mouse events' inToggleArea:)('private' hasToggle toggleBounds toggleRectangle withSiblingsDo:)('private-container protocol' addChildrenForList:addingTo:withExpandedItems: complexContents highlight openPath: recursiveAddTo: recursiveDelete toggleExpandedState)!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Preferences 	addPreference: #showLinesInHierarchyViews	category: #morphic	default: true 	balloonHelp: 'If true, lines are drawn in hierarchy views connecting items to their siblings and children.' .!