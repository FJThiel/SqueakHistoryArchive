'From Squeak 2.3 beta of Nov 25, 1998 on 13 December 1998 at 3:43:30 pm'!"Change Set:		MethodCacheByRowDate:			12 December 1998Author:			Dan IngallsA rearrangement of the Squeak method cache to see if it runs faster when organized by row.These changes are mingled with the AtCacheOnly changes."!!Interpreter methodsFor: 'method lookup cache' stamp: 'di 12/10/1998 21:38'!addToMethodCacheSel: selector class: class method: meth primIndex: primIndex	"Add the given entry to the method cache.	The policy is as follows:		Look for an empty entry anywhere in the reprobe chain.		If found, install the new entry there.		If not found, then install the new entry at the first probe position			and delete the entries in the rest of the reprobe chain.		This has two useful purposes:			If there is active contention over the first slot, the second				or third will likely be free for reentry after ejection.			Also, flushing is good when reprobe chains are getting full."	| probe hash |	self inline: false.	hash _ selector bitXor: class.  "drop low-order zeros from addresses"	0 to: CacheProbeMax-1 do:		[:p | probe _ ((hash >> p) bitAnd: MethodCacheMask) + 1.		(methodCache at: probe + MethodCacheSelector) = 0 ifTrue:				["Found an empty entry -- use it"				methodCache at: probe + MethodCacheSelector put: selector.				methodCache at: probe + MethodCacheClass put: class.				methodCache at: probe + MethodCacheMethod put: meth.				methodCache at: probe + MethodCachePrim put: primIndex.				^ nil]].	"OK, we failed to find an entry -- install at the first slot..."	probe _ (hash bitAnd: MethodCacheMask) + 1.  "first probe"	methodCache at: probe + MethodCacheSelector put: selector.	methodCache at: probe + MethodCacheClass put: class.	methodCache at: probe + MethodCacheMethod put: meth.	methodCache at: probe + MethodCachePrim put: primIndex.	"...and zap the following entries"	1 to: CacheProbeMax-1 do:		[:p | probe _ ((hash >> p) bitAnd: MethodCacheMask) + 1.		methodCache at: probe + MethodCacheSelector put: 0].! !!Interpreter methodsFor: 'method lookup cache' stamp: 'di 12/12/1998 23:37'!flushMethodCache	"Flush the method cache. The method cache is flushed on every programming change and garbage collect."	1 to: MethodCacheSize do: [ :i | methodCache at: i put: 0 ].	1 to: AtCacheTotalSize do: [ :i | atCache at: i put: 0 ].! !!Interpreter methodsFor: 'method lookup cache' stamp: 'di 12/10/1998 21:23'!lookupInMethodCacheSel: selector class: class	"This method implements a simple method lookup cache. If an entry for the given selector and class is found in the cache, set the values of 'newMethod' and 'primitiveIndex' and return true. Otherwise, return false."	"About the re-probe scheme: The hash is the low bits of the XOR of two large addresses, minus their useless lowest two bits. If a probe doesn't get a hit, the hash is shifted right one bit to compute the next probe, introducing a new randomish bit. The cache is probed CacheProbeMax times before giving up."	"WARNING: Since the hash computation is based on the object addresses of the class and selector, we must rehash or flush when compacting storage. We've chosen to flush, since that also saves the trouble of updating the addresses of the objects in the cache."	| hash probe |	self inline: true.	hash _ selector bitXor: class.  "shift drops two low-order zeros from addresses"	probe _ (hash bitAnd: MethodCacheMask) + 1.  "first probe"	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			^ true	"found entry in cache; done"].	probe _ ((hash >> 1) bitAnd: MethodCacheMask) + 1.  "second probe"	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			^ true	"found entry in cache; done"].	probe _ ((hash >> 2) bitAnd: MethodCacheMask) + 1.	(((methodCache at: probe + MethodCacheSelector) = selector) and:		 [(methodCache at: probe + MethodCacheClass) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethod.			primitiveIndex _ methodCache at: probe + MethodCachePrim.			^ true	"found entry in cache; done"].	^ false! !!Interpreter methodsFor: 'other primitives' stamp: 'di 12/10/1998 22:03'!primitiveFlushCacheSelective	"The receiver is a message selector.  Clear all entries in the method lookup cache with this selector, presumably because an associated method has been redefined."	| selector probe |	selector _ self stackTop.	probe _ 1.	1 to: MethodCacheEntries do:		[:i | (methodCache at: probe + MethodCacheSelector) = selector ifTrue:			[methodCache at: probe + MethodCacheSelector put: 0].		probe _ probe + MethodCacheEntrySize]! !!Interpreter class methodsFor: 'initialization' stamp: 'di 12/12/1998 23:39'!initializeCaches 	| atCacheEntrySize |	MethodCacheEntries _ 512. 	MethodCacheSelector _ 0.	MethodCacheClass _ 1.	MethodCacheMethod _ 2.	MethodCachePrim _ 3.	MethodCacheEntrySize _ 4.  "Must be power of two for masking scheme."	MethodCacheMask _ (MethodCacheEntries - 1) * MethodCacheEntrySize.	MethodCacheSize _ MethodCacheEntries * MethodCacheEntrySize.	CacheProbeMax _ 3.	AtCacheEntries _ 8.  "Must be power of two"	AtCacheOop _ 0.	AtCacheSize _ 1.	AtCacheFmt _ 2.	AtCacheFixedFields _ 3.	atCacheEntrySize _ 4.  "Must be power of two for masking scheme."	AtCacheMask _ (AtCacheEntries-1) * atCacheEntrySize.	AtPutBase _ AtCacheEntries * atCacheEntrySize.	AtCacheTotalSize _ AtCacheEntries * atCacheEntrySize * 2.! !