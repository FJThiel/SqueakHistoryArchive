'From R&DSqueak2.8 of 6 June 2001 [latest update: #28] on 26 November 2001 at 7:46:18 am'!"Change Set:		jpegMovie-jmDate:			26 November 2001Author:			John MaloneyExploits the new fast JPEG plugin to support a new, compressedmovie format: JPEG movies. A JPEG movie file (usually endingin '.jmv') contains a header, the JPEG compressed frames of themovie, and possibly one or more sound tracks. Like a Squeakmovie--and unlike an MPEG movie--JPEG movies can be created,manipulated, and edited using only Squeak. However, they aremuch, much smaller than Squeak movies. For example, aseveral minute clip from Fantasia ('Night on Bald Mountain')shrunk from about 176 to under 6 megabytes. On the other hand,JPEG movies tend to be 1.5 to 3.0 times the size of an MPEG movieat a similar quality level.The class JPEGMovieFile contains methods for converting bothMPEG or Squeak movies into JPEG movies. JPEGMovieFile implementsa subset of the MPEGFile protocol so that JPEG movies can beplayed by MPEGMoviePlayerMorph.Also included in this changeset:  1. the ability to resize the movie display (use the yellow halo)  2. improved sound/picture sync that is robust in the face of     sound pauses induced by OS activities"!Object subclass: #JPEGMovieFile	instanceVariableNames: 'file movieExtent frameRate frameOffsets currentFrameIndex soundtrackOffsets '	classVariableNames: ''	poolDictionaries: ''	category: 'MPEG3-Kernel'!!JPEGMovieFile commentStamp: 'jm 11/20/2001 15:51' prior: 0!A JPEG movie file consists of a header followed by a sequence of JPEG-compressed images followed by one or more sound tracks. It responds to a subset of the protocol for MPEGFile so that a JPEG movie can be played by MPEGDisplayMorph as if it were an MPEG movie.!!JPEGMovieFile methodsFor: 'initialization' stamp: 'jm 11/15/2001 08:13'!initialize	file _ nil.	frameOffsets _ #().	currentFrameIndex _ 1.! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 11/14/2001 14:08'!closeFile	"Close my file stream."	file ifNotNil: [file close].! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 11/14/2001 14:13'!fileHandle	"Answer my file, or nil if the file is not open."	file ifNil: [^ nil].	file closed ifTrue: [^ nil].	^ file! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 11/15/2001 07:59'!fileName	"Answer the name of my file."	file ifNil: [^ ''].	^ file fullName! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 11/16/2001 15:52'!openFileNamed: fileName	"Open the JPEG movie file with the given name."	file ifNotNil: [file close].	file _ nil.	(FileDirectory default fileExists: fileName) ifFalse: [^ self].	file _ (FileStream readOnlyFileNamed: fileName) binary.	self readHeader.	currentFrameIndex _ 1.! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/20/2001 16:08'!hasVideo	"Answer true if I have one or more frames."	^ frameOffsets size > 1  "note: the empty movie still has one frameOffset"! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/14/2001 14:18'!videoDropFrames: skipCount stream: streamIndex	"Advance the index of the current frame by the given number of frames."	self videoSetFrame: currentFrameIndex + skipCount stream: streamIndex.! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 08:08'!videoFrameHeight: ignored	"Answer the height of this movie."	^ movieExtent y! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 07:37'!videoFrameRate: ignored	"Answer the frame rate of this movie."	^ frameRate! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 08:08'!videoFrameWidth: ignored	"Answer the width of this movie."	^ movieExtent x! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 07:34'!videoFrames: ignored	"Answer the number of video frames in this movie."	^ (frameOffsets size - 1) max: 0! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/14/2001 14:05'!videoGetFrame: ignored	"Answer the index of the current frame, or zero if the movie has no frames."	^ currentFrameIndex! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/20/2001 11:02'!videoReadFrameInto: aForm stream: aStream	"Read the next frame into the given 16-bit or 32-bit Form."	| compressedBytes |	compressedBytes _ self bytesForFrame: currentFrameIndex.	compressedBytes ifNil: [^ self].	JPEGReadWriter2 new uncompress: compressedBytes into: aForm.	currentFrameIndex _ (currentFrameIndex + 1) min: (frameOffsets size - 1).! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 08:10'!videoSetFrame: newIndex stream: ignored	"Set the index of the current frame."	currentFrameIndex _ (newIndex asInteger max: 1) min: (frameOffsets size - 1).! !!JPEGMovieFile methodsFor: 'audio' stamp: 'jm 11/17/2001 09:49'!audioPlayerForChannel: anInteger	"Answer a streaming sound for playing the audio channel with the given index."	((anInteger >= 1) & (anInteger <= soundtrackOffsets size)) ifFalse: [^ nil].	^ StreamingMonoSound		onFileNamed: file fullName		headerStart: (soundtrackOffsets at: anInteger)! !!JPEGMovieFile methodsFor: 'audio' stamp: 'jm 11/16/2001 17:03'!hasAudio	"Answer true if this movie has at least one sound track."	^ soundtrackOffsets size > 0! !!JPEGMovieFile methodsFor: 'private' stamp: 'jm 11/15/2001 08:02'!bytesForFrame: frameIndex	"Answer a ByteArray containing the encoded bytes for the frame with the given index. Answer nil if the index is out of range or if my file is not open."	frameIndex < 1 ifTrue: [^ nil].	frameIndex >= frameOffsets size ifTrue: [^ nil].	file ifNil: [^ nil].	file closed ifTrue: [file ensureOpen; binary].	file position: (frameOffsets at: frameIndex).	^ file next: (frameOffsets at: frameIndex + 1) - (frameOffsets at: frameIndex)! !!JPEGMovieFile methodsFor: 'private' stamp: 'jm 11/16/2001 17:01'!readHeader	"Read a JPEG movie header file."	"Details: The file structures is:		<header, including sequence frame offsets>		<sequence of JPEG compressed images>		<optional soundtracks>"	| tag w h frameOffsetCount soundtrackCount |	file position: 0.	tag _ (file next: 10) asString.	tag = 'JPEG Movie' ifFalse: [self error: 'not a JPEG movie file'].	w _ file uint16.	h _ file uint16.	movieExtent _ w @ h.	frameRate _ file uint32 / 10000.0.	frameOffsetCount _ file uint32.	frameOffsets _ Array new: frameOffsetCount.	1 to: frameOffsetCount do: [:i | frameOffsets at: i put: file uint32].	soundtrackCount _ file uint16.	soundtrackOffsets _ Array new: soundtrackCount.	1 to: soundtrackCount do: [:i | soundtrackOffsets at: i put: file uint32].! !!JPEGMovieFile methodsFor: 'private' stamp: 'jm 11/17/2001 13:38'!testPlay	"Performance benchmark. Decompress and display all my frames. Answer the frame rate achieved in frames/second. No sound is played."	| frameForm frameCount t |	frameForm _ Form extent: movieExtent depth: (Display depth max: 16).	frameCount _ self videoFrames: 0.	self videoSetFrame: 1 stream: 0.	t _ [		frameCount timesRepeat: [			self videoReadFrameInto: frameForm stream: 0.			frameForm display].	] timeToRun.	^ (1000.0 * frameCount) / t! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JPEGMovieFile class	instanceVariableNames: ''!!JPEGMovieFile class methodsFor: 'testing' stamp: 'jm 11/15/2001 14:56'!isJPEGMovieFile: fileName	"Answer true if the file with the given name appears to be a JPEG movie file."	| f tag |	(FileDirectory default fileExists: fileName) ifFalse: [^ false].	f _ (FileStream readOnlyFileNamed: fileName) binary.	tag _ (f next: 10) asString.	f close.	^ tag = 'JPEG Movie'! !!JPEGMovieFile class methodsFor: 'movie conversion' stamp: 'jm 11/21/2001 15:14'!convertMPEGFileNamed: mpegFileName toJPEGMovieNamed: jpegFileName quality: quality	"Convert the MPEG movie with the given file name into a JPEG movie with the given file name."	| mpegFile jpegFile soundtrackCount movieExtent frameOffsets soundTrackOffsets |	(FileDirectory default fileExists: mpegFileName)		ifFalse: [^ self inform: 'File not found: ', mpegFileName].	(MPEGFile isFileValidMPEG: mpegFileName)		ifFalse: [^ self inform: 'Not an MPEG file: ', mpegFileName].	mpegFile _ MPEGFile openFile: mpegFileName.	mpegFile fileHandle ifNil: [^ self inform: 'Could not open ', mpegFileName].	jpegFile _ (FileStream newFileNamed: jpegFileName) binary.	"write header"	soundtrackCount _ mpegFile hasAudio ifTrue: [1] ifFalse: [0].	mpegFile hasVideo		ifTrue: [			movieExtent _ (mpegFile videoFrameWidth: 0)@(mpegFile videoFrameHeight: 0).			self writeHeaderExtent: movieExtent				frameRate: (mpegFile videoFrameRate: 0)				frameCount: (mpegFile videoFrames: 0)				soundtrackCount: soundtrackCount				on: jpegFile]		ifFalse: [			self writeHeaderExtent: 0@0				frameRate: 0				frameCount: 0				soundtrackCount: soundtrackCount				on: jpegFile].	"convert and write frames"	frameOffsets _ self writeFramesFrom: mpegFile on: jpegFile quality: quality.	self updateFrameOffsets: frameOffsets on: jpegFile.	"convert and write sound tracks"	jpegFile position: frameOffsets last.  "store sound tracks after the last frame"	soundTrackOffsets _ self writeSoundTracksFrom: mpegFile on: jpegFile.	self updateSoundtrackOffsets: soundTrackOffsets frameOffsets: frameOffsets on: jpegFile.	mpegFile closeFile.	jpegFile close.! !!JPEGMovieFile class methodsFor: 'movie conversion' stamp: 'jm 11/17/2001 13:12'!convertSqueakMovieNamed: squeakMovieFileName toJPEGMovieNamed: jpegFileName quality: quality	"Convert the Squeak movie with the given file name into a JPEG movie with the given file name."	| sqMovieFile jpegFile w h d frameCount mSecsPerFrame frameForm bytesPerFrame frameOffsets |	(FileDirectory default fileExists: squeakMovieFileName)		ifFalse: [^ self inform: 'File not found: ', squeakMovieFileName].	sqMovieFile _ (FileStream readOnlyFileNamed: squeakMovieFileName) binary.	sqMovieFile ifNil: [^ self inform: 'Could not open ', squeakMovieFileName].	jpegFile _ (FileStream newFileNamed: jpegFileName) binary.	sqMovieFile nextInt32.  "skip first word"	w _ sqMovieFile nextInt32.	h _ sqMovieFile nextInt32.	d _ sqMovieFile nextInt32.	frameCount _ sqMovieFile nextInt32.	mSecsPerFrame _ (sqMovieFile nextInt32) / 1000.0.	"write header"	self writeHeaderExtent: w@h		frameRate: (1000.0 / mSecsPerFrame)		frameCount: frameCount		soundtrackCount: 0		on: jpegFile.	"convert and write frames"	frameForm _ Form extent: w@h depth: d.	bytesPerFrame _ 4 + (frameForm bits size * 4).	frameOffsets _ Array new: frameCount + 1.	1 to: frameCount do: [:i |		frameOffsets at: i put: jpegFile position.		sqMovieFile position: 128 + ((i - 1) * bytesPerFrame) + 4.		sqMovieFile next: frameForm bits size into: frameForm bits startingAt: 1.		frameForm display.		self writeFrame: frameForm on: jpegFile quality: quality displayFlag: false].	frameOffsets at: (frameCount + 1) put: jpegFile position.	self updateFrameOffsets: frameOffsets on: jpegFile.	sqMovieFile close.	jpegFile close.! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/17/2001 08:05'!updateFrameOffsets: frameOffsets on: aBinaryStream	"Update the JPEG movie file header on the given stream with the given collection of frame offsets."	aBinaryStream position: 22.	frameOffsets do: [:offset | aBinaryStream uint32: offset].! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/17/2001 07:40'!updateSoundtrackOffsets: soundtrackOffsetList frameOffsets: frameOffsets on: aBinaryStream	"Update the JPEG movie file header on the given stream with the given sequence of sound track offsets."	aBinaryStream position: 22 + (4 * frameOffsets size).	aBinaryStream uint16: soundtrackOffsetList size.	soundtrackOffsetList do: [:offset | aBinaryStream uint32: offset].! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/25/2001 14:20'!writeFrame: aForm on: aBinaryStream quality: quality displayFlag: displayFlag	"Compress and the given Form on the given stream and answer its offset. If displayFlag is true, show the result of JPEG compression on the display."	| offset compressed outForm |	offset _ aBinaryStream position.	compressed _ JPEGReadWriter2 new compress: aForm quality: quality.	displayFlag ifTrue: [  "show decompressed frame"		outForm _ (JPEGReadWriter2 on: (ReadStream on: compressed)) nextImage.		outForm display].	aBinaryStream nextPutAll: compressed.	^ offset! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/25/2001 14:23'!writeFramesFrom: mpegFile on: aBinaryStream quality: quality	"Write the frames of the given MPEG movie on the given stream at the given JPEG quality level. Answer a collection of frame offsets. The size of this collection is one larger than the number of frames; it's final entry is the stream position just after the final frame. The byte count for any frame can thus be computed as the difference between two adjacent offsets."	| frameCount frameOffsets frameForm |	mpegFile hasVideo ifFalse: [^ Array with: aBinaryStream position].	frameCount _ mpegFile videoFrames: 0.	frameOffsets _ OrderedCollection new: frameCount + 1.	frameForm _ Form		extent: (mpegFile videoFrameWidth: 0)@(mpegFile videoFrameHeight: 0)		depth: 32.	[(mpegFile videoGetFrame: 0) < (mpegFile videoFrames: 0)] whileTrue: [		frameOffsets addLast: aBinaryStream position.		mpegFile videoReadFrameInto: frameForm stream: 0.		self writeFrame: frameForm on: aBinaryStream quality: quality displayFlag: true].	frameOffsets addLast: aBinaryStream position.  "add final offset"	^ frameOffsets! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/17/2001 08:01'!writeHeaderExtent: movieExtent frameRate: frameRate frameCount: frameCount soundtrackCount: soundtrackCount on: aBinaryStream	"Write a header on the given stream for a JPEG movie file with the given specifications. Leave the stream positioned at the start of the first movie frame."	| offsetCount |	aBinaryStream position: 0.	aBinaryStream nextPutAll: ('JPEG Movie') asByteArray.	aBinaryStream uint16: movieExtent x.	aBinaryStream uint16: movieExtent y.	aBinaryStream uint32: (frameRate * 10000) rounded.	offsetCount _ frameCount + 1.	aBinaryStream uint32: offsetCount.	aBinaryStream skip: (offsetCount * 4).  "leave room for frame offsets"	aBinaryStream uint16: soundtrackCount.	aBinaryStream skip: (soundtrackCount * 4).  "leave room for sound track offsets"! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/25/2001 16:55'!writeSoundTracksFrom: mpegFile on: aBinaryStream	"Convert and write the sound tracks from the given MPEG file to given stream. Answer a collection of sound track offsets."	"Details: Currently converts at most one sound track; only the left channel of a stereo movie will be converted."	| soundtrackCount soundTrackOffsets snd |	soundtrackCount _ mpegFile hasAudio ifTrue: [1] ifFalse: [0].	soundTrackOffsets _ Array new: soundtrackCount.	1 to: soundtrackCount do: [:i |		soundTrackOffsets at: i put: aBinaryStream position.		snd _ mpegFile audioPlayerForChannel: i.		snd storeSunAudioOn: aBinaryStream compressionType: 'mulaw'.		snd closeFile].	^ soundTrackOffsets! !Morph subclass: #MPEGDisplayMorph	instanceVariableNames: 'frameBuffer mpegFile running desiredFrameRate allowFrameDropping repeat startMSecs startFrame soundTrack volume '	classVariableNames: ''	poolDictionaries: ''	category: 'MPEG-Player'!!MPEGDisplayMorph methodsFor: 'initialization' stamp: 'jm 11/20/2001 15:00'!initialize	super initialize.	super extent: 250@0.	frameBuffer _ nil.	mpegFile _ nil.	running _ false.		desiredFrameRate _ 10.0.	allowFrameDropping _ true.	repeat _ false.	soundTrack _ nil.	volume _ 0.5.! !!MPEGDisplayMorph methodsFor: 'accessing' stamp: 'jm 11/16/2001 16:40'!extent: aPoint	"Overridden to maintain movie aspect ratio."	| scale |	frameBuffer ifNil: [^ super extent: aPoint].	scale _ (aPoint x / frameBuffer width) max: (aPoint y / frameBuffer height).	scale _ scale max: (16 / frameBuffer width).	super extent: (frameBuffer extent * scale) rounded.! !!MPEGDisplayMorph methodsFor: 'accessing' stamp: 'jm 11/16/2001 16:29'!moviePosition	"Answer a number between 0.0 and 1.0 indicating the current position within the movie."	mpegFile ifNil: [^ 0.0].	mpegFile fileHandle ifNil: [^ 0.0].	mpegFile hasVideo		ifTrue: [^ ((mpegFile videoGetFrame: 0) asFloat / (mpegFile videoFrames: 0)) min: 1.0].	soundTrack ifNotNil: [^ soundTrack soundPosition].	^ 0.0! !!MPEGDisplayMorph methodsFor: 'accessing' stamp: 'jm 11/21/2001 17:54'!moviePosition: fraction	"Jump to the position the given fraction through the movie. The argument is a number between 0.0 and 1.0."	| frameCount frameIndex |	self mpegFileIsOpen ifFalse: [^ self].	self stopPlaying.	mpegFile hasVideo ifTrue: [		frameCount _ mpegFile videoFrames: 0.		frameIndex _ (frameCount * fraction) truncated - 1.		frameIndex _ (frameIndex max: 0) min: (frameCount - 3).		mpegFile videoSetFrame: frameIndex stream: 0.		self nextFrame].! !!MPEGDisplayMorph methodsFor: 'file open/close' stamp: 'jm 11/17/2001 09:48'!openFileNamed: mpegFileName	"Try to open the MPEG file with the given name. Answer true if successful."	| e |	self closeFile.	(FileDirectory default fileExists: mpegFileName)		ifFalse: [self inform: 'File not found: ', mpegFileName. ^ false].	(MPEGFile isFileValidMPEG: mpegFileName)		ifTrue: [mpegFile _ MPEGFile openFile: mpegFileName]		ifFalse: [			(JPEGMovieFile isJPEGMovieFile: mpegFileName)				ifTrue: [mpegFile _ JPEGMovieFile new openFileNamed: mpegFileName]				ifFalse: [self inform: 'Not an MPEG or JPEG movie file: ', mpegFileName. ^ false]].	mpegFile fileHandle ifNil: [^ false].	"initialize soundTrack"	mpegFile hasAudio		ifTrue: [soundTrack _ mpegFile audioPlayerForChannel: 1]		ifFalse: [soundTrack _ nil].	mpegFile hasVideo		ifTrue: [  "set screen size and display first frame"			desiredFrameRate _ mpegFile videoFrameRate: 0.			soundTrack ifNotNil: [  "compute frame rate from length of audio track"				desiredFrameRate _ (mpegFile videoFrames: 0) / soundTrack duration].			e _ (mpegFile videoFrameWidth: 0)@(mpegFile videoFrameHeight: 0).			frameBuffer _ Form extent: e depth: (Display depth max: 16).			super extent: e.			self nextFrame]		ifFalse: [  "hide screen for audio-only files"			super extent: 250@0].! !!MPEGDisplayMorph methodsFor: 'file open/close' stamp: 'jm 11/26/2001 08:26'!openMPEGFile	"Invoked by the 'Open' button. Prompt for a file name and try to open that file as an MPEG file."	| result |	result _ (FileList2 modalFileSelectorForSuffixes: #('mp3' 'mpg' 'mpeg' 'jmv')) .	result ifNil: [^ self].	self stopPlaying.	self openFileNamed: (result fullName).! !!MPEGDisplayMorph methodsFor: 'drawing' stamp: 'jm 11/11/2001 15:49'!drawOn: aCanvas	"Draw the current frame image, if there is one. Otherwise, fill screen with gray."	frameBuffer		ifNil: [aCanvas fillRectangle: self bounds color: (Color gray: 0.75)]		ifNotNil: [			self extent = frameBuffer extent				ifTrue: [aCanvas drawImage: frameBuffer at: bounds origin]				ifFalse: [self drawScaledOn: aCanvas]].! !!MPEGDisplayMorph methodsFor: 'drawing' stamp: 'jm 11/13/2001 08:45'!drawScaledOn: aCanvas	"Draw the current frame image scaled to my bounds."	| outForm destPoint warpBlt |	((aCanvas isKindOf: FormCanvas) and: [aCanvas form = Display])		ifTrue: [  "optimization: when canvas is the Display, Warpblt directly to it"			outForm _ Display.			destPoint _ bounds origin + aCanvas origin]		ifFalse: [			outForm _ Form extent: self extent depth: aCanvas form depth.			destPoint _ 0@0].	warpBlt _ (WarpBlt current toForm: outForm)		sourceForm: frameBuffer;		colorMap: (frameBuffer colormapIfNeededForDepth: outForm depth);		cellSize: 1;  "installs a new colormap if cellSize > 1"		combinationRule: Form over.	outForm == Display ifTrue: [warpBlt clipRect: aCanvas clipRect].	warpBlt		copyQuad: frameBuffer boundingBox innerCorners		toRect: (destPoint extent: self extent).	outForm == Display ifFalse: [		aCanvas drawImage: outForm at: bounds origin].! !!MPEGDisplayMorph methodsFor: 'commands' stamp: 'jm 11/16/2001 15:39'!nextFrame	"Fetch the next frame into the frame buffer."	mpegFile ifNil: [^ self].	mpegFile videoReadFrameInto: frameBuffer stream: 0.	self changed.! !!MPEGDisplayMorph methodsFor: 'commands' stamp: 'jm 11/13/2001 07:36'!rewindMovie	"Rewind to the beginning of the movie."	"Details: Seeking by percent or frame number both seem to have problems, so just re-open the file."	| savedExtent savedRate |	self mpegFileIsOpen ifFalse: [^ self].	self stopPlaying.	"re-open the movie, retaining current extent and frame rate"	savedExtent _ self extent.	savedRate _ desiredFrameRate.	self openFileNamed: mpegFile fileName.  "recomputes rate and extent"	self extent: savedExtent.	desiredFrameRate _ savedRate.! !!MPEGDisplayMorph methodsFor: 'commands' stamp: 'jm 11/21/2001 17:56'!startPlaying	"Start playing the movie at the current position."	| frameIndex |	self stopPlaying.	self mpegFileIsOpen ifFalse: [^ self].	mpegFile hasAudio		ifTrue: [			mpegFile hasVideo ifTrue: [				"set movie frame position from soundTrack position"				soundTrack reset.  "ensure file is open before positioning"				soundTrack soundPosition: (mpegFile videoGetFrame: 0) asFloat / (mpegFile videoFrames: 0).				"now set frame index from the soundtrack position for best sync"				frameIndex _ ((soundTrack millisecondsSinceStart * desiredFrameRate) // 1000).				frameIndex _ (frameIndex max: 0) min: ((mpegFile videoFrames: 0) - 3).				mpegFile videoSetFrame: frameIndex stream: 0].			SoundPlayer stopReverb.			soundTrack volume: volume.			soundTrack repeat: repeat.			soundTrack resumePlaying.			startFrame _ startMSecs _ 0]		ifFalse: [			soundTrack _ nil.			startFrame _ mpegFile videoGetFrame: 0.			startMSecs _ Time millisecondClockValue].	running _ true.! !!MPEGDisplayMorph methodsFor: 'other' stamp: 'jm 11/17/2001 08:46'!advanceFrame	"Advance to the next frame if it is time to do so, skipping frames if necessary."	| msecs currentFrame desiredFrame framesToAdvance |	mpegFile hasVideo ifFalse: [^ self].	soundTrack		ifNil: [msecs _ Time millisecondClockValue - startMSecs]		ifNotNil: [msecs _ soundTrack millisecondsSinceStart + 100].	desiredFrame _ startFrame + ((msecs * desiredFrameRate) // 1000).	desiredFrame _ desiredFrame min: (mpegFile videoFrames: 0).	currentFrame _ mpegFile videoGetFrame: 0.	framesToAdvance _ desiredFrame - currentFrame.	framesToAdvance <= 0 ifTrue: [^ self].	(allowFrameDropping and: [framesToAdvance > 1]) ifTrue: [		mpegFile videoDropFrames: framesToAdvance - 1 stream: 0].	self nextFrame.! !!MPEGDisplayMorph methodsFor: 'other' stamp: 'jm 11/14/2001 11:58'!jpegMovieSize: quality	"Convert all my frames to a JPEG and measure the total size."	| jpegSize jpegDecodeTime jpegStream t outForm |	mpegFile hasVideo ifFalse: [^ self error: 'movie has no video'].	jpegSize _ 0.	jpegDecodeTime _ 0.	jpegStream _ WriteStream on: (ByteArray new: 100000).	self rewindMovie.	[(mpegFile videoGetFrame: 0) < (mpegFile videoFrames: 0)] whileTrue: [		jpegStream reset.		(JPEGReadWriter2 on: jpegStream)			nextPutImage: frameBuffer			quality: quality			progressiveJPEG: false.		jpegSize _ jpegSize + jpegStream position.		t _ [			outForm _ (JPEGReadWriter2 on: (ReadStream on: jpegStream contents)) nextImage		] timeToRun.		jpegDecodeTime _ jpegDecodeTime + t.		outForm display.		frameBuffer displayAt: (outForm width + 10)@0.		self nextFrame].	^ Array with: jpegSize with: jpegDecodeTime with: (mpegFile videoFrames: 0)! !!MPEGDisplayMorph methodsFor: 'other' stamp: 'jm 11/21/2001 16:58'!measureMaxFrameRate	"For testing. Play through the movie as fast as possible, updating the world each time, and report the frame rate."	| oldFrameRate oldFrameDropping t |	self rewindMovie.	oldFrameRate _ desiredFrameRate.	oldFrameDropping _ allowFrameDropping.	desiredFrameRate _ 1000.0.	allowFrameDropping _ false.	self startPlaying.	t _ [[running] whileTrue: [self world doOneCycleNow]] timeToRun.	desiredFrameRate _ oldFrameRate.	allowFrameDropping _ oldFrameDropping.	^ (mpegFile videoFrames: 0) / (t / 1000.0)! !!MPEGFile methodsFor: 'audio' stamp: 'jm 11/17/2001 08:18'!audioChannels: aStream	"Returns -1 if error, otherwise returns audioChannels for stream aStream"	self hasAudio ifFalse: [^ 0].	^[self primAudioChannels: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'jm 11/17/2001 09:36'!audioPlayerForChannel: channelNumber	"Answer a streaming sound for playing the audio channel with the given index."	"Note: The MP3 player can not yet isolate a single channel from a multi-channel audio stream."	^ StreamingMP3Sound new initMPEGFile: self streamIndex: 0! !!MPEGFile methodsFor: 'video' stamp: 'jm 11/16/2001 07:53'!videoReadFrameInto: aForm stream: aStream	"Read the next video frame from the given stream into the given 16- or 32-bit Form. The movie frame will be scaled to fit the Form if necessary."	| colorModel bytesPerRow |	((aForm depth = 16) | (aForm depth = 32)) ifFalse: [self error: 'must use 16- or 32-bit Form'].	aForm depth = 16		ifTrue: [			colorModel _ self endianness = #big ifTrue: [14] ifFalse: [16].			bytesPerRow _ 2 * (aForm width roundUpTo: 2)]		ifFalse: [			colorModel _ self endianness = #big ifTrue: [13] ifFalse: [1].			bytesPerRow _ 4 * aForm width]. 	^ self		videoReadNextFrameInto: aForm bits		x: 0 y: 0		width: (self videoFrameWidth: aStream)		height: (self videoFrameHeight: aStream)		outWidth: aForm width		outHeight: aForm height		colorModel: colorModel		stream: aStream		bytesPerRow: bytesPerRow! !!MPEGMoviePlayerMorph methodsFor: 'drawing' stamp: 'jm 11/13/2001 09:12'!drawOn: aCanvas	"Optimization: Do not draw myself if the movie player is one of my submorphs and the only damage is contained within it. This avoids overdrawing while playing a movie."	((moviePlayer owner == self) and:	 [moviePlayer bounds containsRect: aCanvas clipRect])		ifFalse: [super drawOn: aCanvas].! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jm 11/26/2001 08:31'!unimplemented	"Answer an Array of each message that is sent by an expression in a method but is not implemented by any object in the system."	| all unimplemented entry |	all _ IdentitySet new: Symbol instanceCount * 2.	Cursor wait showWhile: 		[self allBehaviorsDo: [:cl | cl selectorsDo: [:aSelector | all add: aSelector]]].	unimplemented _ IdentityDictionary new.	Cursor execute showWhile: [		self allBehaviorsDo: [:cl |			 cl selectorsDo: [:sel |				(cl compiledMethodAt: sel) messages do: [:m |					(all includes: m) ifFalse: [						entry _ unimplemented at: m ifAbsent: [Array new].						entry _ entry copyWith: (cl name, '>', sel).						unimplemented at: m put: entry]]]]].	"remove some clutter from the result:"	#(DoItIn: primitiveFail diffedVersionContents uniformWindowColors macOptionKeyAllowed)		do: [:sel | unimplemented removeKey: sel ifAbsent: []].	"these messages are not sent when running on the Zaurus:"	#(channelData defaultAALevel: from:title: fromWaveFileNamed: imageFormOfSize:forFrame:invokeAt:in: loadedFrames originalSamplingRate printInstructionsOn: processFilereadFrom:mergeIfStereo:skipDataChunk: samples samples:samplingRate: samplesRemainingstoreAIFFSamples:samplingRate:on: windowMenuWithLabels:colorPattern:targets:selections:title:)		do: [:sel | unimplemented removeKey: sel ifAbsent: []].	^ unimplemented! !MPEGFile removeSelector: #videoReadNext16BitFrameInto:width:height:stream:!MPEGFile removeSelector: #videoReadNextFrameInto:width:height:stream:!!MPEGFile reorganize!('initialize-release' closeFile initialize openFile:)('file ops' finalize)('access' endianness fileHandle fileName getPercentage getTOC:doStreams: getTimeCode seekPercentage: setMMX:)('audio' audioChannels: audioGetSample: audioPlayerForChannel: audioReReadBuffer:stream:channel: audioReReadBuffer:stream:channel:samples: audioReadBuffer:stream:channel: audioReadBuffer:stream:channel:samples: audioSampleRate: audioSamples: audioSetSample:stream: endOfAudio: hasAudio totalAudioStreams)('video' endOfVideo: hasVideo totalVideoStreams videoDropFrames:stream: videoFrameHeight: videoFrameRate: videoFrameWidth: videoFrames: videoGetFrame: videoPreviousFrame: videoReadFrameInto:stream: videoReadNextFrameInto:x:y:width:height:outWidth:outHeight:colorModel:stream:bytesPerRow: videoSetCPUs: videoSetFrame:stream:)('private' register unregister)('primitives' primAudioChannels:stream: primAudioReReadBuffer:buffer:channel:samples:stream: primAudioReadBuffer:buffer:channel:samples:stream: primAudioSamples:stream: primDropFrame:frame:stream: primEndOfAudio:stream: primEndOfVideo:stream: primFileClose: primFileOpen: primFrameRate:stream: primGenerateToc:useSearch:doStreams:buffer: primGetFrame:stream: primGetPercentage: primGetSample:stream: primGetTime: primHasAudio: primHasVideo: primPreviousFrame:stream: primSampleRate:stream: primSeekPercentage:percentage: primSetCPUs:number: primSetFrame:frame:stream: primSetMMX:useMMX: primSetSample:sample:stream: primTotalAudioStreams: primTotalVideoStreams: primVideoFrames:stream: primVideoHeight:stream: primVideoReadNextFrameFor:into:x:y:width:height:outWidth:outHeight:colorModel:stream:bytesPerRow: primVideoWidth:stream:)!Morph subclass: #MPEGDisplayMorph	instanceVariableNames: 'frameBuffer mpegFile running desiredFrameRate allowFrameDropping repeat soundTrack volume startMSecs startFrame '	classVariableNames: ''	poolDictionaries: ''	category: 'MPEG-Player'!