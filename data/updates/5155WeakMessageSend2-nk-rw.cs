'From Squeak3.4beta of ''1 December 2002'' [latest update: #5147] on 8 December 2002 at 12:19:45 pm'!"Change Set:		WeakMessageSend2-nk-rwDate:			8 December 2002 (v2)Author:			Ned Konz and Rob Withersv2: Eliminated WeakMessageSendError; value* now silently returns nil if receiver or arguments have been GC'd.This defines a simple MessageSend where the receiver and arguments are held onto weakly.And it changes the NuBlue event registration to use the WeakMessageSends instead, so that subscribers can be garbage collected."!Array variableSubclass: #WeakActionSequence	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!Object weakSubclass: #WeakMessageSend	instanceVariableNames: 'selector shouldBeNil arguments '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!TestCase subclass: #WeakMessageSendTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Tests-EventManager'!!Object methodsFor: 'converting' stamp: 'rw 4/27/2002 07:48'!asActionSequence	^WeakActionSequence with: self! !!Object methodsFor: 'testing' stamp: 'nk 4/25/2002 08:04'!isMessageSend	^false! !!Object methodsFor: 'events-accessing' stamp: 'rw 4/27/2002 07:50'!actionForEvent: anEventSelector    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	actions ifNil: [^nil].	actions isReceiverOrAnyArgumentGarbage		ifTrue: [actions := actions asMinimalRepresentation].	^ actions! !!Object methodsFor: 'events-accessing' stamp: 'rw 4/27/2002 07:51'!actionForEvent: anEventSelectorifAbsent: anExceptionBlock    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	actions ifNil: [^anExceptionBlock value].	actions isReceiverOrAnyArgumentGarbage		ifTrue: [actions := actions asMinimalRepresentation].	^ actions! !!Object methodsFor: 'events-accessing' stamp: 'rw 4/27/2002 08:35'!actionSequenceForEvent: anEventSelector    ^(self actionMap        at: anEventSelector asSymbol        ifAbsent: [^WeakActionSequence new])            asActionSequence! !!Object methodsFor: 'events' stamp: 'rw 4/27/2002 07:20'!when: anEventSelectorsend: aMessageSelectorto: anObject    self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector)! !!Object methodsFor: 'events' stamp: 'rw 4/27/2002 07:21'!when: anEventSelectorsend: aMessageSelectorto: anObjectwith: anArg    self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: (Array with: anArg))! !!Object methodsFor: 'events' stamp: 'rw 4/27/2002 07:21'!when: anEventSelectorsend: aMessageSelectorto: anObjectwithArguments: anArgArray    self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: anArgArray)! !!EventTestCase methodsFor: 'running-broadcast query' stamp: 'rw 4/27/2002 09:12'!testMultipleValueSuppliersEventHasArgumentsWithGC	eventSource		when: #needsValue:		send: #getFalse:		to: self		with: Object new.	eventSource		when: #needsValue:		send: #getTrue:		to: self		with: Object new.	Smalltalk garbageCollectMost.	succeeded := eventSource triggerEvent: #needsValue: with: 'kolme'.	self should: [succeeded = nil]! !!FileList methodsFor: 'file list menu' stamp: 'nk 12/7/2002 12:56'!itemsForFile: fullName	"Answer a list of services appropriate for a file of the given full name"	| suffix |	suffix _ self class suffixOf: fullName.	^ (self class itemsForFile: fullName) , (self myServicesForFile: fullName suffix: suffix)! !!FileList methodsFor: 'file list menu' stamp: 'nk 12/7/2002 12:57'!suffixOfSelectedFile	"Answer the file extension of the receiver's selected file"	^ self class suffixOf: self fullName.! !!MessageSend methodsFor: 'evaluating' stamp: 'reThink 2/18/2001 16:51'!valueWithArguments: anArray	^ receiver 		perform: selector 		withArguments: (self collectArguments: anArray)! !!MessageSend methodsFor: 'testing' stamp: 'nk 4/25/2002 08:04'!isMessageSend	^true! !!WeakActionSequence methodsFor: 'converting' stamp: 'rw 4/27/2002 07:44'!asActionSequence	^self! !!WeakActionSequence methodsFor: 'converting' stamp: 'rw 4/27/2002 08:36'!asMinimalRepresentation	| valid |	valid := self select: [:e | e isReceiverOrAnyArgumentGarbage not].	valid size = 0		ifTrue: [^nil].	valid size = 1		ifTrue: [^self first].	^valid! !!WeakActionSequence methodsFor: 'evaluating' stamp: 'rw 4/27/2002 07:45'!value    "Answer the result of evaluating the elements of the receiver."    | answer |    self do:        [:each |		each isReceiverOrAnyArgumentGarbage 			ifFalse: [answer := each value]].    ^answer! !!WeakActionSequence methodsFor: 'evaluating' stamp: 'rw 4/27/2002 07:45'!valueWithArguments: anArray    | answer |    self do:        [:each |        	each isReceiverOrAnyArgumentGarbage 			ifFalse: [answer := each valueWithArguments: anArray]].    ^answer! !!WeakActionSequence methodsFor: 'testing' stamp: 'rw 4/27/2002 07:47'!isReceiverOrAnyArgumentGarbage 	^ self		inject: false		into: [:truth :element | truth or: [element isReceiverOrAnyArgumentGarbage]]! !!WeakActionSequence methodsFor: 'printing' stamp: 'rw 4/27/2002 07:46'!printOn: aStream	self size < 2 ifTrue: [^super printOn: aStream].	aStream nextPutAll: '#('.	self		do: [:each | each printOn: aStream]		separatedBy: [aStream cr].	aStream nextPut: $)! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 09:54'!arguments	^arguments ifNil: [ Array new ]! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 09:38'!arguments: anArray	arguments _ WeakArray withAll: anArray.	"no reason this should be a WeakArray"	shouldBeNil _ Array withAll: (anArray collect: [ :ea | ea isNil ]).! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 07:54'!receiver	^self at: 1! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 07:54'!receiver: anObject	self at: 1 put: anObject! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 07:54'!selector	^selector! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 07:55'!selector: aSymbol	selector _ aSymbol! !!WeakMessageSend methodsFor: 'comparing' stamp: 'nk 4/25/2002 08:05'!= anObject	"Compare equal to equivalent MessageSend"	^ anObject isMessageSend		and: [self receiver == anObject receiver		and: [selector == anObject selector		and: [(Array withAll: arguments) = (Array withAll: anObject arguments)]]]! !!WeakMessageSend methodsFor: 'comparing' stamp: 'nk 4/25/2002 09:31'!hash	"work like MessageSend>>hash"	^self receiver hash bitXor: selector hash! !!WeakMessageSend methodsFor: 'converting' stamp: 'nk 4/25/2002 09:33'!asMessageSend	^MessageSend receiver: self receiver selector: selector arguments: (Array withAll: self arguments) ! !!WeakMessageSend methodsFor: 'converting' stamp: 'rww 10/20/2002 19:56'!asMinimalRepresentation	self isReceiverOrAnyArgumentGarbage		ifTrue: [^nil]		ifFalse:[^self].! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'nk 12/8/2002 12:15'!value	^ arguments isNil		ifTrue: [self ensureReceiver				ifTrue: [self receiver perform: selector] ifFalse: []]		ifFalse: [self ensureReceiverAndArguments				ifTrue: [self receiver						perform: selector						withArguments: (Array withAll: arguments)] ifFalse: []]! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'nk 12/8/2002 12:15'!valueWithArguments: anArray	self ensureReceiverAndArguments ifFalse: [ ^nil ].	^ self receiver 		perform: selector 		withArguments: (self collectArguments: anArray)! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'nk 12/8/2002 12:15'!valueWithEnoughArguments: anArray	"call the selector with enough arguments from arguments and anArray"	| args |	self ensureReceiverAndArguments ifFalse: [ ^nil ].	args _ Array new: selector numArgs.	args replaceFrom: 1		to: ( arguments size min: args size)		with: arguments		startingAt: 1.	args size > arguments size ifTrue: [		args replaceFrom: arguments size + 1			to: (arguments size + anArray size min: args size)			with: anArray			startingAt: 1.	].	^ self receiver perform: selector withArguments: args! !!WeakMessageSend methodsFor: 'printing' stamp: 'nk 4/25/2002 09:36'!printOn: aStream        aStream                nextPutAll: self class name;                nextPut: $(.        selector printOn: aStream.        aStream nextPutAll: ' -> '.        self receiver printOn: aStream.        aStream nextPut: $)! !!WeakMessageSend methodsFor: 'testing' stamp: 'nk 4/25/2002 08:04'!isMessageSend	^true! !!WeakMessageSend methodsFor: 'tiles' stamp: 'nk 4/25/2002 09:34'!asTilesIn: playerClass	^self asMessageSend asTilesIn: playerClass! !!WeakMessageSend methodsFor: 'tiles' stamp: 'nk 4/25/2002 09:34'!asTilesIn: playerClass globalNames: makeSelfGlobal	^self asMessageSend asTilesIn: playerClass globalNames: makeSelfGlobal! !!WeakMessageSend methodsFor: 'tiles' stamp: 'nk 4/25/2002 09:35'!stringFor: anObject	^self asMessageSend stringFor: anObject! !!WeakMessageSend methodsFor: 'private' stamp: 'nk 4/25/2002 09:49'!collectArguments: anArgArray	"Private"    | staticArgs |    staticArgs := self arguments.    ^(anArgArray size = staticArgs size)        ifTrue: [anArgArray]        ifFalse:            [(staticArgs isEmpty                ifTrue: [ staticArgs := Array new: selector numArgs]                ifFalse: [staticArgs copy] )                    replaceFrom: 1                    to: (anArgArray size min: staticArgs size)                    with: anArgArray                    startingAt: 1]! !!WeakMessageSend methodsFor: 'private' stamp: 'nk 12/8/2002 12:13'!ensureArguments	"Return true if my arguments haven't gone away"	arguments ifNotNil: [		arguments with: shouldBeNil do: [ :arg :flag |			arg ifNil: [ flag ifFalse: [ ^false ]]		]	].	^true! !!WeakMessageSend methodsFor: 'private' stamp: 'nk 12/8/2002 12:13'!ensureReceiver	"Return true if my receiver hasn't gone away"	^self receiver notNil! !!WeakMessageSend methodsFor: 'private' stamp: 'nk 12/8/2002 12:13'!ensureReceiverAndArguments	"Return true if my receiver hasn't gone away"	self receiver ifNil: [ ^false ].	"Make sure that my arguments haven't gone away"	arguments ifNotNil: [		arguments with: shouldBeNil do: [ :arg :flag |			arg ifNil: [ flag ifFalse: [ ^false ]]		]	].	^true! !!WeakMessageSend methodsFor: 'private' stamp: 'rw 4/27/2002 07:33'!isAnyArgumentGarbage	"Make sure that my arguments haven't gone away"	arguments ifNotNil: [		arguments with: shouldBeNil do: [ :arg :flag |			(flag not and: [arg isNil])				ifTrue: [^true]		]	].	^false! !!WeakMessageSend methodsFor: 'private' stamp: 'rw 4/27/2002 07:31'!isReceiverGarbage	"Make sure that my receiver hasn't gone away"	^self receiver isNil! !!WeakMessageSend methodsFor: 'private' stamp: 'rw 4/27/2002 07:34'!isReceiverOrAnyArgumentGarbage	"Make sure that my receiver hasn't gone away"	^self isReceiverGarbage 		or: [self isAnyArgumentGarbage]! !!WeakMessageSend class methodsFor: 'instance creation' stamp: 'nk 4/25/2002 10:00'!new	^self new: 1! !!WeakMessageSend class methodsFor: 'instance creation' stamp: 'nk 4/25/2002 09:37'!receiver: anObject selector: aSymbol	^ self receiver: anObject selector: aSymbol arguments: #()! !!WeakMessageSend class methodsFor: 'instance creation' stamp: 'nk 4/25/2002 09:37'!receiver: anObject selector: aSymbol argument: aParameter	^ self receiver: anObject selector: aSymbol arguments: (Array with: aParameter)! !!WeakMessageSend class methodsFor: 'instance creation' stamp: 'nk 4/25/2002 09:37'!receiver: anObject selector: aSymbol arguments: anArray	^ self new		receiver: anObject;		selector: aSymbol;		arguments: anArray! !!WeakMessageSendTestCase methodsFor: 'as yet unclassified' stamp: 'nk 4/25/2002 10:12'!testNoArguments	| m |	m _ WeakMessageSend		receiver: true		selector: #yourself.	self should: [ m value  ].! !!WeakMessageSendTestCase methodsFor: 'as yet unclassified' stamp: 'nk 4/25/2002 10:10'!testOneArgument	| m |	m _ WeakMessageSend		receiver: Array		selector: #with:		argument: 1.	Smalltalk garbageCollectMost.	self should: [ m value  = { 1 } ].! !!WeakMessageSendTestCase methodsFor: 'as yet unclassified' stamp: 'nk 12/8/2002 12:17'!testOneArgumentWithGC	| m |	m _ WeakMessageSend		receiver: Array		selector: #with:		arguments: { Object new }.	Smalltalk garbageCollectMost.	self assert: (m value isNil)! !!WeakMessageSendTestCase methodsFor: 'as yet unclassified' stamp: 'nk 12/8/2002 12:17'!testReceiverWithGC	| m |	m _ WeakMessageSend		receiver: Object new		selector: #isNil.	Smalltalk garbageCollectMost.	self assert: (m value isNil).! !!WeakMessageSendTestCase methodsFor: 'as yet unclassified' stamp: 'nk 4/25/2002 10:11'!testTwoArguments	| m |	m _ WeakMessageSend		receiver: Array		selector: #with:with:		arguments: { 1 . 2 }.	Smalltalk garbageCollectMost.	self should: [ m value = { 1 . 2 } ].! !!WeakMessageSend reorganize!('accessing' arguments arguments: receiver receiver: selector selector:)('comparing' = hash)('converting' asMessageSend asMinimalRepresentation)('evaluating' value valueWithArguments: valueWithEnoughArguments:)('printing' printOn:)('testing' isMessageSend)('tiles' asTilesIn: asTilesIn:globalNames: stringFor:)('private' collectArguments: ensureArguments ensureReceiver ensureReceiverAndArguments isAnyArgumentGarbage isReceiverGarbage isReceiverOrAnyArgumentGarbage)!