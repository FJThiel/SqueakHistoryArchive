'From Squeak 2.1 of June 30, 1998 on 22 August 1998 at 11:26:38 am'!"Change Set:		veryDeep-tk-ZGDate:			21 August 1998Author:			Ted KaehlerA complete rewrite of Object veryDeepCopy.  Copy an object and the entire tree of objects it points to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied (see Morph|veryDeepCopyWith:).  Some method have the location of instance variable hard coded.  These classes are checked for having changed shape in checkVariables.Superscedes the veryDeepCopy: in SmartRefStream, and all of class DeepCopyStream.  Morph fullCopy is still used in limited cases."!Object subclass: #DeepCopier	instanceVariableNames: 'references uniClasses '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Storage'!!Object methodsFor: 'copying' stamp: 'tk 8/20/1998 16:01'!copyAddedStateFrom: anotherObject	"Copy over the values of instance variables added by the receiver's class from anotherObject to the receiver.  These will be remapped in mapUniClasses, if needed."	self class superclass instSize + 1 to: self class instSize do:		[:index | self instVarAt: index put: (anotherObject instVarAt: index)]! !!Object methodsFor: 'copying' stamp: 'tk 8/20/1998 22:16'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy."	| copier new |	copier _ DeepCopier new initialize.	new _ self veryDeepCopyWith: copier.	copier mapUniClasses.	^ new! !!Object methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new absent uc |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	class _ self class.	class isMeta ifTrue: [^ self].		"a class"	new _ self clone.	class isSystemDefined ifFalse: [		uc _ deepCopier uniClasses at: class ifAbsent: [nil].		uc ifNil: [deepCopier uniClasses at: class put: (uc _ self copyUniClass)].		new _ uc new].	deepCopier references at: self put: new.	"remember"	(class isVariable and: [class isPointers]) ifTrue: 		[index _ self basicSize.		[index > 0] whileTrue: 			[sub _ self basicAt: index.			(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])				ifNil: [new basicAt: index put: (sub veryDeepCopyWith: deepCopier)]				ifNotNil: [new basicAt: index put: subAss value].			index _ index - 1]].	index _ class instSize.	[index > 0] whileTrue: 		[sub _ self instVarAt: index.		(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])			ifNil: [new instVarAt: index put: (sub veryDeepCopyWith: deepCopier)]			ifNotNil: [new instVarAt: index put: subAss value].		index _ index - 1].	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!Object methodsFor: 'objects from disk' stamp: 'tk 8/19/1998 15:03'!rehash	"Do nothing.  Here so sending this to a Set does not have to do a time consuming respondsTo:"! !!Boolean methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!Color methodsFor: 'copying' stamp: 'tk 8/19/1998 16:12'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!CompiledMethod methodsFor: 'file in/out' stamp: 'tk 8/19/1998 16:20'!veryDeepCopyWith: deepCopier	"Return self.  I am always shared.  Do not record me.  Only use this for blocks.  Normally methodDictionaries should not be copied this way."! !!DeepCopier commentStamp: 'tk 8/22/1998 11:26' prior: 0!I do veryDeepCopy.  I hold the dictionary of objects seen, and the correspondance (uniClass -> new uniClass).  See Object|veryDeepCopy which calls (self veryDeepCopyWith: aDeepCopier).Rule:  If a morph stores a uniClass class (Player 57) as an object in a field, the new uniClass will not be stored there.   All uniClass instances do have a new class created for them.  (fix this by putting the old class in references and allow lookup?  Wrong if encounter it before seeing an instance?)Rule: If object A has object C in a field, and A says (^ C) for the copy, but object B has A in a normal field and it gets deepcopied, and A in encountered first, then there will be two copies of C.  (just be aware of it)!!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/20/1998 16:06'!checkVariables	"Check that no indexed of inst vars have changed in certain classes.  If you get an error in this method, you MUST go the the method being checked (veryDeepCopyWith:) and update its code.  And then update the test here."	| str str2 |	str _ '|veryDeepCopyWith: is out of date.'.	Object instSize = 0 ifFalse: [self error: 'Many implementers of ', str].	Morph superclass == Object ifFalse: [self error: 'Morph', str].	Morph instVarNames = #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension') 		ifFalse: [self error: 'Morph', str].	str2 _ 'Player|copyUniClass and DeepCopier|mapUniClasses are out of date'.	Behavior instVarNames = #('superclass' 'methodDict' 'format' 'subclasses' )		ifFalse: [self error: str2].	ClassDescription instVarNames = #('instanceVariables' 'organization' )		ifFalse: [self error: str2].	Class instVarNames = #('name' 'classPool' 'sharedPools' )		ifFalse: [self error: str2].	Model superclass == Object ifFalse: [self error: str2].	Player superclass == Model ifFalse: [self error: str2].	Model class instVarNames = #() ifFalse: [self error: str2].	Player class instVarNames = #('scripts' 'slotInfo' 'costumeDictionary')		ifFalse: [self error: str2].	"Any other class that implements veryDeepCopyWith: for the purpose of not doing	a veryDeepCopy on some inst var, must have a check here."! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/22/1998 11:25'!initialize	references _ IdentityDictionary new: 4096.	uniClasses _ IdentityDictionary new.	"UniClass -> new UniClass"	(self identityHash // 16 bitAnd: 7) = 1 ifTrue: [self checkVariables].		"Just check once in a while"! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/20/1998 16:04'!mapUniClasses	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo costumeDictionary) and cross references (player321).""Uniclasses use class vars to hold onto siblings who are referred to in code"| pp |pp _ Object class instSize + 1.uniClasses do: [:class | "values = new ones"		class classPool associationsDo: [:assoc |			assoc value: (assoc value veryDeepCopyWith: self)].		class instVarAt: pp put: ((class instVarAt: pp) veryDeepCopyWith: self).  "scripts"		pp+3 to: class class instSize do: [:ii | 			class instVarAt: ii put: ((class instVarAt: ii) veryDeepCopyWith: self)].		].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/20/1998 22:13'!references	^ references! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/19/1998 15:48'!uniClasses	^uniClasses! !!Float methodsFor: 'copying' stamp: 'tk 8/19/1998 16:08'!veryDeepCopyWith: deepCopier	"Return self.  Do not record me."	^ self clone! !!Form methodsFor: 'copying' stamp: 'tk 8/19/1998 16:11'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."	^ self! !!Metaclass methodsFor: 'copying' stamp: 'tk 8/19/1998 16:16'!veryDeepCopyWith: deepCopier	"Return self.  Must be created, not copied.  Do not record me."! !!Morph methodsFor: 'copying' stamp: 'tk 8/20/1998 15:57'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Do not copy the owner field.  That must be filled in by the owner, if he is within the tree being copied."	| class index sub subAss new absent uc |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	class _ self class.	new _ self clone.	class isSystemDefined ifFalse: ["May occur in the future"		uc _ deepCopier uniClasses at: class ifAbsent: [nil].		uc ifNil: [deepCopier uniClasses at: class put: (uc _ self copyUniClass)].		new _ uc new].	deepCopier references at: self put: new.	"remember"	"can't be variable number of fields"	new instVarAt: 1 put: bounds copy.	"bounds"		"indexes used here are checked by checkVariables"	(subAss _ deepCopier references associationAt: owner ifAbsent: [nil])		ifNil: [new instVarAt: 2 put: nil]	"owner"		ifNotNil: [new instVarAt: 2 put: subAss value].	new instVarAt: 3 put: (submorphs veryDeepCopyWith: deepCopier).		"submorphs array is not supposed to be held in any other inst field!!		If it is, two copies will be made."	new instVarAt: 4 put: fullBounds.	"fullBounds is shared with original!!"	new instVarAt: 5 put: (color veryDeepCopyWith: deepCopier).		"color, OK to test, may be complex"	new instVarAt: 6 put: (extension veryDeepCopyWith: deepCopier).		"extension object is not supposed to be held in any other inst field!!		If it is, two copies will be made."	index _ class instSize.	[index > 6] whileTrue: 		[sub _ self instVarAt: index.		(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])			ifNil: [new instVarAt: index put: (sub veryDeepCopyWith: deepCopier)]			ifNotNil: [new instVarAt: index put: subAss value].		index _ index - 1].	new submorphsDo: [:morph | morph privateOwner: new].  "strengthen weak pointer"	^ new! !!EToyPalette methodsFor: 'copying' stamp: 'tk 8/19/1998 16:23'!veryDeepCopyWith: deepCopier	"Lots of special stuff.  See storeDataOn:"	^ self error: 'not specialized yet'    "Is this class used any more?"! !!Player methodsFor: 'clone' stamp: 'tk 8/20/1998 15:52'!copyUniClass	"my class is a subclass of Player.  Return another class just like my class.  Share the costume list."	| newCls |	newCls _ self class officialClass 		newUniqueClassInstVars: self class instanceVariablesString 		classInstVars: self class class instanceVariablesString.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	newCls instVarAt: 10 "scripts" put: self class scripts.	"later must duplicate this"	newCls instVarAt: 11 "slotInfo" put: self class slotInfo deepCopy.	newCls instVarAt: 12 "costumeDictionary" put: self class costumeDictionary copy.	newCls copyAddedStateFrom: self class.  "The player-ref jump table?"	^ newCls! !!Point methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!SmallInteger methodsFor: 'copying' stamp: 'tk 8/19/1998 16:04'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!StrikeFont methodsFor: 'copying' stamp: 'tk 8/19/1998 16:15'!veryDeepCopyWith: deepCopier	"Return self.  I am shared.  Do not record me."! !!Symbol methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!TextStyle methodsFor: 'Disk I/O' stamp: 'tk 8/20/1998 08:48'!veryDeepCopyWith: deepCopier	"All inst vars are meant to be shared"	| new absent |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	new _ self clone.	deepCopier references at: self put: new.	"remember"	^ new! !!UndefinedObject methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!WorldMorph reorganize!('initialization' configureForConstruction initialize open openWithTitle: positionControlPanel:)('install / exit' exit goBack install sleep)('classification' isWorldMorph)('accessing' activeHand canvas canvas: color: viewBox viewBox: world)('submorphs-accessing' allMorphsDo:)('drawing' assuredCanvas displayWorld displayWorldAsTwoTone displayWorldNonIncrementally doDeferredUpdating drawInvalidAreasOn: flashRects:color: selectHandsToDrawForDamage:)('events' handlesMouseDown: mouseDown:)('stepping' adjustWakeupTimes adjustWakeupTimesIfNecessary isStepping: runStepMethods startStepping: startSteppingSubmorphsOf: stopStepping:)('hands' activeHand: addHand: hands removeHand:)('change reporting' fullRepaintNeeded invalidRect:)('interaction loop' doOneCycle doOneCycleInBackground doOneCycleNow interCyclePause startBackgroundProcess)('dropping' acceptDroppingMorph:event:)('painting support' installForm: paintArea paintAreaFor: paintBox)('sensing' colorAt:belowMorph:)('fileIn/Out' addMorphsAndModel: saveAsWorld storeDataOn: veryDeepCopyWith:)('halos' abandonAllHalos haloMorphOrNil haloMorphs mouseOverHalosEnabled)('etoy support' allKnownNames allTileScriptingElements chooseClickTarget goVGA nextPage presenter previousPage referencePlayfield residesInPartsBin slotNamesAndTypesForBank: soundsEnabled specialNameInModelFor: standardHolder standardPlayerHit standardSystemController)('submorphs-add/remove' addAllMorphs: addMorph:centeredNear:)('object fileIn' convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslp0:bosfcepcbbfgccpmcpbttloiairfidcuwhavcdslpl0: convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslpl0:bosfcepcbbfgccpmcpbttloiairfidcuwhavcdslplb0: convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslplb0:bosfcepcbbfgccpmcpbttloiairfidcuwhavcdsllb0: convertbosfcephvcdslm0:bosfcepcbbfgccpmcpbttloiairfidcuhavcdslp0:)('balloon help' balloonHelpEnabled toggleShowBalloons)!!WorldMorph methodsFor: 'fileIn/Out' stamp: 'tk 8/20/1998 22:18'!veryDeepCopyWith: deepCopier	"Does a WorldMorph really need to be veryDeepCopied?  If so, only copy submorphs, model, and stepList.  Lots of special stuff.  See storeDataOn:"	^ self error: 'not specialized yet'! !TranslucentColor removeSelector: #veryDeepCopyWith:!TransparentColor removeSelector: #veryDeepCopyWith:!