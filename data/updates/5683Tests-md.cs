'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5657] on 29 January 2004 at 12:08:36 pm'!"Change Set:		Tests-mdDate:			29 January 2004Author:			Marcus DenkerThese are all the tests from the BaseImage tests package on SqueakMap.We decided to add these to the image to make it more  easy to add new testsand, most important, allow the tests to be used as runnable documentation.Conventions used:a) All tests are in a parallel class-category with the prefix Tests-    This makes it easy to remove all tests.b) Tests for single classes: These tests are named ClassToBeTestedTest, all    tests that test a single method are named testOriginalMethod, and are    in a method-categorie named like the original, but with the prefix     'testing - '.    For these kinds of tests an abstrakt subclass of TestCase (named ClassTestCase)    is provided that adds common tests that seem to be usefull in all cases.    (three up to now: a test if all methods are categoriesed, a test to send new    and a test that looks if a class comment is provided)c) Tests that are testing more than one class (whole subsystems) or test     for complex bugs are of course possible. These can be put in an existing    'Tests-*' category or even add their own (like Tests-KCP, or Tests-Bugs)."!Object subclass: #Analyzer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-KCP'!TestCase subclass: #AnalyzerTest	instanceVariableNames: 'classesCreated'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-KCP'!Object subclass: #AnotherDummyClassForTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-KCP'!TestCase subclass: #AssociationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Support'!TestCase subclass: #BCCMTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Classes'!!BCCMTest commentStamp: '<historical>' prior: 0!This class contains some tests regarding the classes 	Behavior		ClassDescription			Class			Metaclass---	!Object subclass: #BadEqualer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Utilities'!!BadEqualer commentStamp: 'mjr 8/20/2003 13:28' prior: 0!I am an object that doesn't always report #= correctly.  Used for testing the EqualityTester.!Object subclass: #BadHasher	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Utilities'!!BadHasher commentStamp: 'mjr 8/20/2003 13:28' prior: 0!I am an object that doesn't always hash correctly.  I am used for testing the HashTester.!TestCase subclass: #BalloonFontTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Widgets'!TestCase subclass: #Base64MimeConverterTest	instanceVariableNames: 'message'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Streams'!!Base64MimeConverterTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Base64MimeConverter. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!TestCase subclass: #BecomeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-VM'!TestCase subclass: #BitBltClipBugs	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Bugs'!TestCase subclass: #BitmapBugz	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Bugs'!TestCase subclass: #BitmapStreamTests	instanceVariableNames: 'random array stream'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Bugs'!TestCase subclass: #BlockContextTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Methods'!TestCase subclass: #ByteArrayBugz	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Bugs'!TestCase subclass: #ClassBuilderChangeClassTypeTest	instanceVariableNames: 'baseClass subClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Classes'!TestCase subclass: #ClassBuilderFormatTests	instanceVariableNames: 'baseClass subClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Classes'!TestCase subclass: #ClassRenameFixTest	instanceVariableNames: 'previousChangeSet testsChangeSet'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Bugs'!TestCase subclass: #ClassTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Classes'!TestCase subclass: #ClassTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Utilities'!!ClassTestCase commentStamp: 'brp 7/26/2003 16:57' prior: 0!This class is intended for unit tests of individual classes and their metaclasses.It provides methods to determine the coverage of the unit tests.Subclasses are expected to re-implement #classesToBeTested and #selectorsToBeIgnored.They should also implement to confirm that all methods have been tested.#testCoverage	super testCoverage.!ClassTestCase subclass: #ArrayTest	instanceVariableNames: 'example1'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Arrayed'!!ArrayTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Array. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #AtomMorphTest	instanceVariableNames: 'morph'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Demo'!!AtomMorphTest commentStamp: '<historical>' prior: 0!This is the unit test for the class AtomMorph. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #BitBltTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Graphics-Primitives'!ClassTestCase subclass: #BlobMorphTest	instanceVariableNames: 'morph'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Demo'!!BlobMorphTest commentStamp: '<historical>' prior: 0!This is the unit test for the class BlobMorph. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #BooleanTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Objects'!!BooleanTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Boolean. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #CharacterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Text'!!CharacterTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Character. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #ClassDescriptionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Classes'!!ClassDescriptionTest commentStamp: '<historical>' prior: 0!This is the unit test for the class ClassDescription. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!TestCase subclass: #CleanKernelTest	instanceVariableNames: 'classesCreated'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-KCP'!ClassTestCase subclass: #CompiledMethodTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Methods'!!CompiledMethodTest commentStamp: '<historical>' prior: 0!This is the unit test for the class CompiledMethod. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!TestCase subclass: #DebuggerUnwindBug	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!ClassTestCase subclass: #DelayTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Processes'!TestCase subclass: #DictionaryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Unordered'!Object subclass: #DummyClassForTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-KCP'!Object subclass: #DummyToolWorkingWithFileList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Tools-FileList'!!DummyToolWorkingWithFileList commentStamp: '<historical>' prior: 0!I'm a dummy class for testing that the registration of the tool to the FileList of actually happens.In the future the tests should cover that the class register when loaded in memory and unregister when unloaded.!ClassTestCase subclass: #EventManagerTest	instanceVariableNames: 'eventSource eventListener succeeded'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-System-Object Events'!TestCase subclass: #EventTest	instanceVariableNames: 'eventSource eventListener succeeded'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-System-Object Events'!Object subclass: #ExceptionTester	instanceVariableNames: 'log suiteLog'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!TestCase subclass: #ExceptionTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!ClassTestCase subclass: #FalseTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Objects'!!FalseTest commentStamp: '<historical>' prior: 0!This is the unit test for the class False. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #FileDirectoryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-System-Files'!TestCase subclass: #FileList2ModalDialogsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Tools-FileList'!!FileList2ModalDialogsTest commentStamp: '<historical>' prior: 0!TestRunner open!ClassTestCase subclass: #FileListTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Tools-FileList'!TestCase subclass: #FlapsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Flaps'!!FlapsTest commentStamp: '<historical>' prior: 0!A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.!ClassTestCase subclass: #FloatTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Numbers'!ClassTestCase subclass: #FractionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Numbers'!TestCase subclass: #HashAndEqualsTestCase	instanceVariableNames: 'prototypes'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Utilities'!!HashAndEqualsTestCase commentStamp: 'mjr 8/20/2003 17:37' prior: 0!I am a simple TestCase that tests for correct operation of #hash and #=.Subclasses of me need to fill my prototypes with suitable objects to be tested.!HashAndEqualsTestCase subclass: #CRLookupItemTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Genie-Engine'!HashAndEqualsTestCase subclass: #FlashLineStyleTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Balloon-MMFlash Support'!TestCase subclass: #HashTesterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Utilities'!!HashTesterTest commentStamp: 'mjr 8/20/2003 12:48' prior: 0!I am a simple test case to check that HashTester works correctly!TestCase subclass: #InstVarRefLocatorTest	instanceVariableNames: 'tt'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Methods'!!InstVarRefLocatorTest commentStamp: '<historical>' prior: 0!This is the unit test for the class InstVarRefLocator. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!TestCase subclass: #InstructionClientTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Methods'!!InstructionClientTest commentStamp: '<historical>' prior: 0!This is the unit test for the class InstructionClient. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #InstructionPrinterTest	instanceVariableNames: 'tt'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Methods'!!InstructionPrinterTest commentStamp: '<historical>' prior: 0!This is the unit test for the class InstructionPrinter. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!TestCase subclass: #IntegerDigitLogicTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Numbers'!ClassTestCase subclass: #IntegerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Numbers'!ClassTestCase subclass: #IntervalTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Sequenceable'!TestCase subclass: #IslandVMTweaksTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-VM'!!IslandVMTweaksTestCase commentStamp: 'ls 7/10/2003 18:59' prior: 0!Test case for some tweaks to the VM that Islands requires.  These tests are largely for documentation; with an un-tweaked VM, the tests mostly still succeed, albeit with possible memory corruption.!ClassTestCase subclass: #LargeNegativeIntegerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Numbers'!ClassTestCase subclass: #LargePositiveIntegerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Numbers'!TestCase subclass: #MCPTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Kernel'!TestCase subclass: #MacFileDirectoryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-System-Files'!TestCase subclass: #MailAddressParserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Network-RFC822'!!MailAddressParserTest commentStamp: '<historical>' prior: 0!This is the unit test for the class MailAddressParser. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #MethodReferenceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Tools-Browser'!TestCase subclass: #MorphTest	instanceVariableNames: 'morph'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Kernel'!!MorphTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Morph. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!Error subclass: #MyResumableTestError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!Error subclass: #MyTestError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!Notification subclass: #MyTestNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!Object subclass: #NameOfSubclass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Bugs'!ClassTestCase subclass: #NumberTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Numbers'!ClassTestCase subclass: #ObjectTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Objects'!Object subclass: #ObjectWithInitialize	instanceVariableNames: ''	classVariableNames: 'ClassVar'	poolDictionaries: ''	category: 'Tests-KCP'!TestCase subclass: #ObsoleteMethodTest	instanceVariableNames: 'targetClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compatibility'!!ObsoleteMethodTest commentStamp: 'Noury Bouraqadi 10/22/2003 09:32' prior: 0!Abstract class.Subclasses should implement #obsoleteMethodSelector!ObsoleteMethodTest subclass: #EmptyInitializeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compatibility'!ObsoleteMethodTest subclass: #NewInitializeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compatibility'!!NewInitializeTest commentStamp: 'ar 9/16/2003 01:16' prior: 0!NewInitializeTest is a test which is run on all classes in the system to detect obsolete or otherwise considered invalid implementations of #new. It provides a set of patterns against which all implementations of #new are run. To add a new pattern provide a method beginning with #obsolete such as #obsoleteStrangeNewTest.!TestCase subclass: #OrderedCollectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Sequenceable'!!OrderedCollectionTest commentStamp: 'BG 1/10/2004 22:07' prior: 0!These test cases demonstrate addition of items into an OrderedCollection as well as item removal.Some of the assertions are quite complicated and use a lot of collection protocol. Such methods do not test one single method, but protocol in general.!Notification subclass: #ParserRemovedUnusedTemps	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!ClassTestCase subclass: #PasteUpMorphTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Worlds'!!PasteUpMorphTest commentStamp: '<historical>' prior: 0!I am a TestCase for PasteUpMorph.!ClassTestCase subclass: #PointTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Graphics-Primitives'!!PointTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Point. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #ProcessBrowserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Tools-Process Browser'!TestCase subclass: #ProcessTerminateBug	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!ClassTestCase subclass: #ProtoObjectTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Objects'!!ProtoObjectTest commentStamp: '<historical>' prior: 0!This is the unit test for the class ProtoObject. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!Object subclass: #PrototypeTester	instanceVariableNames: 'prototype'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Utilities'!!PrototypeTester commentStamp: 'mjr 8/20/2003 13:09' prior: 0!I am a simple holder of a prototype object and hand out copies when requested.!PrototypeTester subclass: #EqualityTester	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Utilities'!!EqualityTester commentStamp: 'mjr 8/20/2003 13:04' prior: 0!I provide a simple way to test the equality properties of any object.!PrototypeTester subclass: #HashTester	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Utilities'!!HashTester commentStamp: 'mjr 8/20/2003 12:48' prior: 0!I provide a simple way to test the hash properties of any object.  I am given an object that should be tested and I treat it like a prototype.  I take a copy of it when I am given it so that it can't change whilst I am holding on to it.  I can then test that multiple copies of this object all hash to the same value.!ClassTestCase subclass: #RandomTest	instanceVariableNames: 'gen'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Numbers'!ClassTestCase subclass: #ReadWriteStreamTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Streams'!!ReadWriteStreamTest commentStamp: '<historical>' prior: 0!This is the unit test for the class ReadWriteStream.Unit tests are a good way to exercise thefunctionality of your system in a repeatable andautomatic manner. They are therefore recommended ifyou plan to release anything. For more information,see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!TestCase subclass: #RectangleTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Graphics-Primitives'!ClassTestCase subclass: #ScriptableButtonTest	instanceVariableNames: 'button'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Scripting'!!ScriptableButtonTest commentStamp: '<historical>' prior: 0!A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.!ClassTestCase subclass: #SecureHashAlgorithmTest	instanceVariableNames: 'hash'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-System-Digital Signatures'!!SecureHashAlgorithmTest commentStamp: '<historical>' prior: 0!This is the unit test for the class SecureHashAlgorithm. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #SetTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Unordered'!!SetTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Set. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #SmallIntegerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Numbers'!TestCase subclass: #SocketStreamTest	instanceVariableNames: 'listener stream1 stream2'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Network-Kernel'!TestCase subclass: #StreamBugz	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Bugs'!ClassTestCase subclass: #StringTest	instanceVariableNames: 'string'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Text'!!StringTest commentStamp: '<historical>' prior: 0!This is the unit test for the class String. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #SymbolTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Text'!!SymbolTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Symbol. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!TestCase subclass: #TestCaseDoubleInitialize	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-KCP'!Morph subclass: #TestInWorldMorph	instanceVariableNames: 'intoWorldCount outOfWorldCount'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Kernel'!TestCase subclass: #TestIndenting	instanceVariableNames: 'para'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-ST80-Support'!TestCase subclass: #TestObjectsAsMethods	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-ObjectsAsMethods'!Object subclass: #TestObjectsAsMethodsFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-ObjectsAsMethods'!TestCase subclass: #TestParagraphFix	instanceVariableNames: 'para'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-ST80-Support'!!TestParagraphFix commentStamp: '<historical>' prior: 0!This class tests whether locating characters past the end of a text is possible in all cases.!TestParagraphFix subclass: #TestNewParagraphFix	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-ST80-Support'!!TestNewParagraphFix commentStamp: '<historical>' prior: 0!This class tests the same things as its superclass, but for NewParagraph which is used in the Morphic environment.!TestCase subclass: #TestsForTextAndTextStreams	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Text'!!TestsForTextAndTextStreams commentStamp: '<historical>' prior: 0!At May 09, 2003 Tim Olson sent a bug report to the Squeak developers list that inspired me to examine the protocol of TextStream in greater detail.  (The bug that Tim reported was present in Squeak 3.4, it is shown in testExample1.) In a discussion that followed,  Daniel Vainsencher proposed that we should have tests for Text and TextStreams. This class is an attempt to implement that proposal. For Squeak 3.4, some of the test examples fail.!HashAndEqualsTestCase subclass: #TextAlignmentTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Text'!HashAndEqualsTestCase subclass: #TextAnchorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Text Support'!HashAndEqualsTestCase subclass: #TextEmphasisTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Text'!HashAndEqualsTestCase subclass: #TextFontChangeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Text'!HashAndEqualsTestCase subclass: #TextFontReferenceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Text'!HashAndEqualsTestCase subclass: #TextKernTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Text'!TestCase subclass: #TextLineEndingsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Text'!!TextLineEndingsTest commentStamp: 'nk 11/1/2003 07:55' prior: 0!This is a test case for Text>>withSqueakLineEndings and String>>withSqueakLineEndings.The main problem we've seen with the Text version is that it doesn't preserve formatting correctly.!HashAndEqualsTestCase subclass: #TextLineTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Text Support'!ClassTestCase subclass: #TextMorphTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Morphic-Basic'!HashAndEqualsTestCase subclass: #TextStyleTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Graphics-Text'!ClassTestCase subclass: #TextTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Text'!!TextTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Text. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #TrueTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Objects'!TestCase subclass: #UUIDPrimitivesTest	instanceVariableNames: ''	classVariableNames: 'Default'	poolDictionaries: ''	category: 'Tests-Network-UUID'!ClassTestCase subclass: #UndefinedObjectTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Objects'!!UndefinedObjectTest commentStamp: '<historical>' prior: 0!This is the unit test for the class UndefinedObject. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #UrlTest	instanceVariableNames: 'url baseUrl expected string'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Network-Url'!!UrlTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Url. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!ClassTestCase subclass: #WeakMessageSendTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Kernel-Objects'!ClassTestCase subclass: #WriteStreamTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Streams'!Object subclass: #YetDummyClassForTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-KCP'!!Analyzer class methodsFor: 'dependencies' stamp: 'md 10/29/2003 23:40'!dependenciesForClass: aClass 	| r |	r := Set new.	aClass methodDict values		do: [:cm | (cm literals				select: [:l | l isKindOf: LookupKey]) 				do: [:ll | ll key						ifNotNil: [r add: ll key]]].	^ r! !!Analyzer class methodsFor: 'dependencies' stamp: 'md 10/29/2003 23:40'!externalReference	^ self ! !!Analyzer class methodsFor: 'dependencies' stamp: 'md 10/29/2003 23:40'!externalReferenceOf: aCollectionOfClass 	| r |	r := Set new.	aCollectionOfClass		do: [:cls | r				addAll: (self dependenciesForClass: cls)].	aCollectionOfClass 		do: [:clss | r				remove: clss name				ifAbsent: []].	^ r! !!Analyzer class methodsFor: 'methods' stamp: 'md 10/29/2003 23:39'!doesClass: cls define: aSelector 	^ cls methodDict includesKey: aSelector ! !!Analyzer class methodsFor: 'methods' stamp: 'md 10/29/2003 23:39'!methodsCalledAndCalleeForClass: aClass 	| r |	r := Set new.	aClass methodDict		associationsDo: [:assoc | (assoc value literals				select: [:l | l isKindOf: Symbol])				do: [:ll | r 						add: (Array with: assoc key with: ll)]].	^ r! !!Analyzer class methodsFor: 'methods' stamp: 'md 10/29/2003 23:39'!methodsCalledForClass: aClass 	| r |	r := Set new.	aClass methodDict values 		do: [:cm | (cm literals				select: [:l | l isKindOf: Symbol])				do: [:ll | r add: ll]].	^ r! !!Analyzer class methodsFor: 'methods' stamp: 'md 10/29/2003 23:39'!methodsDefinedForClass: aClass 	^ aClass methodDict keys ! !!Analyzer class methodsFor: 'methods' stamp: 'md 10/29/2003 23:40'!methodsIn: cls callingMethodsDefinedIn: classes 	"Give collection matching (m1, m2) where: 			- m1 is defined in C 			- m2 is defined in classes 			- m2 called in m1 of C, 		- and m2 not defined in C"		"We made the following assumption: If a method foo is in defined in cls  	and in classes, then if cls call foo, then it calls its own"	| methodsCalled allMethodsDefined ans |	methodsCalled := self methodsCalledAndCalleeForClass: cls.	allMethodsDefined := Set new.	classes		do: [:clss | allMethodsDefined				addAll: (self methodsDefinedForClass: clss)].	ans := methodsCalled				select: [:calleeCalled | (self doesClass: cls define: calleeCalled second) not						and: [allMethodsDefined includes: calleeCalled second]].	^ ans! !!Analyzer class methodsFor: 'methods' stamp: 'md 10/29/2003 23:40'!referingMethodsDefinedInSubclasses: aClass 	| r |	r := self methodsCalledForClass: aClass. 	subclasses := aClass allSubclasses.	subclasses remove: aClass! !!Analyzer class methodsFor: 'examples' stamp: 'md 10/29/2003 23:39'!example1	"self example1"	Analyzer externalReferenceOf: (#(#Object #Behavior #ClassDescription #Class )			collect: [:clsname | Smalltalk at: clsname]) inspect ! !!Analyzer class methodsFor: 'examples' stamp: 'md 10/29/2003 23:39'!example2	"self example2"	(Analyzer 		externalReferenceOf: (#(#Behavior #ClassDescription #Class )				collect: [:clsname | Smalltalk at: clsname])) inspect! !!Analyzer class methodsFor: 'examples' stamp: 'md 10/29/2003 23:39'!example3	"self example3"	(((Analyzer		externalReferenceOf: (#(#Behavior #ClassDescription #Class )				collect: [:clsname | Smalltalk at: clsname]))		select: [:clsName | (Smalltalk includesKey: clsName) 				and: [(Smalltalk at: clsName)						isKindOf: Class]])		select: [:clssName | ((Smalltalk at: clssName) category asString beginsWith: 'Kernel') not]) inspect! !!Analyzer class methodsFor: 'examples' stamp: 'md 10/29/2003 23:39'!example4 	"self example4"	(((Analyzer		externalReferenceOf: (#(#Object #Behavior #ClassDescription #Class )				collect: [:clsname | Smalltalk at: clsname]))		select: [:clsName | (Smalltalk includesKey: clsName)				and: [(Smalltalk at: clsName)						isKindOf: Class]])		select: [:clssName | ((Smalltalk at: clssName) category asString beginsWith: 'Kernel') not]) inspect! !!Analyzer class methodsFor: 'examples' stamp: 'md 10/29/2003 23:39'!example5	"self example5"	| classes | 	classes := #(#ClassBuilder #ClassDescription #Class )				collect: [:clsname | Smalltalk at: clsname].	(Analyzer methodsIn: Behavior callingMethodsDefinedIn: classes) inspect! !!AnalyzerTest methodsFor: 'utility' stamp: 'ab 3/8/2003 13:55'!createClass: aClassname	^ self createClass: aClassname superclass: Object ! !!AnalyzerTest methodsFor: 'utility' stamp: 'md 10/29/2003 23:42'!createClass: aClassname superclass: aClass 	| r |	r _ aClass		subclass: aClassname		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Tests-KCP'.	classesCreated add: r.	^ r! !!AnalyzerTest methodsFor: 'utility' stamp: 'md 10/29/2003 23:41'!removeClassIfExists: aClassname 	Smalltalk		at: aClassname		ifPresent: [:cls | cls removeFromSystem] ! !!AnalyzerTest methodsFor: 'utility' stamp: 'rw 5/12/2003 11:56'!removeClassNamedIfExists: aClassname	Smalltalk at: aClassname ifPresent: [:cls| cls removeFromSystem].	Smalltalk at: aClassname ifPresent: [:clss| self error: 'Error !!!!']! !!AnalyzerTest methodsFor: 'running' stamp: 'ab 3/8/2003 13:54'!setUp	classesCreated _ OrderedCollection new! !!AnalyzerTest methodsFor: 'running' stamp: 'sd 5/23/2003 14:51'!tearDown	| name |	classesCreated		do: [:cls | 			name _ cls name.			self removeClassNamedIfExists: name.			ChangeSet current removeClassChanges: name].	classesCreated _ nil! !!AnalyzerTest methodsFor: 'dependencies' stamp: 'ab 3/8/2003 14:04'!testDependenciesForClass	| cls r |	cls _ self createClass: #MyClass.	"-------"	cls compile: 'foo ^ Object'.	cls compile: 'bar Transcript show: ''blah blah'''.	cls compile: 'zork OrderedCollection new'.	"-------"	r _ Analyzer dependenciesForClass: cls.	self assert: r size = 3.	self		assert: (r includesAllOf: #(#Object #Transcript #OrderedCollection )).! !!AnalyzerTest methodsFor: 'dependencies' stamp: 'ab 3/8/2003 14:04'!testExternalReferenceOf	| r cls1 cls2 cls3 |	cls1 _ self createClass: #MyClass1.	cls2 _ self createClass: #MyClass2.	cls3 _ self createClass: #MyClass3.	"-------"	cls1 compile: 'foo ^ MyClass2'.	cls1 compile: 'bar MyClass1 show: ''blah blah'''.	cls1 compile: 'zork OrderedCollection new'.	cls1 compile: 'baz Morph new openInWorld'.	"-------"	cls2 compile: 'foo ^ Object'.	cls2 compile: 'bar Transcript show: ''blah blah'''.	cls2 compile: 'zork OrderedCollection new'.	"-------"	cls3 compile: 'foo ^ Object'.	cls3 compile: 'bar Transcript show: ''blah blah'''.	cls3 compile: 'zork MyClass3 new'.	"-------"	r _ Analyzer				externalReferenceOf: (#(#MyClass1 #MyClass2 #MyClass3 )						collect: [:clsName | Smalltalk at: clsName]).	self assert: r size = 4.	self		assert: (r includesAllOf: #(#Object #Transcript #OrderedCollection #Morph )).! !!AnalyzerTest methodsFor: 'methods' stamp: 'ab 3/8/2003 14:03'!testMethodCallDefinedInSubclasses	| cls1 cls2 r |	cls1 _ self createClass: #MyClass1.	cls2 _ self createClass: #MyClass2 superclass: cls1.	"-------"	cls1 compile: 'foo ^ self bar'.	cls2 compile: 'bar ^ true'.	"-------"	self assert: cls2 new foo.	r _ Analyzer				methodsIn: cls1				callingMethodsDefinedIn: (Array with: cls2).	r _ r asOrderedCollection.	self assert: r size = 1.	self assert: r first size = 2.	self assert: r first first == #foo.	self assert: r first second == #bar.! !!AnalyzerTest methodsFor: 'methods' stamp: 'ab 3/8/2003 14:03'!testMethodCallDefinedInSubclasses2	| cls1 cls2 r cls3 cls4 |	cls1 _ self createClass: #MyClass1.	cls2 _ self createClass: #MyClass2 superclass: cls1.	cls3 _ self createClass: #MyClass3.	cls4 _ self createClass: #MyClass4 superclass: cls3.	"-------"	cls1 compile: 'foo ^ self f1; f2'.	cls1 compile: 'bar ^ self f3; foo'.	cls1 compile: 'zork ^ self bar; blah'.	cls2 compile: 'f1 ^ true'.	cls2 compile: 'f2 ^ true'.	cls3 compile: 'f3 ^ true'.	cls3 compile: 'foo ^ true'.	cls4 compile: 'f3 ^ true'.	cls4 compile: 'f4 ^ true'.	cls4 compile: 'bleubleu ^ true'.	cls4 compile: 'bouba ^ true'.	"-------"	r _ Analyzer				methodsIn: cls1				callingMethodsDefinedIn: (Array						with: cls2						with: cls3						with: cls4).	r _ r asOrderedCollection.	self assert: r size = 3.	self		assert: (r includesAllOf: #(#(#foo #f1) #(#foo #f2) #(#bar #f3) )).! !!AnalyzerTest methodsFor: 'methods' stamp: 'ab 3/8/2003 14:03'!testMethodsCalledAndCalleeForClass	| cls r |	cls _ self createClass: #MyClass.	"-------"	cls compile: 'foo ^ Object'.	cls compile: 'bar Transcript show: ''blah blah'''.	cls compile: 'zork OrderedCollection new'.	cls compile: 'foobar Object new asMorph; beep'.	"-------"	r _ Analyzer methodsCalledAndCalleeForClass: cls.	self assert: r size = 3.	self		assert: (r includesAllOf: #(#(#bar #show:) #(#foobar #asMorph) #(#foobar #asMorph) )).! !!AnalyzerTest methodsFor: 'methods' stamp: 'ab 3/8/2003 14:03'!testMethodsCalledForClass	| cls r |	cls _ self createClass: #MyClass.	"-------"	cls compile: 'foo ^ Object'.	cls compile: 'bar Transcript show: ''blah blah'''.	cls compile: 'zork OrderedCollection new'.	cls compile: 'foobar Object new asMorph; beep'.	"-------"	r _ Analyzer methodsCalledForClass: cls.	self assert: r size = 3.	self		assert: (r includesAllOf: #(#beep #show: #asMorph )).! !!AnotherDummyClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 4/15/2003 21:19'!callingAThirdMethod	self inform: ';lkl;'.	self zoulouSymbol! !!AnotherDummyClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 4/15/2003 20:49'!zoulouSymbol	self callingAThirdMethod! !!AssociationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 20:20'!testEquality	| a b |	a _ 1 -> 'one'.	b _ 1 -> 'een'.		self 		assert: (a key = b key);		deny: (a value = b value);		deny: (a = b)! !!BCCMTest methodsFor: 'testing' stamp: 'HJH 2/24/2003 11:29'!test01metaclassName	self assert: Dictionary class  name = 'Dictionary class'.	self assert: OrderedCollection class name = 'OrderedCollection class'.	! !!BCCMTest methodsFor: 'testing' stamp: 'HJH 2/24/2003 11:28'!test02metaclassNumberOfInstances	self assert: Dictionary class allInstances size  = 1.	self assert: OrderedCollection class allInstances size  = 1.! !!BCCMTest methodsFor: 'testing' stamp: 'HJH 2/24/2003 11:36'!test03superclass	| s |	self assert: Dictionary superclass == Set.	self assert: OrderedCollection superclass == SequenceableCollection.	s _ OrderedCollection new.	s add: SequenceableCollection.	s add: Collection.	s add: Object.	s add: ProtoObject.	self assert: OrderedCollection allSuperclasses = s.		! !!BCCMTest methodsFor: 'testing' stamp: 'HJH 2/24/2003 11:39'!test04metaclassSuperclass	| s |	self assert: Dictionary class superclass == Set class.	self assert: OrderedCollection class superclass == SequenceableCollection class.	! !!BCCMTest methodsFor: 'testing' stamp: 'HJH 2/24/2003 12:53'!test05metaclassSuperclassHierarchy	| s |		self assert: SequenceableCollection class instanceCount  = 1.	self assert: Collection class instanceCount  = 1.	self assert: Object class instanceCount  = 1.	self assert: ProtoObject class instanceCount  = 1.		s _ OrderedCollection new.	s add: SequenceableCollection class.	s add: Collection class.	s add: Object class.	s add: ProtoObject class.	s add: Class.	s add: ClassDescription.	s add: Behavior.	s add: Object.	s add: ProtoObject.	self assert: OrderedCollection class allSuperclasses  = s.			! !!BCCMTest methodsFor: 'testing' stamp: 'HJH 2/24/2003 12:53'!test06ClassDescriptionAllSubInstances		| cdNo clsNo metaclsNo |	cdNo _ ClassDescription allSubInstances size.	clsNo _ Class allSubInstances size .	metaclsNo _ Metaclass allSubInstances size.	self assert: cdNo = (clsNo + metaclsNo).						! !!BCCMTest methodsFor: 'testing' stamp: 'HJH 2/24/2003 13:02'!test07bmetaclassPointOfCircularity		self assert: Metaclass class instanceCount = 1.	self assert: Metaclass class someInstance == Metaclass.						! !!BCCMTest methodsFor: 'testing' stamp: 'HJH 2/24/2003 12:16'!test07metaclass		self assert: OrderedCollection class class == Metaclass.	self assert: OrderedCollection class class = Metaclass.	self assert: Dictionary class class == Metaclass.	self assert: Dictionary class class = Metaclass.	self assert: Object class class == Metaclass.	self assert: Object class class = Metaclass.						! !!BCCMTest methodsFor: 'testing' stamp: 'HJH 2/24/2003 12:25'!test08BCCMhierarchy		self assert: Class superclass  == ClassDescription.	self assert: Metaclass superclass == ClassDescription.	self assert: ClassDescription superclass  == Behavior.	self assert: Behavior superclass  = Object.	self assert: Class class class ==  Metaclass.	self assert: Metaclass class class  == Metaclass.	self assert: ClassDescription class class == Metaclass.	self assert: Behavior class class == Metaclass.						! !!BCCMTest methodsFor: 'testing' stamp: 'HJH 2/24/2003 12:43'!test09ObjectAllSubclasses	| n2 |	n2 _ Object allSubclasses size.	self assert: n2 = (Object allSubclasses			select: [:cls | cls class class == Metaclass					or: [cls class == Metaclass]]) size! !!BadEqualer methodsFor: 'comparing' stamp: 'mjr 8/20/2003 18:56'!= other 	self class = other class		ifFalse: [^ false].	^ 100 atRandom < 30 ! !!BadHasher methodsFor: 'comparing' stamp: 'mjr 8/20/2003 18:56'!hash	"answer with a different hash some of the time"	100 atRandom < 30		ifTrue: [^ 1]. 	^ 2! !!BalloonFontTest methodsFor: 'testing' stamp: 'sd 12/9/2001 21:44'!testDefaultFont	"(self selector: #testDefaultFont) debug"	self assert: RectangleMorph new balloonFont = BalloonMorph balloonFont.	self assert: RectangleMorph new defaultBalloonFont = BalloonMorph balloonFont.! !!BalloonFontTest methodsFor: 'testing' stamp: 'sd 12/9/2001 21:55'!testSpecificFont	"(self selector: #testSpecificFont) debug"	| aMorph |	aMorph := RectangleMorph new.	self assert: RectangleMorph new balloonFont = BalloonMorph balloonFont.	self assert: RectangleMorph new defaultBalloonFont = BalloonMorph balloonFont.	aMorph		balloonFont: (StrikeFont familyName: #ComicPlain size: 19).	self assert: aMorph balloonFont			= (StrikeFont familyName: #ComicPlain size: 19).	"The next test is horrible because I do no know how to access the font 	with the appropiate interface"	self assert: (((BalloonMorph getTextMorph: 'lulu' for: aMorph) text runs at: 1)			at: 1) font			= (StrikeFont familyName: #ComicPlain size: 19)! !!Base64MimeConverterTest methodsFor: 'initialize-release' stamp: 'md 3/17/2003 15:37'!setUp	message _ ReadWriteStream on: (String new: 10).	message nextPutAll: 'Hi There!!'.! !!Base64MimeConverterTest methodsFor: 'initialize-release' stamp: 'md 3/17/2003 15:34'!tearDown	"I am called whenever your test ends. I am the place where you release the ressources"! !!Base64MimeConverterTest methodsFor: 'initialize-release' stamp: 'md 3/17/2003 15:45'!testMimeEncodeDecode	| encoded |	encoded _ Base64MimeConverter mimeEncode: message.		self should: [encoded contents = 'SGkgVGhlcmUh'].     self should: [(Base64MimeConverter mimeDecodeToChars: encoded)                      contents = message contents].! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 15:28'!testBecome	"Test the two way become. Note. we cannot use string literals for this test"	| a b c d |	a := 'ab' copy.	b := 'cd' copy.	c := a.	d := b.	a become: b.	self 		assert: a = 'cd';		assert: b = 'ab';		assert: c = 'cd';		assert: d = 'ab'.! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 15:28'!testBecomeForward	"Test the forward become."	| a b c d |	a := 'ab' copy.	b := 'cd' copy.	c := a.	d := b.	a becomeForward: b.	self 		assert: a = 'cd';		assert: b = 'cd';		assert: c = 'cd';		assert: d = 'cd'.! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 17:36'!testBecomeForwardDontCopyIdentityHash	"Check that		1. the argument to becomeForward: is NOT modified to have the receiver's identity hash.		2. the receiver's identity hash is unchanged." 	| a b hb |	a := 'ab' copy.	b := 'cd' copy.	hb := b identityHash.	a becomeForward: b copyHash: false.	self 		assert: a identityHash = hb;		assert: b identityHash = hb.! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 15:29'!testBecomeForwardHash	| a b c hb |	a := 'ab' copy.	b := 'cd' copy.	c := a.	hb := b hash.	a becomeForward: b.	self 		assert: a hash = hb;		assert: b hash = hb;		assert: c hash = hb.! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 15:27'!testBecomeForwardIdentityHash	"Check that		1. the argument to becomeForward: is modified to have the receiver's identity hash.		2. the receiver's identity hash is unchanged." 	| a b ha |	a := 'ab' copy.	b := 'cd' copy.	ha := a identityHash.	a becomeForward: b.	self 		assert: a identityHash = ha;		assert: b identityHash = ha.! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 15:30'!testBecomeHash	| a b c d ha hb |	a := 'ab' copy.	b := 'cd' copy.	c := a.	d := b.	ha := a hash.	hb := b hash.	a become: b.	self 		assert: a hash = hb;		assert: b hash = ha;		assert: c hash = hb;		assert: d hash = ha.! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 15:31'!testBecomeIdentityHash	"Note. The identity hash of both objects seems to change after the become:"	| a b c d |	a := 'ab' copy.	b := 'cd' copy.	c := a.	d := b.	a become: b.	self 		assert: a identityHash = c identityHash;		assert: b identityHash = d identityHash;		deny: a identityHash = b identityHash.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:33'!testDrawingWayOutside	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: 100; height: 100.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:33'!testDrawingWayOutside2	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: 0@0.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:33'!testDrawingWayOutside3	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:34'!testDrawingWayOutside4	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: 100; height: 100.	bb sourceOrigin: SmallInteger maxVal squared asPoint.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:34'!testDrawingWayOutside5	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: 0@0.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	bb sourceOrigin: SmallInteger maxVal squared asPoint.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:34'!testDrawingWayOutside6	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	bb sourceOrigin: SmallInteger maxVal squared asPoint.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:32'!testFillingWayOutside	| f1 bb |	f1 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb fillColor: Color black.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: 100; height: 100.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:32'!testFillingWayOutside2	| f1 bb |	f1 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb fillColor: Color black.	bb destOrigin: 0@0.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:32'!testFillingWayOutside3	| f1 bb |	f1 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb fillColor: Color black.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	self shouldnt:[bb copyBits] raise: Error.! !!BitmapBugz methodsFor: 'as yet unclassified' stamp: 'ar 8/2/2003 19:21'!testBitmapByteAt	| bm |	bm := Bitmap new: 1.	1 to: 4 do:[:i|		self should:[bm byteAt: i put: 1000] raise: Error.	].! !!BitmapStreamTests methodsFor: 'private' stamp: 'nk 7/5/2003 16:33'!randomShortInt	^((random next * 65536) - 32768) truncated! !!BitmapStreamTests methodsFor: 'private' stamp: 'nk 7/5/2003 16:00'!randomShortPoint	^(((random next * 65536) @ (random next * 65536)) - (32768 @ 32768)) truncated! !!BitmapStreamTests methodsFor: 'private' stamp: 'nk 7/5/2003 18:26'!randomWord	"Answer a random 32-bit integer"	| w |	random seed: (w _ random nextValue).	^w truncated! !!BitmapStreamTests methodsFor: 'private' stamp: 'nk 7/5/2003 18:11'!validateImageSegment	"array is set up with an array."	| other filename |	filename _ 'bitmapStreamTest.extSeg'.	FileDirectory default deleteFileNamed: filename ifAbsent: [ ].	(ImageSegment new copyFromRootsForExport: (Array with: array))         writeForExport: filename.	other _ (FileDirectory default readOnlyFileNamed: filename)		fileInObjectAndCode.	self assert: array = other originalRoots first! !!BitmapStreamTests methodsFor: 'private' stamp: 'nk 7/5/2003 18:17'!validateRefStream	"array is set up with an array."	| other rwstream |	rwstream _ RWBinaryOrTextStream on: (ByteArray new: array basicSize * 6).	stream _ ReferenceStream on: rwstream.	stream nextPut: array; close.	rwstream position: 0.	stream _ ReferenceStream on: rwstream.	other _ stream next.	stream close.	self assert: array = other! !!BitmapStreamTests methodsFor: 'private' stamp: 'nk 7/5/2003 18:22'!validateRefStreamOnDisk	"array is set up with an array."	| other filename |	filename _ 'bitmapStreamTest.ref'.	FileDirectory default deleteFileNamed: filename ifAbsent: [ ].	stream _ ReferenceStream fileNamed: filename.	stream nextPut: array; close.	stream _ ReferenceStream fileNamed: filename.	other _ stream next.	stream close.	self assert: array = other! !!BitmapStreamTests methodsFor: 'private' stamp: 'nk 7/5/2003 16:43'!validateSmartRefStream	"array is set up with an array."	| other |	stream _ RWBinaryOrTextStream on: (ByteArray new: array basicSize * 6).	stream binary.	stream fileOutClass: nil andObject: array.	stream position: 0.	stream binary.	other _ stream fileInObjectAndCode.	self assert: array = other! !!BitmapStreamTests methodsFor: 'private' stamp: 'nk 7/5/2003 18:32'!validateSmartRefStreamOnDisk	"array is set up with an array."	| other filename |	filename _ 'bitmapStreamTest.ref'.	FileDirectory default deleteFileNamed: filename ifAbsent: [ ].	stream _ FileDirectory default fileNamed: filename.	stream fileOutClass: nil andObject: array.	stream close.	stream _ FileDirectory default fileNamed: filename.	other _ stream fileInObjectAndCode.	stream close.	self assert: array = other! !!BitmapStreamTests methodsFor: 'Running' stamp: 'nk 7/5/2003 15:22'!setUp	random _ Random new.! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:06'!testShortIntegerArrayWithImageSegment	array _ ShortIntegerArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortInt ].	self validateImageSegment	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:17'!testShortIntegerArrayWithRefStream	array _ ShortIntegerArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortInt ].	self validateRefStream	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:22'!testShortIntegerArrayWithRefStreamOnDisk	array _ ShortIntegerArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortInt ].	self validateRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 16:32'!testShortIntegerArrayWithSmartRefStream	array _ ShortIntegerArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortInt ].	self validateSmartRefStream 	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:31'!testShortIntegerArrayWithSmartRefStreamOnDisk	array _ ShortIntegerArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortInt ].	self validateSmartRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:12'!testShortPointArrayWithImageSegment	array _ ShortPointArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortPoint ].	self validateImageSegment 	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:17'!testShortPointArrayWithRefStream	array _ ShortPointArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortPoint ].	self validateRefStream 	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:22'!testShortPointArrayWithRefStreamOnDisk	array _ ShortPointArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortPoint ].	self validateRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 15:57'!testShortPointArrayWithSmartRefStream	array _ ShortPointArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortPoint ].	self validateSmartRefStream 	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:31'!testShortPointArrayWithSmartRefStreamOnDisk	array _ ShortPointArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortPoint ].	self validateSmartRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:12'!testShortRunArrayWithImageSegment	array _ ShortRunArray newFrom: ((1 to: 10) collect: [ :i | self randomShortInt ]).	self validateImageSegment 	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:17'!testShortRunArrayWithRefStream	array _ ShortRunArray newFrom: ((1 to: 10) collect: [ :i | self randomShortInt ]).	self validateRefStream 	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:22'!testShortRunArrayWithRefStreamOnDisk	array _ ShortRunArray newFrom: ((1 to: 10) collect: [ :i | self randomShortInt ]).	self validateRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 16:40'!testShortRunArrayWithSmartRefStream	array _ ShortRunArray newFrom: ((1 to: 10) collect: [ :i | self randomShortInt ]).	self validateSmartRefStream 	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:31'!testShortRunArrayWithSmartRefStreamOnDisk	array _ ShortRunArray newFrom: ((1 to: 10) collect: [ :i | self randomShortInt ]).	self validateSmartRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:25'!testWordArrayWithImageSegment	array _ WordArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomWord ].	self validateImageSegment	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:27'!testWordArrayWithRefStream	array _ WordArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomWord ].	self validateRefStream	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:27'!testWordArrayWithRefStreamOnDisk	array _ WordArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomWord ].	self validateRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:27'!testWordArrayWithSmartRefStream	array _ WordArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomWord ].	self validateSmartRefStream	! !!BitmapStreamTests methodsFor: 'Tests' stamp: 'nk 7/5/2003 18:31'!testWordArrayWithSmartRefStreamOnDisk	array _ WordArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomWord ].	self validateSmartRefStreamOnDisk	! !!BlockContextTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/24/2003 18:27'!testNoArguments	[10		timesRepeat: [:arg | 1 + 2]]		ifError: [:err :rcvr | self deny: err = 'This block requires 1 arguments.'].	[10		timesRepeat: [:arg1 :arg2 | 1 + 2]]		ifError: [:err :rcvr | self deny: err = 'This block requires 2 arguments.'] ! !!BlockContextTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/24/2003 18:25'!testOneArgument	| c |	c _ OrderedCollection new.	c add: 'hello'.	[c		do: [1 + 2]]		ifError: [:err :rcvr | self deny: err = 'This block requires 0 arguments.'].	[c		do: [:arg1 :arg2 | 1 + 2]]		ifError: [:err :rcvr | self deny: err = 'This block requires 2 arguments.'] ! !!BlockContextTest methodsFor: 'as yet unclassified' stamp: 'mjr 9/10/2003 23:01'!testValueWithArguments	self		should: [[3 + 4]				valueWithArguments: #(1 )]		raise: Error.	self		shouldnt: [[3 + 4]				valueWithArguments: #()]		raise: Error.	[[3 + 4]		valueWithArguments: #(1 )]		ifError: [:err :rcvr | self assert: err = 'Error: This block accepts 0 arguments, but was called with 1.'].	[[:i | 3 + 4]		valueWithArguments: #(1 2)]		ifError: [:err :rcvr | self assert: err = 'Error: This block accepts 1 argument, but was called with 2.']! !!ByteArrayBugz methodsFor: 'as yet unclassified' stamp: 'ar 8/2/2003 19:28'!testByteArrayLongAt	| ba value |	ba := ByteArray new: 4.	value := -1.	self shouldnt:[ba longAt: 1 put: value bigEndian: true] raise: Error.	self assert: (ba longAt: 1 bigEndian: true) = value.	self shouldnt:[ba longAt: 1 put: value bigEndian: false] raise: Error.	self assert: (ba longAt: 1 bigEndian: false) = value.! !!ClassBuilderChangeClassTypeTest methodsFor: 'utilities' stamp: 'BG 1/5/2004 22:49'!baseClassName   ^'TestClassForClassChangeTest'! !!ClassBuilderChangeClassTypeTest methodsFor: 'utilities' stamp: 'BG 1/5/2004 22:51'!cleanup	baseClass ifNotNil:[baseClass removeFromSystem].! !!ClassBuilderChangeClassTypeTest methodsFor: 'testing' stamp: 'BG 1/6/2004 00:04'!testClassCreationAndChange    |  success |  [baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.  self assert: baseClass isPointers.  self deny: baseClass isVariable.  success := true.     [Object variableSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.]      on: Error      do: [:exception |  success := false].  self assert: (success and: [baseClass isVariable]). ] ensure: [self cleanup]    ! !!ClassBuilderFormatTests methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!baseClassName	^#DummyClassBuilderFormatTestSuperClass! !!ClassBuilderFormatTests methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!cleanup	subClass ifNotNil:[subClass removeFromSystem].	baseClass ifNotNil:[baseClass removeFromSystem].! !!ClassBuilderFormatTests methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!makeByteVariableSubclassOf: aClass	subClass := aClass variableByteSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'! !!ClassBuilderFormatTests methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!makeIVarsSubclassOf: aClass	subClass := aClass subclass: self subClassName		instanceVariableNames: 'var3 var4'		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'! !!ClassBuilderFormatTests methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!makeNormalSubclassOf: aClass	subClass := aClass subclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'! !!ClassBuilderFormatTests methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!makeVariableSubclassOf: aClass	subClass := aClass variableSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.! !!ClassBuilderFormatTests methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:16'!makeWeakSubclassOf: aClass	subClass := aClass weakSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'! !!ClassBuilderFormatTests methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:16'!makeWordVariableSubclassOf: aClass	subClass := aClass variableWordSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'! !!ClassBuilderFormatTests methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:16'!subClassName	^#DummyClassBuilderFormatTestSubClass! !!ClassBuilderFormatTests methodsFor: 'testing' stamp: 'ar 1/4/2004 20:21'!testByteVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableByteSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self should:[self makeIVarsSubclassOf: baseClass] raise: Error.	self should:[self makeVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWeakSubclassOf: baseClass] raise: Error.	"bit classes"	self shouldnt:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderFormatTests methodsFor: 'testing' stamp: 'ar 1/4/2004 20:20'!testSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert:(subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert:(subClass isVariable).	self assert:(subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self shouldnt:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWordVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	] ensure:[self cleanup].! !!ClassBuilderFormatTests methodsFor: 'testing' stamp: 'ar 1/4/2004 20:21'!testSubclassWithInstanceVariables	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var1 var2'		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderFormatTests methodsFor: 'testing' stamp: 'ar 1/4/2004 20:20'!testVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	"pointer classes"	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderFormatTests methodsFor: 'testing' stamp: 'ar 1/4/2004 20:20'!testWeakSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object weakSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	"pointer classes"	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderFormatTests methodsFor: 'testing' stamp: 'ar 1/4/2004 20:20'!testWordVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableWordSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self should:[self makeIVarsSubclassOf: baseClass] raise: Error.	self should:[self makeVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWeakSubclassOf: baseClass] raise: Error.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self shouldnt:[self makeWordVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	] ensure:[self cleanup].! !!ClassRenameFixTest methodsFor: 'Private' stamp: 'rw 8/23/2003 16:04'!newUniqueClassName	"Return a class name that is not used in the system."	"self new newClassName"	| baseName newName |	baseName := 'AutoGeneratedClassForTestingSystemChanges'.	1 to: 9999		do: 			[:number | 			newName := baseName , number printString.			(Smalltalk hasClassNamed: newName) ifFalse: [^newName asSymbol]].	^self 		error: 'Can no longer find a new and unique class name for the SystemChangeTest !!'! !!ClassRenameFixTest methodsFor: 'Private' stamp: 'rw 8/23/2003 16:17'!removeEverythingInSetFromSystem: aChangeSet 	aChangeSet changedMessageList		do: [:methodRef | methodRef actualClass removeSelector: methodRef methodSymbol].	aChangeSet changedClasses		do: [:each | each isMeta				ifFalse: [each removeFromSystemUnlogged]]! !!ClassRenameFixTest methodsFor: 'Tests' stamp: 'rw 8/23/2003 16:46'!renameClassUsing: aBlock	| originalName createdClass newClassName foundClasses |	originalName := self newUniqueClassName.	createdClass := Object 		subclass: originalName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'ClassRenameFix-GeneradClass'.	newClassName := self newUniqueClassName.	aBlock value: createdClass value: newClassName.	self assert: (Smalltalk classNamed: originalName) isNil.	self assert: (Smalltalk classNamed: newClassName) notNil.	foundClasses := Smalltalk organization listAtCategoryNamed: 'ClassRenameFix-GeneradClass'.	self assert: (foundClasses notEmpty).	self assert: (foundClasses includes: newClassName).	self assert: (createdClass name = newClassName).! !!ClassRenameFixTest methodsFor: 'Tests' stamp: 'rw 8/23/2003 16:45'!testRenameClassUsingClass	"self run: #testRenameClassUsingClass"	self renameClassUsing: [:class :newName | class rename: newName].! !!ClassRenameFixTest methodsFor: 'Tests' stamp: 'rw 8/23/2003 16:45'!testRenameClassUsingSystemDictionary	"self run: #testRenameClassUsingSystemDictionary"	self renameClassUsing: [:class :newName | Smalltalk renameClass: class as: newName].! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'rw 8/23/2003 16:16'!setUp	previousChangeSet := ChangeSet current.	testsChangeSet := ChangeSet new.	ChangeSet newChanges: testsChangeSet.	super setUp! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'rw 8/23/2003 16:17'!tearDown	self removeEverythingInSetFromSystem: testsChangeSet.	ChangeSet newChanges: previousChangeSet.	ChangeSorter removeChangeSet: testsChangeSet.	previousChangeSet := nil.	testsChangeSet := nil.	super tearDown.! !!ClassTest methodsFor: 'setup' stamp: 'md 1/5/2004 14:59'!setUp	Smalltalk removeClassNamed: #TUTU.	Object subclass: #TUTU		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Tests-Kernel-Classes'! !!ClassTest methodsFor: 'setup' stamp: 'sd 12/28/2003 10:53'!tearDown	Smalltalk removeClassNamed: #TUTU.	! !!ClassTest methodsFor: 'testing' stamp: 'md 1/5/2004 14:59'!testAddInstVarName	"self run: #testAddInstVarName"			| tutu |	tutu := Smalltalk at: #TUTU.	tutu addInstVarName: 'x'.	self assert: (tutu instVarNames = #('x')).	tutu addInstVarName: 'y'.	self assert: (tutu instVarNames = #('x' 'y'))		! !!ClassTest methodsFor: 'testing - compiling' stamp: 'md 4/16/2003 14:54'!testCompileAll	self shouldnt: [ClassTest compileAll] raise: Error.! !!ClassTestCase methodsFor: 'private' stamp: 'md 1/28/2004 11:32'!categoriesForClass: aClass ^ aClass organization allMethodSelectors collect: 			[:each |  aClass organization categoryOfElement: each].! !!ClassTestCase methodsFor: 'private' stamp: 'md 1/28/2004 11:28'!targetClass  |className|  className := self class name asText copyFrom: 0 to: self class name size - 4.  ^ Smalltalk at: (className asString asSymbol).! !!ClassTestCase methodsFor: 'testing' stamp: 'md 3/26/2003 17:39'!testClassComment	self shouldnt: [self targetClass organization hasNoComment].! !!ClassTestCase methodsFor: 'testing' stamp: 'md 3/25/2003 23:07'!testNew	self shouldnt: [self targetClass new] raise: Error.! !!ClassTestCase methodsFor: 'testing' stamp: 'md 3/26/2003 17:24'!testUnCategorizedMethods	| categories slips  |	categories := self categoriesForClass: self targetClass.	slips := categories select: [:each | each = #'as yet unclassified'].	self should: [slips isEmpty].	! !!ArrayTest methodsFor: 'initialize-release' stamp: 'md 4/21/2003 16:29'!setUp	example1 := #(1 2 3 4 5).! !!ArrayTest methodsFor: 'testing' stamp: 'md 4/21/2003 16:36'!testIsLiteral		self assert: example1 isLiteral.	example1 at: 1 put: self class.	self deny: example1 isLiteral.	example1 at: 1 put: 1.! !!AtomMorphTest methodsFor: 'initialize-release' stamp: 'md 4/17/2003 19:03'!setUp		morph := AtomMorph new.! !!AtomMorphTest methodsFor: 'initialize-release' stamp: 'md 4/17/2003 19:03'!tearDown	morph delete.! !!AtomMorphTest methodsFor: 'testing ' stamp: 'md 4/17/2003 19:06'!testVelocity	morph velocity: 0@0.	self assert: ( (morph velocity) = (0@0) ).! !!BitBltTest methodsFor: 'bugs' stamp: 'ar 4/6/2003 19:04'!testAlphaCompositing	| bb f1 f2 mixColor result eps |	f1 := Form extent: 1@1 depth: 32.	f2 := Form extent: 1@1 depth: 32.	eps := 0.5 / 255.	0 to: 255 do:[:i|		f1 colorAt: 0@0 put: Color blue.		mixColor := Color red alpha: i / 255.0.		f2 colorAt: 0@0 put: mixColor.		mixColor := f2 colorAt: 0@0.		bb := BitBlt toForm: f1.		bb sourceForm: f2.		bb combinationRule: Form blend.		bb copyBits.		result := f1 colorAt: 0@0.		self assert: (result red - mixColor alpha) abs < eps.		self assert: (result blue - (1.0 - mixColor alpha)) abs < eps.		self assert: result alpha = 1.0.	].! !!BitBltTest methodsFor: 'bugs' stamp: 'ar 4/6/2003 19:04'!testAlphaCompositing2	| bb f1 f2 mixColor result eps |	f1 := Form extent: 1@1 depth: 32.	f2 := Form extent: 1@1 depth: 32.	eps := 0.5 / 255.	0 to: 255 do:[:i|		f1 colorAt: 0@0 put: Color transparent.		mixColor := Color red alpha: i / 255.0.		f2 colorAt: 0@0 put: mixColor.		mixColor := f2 colorAt: 0@0.		bb := BitBlt toForm: f1.		bb sourceForm: f2.		bb combinationRule: Form blend.		bb copyBits.		result := f1 colorAt: 0@0.		self assert: (result red - mixColor alpha) abs < eps.		self assert: result alpha = mixColor alpha.	].! !!BitBltTest methodsFor: 'bugs' stamp: 'tpr 8/15/2003 19:00'!testAlphaCompositing2Simulated	| bb f1 f2 mixColor result eps |	Smalltalk at: #BitBltSimulation ifPresent: [:bitblt|	f1 := Form extent: 1@1 depth: 32.	f2 := Form extent: 1@1 depth: 32.	eps := 0.5 / 255.	0 to: 255 do:[:i|		f1 colorAt: 0@0 put: Color transparent.		mixColor := Color red alpha: i / 255.0.		f2 colorAt: 0@0 put: mixColor.		mixColor := f2 colorAt: 0@0.		bb := BitBlt toForm: f1.		bb sourceForm: f2.		bb combinationRule: Form blend.		bb copyBitsSimulated.		result := f1 colorAt: 0@0.		self assert: (result red - mixColor alpha) abs < eps.		self assert: result alpha = mixColor alpha.	].]! !!BitBltTest methodsFor: 'bugs' stamp: 'tpr 8/15/2003 19:02'!testAlphaCompositingSimulated	| bb f1 f2 mixColor result eps |		Smalltalk at: #BitBltSimulation ifPresent:[:bitblt|	f1 := Form extent: 1@1 depth: 32.	f2 := Form extent: 1@1 depth: 32.	eps := 0.5 / 255.	0 to: 255 do:[:i|		f1 colorAt: 0@0 put: Color blue.		mixColor := Color red alpha: i / 255.0.		f2 colorAt: 0@0 put: mixColor.		mixColor := f2 colorAt: 0@0.		bb := BitBlt toForm: f1.		bb sourceForm: f2.		bb combinationRule: Form blend.		bb copyBitsSimulated.		result := f1 colorAt: 0@0.		self assert: (result red - mixColor alpha) abs < eps.		self assert: (result blue - (1.0 - mixColor alpha)) abs < eps.		self assert: result alpha = 1.0.	]].! !!BlobMorphTest methodsFor: 'initialize-release' stamp: 'md 4/21/2003 16:26'!setUp	morph := BlobMorph new.! !!BlobMorphTest methodsFor: 'initialize-release' stamp: 'md 4/21/2003 16:26'!tearDown	morph delete.! !!BlobMorphTest methodsFor: 'testing' stamp: 'md 4/21/2003 16:26'!testOpenInWorld	self shouldnt: [morph openInWorld] raise: Error.! !!BooleanTest methodsFor: 'testing-printing' stamp: 'md 3/5/2003 00:43'!testBasicType	self		should: [true basicType = #Boolean].	self		should: [false basicType = #Boolean].! !!BooleanTest methodsFor: 'testing' stamp: 'md 3/5/2003 00:29'!testBooleanInitializedInstance	self should:[Boolean initializedInstance = nil].! !!BooleanTest methodsFor: 'testing' stamp: 'md 3/2/2003 17:52'!testBooleanNew	self should: [Boolean new] raise: TestResult error. 	self should: [True new] raise: TestResult error. 	self should: [False new] raise: TestResult error. ! !!BooleanTest methodsFor: 'testing' stamp: 'md 3/25/2003 23:09'!testNew	self should: [Boolean new] raise: TestResult error. ! !!BooleanTest methodsFor: 'testing-misc' stamp: 'md 3/6/2003 15:22'!testNewTileMorphRepresentative self should: [false newTileMorphRepresentative isKindOf: TileMorph]. self should: [false newTileMorphRepresentative literal = false]. self should: [true newTileMorphRepresentative literal = true].! !!CharacterTest methodsFor: 'testing - Class Methods' stamp: 'md 4/18/2003 09:59'!testNew	self should: [Character new] raise: Error.! !!ClassDescriptionTest methodsFor: 'initialize-release' stamp: 'md 3/26/2003 17:34'!setUp	"I am the method in which your test is initialized. If you have ressources to build, put them here."! !!ClassDescriptionTest methodsFor: 'initialize-release' stamp: 'md 3/26/2003 17:34'!tearDown	"I am called whenever your test ends. I am the place where you release the ressources"! !!ClassDescriptionTest methodsFor: 'testing' stamp: 'md 3/26/2003 17:37'!testOrganization	| aClassOrganizer |	aClassOrganizer := ClassDescription organization.	self should: [aClassOrganizer isKindOf: ClassOrganizer].! !!ClassTestCase class methodsFor: 'Testing' stamp: 'md 1/28/2004 11:50'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self sunitName = #ClassTestCase			! !!CleanKernelTest methodsFor: 'utility'!classesCreated	classesCreated ifNil: [ classesCreated := OrderedCollection new].	^ classesCreated! !!CleanKernelTest methodsFor: 'utility'!createClassNamed: aClassname 	^ self createClassNamed: aClassname superClass: Object! !!CleanKernelTest methodsFor: 'utility' stamp: 'rw 5/12/2003 12:33'!createClassNamed: aClassname superClass: aClass 	^self createClassNamed: aClassname superClass: aClass instanceVariables: ''! !!CleanKernelTest methodsFor: 'utility' stamp: 'md 10/30/2003 09:49'!createClassNamed: aClassname superClass: aClass instanceVariables: instvarString	| r |	r := aClass		subclass: aClassname		instanceVariableNames: instvarString		classVariableNames: ''		poolDictionaries: ''		category: 'Tests-KCP'.	self classesCreated add: r.	^ r! !!CleanKernelTest methodsFor: 'utility' stamp: 'md 10/29/2003 23:45'!isSelector: aSymbol definedInClass: aClassSymbol 	| cls |	cls := Smalltalk				at: aClassSymbol				ifAbsent: [^ false].	^ cls selectors includes: aSymbol! !!CleanKernelTest methodsFor: 'utility' stamp: 'sd 4/29/2003 21:43'!isSelector: aSymbol definedInClassOrMetaClass: aClass			^ (aClass selectors includes: aSymbol)! !!CleanKernelTest methodsFor: 'utility' stamp: 'rw 5/13/2003 16:19'!isSelector: aSymbol deprecatedInClass: aClassSymbol 	| cls |	cls _ Smalltalk				at: aClassSymbol				ifAbsent: [^ false].	^ (cls >> aSymbol) literals includesAllOf: #(deprecatedExplanation:)! !!CleanKernelTest methodsFor: 'utility'!removeClassNamedIfExists: aClassname	Smalltalk at: aClassname ifPresent: [:cls| cls removeFromSystem].	Smalltalk at: aClassname ifPresent: [:clss| self error: 'Error !!!!']! !!CleanKernelTest methodsFor: 'Running' stamp: 'rw 5/12/2003 12:52'!setUp	| classBuilderTestClass classBuilderTestSubClass |	self createClassNamed: #ClassBuilderTestClass superClass: Object instanceVariables: 'var1 var2'.	classBuilderTestClass := (Smalltalk at: #ClassBuilderTestClass).	classBuilderTestClass compile: 'var1	^var1'.	classBuilderTestClass compile: 'var1: object	var1 := object'.	classBuilderTestClass compile: 'var2	^var2'.	classBuilderTestClass compile: 'var2: object	var2 := object'.	self createClassNamed: #ClassBuilderTestSubClass superClass: classBuilderTestClass instanceVariables: 'var3 var4'.	classBuilderTestSubClass := (Smalltalk at: #ClassBuilderTestSubClass).	classBuilderTestSubClass compile: 'var3	^var3'.	classBuilderTestSubClass compile: 'var3: object	var3 := object'.	classBuilderTestSubClass compile: 'var4	^var4'.	classBuilderTestSubClass compile: 'var4: object	var4 := object'.! !!CleanKernelTest methodsFor: 'Running' stamp: 'sd 5/23/2003 14:52'!tearDown	| name |	self classesCreated		do: [:cls | 			name _ cls name.			self removeClassNamedIfExists: name.			ChangeSet current removeClassChanges: name].	classesCreated _ nil! !!CleanKernelTest methodsFor: 'behavior'!testAccessingClassHierarchy	"self run: #testAccessingClassHierarchy"	| clsRoot clsA clsB clsC1 clsC2 |	clsRoot _ self createClassNamed: #Root.	clsA _ self createClassNamed: #A superClass: clsRoot.	clsB _ self createClassNamed: #B superClass: clsA.	clsC1 _ self createClassNamed: #C1 superClass: clsB.	clsC2 _ self createClassNamed: #C2 superClass: clsB.	"--------"	self assert: clsRoot subclasses size = 1.	self		assert: (clsRoot subclasses includes: clsA).	self assert: clsB subclasses size = 2.	self		assert: (clsB subclasses				includesAllOf: (Array with: clsC1 with: clsC2)).	self assert: clsC1 subclasses isEmpty.	"--------"	self assert: clsRoot allSubclasses size = 4.	self		assert: (clsRoot allSubclasses				includesAllOf: (Array						with: clsA						with: clsB						with: clsC1						with: clsC2)).	"--------"	self assert: clsRoot withAllSubclasses size = 5.		self		assert: (clsRoot withAllSubclasses				includesAllOf: (Array						with: clsA						with: clsB						with: clsC1						with: clsC2						with: clsRoot)).! !!CleanKernelTest methodsFor: 'behavior'!testAccessingClassHierarchySuperclasses	"self run: #testAccessingClassHierarchySuperclasses"	| clsRoot clsA clsB clsC1 clsC2 |	clsRoot _ self createClassNamed: #Root.	clsA _ self createClassNamed: #A superClass: clsRoot.	clsB _ self createClassNamed: #B superClass: clsA.	clsC1 _ self createClassNamed: #C1 superClass: clsB.	clsC2 _ self createClassNamed: #C2 superClass: clsB.	"--------"	self assert: clsC2 superclass == clsB.	self		assert: (clsC2 allSuperclasses includes: clsA).	self assert: clsC2 allSuperclasses size = 5.	self		assert: (clsC2 allSuperclasses				includesAllOf: (Array						with: clsB						with: clsA						with: clsRoot						with: Object						with: ProtoObject)).	"--------"	self assert: clsC1 superclass == clsB.	self		assert: (clsC1 allSuperclasses includes: clsA).	self assert: clsC1 allSuperclasses size = 5.	self		assert: (clsC1 allSuperclasses				includesAllOf: (Array						with: clsB						with: clsA						with: clsRoot						with: Object						with: ProtoObject)).	"--------"	self assert: clsC2 withAllSuperclasses size = (clsC2 allSuperclasses size + 1).	self		assert: (clsC2 withAllSuperclasses includesAllOf: clsC2 allSuperclasses).	self		assert: (clsC2 withAllSuperclasses includes: clsC2).	"--------"	self assert: clsC1 withAllSuperclasses size = (clsC1 allSuperclasses size + 1).	self		assert: (clsC1 withAllSuperclasses includesAllOf: clsC1 allSuperclasses).	self		assert: (clsC1 withAllSuperclasses includes: clsC1)! !!CleanKernelTest methodsFor: 'query' stamp: 'sd 4/29/2003 13:15'!testAllCallsOn	"self run: #testAllCallsOn"	self class forgetDoIts.	self assert: (SystemNavigation new allCallsOn: #zoulouSymbol) size = 7.	self assert: (SystemNavigation new allCallsOn: #callingAnotherMethod) size = 2! !!CleanKernelTest methodsFor: 'query' stamp: 'sd 4/29/2003 13:17'!testAllCallsOnAnd	"self run: #testAllCallsOnAnd"	self class forgetDoIts.	self assert: (SystemNavigation new allCallsOn: #zoulouSymbol and: #callingAThirdMethod) size = 2.	self assert: (SystemNavigation new allCallsOn: #callingAThirdMethod and: #inform:) size = 1! !!CleanKernelTest methodsFor: 'query' stamp: 'sd 4/29/2003 20:43'!testAllMethodsSelect	"self run: #testAllMethodsSelect"	| res |	res _ SystemNavigation new				allMethodsSelect: [:each | each messages includes: #zoulouSymbol].	self assert: res size = 1.	self assert: (res at: 1) methodSymbol = #callingAThirdMethod! !!CleanKernelTest methodsFor: 'query' stamp: 'sd 4/18/2003 10:44'!testIsThereAnImplementorOf	"self run: #testIsThereAnImplementorOf"	self deny: (SystemNavigation new isThereAnImplementorOf: #nobodyImplementsThis) .	self assert: (SystemNavigation new isThereAnImplementorOf: #zoulouSymbol).! !!CleanKernelTest methodsFor: 'query' stamp: 'sd 4/18/2003 10:41'!testNumberOfImplementors	"self run: #testNumberOfImplementors"	self assert: (SystemNavigation new numberOfImplementorsOf: #nobodyImplementsThis) isZero.	self assert: (SystemNavigation new numberOfImplementorsOf: #zoulouSymbol) = 2.! !!CleanKernelTest methodsFor: 'isMeta' stamp: 'md 10/30/2003 09:29'!testBehaviorDefineIsMeta	self deny: Behavior new isMeta! !!CleanKernelTest methodsFor: 'isMeta' stamp: 'md 10/30/2003 09:29'!testMetaclassDefineIsMeta	self assert: Metaclass new isMeta! !!CleanKernelTest methodsFor: 'isMeta' stamp: 'md 10/30/2003 09:37'!testMovePowerManagementToPwerManagement	self		assert: (self isSelector: #disablePowerManager definedInClassOrMetaClass: PowerManagement class).	self		assert: (self isSelector: #enablePowerManager definedInClassOrMetaClass: PowerManagement class).	self		assert: (self isSelector: #disablePowerManager: definedInClassOrMetaClass: PowerManagement class).	self		assert: (self isSelector: #itsyVoltage definedInClassOrMetaClass: PowerManagement class)! !!CleanKernelTest methodsFor: 'isMeta' stamp: 'md 10/30/2003 09:45'!testMoveSortAllCategoriesToClassOrganizer	self	 assert: (self isSelector: #sortAllCategories definedInClassOrMetaClass: ClassOrganizer class).! !!CleanKernelTest methodsFor: 'isMeta' stamp: 'md 10/30/2003 09:29'!testPullUpIsMeta	self		deny: (self isSelector: #isMeta definedInClass: #ClassDescription).	self		deny: (self isSelector: #isMeta definedInClass: #Class).	self		assert: (self isSelector: #isMeta definedInClass: #Behavior)! !!CleanKernelTest methodsFor: 'isMeta'!testPullUpIsWithAllSubclasses	"self run: #testPullUpIsWithAllSubclasses" 	self		deny: (self isSelector: #withAllSubclasses definedInClass: #ClassDescription).	self		assert: (self isSelector: #withAllSubclasses definedInClass: #Behavior)! !!CleanKernelTest methodsFor: 'environment' stamp: 'sd 3/28/2003 16:08'!testMetaclassClassClassDescriptionDoesNotReferToSmalltalk	"self run: #testMetaclassClassClassDescriptionDoesNotReferToSmalltalk"	self deny: ((Analyzer externalReferenceOf: (Array with: Metaclass)) includes: #Smalltalk).	self deny: ((Analyzer externalReferenceOf: (Array with: ClassDescription)) includes: #Smalltalk). 	self deny: ((Analyzer externalReferenceOf: (Array with: Class)) includes: #Smalltalk).! !!CleanKernelTest methodsFor: 'environment' stamp: 'sd 3/28/2003 16:06'!testMetaclassDoesNotReferToSmalltalk	"self run: #testMetaclassDoesNotReferToSmalltalk"	self deny: ((Analyzer externalReferenceOf: (Array with: Metaclass)) includes: #Smalltalk).! !!CleanKernelTest methodsFor: 'environment' stamp: 'sd 3/28/2003 15:16'!testNilEnvironment	"self run: #testNilEnvironment"	self assert: nil environment == Smalltalk! !!CleanKernelTest methodsFor: 'allSubclasses' stamp: 'md 10/30/2003 09:30'!testPullUpAllSubclasses	self		deny: (self isSelector: #allSubclasses definedInClass: #ClassDescription).	self		assert: (self isSelector: #allSubclasses definedInClass: #Behavior)! !!CleanKernelTest methodsFor: 'browing' stamp: 'sd 3/28/2003 17:00'!testRemoveBroweMethod	self		deny: (self isSelector: #browse definedInClass: #Behavior)! !!CleanKernelTest methodsFor: 'module reference' stamp: 'md 10/29/2003 23:44'!testRemoveSubclassModuleMethod	self 		deny: (self isSelector: #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:module: definedInClass: #Class)! !!CleanKernelTest methodsFor: 'module reference' stamp: 'sd 3/28/2003 18:15'!testRemoveSubclassModuleMethodInClass	self		deny: (self isSelector: #existingCategoryFor:orConvert:   definedInClass: #Class).	self		deny: (self isSelector: #subclass:instanceVariableNames:classVariableNames:module:  definedInClass: #Class).self		deny: (self isSelector: #variableByteSubclass:instanceVariableNames:classVariableNames:module: definedInClass: #Class).self		deny: (self isSelector: #variableSubclass:instanceVariableNames:classVariableNames:module: definedInClass: #Class).self		deny: (self isSelector: #variableWordSubclass:instanceVariableNames:classVariableNames:module: definedInClass: #Class).self		deny: (self isSelector: #weakSubclass:instanceVariableNames:classVariableNames:module:  definedInClass: #Class).! !!CleanKernelTest methodsFor: 'classBuilder' stamp: 'rw 5/12/2003 12:48'!testReshapeClass	"see if reshaping classes works"	"self run: #testReshapeClass"	| testInstance testClass testMeta newClass newMeta |	testClass _ Smalltalk at: #ClassBuilderTestClass.	testMeta _ testClass class.	testInstance _ testClass new.	testInstance var1: 42.	testInstance var2: 'hello'.	newClass _ self				createClassNamed: #ClassBuilderTestClass				superClass: Object				instanceVariables: 'foo var1 bar var2 mumble'.	newMeta _ newClass class.	"test transparency of mapping"	self assert: testInstance var1 = 42.	self assert: testInstance var2 = 'hello'.	self assert: (testInstance instVarAt: 1) isNil.	self assert: (testInstance instVarAt: 2)			= 42.	self assert: (testInstance instVarAt: 3) isNil.	self assert: (testInstance instVarAt: 4)			= 'hello'.	self assert: (testInstance instVarAt: 5) isNil.	"test transparency of reshapes"	self assert: testInstance class == newClass.	self assert: testClass == newClass.	self assert: testMeta == newMeta! !!CleanKernelTest methodsFor: 'classBuilder' stamp: 'rw 5/12/2003 12:49'!testReshapeClassWithJugglingInstVars	"see if reshapes of classes juggle their instVars correctly"	| testInstance testClass testMeta newClass newMeta |	testClass _ Smalltalk at: #ClassBuilderTestClass.	testMeta _ testClass class.	testInstance _ testClass new.	testInstance var1: 42.	testInstance var2: 'hello'.	newClass _ self				createClassNamed: #ClassBuilderTestClass				superClass: Object				instanceVariables: 'var2 foo bar mumble var1'.	newMeta _ newClass class.	"test transparency of mapping"	self assert: testInstance var1 = 42.	self assert: testInstance var2 = 'hello'.	self assert: (testInstance instVarAt: 1)			= 'hello'.	self assert: (testInstance instVarAt: 2) isNil.	self assert: (testInstance instVarAt: 3) isNil.	self assert: (testInstance instVarAt: 4) isNil.	self assert: (testInstance instVarAt: 5)			= 42.	"test transparency of reshapes"	self assert: testInstance class == newClass.	self assert: testClass == newClass.	self assert: testMeta == newMeta! !!CleanKernelTest methodsFor: 'classBuilder' stamp: 'rw 5/12/2003 12:55'!testReshapeSubClass	"self run: #testReshapeSubClass"	"self debug: #testReshapeSubClass"	| testInstance testClass testMeta |	testClass _ Smalltalk at: #ClassBuilderTestSubClass.	testMeta _ testClass class.	testInstance _ testClass new.	testInstance var1: 42.	testInstance var2: 'hello'.	testInstance var3: 'foo'.	testInstance var4: #bar.	self		createClassNamed: #ClassBuilderTestClass		superClass: Object		instanceVariables: 'var1 foo var2 bar mumble '.	self assert: testInstance var1 = 42.	self assert: testInstance var2 = 'hello'.	self assert: testInstance var3 = 'foo'.	self assert: testInstance var4 = #bar.	self assert: (testInstance instVarAt: 1)			= 42.	self assert: (testInstance instVarAt: 2) isNil.	self assert: (testInstance instVarAt: 3)			= 'hello'.	self assert: (testInstance instVarAt: 4) isNil.	self assert: (testInstance instVarAt: 5) isNil.	self assert: (testInstance instVarAt: 6)			= 'foo'.	self assert: (testInstance instVarAt: 7)			= #bar.	self assert: testInstance class == (Smalltalk at: #ClassBuilderTestSubClass).	self assert: testClass == (Smalltalk at: #ClassBuilderTestSubClass).	self assert: testMeta == (Smalltalk at: #ClassBuilderTestSubClass) class! !!CleanKernelTest methodsFor: 'classBuilder' stamp: 'sd 5/23/2003 14:52'!testValidateSubclassFormatFix	"Recompiling Array"	self		shouldnt: [ArrayedCollection				variableSubclass: #Array				instanceVariableNames: ''				classVariableNames: ''				poolDictionaries: ''				category: 'Collections-Arrayed']		raise: Error.	ChangeSet current removeClassChanges: #Array! !!CleanKernelTest methodsFor: 'theNonMetaclass' stamp: 'sd 6/27/2003 23:09'!testTheMetaClass	"self run: #testTheMetaClass"	self assert: Class class theMetaClass == Class class.	self assert: Class theMetaClass == Class class.! !!CleanKernelTest methodsFor: 'theNonMetaclass' stamp: 'sd 6/27/2003 23:10'!testTheNonMetaClass	"self run: #testTheNonMetaClass"	self assert: Class class theNonMetaClass == Class.	self assert: Class theNonMetaClass == Class.! !!CompiledMethodTest methodsFor: 'examples' stamp: 'md 4/16/2003 15:26'!returnPlusOne: anInteger	^anInteger + 1.! !!CompiledMethodTest methodsFor: 'examples' stamp: 'md 4/16/2003 15:25'!returnTrue	^true! !!CompiledMethodTest methodsFor: 'testing - testing' stamp: 'md 4/16/2003 15:32'!testIsQuick	| method  |	method := self class compiledMethodAt: #returnTrue.	self assert: (method isQuick).	method := self class compiledMethodAt: #returnPlusOne:.	self deny: (method isQuick).	! !!CompiledMethodTest methodsFor: 'testing - evaluating' stamp: 'md 4/16/2003 15:30'!testValueWithReceiverArguments		| method value |	method := self class compiledMethodAt: #returnTrue.	value := method valueWithReceiver: nil arguments: #().	self assert: (value = true).	method := self class compiledMethodAt: #returnPlusOne:.	value := method valueWithReceiver: nil arguments: #(1).	self assert: (value = 2).	! !!DebuggerUnwindBug methodsFor: 'as yet unclassified' stamp: 'ar 3/7/2003 01:38'!testUnwindBlock	"test if unwind blocks work properly"	| sema process |	sema := Semaphore forMutualExclusion.	self assert: sema isSignaled.	"deadlock on the semaphore"	process := [sema critical:[sema wait]] forkAt: Processor userInterruptPriority.	self deny: sema isSignaled.	"terminate process"	process terminate.	self assert: sema isSignaled.! !!DebuggerUnwindBug methodsFor: 'as yet unclassified' stamp: 'ar 3/7/2003 01:41'!testUnwindDebugger	"test if unwind blocks work properly when a debugger is closed"	| sema process debugger top |	sema := Semaphore forMutualExclusion.	self assert: sema isSignaled.	process := [sema critical:[sema wait]] forkAt: Processor userInterruptPriority.	self deny: sema isSignaled.	"everything set up here - open a debug notifier"	debugger := Debugger openInterrupt: 'test' onProcess: process.	"get into the debugger"	debugger debug.	top := debugger topView.	"set top context"	debugger toggleContextStackIndex: 1.	"close debugger"	top delete.	"and see if unwind protection worked"	self assert: sema isSignaled.! !!DebuggerUnwindBug methodsFor: 'as yet unclassified' stamp: 'ar 3/7/2003 01:40'!testUnwindDebuggerWithStep	"test if unwind blocks work properly when a debugger is closed"	| sema process debugger top |	sema := Semaphore forMutualExclusion.	self assert: sema isSignaled.	process := [sema critical:[sema wait]] forkAt: Processor userInterruptPriority.	self deny: sema isSignaled.	"everything set up here - open a debug notifier"	debugger := Debugger openInterrupt: 'test' onProcess: process.	"get into the debugger"	debugger debug.	top := debugger topView.	"set top context"	debugger toggleContextStackIndex: 1.	"do single step"	debugger doStep.	"close debugger"	top delete.	"and see if unwind protection worked"	self assert: sema isSignaled.! !!DictionaryTest methodsFor: 'testing' stamp: 'sd 12/17/2003 20:31'!testAddAll	"(self run: #testAddAll)"		| dict1 dict2 |	dict1 := Dictionary new.	dict1 at: #a put:1 ; at: #b put: 2. 	dict2 := Dictionary new.	dict2 at: #a put: 3 ; at: #c put: 4.	dict1 addAll: dict2.	self assert: (dict1 at: #a) = 3.	self assert: (dict1 at: #b) = 2.	self assert: (dict1 at: #c) = 4.! !!DictionaryTest methodsFor: 'testing' stamp: 'sd 12/17/2003 20:30'!testComma	"(self run: #testComma)"		| dict1 dict2 dict3 |	dict1 := Dictionary new.	dict1 at: #a put:1 ; at: #b put: 2. 	dict2 := Dictionary new.	dict2 at: #a put: 3 ; at: #c put: 4.	dict3 := dict1, dict2.	self assert: (dict3 at: #a) = 3.	self assert: (dict3 at: #b) = 2.	self assert: (dict3 at: #c) = 4.! !!DummyClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 4/15/2003 20:48'!callingAnotherMethod! !!DummyClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 4/15/2003 20:48'!zoulouSymbol	self callingAnotherMethod! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'sd 2/6/2002 21:29'!fileReaderServicesForFile: fullName suffix: suffix	^ (suffix = 'kkk')		ifTrue: [ self services]		ifFalse: [#()] ! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'sd 2/6/2002 21:46'!initialize	"self initialize"	FileList registerFileReader: self! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'SD 11/14/2001 22:12'!loadAFileForTheDummyTool: aFileListOrAPath		"attention. if the file list selects a file the argument will be a fullpath of the selected file else it will pass the filelist itself"! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'sw 2/17/2002 02:36'!serviceLoadAFilForDummyTool	"Answer a service for opening the Dummy tool"	^ SimpleServiceEntry 		provider: self 		label: 'menu label'		selector: #loadAFileForTheDummyTool:		description: 'Menu label for dummy tool'		buttonLabel: 'test'! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'sd 2/1/2002 22:32'!services 	^ Array with: self serviceLoadAFilForDummyTool! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'SD 11/15/2001 22:21'!unload	FileList unregisterFileReader: self ! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'SD 11/10/2001 21:49'!unregister	FileList unregisterFileReader: self.	! !!EventManagerTest methodsFor: 'private' stamp: 'jws 9/7/2000 16:37'!addArg1: arg1addArg2: arg2	eventListener		add: arg1;		add: arg2! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getFalse	^false! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getFalse: anArg	^false! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getTrue	^true! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getTrue: anArg	^true! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:20'!heardEvent	succeeded := true! !!EventManagerTest methodsFor: 'running' stamp: 'JWS 9/7/2000 17:19'!setUp	super setUp.	eventSource := EventManager new.	eventListener := Bag new.	succeeded := false! !!EventManagerTest methodsFor: 'running' stamp: 'jws 11/28/2000 16:25'!tearDown	eventSource releaseActionMap.	eventSource := nil.	eventListener := nil.	super tearDown.! !!EventManagerTest methodsFor: 'running-copying' stamp: 'SqR 11/12/2000 19:38'!testCopy	"Ensure that the actionMap is zapped when	you make a copy of anEventManager"	eventSource when: #blah send: #yourself to: eventListener.	self assert: eventSource actionMap keys isEmpty not.	self assert: eventSource copy actionMap keys isEmpty! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:21'!testMultipleValueSuppliers	eventSource		when: #needsValue		send: #getFalse		to: self.	eventSource		when: #needsValue		send: #getTrue		to: self.	succeeded := eventSource triggerEvent: #needsValue.	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:21'!testMultipleValueSuppliersEventHasArguments	eventSource		when: #needsValue:		send: #getFalse:		to: self.	eventSource		when: #needsValue:		send: #getTrue:		to: self.	succeeded := eventSource triggerEvent: #needsValue: with: 'kolme'.	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:22'!testNoValueSupplier	succeeded := eventSource 		triggerEvent: #needsValue		ifNotHandled: [true].	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:22'!testNoValueSupplierHasArguments	succeeded := eventSource 		triggerEvent: #needsValue:		with: 'nelja'		ifNotHandled: [true].	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'jws 11/28/2000 15:52'!testSingleValueSupplier	eventSource		when: #needsValue		send: #getTrue		to: self.	succeeded := eventSource triggerEvent: #needsValue.	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'jws 9/7/2000 16:39'!testNoArgumentEvent	eventSource when: #anEvent send: #heardEvent to: self.	eventSource triggerEvent: #anEvent.	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'JWS 9/7/2000 17:20'!testOneArgumentEvent	eventSource when: #anEvent: send: #add: to: eventListener.	eventSource triggerEvent: #anEvent: with: 9.	self should: [eventListener includes: 9]! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'JWS 9/7/2000 17:20'!testTwoArgumentEvent	eventSource when: #anEvent:info: send: #addArg1:addArg2: to: self.	eventSource triggerEvent: #anEvent:info: withArguments: #( 9 42 ).	self should: [(eventListener includes: 9) and: [eventListener includes: 42]]! !!EventManagerTest methodsFor: 'running-dependent action supplied arguments' stamp: 'JWS 9/7/2000 17:20'!testNoArgumentEventDependentSuppliedArgument	eventSource when: #anEvent send: #add: to: eventListener with: 'boundValue'.	eventSource triggerEvent: #anEvent.	self should: [eventListener includes: 'boundValue']! !!EventManagerTest methodsFor: 'running-dependent action supplied arguments' stamp: 'JWS 9/7/2000 17:21'!testNoArgumentEventDependentSuppliedArguments	eventSource 		when: #anEvent 		send: #addArg1:addArg2: 		to: self 		withArguments: #('hello' 'world').	eventSource triggerEvent: #anEvent.	self should: [(eventListener includes: 'hello') and: [eventListener includes: 'world']]! !!EventManagerTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:01'!testRemoveActionsForEvent	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsForEvent: #anEvent.	self shouldnt: [eventSource hasActionForEvent: #anEvent]! !!EventManagerTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:01'!testRemoveActionsTwiceForEvent	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsForEvent: #anEvent.	self assert: (eventSource hasActionForEvent: #anEvent) not.	eventSource removeActionsForEvent: #anEvent.	self assert: (eventSource hasActionForEvent: #anEvent) not.! !!EventManagerTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:10'!testRemoveActionsWithReceiver	| action |	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsWithReceiver: self.	action := eventSource actionForEvent: #anEvent.	self assert: (action respondsTo: #receiver).	self assert: ((action receiver == self) not)! !!EventManagerTest methodsFor: 'running-dependent value' stamp: 'JWS 9/7/2000 17:21'!testReturnValueWithManyListeners	| value newListener |	newListener := 'busybody'.	eventSource		when: #needsValue		send: #yourself		to: eventListener.	eventSource		when: #needsValue		send: #yourself		to: newListener.	value := eventSource triggerEvent: #needsValue.	self should: [value == newListener]! !!EventManagerTest methodsFor: 'running-dependent value' stamp: 'JWS 9/7/2000 17:21'!testReturnValueWithNoListeners	| value |	value := eventSource triggerEvent: #needsValue.	self should: [value == nil]! !!EventManagerTest methodsFor: 'running-dependent value' stamp: 'JWS 9/7/2000 17:21'!testReturnValueWithOneListener	| value |	eventSource		when: #needsValue		send: #yourself		to: eventListener.	value := eventSource triggerEvent: #needsValue.	self should: [value == eventListener]! !!EventTest methodsFor: 'private' stamp: 'jws 9/7/2000 16:37'!addArg1: arg1addArg2: arg2	eventListener		add: arg1;		add: arg2! !!EventTest methodsFor: 'private' stamp: 'jws 9/7/2000 16:37'!getFalse	^false! !!EventTest methodsFor: 'private' stamp: 'jws 9/7/2000 16:37'!getFalse: anArg	^false! !!EventTest methodsFor: 'private' stamp: 'jws 9/7/2000 16:38'!getTrue	^true! !!EventTest methodsFor: 'private' stamp: 'jws 9/7/2000 16:38'!getTrue: anArg	^true! !!EventTest methodsFor: 'private' stamp: 'jws 9/7/2000 16:38'!heardEvent	succeeded := true! !!EventTest methodsFor: 'running' stamp: 'jws 9/7/2000 16:37'!setUp	super setUp.	eventSource := Object new.	eventListener := Bag new.	succeeded := false! !!EventTest methodsFor: 'running' stamp: 'jws 11/28/2000 16:25'!tearDown	eventSource releaseActionMap.	eventSource := nil.	eventListener := nil.	super tearDown.! !!EventTest methodsFor: 'running-broadcast query' stamp: 'jws 9/7/2000 16:41'!testMultipleValueSuppliers	eventSource		when: #needsValue		send: #getFalse		to: self.	eventSource		when: #needsValue		send: #getTrue		to: self.	succeeded := eventSource triggerEvent: #needsValue.	self should: [succeeded]! !!EventTest methodsFor: 'running-broadcast query' stamp: 'jws 9/7/2000 16:41'!testMultipleValueSuppliersEventHasArguments	eventSource		when: #needsValue:		send: #getFalse:		to: self.	eventSource		when: #needsValue:		send: #getTrue:		to: self.	succeeded := eventSource triggerEvent: #needsValue: with: 'kolme'.	self should: [succeeded]! !!EventTest methodsFor: 'running-broadcast query' stamp: 'rw 4/27/2002 09:12'!testMultipleValueSuppliersEventHasArgumentsWithGC	eventSource		when: #needsValue:		send: #getFalse:		to: self		with: Object new.	eventSource		when: #needsValue:		send: #getTrue:		to: self		with: Object new.	Smalltalk garbageCollectMost.	succeeded := eventSource triggerEvent: #needsValue: with: 'kolme'.	self should: [succeeded = nil]! !!EventTest methodsFor: 'running-broadcast query' stamp: 'jws 9/7/2000 16:41'!testNoValueSupplier	succeeded := eventSource 		triggerEvent: #needsValue		ifNotHandled: [true].	self should: [succeeded]! !!EventTest methodsFor: 'running-broadcast query' stamp: 'jws 9/7/2000 16:41'!testNoValueSupplierHasArguments	succeeded := eventSource 		triggerEvent: #needsValue:		with: 'nelja'		ifNotHandled: [true].	self should: [succeeded]! !!EventTest methodsFor: 'running-broadcast query' stamp: 'jws 9/7/2000 16:42'!testSingleValueSupplier	eventSource		when: #needsValue		send: #getTrue		to: self.	succeeded := eventSource triggerEvent: #needsValue.	self should: [succeeded]! !!EventTest methodsFor: 'running-dependent action' stamp: 'jws 9/7/2000 16:39'!testNoArgumentEvent	eventSource when: #anEvent send: #heardEvent to: self.	eventSource triggerEvent: #anEvent.	self should: [succeeded]! !!EventTest methodsFor: 'running-dependent action' stamp: 'jws 9/7/2000 16:39'!testOneArgumentEvent	eventSource when: #anEvent: send: #add: to: eventListener.	eventSource triggerEvent: #anEvent: with: 9.	self should: [eventListener includes: 9]! !!EventTest methodsFor: 'running-dependent action' stamp: 'jws 9/7/2000 16:39'!testTwoArgumentEvent	eventSource when: #anEvent:info: send: #addArg1:addArg2: to: self.	eventSource triggerEvent: #anEvent:info: withArguments: #( 9 42 ).	self should: [(eventListener includes: 9) and: [eventListener includes: 42]]! !!EventTest methodsFor: 'running-dependent action supplied arguments' stamp: 'jws 9/7/2000 16:39'!testNoArgumentEventDependentSuppliedArgument	eventSource when: #anEvent send: #add: to: eventListener with: 'boundValue'.	eventSource triggerEvent: #anEvent.	self should: [eventListener includes: 'boundValue']! !!EventTest methodsFor: 'running-dependent action supplied arguments' stamp: 'jws 9/7/2000 16:40'!testNoArgumentEventDependentSuppliedArguments	eventSource 		when: #anEvent 		send: #addArg1:addArg2: 		to: self 		withArguments: #('hello' 'world').	eventSource triggerEvent: #anEvent.	self should: [(eventListener includes: 'hello') and: [eventListener includes: 'world']]! !!EventTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:04'!testRemoveActionsForEvent	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsForEvent: #anEvent.	self shouldnt: [eventSource hasActionForEvent: #anEvent]! !!EventTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:05'!testRemoveActionsTwiceForEvent	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsForEvent: #anEvent.	self assert: (eventSource hasActionForEvent: #anEvent) not.	eventSource removeActionsForEvent: #anEvent.	self assert: (eventSource hasActionForEvent: #anEvent) not.! !!EventTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:05'!testRemoveActionsWithReceiver	| action |	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsWithReceiver: self.	action := eventSource actionForEvent: #anEvent.	self assert: (action respondsTo: #receiver).	self assert: ((action receiver == self) not)! !!EventTest methodsFor: 'running-dependent value' stamp: 'jws 9/7/2000 16:40'!testReturnValueWithManyListeners	| value newListener |	newListener := 'busybody'.	eventSource		when: #needsValue		send: #yourself		to: eventListener.	eventSource		when: #needsValue		send: #yourself		to: newListener.	value := eventSource triggerEvent: #needsValue.	self should: [value == newListener]! !!EventTest methodsFor: 'running-dependent value' stamp: 'jws 9/7/2000 16:40'!testReturnValueWithNoListeners	| value |	value := eventSource triggerEvent: #needsValue.	self should: [value == nil]! !!EventTest methodsFor: 'running-dependent value' stamp: 'jws 9/7/2000 16:40'!testReturnValueWithOneListener	| value |	eventSource		when: #needsValue		send: #yourself		to: eventListener.	value := eventSource triggerEvent: #needsValue.	self should: [value == eventListener]! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/12/1999 23:59'!basicANSISignaledExceptionTestSelectors	^#( simpleIsNestedTest simpleOuterTest simplePassTest simpleResignalAsTest simpleResumeTest simpleRetryTest simpleRetryUsingTest simpleReturnTest)! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 11/14/1999 17:33'!basicTestSelectors       ^#( simpleEnsureTest simpleEnsureTestWithNotification simpleEnsureTestWithUparrow simpleEnsureTestWithError signalFromHandlerActionTest               resumableFallOffTheEndHandler nonResumableFallOffTheEndHandler doubleResumeTest)! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:14'!doSomethingElseString	^'Do something else.'! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:14'!doSomethingExceptionalString	^'Do something exceptional.'! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:13'!doSomethingString	^'Do something.'! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:15'!doYetAnotherThingString	^'Do yet another thing.'! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/7/1999 15:03'!log	log == nil		ifTrue: [log := OrderedCollection new].	^log! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:30'!suiteLog	suiteLog == nil		ifTrue: [suiteLog := OrderedCollection new].	^suiteLog! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:15'!testString	^'This is only a test.'! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/8/1999 09:17'!clearLog	log := nil! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/7/1999 15:16'!contents	^( self log		inject: (WriteStream on: (String new: 80))		into: 			[:result :item |			result 				cr; 				nextPutAll: item;				yourself] ) contents! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/7/1999 15:03'!log: aString	self log add: aString! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/12/1999 23:07'!logTest: aSelector	self suiteLog add: aSelector! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/8/1999 09:38'!logTestResult: aString	| index |	index := self suiteLog size.	self suiteLog 		at: index		put: ((self suiteLog at: index), ' ', aString)! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:13'!doSomething	self log: self doSomethingString! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:14'!doSomethingElse	self log: self doSomethingElseString! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:14'!doSomethingExceptional	self log: self doSomethingExceptionalString! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:15'!doYetAnotherThing	self log: self doYetAnotherThingString! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:16'!methodWithError	MyTestError signal: self testString! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:16'!methodWithNotification	MyTestNotification signal: self testString! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 11/14/1999 17:26'!doubleResumeTest       [self doSomething.       MyResumableTestError signal.       self doSomethingElse.       MyResumableTestError signal.       self doYetAnotherThing]               on: MyResumableTestError               do: [:ex | ex resume].! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/7/1999 13:43'!nonResumableFallOffTheEndHandler		[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do: [:ex | self doSomethingExceptional].	self doYetAnotherThing! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/9/1999 16:07'!resumableFallOffTheEndHandler	[self doSomething.	MyTestNotification signal.	self doSomethingElse]		on: MyTestNotification		do: [:ex | self doSomethingExceptional].	self doYetAnotherThing! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 8/19/1999 01:39'!signalFromHandlerActionTest	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[self doYetAnotherThing.			MyTestError signal]! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/8/1999 09:44'!simpleEnsureTest	[self doSomething.	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/8/1999 12:50'!simpleEnsureTestWithError	[self doSomething.	MyTestError signal.	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/8/1999 10:15'!simpleEnsureTestWithNotification	[self doSomething.	self methodWithNotification.	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/9/1999 16:04'!simpleEnsureTestWithUparrow	[self doSomething.	true ifTrue: [^nil].	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/7/1999 14:28'!warningTest	self log: 'About to signal warning.'.	Warning signal: 'Ouch'.	self log: 'Warning signal handled and resumed.'! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 11/14/1999 17:29'!doubleResumeTestResults       ^OrderedCollection new               add: self doSomethingString;               add: self doSomethingElseString;               add: self doYetAnotherThingString;               yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 09:21'!nonResumableFallOffTheEndHandlerResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingExceptionalString;		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 8/19/1999 02:39'!resumableFallOffTheEndHandlerResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingExceptionalString;		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 8/19/1999 01:51'!signalFromHandlerActionTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: 'Unhandled Exception';		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 09:47'!simpleEnsureTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingElseString;		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/9/1999 17:44'!simpleEnsureTestWithErrorResults	^OrderedCollection new		add: self doSomethingString;		add: 'Unhandled Exception';		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 10:13'!simpleEnsureTestWithNotificationResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingElseString;		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 18:55'!simpleEnsureTestWithUparrowResults	^OrderedCollection new		add: self doSomethingString;"		add: self doSomethingElseString;"		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'suites' stamp: 'tfei 6/13/1999 01:25'!runAllTests	"ExceptionTester new runAllTests"	self		runBasicTests;		runBasicANSISignaledExceptionTests! !!ExceptionTester methodsFor: 'suites' stamp: 'tfei 6/12/1999 23:54'!runBasicANSISignaledExceptionTests	self basicANSISignaledExceptionTestSelectors		do:			[:eachTestSelector |			self runTest: eachTestSelector]! !!ExceptionTester methodsFor: 'suites' stamp: 'tfei 6/9/1999 16:06'!runBasicTests	self basicTestSelectors		do:			[:eachTestSelector |			self runTest: eachTestSelector]! !!ExceptionTester methodsFor: 'testing' stamp: 'tfei 8/19/1999 03:10'!runTest: aSelector	| expectedResult |	[expectedResult := self perform: (aSelector, #Results) asSymbol.	self logTest: aSelector.	self clearLog.	self perform: aSelector.	] on: MyTestError	  do: 		[ :ex |		self log: 'Unhandled Exception'.		ex return: nil].	self log = expectedResult		ifTrue: [self logTestResult: 'succeeded']		ifFalse: [self logTestResult: 'failed']! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 01:27'!simpleIsNestedTest	"uses resignalAs:"	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[:ex |			ex isNested "expecting to detect handler in #runTest:"				ifTrue:					[self doYetAnotherThing.					ex resignalAs: MyTestNotification new]]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 00:36'!simpleOuterTest	"uses #resume"	[[self doSomething.	MyTestNotification signal.	self doSomethingElse]		on: MyTestNotification		do: [:ex | ex outer]]				on: MyTestNotification				do: [:ex | self doYetAnotherThing. ex resume]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 00:37'!simplePassTest	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[:ex |			self doYetAnotherThing.			ex pass "expecting handler in #runTest:"]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 02:12'!simpleResignalAsTest	"ExceptionTester new simpleResignalAsTest"	[self doSomething.	MyTestNotification signal.	self doSomethingElse]		on: MyTestNotification		do:			[:ex | ex resignalAs: MyTestError new]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'RAA 12/8/2000 12:58'!simpleResumeTest	"see if we can resume twice"	| it |	[self doSomething.	it := MyResumableTestError signal.	it = 3 ifTrue: [self doSomethingElse].	it := MyResumableTestError signal.	it = 3 ifTrue: [self doSomethingElse].	]		on: MyResumableTestError		do:			[:ex |			self doYetAnotherThing.			ex resume: 3]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 01:02'!simpleRetryTest	| theMeaningOfLife |	theMeaningOfLife := nil.	[self doSomething.	theMeaningOfLife == nil		ifTrue: [MyTestError signal]		ifFalse: [self doSomethingElse]]			on: MyTestError			do:				[:ex |				theMeaningOfLife := 42.				self doYetAnotherThing.				ex retry]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 01:03'!simpleRetryUsingTest	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[:ex | ex retryUsing: [self doYetAnotherThing]]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 00:59'!simpleReturnTest	| it |	it :=		[self doSomething.		MyTestError signal.		self doSomethingElse]			on: MyTestError			do: [:ex | ex return: 3].	it = 3 ifTrue: [self doYetAnotherThing]! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:09'!simpleIsNestedTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: self doSomethingElseString;		yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:10'!simpleOuterTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: self doSomethingElseString;		yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:10'!simplePassTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: 'Unhandled Exception';		yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:11'!simpleResignalAsTestResults	^OrderedCollection new		add: self doSomethingString;		add: 'Unhandled Exception';		yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'RAA 12/8/2000 12:59'!simpleResumeTestResults	"see if we can resume twice"	^OrderedCollection new			add: self doSomethingString;			add: self doYetAnotherThingString;			add: self doSomethingElseString;			add: self doYetAnotherThingString;			add: self doSomethingElseString;			yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:23'!simpleRetryTestResults	^OrderedCollection new			add: self doSomethingString;			add: self doYetAnotherThingString;			add: self doSomethingString;			add: self doSomethingElseString;			yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:23'!simpleRetryUsingTestResults	^OrderedCollection new			add: self doSomethingString;			add: self doYetAnotherThingString;			yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 02:22'!simpleReturnTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		yourself! !!ExceptionTests methodsFor: 'private' stamp: 'md 3/25/2003 23:40'!assertSuccess: anExceptionTester	self should: [ ( anExceptionTester suiteLog first) endsWith:  'succeeded'].! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:43'!testDoubleResume	self assertSuccess: (ExceptionTester new runTest: #doubleResumeTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:44'!testNonResumableFallOffTheEndHandler	self assertSuccess: (ExceptionTester new runTest: #nonResumableFallOffTheEndHandler ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:44'!testResumableFallOffTheEndHandler	self assertSuccess: (ExceptionTester new runTest: #resumableFallOffTheEndHandler ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:44'!testSignalFromHandlerActionTest	self assertSuccess: (ExceptionTester new runTest: #signalFromHandlerActionTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:48'!testSimpleEnsure	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:45'!testSimpleEnsureTestWithError	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithError ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:46'!testSimpleEnsureTestWithNotification	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithNotification ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:45'!testSimpleEnsureTestWithUparrow	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithUparrow ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:46'!testSimpleIsNested	self assertSuccess: (ExceptionTester new runTest: #simpleIsNestedTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:41'!testSimpleOuter	self assertSuccess: (ExceptionTester new runTest: #simpleOuterTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:42'!testSimplePass	self assertSuccess: (ExceptionTester new runTest: #simplePassTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:43'!testSimpleResignalAs	self assertSuccess: (ExceptionTester new runTest: #simpleResignalAsTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:48'!testSimpleResume	self assertSuccess: (ExceptionTester new runTest: #simpleResumeTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:48'!testSimpleRetry	self assertSuccess: (ExceptionTester new runTest: #simpleRetryTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:47'!testSimpleRetryUsing	self assertSuccess: (ExceptionTester new runTest: #simpleRetryUsingTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'md 3/25/2003 23:48'!testSimpleReturn	self assertSuccess: (ExceptionTester new runTest: #simpleReturnTest ) ! !!FalseTest methodsFor: 'testing' stamp: 'md 3/2/2003 17:02'!testAND self assert: (false & true) = false. self assert: (false & false) = false.! !!FalseTest methodsFor: 'testing' stamp: 'md 3/2/2003 17:05'!testAnd self assert: (false and: ['alternativeBlock']) = false.! !!FalseTest methodsFor: 'testing' stamp: 'md 3/5/2003 00:59'!testIfFalse self should: [(false ifFalse: ['alternativeBlock']) = 'alternativeBlock']. ! !!FalseTest methodsFor: 'testing' stamp: 'md 3/2/2003 17:07'!testIfFalseIfTrue self assert: (false ifFalse: ['falseAlternativeBlock']                       ifTrue: ['trueAlternativeBlock']) = 'falseAlternativeBlock'. ! !!FalseTest methodsFor: 'testing' stamp: 'md 3/2/2003 17:04'!testIfTrue self assert: (false ifTrue: ['alternativeBlock']) = nil. ! !!FalseTest methodsFor: 'testing' stamp: 'md 3/2/2003 17:09'!testIfTrueIfFalse self assert: (false ifTrue: ['trueAlternativeBlock']                       ifFalse: ['falseAlternativeBlock']) = 'falseAlternativeBlock'. ! !!FalseTest methodsFor: 'testing' stamp: 'md 3/25/2003 23:16'!testNew	self should: [False new] raise: TestResult error. ! !!FalseTest methodsFor: 'testing' stamp: 'md 3/5/2003 00:30'!testNot self should: [false not = true].! !!FalseTest methodsFor: 'testing' stamp: 'md 3/2/2003 16:44'!testOR self assert: (false | true) =  true. self assert: (false | false) = false.! !!FalseTest methodsFor: 'testing' stamp: 'md 3/2/2003 17:05'!testOr self assert: (false or: ['alternativeBlock']) = 'alternativeBlock'.! !!FalseTest methodsFor: 'testing' stamp: 'md 3/2/2003 16:41'!testPrintOn self assert: (String streamContents: [:stream | false printOn: stream]) = 'false'. ! !!FileDirectoryTest methodsFor: 'create/delete tests' stamp: 'nk 11/13/2002 19:39'!deleteDirectory		(self myDirectory exists) ifTrue:		[self myDirectory containingDirectory deleteDirectory: self myLocalDirectoryName]! !!FileDirectoryTest methodsFor: 'create/delete tests' stamp: 'aka 5/21/2003 00:31'!testDeleteDirectory	"Test deletion of a directory"		| aContainingDirectory preTestItems |	aContainingDirectory _ self myDirectory containingDirectory.	preTestItems _ aContainingDirectory fileAndDirectoryNames.		self assert: self myAssuredDirectory exists.	aContainingDirectory deleteDirectory: self myLocalDirectoryName.	self shouldnt: 		[aContainingDirectory directoryNames 			includes: self myLocalDirectoryName ]		description: 'Should successfully delete directory.'.	self should: 		[preTestItems = aContainingDirectory fileAndDirectoryNames]		description: 'Should only delete the indicated directory.'.		! !!FileDirectoryTest methodsFor: 'resources' stamp: 'hg 2/2/2002 16:44'!myAssuredDirectory	^self myDirectory assureExistence! !!FileDirectoryTest methodsFor: 'resources' stamp: 'hg 2/2/2002 16:42'!myDirectory	^FileDirectory default directoryNamed: self myLocalDirectoryName! !!FileDirectoryTest methodsFor: 'resources' stamp: 'hg 2/2/2002 16:42'!myLocalDirectoryName	^'zTestDir'! !!FileDirectoryTest methodsFor: 'resources' stamp: 'nk 11/13/2002 19:56'!tearDown	[ self deleteDirectory ] on: Error do: [ :ex | ]! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'aka 5/20/2003 16:43'!testAttemptExistenceCheckWhenFile"How should a FileDirectory instance respond with an existent file name?"| directory |FileDirectory default				forceNewFileNamed: 'aTestFile'.directory := FileDirectory default				directoryNamed: 'aTestFile'.self shouldnt: [directory exists]	description: 'Files are not directories.'.! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'aka 5/20/2003 23:33'!testDirectoryExists	self assert: self myAssuredDirectory exists.	self should: [self myDirectory containingDirectory 					directoryExists: self myLocalDirectoryName].	self myDirectory containingDirectory deleteDirectory: self myLocalDirectoryName.	self shouldnt: [self myDirectory containingDirectory 						directoryExists: self myLocalDirectoryName]! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'svp 5/20/2003 17:14'!testDirectoryExistsWhenLikeNamedFileExists| testFileName |[testFileName := self myAssuredDirectory fullNameFor: 'zDirExistsTest.testing'.(FileStream newFileNamed: testFileName) close.self should: [FileStream isAFileNamed: testFileName].self shouldnt: [(FileDirectory on: testFileName) exists]]ensure: [self myAssuredDirectory deleteFileNamed: 'zDirExistsTest.testing']! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'hg 2/2/2002 16:44'!testDirectoryNamed	self should: [(self myDirectory containingDirectory 					directoryNamed: self myLocalDirectoryName) pathName 						= self myDirectory pathName]! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'tpr 8/15/2003 16:30'!testExists	self should: [FileDirectory default exists]		description: 'Should know default directory exists.'.	self should: [self myAssuredDirectory exists]		description: 'Should know created directory exists.'.	self myDirectory containingDirectory deleteDirectory: self myLocalDirectoryName.	self shouldnt: [(self myDirectory containingDirectory directoryNamed: self myLocalDirectoryName) exists]		description: 'Should know that recently deleted directory no longer exists.'.! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'aka 5/20/2003 14:26'!testNonExistentDirectory	| directory parentDirectory |	directory _FileDirectory default				directoryNamed: 'nonExistentFolder'.	self shouldnt: [directory exists] 		description: 'A FileDirectory instance should know if it points to a non-existent directory.'.	parentDirectory _FileDirectory default.	self shouldnt: [parentDirectory directoryExists: 'nonExistentFolder'] 		description: 'A FileDirectory instance should know when a directory of the given name doesn''t exist'.! !!FileList2ModalDialogsTest methodsFor: 'running' stamp: 'LC 1/6/2002 08:45'!testModalFileSelector	| window fileList2 |	window _ FileList2 morphicViewFileSelector.	window openCenteredInWorld.	fileList2 _ window valueOfProperty: #fileListModel.	fileList2 fileListIndex: 1.	window delete.	self assert: fileList2 getSelectedFile isNil.	fileList2 okHit.	self deny: fileList2 getSelectedFile isNil! !!FileList2ModalDialogsTest methodsFor: 'running' stamp: 'LC 1/6/2002 08:50'!testModalFileSelectorForSuffixes	| window fileList2 |	window _ FileList2 morphicViewFileSelectorForSuffixes: nil.	window openCenteredInWorld.	fileList2 _ window valueOfProperty: #fileListModel.	fileList2 fileListIndex: 1.	window delete.	self assert: fileList2 getSelectedFile isNil.	fileList2 okHit.	self deny: fileList2 getSelectedFile isNil! !!FileList2ModalDialogsTest methodsFor: 'running' stamp: 'LC 1/6/2002 08:55'!testModalFolderSelector	| window fileList2 |	window _ FileList2 morphicViewFolderSelector.	fileList2 _ window model.	window openInWorld: self currentWorld extent: 300@400.	fileList2 fileListIndex: 1.	window delete.	self assert: fileList2 getSelectedDirectory withoutListWrapper isNil.	fileList2 okHit.	self deny: fileList2 getSelectedDirectory withoutListWrapper isNil! !!FileList2ModalDialogsTest methodsFor: 'running' stamp: 'LC 1/6/2002 09:01'!testModalFolderSelectorForProjectLoad	| window fileList2 w |	window _ FileList2		morphicViewProjectLoader2InWorld: self currentWorld		reallyLoad: false.	fileList2 _ window valueOfProperty: #FileList.	w _ self currentWorld.	window position: w topLeft + (w extent - window extent // 2).	window openInWorld: w.	window delete.	self assert: fileList2 getSelectedDirectory withoutListWrapper isNil.	fileList2 okHit.	self deny: fileList2 getSelectedDirectory withoutListWrapper isNil! !!FileListTest methodsFor: 'private' stamp: 'sd 2/1/2002 23:04'!checkIsServiceIsFromDummyTool: service		^ (service instVarNamed: #provider) = DummyToolWorkingWithFileList	 	& service label = 'menu label'		& (service instVarNamed: #selector) = #loadAFileForTheDummyTool:! !!FileListTest methodsFor: 'initialize' stamp: 'SD 11/10/2001 21:48'!setUp	DummyToolWorkingWithFileList initialize.! !!FileListTest methodsFor: 'initialize' stamp: 'SD 11/10/2001 21:49'!tearDown	DummyToolWorkingWithFileList unregister.! !!FileListTest methodsFor: 'test' stamp: 'SD 11/10/2001 21:53'!testMenuReturned	"(self selector: #testToolRegistered) debug"	self assert: (FileList registeredFileReaderClasses includes: DummyToolWorkingWithFileList)! !!FileListTest methodsFor: 'test' stamp: 'sd 2/6/2002 21:26'!testService	"a stupid test to check that the class returns a service"	"(self selector: #testService) debug"		| service |	service := (DummyToolWorkingWithFileList fileReaderServicesForFile: 'abab.kkk' suffix: 'kkk') first.	self assert: (self checkIsServiceIsFromDummyTool: service).	service := (DummyToolWorkingWithFileList fileReaderServicesForFile: 'zkk.gz' suffix: 'gz').	self assert: service isEmpty! !!FileListTest methodsFor: 'test' stamp: 'nk 11/30/2002 14:55'!testServicesForFileEnding	"(self selector: #testServicesForFileEnding) debug"	self assert: (((FileList new directory: FileDirectory default; yourself) itemsForFile: 'aaa.kkk') anySatisfy: [ :ea | self checkIsServiceIsFromDummyTool: ea ]).! !!FileListTest methodsFor: 'test' stamp: 'SD 11/10/2001 21:52'!testToolRegistered	"(self selector: #testToolRegistered) debug"	self assert: (FileList registeredFileReaderClasses includes: DummyToolWorkingWithFileList)! !!FileListTest methodsFor: 'test' stamp: 'SD 11/11/2001 13:54'!testToolRegisteredUsingInterface	"(self selector: #testToolRegisteredUsingInterface) debug"	self assert: (FileList isReaderNamedRegistered: #DummyToolWorkingWithFileList)! !!FlapsTest methodsFor: 'initialize-release' stamp: 'cE 10/10/2003 19:08'!setUp	"I am the method in which your test is initialized. If you have ressources to build, put them here."! !!FlapsTest methodsFor: 'initialize-release' stamp: 'cE 10/10/2003 19:08'!tearDown	"I am called whenever your test ends. I am the place where you release the ressources"! !!FlapsTest methodsFor: 'testing' stamp: 'cE 10/12/2003 19:54'!testRegisteredFlapsQuads	"Defaults are defined in Flaps class>>defaultQuadsDefining...	If you change something there, do the following afterwards:	Flaps initializeFlapsQuads"	| allQuads absentClasses absentSelectors |	allQuads _ OrderedCollection new.	absentClasses _ OrderedCollection new.	Flaps registeredFlapsQuads valuesDo: [:each | allQuads addAll: each].	allQuads do: [:each | | theObject |		theObject _ each at: 1.		Smalltalk			at: theObject			ifAbsent: [absentClasses add: each]].	self		assert: absentClasses isEmpty		description: 'There are absent classes: ' , absentClasses asString.	absentSelectors _ OrderedCollection new.	allQuads do: [:each | | theClass theSelector |		theClass _ (Smalltalk at: (each at: 1)) class.		theSelector _ each at: 2.		(theClass canUnderstand: theSelector)			ifFalse: [absentSelectors add: each]].	self		assert: absentSelectors isEmpty		description: 'There are absent selectors: ' , absentSelectors asString! !!FloatTest methodsFor: 'as yet unclassified' stamp: 'md 4/16/2003 15:02'!testIsZero	self assert: 0.0 isZero.	self deny:  0.1 isZero.! !!HashAndEqualsTestCase methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:57'!setUp	"subclasses will add their prototypes into this collection"	prototypes _ OrderedCollection new ! !!HashAndEqualsTestCase methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!testEquality	"Check that TextFontChanges report equality correctly"	prototypes		do: [:p | self				should: [(EqualityTester with: p) result]] ! !!HashAndEqualsTestCase methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!testHash	"test that TextFontChanges hash correctly"	prototypes		do: [:p | self				should: [(HashTester with: p) result]] ! !!CRLookupItemTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!setUp	super setUp.	prototypes		add: (CRLookupItem				feature: nil				char: nil				distance: 1) ! !!FlashLineStyleTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!setUp	super setUp.	prototypes		add: (FlashLineStyle color: 1 width: 1);				add: (FlashLineStyle color: 1 width: 2);				add: (FlashLineStyle color: 2 width: 1);				add: (FlashLineStyle color: 2 width: 2) ! !!HashTesterTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!testBasicBehaviour	self		should: [(HashTester with: 1)				resultFor: 100].	self		should: [(HashTester with: 'fred')				resultFor: 100].	self		shouldnt: [(HashTester with: BadHasher new)				resultFor: 100] ! !!InstVarRefLocatorTest methodsFor: 'examples' stamp: 'md 4/8/2003 12:31'!example1	| ff|	(1 < 2) ifTrue: [tt ifNotNil: [ff _ 'hallo']].	^ ff.! !!InstVarRefLocatorTest methodsFor: 'examples' stamp: 'md 4/8/2003 12:31'!example2	| ff|		ff := 1.	(1 < 2) ifTrue: [ff ifNotNil: [ff _ 'hallo']].	^ ff.! !!InstVarRefLocatorTest methodsFor: 'private' stamp: 'md 4/8/2003 12:39'!hasInstVarRef: aMethod	"Answer whether the receiver references an instance variable."	| scanner end printer |	scanner _ InstructionStream on: aMethod.	printer _ InstVarRefLocator new.	end _ scanner method endPC.	[scanner pc <= end] whileTrue: [		(printer interpretNextInstructionUsing: scanner) ifTrue: [^true].	].	^false! !!InstVarRefLocatorTest methodsFor: 'testing' stamp: 'md 4/8/2003 12:42'!testExample1	| method |	method := self class compiledMethodAt: #example1.	self assert: (self hasInstVarRef: method).! !!InstVarRefLocatorTest methodsFor: 'testing' stamp: 'md 4/8/2003 12:42'!testExample2	| method |	method := self class compiledMethodAt: #example2.	self deny: (self hasInstVarRef: method).! !!InstVarRefLocatorTest methodsFor: 'testing' stamp: 'md 4/8/2003 12:35'!testInstructions	| scanner end printer methods |	methods := Object methodDict values. 	methods do: [:method |		scanner _ InstructionStream on: method.		printer _ InstVarRefLocator new.		end _ scanner method endPC.		[scanner pc <= end] whileTrue: [			self shouldnt: [printer interpretNextInstructionUsing: scanner] raise: Error.		].	].! !!InstructionClientTest methodsFor: 'testing' stamp: 'md 4/8/2003 12:07'!testInstructions	"just interpret all of methods of Object"	| methods client scanner|		methods := Object methodDict values. 	client := InstructionClient new.		methods do: [:method |			scanner := (InstructionStream on: method).			[scanner pc <= method endPC] whileTrue: [					self shouldnt: [scanner interpretNextInstructionFor: client] raise: Error.			].	].! !!InstructionPrinterTest methodsFor: 'examples' stamp: 'md 4/8/2003 12:28'!example1	| ff|	(1 < 2) ifTrue: [tt ifNotNil: [ff _ 'hallo']].	^ ff.! !!InstructionPrinterTest methodsFor: 'testing' stamp: 'md 4/8/2003 12:13'!testInstructions	"just print all of methods of Object and see if no error accours"	| methods printer  |		methods := Object methodDict values. 	printer  := InstructionPrinter.		methods do: [:method |					self shouldnt: [ 						String streamContents: [:stream | 							(printer on: method) printInstructionsOn: stream]] raise: Error.			].! !!IntegerDigitLogicTest methodsFor: 'running' stamp: 'hmm 1/7/2002 21:12'!testAndSingleBitWithMinusOne	"And a single bit with -1 and test for same value"	1 to: 100 do: [:i | self assert: ((1 bitShift: i) bitAnd: -1) = (1 bitShift: i)].! !!IntegerDigitLogicTest methodsFor: 'running' stamp: 'hmm 1/7/2002 21:13'!testMixedSignDigitLogic	"Verify that mixed sign logic with large integers works."	self assert: (-2 bitAnd: 16rFFFFFFFF) = 16rFFFFFFFE! !!IntegerDigitLogicTest methodsFor: 'running' stamp: 'hmm 1/7/2002 21:12'!testNBitAndNNegatedEqualsN	"Verify that (n bitAnd: n negated) = n for single bits"	| n |	1 to: 100 do: [:i | n _ 1 bitShift: i.				self assert: (n bitAnd: n negated) = n]! !!IntegerDigitLogicTest methodsFor: 'running' stamp: 'hmm 1/7/2002 21:12'!testNNegatedEqualsNComplementedPlusOne	"Verify that n negated = (n complemented + 1) for single bits"	| n |	1 to: 100 do: [:i | n _ 1 bitShift: i.				self assert: n negated = ((n bitXor: -1) + 1)]! !!IntegerDigitLogicTest methodsFor: 'running' stamp: 'hmm 1/7/2002 21:13'!testShiftMinusOne1LeftThenRight	"Shift -1 left then right and test for 1"	1 to: 100 do: [:i | self assert: ((-1 bitShift: i) bitShift: i negated) = -1].! !!IntegerDigitLogicTest methodsFor: 'running' stamp: 'hmm 1/7/2002 21:12'!testShiftOneLeftThenRight	"Shift 1 bit left then right and test for 1"	1 to: 100 do: [:i | self assert: ((1 bitShift: i) bitShift: i negated) = 1].! !!IntegerTest methodsFor: 'testing - benchmarks' stamp: 'md 4/15/2003 20:34'!testBenchFib	self should: [0 benchFib = 1].	self should: [1 benchFib = 1].	self should: [2 benchFib = 3].	! !!IntegerTest methodsFor: 'testing - benchmarks' stamp: 'md 4/15/2003 20:34'!testBenchmark	self shouldnt: [0 benchmark ] raise: Error.	! !!IntegerTest methodsFor: 'testing - benchmarks' stamp: 'md 4/15/2003 20:32'!testTinyBenchmarks	self shouldnt: [0 tinyBenchmarks] raise: Error.! !!IntegerTest methodsFor: 'testing - bitLogic' stamp: 'md 3/17/2003 15:27'!testBitLogic  	"This little suite of tests is designed to verify correct operation of most	of Squeak's bit manipulation code, including two's complement	representation of negative values.  It was written in a hurry and	is probably lacking several important checks."	"Shift 1 bit left then right and test for 1"	| n |	1 to: 100 do: [:i | self should: [((1 bitShift: i) bitShift: i negated) = 1]].	"Shift -1 left then right and test for 1"	1 to: 100 do: [:i | self should: [((-1 bitShift: i) bitShift: i negated) = -1]].	"And a single bit with -1 and test for same value"	1 to: 100 do: [:i | self should: [((1 bitShift: i) bitAnd: -1) = (1 bitShift: i)]].	"Verify that (n bitAnd: n negated) = n for single bits"	1 to: 100 do: [:i | self should: [n _ 1 bitShift: i. (n bitAnd: n negated) = n]].	"Verify that n negated = (n complemented + 1) for single bits"	1 to: 100 do: [:i | self should:[n _ 1 bitShift: i.				n negated = ((n bitXor: -1) + 1)]].	"Verify that (n + n complemented) = -1 for single bits"	1 to: 100 do: [:i | self should: [n _ 1 bitShift: i.				(n + (n bitXor: -1)) = -1]].	"Verify that n negated = (n complemented +1) for single bits"	1 to: 100 do: [:i | self should: [n _ 1 bitShift: i.				n negated = ((n bitXor: -1) + 1)]].	self should: [(-2 bitAnd: 16rFFFFFFFF) = 16rFFFFFFFE].! !!IntegerTest methodsFor: 'testing - bitLogic' stamp: 'md 3/17/2003 15:10'!testTwoComplementRightShift	| large small |	small _ 2 << 16.	large _ 2 << 32.		self should: [(small negated bitShift: -1) ~= ((small + 1) negated bitShift: -1)		== ((large negated bitShift: -1) ~= ((large + 1) negated bitShift: -1))].		     self should: [ (small bitShift: -1) ~= (small + 1 bitShift: -1)		== ((large bitShift: -1) ~= (large + 1 bitShift: -1))].! !!IntegerTest methodsFor: 'testing - testing' stamp: 'md 4/21/2003 16:17'!testEven		self deny: (1073741825 even).	self assert: (1073741824  even).	! !!IntegerTest methodsFor: 'testing - testing' stamp: 'md 4/21/2003 16:14'!testIsInteger	self assert: (0 isInteger).	! !!IntegerTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 20:40'!testIsPowerOfTwo	self assert: (0 isPowerOfTwo).	self assert: (1 isPowerOfTwo).	self assert: (2 isPowerOfTwo).	self deny:  (3 isPowerOfTwo).	self assert: (4 isPowerOfTwo).	! !!IntegerTest methodsFor: 'testing - instance creation' stamp: 'md 3/25/2003 23:14'!testNew	self should: [Integer new] raise: TestResult error. ! !!IntegerTest methodsFor: 'testing - Class Methods' stamp: 'md 4/21/2003 16:12'!testPrimesUpTo	|primes|	primes := Integer primesUpTo: 100.	self assert: primes = #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97).! !!IntervalTest methodsFor: 'testing' stamp: 'md 10/12/2003 20:13'!testEquals	self shouldnt: [		self assert: (3 to: 5) = #(3 4 5).		self deny: (3 to: 5) = #(3 5).		self deny: (3 to: 5) = #().		self assert: #(3 4 5) = (3 to: 5).		self deny: #(3 5) = (3 to: 5).		self deny: #() = (3 to: 5).	] raise: MessageNotUnderstood.! !!IntervalTest methodsFor: 'testing' stamp: 'md 10/12/2003 20:13'!testEquals2	self assert: (3 to: 5) = #(3 4 5).	self deny: (3 to: 5) = #(3 5).	self deny: (3 to: 5) = #().	self assert: #(3 4 5) = (3 to: 5).	self deny: #(3 5) = (3 to: 5).	self deny: #() = (3 to: 5).! !!IntervalTest methodsFor: 'testing' stamp: 'md 10/12/2003 20:13'!testEquals3	self assert: (3 to: 5 by: 2) first = (3 to: 6 by: 2) first.	self assert: (3 to: 5 by: 2) last = (3 to: 6 by: 2) last.	self assert: (3 to: 5 by: 2) = (3 to: 6 by: 2).! !!IntervalTest methodsFor: 'testing' stamp: 'md 10/12/2003 20:13'!testEquals4	self assert: (3 to: 5 by: 2) = #(3 5).	self deny: (3 to: 5 by: 2) = #(3 4 5).	self deny: (3 to: 5 by: 2) = #().	self assert: #(3 5) = (3 to: 5 by: 2).	self deny: #(3 4 5) = (3 to: 5 by: 2).	self deny: #() = (3 to: 5 by: 2).! !!IntervalTest methodsFor: 'testing' stamp: 'md 10/12/2003 20:14'!testEquals5	self assert: (3 to: 5 by: 2) = (Heap withAll: #(3 5)).	self deny: (3 to: 5 by: 2) = (Heap withAll: #(3 4 5)).	self deny: (3 to: 5 by: 2) = Heap new.	self assert: (Heap withAll: #(3 5)) = (3 to: 5 by: 2).	self deny: (Heap withAll: #(3 4 5)) = (3 to: 5 by: 2).	self deny: Heap new = (3 to: 5 by: 2).! !!IntervalTest methodsFor: 'testing' stamp: 'md 10/12/2003 20:14'!testEquals6	self assert: #() = Heap new.	self assert: #(3 5) = (Heap withAll: #(3 5)).	self deny: (3 to: 5 by: 2) = (Heap withAll: #(3 4 5)).	self deny: (3 to: 5 by: 2) = Heap new.	self assert: Heap new = #().	self assert: (Heap withAll: #(3 5)) = #(3 5).	self deny: (Heap withAll: #(3 4 5)) = #(3 5).	self deny: Heap new = #(3 5).! !!IntervalTest methodsFor: 'testing' stamp: 'sd 12/23/2001 16:16'!testExtent	self assert: (Interval from: 10 to: 100) extent = 90! !!IntervalTest methodsFor: 'testing' stamp: 'md 1/14/2004 11:43'!testNewFrom	self shouldnt: [		 self assert: ( (Interval newFrom: (1 to: 1)) = (1 to: 1)).		 self assert: ( (Interval newFrom: #(1)) = (1 to: 1)).		 self assert: ( (Interval newFrom: #()) =  ( 1 to: 0)) .	] raise: Error.! !!IntervalTest methodsFor: 'testing' stamp: 'md 6/6/2003 15:02'!testPermutationsDo	| i oc |	i _ (1.234 to: 4.234).	oc _ OrderedCollection new.	i permutationsDo: [:e | oc add: e].	self assert: (oc size == i size factorial)! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:16'!aaaREADMEaboutPrimitives	"most of the Islands tweaks allow primitive methods to be located in places other than class Object.  Thus they are copied here for testing."! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:17'!classOf: anObject	<primitive: 111>! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:16'!instVarOf: anObject at: index	<primitive: 73>	self primitiveFailed! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:17'!instVarOf: anObject at: index put: anotherObject	<primitive: 74>	self primitiveFailed! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:18'!nextInstanceAfter: anObject	<primitive: 78>! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:18'!nextObjectAfter: anObject	<primitive: 139>! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:21'!replaceIn: replacee  from: start  to: stop   with: replacer  startingAt: replStart	<primitive: 105>	self primitiveFailed! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:19'!someInstanceOf: aClass	<primitive: 77>	self primitiveFailed! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:20'!someObject	<primitive: 138>	self primitiveFailed! !!IslandVMTweaksTestCase methodsFor: 'miscellaneous' stamp: 'ls 7/10/2003 17:42'!returnTwelve	"this method is tweaked by testFlagInCompiledMethod"	^12! !!IslandVMTweaksTestCase methodsFor: 'testing' stamp: 'ls 7/10/2003 11:03'!testEmptyReplace	| array1 array2 |	array1 := Array with: 1 with: 2 with: 3 with: 4.	array2 := Array with: 5 with: 6 with: 7.	self replaceIn: array1 from: 1 to: 0 with: array2 startingAt: 1.	self should: [ array1 = #(1 2 3 4) ].! !!IslandVMTweaksTestCase methodsFor: 'testing' stamp: 'ls 7/10/2003 18:53'!testFlagInCompiledMethod	"this tests that the flag in compiled methods is treated correctly"	| method |	method := self class compiledMethodAt: #returnTwelve.	"turn off the flag"	method objectAt: 1 put: (method header bitAnd: (1 << 29) bitInvert).	self should: [ method flag not ].	"turn on the flag"	method objectAt: 1 put: (method header bitOr: (1 << 29)).	self should: [ method flag ].	"try running the method with the flag turned on"	self should: [ self returnTwelve = 12 ].	"make sure the flag bit isn't interpreted as a primitive"	self should: [ method primitive = 0 ].! !!IslandVMTweaksTestCase methodsFor: 'testing' stamp: 'ls 7/10/2003 10:38'!testForgivingPrims	| aPoint anotherPoint array1 array2 |	aPoint := Point x: 5 y: 6.	anotherPoint := Point x: 7 y: 8.  "make sure there are multiple points floating around"	anotherPoint.  "stop the compiler complaining about no uses"	self should: [ (self classOf:  aPoint) = Point ].	self should: [ (self instVarOf: aPoint at: 1) = 5 ].	self instVarOf: aPoint at: 2 put: 10.	self should: [ (self instVarOf: aPoint at: 2) = 10 ].	self someObject.	self nextObjectAfter: aPoint.	self should: [ (self someInstanceOf: Point) class = Point ].	self should: [ (self nextInstanceAfter: aPoint) class = Point ].	array1 := Array with: 1 with: 2 with: 3.	array2 := Array with: 4 with: 5 with: 6.	self replaceIn: array1 from: 2 to: 3 with: array2 startingAt: 1.	self should: [ array1 = #(1 4 5) ].! !!LargePositiveIntegerTest methodsFor: 'as yet unclassified' stamp: 'md 3/17/2003 15:20'!testBitShift	"Check bitShift from and back to SmallInts"		1 to: 257 do: [:i | self should: [((i bitShift: i) bitShift: 0-i) == i]].! !!LargePositiveIntegerTest methodsFor: 'as yet unclassified' stamp: 'md 3/17/2003 15:17'!testMultDicAddSub	| n f f1 |		n _ 100.	f _ 100 factorial.	f1 _ f*(n+1).	n timesRepeat: [f1 _ f1 - f].	self should: [f1 = f]. 	n timesRepeat: [f1 _ f1 + f].	self should: [f1 // f = (n+1)]. 	self should: [f1 negated = (Number readFrom: '-' , f1 printString)].! !!LargePositiveIntegerTest methodsFor: 'as yet unclassified' stamp: 'md 3/17/2003 15:19'!testNormalize	"Check normalization and conversion to/from SmallInts"	self should: [(SmallInteger maxVal + 1 - 1) == SmallInteger maxVal].	self should: [(SmallInteger maxVal + 3 - 6) == (SmallInteger maxVal-3)].	self should: [(SmallInteger minVal - 1 + 1) == SmallInteger minVal].	self should: [(SmallInteger minVal - 3 + 6) == (SmallInteger minVal+3)].! !!MCPTest methodsFor: 'Testing - geometry' stamp: 'dgd 2/14/2003 10:13'!defaultBounds	"the default bounds for morphs"	^ 0 @ 0 corner: 50 @ 40 ! !!MCPTest methodsFor: 'Testing - geometry' stamp: 'dgd 2/14/2003 10:13'!defaultTop	"the default top for morphs"	^ self defaultBounds top ! !!MCPTest methodsFor: 'Testing - geometry' stamp: 'dgd 2/14/2003 10:15'!testTop	"test the #top: messages and its consequences"	| morph factor newTop newBounds |	morph _ Morph new.	""	factor _ 10.	newTop _ self defaultTop + factor.	newBounds _ self defaultBounds translateBy: 0 @ factor.	""	morph top: newTop.	""	self assert: morph top = newTop;		 assert: morph bounds = newBounds! !!MCPTest methodsFor: 'Testing' stamp: 'gm 2/22/2003 12:58'!testIsMorphicModel	"test isMorphicModel"	self deny: Object new isMorphicModel.	self deny: Morph new isMorphicModel.	self assert: MorphicModel new isMorphicModel.! !!MCPTest methodsFor: 'Testing' stamp: 'gm 2/16/2003 20:42'!testIsSystemWindow	"test isSystemWindow"	self deny: Object new isSystemWindow.	self assert: SystemWindow new isSystemWindow.	self assert: WorldWindow new isSystemWindow.! !!MacFileDirectoryTest methodsFor: 'test' stamp: 'sd 10/27/2003 18:05'!testMacFileDirectory	"(self run: #testMacFileDirectory)"		"This fails before the the fix if the Squeak directory is on the root	directory like: 'HardDisk:Squeak'	But should work both before and after the fix of John if there is several	directories in the hieracry: HardDisk:User:Squeak"	"If somebody can find a way to make the test failed all the time when the fix is not 	present we should replace it"	self assert: (FileDirectory default fullName) = (FileDirectory default fullNameFor: (FileDirectory default fullName))! !!MacFileDirectoryTest methodsFor: 'test' stamp: 'md 1/13/2004 17:54'!testMacFileFullPathFor	"(self run: #testMacFileFullPathFor)"	Smalltalk platformName =  'Mac OS' ifTrue: [	self		assert: (MacFileDirectory				isAbsolute: (FileDirectory default fullPathFor: FileDirectory default fullName)).	self		deny: (MacFileDirectory isAbsolute: (FileDirectory on: 'Data') pathName)	]! !!MacFileDirectoryTest methodsFor: 'test' stamp: 'md 1/13/2004 17:53'!testMacIsAbsolute	"(self selector: #testMacIsAbsolute) run"			self deny: (MacFileDirectory isAbsolute: 'Volumes').	self assert: (MacFileDirectory isAbsolute: 'Volumes:Data:Stef').	self assert: (MacFileDirectory isAbsolute: ':Desktop:test.st')! !!MacFileDirectoryTest methodsFor: 'test' stamp: 'sd 10/27/2003 18:02'!testMakeAbsolute	self assert: (MacFileDirectory isAbsolute: (MacFileDirectory makeAbsolute: 'Data')).	self assert: (MacFileDirectory isAbsolute: (MacFileDirectory makeAbsolute: ':Data')).! !!MailAddressParserTest methodsFor: 'initialize-release' stamp: 'md 3/17/2003 15:48'!setUp	"I am the method in which your test is initialized. If you have ressources to build, put them here."! !!MailAddressParserTest methodsFor: 'initialize-release' stamp: 'md 3/17/2003 15:48'!tearDown	"I am called whenever your test ends. I am the place where you release the ressources"! !!MailAddressParserTest methodsFor: 'testing' stamp: 'md 3/17/2003 15:54'!testAddressesIn	| testString correctAnswer |	testString _ 'joe@lama.com, joe2@lama.com joe3@lama.com joe4 , Not an Address <joe5@address>, joe.(annoying (nested) comment)literal@[1.2.3.4], "an annoying" group : joe1@groupie, joe2@groupie, "Joey" joe3@groupy, "joe6"."joe8"@group.com;,  Lex''s email account <lex>'.correctAnswer _ #('joe@lama.com' 'joe2@lama.com' 'joe3@lama.com' 'joe4' 'joe5@address' 'joe.literal@[1.2.3.4]' 'joe1@groupie' 'joe2@groupie' '"Joey"' 'joe3@groupy' '"joe6"."joe8"@group.com' 'lex') asOrderedCollection.	self should:	[(MailAddressParser addressesIn: testString) =  correctAnswer].! !!MethodReferenceTest methodsFor: 'Running' stamp: 'dgd 3/8/2003 11:48'!testEquals	| aMethodReference anotherMethodReference |	aMethodReference _ MethodReference new.	anotherMethodReference _ MethodReference new.	" 	two fresh instances should be equals between them"	self		should: [aMethodReference = anotherMethodReference].	self		should: [aMethodReference hash = anotherMethodReference hash].	" 	two instances representing the same method (same class and  	same selector) should be equals"	aMethodReference setStandardClass: String methodSymbol: #foo.	anotherMethodReference setStandardClass: String methodSymbol: #foo.	self		should: [aMethodReference = anotherMethodReference].	self		should: [aMethodReference hash = anotherMethodReference hash] ! !!MethodReferenceTest methodsFor: 'Running' stamp: 'dgd 3/8/2003 11:48'!testNotEquals	| aMethodReference anotherMethodReference |	aMethodReference _ MethodReference new.	anotherMethodReference _ MethodReference new.	""	aMethodReference setStandardClass: String methodSymbol: #foo.	anotherMethodReference setStandardClass: String class methodSymbol: #foo.	" 	differente classes, same selector -> no more equals"	self		shouldnt: [aMethodReference = anotherMethodReference].	" 	same classes, diferente selector -> no more equals"	anotherMethodReference setStandardClass: String methodSymbol: #bar.	self		shouldnt: [aMethodReference = anotherMethodReference] ! !!MorphTest methodsFor: 'initialize-release' stamp: 'md 4/16/2003 17:10'!setUp	morph := Morph new.! !!MorphTest methodsFor: 'initialize-release' stamp: 'md 4/16/2003 17:10'!tearDown	morph delete.! !!MorphTest methodsFor: 'testing - into/outOf World' stamp: 'ar 8/4/2003 00:11'!testIntoWorldCollapseOutOfWorld	| m1 m2 collapsed |	"Create the guys"	m1 := TestInWorldMorph new.	m2 := TestInWorldMorph new.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	"add them to basic morph"	morph addMorphFront: m1.	m1 addMorphFront: m2.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	"open the guy"	morph openInWorld.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	"collapse it"	collapsed := 	CollapsedMorph new beReplacementFor: morph.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 1).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 1).	"expand it"	collapsed collapseOrExpand.	self assert: (m1 intoWorldCount = 2).	self assert: (m1 outOfWorldCount = 1).	self assert: (m2 intoWorldCount = 2).	self assert: (m2 outOfWorldCount = 1).	"delete it"	morph delete.	self assert: (m1 intoWorldCount = 2).	self assert: (m1 outOfWorldCount = 2).	self assert: (m2 intoWorldCount = 2).	self assert: (m2 outOfWorldCount = 2).! !!MorphTest methodsFor: 'testing - into/outOf World' stamp: 'ar 8/4/2003 00:12'!testIntoWorldDeleteOutOfWorld	| m1 m2 |	"Create the guys"	m1 := TestInWorldMorph new.	m2 := TestInWorldMorph new.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	morph addMorphFront: m1.	m1 addMorphFront:  m2.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	morph openInWorld.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	morph delete.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 1).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 1).	! !!MorphTest methodsFor: 'testing - into/outOf World' stamp: 'ar 8/10/2003 18:30'!testIntoWorldTransferToNewGuy	| m1 m2 |	"Create the guys"	m1 := TestInWorldMorph new.	m2 := TestInWorldMorph new.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	morph addMorphFront: m1.	m1 addMorphFront:  m2.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	morph openInWorld.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	morph addMorphFront: m2.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	morph addMorphFront: m1.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	m2 addMorphFront: m1.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	morph delete.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 1).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 1).! !!MorphTest methodsFor: 'testing - classification' stamp: 'md 4/16/2003 17:11'!testIsMorph	self assert: (morph isMorph).! !!MorphTest methodsFor: 'testing - initialization' stamp: 'md 4/16/2003 17:10'!testOpenInWorld	self shouldnt: [morph openInWorld] raise: Error.! !!MyResumableTestError methodsFor: 'exceptionDescription' stamp: 'tfei 6/13/1999 00:46'!isResumable	^true! !!ObjectTest methodsFor: 'testing - error handling' stamp: 'm 8/12/2003 17:26'!testAssert	self shouldnt: [Object assert: [true]] raise: Error.	self shouldnt: [Object assert: true] raise: Error.	self should: [Object assert: [false]] raise: AssertionFailure.	self should: [Object assert: false] raise: AssertionFailure.! !!ObjectWithInitialize class methodsFor: 'initialize' stamp: 'sd 11/11/2003 13:38'!classVar	^ ClassVar! !!ObjectWithInitialize class methodsFor: 'initialize' stamp: 'sd 11/11/2003 13:54'!initialize	"self initialize"		Transcript show: 'Initializing ObjectWithInitialize. classVar state was: ', ClassVar asString; cr.		ClassVar isNil  		ifTrue: [ClassVar := 1]		ifFalse: [ClassVar := 2].	Transcript show: 'After initializing ObjectWithInitialize. classVar state is: ', ClassVar asString; cr.! !!ObjectWithInitialize class methodsFor: 'initialize' stamp: 'sd 11/11/2003 13:39'!reset	"self reset"		ClassVar := nil! !!ObsoleteMethodTest methodsFor: 'private'!copySuperedMethod: aMethod 	"Create a copy of a potentially supered method"	| copy nLits lastLit |	copy := aMethod copyWithTrailerBytes: #(0 0 0 0).	"regular"	nLits := aMethod numLiterals.	nLits > 0 		ifTrue: 			[lastLit := copy literalAt: nLits.			(lastLit isVariableBinding and: [lastLit value == self class]) 				ifTrue: [copy literalAt: nLits put: nil -> self targetClass class]].	^copy! !!ObsoleteMethodTest methodsFor: 'private' stamp: 'Noury Bouraqadi 9/16/2003 12:48'!patterns	"Answer all the methods implementing one of the obsolete #new methods"	| list |	list := IdentityDictionary new.	self class selectorsAndMethodsDo:[:sel :meth|		(sel beginsWith: 'obsolete') ifTrue:[			list at: sel put: (self copySuperedMethod: meth)]].	^list! !!ObsoleteMethodTest methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self class printString;		nextPutAll: '>>#';		nextPutAll: testSelector.	self targetClass ifNotNil: 			[aStream				nextPutAll: ' for ';				nextPutAll: self targetClass name]! !!ObsoleteMethodTest methodsFor: 'accessing' stamp: 'Noury Bouraqadi 9/16/2003 15:48'!targetClass	^targetClass! !!ObsoleteMethodTest methodsFor: 'accessing' stamp: 'Noury Bouraqadi 9/16/2003 15:48'!targetClass: aClass 	targetClass := aClass! !!ObsoleteMethodTest methodsFor: 'tests'!testObsoleteMethod	"Test if the implementation of obsoleteMethod matches any of the patterns defined in this test"	| aMethod |	aMethod := self targetClass compiledMethodAt: self class obsoleteMethodSelector				ifAbsent: [^self].	"allow the test to succeed if (for example) the method was removed"	self patterns 		keysAndValuesDo: [:obsoleteSelector :obsoleteMethod | self deny: aMethod = obsoleteMethod]! !!EmptyInitializeTest methodsFor: 'patterns' stamp: 'Noury Bouraqadi 9/16/2003 13:01'!obsoleteAnsweringSuperInitialize	^super initialize	! !!EmptyInitializeTest methodsFor: 'patterns' stamp: 'Noury Bouraqadi 9/16/2003 12:59'!obsoleteEmptyInitialize	"Should be implemented only by Object"! !!EmptyInitializeTest methodsFor: 'patterns' stamp: 'Noury Bouraqadi 9/16/2003 13:00'!obsoleteSuperInitialize	super initialize	! !!NewInitializeTest methodsFor: 'patterns' stamp: 'ar 9/16/2003 00:16'!obsoleteSelfBasicNewInitialize	"This pattern is obsoleted by Object class>>new"	^self basicNew initialize! !!NewInitializeTest methodsFor: 'patterns' stamp: 'ar 9/16/2003 00:23'!obsoleteSuperBasicNewInitialize	"This pattern is obsoleted by Object class>>new"	^super basicNew initialize! !!NewInitializeTest methodsFor: 'patterns' stamp: 'ar 9/16/2003 00:22'!obsoleteSuperNew	"This is pointless unless specifically documented"	^super new! !!NewInitializeTest methodsFor: 'patterns' stamp: 'ar 9/16/2003 00:16'!obsoleteSuperNewInitialize	"This pattern is obsoleted by Object class>>new"	^super new initialize! !!NewInitializeTest methodsFor: 'patterns' stamp: 'ar 9/16/2003 00:19'!obsoleteSuperNewInitializeWithTemp	"This pattern is obsoleted by Object class>>new"	| temp |	temp := super new.	temp initialize.	^temp! !!NewInitializeTest methodsFor: 'patterns' stamp: 'ar 9/16/2003 00:20'!obsoleteSuperNewInitializeWithTempDirectly	"This pattern is obsoleted by Object class>>new"	| temp |	temp := super new initialize.	^temp! !!NewInitializeTest methodsFor: 'patterns' stamp: 'ar 9/16/2003 00:17'!obsoleteSuperNewInitializeYourself	"This pattern is obsoleted by Object class>>new"	^(super new) initialize; yourself! !!ObsoleteMethodTest class methodsFor: 'Building Suites' stamp: 'md 11/13/2003 17:14'!buildSuite	"Construct this test suite from all classes implementing the obsoleteMethod"	| suite mcClasses  |	suite := self suiteClass named: self name asString.	self isAbstract ifTrue: [^suite].		mcClasses := (PackageInfo named: 'Monticello') classes.	mcClasses addAll: (mcClasses copy collect: [:each | each class]).		self classesToTest do:[:aClass|		((aClass includesSelector: self obsoleteMethodSelector) & (mcClasses includes: aClass) not) ifTrue:[			suite addTest: 				(self 					selector: self testMethodSelector 					targetClass: aClass).		].	].	^suite! !!ObsoleteMethodTest class methodsFor: 'Building Suites' stamp: 'Noury Bouraqadi 10/22/2003 09:44'!buildSuiteFromSelectors	^self buildSuite! !!ObsoleteMethodTest class methodsFor: 'Building Suites' stamp: 'Noury Bouraqadi 9/16/2003 12:58'!classesToTest	^Smalltalk allClasses asArray sort:[:cls1 :cls2| cls1 name <= cls2 name]! !!ObsoleteMethodTest class methodsFor: 'Building Suites' stamp: 'Noury Bouraqadi 9/16/2003 12:53'!obsoleteMethodSelector	self subclassResponsibility! !!ObsoleteMethodTest class methodsFor: 'Building Suites'!testMethodSelector	^#testObsoleteMethod! !!ObsoleteMethodTest class methodsFor: 'Testing'!isAbstract	^(self class whichClassIncludesSelector: #obsoleteMethodSelector) == ObsoleteMethodTest class! !!ObsoleteMethodTest class methodsFor: 'Instance Creation'!selector: aSelector targetClass: aClass 	^(self new)		setTestSelector: aSelector;		targetClass: aClass;		yourself! !!EmptyInitializeTest class methodsFor: 'Building Suites' stamp: 'Noury Bouraqadi 9/16/2003 13:16'!classesToTest	"Its Ok if Object has a method #initialize"	^super classesToTest copyWithout: Object! !!EmptyInitializeTest class methodsFor: 'Building Suites' stamp: 'Noury Bouraqadi 9/16/2003 12:56'!obsoleteMethodSelector	^#initialize! !!NewInitializeTest class methodsFor: 'Building Suites' stamp: 'Noury Bouraqadi 9/16/2003 15:07'!classesToTest	^super classesToTest collect: [:aClass| aClass class]! !!NewInitializeTest class methodsFor: 'Building Suites' stamp: 'Noury Bouraqadi 9/16/2003 12:53'!obsoleteMethodSelector	^#new! !!OrderedCollectionTest methodsFor: 'testing-public methods' stamp: 'sd 1/10/2004 15:28'!testAddBefore	"self run: #testAddBefore"	| l |	l := #(1 2 3 4) asOrderedCollection.	l add: 88 before: 1.	self assert: (l =  #(88 1 2 3 4) asOrderedCollection).	l add: 99 before: 2.	self assert: (l =  #(88 1 99 2 3 4) asOrderedCollection). ! !!OrderedCollectionTest methodsFor: 'testing-public methods' stamp: 'BG 1/10/2004 21:52'!testAddBeforeAndRemove	"self run: #testAddBefore"	| l initialCollection |	l := #(1 2 3 4) asOrderedCollection.	initialCollection := l shallowCopy.	l add: 88 before: 1.	self assert: (l =  #(88 1 2 3 4) asOrderedCollection).	l add: 99 before: 2.	self assert: (l =  #(88 1 99 2 3 4) asOrderedCollection). 	l remove: 99.	l remove: 88.	self assert: l = initialCollection.! !!OrderedCollectionTest methodsFor: 'testing-public methods' stamp: 'BG 1/10/2004 21:46'!testAddDuplicateItem1   | collection |   collection := #('Jim' 'Mary' 'John' 'Andrew' ) asOrderedCollection.   collection add: 'John' before: 'John'.   self assert: ((collection asBag occurrencesOf: 'John') = 2                  and: [(collection at: (collection indexOf: 'John') + 1)					= (collection at: (collection indexOf: 'John'))])! !!OrderedCollectionTest methodsFor: 'testing-public methods' stamp: 'BG 1/10/2004 21:49'!testAddItem1   | collection size |   collection := #('Jim' 'Mary' 'John' 'Andrew' ) asOrderedCollection.   size := collection size.   collection add: 'James' before: 'Jim'.   collection add: 'Margaret' before: 'Andrew'.   self assert: size + 2 = collection size.! !!OrderedCollectionTest methodsFor: 'testing-public methods' stamp: 'BG 1/10/2004 21:50'!testAddItem2   | collection |   collection := #('Jim' 'Mary' 'John' 'Andrew' ) asOrderedCollection.   collection add: 'James' before: 'Jim'.   collection add: 'Margaret' before: 'Andrew'.   self assert: (collection indexOf: 'James') + 1 = (collection indexOf: 'Jim').   self assert: (collection indexOf: 'Margaret') + 1 = (collection indexOf: 'Andrew').! !!OrderedCollectionTest methodsFor: 'testing-public methods' stamp: 'BG 1/10/2004 21:55'!testIndexOf   | collection indices |   collection := #('Jim' 'Mary' 'John' 'Andrew' ) asOrderedCollection.   indices := collection collect: [:item | collection indexOf: item].   self assert: (1 to: 4) asOrderedCollection = indices.   " note that this assertion does not hold in the presence of duplicate items. "! !!OrderedCollectionTest methodsFor: 'testing-public methods' stamp: 'BG 1/10/2004 22:45'!testIndexOfWithDuplicates   | collection indices bagOfIndices |   collection := #('Jim' 'Mary' 'John' 'Andrew' 'Mary' 'John' 'Jim' 'Micheal') asOrderedCollection.   indices := collection collect: [:item | collection indexOf: item].   self assert: indices asSet size = collection asSet size.   bagOfIndices := indices asBag.   self assert: (indices asSet                     allSatisfy: [:index | (bagOfIndices occurrencesOf: index)	                                       = (collection occurrencesOf: (collection at: index))]).  "  indexOf:  returns the index of the first occurrence of an item.     For an item with n occurrences, the index of its first occurrence     is found  n  times. "! !!PasteUpMorphTest methodsFor: 'texture fills' stamp: 'mjr 3/6/2003 11:34'!testGridToGradient	"A trivial test for checking that you can change from a grid to a  	gradient background. A recent [FIX] will make this pass."	| pum |	pum _ PasteUpMorph new.	pum setStandardTexture.	"The following should fail without the fix"	self		shouldnt: [pum gradientFillColor: Color red]		raise: MessageNotUnderstood! !!PointTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 21:38'!testIsZero	self assert: (0@0) isZero.		self deny:  (0@1) isZero.	self deny:  (1@0) isZero.	self deny:  (1@1) isZero.! !!ProcessTerminateBug methodsFor: 'tests' stamp: 'm 7/28/2003 19:10'!testSchedulerTermination   | process sema gotHere sema2 |   gotHere := false.   sema := Semaphore new.   sema2 := Semaphore new.   process := [       sema signal.       sema2 wait.       "will be suspended here"       gotHere := true. "e.g., we must *never* get here"   ] forkAt: Processor activeProcess priority.   sema wait. "until process gets scheduled"   process terminate.   sema2 signal.   Processor yield. "will give process a chance to continue andhorribly screw up"   self assert: gotHere not.! !!ProcessTerminateBug methodsFor: 'tests' stamp: 'ar 7/27/2003 19:44'!testUnwindFromActiveProcess	| sema process |	sema := Semaphore forMutualExclusion.	self assert:(sema isSignaled).	process := [		sema critical:[			self deny: sema isSignaled.			Processor activeProcess terminate.		]	] forkAt: Processor userInterruptPriority.	self assert: sema isSignaled.! !!ProcessTerminateBug methodsFor: 'tests' stamp: 'ar 7/27/2003 19:49'!testUnwindFromForeignProcess	| sema process |	sema := Semaphore forMutualExclusion.	self assert: sema isSignaled.	process := [		sema critical:[			self deny: sema isSignaled.			sema wait. "deadlock"		]	] forkAt: Processor userInterruptPriority.	self deny: sema isSignaled.	"This is for illustration only - the BlockCannotReturn cannot 	be handled here (it's truncated already)"	self shouldnt: [process terminate] raise: BlockCannotReturn.	self assert: sema isSignaled.	! !!ProtoObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 21:30'!testFlag	self shouldnt: [ProtoObject new flag: #hallo] raise: Error.! !!ProtoObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 21:29'!testIsNil	self assert: (ProtoObject new isNil = false).! !!PrototypeTester methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!prototype	"Get a prototype"	^ prototype copy ! !!PrototypeTester methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!prototype: aPrototype 	"Set my prototype"	prototype _ aPrototype copy ! !!PrototypeTester methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:57'!result	"Perform the test the default number of times"	^ self resultFor: self class defaultRuns ! !!EqualityTester methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!resultFor: runs 	"Test that equality is the same over runs and answer the result"	1		to: runs		do: [:i | self prototype = self prototype				ifFalse: [^ false]]. 	^ true! !!HashTester methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!resultFor: runs 	"Test that the hash is the same over runs and answer the result"	| hash |	hash _ self prototype hash.	1		to: runs		do: [:i | hash = self prototype hash				ifFalse: [^ false]].	^ true ! !!PrototypeTester class methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 13:08'!defaultRuns"the default number of times to test"	^ 50! !!PrototypeTester class methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 13:08'!with: aPrototype	^self new prototype:aPrototype! !!RandomTest methodsFor: 'setup' stamp: 'md 4/2/2003 12:32'!setUp	gen := Random seed: 112629.! !!RandomTest methodsFor: 'testing - accessing' stamp: 'md 4/2/2003 12:50'!testNext	10000 timesRepeat: [			| next | 			next := gen next.			self assert: (next >= 0).			self assert: (next < 1).	].! !!ReadWriteStreamTest methodsFor: 'testing' stamp: 'md 10/22/2003 12:47'!testConstructionUsingWith	"Use the with: constructor."	| aStream |	aStream _ ReadWriteStream with: #(1 2).	self assert: (aStream contents = #(1 2)) description: 'Ensure correct initialization.'! !!ReadWriteStreamTest methodsFor: 'testing' stamp: 'md 10/22/2003 12:54'!testNew	self should: [ReadWriteStream new] raise: Error.! !!RectangleTest methodsFor: 'testing' stamp: 'FBS 1/23/2004 13:22'!testMergingDisjointRects	| coll merge |	coll := OrderedCollection new.	coll add: (Rectangle left: -10 right: 0 top: -10 bottom: 0).	coll add: (Rectangle left: 0 right: 10 top: 0 bottom: 10).	merge := Rectangle merging: coll.	self assert: merge = (Rectangle left: -10 right: 10 top: -10 bottom: 10).! !!RectangleTest methodsFor: 'testing' stamp: 'FBS 1/23/2004 13:16'!testMergingNestedRects	| coll merge |	coll := OrderedCollection new.	coll add: (Rectangle left: 1 right: 10 top: 1 bottom: 10).	coll add: (Rectangle left: 4 right: 5 top: 4 bottom: 5).	merge := Rectangle merging: coll.	self assert: merge = coll first.! !!RectangleTest methodsFor: 'testing' stamp: 'FBS 1/23/2004 13:18'!testMergingOverlappingRects	| coll merge |	coll := OrderedCollection new.	coll add: (Rectangle left: 5 right: 10 top: 0 bottom: 15).	coll add: (Rectangle left: 0 right: 15 top: 5 bottom: 10).	merge := Rectangle merging: coll.	self assert: merge = (Rectangle left: 0 right: 15 top: 0 bottom: 15).! !!RectangleTest methodsFor: 'testing' stamp: 'FBS 1/23/2004 13:21'!testMergingTrivial	| coll merge |	coll := OrderedCollection new.	coll add: (Rectangle left: 1 right: 1 top: 1 bottom: 1).	merge := Rectangle merging: coll.	self assert: merge = coll first.! !!RectangleTest methodsFor: 'testing' stamp: 'FBS 1/23/2004 13:18'!testMergingTwoRects	| coll merge |	coll := OrderedCollection new.	coll add: (Rectangle left: 1 right: 1 top: 1 bottom: 1).	coll add: (Rectangle left: 10 right: 10 top: 10 bottom: 10).	merge := Rectangle merging: coll.	self assert: merge = (Rectangle left: 1 right: 10 top: 1 bottom: 10).! !!ScriptableButtonTest methodsFor: 'initialize-release' stamp: 'md 10/22/2003 13:01'!setUp	button := ScriptableButton new openInWorld.! !!ScriptableButtonTest methodsFor: 'initialize-release' stamp: 'md 10/22/2003 13:11'!tearDown	button delete.! !!ScriptableButtonTest methodsFor: 'testing' stamp: 'md 10/22/2003 13:12'!testEditButtonsScript	self shouldnt: [button editButtonsScript] raise: Error.	World currentHand submorphsReverseDo: [:each | each delete].			! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:23'!testExample1	"This is the first example from the specification document (FIPS PUB 180-1)"	hash _ SecureHashAlgorithm new hashMessage: 'abc'.	self assert: (hash = 16rA9993E364706816ABA3E25717850C26C9CD0D89D).		! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:23'!testExample2	"This is the second example from the specification document (FIPS PUB 180-1)"	hash _ SecureHashAlgorithm new hashMessage:		'abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq'.	self assert: (hash = 16r84983E441C3BD26EBAAE4AA1F95129E5E54670F1).! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:25'!testExample3	"This is the third example from the specification document (FIPS PUB 180-1). 	This example may take several minutes."	hash _ SecureHashAlgorithm new hashMessage: (String new: 1000000 withAll: $a).	self assert: (hash = 16r34AA973CD4C4DAA4F61EEB2BDBAD27316534016F).! !!SetTest methodsFor: 'initialize-release' stamp: 'md 4/16/2003 15:03'!setUp	"I am the method in which your test is initialized. If you have ressources to build, put them here."! !!SetTest methodsFor: 'initialize-release' stamp: 'md 4/16/2003 15:03'!tearDown	"I am called whenever your test ends. I am the place where you release the ressources"! !!SmallIntegerTest methodsFor: 'testing - Class Methods' stamp: 'md 4/15/2003 20:53'!testBasicNew	self should: [SmallInteger basicNew] raise: TestResult error. ! !!SmallIntegerTest methodsFor: 'testing - Class Methods' stamp: 'md 4/15/2003 20:55'!testMaxVal	self should: [SmallInteger maxVal = 16r3FFFFFFF].! !!SmallIntegerTest methodsFor: 'testing - Class Methods' stamp: 'md 4/15/2003 20:55'!testMinVal	self should: [SmallInteger minVal = -16r40000000].! !!SmallIntegerTest methodsFor: 'testing - Class Methods' stamp: 'md 3/25/2003 23:14'!testNew	self should: [SmallInteger new] raise: TestResult error. ! !!SocketStreamTest methodsFor: 'running' stamp: 'len 7/21/2003 11:50'!setUp	listener _ Socket newTCP listenOn: 7357 backlogSize: 5.	stream1 _ SocketStream on: (Socket newTCP connectTo: NetNameResolver localHostAddress port: 7357).	stream2 _ SocketStream on: listener accept! !!SocketStreamTest methodsFor: 'running' stamp: 'len 7/21/2003 11:50'!tearDown	listener close.	stream1 close.	stream2 close! !!SocketStreamTest methodsFor: 'running' stamp: 'md 11/13/2003 17:09'!testNextColonBug	stream2 timeout: 1.	stream1 nextPutAll: '12345678'; flush.	stream2 next: 4.	"self should: [stream2 next: 8] raise: ConnectionTimedOut"	self assert: false.	"md: doesn't timeOut for me... just hangs".! !!SocketStreamTest methodsFor: 'running' stamp: 'md 1/13/2004 18:02'!testNextColonConnectionTimeout	"	stream1 nextPutAll: '12345'; flush.	stream2 timeout: 1.	self should: [stream2 next: 10] raise: ConnectionTimedOut.	stream1 nextPutAll: '67890'; flush.	self assert: (stream2 next: 10) size = 10	"	self assert: false.	"md: doesn't timeOut for me... just hangs".! !!StreamBugz methodsFor: 'as yet unclassified' stamp: 'ar 8/5/2003 02:25'!testReadWriteStreamNextNBug	| aStream |	aStream := ReadWriteStream on: String new.	aStream nextPutAll: 'Hello World'.	self shouldnt:[aStream next: 5] raise: Error.! !!StringTest methodsFor: 'initialize-release' stamp: 'md 4/18/2003 10:00'!setUp	string := 'Hi, I am a String'! !!StringTest methodsFor: 'initialize-release' stamp: 'md 4/16/2003 15:51'!tearDown	"I am called whenever your test ends. I am the place where you release the ressources"! !!StringTest methodsFor: 'testing - accessing' stamp: 'md 4/18/2003 10:01'!testAt	self assert: (string at: 1) = $H.! !!SymbolTest methodsFor: 'initialize-release' stamp: 'md 4/17/2003 20:06'!setUp	"I am the method in which your test is initialized. If you have ressources to build, put them here."! !!SymbolTest methodsFor: 'initialize-release' stamp: 'md 4/17/2003 20:06'!tearDown	"I am called whenever your test ends. I am the place where you release the ressources"! !!TestCaseDoubleInitialize methodsFor: 'setUp' stamp: 'sd 11/11/2003 13:47'!setUp	ObjectWithInitialize reset.	ObjectWithInitialize initialize	! !!TestCaseDoubleInitialize methodsFor: 'setUp' stamp: 'sd 11/11/2003 14:08'!tearDown	| res |	res := Smalltalk at: #ObjectWithInitializeSubclass ifAbsent: [nil]. 	res isNil 		ifFalse: [Smalltalk removeClassNamed: #ObjectWithInitializeSubclass]! !!TestCaseDoubleInitialize methodsFor: 'tests' stamp: 'sd 11/11/2003 13:48'!testInitializeIsCallOnceWhenClassIsInitialized	"self run: #testInitializeIsCallOnceWhenClassIsInitialized"		"as the setup run reset and initialize should be in 1"	self assert: ObjectWithInitialize classVar =1! !!TestCaseDoubleInitialize methodsFor: 'tests' stamp: 'md 11/11/2003 18:02'!testInitializeIsCallOnceWhensubclassIsCreated	"self debug: #testInitializeIsCallOnceWhensubclassIsCreated"	ObjectWithInitialize		subclass: #ObjectWithInitializeSubclass		instanceVariableNames: ' '		classVariableNames: ''		poolDictionaries: ''		category: 'Tests-KCP'.	self assert: ObjectWithInitialize classVar =1.! !!TestInWorldMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2003 00:06'!initialize	super initialize.	outOfWorldCount := intoWorldCount := 0.! !!TestInWorldMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2003 00:03'!intoWorld: aWorld	aWorld ifNil:[^self].	super intoWorld: aWorld.	intoWorldCount := intoWorldCount + 1.! !!TestInWorldMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2003 00:06'!intoWorldCount	^intoWorldCount! !!TestInWorldMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2003 00:03'!outOfWorld: aWorld	aWorld ifNil:[^self].	super outOfWorld: aWorld.	outOfWorldCount := outOfWorldCount + 1.! !!TestInWorldMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2003 00:06'!outOfWorldCount	^outOfWorldCount! !!TestIndenting methodsFor: 'running' stamp: 'hmm 2/2/2001 14:29'!setUp	| text |	text _ 'p	' asText, (Text string: 'word word' attribute: (TextIndent tabs: 1)).	para _ text asParagraph! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:42'!testBreak1	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para compositionRectangle: (0@0 extent: para width - 1@100); updateCompositionHeight.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: cb top > 0.	self assert: cb left = 24! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:45'!testBreak2	"When an indented line is broken at a space, the character block must still lie in the line crossing the right margin."	| cb |	para compositionRectangle: (0@0 extent: para width - 24 // 2 + 24@100); updateCompositionHeight.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 7.	self assert: cb top = 0.	self assert: cb left >= 24! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:41'!testCR	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para replaceFrom: 7 to: 7 with: (String with: Character cr) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: cb top > 0.	self assert: cb left = 24! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:41'!testCR2	"Checks whether the drawing of indented text is really indented..."	| cb |	para replaceFrom: 7 to: 7 with: (String with: Character cr) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: (para asForm copy: (0@cb top extent: 24@cb height)) isAllWhite! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 15:17'!testCR3	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para replaceFrom: 11 to: 11 with: (Text string: (String with: Character cr) attribute: (TextIndent tabs: 1)) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 12.	self assert: cb top > 0.	self assert: cb left = 24! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'md 1/13/2004 17:38'!testAddNumbers"self debug: #testAddNumbers"	"md: I had to comment out the error... did strange things"	self class addSelector: #add:with: withMethod: TestObjectsAsMethodsFunction.	self assert: (self add: 3 with: 4) = 7.	"self assert: (self perform: #add:with: withArguments: #(3 4)) = 7. "	self class removeSelectorSimply: #add:with:.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'ar 5/17/2003 20:23'!testAnswer42	self class addSelector: #answer42 withMethod: TestObjectsAsMethodsFunction.	self assert: self answer42 = 42.	self class removeSelectorSimply: #answer42.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'ar 5/17/2003 20:21'!testDNU	self class addSelector: #answer42 withMethod: Object.	self should: [self answer42] raise: MessageNotUnderstood.	self class removeSelectorSimply: #answer42.! !!TestObjectsAsMethodsFunction methodsFor: 'as yet unclassified' stamp: 'ar 5/17/2003 20:16'!add: a with: b	^a + b! !!TestObjectsAsMethodsFunction methodsFor: 'as yet unclassified' stamp: 'ar 5/17/2003 20:16'!answer42	^42! !!TestObjectsAsMethodsFunction class methodsFor: 'as yet unclassified' stamp: 'ar 5/17/2003 20:19'!run: oldSelector with: arguments in: aReceiver	^self new perform: oldSelector withArguments: arguments! !!TestParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 15:05'!setUp	para _ 'i i' asParagraph! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:52'!testCharacterBlockAfterReplacingAll	para replaceFrom: 1 to: 3 with: 'mmm' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockAfterReplacingOther	para replaceFrom: 3 to: 3 with: 'm' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockAfterReplacingSpace	para replaceFrom: 3 to: 3 with: ' ' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockNormal	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestNewParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 17:41'!setUp	| morph |	morph _ TextMorph new contents: 'i i'.	morph fit.	para _ morph paragraph! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingAll	^super testCharacterBlockAfterReplacingAll! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingOther	^super testCharacterBlockAfterReplacingOther! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingSpace	^super testCharacterBlockAfterReplacingSpace! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:43'!testCharacterBlockNormal	^super testCharacterBlockNormal! !!TestsForTextAndTextStreams methodsFor: 'example1' stamp: 'BG 6/10/2003 20:17'!example1: size   | ts text |  ts := TextStream on: (Text new: size).  ts  nextPutAll: 'xxxxx' asText.  ts nextPutAll: ('yyyyy' asText allBold, 'zzzzzzz' asText).  text := ts contents.  ^text  ! !!TestsForTextAndTextStreams methodsFor: 'example2' stamp: 'BG 6/10/2003 20:26'!example2      | ts text |  ts := TextStream on: (Text new: 50).  ts  nextPutAll: 'abc' asText.  ts nextPutAll: 'def' asText allBold.  ts nextPutAll: 'ghijk' asText.  text := ts contents.  ^text  ! !!TestsForTextAndTextStreams methodsFor: 'replacement examples' stamp: 'BG 6/11/2003 13:09'!replacementAtStartExample3   | text1  replacement  length  |   text1 := 'This is a simple text' copy asText.    " without the copy, we would modify a constant that the compiler attached at the compiled method. "   length  := 'This' size.   replacement := 'Tht' asText.   text1 replaceFrom: 1         to:   length        with: replacement        startingAt: 1.! !!TestsForTextAndTextStreams methodsFor: 'replacement examples' stamp: 'BG 6/11/2003 13:05'!replacementExample3  " for a Text  t,     the following assertion should always hold:     t string size = t run size     This test examines the preservation of this assertion for in-place replacement  Here, the replacement text is shorteer than the text that is shall replace. "   | text1 string replacement startPos length startPosInRep string2 |   text1 := (string := 'This is again simple text' copy) asText.     " without the copy, we would modify a constant that the compiler attached at the compiled method. "   startPos := string findString: 'simple'.    length  := 'simple' size.   replacement := (string2 := 'both simple and short') asText.   startPosInRep :=  string2 findString: 'short'.   text1 replaceFrom: startPos         to: startPos + length - 1        with: replacement        startingAt: startPosInRep.   ! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/10/2003 20:46'!testExampleRunArray1  " this demonstrates that the size of a run array is the sum of the sizes of its runs. " | runArray |   runArray := RunArray new.   runArray      addLast: TextEmphasis normal times: 5;     addLast: TextEmphasis bold times: 5;     addLast: TextEmphasis normal times: 5.   self assert:       (runArray size = 15). ! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/10/2003 20:47'!testExampleRunArray2  " this demonstrates that different runs are not merged " | runArray |   runArray := RunArray new.   runArray      addLast: TextEmphasis normal times: 5;     addLast: TextEmphasis bold times: 5;     addLast: TextEmphasis normal times: 5.   self assert:       (runArray runs size = 3). ! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/10/2003 20:48'!testExampleRunArray3  " this demonstrates that adjancent runs with equal attributes are merged. " | runArray |   runArray := RunArray new.   runArray      addLast: TextEmphasis normal times: 5;     addLast: TextEmphasis bold times: 5;     addLast: TextEmphasis bold times: 5.   self assert:       (runArray runs size = 2). ! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/10/2003 20:47'!testExampleRunArray4  " this tests the reversal of a  RunArray " | runArray |   runArray := RunArray new.   runArray      addLast: TextEmphasis normal times: 5;     addLast: TextEmphasis bold times: 5;     addLast: TextEmphasis normal times: 5.   self assert:       (runArray reversed runs size = 3). ! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/12/2003 08:19'!testExampleRunArray5  " this verifies that the fundamental invariant of a RunArray is always satisfied. "  " see comment below" | runArray |   runArray := RunArray new.   runArray      addLast: TextEmphasis normal times: 5;     addLast: TextEmphasis bold times: 5;     addLast: TextEmphasis normal times: 5.   self assert:       ((1 to: runArray size) allSatisfy:           [:idx |  | lastIndex lastOffset lastRun lengthOfPreviousRuns |               runArray at: idx.  " updates the cached values "               lastIndex := runArray instVarNamed: 'lastIndex'.               lastRun := runArray instVarNamed: 'lastRun'.               lastOffset := runArray instVarNamed: 'lastOffset'.               lengthOfPreviousRuns                    := (1 to: lastRun - 1)                      inject: 0                       into: [:sum :idx2 | sum + (runArray runs at: idx2)].               lastIndex = (lastOffset + lengthOfPreviousRuns + 1)            ]       ). " This method is a bit tricky. First, it uses Object>>instVarNamed: to access instance variables for which no accessors are defined. The same method is used by the debuggers and by various inspectors.The assertion itself explains the meaning of the cached values. "! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/11/2003 19:56'!testExampleText1  " inspired by a bug report from Tim Olson.    Text attributes are lost when the stream collection is expanded. "    | text1 text2 atts1 atts2 |      text1 := self example1: 10. " here we will loose the attribute bold "      text2 := self example1: 50. " here we have a larger buffer and will not loose text attributes "      atts1 := text1 runs copyFrom: 6 to: 10.       atts2 := text2 runs copyFrom: 6 to: 10.       self assert: atts1 = atts2.      ! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/10/2003 20:51'!testExampleText2  "  a Text looses its attributes when it is reversed "    | text1 text2 |    text1 := self example2.    text2 := text1 reversed reversed.    self assert:  text1 runs  = text2 runs. ! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/12/2003 08:26'!testExampleText3  "  It is possible to add a string into a TextStream.     This test verifies that the created text has text attributes for all its characters. "      | ts text |  ts := TextStream on: (Text new: 50).  ts  nextPutAll: 'abc' asText.  ts nextPutAll: 'def' asText allBold.  ts nextPutAll: 'ghijk'.  text := ts contents.     " now, check the fundamental invariant of a text: "  self assert: text string size = text runs size.! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/12/2003 11:31'!testExampleText4  "  This test verifies that adjacent runs with identical attributes are coalesced.  "      | ts text rangeOfBold |  ts := TextStream on: (Text new: 50).  ts  nextPutAll: 'abc' asText.  ts nextPutAll: 'def' asText allBold.  ts nextPutAll: 'ghijk'.  text := ts contents.  rangeOfBold := text find:  TextEmphasis bold.  text removeAttribute: TextEmphasis bold from: rangeOfBold first to: rangeOfBold last.      " now, check that only one run is left and that it has the correct size "  self assert: text runs runs size = 1 & (text runs size = text string size).! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'dvf 10/1/2003 13:28'!testRangeDetection1  " this tests the detection of the range of a text attribute. "   | text startPos boldStyle |  text := 'This is a text with attriute bold for some characters' asText.  startPos := text findString: 'bold' startingAt: 1.  text addAttribute: TextEmphasis bold       from: startPos to: startPos + 3.  boldStyle := TextEmphasis bold.  " uncomment the following statement for examine failures: "  " -----------------       (1 to: text size) do:           [:idx | | range |              range := text rangeOf: boldStyle startingAt: idx.             Transcript show: startPos; show: ' -- '; show: idx printString; show: '  '; show: range printString; show: range size printString; show: ((idx between: startPos and: startPos + 3)                  ifTrue:                    [range first = startPos & (range size = 4)]                  ifFalse:                    [range first = idx & (range size = 0)]) printString; cr.           ].    ------------- "  self assert:        ((1 to: text size) allSatisfy:           [:idx | | range |              range := text rangeOf: boldStyle startingAt: idx.              (idx between: startPos and: startPos + 3)                  ifTrue:                    [range first = startPos & (range size = 4)]                  ifFalse:                    [range first = idx & (range size = 0)]           ]       )! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'dvf 10/1/2003 13:28'!testRangeDetection2  " this tests the detection of the range of a text attribute.    Here the searched attribute spans three runs. The objective of the test is whether the entire range is always found."   | text startPos searchedStyle |  text := 'This is a text with attriute bold for some characters' asText.  startPos := text findString: 'bold' startingAt: 1.  text addAttribute: TextEmphasis bold       from: startPos to: startPos + 3.  text addAttribute: TextEmphasis italic       from: startPos - 2 to: startPos + 5.  searchedStyle := TextEmphasis italic.  " uncomment the following statement for examine failures: "   " -----------------------       (1 to: text size) do:           [:idx | | range |               range := text rangeOf: searchedStyle startingAt: idx.             Transcript show: startPos; show: ' -- '; show: idx printString; show: '  '; show: range printString; show: range size printString; show: ((idx between: startPos - 2 and: startPos -2 + 7)                  ifTrue:                    [range first = (startPos - 2) & (range size = 8)]                  ifFalse:                    [range first = idx & (range size = 0)]) printString; cr.           ].   ----------------------- "  self assert:        ((1 to: text size) allSatisfy:           [:idx | | range |              range := text rangeOf: searchedStyle startingAt: idx.              (idx between: startPos - 2 and: startPos -2 + 7)                  ifTrue:                    [range first = (startPos - 2) & (range size = 8)]                  ifFalse:                    [range first = idx & (range size = 0)]           ]       )! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'dvf 10/1/2003 13:28'!testRangeDetection3  " this tests the detection of the range of a text attribute.    Here the searched attribute spans three runs. The the range to be detected begins at text position 1. The objective of the test is whether the entire range is always found."   | text startPos searchedStyle |  text := 'This is a text with attriute bold for some characters' asText.  startPos := text findString: 'bold' startingAt: 1.  text addAttribute: TextEmphasis bold       from: startPos to: startPos + 3.  text addAttribute: TextEmphasis italic       from: 1 to: startPos + 5.  searchedStyle := TextEmphasis italic.  " uncomment the following statement to examine failures: "   " -----------------------       (1 to: text size) do:           [:idx | | range |               range := text rangeOf: searchedStyle startingAt: idx.             Transcript show: startPos;					show: ' -- ';					show: idx printString;					show: '  ';					show: range printString;					show: range size printString;                        show: ' ';					 show: ((idx between: 1 and: startPos + 5)                  					ifTrue:                  					  [range first = 1 & (range size = (startPos + 5))]                					ifFalse:                   					 [range first = idx & (range size = 0)]) printString; cr.           ].   ----------------------- "  self assert:        ((1 to: text size) allSatisfy:           [:idx | | range |              range := text rangeOf: searchedStyle startingAt: idx.              (idx between: 1 and: startPos + 5)                  ifTrue:                    [range first = 1 & (range size = (startPos + 5))]                  ifFalse:                    [range first = idx & (range size = 0)]           ]       )! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'dvf 10/1/2003 13:29'!testRangeDetection4  " this tests the detection of the range of a text attribute.    Here the searched attribute spans three runs. The the range to be detected extends to the end of the text . The objective of the test is whether the entire range is always found."   | text startPos searchedStyle |  text := 'This is a text with attriute bold for some characters' asText.  startPos := text findString: 'bold' startingAt: 1.  text addAttribute: TextEmphasis bold       from: startPos to: startPos + 3.  text addAttribute: TextEmphasis italic       from: startPos - 2 to: text size.  searchedStyle := TextEmphasis italic.  " uncomment the following statement to examine failures: "   " -----------------------------------------       (1 to: text size) do:           [:idx | | range |               range := text rangeOf: searchedStyle startingAt: idx.             Transcript show: startPos;					show: ' -- ';					show: idx printString;					show: '  ';					show: range printString;					show: range size printString;                        show: ' ';					 show: ((idx between: startPos - 2 and: text size)                  			ifTrue:   			                 [range first = (startPos - 2) & (range size = (text size - (startPos - 2) + 1))]                  			ifFalse: 			                 [range first = idx & (range size = 0)]) printString;					cr.           ].   -------------------------------"  self assert:        ((1 to: text size) allSatisfy:           [:idx | | range |              range := text rangeOf: searchedStyle startingAt: idx.              (idx between: startPos - 2 and: text size)                  ifTrue:                    [range first = (startPos - 2) & (range size = (text size - (startPos - 2) + 1))]                  ifFalse:                    [range first = idx & (range size = 0)]           ]       )! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/10/2003 23:09'!testReplacement1  " for a Text  t,     the following assertion should always hold:     t string size = t run size     This test examines the preservation of this assertion for in-place replacement "   | text1 string replacement startPos length startPosInRep string2 |   text1 := (string := 'This is a simple text' copy) asText.    " without the copy, we would modify a constant that the compiler attached at the compiled method. "   startPos := string findString: 'simple'.    length  := 'simple' size.   replacement := (string2 := 'both simple and short*') asText.   startPosInRep :=  string2 findString: 'short'.   text1 replaceFrom: startPos         to: startPos + length - 1        with: replacement        startingAt: startPosInRep.   self assert: text1 string size = text1 runs size.! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/10/2003 23:09'!testReplacement2  " for a Text  t,     the following assertion should always hold:     t string size = t run size     This test examines the preservation of this assertion for in-place replacement.    Here, the replacement text has trailing characters. "   | text1 string replacement startPos length startPosInRep string2 |   text1 := (string := 'This is simple text' copy) asText.    " without the copy, we would modify a constant that the compiler attached at the compiled method. "   startPos := string findString: 'simple'.    length  := 'simple' size.   replacement := (string2 := 'both simple and short*************') asText.   startPosInRep :=  string2 findString: 'short'.   text1 replaceFrom: startPos         to: startPos + length - 1        with: replacement        startingAt: startPosInRep.   self assert: text1 string size = text1 runs size.! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/11/2003 13:07'!testReplacement3  " for a Text  t,     the following assertion should always hold:     t string size = t run size     This test examines the preservation of this assertion for in-place replacement  Here, the replacement text is shorteer than the text that is shall replace. "   self should: [self replacementExample3]        raise: Error! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/11/2003 05:54'!testReplacementAtStartPos1  " for a Text  t,     the following assertion should always hold:     t string size = t run size     This test examines the preservation of this assertion for in-place replacement "   | text1  replacement  length  |   text1 := 'This is a simple text' copy asText.    " without the copy, we would modify a constant that the compiler attached at the compiled method. "   length  := 'This' size.   replacement := 'That' asText.   text1 replaceFrom: 1         to:   length        with: replacement        startingAt: 1.   self assert: text1 string size = text1 runs size.! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/11/2003 05:55'!testReplacementAtStartPos2  " for a Text  t,     the following assertion should always hold:     t string size = t run size     This test examines the preservation of this assertion for in-place replacement "   | text1  replacement  length  |   text1 := 'This is a simple text' copy asText.    " without the copy, we would modify a constant that the compiler attached at the compiled method. "   length  := 'This' size.   replacement := 'That********' asText.   text1 replaceFrom: 1         to:   length        with: replacement        startingAt: 1.   self assert: text1 string size = text1 runs size.! !!TestsForTextAndTextStreams methodsFor: 'Testing' stamp: 'BG 6/11/2003 13:08'!testReplacementAtStartPos3  " for a Text  t,     the following assertion should always hold:     t string size = t run size     This test examines the preservation of this assertion for in-place replacement  Here, the replacement text is shorteer than the text that is shall replace. "   self should: [self replacementAtStartExample3]        raise: Error! !!TextAlignmentTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes add: TextAlignment centered;		 add: TextAlignment justified;		 add: TextAlignment leftFlush;		 add: TextAlignment rightFlush ! !!TextAnchorTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes		add: (TextAnchor new anchoredMorph: RectangleMorph new initialize);				add: (TextAnchor new anchoredMorph: EllipseMorph new initialize) ! !!TextEmphasisTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes add: TextEmphasis bold;		 add: TextEmphasis italic;		 add: TextEmphasis narrow;		 add: TextEmphasis normal;		 add: TextEmphasis struckOut;		 add: TextEmphasis underlined ! !!TextFontChangeTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:55'!setUp	"create the prototypes for testing"	super setUp.	prototypes add: TextFontChange defaultFontChange.	prototypes add: TextFontChange font1.	prototypes add: TextFontChange font2.	prototypes add: TextFontChange font3.	prototypes add: TextFontChange font4.	prototypes		add: (TextFontChange fontNumber: 6) ! !!TextFontChangeTest methodsFor: 'testing' stamp: 'mjr 8/17/2003 20:29'!testEquality	"Check that different instances of the same TextFontChange are equal"	self assert: TextFontChange defaultFontChange = TextFontChange defaultFontChange.	self assert: TextFontChange font1 = TextFontChange font1.	self assert: TextFontChange font2 = TextFontChange font2.	self assert: TextFontChange font3 = TextFontChange font3.	self assert: TextFontChange font4 = TextFontChange font4.	self assert: (TextFontChange fontNumber: 6)			= (TextFontChange fontNumber: 6)! !!TextFontChangeTest methodsFor: 'testing' stamp: 'mjr 8/17/2003 20:16'!testHash	"test that different instances of the same TextFontChange hash to the 	same value"	| hashes hash |	hashes _ OrderedCollection new.	1		to: 100		do: [:i | hashes add: TextFontChange defaultFontChange hash].	hash _ hashes at: 1.	2		to: 100		do: [:i | self assert: (hashes at: i)					= hash]! !!TextFontReferenceTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes		add: (TextFontReference				toFont: (StrikeFont familyName: 'NewYork' size: 15)) ! !!TextKernTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes		add: (TextKern kern: 1) ! !!TextLineEndingsTest methodsFor: 'Running' stamp: 'nk 11/1/2003 07:52'!testDecoratedTextConversionCrLF	| text newText |	text _ ('123456', String crlf, '901234') asText.	text addAttribute: TextColor blue from: 4 to: 10.	text addAttribute: TextColor red from: 6 to: 9.	text addAttribute: TextEmphasis bold.	newText _ text withSqueakLineEndings.	self assert: ((text size - 1) = newText size).	self assert: (newText size = newText runs size).	self assert: (newText attributesAt: 6) = (text attributesAt: 6).	self assert: (newText attributesAt: 8) = (text attributesAt: 9).! !!TextLineEndingsTest methodsFor: 'Running' stamp: 'nk 11/1/2003 07:53'!testDecoratedTextConversionJustLF	| text newText |	text _ ('123456', String lf, '901234') asText.	text addAttribute: TextColor blue from: 4 to: 10.	text addAttribute: TextColor red from: 6 to: 9.	text addAttribute: TextEmphasis bold.	newText _ text withSqueakLineEndings.	self assert: ((text size) = newText size).	self assert: (newText size = newText runs size).	self assert: (newText attributesAt: 6) = (text attributesAt: 6).	self assert: (newText attributesAt: 8) = (text attributesAt: 8).! !!TextLineEndingsTest methodsFor: 'Running' stamp: 'nk 11/1/2003 07:53'!testDecoratedTextConversionNoLF	| text newText |	text _ ('123456', String cr, '901234') asText.	text addAttribute: TextColor blue from: 4 to: 10.	text addAttribute: TextColor red from: 6 to: 9.	text addAttribute: TextEmphasis bold.	newText _ text withSqueakLineEndings.	self assert: ((text size) = newText size).	self assert: (newText size = newText runs size).	self assert: (newText attributesAt: 6) = (text attributesAt: 6).	self assert: (newText attributesAt: 8) = (text attributesAt: 8).! !!TextLineEndingsTest methodsFor: 'Running' stamp: 'nk 11/1/2003 07:47'!testSimpleTextConversionCrLF	| string newText |	string _ 'This is a test', String crlf, 'of the conversion'.	newText _ string asText withSqueakLineEndings.	self assert: ((string size - 1) = newText size).	self assert: (newText size = newText runs size).! !!TextLineEndingsTest methodsFor: 'Running' stamp: 'nk 11/1/2003 07:54'!testSimpleTextConversionJustCR	| string newText |	string _ 'This is a test', String cr, 'of the conversion'.	newText _ string asText withSqueakLineEndings.	self assert: ((string size) = newText size).	self assert: (newText size = newText runs size).! !!TextLineEndingsTest methodsFor: 'Running' stamp: 'nk 11/1/2003 07:54'!testSimpleTextConversionJustLF	| string newText |	string _ 'This is a test', String lf, 'of the conversion'.	newText _ string asText withSqueakLineEndings.	self assert: ((string size) = newText size).	self assert: (newText size = newText runs size).! !!TextLineEndingsTest methodsFor: 'Running' stamp: 'nk 11/1/2003 07:45'!testStringConversionCrLF	| string newString |	string _ 'This is a test', String crlf, 'of the conversion'.	newString _ string withSqueakLineEndings.	self assert: ((string size - 1) = newString size).! !!TextLineEndingsTest methodsFor: 'Running' stamp: 'nk 11/1/2003 08:43'!testStringConversionJustLF	| string newString |	string _ 'This is a test', String lf, 'of the conversion'.	newString _ string withSqueakLineEndings.	self assert: (string size = newString size).! !!TextLineEndingsTest methodsFor: 'Running' stamp: 'nk 11/1/2003 08:40'!testStringConversionNoLF	| string newString |	string _ 'This is a test', String cr, 'of the conversion'.	newString _ string withSqueakLineEndings.	self assert: (string = newString).! !!TextLineTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!setUp	super setUp.	prototypes		add: (TextLine				start: 1				stop: 50				internalSpaces: 2				paddingWidth: 1) ! !!TextMorphTest methodsFor: 'testing' stamp: 'md 11/13/2003 10:01'!testInitialize	"For now, just make sure initialization doesn't throw exception"	self shouldnt: [TextMorph initialize] raise: Error.! !!TextStyleTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes add: TextStyle default ! !!TrueTest methodsFor: 'testing' stamp: 'md 4/21/2003 16:28'!testAND self assert: (true & true) = true. self assert: (true & false) = false.! !!TrueTest methodsFor: 'testing' stamp: 'md 4/16/2003 14:50'!testInMemory self should: [false isInMemory = true].! !!TrueTest methodsFor: 'testing' stamp: 'md 3/25/2003 23:13'!testNew	self should: [True new] raise: Error. ! !!TrueTest methodsFor: 'testing' stamp: 'md 3/6/2003 14:19'!testNot self should: [false not = true].! !!TrueTest methodsFor: 'testing' stamp: 'md 4/16/2003 14:49'!testPrintOn self assert: (String streamContents: [:stream | true printOn: stream]) = 'true'. ! !!UUIDPrimitivesTest methodsFor: 'testing' stamp: 'JMM 11/22/2001 17:14'!testCreation	| uuid |	uuid _ UUID new.	self should: [uuid size = 16].	self shouldnt: [uuid isNilUUID].	self should: [uuid asString size = 36].! !!UUIDPrimitivesTest methodsFor: 'testing' stamp: 'JMM 11/22/2001 17:27'!testCreationEquality	| uuid1 uuid2 |	uuid1 _ UUID new.	uuid2 _ UUID new.	self should: [uuid1 = uuid1].	self should: [uuid2 = uuid2].	self shouldnt: [uuid1 = uuid2].	self shouldnt: [uuid1 hash = uuid2 hash].! !!UUIDPrimitivesTest methodsFor: 'testing' stamp: 'JMM 11/22/2001 17:17'!testCreationFromString	| uuid string |	string _ UUID nilUUID asString.	uuid _ UUID fromString: string.	self should: [uuid size = 16].	self should: [uuid = UUID nilUUID].	self should: [uuid isNilUUID].	self should: [uuid asString size = 36].	self should: [uuid asArray asSet size = 1].	self should: [(uuid asArray asSet asArray at: 1) = 0].! !!UUIDPrimitivesTest methodsFor: 'testing' stamp: 'JMM 11/22/2001 17:18'!testCreationFromStringNotNil	| uuid string |	string _ UUID new asString.	uuid _ UUID fromString: string.	self should: [uuid size = 16].	self should: [uuid asString size = 36].! !!UUIDPrimitivesTest methodsFor: 'testing' stamp: 'JMM 11/22/2001 17:16'!testCreationNil	| uuid |	uuid _ UUID nilUUID.	self should: [uuid size = 16].	self should: [uuid isNilUUID].	self should: [uuid asString size = 36].	self should: [uuid asArray asSet size = 1].	self should: [(uuid asArray asSet asArray at: 1) = 0].! !!UUIDPrimitivesTest methodsFor: 'testing' stamp: 'JMM 11/22/2001 23:24'!testCreationNodeBased	| uuid |	(UUID new asString last: 12) = (UUID new asString last: 12) ifFalse: [^self].	1000 timesRepeat:		[uuid _ UUID new.		self should: [((uuid at: 7) bitAnd: 16rF0) = 16r10].		self should: [((uuid at: 9) bitAnd: 16rC0) = 16r80]]! !!UUIDPrimitivesTest methodsFor: 'testing' stamp: 'JMM 11/22/2001 23:24'!testCreationRandom	| uuid |	(UUID new asString last: 12) = (UUID new asString last: 12) ifTrue: [^self].	1000 timesRepeat:		[uuid _ UUID new.		self should: [((uuid at: 7) bitAnd: 16rF0) = 16r40].		self should: [((uuid at: 9) bitAnd: 16rC0) = 16r80]]! !!UUIDPrimitivesTest methodsFor: 'testing' stamp: 'JMM 11/22/2001 22:38'!testDuplicationsKinda	|check uuid size |	size _ 5000.	check _ Set new: size.	size timesRepeat: 		[uuid _ UUID new.		self shouldnt: [check includes: uuid].		check add: uuid].		! !!UUIDPrimitivesTest methodsFor: 'testing' stamp: 'JMM 11/22/2001 17:37'!testOrder	| uuid1 uuid2 |	100 timesRepeat:		[uuid1 _ UUID new.		uuid2 _ UUID new.		(uuid1 asString last: 12) = (uuid2 asString last: 12) ifTrue:			[self should: [uuid1 < uuid2].			self should: [uuid2 > uuid1].			self shouldnt: [uuid1 = uuid2]]]! !!UndefinedObjectTest methodsFor: 'testing - copying' stamp: 'md 4/15/2003 21:08'!testClone	self assert: ( nil clone = nil).! !!UndefinedObjectTest methodsFor: 'testing - copying' stamp: 'md 4/15/2003 21:09'!testDeepCopy	self assert: ( nil deepCopy = nil).! !!UndefinedObjectTest methodsFor: 'testing - copying' stamp: 'md 4/15/2003 21:09'!testShallowCopy	self assert: ( nil shallowCopy = nil).! !!UndefinedObjectTest methodsFor: 'testing - copying' stamp: 'md 4/15/2003 21:12'!testVeryDeepCopyWith	self assert: ( (nil veryDeepCopyWith: nil) = nil).! !!UndefinedObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 21:00'!testHaltIfNil	self should: [ nil haltIfNil] raise: Halt.! !!UndefinedObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 22:59'!testIfNil	self should: [ nil ifNil: [self halt]] raise: Halt.! !!UndefinedObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 22:59'!testIfNilIfNotNil	self should: [ nil ifNil: [self halt] ifNotNil: [self error] ] raise: Halt.! !!UndefinedObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 22:58'!testIfNotNil	self shouldnt: [ nil ifNotNil: [self halt]] raise: Halt.! !!UndefinedObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 22:58'!testIfNotNilDo	self shouldnt: [ nil ifNotNilDo: [self halt]] raise: Halt.! !!UndefinedObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 23:00'!testIfNotNilIfNil	self should: [ nil ifNotNil: [self error] ifNil: [self halt] ] raise: Halt.! !!UndefinedObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 21:01'!testIsEmptyOrNil	self assert: (nil isEmptyOrNil).! !!UndefinedObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 21:21'!testIsLiteral	self assert: (nil isLiteral).! !!UndefinedObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 21:21'!testIsNil	self assert: (nil isNil).! !!UndefinedObjectTest methodsFor: 'testing - testing' stamp: 'md 4/15/2003 21:02'!testNotNil	self deny: (nil notNil).! !!UndefinedObjectTest methodsFor: 'testing - Class Methods' stamp: 'md 4/15/2003 21:06'!testInitializedInstance	self should: [ UndefinedObject initializedInstance class == UndefinedObject].! !!UndefinedObjectTest methodsFor: 'testing - Class Methods' stamp: 'md 4/15/2003 21:05'!testNew	self should: [ UndefinedObject new] raise: Error.! !!UndefinedObjectTest methodsFor: 'testing - printing' stamp: 'md 4/15/2003 21:18'!testNewTileMorphRepresentative		self assert: (nil newTileMorphRepresentative class =  UndescribedTile ).! !!UndefinedObjectTest methodsFor: 'testing - printing' stamp: 'md 4/15/2003 21:14'!testPrintOn	| string |	string := String streamContents: [:stream | nil printOn: stream].	self assert: (string = 'nil').! !!UndefinedObjectTest methodsFor: 'testing - printing' stamp: 'md 4/15/2003 21:16'!testStoreOn	| string |	string := String streamContents: [:stream | nil storeOn: stream].	self assert: ((Compiler evaluate: string) = nil).! !!UrlTest methodsFor: 'testing' stamp: 'md 4/21/2003 13:58'!testAbsoluteBrowser	url _ Url absoluteFromText: 'browser:bookmarks#mainPart'.	self assert: url schemeName = 'browser'.	self assert: url locator = 'bookmarks'.	self assert:url fragment = 'mainPart'.	self assert: url class = BrowserUrl.	! !!UrlTest methodsFor: 'testing' stamp: 'md 4/21/2003 13:29'!testAbsoluteFILE		url _ Url absoluteFromText: 'file:/etc/passwd#foo'.	self assert: url schemeName = 'file'.	self assert: url path first = 'etc'.	self assert: url path size = 2.		self assert: url fragment = 'foo'.! !!UrlTest methodsFor: 'testing' stamp: 'md 4/21/2003 13:32'!testAbsoluteFILE2		url _ 'fILE:/foo/bar//zookie/?fakequery/#fragger' asUrl.	self assert: url schemeName = 'file'.	self assert: url class = FileUrl.	self assert: url path first ='foo'.	self assert: url path size = 5.	self assert: url fragment = 'fragger'.! !!UrlTest methodsFor: 'testing' stamp: 'md 4/21/2003 13:05'!testAbsoluteFTP		url _ 'ftP://some.server/some/directory/' asUrl.	self assert: url schemeName = 'ftp'.	self assert: url class = FtpUrl.	self assert: url authority = 'some.server'.		self assert: url path first = 'some'.	self assert: url path size  = 3.	! !!UrlTest methodsFor: 'testing' stamp: 'md 4/21/2003 13:05'!testAbsoluteHTTP		url _ 'hTTp://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part' asUrl.	self assert: url schemeName = 'http'.	self assert: url authority = 'chaos.resnet.gatech.edu'.	self assert: url path first = 'docs'.	self assert: url path size = 3.	self assert: url query = 'A%20query%20'.	self assert: url fragment = 'part'.! !!UrlTest methodsFor: 'testing' stamp: 'md 1/5/2004 14:51'!testAbsolutePortErrorFix		self shouldnt: [Url absoluteFromText: 'http://swikis.ddo.jp:8823/'] raise: Error.	self should: [Url absoluteFromText: 'http://swikis.ddo.jp:-1/'] raise: Error.	self should: [Url absoluteFromText: 'http://swikis.ddo.jp:65536/'] raise: Error.	self should: [Url absoluteFromText: 'http://swikis.ddo.jp:auau/'] raise: Error.! !!UrlTest methodsFor: 'testing' stamp: 'md 4/21/2003 13:08'!testAbsoluteTELNET		url _ 'telNet:chaos.resnet.gatech.edu#goo' asUrl.	self assert: url schemeName = 'telnet'.	self assert: url locator = 'chaos.resnet.gatech.edu'.	self assert: url fragment = 'goo'.	! !!UrlTest methodsFor: 'testing' stamp: 'md 4/21/2003 14:01'!testRelativeFILE		baseUrl _ 'file:/some/dir#fragment1' asUrl.	url _ baseUrl newFromRelativeText: 'file:../another/dir/#fragment2'.	self assert: url toText =  'file:/another/dir/#fragment2'.! !!UrlTest methodsFor: 'testing' stamp: 'md 4/21/2003 13:59'!testRelativeFTP		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.	url _ baseUrl newFromRelativeText: 'ftp://a.b'.	self assert: url toText =  'ftp://a.b/'.! !!UrlTest methodsFor: 'testing' stamp: 'md 4/21/2003 14:00'!testRelativeFTP2		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.	url _ baseUrl newFromRelativeText: 'ftp:xyz'.	self assert: url toText =  'ftp://somewhere/some/dir/xyz'.! !!UrlTest methodsFor: 'testing' stamp: 'md 4/21/2003 14:02'!testRelativeFTP3		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.	url _ baseUrl newFromRelativeText: 'http:xyz'.	self assert: url toText = 'http://xyz/'.! !!UrlTest methodsFor: 'testing' stamp: 'md 4/21/2003 14:01'!testRelativeHTTP		baseUrl _ 'http://some.where/some/dir?query1#fragment1' asUrl.	url _ baseUrl newFromRelativeText: '../another/dir/?query2#fragment2'.	self assert: url toText =  'http://some.where/another/dir/?query2#fragment2'.! !!UrlTest methodsFor: 'testing' stamp: 'md 7/21/2003 10:48'!testUsernamePassword	"basic case with a username+password specified"	url := 'http://user:pword@someserver.blah:8000/root/index.html' asUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = 8000 ].	self should: [ url path first = 'root' ].	self should: [ url username = 'user' ].	self should: [ url password = 'pword' ].	"basic case for a relative url"	baseUrl := 'http://anotherserver.blah:9999/somedir/someotherdir/stuff/' asUrl.	url := 'http://user:pword@someserver.blah:8000/root/index.html' asUrlRelativeTo: baseUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = 8000 ].	self should: [ url path first = 'root' ].	self should: [ url username = 'user' ].	self should: [ url password = 'pword' ].	"a true relative test that should keep the username and password from the base URL"	baseUrl := 'http://user:pword@someserver.blah:8000/root/index.html' asUrl.	url := '/anotherdir/stuff/' asUrlRelativeTo: baseUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = 8000 ].	self should: [ url path first = 'anotherdir' ].	self should: [ url username = 'user' ].	self should: [ url password = 'pword' ].		"just a username specified"	url := 'http://user@someserver.blah:8000/root/index.html' asUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = 8000 ].	self should: [ url path first = 'root' ].	self should: [ url username = 'user' ].	self should: [ url password = nil ].	"the port is not specified"	url := 'http://user:pword@someserver.blah/root/index.html' asUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = nil ].	self should: [ url path first = 'root' ].	self should: [ url username = 'user' ].	self should: [ url password = 'pword' ].	"neither a path nor a port is specified"	url := 'http://user:pword@someserver.blah' asUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = nil ].	self should: [ url username = 'user' ].	self should: [ url password = 'pword' ].	"relative URL where the username+password should be forgotten"	baseUrl := 'http://user:pword@someserver.blah' asUrl.	url := 'http://anotherserver.blah' asUrlRelativeTo: baseUrl.	self should: [ url username = nil ].	self should: [ url password = nil ].! !!UrlTest methodsFor: 'testing' stamp: 'md 7/21/2003 10:48'!testUsernamePasswordPrinting	#(	'http://user:pword@someserver.blah:8000/root/index.html'		'http://user@someserver.blah:8000/root/index.html' 		'http://user:pword@someserver.blah/root/index.html'	) do: [ :urlText |		self should: [ urlText = urlText asUrl toText ] ].! !!WeakMessageSendTest methodsFor: 'testing' stamp: 'nk 4/25/2002 10:12'!testNoArguments	| m |	m _ WeakMessageSend		receiver: true		selector: #yourself.	self should: [ m value  ].! !!WeakMessageSendTest methodsFor: 'testing' stamp: 'nk 4/25/2002 10:10'!testOneArgument	| m |	m _ WeakMessageSend		receiver: Array		selector: #with:		argument: 1.	Smalltalk garbageCollectMost.	self should: [ m value  = { 1 } ].! !!WeakMessageSendTest methodsFor: 'testing' stamp: 'nk 12/8/2002 12:17'!testOneArgumentWithGC	| m |	m _ WeakMessageSend		receiver: Array		selector: #with:		arguments: { Object new }.	Smalltalk garbageCollectMost.	self assert: (m value isNil)! !!WeakMessageSendTest methodsFor: 'testing' stamp: 'nk 12/8/2002 12:17'!testReceiverWithGC	| m |	m _ WeakMessageSend		receiver: Object new		selector: #isNil.	Smalltalk garbageCollectMost.	self assert: (m value isNil).! !!WeakMessageSendTest methodsFor: 'testing' stamp: 'nk 4/25/2002 10:11'!testTwoArguments	| m |	m _ WeakMessageSend		receiver: Array		selector: #with:with:		arguments: { 1 . 2 }.	Smalltalk garbageCollectMost.	self should: [ m value = { 1 . 2 } ].! !!WriteStreamTest methodsFor: 'testing' stamp: 'md 3/25/2003 23:13'!testNew	self should: [WriteStream new] raise: Error. ! !!WriteStreamTest methodsFor: 'testing' stamp: 'md 3/6/2003 13:00'!testSetToEnd	| string stream |	string _ 'hello'.	stream _ WriteStream with: ''.	stream nextPutAll: string.	self assert: stream position = string size.	stream setToEnd.	self assert: stream position = string size.	self assert: stream contents = string! !!YetDummyClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 4/15/2003 21:19'!callingAThirdMethod	"Smalltalk allCallOn: #zoulouSymbol"	self containingaSymbol! !!YetDummyClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 4/15/2003 21:18'!containingaSymbol	^ #zoulouSymbol! !ObjectWithInitialize initialize!DummyToolWorkingWithFileList initialize!