'From Squeak 2.4c of May 10, 1999 on 11 May 1999 at 6:11:38 pm'!Object subclass: #ServerDirectory	instanceVariableNames: 'server directory type user passwordHolder group moniker altURL urlObject socket '	classVariableNames: 'Servers '	poolDictionaries: ''	category: 'System-Network'!!ServerDirectory commentStamp: 'tk 5/11/1999 18:09' prior: 0!Holds all the information needed to read or write on a directory of an internet server.  I am used for FTP and HTTP (and STMP?  NNTP?).  The password policy is: unless it is a public password (like annomyous), clear all passwords before any snapshot.  There is a way to store passwords on the disk.server 		'www.disney.com'  or '123.34.56.08' or the ServerDirectory above me 			(if I am a subdirectory sharing the info in a master directory)directory 	'ftp/pubs/'  name of my directory within the server or superdirectory.			(for file://, directory is converted to local delimiters.)type 		#ftp	what you can do in this directoryuser 		'Jones45'password 	an instance of Password.  group 		an Association ('group name' -> an array of ServerDirectorys)			If this first one is down, try the next one.  Store on all of them.  I am in the list.moniker 	'Main Squeak Directory'  Description of this directory.altURL		When a FTP server holds some web pages, the altURL of those pages is often			different from the FTP directory.  Put the altURL here.  If the directory is 			'public_html/Squeak/', the altURL might be 'www.webPage.com/~kaehler2/			Squeak/'.urlObject	An instance of a subclass of Url.  It is very good at parsing complex urls.			Relative references.  file:// uses this.  Use this in the future instead of 			server and directory inst vars.socket		nil or an FTPSocket.  Only non-nil if the connection is being kept open			for multiple stores or retrievals.  A normal call on some command like (aServer getFileNamed: 'foo') does not set 'socket'.  Socket being nil tells it to close the connection and destroy the socket after this one transcation.  If the caller stores into 'socket', then the same command does NOT close the connection.  	Call 'openKeepFTP' or 'openGroup' to store into socket and keep the connection open.  It is up to the user to call 'quit' or 'closeGroup' later.DD openKeepFTP.Transcript cr; show: ((DD getFileNamed: '1198misc-tkKG.cs') next: 100).Transcript cr; show: ((DD getFileNamed: '1192multFinder-tkKF.cs') next: 100).DD quit.!]style[(677 8 1406)f1,f1LPassword Comment;,f1!!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/11/1999 16:43'!getDirectory	"Return a stream with a listing of the current server directory.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'LIST'.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'getting directory LIST'; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; cr."	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [socket _ nil.  ^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"226 Transfer complete."	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"	dd destroy.	^ resp	"RWStream with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/11/1999 16:43'!getFileList	"Return a stream with a list of files in the current server directory.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'NLST'.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'getting file list NLST'; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; cr."	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [socket _ nil.  ^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"226 Transfer complete."	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"	dd destroy.	^ resp	"RWStream with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/11/1999 16:38'!getFileNamed: fileNameOnServer	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieving file ', fileNameOnServer; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; space;		show: fileNameOnServer; cr."	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [socket _ nil.  ^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"226 Transfer complete."	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"	dd destroy.	^ resp	"a RWBinaryOrTextStream"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/11/1999 16:44'!getFileNamed: fileNameOnServer into: dataStream	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	type == #file ifTrue: [		dataStream nextPutAll: 			(resp _ FileStream oldFileNamed: server,(self serverDelimiter asString), 				self bareDirectory, (self serverDelimiter asString),				fileNameOnServer) contentsOfEntireFile.		^ resp].	type == #http ifTrue: [		resp _ HTTPSocket httpGet: (self fullNameFor: fileNameOnServer) 				accept: 'application/octet-stream'.		resp class == String ifTrue: [^ dataStream].	"error, no data"		dataStream copyFrom: resp.		^ dataStream].	type ifNil: [type _ #ftp].	"type == #ftp"	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieving file ', fileNameOnServer; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; cr."	resp _ dd getDataTo: dataStream whileWatching: so.		"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [socket _ nil.  ^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"226 Transfer complete."	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"	dd destroy.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/11/1999 17:35'!openFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  It has opened passive, and has a dataPort number assigned to a data FTPSocket.  But the data connection is not open.  When you are done, be sure to tell the socket to QUIT, and then destroy it."| so resp portInfo list dataPort dd rr |	(so _ self openNoDataFTP) class == String ifTrue: [^ so].	so sendCommand: 'TYPE L 8'.	(rr _ so lookFor: '200 ') == true ifFalse: [socket _ nil.  ^ rr].	"200 Type set to L"	so sendCommand: 'PASV'.	resp _ (so getResponseUpTo: FTPSocket crLf) first.		"Tells which port on server to use for data"	"Transcript show: resp; cr."	(resp beginsWith: '227 ') ifFalse: [ "Check for Entering Passive Mode"		so sendCommand: 'QUIT'.		so destroy. socket _ nil.		^ self error: 'can''t get into passive mode'].	portInfo _ (resp findTokens: '()') at: 2.	list _ portInfo findTokens: ','.	dataPort _ (list at: 5) asNumber * 256 + (list at: 6) asNumber.	dd _ FTPSocket new.	dd portNum: dataPort.	so dataSocket: dd.	"save it, not opened yet"	^ so! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/11/1999 17:15'!openKeepFTP	"Open for FTP and keep the connection open"	| so |	(so _ self openNoDataFTP) == String ifTrue: [^ so].	^ socket _ so! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/11/1999 17:21'!openNoDataFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  No dataPort is opened.  When you are done, be sure to tell the socket to QUIT, and then destroy it."	| so rr serverIP |	Socket initializeNetwork.	socket ifNotNil: [^ socket].	"already open"	FTPSocket retry: [serverIP _ NetNameResolver addressForName: server timeout: 20.				serverIP ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', server].	so _ FTPSocket new.	so portNum: 21.	so connectTo: serverIP port: 21.  "21 is for the control connection"	so waitForConnectionUntil: FTPSocket standardDeadline.	Transcript cr; show: 'ftp: ', server; cr.	(rr _ so lookFor: '220 ') == true ifFalse: [^ rr].	"220 para1 Microsoft FTP Service"	so sendCommand: 'USER ', user.	(rr _ so lookFor: '331 ') == true ifFalse: [^ rr].	"331 Password required"	so sendCommand: 'PASS ', self password.	(rr _ so lookFor: '230 ') == true ifFalse: [^ rr].	"230 User logged in"	so sendCommand: 'CWD ', directory.	(rr _ so lookFor: '250 ') == true ifFalse: [^ rr].	"250 CWD successful"	"Need to ask for name of directory to make sure?"	"socket _ so".	"If user wants to keep connnection open, he must store socket"	^ so! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/11/1999 16:45'!putFile: fileStream named: fileNameOnServer	"Just FTP a local fileStream to the server.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'STOR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'storing file ', fileNameOnServer; cr.	"Transcript show: 'store via port ', dd portNum printString; cr."	dd sendData: fileStream contentsOfEntireFile.	dd close.	(rr _ so responseOK) == true ifFalse: [		(rr beginsWith: '426 ') ifTrue: [socket _ nil.  ^ rr, ' (Server may be full.)'].			"Connection closed, transfer aborted"		socket _ nil.  ^ rr].	"150 Opening BINARY mode data connection"	(resp _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"226 Transfer complete."	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"	dd destroy.	^ resp	"226 Transfer complete."! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/11/1999 17:49'!quit	"break the connection"	| rr so |	(so _ socket) ifNil: [^ self].	"already done"	socket _ nil.	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 5/11/1999 17:48'!checkServers	"Check that all servers are up and have the latest Updates.list.Warn user when can't write to a server that can still be read."	| final fileSize this serverList theUpdates decided myUpdates abortstrm res |	serverList _ group			ifNil: [Array with: self]			ifNotNil: [group value].	final _ OrderedCollection new.	fileSize _ 0.  theUpdates _ ''.	"list of updates"	abort _ false.	serverList do: [:aServer |		decided _ false.		this _ aServer getFileNamed: 'updates.list'.		(this = #error:) ifTrue: [^'' "Not found"].		(this class == String) &			((aServer altUrl isNil ifTrue: [''] ifFalse: [aServer altUrl]) size > 0) ifTrue: [			"no ftp"			strm _ HTTPSocket httpGet: aServer altUrl, 'updates/updates.list'						accept: 'application/octet-stream'.			strm class == String				ifTrue: [res _ (PopUpMenu						labels: 'Install even though not visible\Cancel entire update' withCRs)						startUpWithCaption: 'Server', aServer moniker,						' is a weird state.\You cannot store, but users can get updates.\If you store on other servers, the file will not be visible.\Strongly advise that you Cancel.' withCRs]				ifFalse: [					res _ (PopUpMenu labels: 'Install on others\Cancel entire update' withCRs)							startUpWithCaption: 'Server ', aServer moniker,							' is unavailable\' withCRs, this].			abort _ res ~= 1.			decided _ true].		decided not & (this size > fileSize) ifTrue: ["new has a longer update.list"			fileSize _ this size.			final do: [:each | abort _ self outOfDate: each].			(final _ OrderedCollection new) add: aServer.			theUpdates _ this contentsOfEntireFile.			decided _ true].		decided not & (this size < fileSize) ifTrue: [			abort _ self outOfDate: aServer.  decided _ true].		decided not ifTrue: [myUpdates _ this contentsOfEntireFile.			myUpdates = theUpdates				ifTrue: [final add: aServer]				ifFalse: [abort _ self outOfDate: this]].		abort ifTrue: [^ Array new].		].	^ final! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 5/11/1999 18:04'!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class readServerUpdatesThrough:saveLocally:updateImage:."	| myServers updateStrm sequence newName myName response local restOfText seq |"	(ScheduledControllers scheduledControllers detect: [:each |		each model == Transcript] ifNone: [nil]) ifNil: [			^ self inform: 'Please open a Transcript window, and then start putting out this update again.']."	local _ fileStrm localName.	fileStrm size = 0 ifTrue: [^ self inform: 'That file has zero bytes!!  May have a new name.'].	(self checkNames: (Array with: local)) ifFalse: [^ nil].	"allowed characters"	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	(myServers _ self checkServers) size = 0 ifTrue: [self closeGroup.  ^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	sequence _ Utilities lastUpdateNum: updateStrm.	seq _ (sequence+1) printString.	seq size = 1 ifTrue: [seq _ '00', seq].	seq size = 2 ifTrue: [seq _ '0', seq].	newName _ seq, local.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr; nextPutAll: restOfText.	myServers do: [:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName retry: true.		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript cr; show: 'Update succeeded on server ', aServer moniker].	self closeGroup.			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.!]style[(19 225 65 2241)f1b,f1,f1LUtilities class readServerUpdatesThrough:saveLocally:updateImage:;,f1! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 5/11/1999 18:06'!putUpdateMulti: list	"Put these files out as an Update on the servers of my group.  List is an array of local file names without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence myName response restOfText seq start add newNames file |	(self checkNames: list) ifFalse: [^ nil].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	(myServers _ self checkServers) size = 0 ifTrue: [self closeGroup.  ^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	start _ sequence _ Utilities lastUpdateNum: updateStrm.	add _ WriteStream on: (String new: 200).	newNames _ list collect: [:each | 		seq _ (sequence _ sequence+1) printString.		seq size = 1 ifTrue: [seq _ '00', seq].		seq size = 2 ifTrue: [seq _ '0', seq].		add nextPutAll: seq; nextPutAll: each; cr.		seq, each].	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: add contents; nextPutAll: restOfText.	myServers do: [:aServer |		list doWithIndex: [:local :ind |			file _ FileStream oldFileNamed: local.			aServer putFile: file named: (newNames at: ind) retry: true.			file close].		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript cr; show: 'Updates succeeded on server ', aServer moniker].	self closeGroup.		Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	file _ FileStream oldFileNamed: (list first).	file close.	list doWithIndex: [:local :ind |		file directory rename: local toBe: (newNames at: ind)].! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/11/1999 16:42'!createDirectory: localName	"Create a new sub directory within the current one"	| so rr |	type == #file ifTrue: [FileDirectory createDirectory: localName].	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'MKD ', localName.	(rr _ so responseOK) == true ifFalse: [socket _ nil.  ^ rr].	""	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/11/1999 16:43'!deleteDirectory: localName	"Delete the sub directory within the current one.  Call needs to ask user to confirm."	| so rr |	type == #file ifTrue: [FileDirectory deleteFileNamed: localName].		"Is this the right command???"	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RMD ', localName.	(rr _ so responseOK) == true ifFalse: [socket _ nil.  ^ rr].	""	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/11/1999 16:43'!deleteFileNamed: fullName	"Detete a remote file.  fullName is directory path, and does include name of the server.  Or it can just be a fileName."	| file so rr |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file type == #file ifTrue: [		^ (FileDirectory forFileName: (file fileNameRelativeTo: self)) 			deleteFileNamed: file fileName].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'DELE ', file fileName.	(rr _ so responseOK) == true ifFalse: [socket _ nil.  ^ rr].	""	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/11/1999 17:10'!rename: fullName toBe: newName	"Rename a remote file.  fullName is just be a fileName, or can be directory path that includes name of the server.  newName is just a fileName"	| file so rr |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, the rest is here"			"Mac files that include / in their name, must encode it as %2F "	file type == #file ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			rename: file fileName toBe: newName].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RNFR ', file fileName.	(rr _ so responseOK) == true ifFalse: [socket _ nil.  ^ rr].	""	so sendCommand: 'RNTO ', newName.	(rr _ so responseOK) == true ifFalse: [socket _ nil.  ^ rr].	""	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"! !!ServerDirectory methodsFor: 'server groups' stamp: 'tk 5/11/1999 17:54'!closeGroup	"Close connection with all servers in the group."	(group		ifNil: [Array with: self]		ifNotNil: [group value]) do: [:aDir | aDir quit].! !!ServerDirectory methodsFor: 'server groups' stamp: 'tk 5/11/1999 17:53'!openGroup	"Open all servers in the group.  Don't forget to close later."	(group		ifNil: [Array with: self]		ifNotNil: [group value]) do: [:aDir | aDir openKeepFTP].! !