'From Squeak 2.3 of January 14, 1999 on 27 February 1999 at 2:32:43 pm'!!DocLibrary commentStamp: 'tk 2/18/1999 20:45' prior: 0!Method and Class shared documentation.  Pane in browser.  url for each official version of each method. Each update server group have a prefix (i=internal, e=external).  Point.x;.738.sp  Pane holds a pasteupmorph with comments and examples.  	Must be very careful to give the right options for when to look for docs.  Could be annoying.  Look on disk.  If there, bring it in in background.  If not there, and network has been active this session, or within 15 mins, get from server (in background) and cache on disk.  	When get updates, check for latest version of all comments in the cache.  	Need quick registration of version of inst vars (less bulky and quick to check.)  If all inst var lists are the same as a certain release, mark it as that.  Each release (or update?) have an automatic known registration.	Get doc, Get all docs for this class. //  Net: When you ask, If net has been used, Always (always gets in background) // From disk:  When you ask, always (laptop users do the former).  	Security: Squeakers can write anything, including players.  Users can only add Morphic objects, not players.  (No new code)	Mech:  Users write file to a server with open drop box.  Our server in Alan's office (the librarian) grabs the files once every two minutes, and scans them.  Code must be same as before.  Saves a copy.  Writes on official directory on two outside servers.	Any combo of objects of existing classes that can crash the system, or deny service?  Should the librarian try all buttons first?  If it crashes, won't post it.	Need another machine to check if the librarian is up, and beep Ted.  Could check a time stamp on the main server.  Users could also tell if librarian is up.  Number of docs in the queue.	If we had mime really down, could have squeak email the page to the librarian.  What if the user does not know his pop server?  Use a standard one?  How keep spam out?-----[ ] set up folders, get reader going (no good interface yet)group		Name of group of servers (internal/external)lastUpdate	Number of last update we have.lastUpdateName		File name without number for checking against ChangeSets.methodVersions	Dictionary (class.method -> #(45 secs 120 secs 198 secs)) updates 	that this method  appeared in.  From my version, check backwards till find a doc file on server.  secs is (Time totalSeconds) of file on the server (by its directory) of last version I have.  so can tell if have most recent one.  (use one day slop for older ones)	point.x;.205.sp	rectangle.205.spNames of this form that are too long are run through a dictionary and given a serial number.  It is (first two letters of class name), (crc16 of first half), (crc16 of second half).205.sp.  	Can't store over a file in the drop box, so append random number to end of name.  Look at times to figure out which one is most recent when empty drop box.			localCachePath 	name of cache directory on local disk.  (Is shared between Squeaks on this machine, so might have things too new.)  In the form of a url 'file://disk/folder/'Algorithm for finding the doc file:  	Find my version	Find version of current def of method relative to me.	make file name.	look locally	check server, might have changed.When put new update, no extra work needed.When put a new version of the system, include External with methodVersions filled in.  If methods changed and not in a numbered update, must run a method to put them in the database.When get updates, add new entries as we read updates.Default method update number is 0.AA _ DocLibrary new initialize.AA scanFolder: 'file://Ted''s/Updates 328-/' from: 595.DocLibrary classPool at: #External put: AA.DocLibrary new setUp.[How use internal updates, but do documentation for external?  Disable feature of adding to table when get updates.  Point to UIUC external directory and scan the latest ext updates.]	When a docPane comes in, store property: #classAndMethod.  To put out, menu item "Broadcast Documentation" in PasteUpMorph that has the property.  DocLibrary puts out this morph.  Writes to drop box and local cache.	In codePane, on more menu, "Fetch Documentation" (if none, ask if want blank one).  Creates a new pasteUpMorph after verifying that it doesn't have one.	Later need preference and do fetch always and in the background.	Crude review process -- a method here that brings up each pane that is in drop box (10 at a time).  First just shows code and text, not bring in.  Then bring in.  And a way for me to store it in the official directory.  (Do as menu items in file list?)  And archives and deletes for drop box.  (I do manually twice a day?)	When write a file, take lastUpdateName and look for it in ChangeSet names.  When find, see if this method occurs in any newer changeSet.  If so, writing to an older version.  "The documentation will be attached to the version of this method in xxx.cs.  You have a newer version of that method in yyy.cs.  If what you are storing applies only to the newer version, please do not broadcast it!!  Wait until the new version is in an external update." Broadcast to all Squeak users \ Cancel.  (Otherwise "Make this documentation available to all Squeak users?")When fetch any updates, look for "latest.ix"  Has format:External   407   'aChangeSet.cs'376.ix'class method:' updateNumber'class method' updateNumber'class' updateNumber	Keep local copy of updates.list and read it for files not mentioned yet in latest.ix.¥Warn the user if the method he is documenting is too new to be on the External updates server.¥Correcting the database of method versions when new External Updates are released.¥Create the file to put on the server with the database info for a new update.¥Methods to help the reviewer (me) scan files.  It will show me all the code, all the doits in text, and all the text.¥Allow documentation for classes, as opposed to methods. (written in file, in dict, just need interface)self scanUpdatesIn: (ServerDirectory serverNamed: 'UpdatesExtUIUC') realUrl, '/'.self updateMethodVersions.[ ] When write, write to cache also.[ ] If can't write to server, tell user to store again later.[ ] Sparse database to tell if method has a docPane -- user fetches it explicitly.[ ] Write to both servers.  Retrieve from either.  Drop box on just UIUC.!!DocLibrary methodsFor: 'doc pane' stamp: 'tk 2/16/1999 14:13'!docObjectAt: classAndMethod	"Return a morphic object that is the documentation pane for this method.  nil if none can be found.  Look on both the network and the disk."	| fileNames server aUrl strm local obj |	methodVersions size = 0 ifTrue: [self updateMethodVersions].	"first time"	fileNames _ self docNamesAt: classAndMethod.	self assureCacheFolder.	self haveNetwork ifTrue: [		"server _ (ServerDirectory groupNamed: group) clone."  "Note: directory ends with '/updates' which needs to be '/docpane', but altUrl end one level up"		server _ ServerDirectory groupNamed: group.			"later try multiple servers"		aUrl _ server altUrl, 'docpane/'.		fileNames do: [:aVersion | 			strm _ HTTPSocket httpGetNoError: aUrl,aVersion 				args: nil accept: 'application/octet-stream'.			strm class == RWBinaryOrTextStream ifTrue: [				self cache: strm as: aVersion.				strm reset.				obj _ strm fileInObjectAndCode asMorph.				(obj valueOfProperty: #classAndMethod) = classAndMethod ifFalse: [					self inform: 'suspicious object'.					obj setProperty: #classAndMethod toValue: classAndMethod].				^ obj].	"The pasteUpMorph itself"			"If file not there, error 404, just keep going"]].	local _ ServerDirectory new fullPath: DocsCachePath.	"check that it is really there -- let user respecify"	fileNames do: [:aVersion | 		(local includesKey: aVersion) ifTrue: [			strm _ local oldFileNamed: aVersion.			obj _ strm fileInObjectAndCode asMorph.			(obj valueOfProperty: #classAndMethod) = classAndMethod ifFalse: [				self inform: 'suspicious object'.				obj setProperty: #classAndMethod toValue: classAndMethod].			Transcript cr; show: 'local cache: ', aVersion.			^ obj].	"The pasteUpMorph itself"		"If file not there, just keep looking"].	"Never been documented"	^ nil! !!DocLibrary methodsFor: 'doc pane' stamp: 'tk 2/17/1999 13:42'!fetchDocSel: aSelector class: className	"Look on servers to see if there is documentation pane for the selected message. Take into account the current update number.  If not, ask the user if she wants to create a blank one."	| key response docPane ext |	key _ className, ' ', aSelector.	(self openDocAt: key) ifNil: [		response _ (PopUpMenu labels: 'Create new page\Cancel' withCRs)				startUpWithCaption: 'No documentation exists for this method.\Would you like to write some?' withCRs.		response = 1 ifTrue: [			docPane _ PasteUpMorph new.			docPane color: Color white; borderWidth: 2; borderColor: Color green.			docPane setProperty: #classAndMethod toValue: key.			docPane setProperty: #initialExtent toValue: (ext _ 200@200).			docPane topLeft: (RealEstateAgent initialFrameFor: docPane) origin.			docPane extent: ext.			docPane addMorph: (TextMorph new topLeft: docPane topLeft + (10@10);					extent: docPane width - 15 @ 30).			Smalltalk currentWorld addMorph: docPane]].	"If found, openDocAt: put it on the screen"! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 2/27/1999 13:44'!saveOnURL	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| um pg |	pg _ self saveOnURLbasic.	um _ URLMorph newForURL: pg url.	um setURL: pg url page: pg.	pg isContentsInMemory ifTrue: [pg computeThumbnail].	um isBookmark: true.	um removeAllMorphs.	um color: Color transparent.	self primaryHand attachMorph: um.! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/26/1999 22:39'!forgetURLs	"About to save these objects in a new place.  Forget where stored now.  Must bring in all pages we don't have."| pg |pages do: [:aPage |	aPage yourself.	"bring it into memory"	(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [		SqueakPageCache removeURL: pg url.		pg contentsMorph setProperty: #SqueakPage toValue: nil]].self setProperty: #url toValue: nil.! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/27/1999 14:24'!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| stem list firstTime |firstTime _ (self valueOfProperty: #url) == nil.stem _ self getStemUrl.	"user must approve"stem size = 0 ifTrue: [^ self].firstTime ifTrue: [self setProperty: #futureUrl toValue: stem, '.bo'].self reserveUrlsIfNeeded.pages doWithIndex: [:aPage :ind | 	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage presenter ifNotNil: [aPage presenter flushPlayerListCache].		aPage saveOnURL: stem,(ind printString),'.sp'.		]].list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	URLMorph grabForBook: self.	self setProperty: #futureUrl toValue: nil].	"clean up"! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/26/1999 19:01'!saveIndexOfOnly: aPage	"Modify the index of this book on a server.  Read the index, modify the entry for just this page, and write back.  See saveIndexOnURL. (page file names must be unique even if they live in different directories.)"	| mine sf remoteFile strm remote pageURL num pre index after dict allText allTextUrls fName |	mine _ self valueOfProperty: #url.	mine ifNil: [^ self saveIndexOnURL].	Cursor wait showWhile: [strm _ (ServerFile new fullPath: mine) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	remote _ strm fileInObjectAndCode.	dict _ remote at: 1.	allText _ dict at: #allText ifAbsent: [nil].	"remote, not local"	allTextUrls _ dict at: #allTextUrls ifAbsent: [nil].	allText size + 1 ~= remote size ifTrue: [self error: '.bo size mismatch.  Please tell Ted what you just did to this book.'].	(pageURL _ aPage url) ifNil: [self error: 'just had one!!'].	fName _ pageURL copyAfterLast: $/.	2 to: remote size do: [:ii | 		((remote at: ii) url findString: fName startingAt: 1 						caseSensitive: false) > 0 ifTrue: [index _ ii].	"fast"		(remote at: ii) xxxReset].	index ifNil: ["new page, what existing page does it follow?"		num _ self pageNumberOf: aPage.		1 to: num-1 do: [:ii | (pages at: ii) url ifNotNil: [pre _ (pages at: ii) url]].		pre ifNil: [after _ remote size+1]			ifNotNil: ["look for it on disk, put me after"				pre _ pre copyAfterLast: $/.				2 to: remote size do: [:ii | 					((remote at: ii) url findString: pre startingAt: 1 								caseSensitive: false) > 0 ifTrue: [after _ ii+1]].				after ifNil: [after _ remote size+1]].		remote _ remote copyReplaceFrom: after to: after-1 with: #(1).		allText ifNotNil: [			dict at: #allText put: (allText copyReplaceFrom: after-1 to: after-2 with: #(())).			dict at: #allTextUrls put: (allTextUrls copyReplaceFrom: after-1 to: after-2 with: #(()))].		index _ after].	remote at: index put: (aPage sqkPage copyForSaving).	(dict at: #modTime ifAbsent: [0]) < Time totalSeconds ifTrue:		[dict at: #modTime put: Time totalSeconds].	allText ifNotNil: [		(dict at: #allText) at: index-1 put: (aPage allStringsAfter: nil).		(dict at: #allTextUrls) at: index-1 put: pageURL].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: remote.		"remoteFile close"].! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/27/1999 14:23'!savePagesOnURL	"Write out all pages in this book onto a server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are not in memory will stay that way.  The local disk could be the server."	| response list firstTime newPlace rand dir bookUrl |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.		^ self].	self getAllText.	"stored with index later"	response _ (PopUpMenu labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)\Save new book sharing old pages' withCRs)			startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' withCRs.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 5 ifTrue: [		"Make up new url for .bo file and confirm with user."  "Mark as shared"		[rand _ String new: 4.		1 to: rand size do: [:ii |			rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].		(newPlace _ self getStemUrl) size = 0 ifTrue: [^ self].		newPlace _ (newPlace copyUpToLast: $/), '/BK', rand, '.bo'.		dir _ ServerFile new fullPath: newPlace.		(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"		self setProperty: #url toValue: newPlace.		self saveAsNumberedURLs. 		bookUrl _ self valueOfProperty: #url.		(SqueakPage stemUrl: bookUrl) = 			(SqueakPage stemUrl: currentPage url) ifTrue: [				bookUrl _ true].		"not a shared book"		(URLMorph grabURL: currentPage url) book: bookUrl.		^ self].	response = 0 ifTrue: [^ self]."self reserveUrlsIfNeeded.	Need two passes here -- name on one, write on second"pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage presenter ifNotNil: [aPage presenter flushPlayerListCache].		aPage saveOnURLbasic.		]].	"ask user if no url"list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).firstTime _ (self valueOfProperty: #url) == nil.self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	URLMorph grabForBook: self.	self setProperty: #futureUrl toValue: nil].	"clean up"! !!SequenceableCollection methodsFor: 'copying' stamp: 'tk 2/26/1999 18:58'!copyAfterLast: anElement 	"Answer a copy of the receiver from index 1 to the last occurrence of anElement, not including anElement."	self size to: 1 by: -1 do: [:index | 		(self at: index) = anElement ifTrue: [			^ self copyFrom: index+1 to: self size]].	^ self class new: 0	"not found"! !!SequenceableCollection methodsFor: 'copying' stamp: 'tk 2/26/1999 18:58'!copyUpToLast: anElement 	"Answer a copy of the receiver from index 1 to the last occurrence of anElement, not including anElement."	self size to: 1 by: -1 do: [:index | 		(self at: index) = anElement ifTrue: [			^ self copyFrom: 1 to: index-1]].	^ self copy    "not found"! !!URLMorph class methodsFor: 'instance creation' stamp: 'tk 2/27/1999 14:18'!grabForBook: bookMorph	"Create a URLMorph for this book.  Put it into the hand."	| um bookUrl pageUrl pg |	bookUrl _ bookMorph valueOfProperty: #url.	pageUrl _ bookMorph currentPage url.	"should have one!!"	pg _ SqueakPageCache atURL: pageUrl.	(SqueakPage stemUrl: bookUrl) = (SqueakPage stemUrl: pageUrl) 		ifTrue: [bookUrl _ true].		"not a shared book"	um _ URLMorph newForURL: pageUrl.	um setURL: pageUrl page: pg.	pg isContentsInMemory ifTrue: [pg computeThumbnail].	um isBookmark: true.	um book: bookUrl.	um removeAllMorphs.	um color: Color transparent.	Smalltalk currentHand attachMorph: um.	^ um! !