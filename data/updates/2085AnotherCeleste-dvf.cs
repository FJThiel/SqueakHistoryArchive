'From Squeak2.8alpha of 4 February 2000 [latest update: #2052] on 3 May 2000 at 11:16:52 pm'!"Change Set:		034AnotherCeleste-dvfDate:			1 May 2000Author:			Daniel Vainsencher and Lex SpoonAllows sending and receiving attachments in Celeste."!Model subclass: #Celeste	instanceVariableNames: 'mailDB currentCategory currentMessages currentTOC currentMsgID lastCategory subjectFilter fromFilter dateFilter customFilterBlock formatMessages lastCategoryList lastCategoryMenu messageTextView userPassword status '	classVariableNames: 'CCList CustomFilters DeleteInboxAfterFetching FormatWhenFetching PopServer PopUserName SmtpServer SuppressWorthlessHeaderFields UserName '	poolDictionaries: ''	category: 'Network-Mail Reader'!Model subclass: #CelesteComposition	instanceVariableNames: 'celeste messageText textEditor attachmentSeparator morphicWindow mvcWindow '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Mail Reader'!Object subclass: #MIMEHeaderValue	instanceVariableNames: 'mainValue parameters '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Mail Reader'!Object subclass: #MailMessage	instanceVariableNames: 'time from to cc subject text body separator fields parts '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Mail Reader'!TextAttribute subclass: #TextMessageLink	instanceVariableNames: 'message '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Mail Reader'!!TextMessageLink commentStamp: '<historical>' prior: 0!A link to a hidden mail message.  Clicking on it allows the message to be viewed or saved to disk.!!Celeste methodsFor: 'categories pane' stamp: 'dvf 4/27/2000 21:04'!messages: actuallyShown from: possible 	status _ 'Showing ' , actuallyShown printString , ' of ' , possible printString , ' messages in ', self category.	self changed: status! !!Celeste methodsFor: 'table of contents pane' stamp: 'dvf 4/27/2000 00:14'!saveMessage	"save the currently selected message to a file"	| fileName file |	currentMsgID ifNil: [^ self].	fileName _ FillInTheBlank request: 'file to save in'.	fileName isEmpty ifTrue: [^ self].	file _ FileStream fileNamed: fileName.	file nextPutAll: (self currentMessage) text.	file close! !!Celeste methodsFor: 'message text pane' stamp: 'ls 4/30/2000 18:33'!messageText	"Answer the text which makes up the complete message (header+body)"	(currentMsgID isNil) ifTrue: [^''].	"Always show the full message header for messages in the category .tosend. so that all special header lines are preserved, shown and can be edited."	(currentCategory = '.tosend.')		ifTrue: [^ mailDB getText: currentMsgID].	SuppressWorthlessHeaderFields		ifTrue: [^ self currentMessage formattedText]		ifFalse: [^ mailDB getText: currentMsgID].! !!Celeste methodsFor: 'other' stamp: 'dvf 4/27/2000 00:12'!currentMessage	^mailDB getMessage: currentMsgID! !!Celeste methodsFor: 'sending mail' stamp: 'ls 4/30/2000 23:12'!forwardTextFor: msgID	"Answer the template for forwarding the message with the given ID."	| msg separator |	msg := self currentMessage.	^String streamContents: [ :str |		"From header"		str nextPutAll: 'From: ';		nextPutAll: Celeste userName; cr.		"Put a blank To"		str nextPutAll: 'To: '; cr.		"Add a subject modified from the original"		str nextPutAll: 'Subject: (fwd) '.		str nextPutAll: msg subject.		str cr.		"Add auto-cc if it's been set"		Celeste ccList isEmpty ifFalse: [			str nextPutAll: 'Cc: '.			str nextPutAll: Celeste ccList; cr].		"add the mime headers to make it multi-part"		separator := MailMessage generateSeparator.		str nextPutAll: 'MIME-Version: 1.0'; cr.		str nextPutAll: 'Content-type: multipart/mixed; separator='.		str nextPutAll: separator.		str cr.		"skip down to the main part of the message"		str cr.		str nextPutAll: '--'; nextPutAll: separator; cr.		str nextPutAll: 'Content-type: text/plain'; cr; cr.		"insert the forwarded message"		str cr; cr; nextPutAll: '====forwarded===='; cr; cr.		str nextPutAll: '--'; nextPutAll: separator; cr.		str nextPutAll: 'Content-type: message/rfc822'; cr; cr.		str nextPutAll: msg text; cr.		"final separator"		str nextPutAll: '--'; nextPutAll: separator; nextPutAll: '--'; cr.	].! !!CelesteComposition methodsFor: 'private' stamp: 'dvf 4/28/2000 02:19'!hasAttachments	^ attachmentSeparator notNil! !!CelesteComposition methodsFor: 'interface' stamp: 'dvf 4/28/2000 03:21'!addAttachment	| file fileResult fileName strm |	textEditor		ifNotNil: [self hasUnacceptedEdits ifTrue: [textEditor accept]].	"transform into multipart if needed"	self hasAttachments ifFalse: [self transformToMultipart].	"then simply append another attachment section"	(fileResult _ StandardFileMenu oldFile)		ifNotNil: 			[fileName _ fileResult directory fullNameFor: fileResult name.			file _ FileStream oldFileNamed: fileName.			file				ifNotNil: 					[strm _ WriteStream on: (String new: 100).					strm nextPutAll: 'Content-Type: application/octet-stream; name="' , fileResult name , '"';					 cr;					 nextPutAll: 'Content-Disposition: attachment; filename="' , fileResult name , '"';					 cr;					 nextPutAll: 'Content-Transfer-Encoding: base64';					 cr;					 cr.					Base64MimeConverter new dataStream: file;					 mimeStream: strm;					 mimeEncode.					strm cr; nextPutAll: '--' , attachmentSeparator; cr. self messageText: (self messageText, strm contents)]]! !!CelesteComposition methodsFor: 'interface' stamp: 'dvf 4/28/2000 02:06'!openInMorphic	"open an interface for sending a mail message with the given initial 	text "	| textMorph buttonsList sendButton attachmentButton |	morphicWindow _ SystemWindow labelled: 'Mister Postman'.	morphicWindow model: self.	textEditor _ textMorph _ PluggableTextMorph						on: self						text: #messageText						accept: #messageText:.	morphicWindow addMorph: textMorph frame: (0 @ 0.1 corner: 1 @ 1).	buttonsList _ AlignmentMorph newRow.	sendButton _ PluggableButtonMorph				on: self				getState: nil				action: #submit.	sendButton label: 'send message'.	sendButton setBalloonText: 'add this to the queue of messages to be sent'.	sendButton onColor: Color white offColor: Color white.	buttonsList addMorphBack: sendButton.		attachmentButton _ PluggableButtonMorph				on: self				getState: nil				action: #addAttachment.	attachmentButton label: 'add attachment'.	attachmentButton setBalloonText: 'Send a file with the message'.	attachmentButton onColor: Color white offColor: Color white.	buttonsList addMorphBack: attachmentButton.		morphicWindow addMorph: buttonsList frame: (0 @ 0 extent: 1 @ 0.1).	morphicWindow openInMVC! !!CelesteComposition methodsFor: 'interface' stamp: 'ls 4/30/2000 22:58'!transformToMultipart	| oldPart newText strm |	oldPart _ MailMessage from: self messageText asString.	attachmentSeparator _ MailMessage generateSeparator.	newText _ String new: 200.	strm _ WriteStream on: newText.	strm nextPutAll: 'Mime-Version: 1.0';	 cr;	 nextPutAll: 'Content-Type: multipart/mixed; boundary="';	 nextPutAll: attachmentSeparator;	 nextPut: $";	 cr;	 nextPutAll: oldPart fieldsAsMimeHeader;	 cr;cr;	 nextPutAll: '--' , attachmentSeparator;	 cr;	 nextPutAll: 'Content-Type: text/plain; charset="us-ascii"';	 cr;	 cr;	 nextPutAll: oldPart content;	 cr;	 nextPutAll: '--' , attachmentSeparator;	 cr.	self messageText: strm contents! !!MIMEDocument methodsFor: 'testing' stamp: 'ls 4/30/2000 18:07'!isMultipart	^self mainType = 'multipart'! !!MIMEDocument methodsFor: 'as yet unclassified' stamp: 'ls 4/30/2000 18:45'!isMultipartAlternative	"whether the document is in a multipart format where the parts are alternates"	^ self contentType = 'multipart/alternative'! !!MIMEHeaderValue methodsFor: 'accessing' stamp: 'dvf 4/27/2000 18:55'!mainValue	^mainValue! !!MIMEHeaderValue methodsFor: 'accessing' stamp: 'dvf 4/27/2000 18:13'!mainValue: anObject	mainValue _ anObject! !!MIMEHeaderValue methodsFor: 'accessing' stamp: 'dvf 4/27/2000 18:18'!parameters	^parameters! !!MIMEHeaderValue methodsFor: 'accessing' stamp: 'dvf 4/27/2000 18:11'!parameters: anObject	parameters _ anObject! !!MIMEHeaderValue methodsFor: 'printing' stamp: 'dvf 4/28/2000 02:48'!asHeaderValue	| strm |	strm _ WriteStream on: (String new: 20).	strm nextPutAll: mainValue.	parameters associationsDo: [:e | strm nextPut: $; ; nextPutAll: e key;		 nextPutAll: '="';		 nextPutAll: e value , '"'].	^ strm contents! !!MIMEHeaderValue class methodsFor: 'as yet unclassified' stamp: 'dvf 5/2/2000 00:53'!fromString: aString 	| parts newValue parms temp |	parts _ ReadStream on: (aString findTokens: ';').	newValue _ self new mainValue: parts next asLowercase.	parms _ Dictionary new.	parts do: 		[:e | 		temp _ e withBlanksTrimmed findTokens: '="'.		parms at: temp first put: temp second].	newValue parameters: parms.	^ newValue! !!MailMessage methodsFor: 'initialize-release' stamp: 'ls 4/30/2000 22:47'!from: aString 	"Parse aString to initialize myself."	| parseStream isMime contentType bodyText contentTransferEncoding |	time _ 0.	from _ to _ cc _ subject _ '' copy.	text _ aString withoutTrailingBlanks.	parseStream _ ReadStream on: text.	isMime _ false.	"mdr: this does not appear to be used"	contentType _ 'text/plain'.	contentTransferEncoding _ nil.	fields := Dictionary new.	self fieldsFrom: parseStream do: 		[:fName :fValue | 		fName = 'date' ifTrue: [time _ (self timeFrom: fValue) ifNil: [ 0 ]].		fName = 'from' ifTrue: [from _ fValue].		fName = 'to'			ifTrue: [to isEmpty					ifTrue: [to _ fValue]					ifFalse: [to _ to , ', ' , fValue]].		fName = 'cc'			ifTrue: [cc isEmpty					ifTrue: [cc _ fValue]					ifFalse: [cc _ cc , ', ' , fValue]].		fName = 'subject' ifTrue: [subject _ fValue].		fName = 'mime-version' ifTrue: [isMime _ true].		fName = 'content-type' ifTrue: [contentType _ (fValue copyUpTo: $;) asLowercase].		fName = 'content-transfer-encoding' ifTrue: [contentTransferEncoding _ fValue asLowercase].		fields at: fName put: (MIMEHeaderValue fromString: fValue)].	bodyText _ parseStream upToEnd.	contentTransferEncoding = 'base64'		ifTrue: 			[bodyText _ Base64MimeConverter mimeDecodeToChars: (ReadStream on: bodyText).			bodyText _ bodyText contents].	contentTransferEncoding = 'quoted-printable' ifTrue: [bodyText _ bodyText decodeQuotedPrintable].	body _ MIMEDocument contentType: contentType content: bodyText! !!MailMessage methodsFor: 'access' stamp: 'ls 4/30/2000 18:15'!fields	^ fields! !!MailMessage methodsFor: 'access' stamp: 'ls 4/30/2000 18:21'!name	"return a default name for this part, if any was specified.  If not, return nil"	| type nameField disposition |	"try in the content-type: header"	type _ self fields at: 'content-type' ifAbsent: [nil].	(type notNil and: [(nameField _ type parameters at: 'name' ifAbsent: [nil]) notNil])		ifTrue: [^ nameField].	"try in content-disposition:"	disposition _ self fields at: 'content-disposition' ifAbsent: [nil].	(disposition notNil and: [(nameField _ disposition parameters at: 'filename' ifAbsent: [nil]) notNil])		ifTrue: [^ nameField].	"give up"	^ nil! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 4/30/2000 23:37'!bodyTextFormatted	"Answer a version of the text in my body suitable for display.  This will parse multipart forms, decode HTML, and other such things"	"check for multipart"	self body isMultipart ifTrue: [		"check for alternative forms"		self body isMultipartAlternative ifTrue: [			"it's multipart/alternative.  search for a part that we can display, biasing towards nicer formats"			#('text/html' 'text/plain') do: [ :format |				self parts do: [ :part |					part body contentType = format ifTrue: [ ^part bodyTextFormatted ] ] ].			"couldn't find a desirable part to display; just display the first part"			^self parts first bodyTextFormatted ].		"not alternative parts.  put something for each part"		^Text streamContents: [ :str |			self parts do: [ :part |				((#('text' 'multipart') includes: part body mainType) or: 					[ part body contentType = 'message/rfc822'])				ifTrue: [					"try to inline the message part"					str nextPutAll: part bodyTextFormatted. ]				ifFalse: [ 					|descript |					str cr.					descript := part name ifNil: [ 'attachment' ].					str nextPutAll: (Text string: '[', descript, ']'  attribute: (TextMessageLink message: part)). ] ] ]. ].	"check for HTML"	self body contentType = 'text/html'		ifTrue: [^(HtmlParser parse: (ReadStream on: body content)) formattedText].	"check for an embedded message"	self body contentType = 'message/rfc822' ifTrue: [		^(MailMessage from: self body content) formattedText ].	"nothing special--just return the text"	^body content.! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 4/30/2000 18:19'!fieldsAsMimeHeader	"return the entire header in proper MIME format"	| strm |	strm _ WriteStream on: (String new: 100).	self fields associationsDo: [:e | strm nextPutAll: e key;		 nextPutAll: ': ';		 nextPutAll: e value asHeaderValue;		 cr]. 	^ strm contents! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 4/30/2000 18:52'!formattedText	"Answer a version of my text suitable for display.  This cleans up the header, decodes HTML, and things like that"		^ self cleanedHeader asText, String cr , self bodyTextFormatted! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 4/30/2000 20:32'!viewBody	"open a viewer on the body of this message"	(StringHolder new contents: self bodyTextFormatted; yourself) 		openLabel: (self name ifNil: ['(a message part)']) ! !!MailMessage methodsFor: 'multipart' stamp: 'ls 4/30/2000 18:47'!content	"returns the text, still encoded"	^self bodyText! !!MailMessage methodsFor: 'multipart' stamp: 'ls 4/30/2000 18:13'!decoderClass	| encoding |	encoding _ self fields at: 'content-transfer-encoding' ifAbsent: [^ nil].	encoding _ encoding mainValue.	encoding asLowercase = 'base64' ifTrue: [^ Base64MimeConverter].	encoding asLowercase = 'quoted-printable' ifTrue: [^ QuotedPrintableMimeConverter].	^ nil! !!MailMessage methodsFor: 'multipart' stamp: 'ls 4/30/2000 18:14'!excerpt	"give a very brief excerpt from the text"	^ self content withSeparatorsCompacted truncateWithElipsisTo: 30! !!MailMessage methodsFor: 'multipart' stamp: 'ls 4/30/2000 22:37'!parseParts	"private -- parse the parts of the message and put them in the parts ivar.  If this is not a multipart message, put #() into the ivar"	| parseStream currLine msgStream messages |	self body isMultipart ifFalse: [^ parts _ #()].	parseStream _ ReadStream on: self content.	currLine _ ''.	['--*' match: currLine]		whileFalse: [currLine _ parseStream nextLine].	separator _ currLine copy.	msgStream _ LimitingLineStreamWrapper on: parseStream delimiter: separator.	messages _ OrderedCollection new.	[parseStream atEnd]		whileFalse: 			[messages add: msgStream upToEnd.			msgStream skipThisLine].	parts _ messages collect: [:e | MailMessage from: e]! !!MailMessage methodsFor: 'multipart' stamp: 'ls 4/30/2000 18:22'!parts	parts ifNil: [self parseParts].	^ parts! !!MailMessage methodsFor: 'multipart' stamp: 'ls 4/30/2000 20:31'!save	"save the part to a file"	| fileName file |	fileName _ self name ifNil: ['attachment' , Utilities dateTimeSuffix].	fileName _ FillInTheBlank request: 'File name for save?' initialAnswer: fileName.	fileName isEmpty ifTrue: [ ^nil ].	file _ FileStream newFileNamed: fileName.	file nextPutAll: self content.! !!MailMessage class methodsFor: 'utilities' stamp: 'ls 4/30/2000 22:58'!generateSeparator	"generate a separator usable for making MIME multipart documents.  A leading -- will *not* be included"	^'==CelesteAttachment' , (10000 to: 99999) atRandom asString , '=='.! !!SequenceableCollection methodsFor: 'copying' stamp: 'ls 4/30/2000 18:59'!copyWithoutFirst	"return a copy of the receiver which doesn't include the first element"	^self copyFrom: 2 to: self size! !!TextMessageLink methodsFor: 'initialization' stamp: 'ls 4/30/2000 18:54'!initialize: message0	message := message0! !!TextMessageLink methodsFor: 'acting' stamp: 'ls 4/30/2000 20:35'!actOnClickFor: evt	| choice |	choice := (PopUpMenu labels: 'view this attachment\save this attachment' withCRs) startUp.	choice = 1 ifTrue: [		"open a new viewer"		message viewBody].	choice = 2 ifTrue: [		"save the mesasge"		message save ].	^true! !!TextMessageLink methodsFor: 'acting' stamp: 'ls 4/30/2000 19:03'!mayActOnClick	^true! !!TextMessageLink methodsFor: 'appearance' stamp: 'ls 4/30/2000 20:34'!emphasizeScanner: scanner	scanner textColor: Color brown! !!TextMessageLink class methodsFor: 'instance creation' stamp: 'ls 4/30/2000 19:00'!message: aMessage	^super new initialize: aMessage! !Object subclass: #MailMessage	instanceVariableNames: 'time from to cc subject text body fields parts separator '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Mail Reader'!