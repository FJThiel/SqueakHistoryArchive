'From Squeak3.1alpha of 4 February 2001 [latest update: #3800] on 6 March 2001 at 3:40:41 pm'!"Change Set:		Exception-unwind-V3Date:			6 March 2001Author:			tim@sumeru.stanford.edu, Paul McDonough, Stephen Pair and othersIntended for the 3.1 image post update 3602.Fix exception handling so that unwinding is done resonably efficiently and correctly.Change the #returnValue:to: code to check for non-local returns and send #aboutToReturn:through: to the first unwind-marked method context on the stack.The method that handles this will use the findNextUnwindContextUpTo: method(prim) to scan up the stack for other unwind methods.For this version, the methods are marked by using two primitives (198 for unwind and 199 for handler) since there is only one 'spare' bit in the method header. The two prims are left unimplemented for the normal vm since that leaves them as simple failure cases that let the bytecodes do the work as before (actually, empty macros are used in the hoe of making it simpler for Ian as well as stamping on the prim table entries to claim them). For the jitter we can use the prims to do real frame marking.You might wonder why we use prims to scan up the stack for marked contexts; it's not really much of a performance issue for a simple vm like Squeak since there is not often more than a couple of layers of stack to search, but for a context caching vm like the jitter the prim avoids the very expensive, repetitive, realisation of the cached contexts.You can simply file this code in and then generate a new vm; this new vm will run old images ok and the new image will run about as well on a new vm as the old ones did.Final modifications by ar 3/6/2001: * Made an extra primitive to check if the VM implements proper unwind semantics (#primitiveValueUninterruptably) and using the former behavior if not, thus making sure newer images will run fine on older VMs. The primitive will be removed in due time.* Fixed up #returnValue:to: to check the sender chain for inbetween nil contexts, thus making sure older images will run fine on newer VMs.* Implemented #primitiveMarkUnwindMethod and #primitiveMarkHandlerMethod as #primitiveFail for documentation reasons rather than #define them in sq.h."!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows freeContexts freeLargeContexts interruptCheckCounter displayBits totalObjectCount shrinkThreshold growHeadroom '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize BlockContextProto CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassExternalAddress ClassExternalData ClassExternalFunction ClassExternalLibrary ClassExternalStructure ClassFloat ClassInteger ClassLargeNegativeInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClassMask CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero CtxtTempFrameStart DoAssertionChecks DoBalanceChecks Done ExternalObjectsArray FalseObject FloatProto GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextBit LargeContextSize MarkBit MethodContextProto NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorAboutToReturn SelectorCannotInterpret SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SizeMask SmallContextSize SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'VMConstruction-Interpreter'!!ContextPart methodsFor: 'controlling' stamp: 'ar 3/6/2001 14:26'!terminateTo: previousContext	"Terminate all the Contexts between me and previousContext, if previousContext is on my Context stack. Make previousContext my sender."	| currentContext sendingContext |	<primitive: 196>	(self hasSender: previousContext) ifTrue: [		currentContext _ sender.		[currentContext == previousContext] whileFalse: [			sendingContext _ currentContext sender.			currentContext terminate.			currentContext _ sendingContext]].	sender _ previousContext! !!ContextPart methodsFor: 'private-exceptions' stamp: 'TPR 8/28/2000 19:27'!findNextHandlerContextStarting	"Return the next handler marked context, returning nil if there is none.  Search starts with self and proceeds up to nil."	| ctx |	<primitive: 197>	ctx _ self.		[ctx isHandlerContext ifTrue:[^ctx].		(ctx _ ctx sender) == nil ] whileFalse.	^nil! !!ContextPart methodsFor: 'private-exceptions' stamp: 'TPR 8/23/2000 16:37'!findNextUnwindContextUpTo: aContext	"Return the next unwind marked above the receiver, returning nil if there is none.  Search proceeds up to but not including aContext."	| ctx |	<primitive: 195>	ctx _ self.		[(ctx _ ctx sender) == nil or: [ctx == aContext]] whileFalse:		[ ctx isUnwindContext ifTrue: [^ctx]].	^nil! !!ContextPart methodsFor: 'private-exceptions' stamp: 'tpr 2/24/2001 21:29'!isHandlerContext	^false! !!ContextPart methodsFor: 'private-exceptions' stamp: 'TPR 8/28/2000 15:45'!isUnwindContext	^false! !!ContextPart methodsFor: 'private-exceptions' stamp: 'tpr 2/24/2001 21:39'!unwindTo: aContext	| ctx returnValue unwindBlock |	ctx := self.	[(ctx _ ctx findNextUnwindContextUpTo: aContext) isNil] whileFalse: [		unwindBlock := ctx tempAt: 1.		unwindBlock == nil			ifFalse: [returnValue := unwindBlock value]].	^returnValue! !!BlockContext methodsFor: 'private' stamp: 'tpr 2/16/2001 18:24'!aboutToReturn: result through: firstUnwindContext 	"Use the passed in context as the first marked context; evaluate the 	unwind block and then scan upwards for the next unwind marked 	method context"	| ctx unwindBlock |	ctx _ firstUnwindContext.	[ctx isNil]		whileFalse: [unwindBlock _ ctx tempAt: 1.			unwindBlock == nil				ifFalse: [unwindBlock value].			ctx _ ctx findNextUnwindContextUpTo: home].	thisContext swapSender: home sender.	^ result! !!BlockContext methodsFor: 'exceptions' stamp: 'ar 3/6/2001 14:24'!ensure: aBlock	"Evaluate a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes."	| returnValue |	<primitive: 198>	returnValue := self valueUninterruptably.	"aBlock wasn't nil when execution of this method began; it is nil'd out by the unwind machinery, and that's how we know it's already been evaluated ... otherwise, obviously, it needs to be evaluated"	aBlock == nil ifFalse: [aBlock value].	^returnValue! !!BlockContext methodsFor: 'exceptions' stamp: 'ar 3/6/2001 14:25'!ifCurtailed: aBlock	"Evaluate the receiver with an abnormal termination action."	<primitive: 198>	^self valueUninterruptably! !!BlockContext methodsFor: 'exceptions' stamp: 'ar 3/6/2001 14:25'!on: exception do: handlerAction	"Evaluate the receiver in the scope of an exception handler."	| handlerActive |	<primitive: 199>	handlerActive _ true.	^self value! !!BlockContext methodsFor: 'private-exceptions' stamp: 'ar 3/6/2001 14:55'!valueUninterruptably	"Temporarily make my home Context unable to return control to its sender, to guard against circumlocution of the ensured behavior."	| sendingContext result homeSender |	<primitive: 123>	"The above indicates new EH primitives supported. In this case is identical to #value."	sendingContext := thisContext sender sender.	homeSender _ home swapSender: nil.	[[result := self				on: BlockCannotReturn				do:					[:ex |					thisContext unwindTo: sendingContext.					sendingContext home answer: ex result.					ex return: ex result]]						on: ExceptionAboutToReturn						do:							[:ex |							home sender == nil								ifTrue:									[home swapSender: homeSender.									ex resume: homeSender]								ifFalse: [ex resume: nil]]]		on: Exception		do:			[:ex |			home swapSender: homeSender.			ex pass].	home swapSender: homeSender.	^result! !!Exception methodsFor: 'private' stamp: 'tpr 2/24/2001 21:42'!findHandlerFrom: startCtx	| ctx handler |	ctx := startCtx.	[(ctx _ ctx findNextHandlerContextStarting) isNil]		whileFalse:			[handler := ctx tempAt: 1. "the first argument"			((handler handles: self) and: [(ctx tempAt: 3) ])				ifTrue: [handlerContext := ctx.							^ctx].			ctx _ ctx sender].	^nil! !!Exception methodsFor: 'private' stamp: 'pnm 8/16/2000 15:21'!initialContext: aContext	initialContext := aContext! !!Exception methodsFor: 'private' stamp: 'pnm 8/16/2000 15:04'!receiver	^initialContext receiver! !!Exception methodsFor: 'signaledException' stamp: 'pnm 8/16/2000 14:45'!resignalAs: replacementException	"Signal an alternative exception in place of the receiver."	thisContext unwindTo: initialContext.	replacementException initialContext: initialContext.	resignalException := replacementException.	thisContext swapSender: thisContext sender sender! !!Exception methodsFor: 'signaledException' stamp: 'pnm 8/16/2000 15:00'!retry	"Abort an exception handler and re-evaluate its protected block."	thisContext unwindTo: handlerContext.	thisContext terminateTo: handlerContext.	handlerContext restart! !!Exception methodsFor: 'signaledException' stamp: 'pnm 8/16/2000 15:00'!retryUsing: alternativeBlock	"Abort an exception handler and evaluate a new block in place of the handler's protected block."	handlerContext receiver: alternativeBlock.	self retry! !!Exception methodsFor: 'signaledException' stamp: 'pnm 8/16/2000 12:57'!return: returnValue	"Return the argument as the value of the block protected by the active exception handler."	initialContext unwindTo: handlerContext.	thisContext terminateTo: handlerContext.	^returnValue! !!Exception methodsFor: 'exceptionBuilder' stamp: 'pnm 8/16/2000 15:00'!messageText: signalerText	"Set an exception's message text."	messageText := signalerText! !!Exception methodsFor: 'exceptionBuilder' stamp: 'pnm 8/16/2000 15:23'!tag: t	"This message is not specified in the ANSI protocol, but that looks like an oversight because #tag is specified, and the spec states that the signaler may store the tag value."	tag := t! !!Exception methodsFor: 'exceptionDescription' stamp: 'pnm 8/16/2000 14:53'!defaultAction	"The default action taken if the exception is signaled."	self subclassResponsibility! !!Exception methodsFor: 'exceptionDescription' stamp: 'pnm 8/16/2000 14:53'!description	"Return a textual description of the exception."	| desc mt |	desc := self class name asString.	^(mt := self messageText) == nil		ifTrue: [desc]		ifFalse: [desc, ': ', mt]! !!Exception methodsFor: 'exceptionDescription' stamp: 'pnm 8/16/2000 14:53'!isResumable	"Determine whether an exception is resumable."	^false! !!Exception methodsFor: 'exceptionDescription' stamp: 'pnm 8/16/2000 14:53'!messageText	"Return an exception's message text."	^messageText! !!Exception methodsFor: 'exceptionDescription' stamp: 'pnm 8/16/2000 14:54'!tag	"Return an exception's tag value."	^tag == nil		ifTrue: [self messageText]		ifFalse: [tag]! !!Exception class methodsFor: 'exceptionInstantiator' stamp: 'pnm 8/16/2000 15:01'!signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	| ex |	ex := self new.	ex initialContext: thisContext sender.	^ex signal: signalerText! !!ExceptionSet methodsFor: 'exceptionSelector' stamp: 'pnm 8/16/2000 15:15'!handles: anException	"Determine whether an exception handler will accept a signaled exception."	exceptions do:		[:ex |		(ex handles: anException)			ifTrue: [^true]].	^false! !!MessageNotUnderstood methodsFor: 'exceptionBuilder' stamp: 'pnm 8/16/2000 15:03'!message: aMessage	message := aMessage! !!MessageNotUnderstood methodsFor: 'exceptionDescription' stamp: 'pnm 8/16/2000 15:03'!messageText	"Return an exception's message text."	^messageText == nil		ifTrue:			[message == nil				ifTrue: [super messageText]				ifFalse: [message selector asString]]		ifFalse: [messageText]! !!MethodContext methodsFor: 'private-exceptions' stamp: 'tpr 2/24/2001 22:05'!isHandlerContext"is this context for  method that is marked?"	^method primitive = 199! !!MethodContext methodsFor: 'private-exceptions' stamp: 'tpr 2/24/2001 22:05'!isUnwindContext"is this context for  method that is marked?"	^method primitive = 198! !!MethodContext methodsFor: 'controlling' stamp: 'ar 3/6/2001 15:02'!answer: anObject	"ar 3/6/2001: OBSOLETE. Must not be used. Will be removed VERY SOON."	"Modify my code, from the current program counter value, to answer anObject."	self push: anObject.	(method at: pc) = 124 ifFalse: [		method _ (			(method clone)				at: pc + 1 put: 124;				yourself)]! !!Notification methodsFor: 'exceptionDescription' stamp: 'pnm 8/16/2000 15:04'!defaultAction	"No action is taken. The value nil is returned as the value of the message that signaled the exception."	^nil! !!Interpreter methodsFor: 'compiled methods' stamp: 'ar 3/6/2001 15:04'!isHandlerMarked: aContext	"Is this a MethodContext whose meth has a primitive number of 199?"	| header meth pIndex |	"NB: the use of a primitive number for marking the method is pretty grungy, but it is simple to use for a test sytem, not too expensive and we don't actually have the two spare method header bits we need. We can probably obtain them when the method format is changed.	NB 2: actually, the jitter will probably implement the prim to actually mark the volatile frame by changing the return function pointer."	self inline: true.	header _ self baseHeader: aContext.	(self isMethodContextHeader: header) ifFalse: [^false].	meth _ self fetchPointer: MethodIndex ofObject: aContext.	pIndex _ self primitiveIndexOf: meth.	^pIndex == 199! !!Interpreter methodsFor: 'compiled methods' stamp: 'ar 3/6/2001 15:04'!isUnwindMarked: aContext	"Is this a MethodContext whose meth has a primitive number of 198?"	| header meth pIndex |	"NB: the use of a primitive number for marking the method is pretty grungy, but it is simple to use for a test sytem, not too expensive and we don't actually have the two spare method header bits we need. We can probably obtain them when the method format is changed	NB 2: actually, the jitter will probably implement the prim to actually mark the volatile frame by changing the return function pointer."	self inline: true.	header _ self baseHeader: aContext.	(self isMethodContextHeader: header) ifFalse: [^false].	meth _ self fetchPointer: MethodIndex ofObject: aContext.	pIndex _ self primitiveIndexOf: meth.	^pIndex == 198! !!Interpreter methodsFor: 'contexts' stamp: 'ar 3/6/2001 15:03'!context: thisCntx hasSender: aContext	"Does thisCntx have aContext in its sender chain?"	| s nilOop |	self inline: true.	thisCntx == aContext ifTrue: [^false].	nilOop _ nilObj.	s _ self fetchPointer: SenderIndex ofObject: thisCntx.	[s == nilOop]		whileFalse: 			[s == aContext ifTrue: [^true].			s _ s self fetchPointer: SenderIndex ofObject: s].	^false! !!Interpreter methodsFor: 'contexts' stamp: 'ar 3/6/2001 14:57'!primitiveFindHandlerContext	"Primitive. Search up the context stack for the next method context marked for exception handling starting at the receiver. Return nil if none found"	| thisCntx nilOop |	thisCntx _ self popStack.	nilOop _ nilObj.	[(self isHandlerMarked: thisCntx) ifTrue:[			self push: thisCntx.			^nil].		thisCntx _ self fetchPointer: SenderIndex ofObject: thisCntx.		thisCntx = nilOop] whileFalse.	^self push: nilObj! !!Interpreter methodsFor: 'contexts' stamp: 'ar 3/6/2001 14:56'!primitiveFindNextUnwindContext	"Primitive. Search up the context stack for the next method context marked for unwind handling from the receiver up to but not including the argument. Return nil if none found."	| thisCntx nilOop aContext |	aContext _ self popStack.	thisCntx _ self fetchPointer: SenderIndex ofObject: self popStack.	nilOop _ nilObj.	[(thisCntx = aContext) or: [thisCntx = nilOop]] whileFalse: [		(self isUnwindMarked: thisCntx) ifTrue:[			self push: thisCntx.			^nil].		thisCntx _ self fetchPointer: SenderIndex ofObject: thisCntx].	^self push: nilOop! !!Interpreter methodsFor: 'contexts' stamp: 'ar 3/6/2001 14:59'!primitiveMarkHandlerMethod	"Primitive. Mark the method for exception handling. The primitive must fail after marking the context so that the regular code is run."	^self primitiveFail! !!Interpreter methodsFor: 'contexts' stamp: 'ar 3/6/2001 14:59'!primitiveMarkUnwindMethod	"Primitive. Mark the method for exception unwinding. The primitive must fail after marking the context so that the regular code is run."	^self primitiveFail! !!Interpreter methodsFor: 'contexts' stamp: 'ar 3/6/2001 14:57'!primitiveTerminateTo	"Primitive. Terminate up the context stack from the receiver up to but not including the argument, if previousContext is on my Context stack. Make previousContext my sender. This prim has to shadow the code in ContextPart>terminateTo: to be correct"	| thisCntx currentCntx aContext nextCntx nilOop |	aContext _ self popStack.	thisCntx _ self popStack.	"make sure that aContext is in my chain"	(self context: thisCntx hasSender: aContext) ifTrue:[		nilOop _ nilObj.		currentCntx _ self fetchPointer: SenderIndex ofObject: thisCntx.		[currentCntx = aContext] whileFalse: [			nextCntx _ self fetchPointer: SenderIndex ofObject: currentCntx.			self storePointer: SenderIndex ofObject: currentCntx withValue: nilOop.			currentCntx _ nextCntx]].	self storePointer: SenderIndex ofObject: thisCntx withValue: aContext.	^self push: thisCntx! !!Interpreter methodsFor: 'contexts' stamp: 'ar 3/6/2001 14:59'!primitiveValueUninterruptably	"The only purpose of this primitive is to indicate that the new EH mechanisms are supported."	^self primitiveValue! !!Interpreter methodsFor: 'return bytecodes' stamp: 'ar 3/6/2001 15:21'!internalAboutToReturn: resultObj through: aContext	self inline: true.	self internalPush: activeContext.	self internalPush: resultObj.	self internalPush: aContext.	messageSelector _ self splObj: SelectorAboutToReturn.	argumentCount _ 2.	^self normalSend! !!Interpreter methodsFor: 'return bytecodes' stamp: 'ar 3/6/2001 15:21'!internalCannotReturn: resultObj	self inline: true.	self internalPush: activeContext.	self internalPush: resultObj.	messageSelector _ self splObj: SelectorCannotReturn.	argumentCount _ 1.	^ self normalSend! !!Interpreter methodsFor: 'return bytecodes' stamp: 'ar 3/6/2001 14:50'!returnValue: resultObj to: returnContext	"Note: Assumed to be inlined into the dispatch loop."	| nilOop thisCntx contextOfCaller |	self inline: true.	self sharedCodeNamed: 'commonReturn' inCase: 120.	nilOop _ nilObj. "keep in a register"	thisCntx _ activeContext.	"make sure we can return to the given context"	((returnContext = nilOop) or:	 [(self fetchPointer: InstructionPointerIndex ofObject: returnContext) = nilOop]) ifTrue: [		"error: sender's instruction pointer or context is nil; cannot return"		^self internalCannotReturn: resultObj].	"If this return is not to our immediate predecessor (i.e. from a method to its sender, or from a block to its caller), scan the stack for the first unwind marked context and inform this context and let it deal with it. This provides a chance for ensure unwinding to occur."	thisCntx _ self fetchPointer: SenderIndex ofObject: activeContext.	"Just possibly a faster test would be to compare the homeContext and activeContext - they are of course different for blocks. Thus we might be able to optimise a touch by having a different returnTo for the blockreteurn (since we know that must return to caller) and then if active ~= home we must be doing a non-local return. I think. Maybe."	[thisCntx = returnContext] whileFalse: [		thisCntx = nilObj ifTrue:[			"error: sender's instruction pointer or context is nil; cannot return"			^self internalCannotReturn: resultObj].		"Climb up stack towards returnContext. Break out to a send of #aboutToReturn:through: if an unwind marked context is found"		(self isUnwindMarked: thisCntx) ifTrue:[			"context is marked; break out"			^self internalAboutToReturn: resultObj through: thisCntx].		thisCntx _ self fetchPointer: SenderIndex ofObject: thisCntx. ].	"If we get here there is no unwind to worry about. Simply terminate the stack up to the returnContext - often just the sender of the method"	thisCntx _ activeContext.	[thisCntx = returnContext]		whileFalse:		["climb up stack to returnContext"		contextOfCaller _ self fetchPointer: SenderIndex ofObject: thisCntx.		"zap exited contexts so any future attempted use will be caught"		self storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.		self storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.		reclaimableContextCount > 0 ifTrue:			["try to recycle this context"			reclaimableContextCount _ reclaimableContextCount - 1.			self recycleContextIfPossible: thisCntx].		thisCntx _ contextOfCaller].	activeContext _ thisCntx.	(thisCntx < youngStart) ifTrue: [ self beRootIfOld: thisCntx ].	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"	self fetchNextBytecode.	self internalPush: resultObj.! !!ObjectMemory class methodsFor: 'initialization' stamp: 'ar 3/6/2001 14:34'!initializeSpecialObjectIndices	"Initialize indices into specialObjects array."	NilObject _ 0.	FalseObject _ 1.	TrueObject _ 2.	SchedulerAssociation _ 3.	ClassBitmap _ 4.	ClassInteger _ 5.	ClassString _ 6.	ClassArray _ 7.	"SmalltalkDictionary _ 8."  "Do not delete!!"	ClassFloat _ 9.	ClassMethodContext _ 10.	ClassBlockContext _ 11.	ClassPoint _ 12.	ClassLargePositiveInteger _ 13.	TheDisplay _ 14.	ClassMessage _ 15.	ClassCompiledMethod _ 16.	TheLowSpaceSemaphore _ 17.	ClassSemaphore _ 18.	ClassCharacter _ 19.	SelectorDoesNotUnderstand _ 20.	SelectorCannotReturn _ 21.	TheInputSemaphore _ 22.	SpecialSelectors _ 23.	CharacterTable _ 24.	SelectorMustBeBoolean _ 25.	ClassByteArray _ 26.	ClassProcess _ 27.	CompactClasses _ 28.	TheTimerSemaphore _ 29.	TheInterruptSemaphore _ 30.	FloatProto _ 31.	SelectorCannotInterpret _ 34.	MethodContextProto _ 35.	BlockContextProto _ 37.	ExternalObjectsArray _ 38.	ClassPseudoContext _ 39.	ClassTranslatedMethod _ 40.	TheFinalizationSemaphore _ 41.	ClassLargeNegativeInteger _ 42.	ClassExternalAddress _ 43.	ClassExternalStructure _ 44.	ClassExternalData _ 45.	ClassExternalFunction _ 46.	ClassExternalLibrary _ 47.	SelectorAboutToReturn _ 48.! !!Interpreter class methodsFor: 'initialization' stamp: 'ar 3/6/2001 15:00'!initializePrimitiveTable 	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveArrayBecomeOneWay)	"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveStoreStackp)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveBlockCopy)		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveTestDisplayDepth)			"Blue Book: primitiveCursorLocPut"		(92 primitiveSetDisplayMode)				"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveGetNextEvent)				"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveObsoleteIndexedPrimitive)	"primitiveCopyBits"		(97 primitiveSnapshot)		(98 primitiveStoreImageSegment)		(99 primitiveLoadImageSegment)		(100 primitivePerformInSuperclass)		"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveObsoleteIndexedPrimitive)	"primitiveDrawLoop"		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveChangeClass)					"Blue Book: primitiveOopsLeft"		(116 primitiveFlushCacheByMethod)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)			"Squeak 2.2 and earlier use 119.  Squeak 2.3 and later use 116.			Both are supported for backward compatibility."		"Miscellaneous Primitives (120-127)"		(120 primitiveCalloutToFFI)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveValueUninterruptably)	"@@@: Remove this when all VMs have support"		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		"NOTE: When removing the obsolete indexed primitives,		the following two should go become #primitiveIntegerAt / atPut"		(146 primitiveObsoleteIndexedPrimitive)	"primitiveReadJoystick"		(147 primitiveObsoleteIndexedPrimitive)	"primitiveWarpBits"		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169) - NO LONGER INDEXED"		(150 164 primitiveObsoleteIndexedPrimitive)		(165 primitiveIntegerAt)		"hacked in here for now"		(166 primitiveIntegerAtPut)		(167 168 primitiveFail)		(169 primitiveObsoleteIndexedPrimitive)		"Sound Primitives (170-199) - NO LONGER INDEXED"		(170 185 primitiveObsoleteIndexedPrimitive)		(186 188 primitiveFail)		(189 194 primitiveObsoleteIndexedPrimitive)		"Unwind primitives"		(195 primitiveFindNextUnwindContext)		(196 primitiveTerminateTo)		(197 primitiveFindHandlerContext)		(198 primitiveMarkUnwindMethod)		(199 primitiveMarkHandlerMethod)		"Networking Primitives (200-229) - NO LONGER INDEXED"		(200 225 primitiveObsoleteIndexedPrimitive)		(226 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primitiveObsoleteIndexedPrimitive) "primBitmapdecompressfromByteArrayat"		(235 primitiveObsoleteIndexedPrimitive) "primStringcomparewithcollated"		(236 primitiveObsoleteIndexedPrimitive) "primSampledSoundconvert8bitSignedFromto16Bit"		(237 primitiveObsoleteIndexedPrimitive) "primBitmapcompresstoByteArray"		(238 241 primitiveObsoleteIndexedPrimitive) "serial port primitives"		(242 primitiveFail)		(243 primitiveObsoleteIndexedPrimitive) "primStringtranslatefromtotable"		(244 primitiveObsoleteIndexedPrimitive) "primStringfindFirstInStringinSetstartingAt"		(245 primitiveObsoleteIndexedPrimitive) "primStringindexOfAsciiinStringstartingAt"		(246 primitiveObsoleteIndexedPrimitive) "primStringfindSubstringinstartingAtmatchTable"		(247 primitiveSnapshotEmbedded)		(248 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveInstVarsPutFromStack) "Never used except in Disney tests.  Remove after 2.3 release."		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539) - NO LONGER INDEXED"		(520 529 primitiveObsoleteIndexedPrimitive)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives - NO LONGER INDEXED"		(540 545 primitiveObsoleteIndexedPrimitive)		(546 547 primitiveFail)		"Pen Tablet Primitives - NO LONGER INDEXED"		(548 primitiveObsoleteIndexedPrimitive)		(549 primitiveObsoleteIndexedPrimitive)		"Sound Codec Primitives - NO LONGER INDEXED"		(550 553 primitiveObsoleteIndexedPrimitive)		(554 569 primitiveFail)		"External primitive support primitives"		(570 primitiveFlushExternalPrimitives)		(571 primitiveUnloadModule)		(572 primitiveListBuiltinModule)		(573 primitiveListExternalModule)		(574 primitiveFail) "reserved for addl. external support prims"		"Unassigned Primitives"		(575 700 primitiveFail)).! !!SystemDictionary methodsFor: 'special objects' stamp: 'svp 1/15/2000 21:47'!recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	Smalltalk virtual machine.  Its contents are critical and unchecked,	so don't even think of playing here unless you know what you are doing."	| newArray |	newArray _ Array new: 49.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (Smalltalk associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk. 	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18)  "(low space Semaphore)".	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.  "*unused*"	"An array of the 32 selectors that are compiled as special bytecodes,	paired alternately with the number of arguments each takes."	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 blockCopy: 1 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30)   "(delay Semaphore)".	newArray at: 31 put: (self specialObjectsArray at: 31)   "(user input Semaphore)".	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes"	newArray at: 36 put: (self specialObjectsArray at: 36). 						"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 37 put: nil.	newArray at: 38 put: (self specialObjectsArray at: 38). 						"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 39 put: Array new.  "array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil:[Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (Smalltalk at: #ExternalAddress ifAbsent:[nil]).	newArray at: 45 put: (Smalltalk at: #ExternalStructure ifAbsent:[nil]).	newArray at: 46 put: (Smalltalk at: #ExternalData ifAbsent:[nil]).	newArray at: 47 put: (Smalltalk at: #ExternalFunction ifAbsent:[nil]).	newArray at: 48 put: (Smalltalk at: #ExternalLibrary ifAbsent:[nil]).	newArray at: 49 put: #aboutToReturn:through:.	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !!Warning methodsFor: 'exceptionDescription' stamp: 'pnm 8/16/2000 15:05'!defaultAction	"The user should be notified of the occurrence of an exceptional occurrence and given an option of continuing or aborting the computation. The description of the occurrence should include any text specified as the argument of the #signal: message."	(self confirm: 'Warning: ', self messageText, ' Continue?') ifTrue: [self resume]! !!ZeroDivide methodsFor: 'exceptionDescription' stamp: 'pnm 8/16/2000 15:05'!isResumable	"Determine whether an exception is resumable."	^true! !!ZeroDivide methodsFor: 'exceptionBuilder' stamp: 'pnm 8/16/2000 15:05'!dividend: argument	"Specify the number that was being divided by zero."	dividend := argument! !"Postscript:Reinitialize special objects."Smalltalk recreateSpecialObjectsArray.!