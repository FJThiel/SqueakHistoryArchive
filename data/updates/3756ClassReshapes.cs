'From Squeak3.1alpha of 4 February 2001 [latest update: #3820] on 9 March 2001 at 12:53:50 am'!"Change Set:		ClassReshapesDate:			2 March 2001Author:			Andreas RaabThe change set reformulates most of the mutation mechanism in ClassBuilder. The class builder now mutates both, any old instances and the class itself into the new one in a single step. The CS also introduces a primitive for changing the class of an object provided that the format of the new class is acceptable.Most of the speedup in this CS can be seen when recompiling very few classes (up to a factor of ten for recompiling uni classes if the primitive for changing the class is supported). For large numbers of classes the speedup is less (about 2-3), mostly because of the need for preventing the creation of any new objects of the old class during the entire recompilation scheme.The new scheme has an approximately constant speed when reshaping classes. Per class reshaped we have one #allInstances (assembling the instances), one two-way #become (exchanging the instances) and one one-way #become  (exchanging the classes) operation. If the class changing primitive is not supported, an extra two-way #become and a full garbage collect is necessary per class. See ClassBuilder>>update:to:Finally, the change set fixes Interpreter>>transferTo: so that it nils out the suspended context of the activated process. Before this CS, the suspended context was one of the primary reasons for holding onto obsolete instances that should've been garbage collected."!!Object methodsFor: 'system primitives' stamp: 'ar 3/2/2001 01:34'!primitiveChangeClassTo: anObject	"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have.	Note: The primitive will fail in most cases that you think might work. This is mostly because of a) the difference between compact and non-compact classes, and b) because of differences in the format. As an example, '(Array new: 3) primitiveChangeClassTo: Morph basicNew' would fail for three of the reasons mentioned above. Array is compact, Morph is not (failure #1). Array is variable and Morph is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too short (failure #3).	The facility is really provided for certain, very specific applications (mostly related to classes changing shape) and not for casual use."	<primitive: 115>	self primitiveFailed! !!BlockContext methodsFor: 'private' stamp: 'ar 3/2/2001 01:16'!valueUnpreemptively	"Evaluate the receiver (block), without the possibility of preemption by higher priority processes. Use this facility VERY sparingly!!"	"Think about using Block>>valueUninterruptably first, and think about using Semaphore>>critical: before that, and think about redesigning your application even before that!! 	After you've done all that thinking, go right ahead and use it..."	| activeProcess oldPriority result |	activeProcess _ Processor activeProcess.	oldPriority _ activeProcess priority.	activeProcess priority: Processor highestPriority.	result _ self ensure: [activeProcess priority: oldPriority].	"Yield after restoring priority to give the preempted processes a chance to run"	Processor yield.	^result! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 3/3/2001 00:29'!doneCompiling: aClass	"The receiver has finished modifying the class hierarchy.	Do any necessary cleanup."	aClass doneCompiling.	Behavior flushObsoleteSubclasses.! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 3/1/2001 21:43'!class: oldClass instanceVariableNames: instVarString unsafe: unsafe	"This is the basic initialization message to change the definition of	an existing Metaclass"	| instVars newClass |	environ _ oldClass environment.	instVars _ Scanner new scanFieldNames: instVarString.	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: oldClass superclass 		type: oldClass typeOfClass		instanceVariables: instVars		from: oldClass		unsafe: unsafe.	newClass == nil ifTrue:[^nil]. "Some error"	newClass _ self recompile: false from: oldClass to: newClass mutate: false.	self doneCompiling: newClass.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 3/2/2001 00:59'!mutate: oldClass to: newClass	"Mutate oldClass to newClass.	Convert all instances of oldClass and recursively update	the subclasses."	| subs newSubclass oldSubclass |	subs _ oldClass subclasses asArray, oldClass obsoleteSubclasses.	"Walk down"	1 to: subs size do:[:i|		oldSubclass _ subs at: i.		self showProgressFor: oldSubclass.		"Create the new class"		newSubclass _ self reshapeClass: oldSubclass to: nil super: newClass.		"Mutate the subclasses"		self mutate: oldSubclass to: newSubclass.		"And do the magic become"		self update: oldSubclass to: newSubclass.	].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 3/1/2001 23:14'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force |	environ _ env.	instVars _ Scanner new scanFieldNames: instVarString.	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass _ env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: newSuper 		type: type 		instanceVariables: instVars		from: oldClass		unsafe: unsafe.	newClass == nil ifTrue:[^nil]. "Some error"	newClass == oldClass ifFalse:[newClass setName: className].	"Install the class variables and pool dictionaries... "	force _ (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	organization _ environ ifNotNil:[environ organization].	organization classify: newClass name under: category asSymbol.	newClass environment: environ.	"... recompile ..."	newClass _ self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		environ at: newClass name put: newClass.		Smalltalk flushClassNameCache.	].	self doneCompiling: newClass.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 3/2/2001 01:06'!recompile: force from: oldClass to: aClass mutate: forceMutation	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses. If forceMutation is true force a mutation even	if oldClass and newClass are the same."	| newClass |	newClass _ aClass.	oldClass == nil ifTrue:[		"newClass has an empty method dictionary		so we don't need to recompile"		Smalltalk changes addClass: newClass.		newClass superclass addSubclass: newClass.		^newClass].	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[		"No recompilation necessary but we might have added		class vars or class pools so record the change"		Smalltalk changes changeClass: newClass from: oldClass.		^newClass].	currentClassIndex _ 0.	maxClassIndex _ oldClass withAllSubclasses size.	(oldClass == newClass and:[forceMutation not]) ifTrue:[		Smalltalk changes changeClass: newClass from: oldClass.		"Recompile from newClass without mutating"		self informUserDuring:[			newClass isSystemDefined ifFalse:[progress _ nil].			newClass withAllSubclassesDo:[:cl|				self showProgressFor: cl.				cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	self informUserDuring:[		newClass isSystemDefined ifFalse:[progress _ nil].		self showProgressFor: oldClass.		newClass _ self reshapeClass: oldClass to: newClass super: newClass superclass.		Smalltalk changes changeClass: newClass from: oldClass.		self mutate: oldClass to: newClass.		"And do the magic become"		self update: oldClass to: newClass.	].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 3/5/2001 11:53'!reshapeClass: aClass to: templateClass super: newSuper	"Reshape the given class to the new super class.	If templateClass is not nil then it defines the shape of the new class"	| fmt newClass newMeta newSuperMeta oldMeta instVars oldClass |	templateClass == nil		ifTrue:[oldClass _ aClass]		ifFalse:[oldClass _ templateClass].	aClass becomeUncompact.	"Compute the new format of the class"	instVars _ instVarMap at: aClass name ifAbsent:[oldClass instVarNames].	fmt _ self computeFormat: oldClass typeOfClass				instSize: instVars size				forSuper: newSuper				ccIndex: 0."Known to be 0 since we uncompacted aClass first"	fmt == nil ifTrue:[^nil].	aClass isMeta ifFalse:["Create a new meta class"		oldMeta _ aClass class.		newMeta _ oldMeta clone.		newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].		newMeta 			superclass: newSuperMeta			methodDictionary: MethodDictionary new			format: (self computeFormat: oldMeta typeOfClass 							instSize: oldMeta instVarNames size 							forSuper: newSuperMeta							ccIndex: 0);			setInstVarNames: oldMeta instVarNames;			organization: oldMeta organization.		"Recompile the meta class"		oldMeta hasMethods 			ifTrue:[newMeta compileAllFrom: oldMeta].		"Fix up meta class structure"		oldMeta superclass addObsoleteSubclass: oldMeta.		(oldMeta superclass subclasses includes: oldMeta) ifTrue:[			oldMeta superclass removeSubclass: oldMeta.			newMeta superclass addSubclass: newMeta].		"And record the change so we can fix global refs later"		self recordClass: oldMeta replacedBy: newMeta.	].	newClass _ newMeta == nil		ifTrue:[oldClass clone]		ifFalse:[newMeta adoptInstance: oldClass from: oldMeta].	newClass		superclass: newSuper		methodDictionary: MethodDictionary new		format: fmt;		setInstVarNames: instVars;		organization: aClass organization.	"Recompile the new class"	aClass hasMethods 		ifTrue:[newClass compileAllFrom: aClass].	"Export the new class into the environment"	aClass isMeta ifFalse:[		"Derefence super sends in the old class"		self fixSuperSendsFrom: aClass.		"Export the class"		environ at: newClass name put: newClass.		"And use the ST association in the new class"		self fixSuperSendsTo: newClass].	"Fix up the class hierarchy"	(aClass superclass subclasses includes: aClass) ifTrue:[		aClass superclass removeSubclass: aClass.		newClass superclass addSubclass: newClass.	].	"And record the change"	self recordClass: aClass replacedBy: newClass.	^newClass! !!ClassBuilder methodsFor: 'private' stamp: 'ar 3/5/2001 01:57'!hasPrimitiveChangeClassTo	"Return true if #primitiveChangeClassTo is supported"	^(self tryPrimitiveChangeClassTo: self clone) notNil! !!ClassBuilder methodsFor: 'private' stamp: 'ar 3/2/2001 01:05'!recordClass: oldClass replacedBy: newClass	"Keep the changes up to date when we're moving instVars around"	(instVarMap includesKey: oldClass name) ifTrue:[		Smalltalk changes changeClass: newClass from: oldClass.	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 3/5/2001 12:00'!showProgressFor: aClass	"Announce that we're processing aClass"	progress == nil ifTrue:[^self].	aClass isObsolete ifTrue:[^self].	currentClassIndex _ currentClassIndex + 1.	(aClass hasMethods and: [aClass wantsRecompilationProgressReported]) ifTrue:		[progress value: ('Recompiling ', aClass name,' (', currentClassIndex printString,'/', maxClassIndex printString,')')]! !!ClassBuilder methodsFor: 'private' stamp: 'ar 3/9/2001 00:39'!update: oldClass to: newClass	"Convert oldClass and all its instances into newClass. The process is to do a two-way #become of the old vs. new instances, then we map the old instances into a temporary class and then we do a one-way become of the old into the new class. The entire process must be run unpreemptively so that	a) nobody can create any more instances of oldClass 	   (which may happen in a process switch), and	b) in case we don't #primitiveChangeClassTo: nobody can	   hold on to any of the old instances (which would #become	   instances of the new class later on).	The return value of this method is the temporary class we used for converting instances so that the senders still have a handle on the 'old' class."	| oldInstances someLeft tmp tmpClass |	[		someLeft _ false.		tmpClass _ oldClass clone.		oldInstances _ newClass updateInstancesFrom: oldClass.		oldInstances size > 0 ifTrue:[			"need to map instances"			self hasPrimitiveChangeClassTo ifTrue:[				"Much easier, faster, and better that way"				tmp _ tmpClass basicNew.				oldInstances do:[:inst| 					inst primitiveChangeClassTo: tmp.					inst class == tmpClass ifFalse:[self error:'Ouch']].			] ifFalse:[				"Do it the hard way. We need to make sure that there are no				instances of oldClass anymore. Thus we're #becoming the old				instances into temp instances and do a big GC afterwards. 				This is sloooooow (a bulk become + full GC for any class having				instances) but it's most definitely a way to get the required result."				tmpClass updateInstances: oldInstances from: oldClass isMeta: oldClass isMeta.				Smalltalk garbageCollect.			].		].		"It's better to be sure than sorry..."		someLeft _ oldClass someInstance notNil.		someLeft ifFalse:[			"remap obsolete subclasses in case they have instances"			oldClass obsoleteSubclasses do:[:obs| obs superclass: tmpClass].			oldClass becomeForward: newClass.			tmpClass isMeta ifFalse:				[tmpClass class replaceObsoleteInstanceWith: tmpClass]].	] valueUnpreemptively.	someLeft		ifTrue:[self error:'Illegal pointers to obsolete instances found'].	tmpClass superclass addObsoleteSubclass: tmpClass.	tmpClass obsolete.	^tmpClass! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 3/1/2001 23:25'!updateInstances: oldInstances from: oldClass isMeta: isMeta	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. Permute variables as necessary. Return the array of old instances (none of which should be pointed to legally by anyone but the array)."	"If there are any contexts having an old instance as receiver it might crash the system because the layout has changed, and the method only knows about the old layout."	| map variable instSize newInstances |	oldInstances isEmpty ifTrue:[^#()]. "no instances to convert"	isMeta ifTrue: [		oldInstances size = 1 ifFalse:[^self error:'Metaclasses can only have one instance'].		self soleInstance class == self ifTrue:[			^self error:'Metaclasses can only have one instance']].	map _ self instVarMappingFrom: oldClass.	variable _ self isVariable.	instSize _ self instSize.	newInstances _ Array new: oldInstances size.	1 to: oldInstances size do:[:i|		newInstances at: i put: (			self newInstanceFrom: (oldInstances at: i) variable: variable size: instSize map: map)].	"Now perform a bulk mutation of old instances into new ones"	oldInstances elementsExchangeIdentityWith: newInstances.	^newInstances "which are now old"! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 3/1/2001 20:48'!updateInstancesFrom: oldClass	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary. Return the array of old instances (none of which should be	pointed to legally by anyone but the array)."	"ar 7/15/1999: The updating below is possibly dangerous. If there are any	contexts having an old instance as receiver it might crash the system if	the new receiver in which the context is executed has a different layout.	See bottom below for a simple example:"	| oldInstances |	oldInstances _ oldClass allInstances asArray.	oldInstances _ self updateInstances: oldInstances from: oldClass isMeta: self isMeta.	"Now fix up instances in segments that are out on the disk."	ImageSegment allSubInstancesDo: [:seg |		seg segUpdateInstancesOf: oldClass toBe: self isMeta: self isMeta].	^oldInstances"	| crashingBlock class |	class _ Object subclass: #CrashTestDummy		instanceVariableNames: 'instVar'		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	class compile:'instVar: value instVar _ value'.	class compile:'crashingBlock ^[instVar]'.	crashingBlock _ (class new) instVar: 42; crashingBlock.	Object subclass: #CrashTestDummy		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	crashingBlock.	crashingBlock value.	"! !!Behavior class methodsFor: 'class initialization' stamp: 'ar 3/3/2001 00:30'!flushObsoleteSubclasses	"Behavior flushObsoleteSubclasses"	ObsoleteSubclasses keys "need a copy" 		do:[:obs| obs ifNotNil:[obs obsoleteSubclasses]]. "remove themselves"	ObsoleteSubclasses finalizeValues.! !!Interpreter methodsFor: 'object access primitives' stamp: 'ar 3/2/2001 01:25'!primitiveChangeClass	"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have."	| arg rcvr argClass classHdr sizeHiBits byteSize argFormat rcvrFormat ccIndex |	arg _ self stackObjectValue: 0.	rcvr _ self stackObjectValue: 1.	successFlag ifFalse:[^nil].	"Get the class we want to convert the receiver into"	argClass _ self fetchClassOf: arg.	"Check what the format of the class says"	classHdr _ self formatOfClass: argClass. "Low 2 bits are 0"	"Compute the size of instances of the class (used for fixed field classes only)"	sizeHiBits _ (classHdr bitAnd: 16r60000) >> 9.	classHdr _ classHdr bitAnd: 16r1FFFF.	byteSize _ (classHdr bitAnd: SizeMask) + sizeHiBits. "size in bytes -- low 2 bits are 0"	"Check the receiver's format against that of the class"	argFormat _ (classHdr >> 8) bitAnd: 16rF.	rcvrFormat _ self formatOf: rcvr.	argFormat = rcvrFormat ifFalse:[^self success: false]. "no way"	"For fixed field classes, the sizes must match.	Note: byteSize-4 because base header is included in class size."	argFormat < 2 ifTrue:[(byteSize - 4) = (self byteSizeOf: rcvr) ifFalse:[^self success: false]].	(self headerType: rcvr) = HeaderTypeShort ifTrue:[		"Compact classes. Check if the arg's class is compact and exchange ccIndex"		ccIndex _ classHdr bitAnd: CompactClassMask.		ccIndex = 0 ifTrue:[^self success: false]. "class is not compact"		self longAt: rcvr put:			(((self longAt: rcvr) bitAnd: CompactClassMask bitInvert32)				bitOr: ccIndex)	] ifFalse:[		"Exchange the class pointer, which could make rcvr a root for argClass"		self longAt: rcvr-4 put: (argClass bitOr: (self headerType: rcvr)).		(rcvr < youngStart) ifTrue: [			self possibleRootStoreInto: rcvr value: argClass.		].	].	"Flush cache because rcvr's class has changed"	self flushMethodCache.	successFlag ifTrue: [ self pop: 1 ].! !!Interpreter methodsFor: 'processes' stamp: 'ar 3/1/2001 19:26'!transferTo: aProc	"Record a process to be awoken on the next interpreter cycle.	ikp 11/24/1999 06:07 -- added hook for external runtime compiler"	| sched oldProc newProc |	newProc _ aProc.	sched _ self schedulerPointer.	oldProc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	self storePointer: ActiveProcessIndex ofObject: sched withValue: newProc.	compilerInitialized ifTrue: [		self compilerProcessChange: oldProc to: newProc.	] ifFalse: [		self storePointer: SuspendedContextIndex ofObject: oldProc withValue: activeContext.		self newActiveContext: (self fetchPointer: SuspendedContextIndex ofObject: newProc).		self storePointer: SuspendedContextIndex ofObject: newProc withValue: nilObj.	].	reclaimableContextCount _ 0.! !!Interpreter class methodsFor: 'initialization' stamp: 'ar 3/6/2001 15:00'!initializePrimitiveTable 	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveArrayBecomeOneWay)	"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveStoreStackp)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveBlockCopy)		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveTestDisplayDepth)			"Blue Book: primitiveCursorLocPut"		(92 primitiveSetDisplayMode)				"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveGetNextEvent)				"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveObsoleteIndexedPrimitive)	"primitiveCopyBits"		(97 primitiveSnapshot)		(98 primitiveStoreImageSegment)		(99 primitiveLoadImageSegment)		(100 primitivePerformInSuperclass)		"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveObsoleteIndexedPrimitive)	"primitiveDrawLoop"		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveChangeClass)					"Blue Book: primitiveOopsLeft"		(116 primitiveFlushCacheByMethod)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)			"Squeak 2.2 and earlier use 119.  Squeak 2.3 and later use 116.			Both are supported for backward compatibility."		"Miscellaneous Primitives (120-127)"		(120 primitiveCalloutToFFI)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveValueUninterruptably)	"@@@: Remove this when all VMs have support"		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		"NOTE: When removing the obsolete indexed primitives,		the following two should go become #primitiveIntegerAt / atPut"		(146 primitiveObsoleteIndexedPrimitive)	"primitiveReadJoystick"		(147 primitiveObsoleteIndexedPrimitive)	"primitiveWarpBits"		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169) - NO LONGER INDEXED"		(150 164 primitiveObsoleteIndexedPrimitive)		(165 primitiveIntegerAt)		"hacked in here for now"		(166 primitiveIntegerAtPut)		(167 168 primitiveFail)		(169 primitiveObsoleteIndexedPrimitive)		"Sound Primitives (170-199) - NO LONGER INDEXED"		(170 185 primitiveObsoleteIndexedPrimitive)		(186 188 primitiveFail)		(189 194 primitiveObsoleteIndexedPrimitive)		"Unwind primitives"		(195 primitiveFindNextUnwindContext)		(196 primitiveTerminateTo)		(197 primitiveFindHandlerContext)		(198 primitiveMarkUnwindMethod)		(199 primitiveMarkHandlerMethod)		"Networking Primitives (200-229) - NO LONGER INDEXED"		(200 225 primitiveObsoleteIndexedPrimitive)		(226 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primitiveObsoleteIndexedPrimitive) "primBitmapdecompressfromByteArrayat"		(235 primitiveObsoleteIndexedPrimitive) "primStringcomparewithcollated"		(236 primitiveObsoleteIndexedPrimitive) "primSampledSoundconvert8bitSignedFromto16Bit"		(237 primitiveObsoleteIndexedPrimitive) "primBitmapcompresstoByteArray"		(238 241 primitiveObsoleteIndexedPrimitive) "serial port primitives"		(242 primitiveFail)		(243 primitiveObsoleteIndexedPrimitive) "primStringtranslatefromtotable"		(244 primitiveObsoleteIndexedPrimitive) "primStringfindFirstInStringinSetstartingAt"		(245 primitiveObsoleteIndexedPrimitive) "primStringindexOfAsciiinStringstartingAt"		(246 primitiveObsoleteIndexedPrimitive) "primStringfindSubstringinstartingAtmatchTable"		(247 primitiveSnapshotEmbedded)		(248 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveInstVarsPutFromStack) "Never used except in Disney tests.  Remove after 2.3 release."		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539) - NO LONGER INDEXED"		(520 529 primitiveObsoleteIndexedPrimitive)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives - NO LONGER INDEXED"		(540 545 primitiveObsoleteIndexedPrimitive)		(546 547 primitiveFail)		"Pen Tablet Primitives - NO LONGER INDEXED"		(548 primitiveObsoleteIndexedPrimitive)		(549 primitiveObsoleteIndexedPrimitive)		"Sound Codec Primitives - NO LONGER INDEXED"		(550 553 primitiveObsoleteIndexedPrimitive)		(554 569 primitiveFail)		"External primitive support primitives"		(570 primitiveFlushExternalPrimitives)		(571 primitiveUnloadModule)		(572 primitiveListBuiltinModule)		(573 primitiveListExternalModule)		(574 primitiveFail) "reserved for addl. external support prims"		"Unassigned Primitives"		(575 700 primitiveFail)).! !!Metaclass methodsFor: 'private' stamp: 'ar 3/3/2001 00:20'!replaceObsoleteInstanceWith: newInstance	thisClass class == self ifTrue:[^self error:'I am fine, thanks'].	newInstance class == self ifFalse:[^self error:'Not an instance of me'].	thisClass _ newInstance.! !ClassBuilder class removeSelector: #autoMutateInstances!ClassBuilder removeSelector: #fixGlobalReferences!ClassBuilder removeSelector: #fixObsoleteMethodsFrom:map:!ClassBuilder removeSelector: #fixObsoleteReferencesTo:!ClassBuilder removeSelector: #mapObsoleteClassesToTemps:!Behavior removeSelector: #autoMutateInstances!