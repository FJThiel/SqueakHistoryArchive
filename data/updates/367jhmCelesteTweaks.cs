'From Squeak 2.2 of Sept 23, 1998 on 14 October 1998 at 7:17:16 am'!"Change Set:		jhmCelesteTweaksDate:			12 October 1998Author:			John MaloneyVarious improvements and bug fixes to Celeste. Fixes the bugresulting in 'Block cannot return' notifier when serveris unavailable. This was caused by having a return inan ifError: block, which left the old error handlerblock installed, even though the block could not be usedsince it had already returned.Fixes all other methods containing returns in error blocks.Includes Lex's fix of indexOfAscii:inString:startingAt: primitiveto handle characters > 127."!Model subclass: #Celeste	instanceVariableNames: 'mailDB currentCategory currentMessages currentTOC currentMsgID lastCategory subjectFilter fromFilter dateFilter customFilterBlock formatMessages lastCategoryList lastCategoryMenu messageTextView userPassword '	classVariableNames: 'CCList CustomFilters DeleteInboxAfterFetching FormatWhenFetching PopServer PopUserName SmtpServer SuppressWorthlessHeaderFields UserName '	poolDictionaries: ''	category: 'NetTools-Celeste'!!CategoriesFile methodsFor: 'categories access' stamp: 'jm 10/4/1998 11:16'!renameCategory: oldName to: newName	"Rename the given category."	| oldEntry |	(oldName = '.all.' | oldName = '.unclassified.' |	 (self categories includes: newName)) ifTrue:		[^ self].  "can't rename a special category or overwrite an existing one"	oldEntry _ categories removeKey: oldName ifAbsent: [Set new].	categories at: newName put: oldEntry.! !!Celeste methodsFor: 'open-close' stamp: 'jm 10/4/1998 14:01'!close	"Close the mail database."	userPassword _ nil.	mailDB ifNotNil: [		mailDB close; release.		mailDB _ nil].! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/12/1998 09:33'!categoryMenu: aMenu	"Answer the menu for the categories pane."	| labels lineSeparations selectors lines |	labels _ 'save\fetch mail\send queued mail\add category' withCRs.	lineSeparations _ #(1 2).	selectors _ #(save fetchMail sendQueuedMail addCategory).	"add extra commands if a normal category is selected"	((currentCategory notNil) and:	 [(currentCategory ~= '.all.') &	  (currentCategory ~= '.unclassified.')])		ifTrue: [			labels _ labels, '\rename category\remove category\import into category\export category (Celeste)\export category (Unix/Eudora)' withCRs.			lineSeparations _ lineSeparations, #(3 3).			selectors _ selectors, #(renameCategory removeCategory importIntoCategory exportCategory exportCategoryUnix)]		ifFalse: [			lineSeparations _ lineSeparations, #(1)].	labels _ labels, '\empty trash\compact\find duplicates\toggle headers\set user name\set cc: list\set POP server\set POP username\set SMTP server' withCRs.	lineSeparations _ lineSeparations, #(3 1 5).	selectors _ selectors, #(emptyTrash compact findDuplicates toggleSuppressHeaders setUserName setCCList setPopServer setPopUserName setSmtpServer).	"add toggle for whether to delete messages on download"	DeleteInboxAfterFetching		ifTrue: [labels _ labels, '\leave messages on server' withCRs.			selectors _ selectors, #(keepMessagesOnServer)]		ifFalse: [labels _ labels, '\don''t leave messages on server' withCRs.			selectors _ selectors, #(deleteMessagesAfterFetching)].	lineSeparations _ lineSeparations, #(1).	"convert lineSeperations into absolute line positions"	lines _ lineSeparations copyFrom: 1 to: (lineSeparations size - 1).	(2 to: lines size) do: [:i |		lines at: i put: ((lines at: i) + (lines at: i-1))].	^ aMenu labels: labels lines: lines  selections: selectors! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 14:06'!fetchMail	"Append messages from the user's mailbox to this mail database."	| server password msgCount |	server _ self class popServer.	password _ self popPassword.	(password isNil or: [password isEmpty]) ifTrue: [^ self].	msgCount _ mailDB fetchMailFromPOP: server		userName: self class popUserName		password: password		doFormatting: FormatWhenFetching		deleteFromServer: DeleteInboxAfterFetching.	msgCount < 0		ifTrue: [self inform: 'could not connect to the mail server']		ifFalse: [self inform: msgCount printString, ' messages fetched'].	msgCount <= 0 ifTrue: [^ self].	currentCategory _ 'new'. 	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:46'!findDuplicates	"Find duplicate messages, and move the redundant copies to a given category."	| duplicatesCategory |	duplicatesCategory _ FillInTheBlank		request: 'File duplicates in category?'		initialAnswer: 'duplicates'.	duplicatesCategory isEmpty ifTrue:[^ self].	Utilities informUser: 'Searching for duplicates...'		during: [mailDB fileDuplicatesIn: duplicatesCategory].	self changed: #categoryList.	self setCategory: duplicatesCategory.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:39'!nextCategory	"Select the next category."	| catList i |	catList _ self categoryList.	(currentCategory isNil) ifTrue: [currentCategory _ catList last].	i _ catList indexOf: currentCategory.	i < catList size		ifTrue: [self setCategory: (catList at: i + 1)]		ifFalse: [self setCategory: (catList at: 1)].! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:39'!previousCategory	"Select the next category."	| catList i |	catList _ self categoryList.	(currentCategory isNil) ifTrue: [currentCategory _ catList last].	i _ catList indexOf: currentCategory.	i > 1		ifTrue: [self setCategory: (catList at: i - 1)]		ifFalse: [self setCategory: (catList at: catList size)].! !!Celeste methodsFor: 'categories pane' stamp: 'jm 10/4/1998 10:37'!removeCategory	"Remove the existing category with the user-specified name."	| msgList |	currentCategory ifNil: [ ^self ].	msgList _ mailDB messagesIn: currentCategory.	(mailDB messagesIn: '.trash.') do: [: id |		msgList remove: id ifAbsent: []].	msgList isEmpty ifFalse: [		(self confirm:'This category is not empty. Areyou sure you wish to remove it?') ifFalse: [^self]].	mailDB removeCategory: currentCategory.	self changed: #categoryList.	self setCategory: nil.! !!Celeste methodsFor: 'message text pane' stamp: 'jm 10/2/1998 16:14'!messageText	(currentMsgID isNil) ifTrue: [^''].	SuppressWorthlessHeaderFields		ifTrue: [^ self formatedMessageText]		ifFalse: [^ mailDB getText: currentMsgID].! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 10:55'!composeText	"Answer the template for a new message."	^ String streamContents: [:str |		str nextPutAll: 'From: '.		str nextPutAll: Celeste userName; cr.		str nextPutAll: 'To: '; cr.		str nextPutAll: 'Subject: '; cr.		Celeste ccList isEmpty ifFalse: [			str nextPutAll: 'Cc: '.			str nextPutAll: Celeste ccList; cr].		str cr].! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 10:55'!forwardTextFor: msgID	"Answer the template for forwarding the message with the given ID."	^ self composeText, '---------- Forwarded ----------',	(mailDB getMessage: msgID) body, '-------------------------------'! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 14:23'!popPassword	"Answer the password to use when retrieving mail via POP3. The password is stored in an instance variable, which disappears when you close the Celeste window."	userPassword ifNotNil: [^ userPassword].	userPassword _ FillInTheBlank request: 'POP password'.	^ userPassword! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 11:11'!queueMessageWithText: aStringOrText	"Queue a message to be sent later. The message is added to the database and filed in the '.tosend.' category."	| messageText id |	"add a x-mailer line"	messageText _		'X-Mailer: ',		Celeste versionString, 		String cr, 		aStringOrText asString.		"queue the message"	id _ mailDB addNewMessage: (MailMessage from: messageText).	mailDB file: id inCategory: '.tosend.'.	self changed: #categoryList.	self changed: #tocEntryList.! !!Celeste methodsFor: 'sending mail' stamp: 'jm 10/4/1998 10:59'!sendQueuedMail	"Post queued messages to the SMTP server."	| outgoing sender n message recipients ok |	outgoing _ mailDB messagesIn: '.tosend.'.	outgoing isEmpty ifTrue: [^ self inform: 'no mail to be sent'].	sender _ (MailAddressParser addressesIn: self class userName) first.	('sending ', outgoing size printString, ' messages...')		displayProgressAt: Sensor mousePoint		from: 1		to: outgoing size		during: [:progressBar |			n _ 0.			outgoing do: [:id |				progressBar value: (n _ n + 1).				message _ mailDB getMessage: id.				recipients _ Set new.				recipients addAll: (MailAddressParser addressesIn: message to).				recipients addAll: (MailAddressParser addressesIn: message cc).				ok _ SMTPSocket 					deliverMailFrom: sender					to: recipients 					text: message text 					usingServer: Celeste smtpServer.				ok					ifTrue: [						mailDB remove: id fromCategory: '.tosend.'.						mailDB file: id inCategory: '.sent.']					ifFalse: [^ self error: 'error posting mail']]].	mailDB saveDB.	self changed: #categoryList.	self updateTOC.! !!Celeste class methodsFor: 'class initialization' stamp: 'jm 10/4/1998 13:55'!initialize	"Celeste initialize"	"user preferences"	CCList _ nil.	DeleteInboxAfterFetching _ false.	PopServer _ nil.	PopUserName _ nil.	SmtpServer _ nil.	SuppressWorthlessHeaderFields _ true.	UserName _ nil.	"options with no UI; just set their values directly"	FormatWhenFetching _ false.	"dictionary of custom filters"	CustomFilters _ Dictionary new.! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 10/4/1998 14:44'!buildButtonsFor: model	"Answer a collection of handy buttons for the Celeste user interface."	| buttonViewClass buttons b |	Smalltalk isMorphic		ifTrue: [buttonViewClass _ PluggableButtonMorph]		ifFalse: [buttonViewClass _ PluggableButtonView].	buttons _ OrderedCollection new.	b _ buttonViewClass on:		(Switch new			onAction: [model subjectFilterOn];			offAction: [model subjectFilterOff]).	b	label: ('Subj. F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass on:		(Switch new			onAction: [model fromFilterOn];			offAction: [model fromFilterOff]).	b	label: ('From F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass on:		(Switch new			onAction: [model customFilterOn];			offAction: [model customFilterOff]).	b	label: ('Custom F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model compose]);		action: #turnOn;		label: ('New' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model reply]);		action: #turnOn;		label: ('Reply' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model forward]);		action: #turnOn;		label: ('Forward' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model moveAgain]);		action: #turnOn;		label: ('Move Again' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model deleteMessage]);		action: #turnOn;		label: ('Delete' asParagraph centered);		borderWidth: 1.	buttons add: b.	^ buttons! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 10/4/1998 14:46'!openOnDatabase: aMailDB	"Open a MailReader on the given mail database."	| model views buttons topWindow |	model _ self new openOnDatabase: aMailDB.	views _ self buildViewsFor: model.	buttons _ self buildButtonsFor: model.	Smalltalk isMorphic		ifTrue: [			topWindow _ (SystemWindow labelled: 'Celeste') model: model.			topWindow addMorph: (buttons at: 1) frame: (0.0@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 2) frame: (0.125@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 3) frame: (0.25@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 4) frame: (0.375@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 5) frame: (0.50@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 6) frame: (0.625@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 7) frame: (0.75@0.0 extent: 0.125@0.05).			topWindow addMorph: (buttons at: 8) frame: (0.875@0.0 extent: 0.125@0.05).			topWindow addMorph: (views at: 1) frame: (0.0@0.05 extent: 0.2@0.25).			topWindow addMorph: (views at: 2) frame: (0.2@0.05 extent: 0.8@0.25).			topWindow addMorph: (views at: 3) frame: (0.0@0.30 extent: 1.0@0.70).			buttons do: [:b | b onColor: Color lightGray offColor: Color white].			topWindow openInWorld]		ifFalse: [			topWindow _ StandardSystemView new				model: model;				label: 'Celeste';				minimumSize: 400@250.			(views at: 1) window: (0@0 extent: 20@25).			(views at: 2) window: (0@0 extent: 80@25).			(views at: 3) window: (0@0 extent: 100@70).			(buttons at: 1) window: (0@0 extent: 12@5).			(buttons at: 2) window: (0@0 extent: 12@5).			(buttons at: 3) window: (0@0 extent: 12@5).			(buttons at: 4) window: (0@0 extent: 10@5).			(buttons at: 5) window: (0@0 extent: 13@5).			(buttons at: 6) window: (0@0 extent: 13@5).			(buttons at: 7) window: (0@0 extent: 15@5).			(buttons at: 8) window: (0@0 extent: 13@5).			topWindow				addSubView: (buttons at: 1);				addSubView: (buttons at: 2) toRightOf: (buttons at: 1);				addSubView: (buttons at: 3) toRightOf: (buttons at: 2);				addSubView: (buttons at: 4) toRightOf: (buttons at: 3);				addSubView: (buttons at: 5) toRightOf: (buttons at: 4);				addSubView: (buttons at: 6) toRightOf: (buttons at: 5);				addSubView: (buttons at: 7) toRightOf: (buttons at: 6);				addSubView: (buttons at: 8) toRightOf: (buttons at: 7);				addSubView: (views at: 1) below: (buttons at: 1);				addSubView: (views at: 2) toRightOf: (views at: 1);				addSubView: (views at: 3) below: (views at: 1).			topWindow controller open].! !!Celeste class methodsFor: 'sending' stamp: 'jm 10/2/1998 16:24'!addMessageToInbox: msgString	"Append a copy of the given message to the inbox file."	self inform:'The "keep" feature is not yet implemented;please cc: yourself to retain a copy of your message.'! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 9/27/1998 21:34'!fullNamesOfAllFilesInSubtree	"Answer a collection containing the full names of all the files in the subtree of the file system whose root is this directory."	| result todo dir |	result _ OrderedCollection new: 100.	todo _ OrderedCollection with: self.	[todo size > 0] whileTrue: [		dir _ todo removeFirst.		dir fileNames do: [:n | result add: (dir fullNameFor: n)].		dir directoryNames do: [:n | todo add: (dir directoryNamed: n)]].	^ result asArray! !!IRCConnection methodsFor: 'access' stamp: 'jm 10/3/1998 08:37'!portAsString: aString	port _ aString asString asNumber.	DefaultPort _ port.	^ true! !!IRCConnection methodsFor: 'UI' stamp: 'jm 10/3/1998 08:43'!sendRawCommand: aString	"Send a command directly."	| message |	message _ [IRCProtocolMessage fromString: aString asString] ifError: [:a :b | nil].	message ifNil: [^ false].	self sendMessage: message.	^ true! !!IRCMorph methodsFor: 'interface' stamp: 'jm 10/3/1998 08:44'!sendCommand: aString	| message |	[message _ IRCProtocolMessage fromString: aString asString] ifError: [nil].	message ifNil: [^ false].	connection sendMessage: message.	^ true! !!IRCMorph methodsFor: 'access' stamp: 'jm 10/3/1998 08:37'!portAsString: aString	port _ aString asString asNumber.	DefaultPort _ port.	^ true! !!IndexFileEntry methodsFor: 'filtering support' stamp: 'jm 10/12/1998 09:34'!textHas: stringOrList	^ self field: self getMessage text has: stringOrList! !!JPEGReadWriter methodsFor: 'testing' stamp: 'jm 10/3/1998 08:33'!understandsImageFormat	"Answer true if the image stream format is understood by this decoder."	self next = 16rFF ifFalse: [^ false].	self next = 16rD8 ifFalse: [^ false].	^ true! !!MailDB reorganize!('initialize-release' close openOn:)('open-create-save' createDB dbStatus openDB recoverDB rootFilename saveDB)('fetch-import-export' fetchMailFromPOP:userName:password:doFormatting:deleteFromServer: fetchMessageCount:fromPOPConnection:doFormatting: fetchNewsFrom:doFormatting:deleteInbox: importMailFrom:intoCategory: mergeMessages:from: removeMessageCount:fromPOPConnection:)('housekeeping' appendMessages:messageFile:indexFile: cleanUpCategories compact copyUndeletedTo:indexFile: fileDuplicatesIn: findDuplicates nextUnusedID)('categories' addCategory: allCategories categoriesThatInclude: file:inCategory: fileAll:inCategory: messagesIn: remove:fromCategory: removeAll:fromCategory: removeCategory: removeFromAllCategories: renameCategory:to:)('messages' addNewMessage: delete: deleteAll: getMessage: getTOCentry: getTOCstring: getText: newText:for:)('printing' printOn:)('private')('fetch-merge-compact')!!MailDB methodsFor: 'open-create-save' stamp: 'jm 10/12/1998 13:53'!dbStatus	"See if my database exists. Since the database has several components, the answer is one of:	#exists				all files exist	#partialDatabase	only some of the files exist	#doesNotExist		none of the files exist"	| dir localName |	dir _ FileDirectory forFileName: rootFilename.	localName _ FileDirectory localNameFor: rootFilename.	messageFile _ dir includesKey: localName, '.messages'.	indexFile _ dir includesKey: localName, '.index'.	categoriesFile _ dir includesKey: localName, '.categories'.	(messageFile & indexFile & categoriesFile) ifTrue: [^ #exists].	(messageFile | indexFile | categoriesFile) ifFalse: [^ #doesNotExist].	^ #partialDatabase! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/2/1998 15:29'!fetchMailFromPOP: server userName: userName password: password doFormatting: doFormatting deleteFromServer: deleteFromServer	"Download mail from the given POP3 mail server and append it this mail database. Answer the number of messages fetched. If doFormatting is true, messages will be formatted as they are received. If deleteFromServer is true, then messages will be removed from the POP3 server after being successfully retrieved. (Note: If there is a failure while fetching mail, all messages will be left on the server.)"	| popConnection msgCount |	popConnection _ POPSocket createIfFail: [^ -1].	popConnection serverName: server;			userName: userName;		password: password;		addProgressObserver: Transcript.	Utilities		informUser: 'connecting to ', server		during: [popConnection connectToPOP].	popConnection isConnected ifFalse: [^ -1].	msgCount _ popConnection numMessages.	msgCount > 0 ifTrue: [		self fetchMessageCount: msgCount			fromPOPConnection: popConnection			doFormatting: doFormatting.		deleteFromServer ifTrue: [			self removeMessageCount: msgCount fromPOPConnection: popConnection]].	popConnection disconnectFromPOP.	^ msgCount! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/2/1998 16:10'!fetchMessageCount: msgCount fromPOPConnection: popConnection doFormatting: doFormatting	"Download the given number of messages from the given open POP3 connection. If doFormatting is true, messages will be formatted as they are received."	| nextID msgText msg location |	nextID _ self nextUnusedID.	messageFile beginAppend.	('Downloading ', msgCount printString, ' messages...')		displayProgressAt: Sensor mousePoint		from: 0		to: msgCount		during: [:progressBar |			1 to: msgCount do: [:messageNum |				progressBar value: messageNum.				popConnection isConnected ifFalse: [					popConnection destroy.  "network error"					messageFile endAppend.					LastID _ nextID.					self saveDB.					^ self inform: 'Server connection unexpectedly closed.'].				"get a message"				msgText _ popConnection retrieveMessage: messageNum.				"save that message"				msg _ MailMessage from: msgText.				doFormatting ifTrue: [msg format].				location _ messageFile basicAppend: msg text id: nextID.				indexFile					at: nextID					put: (IndexFileEntry						message: msg						location: location						messageFile: messageFile						msgID: nextID).				categoriesFile file: nextID inCategory: 'new'.				nextID _ nextID + 1]].	messageFile endAppend.	LastID _ nextID.	self saveDB.! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/2/1998 15:39'!importMailFrom: inboxFileName intoCategory: category	"Append the messages from the given mail file to this mail database, and store them in the given category. Answer the number of messages imported."	| inbox nextID count msg location |	inbox _ MailInboxFile openOn: inboxFileName.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox mailMessagesDo: [:msgText |		 msg _ MailMessage from: msgText.		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: category.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	self saveDB.	^ count! !!MailDB methodsFor: 'fetch-import-export' stamp: 'jm 10/2/1998 15:51'!removeMessageCount: msgCount fromPOPConnection: popConnection	"Remove messages 1 through msgCount from the given POP3 server."	('Removing ', msgCount printString, ' messages from the server...')		displayProgressAt: Sensor mousePoint		from: 0		to: msgCount		during: [:progressBar |			1 to: msgCount do: [:messageNum |				progressBar value: messageNum.				popConnection isConnected ifFalse: [					popConnection destroy.  "network error"					^ self inform: 'Server connection unexpectedly closed.'].				popConnection deleteMessage: messageNum]].! !!MailDB methodsFor: 'housekeeping' stamp: 'jm 10/4/1998 11:06'!nextUnusedID	"Answer the next unused message identifier. Message ID's are a monotonically increasing series roughly related to the time that they were requested. We use a block of message ID's based on the starting ID computed here. The last ID used is kept in LastID, to be sure that we don't reuse an already allocated ID."	| id |	"initialize LastID the first time it is used"	(LastID isNil) ifTrue: [LastID _ 0]. 	"message ID's are roughly the number of seconds since the beginning of 1980"	id _ Date today asSeconds + Time now asSeconds -		(Date newDay: 1 year: 1980) asSeconds.	id _ id max: (LastID + 1).  "never go backwards!!"	LastID _ id.	^ id! !!MailDB methodsFor: 'categories' stamp: 'jm 10/4/1998 11:16'!renameCategory: oldName to: newName	"Rename the given category. This does nothing if the category does not exist or if it is a special category ('.all.' or '.unclassified.')."	categoriesFile renameCategory: oldName to: newName.! !!MailDB methodsFor: 'messages' stamp: 'jm 10/4/1998 11:13'!addNewMessage: message	"Add the given message to the database, and answer its message id."	| id location |	id _ self nextUnusedID.	location _ messageFile append: message text id: id.	indexFile		at: id		put: (IndexFileEntry				message: message				location: location				messageFile: messageFile				msgID: id).	^ id! !!POPSocket reorganize!('initialization' addProgressObserver: initialize password: serverName: userName:)('low-level protocol' connectToPOP deleteAllMessages deleteMessage: disconnectFromPOP messagesDo: numMessages retrieveMessage:)('private' reportToObservers:)!!POPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/2/1998 16:05'!disconnectFromPOP	"Send a QUIT message, then disconnect."	self isValid ifFalse: [^ self].  "already closed"	self reportToObservers: 'closing connection'.	numMessages _ nil.	self sendCommand: 'QUIT'.	self reportToObservers: self getResponse.	self closeAndDestroy.! !!POPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/3/1998 07:55'!numMessages	"Query the server and answer the number of messages that are in the user's mailbox."	| response answerString |	numMessages ifNotNil: [^ numMessages].  "cached result of earlier query"	self sendCommand: 'STAT'.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [^ 0].  "error"	answerString _ (response findTokens: Character separators) second.	^ answerString asNumber asInteger! !!POPSocket class reorganize!('all' example getMessagesNotifying:andForEachDo:)!!PWS class methodsFor: 'Serving' stamp: 'jm 10/3/1998 08:48'!doBackupJobs	"This is just a wrapper so we don't have to restart the server loop when we add/remove jobs."	| problemReport |	BackupJobs do: [:block |		problemReport _ nil.		[block value] ifError: [:msg :rec |			problemReport _ '*** ', rec asString, ': ', msg asString].		problemReport ifNotNil: [^ problemReport]].	^ 'Backup jobs completed'! !!SMTPSocket commentStamp: '<historical>' prior: 0!This is used to post email messages to an SMTP server. See my class messages for examples of how to use it.!!SMTPSocket class reorganize!('sending mail' deliverMailFrom:to:text:usingServer:)('examples' example example2)('as yet unclassified')!!String class methodsFor: 'primitives' stamp: 'jm 10/12/1998 18:21'!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	<primitive: 245>	self var: #aCharacter declareC: 'int anInteger'.	self var: #aString declareC: 'unsigned char *aString'.	stringSize _ aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !Celeste removeSelector: #underConstruction!Celeste removeSelector: #fetchNews!Celeste removeSelector: #checkTrash!Celeste removeSelector: #setInOutFolder!Celeste class removeSelector: #postToUnixOutbox:!Celeste initialize!Celeste class removeSelector: #inOutFolder!Celeste class removeSelector: #popPassword!Celeste class removeSelector: #setInOutFolder!Celeste class removeSelector: #postToEudoraOutbox:!MailDB removeSelector: #fetchMailFrom:doFormatting:deleteInbox:!MailDB removeSelector: #POPMailFrom:userName:password:doFormatting:deleteInbox:informingUser:!MailDB removeSelector: #release!MailDB removeSelector: #addNewMessage:inCategory:!MailDB removeSelector: #do:andInform:!MailDB removeSelector: #showProgress:from:to:message:during:!SMTPSocket class removeSelector: #deliverMailTo:from:to:text:!