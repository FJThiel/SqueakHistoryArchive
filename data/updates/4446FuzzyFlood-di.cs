'From Squeak3.2alpha of 2 October 2001 [latest update: #4441] on 21 October 2001 at 9:51:43 pm'!"Change Set:		FuzzyFloodDate:			18 October 2001Author:			Dan IngallsIntroduces a new variant of the bitmap flood algorithm, designed to allow for minor variations of color.  This allows one to get reasonable behavior in, eg, images reconstructed from .jpeg files, and images taken from real life.  Two preferences, #areaFillsAreTolerant and #areaFillsAreVeryTolerant, govern the use of this feature.  They affect both flooding in the SketchEditor and grabbing the screen by flood area.I'm proud of this feature because it does not affect the flooding algorithm or its performance at all.  It simply makes the maze follower 'color blind' to minor variations in color by introducing a tweaked color map.Another feature is also added -- the ability to add a border to a sketchMroph.  This is located in the 'painting...' option of the SketchMorph menu.  It should be generalized in color but, hey, I've done the hard work ;-)."!!Form methodsFor: 'filling' stamp: 'di 10/20/2001 22:03'!floodFill: aColor at: interiorPoint	Preferences areaFillsAreVeryTolerant ifTrue:		[^ self floodFill: aColor at: interiorPoint tolerance: 0.2].	Preferences areaFillsAreTolerant ifTrue:		[^ self floodFill: aColor at: interiorPoint tolerance: 0.1].	^ self floodFill: aColor at: interiorPoint tolerance: 0! !!Form methodsFor: 'filling' stamp: 'di 10/20/2001 08:47'!floodFill: aColor at: interiorPoint tolerance: tolerance	"Fill the shape (4-connected) at interiorPoint.  The algorithm is based on Paul Heckbert's 'A Seed Fill Algorithm', Graphic Gems I, Academic Press, 1990.	NOTE (ar): This variant has been heavily optimized to prevent the overhead of repeated calls to BitBlt. Usually this is a really big winner but the runtime now depends a bit on the complexity of the shape to be filled. For extremely complex shapes (say, a Hilbert curve) with very few pixels to fill it can be slower than #floodFill2:at: since it needs to repeatedly read the source bits. However, in all practical cases I found this variant to be 15-20 times faster than anything else.	Further note (di):  I have added a feature that allows this routine to fill areas of approximately constant color (such as  photos, scans, and jpegs).  It does this by computing a color map for the peeker that maps all colors close to 'old' into colors identical to old.  This mild colorblindness achieves the desired effect with no further change or degradation of the algorithm.  tolerance should be 0 (exact match), or a value corresponding to those returned by Color>>diff:, with 0.1 being a reasonable starting choice."	| peeker poker stack old new x y top x1 x2 dy left goRight span spanBits w box debug |	debug _ false. "set it to true to see the filling process"	box _ interiorPoint extent: 1@1.	span _ Form extent: width@1 depth: 32.	spanBits _ span bits.	peeker _ BitBlt current toForm: span.	peeker 		sourceForm: self; 		combinationRule: 3; 		width: width; 		height: 1.	"read old pixel value"	peeker sourceOrigin: interiorPoint; destOrigin: interiorPoint x @ 0; width: 1; copyBits.	old _ spanBits at: interiorPoint x + 1.	"compute new value (take care since the algorithm will fail if old = new)"	new _ self privateFloodFillValue: aColor.	old = new ifTrue: [^ box].	tolerance > 0 ifTrue:		["Set up color map for approximate fills"		peeker colorMap: (self floodFillMapFrom: self to: span mappingColorsWithin: tolerance to: old)].	poker _ BitBlt current toForm: self.	poker 		fillColor: aColor;		combinationRule: 3;		width: width;		height: 1.	stack _ OrderedCollection new: 50.	x _ interiorPoint x.	y _ interiorPoint y.	(y >= 0 and:[y < height]) ifTrue:[		stack addLast: {y. x. x. 1}. "y, left, right, dy"		stack addLast: {y+1. x. x. -1}].	[stack isEmpty] whileFalse:[		debug ifTrue:[self displayOn: Display].		top _ stack removeLast.		y _ top at: 1. x1 _ top at: 2. x2 _ top at: 3. dy _ top at: 4.		y _ y + dy.		debug ifTrue:[			(Line from: (x1-1)@y to: (x2+1)@y 				withForm: (Form extent: 1@1 depth: 8) fillWhite) displayOn: Display].		"Segment of scanline (y-dy) for x1 <= x <= x2 was previously filled.		Now explore adjacent pixels in scanline y."		peeker sourceOrigin: 0@y; destOrigin: 0@0; width: width; copyBits.			"Note: above is necessary since we don't know where we'll end up filling"		x _ x1.		w _ 0.		[x >= 0 and:[(spanBits at: x+1) = old]] whileTrue:[			w _ w + 1.			x _ x - 1].		w > 0 ifTrue:[			"overwrite pixels"			poker destOrigin: x+1@y; width: w; copyBits.			box _ box quickMerge: ((x+1@y) extent: w@1)].		goRight _ x < x1.		left _ x+1.		(left < x1 and:[y-dy >= 0 and:[y-dy < height]]) 			ifTrue:[stack addLast: {y. left. x1-1. 0-dy}].		goRight ifTrue:[x _ x1 + 1].		[			goRight ifTrue:[				w _ 0.				[x < width and:[(spanBits at: x+1) = old]] whileTrue:[					w _ w + 1.					x _ x + 1].				w > 0 ifTrue:[					"overwrite pixels"					poker destOrigin: (x-w)@y; width: w; copyBits.					box _ box quickMerge: ((x-w@y) extent: w@1)].				(y+dy >= 0 and:[y+dy < height]) 					ifTrue:[stack addLast: {y. left. x-1. dy}].				(x > (x2+1) and:[y-dy >= 0 and:[y-dy >= 0]]) 					ifTrue:[stack addLast: {y. x2+1. x-1. 0-dy}]].			[(x _ x + 1) <= x2 and:[(spanBits at: x+1) ~= old]] whileTrue.			left _ x.			goRight _ true.		x <= x2] whileTrue.	].	^box! !!Form methodsFor: 'filling' stamp: 'di 10/20/2001 10:09'!floodFillMapFrom: sourceForm to: scanlineForm mappingColorsWithin: dist to: centerPixVal	"This is a helper routine for floodFill.  It's written for clarity (scanning the entire	map using colors) rather than speed (which would require hacking rgb components	in the nieghborhood of centerPixVal.  Note that some day a better proximity metric	would be (h s v) where tolerance could be reduced in hue."	| colorMap centerColor |	scanlineForm depth = 32 ifFalse: [self error: 'depth 32 assumed'].	"First get a modifiable identity map"	colorMap _ 	(Color cachedColormapFrom: sourceForm depth to: scanlineForm depth) copy.	centerColor _ Color colorFromPixelValue: (centerPixVal bitOr: 16rFFe6) depth: scanlineForm depth.	"Now replace all entries that are close to the centerColor"	1 to: colorMap size do:		[:i | ((Color colorFromPixelValue: ((colorMap at: i) bitOr: 16rFFe6) depth: scanlineForm depth)				diff: centerColor) <= dist ifTrue: [colorMap at: i put: centerPixVal]].	^ colorMap! !!Form methodsFor: 'bordering' stamp: 'di 10/21/2001 09:39'!shapeBorder: aColor width: borderWidth	"A simplified version for shapes surrounded by transparency (as SketchMorphs).	Note also this returns a new form that may be larger, and does not affect the original."	| shapeForm borderForm newForm |	newForm _ Form extent: self extent + (borderWidth*2) depth: self depth.	newForm fillColor: Color transparent.	self displayOn: newForm at: (0@0) + borderWidth.	"First identify the shape in question as a B/W form"	shapeForm _ (newForm makeBWForm: Color transparent) reverse.	"Now find the border of that shape"	borderForm _ shapeForm borderFormOfWidth: borderWidth sharpCorners: false.	"Finally use that shape as a mask to paint the border with color"	^ newForm fillShape: borderForm fillColor: aColor! !!Morph methodsFor: 'menus' stamp: 'di 10/20/2001 22:12'!addPaintingItemsTo: aMenu hand: aHandMorph	| subMenu movies |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'repaint' action: #editDrawing.	subMenu add: 'set rotation center' action: #setRotationCenter.	subMenu add: 'reset forward-direction' action: #resetForwardDirection.	subMenu add: 'set rotation style' action: #setRotationStyle.	subMenu add: 'erase pixels of color' action: #erasePixelsOfColor:.	subMenu add: 'recolor pixels of color' action: #recolorPixelsOfColor:.	subMenu add: 'reduce color palette' action: #reduceColorPalette:.	subMenu add: 'add a border around this shape...' action: #addBorderToShape:.	movies _		(self world rootMorphsAt: aHandMorph targetOffset)			select: [:m | (m isKindOf: MovieMorph) or:						[m isKindOf: SketchMorph]].	(movies size > 1) ifTrue:		[subMenu add: 'insert into movie' action: #insertIntoMovie:].	aMenu add: 'painting...' subMenu: subMenu! !!SketchMorph methodsFor: 'accessing' stamp: 'di 10/21/2001 21:33'!form: aForm	| oldForm |	oldForm _ originalForm.	originalForm _ aForm.	self rotationCenter: 0.5@0.5.	self layoutChanged.	oldForm ifNotNil: [self position: self position + (oldForm extent - aForm extent // 2)].! !!SketchMorph methodsFor: 'menu' stamp: 'di 10/21/2001 09:36'!addBorderToShape: evt	| str borderWidth borderedForm r |	str _ FillInTheBlank		request: 'Please enter the desired border width'		initialAnswer: '0'.	borderWidth _ Integer readFrom: (ReadStream on: str).	(borderWidth between: 1 and: 10) ifFalse: [^ self].	"Take care of growing appropriately.  Does this lose the reg point?"	borderedForm _ originalForm shapeBorder: Color black width: borderWidth.	r _ borderedForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (borderedForm copy: r).! !"Postscript:Init preferences for new fuzzyFlood."Preferences addPreference: #areaFillsAreTolerant category: #morphic default: false balloonHelp: 'If true, area fills by flooding (used in the paint tool and grab flood area) will be tolerant of minor variations from the color at the seed location.  If neither this nor the veryTolerant preference is set, only regions of identical color will be flooded.'.Preferences addPreference: #areaFillsAreVeryTolerant category: #morphic default: false balloonHelp: 'If true, area fills by flooding (used in the paint tool and grab flood area) will be tolerant of significant variations from the color at the seed location.  This setting overrides the normally Tolerant setting.'.!