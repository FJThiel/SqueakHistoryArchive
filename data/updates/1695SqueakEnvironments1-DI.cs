'From Squeak2.6 of 11 October 1999 [latest update: #1693] on 6 December 1999 at 1:49:17 pm'!"Change Set:		SqueakEnvironments1Date:			28 November 1999Author:			Dan Ingalls[X]	Adds 'environment' and 'category' to all classes[X]	Makes cachedClassNames be an instVar of SystemDictionary.[X]	Defines a new class Environment -- (see class comment)[X]	Define doesNotUnderstand: for Environments so they can find things before they have been defined as exports (via messages).[X]	Refactors the SystemOrganization so it can easily be grouped...		Kernel (incl numbers)		Collections		Graphics		Tools (used to be called interface)		System (incl files)		--------------		ST80 (old MVC stuff)		Morphic		Sound		Network		Postscript		Squeak (VM support stuff)		Balloon (incl Flash and TT)		Baloon3D (incl Alice, Wonderland and VRML)Above the line are only distinctions in the system organization -- all those classes are still in the environment called Smalltalk.  Below the line, each category is its own environment (dictionary like Smalltalk).[X]	Defines Smalltalk reorganizeEverything.  This converts the old Smaalltalk SystemDictionary to a sub instance of Environment.  Then it runs through SystemOrganization making up a new Environment for each non-kernel major category.  Moves the class associations into the envt, and points the class's environment slot at its new home.[X]	Adds the capability to the parser to track source code locations of variable references (it used to do this only for complete messages).[X]	Defines Smalltalk rewriteIndirectReferences.  This rumbles through every method in the system identifying those that make global references that are out of their new direct access scope.  For each of these (there are about 340 of them), it parses them with the compiler in 'lenient' mode (will resolve references out of scope) to determine the exact source code location of the each reference.  With these as a guide, and knowing the name of the dictionary in which the remote reference can be found, it updates the source code and recompiles it with proper remote reference patterns.[X]	In the process, it also adds the proper export methods to the environments being so accessed."!PopUpMenu notify: 'You should proceed through the coming notifier.Your system will then grind for 10 minutes or so.Have faith.  It will finish.'!ClassDescription subclass: #Class	instanceVariableNames: 'subclasses name classPool sharedPools environment category '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!ParseNode subclass: #Encoder	instanceVariableNames: 'scopeTable nTemps supered requestor class literalStream selectorSet litIndSet litSet sourceRanges globalSourceRanges '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!IdentityDictionary subclass: #SystemDictionary	instanceVariableNames: 'cachedClassNames '	classVariableNames: 'LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore ShutDownList SpecialSelectors StartUpList SystemChanges '	poolDictionaries: ''	category: 'System-Support'!SystemDictionary subclass: #Environment	instanceVariableNames: 'outerEnvt '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!Environment subclass: #SmalltalkEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Environments'!ClassOrganizer subclass: #SystemOrganizer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!!Class methodsFor: 'compiling' stamp: 'di 12/4/1999 07:18'!canFindWithoutEnvironment: varName	"This method is used for analysis of system structure -- see senders."	"Look up varName, in the context of the receiver. Return true if it can be found without using the declared environment."	| assoc |	"First look in classVar dictionary."	(assoc _ self classPool associationAt: varName ifAbsent: []) == nil		ifFalse: [^ true].	"Next look in shared pools."	self sharedPools do: 		[:pool | 		assoc _ pool associationAt: varName ifAbsent: [			"Hideous string key hack from Hypersqueak now used in Wonderland"			pool associationAt: varName asString ifAbsent: []].		assoc == nil ifFalse: 				[^ true]].	"Finally look higher up the superclass chain and fail at the end."	superclass == nil		ifTrue: [^ false]		ifFalse: [^ superclass scopeHas: varName ifTrue: [:ignored]].! !!Class methodsFor: 'compiling' stamp: 'di 12/4/1999 16:51'!scopeHas: varName ifTrue: assocBlock	"Look up the first argument, varName, in the context of the receiver. If it is there,	pass the association to the second argument, assocBlock, and answer true."	| assoc |	"First look in classVar dictionary."	(assoc _ self classPool associationAt: varName ifAbsent: []) == nil		ifFalse: [assocBlock value: assoc.				^ true].	"Next look in shared pools."	self sharedPools do: 		[:pool | 		assoc _ pool associationAt: varName ifAbsent: [			"String key hack from Hypersqueak now used in Wonderland  **Eliminate this**"			pool associationAt: varName asString ifAbsent: []].		assoc == nil ifFalse: 				[assocBlock value: assoc.				^true]].	"Next look in declared environment."	(assoc _ self environment associationAtOrAbove: varName ifAbsent: [nil]) == nil		ifFalse: [assocBlock value: assoc.				^ true].	"Finally look higher up the superclass chain and fail at the end."	superclass == nil		ifTrue: [^ false]		ifFalse: [^ superclass scopeHas: varName ifTrue: assocBlock].! !!Class methodsFor: 'organization' stamp: 'di 11/16/1999 16:22'!category	category == nil ifTrue: [^ super category].	^ category! !!Class methodsFor: 'organization' stamp: 'di 11/16/1999 16:25'!environment	environment == nil ifTrue: [^ super environment].	^ environment! !!Class methodsFor: 'organization' stamp: 'di 11/16/1999 16:21'!environment: aPackage category: aSymbol	"Smalltalk allClassesDo: [:c | c environment: Smalltalk category: c category]."	environment _ aPackage.	category _ aSymbol! !!ClassBuilder methodsFor: 'class definition' stamp: 'di 11/28/1999 21:02'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force |	environ _ env.	instVars _ Scanner new scanFieldNames: instVarString.	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass _ env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: newSuper 		type: type 		instanceVariables: instVars		from: oldClass		unsafe: unsafe.	newClass == nil ifTrue:[^nil]. "Some error"	newClass == oldClass ifFalse:[newClass setName: className].	"Install the class variables and pool dictionaries... "	force _ (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	organization _ environ ifNotNil:[environ organization].	newClass environment: environ category: category asSymbol.	organization classify: newClass name under: newClass category.	"... recompile ..."	newClass _ self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		environ at: newClass name put: newClass.		Smalltalk flushClassNameCache.	].	"... and fix eventual references to obsolete globals."	oldClass _ nil. "So we have no references to the old class anymore"	self fixGlobalReferences.	self doneCompiling: newClass.	^newClass! !!ClassOrganizer methodsFor: 'accessing' stamp: 'di 12/2/1999 20:36'!changeFromCategorySpecs: categorySpecs 	"Tokens is an array of categorySpecs as scanned from a browser 'reorganize' pane, or built up by some other process, such as a scan of an environment."	| oldElements newElements newCategories newStops currentStop temp ii cc catSpec |	oldElements _ elementArray asSet.	newCategories _ Array new: categorySpecs size.	newStops _ Array new: categorySpecs size.	currentStop _ 0.	newElements _ WriteStream on: (Array new: 16).	1 to: categorySpecs size do: 		[:i | 		catSpec _ categorySpecs at: i.		newCategories at: i put: catSpec first asSymbol.		catSpec allButFirst asSortedCollection do:			[:elem |			(oldElements remove: elem ifAbsent: [nil]) notNil ifTrue:				[newElements nextPut: elem.				currentStop _ currentStop+1]].		newStops at: i put: currentStop].	"Ignore extra elements but don't lose any existing elements!!"	oldElements _ oldElements collect:		[:elem | Array with: (self categoryOfElement: elem) with: elem].	newElements _ newElements contents.	categoryArray _ newCategories.	(cc _ categoryArray asSet) size = categoryArray size ifFalse: ["has duplicate element"		temp _ categoryArray asOrderedCollection.		temp removeAll: categoryArray asSet asOrderedCollection.		temp do: [:dup | 			ii _ categoryArray indexOf: dup.			[dup _ (dup,' #2') asSymbol.  cc includes: dup] whileTrue.			cc add: dup.			categoryArray at: ii put: dup]].	categoryStops _ newStops.	elementArray _ newElements.	oldElements do: [:pair | self classify: pair last under: pair first].! !!ClassOrganizer methodsFor: 'accessing' stamp: 'di 12/2/1999 10:54'!changeFromString: aString 	"Parse the argument, aString, and make this be the receiver's structure."	| categorySpecs |	categorySpecs _ Scanner new scanTokens: aString.	"If nothing was scanned and I had no elements before, then default me"	(categorySpecs isEmpty and: [elementArray isEmpty])		ifTrue: [^ self setDefaultList: Array new].	^ self changeFromCategorySpecs: categorySpecs! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'di 11/28/1999 20:59'!checkVariables	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it.  	DeepCopier new checkVariables	"	| str str2 meth |	str _ '|veryDeepCopyWith: or veryDeepInner: is out of date.'.	Object instSize = 0 ifFalse: [self error: 'Many implementers of veryDeepCopyWith: are out of date'].	Morph superclass == Object ifFalse: [self error: 'Morph', str].	(Morph instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 			'fullBounds' 'color' 'extension') 		ifFalse: [self error: 'Morph', str].	"added ones are OK"	"Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  So check that the last one is mentioned in the copy method."	(Smalltalk allClassesImplementing: #veryDeepInner:) do: [:aClass | 		((aClass compiledMethodAt: #veryDeepInner:) writesField: aClass instSize) ifFalse: [			aClass instSize > 0 ifTrue: [				self warnIverNotCopiedIn: aClass sel: #veryDeepInner:]]].	(Smalltalk allClassesImplementing: #veryDeepCopyWith:) do: [:aClass | 		meth _ aClass compiledMethodAt: #veryDeepCopyWith:.		(meth size > 20) & (meth literals includes: #veryDeepCopyWith:) not ifTrue: [			(meth writesField: aClass instSize) ifFalse: [				self warnIverNotCopiedIn: aClass sel: #veryDeepCopyWith:]]].	str2 _ 'Player|copyUniClass and DeepCopier|mapUniClasses are out of date'.	Behavior instVarNames = #('superclass' 'methodDict' 'format' )		ifFalse: [self error: str2].	ClassDescription instVarNames = #('instanceVariables' 'organization' )		ifFalse: [self error: str2].	Class instVarNames = #('subclasses' 'name' 'classPool' 'sharedPools' 'environment' 'category' )		ifFalse: [self error: str2].	Model superclass == Object ifFalse: [self error: str2].	Player superclass == Model ifFalse: [self error: str2].	Model class instVarNames = #() ifFalse: [self error: str2].	Player class instVarNames = #('scripts' 'slotInfo')		ifFalse: [self error: str2].! !!Encoder methodsFor: 'initialize-release' stamp: 'di 12/4/1999 22:22'!init: aClass context: aContext notifying: req	| node n homeNode indexNode |	requestor _ req.	class _ aClass.	nTemps _ 0.	supered _ false.	self initScopeAndLiteralTables.	n _ -1.	class allInstVarNames do: 		[:variable | 		node _ VariableNode new					name: variable					index: (n _ n + 1)					type: LdInstType.		scopeTable at: variable put: node].	aContext == nil		ifFalse: 			[homeNode _ self bindTemp: 'homeContext'.			"first temp = aContext passed as arg"			n _ 0.			aContext tempNames do: 				[:variable | 				indexNode _ self encodeLiteral: (n _ n + 1).				node _ MessageAsTempNode new							receiver: homeNode							selector: #tempAt:							arguments: (Array with: indexNode)							precedence: 3							from: self.				scopeTable at: variable put: node]].	sourceRanges _ Dictionary new: 32.	globalSourceRanges _ OrderedCollection new: 32.! !!Encoder methodsFor: 'encoding' stamp: 'di 12/4/1999 22:39'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode _ scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode _ self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [action value]].	name first isUppercase ifTrue:		[globalSourceRanges addLast: { name. range. false }].	^ varNode! !!Encoder methodsFor: 'encoding' stamp: 'di 12/4/1999 20:09'!encodeVariable: name	^ self encodeVariable: name sourceRange: nil ifUnknown: [ self undeclared: name ]! !!Encoder methodsFor: 'source mapping' stamp: 'di 12/4/1999 22:27'!globalSourceRanges	^ globalSourceRanges! !!Encoder methodsFor: 'private' stamp: 'di 12/4/1999 16:51'!lookupInPools: varName ifFound: assocBlock	Symbol hasInterned: varName ifTrue:		[:sym | (class scopeHas: sym ifTrue: assocBlock) ifTrue: [^ true].		(Preferences valueOfFlag: #lenientScopeForGlobals)  "**Temporary**"			ifTrue: [^ Smalltalk lenientScopeHas: sym ifTrue: assocBlock]			ifFalse: [^ false]].	^ class scopeHas: varName ifTrue: assocBlock.  "Maybe a string in a pool  **Eliminate this**"! !!IdentityDictionary methodsFor: 'private' stamp: 'di 12/1/1999 20:54'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock." 	self associationsDo: 		[:association | value == association value ifTrue: [^ association key]].	^ exceptionBlock value! !!Interpreter methodsFor: 'image segment in/out' stamp: 'tk 12/3/1999 14:41'!primitiveLoadImageSegment	"This primitive is called from Squeak as...		<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray.""This primitive will load a binary image segment created by primitiveStoreImageSegment.  It expects the outPointer array to be of the proper size, and the wordArray to be well formed.  It will return as its value the original array of roots, and the erstwhile segmentWordArray will have been truncated to a size of zero.  If this primitive should fail, the segmentWordArray will, sadly, have been reduced to an unrecognizable and unusable jumble.  But what more could you have done with it anyway?"	| outPointerArray segmentWordArray endSeg segOop fieldPtr fieldOop doingClass lastPtr extraSize mapOop lastOut outPtr hdrTypeBits header data |	DoAssertionChecks ifTrue: [self verifyCleanHeaders].	outPointerArray _ self stackValue: 0.	lastOut _ outPointerArray + (self lastPointerOf: outPointerArray).	segmentWordArray _ self stackValue: 1.	endSeg _ segmentWordArray + (self sizeBitsOf: segmentWordArray) - BaseHeaderSize.	"Essential type checks"	((self formatOf: outPointerArray) = 2				"Must be indexable pointers"		and: [(self formatOf: segmentWordArray) = 6])	"Must be indexable words"		ifFalse: [^ self primitiveFail].	"Version check.  Byte order of the WordArray now"	data _ self longAt: segmentWordArray + BaseHeaderSize.	(self readableFormat: (data bitAnd: 16rFFFF "low 2 bytes")) ifFalse: [		"Not readable -- try again with reversed bytes..."		self reverseBytesFrom: segmentWordArray + BaseHeaderSize to: endSeg + 4.		data _ self longAt: segmentWordArray + BaseHeaderSize.		(self readableFormat: (data bitAnd: 16rFFFF "low 2 bytes")) ifFalse: [			"Still NG -- put things back and fail"			self reverseBytesFrom: segmentWordArray + BaseHeaderSize to: endSeg + 4.			DoAssertionChecks ifTrue: [self verifyCleanHeaders].			^ self primitiveFail]].	"Reverse the Byte type objects if the data from opposite endian machine"	"Test top byte.  $d on the Mac or $s on the PC.  Rest of word is equal"	data = self imageSegmentVersion ifFalse: [		"Reverse the byte-type objects once"		segOop _ self oopFromChunk: segmentWordArray + BaseHeaderSize + 4.			 "Oop of first embedded object"		self byteSwapByteObjectsFrom: segOop to: endSeg + 4].	"Proceed through the segment, remapping pointers..."	segOop _ self oopFromChunk: segmentWordArray + BaseHeaderSize + 4.	[segOop <= endSeg] whileTrue:		[(self headerType: segOop) <= 1			ifTrue: ["This object has a class field (type = 0 or 1) -- start with that."					fieldPtr _ segOop - 4.  doingClass _ true]			ifFalse: ["No class field -- start with first data field"					fieldPtr _ segOop + BaseHeaderSize.  doingClass _ false].		lastPtr _ segOop + (self lastPointerOf: segOop).	"last field"		lastPtr > endSeg ifTrue: [			DoAssertionChecks ifTrue: [self verifyCleanHeaders].			^ self primitiveFail "out of bounds"].		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop _ self longAt: fieldPtr.			doingClass ifTrue:				[hdrTypeBits _ self headerType: fieldPtr.				fieldOop _ fieldOop - hdrTypeBits].			(self isIntegerObject: fieldOop)				ifTrue:					["Integer -- nothing to do"					fieldPtr _ fieldPtr + 4]				ifFalse:					[(fieldOop bitAnd: 3) = 0 ifFalse: [^ self primitiveFail "bad oop"].					(fieldOop bitAnd: 16r80000000) = 0						ifTrue: ["Internal pointer -- add segment offset"								mapOop _ fieldOop + segmentWordArray]						ifFalse: ["External pointer -- look it up in outPointers"								outPtr _ outPointerArray + (fieldOop bitAnd: 16r7FFFFFFF).								outPtr > lastOut ifTrue: [^ self primitiveFail "out of bounds"].								mapOop _ self longAt: outPtr].					doingClass						ifTrue: [self longAt: fieldPtr put: mapOop + hdrTypeBits.								fieldPtr _ fieldPtr + 8.								doingClass _ false]						ifFalse: [self longAt: fieldPtr put: mapOop.								fieldPtr _ fieldPtr + 4].					segOop < youngStart						ifTrue: [self possibleRootStoreInto: segOop value: mapOop].					]].		segOop _ self objectAfter: segOop].	"Again, proceed through the segment checking consistency..."	segOop _ self oopFromChunk: segmentWordArray + BaseHeaderSize + 4.	[segOop <= endSeg] whileTrue:		[(self oopHasOKclass: segOop) ifFalse: [^ self primitiveFail "inconsistency"].		fieldPtr _ segOop + BaseHeaderSize.		"first field"		lastPtr _ segOop + (self lastPointerOf: segOop).	"last field"		"Go through all oops, remapping them..."		[fieldPtr > lastPtr] whileFalse:			["Examine each pointer field"			fieldOop _ self longAt: fieldPtr.			(self oopHasOKclass: fieldOop) ifFalse: [^ self primitiveFail "inconsistency"].			fieldPtr _ fieldPtr + 4].		segOop _ self objectAfter: segOop].	"Truncate the segment word array to size = 4 (vers stamp only)"	extraSize _ self extraHeaderBytes: segmentWordArray.	hdrTypeBits _ self headerType: segmentWordArray.	extraSize = 8		ifTrue: [self longAt: segmentWordArray-extraSize put: BaseHeaderSize + 4 + hdrTypeBits]		ifFalse: [header _ self longAt: segmentWordArray.				self longAt: segmentWordArray					put: header - (header bitAnd: SizeMask) + BaseHeaderSize + 4].		"and return the roots array which was first in the segment"	DoAssertionChecks ifTrue: [self verifyCleanHeaders].	self pop: 3 thenPush: (self oopFromChunk: segmentWordArray + BaseHeaderSize + 4).! !!MessageSet class methodsFor: 'instance creation' stamp: 'di 12/1/1999 20:15'!parse: messageString toClassAndSelector: csBlock	"Decode strings of the form <className> [class] <selectorName>."	| tuple cl |	tuple _ messageString findTokens: ' .'.	cl _ Smalltalk atOrBelow: tuple first asSymbol ifAbsent: [self error: 'key not found'].	(tuple size = 2 or: [tuple size > 2 and: [(tuple at: 2) ~= 'class']])		ifTrue: [^ csBlock value: cl value: (tuple at: 2) asSymbol]		ifFalse: [^ csBlock value: cl class value: (tuple at: 3) asSymbol]! !!Parser methodsFor: 'expression types' stamp: 'di 12/4/1999 21:04'!variable	| varName varStart varEnd |	varStart _ self startOfNextToken + requestorOffset.	varName _ self advance.	varEnd _ self endOfLastToken + requestorOffset.	^ encoder encodeVariable: varName		sourceRange: (varStart to: varEnd)		ifUnknown: [self correctVariable: varName interval: (varStart to: varEnd)]! !!Preferences reorganize!('look in class' seeClassSide)!!Preferences methodsFor: 'look in class' stamp: 'di 12/4/1999 15:11'!seeClassSide	"All the code for Preferences is on the class side"! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/6/1999 12:42'!associationAtOrAbove: varName ifAbsent: absentBlock 	"Compatibility with environment protocol."	^ self associationAt: varName ifAbsent: absentBlock! !!SystemDictionary methodsFor: 'class names' stamp: 'di 11/16/1999 12:44'!classNames	"Answer a SortedCollection of all class names."	| names |	cachedClassNames == nil ifTrue:		[names _ OrderedCollection new: self size.		self do: 			[:cl | (cl isInMemory and: [(cl isKindOf: Class) and: [(cl name beginsWith: 'AnObsolete') not]])				ifTrue: [names add: cl name]].		cachedClassNames _ names asSortedCollection].	^ cachedClassNames! !!SystemDictionary methodsFor: 'class names' stamp: 'di 11/16/1999 12:44'!flushClassNameCache	"This is an implementation efficiency: the collection of class names is 	saved as a class variable and recomputed whenever the collection is 	needed but has been previously flushed (set to nil).  Last touched sw 8/91"	"Smalltalk flushClassNameCache"	cachedClassNames _ nil! !!Environment commentStamp: 'di 12/2/1999 16:16' prior: 0!Environments are used to provide separate name spaces in Squeak.  Each one operates pretty much the same way that the Smalltalk systemDictionary is used in a non-partitioned Squeak.Each class has a direct-access environment in which it is compiled.  Its environment slot points to an instance of this class, and it is there where the bindings of global variables are sought.  The compiler looks up these bindings using normal dictionary protocol (at:, etc).  If a binding is not found, then the name is looked up in the environment from which that one inherits, if any.  In this way a class may be compiled in a context that consists of several nested name spaces, and direct reference may be made to any of the objects resident in those spaces.Various methods may need to refer to objects that reside in environnments that are not a part of their direct-access environment.  For these references, a simple global reference,	Thingmay not be used, and instead the construct,	Envt Thingmust be used.  In this case Envt is a gloabl reference to another environment, and the global name, Thing, is sent as a message to that environment.Obviously, such a foreign reference cannot be resolved unless the environment in question implements a method of that name.  This is how environmental variables are exported.Each environment has its own unique class.  With this structure, each environment can have its own instance-specific messeages to provide access to its exported symbols.  Note that this mechanism provides much faster runtime access than the Dictionary at: protocol.  Also note that inheritance provides a trivial implementation of nested name scope by the same token.In the early stages of installing partitioned environments in Squeak, interpreted access will be provided in several ways.  To begin with, environments will intercept the doesNotUnderstand: message and, if the message begins with a capital letter, it will look up the corresponding name using #at:, and return the value if found.  A refinement to this feature will be to compile an export method on the spot, so that subsequent accesses to that variable run much faster.Note that there is no Environmental access pattern analogous to 'Envt Thing'.  If an implementor wishes to store into environmental variables, he must do so by defining, eg, a SetThingTo: method and using a call to that method in his code.  We may choose to only allow one certain pattern of access to be compiled in any subclass of Environment to enforce some understandable style of coding.!!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/2/1999 15:54'!allClassesAnywhereDo: classBlock	| cl |	self deepAssociationsDo:		[:assn | cl _ assn value.		(cl isKindOf: Class) ifTrue: [classBlock value: cl]]! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/2/1999 19:57'!associationAtOrAbove: key ifAbsent: absentBlock	"Look up an association with this key here or in an outer environment."	^ super associationAt: key ifAbsent:		[outerEnvt ifNil: [^ absentBlock value].		^ outerEnvt associationAtOrAbove: key ifAbsent: absentBlock]! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/2/1999 20:55'!at: key	"Compatibility hack for starting up Environments"	^ self atOrBelow: key ifAbsent: [self errorKeyNotFound]! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/1/1999 20:37'!atOrAbove: key ifAbsent: absentBlock	"Look up the value iof this key here or in an outer environment."	^ super at: key ifAbsent:		[outerEnvt ifNil: [^ absentBlock value].		^ outerEnvt atOrAbove: key ifAbsent: absentBlock]! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/1/1999 20:14'!atOrBelow: key ifAbsent: absentBlock	| envt value maybe |	"Compatibility hack -- find things in sub environments for now"	^ super at: key ifAbsent:		[self associationsDo:			[:assn | (((envt _ assn value) isKindOf: Environment) and: [envt ~~ self])				ifTrue: [maybe _ true.						value _ envt atOrBelow: key ifAbsent: [maybe _ false].						maybe ifTrue: [^ value]]].		^ absentBlock value]! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/4/1999 14:26'!browseIndirectRefs  "Smalltalk browseIndirectRefs"	| cm lits browseList foundOne allClasses n |	browseList _ OrderedCollection new.	allClasses _ OrderedCollection new.	Smalltalk allClassesAnywhereDo: [:cls | allClasses addLast: cls].	'Locating methods with indirect global references...'		displayProgressAt: Sensor cursorPoint		from: 0 to: allClasses size		during:		[:bar | n _ 0.		allClasses do:			[:cls | bar value: (n_ n+1).			{ cls. cls class } do:				[:cl | cl selectors do:					[:sel | cm _ cl compiledMethodAt: sel.					lits _ cm literals.					foundOne _ false.					lits do:						[:lit | lit class == Association ifTrue:							[(lit value == cl or: [cl scopeHas: lit key ifTrue: [:ignored]])								ifFalse: [foundOne _ true]]].					foundOne ifTrue: [browseList add: cl name , ' ' , sel]]]]].	Smalltalk browseMessageList: browseList asSortedCollection		name: 'Indirect Global References' autoSelect: nil! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/2/1999 19:07'!deepAssociationsDo: assnBlock	"Compatibility hack -- find things in sub environments for now"	| envt |	self associationsDo:		[:assn |		(((envt _ assn value) isKindOf: Environment) and: [envt ~~ self])			ifTrue: [envt deepAssociationsDo: assnBlock]			ifFalse: [assnBlock value: assn]]! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/1/1999 20:24'!doesNotUnderstand: message	message selector first isUppercase ifFalse: [^ super doesNotUnderstand: message].	(message selector includes: $:) ifTrue: [^ super doesNotUnderstand: message].	^ self atOrAbove: message selector ifAbsent: [^ super doesNotUnderstand: message]! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/5/1999 11:58'!exportMethodFor: varName	^ varName , '	"Automatically generated during environmental reorganization"	^ ' , varName ! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/4/1999 15:41'!lenientScopeHas: varName ifTrue: assocBlock	"Compatibility hack -- find things in sub environments for now"	| assoc envt |	(assoc _ self associationAt: varName ifAbsent: []) == nil		ifFalse: [assocBlock value: assoc.				^ true].	self associationsDo:		[:assn | (((envt _ assn value) isKindOf: Environment) and: [envt ~~ self])			ifTrue: [(envt lenientScopeHas: varName ifTrue: assocBlock)						ifTrue: [^ true]]].	^ false! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/5/1999 12:04'!makeSubEnvironmentNamed: name	| envtClass envt |	envtClass _ self class subclass: (name , 'Environment') asSymbol				instanceVariableNames: '' classVariableNames: ''				poolDictionaries: '' category: 'System-Environments'.	self at: name asSymbol put: (envt _ envtClass new setOuterEnvt: self).	^ envt! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/1/1999 21:06'!printOn: aStream	| name |	aStream nextPutAll: 'An Environment'.	name _ Smalltalk keyAtValue: self ifAbsent: [nil].	name ifNotNil: [aStream nextPutAll: ' named ' , name]! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/2/1999 20:38'!rebuildSystemOrganization	| cl catList catDict |	"Eventually SystemOrganization should just go away.	For now we'll keep it up to date for compatibility."	catDict _ Dictionary new.	self deepAssociationsDo:		[:assn | (assn value isKindOf: Class) ifTrue:			[cl _ assn value.			catList _ catDict at: cl category					ifAbsent: [catDict at: cl category put: (OrderedCollection new: 20)].			catList addLast: cl name]].	SystemOrganization changeFromCategorySpecs: 		(catDict keys asSortedCollection collect:			[:key | (Array with: key) , (catDict at: key)])! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/4/1999 21:12'!rewriteIndirectRefs   "Smalltalk rewriteIndirectRefs"	"For all classes, identify all methods with references to globals outside their direct access path.	For each of these, call another method to rewrite the source with proper references."	| cm lits envtForVar envt foundOne allClasses n |	envtForVar _ Dictionary new.  "Dict of varName -> envt name"	Smalltalk associationsDo:		[:assn | (((envt _ assn value) isKindOf: Environment) and: [envt size < 500])			ifTrue: [envt associationsDo:						[:a | envtForVar at: a key put: assn key]]].	"Allow compiler to compile refs to globals out of the direct reference path"	Preferences enable: #lenientScopeForGlobals.	allClasses _ OrderedCollection new.	Smalltalk allClassesAnywhereDo: [:cls | allClasses addLast: cls].	'Updating indirect global references in source code...'		displayProgressAt: Sensor cursorPoint		from: 0 to: allClasses size		during:		[:bar | n _ 0.		allClasses do:			[:cls | bar value: (n_ n+1).			{ cls. cls class } do:				[:cl | cl selectors do:					[:sel | cm _ cl compiledMethodAt: sel.					lits _ cm literals.					foundOne _ false.					lits do:						[:lit | lit class == Association ifTrue:							[(lit value == cl or: [cl scopeHas: lit key ifTrue: [:ignored]])								ifFalse: [foundOne _ true]]].					foundOne ifTrue:						[self rewriteSourceForSelector: sel inClass: cl using: envtForVar]]].			]].	Preferences disable: #lenientScopeForGlobals.! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/5/1999 11:55'!rewriteSourceForSelector: selector inClass: aClass using: envtForVar	"Rewrite the source code for the method in question so that all global references out of the direct access path are converted to indirect global references.  This is done by parsing the source with a lenient parser able to find variables in any environment.  Then the parse tree is consulted for the source code ranges of each reference that needs to be rewritten and the pattern to which it should be rewritten.  Note that assignments, which will take the form	envt setValueOf: #GlobalName to: ...may generate spurious message due to agglutination of keywords with the value expression."	| code methodNode edits varName envtName envt |	code _ aClass sourceCodeAt: selector.	methodNode _ Compiler new parse: code in: aClass notifying: nil.	edits _ OrderedCollection new.	methodNode encoder globalSourceRanges do:		[:tuple |   "{ varName. srcRange. store }"		(aClass scopeHas: (varName _ tuple first asSymbol) ifTrue: [:ignored]) ifFalse:			["This is a remote global.  Add it as reference to be edited."			edits addLast: { varName. tuple at: 2. tuple at: 3 }]].	"Sort the edits by source position."	edits _ edits asSortedCollection: [:a :b | a second first < b second first].	edits reverseDo:		[:edit | varName _ edit first.		envtName _ envtForVar at: varName.		"Replace each access out of scope with a proper remote reference"		code _ code copyReplaceFrom: edit second first					to: edit second last					with: envtName , ' ' , varName.		"If varName is not already exported, define an export method"		envt _ self at: envtName.		(envt class includesSelector: varName) ifFalse:			[envt class compile: (self exportMethodFor: varName)					 classified: 'exports']].	aClass compile: code classified: (aClass organization categoryOfElement: selector)! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/1/1999 20:39'!setOuterEnvt: outer	outerEnvt _ outer! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/4/1999 14:28'!tallyIndirectRefs   "Smalltalk tallyIndirectRefs"	"For all classes, tally the number of references to globals outside their inherited environment.  Then determine the 'closest' environment that resolves most of them.  If the closest environment is different from the one in whick the class currently resides, then enter the class name with the tallies of its references to all other environments.	Return a triplet:	A dictionary of all classes for which this is so, with those tallies,	A dictionary giving the classes that would be happier in each of the other categories,	A list of the variable names sorted by number of occurrences."	| tallies refs cm lits envtForVar envt envtRefs allRefs newCategories cat allClasses n |	envtForVar _ Dictionary new.  "Dict of varName -> envt name"	allRefs _ Bag new.	Smalltalk associationsDo:		[:assn | (((envt _ assn value) isKindOf: Environment) and: [envt size < 500])			ifTrue: [envt associationsDo:						[:a | envtForVar at: a key put: assn key]]].	tallies _ Dictionary new.	allClasses _ OrderedCollection new.	Smalltalk allClassesAnywhereDo: [:cls | allClasses addLast: cls].	'Scanning methods with indirect global references...'		displayProgressAt: Sensor cursorPoint		from: 0 to: allClasses size		during:		[:bar | n _ 0.		allClasses do:			[:cls | bar value: (n_ n+1).			refs _ Set new.			{ cls. cls class } do:			[:cl | cl selectors do:				[:sel | cm _ cl compiledMethodAt: sel.				lits _ cm literals.				lits do:					[:lit | lit class == Association ifTrue:						[(lit value == cl or: [cls canFindWithoutEnvironment: lit key])							ifFalse: [refs add: lit key]]]]].		envtRefs _ Bag new.		refs asSet do:			[:varName |			envtRefs add: (envtForVar at: varName)					withOccurrences: (refs occurrencesOf: varName)].		(envtRefs sortedCounts isEmpty or: [envtRefs sortedCounts first value == (Smalltalk keyAtValue: cls environment)])			ifFalse: [allRefs add: varName withOccurrences: (refs occurrencesOf: varName).					tallies at: cls name put: envtRefs sortedCounts.					Transcript cr; print: envtRefs sortedCounts; endEntry]]].	newCategories _ Dictionary new.	tallies associationsDo:		[:assn | cat _ assn value first value.		(newCategories includesKey: cat) ifFalse:			[newCategories at: cat put: Array new].		newCategories at: cat put: ((newCategories at: cat) copyWith: assn key)].	^ { tallies. newCategories. allRefs sortedCounts }! !!Environment methodsFor: 'as yet unclassified' stamp: 'di 12/2/1999 11:00'!transferBindingsNamedIn: nameList from: otherEnvt	| cls |	nameList do:		[:name |		cls _ otherEnvt at: name.		self add: (otherEnvt associationAt: name).		cls environment: self category: cls category.		otherEnvt removeKey: name].! !!Environment class methodsFor: 'as yet unclassified' stamp: 'di 12/6/1999 13:47'!reorganizeEverything		"Environment reorganizeEverything.		Smalltalk browseIndirectRefs.		Smalltalk tallyIndirectRefs.		Smalltalk rewriteIndirectRefs."	| bigCat envt |	"Paint the world so we know not to save it."	World == nil		ifTrue: [self error: 'This has only been tried when running in Morphic']		ifFalse: [World color: Color red darker darker].	"Recreate the Smalltalk dictionary as the top-level Environment."	Smalltalk _ SmalltalkEnvironment newFrom: Smalltalk.	"Don't hang onto old copy of Smalltalk ."	Smalltalk recreateSpecialObjectsArray.	"Store values for environment and category in each class."	Smalltalk allClassesDo:		[:c | c environment: nil category: nil. "Flush any old values"		c environment: c environment category: c category].	"Run through all categories making up new sub-environments"	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(#(Kernel Collections Graphics Tools System Exceptions) includes: bigCat) ifFalse:			["Not a kernel category ..."			envt _ Smalltalk at: bigCat						ifAbsent: ["... make up a new environment if necessary ..."									Smalltalk makeSubEnvironmentNamed: bigCat].			"... and install the member classes in that category"			envt transferBindingsNamedIn: (SystemOrganization listAtCategoryNamed: cat)									from: Smalltalk].		].	Smalltalk rebuildSystemOrganization.	Smalltalk rewriteIndirectRefs.	Preferences enable: #browserShowsPackagePane.! !Class removeSelector: #initForNewOrganization!ClassOrganizer removeSelector: #changeFromTokens:!Encoder removeSelector: #encodeVariable:ifUnknown:!Preferences removeSelector: #readMe!SystemDictionary removeSelector: #printOn:!Environment removeSelector: #deepAt:!Environment removeSelector: #makeEnvironmentNamed:fromCategories:!Environment removeSelector: #outerEnvironment!Environment removeSelector: #browseDirectedRefs!Environment removeSelector: #tallyDirectedRefs!Environment removeSelector: #reorganizeEverything!Environment removeSelector: #reorganizeSmalltalk!Environment class removeSelector: #reorganizeSmalltalk!Undeclared removeUnreferencedKeys!