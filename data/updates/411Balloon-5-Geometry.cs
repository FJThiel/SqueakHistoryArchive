'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:04:34 am'!Object subclass: #CompressedBoundaryShape	instanceVariableNames: 'points leftFills rightFills lineWidths lineFills fillStyles '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Geometry'!Object subclass: #FillStyle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Fills'!Object subclass: #LineSegment	instanceVariableNames: 'start end '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Geometry'!LineSegment subclass: #Bezier2Segment	instanceVariableNames: 'via '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Geometry'!FillStyle subclass: #OrientedFillStyle	instanceVariableNames: 'origin direction normal '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Fills'!OrientedFillStyle subclass: #BitmapFillStyle	instanceVariableNames: 'form '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Fills'!OrientedFillStyle subclass: #GradientFillStyle	instanceVariableNames: 'colorRamp pixelRamp radial '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Fills'!IntegerArray variableWordSubclass: #PointArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Collections'!ArrayedCollection variableWordSubclass: #ShortIntegerArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Collections'!ShortIntegerArray variableWordSubclass: #ShortPointArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Collections'!ArrayedCollection variableWordSubclass: #ShortRunArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Collections'!FillStyle subclass: #SolidFillStyle	instanceVariableNames: 'color pixelValue32 '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Fills'!!BitmapFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/13/1998 20:32'!form: aForm	^self new form: aForm! !!Color methodsFor: 'access' stamp: 'ar 11/8/1998 18:33'!pixelValue32	^self pixelWordForDepth: 32! !!Color methodsFor: 'queries' stamp: 'ar 11/7/1998 20:20'!isSolidFill	^true! !!Color methodsFor: 'conversions' stamp: 'ar 11/2/1998 12:19'!asColor	"Convert the receiver into a color"	^self! !!CompressedBoundaryShape commentStamp: '<historical>' prior: 0!This class represents a very compact representation of a boundary shape. It consists of a number of compressed arrays that can be handled by the balloon engine directly. Due to this, there are certain restrictions (see below). Boundaries are always represented by three subsequent points that define a quadratic bezier segment. It is recommended that for straight line segments the control point is set either to the previous or the next point.Instance variables:	points		<PointArray | ShortPointArray>	Point storage area	leftFills		<ShortRunArray>	Containing the "left" fill index of each segment	rightFills	<ShortRunArray>	Containing the "right" fill index of each segment	lineWidths	<ShortRunArray>	Containing the line width of each segment	lineFills		<ShortRunArray>	Containing the line fill (e.g., line color) of each segment	fillStyles	<Collections>			Contains the actual fill styles referenced by the indexesRESTRICTIONS:None of the ShortRunArrays may contain a run of length Zero.Also, due to the use of ShortRunArrays 	a) you cannot have more than 32768 different fill styles	b) you cannot have a line width that exceeds 32768In case you have trouble with a), try to merge some of the fills into one. You might do so by converting colors to 32bit pixel values. In case you have trouble with b) you might change the general resolution of the compressed shape to have less accuracy.!!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/15/1998 17:23'!bounds	| min max width |	points isEmpty ifTrue:[^0@0 corner: 1@1].	min _ max _ points first.	points do:[:pt|		min _ min min: pt.		max _ max max: pt	].	width _ 0.	lineWidths valuesDo:[:w| width _ width max: w].	^(min corner: max) insetBy: (w negated asPoint)! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!fillStyles	^fillStyles! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!leftFills	^leftFills! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!lineFills	^lineFills! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!lineWidths	^lineWidths! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/4/1998 13:50'!numSegments	^points size // 3! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 20:42'!points	^points! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/3/1998 21:55'!rightFills	^rightFills! !!CompressedBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:09'!segments	"Return all the segments in the receiver"	| out |	out _ WriteStream on: Array new.	self segmentsDo:[:seg| out nextPut: seg].	^out contents! !!CompressedBoundaryShape methodsFor: 'editing' stamp: 'ar 11/12/1998 21:12'!collectFills: aBlock	fillStyles _ fillStyles collect: aBlock.! !!CompressedBoundaryShape methodsFor: 'editing' stamp: 'ar 11/12/1998 21:11'!copyAndCollectFills: aBlock	^self copy collectFills: aBlock! !!CompressedBoundaryShape methodsFor: 'enumerating' stamp: 'ar 11/9/1998 14:10'!segmentsDo: aBlock	"Enumerate all segments in the receiver and execute aBlock"	| p1 p2 p3 |	1 to: points size by: 3 do:[:i|		p1 _ points at: i.		p2 _ points at: i+1.		p3 _ points at: i+2.		(p1 = p2 or:[p2 = p3]) ifTrue:[			aBlock value: (LineSegment from: p1 to: p3).		] ifFalse:[			aBlock value: (Bezier2Segment from: p1 via: p2 to: p3).		].	].! !!CompressedBoundaryShape methodsFor: 'private' stamp: 'ar 11/3/1998 18:03'!setPoints: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList lineWidths: lineWidthList lineFills: lineFillList	points _ pointList.	leftFills _ leftFillList.	rightFills _ rightFillList.	lineWidths _ lineWidthList.	lineFills _ lineFillList.	fillStyles _ fillStyleList.! !!CompressedBoundaryShape class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 16:28'!points: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList	^self new setPoints: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList! !!CompressedBoundaryShape class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 18:02'!points: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList lineWidths: lineWidthList lineFills: lineFillList	^self new setPoints: pointList leftFills: leftFillList rightFills: rightFillList fillStyles: fillStyleList lineWidths: lineWidthList lineFills: lineFillList! !!FillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 13:53'!pixelValue32	"Return a pixel value of depth 32 for the primary color in the fill style"	^self asColor pixelWordForDepth: 32! !!FillStyle methodsFor: 'testing' stamp: 'ar 11/9/1998 13:54'!isBitmapFill	^false! !!FillStyle methodsFor: 'testing' stamp: 'ar 11/9/1998 13:54'!isGradientFill	^false! !!FillStyle methodsFor: 'testing' stamp: 'ar 11/9/1998 13:54'!isSolidFill	^false! !!FillStyle methodsFor: 'converting' stamp: 'ar 11/9/1998 13:53'!asColor	^self subclassResponsibility! !!GradientFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/9/1998 14:05'!ramp: colorRamp	^self new colorRamp: colorRamp! !!GradientFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/10/1998 19:13'!sample	"GradientFill sample"	^(self ramp: { 0.0 -> Color red. 0.5 -> Color green. 1.0 -> Color blue})		origin: 300 @ 300;		direction: 400@0;		normal: 0@400;		radial: true;	yourself! !!Integer methodsFor: 'converting' stamp: 'ar 10/31/1998 23:04'!asColorOfDepth: d	"Return a color value representing the receiver as color of the given depth"	^Color colorFromPixelValue: self depth: d! !!LineSegment commentStamp: '<historical>' prior: 0!This class represents a straight line segment between two pointsInstance variables:	start	<Point>	start point of the line	end		<Point>	end point of the line!!LineSegment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:12'!from: startPoint to: endPoint	"Initialize the receiver"	start _ startPoint.	end _ endPoint.! !!LineSegment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:12'!bounds	"Return the bounds containing the receiver"	^(start min: end) corner: (start max: end)! !!LineSegment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:12'!end	"Return the end point"	^end! !!LineSegment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:12'!start	"Return the start point"	^start! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:12'!hasZeroLength	"Return true if the receiver has zero length"	^start = end! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:07'!isBezier2Segment	"Return true if the receiver is a quadratic bezier segment"	^false! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:07'!isLineSegment	"Return true if the receiver is a line segment"	^true! !!LineSegment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:08'!isStraight	"Return true if the receiver represents a straight line"	^true! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:08'!length	"Return the length of the receiver"	^start dist: end! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:08'!lineSegmentsDo: aBlock	"Evaluate aBlock with the receiver's line segments"	aBlock value: start value: end! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!tangentAt: parameter	"Return the tangent at the given parametric value along the receiver"	^end - start! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!tangentAtEnd	"Return the tangent for the last point"	^(end - start)! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!tangentAtStart	"Return the tangent for the last point"	^(end - start)! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:09'!valueAt: parameter	"Evaluate the receiver at the given parametric value"	^start + (end - start * parameter)! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:10'!valueAtEnd	"Evaluate the receiver at it's end point (e.g., self valueAtEnd = (self valueAt: 1.0))"	^end! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:10'!valueAtStart	"Evaluate the receiver at it's start point (e.g., self valueAtEnd = (self valueAt: 0.0))"	^start! !!LineSegment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:11'!asBezier2Segment	"Represent the receiver as quadratic bezier segment"	^Bezier2Segment from: start to: end! !!LineSegment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:11'!asIntegerSegment	"Convert the receiver into integer representation"	^self species from: start asIntegerPoint to: end asIntegerPoint! !!LineSegment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:11'!asLineSegment	"Represent the receiver as a straight line segment"	^self! !!LineSegment methodsFor: 'printing' stamp: 'ar 11/2/1998 12:13'!printOn: aStream	"Print the receiver on aStream"	aStream 		nextPutAll: self class name;		nextPutAll:' from: ';		print: start;		nextPutAll: ' to: ';		print: end;		space.! !!LineSegment methodsFor: 'private' stamp: 'ar 11/6/1998 15:05'!debugDraw	| canvas |	canvas _ FormCanvas on: Display.	self lineSegmentsDo:[:p1 :p2|		canvas line: p1 rounded to: p2 rounded width: 1 color: Color black.	].! !!Bezier2Segment commentStamp: '<historical>' prior: 0!This class represents a quadratic bezier segment between two pointsInstance variables:	via		<Point>	The additional control point (OFF the curve)!!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:13'!from: startPoint to: endPoint	"Initialize the receiver as straight line"	start _ startPoint.	end _ endPoint.	via _ (start + end) // 2.! !!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:13'!from: startPoint to: endPoint via: viaPoint	"Initialize the receiver"	start _ startPoint.	end _ endPoint.	via _ viaPoint.! !!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:14'!from: startPoint to: endPoint withMidPoint: pointOnCurve	"Initialize the receiver with the pointOnCurve assumed at the parametric value 0.5"	start _ startPoint.	end _ endPoint.	"Compute via"	via _ (pointOnCurve * 2) - ((start+end) // 2).! !!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 11/2/1998 12:14'!from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter	"Initialize the receiver with the pointOnCurve at the given parametric value"	| t1 t2 t3 |	start _ startPoint.	end _ endPoint.	"Compute via"	t1 _ (1.0 - parameter) squared.	t2 _ 2 * parameter * (1.0 - parameter).	t3 _ parameter squared.	via _ (pointOnCurve * t2) - (start * t1)  - (end * t3)! !!Bezier2Segment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:14'!bounds	"Return the bounds containing the receiver"	^super bounds encompass: via! !!Bezier2Segment methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:14'!via	"Return the control point"	^via! !!Bezier2Segment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:15'!hasZeroLength	"Return true if the receiver has zero length"	^start = end and:[start = via]! !!Bezier2Segment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:15'!isBezier2Segment	"Return true if the receiver is a quadratic bezier segment"	^true! !!Bezier2Segment methodsFor: 'testing' stamp: 'ar 11/2/1998 12:15'!isStraight	"Return true if the receiver represents a straight line"	^(self tangentAtStart crossProduct: self tangentAtEnd) = 0! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:15'!length	"Return the length of the receiver"	"Note: Overestimates the length"	^(start dist: via) + (via dist: end)! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/6/1998 23:39'!lineSegmentsDo: aBlock	"Evaluate aBlock with the receiver's line segments"	"Note: We could use forward differencing here."	| steps last deltaStep t next |	steps _ 1 max: (self length // 10). "Assume 10 pixels per step"	last _ start.	deltaStep _ 1.0 / steps asFloat.	t _ deltaStep.	1 to: steps do:[:i|		next _ self valueAt: t.		aBlock value: last value: next.		last _ next.		t _ t + deltaStep].! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:16'!tangentAt: parameter	"Return the tangent at the given parametric value along the receiver"	| in out |	in _ self tangentAtStart.	out _ self tangentAtEnd.	^in + (out - in * parameter)! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:16'!tangentAtEnd	"Return the tangent for the last point"	^end - via! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:16'!tangentAtStart	"Return the tangent for the first point"	^via - start! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 11/2/1998 12:17'!valueAt: parameter	"Evaluate the receiver at the given parametric value"	"Return the point at the parametric value t:		p(t) =	(1-t)^2 * p1 + 				2*t*(1-t) * p2 + 				t^2 * p3.	"	| t1 t2 t3 |	t1 _ (1.0 - parameter) squared.	t2 _ 2 * parameter * (1.0 - parameter).	t3 _ parameter squared.	^(start * t1) + (via * t2) + (end * t3)! !!Bezier2Segment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:17'!asBezier2Segment	"Represent the receiver as quadratic bezier segment"	^self! !!Bezier2Segment methodsFor: 'converting' stamp: 'ar 11/2/1998 12:18'!asIntegerSegment	"Convert the receiver into integer representation"	^self species 			from: start asIntegerPoint 			to: end asIntegerPoint 			via: via asIntegerPoint! !!Bezier2Segment methodsFor: 'printing' stamp: 'ar 11/2/1998 12:18'!printOn: aStream	"Print the receiver on aStream"	aStream 		nextPutAll: self class name;		nextPutAll:' from: ';		print: start;		nextPutAll: ' via: ';		print: via;		nextPutAll: ' to: ';		print: end;		space.! !!LineSegment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:10'!from: startPoint to: endPoint	^self new from: startPoint to: endPoint! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:14'!from: startPoint to: endPoint via: viaPoint	^self new from: startPoint to: endPoint via: viaPoint! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:30'!from: startPoint to: endPoint withMidPoint: pointOnCurve	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:32'!from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:30'!from: startPoint via: viaPoint to: endPoint 	^self new from: startPoint to: endPoint via: viaPoint! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:32'!from: startPoint withMidPoint: pointOnCurve at: parameter to: endPoint 	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve at: parameter! !!Bezier2Segment class methodsFor: 'instance creation' stamp: 'ar 11/1/1998 21:30'!from: startPoint withMidPoint: pointOnCurve to: endPoint 	^self new from: startPoint to: endPoint withMidPoint: pointOnCurve! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:37'!direction	^direction! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:37'!direction: aPoint	direction _ aPoint! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:31'!normal	^normal ifNil:[normal _ direction y negated @ direction x]! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:37'!normal: aPoint	normal _ aPoint! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:38'!origin	^origin! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:38'!origin: aPoint	origin _ aPoint.! !!BitmapFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:40'!form	^form! !!BitmapFillStyle methodsFor: 'accessing' stamp: 'ar 11/11/1998 22:40'!form: aForm	form _ aForm! !!BitmapFillStyle methodsFor: 'testing' stamp: 'ar 11/11/1998 22:40'!isBitmapFill	^true! !!BitmapFillStyle methodsFor: 'converting' stamp: 'ar 11/11/1998 22:41'!asColor	^form colorAt: 0@0! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/7/1998 22:10'!colorRamp	^colorRamp! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:00'!colorRamp: anArray	colorRamp _ anArray.	pixelRamp _ nil.! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:07'!pixelRamp	^pixelRamp ifNil:[pixelRamp _ self computePixelRampOfSize: 256].! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:06'!pixelRamp: aBitmap	pixelRamp _ aBitmap! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:06'!radial	^radial! !!GradientFillStyle methodsFor: 'accessing' stamp: 'ar 11/7/1998 22:11'!radial: aBoolean	radial _ aBoolean! !!GradientFillStyle methodsFor: 'testing' stamp: 'ar 11/7/1998 22:12'!isGradientFill	^true! !!GradientFillStyle methodsFor: 'testing' stamp: 'ar 11/7/1998 22:13'!isRadialFill	^radial == true! !!GradientFillStyle methodsFor: 'testing' stamp: 'ar 11/7/1998 22:12'!isSolidFill	^false! !!GradientFillStyle methodsFor: 'converting' stamp: 'ar 11/9/1998 14:07'!asColor	^colorRamp first value! !!GradientFillStyle methodsFor: 'private' stamp: 'ar 11/9/1998 14:09'!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver"	| bits lastColor lastIndex nextIndex nextColor distance theta color lastValue ramp |	ramp _ colorRamp asSortedCollection:[:a1 :a2| a1 key < a2 key].	bits _ Bitmap new: length.	lastColor _ ramp first value.	lastIndex _ 0.	ramp do:[:assoc|		nextIndex _ (assoc key * length) rounded.		nextColor _ assoc value.		distance _ (nextIndex - lastIndex).		distance = 0 ifTrue:[distance _ 1].		lastIndex+1 to: nextIndex do:[:i|			theta _ (i - lastIndex) asFloat / distance asFloat.			color _ nextColor mixed: theta with: lastColor.			bits at: i put: (color pixelWordForDepth: 32).		].		lastIndex _ nextIndex.		lastColor _ nextColor.	].	lastValue _ lastColor pixelWordForDepth: 32.	lastIndex+1 to: length do:[:i| bits at: i put: lastValue].	^bits! !!GradientFillStyle methodsFor: 'private' stamp: 'ar 11/9/1998 16:56'!display	| f ramp |	ramp _ self pixelRamp.	f _ Form extent: ramp size @ 1 depth: 32 bits: ramp.	1 to: 100 do:[:i| f displayAt: 1@i].	[Sensor anyButtonPressed] whileFalse.	[Sensor anyButtonPressed] whileTrue.! !!Point methodsFor: 'point functions' stamp: 'ar 10/30/1998 03:05'!crossProduct: aPoint 	"Answer a number that is the cross product of the receiver and the 	argument, aPoint."	^ (x * aPoint y) - (y * aPoint x)! !!Point methodsFor: 'point functions' stamp: 'ar 11/12/1998 01:44'!transposed	^y@x! !!PointArray commentStamp: '<historical>' prior: 0!This class stores 32bit Integer points in place. It is used to pass data efficiently to the primitive level during high-bandwidth 2D graphics operations.!!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:21'!at: index	"Return the element (e.g., point) at the given index"	^(super at: index * 2 - 1) @ (super at: index * 2)! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:21'!at: index put: aPoint	"Store the argument aPoint at the given index"	super at: index * 2 - 1 put: aPoint x asInteger.	super at: index * 2 put: aPoint y asInteger.	^aPoint! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/10/1998 19:41'!bounds	| min max |	min _ max _ self at: 1.	self do:[:pt|		min _ min min: pt.		max _ max max: pt].	^min corner: max		! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0@0! !!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:21'!size	"Return the number of elements in the receiver"	^super size // 2! !!PointArray class methodsFor: 'instance creation' stamp: 'ar 10/16/1998 00:04'!new: n	^super new: n*2! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!at: index	"Return the 16-bit integer value at the given index of the receiver."	<primitive: 143>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber ifTrue: [^ self at: index truncated].	self errorNonIntegerIndex.! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!at: index put: value	"Store the given 16-bit integer at the given index in the receiver."	<primitive: 144>	index isInteger		ifTrue: [			(index >= 1 and: [index <= self size])				ifTrue: [self errorImproperStore]				ifFalse: [self errorSubscriptBounds: index]].	index isNumber ifTrue: [^ self at: index truncated put: value].	self errorNonIntegerIndex.! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!defaultElement	^0! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!size	^super size * 2! !!ShortPointArray commentStamp: '<historical>' prior: 0!This class stores points that are in short integer range (e.g., -32767 <= value <= 32768). It is used to pass data efficiently to the primitive level during high-bandwidth 2D graphics operations.!!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!at: index	"Return the element (e.g., point) at the given index"	^(super at: index * 2 - 1) @ (super at: index * 2)! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!at: index put: aPoint	"Store the argument aPoint at the given index"	super at: index * 2 - 1 put: aPoint x asInteger.	super at: index * 2 put: aPoint y asInteger.	^aPoint! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/10/1998 19:41'!bounds	| min max |	min _ max _ self at: 1.	self do:[:pt|		min _ min min: pt.		max _ max max: pt].	^min corner: max		! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!defaultElement	"Return the default element of the receiver"	^0@0! !!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43'!size	^self basicSize! !!ShortRunArray commentStamp: '<historical>' prior: 0!This class is run-length encoded representation of short integer (e.g., 16bit signed integer values)!!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:26'!at: index	"Return the short value at the given index"	| rlIndex |	index < 1 ifTrue:[^self errorSubscriptBounds: index].	rlIndex _ index.	self lengthsAndValuesDo:[:runLength :runValue|		rlIndex <= runLength ifTrue:[^runValue].		rlIndex _ rlIndex - runLength].	"Not found. Must be out of range"	^self errorSubscriptBounds: index! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:18'!at: index put: value	"ShortRunArrays are read-only"	^self shouldNotImplement.! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:39'!compressionRatio	"Return the compression ratio.	The compression ratio is computed based	on how much space would be needed to	store the receiver in a ShortIntegerArray"	^(self size asFloat * 0.5) "Would need only half of the amount in ShortIntegerArray"		/ (self runSize max: 1)! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:21'!lengthAtRun: index	"Return the length of the run starting at the given index"	^(self basicAt: index) bitShift: -16! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:28'!runSize	"Return the number of runs in the receiver"	^self basicSize! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:28'!size	"Return the number of elements stored in the receiver"	| n |	n _ 0.	"Note: The following loop is open-coded for speed"	1 to: self basicSize do:[:i|		n _ n + ((self basicAt: i) bitShift: -16).	].	^n! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:29'!species	"Answer the preferred class for reconstructing the receiver."	^ShortIntegerArray! !!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:22'!valueAtRun: index	"Return the value of the run starting at the given index"	| uShort |	uShort _ (self basicAt: index) bitAnd: 16rFFFF.	^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/3/1998 17:31'!do: aBlock	"Evaluate aBlock with all elements of the receiver"	self lengthsAndValuesDo:[:runLength :runValue|		"Use to:do: instead of timesRepeat: for compiler optimization"		1 to: runLength do:[:i|			aBlock value: runValue.		].	].! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/3/1998 17:25'!lengthsAndValuesDo: aBlock	"Evaluate aBlock with the length and value of each run in the receiver"	| basicValue length value |	1 to: self basicSize do:[:i|		basicValue _ self basicAt: i.		length _ basicValue bitShift: -16.		value _ basicValue bitAnd: 16rFFFF.		value _ (value bitAnd: 16r7FFF) - (value bitAnd: 16r8000).		aBlock value: length value: value.	].! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/3/1998 21:05'!valuesCollect: aBlock	"Evaluate aBlock with each of the receiver's values as the argument. 	Collect the resulting values into a collection like the receiver. Answer 	the new collection."	| newArray newValue |	newArray _ self class basicNew: self basicSize.	1 to: self runSize do:[:i|		newValue _ aBlock value: (self valueAtRun: i).		newArray setRunAt: i toLength: (self lengthAtRun: i) value: newValue.	].	^newArray! !!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/15/1998 17:22'!valuesDo: aBlock	self lengthsAndValuesDo:[:runLength :runValue| aBlock value: runValue]! !!ShortRunArray methodsFor: 'printing' stamp: 'ar 11/3/1998 17:41'!printOn: aStream	aStream nextPutAll: self class name; nextPutAll:' ( '.	self lengthsAndValuesDo:[:runLength :runValue |		aStream			nextPutAll:' (';			print: runLength;			space;			print: runValue;			nextPut:$).	].	aStream nextPutAll:' )'.! !!ShortRunArray methodsFor: 'private' stamp: 'ar 11/3/1998 21:02'!setRunAt: i toLength: runLength value: value	(value < -16r7FFF or:[value > 16r8000]) ifTrue:[^self errorImproperStore].	(runLength < 0 or:[runLength > 16rFFFF]) ifTrue:[^self errorImproperStore].	self basicAt: i put: (runLength bitShift: 16) + 		((value bitAnd: 16r7FFF) - (value bitAnd: -16r8000)).! !!ShortRunArray methodsFor: 'private' stamp: 'ar 11/3/1998 21:00'!setRuns: runArray values: valueArray	| runLength value |	1 to: runArray size do:[:i|		runLength _ runArray at: i.		value _ valueArray at: i.		self setRunAt: i toLength: runLength value: value.	].! !!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:12'!new: n	"ShortRunArrays must be created with either		someCollection as: ShortRunArray	or by using		ShortRunArray runs: runCollection values: valueCollection.	"	^self shouldNotImplement! !!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:35'!newFrom: aCollection	"Compress aCollection into a ShortRunArray"	| lastValue lastRun runs values |	aCollection isEmpty ifTrue:[^self runs:#() values: #()].	runs _ WriteStream on: (WordArray new: 100).	values _ WriteStream on: (ShortIntegerArray new: 100).	lastValue _ aCollection first.	lastRun _ 0.	aCollection do:[:item|		(item = lastValue and:[lastRun < 16r8000]) ifTrue:[			lastRun _ lastRun + 1.		] ifFalse:[			runs nextPut: lastRun.			values nextPut: lastValue.			lastRun _ 1.			lastValue _ item.		].	].	runs nextPut: lastRun.	values nextPut: lastValue.	^self runs: runs contents values: values contents! !!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:12'!runs: runCollection values: valueCollection	^(self basicNew: runCollection size) setRuns: runCollection values: valueCollection! !!SolidFillStyle methodsFor: 'accessing' stamp: 'ar 11/8/1998 18:31'!color: aColor	color _ aColor.	pixelValue32 _ aColor pixelWordForDepth: 32.! !!SolidFillStyle methodsFor: 'accessing' stamp: 'ar 11/9/1998 03:29'!display	^color display! !!SolidFillStyle methodsFor: 'accessing' stamp: 'ar 11/8/1998 18:32'!pixelValue32	^pixelValue32! !!SolidFillStyle methodsFor: 'testing' stamp: 'ar 11/8/1998 18:34'!isSolidFill	^true! !!SolidFillStyle methodsFor: 'converting' stamp: 'ar 11/9/1998 13:55'!asColor	^color! !!SolidFillStyle class methodsFor: 'instance creation' stamp: 'ar 11/8/1998 18:31'!color: aColor	^self new color: aColor! !