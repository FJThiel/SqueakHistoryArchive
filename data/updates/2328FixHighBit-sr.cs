'From Squeak2.8alpha of 4 February 2000 [latest update: #2310] on 12 June 2000 at 1:00:31 pm'!"Change Set:		143FixHighBit-srDate:			8 June 2000Author:			Stephan RudlofFixes a bug originating from a mixture of two-complement and magnitude arithmetics.Introduces a differentiation between Integer>>highBit and Integer>>highBitOfMagnitude.Integer>>highBit has *always* two-complement semantics now, and therefore it isn't defined for negative Integers.Integer>>highBitOfMagnitude returns the number of the highest bit of the magnitude (absolute value) of the receiver, therefore it is defined as for positive as for negative Integers.MotivationInteger>>digitLshift: needs the high bit of the magnitude of the receiver:This has worked- for LargeIntegers, because their >>highBit returned their magnitude high bit, and also- for positive SmallIntegers, because their two-complement high bit is the same as their magnitude high bit,- but *not* for *negative* SmallIntegers, because their two-complement high bit is *not* defined!!So I have made a distinction between two-complement >>highBit and magnitude >>highBitForMagnitude and changed calling methods accordingly.EvaluationEvaluate	-585148196 // -1442692966(taken from a bug report of Andreas Raab) before and after applying this changeset, but without using the LargeIntegers module (!!), to see the effect of this changeset.NoteThe LargeIntegers module isn't affected by this problem, because it converts SmallIntegers to LargeIntegers before performing arithmetics (and uses highBit of magnitude)."!!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:13'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self subclassResponsibility! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 01:55'!highBitOfMagnitude	"Answer the index of the high order bit of the magnitude of the  	receiver, or zero if the receiver is zero."	^ self subclassResponsibility! !!Integer methodsFor: 'private' stamp: 'sr 6/8/2000 01:28'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	<primitive: 'primDigitDivNegative' module:'LargeIntegers'>	arg = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	"TFEI added this line"	l _ self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^ Array with: 0 with: self].	"shortcut against #highBit"	d _ 8 - arg lastDigit highBitOfPositiveReceiver.	div _ arg digitLshift: d.	div _ div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem _ self digitLshift: d.	rem digitLength = self digitLength ifTrue: [rem _ rem growto: self digitLength + 1].	"makes a copy and shifts"	quo _ Integer new: l neg: ng.	dl _ div digitLength - 1.	"Last actual byte of data"	ql _ l.	dh _ div digitAt: dl.	dnh _ dl = 1				ifTrue: [0]				ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ rem digitLength + 1 - k.		"r1 _ rem digitAt: j."		(rem digitAt: j)			= dh			ifTrue: [qhi _ qlo _ 15				"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13  				bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((rem digitAt: j)							bitShift: 4)							+ ((rem digitAt: j - 1)									bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4)							+ ((rem digitAt: j - 1)									bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15)								bitShift: 4).				hi _ (hi bitShift: -4)							+ (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 _ j < 3							ifTrue: [0]							ifFalse: [rem digitAt: j - 2].				[(t < hi					or: [t = hi and: [r3 < lo]])					and: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0							ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						hi >= dh]]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: div digitLength do: 			[:i | 			hi _ (div digitAt: i)						* qhi.			lo _ a + (rem digitAt: l) - ((hi bitAnd: 15)							bitShift: 4) - ((div digitAt: i)							* qlo).			rem digitAt: l put: lo - (lo // 256 * 256).			"sign-tolerant form of (lo bitAnd: 255)"			a _ lo // 256 - (hi bitShift: -4).			l _ l + 1].		a < 0			ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: div digitLength do: 					[:i | 					a _ (a bitShift: -8)								+ (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l _ l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4)				+ qlo].	rem _ rem				digitRshift: d				bytes: 0				lookfirst: dl.	^ Array with: quo with: rem! !!Integer methodsFor: 'private' stamp: 'sr 6/8/2000 01:30'!digitLshift: shiftCount 	| carry rShift mask len result digit byteShift bitShift highBit |	(highBit _ self highBitOfMagnitude) = 0 ifTrue: [^ 0].	len _ highBit + shiftCount + 7 // 8.	result _ Integer new: len neg: self negative.	byteShift _ shiftCount // 8.	bitShift _ shiftCount \\ 8.	bitShift = 0 ifTrue: ["Fast version for byte-aligned shifts"		^ result			replaceFrom: byteShift + 1			to: len			with: self			startingAt: 1].	carry _ 0.	rShift _ bitShift - 8.	mask _ 255 bitShift: 0 - bitShift.	1 to: byteShift do: [:i | result digitAt: i put: 0].	1 to: len - byteShift do: 		[:i | 		digit _ self digitAt: i.		result digitAt: i + byteShift put: (((digit bitAnd: mask)				bitShift: bitShift)				bitOr: carry).		carry _ digit bitShift: rShift].	^ result! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:11'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self highBitOfMagnitude! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:15'!highBitOfMagnitude	"Answer the index of the high order bit of the magnitude of the  	receiver, or zero if the receiver is zero.  	This method is used for LargeNegativeIntegers as well,  	since Squeak's LargeIntegers are sign/magnitude."	| realLength lastDigit |	realLength _ self digitLength.	[(lastDigit _ self digitAt: realLength) = 0]		whileTrue: [(realLength _ realLength - 1) = 0 ifTrue: [^ 0]].	^ lastDigit highBitOfPositiveReceiver + (8 * (realLength - 1))! !!LargeNegativeInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:10'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self shouldNotImplement! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:07'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to 	get the highest bit of the magnitude."	self < 0 ifTrue: [^ self error: 'highBit is not defined for negative integers'].	^ self highBitOfPositiveReceiver! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:08'!highBitOfMagnitude	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. This method is used for negative SmallIntegers as well,  	since Squeak's LargeIntegers are sign/magnitude."	^ self abs highBitOfPositiveReceiver! !!SmallInteger methodsFor: 'private' stamp: 'sr 6/8/2000 01:14'!highBitOfPositiveReceiver	| shifted bitNo |	"Answer the index of the high order bit of the receiver, or zero if the 	receiver is zero. Receiver has to be positive!!"	shifted _ self.	bitNo _ 0.	[shifted < 16]		whileFalse: 			[shifted _ shifted bitShift: -4.			bitNo _ bitNo + 4].	[shifted = 0]		whileFalse: 			[shifted _ shifted bitShift: -1.			bitNo _ bitNo + 1].	^ bitNo! !!LargeNegativeInteger reorganize!('arithmetic' abs negated)('bit manipulation' highBit)('converting' normalize)('testing' negative positive sign strictlyPositive)('printing')!