'From Squeak2.8alpha of 12 January 2000 [latest update: #1811] on 6 February 2000 at 2:42:57 pm'!"Change Set:		BetterDoLoopDecomp-DIDate:			6 February 2000Author:			Dan IngallsProvides better decompilation of do-loops by converting the pattern		limitVar _ limitExpr.		startExpr to: limitVar do: [:var | ...statements...]	to		startExpr to: limitExpr do: [:var | ...statements...]"!!Decompiler methodsFor: 'private' stamp: 'di 2/6/2000 11:06'!convertToDoLoop	"If statements contains the pattern		var _ startExpr.		[var <= limit] whileTrue: [...statements... var _ var + incConst]	then replace this by		startExpr to: limit by: incConst do: [:var | ...statements...]"	| initStmt toDoStmt limitStmt |	statements size < 2 ifTrue: [^ self].	initStmt _ statements at: statements size-1.	(toDoStmt _ statements last toDoFromWhileWithInit: initStmt)		== nil ifTrue: [^ self].	initStmt variable scope: -1.  "Flag arg as block temp"	statements removeLast; removeLast; addLast: toDoStmt.	"Attempt further conversion of the pattern		limitVar _ limitExpr.		startExpr to: limitVar by: incConst do: [:var | ...statements...]	to		startExpr to: limitExpr by: incConst do: [:var | ...statements...]"	statements size < 2 ifTrue: [^ self].	limitStmt _ statements at: statements size-1.	((limitStmt isMemberOf: AssignmentNode)		and: [limitStmt variable isTemp		and: [limitStmt variable == toDoStmt arguments first		and: [self methodRefersOnlyOnceToTemp: limitStmt variable fieldOffset]]])		ifFalse: [^ self].	toDoStmt arguments at: 1 put: limitStmt value.	limitStmt variable scope: -2.  "Flag limit var so it won't print"	statements removeLast; removeLast; addLast: toDoStmt.! !!Decompiler methodsFor: 'private' stamp: 'di 2/6/2000 10:55'!methodRefersOnlyOnceToTemp: offset	| nRefs byteCode extension scanner |	nRefs _ 0.	offset <= 15		ifTrue:			[byteCode _ 16 + offset.			(InstructionStream on: method) scanFor:				[:instr | instr = byteCode ifTrue: [nRefs _ nRefs + 1].				nRefs > 1]]		ifFalse:			[extension _ 64 + offset.			scanner _ InstructionStream on: method.			scanner scanFor:				[:instr | (instr = 128 and: [scanner followingByte = extension])							ifTrue: [nRefs _ nRefs + 1].				nRefs > 1]].	^ nRefs = 1! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'di 2/6/2000 14:38'!codeMessage: receiver selector: selector arguments: arguments	| symbol node |	symbol _ selector key.	(node _ BraceNode new			matchBraceWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	(node _ self decodeIfNilWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	^ MessageNode new			receiver: receiver selector: selector			arguments: arguments			precedence: (symbol isInfix								ifTrue: [2]								ifFalse: [symbol isKeyword												ifTrue: [3]												ifFalse: [1]])! !!VariableNode methodsFor: 'code generation' stamp: 'di 2/6/2000 10:52'!fieldOffset  "Return temp or instVar offset for this variable"	code < 256		ifTrue: 			[^ code \\ 16]		ifFalse: 			[^ code \\ 256]! !MessageNode removeSelector: #toDoWithLimit:!