'From Squeak2.9alpha of 13 June 2000 [latest update: #2828] on 8 October 2000 at 3:16:43 pm'!"Change Set:		VariousFixes-arDate:			8 October 2000Author:			Andreas RaabVarious fixes for broken behavior from the last bunch of changes:Halos:[X] Transfers of halos through renderers[X] Position offset in halo-drags[X] Restore all handles after pickup/duplicateGrabbing/Dropping[X] Automatic repositioning of grabbed morphs (pickup and duplicate handle)Scripting[X] Touching last tile in Script accidentally drops it as new script.[X] TryMe ('!!') doesn't work[X] Moving and dropping script out of viewer leaves script tile on handFreeCell[X] Drag, click, and double click distinction"!!Morph methodsFor: 'halos and balloon help' stamp: 'ar 10/8/2000 00:47'!transferHalo: event from: formerHaloOwner	"Progressively transfer the halo to the next likely recipient"	| localEvt w target |	self flag: #workAround. "For halo's distinction between 'target' and 'innerTarget' we need to bypass any renderers."	(formerHaloOwner == self and:[self isRenderer and:[self wantsHaloFromClick not]]) ifTrue:[		event shiftPressed ifTrue:[			target _ owner.			localEvt _ event transformedBy: (self transformedFrom: owner).		] ifFalse:[			target _ self renderedMorph.			localEvt _ event transformedBy: (target transformedFrom: self).		].		^target transferHalo: localEvt from: target].	"Never transfer halo to top-most world"	(self isWorldMorph and:[owner isNil]) ifFalse:[		(self wantsHaloFromClick and:[formerHaloOwner ~~ self]) 			ifTrue:[^self addHalo: event from: formerHaloOwner]].	event shiftPressed ifTrue:[		"Pass it outwards"		owner ifNotNil:[^owner transferHalo: event from: formerHaloOwner].		"We're at the top level; throw the event back in to find recipient"		formerHaloOwner removeHalo.		^self processEvent: event copy resetHandlerFields.	].	self submorphsDo:[:m|		localEvt _ event transformedBy: (m transformedFrom: self).		(m fullContainsPoint: localEvt position) 			ifTrue:[^m transferHalo: event from: formerHaloOwner].	].	"We're at the bottom most level; throw the event back up to the root to find recipient"	formerHaloOwner removeHalo.	w _ self world.	localEvt _ event transformedBy: (self transformedFrom: w) inverseTransformation.	^w processEvent: localEvt resetHandlerFields.! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/8/2000 15:12'!duplicateMorph: evt	"Make and return a duplicate of the receiver's argument"	| dup |	dup _ self duplicate.	self isPartsDonor ifTrue:[		dup isPartsDonor: false.		(dup fullBounds containsPoint: evt position) 			ifFalse:[dup position: evt position]].	evt hand grabMorph: dup.	^dup! !!HaloMorph methodsFor: 'events' stamp: 'ar 10/7/2000 23:50'!blueButtonDown: event	"Transfer the halo to the next likely recipient"	target ifNil:[^self delete].	positionOffset _ event position - target position.	"wait for drags or transfer"	event hand 		waitForClicksOrDrag: self 		event: event		selectors: { #transferHalo:. nil. #startDragTarget:. }		threshold: 5.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/8/2000 14:04'!dropMorph: aMorph event: anEvent	"Drop the given morph which was carried by the hand"	| event |	event _ DropEvent new setPosition: self position contents: aMorph hand: self.	owner processEvent: event.	event wasHandled ifFalse:[aMorph rejectDropMorphEvent: event].	aMorph owner == self ifTrue:[aMorph delete].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/8/2000 15:12'!grabMorph: aMorph	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| grabbed tfm |	self releaseMouseFocus.	grabbed _ aMorph aboutToBeGrabbedBy: self.	grabbed ifNil:[^self].	grabbed _ grabbed topRendererOrSelf.	tfm _ grabbed owner ifNil:[IdentityTransform new] ifNotNil:[grabbed owner grabTransform].	grabbed _ grabbed transformedBy: tfm.	targetOffset _ grabbed position - self position.	self addMorphBack: grabbed.! !!MouseClickState methodsFor: 'initialize' stamp: 'ar 10/8/2000 15:04'!handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| localEvt timedOut isDrag |	timedOut _ (evt timeStamp - firstClickTime) > dblClickTime.	localEvt _ evt transformedBy: (clickClient transformedFrom: aHand owner).	isDrag _ (localEvt cursorPoint - firstClickDown cursorPoint) r > dragThreshold.	clickState == #firstClickDown ifTrue: [		"Careful here - if we had a slow cycle we may have a timedOut mouseUp event"		(timedOut and:[localEvt isMouseUp not]) ifTrue:[			"timeout before #mouseUp -> keep waiting for drag if requested"			clickState _ #firstClickTimedOut.			dragSelector ifNil:[				aHand resetClickState.				clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown]].			^true].		localEvt isMouseUp ifTrue:[			"If timedOut or the client's not interested in dbl clicks get outta here"			(timedOut or:[dblClickSelector isNil]) ifTrue:[				aHand resetClickState.				clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].				^true].			"Otherwise transfer to #firstClickUp"			firstClickUp _ localEvt.			clickState _ #firstClickUp.			^false].		isDrag ifTrue:["drag start"			aHand resetClickState.			dragSelector == nil "If no drag selector send #click instead"				ifTrue:[clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown]]				ifFalse:[clickClient perform: dragSelector with: localEvt].			^true].		^false].	clickState == #firstClickTimedOut ifTrue:[		localEvt isMouseUp ifTrue:["neither drag nor double click"			aHand resetClickState.			clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].			^true].		isDrag ifTrue:["drag start"			aHand resetClickState.			dragSelector ifNotNil:[clickClient perform: dragSelector with: localEvt].			^true].		^false].	clickState = #firstClickUp ifTrue:[		(timedOut) ifTrue:[			"timed out after mouseUp - send #click: and mouseUp"			aHand resetClickState.			clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].			"Note: Using aHand handleEvent here (rather than clickClient handleMouseUp:) to be consistent with a timeout before firstClickUp in which case aHand would process the up event."			aHand handleEvent: firstClickUp.			^true].		localEvt isMouseDown ifTrue:["double click"			aHand resetClickState.			dblClickSelector ifNotNil:[clickClient perform: dblClickSelector with: firstClickDown].			^false]].	^true! !!PhraseTileMorph methodsFor: 'code generation' stamp: 'ar 10/8/2000 14:54'!mouseDown: evt 	"Pretend we picked up the tile and then put it down for a trial  	positioning."	"The essence of ScriptEditor mouseEnter:"	| ed ss |	self isPartsDonor ifTrue:[^self duplicateMorph: evt].	submorphs isEmpty		ifTrue: [^ self].	owner class == TilePadMorph		ifTrue: ["picking me out of another phrase"			(ss _ submorphs first) class == TilePadMorph				ifTrue: [ss _ ss submorphs first].			owner addMorph: ss fullCopy].	(ed _ self enclosingEditor)		ifNotNil: [			evt hand grabMorph: self.			ed startStepping.			ed mouseEnterDragging: evt.			ed setProperty: #justPickedUpPhrase toValue: true.			]! !!PlayingCardMorph methodsFor: 'events' stamp: 'ar 10/8/2000 13:50'!click: evt	| root popUp |	root _ owner rootForGrabOf: self.	root == nil		ifTrue: ["Display hidden card in front"				popUp _ self copy.				self board owner owner addMorphFront: popUp.				self world displayWorld.				(Delay forMilliseconds: 750) wait.				popUp delete]		ifFalse: [evt hand grabMorph: root]! !!PlayingCardMorph methodsFor: 'events' stamp: 'ar 10/8/2000 14:24'!mouseDown: evt	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing click:, doubleClick:, or drag: message gets dispatched"	evt hand waitForClicksOrDrag: self event: evt selectors: { #click:. #doubleClick:. nil} threshold: 5! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/8/2000 14:53'!mouseEnter: evt	| hand tile |	self flag: #bob.		"needed renderedMorph due to transformations"	hand _ evt hand.	hand submorphs size = 1 ifFalse: [^self].	evt "hand lastEvent" redButtonPressed ifFalse: [^self].	tile _ hand firstSubmorph renderedMorph.	(self wantsDroppedMorph: tile event: evt) ifFalse: [^self].	(tile isKindOf: PhraseTileMorph) ifTrue: [tile brightenTiles]. 	handWithTile _ hand.	self startStepping! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/8/2000 14:54'!mouseLeave: evt	| hand tile |	owner ifNil: [^ self].	"left by being removed, not by mouse movement"	(self hasProperty: #justPickedUpPhrase) ifTrue:[		self removeProperty: #justPickedUpPhrase.		^self].	self stopStepping.	handWithTile _ nil.	self removeSpaces.	hand _ evt hand.	(hand submorphs size = 1) & (hand lastEvent redButtonPressed) ifTrue:		[tile _ hand firstSubmorph.		(tile isKindOf: PhraseTileMorph) ifTrue: [tile unbrightenTiles]].! !!SimpleButtonMorph methodsFor: 'events' stamp: 'ar 10/8/2000 14:13'!mouseDown: evt	| now dt |	now _ Time millisecondClockValue.	oldColor _ color. 	actWhen == #buttonDown		ifTrue: [self doButtonAction]		ifFalse: [	self updateVisualState: evt; refreshWorld].	dt _ Time millisecondClockValue - now max: 0.  "Time it took to do"	dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait].	(actWhen == #whilePressed) ifTrue:[		self setProperty: #doesButtonAction toValue: true.		self startStepping].! !!SimpleButtonMorph methodsFor: 'events' stamp: 'ar 10/8/2000 14:20'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	self updateVisualState: evt.! !!SimpleButtonMorph methodsFor: 'events' stamp: 'ar 10/8/2000 14:18'!mouseUp: evt	oldColor ifNotNil:		["if oldColor nil, it signals that mouse had not gone DOWN		inside me, e.g. because of a cmd-drag; in this case we want		to avoid triggering the action!!"		self color: oldColor.		oldColor _ nil.		(actWhen == #buttonUp and: [self containsPoint: evt cursorPoint])			ifTrue: [self doButtonAction]].	(actWhen == #whilePressed) ifTrue:[		self stopStepping.		self removeProperty: #doesButtonAction.	].! !!SimpleButtonMorph methodsFor: 'stepping' stamp: 'ar 10/8/2000 14:14'!step	(self hasProperty: #doesButtonAction) ifTrue:[self doButtonAction].! !!SimpleButtonMorph methodsFor: 'stepping' stamp: 'ar 10/8/2000 14:14'!stepTime	(self hasProperty: #doesButtonAction) ifTrue:[^1].	^super stepTime! !!SimpleButtonMorph methodsFor: 'stepping' stamp: 'ar 10/8/2000 14:14'!wantsSteps	^(self hasProperty: #doesButtonAction) or:[super wantsSteps]! !PlayingCardMorph removeSelector: #startDrag:!