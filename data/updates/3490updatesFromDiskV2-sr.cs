'From Squeak3.0 of 4 February 2001 [latest update: #3446] on 12 February 2001 at 4:05:57 am'!"Change Set:		applyUpdatesFromDiskV2-srDate:			12 February 2001Author:			Stephan RudlofEnhances functionality for applying updates from disk.Update and replacement of changeset applyUpdatesFromDisk-sr.Utilities	>>applyUpdatesFromDiskToUpdateNumber:stopIfGap:replaces	>>applyUpdatesFromDiskToUpdateNumber: lastUpdateNumber. So it becomes possible to update while jumping over missing updates.Utilities	>>applyUpdatesFromDiskcomputes highest update number to update exactly until the last available one (without the need to call >>applyUpdatesFromDiskToUpdateNumber:stopIfGap: with a very high limit or looking manually into the directory)."!!Utilities class methodsFor: 'fetching updates' stamp: 'sr 2/12/2001 03:38'!applyUpdatesFromDisk	"Utilities applyUpdatesFromDisk"	"compute highest update number"	| updateDirectory updateNumbers |	updateDirectory _ self getUpdateDirectoryOrNil.	updateDirectory		ifNil: [^ self].	updateNumbers _ updateDirectory fileNames				collect: [:fn | fn initialIntegerOrNil]				thenSelect: [:fn | fn notNil].	self		applyUpdatesFromDiskToUpdateNumber: (updateNumbers				inject: 0				into: [:max :num | max max: num])		stopIfGap: false! !!Utilities class methodsFor: 'fetching updates' stamp: 'sr 2/12/2001 03:40'!applyUpdatesFromDiskToUpdateNumber: lastUpdateNumber stopIfGap: stopIfGapFlag 	"To use this mechanism, be sure all updates you want to have considered 	are in a folder named 'updates' which resides in the same directory as  	your image. Having done that, simply evaluate:  	 	Utilities applyUpdatesFromDiskToUpdateNumber: 1234 stopIfGap: false  	 	and all numbered updates <= lastUpdateNumber not yet in the image will 	be loaded in numerical order."	| previousHighest currentUpdateNumber done fileNames aMessage updateDirectory loaded |	updateDirectory _ self getUpdateDirectoryOrNil.	updateDirectory ifNil: [^ self].	previousHighest _ ChangeSorter highestNumberedChangeSet.	currentUpdateNumber _ previousHighest.	done _ false.	loaded _ 0.	[done]		whileFalse: [currentUpdateNumber _ currentUpdateNumber + 1.			currentUpdateNumber > lastUpdateNumber				ifTrue: [done _ true]				ifFalse: [fileNames _ updateDirectory fileNamesMatching: currentUpdateNumber printString , '*'.					fileNames size > 1						ifTrue: [^ self inform: 'ambiguity -- two files both start with ' , currentUpdateNumber printString , '(at this point it is probably best to remedythe situation on disk, then try again.)'].					fileNames size == 0						ifTrue: [Transcript cr; show: 'gap in updates from disk for update number '; print: currentUpdateNumber; show: ' found...'.							done _ stopIfGapFlag]						ifFalse: [ChangeSorter								newChangesFromStream: (updateDirectory readOnlyFileNamed: fileNames first)								named: fileNames first.							loaded _ loaded + 1]]].	aMessage _ loaded = 0				ifTrue: ['No new updates found.']				ifFalse: [loaded printString , ' update(s) loaded.'].	self inform: aMessage , 'Highest numbered update is now ' , (currentUpdateNumber - 1) printString , '.'! !!Utilities class methodsFor: 'fetching updates' stamp: 'sr 2/12/2001 03:36'!getUpdateDirectoryOrNil	^ (FileDirectory default directoryNames includes: 'updates')		ifTrue: [FileDirectory default directoryNamed: 'updates']		ifFalse: [self inform: 'Error: cannot find "updates" folder'.			nil]! !Utilities class removeSelector: #applyUpdatesFromDiskToUpdateNumber:!