'From Squeak 2.0 of May 22, 1998 on 22 June 1998 at 2:09:47 am'!"Change Set:		SundryFixes6-21-diDate:			21 June 1998Author:			Dan IngallsOptimizes ChangeSorter updates for faster window switching.Fixes 'browseItHere' (Ctrl-B) in Morphic and adds token auto-select.Fixes ChangeSorters to not show a method after forgetting.Fixes 'find' (Cmd-f) in Morphic.Adds a new creation message to PolygonMorph.  Try it out with...	World addMorph: (PolygonMorph		shapeFromPen: [:p | p hilbert: 4 side: 7; go: 7.							p hilbert: 4 side: 7; go: 7]		color: Color red borderWidth: 1 borderColor: Color black).Adds a new method, Form>>anyShapeFill, that does a slow but sure	job of filling shapes, as opposed to convexShapeFill:.Adds the menu item 'proper fill'/'quick fill' to polygons (and curves)."!StringHolder subclass: #ChangeSorter	instanceVariableNames: 'parent myChangeSet currentClassName currentSelector priorChangeSetList '	classVariableNames: 'AllChangeSets '	poolDictionaries: ''	category: 'Interface-Changes'!Pen subclass: #PenPointRecorder	instanceVariableNames: 'points '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Browser methodsFor: 'accessing' stamp: 'di 6/21/1998 22:20'!couldBrowseAnyClass	"Answer whether the receiver is equipped to browse any class. This is in support of the system-brower feature that allows the browser to be redirected at the selected class name.  This implementation is clearly ugly, but the feature it enables is handsome enough.  3/1/96 sw"	self dependents		detect: [:d |			((d isKindOf: PluggableListView) or: [d isKindOf: PluggableListMorph]) and: 			[d getListSelector == #systemCategoryList]]		ifNone: [^ false].	^ true! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:02'!update	"recompute all of my panes"	self updateIfNecessary.	parent ifNotNil: [(parent other: self) updateIfNecessary]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:19'!updateIfNecessary	"recompute all of my panes"	| newList |	self okToChange ifFalse: [^ self].	priorChangeSetList == nil		ifTrue: [priorChangeSetList _ self changeSetList.				self changed: #changeSetList]		ifFalse: [newList _ self changeSetList.				priorChangeSetList = newList ifFalse:					[priorChangeSetList _ newList.					self changed: #changeSetList]].	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/22/1998 02:08'!forget	"Drop this method from the changeSet"	self okToChange ifFalse: [^ self].	currentSelector ifNotNil: [		myChangeSet removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.		currentSelector _ nil.		self showChangeSet: myChangeSet]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/21/1998 23:13'!removeFromCurrentChanges	"Redisplay after removal in case we are viewing the current changeSet"	super removeFromCurrentChanges.	currentSelector _ nil.	self showChangeSet: myChangeSet! !!Form methodsFor: 'filling' stamp: 'di 6/21/1998 10:21'!anyShapeFill	"Fill the interior of the outtermost outlined region in the receiver, a 1-bit deep form.  Typically the resulting form is used with fillShape: to paint a solid color.  See also convexShapeFill:"	| shape |	shape _ (self findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: self to: 0@0 rule: Form erase.	^ shape! !!Form methodsFor: 'filling' stamp: 'di 6/21/1998 10:21'!convexShapeFill: aMask 	"Fill the interior of the outtermost outlined region in the receiver.  The outlined region must not be concave by more than 90 degrees.  Typically aMask is Color black, to produce a solid fill. then the resulting form is used with fillShape: to paint a solid color.  See also anyShapeFill"	| destForm tempForm |	destForm _ Form extent: self extent.  destForm fillBlack.	tempForm _ Form extent: self extent.	(0@0) fourNeighbors do:		[:dir |  "Smear self in all 4 directions, and AND the result"		self displayOn: tempForm at: (0@0) - self offset.		tempForm smear: dir distance: (dir dotProduct: tempForm extent).		tempForm displayOn: destForm at: 0@0			clippingBox: destForm boundingBox			rule: Form and fillColor: nil].	destForm displayOn: self at: 0@0		clippingBox: self boundingBox		rule: Form over fillColor: aMask! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/21/1998 22:24'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b |	(((b _ model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ view flash].	model okToChange ifFalse: [^ view flash].	self selectWord.	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[foundClass _ (Smalltalk at: aSymbol ifAbsent: [nil]).			foundClass isNil ifTrue: [^ view flash].			(foundClass isKindOf: Class)				ifTrue:					[model systemCategoryListIndex: 						(model systemCategoryList indexOf: foundClass category).		model classListIndex: (model classList indexOf: foundClass name)]]! !!Pen methodsFor: 'operations' stamp: 'di 6/21/1998 09:37'!fill: drawBlock color: color	| region tileForm tilePen shape saveColor recorder |	drawBlock value: (recorder _ self as: PenPointRecorder).	region _ Rectangle encompassing: recorder points.	tileForm _ Form extent: region extent+6.	tilePen _ Pen newOnForm: tileForm.	tilePen location: location-(region origin-3)		direction: direction		penDown: penDown.	drawBlock value: tilePen.  "Draw the shape in B/W"	saveColor _ halftoneForm.	drawBlock value: self.	halftoneForm _ saveColor.	shape _ (tileForm findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: tileForm to: 0@0 rule: Form erase.	destForm fillShape: shape fillColor: color at: region origin-3! !!PenPointRecorder reorganize!('all' drawFrom:to: points)!!PenPointRecorder methodsFor: 'all' stamp: 'di 6/21/1998 09:35'!drawFrom: p1 to: p2.	"Overridden to skip drawing but track bounds of the region traversed."	points == nil ifTrue:		[points _ OrderedCollection new: 1000.		points addLast: p1].	points addLast: p2! !!PenPointRecorder methodsFor: 'all' stamp: 'di 6/21/1998 09:35'!points	^ points! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 6/21/1998 22:19'!getListSelector	^ getListSelector! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 6/22/1998 01:32'!selectionInterval: sel	selectionInterval _ sel! !!PolygonMorph methodsFor: 'access' stamp: 'di 6/21/1998 12:23'!quickFill: trueOrFalse	quickFill _ trueOrFalse.	filledForm _ nil.	self changed! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 6/21/1998 21:10'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^ false].	closed & color isTransparent not ifTrue:		[self filledForm colors: (Array with: Color white with:Color black).		^ (filledForm pixelValueAt: aPoint - boundstopLeft + 1) = 1]	ifFalse:		[self lineSegmentsDo:			[:p1 :p2 | (aPoint onLineFrom: p1 to: p2 within: (2 max: borderWidth+1//2) asFloat)					ifTrue: [^ true]].		arrowForms ifNotNil: [arrowForms do:			[:f | (f pixelValueAt: aPoint - f offset) > 0					ifTrue: [^ true]]].		^ false]! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 6/21/1998 21:10'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not ifTrue:		[self filledForm colors: (Array with: Color transparent with: color).		aCanvas image: self filledForm at: bounds topLeft-1].	lineColor _ borderColor.  bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: [topLeftColor _ color lighter.						bottomRightColor _ color darker.  bevel _ true].	borderColor == #inset ifTrue: [topLeftColor _ owner colorForInsets darker.						bottomRightColor _ owner colorForInsets lighter.  bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth+1//2.	brush _ nil.	self lineSegmentsDo:		[:p1 :p2 | p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) <=					((p1i max: p2i) min: bigClipRect corner)]) ifTrue:			[bevel ifTrue: [((p1i quadrantOf: p2i) > 2)						ifTrue: [lineColor _ topLeftColor]						ifFalse: [lineColor _ bottomRightColor]].			(borderWidth > 3 and: [borderColor isColor])			ifTrue: [brush == nil ifTrue:						[brush _ (ColorForm dotOfSize: borderWidth)								colors: (Array with: Color transparent with: borderColor)].					aCanvas line: p1i to: p2i brushForm: brush]			ifFalse: [aCanvas line: p1i to: p2i							width: borderWidth color: lineColor]]].	self arrowForms ifNotNil:		[self arrowForms do:			[:f | f colors: (Array with: Color transparent with: borderColor).			aCanvas image: f at: f offset]]! !!PolygonMorph methodsFor: 'menu' stamp: 'di 6/21/1998 12:17'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	handles == nil		ifTrue: [aCustomMenu add: 'show handles' action: #addHandles]		ifFalse: [aCustomMenu add: 'hide handles' action: #removeHandles].	quickFill		ifTrue: [aCustomMenu add: 'proper fill' selector: #quickFill: argument: false]		ifFalse: [aCustomMenu add: 'quick fill' selector: #quickFill: argument: true].	closed ifTrue: [aCustomMenu add: 'open polygon' action: #makeOpen]		ifFalse:		[aCustomMenu add: 'close polygon' action: #makeClosed.		arrows == #none ifFalse: [aCustomMenu add: '---' action: #makeNoArrows].		arrows == #forward ifFalse: [aCustomMenu add: '-->' action: #makeForwardArrow].		arrows == #back ifFalse: [aCustomMenu add: '<--' action: #makeBackArrow].		arrows == #both ifFalse: [aCustomMenu add: '<-->' action: #makeBothArrows]]! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/21/1998 15:24'!curveBounds	^ (Rectangle encompassing: vertices) expandBy: borderWidth+1//2! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/21/1998 21:15'!filledForm	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ ColorForm extent: bounds extent+2. "for anyShapeFill"	bb _ (BitBlt toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft asIntegerPoint-1.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	quickFill ifTrue: [filledForm convexShapeFill: Color black]			ifFalse: [filledForm _ ColorForm mappingWhiteToTransparentFrom: filledForm anyShapeFill].	^ filledForm! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 6/21/1998 10:24'!shapeFromPen: penBlock color: c borderWidth: bw borderColor: bc	"World addMorph: (PolygonMorph		shapeFromPen: [:p |				p hilbert: 4 side: 5.				p go: 5.				p hilbert: 4 side: 5.				p go: 5.]		color: Color red borderWidth: 1 borderColor: Color black)"	| pen |	penBlock value: (pen _ PenPointRecorder new).	^ (self vertices: pen points color: c borderWidth: bw borderColor: bc)		quickFill: false! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 6/22/1998 01:32'!againOrSame: bool	super againOrSame: bool.	morph editView selectionInterval: self selectionInterval! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/22/1998 01:31'!editView	^ editView! !PolygonMorph removeSelector: #rotate:around:!TextMorphEditor removeSelector: #againOnce:!Smalltalk removeClassNamed: #PenRegionTracer!