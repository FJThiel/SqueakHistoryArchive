'From Squeak2.7alpha of October 23, 1999 [latest update: #1587] on 27 November 1999 at 8:32:19 pm'!"Change Set:		ScamperForms-Fixes2Date:			27 November 1999Author:			Bolot KerimbaevSome more fixes and enhancements for Scamper:- password font (all chars=$*)- upload form field supportpassword font is generated each time it is used"!TextInput subclass: #FileInput	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Forms'!!FileInput commentStamp: 'bolot 11/27/1999 18:37' prior: 0!An input field for <INPUT TYPE="file">Support for uploading files using HTTP/multipart formsAppearance/behavior as in NS/MS browsers(i.e., separate filename entry box and browse files button)!!FileInput methodsFor: 'accessing' stamp: 'bolot 11/27/1999 19:37'!browse	| file |	file _ (StandardFileMenu oldFileFrom: self directory) ifNil: [^nil].	file directory isNil ifTrue: [^ nil].	textMorph setText: (file directory pathName, FileDirectory slash, file name);		hasUnacceptedEdits: true;		accept! !!FileInput methodsFor: 'accessing' stamp: 'bolot 11/27/1999 18:56'!directory	^FileDirectory forFileName: self filename! !!FileInput methodsFor: 'accessing' stamp: 'bolot 11/27/1999 18:43'!filename	textMorph hasUnacceptedEdits ifTrue: [ textMorph accept ].	^textMorph getText asString withInternetLineEndings! !!FileInput methodsFor: 'accessing' stamp: 'bolot 11/27/1999 18:58'!localFilename	^FileDirectory localNameFor: self filename! !!FileInput methodsFor: 'accessing' stamp: 'bolot 11/27/1999 19:23'!url	^FileUrl new path: (self directory pathParts), {self localFilename}		isAbsolute: true! !!FileInput methodsFor: 'accessing' stamp: 'bolot 11/27/1999 18:55'!value	^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self filename)		content: nil		url: self url! !!FileInput class methodsFor: 'instance creation' stamp: 'bolot 11/27/1999 18:36'!name: aString textMorph: aTextMorph	^self name: aString defaultValue: '' textMorph: aTextMorph! !!FormInputSet methodsFor: 'action' stamp: 'bolot 11/3/1999 03:09'!submit	"collect inputs and instruct the browser to do a submission"	| inputValues |	inputValues _ Dictionary new.	inputs do: [ :input |		input active ifTrue: [			(inputValues includesKey: input name) ifFalse: [				inputValues at: input name  put: (OrderedCollection new: 1) ].			(inputValues at: input name)  add: input value ] ].	browser submitFormWithInputs: inputValues url: form url		method: form method encoding: form encoding.	^true! !!HTTPSocket class methodsFor: 'get the page' stamp: 'bolot 11/27/1999 20:31'!httpPostMultipart: url args: argsDict accept: mimeType request: requestString	" do multipart/form-data encoding rather than x-www-urlencoded "	" by Bolot Kerimbaev, 1998 "	" this version is a memory hog: puts the whole file in memory "	| serverName serverAddr s header length bare page list firstData aStream port argsStream specifiedServer type newUrl mimeBorder fieldValue |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxyServer ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].	mimeBorder _ '---------squeak-georgia-tech-csl-cool-stuff-----'.	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	argsStream nextPutAll: mimeBorder, CrLf.	argsDict associationsDo: [:assoc |		assoc value do: [ :value |		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue _ value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', CrLf, 'Content-Type: ', value contentType.				fieldValue _ (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: CrLf, CrLf, fieldValue, CrLf, CrLf, mimeBorder, CrLf.	]].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName, ':', port asString; cr.	s sendCommand: 'POST ', page, ' HTTP/1.1', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: multipart/form-data; boundary=', mimeBorder, CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpPostDocument: newUrl  args: argsDict  accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HtmlForm methodsFor: 'attributes' stamp: 'bolot 11/27/1999 19:21'!encoding	"encoding for posting"	^self getAttribute: 'enctype' default: nil.  ! !!HtmlInput methodsFor: 'formatting' stamp: 'bolot 11/27/1999 18:47'!addFileInputToFormatter: formatter	"is it a submit button?"	| inputMorph size fileInput |	inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.	size _ (self getAttribute: 'size' default: '12') asNumber.	inputMorph extent: (size*10@20).	fileInput _ FileInput name: self name textMorph: inputMorph.	formatter addMorph: inputMorph;		addMorph: ((PluggableButtonMorph on: fileInput getState: nil action: #browse)				label: 'Browse').	formatter currentFormData addInput: fileInput! !!HtmlInput methodsFor: 'formatting' stamp: 'bolot 11/2/1999 14:20'!addTextInputToFormatter: formatter	"is it a submit button?"	| inputMorph size |	inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.	self type = 'password'		ifTrue: [inputMorph font: (StrikeFont passwordFontSize: 12)].	size _ (self getAttribute: 'size' default: '12') asNumber.	inputMorph extent: (size*10@20).	formatter addMorph: inputMorph.	formatter currentFormData addInput:		(TextInput name: self name defaultValue: self defaultValue  textMorph: inputMorph).! !!HtmlInput methodsFor: 'formatting' stamp: 'bolot 11/27/1999 18:48'!addToFormatter: formatter	"is it a submit button?"	self type = 'submit' ifTrue: [		formatter addMorph: ((PluggableButtonMorph on: formatter currentFormData getState: nil action: #submit) label: (self getAttribute: 'value' default: 'Submit')).		^self ].	self type = 'image'		ifTrue: [^self addImageButtonToFormatter: formatter].	(self type = 'text' or: [self type = 'password'])		ifTrue: [^self addTextInputToFormatter: formatter].	self type = 'hidden' ifTrue: [		formatter currentFormData addInput: (HiddenInput name: self name  value: self defaultValue).		^self ].	self type = 'radio' ifTrue: [ 		^self addRadioButtonToFormatter: formatter ].	self type = 'checkbox' ifTrue: [ 		^self addCheckBoxButtonToFormatter: formatter ].	self type = 'file' ifTrue: [ 		^self addFileInputToFormatter: formatter ].	formatter addString: '[form input of type: ', self type, ']'.! !!HttpUrl methodsFor: 'downloading' stamp: 'bolot 11/3/1999 03:05'!postMultipartFormArgs: args	| contents request std oldRealm encoded |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpPostMultipart: self toText args: args				accept: 'application/octet-stream' request: request).	(contents isKindOf: String) ifTrue: [		(contents beginsWith: 'HTTP/1.0 401 Unauthorized') ifTrue: [			std _ (PWS unauthorizedFor: '') findTokens: '"'.			(contents beginsWith: (std at: 1)) ifTrue: [				oldRealm _ realm.				realm _ (contents findTokens: '"') at: 2.				Passwords ifNil: [Passwords _ Dictionary new].				encoded _ Passwords at: realm ifAbsent: [nil].				(oldRealm ~= realm) & (encoded ~~ nil) 					ifTrue: [^ self postFormArgs: args]					ifFalse: ["ask the user"						self askNamePassword ifTrue: [^ self postFormArgs: args]]				]].		^MIMEDocument contentType: 'text/plain' content: 'error occured retrieving ', self toText, ': ', contents].	contents contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: contents content url: contents url ].	^contents! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'bolot 11/2/1999 03:18'!font: aFont	textMorph beAllFont: aFont! !!Scamper methodsFor: 'changing page' stamp: 'bolot 11/3/1999 03:08'!submitFormWithInputs: inputs url: url method: method encoding: encoding	| newUrl newSource | 	self stopEverything.	(method asLowercase ~= 'get' and: [ method asLowercase ~= 'post' ]) ifTrue: [		self notify: 'unkown FORM method: ', method.		^false ].	newUrl _ url asUrlRelativeTo: currentUrl.		newUrl schemeName ~= 'http' ifTrue: [		self notify: 'I can only submit forms via HTTP'.		^false ].	self status: 'submitting form...'.	downloadingProcess _ [		method asLowercase = 'get' 			ifTrue: [newSource _ newUrl retrieveContentsArgs: inputs] 			ifFalse: [				encoding = MIMEDocument contentTypeMultipart					ifTrue: [newSource _ newUrl postMultipartFormArgs: inputs]					ifFalse: [newSource _ newUrl postFormArgs: inputs]].		documentQueue nextPut:  newSource.		downloadingProcess _ nil.	] newProcess.	downloadingProcess resume.	^true! !!StrikeFont class methodsFor: 'instance creation' stamp: 'bolot 11/2/1999 02:53'!passwordFontSize: aSize	| aFont newXTable newGlyphs |	aFont _ (StrikeFont familyName: #NewYork10 size: aSize) copy.	newXTable _ aFont xTable copy.	newGlyphs _ aFont glyphs copy.	aFont instVarNamed: 'xTable' put: newXTable.	aFont instVarNamed: 'glyphs' put: newGlyphs.	aFont minAscii to: aFont maxAscii do: [:ascii |		aFont characterFormAt: ascii asCharacter put: (aFont characterFormAt: $*)].	^aFont! !FileInput removeSelector: #name!FileInput removeSelector: #name:textMorph:!