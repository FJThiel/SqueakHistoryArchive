'From Squeak3.6alpha of ''17 March 2003'' [latest update: #5278] on 29 June 2003 at 10:32:28 pm'!"Change Set:		ContextEnh-ajhDate:			29 June 2003Author:			Anthony HannanReviewer:		Andreas RaabThis adds some control behavior to contexts and processes and refactors the exceptions and the debugger to use them.  The debugger quickStep has been fixed to execute in the context of the debugged process so earlier exception handlers will be active.  Finally, some compiler enhancements have been made to make it compatible with ClosureCompiler-ajh.PreContextEnh-ajh must be filed-in before this, and PostContextEnh-ajh must be filed-in after this.  This must be filed-in before ClosureCompiler-ajh.(merged more recent changes to Environment class>>reorganizeEverything -dew)"!CodeHolder subclass: #Debugger	instanceVariableNames: 'interruptedProcess interruptedController contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC sourceMap tempNames savedCursor isolationHead failedProject errorWasInUIProcess labelString theMethodNode '	classVariableNames: 'ContextStackKeystrokes ErrorRecursion '	poolDictionaries: ''	category: 'Tools-Debugger'!Exception subclass: #Abort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!Error subclass: #BlockCannotReturn	instanceVariableNames: 'result deadHome '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!InstructionClient subclass: #InstructionPrinter	instanceVariableNames: 'method scanner stream oldPC indent '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!Error subclass: #MessageNotUnderstood	instanceVariableNames: 'message receiver '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!ParseNode subclass: #MethodNode	instanceVariableNames: 'selectorOrFalse precedence arguments block literals primitive encoder temporaries sourceText '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!Exception subclass: #UnhandledError	instanceVariableNames: 'exception '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!ProtoObject methodsFor: 'system primitives' stamp: 'ajh 1/13/2002 17:02'!cannotInterpret: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but a null methodDictionary was encountered while looking up the message selector.  Hopefully this is the result of encountering a stub for a swapped out class which induces this exception on purpose.""If this is the result of encountering a swap-out stub, then simulating the lookup in Smalltalk should suffice to install the class properly, and the message may be resent."	(self class lookupSelector: aMessage selector) == nil ifFalse:		["Simulated lookup succeeded -- resend the message."		^ aMessage sentTo: self].	"Could not recover by simulated lookup -- it's an error"	Error signal: 'MethodDictionary fault'.	"Try again in case an error handler fixed things"	^ aMessage sentTo: self! !!ProtoObject methodsFor: 'system primitives' stamp: 'ajh 10/9/2001 17:20'!doesNotUnderstand: aMessage	^ MessageNotUnderstood new 		message: aMessage;		receiver: self;		signal! !!Object methodsFor: 'error handling' stamp: 'ajh 10/9/2001 17:21'!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."	"Testing: (3 activeProcess)"	(Preferences autoAccessors and: [self tryToDefineVariableAccess: aMessage])		ifTrue: [^ aMessage sentTo: self].	^ MessageNotUnderstood new 		message: aMessage;		receiver: self;		signal! !!Object methodsFor: 'error handling' stamp: 'ajh 9/7/2002 21:20'!subclassResponsibility	"This message sets up a framework for the behavior of the class' subclasses.	Announce that the subclass should have implemented this message."	self error: 'My subclass should have overridden ', thisContext sender methodSelector printString! !!Object methodsFor: 'message handling' stamp: 'ajh 1/28/2003 12:32'!withArgs: argArray executeMethod: compiledMethod	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelector: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class removeSelectorSimply: selector]! !!Object methodsFor: 'testing' stamp: 'ajh 1/21/2003 13:15'!isBlock	^ false! !!Behavior methodsFor: 'accessing' stamp: 'ajh 9/19/2001 17:30'!classDepth	superclass ifNil: [^ 1].	^ superclass classDepth + 1! !!Behavior methodsFor: 'creating method dictionary' stamp: 'ajh 6/11/2001 16:59'!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode |	method _ oldClass compiledMethodAt: selector.	trailer _ method trailer.	methodNode _ self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self addSelector: selector withMethod: (methodNode generate: trailer).! !!Behavior methodsFor: 'creating method dictionary' stamp: 'ajh 6/11/2001 17:05'!recompileNonResidentMethod: method atSelector: selector from: oldClass	"Recompile the method supplied in the context of this class."	| trailer methodNode |	trailer _ method trailer.	methodNode _ self compilerClass new			compile: (method getSourceFor: selector in: oldClass)			in: self			notifying: nil			ifFail: ["We're in deep doo-doo if this fails (syntax error).				Presumably the user will correct something and proceed,				thus installing the result in this methodDict.  We must				retrieve that new method, and restore the original (or remove)				and then return the method we retrieved."				^ self error: 'see comment'].	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	^ methodNode generate: trailer! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'ajh 10/17/2002 11:03'!allowsSubInstVars	"Classes that allow instances to change classes among its subclasses will want to override this and return false, so inst vars are not accidentally added to its subclasses."	^ true! !!ClassBuilder methodsFor: 'validation' stamp: 'ajh 10/17/2002 11:10'!validateInstvars: instVarArray from: oldClass forSuper: newSuper	"Check if any of the instVars of oldClass conflict with the new superclass"	| instVars usedNames temp |	instVarArray isEmpty ifTrue:[^true]. "Okay"	newSuper allowsSubInstVars ifFalse: [		self error: newSuper printString, ' does not allow subclass inst vars. See allowsSubInstVars.'. ^ false].	"Validate the inst var names"	usedNames _ instVarArray asSet.	usedNames size = instVarArray size 		ifFalse:[	instVarArray do:[:var|					usedNames remove: var ifAbsent:[temp _ var]].				self error: temp,' is multiply defined'. ^false].	(usedNames includesAnyOf: self reservedNames) 		ifTrue:[	self reservedNames do:[:var|					(usedNames includes: var) ifTrue:[temp _ var]].				self error: temp,' is a reserved name'. ^false].	newSuper == nil ifFalse:[		usedNames _ newSuper allInstVarNames asSet.		instVarArray do:[:iv|			(usedNames includes: iv) ifTrue:[				newSuper withAllSuperclassesDo:[:cl|					(cl instVarNames includes: iv) ifTrue:[temp _ cl]].				self error: iv,' is already defined in ', temp name.				^false]]].	oldClass == nil ifFalse:[		usedNames _ Set new: 20.		oldClass allSubclassesDo:[:cl| usedNames addAll: cl instVarNames].		instVars _ instVarArray.		newSuper == nil ifFalse:[instVars _ instVars, newSuper allInstVarNames].		instVars do:[:iv|			(usedNames includes: iv) ifTrue:[				self error: iv, ' is already defined in a subclass of ', oldClass name.				^false]]].	^true! !!ClassCategoryReader methodsFor: 'private' stamp: 'ajh 1/18/2002 01:14'!theClass	^ class! !!CompiledMethod methodsFor: 'accessing' stamp: 'ajh 11/17/2001 14:30'!trailer	| end trailer |	end _ self endPC.	trailer _ ByteArray new: self size - end.	end + 1 to: self size do: [:i | 		trailer at: i - end put: (self at: i)].	^ trailer! !!CompiledMethod methodsFor: 'printing' stamp: 'ajh 2/9/2003 14:17'!longPrintOn: aStream	"List of all the byte codes in a method with a short description of each" 	self longPrintOn: aStream indent: 0! !!CompiledMethod methodsFor: 'printing' stamp: 'ar 6/28/2003 00:08'!longPrintOn: aStream indent: tabs	"List of all the byte codes in a method with a short description of each" 	self isQuick ifTrue: 		[self isReturnSpecial ifTrue:			[^ aStream tab: tabs; nextPutAll: 'Quick return ' , 				(#('self' 'true' 'false' 'nil' '-1' '0' '1' '2') at: self primitive - 255)].		^ aStream nextPutAll: 'Quick return field ' , self returnField printString , ' (0-based)'].	self primitive = 0 ifFalse: [		aStream tab: tabs.		self printPrimitiveOn: aStream.	].	(InstructionPrinter on: self) indent: tabs; printInstructionsOn: aStream.! !!CompiledMethod methodsFor: 'printing' stamp: 'ajh 6/27/2003 22:21'!symbolic	"Answer a String that contains a list of all the byte codes in a method 	with a short description of each."	| aStream |	aStream _ WriteStream on: (String new: 1000).	self longPrintOn: aStream.	^aStream contents! !!CompiledMethod methodsFor: 'source code management' stamp: 'ajh 8/13/2002 18:19'!sourceClass	"Get my receiver class (method class) from the preamble of my source.  Return nil if not found."	^ [(Compiler evaluate: (self sourceFileStream backChunk "blank"; backChunk "preamble")) theClass] on: Error do: [nil]! !!CompiledMethod methodsFor: 'source code management' stamp: 'ajh 8/13/2002 18:18'!sourceFileStream 	"Answer the sources file stream with position set at the beginning of my source string"	| pos |	(pos _ self filePosition) = 0 ifTrue: [^ nil].	^ (RemoteString newFileNumber: self fileIndex position: pos) fileStream! !!CompiledMethod methodsFor: 'source code management' stamp: 'ajh 8/13/2002 18:28'!sourceSelector	"Answer my selector extracted from my source.  If no source answer nil"	| sourceString |	sourceString _ self getSourceFromFile ifNil: [^ nil].	^ Compiler parserClass new parseSelector: sourceString! !!CompiledMethod methodsFor: 'evaluating' stamp: 'ajh 1/28/2003 12:33'!valueWithReceiver: aReceiver arguments: anArray 	^ aReceiver withArgs: anArray executeMethod: self! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 2/3/2003 21:18'!blockNode	BlockNodeCache key == self ifTrue: [^ BlockNodeCache value].	^ self blockNodeIn: nil! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 5/28/2003 01:10'!blockNodeIn: homeMethodNode	"Return the block node for self"	homeMethodNode ifNil: [		^ self decompilerClass new decompileBlock: self].	homeMethodNode ir compiledMethod.  "generate method"	homeMethodNode nodesDo: [:node |		(node isBlock and:		 [node scope isInlined not and:		  [node ir compiledMethod = self]])			ifTrue: [				BlockNodeCache _ self -> node.				^ node]	].	self errorNodeNotFound! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 2/9/2003 19:45'!decompile	"Return the decompiled parse tree that represents self"	^ self decompileClass: nil selector: nil! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 2/9/2003 19:44'!decompileClass: aClass selector: selector	"Return the decompiled parse tree that represents self"	^ self decompilerClass new decompile: selector in: aClass method: self! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ar 6/28/2003 00:05'!decompilerClass	^Decompiler! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 2/9/2003 13:11'!isClosureCompiled	"Return true if this method was compiled with the new closure compiler, Parser2 (compiled while Preference compileBlocksAsClosures was true).  Return false if it was compiled with the old compiler."	^ self header < 0! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 2/9/2003 00:22'!methodNode	"Return the parse tree that represents self"	^ self methodNodeDecompileClass: nil selector: nil! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 3/3/2003 12:02'!methodNodeDecompileClass: aClass selector: selector	"Return the parse tree that represents self"	| source |	^ (source _ self getSourceFromFile)		ifNil: [self decompileClass: aClass selector: selector]		ifNotNil: [self parserClass new parse: source class: (self sourceClass ifNil: [aClass])]! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ar 6/28/2003 00:05'!parserClass	^Parser! !!CompiledMethod class methodsFor: 'class initialization' stamp: 'ajh 7/18/2001 02:04'!smallFrameSize	^ SmallFrame! !!Compiler methodsFor: 'public access' stamp: 'ajh 9/14/2002 18:47'!parse: textOrStream in: aClass notifying: req dialect: useDialect        "Compile the argument, textOrStream, with respect to the class, aClass,         and answer the MethodNode that is the root of the resulting parse tree.         Notify the argument, req, if an error occurs. The failBlock is defaulted to         an empty block."        self from: textOrStream class: aClass context: nil notifying: req.        ^ ((useDialect and: [RequestAlternateSyntaxSetting signal])                ifTrue: [self dialectParserClass]                ifFalse: [self parserClass]) new                        parse: sourceStream                        class: class                        noPattern: false                        context: context                        notifying: requestor                        ifFail: []! !!Compiler methodsFor: 'private' stamp: 'ajh 9/19/2002 02:19'!cacheDoItNode: boolean	cacheDoItNode _ boolean! !!Compiler methodsFor: 'private' stamp: 'ar 6/28/2003 00:05'!dialectParserClass	^DialectParser! !!Compiler methodsFor: 'private' stamp: 'ajh 1/21/2003 12:44'!format: aStream noPattern: noPattern ifFail: failBlock	| tree |	tree _ 		self parserClass new			parse: aStream			class: class			noPattern: noPattern			context: context			notifying: requestor			ifFail: [^ failBlock value].	^ tree! !!Compiler methodsFor: 'private' stamp: 'ajh 1/21/2003 12:45'!translate: aStream noPattern: noPattern ifFail: failBlock	| tree |	tree _ 		self parserClass new			parse: aStream			class: class			noPattern: noPattern			context: context			notifying: requestor			ifFail: [^ failBlock value].	^ tree! !!ControlManager methodsFor: 'scheduling' stamp: 'ajh 12/31/2001 15:15'!spawnNewProcess	self activeController: self screenController! !!Debugger methodsFor: 'accessing' stamp: 'ajh 3/21/2003 00:44'!contents: aText notifying: aController 	"The retrieved information has changed and its source must now be 	updated. In this case, the retrieved information is the method of the 	selected context."	| selector classOfMethod category h ctxt |	contextStackIndex = 0 ifTrue: [^ false].	self selectedContext isExecutingBlock ifTrue: [		h _ self selectedContext finalBlockHome.		h ifNil: [self inform: 'Method not found for block, can''t edit'. ^ false].		(self confirm: 'I will have to revert to the method fromwhich this block originated.  Is that OK?')			ifTrue: [self resetContext: h]			ifFalse: [^ false]	].	classOfMethod _ self selectedClass.	category _ self selectedMessageCategoryName.	selector _ Compiler parserClass new parseSelector: aText.	selector == self selectedMessageName		ifFalse: [self inform: 'can''t change selector'. ^ false].	selector _ classOfMethod		compile: aText		classified: category		notifying: aController.	selector ifNil: [^ false].  "compile cancelled"	contents _ aText.	ctxt _ self selectedContext.	interruptedProcess		popTo: ctxt;		restartTopWith: (classOfMethod compiledMethodAt: selector);		stepToSendOrReturn.	contextVariablesInspector object: nil.	theMethodNode _ ctxt methodNode.	sourceMap _ theMethodNode sourceMap.	tempNames _ theMethodNode tempNames.	self resetContext: ctxt.	^true! !!Debugger methodsFor: 'context stack (message list)' stamp: 'ajh 9/25/2001 00:14'!fullyExpandStack	"Expand the stack to include all of it, rather than the first four or five	contexts."	self okToChange ifFalse: [^ self].	self newStack: contextStackTop contextStack.	self changed: #contextStackList! !!Debugger methodsFor: 'context stack (message list)' stamp: 'ajh 3/19/2003 13:40'!selectedMessage	"Answer the source code of the currently selected context."	contents _ theMethodNode sourceText.	Preferences browseWithPrettyPrint ifTrue: [		contents _ self selectedClass compilerClass new				format: contents				in: self selectedClass				notifying: nil				decorated: Preferences colorWhenPrettyPrinting].	^ contents _ contents asText makeSelectorBold! !!Debugger methodsFor: 'context stack (message list)' stamp: 'ajh 9/7/2002 21:15'!selectedMessageName	"Answer the message selector of the currently selected context."	^self selectedContext methodSelector! !!Debugger methodsFor: 'context stack menu' stamp: 'ajh 1/24/2003 13:35'!doStep	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext newContext |	self okToChange ifFalse: [^ self].	self checkContextSelection.	currentContext _ self selectedContext.	interruptedProcess completeStep: currentContext.	newContext _ interruptedProcess stepToSendOrReturn.	self contextStackIndex > 1		ifTrue: 			[self resetContext: newContext]		ifFalse: 			[newContext == currentContext				ifTrue: [					self changed: #contentsSelection.					self updateInspectors]				ifFalse: [					self resetContext: newContext]]! !!Debugger methodsFor: 'context stack menu' stamp: 'ajh 1/24/2003 12:29'!proceed: aTopView 	"Proceed from the interrupted state of the currently selected context. The 	argument is the topView of the receiver. That view is closed."	self okToChange ifFalse: [^ self].	self checkContextSelection.	self resumeProcess: aTopView! !!Debugger methodsFor: 'context stack menu' stamp: 'ajh 1/24/2003 12:27'!restart	"Proceed from the initial state of the currently selected context. The 	argument is a controller on a view of the receiver. That view is closed."	"Closing now depends on a preference #restartAlsoProceeds - hmm 9/7/2001 16:46"	self okToChange ifFalse: [^ self].	self checkContextSelection.	interruptedProcess		popTo: self selectedContext;		restartTop;		stepToSendOrReturn.	self resetContext: self selectedContext.	Preferences restartAlsoProceeds ifTrue: [self proceed]! !!Debugger methodsFor: 'context stack menu' stamp: 'ajh 1/24/2003 12:29'!send	"Send the selected message in the accessed method, and take control in 	the method invoked to allow further step or send."	self okToChange ifFalse: [^ self].	self checkContextSelection.	interruptedProcess step: self selectedContext.	self resetContext: interruptedProcess stepToSendOrReturn.! !!Debugger methodsFor: 'context stack menu' stamp: 'ajh 1/24/2003 12:46'!stepIntoBlock	"Send messages until you return to the present method context.	 Used to step into a block in the method."	interruptedProcess stepToHome: self selectedContext.	self resetContext: interruptedProcess stepToSendOrReturn.! !!Debugger methodsFor: 'code pane' stamp: 'ar 6/28/2003 00:03'!pcRange	"Answer the indices in the source code for the method corresponding to 	the selected context's program counter value."	| i pc end |	(selectingPC and: [contextStackIndex ~= 0])		ifFalse: [^1 to: 0].	sourceMap == nil ifTrue:		[sourceMap _ theMethodNode sourceMap.		tempNames _ theMethodNode tempNames.		self selectedContext method cacheTempNames: tempNames].	sourceMap size = 0 ifTrue: [^1 to: 0].	Smalltalk at: #RBProgramNode ifPresent:[:nodeClass|		(theMethodNode isKindOf: nodeClass) ifTrue: [			pc _ contextStackIndex = 1				ifTrue: [self selectedContext pc]				ifFalse: [self selectedContext previousPc].			i _ sourceMap findLast:[:pcRange | pcRange key <= pc].			i = 0 ifTrue:[^ 1 to: 0].			^ (sourceMap at: i) value		].	].	pc_ self selectedContext pc -		(("externalInterrupt" true and: [contextStackIndex=1])			ifTrue: [1]			ifFalse: [2]).	i _ sourceMap indexForInserting: (Association key: pc value: nil).	i < 1 ifTrue: [^1 to: 0].	i > sourceMap size		ifTrue:			[end _ sourceMap inject: 0 into:				[:prev :this | prev max: this value last].			^ end+1 to: end].	^(sourceMap at: i) value! !!Debugger methodsFor: 'private' stamp: 'ajh 1/23/2003 19:34'!contextStackIndex: anInteger oldContextWas: oldContext	| newMethod |	contextStackIndex _ anInteger.	anInteger = 0		ifTrue:			[theMethodNode _ tempNames _ sourceMap _ contents _ nil.			self changed: #contextStackIndex.			self contentsChanged.			contextVariablesInspector object: nil.			receiverInspector object: self receiver.			^self].	(newMethod _ oldContext == nil or:		[oldContext method ~~ self selectedContext method])		ifTrue:			[tempNames _ sourceMap _ nil.			theMethodNode _ self selectedContext methodNode.			contents _ self selectedMessage.			self contentsChanged.			self pcRange "will compute tempNamesunless noFrills"].	self changed: #contextStackIndex.	tempNames == nil		ifTrue: [tempNames _ 					self selectedClassOrMetaClass parserClass new parseArgsAndTemps: contents notifying: nil].	contextVariablesInspector object: self selectedContext.	receiverInspector object: self receiver.	newMethod ifFalse: [self changed: #contentsSelection]! !!Debugger methodsFor: 'private' stamp: 'ajh 9/25/2001 00:14'!resetContext: aContext 	"Used when a new context becomes top-of-stack, for instance when the	method of the selected context is re-compiled, or the simulator steps or	returns to a new method. There is room for much optimization here, first	to save recomputing the whole stack list (and text), and secondly to avoid	recomposing all that text (by editing the paragraph instead of recreating it)."	| oldContext |	oldContext _ self selectedContext.	contextStackTop _ aContext.	self newStack: contextStackTop contextStack.	self changed: #contextStackList.	self contextStackIndex: 1 oldContextWas: oldContext.	self changed: #content.! !!Debugger methodsFor: 'private' stamp: 'ajh 1/24/2003 12:25'!resumeProcess: aTopView 	Smalltalk isMorphic		ifFalse: [aTopView erase].	savedCursor		ifNotNil: [Sensor currentCursor: savedCursor].	isolationHead		ifNotNil: [failedProject enterForEmergencyRecovery.			isolationHead invoke.			isolationHead _ nil].	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate)		ifFalse: [			Smalltalk isMorphic				ifTrue: [errorWasInUIProcess						ifTrue: [Project resumeProcess: interruptedProcess]						ifFalse: [interruptedProcess resume]]				ifFalse: [ScheduledControllers activeControllerNoTerminate: interruptedController andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil.	"Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: [aTopView delete.			World displayWorld]		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.	"restart low space handler"	errorWasInUIProcess == false		ifFalse: [Processor terminateActive]! !!Debugger class methodsFor: 'class initialization' stamp: 'hg 10/2/2001 20:44'!openContext: aContext label: aString contents: contentsStringOrNil	| isolationHead |	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	<primitive: 19> "Simulation guard"	ErrorRecursion not & Preferences logDebuggerStackToFile ifTrue:		[Smalltalk logError: aString inContext: aContext to: 'SqueakDebug.log'].	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		(isolationHead _ CurrentProjectRefactoring currentIsolationHead)			ifNil: [self primitiveError: aString]			ifNotNil: [isolationHead revoke]].	ErrorRecursion _ true.	self informExistingDebugger: aContext label: aString.	(Debugger context: aContext isolationHead: isolationHead)		openNotifierContents: contentsStringOrNil		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!Debugger class methodsFor: 'instance creation' stamp: 'di 4/14/2000 16:29'!context: aContext isolationHead: isolationHead	"Answer an instance of me for debugging the active process starting with the given context."	^ self new		process: Processor activeProcess		controller:			((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: aContext		isolationHead: isolationHead! !!Debugger class methodsFor: 'opening' stamp: 'ajh 9/14/2002 22:22'!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	<primitive: 19> "Simulation guard"	[	| debugger |		debugger _ self new			process: process			controller: ((Smalltalk isMorphic not and: [ScheduledControllers activeControllerProcess == process]) ifTrue: [ScheduledControllers activeController])			context: context.		bool ifTrue: [debugger openFullNoSuspendLabel: title]			ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].		Preferences logDebuggerStackToFile ifTrue: [			Smalltalk logError: title inContext: context to: 'SqueakDebug.log'].		process isSuspended ifFalse: [process suspend].	] on: Error do: [:ex |		self primitiveError: 			'Orginal error: ', 			title asString, '.Debugger error: ', 			([ex description] on: Error do: ['a ', ex class printString]), ':'	]! !!Encoder methodsFor: 'initialize-release' stamp: 'ajh 1/24/2003 18:46'!nTemps: n literals: lits class: cl 	"Decompile."	supered _ false.	class _ cl.	nTemps _ n.	literalStream _ ReadStream on: lits.	literalStream position: lits size.	sourceRanges _ Dictionary new: 32.	globalSourceRanges _ OrderedCollection new: 32.! !!Environment class methodsFor: 'system conversion' stamp: 'ajh 9/13/2002 23:01'!reorganizeEverything	"Undertake a grand reorganization.	Environment reorganizeEverything.	"	| bigCat envt pool s |	"First check for clashes between environment names and existing globals..."	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			[(Smalltalk includesKey: bigCat) ifTrue:				[^ self error: bigCat , ' cannot be used to nameboth a package and a class or other global variable.No reorganization will be attempted.']]].	(self confirm:'Your image is about to be partitioned into environments.Many things may not work after this, so you should beworking in a throw-away copy of your working image.Are you really ready to procede?(choose ''no'' to stop here safely)')		ifFalse: [^ self inform: 'No changes were made'].	ChangeSet newChanges: (ChangeSet basicNewNamed: 'Reorganization').	"Recreate the Smalltalk dictionary as the top-level Environment."	Smalltalk at: #Smalltalk put: (SmalltalkEnvironment newFrom: Smalltalk).	Smalltalk setName: #Smalltalk inOuterEnvt: nil.	"Don't hang onto old copy of Smalltalk ."	Smalltalk recreateSpecialObjectsArray.	Smalltalk allClassesDo:		[:c | c environment: nil. "Flush any old values"].	"Run through all categories making up new sub-environments"	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			["Not a kernel category ..."			envt _ Smalltalk at: bigCat						ifAbsent: ["... make up a new environment if necessary ..."									Smalltalk makeSubEnvironmentNamed: bigCat].			"... and install the member classes in that category"			envt transferBindingsNamedIn: (SystemOrganization listAtCategoryNamed: cat)									from: Smalltalk].		].	"Move all shared pools that are only referred to in sub environments"	Smalltalk associationsDo:		[:assn | ((pool _ assn value) isMemberOf: Dictionary) ifTrue:			[s _ IdentitySet new.			Smalltalk allClassesAnywhereDo:				[:c | c sharedPools do:					[:p | p == pool ifTrue:						[s add: c environment]]].			(s size = 1 and: [(envt _ s someElement) ~~ Smalltalk]) ifTrue:				[envt declare: assn key from: Smalltalk]]].	Smalltalk rewriteIndirectRefs.	ChangeSet newChanges: (ChangeSet basicNewNamed: 'PostReorganization').	ChangeSorter initialize.	Preferences enable: #browserShowsPackagePane.! !!Exception methodsFor: '*Refactory-RBAddons' stamp: 'ajh 2/16/2003 17:37'!searchFrom: aContext	" Set the context where the handler search will start. "	signalContext := aContext contextTag! !!Exception methodsFor: 'handling' stamp: 'ajh 2/1/2003 01:32'!isNested	"Determine whether the current exception handler is within the scope of another handler for the same exception."	^ handlerContext nextHandlerContext canHandleSignal: self! !!Exception methodsFor: 'handling' stamp: 'ajh 6/27/2003 22:13'!outer	"Evaluate the enclosing exception action and return to here instead of signal if it resumes (see #resumeUnchecked:)."	| prevOuterContext |	self isResumable ifTrue: [		prevOuterContext _ outerContext.		outerContext _ thisContext contextTag.	].	self pass.! !!Exception methodsFor: 'handling' stamp: 'ajh 2/1/2003 01:33'!pass	"Yield control to the enclosing exception action for the receiver."	handlerContext nextHandlerContext handleSignal: self! !!Exception methodsFor: 'handling' stamp: 'ajh 1/22/2003 23:04'!resignalAs: replacementException	"Signal an alternative exception in place of the receiver."	self resumeUnchecked: replacementException signal! !!Exception methodsFor: 'handling' stamp: 'ajh 1/13/2002 15:09'!resume	"Return from the message that signaled the receiver."	self resume: nil! !!Exception methodsFor: 'handling' stamp: 'ajh 1/13/2002 15:14'!resume: resumptionValue	"Return resumptionValue as the value of the signal message."	self isResumable ifFalse: [IllegalResumeAttempt signal].	self resumeUnchecked: resumptionValue! !!Exception methodsFor: 'handling' stamp: 'ajh 6/27/2003 22:30'!resumeUnchecked: resumptionValue	"Return resumptionValue as the value of #signal, unless this was called after an #outer message, then return resumptionValue as the value of #outer."	| ctxt |	outerContext ifNil: [		signalContext return: resumptionValue	] ifNotNil: [		ctxt _ outerContext.		outerContext _ ctxt tempAt: 1. "prevOuterContext in #outer"		ctxt return: resumptionValue	].! !!Exception methodsFor: 'handling' stamp: 'ajh 1/29/2003 13:36'!retry	"Abort an exception handler and re-evaluate its protected block."	handlerContext restart! !!Exception methodsFor: 'handling' stamp: 'ajh 1/29/2003 13:37'!retryUsing: alternativeBlock	"Abort an exception handler and evaluate a new block in place of the handler's protected block."	handlerContext restartWithNewReceiver: alternativeBlock! !!Exception methodsFor: 'handling' stamp: 'ajh 9/30/2001 15:33'!return	"Return nil as the value of the block protected by the active exception handler."	self return: nil! !!Exception methodsFor: 'handling' stamp: 'ajh 1/29/2003 13:37'!return: returnValue	"Return the argument as the value of the block protected by the active exception handler."	handlerContext return: returnValue! !!Exception methodsFor: 'printing' stamp: 'ajh 10/24/2002 19:24'!description	"Return a textual description of the exception."	^ self messageText ifNil: [self class name asString]! !!Exception methodsFor: 'printing' stamp: 'ajh 9/30/2001 15:33'!messageText	"Return an exception's message text."	^messageText! !!Exception methodsFor: 'printing' stamp: 'ajh 9/30/2001 15:33'!printOn: stream	stream nextPutAll: self description! !!Exception methodsFor: 'printing' stamp: 'ajh 10/22/2001 14:24'!receiver	^ self signalerContext receiver! !!Exception methodsFor: 'printing' stamp: 'ar 6/28/2003 00:13'!signalerContext	"Find the first sender of signal(:)"	^ signalContext findContextSuchThat: [:ctxt |		(ctxt receiver == self or: [ctxt receiver == self class]) not]! !!Exception methodsFor: 'signaling' stamp: 'ajh 9/30/2001 15:33'!messageText: signalerText	"Set an exception's message text."	messageText := signalerText! !!Exception methodsFor: 'signaling' stamp: 'ajh 2/1/2003 01:33'!signal	"Ask ContextHandlers in the sender chain to handle this signal.  The default is to execute and return my defaultAction."	signalContext _ thisContext contextTag.	^ thisContext nextHandlerContext handleSignal: self! !!Exception methodsFor: 'signaling' stamp: 'ajh 9/30/2001 20:13'!signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	self messageText: signalerText.	^ self signal! !!Exception methodsFor: 'priv handling' stamp: 'ajh 9/30/2001 15:33'!defaultAction	"The default action taken if the exception is signaled."	self subclassResponsibility! !!Exception methodsFor: 'priv handling' stamp: 'ajh 2/1/2003 00:58'!isResumable	"Determine whether an exception is resumable."	^ true! !!Exception methodsFor: 'priv handling' stamp: 'ajh 1/29/2003 13:44'!privHandlerContext: aContextTag	handlerContext _ aContextTag! !!Abort methodsFor: 'as yet unclassified' stamp: 'ajh 3/24/2003 00:55'!defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	UnhandledError signalForException: self! !!Error methodsFor: 'private' stamp: 'ajh 2/1/2003 00:54'!isResumable	"Determine whether an exception is resumable."	^ false! !!Error methodsFor: 'exceptionDescription' stamp: 'ajh 9/4/2002 19:24'!defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	UnhandledError signalForException: self! !!BlockCannotReturn methodsFor: 'accessing' stamp: 'ajh 2/6/2002 11:12'!deadHome	^ deadHome! !!BlockCannotReturn methodsFor: 'accessing' stamp: 'ajh 2/6/2002 11:12'!deadHome: context	deadHome _ context! !!Exception class methodsFor: 'exceptionInstantiator' stamp: 'ajh 9/30/2001 21:54'!signal	"Signal the occurrence of an exceptional condition."	^ self new signal! !!Exception class methodsFor: 'exceptionInstantiator' stamp: 'ajh 9/30/2001 21:54'!signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	^ self new signal: signalerText! !!Exception class methodsFor: 'exceptionSelector' stamp: 'ajh 9/30/2001 15:33'!, anotherException	"Create an exception set."	^ExceptionSet new		add: self;		add: anotherException;		yourself! !!Exception class methodsFor: 'exceptionSelector' stamp: 'ajh 9/30/2001 15:33'!handles: exception	"Determine whether an exception handler will accept a signaled exception."	(exception isKindOf: Halt) ifTrue: [^ false].	^ exception isKindOf: self! !!IllegalResumeAttempt methodsFor: 'comment' stamp: 'ajh 9/4/2002 19:24'!defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	UnhandledError signalForException: self! !!IllegalResumeAttempt methodsFor: 'comment' stamp: 'ajh 2/1/2003 00:57'!isResumable		^ false! !!InstructionPrinter methodsFor: 'accessing' stamp: 'ajh 6/27/2003 22:25'!indent	^ indent ifNil: [0]! !!InstructionPrinter methodsFor: 'initialize-release' stamp: 'ajh 2/9/2003 14:16'!indent: numTabs	indent _ numTabs! !!InstructionPrinter methodsFor: 'printing' stamp: 'ajh 6/27/2003 22:26'!print: instruction 	"Append to the receiver a description of the bytecode, instruction." 	| code |	stream tab: self indent; print: oldPC; space.	stream nextPut: $<.	oldPC to: scanner pc - 1 do: 		[:i | 		code _ (method at: i) radix: 16.		stream nextPut: 			(code size < 5				ifTrue: [$0]				ifFalse: [code at: 4]).		stream nextPut: code last; space].	stream skip: -1.	stream nextPut: $>.	stream space.	stream nextPutAll: instruction.	stream cr.	oldPC _ scanner pc.	"(InstructionPrinter compiledMethodAt: #print:) symbolic."! !!InstructionPrinter methodsFor: 'printing' stamp: 'ajh 6/27/2003 22:26'!pushConstant: obj	"Print the Push Constant, obj, on Top Of Stack bytecode."	self print: 'pushConstant: ' , (String streamContents: [:s |		(obj isKindOf: LookupKey)			ifFalse: [s withStyleFor: #literal do: [obj printOn: s]]			ifTrue: [obj key				ifNotNil: [s nextPutAll: '##'; nextPutAll: obj key]				ifNil: [s nextPutAll: '###'; nextPutAll: obj value soleInstance name]]	]).	(obj isKindOf: CompiledMethod) ifTrue: [		obj longPrintOn: stream indent: self indent + 2. ^ self].	Smalltalk at: #BlockClosure ifPresent:[:aClass|		(obj isKindOf: aClass) ifTrue: [			obj method longPrintOn: stream indent: self indent + 2. ^ self]].! !!InstructionStream methodsFor: 'testing' stamp: 'ajh 8/13/2002 11:34'!willBlockReturn	^ (self method at: pc) = Encoder blockReturnCode! !!InstructionStream methodsFor: 'testing' stamp: 'ajh 8/13/2002 11:10'!willJump	"unconditionally"	| byte |	byte _ self method at: pc.	^ (byte between: 144 and: 151) or: [byte between: 160 and: 167]! !!InstructionStream methodsFor: 'testing' stamp: 'ajh 8/13/2002 17:32'!willJustPop	^ (self method at: pc) = Encoder popCode! !!InstructionStream methodsFor: 'decoding' stamp: 'ajh 7/29/2001 20:45'!atEnd	^ pc > self method endPC! !!InstructionStream methodsFor: 'scanning' stamp: 'ajh 5/30/2003 01:34'!previousPc	| currentPc dummy prevPc |	currentPc _ pc.	pc _ self method initialPC.	dummy _ Message catcher.	[pc = currentPc] whileFalse: [		prevPc _ pc.		self interpretNextInstructionFor: dummy.	].	^ prevPc! !!InstructionStream methodsFor: 'private' stamp: 'ajh 8/1/2001 02:57'!pc: n	pc _ n! !!ContextPart methodsFor: 'accessing' stamp: 'ajh 2/9/2003 00:21'!methodNode	| selector methodClass |	selector _ self receiver class		selectorAtMethod: self method		setClass: [:mclass | methodClass _ mclass].	^ self method methodNodeDecompileClass: methodClass selector: selector! !!ContextPart methodsFor: 'instruction decoding' stamp: 'ajh 1/24/2003 16:35'!methodReturnConstant: value 	"Simulate the action of a 'return constant' bytecode whose value is the 	argument, value. This corresponds to a source expression like '^0'."	^ self return: value from: self home! !!ContextPart methodsFor: 'instruction decoding' stamp: 'ajh 1/24/2003 16:34'!methodReturnReceiver	"Simulate the action of a 'return receiver' bytecode. This corresponds to 	the source expression '^self'."	^ self return: self receiver from: self home! !!ContextPart methodsFor: 'instruction decoding' stamp: 'ajh 1/24/2003 16:34'!methodReturnTop	"Simulate the action of a 'return top of stack' bytecode. This corresponds 	to source expressions like '^something'."	^ self return: self pop from: self home! !!ContextPart methodsFor: 'debugger access' stamp: 'ajh 9/25/2001 00:12'!contextStack 	"Answer an Array of the contexts on the receiver's sender chain."	^self stackOfSize: 100000! !!ContextPart methodsFor: 'debugger access' stamp: 'ajh 9/7/2002 21:15'!methodSelector	"Answer the selector of the method that created the receiver."	^self receiver class 		selectorAtMethod: self method 		setClass: [:ignored]! !!ContextPart methodsFor: 'debugger access' stamp: 'ajh 1/24/2003 00:03'!singleRelease	"Remove information from the receiver in order to break circularities."	stackp == nil ifFalse: [1 to: stackp do: [:i | self at: i put: nil]].	sender _ nil.	pc _ nil.! !!ContextPart methodsFor: 'debugger access' stamp: 'ajh 2/9/2003 12:25'!tempNames	"Answer an OrderedCollection of the names of the receiver's temporary 	variables, which are strings."	^ self methodNode tempNames! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 1/24/2003 01:41'!jump	"Abandon thisContext thread and execute self instead.  You probably should save thisContext's sender before calling this so you can jump back to it."	thisContext privSender: self.	^ nil! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 1/24/2003 20:16'!jumpTop	"Same as jump except do not add a return result to self's stack, leave stack as is.  Meant for contexts that have been halted before sending."	| top |	stackp = 0 ifTrue: [self stepToSendOrReturn].	stackp = 0 ifTrue: [self push: nil].  "must be quick return self/constant"	top _ self pop.	thisContext privSender: self.	^ top! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 2/1/2003 12:39'!restart	"Roll back thisContext to self and resume from beginning.  Execute unwind blocks when rolling back.  ASSUMES self is a sender of thisContext"	| ctxt unwindBlock |	self isDead ifTrue: [self cannotReturn: nil to: self].	self privRefresh.	[	ctxt _ thisContext findNextUnwindContextUpTo: self.		ctxt isNil	] whileFalse: [		unwindBlock _ ctxt tempAt: 1.		thisContext terminateTo: ctxt sender.		unwindBlock value.	].	thisContext terminateTo: self.	self jumpTop.! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 6/27/2003 22:17'!resume	"Roll back thisContext to self and resume.  Execute unwind blocks when rolling back.  ASSUMES self is a sender of thisContext"	self resume: nil! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 6/27/2003 22:16'!resume: value	"Roll back thisContext to self and resume with value as result of last send.  Execute unwind blocks when rolling back.  ASSUMES self is a sender of thisContext"	| ctxt unwindBlock |	self isDead ifTrue: [self cannotReturn: value to: self].	[	ctxt _ thisContext findNextUnwindContextUpTo: self.		ctxt isNil	] whileFalse: [		unwindBlock _ ctxt tempAt: 1.		thisContext terminateTo: ctxt sender.		unwindBlock value.	].	thisContext terminateTo: self.	^ value! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 1/21/2003 19:27'!return	"Unwind until my sender is on top"	self return: self receiver! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 2/1/2003 12:38'!return: value	"Roll back thisContext to self and return value to self's sender.  Execute any unwind blocks on the way.  ASSUMES self is a sender of thisContext"	| ctxt unwindBlock |	(sender isNil or: [sender isDead]) ifTrue: [self cannotReturn: value to: sender].	[	ctxt _ thisContext findNextUnwindContextUpTo: self.		ctxt isNil	] whileFalse: [		unwindBlock _ ctxt tempAt: 1.		thisContext terminateTo: ctxt sender.		unwindBlock value.	].	thisContext terminateTo: self sender.	^ value! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 1/24/2003 23:17'!return: value from: aContext	"Return value to aContext's sender.  If aContext is not self then do remote return by calling return: from self and resuming until the return is complete.  This is done so unwind blocks will be executed in context of self's thread (not thisContext thread which is simulating it)."	| topContext here error ctxt |	self == aContext ifTrue: [		"Do local return"		topContext _ self sender.		self singleRelease.		topContext ifNotNil: [topContext push: value].		^ topContext	].	"Activate a remote #return: context"	topContext _ self activateReturn: aContext value: value.	"Insert ensure: and on:do: under aContext that will halt when reached"	here _ thisContext.	error _ false.	ctxt _ aContext insertSender: (ContextPart		contextOn: UnhandledError do: [:ex | error			ifTrue: [ex pass]			ifFalse: [error _ true. topContext _ thisContext. here jump]]).	ctxt _ ctxt insertSender: (ContextPart		contextEnsure: [error ifFalse: [topContext _ thisContext. here jump]]).	"Execute remote return"	topContext jumpTop.  "do not add return value when jumping to it"	"'here jump' resumes here"	topContext push: nil.  "since we jump out of the topContext in the blocks above before pushing a block return value"	"If no unhandled error was raised, remove ensure: context and step down to sender"	error ifFalse: [		topContext _ topContext stepToCallee.		topContext == ctxt ifTrue: [^ topContext stepToCallee].  "pop ensure: & return"		"topContext must be ContextPart>>#return:, step until it returns"		ctxt _ topContext.		[ctxt isDead] whileFalse: [topContext _ topContext step].	].	^ topContext! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 1/24/2003 15:30'!return: value to: sendr 	"Simulate the return of value to sendr."	self releaseTo: sendr.	sendr ifNil: [^ nil].	^ sendr push: value! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 2/1/2003 12:38'!suspend	"Roll back thisContext to self, while executing unwind blocks, then suspend the current process.  ASSUMES self is a sender of thisContext"	| ctxt unwindBlock |	self isDead ifTrue: [self cannotReturn: nil to: self].	[	ctxt _ thisContext findNextUnwindContextUpTo: self.		ctxt isNil	] whileFalse: [		unwindBlock _ ctxt tempAt: 1.		thisContext terminateTo: ctxt sender.		unwindBlock value.	].	thisContext terminateTo: self.	Processor activeProcess suspend.! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 1/24/2003 00:56'!terminate	"Make myself unresumable."	sender _ nil.	pc _ nil.! !!ContextPart methodsFor: 'printing' stamp: 'ajh 3/17/2003 09:25'!printOn: aStream 	| selector class mclass |	self method == nil ifTrue: [^ super printOn: aStream].	selector _ 		(class _ self receiver class) 			selectorAtMethod: self method 			setClass: [:c | mclass _ c].	selector == #?		ifTrue: 			[aStream nextPut: $?; print: self method who.			^self].	aStream nextPutAll: class name.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass name.			aStream nextPut: $)].	aStream nextPutAll: '>>'.	aStream nextPutAll: selector.	selector = #doesNotUnderstand: ifTrue: [		aStream space.		(self tempAt: 1) selector printOn: aStream.	].! !!ContextPart methodsFor: 'system simulation' stamp: 'ajh 1/24/2003 22:54'!stepToCallee	"Step to callee or sender"	| ctxt |	ctxt _ self.	[(ctxt _ ctxt step) == self] whileTrue.	^ ctxt! !!ContextPart methodsFor: 'private' stamp: 'ajh 1/24/2003 16:17'!activateReturn: aContext value: value	"Activate 'aContext return: value' in place of self, so execution will return to aContext's sender"	| meth |	meth _ aContext class lookupSelector: #return:.	meth primitive = 0 ifFalse: [^ self error: '#return: must not be a primitive'].	^ self		activateMethod: meth		withArgs: {value}		receiver: aContext		class: aContext class! !!ContextPart methodsFor: 'private' stamp: 'ajh 6/29/2003 15:32'!cannotReturn: result to: homeContext	"The receiver tried to return result to homeContext that no longer exists."	^ BlockCannotReturn new		result: result;		deadHome: homeContext;		signal! !!ContextPart methodsFor: 'private' stamp: 'ajh 1/27/2003 21:18'!copyTo: aContext blocks: dict	"Copy self and my sender chain down to, but not including, aContext.  End of copied chain will have nil sender.  BlockContexts whose home is also copied will point to the copy.  However, blockContexts that are not on the stack but may be later will not have their home pointing in the new copied thread.  So an error will be raised if one of these tries to return directly to its home."	| copy |	self == aContext ifTrue: [^ nil].	copy _ self copy.	dict at: self ifPresent: [:blocks | blocks do: [:b | b privHome: copy]].	self sender ifNotNil: [		copy privSender: (self sender copyTo: aContext blocks: dict)].	^ copy! !!ContextPart methodsFor: 'private' stamp: 'ajh 1/24/2003 00:50'!cut: aContext	"Cut aContext and its senders from my sender chain"	| ctxt callee |	ctxt _ self.	[ctxt == aContext] whileFalse: [		callee _ ctxt.		ctxt _ ctxt sender.		ctxt ifNil: [aContext ifNotNil: [self error: 'aContext not a sender']].	].	callee privSender: nil.! !!ContextPart methodsFor: 'private' stamp: 'ajh 1/24/2003 23:17'!insertSender: aContext	"Insert aContext and its sender chain between me and my sender.  Return new callee of my original sender."	| ctxt |	ctxt _ aContext bottom.	ctxt privSender: self sender.	self privSender: aContext.	^ ctxt! !!ContextPart methodsFor: 'private' stamp: 'ajh 1/23/2003 22:35'!privSender: aContext 	sender _ aContext! !!ContextPart methodsFor: 'private-exceptions' stamp: 'ajh 2/1/2003 01:30'!canHandleSignal: exception	"Sent to handler (on:do:) contexts only.  If my exception class (first arg) handles exception then return true, otherwise forward this message to the next handler context.  If none left, return false (see nil>>canHandleSignal:)"	^ (((self tempAt: 1) handles: exception) and: [self tempAt: 3])		or: [self nextHandlerContext canHandleSignal: exception].! !!ContextPart methodsFor: 'private-exceptions' stamp: 'ajh 6/27/2003 20:47'!handleSignal: exception	"Sent to handler (on:do:) contexts only.  If my exception class (first arg) handles exception then execute my handle block (second arg), otherwise forward this message to the next handler context.  If none left, execute exception's defaultAction (see nil>>handleSignal:)."	| val |	(((self tempAt: 1) handles: exception) and: [self tempAt: 3]) ifFalse: [		^ self nextHandlerContext handleSignal: exception].	exception privHandlerContext: self contextTag.	self tempAt: 3 put: false.  "disable self while executing handle block"	val _ [(self tempAt: 2) valueWithPossibleArgs: {exception}]		ensure: [self tempAt: 3 put: true].	self return: val.  "return from self if not otherwise directed in handle block"! !!ContextPart methodsFor: 'private-exceptions' stamp: 'ajh 2/1/2003 00:20'!nextHandlerContext	^ self sender findNextHandlerContextStarting! !!ContextPart methodsFor: 'private-exceptions' stamp: 'ajh 1/21/2003 17:59'!unwindTo: aContext	| ctx unwindBlock |	ctx := self.	[(ctx _ ctx findNextUnwindContextUpTo: aContext) isNil] whileFalse: [		unwindBlock := ctx tempAt: 1.		unwindBlock == nil ifFalse: [			ctx tempAt: 1 put: nil.			unwindBlock value]	].! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/24/2003 12:35'!blockHome	^ self! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/24/2003 00:12'!bottom	"Return the bottom of my sender chain"	^ self findContextSuchThat: [:c | c sender isNil]! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/27/2003 18:35'!copyStack	^ self copyTo: nil! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/27/2003 21:20'!copyTo: aContext	"Copy self and my sender chain down to, but not including, aContext.  End of copied chain will have nil sender.  BlockContexts whose home is also copied will point to the copy.  However, blockContexts that are not on the stack but may be later will not have their home pointing in the new copied thread.  So an error will be raised if one of these tries to return directly to its home.  It is best to use BlockClosures instead.  They only hold a ContextTag, which will work for all copies of the original home context."	^ self copyTo: aContext blocks: IdentityDictionary new! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/24/2003 00:12'!findContextSuchThat: testBlock	"Search self and my sender chain for first one that satisfies testBlock.  Return nil if none satisfy"	| ctxt |	ctxt _ self.	[ctxt isNil] whileFalse: [		(testBlock value: ctxt) ifTrue: [^ ctxt].		ctxt _ ctxt sender.	].	^ nil! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/24/2003 19:42'!hasContext: aContext 	"Answer whether aContext is me or one of my senders"	^ (self findContextSuchThat: [:c | c == aContext]) notNil! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/24/2003 00:04'!isDead	"Has self finished"	^ pc isNil! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/24/2003 22:28'!secondFromBottom	"Return the second from bottom of my sender chain"	self sender ifNil: [^ nil].	^ self findContextSuchThat: [:c | c sender sender isNil]! !!BlockContext methodsFor: 'initialize-release' stamp: 'ajh 1/23/2003 20:27'!privRefresh	"Reinitialize the receiver so that it is in the state it was at its creation."	nargs = 0 ifFalse: [self error: 'can only refresh block contexts that have zero arguments'].	pc _ startpc.	self stackp: 0.! !!BlockContext methodsFor: 'accessing' stamp: 'ajh 1/24/2003 12:35'!blockHome	^ self home! !!BlockContext methodsFor: 'accessing' stamp: 'ajh 1/31/2003 23:29'!finalBlockHome	^ self home! !!BlockContext methodsFor: 'accessing' stamp: 'ajh 1/21/2003 13:16'!isBlock	^ true! !!BlockContext methodsFor: 'accessing' stamp: 'ajh 1/31/2003 12:12'!isExecutingBlock	^ true! !!BlockContext methodsFor: 'accessing' stamp: 'ajh 9/28/2001 02:16'!isMethodContext	^ false! !!BlockContext methodsFor: 'accessing' stamp: 'ajh 1/30/2003 15:45'!reentrant	"Copy before calling so multiple activations can exist"	^ self copy! !!BlockContext methodsFor: 'evaluating' stamp: 'ajh 1/13/2002 13:36'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver, and normally return it's value.  If an error occurs, the errorHandlerBlock is evaluated, and it's value is instead returned.  The errorHandlerBlock must accept zero, one, or two parameters (the error message and the receiver)."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'ZeroDivide' = err				ifTrue: [Float infinity]				ifFalse: [self error: err]]"	^ self on: Error do: [:ex |		errorHandlerBlock valueWithPossibleArgs: {ex description. ex receiver}]! !!BlockContext methodsFor: 'scheduling' stamp: 'ajh 10/16/2002 11:14'!forkAndWait	"Suspend current process and execute self in new process, when it completes resume current process"	| semaphore |	semaphore _ Semaphore new.	[self ensure: [semaphore signal]] fork.	semaphore wait.! !!BlockContext methodsFor: 'instruction decoding' stamp: 'ajh 1/24/2003 16:35'!blockReturnTop	"Simulate the interpreter's action when a ReturnTopOfStack bytecode is 	encountered in the receiver."	| save dest |	save _ home.	"Needed because return code will nil it"	dest _ self return: self pop from: self.	home _ save.	sender _ nil.	^ dest! !!BlockContext methodsFor: 'private' stamp: 'ajh 1/24/2003 20:36'!aboutToReturn: result through: firstUnwindContext 	"Called from VM when an unwindBlock is found between self and its home.  Return to home's sender, executing unwind blocks on the way."	self home return: result! !!BlockContext methodsFor: 'private' stamp: 'ajh 1/27/2003 21:18'!copyTo: aContext blocks: dict	"Copy self and my sender chain down to, but not including, aContext.  End of copied chain will have nil sender.  BlockContexts whose home is also copied will point to the copy.  However, blockContexts that are not on the stack but may be later will not have their home pointing in the new copied thread.  So an error will be raised if one of these tries to return directly to its home."	| copy |	self == aContext ifTrue: [^ nil].	copy _ self copy.	(dict at: self home ifAbsentPut: [OrderedCollection new]) add: copy.	self sender ifNotNil: [		copy privSender: (self sender copyTo: aContext blocks: dict)].	^ copy! !!BlockContext methodsFor: 'private' stamp: 'ajh 1/27/2003 21:08'!privHome: context	home _ context! !!BlockContext methodsFor: 'exceptions' stamp: 'ajh 1/24/2003 23:40'!ensure: aBlock	"Evaluate a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes."	| returnValue |	<primitive: 198>	returnValue := self value.	"aBlock wasn't nil when execution of this method began; it is nil'd out by the unwind machinery, and that's how we know it's already been evaluated ... otherwise, obviously, it needs to be evaluated"	aBlock == nil ifFalse: [aBlock value].	^returnValue! !!BlockContext methodsFor: 'exceptions' stamp: 'ajh 1/24/2003 21:43'!ifCurtailed: aBlock	"Evaluate the receiver with an abnormal termination action."	<primitive: 198>	^ self value! !!BlockContext methodsFor: 'exceptions' stamp: 'ar 3/6/2001 14:25'!on: exception do: handlerAction	"Evaluate the receiver in the scope of an exception handler."	| handlerActive |	<primitive: 199>	handlerActive _ true.	^self value! !!BlockContext methodsFor: 'exceptions' stamp: 'ajh 10/9/2001 16:51'!onDNU: selector do: handleBlock	"Catch MessageNotUnderstood exceptions but only those of the given selector (DNU stands for doesNotUnderstand:)"	^ self on: MessageNotUnderstood do: [:exception |		exception message selector = selector			ifTrue: [handleBlock valueWithPossibleArgs: {exception}]			ifFalse: [exception pass]	  ]! !!BlockContext methodsFor: 'exceptions' stamp: 'ajh 1/24/2003 21:53'!valueUninterruptably	"Temporarily make my home Context unable to return control to its sender, to guard against circumlocution of the ensured behavior."	^ self ifCurtailed: [^ self]! !!ContextPart class methodsFor: 'special context creation' stamp: 'ajh 1/24/2003 14:31'!contextEnsure: block	"Create an #ensure: context that is ready to return from executing its receiver"	| ctxt chain |	ctxt _ thisContext.	[chain _ thisContext sender cut: ctxt. ctxt jump] ensure: block.	"jump above will resume here without unwinding chain"	^ chain! !!ContextPart class methodsFor: 'special context creation' stamp: 'ajh 1/24/2003 14:31'!contextOn: exceptionClass do: block	"Create an #on:do: context that is ready to return from executing its receiver"	| ctxt chain |	ctxt _ thisContext.	[chain _ thisContext sender cut: ctxt. ctxt jump] on: exceptionClass do: block.	"jump above will resume here without unwinding chain"	^ chain! !!Message methodsFor: 'accessing' stamp: 'ajh 10/9/2001 16:32'!lookupClass	^ lookupClass! !!MessageNotUnderstood methodsFor: 'exceptionBuilder' stamp: 'ajh 10/9/2001 16:31'!messageText	"Return an exception's message text."	^messageText == nil		ifTrue:			[message == nil				ifTrue: [super messageText]				ifFalse: [message lookupClass printString, ' ', message selector asString, '?']]		ifFalse: [messageText]! !!MessageNotUnderstood methodsFor: 'exceptionBuilder' stamp: 'ajh 10/9/2001 16:38'!receiver: obj	receiver _ obj! !!MessageNotUnderstood methodsFor: 'exceptionDescription' stamp: 'ajh 10/9/2001 16:39'!receiver	"Answer the receiver that did not understand the message"	^ receiver! !!MethodContext methodsFor: 'initialize-release' stamp: 'ajh 1/23/2003 20:27'!privRefresh	"Reinitialize the receiver so that it is in the state it was at its creation."	pc _ method initialPC.	self stackp: method numTemps.	method numArgs+1 to: method numTemps		do: [:i | self tempAt: i put: nil]! !!MethodContext methodsFor: 'initialize-release' stamp: 'ajh 5/22/2003 16:28'!privRefreshWith: aCompiledMethod 	"Reinitialize the receiver as though it had been for a different method. 	Used by a Debugger when one of the methods to which it refers is 	recompiled."	method _ aCompiledMethod.	receiverMap _ nil.	self privRefresh! !!MethodContext methodsFor: 'accessing' stamp: 'ajh 1/31/2003 16:55'!blockHome	"If executing closure, search senders for method containing my closure method.  If not found return nil."	| m |	self isExecutingBlock ifFalse: [^ self].	self sender ifNil: [^ nil].	m _ self method.	^ self sender findContextSuchThat: [:c | c method hasLiteralThorough: m]! !!MethodContext methodsFor: 'accessing' stamp: 'ajh 1/31/2003 23:29'!finalBlockHome	"If executing closure, search senders for original method containing my closure method.  If not found return nil."	| h |	self isExecutingBlock ifFalse: [^ self].	^ (h _ self blockHome) ifNotNil: [h finalBlockHome]! !!MethodContext methodsFor: 'accessing' stamp: 'ar 6/28/2003 00:04'!isExecutingBlock	"Is this executing a block versus a method"	| r |	Smalltalk at: #BlockClosure ifPresent:[:aClass|		^((r _ self receiver) isKindOf: aClass) and: [r method == self method]	].	^false! !!MethodContext methodsFor: 'accessing' stamp: 'ajh 9/28/2001 02:16'!isMethodContext	^ true! !!MethodContext methodsFor: 'accessing' stamp: 'ajh 2/9/2003 00:08'!methodNode	| h |	^ self isExecutingBlock		ifTrue: [self method blockNodeIn: ((h _ self blockHome) ifNotNil: [h methodNode])]		ifFalse: [super methodNode]! !!MethodContext methodsFor: 'private' stamp: 'ajh 8/13/2002 13:34'!startpc	^ self method initialPC! !!MethodContext methodsFor: 'private-exceptions' stamp: 'ar 6/28/2003 00:10'!restartWithNewReceiver: obj	self		swapReceiver: obj;		restart! !!MethodContext methodsFor: 'private-exceptions' stamp: 'ajh 10/8/2001 23:56'!swapReceiver: r	receiver := r! !!MethodContext methodsFor: 'private-debugger' stamp: 'ajh 1/24/2003 23:38'!cachesStack	^ false	"^self selector == #valueUninterruptably		and: [self receiver class == BlockContext]"! !!MethodContext methodsFor: 'printing' stamp: 'ajh 1/31/2003 20:34'!printOn: aStream	| h |	self isExecutingBlock ifFalse: [^ super printOn: aStream].	h _ self blockHome.	h ifNil: [^ aStream nextPutAll: '[]'].	aStream nextPutAll: '[] from '.	h printOn: aStream! !!MethodContext methodsFor: 'closure support' stamp: 'ar 6/28/2003 00:15'!contextTag	"Context tags may be used for referring to contexts instead of contexts themselves as they can be copied and will continue to work in other processes (continuations). By default, we use the context itself to as its tag."	^self! !!MethodNode methodsFor: 'initialize-release' stamp: 'ajh 1/24/2003 17:37'!selector: symbol	selectorOrFalse _ symbol! !!MethodNode methodsFor: 'initialize-release' stamp: 'ajh 1/22/2003 17:53'!sourceText: stringOrText	sourceText _ stringOrText! !!MethodNode methodsFor: 'code generation' stamp: 'ajh 3/24/2003 14:52'!sourceMap	"Answer a SortedCollection of associations of the form: pc (byte offset in 	me) -> sourceRange (an Interval) in source text."	self generateNative: #(0 0 0 0).	^encoder sourceMap! !!MethodNode methodsFor: 'printing' stamp: 'ajh 1/22/2003 17:39'!methodClass	^ encoder classEncoding! !!MethodNode methodsFor: 'printing' stamp: 'ajh 1/24/2003 17:41'!sourceText	^ sourceText ifNil: [self printString]! !!ParseNode class methodsFor: 'class initialization' stamp: 'ajh 8/12/2002 11:10'!blockReturnCode	^ EndRemote! !!ParseNode class methodsFor: 'class initialization' stamp: 'ajh 8/6/2002 12:04'!popCode	^ Pop! !!Parser methodsFor: 'public access' stamp: 'ajh 1/22/2003 16:51'!parse: sourceStreamOrString class: behavior	^ self parse: sourceStreamOrString readStream class: behavior		noPattern: false context: nil notifying: nil ifFail: [self parseError]! !!Parser methodsFor: 'public access' stamp: 'ajh 6/22/2003 22:48'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock         "Answer a MethodNode for the argument, sourceStream, that is the root of         a parse tree. Parsing is done with respect to the argument, class, to find         instance, class, and pool variables; and with respect to the argument,         ctxt, to find temporary variables. Errors in parsing are reported to the         argument, req, if not nil; otherwise aBlock is evaluated. The argument         noPattern is a Boolean that is true if the the sourceStream does not         contain a method header (i.e., for DoIts)."         | methNode repeatNeeded myStream parser s p |        (req notNil and: [RequestAlternateSyntaxSetting signal and: [(sourceStream isKindOf: FileStream) not]])                ifTrue: [parser _ self as: DialectParser]                ifFalse: [parser _ self].        myStream _ sourceStream.        [repeatNeeded _ false.	   p _ myStream position.	   s _ myStream upToEnd.	   myStream position: p.        parser init: myStream notifying: req failBlock: [^ aBlock value].        doitFlag _ noPattern.        failBlock_ aBlock.        [methNode _ parser method: noPattern context: ctxt                                encoder: (Encoder new init: class context: ctxt notifying: parser)]                 on: ParserRemovedUnusedTemps                 do:                         [ :ex | repeatNeeded _ (requestor isKindOf: TextMorphEditor) not.                        myStream _ ReadStream on: requestor text string.                        ex resume].        repeatNeeded] whileTrue.        encoder _ failBlock _ requestor _ parseNode _ nil. "break cycles & mitigate refct overflow"	   methNode sourceText: s.        ^ methNode! !!Process methodsFor: 'changing process state' stamp: 'ajh 1/23/2003 23:02'!run	"Suspend current process and execute self instead"	| proc |	proc _ Processor activeProcess.	[	proc suspend.		self resume.	] forkAt: Processor highestPriority! !!Process methodsFor: 'changing process state' stamp: 'ajh 1/25/2003 00:04'!terminate 	"Stop the process that the receiver represents forever."	Processor activeProcess == self		ifTrue: 			[thisContext bottom suspend]		ifFalse: 			[myList == nil				ifFalse: 					[myList remove: self ifAbsent: [].					myList _ nil].			self popTo: nil]! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 16:14'!activateReturn: aContext value: value	"Activate 'aContext return: value', so execution will return to aContext's sender"	^ suspendedContext _ suspendedContext activateReturn: aContext value: value! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 23:17'!complete: aContext 	"Run self until aContext is popped, then resume here"	| error ctxt here |	here _ thisContext.	"Insert ensure: and on:do: under aContext that will halt self when reached"	error _ false.	ctxt _ aContext insertSender: (ContextPart		contextOn: UnhandledError do: [:ex | error			ifTrue: [ex pass]			ifFalse: [error _ true. suspendedContext _ thisContext. here jump]]).	ctxt _ ctxt insertSender: (ContextPart		contextEnsure: [error ifFalse: [suspendedContext _ thisContext. here jump]]).	suspendedContext jumpTop.  "do not add return value when jumping to it"	"'here jump' resumes here"	suspendedContext push: nil.  "since we jump out of the suspendedContext in the blocks above before pushing a block return value"	"If no unhandled error was raised, remove ensure: context and step down to sender"	error ifFalse: [		self stepToCallee.		suspendedContext == ctxt ifTrue: [^ self stepToCallee]. "pop ensure: & return"		"suspendedContext must be ContextPart>>#return:, step until it returns"		ctxt _ suspendedContext.		[ctxt isDead] whileFalse: [self step].	].	^ suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 10:16'!completeStep: aContext 	"Resume self until aContext is on top, or if already on top, complete next step"	| callee |	self suspendedContext == aContext ifFalse: [		^ self complete: (self calleeOf: aContext)].	callee _ self step.	callee == aContext ifTrue: [^ callee].	aContext isDead ifTrue: [^ self suspendedContext].  "returned"	^ self complete: callee  "finish send"! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/23/2003 21:43'!completeTo: aContext 	"Resume self until aContext is on top"	self suspendedContext == aContext ifTrue: [^ aContext].	^ self complete: (self calleeOf: aContext)! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 14:54'!popTo: aContext 	"Replace the suspendedContext with aContext, releasing all contexts 	between the currently suspendedContext and it."	| callee |	self == Processor activeProcess		ifTrue: [^ self error: 'The active process cannot pop contexts'].	callee _ (self calleeOf: aContext) ifNil: [^ aContext].	^ self return: callee value: callee receiver! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/23/2003 20:40'!restartTop	"Rollback top context and replace with new method.  Assumes self is suspended"	suspendedContext privRefresh! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/23/2003 20:33'!restartTopWith: method	"Rollback top context and replace with new method.  Assumes self is suspended"	suspendedContext privRefreshWith: method.! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 14:49'!return: aContext value: value	"Pop thread down to aContext's sender.  Execute any unwind blocks on the way."	self activateReturn: aContext value: value.	^ self complete: aContext! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 10:17'!step	^ suspendedContext _ suspendedContext step! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/31/2003 14:45'!step: aContext 	"Resume self until aContext is on top, or if already on top, do next step"	^ self suspendedContext == aContext		ifTrue: [self step]		ifFalse: [self complete: (self calleeOf: aContext)]! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/23/2003 22:06'!stepToCallee	"Step until top context changes"	| ctxt |	ctxt _ suspendedContext.	[ctxt == suspendedContext] whileTrue: [		suspendedContext _ suspendedContext step].	^ suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 12:44'!stepToHome: aContext 	"Resume self until the home of top context is aContext.  Top context may be a block context."	| home ctxt |	self suspendedContext == aContext		ifFalse: [^ self complete: (self calleeOf: aContext)].	home _ aContext.	[	ctxt _ self step.		home == ctxt blockHome.	] whileFalse: [		home isDead ifTrue: [^ self suspendedContext].	].	^ self suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 10:17'!stepToSendOrReturn	^ suspendedContext _ suspendedContext stepToSendOrReturn! !!Process methodsFor: 'accessing' stamp: 'ajh 1/24/2003 14:53'!calleeOf: aContext	"Return the context whose sender is aContext.  Return nil if aContext is on top.  Raise error if aContext is not in process chain."	suspendedContext == aContext ifTrue: [^ nil].	^ (suspendedContext findContextSuchThat: [:c | c sender == aContext])		ifNil: [self error: 'aContext not in process chain']! !!Process methodsFor: 'accessing' stamp: 'ajh 1/27/2003 18:39'!copyStack	^ self copy install: suspendedContext copyStack! !!Process methodsFor: 'accessing' stamp: 'ajh 1/24/2003 19:44'!isActiveProcess	^ self == Processor activeProcess! !!Process methodsFor: 'printing' stamp: 'ajh 10/2/2001 14:36'!longPrintOn: stream	| ctxt |	super printOn: stream.	stream cr.	ctxt _ self suspendedContext.	[ctxt == nil] whileFalse: [		stream space.		ctxt printOn: stream.		stream cr.		ctxt _ ctxt sender.	].! !!Process methodsFor: 'debugging' stamp: 'ajh 1/24/2003 19:46'!debug: context title: title	"Open debugger on self with context shown on top"	| topCtxt |	topCtxt _ self isActiveProcess ifTrue: [thisContext] ifFalse: [self suspendedContext].	(topCtxt hasContext: context) ifFalse: [^ self error: 'context not in process'].	Debugger openOn: self context: context label: title contents: nil fullView: false.! !!Process methodsFor: 'debugging' stamp: 'ajh 1/24/2003 19:49'!debugWithTitle: title	"Open debugger on self"	| topCtxt |	topCtxt _ self isActiveProcess ifTrue: [thisContext] ifFalse: [self suspendedContext].	Debugger openOn: self context: topCtxt label: title contents: nil fullView: true.! !!ProcessBrowser methodsFor: 'accessing' stamp: 'ajh 9/7/2002 21:22'!selectedSelector	"Answer the class in which the currently selected context's method was  	found."	^ selectedSelector		ifNil: [selectedSelector _ selectedContext receiver				ifNil: [| who | 					who _ selectedContext method.					selectedClass _ who first.					who last]				ifNotNil: [selectedContext methodSelector]]! !!ProgressInitiationException class methodsFor: 'signalling' stamp: 'ajh 1/22/2003 23:51'!display: aString at: aPoint from: minVal to: maxVal during: workBlock	^ self new		display: aString at: aPoint from: minVal to: maxVal during: workBlock! !!ProgressNotification class methodsFor: 'exceptionInstantiator' stamp: 'ajh 1/22/2003 23:51'!signal: signalerText extra: extraParam	"TFEI - Signal the occurrence of an exceptional condition with a specified textual description."	| ex |	ex := self new.	ex extraParam: extraParam.	^ex signal: signalerText! !!ProjectEntryNotification class methodsFor: 'as yet unclassified' stamp: 'ajh 1/22/2003 23:52'!signal: aProject	| ex |	ex := self new.	ex projectToEnter: aProject.	^ex signal: 'Entering ',aProject printString! !!PseudoClass methodsFor: 'private' stamp: 'ajh 1/21/2003 13:03'!parserClass	^ Compiler parserClass! !!RemoteString methodsFor: 'accessing' stamp: 'ajh 1/18/2002 01:04'!fileStream 	"Answer the file stream with position set at the beginning of my string"	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile _ SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile! !!Text methodsFor: 'emphasis' stamp: 'ar 6/28/2003 00:06'!makeSelectorBold	"For formatting Smalltalk source code, set the emphasis of that portion of 	the receiver's string that parses as a message selector to be bold."	| parser i |	string size = 0 ifTrue: [^ self].	i _ 0.	[(string at: (i _ i + 1)) isSeparator] whileTrue.	(string at: i) = $[ ifTrue: [^ self].  "block, no selector"	(parser _ Compiler parserClass new) parseSelector: string.	self makeBoldFrom: 1 to: (parser endOfLastToken min: string size)! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ajh 1/27/2003 17:48'!literalScannedAs: scannedLiteral notifying: requestor 	^ scannedLiteral! !!UndefinedObject methodsFor: 'bottom context' stamp: 'ajh 2/1/2003 01:31'!canHandleSignal: exception	"When no more handler (on:do:) context left in sender chain this gets called"	^ false! !!UndefinedObject methodsFor: 'bottom context' stamp: 'ajh 2/1/2003 01:31'!handleSignal: exception	"When no more handler (on:do:) context left in sender chain this gets called.  Return from signal with default action."	^ exception resumeUnchecked: exception defaultAction! !!UnhandledError methodsFor: 'priv handling' stamp: 'ajh 9/5/2002 15:11'!defaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	self isDevelopmentEnvironmentPresent		ifTrue: [self devDefaultAction]		ifFalse: [self runtimeDefaultAction].! !!UnhandledError methodsFor: 'priv handling' stamp: 'ajh 1/24/2003 19:21'!devDefaultAction	Processor activeProcess		debug: exception signalerContext		title: exception description! !!UnhandledError methodsFor: 'priv handling' stamp: 'ajh 9/4/2002 19:16'!isDevelopmentEnvironmentPresent	^ Smalltalk includesKey: #Debugger! !!UnhandledError methodsFor: 'priv handling' stamp: 'ajh 2/1/2003 00:56'!isResumable		^ false! !!UnhandledError methodsFor: 'priv handling' stamp: 'ajh 9/5/2002 16:37'!runtimeDefaultAction	"Dump the stack trace to a log file, then exit the program (image)."	| file |	file := FileStream newFileNamed: ('error', Utilities dateTimeSuffix, FileDirectory dot, 'log') asFileName.	Smalltalk timeStamp: file.	(thisContext sender stackOfSize: 20) do: [:ctx | file cr. ctx printOn: file].	file close.	Smalltalk snapshot: false andQuit: true! !!UnhandledError methodsFor: 'as yet unclassified' stamp: 'ajh 9/4/2002 19:15'!exception	^ exception! !!UnhandledError methodsFor: 'as yet unclassified' stamp: 'ajh 9/4/2002 19:15'!exception: anError	exception _ anError! !!UnhandledError class methodsFor: 'as yet unclassified' stamp: 'ajh 9/4/2002 19:17'!signalForException: anError	^ self new		exception: anError;		signal! !!UpdatingMenuItemMorph methodsFor: 'enablement' stamp: 'ajh 1/21/2003 13:17'!enablement 	enablementSelector isBlock		ifTrue: [^ enablementSelector value]		ifFalse: [enablementSelector numArgs = 0				ifTrue: [^ wordingProvider perform: enablementSelector]				ifFalse: [^ wordingProvider perform: enablementSelector										withArguments: arguments]]! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/28/2003 01:07'!displayWorldSafely: aWorld	"Update this world's display and keep track of errors during draw methods."	[aWorld displayWorld] ifError: [:err :rcvr |		"Handle a drawing error"		| errCtx errMorph |		errCtx _ thisContext.		[			errCtx _ errCtx sender.			"Search the sender chain to find the morph causing the problem"			[errCtx notNil and:[(errCtx receiver isMorph) not]] 				whileTrue:[errCtx _ errCtx sender].			"If we're at the root of the context chain then we have a fatal drawing problem"			errCtx ifNil:[^self handleFatalDrawingError: err].			errMorph _ errCtx receiver.			"If the morph causing the problem has already the #drawError flag set,			then search for the next morph above in the caller chain."			errMorph hasProperty: #errorOnDraw		] whileTrue.		errMorph setProperty: #errorOnDraw toValue: true.		"Install the old error handler, so we can re-raise the error"		rcvr error: err.	].! !Warning removeSelector: #signal!MethodContext removeSelector: #restart!MethodContext removeSelector: #restartWith:!BlockContext removeSelector: #value:ifError:!Error removeSelector: #devDefaultAction!Error removeSelector: #isDevelopmentEnvironmentPresent!Error removeSelector: #runtimeDefaultAction!Exception removeSelector: #findHandlerFrom:!Exception removeSelector: #handlerAction!Exception removeSelector: #initialContext:!Exception removeSelector: #setHandlerFrom:!Object subclass: #Exception	instanceVariableNames: 'messageText tag signalContext handlerContext outerContext '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!Object removeSelector: #cannotInterpret:!