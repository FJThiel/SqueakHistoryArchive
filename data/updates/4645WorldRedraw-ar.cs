'From Squeak3.2alpha of 17 December 2001 [latest update: #4643] on 6 January 2002 at 1:48:20 am'!"Change Set:		WorldRedraw-arDate:			6 January 2002Author:			Andreas RaabThe change set fixes a non-apparent problem with DamageRecorder's policy for handling invalidated regions. Under various circumstances the damage recorder would hold overlapping and even otherwise completely covered rectangles which led to repeated redraw operations of one and the same morph. The behavior was observed in a case where redrawing the full morph took roughly 100ms whereas the morphic redraw cycle took roughly 250ms - caused exclusively by overlapping damage rectangles.This change set fixes the issue in the world's redraw cycle rather than in the damage recorder. The reasoning is that a *lot* of damage may be reported so the recording code needs to be kept fast. Redrawing the world on the other hand is done exactly once per cycle so we may well spent a few cycles to re-order the damage rects to be unique and non-overlapping. In addition, the change set optimized the process of corner rounding significantly for damage regions which do not overlap an entire morph. Before these changes, the rounder would perform its operation on all corners - even those where we know beforehand that they are not visible at all."!!CornerRounder methodsFor: 'all' stamp: 'ar 1/5/2002 17:26'!saveBitsUnderCornersOf: aMorph on: aCanvas in: bounds corners: cornerList	| offset corner mask form corners rect |	underBits _ Array new: 4.	corners _ bounds corners.	cornerList do:[:i|		mask _ cornerMasks at: i.		corner _ corners at: i.		i = 1 ifTrue: [offset _ 0@0].		i = 2 ifTrue: [offset _ 0@mask height negated].		i = 3 ifTrue: [offset _ mask extent negated].		i = 4 ifTrue: [offset _ mask width negated@0].		rect _ corner + offset extent: mask extent.		(aCanvas isVisible: rect) ifTrue:[			form _ aCanvas contentsOfArea: rect.			form copyBits: form boundingBox from: mask at: 0@0 clippingBox: form boundingBox rule: Form and fillColor: nil map: (Bitmap with: 16rFFFFFFFF with: 0).			underBits at: i put: form]].! !!CornerRounder methodsFor: 'all' stamp: 'ar 1/5/2002 17:22'!tweakCornersOf: aMorph on: aCanvas in: bounds borderWidth: w corners: cornerList	"This variant has a cornerList argument, to allow some corners to be rounded and others not"	| offset corner saveBits fourColors mask outBits shadowColor corners |	shadowColor _ aCanvas shadowColor.	aCanvas shadowColor: nil. "for tweaking it's essential"	w > 0 ifTrue:[			fourColors _ shadowColor 				ifNil:[aMorph borderStyle colorsAtCorners]				ifNotNil:[Array new: 4 withAll: shadowColor]].	mask _ Form extent: cornerMasks first extent depth: aCanvas depth.	corners _ bounds corners.	cornerList do:[:i|		corner _ corners at: i.		saveBits _ underBits at: i.		saveBits ifNotNil:[			i = 1 ifTrue: [offset _ 0@0].			i = 2 ifTrue: [offset _ 0@saveBits height negated].			i = 3 ifTrue: [offset _ saveBits extent negated].			i = 4 ifTrue: [offset _ saveBits width negated@0].			"Mask out corner area (painting saveBits won't clear if transparent)."			mask copyBits: mask boundingBox from: (cornerMasks at: i) at: 0@0 clippingBox: mask boundingBox rule: Form over fillColor: nil map: (Bitmap with: 0 with: 16rFFFFFFFF).			outBits _ aCanvas contentsOfArea: (corner + offset extent: mask extent).			mask displayOn: outBits at: 0@0 rule: Form and.			"Paint back corner bits."			saveBits displayOn: outBits at: 0@0 rule: Form paint.			"Paint back corner bits."			aCanvas drawImage: outBits at: corner + offset.			w > 0 ifTrue:[				"Paint over with border if any"				aCanvas stencil: (cornerOverlays at: i) at: corner + offset						color: (fourColors at: i)]]].	aCanvas shadowColor: shadowColor. "restore shadow color"! !!CornerRounder class methodsFor: 'all' stamp: 'ar 1/5/2002 17:24'!roundCornersOf: aMorph on: aCanvas in: bounds displayBlock: displayBlock borderWidth: w corners: aList	| rounder |	rounder _ CR0.	w = 1 ifTrue: [rounder _ CR1].	w = 2 ifTrue: [rounder _ CR2].	rounder _ rounder copy.	rounder saveBitsUnderCornersOf: aMorph on: aCanvas in: bounds corners: aList.	displayBlock value.	rounder tweakCornersOf: aMorph on: aCanvas in: bounds borderWidth: w corners: aList! !!PasteUpMorph methodsFor: 'misc' stamp: 'ar 1/5/2002 17:06'!invalidRect: damageRect from: aMorph        "Clip damage reports to my bounds, since drawing is clipped to my bounds."        self == self outermostWorldMorph                 ifTrue: [worldState recordDamagedRect: (damageRect intersect: self bounds)]                ifFalse: [super invalidRect: damageRect from: aMorph]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 1/5/2002 18:04'!allAreasOutsideList: aCollection do: aBlock	"Enumerate aBlock with all areas of the receiver not overlapping 	any rectangle in the given collection"	^self allAreasOutsideList: aCollection startingAt: 1 do: aBlock! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 1/5/2002 18:03'!allAreasOutsideList: aCollection startingAt: startIndex do: aBlock	"Enumerate aBlock with all areas of the receiver not overlapping 	any rectangle in the given collection"	| yOrigin yCorner aRectangle index rr |	index _ startIndex.	"Find the next intersecting rectangle from aCollection"	[index <= aCollection size ifFalse:[^aBlock value: self].	aRectangle _ aCollection at: index.	origin <= aRectangle corner and: [aRectangle origin <= corner]] 		whileFalse:[index _ index + 1].	"aRectangle is intersecting; process it"	aRectangle origin y > origin y 		ifTrue: [rr _ origin corner: corner x @ (yOrigin _ aRectangle origin y).				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock]		ifFalse: [yOrigin _ origin y].	aRectangle corner y < corner y		ifTrue: [rr _ origin x @ (yCorner _ aRectangle corner y) corner: corner.				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock]		ifFalse: [yCorner _ corner y].	aRectangle origin x > origin x 		ifTrue: [rr _ origin x @ yOrigin corner: aRectangle origin x @ yCorner.				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock].	aRectangle corner x < corner x 		ifTrue: [rr _ aRectangle corner x @ yOrigin corner: corner x @ yCorner.				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock].! !!WorldState methodsFor: 'update cycle' stamp: 'ar 1/6/2002 01:40'!drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas thatwere redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect validList |	rectList _ damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"	rectList _ rectList asArray sort:[:r1 :r2| r1 area > r2 area].	damageRecorder reset.	n _ submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	validList _ OrderedCollection new: n*2.	rectList do: [:dirtyRect |		dirtyRect allAreasOutsideList: validList do:[:r|			"Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:[				mm _ submorphs at: i.				((mm fullBounds intersects: r) and: [mm visible]) ifTrue:[					morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]				].				i _ i+1.			].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:[aWorld drawOn: (c _ aCanvas copyClipRect: rectToFill)].			[morphs isEmpty] whileFalse:[				(rect _ rects removeLast) == rectToFill 					ifFalse:[c _ aCanvas copyClipRect: (rectToFill _ rect)].				c fullDrawMorph: morphs removeLast.			].			morphs reset.  			rects reset.			validList add: r.		].	].	^validList! !CornerRounder removeSelector: #saveBitsUnderCornersOf:on:in:!