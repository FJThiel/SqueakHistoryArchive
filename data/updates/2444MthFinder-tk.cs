'From Squeak2.9alpha of 16 June 2000 [latest update: #2440] on 2 July 2000 at 6:23:59 pm'!"Change Set:		MthFinder-tkDate:			2 July 2000Author:			Ted KaehlerFrank Winkler asked for a function that would split strings.  I was about to tell him to use the MethodFinder, but it does not work for this case!!  The natural example to give is:     'aa bb'. $ . #('aa' 'bb')But findTokens needs a string of delimiters, and the returned object is an OrderedCollection, not an Array.	This update modifies the MethodFinder to try substitutions for the answer object:	Array -> OrderedCollection.	Character -> String	Symbol or String of len 1 -> CharacterAnd for the argument objects:	Character -> String	Symbol or String of len 1 -> CharacterAlso added #asString to findTokens, so that a single char can be a delimiter."!!MethodFinder methodsFor: 'initialize' stamp: 'tk 7/1/2000 23:11'!cleanInputs: dataAndAnswerString	"Find an remove common mistakes.  Complain when ill formed."| fixed ddd rs places |ddd _ dataAndAnswerString.fixed _ false.rs _ ReadStream on: ddd, ' '.places _ OrderedCollection new.[rs upToAll: '#true'.  rs atEnd] whileFalse: [places addFirst: rs position-4]. places do: [:pos | ddd _ ddd copyReplaceFrom: pos to: pos with: ''.	fixed _ true]. 	"remove #"rs _ ReadStream on: ddd.places _ OrderedCollection new.[rs upToAll: '#false'.  rs atEnd] whileFalse: [places addFirst: rs position-5]. places do: [:pos | ddd _ ddd copyReplaceFrom: pos to: pos with: ''.	fixed _ true]. 	"remove #"fixed ifTrue: [self inform: '#(true false) are Symbols, not Booleans.  Next time use { true. false }.'].fixed _ false.rs _ ReadStream on: ddd.places _ OrderedCollection new.[rs upToAll: '#nil'.  rs atEnd] whileFalse: [places addFirst: rs position-3]. places do: [:pos | ddd _ ddd copyReplaceFrom: pos to: pos with: ''.	fixed _ true]. 	"remove #"fixed ifTrue: [self inform: '#nil is a Symbol, not the authentic UndefinedObject.  Next time use nil instead of #nil'].^ ddd! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 7/1/2000 23:09'!load: dataWithAnswers	"Find a function that takes the data and gives the answers.  Odd list entries are data for it, even ones are the answers. ""  (MethodFinder new) load: #( (4 3) 7  (-10 5) -5  (-3 11) 8);		findMessage  "| |data _ Array new: dataWithAnswers size // 2.1 to: data size do: [:ii | data at: ii put: (dataWithAnswers at: ii*2-1)].answers _ Array new: data size.1 to: answers size do: [:ii | answers at: ii put: (dataWithAnswers at: ii*2)].data do: [:list | 	(list isKindOf: SequenceableCollection) ifFalse: [		^ self inform: 'first and third items are not Arrays'].	].argMap _ (1 to: data first size) asArray.data do: [:list | list size = argMap size ifFalse: [		self inform: 'data arrays must all be the same size']].argMap size > 4 ifTrue: [self inform: 'No more than a receiver and three arguments allowed'].	"Really only test receiver and three args." thisData _ data copy.mapStage _ mapList _ nil.! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 7/2/2000 17:56'!quickList	"Compute the selectors for the single example of receiver and args, in the very top pane" 	| data result resultArray newExp dataStrings mf dataObjects aa |	data _ contents asString.	"delete trailing period. This should be fixed in the Parser!!" 	[data last isSeparator] whileTrue: [data _ data allButLast]. 	data last = $. ifTrue: [data _ data allButLast]. 	"Eval"	mf _ MethodFinder new.	data _ mf cleanInputs: data.	"remove common mistakes"	dataObjects _ Compiler evaluate: '{', data, '}'. "#( data1 data2 result )" 	dataStrings _ (Compiler new parse: 'zort ' , data in: Object notifying: nil)				block statements allButLast collect:				[:node | String streamContents:					[:strm | (node isKindOf: MessageNode) ifTrue: [strm nextPut: $(].					node printOn: strm indent: 0.					(node isKindOf: MessageNode) ifTrue: [strm nextPut: $)].]].	dataObjects size < 2 ifTrue: [self inform: 'If you are giving an example of receiver, \args, and result, please put periods between the parts.\Otherwise just type one selector fragment' withCRs. ^#()]. 	dataObjects _ Array with: dataObjects allButLast with: dataObjects last. "#( (data1 data2) result )" 	result _ mf load: dataObjects; findMessage.	result first = $(  ifFalse: [		aa _ self testObjects: dataObjects strings: dataStrings.		result _ aa first.  dataObjects _ aa second.  dataStrings _ aa third].	resultArray _ self listFromResult: result. 	resultArray isEmpty ifTrue: [self inform: result].	dataStrings size = (dataObjects first size + 1) ifTrue:		[resultArray _ resultArray collect: [:expression |		newExp _ expression.		dataObjects first withIndexDo: [:lit :i |			newExp _ newExp copyReplaceAll: 'data', i printString							with: (dataStrings at: i)].		newExp, ' --> ', dataStrings last]]. 	^ resultArray! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 7/2/2000 18:05'!testObjects: dataObjects strings: dataStrings	| dataObjs dataStrs selectors classes didUnmodifiedAnswer answerMod do ds result ddo dds |	"Try to make substitutions in the user's inputs and search for the selector again.1 no change to answer.2 answer Array -> OrderedCollection.2 answer Character -> String4 answer Symbol or String of len 1 -> Character	For each of these, try straight, and try converting args:Character -> StringSymbol or String of len 1 -> Character	Return array with result, dataObjects, dataStrings.  Don't ever do a find on the same set of data twice."dataObjs _ dataObjects.  dataStrs _ dataStrings.selectors _ {#asString. #first. #asOrderedCollection}.classes _ {Character. String. Array}.didUnmodifiedAnswer _ false.selectors withIndexDo: [:ansSel :ansInd | "Modify the answer object"	answerMod _ false.	do _ dataObjs copyTwoLevel.  ds _ dataStrs copy.	(dataObjs last isKindOf: (classes at: ansInd)) ifTrue: [		((ansSel ~~ #first) or: [dataObjs last size = 1]) ifTrue: [			do at: do size put: (do last perform: ansSel).	"asString"			ds at: ds size put: ds last, ' ', ansSel.			(result _ MethodFinder new load: do; findMessage) first = $( ifTrue: [				"found a selector!!"				^ Array with: result with: do with: ds].				answerMod _ true]].	selectors allButLast withIndexDo: [:argSel :argInd | "Modify an argument object"			"for args, no reason to do Array -> OrderedCollection.  Identical protocol."		didUnmodifiedAnswer not | answerMod ifTrue: [		ddo _ do copyTwoLevel.  dds _ ds copy.		dataObjs first withIndexDo: [:arg :ind |			(arg isKindOf: (classes at: argInd))  ifTrue: [				((argSel ~~ #first) or: [arg size = 1]) ifTrue: [					ddo first at: ind put: ((ddo first at: ind) perform: argSel).	"asString"					dds at: ind put: (dds at: ind), ' ', argSel.					(result _ MethodFinder new load: ddo; findMessage) first = $( ifTrue: [						"found a selector!!"						^ Array with: result with: ddo with: dds]	.						didUnmodifiedAnswer not & answerMod not ifTrue: [						didUnmodifiedAnswer _ true].					]]]]].	].^ Array with: 'no single method does that function' with: dataObjs with: dataStrs! !!String methodsFor: 'accessing' stamp: 'tk 7/2/2000 18:13'!findTokens: delimiters	"Answer the collection of tokens that result from parsing self.  Any character in the String delimiters marks a border.  Several delimiters in a row are considered as just one separation."	| tokens keyStart keyStop separators |	tokens _ OrderedCollection new.	separators _ delimiters asString.	"Allow a single character to work"	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipDelimiters: separators startingAt: keyStop.		keyStop _ self findDelimiters: separators startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !