'From Squeak2.9alpha of 13 June 2000 [latest update: #3379] on 2 February 2001 at 1:02:14 pm'!"Change Set:		DropFiles-arDate:			10 January 2001Author:			Andreas RaabImage side support for dropping files from the OS onto Squeak. Right now this is pretty simple (it assumes all files are bitmaps) but this is something to work on."!DropEvent subclass: #DropFilesEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!Object subclass: #FileDirectory	instanceVariableNames: 'pathName '	classVariableNames: 'DefaultDirectory DirectoryClass StandardMIMEMappings '	poolDictionaries: ''	category: 'System-Files'!!DropEvent methodsFor: 'dispatching' stamp: 'ar 1/10/2001 21:24'!sentTo: anObject	"Dispatch the receiver into anObject"	self type == #dropEvent ifTrue:[^anObject handleDropMorph: self].! !!DropFilesEvent methodsFor: 'accessing' stamp: 'ar 1/10/2001 21:35'!type	^#dropFilesEvent! !!DropFilesEvent methodsFor: 'dispatching' stamp: 'ar 1/10/2001 21:35'!sentTo: anObject	"Dispatch the receiver into anObject"	self type == #dropFilesEvent ifTrue:[^anObject handleDropFiles: self].! !!FileDirectory class methodsFor: 'class initialization' stamp: 'ar 1/27/2001 11:20'!initializeStandardMIMETypes	"FileDirectory initializeStandardMIMETypes"	StandardMIMEMappings _ Dictionary new.	#(		(gif		('image/gif'))		(pdf	('application/pdf'))		(aiff	('audio/aiff'))		(bmp	('image/bmp'))		(swf	('application/x-shockwave-flash'))		(htm	('text/html' 'text/plain'))		(html	('text/html' 'text/plain'))		(jpg		('image/jpeg'))		(jpeg	('image/jpeg'))		(mid	('audio/midi'))		(midi	('audio/midi'))		(mp3	('audio/mpeg'))		(mpeg	('video/mpeg'))		(mpg	('video/mpg'))		(txt		('text/plain'))		(text	('text/plain'))		(mov	('video/quicktime'))		(qt		('video/quicktime'))		(tif		('image/tiff'))		(tiff	('image/tiff'))		(ttf		('application/x-truetypefont'))		(wrl	('model/vrml'))		(vrml	('model/vrml'))		(wav	('audio/wav'))	) do:[:spec|		StandardMIMEMappings at: spec first put: spec last.	].! !!FileStream methodsFor: 'accessing' stamp: 'ar 1/25/2001 19:33'!mimeTypes	^FileDirectory default mimeTypesFor: self name.! !!Morph methodsFor: 'event handling' stamp: 'ar 1/10/2001 21:28'!dropFiles: anEvent	"Handle a number of files dropped from the OS"! !!Morph methodsFor: 'event handling' stamp: 'ar 1/10/2001 21:28'!wantsDropFiles: anEvent	"Return true if the receiver wants files dropped from the OS."	^false! !!Morph methodsFor: 'events-processing' stamp: 'ar 1/10/2001 21:35'!handleDropFiles: anEvent	"Handle a drop from the OS."	anEvent wasHandled ifTrue:[^self]. "not interested"	(self wantsDropFiles: anEvent) ifFalse:[^self].	anEvent wasHandled: true.	self dropFiles: anEvent.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 1/10/2001 21:42'!handleEvent: anEvent	| evt ofs |	owner ifNil:[^self].	evt _ anEvent.	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendEvent: evt focus: self mouseFocus].ShowEvents == true ifTrue:[	ofs _ (owner hands indexOf: self) - 1 * 60.	evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	self keyboardFocus printString displayAt: (0@ofs)+(0@45).].	"Notify listeners"	self sendListenEvent: evt to: self eventListeners.	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: self keyboardListeners.		self sendEvent: evt focus: self keyboardFocus.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isDropEvent ifTrue:[		self sendEvent: evt focus: nil.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: self mouseListeners.		lastMouseEvent _ evt].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendEvent: evt focus: self mouseFocus.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendEvent: evt focus: self mouseFocus].	].	ShowEvents == true ifTrue:[self mouseFocus printString displayAt: (0@ofs) + (0@15)].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 1/30/2001 19:55'!processEvents	"Process user input events from the local input devices.	An interesting problem. Morphic is always supposed to run in an event driven environment but for now it is possible that a Morphic window is run from MVC so that we have to synthesize events in the sensor. That's quite a bit of a problem because it means that we'll get endless mouse events. To compensate for this, EventSensor will always return keyboard events first if synthesized so if we're running into a mouse event AND Sensor doesn't have an event queue we can safely break out of the event processing loop. See also EventSensor>>nextEventSynthesized."	| evt evtBuf type hadMouse hadAny |	hadMouse _ hadAny _ false.	[(evtBuf _ Sensor nextEvent) == nil] whileFalse:[		evt _ nil. "for unknown event types"		type _ evtBuf at: 1.		(type = EventTypeMouse)			ifTrue:[evt _ self generateMouseEvent: evtBuf. hadMouse _ true].		(type = EventTypeKeyboard) 			ifTrue:[evt _ self generateKeyboardEvent: evtBuf].		(type = EventTypeDragDropFiles)			ifTrue:[evt _ self generateDropFilesEvent: evtBuf].		"All other events are ignored"		evt == nil ifFalse:[			"Finally, handle it"			self handleEvent: evt.			hadAny _ true.			"See the note on running a World in MVC in the method comment"			(evt isMouse and:[Sensor eventQueue == nil]) ifTrue:[^self].		].	].	(mouseClickState notNil and:[hadMouse not]) ifTrue:[		"No mouse events during this cycle. Make sure click states time out accordingly"		mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	hadAny ifFalse:[		"No pending events. Make sure z-order is up to date"		self mouseOverHandler processMouseOver: lastMouseEvent.	].! !!HandMorph methodsFor: 'private events' stamp: 'ar 1/30/2001 19:47'!generateDropFilesEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	"Note: This is still in an experimental phase and will need more work"	| position buttons modifiers stamp numFiles dragType |	stamp _ (evtBuf at: 2).	stamp = 0 ifTrue:[stamp _ Time millisecondClockValue].	dragType _ evtBuf at: 3.	position _ (evtBuf at: 4) @ (evtBuf at: 5).	buttons _ 0.	modifiers _ (evtBuf at: 6).	buttons _ buttons bitOr: (modifiers bitShift: 3).	numFiles _ (evtBuf at: 7).	dragType = 4 ifTrue:[		"e.g., drop"		^DropFilesEvent new 			setPosition: position 			contents: numFiles 			hand: self.	].	"the others are currently not handled by morphs themselves"	dragType = 1 ifTrue:[		"experimental drag enter"		owner borderWidth: 4; borderColor: owner color negated.	].	dragType = 2 ifTrue:[		"experimental drag move"	].	dragType = 3 ifTrue:[		"experimental drag leave"		owner borderWidth: 0.	].	^nil! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 1/10/2001 21:43'!dispatchEvent: anEvent with: aMorph	"Dispatch the given event for a morph that has chosen the receiver to dispatch its events. The method implements a shortcut for repeated dispatches of events using the same dispatcher."	anEvent type == lastType ifTrue:[^self perform: lastDispatch with: anEvent with: aMorph].	"Otherwise classify"	lastType _ anEvent type.	anEvent isMouse ifTrue:[		anEvent isMouseDown ifTrue:[			lastDispatch _ #dispatchMouseDown:with:.			^self dispatchMouseDown: anEvent with: aMorph]].	anEvent type == #dropEvent ifTrue:[		lastDispatch _ #dispatchDropEvent:with:.		^self dispatchDropEvent: anEvent with: aMorph].	lastDispatch _ #dispatchDefault:with:.	^self dispatchDefault: anEvent with: aMorph! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 1/25/2001 19:49'!dropFiles: anEvent	"Handle a number of dropped files from the OS.	TODO:		- use a more general mechanism for figuring out what to do with the file (perhaps even offering a choice from a menu)		- remember the resource location or (when in browser) even the actual file handle	"	| numFiles stream sketch type |	numFiles _ anEvent contents.	1 to: numFiles do:[:i|		stream _ FileStream requestDropStream: i.		type _ stream mimeTypes.		type ifNotNil:[type _ type first]. "for now just use the first one"		"only image files will be handled for now"		(type notNil and:[type beginsWith: 'image/']) ifTrue:[			stream binary.			sketch _ SketchMorph withForm: (Form fromBinaryStream: stream).			self addMorph: sketch centeredNear: anEvent position.		] ifFalse:[			"just get us a text editor"			stream edit.		].	].! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 1/10/2001 21:29'!wantsDropFiles: anEvent	^self isWorldMorph! !"Postscript:Initialize standard MIME types for files."FileDirectory initializeStandardMIMETypes.!