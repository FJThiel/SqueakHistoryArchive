'From Squeak2.7 of 5 January 2000 [latest update: #1796] on 26 January 2000 at 4:15:20 pm'!"Change Set:		endian-tkMYDate:			22 January 2000Author:			Ted KaehlerIn memory caching for short files is removed.  (Only add it back if it is shown to go faster.)WordArrays:  Always written in machine independent (Macintosh LSB) form.  Byte-switched just before writing and just after reading.  Written at full disk speed.New class WordArrayForSegment that does not swap byte orders -- used for the segment inst var in an ImageSegment.  (The segment load primitive does its own swapping.  On MSB machines, segment would get swapped twice.) Also, detect when a segment contains a block whose receiver has been reshaped.  Warn the user that the method may have an error or crash."!WordArray variableWordSubclass: #WordArrayForSegment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!!Bitmap methodsFor: 'filing' stamp: 'tk 1/24/2000 22:37'!restoreEndianness	"This word object was just read in from a stream.  Bitmaps are always compressed and serialized in a machine-independent way.  Do not correct the Endianness."	"^ self"! !!DataStream methodsFor: 'write and read' stamp: 'tk 1/24/2000 23:33'!next	"Answer the next object in the stream."	| type selector anObject isARefType pos internalObject |	type _ byteStream next.	type ifNil: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType _ self noteCurrentReference: type.	selector _ #(readNil readTrue readFalse readInteger			readStringOld readSymbol readByteArray			readArray readInstance readReference readBitmap			readClass readUser readFloat readRectangle readShortInst 			readString readWordArray readWordArrayForSegment 			0 0 0 0 0 0 0 0 0 0 0 0 0 0) at: type.			"If out of bounds, file is probably corrupted."	selector == 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"			byteStream close. 			self error: 'file is more recent than this system'. ^ nil].	anObject _ self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	isARefType ifTrue: [self beginReference: anObject].		"After reading the externalObject, internalize it.		 #readReference is a special case. Either:		   (1) We actually have to read the object, recursively calling			   next, which internalizes the object.		   (2) We just read a reference to an object already read and			   thus already interalized.		 Either way, we must not re-internalize the object here."	selector == #readReference ifTrue: [^ anObject].	internalObject _ anObject comeFullyUpOnReload: self.	^ self maybeBeginReference: internalObject! !!DataStream methodsFor: 'write and read' stamp: 'tk 1/24/2000 23:25'!nextPut: anObject	"Write anObject to the receiver stream. Answer anObject.	 NOTE: If anObject is a reference type (one that we write cross-references to) but its externalized form (result of objectForDataStream:) isn't (e.g. CompiledMethod and ViewState), then we should remember its externalized form but not add to 'references'. Putting that object again should just put its external form again. That's more compact and avoids seeks when reading. But we just do the simple thing here, allowing backward-references for non-reference types like nil. So objectAt: has to compensate. Objects that externalize nicely won't contain the likes of ViewStates, so this shouldn't hurt much.	 : writeReference: -> errorWriteReference:."	| typeID selector objectToStore |	typeID _ self typeIDFor: anObject.	(self tryToPutReference: anObject typeID: typeID)		ifTrue: [^ anObject].	objectToStore _ (self objectIfBlocked: anObject) objectForDataStream: self.	objectToStore == anObject ifFalse: [typeID _ self typeIDFor: objectToStore].	byteStream nextPut: typeID.	selector _ #(writeNil: writeTrue: writeFalse: writeInteger: 		writeStringOld: writeSymbol: writeByteArray:		writeArray: writeInstance: errorWriteReference: writeBitmap:		writeClass: writeUser: writeFloat: writeRectangle: == "dummy 16" 		writeString: writeBitmap: writeBitmap:) at: typeID.	self perform: selector with: objectToStore.	^ anObject! !!DataStream methodsFor: 'write and read' stamp: 'tk 1/24/2000 23:20'!readWordArray	"PRIVATE -- Read the contents of a WordArray."	^ WordArray newFromStream: byteStream	"Size is number of long words."! !!DataStream methodsFor: 'write and read' stamp: 'tk 1/24/2000 23:23'!readWordArrayForSegment	"Read the contents of a WordArray ignoring endianness."	^ WordArrayForSegment newFromStream: byteStream	"Size is number of long words."! !!DataStream class methodsFor: 'as yet unclassified' stamp: 'tk 1/24/2000 23:22'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  	Classes named here have special formats in the file.  If such a class has a subclass, it will use tyep 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes _ OrderedCollection new.	t _ TypeMap _ Dictionary new: 60. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: String put: 5.   refTypes add: 1.	t at: Symbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.		"CompiledMethod is handled by Object (type 9)"	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances of any class, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.	t at: String put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"	t at: WordArray put: 18.  refTypes add: 1.	"tetraByteArray"	t at: WordArrayForSegment put: 19.  refTypes add: 1.		"tetraByteArray"	"t at:  put: 20.  refTypes add: 0."	ReferenceStream refTypes: refTypes.	"save it"! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 1/25/2000 21:47'!copyFromRoots: aRootArray sizeHint: segSizeHint	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize rootSet uniqueRoots |	aRootArray ifNil: [self errorWrongState].	rootSet _ IdentitySet new: 150.	uniqueRoots _ OrderedCollection new.	1 to: aRootArray size do: [:ii |	"Don't include any roots twice"		(rootSet includes: (aRootArray at: ii)) 			ifFalse: [				uniqueRoots addLast: (aRootArray at: ii).				rootSet add: (aRootArray at: ii)]			ifTrue: [userRootCnt ifNotNil: ["adjust the count"						ii <= userRootCnt ifTrue: [userRootCnt _ userRootCnt - 1]]]].	arrayOfRoots _ uniqueRoots asArray.	rootSet _ uniqueRoots _ nil.	"be clean"	userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].	arrayOfRoots do: [:aRoot | (aRoot respondsTo: #indexIfCompact) ifTrue: [		aRoot indexIfCompact > 0 ifTrue: [			self error: 'Compact class ', aRoot name, ' cannot be a root']].		aRoot _ nil].	"clean up"	outPointers _ nil.	"may have used this instance before"	segSize _ segSizeHint > 0 ifTrue: [segSizeHint *3 //2] ifFalse: [50000].	["Guess a reasonable segment size"	segmentWordArray _ WordArrayForSegment new: segSize.	[outPointerArray _ Array new: segSize // 20] ifError: [		state _ #tooBig.  ^ self].	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 1/25/2000 21:53'!install	"This operation retrieves the segment if necessary from file storage, installs it in memory, and replaces (using become:) all the root stubs with the reconstructed roots of the segment."	| newRoots |	state = #onFile ifTrue: [self readFromFile].	state = #onFileWithSymbols ifTrue: [self readFromFileWithSymbols.		endMarker _ segment nextObject. 	"for enumeration of objects"		endMarker == 0 ifTrue: [endMarker _ 'End' clone]].	(state = #active) | (state = #imported) ifFalse: [self errorWrongState].	newRoots _ self loadSegmentFrom: segment outPointers: outPointers.	state = #imported 		ifTrue: ["just came in from exported file"			arrayOfRoots _ newRoots]		ifFalse: [			arrayOfRoots elementsForwardIdentityTo: newRoots].	state _ #inactive.	(PluckedSound pitch: 261.625*3 dur: 0.25 loudness: 0.1) play.	"interrupts previous sound"! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 1/25/2000 21:49'!readFromFile	"Read in a simple segment.  Use folder of this image, even if remembered as previous location of this image"	| ff realName |	realName _ self class folder, FileDirectory slash, self localName.	ff _ FileStream oldFileNamed: realName.	segment _ ff nextWordsInto: (WordArrayForSegment new: ff size//4).	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	ff close.	state _ #active! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 1/25/2000 21:43'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots.	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal fakes goods bads perfect ccFixups real insts receiverClasses |	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal 				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is not compatible'].	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		fakes _ mapFakeClassesToReal keys.		goods _ OrderedCollection new.		bads _ OrderedCollection new.		fakes do: [:aFakeClass | 			real _ mapFakeClassesToReal at: aFakeClass.			(real indexIfCompact > 0) "and there is a fake class"				ifFalse: ["normal case"					aFakeClass allInstancesDo: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]				ifTrue: ["instances have the wrong class.  Fix them before anyone notices."					insts _ OrderedCollection new.					self allObjectsDo: [:obj | obj class == real ifTrue: [insts add: obj]].					insts do: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]].		bads size > 0 ifTrue: [			bads asArray elementsForwardIdentityTo: goods asArray]].	receiverClasses _ self rehashSets.	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:aRoot | 		(aRoot isKindOf: Project) ifTrue: [			Project allInstancesDo: [:pp | pp ~~ aRoot ifTrue: [				pp name = aRoot name ifTrue: [					aRoot projectChangeSet name: ChangeSet defaultName]]]].		aRoot class class == Metaclass ifTrue: [			self declare: aRoot]].	mapFakeClassesToReal isEmpty ifFalse: [		fakes do: [:aFake | 			aFake indexIfCompact > 0 ifTrue: [aFake becomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 1/25/2000 22:23'!rehashSets	"I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks.  Return them.  Caller will check if they have been reshaped."	| object sets receiverClasses inSeg |	object _ segment.	sets _ OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses _ IdentitySet new.	inSeg _ true.	[object _ object nextObject.  		object == endMarker ifTrue: [inSeg _ false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: Set) ifTrue: [sets add: object].			object class == BlockContext ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				object class == MethodContext ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				]. 		object == 0] whileFalse.	sets do: [:each | each rehash].	"our purpose"	^ receiverClasses	"our secondary job"! !!ImageSegment methodsFor: 'instance change shape' stamp: 'tk 1/25/2000 21:54'!allInstancesOf: aClass do: aBlock	| withSymbols oldInstances segSize |	"Bring me in, locate instances of aClass and submit them to the block.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols _ state = #onFileWithSymbols.	(outPointers includes: aClass) ifFalse: [^ self].		"If has instances, they point out at the class"	state = #onFile ifTrue: [Cursor read showWhile: [self readFromFile]].	segSize _ segment size.	self install.	oldInstances _ OrderedCollection new.	self allObjectsDo: [:obj | obj class == aClass ifTrue: [		oldInstances add: obj]].	oldInstances do: [:inst | aBlock value: inst].	"do the work"	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!ImageSegment methodsFor: 'instance change shape' stamp: 'tk 1/25/2000 21:54'!ifOutPointer: anObject thenAllObjectsDo: aBlock	| withSymbols segSize |	"If I point out to anObject, bring me in, Submit all my objects to the block.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols _ state = #onFileWithSymbols.	(outPointers includes: anObject) ifFalse: [^ self].	state = #onFile ifTrue: [Cursor read showWhile: [self readFromFile]].	segSize _ segment size.	self install.	self allObjectsDo: [:obj | aBlock value: obj].	"do the work"	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!ImageSegment methodsFor: 'instance change shape' stamp: 'tk 1/25/2000 21:51'!segUpdateInstancesOf: oldClass toBe: newClass isMeta: isMeta	| withSymbols oldInstances segSize |	"Bring me in, locate instances of oldClass and get them converted.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols _ state = #onFileWithSymbols.	"If has instances, they point out at the class"	(outPointers includes: oldClass) ifFalse: [		oldClass == SmallInteger ifTrue: [^ self].	"instance not changable"		oldClass == Symbol ifTrue: [^ self].	"instance is never in a segment"		(Smalltalk compactClassesArray includes: oldClass) ifFalse: [^ self]].		"For a compact class, must search the segment.  Instance does not 		 point outward to class"	state = #onFile ifTrue: [Cursor read showWhile: [self readFromFile]].	segSize _ segment size.	self install.	oldInstances _ OrderedCollection new.	self allObjectsDo: [:obj | obj class == oldClass ifTrue: [		oldInstances add: obj]].	newClass updateInstances: oldInstances asArray from: oldClass isMeta: isMeta.	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 1/26/2000 16:11'!nextWordsInto: aBitmap 	| blt pos mainX mainY frontX frontY little |	"Fill the word based buffer from my collection.  Stored on stream as Little Endian.  Optimized for speed."	(collection class isBytes) ifTrue:		["1 to: aBitmap size do: [:index | aBitmap at: index put: (self nextNumber: 4)]."		little _ Smalltalk endianness == #little.		pos _ self position.		self skip: aBitmap size * 4.		mainX _ pos \\ 4.   mainY _ pos // 4.	"two Blts required if not word aligned"		frontX _ 0.  frontY _ mainY + 1.		blt _ (BitBlt toForm: (Form new hackBits: aBitmap)) 					sourceForm: (Form new hackBits: collection).		blt combinationRule: Form over.  "store"		blt sourceX: mainX; sourceY: mainY; height: aBitmap size; width: 4-mainX.		blt destX: 0; destY: 0.		little ifTrue: [blt sourceX: 0; destX: mainX].	"just happens to be this way!!"		blt copyBits.		mainX = 0 ifTrue: [^ aBitmap].		"second piece when not word aligned"		blt sourceX: frontX; sourceY: frontY; height: aBitmap size; width: mainX.		blt destX: 4-mainX; destY: 0.		little ifTrue: [blt sourceX: 4-mainX; destX: frontX].	"draw picture to understand this"		blt copyBits.		^ aBitmap].	^ self next: aBitmap size into: aBitmap startingAt: 1.! !!FileStream methodsFor: 'fileIn/Out' stamp: 'tk 1/21/2000 16:38'!fileInObjectAndCode	"Read the file directly, do not use an RWBinaryOrTextStream."	self text.	^ super fileInObjectAndCode! !!SmartRefStream methodsFor: 'import image segment' stamp: 'tk 1/25/2000 21:32'!checkFatalReshape: setOfClasses	| suspects oldInstVars newInstVars bad |	"Inform the user if any of these classes were reshaped.  A block has a method from the old system whose receiver is of this class.  The method's inst var references might be wrong.  OK if inst vars were only added."	setOfClasses isEmpty ifTrue: [^ self].	suspects _ OrderedCollection new.	setOfClasses do: [:aClass |		oldInstVars _ (structures at: aClass name) allButFirst.		"should be there"		newInstVars _ aClass allInstVarNames.		oldInstVars size > newInstVars size ifTrue: [bad _ true].		oldInstVars size = newInstVars size ifTrue: [bad _ oldInstVars ~= newInstVars].		oldInstVars size < newInstVars size ifTrue: [			bad _ oldInstVars ~= (newInstVars copyFrom: 1 to: oldInstVars size)].		bad ifTrue: [suspects add: aClass]].	suspects isEmpty ifFalse: [		self inform: ('Imported foreign methods will run on instances of:\',			suspects asArray printString, 			'\whose shape has changed.  Errors may occur.') withCRs].! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'tk 1/24/2000 22:45'!nextWordsInto: aBitmap	"Note: The file primitives automatically adjust for word based objects."	self next: aBitmap size into: aBitmap startingAt: 1.	aBitmap restoreEndianness.	^ aBitmap! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'tk 1/24/2000 23:01'!endianness	| bytes word blt |	"What endian-ness is the current hardware?  The String '1234' will be stored into a machine word.  On BigEndian machines (the Mac), $1 will be the high byte if the word.  On LittleEndian machines (the PC), $4 will be the high byte."	"Smalltalk endianness"	bytes _ ByteArray withAll: #(0 0 0 0).  "(1 2 3 4) or (4 3 2 1)"	word _ WordArray with: 16r01020304.	blt _ (BitBlt toForm: (Form new hackBits: bytes)) 				sourceForm: (Form new hackBits: word).	blt combinationRule: Form over.  "store"	blt sourceY: 0; destY: 0; height: 1; width: 4.	blt sourceX: 0; destX: 0.	blt copyBits.  "paste the word into the bytes"	bytes first = 1 ifTrue: [^ #big].	bytes first = 4 ifTrue: [^ #little].	self error: 'Ted is confused'.! !!WordArray reorganize!('converting' asWordArray)('accessing' atAllPut: defaultElement)('private' replaceFrom:to:with:startingAt:)('fileIn/Out' restoreEndianness swapBytesFrom:to: writeOn:)!!WordArray methodsFor: 'fileIn/Out' stamp: 'tk 1/24/2000 22:34'!restoreEndianness	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Reverse the byte order if the current machine is Little Endian."	Smalltalk endianness == #little 		ifTrue: [			self swapBytesFrom: 1 to: self size]! !!WordArray methodsFor: 'fileIn/Out' stamp: 'tk 1/22/2000 12:04'!swapBytesFrom: start to: stop	"Perform a bigEndian/littleEndian byte reversal of my words"	| hack blt |	"The implementation is a hack, but fast for large ranges"	hack _ Form new hackBits: self.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: start-1; destY: start-1; height: stop-start+1; width: 1.	blt sourceX: 0; destX: 3; copyBits.  "Exchange bytes 0 and 3"	blt sourceX: 3; destX: 0; copyBits.	blt sourceX: 0; destX: 3; copyBits.	blt sourceX: 1; destX: 2; copyBits.  "Exchange bytes 1 and 2"	blt sourceX: 2; destX: 1; copyBits.	blt sourceX: 1; destX: 2; copyBits.! !!WordArray methodsFor: 'fileIn/Out' stamp: 'tk 1/25/2000 18:16'!writeOn: aStream 	| reversed convertToBytes |	"Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed).  Always store in Big Endian (Mac) byte order.  Do the writing at BitBlt speeds."	convertToBytes _ aStream originalContents "collection" class isBytes.	(aStream isKindOf: FileStream) ifTrue: [convertToBytes _ false].	"knows how"	Smalltalk endianness == #big 		ifTrue: ["no change"			aStream nextInt32Put: self size.			convertToBytes ifTrue: [self do: [:vv | aStream nextNumber: 4 put: vv]]					"Later define (aStream nextPutWordsAll:) that uses BitBlt to 					 put words on a byteStream quickly" 				ifFalse: [aStream nextPutAll: self]]		ifFalse: [			reversed _ self clone.			reversed swapBytesFrom: 1 to: reversed size.			aStream nextInt32Put: reversed size.			convertToBytes ifTrue: [reversed do: [:vv | aStream nextNumber: 4 put: vv]]				ifFalse: [aStream nextPutAll: reversed]]! !!WordArrayForSegment methodsFor: 'as yet unclassified' stamp: 'tk 1/24/2000 23:22'!restoreEndianness	"This word object was just read in from a stream.  Do not correct the Endianness because the load primitive will reverse bytes as needed."	"^ self"! !!WordArrayForSegment methodsFor: 'as yet unclassified' stamp: 'tk 1/24/2000 23:22'!writeOn: aByteStream	"Write quickly and disregard the endianness of the words.  Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed)."	aByteStream nextInt32Put: self size.	"4 bytes"	aByteStream nextPutAll: self! !DataStream removeSelector: #rTetraByteArray!DataStream initialize!Smalltalk removeClassNamed: #WordArrayForSegement!