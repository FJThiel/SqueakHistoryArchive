'From Squeak 2.3 beta of Nov 25, 1998 on 12 January 1999 at 3:38:57 pm'!!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'di 1/12/1999 12:25'!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."	| entriesAvailable survivors freeChunk firstFree oop oopHeader oopHeaderType hdrBytes oopSize freeChunkSize |	self inline: false.	entriesAvailable _ self fwdTableInit: 8.  "Two-word blocks".	survivors _ 0.	freeChunk _ nil.	firstFree _ nil.  "will be updated later"	oop _ self oopFromChunk: youngStart.	[oop < endOfMemory] whileTrue: [		"get oop's header, header type, size, and header size"		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeShort) ifTrue: [			oopSize _ oopHeader bitAnd: SizeMask.			hdrBytes _ 0.		] ifFalse: [			(oopHeaderType = HeaderTypeClass) ifTrue: [				oopSize _ oopHeader bitAnd: SizeMask.				hdrBytes _ 4.			] ifFalse: [				(oopHeaderType = HeaderTypeSizeAndClass) ifTrue: [					oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask.					hdrBytes _ 8.				] ifFalse: [  "free chunk"					oopSize _ oopHeader bitAnd: AllButTypeMask.					hdrBytes _ 0.				].			].		].		(oopHeader bitAnd: MarkBit) = 0 ifTrue: ["object is not marked; free it"			"<-- Finalization support: We need to mark each oop chunk as free -->"			self longAt: oop - hdrBytes put: HeaderTypeFree.			freeChunk ~= nil ifTrue: [				"enlarge current free chunk to include this oop"				freeChunkSize _ freeChunkSize + oopSize + hdrBytes.			] ifFalse: [				"start a new free chunk"				freeChunk _ oop - hdrBytes.  "chunk may start 4 or 8 bytes before oop"				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"				firstFree = nil ifTrue: [ firstFree _ freeChunk ].			].		] ifFalse: [			"object is marked; clear its mark bit and possibly adjust the compaction start"			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).			"<-- Finalization support: Check if we're running about a weak class -->"			(self isWeak: oop) ifTrue:[				self finalizeReference: oop.			].			entriesAvailable > 0 ifTrue: [				entriesAvailable _ entriesAvailable - 1.			] ifFalse: [				"start compaction at the last free chunk before this object"				firstFree _ freeChunk.			].			freeChunk ~= nil ifTrue: [				"record the size of the last free chunk"				self longAt: freeChunk					    put: ((freeChunkSize bitAnd: AllButTypeMask) bitOr: HeaderTypeFree).			].			freeChunk _ nil.			survivors _ survivors + 1.		].		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"	].	freeChunk ~= nil ifTrue: [		"record size of final free chunk"		self longAt: freeChunk			    put: ((freeChunkSize bitAnd: AllButTypeMask) bitOr: HeaderTypeFree).	].	oop = endOfMemory		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].	firstFree = nil		ifTrue: [ self error: 'expected to find at least one free object' ]		ifFalse: [ compStart _ firstFree ].	displayBits = 0 ifFalse: [		"TPR: clear mark bit of Acorn's displayBits object, which may lie outside object space"		oopHeader _ self baseHeader: displayBits.		self longAt: displayBits put: (oopHeader bitAnd: AllButMarkBit)].		^ survivors! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 1/12/1999 14:09'!fwdBlockGet: blkSize	"Return the address of a two- or four-word forwarding block or nil if no more entries are available."	fwdTableNext _ fwdTableNext + blkSize.	fwdTableNext <= fwdTableLast		ifTrue: [ ^ fwdTableNext ]		ifFalse: [ ^ nil ].  "no more forwarding blocks available"! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 1/12/1999 12:24'!fwdTableInit: blkSize	"Set the limits for a table of two- or three-word forwarding blocks above the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used for compaction of memory and become-ing objects. Returns the number of forwarding blocks available."	self inline: false.	"set endOfMemory to just after a minimum-sized free block"	self setSizeOfFree: freeBlock to: BaseHeaderSize.	endOfMemory _ freeBlock + BaseHeaderSize.	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	"use all memory free between freeBlock and memoryLimit for forwarding table"	"  (use quadword alignment for better cache performance)"	fwdTableNext _ (endOfMemory + BaseHeaderSize + 7) bitAnd: 16rFFFFFFF8.	fwdTableLast _ memoryLimit - blkSize.  "last forwarding table entry"	"return the number of forwarding blocks available"	^ (fwdTableLast - fwdTableNext) // blkSize  "round down"! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 1/12/1999 12:25'!incCompBody	"Move objects to consolidate free space into one big chunk. Return the newly created free chunk."	| bytesFreed |	self inline: false.	"reserve memory for forwarding table"	self fwdTableInit: 8.  "Two-word blocks"	"assign new oop locations, reverse their headers, and initialize forwarding blocks"	bytesFreed _ self incCompMakeFwd.	"update pointers to point at new oops"	self mapPointersInObjectsFrom: youngStart to: endOfMemory.	"move the objects and restore their original headers; return the new free chunk"	^ self incCompMove: bytesFreed! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 1/12/1999 12:32'!incCompMakeFwd	"Create and initialize forwarding blocks for all non-free objects following compStart. If the supply of forwarding blocks is exhausted, set compEnd to the first chunk above the area to be compacted; otherwise, set it to endOfMemory. Return the number of bytes to be freed."	| bytesFreed oop fwdBlock newOop |	bytesFreed _ 0.	oop _ self oopFromChunk: compStart.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifTrue: [			bytesFreed _ bytesFreed + (self sizeOfFree: oop).		] ifFalse: [			"create a forwarding block for oop"			fwdBlock _ self fwdBlockGet: 8.  "Two-word block"			fwdBlock = nil ifTrue: [				"stop; we have used all available forwarding blocks"				compEnd _ self chunkFromOop: oop.				^ bytesFreed			].			newOop _ oop - bytesFreed.			self initForwardBlock: fwdBlock mapping: oop to: newOop withBackPtr: false.		].		oop _ self objectAfterWhileForwarding: oop.	].	compEnd _ endOfMemory.	^ bytesFreed! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 1/12/1999 14:08'!initForwardBlock: fwdBlock mapping: oop to: newOop withBackPtr: backFlag	"Initialize the given forwarding block to map oop to newOop, and replace oop's header with a pointer to the fowarding block."	"Details: The mark bit is used to indicate that an oop is forwarded. When an oop is forwarded, its header (minus the mark bit) contains the address of its forwarding block. (The forwarding block address is actually shifted right by one bit so that its top-most bit does not conflict with the header's mark bit; since fowarding blocks are stored on word boundaries, the low two bits of the address are always zero.) The first word of the forwarding block is the new oop; the second word is the oop's orginal header. In the case of a forward become, a four-word block is used, with the third field being a backpointer to the old oop (for header fixup), and the fourth word is unused.  The type bits of the forwarding header are the same as those of the original header."	| originalHeader originalHeaderType |	self inline: true.	originalHeader _ self longAt: oop.	DoAssertionChecks ifTrue: [		fwdBlock = nil			ifTrue: [ self error: 'ran out of forwarding blocks in become' ].		(originalHeader bitAnd: MarkBit) ~= 0			ifTrue: [ self error: 'object already has a forwarding table entry' ].	].	originalHeaderType _ originalHeader bitAnd: TypeMask.	self longAt: fwdBlock put: newOop.	self longAt: fwdBlock + 4 put: originalHeader.	backFlag ifTrue:		[self longAt: fwdBlock + 8 put: oop].	self longAt: oop put: (fwdBlock >> 1 bitOr: (MarkBit bitOr: originalHeaderType)).! !!ObjectMemory methodsFor: 'become' stamp: 'di 1/12/1999 14:17'!become: array1 with: array2 twoWay: twoWayFlag	"All references to each object in array1 are swapped with all references to the corresponding object in array2. That is, all pointers to one object are replaced with with pointers to the other. The arguments must be arrays of the same length. Returns true if the primitive succeeds."	"Implementation: Uses forwarding blocks to update references as done in compaction."	(self fetchClassOf: array1) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self fetchClassOf: array2) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self lastPointerOf: array1) = (self lastPointerOf: array2) ifFalse: [ ^ false ].	(self containOnlyOops: array1 and: array2) ifFalse: [ ^ false ].	(self prepareForwardingTableForBecoming: array1 with: array2 twoWay: twoWayFlag)		ifFalse: [^ false].  "fail; not enough space for forwarding table"	(self allYoung: array1 and: array2) ifTrue: [		"sweep only the young objects plus the roots"		self mapPointersInObjectsFrom: youngStart to: endOfMemory.	] ifFalse: [		"sweep all objects"		self mapPointersInObjectsFrom: (self startOfMemory) to: endOfMemory.	].	twoWayFlag		ifTrue: [self restoreHeadersAfterBecoming: array1 with: array2]		ifFalse: [self restoreHeadersAfterForwardBecome].	self initializeMemoryFirstFree: freeBlock.  "re-initialize memory used for forwarding table"	^ true  "success"! !!ObjectMemory methodsFor: 'become' stamp: 'di 1/12/1999 13:43'!prepareForwardingTableForBecoming: array1 with: array2 twoWay: twoWayFlag	"Ensure that there are enough forwarding blocks to accomodate this become, then prepare forwarding blocks for the pointer swap. Return true if successful."	"Details: Doing a GC might generate enough space for forwarding blocks if we're short. However, this is an uncommon enough case that it is better handled by primitive fail code at the Smalltalk level."	| entriesNeeded entriesAvailable fieldOffset oop1 oop2 fwdBlock fwdBlkSize |	entriesNeeded _ (self lastPointerOf: array1) // 4.  "need enough entries for all oops"	twoWayFlag		ifTrue: ["Double the number of blocks for two-way become"				entriesNeeded _ entriesNeeded * 2.				fwdBlkSize _ 8]		ifFalse: ["One-way become needs backPointers in fwd blocks."				fwdBlkSize _ 16 "Could be 12, but code needs dblWord alignment"].	entriesAvailable _ self fwdTableInit: fwdBlkSize.	entriesAvailable < entriesNeeded ifTrue: 		[self initializeMemoryFirstFree: freeBlock.  "re-initialize the free block"		^ false].	fieldOffset _ self lastPointerOf: array1.	[fieldOffset >= BaseHeaderSize] whileTrue: 		[oop1 _ self longAt: array1 + fieldOffset.		oop2 _ self longAt: array2 + fieldOffset.		fwdBlock _ self fwdBlockGet: fwdBlkSize.		self initForwardBlock: fwdBlock mapping: oop1 to: oop2 withBackPtr: twoWayFlag not.		twoWayFlag ifTrue:			["Second block maps oop2 back to oop1 for two-way become"			fwdBlock _ self fwdBlockGet: fwdBlkSize.			self initForwardBlock: fwdBlock mapping: oop2 to: oop1 withBackPtr: twoWayFlag not].		fieldOffset _ fieldOffset - 4].	^ true! !!ObjectMemory methodsFor: 'become' stamp: 'di 1/12/1999 14:06'!restoreHeadersAfterForwardBecome	"Forward become leaves us with no original oops in the mutated object list,	so we must enumerate the (four-word) forwarding blocks	where we have stored backpointers."	| oop1 fwdBlock |	"This loop start is copied from fwdBlockGet:"	fwdBlock _ (endOfMemory + BaseHeaderSize + 7) bitAnd: 16rFFFFFFF8.	fwdBlock _ fwdBlock + 16.  "fwdBlockGet: did a pre-increment"	[fwdBlock <= fwdTableNext]  "fwdTableNext points to the last active block"		whileTrue:		[oop1 _ self longAt: fwdBlock + 8.  "Backpointer to mutated object."		self restoreHeaderOf: oop1.		fwdBlock _ fwdBlock + 16].! !!InterpreterSimulator methodsFor: 'file primitives' stamp: 'di 1/12/1999 15:38'!primitiveFileDelete 	| namePointer |	namePointer _ self stackTop.	self success: (self isBytes: namePointer).	self success: (StandardFileStream isAFileNamed: (self stringOf: namePointer)).	successFlag ifTrue: [FileDirectory deleteFilePath: (self stringOf: namePointer)].	successFlag ifTrue: [self pop: 1].  "pop fileName; leave rcvr on stack"! !ObjectMemory removeSelector: #fwdTableInit!ObjectMemory removeSelector: #fwdBlockGet!ObjectMemory removeSelector: #initForwardBlock:mapping:to:!