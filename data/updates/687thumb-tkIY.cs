'From Squeak 2.3 of January 14, 1999 on 22 February 1999 at 1:36:12 pm'!BasicButton subclass: #URLMorph	instanceVariableNames: 'url page isBookmark book '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-SqueakPage'!!BookMorph class methodsFor: 'all' stamp: 'tk 2/16/1999 14:41'!isInWorld: aWorld withUrl: aUrl	"If a book with this url is in the that (current) world, return it.  Say if it is out or in another world."	self withAllSubclassesDo: [:cls |		cls allInstancesDo: [:aBook | 			 (aBook valueOfProperty: #url) = aUrl ifTrue: [				aBook world == aWorld 					ifTrue: [^ aBook]					ifFalse: [^ #conflict]]]].	^ #out! !!DocLibrary methodsFor: 'doc pane' stamp: 'tk 2/17/1999 13:42'!fetchDocSel: aSelector class: className	"Look on servers to see if there is documentation pane for the selected message. Take into account the current update number.  If not, ask the user if she wants to create a blank one."	| key response docPane ext |	key _ className, ' ', aSelector.	(self openDocAt: key) ifNil: [		response _ (PopUpMenu labels: 'Create new page\Cancel' withCRs)				startUpWithCaption: 'No documentation exists for this method.\Would you like to write some?' withCRs.		response = 1 ifTrue: [			docPane _ PasteUpMorph new.			docPane color: Color white; borderWidth: 2; borderColor: Color green.			docPane setProperty: #classAndMethod toValue: key.			docPane setProperty: #initialExtent toValue: (ext _ 200@200).			docPane topLeft: (RealEstateAgent initialFrameFor: docPane) origin.			docPane extent: ext.			docPane addMorph: (TextMorph new topLeft: docPane topLeft + (10@10);					extent: docPane width - 15 @ 30).			Smalltalk currentWorld addMorph: docPane]].	"If found, openDocAt: put it on the screen"! !!Morph methodsFor: 'accessing' stamp: 'tk 2/17/1999 11:45'!url	"If I have been assigned a url, return it.  For PasteUpMorphs mostly."	| sq |	(sq _ self sqkPage) ifNotNil: [^ sq url].	^ self valueOfProperty: #url		! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 2/17/1999 17:50'!reserveUrl: urlString	"Write a dummy object to the server to hold a name and place for this object."	| dummy ext str |	dummy _ PasteUpMorph new.	dummy borderWidth: 2.	dummy setProperty: #initialExtent toValue: (ext _ 300@100).	dummy topLeft: 50@50; extent: ext.	"reset when comes in"	str _ (TextMorph new) topLeft: dummy topLeft + (10@10); 		extent: dummy width - 15 @ 30.	dummy addMorph: str.	str contents: 'This is a place holder only.  Please \find the original page and choose \"send this page to server"' withCRs.	str extent: dummy width - 15 @ 30.	dummy saveOnURL: urlString.	"Claim that url myself"	self setProperty: #SqueakPage toValue: dummy sqkPage.	(dummy sqkPage) contentsMorph: self; dirty: true.	^ self url! !!BookMorph commentStamp: 'tk 2/17/1999 12:39' prior: 0!A collection of pages, each of which is a place to put morphs.  Allows one or another page to show; orchestrates the page transitions; offers control panel for navigating among pages and for adding and deleting pages.To write a book out to the disk or to a file server, decide what folder it goes in.  Construct a url to a typical page:	file://myDisk/folder/myBook1.spor	ftp://aServer/folder/myBook1.spChoose "send all pages to server" from the book's menu (press the <> part of the controls).  Choose "use page numbers".  Paste in the url.To load an existing book, find its ".bo" file in the file list browser.  Choose "load as book".To load an existing book from its url, execute:Ã(URLMorph grabURL: 'ftp://aServer/folder/myBook1.sp') book: true.Multiple people may modify a book.  If other people may have changed a book you have on your screen, choose "reload all from server".Add or modify a page, and choose "send this page to server".The polite thing to do is to reload before changing a book.  Then write one or all pages soon after making your changes.  If you store a stale book, it will wipe out changes that other people made in the mean time.Pages may be linked to each other.  To create a named link to a new page, type the name of the page in a text area in a page.  Select it and do Cmd-6.  Choose 'link to'.  A new page of that name will be added at the back of the book.  Clicking on the blue text flips to that page.  	To create a link to an existing page, first name the page.  Go to that page and Cmd-click on it.  The name of the page is below the page.  Click in it and backspace and type.  Return to the page you are linking from.  Type the name. Cmd-6, 'link to'.  Text search:  Search for a set of fragments.  allStrings collects text of fields.  Turn to page with all fragments on it and highlight the first one.  Save the container and offset in properties: #searchContainer, #searchOffset, #searchKey.  Search again from there.  Clear those at each page turn, or change of search key.  [rules about book indexes and pages:  Index and pages must live in the same directory. They have the same file prefix, followed by .bo for the index or 4.sp for a page (or x4.sp).  When a book is moved to a new directory, the load routine gets the new urls for all pages and saves those in the index.  Book stores index url in property #url.      Allow mulitple indexes (books) on the same shared set of pages.  If book has a url in same directory as pages, allow them to have different prefixes.	save all pages first time, save one page first time, fromRemoteStream: (first time)	save all pages normal , save one page normal, reload	where I check if same dir]URLMorph holds url of both page and book.!!BookMorph methodsFor: 'menu' stamp: 'tk 2/17/1999 12:52'!bookmarkForThisPage	"If this book exists on a server, make the reference via a URL"	| bb url um |	(url _ self url) ifNil: [		bb _ SimpleButtonMorph new target: self.		bb actionSelector: #goToPageMorph:fromBookmark:.		bb label: 'Bookmark'.		bb arguments: (Array with: currentPage with: bb).		self primaryHand attachMorph: bb.		^ bb].	currentPage url ifNil: [currentPage saveOnURLbasic].	um _ URLMorph newForURL: currentPage url.	um setURL: currentPage url page: currentPage sqkPage.	(SqueakPage stemUrl: url) = (SqueakPage stemUrl: currentPage url) 		ifTrue: [um book: true]		ifFalse: [um book: url].  	"remember which book"	um isBookmark: true; label: 'Bookmark'.	um borderWidth: 1; borderColor: #raised.	um color: (Color r: 0.4 g: 0.8 b: 0.6).	self primaryHand attachMorph: um.	^ um! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/22/1999 12:44'!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| stem list firstTime bookUrl |firstTime _ (self valueOfProperty: #url) == nil.stem _ self getStemUrl.	"user must approve"stem size = 0 ifTrue: [^ self].firstTime ifTrue: [self setProperty: #futureUrl toValue: stem, '.bo'].pages doWithIndex: [:aPage :ind | 	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage saveOnURL: stem,(ind printString),'.sp'.		self presenter ifNotNil: [self presenter flushPlayerListCache].		]].list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	bookUrl _ self valueOfProperty: #url.	(SqueakPage stemUrl: bookUrl) = (SqueakPage stemUrl: currentPage url) ifTrue: [		bookUrl _ true].		"not a shared book"	(URLMorph grabURL: currentPage url) book: bookUrl.	self setProperty: #futureUrl toValue: nil].	"clean up"! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/22/1999 12:28'!saveOnUrlPage: pageMorph	"Write out this single page in this book onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	| stem ind response rand newPlace dir |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.		^ self].	"Don't give the chance to put in a different place.  Assume named by number"	((self valueOfProperty: #url) == nil and: [pages first url ~~ nil]) ifTrue: [		response _ (PopUpMenu labels: 'Old book\New book sharing old pages' 					withCRs)				startUpWithCaption: 'Modify the old book, or make a new\book sharing its pages?' withCRs.		response = 2 ifTrue: [			"Make up new url for .bo file and confirm with user."  "Mark as shared"			[rand _ String new: 4.			1 to: rand size do: [:ii |				rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].			newPlace _ ((self getStemUrl) copyUpToLast: $/), '/BK', rand, '.bo'.			dir _ ServerFile new fullPath: newPlace.			(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"			self setProperty: #url toValue: newPlace].		response = 0 ifTrue: [^ self]].	stem _ self getStemUrl.	"user must approve"	stem size = 0 ifTrue: [^ self].	ind _ pages identityIndexOf: pageMorph ifAbsent: [self error: 'where is the page?'].	pageMorph isInMemory ifTrue: ["not out now"			pageMorph saveOnURL: stem,(ind printString),'.sp'].	self saveIndexOfOnly: pageMorph.! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/22/1999 13:28'!savePrep	"When I have many pages, with interpointing BookMarks, save a dummy version of the book first."self url ifNil: [	pages do: [:pg | 		pg url ifNil: [pg reserveUrl: self getStemUrl]].	self saveIndexOnURL.	].! !!BookPageThumbnailMorph commentStamp: 'tk 2/22/1999 11:22' prior: 0!A small picture representing a page of a BookMorph here or somewhere else.  When clicked, make that book turn to the page and do a visual effect and a noise.page			either the morph of the page, or a urlpageNumberbookMorph		either the book, or a urlflipOnClick!!BookPageThumbnailMorph reorganize!('all' addCustomMenuItems:hand: computeThumbnail doPageFlip encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: handlesMouseDown: inBook: initialize makeFlexMorphFor: mouseDown: page page: pageMorph:inBook: pageNumber:inBook: setPageSound: setPageVisual: smaller toggleBookmark)('fileIn/Out' objectToStoreOnDataStream objectsInMemory)('copying' veryDeepFixupWith: veryDeepInner:)!!BookPageThumbnailMorph methodsFor: 'all' stamp: 'tk 2/22/1999 11:24'!doPageFlip	"Flip to this page"	self objectsInMemory.	bookMorph goToPageMorph: page			transitionSpec: (self valueOfProperty: #transitionSpec).	(owner isKindOf: PasteUpMorph) ifTrue:		[owner cursor: (owner submorphs indexOf: self ifAbsent: [1])]! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'tk 2/22/1999 11:21'!mouseDown: event	self doPageFlip	"Note that all fetching of pages from server is done in doPageFlip"! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'tk 2/22/1999 12:54'!objectToStoreOnDataStream	"I am about to be written on an object file.  It would be bad to write a whole BookMorph out.  Store a string that is the url of the book or page in my inst var."	| clone bookUrl bb stem ind |	(bookMorph class == String) & (page class == String) ifTrue: [		^ super objectToStoreOnDataStream].	clone _ self clone.	(bookUrl _ bookMorph url)		ifNil: [bookUrl _ self valueOfProperty: #futureUrl].	bookUrl 		ifNil: [	bb _ RectangleMorph new.	"write out a dummy"			bb bounds: bounds.			^ bb]		ifNotNil: [clone instVarNamed: 'bookMorph' put: bookUrl].	page url ifNil: [			"Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."		stem _ SqueakPage stemUrl: bookUrl.		ind _ bookMorph pages identityIndexOf: page.		page reserveUrl: stem,(ind printString),'.sp'].	clone instVarNamed: 'page' put: page url.	^ clone! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'tk 2/22/1999 12:01'!objectsInMemory	"See if page or bookMorph need to be brought in from a server."	| bookUrl bk |	bookMorph class == String ifTrue: [		bookUrl _ bookMorph.		bk _ BookMorph isInWorld: self world withUrl: bookUrl.		bk == #conflict ifTrue: [			^ self inform: 'This book is already open in some other project'].		bk == #out ifTrue: [			(bk _ BookMorph new fromURL: bookUrl) ifNil: [^ self]].		bookMorph _ bk].	page class == String ifTrue: [		page _ (bookMorph pages detect: [:pg | pg url = page] 					ifNone: [bookMorph pages at: 1])].! !!MorphThumbnail methodsFor: 'all' stamp: 'tk 2/22/1999 13:01'!objectToStoreOnDataStream	"Avoid big leaks when writing"	| bb |	morphRepresented isInMemory ifFalse: [^ self].	self inform: 'Please send the target of this thumbnail to the disk first'.	bb _ RectangleMorph new.	"write out a dummy"	bb bounds: bounds.	^ bb! !!PolygonMorph methodsFor: 'object fileIn' stamp: 'tk 2/17/1999 11:36'!convertbosfcebbvcfqaah0: varDict bosfcebbvcfqaahb0: smartRefStrm	"These variables are automatically stored into the new instance ('vertices' 'closed' 'filledForm' 'quickFill' 'arrows' 'arrowForms' 'handles' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('borderForm' ) and deal with the information in ()"! !!SimpleButtonMorph methodsFor: 'fileIn/Out' stamp: 'tk 2/17/1999 14:09'!objectToStoreOnDataStream	"I am about to be written on an object file.  If I send a message to a BookMorph, it would be bad to write that object out.  Create and write out a URLMorph instead."	| bb thatPage um stem ind |	actionSelector == #goToPageMorph:fromBookmark: ifFalse: [		^ super objectToStoreOnDataStream].	"normal case"	target url ifNil: ["Later force target book to get a url."		bb _ SimpleButtonMorph new.	"write out a dummy"		bb label: self label.		bb bounds: bounds.		^ bb].	(thatPage _ arguments first) url ifNil: [			"Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."		stem _ target getStemUrl.	"know it has one"		ind _ target pages identityIndexOf: thatPage.		thatPage reserveUrl: stem,(ind printString),'.sp'].	um _ URLMorph newForURL: thatPage url.	um setURL: thatPage url page: thatPage sqkPage.	(SqueakPage stemUrl: target url) = (SqueakPage stemUrl: thatPage url) 		ifTrue: [um book: true]		ifFalse: [um book: target url].  	"remember which book"	um isBookmark: true; label: self label.	um borderWidth: borderWidth; borderColor: borderColor.	um color: color.	^ um! !!SmartRefStream commentStamp: 'tk 2/17/1999 12:42' prior: 0!Ordinary ReferenceStreams assume that the layout of instance variables in an object on the disk is the same as the layout of that class in memory now.  And it assumes that the class has the same name as before.  SmartRefStream allows one to bring in objects whose instance variables or class name have changed.  1/13/97 tk>>>>See SmartRefStream.aComment for an example.<<<< The basic principal is that object conversion to a new version needs to be done after the fact.  SmartRefStream records the names of the instance variables of all outgoing classes.  Adjustments are done later when the file is read in.* Allows incoming object to have fewer instance variables than the current class.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure description, which is big.  * Writes triplets of (version, class structure array, object) on the file.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.		Note that aDictionary has (old inst var name -> value) * Prompts the user to write (or file in) a conversion method when needed.* Allows a change of instance vars in a superclass to be handled by just one conversion method.  Figures out what to do to the subclasses.* Allows mixing cole for filing in, and raw objects.  The file can start out in the normal fileOut format.  Definitions of new classes on the front and an object are at the end.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, #marked if internal call.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.UniClasses are classes for the instance specific behavior of just one instance.  Subclasses of Player are an example.  When a UniClass is read in, and a class of the same name already exists, the incoming one is renamed.  ObjectScanner converts the filed in code.Values in instance variables of UniClasses are stored in the array that tells the class structure.  It is the fourth of the four top level objects.  #(version (class-structure) the-object ((#Player25 scripts slotInfo costumeDictionary) (#Player26 scripts slotInfo costumeDictionary))).Future:* Someday will prompt for a new version number when there are new inst vars with same initials, and tells how to make conversion work when some files have already been written.* There is a separate subclass for doing veryDeepCopy (in memory).  Currently, any object that has objectToStoreOnDataStream return an object other than self does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.!!URLMorph commentStamp: 'tk 2/16/1999 14:17' prior: 0!This morph represents a URL for a SqueakPage. It displays the thumbnail for the associated page, if available. Used in page sorters and for bookmarks.This morph has several options:  a. It can act like a thumbnail for sorting (in which case it can be picked up and dragged) or it acts as a bookmark (in which case shift clicking on it activates it).  b. If it has book set to true, it is a page in a book.  Clicking fetches the index of the book, opens it to the first page, and puts it in the hand.A thumbnail on a known book:	(URLMorph grabURL: 'ftp://doltest1.disney.com/squeak/test/p1.sp')		book: true.A thumbnail on a single PasteUpMorph:Make a PasteUpMorph with any morphs in it.Decide where it should live, make a url string, and copy it.	'file://HardDisk/books/book1/myPage.sp'	'ftp://doltest1.disney.com/squeak/test/p1.sp'Choose 'Save as Web Morph'Paste in the url.Drop the resulting thumbnail into some morph.See SqueakPage's comment for the stages of in/out.url page 		A SqueakPageisBookmark 		Booleanbook 	A Boolean -- whether I represent a whole book or a page.!!URLMorph methodsFor: 'accessing' stamp: 'tk 2/17/1999 12:38'!book: aUrl	"A notation about what book this page is in.  true means page is in same book as url strm says.  Set to the url of the Book if the book has a different stem url.  nil or false if not for a book page at all."	book _ aUrl! !!URLMorph methodsFor: 'drawing' stamp: 'tk 2/2/1999 22:45'!drawOn: aCanvas	"Draw thumbnail for my page, if it is available. Otherwise, just draw a rectangle." | thumbnail oldExt |color == Color transparent 	ifTrue: ["show thumbnail"		thumbnail _ self thumbnailOrNil.		thumbnail			ifNil: [aCanvas frameRectangle: bounds width: borderWidth 						color: borderColor.				aCanvas fillRectangle: (bounds insetBy: borderWidth) color: color]			ifNotNil: [oldExt _ bounds extent.				bounds _ bounds origin extent: thumbnail extent + (2@2).				aCanvas frameRectangle: bounds width: borderWidth color: borderColor.				aCanvas image: thumbnail at: bounds origin + borderWidth.				oldExt = thumbnail extent ifFalse: [self layoutChanged]]]	ifFalse: ["show labeled button"		^ super drawOn: aCanvas]! !!URLMorph methodsFor: 'event handling' stamp: 'tk 2/2/1999 19:22'!mouseUp: evt	| pg ow newPage mm bookUrl bk |	"If url of a book, open it to that page, or bring it in and open to that page."	book ifNotNil: [book == false ifFalse: [		(bookUrl _ book) class == String ifFalse: [			bookUrl _ (SqueakPage stemUrl: url), '.bo'].		(bk _ BookMorph isInWorld: self world withUrl: bookUrl) class ~~ Symbol 			ifTrue: [^ bk goToPageUrl: url].		bk == #conflict ifTrue: [			^ self inform: 'This book is already open in some other project'].		(bk _ BookMorph new fromURL: bookUrl) ifNil: [^ self].		bk goToPageUrl: url.	"turn to the page"		^ World primaryHand attachMorph: bk]].	"If inside a SqueakPage, replace it!!"	pg _ self enclosingPage.	pg ifNotNil: [		(ow _ pg contentsMorph owner) ifNotNil: [			pg contentsMorph delete.	"from its owner"			newPage _ SqueakPageCache atURL: url.			mm _ newPage fetchContents.			mm ifNotNil: [ow addMorph: mm.				page _ newPage].			^ self]].	"If I am a project, jump  -- not done yet"	"For now, just put new page on the hand"	newPage _ SqueakPageCache atURL: url.	mm _ newPage fetchInformIfError.	mm ifNotNil: [self primaryHand attachMorph: mm.		page _ newPage].! !BookMorph class removeSelector: #ifInWorld:goToPageUrl:!Morph removeSelector: #reserveUrl!