'From Squeak2.9alpha of 12 June 2000 [latest update: #3171] on 13 December 2000 at 3:55:30 pm'!"Change Set:		ScriptorChanges9Date:			20 November 2000Author:			Dan IngallsFixes vertical leading of up-arrow.Moving toward a color theme:  gray for structure, brown for grab, green for drop targets.Changes edit panels from popup to apply to current selection.Fixes weird appearance of insertion arrows during retraction.Includes a tweak to the debugging feature showBoundsInHalo.Optimizes UpdatingStringMorph to not wantSteps if it does not read its target."!!HaloMorph methodsFor: 'drawing' stamp: 'di 12/11/2000 13:54'!drawOn: aCanvas	"Draw this morph only if it has no target."	target == nil ifTrue: [^ super drawOn: aCanvas].	Preferences showBoundsInHalo ifTrue:		[aCanvas frameAndFillRectangle: target boundsInWorld				fillColor: Color transparent				borderWidth: 1				borderColor: Color blue]! !!MessageNode methodsFor: 'tiles' stamp: 'di 11/20/2000 18:22'!asMorphicSyntaxIn: parent	| printer substitute row sel |	sel _ #message.	(parent nodeClassIs: CascadeNode) ifTrue: [sel _ #keyword2].	row _ parent addRow: sel on: self.	special > 0 ifTrue: [printer _ MacroPrinters at: special].	substitute _ self as: TileMessageNode.	(printer == #printCaseOn:indent:) ifTrue: [		self asMorphicCaseOn: row indent: nil.		^ parent].	(special > 0)		ifTrue: 			[substitute perform: printer with: row with: nil]		ifFalse: 			[substitute 				printKeywords: selector key				arguments: arguments				on: row				indent: nil].	^ row addTransparentSpacerOfSize: 3@10.! !!MessageNode methodsFor: 'tiles' stamp: 'di 11/13/2000 20:18'!morphFromKeywords: key arguments: args on: parent indent: ignored 	| keywords column row receiverMorph firstArgMorph receiverWidth messageWidth |	receiver ifNotNil: ["i.e. not a cascade"			receiverMorph _ receiver asMorphicSyntaxIn: parent].	keywords _ key keywords.	args size = 0 ifTrue:			[row _ (parent addTextRow: key) layoutInset: 1.			^ row parseNode: selector].	receiverWidth _ receiver				ifNil: [0]				ifNotNil: [receiverMorph fullBounds width].	(receiverWidth <= 80 and: [args size = 1])		ifTrue: [row _ (parent addTextRow: keywords first) layoutInset: 1.			row parseNode: selector.			firstArgMorph _ args first asMorphicSyntaxIn: parent.			receiver ifNil: [^ self].			(firstArgMorph fullBounds height > 100					or: [firstArgMorph fullBounds width > 250])				ifTrue: [parent foldMessageOneArg].			^ self].	column _ parent addColumn: #keyword1 on: self.	messageWidth _ 0.	keywords		with: (args copyFrom: 1 to: keywords size)		do: [:kwd :arg | 			(row _ column addRow: #keyword2 on: self) borderWidth: 1;				parseNode: (self as: MessagePartNode);				 borderColor: row stdBorderColor.			row addToken: kwd				type: #keyword2				on: KeyWordNode new.			arg asMorphicSyntaxIn: row.			messageWidth _ messageWidth + row fullBounds width].	receiverMorph ifNotNil:		[receiverWidth + messageWidth < 350 ifTrue: [^ parent unfoldMessage].			((receiverWidth > 200						or: [receiverWidth > 80								and: [column fullBounds height > 20]])					or: [receiverMorph fullBounds width > 30							and: [column fullBounds height > 100									or: [column fullBounds width > 250]]])				ifTrue: [^ parent foldMessage]]! !!ReturnNode methodsFor: 'tiles' stamp: 'di 11/20/2000 15:53'!asMorphicSyntaxIn: parent	| row |	row _ parent addRow: #return on: self.	row addToken: '^ ' type: #assignment on: self.	expr asMorphicSyntaxIn: row.	expr addCommentToMorph: row.	^row! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 12/11/2000 13:43'!mouseEnter: evt	"Highlight this level as a potential grab target""Transcript cr; print: self; show: ' enter'."	self unhighlightOwner.	self highlightForGrab: evt.	evt hand newKeyboardFocus: self.! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 12/13/2000 13:21'!mouseEnterDragging: evt	"Highlight this level as a potential drop target""Transcript cr; print: self; show: ' enterDragging'."	evt hand hasSubmorphs ifFalse: [^ self].  "Don't react to empty hand"	self unhighlightOwner.	self highlightForDrop: evt.	self isBlockNode ifTrue:		[(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m isBlockNode]])			ifNotNilDo: [:m | "Suspend outer block."						m stopStepping; hideCaret].		self startStepping]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 12/11/2000 13:46'!mouseLeave: evt	"Move grab highlight back out a level""Transcript cr; print: self; show: ' leave'."	self unhighlight.	(owner ~~ nil and: [owner isSyntaxMorph])		ifTrue: [owner highlightForGrab: evt].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/20/2000 19:50'!mouseLeaveDragging: evt inCaret: caretMorph	"Unhighlight the caret as a potential drop target""Transcript cr; print: self; show: ' leaveDraggingInCaret'."	caretMorph borderColor: Color brown.	self highlightForDrop: evt.! !!SyntaxMorph methodsFor: 'drawing' stamp: 'di 12/11/2000 13:17'!drawOn: aCanvas	super drawOn: aCanvas.	self isBlockNode ifTrue:		[owner isMethodNode		ifTrue:			[aCanvas fillRectangle: (self topLeft + (0@-1) extent: self width@1) color: Color gray]		ifFalse:			[aCanvas fillRectangle: (self topLeft + (1@1) extent: 2@(self height-2)) color: Color gray.			aCanvas fillRectangle: (self topLeft + (1@1) extent: 4@1) color: Color gray.			aCanvas fillRectangle: (self bottomLeft + (1@-1) extent: 4@1) color: Color gray].		]! !!SyntaxMorph methodsFor: 'highlighting' stamp: 'di 12/13/2000 15:25'!borderColor: colorOrSymbolOrNil	borderColor = colorOrSymbolOrNil ifFalse: [		borderColor _ colorOrSymbolOrNil.		self bounds area < 40000			ifTrue: [self invalidRect: self bounds]			ifFalse: [(self bounds areasOutside: (self bounds insetBy: self borderWidth))						do: [:r | self invalidRect: r]]].! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 12/13/2000 13:04'!deselect	self allMorphsDo:		[:m | m isSyntaxMorph ifTrue: [m color: Color transparent; borderColor: Color transparent]].	"Note following is wasteful because we do a deselect before each select, and it is often the same morph."	self deletePopup! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 12/11/2000 13:44'!select	self deselect.	self color: Color lightBrown.	self borderColor: #raised.	self offerPopUp.! !!SyntaxMorph methodsFor: 'insertion caret' stamp: 'di 11/20/2000 19:49'!showCaretAt: location	| newArrow |	self valueOfProperty: #caretMorph ifPresentDo:		[:arrow | ^ arrow align: arrow bounds leftCenter with: location].	newArrow _ (PolygonMorph vertices: {0@0. 12@-9. 12@-5. 20@-5. 20@5. 12@5. 12@9}			color: Color yellow darker borderWidth: 1 borderColor: Color brown)			on: #mouseEnterDragging send: #mouseEnterDragging:inCaret: to: self;			on: #mouseLeaveDragging send: #mouseLeaveDragging:inCaret: to: self.	self setProperty: #caretMorph toValue: newArrow.	self addCaretFront: newArrow.	newArrow align: newArrow bounds leftCenter with: location! !!SyntaxMorph methodsFor: 'insertion caret' stamp: 'di 12/13/2000 13:33'!trackCaret	| hand i pt localPt sub |	hand _ self primaryHand.	(hand lastEvent redButtonPressed & hand hasSubmorphs		and: [(self hasOwner: hand) not]) ifTrue:		[localPt _ self globalPointToLocal: hand position.		(i _ self insertionIndexForCaret: localPt) = 0 ifFalse: [			sub _ submorphs at: i.			pt _ localPt y < sub center y				ifTrue: [sub topLeft + (i=2 ifTrue: [-3@2] ifFalse: [-3@-2])]				ifFalse: [sub bottomLeft + (-3@-2)].			^ self showCaretAt: pt]].	self stopStepping; hideCaret.! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 12/13/2000 14:22'!addString: literalOrVarName	| sMorph |	"Create and return an UpdatingStringMorph containing the value.  Use an UpdatingStringMorph, so it can inform its owner when it has been edited."	sMorph _ UpdatingStringMorph contents: literalOrVarName.	sMorph target: self; putSelector: #acceptIgnoring:; useStringFormat.	"keep the getSelector being nil"	^ sMorph! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 12/13/2000 13:05'!deletePopup	self valueOfProperty: #myPopup ifPresentDo:		[:panel | panel delete. self removeProperty: #myPopup]! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 12/11/2000 14:13'!event: evt arrow: arrowMorph upDown: delta		| st aList index now want instVar |	st _ submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	(self nodeClassIs: LiteralNode) ifTrue: [ "+/- 1"		st contents: (self decompile asNumber + delta) printString.		^ self acceptIfInScriptor.	"maybe set parseNode's key"].	(self nodeClassIs: VariableNode) ifTrue: [ "true/false"		st contents: (self decompile asString = 'true') not printString.		^ self acceptIfInScriptor.	"maybe set parseNode's key"].	(self nodeClassIs: SelectorNode) ifTrue: [		aList _ #(+ - * / // \\ min: max:).		index _ aList indexOf: self decompile asString.		index  > 0 ifTrue: [			self setBalloonText: 				(ScriptingSystem helpStringForOperator: (aList atWrap: index + delta)).			st contents: (aList atWrap: index + delta).			^ self acceptIfInScriptor].		aList _ #(= ~= > >= isDivisibleBy: < <=).		index _ aList indexOf: self decompile asString.		index  > 0 ifTrue: [			self setBalloonText: 				(ScriptingSystem helpStringForOperator: (aList atWrap: index + delta)).			st contents: (aList atWrap: index + 1).			^ self acceptIfInScriptor].		"rec or arg type = #number 				ifFalse: [^ st contents: (#(= ~=) atWrap: index + delta)]."		'beep:' = self decompile asString ifTrue: ["replace sound arg"			self changeSound: delta.			^ self acceptIfInScriptor].		].	(self nodeClassIs: SelectorNode) ifTrue: ["kinds of assignment"		((now _ self decompile asString) beginsWith: 'set') ifTrue: ["a setX: 3"			want _ 1+delta.  instVar _ (now allButFirst: 3) allButLast].		(now endsWith: 'IncreaseBy:') ifTrue: ["a xIncreaseBy: 3      a setX: (a getX +3)."			want _ 2+delta.  instVar _ now allButLast: 11].		(now endsWith: 'DecreaseBy:') ifTrue: ["a xDecreaseBy: 3      a setX: (a getX -3)."			want _ 3+delta.  instVar _ now allButLast: 11].		(now endsWith: 'MultiplyBy:') ifTrue: ["a xMultiplyBy: 3      a setX: (a getX *3)."			want _ 4+delta.  instVar _ now allButLast: 11].		want ifNil: [^ self].		instVar _ instVar asLowercase.		want _ #(1 2 3 4) atWrap: want.		want = 1 ifTrue: [st contents: 'set', instVar capitalized, ':'].	"setter method is present"		want = 2 ifTrue: [st contents: instVar, 'IncreaseBy:'].			"notUnderstood will create the method if needed"		want = 3 ifTrue: [st contents: instVar, 'DecreaseBy:'].			"notUnderstood will create the method if needed"		want = 4 ifTrue: [st contents: instVar, 'MultiplyBy:'].			"notUnderstood will create the method if needed"				^ self acceptIfInScriptor].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 12/13/2000 15:30'!extend	| messageNodeMorph first |	"replace this arg with a new message like (arg + 1)."	"Later do evaluation of self to see what type and offer right selector"	self deselect.	messageNodeMorph _ (MessageSend receiver: 1 selector: #+ arguments: #(1))								asTilesIn: Player.	owner replaceSubmorph: self by: messageNodeMorph.	first _ messageNodeMorph submorphs detect: [:mm | mm isSyntaxMorph].	messageNodeMorph replaceSubmorph: first by: self.	self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 12/11/2000 15:10'!offerPopUp	"Put up a halo to allow user to change		Literals (Integer, true),		Selector (beep: sound, +,-,*,//,\\, r:g:b:, setX: incX: decX: for any X,),		Variable (Color),		not AssignmentNode (_ inc dec),	Extend arrows on each literal, variable, and message, (block that is by itself).	Retract arrows on each literal or variable, or message or block that is an argument.	Any literal can be changed by Shift-clicking and typing."	| panel any upDown retract extend colorPatch edge outside |	(self hasProperty: #myPopup) ifTrue: [^ self].  "already has one"	((outside _ self rootTile owner) isKindOf: AlignmentMorph) ifTrue: [^ self].	  "can't put panel in right place"	any _ false.	(upDown _ self upDownArrows) ifNotNil: [any _ true].	(retract _ self retractArrow) ifNotNil: [any _ true].	(extend _ self extendArrow) ifNotNil: [any _ true].	(colorPatch _ self colorPatch) ifNotNil: [any _ true].	any ifFalse: [^ self].Transcript cr; print: parseNode class; space; print: (self hasProperty: #myPopup); endEntry.	panel _ RectangleMorph new color: Color transparent; borderWidth: 0.	upDown ifNotNil: [		panel addMorphBack: upDown first.		upDown first align: upDown first topLeft with: panel topLeft.		panel addMorphBack: upDown second.		upDown second align: upDown second topLeft with: upDown first bottomLeft].	colorPatch ifNotNil: [		panel addMorphBack: colorPatch.		colorPatch align: colorPatch topLeft 					with: panel topLeft].	retract ifNotNil: [		edge _ panel submorphs size = 0 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: retract.		retract align: retract topLeft with: (edge+2) @ (panel top + 3)].	extend ifNotNil: [		edge _ panel submorphs size = 0 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: extend.		extend align: extend topLeft with: (edge+2) @ (panel top + 3)].	panel align: panel topLeft with: self topRight.	panel extent: panel submorphs last bottomRight - panel topLeft.	self setProperty: #myPopup toValue: panel.	outside addMorphFront: panel.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 12/13/2000 15:48'!retract	"replace this message with its receiver.  I am the message node."	| rec |	rec _ submorphs detect: [:m | m isSyntaxMorph and: [m parseNode == parseNode receiver]].	self deletePopup.	owner replaceSubmorph: self by: rec.	rec setSelection: {rec. nil. rec}.	rec acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 12/13/2000 12:57'!retractArrow	"Return the retract arrow button.  It replaces the current message with its receiver.	I am in a MessageNode whose first subnode is not a MessagePartNode.  I did not encounter a block on the way up to it.  I am the last subnode in every owner up to it."	| patch |	(self nodeClassIs: MessageNode) ifFalse: [^ nil].	(owner isSyntaxMorph and: [owner parseNode == parseNode]) ifTrue: [^ nil].	patch _ (ImageMorph new image: (TileMorph classPool at: #RetractPicture)).	patch on: #mouseDown send: #retract to: self.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 12/13/2000 11:52'!upDownArrows	"Return an array of two up/down arrow buttons.  It replaces the selector or arg with a new one.	I am a number or boolean or a selector (beep:, +,-,*,//,\\, or setX: incX: decX: for any X."	| patch sel any ok |	any _ (self nodeClassIs: LiteralNode) and: [parseNode key isNumber].	any _ any or: [(self nodeClassIs: VariableNode) and:						[(#('true' 'false') includes: self decompile asString)]].	any _ any or: [(self nodeClassIs: SelectorNode) and:				[ok _ #(beep: + - * // \\) includes: (sel _ parseNode key).				ok _ ok or: [(sel beginsWith: 'set') and: [(sel atWrap: 4) isUppercase]].				ok _ ok or: [sel size > 11 and:						[#('IncreaseBy:' 'DecreaseBy:' 'MultiplyBy:') includes: (sel last: 11)]].				ok]].	any ifFalse: [^ nil].	patch _ {(ImageMorph new image: TileMorph upPicture)				on: #mouseDown send: #event:arrow:upDown: to: self withValue: 1.			(ImageMorph new image: TileMorph downPicture)				on: #mouseDown send: #event:arrow:upDown: to: self withValue: -1}.	^ patch! !!SyntaxMorph methodsFor: 'tests' stamp: 'di 12/13/2000 15:06'!changed	"(self bounds area > 40000 and: [(self activeHand position dist: 293@289) < 50])		ifTrue: [self halt]."	^ super changed! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'di 12/13/2000 14:21'!wantsSteps	"Don't start me stepping if I have nothing to do."	((target == nil) or: [getSelector == nil]) ifTrue: [^ false].	^ super wantsSteps! !SyntaxMorph removeSelector: #maybeDeletePopup:!SyntaxMorph removeSelector: #offerPopUp2!