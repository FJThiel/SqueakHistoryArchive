'From Squeak2.9alpha of 13 June 2000 [latest update: #3185] on 19 December 2000 at 4:38:28 pm'!"Change Set:		FloodFill-arDate:			19 December 2000Author:			Andreas RaabSpeed up filling in the sketch editor by using a dedicated and optimized flood fill algorithm. In common cases, the new fill algorithm is about 15-20 times faster. It also limits the invalidation of sketches to the region actually filled thus increasing the perceived performance by quite some amount.Also cleans up some disused stuff in SketchEditorMorph."!!Form methodsFor: 'filling' stamp: 'ar 12/19/2000 01:17'!floodFill2: aColor at: interiorPoint	"Fill the shape (4-connected) at interiorPoint.  The algorithm is based on Paul Heckbert's 'A Seed Fill Algorithm', Graphic Gems I, Academic Press, 1990.	NOTE: This is a less optimized variant for flood filling which is precisely along the lines of Heckbert's algorithm. For almost all cases #floodFill:at: will be faster (see the comment there) but this method is left in both as reference and as a fallback if such a strange case is encountered in reality."	| peeker poker stack old new x y top x1 x2 dy left goRight |	peeker _ BitBlt current bitPeekerFromForm: self.	poker _ BitBlt current bitPokerToForm: self.	stack _ OrderedCollection new: 50.	"read old pixel value"	old _ peeker pixelAt: interiorPoint.	"compute new value"	new _ aColor pixelValueForDepth: self depth.	old = new ifTrue:[^self]. "no point, is there?!!"	x _ interiorPoint x.	y _ interiorPoint y.	(y >= 0 and:[y < height]) ifTrue:[		stack addLast: {y. x. x. 1}. "y, left, right, dy"		stack addLast: {y+1. x. x. -1}].	[stack isEmpty] whileFalse:[		top _ stack removeLast.		y _ top at: 1. x1 _ top at: 2. x2 _ top at: 3. dy _ top at: 4.		y _ y + dy.		"Segment of scanline (y-dy) for x1 <= x <= x2 was previously filled.		Now explore adjacent pixels in scanline y."		x _ x1.		[x >= 0 and:[(peeker pixelAt: x@y) = old]] whileTrue:[			poker pixelAt: x@y put: new.			x _ x - 1].		goRight _ x < x1.		left _ x+1.		(left < x1 and:[y-dy >= 0 and:[y-dy < height]]) 			ifTrue:[stack addLast: {y. left. x1-1. 0-dy}].		goRight ifTrue:[x _ x1 + 1].		[			goRight ifTrue:[				[x < width and:[(peeker pixelAt: x@y) = old]] whileTrue:[					poker pixelAt: x@y put: new.					x _ x + 1].				(y+dy >= 0 and:[y+dy < height]) 					ifTrue:[stack addLast: {y. left. x-1. dy}].				(x > (x2+1) and:[y-dy >= 0 and:[y-dy >= 0]]) 					ifTrue:[stack addLast: {y. x2+1. x-1. 0-dy}]].			[(x _ x + 1) <= x2 and:[(peeker pixelAt: x@y) ~= old]] whileTrue.			left _ x.			goRight _ true.		x <= x2] whileTrue.	].! !!Form methodsFor: 'filling' stamp: 'ar 12/19/2000 16:37'!floodFill: aColor at: interiorPoint	"Fill the shape (4-connected) at interiorPoint.  The algorithm is based on Paul Heckbert's 'A Seed Fill Algorithm', Graphic Gems I, Academic Press, 1990.	NOTE: This variant has been heavily optimized to prevent the overhead of repeated calls to BitBlt. Usually this is a really big winner but the runtime now depends a bit on the complexity of the shape to be filled. For extremely complex shapes (say, a Hilbert curve) with very few pixels to fill it can be slower than #floodFill2:at: since it needs to repeatedly read the source bits. However, in all practical cases I found this variant to be 15-20 times faster than anything else."	| peeker poker stack old new x y top x1 x2 dy left goRight span spanBits w box debug |	debug _ false. "set it to true to see the filling process"	box _ interiorPoint extent: 1@1.	span _ Form extent: width@1 depth: 32.	span unhibernate.	spanBits _ span bits.	peeker _ BitBlt current toForm: span.	peeker 		sourceForm: self; 		combinationRule: 3; 		width: width; 		height: 1.	poker _ BitBlt current toForm: self.	poker 		fillColor: aColor;		combinationRule: 3;		width: width;		height: 1.	stack _ OrderedCollection new: 50.	"read old pixel value"	peeker sourceOrigin: interiorPoint; destOrigin: interiorPoint x @ 0; width: 1; copyBits.	old _ spanBits at: interiorPoint x + 1.	"compute new value (accuracy is important since the algorithm will fail if old = new)"	new _ self privateFloodFillValue: aColor.	old = new ifTrue:[^box].	x _ interiorPoint x.	y _ interiorPoint y.	(y >= 0 and:[y < height]) ifTrue:[		stack addLast: {y. x. x. 1}. "y, left, right, dy"		stack addLast: {y+1. x. x. -1}].	[stack isEmpty] whileFalse:[		debug ifTrue:[self displayOn: Display].		top _ stack removeLast.		y _ top at: 1. x1 _ top at: 2. x2 _ top at: 3. dy _ top at: 4.		y _ y + dy.		debug ifTrue:[			(Line from: (x1-1)@y to: (x2+1)@y 				withForm: (Form extent: 1@1 depth: 8) fillWhite) displayOn: Display].		"Segment of scanline (y-dy) for x1 <= x <= x2 was previously filled.		Now explore adjacent pixels in scanline y."		peeker sourceOrigin: 0@y; destOrigin: 0@0; width: width; copyBits.			"Note: above is necessary since we don't know where we'll end up filling"		x _ x1.		w _ 0.		[x >= 0 and:[(spanBits at: x+1) = old]] whileTrue:[			w _ w + 1.			x _ x - 1].		w > 0 ifTrue:[			"overwrite pixels"			poker destOrigin: x+1@y; width: w; copyBits.			box _ box quickMerge: ((x+1@y) extent: w@1)].		goRight _ x < x1.		left _ x+1.		(left < x1 and:[y-dy >= 0 and:[y-dy < height]]) 			ifTrue:[stack addLast: {y. left. x1-1. 0-dy}].		goRight ifTrue:[x _ x1 + 1].		[			goRight ifTrue:[				w _ 0.				[x < width and:[(spanBits at: x+1) = old]] whileTrue:[					w _ w + 1.					x _ x + 1].				w > 0 ifTrue:[					"overwrite pixels"					poker destOrigin: (x-w)@y; width: w; copyBits.					box _ box quickMerge: ((x-w@y) extent: w@1)].				(y+dy >= 0 and:[y+dy < height]) 					ifTrue:[stack addLast: {y. left. x-1. dy}].				(x > (x2+1) and:[y-dy >= 0 and:[y-dy >= 0]]) 					ifTrue:[stack addLast: {y. x2+1. x-1. 0-dy}]].			[(x _ x + 1) <= x2 and:[(spanBits at: x+1) ~= old]] whileTrue.			left _ x.			goRight _ true.		x <= x2] whileTrue.	].	^box! !!Form methodsFor: 'private' stamp: 'ar 12/19/2000 16:23'!privateFloodFillValue: aColor	"Private. Compute the pixel value in the receiver's depth but take into account implicit color conversions by BitBlt."	| f1 f2 bb |	f1 _ Form extent: 1@1 depth: depth.	f2 _ Form extent: 1@1 depth: 32.	bb _ BitBlt toForm: f1.	bb fillColor: aColor; 		destRect: (0@0 corner: 1@1); 		combinationRule: 3; 		copyBits.	bb _ BitBlt toForm: f2.	bb sourceForm: f1; 		sourceOrigin: 0@0;		destRect: (0@0 corner: 1@1);		combinationRule: 3;		copyBits.	^f2 pixelValueAt: 0@0.! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'ar 12/19/2000 00:20'!mouseMove: evt	"In the middle of drawing a stroke.  6/11/97 19:51 tk"	| pt priorEvt |	WorldState canSurrenderToOS: false.		"we want maximum responsiveness"	pt _ evt cursorPoint.	priorEvt _ self get: #lastEvent for: evt.	(priorEvt ~~ nil and: [pt = priorEvt cursorPoint]) ifTrue: [^ self].	self perform: (self getActionFor: evt) with: evt.		"Each action must do invalidRect:"	self set: #lastEvent for: evt to: evt.	false ifTrue: ["So senders will find the things performed here"		self paint: nil; fill: nil; erase: nil; pickup: nil; stamp: nil.		self rect: nil; ellipse: nil; polygon: nil; line: nil; star: nil].! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'ar 12/19/2000 00:20'!mouseUp: evt	| myAction |	"Do nothing except those that work on mouseUp."	myAction _ self getActionFor: evt.	myAction == #fill: ifTrue: [		self perform: myAction with: evt.		"Each action must do invalidRect:"		].	myAction == #pickup: ifTrue: [		self pickupMouseUp: evt].	myAction == #polygon: ifTrue: [self polyEdit: evt].	"a mode lets you drag vertices"	self set: #lastEvent for: evt to: nil.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'ar 12/19/2000 00:20'!deliverPainting: result evt: evt	"Done painting.  May come from resume, or from original call.  Execute user's post painting instructions in the block.  Always use this standard one.  4/21/97 tk"	| newBox newForm ans |	palette ifNotNil: "nil happens" [palette setAction: #paint: evt: evt].	"Get out of odd modes"	"rot _ palette getRotations."	"rotate with heading, or turn to and fro"	"palette setRotation: #normal."	result == #cancel ifTrue: [		ans _ PopUpMenu withCaption: 'Do you really want to throw away what you just painted?' 				chooseFrom: 'throw it away\keep painting it'.		^ ans = 1 ifTrue: [self cancelOutOfPainting]				ifFalse: [nil]].	"for Morphic"	"hostView rotationStyle: rot."		"rotate with heading, or turn to and fro"	newBox _ paintingForm rectangleEnclosingPixelsNotOfColor: Color transparent.	registrationPoint ifNotNil:		[registrationPoint _ registrationPoint - newBox origin]. "relative to newForm origin"	newForm _ 	Form extent: newBox extent depth: paintingForm depth.	newForm copyBits: newBox from: paintingForm at: 0@0 		clippingBox: newForm boundingBox rule: Form over fillColor: nil.	newForm isAllWhite ifTrue: [		(self valueOfProperty: #background) == true 			ifFalse: [^ self cancelOutOfPainting]].	self delete.	"so won't find me again"	dimForm ifNotNil: [dimForm delete].	newPicBlock value: newForm value: (newBox copy translateBy: bounds origin).! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'ar 12/19/2000 01:07'!fill: evt 	"Find the area that is the same color as where you clicked. Fill it with 	the current paint color."	| box |	evt isMouseUp		ifFalse: [^ self].	"Only fill upon mouseUp"	"would like to only invalidate the area changed, but can't find out what it is."	Cursor execute		showWhile: [			box _ paintingForm				floodFill: (self getColorFor: evt)				at: evt cursorPoint - bounds origin.			self render: box]! !SketchEditorMorph removeSelector: #areaFill:!