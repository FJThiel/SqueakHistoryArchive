'From Squeak 2.2 of Sept 23, 1998 on 24 November 1998 at 4:06:28 pm'!HtmlSpecialEntity subclass: #HtmlEmbedded	instanceVariableNames: ''	classVariableNames: 'ExtensionList '	poolDictionaries: ''	category: 'HTML-Parser-Entities'!HtmlSpecialEntity subclass: #HtmlNoEmbed	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/19/1998 23:08'!downloadStateIn: aScamper	"download the image"	| doc |	doc _ url retrieveContents.	downloadQueue nextPut: doc.! !!HtmlEmbedded methodsFor: 'attributes' stamp: 'ar 11/18/1998 19:07'!extent	"the image extent, according to the WIDTH and HEIGHT attributes.  returns nil if either WIDTH or HEIGHT is not specified"	| widthText heightText |	widthText _ self getAttribute: 'width' ifAbsent: [ ^nil ].	heightText _ self getAttribute: 'height' ifAbsent: [ ^nil ].	^ widthText asNumber @ heightText asNumber! !!HtmlEmbedded methodsFor: 'attributes' stamp: 'ar 11/18/1998 19:07'!src	^self getAttribute: 'src' default: nil! !!HtmlEmbedded methodsFor: 'testing' stamp: 'ar 11/18/1998 19:07'!mayContain: anEntity	^false! !!HtmlEmbedded methodsFor: 'testing' stamp: 'ar 11/18/1998 19:07'!tagName	^'embed'! !!HtmlEmbedded methodsFor: 'formatting' stamp: 'ar 11/18/1998 20:56'!addToFormatter: formatter	| url embeddedMorph |	self src isNil ifTrue:[^self].	url _ self src.	embeddedMorph _ self embeddedMorphFor: url.	embeddedMorph isNil ifTrue:[^self].	formatter baseUrl ifNotNil:[url _ url asUrlRelativeTo: formatter baseUrl].	embeddedMorph extent: self extent.	embeddedMorph sourceUrl: url.	embeddedMorph setProperty: #embedded toValue: true.	formatter addIncompleteMorph: embeddedMorph.! !!HtmlEmbedded methodsFor: 'formatting' stamp: 'ar 11/19/1998 22:47'!embeddedMorphClassFor: url	| lastIndex extension className |	lastIndex _ url findLast:[:c| c = $.].	lastIndex = 0 ifTrue:[^nil].	extension _ url copyFrom: lastIndex+1 to: url size.	className _ ExtensionList at: extension asLowercase ifAbsent:[^nil].	^Smalltalk at: className ifAbsent:[nil]	! !!HtmlEmbedded methodsFor: 'formatting' stamp: 'ar 11/18/1998 19:16'!embeddedMorphFor: url	| morphClass |	morphClass _ self embeddedMorphClassFor: url.	^morphClass ifNotNil:[morphClass new]! !!HtmlEmbedded class methodsFor: 'initialize' stamp: 'ar 11/19/1998 22:46'!initialize	"HtmlEmbedded initialize"	ExtensionList _ Dictionary new.	#(		('swf'	FlashPlayerMorph)	) do:[:spec| ExtensionList at: spec first put: spec last].! !!HtmlNoEmbed methodsFor: 'formatting' stamp: 'ar 11/18/1998 21:11'!addToFormatter: aFormatter	"Check if the last incomplete morph has the property #embedded set.	If so, assume that the last <EMBED> tag has been handled."	| morphs |	morphs _ aFormatter incompleteMorphs.	(morphs isEmpty not and:[(morphs last valueOfProperty: #embedded) == true])		ifTrue:[^self].	"If not handled do the usual stuff"	^super addToFormatter: aFormatter! !!HtmlNoEmbed methodsFor: 'testing' stamp: 'ar 11/18/1998 21:11'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlNoEmbed methodsFor: 'testing' stamp: 'ar 11/18/1998 21:02'!tagName	^'noembed'! !!HtmlTag class methodsFor: 'parser support' stamp: 'ar 11/18/1998 21:00'!entityClasses	"a Dictionary mapping tag names into the correct entity class"	"EntityClasses _ nil"	EntityClasses isNil ifFalse: [ ^EntityClasses ].	EntityClasses _ Dictionary new.	#( 		frameset	HtmlFrame		frame	HtmlFrame		title		HtmlTitle		style	HtmlStyle		meta	HtmlMeta		p		HtmlParagraph		form	HtmlForm		blockquote	HtmlBlockQuote		input	HtmlInput		textarea	HtmlTextArea		select	HtmlSelect		optgroup	HtmlOptionGroup		option		HtmlOption		img		HtmlImage		embed	HtmlEmbedded		noembed	HtmlNoEmbed		a		HtmlAnchor		br		HtmlBreak		li		HtmlListItem		dd		HtmlDefinitionDefinition		dt		HtmlDefinitionTerm		ol		HtmlOrderedList		ul		HtmlUnorderedList		dl		HtmlDefinitionList		h1		HtmlHeader		h2		HtmlHeader		h3		HtmlHeader		h4		HtmlHeader		h5		HtmlHeader		h6		HtmlHeader		hr		HtmlHorizontalRule		strong	HtmlBoldEntity		b		HtmlBoldEntity		em		HtmlItalicsEntity		i		HtmlItalicsEntity		dfn 	HtmlItalicsEntity		u		HtmlUnderlineEntity 		tt		HtmlFixedWidthEntity		kbd		HtmlFixedWidthEntity				strike	HtmlStrikeEntity		big		HtmlBiggerFontEntity		small	HtmlSmallerFontEntity		sub		HtmlSubscript		sup		HtmlSuperscript		font	HtmlFontEntity		pre		HtmlPreformattedRegion 		table	HtmlTable		tr		HtmlTableRow		td		HtmlTableDataItem 		th		HtmlTableHeader		) pairsDo: [ 			:tagName :className |			EntityClasses at: tagName asString put: (Smalltalk at: className) ].	^EntityClasses ! !!HtmlTag class methodsFor: 'parser support' stamp: 'ar 11/18/1998 19:27'!initialize	"HtmlTag initialize"	EntityClasses _ nil.! !!Scamper reorganize!('not yet categorized' doItContext doItReceiver release)('lint' hasLint lint showLint)('testing' isWebBrowser)('menus' displayHistory editStartPage inspectParseTree menu:shifted: perform:orSendTo: viewSource visitStartPage)('changing page' jumpToAbsoluteUrl: jumpToNewUrl jumpToUrl: startDownloadingMorphState: startDownloadingStateIn:url: stopEverything submitFormWithInputs:url:method:)('access' currentUrl document formattedPage formattedPageSelection title)('stepping' step)('initialization' initialize)('browser urls' browserUrlContents:)('status' status status:)('start page' startPage startPage:)('user interface' openAsMorph)('document handling' displayDocument: displayFlashPage: displayImagePage: displayPlainTextPage: displayTextHtmlPage: processMidiPage: processUnhandledPage:)('change/update' changeAll: invalidateLayout)!!Scamper methodsFor: 'changing page' stamp: 'ar 11/19/1998 23:12'!startDownloadingMorphState: morphs	downloadingProcess _ [		morphs do: [ :m | m downloadStateIn: self].	] newProcess.	downloadingProcess resume.! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 21:51'!displayDocument: mimeDocument	"switch to viewing the given MIMEDocument"	|  handled  urlString |	handled _ false.	"add it to the history"	recentDocuments removeAllSuchThat: [ :d | d url = mimeDocument url ].	recentDocuments addLast: mimeDocument.	recentDocuments size > 20 ifTrue: [ recentDocuments removeFirst ].			mimeDocument mainType = 'image' 		ifTrue: [handled _ self displayImagePage: mimeDocument].	mimeDocument contentType = 'text/html' 		ifTrue: [handled _ self displayTextHtmlPage: mimeDocument].	mimeDocument contentType = 'x-application/shockwave-flash'		ifTrue:[handled _ self displayFlashPage: mimeDocument].	(#('audio/midi' 'audio/x-midi') includes: mimeDocument contentType) 		ifTrue: [handled _ self processMidiPage: mimeDocument].	"Before we display plain text files we should look at the extension of the URL"	(handled not and:[ mimeDocument mainType = 'text']) ifTrue:[		urlString _ mimeDocument url toText.		(urlString endsWithAnyOf: #('.gif' '.jpg' '.pcx')) 			ifTrue:[handled _ self displayImagePage: mimeDocument].		(handled not and:[urlString endsWithAnyOf: #('.mid' '.midi')])			ifTrue:[handled _ self processMidiPage: mimeDocument].		(handled not and:[urlString endsWith: '.swf'])			ifTrue:[handled _ self displayFlashPage: mimeDocument].	].	(handled not and: [ mimeDocument mainType = 'text']) ifTrue: [		self displayPlainTextPage: mimeDocument.		handled _ true].	handled ifFalse: [self processUnhandledPage: mimeDocument].! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:29'!displayFlashPage: newSource	"A shockwave flash document -- embed it in a text"	| attrib stream player |	stream _ (RWBinaryOrTextStream with: newSource content) binary reset.	(FlashFileReader canRead: stream) ifFalse:[^false]. "Not a flash file"	player _ (FlashMorphReader on: stream) processFileAsync.	player sourceUrl: newSource url.	player startPlaying.	attrib _ TextAnchor new anchoredMorph: player.	formattedPage _ ' * ' asText.	formattedPage addAttribute: attrib from: 2 to: 2.	currentUrl _ newSource url.	pageSource _ newSource content.	"remove it from the history--these thigns are too big!!"	"ideally, there would be a smarter history mechanism that can do things like remove items when memory consumption gets too high...."	recentDocuments removeLast.	self changeAll: 	#(currentUrl title hasLint lint formattedPage formattedPageSelection).	self status: 'sittin'.	^true! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:00'!displayImagePage: newSource	"an image--embed it in a text"	| image imageMorph attrib text handled |	handled _ true.	formattedPage _ [		image _ ImageReadWriter formFromStream: (RWBinaryOrTextStream with: newSource content) binary reset.		imageMorph _ ImageMorph new image: image.		attrib _ TextAnchor new anchoredMorph: imageMorph.		text _ ' * ' asText.		text addAttribute: attrib from: 2 to: 2.		text] ifError: [ :msg :ctx | handled _ false ].	currentUrl _ newSource url.	pageSource _ newSource content.	"remove it from the history--these thigns are too big!!"	"ideally, there would be a smarter history mechanism that can do things like remove items when memory consumption gets too high...."	recentDocuments removeLast.	self changeAll: 	#(currentUrl title hasLint lint formattedPage formattedPageSelection).	self status: 'sittin'.	^handled! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:00'!displayPlainTextPage: newSource	"treat as plain text"	pageSource _ newSource content.	document _ nil.	formattedPage _ pageSource withSqueakLineEndings.	currentUrl _ newSource url.	self status: 'sittin'.	self changeAll: 	#(currentUrl title hasLint lint formattedPage).	^true! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:00'!displayTextHtmlPage: newSource	"HTML page--format it"	| formatter |	currentUrl _ newSource url.	pageSource _ newSource content.	self status: 'parsing...'.	document _ (HtmlParser parse: (ReadStream on: pageSource)).	self status: 'laying out...'.	formatter _ HtmlFormatter new.	formatter browser: self.	formatter baseUrl: currentUrl.	document addToFormatter: formatter.	formattedPage _ formatter text.	currentUrl fragment		ifNil: [ currentAnchorLocation _ nil ]		ifNotNil: [ currentAnchorLocation _				formatter anchorLocations 					at: currentUrl fragment asLowercase					ifAbsent: [ nil ] ].	self startDownloadingMorphState: (formatter incompleteMorphs).	self changeAll: 	#(currentUrl title hasLint lint formattedPage formattedPageSelection).	^true! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:00'!processMidiPage: newSource	Smalltalk at: #MIDIFileReader ifPresent:		[:reader |		reader playStream: (RWBinaryOrTextStream with: newSource content) reset binary.		self status: 'sittin'.		^true].	^false! !!Scamper methodsFor: 'document handling' stamp: 'ar 11/19/1998 22:01'!processUnhandledPage: newSource	"offer to save it to a file"	| fileName file |	self status: 'sittin'.	(self confirm: 'unkown content-type ', newSource contentType,'--Would you like to save to a file?') ifFalse: [ ^false ].	fileName _ ''.	[		fileName _ FillInTheBlank request: 'file to save in' initialAnswer: fileName.		fileName isEmpty ifTrue: [ ^self ].		file _ FileStream fileNamed: fileName.		file == nil	] whileTrue.	file reset.	file binary.	file nextPutAll: newSource content.	file close.	^true! !!Scamper methodsFor: 'change/update' stamp: 'ar 11/19/1998 21:37'!changeAll: aspects	"We have changed all of the aspects in the given array"	aspects do:[:symbol| self changed: symbol].! !!Scamper methodsFor: 'change/update' stamp: 'ar 11/19/1998 23:10'!invalidateLayout	self changeAll: #( formattedPage formattedPageSelection ).! !!String methodsFor: 'comparing' stamp: 'ar 11/19/1998 21:48'!endsWithAnyOf: aCollection	aCollection do:[:suffix|		(self endsWith: suffix) ifTrue:[^true].	].	^false! !DownloadingImageMorph removeSelector: #downloadState!HtmlEmbedded initialize!HtmlTag initialize!