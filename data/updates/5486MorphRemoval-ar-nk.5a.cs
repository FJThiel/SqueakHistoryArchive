'From Squeak3.6 of ''6 October 2003'' [latest update: #5424] on 11 October 2003 at 4:10:13 pm'!"Change Set:		MorphRemoval-arDate:			11 October 2003Author:			Andreas Raab11 October (Ned Konz):Restored Genie focus termination logic.(v5): fixed reverse test that was making invalidation problems (should remember not to make last-minute changes!!)23 September (Ned Konz):Fixed problem with extra #noteNewOwner: notifications.Fixed problem with addMorph: variants when adding morphs that already are in submorphs.This change set fixes various of the issues for getting proper notifications when adding or removing morphs. What it does:* Morph>>removeMorph: has been added as a public method to remove a submorph from some parent (why wasn't this there before???).* Morph>>privateRemove: just removes the morph from its submorphs and is NOT intended for casual use (that's what we have #removeMorph: for).* Morph>>addedMorph: and Morph>>removedMorph: have been introduced for clients which need to know about adding/removing morphs* Morph>>addAll: and friends have been updated to adhere to the new protocols while preserving their optimized implementations.* Various places have been fixed to use #removeMorph: instead of #privateRemoveMorph: and to implement the #removedMorph: notification.* #privateRemoveMorph: as well as #addedOrRemovedSubmorph: have been deprecated."!!Morph methodsFor: 'change reporting' stamp: 'ar 8/12/2003 21:50'!addedMorph: aMorph	"Notify the receiver that the given morph was just added."! !!Morph methodsFor: 'change reporting' stamp: 'ar 8/12/2003 22:27'!addedOrRemovedSubmorph: aMorph	self deprecatedExplanation:'Use #privateInvalidateMorph: instead'.	^self privateInvalidateMorph: aMorph "which is the equvivalent here"! !!Morph methodsFor: 'change reporting' stamp: 'ar 8/12/2003 22:26'!privateInvalidateMorph: aMorph	"Private. Invalidate the given morph after adding or removing.	This method is private because a) we're invalidating the morph 'remotely'	and b) it forces a fullBounds computation which should not be necessary	for a general morph c) the morph may or may not actually invalidate	anything (if it's not in the world nothing will happen) and d) the entire	mechanism should be rewritten."	aMorph fullBounds.	aMorph changed! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 8/12/2003 23:35'!slideBackToFormerSituation: evt 	| slideForm formerOwner formerPosition aWorld startPoint endPoint trans |	formerOwner := self formerOwner.	formerPosition := self formerPosition.	aWorld := evt hand world.	trans := formerOwner transformFromWorld.	slideForm := trans isPureTranslation 				ifTrue: [self imageForm offset: 0 @ 0]				ifFalse: 					[((TransformationMorph new asFlexOf: self) transform: trans) imageForm 						offset: 0 @ 0]. 	startPoint := evt hand fullBounds origin.	endPoint := trans localPointToGlobal: formerPosition.	owner removeMorph: self.	aWorld displayWorld.	slideForm 		slideFrom: startPoint		to: endPoint		nSteps: 12		delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 8/13/2003 11:32'!noteNewOwner: aMorph	"I have just been added as a submorph of aMorph"! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 8/12/2003 23:28'!addAllMorphs: aCollection	^self privateAddAllMorphs: aCollection atIndex: submorphs size! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 8/12/2003 23:29'!addAllMorphs: aCollection after: anotherMorph	^self privateAddAllMorphs: aCollection 			atIndex: (submorphs indexOf: anotherMorph ifAbsent: [submorphs size])! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'nk 10/11/2003 16:03'!delete	"Remove the receiver as a submorph of its owner and make its 	new owner be nil."	| aWorld |	aWorld := self world ifNil: [World].	"Terminate genie recognition focus"	self disableSubmorphFocusForHand: self activeHand.	owner ifNotNil:[ self privateDelete.		self player ifNotNilDo: [ :player |			"Player must be notified"			player noteDeletionOf: self fromWorld: aWorld]].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 8/10/2003 18:31'!privateDelete	"Remove the receiver as a submorph of its owner"	owner ifNotNil:[owner removeMorph: self].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 8/12/2003 22:25'!removeMorph: aMorph	"Remove the given morph from my submorphs"	| aWorld |	aMorph owner == self ifFalse:[^self].	aWorld := self world.	aWorld ifNotNil:[		aMorph outOfWorld: aWorld.		self privateInvalidateMorph: aMorph.	].	self privateRemove: aMorph.	aMorph privateOwner: nil.	self removedMorph: aMorph.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 8/12/2003 22:01'!removedMorph: aMorph	"Notify the receiver that aMorph was just removed from its children"! !!Morph methodsFor: 'private' stamp: 'nk 10/11/2003 16:08'!privateAddAllMorphs: aCollection atIndex: index	"Private. Add aCollection of morphs to the receiver"	| myWorld itsWorld otherSubmorphs |	myWorld _ self world.	otherSubmorphs _ submorphs copyWithoutAll: aCollection.	(index between: 0 and: otherSubmorphs size)		ifFalse: [^ self error: 'index out of range'].	index = 0		ifTrue:[	submorphs _ aCollection asArray, otherSubmorphs]		ifFalse:[	index = otherSubmorphs size			ifTrue:[	submorphs _ otherSubmorphs, aCollection]			ifFalse:[	submorphs _ otherSubmorphs copyReplaceFrom: index + 1 to: index with: aCollection ]].	aCollection do: [:m | | itsOwner |		itsOwner _ m owner.		itsOwner ifNotNil: [			itsWorld _ m world.			(itsWorld == myWorld) ifFalse: [				itsWorld ifNotNil: [self privateInvalidateMorph: m].				m outOfWorld: itsWorld].			(itsOwner ~~ self) ifTrue: [				m owner privateRemove: m.				m owner removedMorph: m ]].		m privateOwner: self.		myWorld ifNotNil: [self privateInvalidateMorph: m].		(myWorld == itsWorld) ifFalse: [m intoWorld: myWorld].		itsOwner == self ifFalse: [			self addedMorph: m.			m noteNewOwner: self ].	].	self layoutChanged.! !!Morph methodsFor: 'private' stamp: 'nk 10/11/2003 16:08'!privateAddMorph: aMorph atIndex: index	| oldIndex myWorld itsWorld oldOwner |	((index >= 1) and: [index <= (submorphs size + 1)])		ifFalse: [^ self error: 'index out of range'].	myWorld _ self world.	oldOwner _ aMorph owner.	(oldOwner == self and: [(oldIndex _ submorphs indexOf: aMorph) > 0]) ifTrue:[		"aMorph's position changes within in the submorph chain"		oldIndex < index ifTrue:[			"moving aMorph to back"			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.			submorphs at: index-1 put: aMorph.		] ifFalse:[			"moving aMorph to front"			oldIndex-1 to: index by: -1 do:[:i|				submorphs at: i+1 put: (submorphs at: i)].			submorphs at: index put: aMorph.		].	] ifFalse:[		"adding a new morph"		oldOwner ifNotNil:[			itsWorld _ aMorph world.			itsWorld ifNotNil: [self privateInvalidateMorph: aMorph].			(itsWorld == myWorld) ifFalse: [aMorph outOfWorld: itsWorld].			oldOwner privateRemove: aMorph.			oldOwner removedMorph: aMorph.		].		aMorph privateOwner: self.		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).		(itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].	].	myWorld ifNotNil:[self privateInvalidateMorph: aMorph].	self layoutChanged.	oldOwner == self ifFalse: [		self addedMorph: aMorph.		aMorph noteNewOwner: self ].! !!Morph methodsFor: 'private' stamp: 'ar 8/10/2003 18:46'!privateRemove: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	submorphs _ submorphs copyWithout: aMorph.! !!Morph methodsFor: 'private' stamp: 'ar 8/10/2003 18:47'!privateRemoveMorph: aMorph	self deprecatedExplanation: 'Use #removeMorph: instead.'.	^self removeMorph: aMorph! !!Morph methodsFor: '*genie-dispatching' stamp: 'NS 5/1/2003 17:28'!disableSubmorphFocusForHand: aHandMorph	"Check whether this morph or any of its submorph has the Genie focus.	If yes, disable it."	aHandMorph disableGenieFocus: self.	self submorphsDo: [:each |		each disableSubmorphFocusForHand: aHandMorph].! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'ar 8/13/2003 11:41'!intoWorld: aWorld	"Make sure report damage at least once"	damageReported _ false.	super intoWorld: aWorld.! !!FlashPlayerMorph methodsFor: 'project transition' stamp: 'ar 8/10/2003 18:17'!playProjectTransitionFrom: oldProject to: newProject entering: aBoolean	"Play the transition from the old to the new project."	Smalltalk isMorphic ifFalse: [^ self]. "Not in MVC"	self stopPlaying.	owner ifNotNil:[		self stopStepping.		owner removeMorph: self].	aBoolean ifTrue:[		self updateProjectFillsFrom: newProject.	] ifFalse:[		self updateProjectFillsFrom: oldProject.		self setProperty: #transitionBackground toValue: newProject imageForm.	].	self frameNumber: 1.	self loopFrames: false.	(self valueOfProperty: #fullScreenTransition ifAbsent:[false])		ifTrue:[self bounds: self world bounds].	self comeToFront.	self startStepping.	self startPlaying.	[playing] whileTrue: [World doOneCycleNow].	self stopPlaying.	self stopStepping.	owner removeMorph: self.	self removeProperty: #transitionBackground.	Display deferUpdates: true.	ActiveWorld fullDrawOn: (Display getCanvas).	Display deferUpdates: false.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 8/13/2003 11:39'!dropMorph: aMorph event: anEvent	"Drop the given morph which was carried by the hand"	| event dropped |	(anEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue:[^self].	"Note: For robustness in drag and drop handling we remove the morph BEFORE we drop him, but we keep his owner set to the hand. This prevents system lockups when there is a problem in drop handling (for example if there's an error in #wantsToBeDroppedInto:). THIS TECHNIQUE IS NOT RECOMMENDED FOR CASUAL USE."	self privateRemove: aMorph.	aMorph privateOwner: self.	dropped _ aMorph.	(dropped hasProperty: #addedFlexAtGrab) 		ifTrue:[dropped _ aMorph removeFlexShell].	event _ DropEvent new setPosition: self position contents: dropped hand: self.	self sendEvent: event focus: nil.	event wasHandled ifFalse:[aMorph rejectDropMorphEvent: event].	aMorph owner == self ifTrue:[aMorph delete].	self mouseOverHandler processMouseOver: anEvent.! !!PianoRollScoreMorph methodsFor: 'private' stamp: 'ar 8/10/2003 18:12'!removedMorph: aMorph	| trackSize |	trackSize _ score ambientTrack size.	score removeAmbientEventWithMorph: aMorph.	trackSize = score ambientTrack size ifFalse:		["Update duration if we removed an event".		scorePlayer updateDuration].	^super removedMorph: aMorph! !!Player methodsFor: 'scripts-vector' stamp: 'ar 8/10/2003 18:18'!* aNumber	"Treating Players like vectors, return a new Player that is myself scaled by the number"	| new newCost |	new _ costume usableSiblingInstance player.	new setX: self getX * aNumber asPoint x.	new setY: self getY * aNumber asPoint y.	newCost _ new costume.	newCost owner removeMorph: newCost.	"Keep him out of the world"	^ new! !!Player methodsFor: 'scripts-vector' stamp: 'ar 8/10/2003 18:18'!+ aPlayer	"Treating Players like vectors, add aPlayer to me and return a new Player"	| new newCost |	new _ costume usableSiblingInstance player.	new setX: self getX + aPlayer asPoint x.	new setY: self getY + aPlayer asPoint y.	newCost _ new costume.	newCost owner removeMorph: newCost.	"Keep him out of the world"	^ new! !!Player methodsFor: 'scripts-vector' stamp: 'ar 8/10/2003 18:19'!- aPlayer	"Treating Players like vectors, subtract aPlayer from me and return a new Player"	| new newCost |	new _ costume usableSiblingInstance player.	new setX: self getX - aPlayer asPoint x.	new setY: self getY - aPlayer asPoint y.	newCost _ new costume.	newCost owner removeMorph: newCost.	"Keep him out of the world"	^ new! !!Player methodsFor: 'scripts-vector' stamp: 'ar 8/10/2003 18:19'!/ aNumber	"Treating Players like vectors, return a new Player that is myself divided by the number"	| new newCost |	new _ costume usableSiblingInstance player.	new setX: self getX / aNumber asPoint x.	new setY: self getY / aNumber asPoint y.	newCost _ new costume.	newCost owner removeMorph: newCost.	"Keep him out of the world"	^ new! !!ScreeningMorph methodsFor: 'private' stamp: 'ar 8/10/2003 18:12'!removedMorph: aMorph	submorphs size = 1 ifTrue:		[self bounds: submorphs first bounds].	super removedMorph: aMorph.! !!ScrollPane methodsFor: 'menu' stamp: 'ar 8/10/2003 18:19'!retractableOrNot	"Change scroll bar operation"	retractableScrollBar _ retractableScrollBar not.	retractableScrollBar		ifTrue: [self removeMorph: scrollBar]		ifFalse: [(submorphs includes: scrollBar) 					ifFalse: [self privateAddMorph: scrollBar atIndex: 1]].	self extent: self extent! !!ScrollPane methodsFor: 'scrolling' stamp: 'ar 8/10/2003 18:19'!hideScrollBar	(submorphs includes: scrollBar) ifFalse: [^self].	self removeMorph: scrollBar.	retractableScrollBar ifFalse: [self resetExtent].! !!SyntaxMorph methodsFor: 'layout' stamp: 'ar 8/10/2003 18:19'!unfoldMessage	"I am a message whose message part is a column.	Rearrange me so that the entire message is one row."	| messageRow |	messageRow _ self submorphs last.	self removeMorph: messageRow.	messageRow submorphs do: [:m | self addMorphBack: m].! !!TextMorph methodsFor: 'anchors' stamp: 'ar 8/10/2003 18:19'!anchorMorph: aMorph at: aPoint type: anchorType	| relPt index newText block |	aMorph owner == self ifTrue:[self removeMorph: aMorph].	aMorph textAnchorType: nil.	aMorph relativeTextAnchorPosition: nil.	self addMorphFront: aMorph.	aMorph textAnchorType: anchorType.	aMorph relativeTextAnchorPosition: nil.	anchorType == #document ifTrue:[^self].	relPt _ self transformFromWorld globalPointToLocal: aPoint.	index _ (self paragraph characterBlockAtPoint: relPt) stringIndex.	newText _ Text string: (String value: 1) attribute: (TextAnchor new anchoredMorph: aMorph).	anchorType == #inline ifTrue:[		self paragraph replaceFrom: index to: index-1 with: newText displaying: false.	] ifFalse:[		index _ index min: paragraph text size.		index _ paragraph text string lastIndexOf: Character cr startingAt: index ifAbsent:[0].		block _ paragraph characterBlockForIndex: index+1.		aMorph relativeTextAnchorPosition: (relPt x - bounds left) @ (relPt y - block top ).		self paragraph replaceFrom: index+1 to: index with: newText displaying: false.	].	self fit.! !!TextMorph methodsFor: 'private' stamp: 'ar 8/10/2003 18:12'!removedMorph: aMorph	| range |	range _ text find: (TextAnchor new anchoredMorph: aMorph).	range ifNotNil:		[self paragraph replaceFrom: range first to: range last				with: Text new displaying: false.		self fit].	aMorph textAnchorType: nil.	aMorph relativeTextAnchorPosition: nil.	super removedMorph: aMorph.! !!VeryPickyMorph methodsFor: 'dropping/grabbing' stamp: 'ar 8/10/2003 18:20'!justDroppedInto: targetMorph event: evt	passengerMorph ifNil: [^self "delete"].	passengerMorph noLongerBeingDragged.	(targetMorph isKindOf: IndentingListItemMorph) ifFalse: [		passengerMorph changed.		passengerMorph _ nil.		owner removeMorph: self.		self privateOwner: nil.	].! !TextMorph removeSelector: #privateRemoveMorph:!ScreeningMorph removeSelector: #privateRemoveMorph:!PianoRollScoreMorph removeSelector: #privateRemoveMorph:!