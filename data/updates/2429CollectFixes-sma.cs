'From Squeak2.9alpha of 13 June 2000 [latest update: #2426] on 25 June 2000 at 3:40:48 pm'!"Change Set:		166CollectFixes-smaDate:			25 June 2000Author:			Stefan Matthias AustHeap>>= didn't work - removedselect/collect/etc. for weak collections didn't work - species addedDictionary>>collect: should answer a dictionary - changedInterval>>collect: didn't work for negative steps - correctedInterval>>= didn't work - correctedmost OrderedCollection enumeration methods could be unified withSequenceableCollection - changedAdded a maximum groth value for sets/ordered collections."!!Collection methodsFor: 'copying' stamp: 'sma 6/25/2000 12:01'!copyEmpty	^ self class new! !!Collection methodsFor: 'copying' stamp: 'sma 6/25/2000 12:12'!copyWith: newElement	"Answer a new collection with newElement added (as last	element if sequenceable)."	| newCollection |	newCollection _ self copy.	newCollection add: newElement.	^ newCollection! !!Collection methodsFor: 'enumerating' stamp: 'sma 6/25/2000 11:26'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection _ self species new: self size.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/25/2000 12:21'!atAll: indexArray	"Answer a new collection like the receiver which contains all elements	of the receiver at the indices of indexArray."	| newCollection |	newCollection _ self copyEmptyOfSize: indexArray size.	1 to: indexArray size do:		[:index |		newCollection at: index put: (self at: (indexArray at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 6/25/2000 12:09'!reversed	"Answer a copy of the receiver with element order reversed."	| n result src |	n _ self size.	result _ self copyEmptyOfSize: n.	src _ n + 1.	1 to: n do: [:i | result at: i put: (self at: (src _ src - 1))].	^ result"Example:	'frog' reversed"! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/25/2000 12:20'!copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newSize |	newSize _ stop - start + 1.	^ (self copyEmptyOfSize: newSize)		replaceFrom: 1		to: newSize		with: self		startingAt: start! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/25/2000 12:19'!copyReplaceFrom: start to: stop with: replacementCollection 	"Answer a copy of the receiver satisfying the following conditions: If 	stop is less than start, then this is an insertion; stop should be exactly 	start-1, start = 1 means insert before the first character, start = size+1 	means append after last character. Otherwise, this is a replacement; start 	and stop have to be within the receiver's bounds."	| newSequenceableCollection newSize endReplacement |	newSize _ self size - (stop - start + 1) + replacementCollection size.	endReplacement _ start - 1 + replacementCollection size.	newSequenceableCollection _ self copyEmptyOfSize: newSize.	newSequenceableCollection		replaceFrom: 1		to: start - 1		with: self		startingAt: 1.	newSequenceableCollection		replaceFrom: start		to: endReplacement		with: replacementCollection		startingAt: 1.	newSequenceableCollection		replaceFrom: endReplacement + 1		to: newSize		with: self		startingAt: stop + 1.	^ newSequenceableCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/25/2000 12:24'!copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and has 	newElement at the last element."	| newCollection |	newCollection _ self copyEmptyOfSize: self size + 1.	newCollection 		replaceFrom: 1		to: self size		with: self		startingAt: 1.	newCollection at: newCollection size put: newElement.	^ newCollection! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 6/25/2000 12:02'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection _ self copyEmptyOfSize: self size.	1 to: self size do:		[:index |		newCollection at: index put: (aBlock value: (self at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 6/25/2000 12:05'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with 	corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size		ifFalse: [self error: 'both collections must have the same size'].	result _ self copyEmptyOfSize: self size.	1 to: self size do:		[:index |		result			at: index			put: (twoArgBlock				value: (self at: index)				value: (otherCollection at: index))].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 6/25/2000 12:27'!withIndexCollect: elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies	the second argument to the block."	| result |	result _ self copyEmptyOfSize: self size.	1 to: self size do:		[:index |		result			at: index			put: (elementAndIndexBlock				value: (self at: index)				value: index)].	^ result! !!SequenceableCollection methodsFor: 'private' stamp: 'sma 6/25/2000 11:55'!copyEmptyOfSize: anInteger	^ self species new: anInteger! !!ArrayedCollection methodsFor: 'enumerating' stamp: 'sma 6/25/2000 14:24'!select: aBlock	| aStream element |	aStream _ WriteStream on: (self species new: self size).	1 to: self size do:		[:index |		(aBlock value: (element _ self at: index))			ifTrue: [aStream nextPut: element]].	^ aStream contents! !!Heap methodsFor: 'enumerating' stamp: 'sma 6/25/2000 14:15'!do: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument."	array from: 1 to: tally do: aBlock! !!Heap methodsFor: 'growing' stamp: 'sma 6/25/2000 14:33'!grow	self growTo: self size + self growSize! !!Heap methodsFor: 'growing' stamp: 'sma 6/25/2000 14:33'!growSize	"Return the size by which the receiver should grow if there are no 	empty slots left."	^ array size min: 1000 max: 5! !!Interval methodsFor: 'accessing' stamp: 'sma 6/25/2000 11:42'!at: anInteger put: anObject 	"Storing into an Interval is not allowed."	self shouldNotImplement! !!Interval methodsFor: 'comparing' stamp: 'sma 6/25/2000 11:41'!= anInterval 	"Answer true if my species and anInterval species are equal, and	if our starts, steps and sizes are equal."	self class == anInterval class ifFalse: [^ false].	^ self first = anInterval first		and: [self increment = anInterval increment		and: [self size = anInterval size]]! !!Interval methodsFor: 'enumerating' stamp: 'sma 6/25/2000 11:46'!collect: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| result index value |	result _ self species new: self size.	index _ 0.	value _ start.	step < 0		ifTrue: [[stop <= value]				whileTrue: 					[result at: (index _ index + 1) put: (aBlock value: value).					value _ value + step]]		ifFalse: [[stop >= value]				whileTrue: 					[result at: (index _ index + 1) put: (aBlock value: value).					value _ value + step]].	^ result! !!Interval methodsFor: 'enumerating' stamp: 'sma 6/25/2000 11:34'!do: aBlock	"Evaluate aBlock for each element of the receiver."	| aValue |	aValue _ start.	step < 0		ifTrue: [[stop <= aValue]				whileTrue: 					[aBlock value: aValue.					aValue _ aValue + step]]		ifFalse: [[stop >= aValue]				whileTrue: 					[aBlock value: aValue.					aValue _ aValue + step]]! !!Interval methodsFor: 'enumerating' stamp: 'sma 6/25/2000 11:35'!reverseDo: aBlock 	"Evaluate aBlock for each element of the receiver, in reverse order."	| aValue |	aValue _ stop.	step < 0		ifTrue: [[start >= aValue]				whileTrue: 					[aBlock value: aValue.					aValue _ aValue - step]]		ifFalse: [[start <= aValue]				whileTrue: 					[aBlock value: aValue.					aValue _ aValue - step]]! !!Interval methodsFor: 'private' stamp: 'sma 6/25/2000 11:35'!species	^ Array! !!OrderedCollection methodsFor: 'copying' stamp: 'sma 6/25/2000 12:12'!copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and 	includes the argument, newElement, at the end."	| newCollection |	newCollection _ self copy.	newCollection add: newElement.	^ newCollection! !!OrderedCollection methodsFor: 'adding' stamp: 'sma 6/25/2000 14:33'!growSize	^ array size min: 10000 max: 5! !!OrderedCollection methodsFor: 'private' stamp: 'sma 6/25/2000 11:56'!copyEmptyOfSize: anInteger	^ (super copyEmptyOfSize: anInteger) firstIndex: 1 lastIndex: anInteger! !!OrderedCollection methodsFor: 'private' stamp: 'sma 6/25/2000 11:57'!firstIndex: first lastIndex: last	firstIndex _ first.	lastIndex _ last! !!OrderedCollection methodsFor: 'private' stamp: 'sma 6/25/2000 12:16'!replaceFrom: start to: stop with: replacement startingAt: repStart	array		replaceFrom: start + firstIndex - 1		to: stop + firstIndex - 1		with: replacement		startingAt: repStart! !!Set methodsFor: 'private' stamp: 'sma 6/25/2000 14:31'!grow	self growTo: self size + self growSize! !!Set methodsFor: 'private' stamp: 'sma 6/25/2000 14:32'!growSize	^ array size min: 1000 max: 2! !!Set methodsFor: 'private' stamp: 'sma 6/25/2000 14:31'!growTo: newSize	"Grow the elements array and reinsert the old elements"	| oldElements |	oldElements _ array.	array _ Array new: newSize.	tally _ 0.	oldElements do: [:each | each ifNotNil: [self noCheckAdd: each]]! !!Set methodsFor: 'private' stamp: 'sma 6/25/2000 12:31'!rehash	| newSelf |	newSelf _ self class new: self size.	self do: [:each | newSelf noCheckAdd: each].	array _ newSelf array! !!Dictionary methodsFor: 'enumerating' stamp: 'sma 6/25/2000 11:28'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection _ self species new: self size.	self keysAndValuesDo: [:key :value | newCollection at: key put: (aBlock value: value)].	^ newCollection! !!Dictionary methodsFor: 'private' stamp: 'sma 6/25/2000 12:31'!rehash	| newSelf |	newSelf _ self class new: self size.	self associationsDo: [:each | newSelf noCheckAdd: each].	array _ newSelf array! !!MethodDictionary methodsFor: 'private' stamp: 'sma 6/25/2000 14:37'!grow	"The receiver's basicSize must be a power of 2."	| newSelf key |	newSelf _ self class new: self basicSize.  "This will double the size"	1 to: self basicSize do:		[:i | 		(key _ self basicAt: i) == nil			ifFalse: [newSelf at: key put: (array at: i)]].	self become: newSelf! !!MethodDictionary methodsFor: 'private' stamp: 'sma 6/25/2000 14:12'!rehash 	| newSelf key |	newSelf _ self class new: self size.	1 to: self basicSize do:		[:i | key _ self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	self become: newSelf! !!SortedCollection methodsFor: 'copying' stamp: 'sma 6/25/2000 11:59'!copyEmpty	"Answer a copy of the receiver without any of the receiver's elements."	^ super copyEmpty sortBlock: sortBlock! !!WeakArray methodsFor: 'private' stamp: 'sma 6/25/2000 11:00'!species	^ Array! !!WeakKeyDictionary methodsFor: 'private' stamp: 'sma 6/25/2000 14:11'!rehash	"Overriden to copy the size also - we may have lost any number of elements"	| newSelf |	newSelf _ self class new: self size.	self associationsDo: [:each | newSelf noCheckAdd: each].	array _ newSelf array.	tally _ newSelf size! !!WeakKeyDictionary methodsFor: 'private' stamp: 'sma 6/25/2000 12:28'!species	^ Dictionary! !!WeakRegistry methodsFor: 'private' stamp: 'sma 6/25/2000 11:01'!species	^ Set! !!WeakRegistry methodsFor: 'enumerating' stamp: 'sma 6/25/2000 11:02'!do: aBlock 	^ self protected: [valueDictionary keysDo: aBlock]! !!WeakValueDictionary methodsFor: 'private' stamp: 'sma 6/25/2000 12:29'!species	^ Dictionary! !!WeakValueDictionary reorganize!('accessing' at:put:)('adding' add:)('private' species)!!WeakArray reorganize!('private' species)!SourceFileArray removeSelector: #collect:!Set removeSelector: #collect:!OrderedCollection removeSelector: #collect:!OrderedCollection removeSelector: #copyEmpty!OrderedCollection removeSelector: #copyFrom:to:!OrderedCollection removeSelector: #copyReplaceFrom:to:with:!OrderedCollection removeSelector: #reversed!OrderedCollection removeSelector: #with:collect:!Interval class removeSelector: #new!Interval removeSelector: #remove:!Interval removeSelector: #remove:ifAbsent:!Heap removeSelector: #=!SequenceableCollection removeSelector: #copyEmpty!SequenceableCollection removeSelector: #select:!Collection removeSelector: #copyEmpty:!