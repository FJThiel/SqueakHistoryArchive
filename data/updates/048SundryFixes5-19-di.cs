'From Squeak 2.0 BETA of May 8, 1998 on 19 May 1998 at 9:08:19 pm'!"Change Set:		SundryFixes-diDate:			19 May 1998Author:			Dan IngallsFixed NewParagraph characterBlockForIndex: to tolerate arguments beyond range	(needed for how browser selects templates).Fixed LargeNegInt highBit to work again.Dictionary inspection now works in Morphic (but not PictDicts). "!!Object methodsFor: 'user interface' stamp: 'di 5/19/1998 20:43'!inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	Inspector openOn: self withEvalPane: true! !!Inspector class methodsFor: 'instance creation' stamp: 'di 5/19/1998 20:51'!openAsMorphOn: anObject withEvalPane: withEval			withLabel: label valueViewClass: valueViewClass	"Note: for now, this always adds an eval pane, and ignores the valueViewClass"	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: anObject defaultLabelForInspector) model: inspector.	window addMorph: (PluggableListMorph on: inspector list: #fieldList				selected: #selectionIndex changeSelected: #toggleIndex: menu: #fieldListMenu:)		frame: (0@0 corner: 0.3@0.7).	window addMorph: (PluggableTextMorph on: inspector text: #contents accept: #accept:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.3@0 corner: 1@0.7).	window addMorph: (PluggableTextMorph on: inspector text: #trash accept: #trash:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.7 corner: 1@1).	window openInWorld! !!Inspector class methodsFor: 'instance creation' stamp: 'di 5/19/1998 17:16'!openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	| topView inspector listView valueView evalView |	World ifNotNil:		[^ self openAsMorphOn: anObject withEvalPane: withEval			withLabel: label valueViewClass: valueViewClass].	inspector _ self inspect: anObject.	topView _ StandardSystemView new model: inspector.	topView borderWidth: 1.	listView _ PluggableListView on: inspector		list: #fieldList		selected: #selectionIndex		changeSelected: #toggleIndex:		menu: #fieldListMenu:		keystroke: #inspectorKey:from:.	(inspector isMemberOf: DictionaryInspector)		ifTrue: [listView menu: #dictionaryMenu:].	listView window: (0 @ 0 extent: 40 @ 40).	topView addSubView: listView.	valueView _ valueViewClass new.		"PluggableTextView or PluggableFormView"	(valueView respondsTo: #getText) ifTrue: [		valueView on: inspector 			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:].	(valueViewClass == FormInspectView) ifTrue: [		valueView model: inspector.		"valueView borderWidthLeft: 2 right: 2 top: 2 bottom: 2"].	valueView window: (0 @ 0 extent: 75 @ 40).	topView addSubView: valueView toRightOf: listView.		withEval ifTrue:		[evalView _ PluggableTextView new on: inspector 			text: #trash accept: #trash:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		evalView window: (0 @ 0 extent: 115 @ 20).		evalView askBeforeDiscardingEdits: false.		topView addSubView: evalView below: listView].	topView label: label.	topView minimumSize: 180 @ 120.	topView controller open! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'di 5/19/1998 20:23'!highBit	"Answer the index of the high order bit of the receiver, or zero if the receiver is zero. This method is allowed (and needed) for LargeNegativeIntegers as well, since Squeak's LargeIntegers are sign/magnitude."	| realLength lastDigit |	realLength _ self digitLength.	[(lastDigit _ self digitAt: realLength) = 0]		whileTrue:		[(realLength _ realLength - 1) = 0 ifTrue: [^ 0]].	^ lastDigit highBit + (8 * (realLength - 1))! !!NewParagraph methodsFor: 'selection' stamp: 'di 5/19/1998 20:39'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line |	line _ lines at: (self lineIndexForCharacter: index).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: nil index: ((index max: line first) min: line last+1)		in: line! !