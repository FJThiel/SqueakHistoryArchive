'From Squeak 2.3 of January 14, 1999 on 5 March 1999 at 5:33:06 pm'!"Change Set:		RootBitCleanupDate:			5 March 1999Author:			Dan IngallsA cleanup of the treatment of root bits in the object memory.Adds a diagnostic test for unmarked roots when DoAssertionChecks is true.Merges three copies of the code for noting a root so as to clarify the correspondence between marking root bits and posting entries in the roots table.Eliminates a check for integer entries in the roots table, since this is forbidden when oops are installed."!!ObjectMemory methodsFor: 'memory access' stamp: 'di 3/5/1999 17:23'!validateRoots 	"Verify that every old object that points to a new object 		has its root bit set, and		appears in the rootTable.	This method should not be called if the rootTable is full, because roots	are no longer recorded, and incremental collections are not attempted.	If DoAssertionChecks is true, this routine will halt on an unmarked root.	Otherwise, this routine will merely return true in that case."	| oop fieldAddr fieldOop header badRoot |	badRoot _ false.	oop _ self firstObject.	[oop < youngStart] whileTrue:		[(self isFreeObject: oop) ifFalse:			[fieldAddr _ oop + (self lastPointerOf: oop).			[fieldAddr > oop] whileTrue:				[fieldOop _ self longAt: fieldAddr.				(fieldOop >= youngStart and: [(self isIntegerObject: fieldOop) not]) ifTrue:					["fieldOop is a pointer to a young object"					header _ self longAt: oop.					(header bitAnd: RootBit) = 0					ifTrue:						["Forbidden: points to young obj but root bit not set."						DoAssertionChecks ifTrue: [self error: 'root bit not set'].						badRoot _ true]					ifFalse:						["Root bit is set"						"Extreme test -- validate that oop was entered in rootTable too..."						"Disabled for now...						found _ false.						1 to: rootTableCount do:							[:i | oop = (rootTable at: i) ifTrue: [found _ true]].						found ifFalse:							[DoAssertionChecks ifTrue: [self error: 'root table not set'].							badRoot _ true].						..."						]].				fieldAddr _ fieldAddr - 4]].		oop _ self objectAfter: oop].	^ badRoot! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'di 2/26/1999 17:17'!beRootIfOld: oop	"If this object is old, mark it as a root (because a new object may be stored into it)"	self inline: false.	((oop < youngStart) and: [(self isIntegerObject: oop) not]) ifTrue:		["Yes, oop is an old object"		self noteAsRoot: oop headerLoc: oop].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'di 3/5/1999 17:21'!incrementalGC	"Do a mark/sweep garbage collection of just the young object area of object memory (i.e., objects above youngStart), using the root table to identify objects containing pointers to young objects from the old object area."	| survivorCount startTime |	self inline: false.	rootTableCount >= RootTableSize ifTrue: [		"root table overflow; cannot do an incremental GC (this should be very rare)"		statRootTableOverflows _ statRootTableOverflows + 1.		^ self fullGC].	DoAssertionChecks ifTrue: [self validateRoots].	self preGCAction: false.	"incremental GC and compaction"	startTime _ self ioMicroMSecs.	self markPhase.	survivorCount _ self sweepPhase.	self incrementalCompaction.	allocationCount _ 0.	statIncrGCs _ statIncrGCs + 1.	statIncrGCMSecs _ statIncrGCMSecs + (self ioMicroMSecs - startTime).	survivorCount > tenuringThreshold ifTrue: [		"move up the young space boundary if there are too many survivors;		 this limits the number of objects that must be processed on future		 incremental GC's"		statTenures _ statTenures + 1.		self clearRootsTable.		youngStart _ freeBlock.  "reset the young object boundary"	].	self postGCAction.! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'di 2/26/1999 17:16'!noteAsRoot: oop headerLoc: headerLoc	"Record that the given oop in the old object area points to an object in the young area.	HeaderLoc is usually = oop, but may be an addr in a forwarding block."	| header |	self inline: true.	header _ self longAt: headerLoc.	(header bitAnd: RootBit) = 0 ifTrue:		["record oop as root only if not already recorded"		rootTableCount < RootTableSize ifTrue:			["record root only if there is room in the roots table"			rootTableCount _ rootTableCount + 1.			rootTable at: rootTableCount put: oop.			self longAt: headerLoc put: (header bitOr: RootBit)]].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'di 2/26/1999 17:17'!possibleRootStoreInto: oop value: valueObj	"oop is an old object.  If valueObj is young, mark the object as a root."	self inline: false.	((valueObj >= youngStart) and: [(self isIntegerObject: valueObj) not]) ifTrue:		["Yes, valueObj is a young object"		self noteAsRoot: oop headerLoc: oop].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'di 2/27/1999 10:17'!markPhase	"Mark phase of the mark and sweep garbage collector. Set the mark bits of all reachable objects. Free chunks are untouched by this process."	"Assume: All non-free objects are initially unmarked. Root objects were unmarked when they were made roots. (Make sure this stays true!!!!)."	| oop |	self inline: false.	"clear the recycled context lists"	freeContexts _ NilContext.	"trace the interpreter's objects, including the active stack and special objects array"	self markAndTraceInterpreterOops.	"trace the roots"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		self markAndTrace: oop.	].! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 2/26/1999 17:22'!beRootWhileForwarding: oop	"Record that the given oop in the old object area points to an object in the young area when oop may be forwarded."	"Warning: No young objects should be recorded as roots. Callers are responsible for ensuring this constraint is not violated."	| header fwdBlock |	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0		ifTrue: ["This oop is forwarded"				fwdBlock _ (header bitAnd: AllButMarkBitAndTypeMask) << 1.				DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].				self noteAsRoot: oop headerLoc: fwdBlock + 4]		ifFalse: ["Normal -- no forwarding"				self noteAsRoot: oop headerLoc: oop]! !