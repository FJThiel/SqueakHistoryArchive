'From Squeak 2.4b of April 23, 1999 on 20 July 1999 at 4:10:10 pm'!Object subclass: #FlashCodec	instanceVariableNames: 'stream '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!!Color class methodsFor: 'instance creation' stamp: 'ar 6/29/1999 16:08'!colorFromPixelValue: p depth: d	"Convert a pixel value for the given display depth into a color."	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."	| r g b alpha |	d = 8 ifTrue: [^ IndexedColors at: (p bitAnd: 16rFF) + 1].	d = 4 ifTrue: [^ IndexedColors at: (p bitAnd: 16r0F) + 1].	d = 2 ifTrue: [^ IndexedColors at: (p bitAnd: 16r03) + 1].	d = 1 ifTrue: [^ IndexedColors at: (p bitAnd: 16r01) + 1].	(d = 16) | (d = 15) ifTrue: [		"five bits per component"		r _ (p bitShift: -10) bitAnd: 16r1F.		g _ (p bitShift: -5) bitAnd: 16r1F.		b _ p bitAnd: 16r1F.		^ Color r: r g: g b: b range: 31].	d = 32 ifTrue: [		"eight bits per component; 8 bits of alpha"		r _ (p bitShift: -16) bitAnd: 16rFF.		g _ (p bitShift: -8) bitAnd: 16rFF.		b _ p bitAnd: 16rFF.		alpha _ p bitShift: -24.		alpha = 0 ifTrue:[^Color transparent].		alpha < 255			ifTrue: [^ (Color r: r g: g b: b range: 255) alpha: (alpha asFloat / 255.0)]			ifFalse: [^ (Color r: r g: g b: b range: 255)]].	d = 12 ifTrue: [		"four bits per component"		r _ (p bitShift: -8) bitAnd: 16rF.		g _ (p bitShift: -4) bitAnd: 16rF.		b _ p bitAnd: 16rF.		^ Color r: r g: g b: b range: 15].	d = 9 ifTrue: [		"three bits per component"		r _ (p bitShift: -6) bitAnd: 16r7.		g _ (p bitShift: -3) bitAnd: 16r7.		b _ p bitAnd: 16r7.		^ Color r: r g: g b: b range: 7].	self error: 'unknown pixel depth: ', d printString! !!FlashBoundaryShape methodsFor: 'disk i/o' stamp: 'ar 6/30/1999 12:44'!compress	(points isKindOf: String) ifFalse:[		points _ FlashCodec compress: self.		leftFills _ rightFills _ lineWidths _ lineFills _ fillStyles _ nil].! !!FlashBoundaryShape methodsFor: 'disk i/o' stamp: 'ar 6/30/1999 12:46'!decompress	| newShape |	(points isKindOf: String) ifTrue:[		newShape _ FlashCodec decompress: (ReadStream on: points).		points _ newShape points.		leftFills _ newShape leftFills.		rightFills _ newShape rightFills.		lineWidths _ newShape lineWidths.		lineFills _ newShape lineFills.		fillStyles _ newShape fillStyles].! !!FlashCodec methodsFor: 'accessing'!compress: aShape	self compressPoints: aShape points.	self compressRunArray: aShape leftFills.	self compressRunArray: aShape rightFills.	self compressRunArray: aShape lineWidths.	self compressRunArray: aShape lineFills.	self compressFills: aShape fillStyles.	^stream contents! !!FlashCodec methodsFor: 'accessing'!contents	^stream contents! !!FlashCodec methodsFor: 'accessing'!decompress	| points leftFills rightFills lineWidths lineFills fillStyles |	points _ self decompressPoints.	leftFills _ self decompressRunArray.	rightFills _ self decompressRunArray.	lineWidths _ self decompressRunArray.	lineFills _ self decompressRunArray.	fillStyles _ self decompressFills.	^FlashBoundaryShape points: points leftFills: leftFills rightFills: rightFills fillStyles: fillStyles lineWidths: lineWidths lineFills: lineFills! !!FlashCodec methodsFor: 'initialize'!initialize	stream _ WriteStream on: (String new: 1000).! !!FlashCodec methodsFor: 'initialize'!on: aStream	stream _ aStream! !!FlashCodec methodsFor: 'compressing points'!compressPoints: points	"Compress the points using delta values and RLE compression."	| lastPt runLength runValue nextPt deltaPt |	points class == ShortPointArray 		ifTrue:[stream print: points size]		ifFalse:[points class == PointArray 					ifTrue:[stream print: points size negated]					ifFalse:[self error:'The point array has the wrong type!!']].	points size = 0 ifTrue:[^self].	lastPt _ points at: 1.	"First point has no delta"	self printCompressedPoint: lastPt on: stream runLength: 1.	runLength _ 0.	runValue _ nil.	2 to: points size do:[:i|		nextPt _ points at: i.		deltaPt _ nextPt - lastPt.		runValue = deltaPt ifTrue:[			runLength _ runLength + 1.		]ifFalse:[			self printCompressedPoint: runValue on: stream runLength: runLength.			runValue _ deltaPt.			runLength _ 1.		].		lastPt _ nextPt].	runLength > 0 ifTrue:[self printCompressedPoint: runValue on: stream runLength: runLength].	stream nextPut:$X."Terminating character"	^stream! !!FlashCodec methodsFor: 'compressing points'!decompressPoints	"Decompress the points using delta values and RLE compression."	| pts n index runValue spl runLength c x y |	n _ Integer readFrom: stream.	n = 0 ifTrue:[^ShortPointArray new].	n < 0		ifTrue:[	n _ 0 - n.				pts _ PointArray new: n]		ifFalse:[pts _ ShortPointArray new: n].	index _ 0.	runValue _ 0@0.	"Prefetch special character"	spl _ stream next.	[index < n] whileTrue:[		"Read runLength/value"		spl = $* ifTrue:[			"Run length follows"			runLength _ 0.			[(c _ stream next) isDigit] 				whileTrue:[runLength _ (runLength * 10) + c digitValue].			spl _ c.		] ifFalse:[runLength _ 1].		"Check for special zero point"		(spl = $Z or:[spl = $A]) ifTrue:[			"Since deltaPt is 0@0 there is no need to update runValue.			Just prefetch the next special character"			spl = $A ifTrue:[runLength _ 2].			spl _ stream next.		] ifFalse:["Regular point"			"Fetch absolute delta x value"			x _ 0.			[(c _ stream next) isDigit] 				whileTrue:[x _ (x * 10) + c digitValue].			"Sign correct x"			spl = $- 				ifTrue:[x _ 0 - x]				ifFalse:[spl = $+ ifFalse:[self error:'Bad special character']].			spl _ c.			"Fetch absolute delta y value"			y _ 0.			[(c _ stream next) isDigit] 				whileTrue:[y _ (y * 10) + c digitValue].			"Sign correct y"			spl = $-				ifTrue:[y _ 0 - y]				ifFalse:[spl = $+ ifFalse:[self error:'Bad special character']].			spl _ c.			"Compute absolute run value"			runValue _ runValue + (x@y).		].		"And store points"		1 to: runLength			do:[:i| pts at: (index _ index + 1) put: runValue].	].	"Last char must be X"	spl = $X ifFalse:[self error:'Bad special character'].	^pts! !!FlashCodec methodsFor: 'compressing points'!printCompressedPoint: aPoint on: aStream runLength: n	"Print the given point on the stream using the given run length"	n = 0 ifTrue:[^self]. "Can only happen for the first run"	"Check if we're storing a zero point"	(aPoint x = 0 and:[aPoint y = 0]) 		ifTrue:[			"Two zero points are specially encoded since they			occur if a line segment ends and the next segment			starts from its end point, e.g., (p1,p2,p2) (p2,p3,p4) - this is very likely."			n = 2 ifTrue:[^aStream nextPut:$A].			n = 1 ifTrue:[^aStream nextPut: $Z].			^aStream nextPut:$*; print: n; nextPut:$Z].	n > 1 ifTrue:[		"Run length encoding: '*N' repeat the following point n times"		aStream nextPut: $*; print: n].	"Point encoding: Two numbers.	Number encoding: '+XYZ' or '-XYZ'"	self printPoint: aPoint on: aStream! !!FlashCodec methodsFor: 'compressing points'!printPoint: aPoint on: aStream	aPoint x < 0		ifTrue:[aStream print: aPoint x]		ifFalse:[aStream nextPut: $+; print: aPoint x].	aPoint y < 0		ifTrue:[aStream print: aPoint y]		ifFalse:[aStream nextPut: $+; print: aPoint y].! !!FlashCodec methodsFor: 'compressing points'!readPointFrom: aStream	| sign x y |	sign _ aStream next.	x _ Integer readFrom: aStream.	sign = $- ifTrue:[x _ 0-x].	sign _ aStream next.	y _ Integer readFrom: aStream.	sign = $- ifTrue:[y _ 0-y].	^x@y! !!FlashCodec methodsFor: 'compressing fills'!compressFillStyle: aFillStyle	aFillStyle isSolidFill ifTrue:[^self compressSolidFill: aFillStyle].	aFillStyle isGradientFill ifTrue:[^self compressGradientFill: aFillStyle].	aFillStyle isBitmapFill ifTrue:[^self compressBitmapFill: aFillStyle].	self error:'Unknown fill style'! !!FlashCodec methodsFor: 'compressing fills'!compressFills: anArray	stream print: anArray size.	anArray do:[:fillStyle| self compressFillStyle: fillStyle].	stream nextPut:$X. "Terminator"! !!FlashCodec methodsFor: 'compressing fills'!compressGradientFill: aFillStyle	"Note: No terminators for simple colors"	| ramp key |	aFillStyle radial		ifTrue:[stream nextPut: $R] " 'R'adial gradient"		ifFalse:[stream nextPut: $L]. " 'L' inear gradient"	self printPoint: aFillStyle origin on: stream.	self printPoint: aFillStyle direction on: stream.	self printPoint: aFillStyle normal on: stream.	ramp _ aFillStyle colorRamp.	stream nextPut: $+; print: ramp size.	ramp do:[:assoc|		key _ (assoc key * 255) truncated.		stream nextPut: (Character value: key).		self storeColor: assoc value on: stream].	stream nextPut:$X. "Terminator"! !!FlashCodec methodsFor: 'compressing fills'!compressSolidFill: aFillStyle	"Note: No terminators for simple colors"	stream nextPut: $S. " 'S'olid fill"	self storeColor: aFillStyle asColor on: stream.! !!FlashCodec methodsFor: 'compressing fills'!decompressFillStyle	| type |	type _ stream next.	type = $S ifTrue:[^self decompressSolidFill].	type = $R ifTrue:[^self decompressGradientFill: true].	type = $L ifTrue:[^self decompressGradientFill: false].	type = $B ifTrue:[^self decompressBitmapFill].	^self error:'Unknown fill type'! !!FlashCodec methodsFor: 'compressing fills'!decompressFills	| fills n |	n _ Integer readFrom: stream.	fills _ Array new: n.	1 to: n do:[:i|		fills at: i put: self decompressFillStyle.	].	stream next = $X ifFalse:[^self error:'Compression problem'].	^fills! !!FlashCodec methodsFor: 'compressing fills'!decompressGradientFill: radial	"Note: No terminators for simple colors"	| ramp fs rampSize rampIndex rampColor |	fs _ GradientFillStyle new.	fs radial: radial.	fs origin: (self readPointFrom: stream).	fs direction: (self readPointFrom: stream).	fs normal: (self readPointFrom: stream).	stream next = $+ ifFalse:[self error:'Negative Array size'].	rampSize _ Integer readFrom: stream.	ramp _ Array new: rampSize.	1 to: rampSize do:[:i|		rampIndex _ stream next asciiValue / 255.0.		rampColor _ self readColorFrom: stream.		ramp at: i put: (rampIndex -> rampColor)].	fs colorRamp: ramp.	stream next = $X ifFalse:[^self error:'Compressio problem'].	^fs! !!FlashCodec methodsFor: 'compressing fills'!decompressSolidFill	| color |	color _ self readColorFrom: stream.	^SolidFillStyle color: color! !!FlashCodec methodsFor: 'compressing fills' stamp: 'ar 7/20/1999 16:05'!readColorFrom: aStream	| pv |	pv _ stream next asciiValue +			(stream next asciiValue bitShift: 8) +				(stream next asciiValue bitShift: 16) +					(stream next asciiValue bitShift: 24).	^Color colorFromPixelValue: pv depth: 32! !!FlashCodec methodsFor: 'compressing fills' stamp: 'ar 7/20/1999 16:03'!storeColor: color on: aStream	| pv |	pv _ color pixelValueForDepth: 32.	aStream 		nextPut: (pv digitAt: 1) asCharacter;		nextPut: (pv digitAt: 2) asCharacter;		nextPut: (pv digitAt: 3) asCharacter;		nextPut: (pv digitAt: 4) asCharacter.! !!FlashCodec methodsFor: 'compressing run arrays'!compressRunArray: aShortRunArray	stream nextPut:$+; print: aShortRunArray runSize.	aShortRunArray lengthsAndValuesDo:[:runLength :runValue|		runLength < 0 ifTrue:[self error:'Bad run length'].		stream nextPut:$+; print: runLength.		runValue < 0			ifTrue:[stream print: runValue]			ifFalse:[stream nextPut:$+; print: runValue].	].	stream nextPut:$X. "Terminator"	^stream! !!FlashCodec methodsFor: 'compressing run arrays'!decompressRunArray	| n array runIndex runLength runValue spl c |	stream next = $+ ifFalse:[self error:'Negative array size'].	n _ Integer readFrom: stream.	array _ ShortRunArray basicNew: n.	runIndex _ 0.	spl _ stream next.	[runIndex < n] whileTrue:[		"Read runLength"		runLength _ 0.		[(c _ stream next) isDigit] 			whileTrue:[runLength _ (runLength * 10) + c digitValue].		spl = $+ ifFalse:[self error:'Negative run length'].		"Read run value"		spl _ c.		runValue _ 0.		[(c _ stream next) isDigit]			whileTrue:[runValue _ (runValue * 10) + c digitValue].		spl = $-			ifTrue:[runValue _ 0 - runValue]			ifFalse:[spl = $+ ifFalse:[self error:'Compression problem']].		array setRunAt: (runIndex _ runIndex+1) toLength: runLength value: runValue.		spl _ c.	].	spl = $X ifFalse:[^self error:'Unexpected special character'].	^array	! !!FlashCodec class methodsFor: 'decompressing'!decompress: aStream	^(self new on: aStream) decompress! !!FlashCodec class methodsFor: 'decompressing'!decompressPoints: aStream	^(self new on: aStream) decompressPoints! !!FlashCodec class methodsFor: 'compressing'!compress: aFlashBoundaryShape	^self new compress: aFlashBoundaryShape! !!FlashCodec class methodsFor: 'compressing'!compressPoints: points	^(self new initialize compressPoints: points) contents! !!FlashCodec class methodsFor: 'instance creation'!new	^super new initialize! !!FlashMorph methodsFor: 'disk i/o' stamp: 'ar 6/30/1999 12:23'!compress	"Compress the receiver for efficient storage on disk"	fullBounds _ nil. "Will be computed on the fly"	submorphs do:[:m| m compress].! !!FlashMorph methodsFor: 'disk i/o' stamp: 'ar 6/30/1999 12:23'!decompress	"Decompress the receiver"	submorphs do:[:m| m decompress].	self fullBounds. "Force computation"! !!FlashShapeMorph methodsFor: 'disk i/o' stamp: 'ar 6/30/1999 12:37'!compress	super compress.	shape compress.! !!FlashShapeMorph methodsFor: 'disk i/o' stamp: 'ar 6/30/1999 12:38'!decompress	shape decompress.	super decompress.! !