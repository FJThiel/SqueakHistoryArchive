'From Squeak 2.1 of June 30, 1998 on 4 July 1998 at 10:20:07 pm'!!Object class methodsFor: 'instance creation' stamp: 'tk 6/29/1998 12:11'!newUniqueClassInstVars: instVarString classInstVars: classInstVarString	"Create a unique class for the receiver"	| aName aClass |	self isSystemDefined ifFalse:		[^ superclass newUniqueClassInstVars: instVarString classInstVars: classInstVarString].	aName _ self chooseUniqueClassName.	aClass _ self subclass: aName instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	^ aClass! !!Player methodsFor: 'clone' stamp: 'tk 6/27/1998 07:43'!copyUniClass	"my class is a subclass of Player.  Return another class just like my class.  Share the costume list."	| newCls civ ii |	newCls _ self class officialClass 		newUniqueClassInstVars: self class instanceVariablesString 		classInstVars: self class class instanceVariablesString.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	civ _ self class class allInstVarNames.	ii _ civ indexOf: 'scripts'.	newCls instVarAt: ii put: self class scripts.	"later must duplicate this"	ii _ civ indexOf: 'slotInfo'.	newCls instVarAt: ii put: self class slotInfo deepCopy.	ii _ civ indexOf: 'costumeDictionary'.	newCls instVarAt: ii put: self class costumeDictionary copy.	newCls copyAddedStateFrom: self class.  "The player-ref jump table?"	^ newCls! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/27/1998 07:46'!veryDeepCopy: anObject	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream and storeDataOn:"	| dummy refs class new uniClasses uc old |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"  		"Note that dummy is a ReferenceStream.  instVarInfo: will not be called."	dummy nextPut: anObject.	"Do the traverse of the tree"	uniClasses _ Dictionary new.	"UniClass -> new UniClass"	renamed _ Dictionary new.	refs _ dummy references.	"all the objects"	"For each object, make a simple copy, then replace all fields with new copy from dict"	refs keysDo: [:each | 		class _ each class.		class == Metaclass ifTrue: ["object is a metaclass" self error: 'can''t copy a class'].		class isMeta 			ifTrue: ["a class" self error: 'can''t copy a class']			ifFalse: ["an instance" class isSystemDefined 				ifFalse: [uc _ uniClasses at: class ifAbsent: [nil].					uc ifNil: [uniClasses at: class put: (uc _ each copyUniClass)]]]].	uniClasses do: [:uniCls | 		dummy nextPut: uniCls scripts].	"more objects to veryDeepCopy"	refs associationsDo: [:assoc | 		(uniClasses includesKey: assoc key class)			ifFalse: [(#(Form Color) includes: assoc key class name)				ifFalse: [assoc key class == DiskProxy					ifFalse: [assoc value: assoc key clone]					ifTrue: [assoc value: nil "assoc key comeFullyUpOnReload"]]						"a DiskProxy will never be looked up -- its not in any field.						Old value of field is used."				ifTrue: [assoc value: assoc key]]		"Don't copy Forms, Colors"			ifTrue: [old _ assoc key.				assoc value: (new _ (uc _ uniClasses at: assoc key class) new).				1 to: uc instSize do: [:ii | new instVarAt: ii put: (old instVarAt: ii)]]].		"Watch out for classes that do extra things in copy but not in shallowCopy"	self veryDeepRectify: refs.	"rehashes Sets and Dictionaries"	self veryDeepClassVars: refs.		"ScannedObject _ refs."	"debug"	^ refs at: anObject! !!StrikeFont class methodsFor: 'instance creation' stamp: 'tk 7/2/1998 16:44'!familyName: aName size: aSize	| aStyle both ind |	(aStyle _ TextStyle named: aName asSymbol) ifNil: [		both _ aName splitInteger.		(both at: 2) > 0 			ifTrue: ["old style"				ind _ #('ComicB' 'Comic' 'ComicAll') indexOf: (both at: 1).				ind = 0 ifTrue: [^ self familyName: (both at: 1) size: aSize].				aStyle _ TextConstants at: (#(ComicBold ComicPlain ComicPlain) at: ind)]			ifFalse: [aStyle _ TextStyle default]].	"Substitute. Read-only so OK not to copy"	^ aStyle fontOfSize: aSize! !!String methodsFor: 'converting' stamp: 'tk 7/2/1998 16:32'!splitInteger	"Answer an array that is a splitting of self into a string and an integer.  '43Sam' yields #(43 'Sam').  'Try90' yields #('Try' 90) "	| pos |	(pos _ self findFirst: [:d | d isDigit not]) == 0 ifTrue: [^ Array with: '' with: self asNumber].	self first isDigit ifTrue: [		^ Array with: (self copyFrom: 1 to: pos - 1) asNumber 			with: (self copyFrom: pos to: self size)].	(pos _ self findFirst: [:d | d isDigit]) == 0 ifTrue: [^ Array with: self with: 0].	^ Array with: (self copyFrom: 1 to: pos - 1)			with: (self copyFrom: pos to: self size) asNumber! !!TextMorph methodsFor: 'anchors' stamp: 'tk 6/30/1998 17:06'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto me."	self addMorphFront: aMorph fromWorldPosition: aMorph position.		"Make a TextAnchor and install it in a run."! !