'From Squeak 2.2 of Sept 23, 1998 on 8 October 1998 at 11:20:15 am'!"Change Set:		Finalization-RoundThreeDate:			7 October 1998Author:			Andreas RaabRound three adds weak collections to the systeme.g., WeakArray, WeakKeyDictionary,WeakValueDictionary, and WeakRegistry."SystemOrganization addCategory: 'Collections-Weak' before: 'Collections-Support' asSymbol.!Array weakSubclass: #WeakArray	instanceVariableNames: ''	classVariableNames: 'FinalizationDependents FinalizationLock FinalizationProcess FinalizationSemaphore IsFinalizationSupported '	poolDictionaries: ''	category: 'Collections-Weak'!Association subclass: #WeakKeyAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!Dictionary subclass: #WeakKeyDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!Collection subclass: #WeakRegistry	instanceVariableNames: 'valueDictionary accessLock '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!Association subclass: #WeakValueAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!Dictionary subclass: #WeakValueDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:26'!actAsExecutor	"Prepare the receiver to act as executor for any resources associated with it"	self breakDependents! !!Object methodsFor: 'finalization' stamp: 'ar 3/20/98 22:19'!executor	"Return an object which can act as executor for finalization of the receiver"	^self shallowCopy actAsExecutor! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:27'!finalize	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority."! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 18:38'!retryWithGC: execBlock until: testBlock	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."	| blockValue |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/8/1998 11:16'!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	self wait.	hasError _ false.	blockValue _ [mutuallyExcludedBlock value] ifError:[:msg :rcvr|		hasError _ true.		errMsg _ msg.		errRcvr _ rcvr].	hasError ifTrue:[		self signal.		^errorBlock value: errMsg value: errRcvr].	self signal.	^blockValue! !!WeakArray commentStamp: 'ar 10/7/1998 16:48' prior: 0!WeakArray is an array which holds only weakly on its elements. This means whenever an object is only referenced by instances of WeakArray it will be garbage collected.!!WeakArray class methodsFor: 'class initialization' stamp: 'ar 10/7/1998 16:45'!initialize	"WeakArray initialize"	"Do we need to initialize specialObjectsArray?"	Smalltalk specialObjectsArray size < 42 		ifTrue:[Smalltalk recreateSpecialObjectsArray].	"Check if Finalization is supported by this VM"	IsFinalizationSupported _ nil.	self isFinalizationSupported ifFalse:[^self].	FinalizationProcess notNil ifTrue:[FinalizationProcess terminate].	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.	FinalizationDependents isNil ifTrue:[		FinalizationDependents := WeakArray new: 10.	].	FinalizationLock := Semaphore forMutualExclusion.	FinalizationProcess := [self finalizationProcess] newProcess.	FinalizationProcess priority: Processor userInterruptPriority.	FinalizationProcess resume.! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/8/1998 11:17'!addWeakDependent: anObject	| finished index weakDependent |	self isFinalizationSupported ifFalse:[^self].	FinalizationLock critical:[		finished := false.		index := 0.		[index := index + 1.		finished not and:[index <= FinalizationDependents size]] whileTrue:[			weakDependent := FinalizationDependents at: index.			weakDependent isNil ifTrue:[				FinalizationDependents at: index put: anObject.				finished := true.			].		].		finished ifFalse:[			"Grow linearly"			FinalizationDependents := FinalizationDependents, (WeakArray new: 10).			FinalizationDependents at: index put: anObject.		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/7/1998 15:30'!isFinalizationSupported	"Check if this VM supports the finalization mechanism"	| tempObject |	IsFinalizationSupported ifNotNil:[^IsFinalizationSupported].	tempObject _ WeakArray new: 1.	"Check if the class format 4 is correctly understood by the VM.	If the weak class support is not installed then the VM will report	any weak class as containing 32bit words - not pointers"	(tempObject at: 1) = nil 		ifFalse:[^IsFinalizationSupported _false].	"Check if objects are correctly freed"	self pvtCreateTemporaryObjectIn: tempObject.	Smalltalk garbageCollect.	^IsFinalizationSupported _ (tempObject at: 1) == nil! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/8/1998 11:17'!removeWeakDependent: anObject	self isFinalizationSupported ifFalse:[^self].	FinalizationLock critical:[		1 to: FinalizationDependents size do:[:i|			((FinalizationDependents at: i) == anObject) ifTrue:[				FinalizationDependents at: i put: nil.			].		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'private' stamp: 'ar 10/8/1998 11:19'!finalizationProcess	[true] whileTrue:[		FinalizationSemaphore wait.		FinalizationLock critical:[			FinalizationDependents do:[:weakDependent|				weakDependent isNil 					ifFalse:[weakDependent finalizeValues].			].		] ifError:[:msg :rcvr| rcvr error: msg].	].! !!WeakArray class methodsFor: 'private' stamp: 'ar 10/7/1998 15:24'!pvtCreateTemporaryObjectIn: tempObject	"We have to create the temporary object in a separate stack frame"	tempObject at: 1 put: Object new! !!WeakKeyAssociation commentStamp: '<historical>' prior: 0!I am an association holding only weakly on my key.!!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:45'!< aLookupKey 	"Refer to the comment in Magnitude|<."	^self key < aLookupKey key! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!= aLookupKey	self species = aLookupKey species		ifTrue: [^self key = aLookupKey key]		ifFalse: [^false]! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!hash	"Hash is reimplemented because = is implemented."	^self key hash! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^self key hashMappedBy: map! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:47'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^ self key identityHashMappedBy: map! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!storeOn: aStream	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll:' key: '.	self key storeOn: aStream.	aStream nextPutAll: ' value: '.	self value storeOn: aStream.	aStream nextPut: $)! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:54'!key	^key isNil		ifTrue:[nil]		ifFalse:[key at: 1]! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:45'!key: aKey	key := WeakArray with: aKey! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:44'!key: aKey value: anObject	key := WeakArray with: key.	value := anObject.! !!WeakKeyDictionary commentStamp: '<historical>' prior: 0!I am a dictionary holding only weakly on my keys. This is a bit dangerous since at any time my keys can go away. Clients are responsible to register my instances by WeakArray such that the appropriate actions can be taken upon loss of any keys.See WeakRegistry for an example of use.!!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ar 3/21/98 16:15'!finalizeValues	"default action is to re-hash the receiver and to remove nil-keys"	self rehash.	self removeKey: nil ifAbsent:[].! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:02'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	key isNil ifTrue:[^anObject].	index _ self findElementOrNil: key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakKeyAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 3/22/98 00:21'!rehash	"Overriden to copy the size also - we may have lost any number of elements"	| newSelf |	newSelf := self species new: self size.	self associationsDo:[:each| newSelf noCheckAdd: each].	array := newSelf array.	tally := newSelf size.! !!WeakKeyDictionary methodsFor: 'adding' stamp: 'ar 3/21/98 16:00'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!WeakRegistry commentStamp: '<historical>' prior: 0!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!!WeakRegistry methodsFor: 'finalization' stamp: 'ar 3/22/98 00:19'!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."	| finiObjects |	finiObjects := nil.	"First collect the objects."	self protected:[		valueDictionary associationsDo:[:assoc|			assoc key isNil ifTrue:[				finiObjects isNil 					ifTrue:[finiObjects := OrderedCollection with: assoc value]					ifFalse:[finiObjects add: assoc value]]		].		finiObjects isNil ifFalse:[valueDictionary finalizeValues].	].	"Then do the finalization"	finiObjects isNil ifTrue:[^self].	finiObjects do:[:each| each finalize].! !!WeakRegistry methodsFor: 'adding' stamp: 'ar 3/21/98 16:33'!add: anObject	"Add anObject to the receiver. Store the object as well as the associated executor."	| executor |	executor := anObject executor.	self protected:[		valueDictionary at: anObject put: executor.	].	^anObject! !!WeakRegistry methodsFor: 'accessing' stamp: 'ar 3/21/98 16:33'!size	^self protected:[		valueDictionary size	].! !!WeakRegistry methodsFor: 'accessing' stamp: 'ar 3/20/98 19:31'!species	^Set! !!WeakRegistry methodsFor: 'initialize' stamp: 'ar 3/21/98 16:08'!initialize: n	valueDictionary := WeakKeyDictionary new: n.	accessLock := Semaphore forMutualExclusion.! !!WeakRegistry methodsFor: 'private' stamp: 'ar 10/8/1998 11:18'!protected: aBlock	"Execute aBlock protected by the accessLock"	^accessLock isNil		ifTrue:[aBlock value]		ifFalse:[accessLock critical: aBlock ifError:[:msg :rcvr| rcvr error: msg]]! !!WeakRegistry methodsFor: 'enumerating' stamp: 'ar 3/21/98 18:36'!do: aBlock	^self protected:[		valueDictionary keysDo: aBlock.	].! !!WeakRegistry methodsFor: 'removing' stamp: 'ar 3/21/98 21:12'!remove: oldObject ifAbsent: exceptionBlock	"Remove oldObject as one of the receiver's elements."	| removedObject |	oldObject isNil ifTrue:[^oldObject].	self protected:[		removedObject := valueDictionary removeKey: oldObject ifAbsent:[nil].	].	^removedObject isNil		ifTrue:[exceptionBlock value]		ifFalse:[removedObject].! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:32'!new	^self new: 5! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:33'!new: n	| registry |	registry := super new initialize: n.	WeakArray addWeakDependent: registry.	^registry! !!WeakValueAssociation commentStamp: '<historical>' prior: 0!I am an association holding only weakly on my value.!!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:53'!key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	key _ aKey.	value _ WeakArray with: anObject! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:55'!value	^value isNil		ifTrue:[nil]		ifFalse:[value at: 1]! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:54'!value: anObject 	"Store the argument, anObject, as the value of the receiver."	value _ WeakArray with: anObject! !!WeakValueAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:54'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !!WeakValueAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:54'!storeOn: aStream	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll:' key: '.	self key storeOn: aStream.	aStream nextPutAll: ' value: '.	self value storeOn: aStream.	aStream nextPut: $)! !!WeakValueDictionary commentStamp: '<historical>' prior: 0!I am a dictionary holding only weakly on my values. Clients may expect to get a nil value for any object they request.!!WeakValueDictionary methodsFor: 'adding' stamp: 'ar 3/21/98 16:02'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!WeakValueDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:01'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	index _ self findElementOrNil: key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakValueAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !WeakArray class removeSelector: #pvtCreateTemporaryObject!WeakArray initialize!