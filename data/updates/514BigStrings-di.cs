'From Squeak 2.3 beta of Nov 25, 1998 on 28 December 1998 at 3:35:49 pm'!"Change Set:		BigStrings-diDate:			27 December 1998Author:			Dan IngallsAn attempt to support the creation (new:) and use (size, at: at:put:) of strings and arrays whose size is 31 or possibly even 32 bits in size.  None of this has yet been tested except that it still works with indices in the smallInteger range."!!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/27/1998 19:36'!allocateChunk: byteSize 	"Allocate a chunk of the given size. Sender must be sure that the requested size includes enough space for the header word(s)."	"Details: To limit the time per incremental GC, do one every so many allocations."	| enoughSpace newFreeSize newChunk |	self inline: true.	allocationCount >= allocationsBetweenGCs ifTrue: [		"do an incremental GC every so many allocations to keep pauses short"		self incrementalGC.	].	enoughSpace _ self sufficientSpaceToAllocate: byteSize.	enoughSpace ifFalse: [		"signal that space is running low, put proceed with allocation if possible"		signalLowSpace _ true.		lowSpaceThreshold _ 0.  "disable additional interrupts until lowSpaceThreshold is reset by image"		interruptCheckCounter _ 0.	].	(self cCoerce: (self sizeOfFree: freeBlock) to: 'unsigned ')		< (self cCoerce: (byteSize + BaseHeaderSize) to: 'unsigned ') ifTrue: [		self error: 'out of memory'.	].	"if we get here, there is enough space for allocation to succeed"	newFreeSize _ (self sizeOfFree: freeBlock) - byteSize.	newChunk _ freeBlock.	freeBlock _ freeBlock + byteSize.	"Assume: client will initialize object header of free chunk, so following is not needed:"	"self setSizeOfFree: newChunk to: byteSize."	self setSizeOfFree: freeBlock to: newFreeSize.	allocationCount _ allocationCount + 1.	^ newChunk! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/27/1998 16:35'!sufficientSpaceAfterGC: minFree	"Return true if there is enough free space after doing a garbage collection. If not, signal that space is low."	self inline: false.	self incrementalGC.  "try to recover some space"	(self cCoerce: (self sizeOfFree: freeBlock) to: 'unsigned ')		< (self cCoerce: minFree to: 'unsigned ')		ifTrue:		[signalLowSpace ifTrue: [ ^ false ].  "give up; problem is already noted"		self fullGC.  "try harder"		"for stability, require more free space after doing an expensive full GC"		(self cCoerce: (self sizeOfFree: freeBlock) to: 'unsigned ')			< ((self cCoerce: minFree to: 'unsigned ') + 15000)			ifTrue: [ ^ false ].  "still not enough"	].	^ true! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/27/1998 19:30'!sufficientSpaceToAllocate: bytes	"Return true if there is enough space to allocate the given number of bytes, perhaps after doing a garbage collection."	| minFree |	self inline: true.	minFree _ lowSpaceThreshold + bytes + BaseHeaderSize.	"check for low-space"	(self cCoerce: (self sizeOfFree: freeBlock) to: 'unsigned ')		>= (self cCoerce: minFree to: 'unsigned ')		ifTrue: [^ true]		ifFalse: [^ self sufficientSpaceAfterGC: minFree].! !!Interpreter commentStamp: '<historical>' prior: 0!This class is a complete implementation of the Smalltalk-80 virtual machine, derived originally from the Blue Book specification.It has been modernized with 32-bit pointers, better management of Contexts, and attention to variable use that allows the CCodeGenerator (qv) to keep, eg, the instruction pointer and stack pointer in registers.In addition to SmallInteger arithmetic and Floats, it supports logic on 32-bit PositiveLargeIntegers, thus allowing it to simulate itself much more effectively than would otherwise be the case.NOTE:  Here follows a list of things to be borne in mind when working on this code, or when making changes for the future.1.  There are a number of things that should be done the next time we plan to release a copletely incompatible image format.  These include unifying the instanceSize field of the class format word -- see instantiateClass:indexableSize:, and unifying the bits of the method primitive index (if we decide we need more than 512, after all) -- see primitiveIndexOf:.  Also, contexts should be given a special format code (see next item).2.  There are several fast checks for contexts (see isContextHeader: and isMethodContextHeader:) which will fail if the compact class indices of BlockContext or MethodContext change.  This is necessary because the oops may change during a compaction when the oops are being adjusted.  It's important to be aware of this when writing a new image using the systemTracer.  A better solution would be to reserve one of the format codes for Contexts only.3.  We have made normal files tolerant to size and positions up to 32 bits.  This has not been done for async files, since they are still experimental.  The code in size, at: and at:put: should work with sizes and indices up to 31 bits, although I have not tested it (di 12/98); it might or might not work with 32-bit sizes.4.  Note that 0 is used in a couple of places as an impossible oop.  This should be changed to a constant that really is impossible (or perhaps there is code somewhere that guarantees it --if so it should be put in this comment).  The places include the method cache and the at cache. !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 17:04'!commonAt: stringy	"This code is called if the receiver responds primitively to at:.	If this is so, it will be installed in the atCache so that subsequent calls of at:	or next may be handled immediately in bytecode primitive routines."	| index rcvr atIx result |	index _ self positive32BitValueOf: (self stackValue: 0).  "Sets successFlag"	rcvr _ self stackValue: 1.	successFlag & (self isIntegerObject: rcvr) not		ifFalse: [^ self primitiveFail].	"NOTE:  The at-cache, since it is specific to the non-super response to #at:.	Therefore we must determine that the message is #at: (not, eg, #basicAt:),	and that the send is not a super-send, before using the at-cache."	(messageSelector = (self specialSelector: 16)		and: [lkupClass = (self fetchClassOfNonInt: rcvr)])		ifTrue:		["OK -- look in the at-cache"		atIx _ rcvr bitAnd: AtCacheMask.  "Index into atCache = 4N, for N = 0 ... 7"		(atCache at: atIx+AtCacheOop) = rcvr ifFalse:			["Rcvr not in cache.  Install it..."			self install: rcvr inAtCache: atCache at: atIx string: stringy].		successFlag ifTrue:			[result _ self commonVariable: rcvr at: index cacheIndex: atIx].		successFlag ifTrue:			[^ self pop: 2 thenPush: result]].	"The slow but sure way..."	successFlag _ true.	result _ self stObject: rcvr at: index.	successFlag ifTrue:		[stringy ifTrue: [result _ self characterForAscii: (self integerValueOf: result)].		^ self pop: 2 thenPush: result]! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 17:06'!commonAtPut: stringy	"This code is called if the receiver responds primitively to at:Put:.	If this is so, it will be installed in the atPutCache so that subsequent calls of at:	or  next may be handled immediately in bytecode primitive routines."	| value index rcvr atIx |	value _ self stackValue: 0.	index _ self positive32BitValueOf: (self stackValue: 1).  "Sets successFlag"	rcvr _ self stackValue: 2.	successFlag & (self isIntegerObject: rcvr) not		ifFalse: [^ self primitiveFail].	"NOTE:  The atPut-cache, since it is specific to the non-super response to #at:Put:.	Therefore we must determine that the message is #at:Put: (not, eg, #basicAt:Put:),	and that the send is not a super-send, before using the at-cache."	(messageSelector = (self specialSelector: 17)		and: [lkupClass = (self fetchClassOfNonInt: rcvr)])		ifTrue:		["OK -- look in the at-cache"		atIx _ (rcvr bitAnd: AtCacheMask) + AtPutBase.  "Index into atPutCache"		(atCache at: atIx+AtCacheOop) = rcvr ifFalse:			["Rcvr not in cache.  Install it..."			self install: rcvr inAtCache: atCache at: atIx string: stringy].		successFlag ifTrue:			[self commonVariable: rcvr at: index put: value cacheIndex: atIx].		successFlag ifTrue:			[^ self pop: 3 thenPush: value]].	"The slow but sure way..."	successFlag _ true.	stringy ifTrue: [self stObject: rcvr at: index put: (self asciiOfCharacter: value)]			ifFalse: [self stObject: rcvr at: index put: value].	successFlag ifTrue: [^ self pop: 3 thenPush: value].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 19:46'!commonVariable: rcvr at: index cacheIndex: atIx 	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields result |	stSize _ atCache at: atIx+AtCacheSize.	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])	ifTrue:		[fmt _ atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields _ atCache at: atIx+AtCacheFixedFields.			^ self fetchPointer: index + fixedFields - 1 ofObject: rcvr].		fmt < 8 ifTrue:  "Bitmap"			[result _ self fetchWord: index - 1 ofObject: rcvr.			result _ self positive32BitIntegerFor: result.			^ result].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: "String"			[^ self characterForAscii: (self fetchByte: index - 1 ofObject: rcvr)]			ifFalse: "ByteArray"			[^ self integerObjectOf: (self fetchByte: index - 1 ofObject: rcvr)]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 19:46'!commonVariable: rcvr at: index put: value cacheIndex: atIx	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields valToPut |	self inline: true.	stSize _ atCache at: atIx+AtCacheSize.	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])	ifTrue:		[fmt _ atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields _ atCache at: atIx+AtCacheFixedFields.			^ self storePointer: index + fixedFields - 1 ofObject: rcvr withValue: value].		fmt < 8 ifTrue:  "Bitmap"			[valToPut _ self positive32BitValueOf: value.			successFlag ifTrue: [self storeWord: index - 1 ofObject: rcvr withValue: valToPut].			^ nil].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: [valToPut _ self asciiOfCharacter: value.					successFlag ifFalse: [^ nil]]			ifFalse: [valToPut _ value].		(self isIntegerObject: valToPut) ifTrue:			[^ self storeByte: index - 1 ofObject: rcvr						withValue: (self integerValueOf: valToPut)]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 19:46'!commonVariableInternal: rcvr at: index cacheIndex: atIx 	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields result |	self inline: true.	stSize _ atCache at: atIx+AtCacheSize.	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])	ifTrue:		[fmt _ atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields _ atCache at: atIx+AtCacheFixedFields.			^ self fetchPointer: index + fixedFields - 1 ofObject: rcvr].		fmt < 8 ifTrue:  "Bitmap"			[result _ self fetchWord: index - 1 ofObject: rcvr.			self externalizeIPandSP.			result _ self positive32BitIntegerFor: result.			self internalizeIPandSP.			^ result].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: "String"			[^ self characterForAscii: (self fetchByte: index - 1 ofObject: rcvr)]			ifFalse: "ByteArray"			[^ self integerObjectOf: (self fetchByte: index - 1 ofObject: rcvr)]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 19:49'!stObject: array at: index	"Return what ST would return for <obj> at: index."	| hdr fmt totalLength fixedFields stSize |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [stSize _ self quickFetchInteger: StackPointerIndex ofObject: array]		ifFalse: [stSize _ totalLength - fixedFields].	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])		ifTrue: [^ self subscript: array with: (index + fixedFields) format: fmt]		ifFalse: [successFlag _ false.  ^ 0].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 19:49'!stObject: array at: index put: value	"Do what ST would return for <obj> at: index put: value."	| hdr fmt totalLength fixedFields stSize |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [stSize _ self quickFetchInteger: StackPointerIndex ofObject: array]		ifFalse: [stSize _ totalLength - fixedFields].	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])		ifTrue: [self subscript: array with: (index + fixedFields) storing: value format: fmt]		ifFalse: [successFlag _ false]! !!Interpreter methodsFor: 'object access primitives' stamp: 'di 12/27/1998 17:01'!primitiveNewWithArg	"Allocate a new indexable instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."	| size class spaceOkay |	size _ self positive32BitValueOf: (self stackValue: 0).	class _ self stackValue: 1.	self success: size >= 0.	successFlag ifTrue: [		spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: size.		self success: spaceOkay.	].	successFlag		ifTrue: [ self pop: 2 thenPush: (self instantiateClass: class indexableSize: size) ]! !!Interpreter methodsFor: 'object access primitives' stamp: 'di 12/27/1998 16:28'!sufficientSpaceToInstantiate: classOop indexableSize: size	"Return the number of bytes required to allocate an instance of the given class with the given number of indexable fields."	"Details: For speed, over-estimate space needed for fixed fields or literals; the low space threshold is a blurry line."	| format okay |	self inline: true.	format _ ((self formatOfClass: classOop) >> 8) bitAnd: 16rF.	"fail if attempting to call new: on non-indexable class"	((self cCoerce: size to: 'unsigned ') > 0 and: [format < 2]) ifTrue: [ ^ false ].	format < 8 ifTrue: [		"indexable fields are words or pointers"		okay _ self sufficientSpaceToAllocate: (2500 + (size * 4)).	] ifFalse: [		"indexable fields are bytes"		okay _ self sufficientSpaceToAllocate: (2500 + size).	].	^ okay! !Interpreter removeSelector: #splObject:at:!Interpreter removeSelector: #splObject:at:put:!