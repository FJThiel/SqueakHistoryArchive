'From Squeak 2.2 of Sept 23, 1998 on 24 November 1998 at 3:32:58 pm'!FormCanvas subclass: #BalloonCanvas	instanceVariableNames: 'transform colorTransform transformStack engine aaLevel '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Engine'!Object subclass: #BalloonEngine	instanceVariableNames: 'workBuffer span bitBlt clipRect destOffset externals aaLevel colorTransform '	classVariableNames: 'BezierStats BufferCache CacheProtect Counts Debug Times '	poolDictionaries: 'BalloonEngineConstants '	category: 'Balloon-Engine'!JPEGReadWriter subclass: #FlashJPEGDecoder	instanceVariableNames: 'eoiSeen streaming '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!FlashFileReader subclass: #FlashMorphReader	instanceVariableNames: 'location fillStyles lineStyles shapes fonts forms sounds buttons lineSequence currentShape player spriteOwners stepTime frameRate frame activeMorphs passiveMorphs activeFont textOffset textHeight textMorph canCompressPoints pointList compressionBounds fillIndex0 fillIndex1 lineStyleIndex leftFillList rightFillList lineStyleList streamingSound '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!Object subclass: #FlashStreamingSound	instanceVariableNames: 'mixFmt stereo samplingRate bitsPerSample sampleCount compressed firstFrame frameNumber buffers '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!MatrixTransformMorph subclass: #FlashMorph	instanceVariableNames: 'colorTransform '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashCharacterMorph	instanceVariableNames: 'id stepTime frame renderTime vData mData dData cmData '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashCharacterMorph subclass: #FlashButtonMorph	instanceVariableNames: 'events sounds '	classVariableNames: 'ActionHelpText '	poolDictionaries: ''	category: 'MM-Flash-Morphs'!SystemWindow subclass: #FlashPlayerWindow	instanceVariableNames: 'startButton stopButton progress '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!BorderedMorph subclass: #FlashProgressMorph	instanceVariableNames: 'value progressColor lastValue '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashSpriteMorph	instanceVariableNames: 'playing maxFrames loadedFrames frameNumber stepTime damageRecorder sounds actions labels '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashSpriteMorph subclass: #FlashPlayerMorph	instanceVariableNames: 'activationKeys activeMorphs localBounds sourceUrl progressValue '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!!BalloonCanvas methodsFor: 'initialize' stamp: 'ar 11/24/1998 15:28'!flush	"Force all pending primitives onscreen"	engine ifNotNil:[engine flush].! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 11/24/1998 15:05'!ensuredEngine	^engine ifNil:[		engine _ BalloonEngine new.		engine aaLevel: aaLevel.		engine bitBlt: port.		engine destOffset: origin.		engine clipRect: clipRect.		engine colorTransform: colorTransform.		engine].! !!BalloonCanvas methodsFor: 'copying' stamp: 'ar 11/24/1998 15:28'!copy	self flush.	^super copy resetEngine! !!BalloonCanvas methodsFor: 'copying' stamp: 'ar 11/24/1998 14:47'!copyAALevel: newAALevel	(newAALevel = self aaLevel) ifTrue:[^self].	^self copy aaLevel: newAALevel! !!BalloonCanvas methodsFor: 'copying' stamp: 'ar 11/24/1998 14:49'!copyColorTransform: aColorTransform	^self copy colorTransformBy: aColorTransform! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/24/1998 15:16'!drawCompressedShape: compressedShape	"Draw a compressed shape"	self ensuredEngine		drawCompressedShape: compressedShape		transform: transform.! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/24/1998 14:45'!colorTransformBy: aColorTransform	aColorTransform ifNil:[^self].	colorTransform 		ifNil:[colorTransform _ aColorTransform]		ifNotNil:[colorTransform _ colorTransform composedWithLocal: aColorTransform]! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/24/1998 14:45'!colorTransformBy: aColorTransform while: aBlock	"Incorporate the local transformation in the receiver while evaluating aBlock"	| result |	aColorTransform ifNil:[^aBlock value: self].	transformStack addLast: colorTransform.	self colorTransformBy: aColorTransform.	result _ aBlock value: self.	colorTransform _ transformStack removeLast.	^result! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/24/1998 15:27'!flush	"Force all pending primitives onscreen"! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/24/1998 15:22'!reset	workBuffer ifNil:[workBuffer _ self class allocateOrRecycleBuffer: 10000].	self primInitializeBuffer: workBuffer.	self primSetAALevel: self aaLevel.	self primSetOffset: destOffset.	self primSetClipRect: clipRect.	self primSetColorTransform: colorTransform.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/24/1998 15:23'!registerFill: aFillStyle transform: aTransform	aFillStyle ifNil:[^0].	aFillStyle isSolidFill 		ifTrue:[^aFillStyle pixelValue32].	aFillStyle isGradientFill ifTrue:[		^self doAddGradientFill: aFillStyle pixelRamp			from: aFillStyle origin			along: aFillStyle direction			normal: aFillStyle normal			radial: aFillStyle isRadialFill			matrix: aTransform.		].	^0! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/24/1998 15:04'!colorTransform	^colorTransform! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/24/1998 15:04'!colorTransform: aColorTransform	colorTransform _ aColorTransform! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 15:23'!primSetColorTransform: cTransform	<primitive: 'gePrimitiveSetColorTransform'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetColorTransform'].	^nil "If not supported"! !!Cursor class methodsFor: 'constants' stamp: 'ar 11/18/1998 15:33'!webLink	"Return a cursor that can be used for emphasizing web links"	"Cursor webLink showWhile: [Sensor waitButton]"	^ (CursorWithMask extent: 16@16			fromArray: #(3072 4608 4608 4608 4608 5046 4681 29257 37449 37449 32769 32769 49155 16386 24582 16380 )			offset: -5@0) setMaskForm:		(Form extent: 16@16 			fromArray: (#(3072 7680 7680 7680 7680 8118 8191 32767 65535 65535 65535 65535 65535 32766 32766 16380 )  collect: [:bits | bits bitShift: 16])			offset: 0@0).! !!FlashButtonMorph class methodsFor: 'class initialization' stamp: 'ar 11/20/1998 22:58'!initialize	"FlashButtonMorph initialize"	ActionHelpText _ Dictionary new.	#(	(getURL:window: 'Jump to URL')		(gotoFrame: 'Continue playing')		(gotoLabel: 'Continue playing')		(gotoNextFrame 'Continue playing')		(gotoPrevFrame 'Continue playing')		(actionPlay 'Continue playing')		(actionStop 'Stop playing')		(stopSounds 'Stop all sounds')		(toggleQuality 'Toggle display quality')	) do:[:spec| ActionHelpText at: spec first put: spec last].! !!FlashColorTransform methodsFor: 'initialize' stamp: 'ar 11/24/1998 15:01'!initialize	rMul _ bMul _ gMul _ aMul _ 1.0.	rAdd _ bAdd _ gAdd _ aAdd _ 0.0.! !!FlashColorTransform methodsFor: 'composing' stamp: 'ar 11/24/1998 14:54'!composedWithGlobal: aColorTransform	^aColorTransform composedWithLocal: self.! !!FlashColorTransform methodsFor: 'composing' stamp: 'ar 11/24/1998 14:57'!composedWithLocal: aColorTransform	| cm |	cm _ self clone.	cm rAdd: self rAdd + (aColorTransform rAdd * self rMul).	cm rMul: self rMul * aColorTransform rMul.	cm gAdd: self gAdd + (aColorTransform gAdd * self gMul).	cm gMul: self gMul * aColorTransform gMul.	cm bAdd: self bAdd + (aColorTransform bAdd * self bMul).	cm bMul: self bMul * aColorTransform bMul.	cm aAdd: self aAdd + (aColorTransform aAdd * self aMul).	cm aMul: self aMul * aColorTransform aMul.	^cm! !!FlashColorTransform methodsFor: 'composing' stamp: 'ar 11/24/1998 15:06'!localColorToGlobal: aColor	^Color		r: (aColor red * self rMul + self rAdd)		g: (aColor green * self gMul + self gAdd)		b: (aColor blue * self bMul + self bAdd)		alpha: (aColor alpha * self aMul + self aAdd)! !!FlashColorTransform methodsFor: 'printing' stamp: 'ar 11/24/1998 14:40'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut:$(;		cr; nextPutAll:' r * '; print: rMul; nextPutAll:' + '; print: rAdd;		cr; nextPutAll:' g * '; print: gMul; nextPutAll:' + '; print: gAdd;		cr; nextPutAll:' b * '; print: bMul; nextPutAll:' + '; print: bAdd;		cr; nextPutAll:' a * '; print: aMul; nextPutAll:' + '; print: aAdd;		nextPut:$).! !!FlashFileReader methodsFor: 'property access' stamp: 'ar 11/18/1998 21:25'!isStreaming	"Subclasses may override this"	^false! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 11/18/1998 23:41'!processFile	"Read and process the entire file"	self processHeader ifFalse:[^nil].	self processFileContents.! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 11/19/1998 00:29'!processFileContents	"Process the contents of the flash file.	Assume that the header has been read before."	| time |	time _ Time millisecondsToRun:[	self isStreaming ifTrue:[		"Don't show progress for a streaming connection.		Note: Yielding is done someplace else."		[self processTagFrom: stream] whileTrue.	] ifFalse:[		'Reading file' displayProgressAt: Sensor cursorPoint			from: 1 to: 100			during:[:theBar|		[self processTagFrom: stream] whileTrue:[			theBar value: (stream position * 100 // stream size).			stream atEnd ifTrue:[				log ifNotNil:[					log cr; nextPutAll:'Unexpected end of data (no end tag)'.					self flushLog].				^self]].		].	].	(stream respondsTo: #close) ifTrue:[stream close].	].	Transcript cr; print: time / 1000.0; show:' secs to read file'! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 11/18/1998 21:59'!processHeader	"Read header information from the source stream.	Return true if successful, false otherwise."	| version twipsFrameSize frameRate frameCount |	self processSignature ifFalse:[^false].	version _ stream nextByte.	"Check for the version supported"	version > self maximumSupportedVersion ifTrue:[^false].	dataSize _ stream nextLong.	"Check for the minimal file size"	dataSize < 21 ifTrue:[^false].	twipsFrameSize _ stream nextRect.	self recordGlobalBounds: twipsFrameSize.	frameRate _ stream nextWord / 256.0.	self recordFrameRate: frameRate.	frameCount _ stream nextWord.	self recordFrameCount: frameCount.	log ifNotNil:[		log cr; nextPutAll:'------------- Header information --------------'.		log cr; nextPutAll:'File version		'; print: version.		log cr; nextPutAll:'File size			'; print: dataSize.		log cr; nextPutAll:'Movie width		'; print: twipsFrameSize extent x // 20.		log cr; nextPutAll:'Movie height	'; print: twipsFrameSize extent y // 20.		log cr; nextPutAll:'Frame rate		'; print: frameRate.		log cr; nextPutAll:'Frame count	'; print: frameCount.		log cr; cr.		self flushLog].	^true! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 11/20/1998 00:24'!processShapesFrom: data	"Process a new shape"	| id bounds |	"Read shape id and bounding box"	id _ data nextWord.	bounds _ data nextRect.	"Start new shape definition"	self recordShapeStart: id bounds: bounds.	"Read styles for this shape"	self processShapeStylesFrom: data.	"Get number of bits for fill and line styles"	data initBits.	nFillBits _ data nextBits: 4.	nLineBits _ data nextBits: 4.	"Process all records in this shape definition"	[self processShapeRecordFrom: data] whileTrue.	"And mark the end of this shape"	self recordShapeEnd: id.! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 11/20/1998 02:47'!processGlyphRecordFrom: data	| flags |	flags _ data nextByte.	flags = 0 ifTrue:[^false].	self flag: #wrongSpec.	"From news://forums.macromedia.com/macromedia.open-swfIt is an error in the spec. There can be up to 255 characters in run. Thehigh bit does not mean anything. The text record type 0 and type 1 is poorlydescribed. The real format is that all of the info in a 'text record type 1'is always followed by the info in a 'text record type 2'. Note the high bitof 'text record type 1' is reserved and should always be zero."	self processGlyphStateChange: flags from: data.	flags _ data nextByte.	flags = 0 ifTrue:[^false].	self processGlyphEntries: flags from: data.	"Old stuff - which is according to the f**cking spec"	"(flags anyMask: 128) ifTrue:[		self processGlyphStateChange: flags from: data.	] ifFalse:[		self processGlyphEntries: flags from: data.	]."	^true! !!FlashFileReader methodsFor: 'processing buttons' stamp: 'ar 11/24/1998 14:22'!processButtonRecords: id from: data cxForm: haveCxForm	| flags state characterId layer matrix cxForm |	[flags _ data nextByte.	flags = 0] whileFalse:[		state _ flags bitAnd: 15.		characterId _ data nextWord.		layer _ data nextWord.		matrix _ data nextMatrix.		haveCxForm ifTrue:[cxForm _ data nextColorMatrix].		self recordButton: id 			character: characterId 			state: state 			layer: layer 			matrix: matrix			colorTransform: cxForm].! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/24/1998 15:32'!processActionGetURL: data	| length position urlString winString |	length _ data nextWord.	position _ data position.	urlString _ data nextString.	winString _ data nextString.	data position = (position + length) ifFalse:[		self halt.		data position: position.		^self processUnknownAction: data].	log ifNotNil:[		log 			nextPutAll:' url='; print: urlString;			nextPutAll:', win='; print: winString].	^Message selector: #getURL:window: arguments: (Array with: urlString with: winString)! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/24/1998 15:31'!processActionGotoLabel: data	| length label |	length _ data nextWord.	label _ data nextString.	log ifNotNil:[log nextPutAll:' label = '; print: label].	^Message selector: #gotoLabel: argument: label! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/19/1998 20:39'!processActionPlay: data	^Message selector: #actionPlay! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/19/1998 20:39'!processActionStop: data	^Message selector: #actionStop! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/21/1998 00:46'!createSoundBuffersOfSize: numSamples stereo: stereo	| channels buffers |	channels _ stereo ifTrue:[2] ifFalse:[1].	buffers _ Array new: channels.	1 to: channels do:[:i| 		buffers at: i put: 			(WriteStream on: ((SoundBuffer newMonoSampleCount: numSamples)))].	^buffers! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/21/1998 00:55'!createSoundFrom: soundStreams stereo: stereo samplingRate: samplingRate	| sound channels buffers |	buffers _ soundStreams collect:[:s| s contents].	channels _ stereo ifTrue:[2] ifFalse:[1].	1 to: channels do:[:i|		sound _ SampledSound samples:  (buffers at: i) samplingRate: samplingRate.		sound setLoudness: 1.0.		buffers at: i put: sound.	].	stereo ifTrue:[		^ MixedSound new			add: (buffers at: 1) pan: 0.0;			add: (buffers at: 2) pan: 1.0;			yourself.	] ifFalse:[		^buffers at: 1	].! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/21/1998 00:47'!decompressSound: aByteArray stereo: stereo samples: numSamples rate: samplingRate	| buffers |	buffers _ self createSoundBuffersOfSize: numSamples stereo: stereo.	self decompressSound: aByteArray 		stereo: stereo 		samples: numSamples 		rate: samplingRate 		into: buffers.	^self createSoundFrom: buffers stereo: stereo samplingRate: samplingRate! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/21/1998 00:41'!decompressSound: aByteArray stereo: stereo samples: numSamples rate: samplingRate into: buffers	| data nBits signMask indexTable channels valPred index vp idx delta step vpdiff allButSignMask k k0 |	data _ FlashFileStream on: (ReadStream on: aByteArray).	data initBits.	nBits _ (data nextBits: 2) + 2.	signMask _ 1 bitShift: nBits - 1.	allButSignMask _ signMask bitInvert32.	k0 _ 1 bitShift: (nBits - 2).	indexTable _ IndexTables at: nBits - 1.	channels _ stereo ifTrue:[2] ifFalse:[1].	valPred _ IntegerArray new: channels.	index _ IntegerArray new: channels.	1 to: numSamples do:[:nOut|		(nOut bitAnd: 16rFFF) = 1 ifTrue:["New block header starts every 4KB"			1 to: channels do:[:i|				vp _ data nextSignedBits: 16.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.				"First sample has no delta"				index at: i put: (data nextBits: 6).			].		] ifFalse:[ "Decode next sample"			1 to: channels do:[:i|				vp _ valPred at: i.				idx _ index at: i.				"Get next delta value"				delta _ data nextBits: nBits.				"Compute difference and new predicted value"				"Computes 'vpdiff = (delta+0.5)*step/4"				step _ StepTable at: idx + 1.				k _ k0.				vpdiff _ 0.				[	(delta bitAnd: k) = 0 ifFalse:[vpdiff _ vpdiff + step].					step _ step bitShift: -1.					k _ k bitShift: -1.					k = 0] whileFalse.				(delta anyMask: signMask) 					ifTrue:[vp _ vp - vpdiff]					ifFalse:[vp _ vp + vpdiff].				"Compute new index value"				idx _ idx + (indexTable at: (delta bitAnd: allButSignMask) + 1).				"Clamp index"				idx < 0 ifTrue:[idx _ 0].				idx > 88 ifTrue:[idx _ 88].				"Clamp output value"				vp < -32768 ifTrue:[vp _ -32768].				vp > 32767 ifTrue:[vp _ 32767].				"Store values back"				index at: i put: idx.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.			]		].	].! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/20/1998 22:37'!processSoundStreamHeadFrom: data	| mixFmt flags stereo bitsPerSample compressed sampleCount |	mixFmt _ data nextByte.	flags _ data nextByte.	stereo _ flags anyMask: 1.	self flag: #wrongSpec.	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	compressed _ (flags bitShift: -4) = 1.	sampleCount _ data nextWord.	self recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 21:32'!processDefineBitsJPEG2: data	| id image decoder |	id _ data nextWord.	decoder _ FlashJPEGDecoder new.	decoder isStreaming: self isStreaming.	decoder decodeJPEGTables: data.	image _ decoder decodeNextImageFrom: data.	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:11'!processDefineBitsJPEG3: data	"TODO: Read zlib compressed alpha."	| id image decoder alphaOffset dataOffset |	id _ data nextWord.	self flag: #wrongSpec.	alphaOffset _ data nextWord.	dataOffset _ data nextWord.	decoder _ FlashJPEGDecoder new.	decoder isStreaming: self isStreaming.	decoder decodeJPEGTables: data.	image _ decoder decodeNextImageFrom: data.	"Note: We must read the zlib compressed alpha values here."	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:12'!processDefineBitsLossless2: data	"TODO: Read zlib compressed data."	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:12'!processDefineBitsLossless: data	"TODO: Read zlib compressed data."	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:41'!processDefineButton2: data	| id flags actions condition actionOffset |	data hasAlpha: true.	id _ data nextWord.	self recordDefineButton: id.	flags _ data nextByte.	self recordButton: id trackAsMenu: flags = 0.	self flag: #wrongSpec.	actionOffset _ data nextWord.	self processButtonRecords: id from: data cxForm: true.	[actionOffset = 0] whileFalse:[		actionOffset _ data nextWord.		condition _ data nextWord.		actions _ self processActionRecordsFrom: data.		self recordButton: id actions: actions condition: condition].	data hasAlpha: false.	self recordEndButton: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:32'!processDefineButtonCxform: data	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/21/1998 13:56'!processDefineButtonSound: data	| id soundID soundInfo |	id _ data nextWord.	#(0 mouseEnter mouseDown 3) do:[:state|		soundID _ data nextWord.		soundID = 0 ifFalse:[			soundInfo _ self processSoundInfoFrom: data.			self recordButton: id sound: soundID info: soundInfo state: state]].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:31'!processDefineFont2: data	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:34'!processDefineFontInfo: data	| id nameLength fontName flags charMap |	id _ data nextWord.	nameLength _ data nextByte.	fontName _ (data nextBytes: nameLength) asString.	flags _ data nextByte.	charMap _ data upToEnd.	self recordFont: id name: fontName charMap: charMap wide: (flags anyMask: 1).	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 21:29'!processDefineSound: data	| flags sampleCount sampleData id stereo bitsPerSample rate compressed sound |	id _ data nextWord.	flags _ data nextByte.	stereo _ (flags anyMask: 1).	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	rate _ #( 5512 11025 22050 44100 ) at: (flags >> 2 bitAnd: 3)+1.	compressed _ flags anyMask: 16.	sampleCount _ data nextULong.	sampleData _ data upToEnd.	compressed ifTrue:[		self isStreaming ifFalse:[Cursor wait show].		sound _ self decompressSound: sampleData 						stereo: stereo 						samples: sampleCount 						rate: rate.		self isStreaming ifFalse:[Cursor normal show].	] ifFalse:[		self halt.		sound _ nil.	].	self recordSound: id data: sound.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:42'!processDefineSprite: data	| id frameCount |	id _ data nextWord.	self flag: #wrongSpec.	frameCount _ data nextWord.	self recordBeginSprite: id frames: frameCount.	[self processTagFrom: data] whileTrue.	self recordEndSprite: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 22:57'!processDoAction: data	| actions |	actions _ self processActionRecordsFrom: data.	self recordFrameActions: actions.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:31'!processFreeCharacter: data	| id |	id _ data nextWord.	data atEnd ifFalse:[self halt].	self recordFreeCharacter: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/18/1998 21:32'!processJPEGTables: data	jpegDecoder _ FlashJPEGDecoder new.	jpegDecoder isStreaming: self isStreaming.	jpegDecoder decodeJPEGTables: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/24/1998 15:32'!processNameCharacter: data	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:43'!processPlaceObject2: data	| id flags depth matrix cxForm ratio name move |	flags _ data nextByte.	depth _ data nextWord.	move _ (flags anyMask: 1).	(flags anyMask: 2) ifTrue:[id _ data nextWord].	(flags anyMask: 4) ifTrue:[matrix _ data nextMatrix].	(flags anyMask: 8) ifTrue:[cxForm _ data nextColorMatrix].	self flag: #checkThis.	(flags anyMask: 16) ifTrue:["self halt." ratio _ data nextWord].	(flags anyMask: 32) ifTrue:["self halt." name _ data nextString].	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' name = ', name printString,' depth = ', depth printString, ' move: ', move printString, ')'.		self flushLog].	move 		ifTrue:[self recordMoveObject: id depth: depth matrix: matrix colorMatrix: cxForm]		ifFalse:[self recordPlaceObject: id depth: depth matrix: matrix colorMatrix: cxForm].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 02:43'!processRemoveObject2: data	| depth |	depth _ data nextWord.	log ifNotNil:[		log nextPutAll:' (depth = ', depth printString, ')'.		self flushLog].	self recordRemoveObject: nil depth: depth.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:37'!processSoundStreamBlock: data	self recordSoundStreamBlock: data upToEnd.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:21'!processSoundStreamHead2: data	self processSoundStreamHeadFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/20/1998 22:22'!processSoundStreamHead: data	self processSoundStreamHeadFrom: data.	^true! !!FlashFileReader methodsFor: 'private' stamp: 'ar 11/20/1998 22:11'!dispatch: argument on: aKey in: aTable ifNone: exceptionBlock	| selector |	(aKey < 1 or:[aKey > aTable size]) ifTrue:[^exceptionBlock value].	selector _ aTable at: aKey.	^self perform: selector with: argument! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 22:35'!recordFont: id name: fontName charMap: charMap wide: isWide	"Record the name and character mapping of the font for the given id.	If isWide is set then the font is a 16bit Unicode font."! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 11/24/1998 14:23'!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix colorTransform: cxForm	"Define the character to use for a button.		buttonId:	global ID used for the button		characterId:	ID of the character defining the shape for the button		state:		bit mask for when to use the character						1 - default (e.g. no other state applies)						2 - display when the mouse is over the button but not pressed						4 - display when the button is pressed						8 - the area in which the mouse is supposed to be 'over' the button		layer:		UNKNOWN.		matrix:		Transformation to apply to the character. (Guess!!)"! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/18/1998 22:00'!recordFrameCount: maxFrames! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 11/20/1998 22:10'!initializeTagTable	"Create and return a new SWF tag table"	"FlashFileReader initializeTagTable"	TagTable _ Array new: 50.	TagTable atAllPut: #processUnknown:.	#(	(processEnd:					0)	(processShowFrame:			1)	(processDefineShape:		2)	(processFreeCharacter:		3)	(processPlaceObject:			4)	(processRemoveObject:		5)	(processDefineBits:			6)	(processDefineButton:		7)	(processJPEGTables:			8)	(processSetBackgroundColor:	9)	(processDefineFont:			10)	(processDefineText:			11)	(processDoAction:			12)	(processDefineFontInfo:		13)	"Event sound tags."	(processDefineSound:		14)	(processStartSound:			15)	(processDefineButtonSound:	17)	(processSoundStreamHead:	18)	(processSoundStreamBlock:	19)	(processDefineBitsLossless:	20)	"A bitmap using lossless zlib compression."	(processDefineBitsJPEG2:		21)	"A bitmap using an internal JPEG compression table"	(processDefineShape2:		22)	(processDefineButtonCxform:	23)	(processProtect:				24)	"This file should not be importable for editing."	"These are the new tags for Flash 3."	(processPlaceObject2:			26)	"The new style place w/ alpha color transform and name."	(processRemoveObject2:		28)	"A more compact remove object that omits the character tag (just depth)."	(processDefineShape3:		32)	"A shape V3 includes alpha values."	(processDefineText2:			33) "A text V2 includes alpha values."	(processDefineButton2:		34)	"A button V2 includes color transform) alpha and multiple actions"	(processDefineBitsJPEG3:		35)	"A JPEG bitmap with alpha info."	(processDefineBitsLossless2:	36)	"A lossless bitmap with alpha info."	(processDefineSprite:		39) "Define a sequence of tags that describe the behavior of a sprite."	(processNameCharacter:		40) "Name a character definition, character id and a string, (used for buttons) bitmaps, sprites and sounds)."	(processFrameLabel:			43) "A string label for the current frame."	(processSoundStreamHead2:	45) "For lossless streaming sound, should not have needed this..."	(processDefineMorphShape:	46) "A morph shape definition"	(processDefineFont2:			48)	) do:[:spec|			TagTable at: spec last+1 put: spec first.	].! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/24/1998 15:01'!nextColorMatrix	"Read a (possibly compressed) color transformation"	| transform nBits flags |	transform _ FlashColorTransform new.	self initBits.	flags _ self nextBits: 2.	nBits _ self nextBits: 4.	(flags anyMask: 1) ifTrue:["Read multiplication factors"		transform rMul: (self nextSignedBits: nBits) / 256.0.		transform gMul: (self nextSignedBits: nBits) / 256.0.		transform bMul: (self nextSignedBits: nBits) / 256.0.		hasAlpha ifTrue:[transform aMul: (self nextSignedBits: nBits) / 256.0]].	(flags anyMask: 2) ifTrue:["Read multiplication factors"		transform rAdd: (self nextSignedBits: nBits) / 256.0.		transform gAdd: (self nextSignedBits: nBits) / 256.0.		transform bAdd: (self nextSignedBits: nBits) / 256.0.		hasAlpha ifTrue:[transform aAdd: (self nextSignedBits: nBits) / 256.0]].	^transform! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/20/1998 00:29'!nextMatrix	"Read a (possibly compressed) transformation matrix"	| transform nBits |	transform _ MatrixTransform2x3 identity.	self initBits.	(self nextBits: 1) = 1 ifTrue:["Read a,d"		nBits _ self nextBits: 5.		transform a11: (self nextSignedBits: nBits) / 65536.0.		transform a22: (self nextSignedBits: nBits) / 65536.0].	(self nextBits: 1) = 1 ifTrue:["Read b,c"		nBits _ self nextBits: 5.		transform a21: (self nextSignedBits: nBits) / 65536.0.		transform a12: (self nextSignedBits: nBits) / 65536.0].	"Read tx, ty"	nBits _ self nextBits: 5.	"Transcript cr; show:'nBits = ', nBits printString, ' from ', thisContext sender printString."	transform a13: (self nextSignedBits: nBits) asFloat.	transform a23: (self nextSignedBits: nBits) asFloat.	^transform! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 11/18/1998 21:33'!decodeNextImageFrom: aStream	| image |	self setStream: aStream.	self isStreaming ifFalse:[Cursor wait show].	image _ self nextImage.	self isStreaming ifFalse:[Cursor normal show].	^image! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 11/18/1998 23:25'!nextImageDitheredToDepth: depth	"Overwritten to yield every now and then."	| form xStep yStep x y |	ditherMask _ DitherMasks		at: depth		ifAbsent: [self error: 'can only dither to display depths'].	redResidual _ greenResidual _ blueResidual _ 0.	sosSeen _ false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form _ Form extent: (width @ height) depth: 32.	xStep _ mcuWidth * DCTSize.	yStep _ mcuHeight * DCTSize.	y _ 0.	1 to: mcuRowsInScan do:		[:row |		"self isStreaming ifTrue:[Processor yield]."		x _ 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			mcuImageBuffer displayOn: form at: (x @ y).			x _ x + xStep].		y _ y + yStep].	^ form! !!FlashJPEGDecoder methodsFor: 'accessing' stamp: 'ar 11/18/1998 21:32'!isStreaming	^streaming! !!FlashJPEGDecoder methodsFor: 'accessing' stamp: 'ar 11/18/1998 21:31'!isStreaming: aBool	streaming _ aBool! !!FlashKeyframes methodsFor: 'private' stamp: 'ar 11/18/1998 23:29'!replaceLastData: newData at: frameNumber	| kf |	lastIndex _ nil.	kf _ kfList last.	(kf stop = kf start)		ifTrue:[kfList removeLast]		ifFalse:[kf stop: kf stop-1].	^self at: frameNumber put: newData! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 11/21/1998 00:30'!on: aStream	super on: aStream.	self doLog ifTrue:[log _ Transcript].	fillStyles _ Dictionary new.	lineStyles _ Dictionary new.	shapes _ Dictionary new.	player _ FlashPlayerMorph new.	fonts _ Dictionary new.	forms _ Dictionary new.	sounds _ Dictionary new.	buttons _ Dictionary new.	spriteOwners _ IdentityDictionary new.	stepTime _ 1000.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.	self recordSolidFill: 1 color: Color black.	compressionBounds _ (-16r7FFF asPoint) corner: (16r8000) asPoint.	currentShape _ WriteStream on: (Array new: 5).	pointList _ WriteStream on: (Array new: 100).	leftFillList _ WriteStream on: (WordArray new: 100).	rightFillList _ WriteStream on: (WordArray new: 100).	lineStyleList _ WriteStream on: (WordArray new: 100).	fillIndex0 _ fillIndex1 _ lineStyleIndex _ 0.	streamingSound _ FlashStreamingSound new.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/19/1998 20:45'!processFile	"Read and process the entire file"	super processFile.	player loadInitialFrame.	player startPlaying.	player open.	^player! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/19/1998 21:54'!processFileAsync	"Read and process the entire file"	self processHeader ifFalse:[^nil].	player sourceUrl:'dummy'.	[self processFileContents] fork.	^player! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/18/1998 23:44'!processFileAsync: aPlayer	"Read and process the entire file"	player _ aPlayer.	super processFile.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/21/1998 00:50'!processFileContents	super processFileContents.	self flushStreamingSound.! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 01:41'!recordNextChar: glyphIndex advanceWidth: advance	| shape transform |	(activeFont includesKey: glyphIndex) ifTrue:[		shape _ (activeFont at: glyphIndex) fullCopy reset.		"Must include the textMorph's transform here - it might be animated"		transform _  ((MatrixTransform2x3 withOffset: textOffset) 							setScale: (textHeight@textHeight) / 1024.0).		transform _ transform composedWithGlobal: textMorph transform.		shape transform: transform.		shape color: textMorph color.		textMorph addMorphBack: shape.].	textOffset _ textOffset + (advance@0).! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 01:46'!recordTextChange: fontId color: color xOffset: xOffset yOffset: yOffset height: height	fontId ifNotNil:[activeFont _ fonts at: fontId].	height ifNotNil:[textHeight _ height].	xOffset ifNotNil:[textOffset _ xOffset @ textOffset x].	yOffset ifNotNil:[textOffset _ textOffset x @ yOffset].	color ifNotNil:[textMorph color: color].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 00:50'!recordTextEnd: id	textMorph submorphs isEmpty ifFalse:[		textMorph allMorphsDo:[:m| m color: textMorph color].		textMorph transform: nil.		textMorph id: id.		textMorph stepTime: stepTime.		textMorph lockChildren.		shapes at: id put: textMorph].	self doLog ifTrue:[log _ Transcript].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/20/1998 01:41'!recordTextStart: id bounds: bounds matrix: matrix	textOffset _ 0@0.	textMorph _ FlashTextMorph new.	textMorph privateBounds: bounds.	textMorph color: Color black.	matrix ifNotNil:[textMorph transform: matrix].! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 11/18/1998 21:36'!recordGradientFill: fillIndex matrix: gradientMatrix ramp: colorRampArray linear: aBoolean	| fillStyle ramp origin direction normal |	ramp _ colorRampArray collect:[:assoc| (assoc key / 255.0) -> assoc value].	origin _ gradientMatrix localPointToGlobal: (aBoolean ifFalse:[0@0] ifTrue:[-16384@0]).	direction _ (gradientMatrix localPointToGlobal: (16384@0)) - origin.	normal _ (gradientMatrix localPointToGlobal: (0@16384)) - origin.	fillStyle _ GradientFillStyle ramp: ramp.	fillStyle origin: origin.	fillStyle direction: direction.	fillStyle normal: normal.	fillStyle radial: aBoolean not.	fillStyle pixelRamp. "Force creation beforehand"	fillStyles at: fillIndex put: fillStyle.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/19/1998 20:30'!recordBeginSprite: id frames: frameCount	| sprite |	sprite _ FlashSpriteMorph new.	sprite maxFrames: frameCount.	sprite stepTime: stepTime.	spriteOwners at: sprite put: (		Array with: player 			with: frame			with: activeMorphs			with: passiveMorphs).	player _ sprite.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/24/1998 14:35'!recordEndSprite: id	| shape sprite |	sprite _ player.	player _ (spriteOwners at: sprite) at: 1.	frame _ (spriteOwners at: sprite) at: 2.	activeMorphs _ (spriteOwners at: sprite) at: 3.	passiveMorphs _ (spriteOwners at: sprite) at: 4.	spriteOwners removeKey: sprite.	sprite loadInitialFrame.	shape _ FlashCharacterMorph withAll: (Array with: sprite).	shape id: id.	shape isSpriteHolder: true.	shape stepTime: stepTime.	shapes at: id put: shape.	shape lockChildren.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/18/1998 22:00'!recordFrameCount: maxFrames	player maxFrames: maxFrames! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/21/1998 00:32'!recordFrameRate: fps	frameRate _ fps.	fps > 0.0 ifTrue:[stepTime _ (1000.0 / fps) rounded].	player stepTime: stepTime.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/18/1998 20:42'!recordGlobalBounds: bounds	player localBounds: bounds.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/21/1998 02:11'!recordMoveObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix	| index oldObj mat |	index _ nil.	activeMorphs do:[:list|		list do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth])					ifTrue:[index _ morph id]]].	oldObj _ self recordRemoveObject: index depth: depth.	oldObj isNil ifTrue:[^self].	objectIndex isNil ifFalse:[index _ objectIndex].	matrix isNil 		ifTrue:[mat _ oldObj matrixAtFrame: frame]		ifFalse:[mat _ matrix].	self recordPlaceObject: index depth: depth matrix: mat colorMatrix: colorMatrix.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/24/1998 14:51'!recordPlaceObject: objectIndex depth: depth matrix: matrix colorMatrix: colorTransform	| cached active doLoad |	cached _ passiveMorphs at: objectIndex ifAbsent:[#()].	cached size >= 1 		ifTrue:["Got an old morph. Re-use it"				doLoad _ false.				active _ cached first.				passiveMorphs at: objectIndex put: (cached copyWithout: active)]		ifFalse:["Need a new morph"				doLoad _ true.				active _ self newMorphFromShape: objectIndex.				active isNil ifTrue:[^self].				active reset.				active visible: false atFrame: frame - 1].	active isNil ifTrue:[^self].	active visible: true atFrame: frame.	active depth: depth atFrame: frame.	active matrix:  matrix atFrame: frame.	active colorTransform: colorTransform atFrame: frame.	doLoad ifTrue:[		active loadInitialFrame.		player addMorph: active].	cached _ (activeMorphs at: objectIndex ifAbsent:[#()]) copyWith: active.	activeMorphs at: objectIndex put: cached.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/21/1998 01:57'!recordRemoveObject: id depth: depth	id ifNotNil:["Faster if id is given"		(activeMorphs at: id ifAbsent:[#()]) do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth]) 					ifTrue:[^self removeActiveMorph: morph]]].	activeMorphs do:[:list|		list do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth]) 					ifTrue:[^self removeActiveMorph: morph]]].	Transcript cr; nextPutAll:'Shape (id = '; print: id; nextPutAll:' depth = '; print: depth; nextPutAll:') not removed in frame '; print: frame; endEntry.	^nil! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/19/1998 20:30'!recordShowFrame	player loadedFrames: frame.	frame _ frame + 1.! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/20/1998 01:04'!createSound: id info: info	| theSound loops |	theSound _ sounds at: id ifAbsent:[^nil].	loops _ info loopCount.	loops <= 1 ifTrue:[^theSound].	^RepeatingSound repeat: theSound count: loops! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/20/1998 01:59'!recordButton: buttonId actions: actionList condition: condition	| button |	button _ buttons at: buttonId ifAbsent:[^self halt].	(condition anyMask: 1) ifTrue:[		button on: #mouseEnter sendAll: actionList.	].	(condition anyMask: 2) ifTrue:[		button on: #mouseLeave sendAll: actionList.	].	(condition anyMask: 4) ifTrue:[		button on: #mouseDown sendAll: actionList.	].	(condition anyMask: 8) ifTrue:[		button on: #mouseUp sendAll: actionList.	].	(condition anyMask: 16) ifTrue:[		button on: #mouseLeaveDown sendAll: actionList.	].	(condition anyMask: 32) ifTrue:[		button on: #mouseEnterDown sendAll: actionList.	].	(condition anyMask: 64) ifTrue:[		button on: #mouseUpOut sendAll: actionList.	].	(condition anyMask: 128) ifTrue:[		button on: #mouseEnterDown sendAll: actionList.	].	(condition anyMask: 256) ifTrue:[		button on: #mouseLeaveDown sendAll: actionList.	].! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/24/1998 14:24'!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix colorTransform: cxForm	| button children shape |	button _ buttons at: buttonId ifAbsent:[^self halt].	button id: buttonId.	shape _ self oldMorphFromShape: characterId.	shape isNil ifTrue:[^nil].	children _ shape submorphs collect:[:m| m fullCopy].	shape _ FlashMorph withAll: children.	shape lockChildren.	shape depth: layer.	shape transform: matrix.	shape colorTransform: cxForm.	(state anyMask: 1) ifTrue:[		button defaultLook: shape.	].	(state anyMask: 2) ifTrue:[		button overLook: shape.	].	(state anyMask: 4) ifTrue:[		button pressLook: shape.	].	(state anyMask: 8) ifTrue:[		button sensitiveLook: shape.	].	button lockChildren.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/21/1998 02:20'!recordButton: id sound: soundId info: soundInfo state: state	"Give the button a sound"	| button theSound |	button _ buttons at: id ifAbsent:[^self halt].	theSound _ self createSound: soundId info: soundInfo.	theSound ifNil:[^self].	button addSound: theSound forState: state.! !!FlashMorphReader methodsFor: 'testing' stamp: 'ar 11/18/1998 21:37'!isStreaming	^player isStreaming! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/21/1998 14:08'!flushStreamingSound	| sound |	streamingSound buffers ifNil:[^self].	streamingSound buffers first position = 0 ifFalse:[		sound _ self createSoundFrom: streamingSound buffers					stereo: streamingSound stereo					samplingRate: streamingSound samplingRate.		player addSound: sound at: streamingSound firstFrame].	streamingSound firstFrame: frame.	streamingSound frameNumber: frame.	streamingSound buffers do:[:s| s reset].! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/20/1998 22:38'!recordSound: id data: aSampledSound	aSampledSound ifNotNil:[sounds at: id put: aSampledSound]! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/21/1998 00:47'!recordSoundStreamBlock: data	streamingSound frameNumber + 1 = frame 		ifFalse:[self flushStreamingSound].	self decompressSound: data					stereo: streamingSound stereo 					samples: streamingSound sampleCount 					rate: streamingSound samplingRate					into: streamingSound buffers.	streamingSound frameNumber: frame.! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/21/1998 00:53'!recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed	streamingSound buffers isNil ifFalse:[self flushStreamingSound].	streamingSound mixFmt: mixFmt.	streamingSound stereo: stereo.	streamingSound bitsPerSample: bitsPerSample.	streamingSound sampleCount: sampleCount.	streamingSound compressed: compressed.	streamingSound samplingRate: (frameRate * sampleCount) truncated.	streamingSound buffers: (self createSoundBuffersOfSize: sampleCount stereo: stereo).	streamingSound firstFrame: frame.	streamingSound frameNumber: frame.! !!FlashMorphReader methodsFor: 'defining sounds' stamp: 'ar 11/20/1998 22:38'!recordStartSound: id info: info	| theSound |	theSound _ self createSound: id info: info.	theSound ifNotNil:[player addSound: theSound at: frame].! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/18/1998 22:02'!isStreaming	^player isStreaming! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/19/1998 20:33'!loadedFrames	^player loadedFrames! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/18/1998 22:02'!maxFrames	^player maxFrames! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/18/1998 22:42'!progressValue	^player progressValue! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/19/1998 20:45'!startPlaying	player startPlaying! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/19/1998 20:43'!stopPlaying	player stopPlaying! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!bitsPerSample	^bitsPerSample! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!bitsPerSample: aNumber	bitsPerSample _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:45'!buffers	^buffers! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:45'!buffers: anArray	buffers _ anArray! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!compressed	^compressed! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!compressed: aBool	compressed _ aBool! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:34'!firstFrame	^firstFrame! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:34'!firstFrame: frame	firstFrame _ frame.! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:45'!frameNumber	^frameNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:45'!frameNumber: aNumber	frameNumber _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!mixFmt	^mixFmt! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!mixFmt: aNumber	mixFmt _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!sampleCount	^sampleCount! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:41'!sampleCount: aNumber	sampleCount _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:33'!samplingRate	^samplingRate! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/21/1998 00:33'!samplingRate: aNumber	samplingRate _ aNumber! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!stereo	^stereo! !!FlashStreamingSound methodsFor: 'accessing' stamp: 'ar 11/20/1998 22:40'!stereo: aBool	stereo _ aBool! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/18/1998 14:03'!inverseTransformation	"Return the inverse transformation of the receiver.	The inverse transformation is computed by first calculating	the inverse offset and then computing transformations	for the two identity vectors (1@0) and (0@1)"	| r1 r2 r3 m |	r3 _ self invertPoint: 0@0.	r1 _ (self invertPoint: 1@0) - r3.	r2 _ (self invertPoint: 0@1) - r3.	m _ self species new.	m		a11: r1 x; a12: r2 x; a13: r3 x;		a21: r1 y; a22: r2 y; a23: r3 y.	^m! !!Morph methodsFor: 'rotate scale and flex' stamp: 'ar 11/24/1998 14:19'!keepsTransform	"Return true if the receiver will keep it's transform while being grabbed by a hand."	^false! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 11/18/1998 21:53'!isStepping	"Return true if the receiver is currently stepping in its world"	| world |	world _ self world.	^world isNil		ifTrue:[false]		ifFalse:[world isStepping: self]! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 22:23'!lockChildren	submorphs do:[:m| 		m isMouseSensitive ifFalse:[m lock]].! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:27'!colorTransform	^colorTransform! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:27'!colorTransform: aColorTransform	colorTransform _ aColorTransform! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:19'!keepsTransform	"Return true if the receiver will keep it's transform while being grabbed by a hand."	^true! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/19/1998 22:22'!isMouseSensitive	"Return true if the receiver is mouse sensitive and must stay unlocked"	^false! !!FlashMorph methodsFor: 'drawing' stamp: 'ar 11/24/1998 14:49'!canvasForSubmorphs: canvasForMe	| canvas aaLevel |	canvas _ (super canvasForSubmorphs: canvasForMe).	colorTransform ifNotNil:[canvas _ canvas copyColorTransform: colorTransform].	aaLevel _ self defaultAALevel.	aaLevel isNil		ifTrue:[^canvas]		ifFalse:[^canvas copyAALevel: aaLevel]! !!FlashMorph methodsFor: 'events' stamp: 'ar 11/24/1998 14:20'!aboutToBeGrabbedBy: aHand	"Usually, FlashMorphs exist in a player. 	If they're grabbed and moved outside the player	they should keep their position."	| player |	player _ self flashPlayer.	player ifNotNil:[player noticeRemovalOf: self].	self transform: (self transformFrom: self world).! !!FlashMorph methodsFor: 'events' stamp: 'ar 11/18/1998 14:04'!justDroppedInto: newOwner event: evt	| ownerTransform |	ownerTransform _ (newOwner transformFrom: newOwner world).	ownerTransform isIdentity ifFalse:[		ownerTransform _ ownerTransform asMatrixTransform2x3 inverseTransformation.		self transform: (self transform composedWithGlobal: ownerTransform).	].	super justDroppedInto: newOwner event: evt.! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:32'!isSpriteHolder	^self hasProperty: #spriteHolder! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 11/24/1998 14:32'!isSpriteHolder: aBoolean	aBoolean		ifTrue:[self setProperty: #spriteHolder toValue: true]		ifFalse:[self removeProperty: #spriteHolder]! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/24/1998 14:50'!colorTransform: aColorTransform atFrame: frameNumber	self colorTransformData at: frameNumber put: aColorTransform! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/24/1998 14:51'!colorTransformAtFrame: frameNumber	^self colorTransformData at: frameNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/24/1998 14:51'!colorTransformData	^cmData	"^self keyframeData: #colorMatrixData"! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 11/24/1998 14:52'!stepToFrame: frameNumber	| m wasVisible isVisible noTransform cm |	wasVisible _ self visible.	self visible: (self visibleAtFrame: frameNumber).	isVisible _ self visible.	frame _ frameNumber.	isVisible ifTrue:[		m _ self matrixAtFrame: frame.		cm _ self colorTransformAtFrame: frame.		noTransform _ (m = transform) and:[colorTransform = cm].		(noTransform and:[isVisible = wasVisible]) ifTrue:[^self]. "No change"		((noTransform not) and:[wasVisible]) ifTrue:[			"Invalidate with old transform"			self changed.		].		self transform: m.		self colorTransform: cm.		((noTransform not) and:[isVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].		((noTransform) and:[isVisible ~~ wasVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].	] ifFalse:[		wasVisible ifTrue:[self changed].	].	(isVisible ~~ wasVisible and:[self isSpriteHolder])		ifTrue:[self activateSprites: isVisible].! !!FlashCharacterMorph methodsFor: 'private' stamp: 'ar 11/24/1998 14:34'!activateSprites: aBool	submorphs do:[:m|		(m isFlashMorph and:[m isFlashSprite]) ifTrue:[			aBool 				ifTrue:[m startPlaying]				ifFalse:[m stopPlaying].		].	].! !!FlashButtonMorph methodsFor: 'accessing' stamp: 'ar 11/20/1998 02:02'!ownerSprite	"Return the sprite owning the receiver.	The owning sprite is responsible for executing	the actions associated with the button."	| sprite |	sprite _ self.	[sprite isNil] whileFalse:[		(sprite isFlashMorph and:[sprite isFlashSprite]) ifTrue:[^sprite].		sprite _ sprite owner].	^nil! !!FlashButtonMorph methodsFor: 'accessing' stamp: 'ar 11/20/1998 02:03'!trackAsMenu: aBoolean	"Currently unused"	aBoolean 		ifTrue:[self setProperty: #trackAsMenu toValue: true]		ifFalse:[self removeProperty: #trackAsMenu].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/20/1998 15:32'!executeActions: type	| rcvr |	(events isNil or:[events isEmpty]) ifTrue:[^self].	rcvr _ self ownerSprite.	Sensor leftShiftDown ifTrue:[self inspect].	rcvr isNil ifTrue:[^self].	(events at: type ifAbsent:[^self]) do:[:action|		action sentTo: rcvr.	].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:32'!executeSounds: type	| sound |	(sounds isNil or:[sounds isEmpty]) ifTrue:[^self].	sound _ sounds at: type ifAbsent:[^self].	sound isPlaying ifFalse:[sound play].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/19/1998 20:32'!handlesMouseOver: evt	"Handle mouse events only if I am visible,"	^self visible! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30'!mouseDown: evt	self lookEnable: #(pressLook) disable:#().	self executeSounds: #mouseDown.	self executeActions: #mouseDown.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30'!mouseEnter: evt	self lookEnable: #(overLook) disable:#(pressLook defaultLook).	evt hand needsToBeDrawn ifFalse:[Cursor webLink show].	self executeSounds: #mouseEnter.	evt anyButtonPressed		ifTrue:[self executeActions: #mouseEnterDown]		ifFalse:[self executeActions: #mouseEnter].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30'!mouseLeave: evt	self lookEnable: #(defaultLook) disable:#(pressLook overLook).	evt hand needsToBeDrawn ifFalse:[Cursor normal show].	self executeSounds: #mouseLeave.	evt anyButtonPressed		ifTrue:[self executeActions: #mouseLeaveDown]		ifFalse:[self executeActions: #mouseLeave].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/21/1998 02:30'!mouseUp: evt	self lookEnable:#(defaultLook overLook) disable:#(pressLook).	self executeSounds: #mouseUp.	self executeActions: #mouseUp.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/20/1998 02:09'!on: eventName sendAll: actions	"Note: We handle more than the standard Morphic events here"	| actionList |	events ifNil:[events _ Dictionary new].	self analyzeActionsForBalloonHelp: actions.	actionList _ events at: eventName ifAbsent:[#()].	actionList _ actionList, actions.	events at: eventName put: actionList.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/24/1998 15:14'!trumpsMouseDown: evt	"Return true if this morph wants to handle mouse down events even when the mouse is pressed under a submorph that also wishes to preepmpt mouse down events. Complete the comment."	^true! !!FlashButtonMorph methodsFor: 'classification' stamp: 'ar 11/19/1998 22:22'!isMouseSensitive	"Return true if the receiver is mouse sensitive and must stay unlocked"	^true! !!FlashButtonMorph methodsFor: 'balloon help' stamp: 'ar 11/20/1998 15:15'!analyzeActionsForBalloonHelp: actionList	| helpText |	actionList do:[:msg|		helpText _ ActionHelpText at: msg selector ifAbsent:[nil].		helpText ifNotNil:[self setBalloonText: helpText].	].! !!FlashButtonMorph methodsFor: 'printing' stamp: 'ar 11/21/1998 01:36'!printOn: aStream	super printOn: aStream.	events ifNil:[^self].	aStream nextPut:$[.	events keys do:[:k| aStream print: k; space].	aStream nextPut: $].! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:34'!addProgressIndicator	progress _ FlashProgressMorph new.	progress borderWidth: 1.	progress color: Color transparent.	progress progressColor: Color gray.	progress extent: (100 @ (startButton extent y - 6)).	self addMorph: progress.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:42'!addProgressIndicator: aValueHolder	progress _ FlashProgressMorph new.	progress borderWidth: 1.	progress color: Color transparent.	progress progressColor: Color gray.	progress value: aValueHolder.	progress extent: (100 @ (startButton extent y - 6)).	self addMorph: progress.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:34'!adjustBookControls	| inner |	startButton ifNil: [^ self].	startButton align: startButton topLeft with: (inner _ self innerBounds) topLeft + (20@-4).	progress ifNotNil:[		progress align: progress topLeft with: (startButton right @ inner top) + (10@0)].	stopButton align: stopButton topRight with: inner topRight - (16@4).! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/18/1998 22:40'!collapseOrExpand	super collapseOrExpand.	isCollapsed ifTrue:[		startButton delete.		stopButton delete.		progress ifNotNil:[progress delete].	] ifFalse:[		self addMorph: startButton.		self addMorph: stopButton.		progress ifNotNil:[self addMorph: progress].		self adjustBookControls.	].! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 20:45'!initialize	| aFont |	super initialize.	aFont _ Preferences fontForScriptorButtons.	self addMorph: (startButton _ SimpleButtonMorph new borderWidth: 0;			label: 'play' font: aFont; color: Color transparent;			actionSelector: #startPlaying; target: self).	startButton setBalloonText: 'continue playing'.	self addMorph: (stopButton _ SimpleButtonMorph new borderWidth: 0;			label: 'stop' font: aFont; color: Color transparent;			actionSelector: #stopPlaying; target: self).	stopButton setBalloonText: 'stop playing'.	startButton submorphs first color: Color blue.	stopButton submorphs first color: Color red.	self adjustBookControls! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 21:10'!model: aFlashPlayerModel	aFlashPlayerModel isStreaming		ifTrue:[self addProgressIndicator: aFlashPlayerModel progressValue].	^super model: aFlashPlayerModel! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 20:46'!startPlaying	model startPlaying! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/19/1998 20:43'!stopPlaying	model stopPlaying! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:14'!progressColor	^progressColor! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:14'!progressColor: aColor	progressColor _ aColor! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:09'!value	^value! !!FlashProgressMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:14'!value: aModel	value removeDependent: self.	value _ aModel.	value addDependent: self.! !!FlashProgressMorph methodsFor: 'drawing' stamp: 'ar 11/18/1998 22:58'!drawOn: aCanvas	| width inner |	super drawOn: aCanvas.	inner _ self innerBounds.	width _ (inner extent x * lastValue) truncated min: inner extent x.	aCanvas fillRectangle: (inner origin extent: width @ inner extent y) color: progressColor.! !!FlashProgressMorph methodsFor: 'initialize' stamp: 'ar 11/18/1998 22:59'!initialize	super initialize.	progressColor _ Color green.	value _ ValueHolder new.	value contents: 0.0.	value addDependent: self.	lastValue _ 0.0.! !!FlashProgressMorph methodsFor: 'updating' stamp: 'ar 11/18/1998 23:04'!update: aSymbol	aSymbol == #contents ifTrue:[		lastValue _ value contents.		self changed]! !!FlashShapeMorph methodsFor: 'drawing' stamp: 'ar 11/18/1998 14:11'!drawOn: aCanvas 	"Display the receiver."	| aaLevel |	shape ifNil:[^aCanvas frameRectangle: self bounds color: Color black.].	aCanvas asBalloonCanvas transformBy: self transform while:[:balloonCanvas|		aaLevel _ self defaultAALevel.		aaLevel ifNotNil:[balloonCanvas aaLevel: aaLevel].		balloonCanvas drawCompressedShape: shape.	].! !!FlashShapeMorph methodsFor: 'geometry' stamp: 'ar 11/18/1998 13:59'!computeBounds	bounds _ self transform localBoundsToGlobal: (shape bounds).	fullBounds _ nil.! !!FlashSpriteMorph reorganize!('initialize' initialize)('accessing' addActions:atFrame: addLabel:atFrame: addSound:at: frameNumber frameNumber: loadedFrames loadedFrames: loopFrames loopFrames: maxFrames maxFrames:)('stepping' startPlaying step stepBackward stepForward stepTime stepTime: stepToFrame: stopPlaying wantsSteps)('classification' isFlashSprite isMouseSensitive)('change reporting' invalidRect:)('actions' actionPlay actionStop actionTarget: executeActionsAt: getURL:window: gotoFrame: gotoLabel: gotoNextFrame gotoPrevFrame isFrameLoaded:elseSkip: stopSounds toggleQuality)('private' getWebBrowser)!!FlashSpriteMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 22:07'!initialize	super initialize.	playing _ false.	loadedFrames _ 0.	maxFrames _ 1.	frameNumber _ 1.	sounds _ Dictionary new.	actions _ Dictionary new.	labels _ Dictionary new.	stepTime _ 1.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:09'!frameNumber	^frameNumber! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:09'!frameNumber: frame	^self stepToFrame: frame! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!loadedFrames	^loadedFrames! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!loadedFrames: n	loadedFrames _ n.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:16'!loopFrames	^false! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:16'!loopFrames: aBool! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!maxFrames	^maxFrames! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:02'!maxFrames: n	maxFrames _ n! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:09'!startPlaying	"Start playing from the current frame"	playing _ true.	loadedFrames = 0 ifTrue:[^nil].	frameNumber >= maxFrames ifTrue:[self frameNumber: 1].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:19'!step	playing ifFalse:[^self].	self stepForward.	damageRecorder _ nil. "Insurance"! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:09'!stepBackward	frameNumber > 1		ifTrue:[self frameNumber: frameNumber - 1]		ifFalse:[self frameNumber: loadedFrames].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:17'!stepForward	frameNumber < maxFrames		ifTrue:[self frameNumber: frameNumber + 1]		ifFalse:[self loopFrames			ifTrue:[self frameNumber: 1]			ifFalse:[self stopPlaying]].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:09'!stepToFrame: frame	"Step to the given frame"	| fullRect postDamage lastVisible resortNeeded |	frame = frameNumber ifTrue:[^self].	frame > loadedFrames ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	lastVisible _ nil.	resortNeeded _ false.	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m stepToFrame: frame.			m visible ifTrue:[				(lastVisible notNil and:[lastVisible depth < m depth])					ifTrue:[resortNeeded _ true].				lastVisible _ m.				(bounds containsRect: m bounds) ifFalse:[bounds _ bounds merge: m bounds].			].		].	].	resortNeeded ifTrue:[submorphs _ submorphs sortBy:[:m1 :m2| m1 depth > m2 depth]].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	(actions at: frame ifAbsent:[#()]) do:[:action| action sentTo: self].	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			"fullRect _ damageRecorder fullDamageRect.			fullRect _ (self transform localBoundsToGlobal: fullRect)."			fullRect _ bounds.			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[		damageRecorder _ nil].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 22:10'!stopPlaying	"Stop playing at the current frame."	playing _ false.! !!FlashSpriteMorph methodsFor: 'classification' stamp: 'ar 11/19/1998 22:22'!isMouseSensitive	"Return true - my children may be sensitive"	^true! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:10'!actionPlay	self startPlaying.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:10'!actionStop	"Stop playing at the current frame."	self stopPlaying.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:10'!actionTarget: target	"Set the context of an action.	I'm not really sure what the context of an action is."	Transcript cr; print:'actionTarget = '; target; endEntry.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:10'!executeActionsAt: frame	| actionList index msg result |	actionList _ actions at: frame ifAbsent:[^self].	index _ 1.	[index <= actionList size] whileTrue:[		msg _ actionList at: index.		result _ msg sentTo: self.		result ifNotNil:[index _ index + result].		index _ index + 1].! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/20/1998 02:36'!getURL: urlString window: windowString	"Load the given url in display it in the window specified by windowString.	Ignored for now."	| browser |	browser _ self getWebBrowser.	browser ifNotNil:[		browser jumpToUrl: urlString.		^nil].	"(self confirm: ('open a browser to view\',urlString,' ?') withCRs) ifTrue: [		browser _ Scamper new.		browser jumpToUrl: urlString.		browser openAsMorph	]."	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!gotoFrame: frame	"Jump to the given frame"	self frameNumber: frame+1.	self stopPlaying.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!gotoLabel: labelString	"Go to the frame with the associated label string."	labels ifNil:[^nil].	self frameNumber: (labels at: labelString ifAbsent:[^nil]).	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!gotoNextFrame	"Go to the next frame"	self frameNumber: self frameNumber+1.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!gotoPrevFrame	"Go to the previous frame"	self frameNumber: self frameNumber-1.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!isFrameLoaded: frame elseSkip: nActions	"Skip nActions if the given frame is not loaded yet."	^loadedFrames >= frameNumber 		ifTrue:[nil]		ifFalse:[nActions].! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!stopSounds	"Stop all sounds"	SoundPlayer shutDown.	^nil! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 11/19/1998 22:11'!toggleQuality	"Toggle the display quality.	Ignored for now - we're aiming at adaptive quality settings."	^nil! !!FlashSpriteMorph methodsFor: 'private' stamp: 'ar 11/19/1998 22:37'!getWebBrowser	"Return a web browser if we're running in one"	| morph |	morph _ self. "I can't really be a web browser, can I?!!"	[morph isNil] whileFalse:[		morph isWebBrowser ifTrue:[^morph].		(morph hasProperty: #webBrowserView) ifTrue:[^morph model].		morph _ morph owner].	"Not in a browser"	^nil! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 22:53'!downloadState	| doc |	doc _ sourceUrl retrieveContents.	(FlashMorphReader on: doc contentStream binary) processFileAsync: self.	self startPlaying.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 23:09'!downloadStateIn: aScamper	| doc |	doc _ sourceUrl retrieveContents.	(FlashMorphReader on: doc contentStream binary) processFileAsync: self.	"Wait until the first frame is there"	[loadedFrames = 0] whileTrue:[(Delay forMilliseconds: 100) wait].	aScamper invalidateLayout.	self startPlaying.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/20/1998 22:56'!initialize	super initialize.	color _ Color white.	self loopFrames: false.	localBounds _ bounds.	activationKeys _ #().	activeMorphs _ SortedCollection new: 50.	activeMorphs sortBlock:[:m1 :m2| m1 depth > m2 depth].	progressValue _ ValueHolder new.	progressValue contents: 0.0.	self defaultAALevel: 2.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 20:31'!loadInitialFrame	"Note: Must only be sent to a player if not in streaming mode"	self isStreaming ifTrue:[^self].	super loadInitialFrame.	activationKeys _ self collectActivationKeys: maxFrames.	activeMorphs _ SortedCollection new: 50.	activeMorphs sortBlock:[:m1 :m2| m1 depth > m2 depth].	activeMorphs addAll: activationKeys first.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/19/1998 20:48'!makeControls	| b r loopSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2.	r _ AlignmentMorph newRow.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #startPlaying).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #stopPlaying).	r addMorphBack: (b fullCopy label: 'Next';			actionSelector: #stepForward).	r addMorphBack: (b fullCopy label: 'Prev';			actionSelector: #stepBackward).	loopSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'Loop';		actionSelector: #loopFrames:;		target: self;		setSwitchState: false.	r addMorphBack: loopSwitch.	loopSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'cache';		actionSelector: #enableCache:;		target: self;		setSwitchState: false.	r addMorphBack: loopSwitch.	r addMorphBack: (b fullCopy label: 'Fastest'; 	actionSelector: #drawFastest).	r addMorphBack: (b fullCopy label: 'Medium';	actionSelector: #drawMedium).	r addMorphBack: (b fullCopy label: 'Nicest';		actionSelector: #drawNicest).	r addMorphBack: (b fullCopy label: '+10';		actionSelector: #jump10).	b target: self.	^ self world activeHand attachMorph: r! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/18/1998 21:40'!open	Smalltalk isMorphic 		ifTrue:[self openInWorld]		ifFalse:[self openInMVC]! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/18/1998 19:21'!sourceUrl: urlString	sourceUrl _ urlString! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/20/1998 02:27'!addMorph: aMorph	aMorph isFlashMorph ifFalse:[^super addMorph: aMorph].	aMorph isMouseSensitive		ifTrue:[self addMorphFront: aMorph]		ifFalse:[self addMorphBack: aMorph].! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 20:52'!borderWidth	"Ignored here - only for keeping the window happy"	^0! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 20:52'!borderWidth: bw	"Ignored here - only for keeping the window happy"! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 21:46'!isStreaming	"Return true if we're in streaming mode"	^sourceUrl notNil! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:59'!loadedFrames: aNumber	self isStreaming ifTrue:[		activationKeys _ self collectActivationKeys: aNumber.		aNumber = 1 ifTrue:[			activeMorphs addAll: activationKeys first.			self changed].		progressValue contents: (aNumber asFloat / maxFrames).		"Give others a chance"		World == nil			ifTrue:[Processor yield]			ifFalse:[World doOneCycle].	].	loadedFrames _ aNumber.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 20:43'!localBounds: newBounds	localBounds _ newBounds.	bounds _ (self position extent: newBounds extent // 20).	transform _ MatrixTransform2x3 					transformFromLocal: newBounds 					toGlobal: bounds! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/19/1998 22:17'!loopFrames	^(self valueOfProperty: #loopFrames) ifNil:[false]! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:33'!progressValue	^progressValue! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/18/1998 22:33'!progressValue: aValueHolder	progressValue _ aValueHolder! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 22:17'!aaLevel	^self defaultAALevel ifNil:[1]! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 20:27'!canvasForSubmorphs: canvasForMe	^(canvasForMe copyClipRect: self bounds)		asBalloonCanvas transformBy: self transform; aaLevel: self aaLevel! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 22:15'!drawFastest	self defaultAALevel: 1.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 22:15'!drawMedium	self defaultAALevel: 2.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 22:15'!drawNicest	self defaultAALevel: 4.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/19/1998 20:28'!drawOn: aCanvas 	"Draw the background of the player"	| box |	box _ self bounds.	aCanvas fillRectangle: box color: color! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/19/1998 20:48'!fullContainsPoint: pt	"The player clips its children"	(bounds containsPoint: pt) ifFalse:[^false].	^super fullContainsPoint: pt! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/19/1998 20:48'!unlockedMorphsAt: pt addTo: mList	"The player clips its children"	(bounds containsPoint: pt) ifFalse:[^mList].	^super unlockedMorphsAt: pt addTo: mList! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/19/1998 23:01'!stepToFrame: frame	| fullRect postDamage |	frame = frameNumber ifTrue:[^self].	frame > loadedFrames ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	frame > frameNumber ifTrue:[		self stepToFrameForward: frame.	] ifFalse:[		activeMorphs _ activeMorphs select:[:any| false].		submorphs do:[:m|			(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[				m stepToFrame: frame.				m visible ifTrue:[activeMorphs add: m].			]].	].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	self executeActionsAt: frame.	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			fullRect _ damageRecorder fullDamageRect: self localBounds.			fullRect _ (self transform localBoundsToGlobal: fullRect).			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[damageRecorder _ nil].! !!FlashPlayerMorph methodsFor: 'private' stamp: 'ar 11/18/1998 23:21'!collectActivationKeys: frame	"Note: Must only be called after a frame has been completed"	| vis lastKey |	vis _ Array new: frame.	vis atAllPut: #().	lastKey _ activationKeys size.	vis replaceFrom: 1 to: lastKey with: activationKeys startingAt: 1.	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m activationKeys do:[:key|				key > lastKey ifTrue:[					vis at: key put: ((vis at: key) copyWith: m)				].			].		].	].	^vis! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 11/24/1998 14:18'!grabMorph: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor localPt |	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike ifTrue:		[editor _ m topEditor].	"Check if the morph will keep it's transform while grabbed"	m keepsTransform		ifTrue:[localPt _ self position]		ifFalse:[localPt _ m pointFromWorld: self position].	(m owner isKindOf: DropShadowMorph)		ifTrue:			[self grabMorph: m owner]		ifFalse:			[m aboutToBeGrabbedBy: self.			m position: self position + (m position - localPt).			gridOn ifTrue: [m position: (m position grid: grid)].			self addMorphBack: m].	editor ifNotNil: [editor scriptEdited]! !FlashButtonMorph initialize!FlashFileReader removeSelector: #readFile!FlashFileReader removeSelector: #recordSound:data:stereo:bitsPerSample:sampleCount:rate:compressed:!FlashFileReader removeSelector: #recordFontName:id:!FlashFileReader removeSelector: #tagPlaceObject2:!FlashFileReader removeSelector: #frameNumber!FlashFileReader removeSelector: #frameNumber:!FlashFileReader removeSelector: #recordButton:character:state:layer:matrix:!FlashMorphReader removeSelector: #recordButton:character:state:layer:matrix:!FlashMorphReader removeSelector: #processFile:!FlashPlayerModel removeSelector: #play!FlashPlayerModel removeSelector: #stop!FlashPlayerModel removeSelector: #frames!FlashStreamingSound removeSelector: #data!FlashStreamingSound removeSelector: #leftBuffer:!FlashStreamingSound removeSelector: #leftBuffer!FlashStreamingSound removeSelector: #data:!FlashStreamingSound removeSelector: #rightBuffer:!FlashStreamingSound removeSelector: #rightBuffer!FlashCharacterMorph removeSelector: #colorMatrixData!FlashCharacterMorph removeSelector: #colorMatrix:atFrame:!FlashCharacterMorph removeSelector: #colorMatrixAtFrame:!FlashButtonMorph removeSelector: #initialize!FlashButtonMorph removeSelector: #on:sendAll:to:!FlashButtonMorph removeSelector: #balloonText!FlashButtonMorph removeSelector: #checkJumpsIn:!FlashButtonMorph removeSelector: #on:send:to:withValue:!FlashPlayerWindow removeSelector: #stop!FlashPlayerWindow removeSelector: #play!FlashProgressMorph removeSelector: #changed:!FlashShapeMorph removeSelector: #containsPoint:!FlashSpriteMorph removeSelector: #executeActions:!FlashSpriteMorph removeSelector: #frames!FlashSpriteMorph removeSelector: #stop!FlashSpriteMorph removeSelector: #frames:!FlashSpriteMorph removeSelector: #play!FlashPlayerMorph removeSelector: #actionPlay!FlashPlayerMorph removeSelector: #pause!FlashPlayerMorph removeSelector: #addActions:atFrame:!FlashPlayerMorph removeSelector: #actionStop!FlashPlayerMorph removeSelector: #syncFrames:!FlashPlayerMorph removeSelector: #addSound:at:!FlashPlayerMorph removeSelector: #gotoLabel:!FlashPlayerMorph removeSelector: #startPlaying!FlashPlayerMorph removeSelector: #wantsSteps!FlashPlayerMorph removeSelector: #isFrameLoaded:elseSkip:!FlashPlayerMorph removeSelector: #actionTarget:!FlashPlayerMorph removeSelector: #loadedFrames!FlashPlayerMorph removeSelector: #gotoNextFrame!FlashPlayerMorph removeSelector: #play!FlashPlayerMorph removeSelector: #collectActivationKeys!FlashPlayerMorph removeSelector: #addLabel:atFrame:!FlashPlayerMorph removeSelector: #stopPlaying!FlashPlayerMorph removeSelector: #toggleQuality!FlashPlayerMorph removeSelector: #stepForward!FlashPlayerMorph removeSelector: #stopSounds!FlashPlayerMorph removeSelector: #frameNumber:!FlashPlayerMorph removeSelector: #maxFrames:!FlashPlayerMorph removeSelector: #frames!FlashPlayerMorph removeSelector: #maxFrames!FlashPlayerMorph removeSelector: #stepBackward!FlashPlayerMorph removeSelector: #stop!FlashPlayerMorph removeSelector: #aaLevel:!FlashPlayerMorph removeSelector: #step!FlashPlayerMorph removeSelector: #gotoFrame:!FlashPlayerMorph removeSelector: #frames:!FlashPlayerMorph removeSelector: #gotoPrevFrame!FlashPlayerMorph removeSelector: #getURL:window:!FlashPlayerMorph removeSelector: #stepTime!FlashPlayerMorph removeSelector: #stepTime:!FlashPlayerMorph removeSelector: #executeActions:!