'From Squeak2.9alpha of 12 June 2000 [latest update: #2498] on 16 August 2000 at 10:08:20 pm'!"Change Set:		EvtFixes-arDate:			16 August 2000Author:			Andreas RaabFixes incorrect recording of modifiers when remapping buttons."!!EventSensor methodsFor: 'accessing' stamp: 'ar 8/16/2000 22:06'!nextEventSynthesized	"Return a synthesized event. This method is called if an event driven client wants to receive events but the primary user interface is not event-driven (e.g., the receiver does not have an event queue but only updates its state). This can, for instance, happen if a Morphic World is run in an MVC window. To simplify the clients work this method will always return all available keyboard events first, and then (repeatedly) the mouse events. Since mouse events come last, the client can assume that after one mouse event has been received there are no more to come. Note that it is impossible for EventSensor to determine if a mouse event has been issued before so the client must be aware of the possible problem of getting repeatedly the same mouse events. See HandMorph>>processEvents for an example on how to deal with this."	| kbd array buttons pos modifiers mapped |	"First check for keyboard"	array _ Array new: 8.	kbd _ self primKbdNext.	kbd = nil ifFalse:[		"simulate keyboard event"		array at: 1 put: EventTypeKeyboard. "evt type"		array at: 2 put: Time millisecondClockValue. "time stamp"		array at: 3 put: (kbd bitAnd: 255). "char code"		array at: 4 put: EventKeyChar. "key press/release"		array at: 5 put: (kbd bitShift: -8). "modifier keys"		^array].	"Then check for mouse"	buttons _ self primMouseButtons.	pos _ self primMousePt.	modifiers _ buttons bitShift: -3.	buttons _ buttons bitAnd: 7.	mapped _ self mapButtons: buttons modifiers: modifiers.	array 		at: 1 put: EventTypeMouse;		at: 2 put: Time millisecondClockValue;		at: 3 put: pos x;		at: 4 put: pos y;		at: 5 put: mapped;		at: 6 put: modifiers.	^array! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 8/16/2000 22:06'!primGetNextEvent: array	"Store the next OS event available into the provided array.	Essential. If the VM is not event driven the ST code will fall	back to the old-style mechanism and use the state based	primitives instead."	| kbd buttons modifiers pos mapped |	<primitive: 94>	"Simulate the events"	array at: 1 put: EventTypeNone. "assume no more events"	"First check for keyboard"	kbd _ super primKbdNext.	kbd = nil ifFalse:[		"simulate keyboard event"		array at: 1 put: EventTypeKeyboard. "evt type"		array at: 2 put: Time millisecondClockValue. "time stamp"		array at: 3 put: (kbd bitAnd: 255). "char code"		array at: 4 put: EventKeyChar. "key press/release"		array at: 5 put: (kbd bitShift: -8). "modifier keys"		^self].	"Then check for mouse"	buttons _ super primMouseButtons.	pos _ super primMousePt.	modifiers _ buttons bitShift: -3.	buttons _ buttons bitAnd: 7.	mapped _ self mapButtons: buttons modifiers: modifiers.	(pos = mousePosition and:[(mapped bitOr: (modifiers bitShift: 3)) = mouseButtons])		ifTrue:[^self].	array 		at: 1 put: EventTypeMouse;		at: 2 put: Time millisecondClockValue;		at: 3 put: pos x;		at: 4 put: pos y;		at: 5 put: mapped;		at: 6 put: modifiers.! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 8/16/2000 22:07'!processMouseEvent: evt	"process a mouse event, updating InputSensor state"	| modifiers buttons mapped |	mousePosition _ (evt at: 3) @ (evt at: 4).	buttons _ evt at: 5.	modifiers _ evt at: 6.	mapped _ self mapButtons: buttons modifiers: modifiers.	mouseButtons _ mapped bitOr: (modifiers bitShift: 3).! !