'From Squeak 2.3 beta of Nov 25, 1998 on 5 December 1998 at 12:49:18 pm'!"Change Set:		SingleCtxtSizeDate:			4 December 1998Author:			Dan IngallsThis set of changes causes all contexts to be allocated the same size.NOTE: These changes were developed together with several others and so may not work in isolation."!!ObjectMemory methodsFor: 'interpreter access' stamp: 'di 12/4/1998 01:32'!instantiateClass: classPointer indexableSize: size	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj sizeHiBits |"	NOTE: This method supports the backward-compatible split instSize field of the	class format word.  The sizeHiBits will go away and other shifts change by 2	when the split fields get merged in an (incompatible) image change."	self inline: false.	checkAssertions ifTrue: [		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ]].	hash _ self newObjectHash.	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"	sizeHiBits _ (header1 bitAnd: 16r60000) >> 9.	header1 _ (header1 bitAnd: 16r1FFFF) bitOr: ((hash << HashBitsOffset) bitAnd: HashBits).	header2 _ classPointer.	header3 _ 0.	cClass _ header1 bitAnd: CompactClassMask. "compact class field from format word"	byteSize _ (header1 bitAnd: SizeMask) + sizeHiBits. "size in bytes -- low 2 bits are 0"	format _ (header1 >> 8) bitAnd: 16rF.	format < 8 ifTrue: [		"Bitmaps and Arrays"		inc _ size * 4.	] ifFalse: [		"Strings and Methods"		inc _ (size + 3) bitAnd: AllButTypeMask. "round up"		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"		"low bits of byte size go in format field"		header1 _ header1 bitOr: (binc << 8).	].	(byteSize + inc) > 255 ifTrue: [		"requires size header word"		header3 _ byteSize + inc.		header1 _ header1 - (byteSize bitAnd: 16rFF).  "Clear qsize field"	] ifFalse: [		header1 _ header1 + inc.	].	byteSize _ byteSize + inc.	header3 > 0 ifTrue: [		"requires full header"		hdrSize _ 3.	] ifFalse: [		cClass = 0			ifTrue: [ hdrSize _ 2 ]			ifFalse: [ hdrSize _ 1 ].	].	format <= 4  "if pointers, fill with nil oop"		ifTrue: [ fillWord _ nilObj ]		ifFalse: [ fillWord _ 0 ].	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 doFill: true with: fillWord.	^ newObj! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'di 12/4/1998 02:36'!instantiateContext: classPointer sizeInBytes: sizeInBytes	"This version of instantiateClass assumes that the total object size is under 256 bytes, the limit for objects with only one or two header words. Note that the size is specified in bytes and should include four bytes for the base header word."	| hash header1 header2 hdrSize |	hash _ self newObjectHash.	header1 _ ((hash << HashBitsOffset) bitAnd: HashBits) bitOr:			   (self formatOfClass: classPointer).	header1 _ header1 + (sizeInBytes - (header1 bitAnd: SizeMask)).	header2 _ classPointer.	(header1 bitAnd: CompactClassMask) = 0 "is compact class field from format word zero?"		ifTrue: [ hdrSize _ 2 ]		ifFalse: [ hdrSize _ 1 ].	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 doFill: false with: 0! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'di 12/4/1998 01:33'!instantiateSmallClass: classPointer sizeInBytes: sizeInBytes fill: fillValue	"This version of instantiateClass assumes that the total object size is under 256 bytes, the limit for objects with only one or two header words. Note that the size is specified in bytes and should include four bytes for the base header word."	| hash header1 header2 hdrSize |	hash _ self newObjectHash.	header1 _ ((hash << HashBitsOffset) bitAnd: HashBits) bitOr:			   (self formatOfClass: classPointer).	header1 _ header1 + (sizeInBytes - (header1 bitAnd: SizeMask)).	header2 _ classPointer.	(header1 bitAnd: CompactClassMask) = 0 "is compact class field from format word zero?"		ifTrue: [ hdrSize _ 2 ]		ifFalse: [ hdrSize _ 1 ].	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 doFill: true with: fillValue! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/4/1998 01:31'!allocate: byteSize headerSize: hdrSize h1: baseHeader h2: classOop h3: extendedSize doFill: doFill with: fillWord	"Allocate a new object of the given size and number of header words. (Note: byteSize already includes space for the base header word.) Initialize the header fields of the new object and fill the remainder of the object with the given value."	| newObj remappedClassOop end i |	self inline: true.	"remap classOop in case GC happens during allocation"	hdrSize > 1 ifTrue: [ self pushRemappableOop: classOop ].  	newObj _ self allocateChunk: byteSize + ((hdrSize - 1) * 4).	hdrSize > 1 ifTrue: [ remappedClassOop _ self popRemappableOop ].	hdrSize = 3 ifTrue: [		self longAt: newObj      put: (extendedSize bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 4 put: (remappedClassOop bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 8 put: (baseHeader bitOr: HeaderTypeSizeAndClass).		newObj _ newObj + 8.	].	hdrSize = 2 ifTrue: [		self longAt: newObj      put: (remappedClassOop bitOr: HeaderTypeClass).		self longAt: newObj + 4 put: (baseHeader bitOr: HeaderTypeClass).		newObj _ newObj + 4.	].	hdrSize = 1 ifTrue: [		self longAt: newObj put: (baseHeader bitOr: HeaderTypeShort).	].	"clear new object"	doFill ifTrue:		[end _ newObj + byteSize.		i _ newObj + 4.		[i < end] whileTrue:			[self longAt: i put: fillWord.			i _ i + 4]].	checkAssertions ifTrue: [		self okayOop: newObj.		self oopHasOkayClass: newObj.		(self objectAfter: newObj) = freeBlock			ifFalse: [ self error: 'allocate bug: did not set header of new oop correctly' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'allocate bug: did not set header of freeBlock correctly' ].	].	^ newObj! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/4/1998 02:36'!allocateOrRecycleContext	"Return a recycled context or a newly allocated one if none is available for recycling. The argument indicates that a small context is wanted."	| cntxt |	self inline: true.		freeLargeContexts ~= NilContext ifTrue: [			cntxt _ freeLargeContexts.			freeLargeContexts _ self fetchPointer: 0 ofObject: cntxt.		] ifFalse: [			cntxt _ self instantiateContext: (self splObj: ClassMethodContext)								sizeInBytes: LargeContextSize.			"Required init -- above does not fill w/nil.  All others get written."			self storePointerUnchecked: 4 "InitialIPIndex" ofObject: cntxt								withValue: nilObj.		].	^ cntxt! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/4/1998 00:52'!internalAllocateOrRecycleContext	"Return a recycled context or a newly allocated one if none is available for recycling. The argument indicates that a small context is wanted."	| cntxt |	self inline: true.	freeLargeContexts ~= NilContext ifTrue: [		cntxt _ freeLargeContexts.		freeLargeContexts _ self fetchPointer: 0 ofObject: cntxt.	] ifFalse: [		self externalizeIPandSP.		cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)							sizeInBytes: LargeContextSize fill: nilObj.		self internalizeIPandSP.	].	^ cntxt! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/4/1998 01:01'!recycleContextIfPossible: cntxOop	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss. It's fields are nil-ed out when it is re-used. The recycled context lists are cleared at every garbage collect."	"Note: This code was found to be critical to good send/return speed, so it has been ruthlessly hand-tuned."	| cntxHeader |	self inline: true.	"only recycle young contexts (which should be most of them)"	cntxOop >= youngStart ifTrue: [	"is the context of class methodCntxClass?"	cntxHeader _ self baseHeader: cntxOop.	(self isMethodContext: cntxOop header: cntxHeader)	ifTrue: ["Note: The following test depends on the format of object headers			 and the fact that both small and large contexts are small enough			 for their size to be encoded in the base object header. If these			 assumptions is false, contexts won't be recycled properly, but the			 code should not break."			(cntxHeader bitAnd: SizeMask) = SmallContextSize				"Dont have to check after all are large"			ifFalse: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeLargeContexts.				freeLargeContexts _ cntxOop.				].		].	].! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/4/1998 00:59'!recycleContextIfPossible: cntxOop methodContextClass: methodCntxClass	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss. It's fields are nil-ed out when it is re-used. The recycled context lists are cleared at every garbage collect."	"Note: This code was found to be critical to good send/return speed, so it has been ruthlessly hand-tuned."	| cntxHeader |	self inline: true.	"only recycle young contexts (which should be most of them)"	cntxOop >= youngStart ifTrue: [	"is the context of class methodCntxClass?"	cntxHeader _ self baseHeader: cntxOop.	(self isMethodContext: cntxOop header: cntxHeader)	ifTrue: ["Note: The following test depends on the format of object headers			 and the fact that both small and large contexts are small enough			 for their size to be encoded in the base object header. If these			 assumptions is false, contexts won't be recycled properly, but the			 code should not break."			(cntxHeader bitAnd: SizeMask) = SmallContextSize				"Dont have to check after all are large"			ifFalse: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeLargeContexts.				freeLargeContexts _ cntxOop.				].		].	].! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/4/1998 00:49'!activateNewMethod	| newContext methodHeader initialIP tempCount nilOop |	methodHeader _ self headerOf: newMethod.	newContext _ self allocateOrRecycleContext.	initialIP _		((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _		(methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	0 to: argumentCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self stackValue: argumentCount-i)].	"clear remaining temps to nil in case it has been recycled"	nilOop _ nilObj.	argumentCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: nilOop].	self pop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self newActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/4/1998 00:53'!internalActivateNewMethod	| newContext methodHeader initialIP tempCount nilOop |	self inline: true.	methodHeader _ self headerOf: newMethod.	newContext _ self internalAllocateOrRecycleContext.	initialIP _		((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _		(methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	0 to: argumentCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self internalStackValue: argumentCount-i)].	"clear remaining temps to nil in case it has been recycled"	nilOop _ nilObj.	argumentCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: nilOop].	self internalPop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self internalNewActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/4/1998 03:15'!internalExecuteNewMethod	self inline: true.	primitiveIndex > 0		ifTrue: [(primitiveIndex > 255 and: [primitiveIndex < 520])				ifTrue: ["Internal return instvars"						primitiveIndex >= 264						ifTrue:						[^ self internalPop: 1 thenPush:								(self fetchPointer: primitiveIndex-264										ofObject: self internalStackTop)]						ifFalse:						["Internal return constants"						primitiveIndex = 256 ifTrue: [^ nil "^ self"].						primitiveIndex = 257 ifTrue: [^ self internalPop: 1 thenPush: trueObj].						primitiveIndex = 258 ifTrue: [^ self internalPop: 1 thenPush: falseObj].						primitiveIndex = 259 ifTrue: [^ self internalPop: 1 thenPush: nilObj].						^ self internalPop: 1 thenPush: (self integerObjectOf: primitiveIndex-261)]]				ifFalse: 	[self externalizeIPandSP.						self primitiveResponse ifTrue: [self internalizeIPandSP. ^ nil].						self internalizeIPandSP]].	"if not primitive, or primitive failed, activate the method"	self internalActivateNewMethod.	"check for possible interrupts at each real send"	self internalQuickCheckForInterrupts.! !!Interpreter methodsFor: 'return bytecodes' stamp: 'di 12/4/1998 01:02'!returnValue: resultObj to: returnContext	"Note: Assumed to be inlined into the dispatch loop."	| nilOop thisCntx contextOfCaller |	self inline: true.	self sharedCodeNamed: 'commonReturn' inCase: 120.	nilOop _ nilObj. "keep in a register"	thisCntx _ activeContext.	"make sure we can return to the given context"	((returnContext = nilOop) or:	 [(self fetchPointer: InstructionPointerIndex ofObject: returnContext) = nilOop]) ifTrue: [		"error: sender's instruction pointer or context is nil; cannot return"		self internalPush: activeContext.		self internalPush: resultObj.		messageSelector _ self splObj: SelectorCannotReturn.		argumentCount _ 1.		^ self normalSend	].	[thisCntx = returnContext] whileFalse: [		"climb up stack to returnContext"		contextOfCaller _ self fetchPointer: SenderIndex ofObject: thisCntx.		"zap exited contexts so any future attempted use will be caught"		self storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.		self storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.		reclaimableContextCount > 0 ifTrue: [			"try to recycle this context"			reclaimableContextCount _ reclaimableContextCount - 1.			self recycleContextIfPossible: thisCntx.		].		thisCntx _ contextOfCaller.	].	activeContext _ thisCntx.	(thisCntx < youngStart) ifTrue: [ self beRootIfOld: thisCntx ].	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"	self internalPush: resultObj.	"self internalQuickCheckForInterrupts."! !!Interpreter methodsFor: 'control primitives' stamp: 'di 12/4/1998 01:53'!primitiveBlockCopy	| context methodContext contextSize newContext initialIP |	context _ self stackValue: 1.	(self isIntegerObject: (self fetchPointer: MethodIndex ofObject: context)) ifTrue: [		"context is a block; get the context of its enclosing method"		methodContext _ self fetchPointer: HomeIndex ofObject: context.	] ifFalse: [		methodContext _ context.	].	contextSize _ self sizeBitsOf: methodContext.  "in bytes, including header"	context _ nil.  "context is no longer needed and is not preserved across allocation"	"remap methodContext in case GC happens during allocation"	self pushRemappableOop: methodContext.	newContext _ self instantiateContext: (self splObj: ClassBlockContext)							   sizeInBytes: contextSize.	methodContext _ self popRemappableOop.	initialIP _ self integerObjectOf: instructionPointer - method.	"Was instructionPointer + 3, but now it's greater by 		methodOop + 4 (headerSize) and less by 1 due to preIncrement"	"Assume: have just allocated a new context; it must be young.	 Thus, can use uncheck stores. See the comment in fetchContextRegisters."	self storeWord: InitialIPIndex					ofObject: newContext		withValue: initialIP.	self storeWord: InstructionPointerIndex		ofObject: newContext		withValue: initialIP.	self storeStackPointerValue: 0				inContext: newContext.	self storePointerUnchecked: BlockArgumentCountIndex	ofObject: newContext		withValue: (self stackValue: 0).	self storePointerUnchecked: HomeIndex		ofObject: newContext		withValue: methodContext.	self storePointerUnchecked: SenderIndex		ofObject: newContext		withValue: nilObj.	self pop: 2.  "block argument count, rcvr"	self push: newContext.! !ObjectMemory removeSelector: #internalAllocateOrRecycleContext:!ObjectMemory removeSelector: #allocateOrRecycleContext:!ObjectMemory removeSelector: #allocate:headerSize:h1:h2:h3:fill:!