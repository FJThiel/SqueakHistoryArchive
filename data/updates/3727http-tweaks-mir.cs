'From Squeak2.9alpha of 13 June 2000 [latest update: #3373] on 2 February 2001 at 6:05:54 pm'!"Change Set:		http-tweaks-mirDate:			2 February 2001Author:			Michael RuegerThis change set cleans up a few minor things in CodeLoader. It also makes the http post (including the mailto: functionality) and put requests in the Netscape plugin API more readily available. These, of course, only work when running inside a browser.See class HTTPClient for examples and utility messages."!Object subclass: #HTTPClient	instanceVariableNames: ''	classVariableNames: 'RunningInBrowser '	poolDictionaries: ''	category: 'Framework-Download'!!CodeLoader methodsFor: 'private' stamp: 'mir 2/2/2001 14:44'!createRequestFor: name in: aLoader	"Create a URL request for the given string, which can be cached locally."	| request |	request _ HTTPLoader httpRequestClass for: self baseURL , name in: aLoader.	aLoader addRequest: request. "fetch from URL"	^request! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 2/2/2001 14:56'!loadCodeSegment: segmentName	| loader |	loader _ self new.	loader loadSegments: (Array with: segmentName). 	loader installSegments.! !!FileStream class methodsFor: 'browser requests' stamp: 'mir 2/2/2001 16:58'!httpPostDocument: url args: argsDict	| argString |	argString _ argsDict		ifNotNil: [argString _ HTTPSocket argString: argsDict]		ifNil: [''].	^self post: argString url: url , argString ifError: [self halt]! !!FileStream class methodsFor: 'browser requests' stamp: 'mir 2/2/2001 17:14'!httpPostMultipart: url args: argsDict	| mimeBorder argsStream crLf fieldValue resultStream result |	" do multipart/form-data encoding rather than x-www-urlencoded "	crLf _ SimpleClientSocket crLf.	mimeBorder _ '----squeak-', Time millisecondClockValue printString, '-stuff-----'.	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, crLf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue _ value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', crLf, 'Content-Type: ', value contentType.				fieldValue _ (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: crLf, crLf, fieldValue, crLf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.	resultStream _ self		post: 			('Content-type: multipart/form-data; boundary=', mimeBorder, crLf,			'Content-length: ', argsStream contents size printString, crLf, crLf, 			argsStream contents)		url: url ifError: [^'Error in post ' url toText].	"get the header of the reply"	result _ resultStream upToEnd.	^MIMEDocument content: result! !!FileStream class methodsFor: 'browser requests' stamp: 'mir 2/2/2001 14:23'!post: data target: target url: url ifError: errorBlock	^self concreteStream new post: data target: target url: url ifError: errorBlock! !!FileStream class methodsFor: 'browser requests' stamp: 'mir 2/2/2001 14:23'!post: data url: url ifError: errorBlock	^self post: data target: nil url: url ifError: errorBlock! !!HTTPClient class methodsFor: 'class initialization' stamp: 'mir 2/2/2001 17:27'!determineIfRunningInBrowser	"HTTPClient determineIfRunningInBrowser"	RunningInBrowser _ StandardFileStream isRunningAsBrowserPlugin! !!HTTPClient class methodsFor: 'utilities' stamp: 'mir 2/2/2001 17:25'!httpPostDocument: url args: argsDict	| argString |	argString _ argsDict		ifNotNil: [argString _ HTTPSocket argString: argsDict]		ifNil: [''].	^FileStream post: argString url: url , argString ifError: [self halt]! !!HTTPClient class methodsFor: 'utilities' stamp: 'mir 2/2/2001 17:25'!httpPostMultipart: url args: argsDict	| mimeBorder argsStream crLf fieldValue resultStream result |	" do multipart/form-data encoding rather than x-www-urlencoded "	crLf _ SimpleClientSocket crLf.	mimeBorder _ '----squeak-', Time millisecondClockValue printString, '-stuff-----'.	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, crLf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue _ value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', crLf, 'Content-Type: ', value contentType.				fieldValue _ (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: crLf, crLf, fieldValue, crLf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.	resultStream _ FileStream		post: 			('Content-type: multipart/form-data; boundary=', mimeBorder, crLf,			'Content-length: ', argsStream contents size printString, crLf, crLf, 			argsStream contents)		url: url ifError: [^'Error in post ' url toText].	"get the header of the reply"	result _ resultStream upToEnd.	^MIMEDocument content: result! !!HTTPClient class methodsFor: 'utilities' stamp: 'mir 2/2/2001 17:34'!mailTo: address message: aString	HTTPClient isRunningInBrowser		ifFalse: [^self error: 'You need to run inside a web browser.'].	FileStream post: aString url: 'mailto:' , address ifError: [self error: 'Can not send mail']! !!HTTPClient class methodsFor: 'utilities' stamp: 'mir 2/2/2001 17:59'!uploadFileNamed: aFilename to: baseUrl user: user passwd: passwd	| fileContents remoteFilename |	remoteFilename _ (baseUrl endsWith: '/')		ifTrue: [baseUrl , '/' , aFilename]		ifFalse: [baseUrl , aFilename].	fileContents _ (StandardFileStream readOnlyFileNamed: aFilename) contentsOfEntireFile.	HTTPSocket httpPut: fileContents to: remoteFilename user: user passwd: passwd! !!HTTPClient class methodsFor: 'testing' stamp: 'mir 2/2/2001 17:28'!isRunningInBrowser	^RunningInBrowser! !!HTTPClient class methodsFor: 'examples' stamp: 'mir 2/2/2001 17:43'!exampleMailTo	"HTTPClient exampleMailTo"	HTTPClient mailTo: 'm.rueger@acm.org' message: 'A test message from within Squeak'! !!HTTPClient class methodsFor: 'examples' stamp: 'mir 2/2/2001 17:43'!examplePostArgs	"HTTPClient examplePostArgs"	| args result resultStream |	args _ Dictionary new.	args		at: 'arg1' put: #('val1');		at: 'arg2' put: #('val2');		yourself.	resultStream _ HTTPClient httpPostDocument: 'http://www.squeaklet.com/cgi-bin/thrd.pl'  args: args.	result _ resultStream upToEnd.	Transcript show: result; cr; cr.	resultStream close! !!HTTPClient class methodsFor: 'examples' stamp: 'mir 2/2/2001 17:44'!examplePostMultipart	"HTTPClient examplePostMultipart"	| args result |	args _ Dictionary new.	args		at: 'arg1' put: #('val1');		at: 'arg2' put: #('val2');		yourself.	result _ HTTPClient httpPostMultipart: 'http://www.squeaklet.com/cgi-bin/thrd.pl'  args: args.	Transcript show: result content; cr; cr.! !!HTTPLoader methodsFor: 'requests' stamp: 'mir 2/2/2001 14:45'!retrieveContentsFor: url	| request |	request _ self httpRequestClass for: url in: self.	self addRequest: request.	^request contents! !!HTTPLoader class methodsFor: 'class initialization' stamp: 'mir 10/7/1999 20:08'!initialize	"HTTPLoader initialize"	MaxNrOfConnections _ 2.	DefaultLoader ifNotNil: [		DefaultLoader release.		DefaultLoader _ nil]! !!HTTPLoader class methodsFor: 'accessing' stamp: 'mir 2/2/2001 17:28'!httpRequestClass	^HTTPClient isRunningInBrowser		ifTrue: [PluginHTTPRequest]		ifFalse: [HTTPRequest]! !!HTTPSocket class methodsFor: 'get the page' stamp: 'mir 9/21/2000 19:12'!httpPut: contents to: url user: user passwd: passwd	"Upload the contents of the stream to a file on the server"	| bare serverName specifiedServer port page serverAddr authorization s list header firstData length aStream command |	Socket initializeNetwork. 	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 				to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxyServer ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	authorization _ (Base64MimeConverter mimeEncode: (user , ':' , passwd) readStream) contents.	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: url; cr.	command _ 		'PUT ', page, ' HTTP/1.0', CrLf, 		'User-Agent: Squeak 2.0', CrLf,		'Host: ', specifiedServer, CrLf, 		'ACCEPT: */*', CrLf,		'Authorization: Basic ' , authorization , CrLf , 		'Content-length: ', contents size printString, CrLf , CrLf , 		contents.	s sendCommand: command.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s destroy.	"Always OK to destroy!!"	^ header, aStream contents! !!HTTPSocket class methodsFor: 'utilities' stamp: 'mir 1/31/2001 17:07'!httpPostDocument: url  args: argsDict accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| s header length page list firstData aStream type newUrl httpUrl argString |	Socket initializeNetwork.	httpUrl _ Url absoluteFromText: url.	page _ httpUrl fullPath.	"add arguments"	argString _ argsDict		ifNotNil: [argString _ self argString: argsDict]		ifNil: [''].	page _ page, argString.	s _ HTTPSocket new. 	s _ self initHTTPSocket: httpUrl wait: (self deadlineSecs: 30) ifError: [:errorString | ^errorString].	Transcript cr; show: url; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: application/x-www-form-urlencoded', CrLf,		'Content-length: ', argString size printString, CrLf,		'Host: ', httpUrl authority, CrLf.  "blank line automatically added"	s sendCommand: argString.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'Response: ' , s responseCode.			Transcript show: ' redirecting to: ', newUrl; cr.			s destroy.			"^self httpPostDocument: newUrl  args: argsDict  accept: mimeType"			^self httpGet: newUrl accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!PluginLauncher methodsFor: 'running' stamp: 'mir 2/2/2001 17:27'!startUp	| scriptName loader |	World ifNotNil: [World install].	HTTPClient determineIfRunningInBrowser.	HTTPClient isRunningInBrowser		ifFalse: [^self].	scriptName _ self parameterAt: 'src'.	scriptName isEmpty ifTrue:[^self].	CodeLoader defaultBaseURL: (self parameterAt: 'Base').	loader _ CodeLoader new.	loader loadSourceFiles: (Array with: scriptName).	(scriptName asLowercase endsWith: '.pr') 		ifTrue:[loader installProject]		ifFalse:[loader installSourceFiles].! !!StandardFileStream methodsFor: 'browser requests' stamp: 'mir 2/2/2001 14:22'!post: data target: target url: url ifError: errorBlock	"Post data to the given URL. The returned file stream contains the reply of the server.	If Squeak is not running in a browser evaluate errorBlock"	| sema index request result |	self waitBrowserReadyFor: self defaultBrowserReadyWait ifFail: [^errorBlock value].	sema _ Semaphore new.	index _ Smalltalk registerExternalObject: sema.	request _ self primURLPost: url target: target data: data semaIndex: index.	request == nil ifTrue:[		Smalltalk unregisterExternalObject: sema.		^errorBlock value.	] ifFalse:[		[sema wait. "until something happens"		result _ self primURLRequestState: request.		result == nil] whileTrue.		result ifTrue:[fileID _ self primURLRequestFileHandle: request].		self primURLRequestDestroy: request.	].	Smalltalk unregisterExternalObject: sema.	fileID == nil ifTrue:[^nil].	self register.	name _ url.	rwmode _ false.	buffer1 _ String new: 1.! !!StandardFileStream methodsFor: 'browser requests' stamp: 'mir 2/2/2001 14:22'!post: data url: url ifError: errorBlock	self post: data target: nil url: url ifError: errorBlock! !!StandardFileStream methodsFor: 'browser requests' stamp: 'mir 9/21/2000 16:58'!primURLPost: url data: contents semaIndex: index	^self primURLPost: url target: nil data: contents semaIndex: index! !!StandardFileStream methodsFor: 'browser requests' stamp: 'mir 9/21/2000 16:58'!primURLPost: url target: target data: contents semaIndex: index	"Post the data (url might be 'mailto:' etc)"	<primitive:'primitivePluginPostURL'>	^nil ! !HTTPLoader initialize!Smalltalk removeClassNamed: #PluginCodeLoader!