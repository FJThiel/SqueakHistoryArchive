'From Squeak 2.2beta of Sept 11, 1998 on 22 September 1998 at 9:43:33 am'!"Change Set:		jhmFileStreamTweaksDate:			22 September 1998Author:			John MaloneyMakes reopen work properly on files that were open when animage was saved and then restarted. Various comment and othercleanups included."!!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!close	"Close this file."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!closed	"Answer true if this file is closed."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:03'!flush	"When writing, flush the current buffer out to disk."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:04'!reopen	"Ensure that the receiver is open, re-open it if necessary."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!ascii	"Set this file to ascii (text) mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!binary	"Set this file to binary mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!readOnly	"Set this file's mode to read-only."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:00'!readWrite	"Set this file's mode to read-write."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!text	"Set this file to text (ascii) mode."	self ascii.! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/19/1998 17:05'!close	"Close this file."	fileID ifNotNil: [		self primClose: fileID.		fileID _ nil].! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/19/1998 17:01'!closed	"Answer true if this file is closed."	^ fileID isNil! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 16:20'!ensureOpen	"Make sure that this file really is open."	self closed ifTrue: [^ self reopen].	(self primSizeNoError: fileID) ifNotNil: [^ self].	self reopen.! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 13:41'!open: fileName forWrite: writeMode 	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	fileID _ self primOpen: fileName writable: writeMode.	fileID ifNil: [^ nil].  "allows sender to detect failure"	name _ fileName.	rwmode _ writeMode.	buffer1 _ String new: 1.! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 13:58'!reopen	"Close and reopen this file. The file position is reset to zero."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	fileID ifNotNil: [self primCloseNoError: fileID].	self open: name forWrite: rwmode.! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 9/21/1998 13:56'!readOnly	"Make this file read-only."	rwmode _ false.! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 9/21/1998 13:56'!readWrite	"Make this file writable."	rwmode _ true.! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:16'!directory	"Return the directory containing this file."	^ FileDirectory forFileName: self fullName! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!fullName	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!name	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 14:11'!next	"Answer the next byte from this file, or nil if at the end of the file."	| count |	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [^ buffer1 at: 1]		ifFalse: [^ nil].! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:55'!nextPut: char	"Write the given character to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	buffer1 at: 1 put: char.	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.	^ char! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:55'!nextPutAll: aString	"Write all the characters of the given string to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	self primWrite: fileID from: aString startingAt: 1 count: aString size.	^ aString! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:56'!verbatim: aString	"A version of nextPutAll that can be called knowing it won't call nextPut: "	^ self nextPutAll: aString! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primAtEnd: id	"Answer true if the file position is at the end of the file."	<primitive: 150>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:02'!primClose: id	"Close this file."	<primitive: 151>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:02'!primCloseNoError: id	"Close this file. Don't raise an error if the primitive fails."	<primitive: 151>! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:04'!primGetPosition: id	"Get this files current position."	<primitive: 152>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:06'!primOpen: fileName writable: writableFlag	"Open a file of the given name, and return the file ID obtained.	If writableFlag is true, then		if there is none with this name, then create one		else prepare to overwrite the existing from the beginning	otherwise		if the file exists, open it read-only		else return nil"	<primitive: 153>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primRead: id into: byteArray startingAt: startIndex count: count	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."	<primitive: 154>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File read failed'.! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:09'!primSetPosition: id to: anInteger	"Set this file to the given position."	<primitive: 155>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:17'!primSize: id	"Answer the size of this file."	<primitive: 157>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:17'!primSizeNoError: id	"Answer the size of this file. Answer nil if the primitive fails; this indicates that the file handle has become stale."	<primitive: 157>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primWrite: id from: stringOrByteArray startingAt: startIndex count: count	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."	<primitive: 158>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File write failed'.! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:13'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:14'!isAFileNamed: fileName	"Answer true if a file of the given name exists."	| f |	f _ self new open: fileName forWrite: false.	f ifNil: [^ false].	f close.	^ true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:14'!newFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, ask the user what to do."	| dir localName choice newName |	(self isAFileNamed: fileName)		ifFalse: [^ self new open: fileName forWrite: true].	"file already exists:"	dir _ FileDirectory forFileName: fileName.	localName _ FileDirectory localNameFor: fileName.	choice _ (PopUpMenu		labels:'overwrite that filechoose another namecancel')		startUpWithCaption: localName, 'already exists.'.	choice = 1 ifTrue: [		dir deleteFileNamed: localName			ifAbsent: [self error: 'Could not delete the old version of that file'].		^ self new open: fileName forWrite: true].	choice = 2 ifTrue: [		newName _ FillInTheBlank request: 'Enter a new file name' initialAnswer: fileName.		^ self newFileNamed: newName].	self error: 'Please close this to abort file opening'.! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:16'!oldFileNamed: fileName	"Open an existing file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	| selection |	(self isAFileNamed: fileName) ifTrue:		[^ self new open: fileName forWrite: true].	"File does not exist..."	selection _ (PopUpMenu labels:'create a new filechoose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: fileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self new open: fileName forWrite: true].	selection = 2 ifTrue:		[^ self oldFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: fileName))].	self halt! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:19'!readOnlyFileNamed: fileName	"Open an existing file with the given name for reading."	| selection |	(self isAFileNamed: fileName) ifTrue:		[^ self new open: fileName forWrite: false].	"File does not exist..."	selection _ (PopUpMenu labels: 'choose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: fileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self readOnlyFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: fileName))].	self halt! !FileStream removeSelector: #shorten!FileStream removeSelector: #release!FileStream removeSelector: #writeShorten!FileStream removeSelector: #dataContents!FileStream removeSelector: #writing!FileStream removeSelector: #setMode:!FileStream removeSelector: #readWriteShorten!StandardFileStream removeSelector: #primCloseGentle:!StandardFileStream removeSelector: #writeShorten!StandardFileStream removeSelector: #writing!StandardFileStream removeSelector: #readWriteShorten!StandardFileStream removeSelector: #fileID!StandardFileStream removeSelector: #reopenGently!StandardFileStream removeSelector: #containingDirectory!ReadWriteStream subclass: #FileStream	instanceVariableNames: 'rwmode '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!FileStream subclass: #StandardFileStream	instanceVariableNames: 'name fileID buffer1 '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!!FileStream reorganize!('accessing' contentsOfEntireFile next next: nextPut: nextPutAll: size)('testing' atEnd)('positioning' position position: reset setToEnd skip:)('printing' printOn:)('editing' edit)('file open/close' close closed flush reopen)('file modes' ascii binary readOnly readWrite text)('file accessing' file localName name)('fileIn/Out' fileIn fileInObjectAndCode)!