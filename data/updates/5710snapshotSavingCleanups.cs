'From Squeak3.7alpha of 11 September 2003 [latest update: #5707] on 20 February 2004 at 9:20:29 pm'!"Change Set:		SnapshotSavingCleanupsPost5707Date:			15 February 2004Author:			tim@sumeru.stanford.eduSome important cleanups in the saving of snapshots and initialising of FileDirectory. Makes it possible to save the snapshots in a different directory than the original snapshot file came from (ie you can start up /var/squeak/squeak.image and save ~joesixpack/joesworking.image).This version built for post-update 5707, compensating for the effects of recent KCP changes in the area of image saving and some changes in the 5707 updates"!!FileDirectory methodsFor: 'file stream creation' stamp: 'tpr 10/13/2003 12:34'!oldFileOrNoneNamed: fileName	"If the file exists, answer a read-only FileStream on it. If it doesn't, answer nil."	^ FileStream oldFileOrNoneNamed: fileName! !!FileDirectory methodsFor: 'enumeration' stamp: 'tpr 10/13/2003 10:58'!directoryEntryFor: filenameOrPath	"Answer the directory entry for the given file or path. Sorta like a poor man's stat()."	| fName dir |	DirectoryClass splitName: filenameOrPath to:[:filePath :name |		fName _ name.		filePath isEmpty			ifTrue: [dir _ self]			ifFalse: [dir _ FileDirectory on: filePath]].	self isCaseSensitive 		ifTrue:[^dir entries detect:[:entry| entry name = fName] ifNone:[nil]]		ifFalse:[^dir entries detect:[:entry| entry name sameAs: fName] ifNone:[nil]]! !!FileDirectory methodsFor: 'testing' stamp: 'tpr 2/17/2004 19:56'!directoryExists: filenameOrPath	"Answer true if a directory of the given name exists. The given name may be either a full path name or a local directory within this directory."	"FileDirectory default directoryExists: FileDirectory default pathName"	| fName dir |	DirectoryClass splitName: filenameOrPath to:		[:filePath :name |			fName _ name.			filePath isEmpty				ifTrue: [dir _ self]				ifFalse: [dir _ self directoryNamed: filePath]].	^dir exists and: [		self isCaseSensitive 			ifTrue:[dir directoryNames includes: fName]			ifFalse:[dir directoryNames anySatisfy: [:name| name sameAs: fName]]].! !!FileDirectory methodsFor: 'testing' stamp: 'tpr 10/13/2003 10:59'!fileExists: filenameOrPath	"Answer true if a file of the given name exists. The given name may be either a full path name or a local file within this directory."	"FileDirectory default fileExists: Smalltalk sourcesName"	| fName dir |	DirectoryClass splitName: filenameOrPath to:		[:filePath :name |			fName _ name.			filePath isEmpty				ifTrue: [dir _ self]				ifFalse: [dir _ FileDirectory on: filePath]].	self isCaseSensitive 		ifTrue:[^dir fileNames includes: fName]		ifFalse:[^dir fileNames anySatisfy: [:name| name sameAs: fName]].	! !!FileDirectory methodsFor: 'file operations' stamp: 'tpr 10/13/2003 10:59'!fileOrDirectoryExists: filenameOrPath	"Answer true if either a file or a directory file of the given name exists. The given name may be either a full path name or a local name within this directory."	"FileDirectory default fileOrDirectoryExists: Smalltalk sourcesName"	| fName dir |	DirectoryClass splitName: filenameOrPath to:		[:filePath :name |			fName _ name.			filePath isEmpty				ifTrue: [dir _ self]				ifFalse: [dir _ FileDirectory on: filePath]].	^ (dir includesKey: fName) or: [ fName = '' and:[ dir entries size > 1]]! !!FileDirectory methodsFor: 'file name utilities' stamp: 'tpr 10/13/2003 10:59'!fullNameFor: fileName	"Return a corrected, fully-qualified name for the given file name. If the given name is already a full path (i.e., it contains a delimiter character), assume it is already a fully-qualified name. Otherwise, prefix it with the path to this directory. In either case, correct the local part of the file name."	"Details: Note that path relative to a directory, such as '../../foo' are disallowed by this algorithm.  Also note that this method is tolerent of a nil argument -- is simply returns nil in this case."	| correctedLocalName prefix |	fileName ifNil: [^ nil].	DirectoryClass splitName: fileName to:		[:filePath :localName |			correctedLocalName _ localName isEmpty 				ifFalse: [self checkName: localName fixErrors: true]				ifTrue: [localName].			prefix _ self fullPathFor: filePath].	prefix isEmpty		ifTrue: [^correctedLocalName].	prefix last = self pathNameDelimiter		ifTrue:[^ prefix, correctedLocalName]		ifFalse:[^ prefix, self slash, correctedLocalName]! !!FileDirectory class methodsFor: 'instance creation' stamp: 'tpr 10/13/2003 10:49'!on: pathString	"Return a new file directory for the given path, of the appropriate FileDirectory subclass for the current OS platform."	| pathName |	DirectoryClass ifNil: [self setDefaultDirectoryClass].	"If path ends with a delimiter (: or /) then remove it"	((pathName _ pathString) endsWith: self pathNameDelimiter asString) ifTrue: [		pathName _ pathName copyFrom: 1 to: pathName size - 1].	^ DirectoryClass new setPathName: pathName! !!FileDirectory class methodsFor: 'name utilities' stamp: 'tpr 10/13/2003 10:59'!dirPathFor: fullName 	"Return the directory part the given name."	DirectoryClass		splitName: fullName		to: [:dirPath :localName | ^ dirPath]! !!FileDirectory class methodsFor: 'name utilities' stamp: 'tpr 10/13/2003 10:59'!localNameFor: fullName 	"Return the local part the given name."	DirectoryClass		splitName: fullName		to: [:dirPath :localName | ^ localName]! !!FileDirectory class methodsFor: 'name utilities' stamp: 'tpr 12/15/2003 12:03'!startUp	"Establish the platform-specific FileDirectory subclass. Do any platform-specific startup."	self setDefaultDirectoryClass.	self setDefaultDirectory: (self dirPathFor: SmalltalkImage current imageName).	Preferences startInUntrustedDirectory 		ifTrue:[	"The SecurityManager may override the default directory to prevent unwanted write access etc."				self setDefaultDirectory: SecurityManager default untrustedUserDirectory.				"Make sure we have a place to go to"				DefaultDirectory assureExistence].	SmalltalkImage current openSourceFiles.! !!FileDirectory class methodsFor: 'name utilities' stamp: 'tpr 10/13/2003 11:00'!urlForFileNamed: aFilename 	"Create a URL for the given fully qualified file name"	"FileDirectory urlForFileNamed: 	'C:\Home\andreasr\Squeak\DSqueak3\DSqueak3_1.1\DSqueak3.1.image' "	| path localName |	DirectoryClass		splitName: aFilename		to: [:p :n | 			path _ p.			localName _ n].	^ localName asUrlRelativeTo: (self on: path) url asUrl! !!FileDirectory class methodsFor: 'system start up' stamp: 'tpr 10/9/2003 16:27'!openChanges: changesName forImage: imageName"find the changes file by looking ina) the directory derived from the image nameb) the DefaultDirectory (which will normally be the directory derived from the image name or the SecurityManager's choice)If an old file is not found in either place, check for a read-only file in the same places. If that fails, return nil"	| changes fd |	"look for the changes file or an alias to it in the image directory"	fd _ FileDirectory on: (FileDirectory dirPathFor: imageName).	(fd fileExists: changesName)		ifTrue: [changes _ fd oldFileNamed: changesName].	changes ifNotNil:[^changes].	"look for the changes in the default directory"	fd _ DefaultDirectory.	(fd fileExists: changesName)		ifTrue: [changes _ fd oldFileNamed: changesName].	changes ifNotNil:[^changes].	"look for read-only changes in the image directory"	fd _ FileDirectory on: (FileDirectory dirPathFor: imageName).	(fd fileExists: changesName)		ifTrue: [changes _ fd readOnlyFileNamed: changesName].	changes ifNotNil:[^changes].	"look for read-only changes in the default directory"	fd _ DefaultDirectory.	(fd fileExists: changesName)		ifTrue: [changes _ fd readOnlyFileNamed: changesName].	"this may be nil if the last try above failed to open a file"	^changes! !!FileDirectory class methodsFor: 'system start up' stamp: 'tpr 12/15/2003 12:02'!openSources: sourcesName andChanges: changesName forImage: imageName 	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems regarding write permissions or CR/CRLF mixups."	"Note: SourcesName and imageName are full paths; changesName is a  	local name."	| sources changes msg wmsg |	msg _ 'Squeak cannot locate &fileRef.Please check that the file is named properly and is in thesame directory as this image.  Further explanation can foundin the startup window, ''How Squeak Finds Source Code''.'.	wmsg _ 'Squeak cannot write to &fileRef.Please check that you have write permission for this file.You won''t be able to save this image correctly until you fix this.'.	sources _ self openSources: sourcesName forImage: imageName.	changes _ self openChanges: changesName forImage: imageName.	((sources == nil or: [sources atEnd])			and: [Preferences valueOfFlag: #warnIfNoSourcesFile])		ifTrue: [SmalltalkImage current platformName = 'Mac OS'				ifTrue: [msg _ msg , 'Make sure the sources file is not an Alias.'].self inform: (msg copyReplaceAll: '&fileRef' with: 'the sources file named ' , sourcesName)].	(changes == nil			and: [Preferences valueOfFlag: #warnIfNoChangesFile])		ifTrue: [self inform: (msg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].	((Preferences valueOfFlag: #warnIfNoChangesFile) and: [changes notNil])		ifTrue: [changes isReadOnly				ifTrue: [self inform: (wmsg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].			((changes next: 200)					includesSubString: String crlf)				ifTrue: [self inform: 'The changes file named ' , changesName , 'has been injured by an unpacking utility.  Crs were changed to CrLfs.Please set the preferences in your decompressing program to "do not convert text files" and unpack the system again.']].	SourceFiles _ Array with: sources with: changes! !!FileDirectory class methodsFor: 'system start up' stamp: 'tpr 2/17/2004 19:59'!openSources: fullSourcesName forImage: imageName "We first do a check to see if a compressed version ofthe sources file is present.Open the .sources file read-only after searching in:a) the directory where the VM livesb) the directory where the image came fromc) the DefaultDirectory (which is likely the same as b unless the SecurityManager has changed it)."	| sources fd sourcesName |	(fullSourcesName endsWith: 'sources') ifTrue:		["Look first for a sources file in compressed format."		sources _ self openSources: (fullSourcesName allButLast: 7) , 'stc'						forImage: imageName.		sources ifNotNil: [^ CompressedSourceStream on: sources]].	sourcesName _ FileDirectory localNameFor: fullSourcesName.	"look for the sources file or an alias to it in the VM's directory"	fd _ FileDirectory on: SmalltalkImage current vmPath.	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	sources ifNotNil: [^ sources].	"look for the sources file or an alias to it in the image directory"	fd _ FileDirectory on: (FileDirectory dirPathFor: imageName).	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	sources ifNotNil: [^ sources].	"look for the sources in the current directory"	fd _ DefaultDirectory.	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	"sources may still be nil here"	^sources! !!FileDirectory class methodsFor: 'system start up' stamp: 'tpr 10/13/2003 10:49'!setDefaultDirectory: directoryName	"Initialize the default directory to the directory supplied. This method is called when the image starts up, very early in the #startUp sequence."	DefaultDirectory _ self on: directoryName.! !!FileDirectory class methodsFor: 'system start up' stamp: 'tpr 10/13/2003 10:39'!setDefaultDirectoryClass	"Initialize the default directory class to suit this platform. This method is called when the image starts up - it needs to be right at the front of the list of the startup sequence"	DirectoryClass _ self activeDirectoryClass! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'tpr 12/15/2003 12:09'!fullNameForChangesNamed: aName	| newName |	newName := FileDirectory baseNameFor: (FileDirectory default fullNameFor: aName).	^newName , FileDirectory dot, FileDirectory changeSuffix.! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'tpr 12/15/2003 12:10'!fullNameForImageNamed: aName	| newName |	newName := FileDirectory baseNameFor: (FileDirectory default fullNameFor: aName).	^newName , FileDirectory dot, FileDirectory imageSuffix.! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'tpr 12/15/2003 12:21'!saveAs	"Put up the 'saveAs' prompt, obtain a name, and save the image  under that new name."	| newName |	newName _ self getFileNameFromUser.	newName isNil ifTrue: [^ self].	(SourceFiles at: 2) ifNotNil:		[self closeSourceFiles; "so copying the changes file will always work"			 saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'tpr 12/15/2003 12:25'!saveAsNewVersion	"Save the image/changes using the next available version number."	"SmalltalkImage current saveAsNewVersion"		| newName changesName aName anIndex |	aName := FileDirectory baseNameFor: (FileDirectory default localNameFor: self imageName).	anIndex := aName lastIndexOf: FileDirectory dot asCharacter ifAbsent: [nil].	(anIndex notNil and: [(aName copyFrom: anIndex + 1 to: aName size) isAllDigits])		ifTrue:			[aName := aName copyFrom: 1 to: anIndex - 1].	newName := FileDirectory default nextNameFor: aName extension: FileDirectory imageSuffix.	changesName := self fullNameForChangesNamed: newName.	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"	(FileDirectory default fileOrDirectoryExists: changesName)		ifTrue:			[^ self inform:'There is already .changes file of the desired name,', newName, 'curiously already present, even though there isno corresponding .image file.   Please remedymanually and then repeat your request.'].	(SourceFiles at: 2) ifNotNil:		[self closeSourceFiles; "so copying the changes file will always work"			saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'tpr 12/15/2003 16:01'!saveChangesInFileNamed: aString	| fullChangesName |	fullChangesName _ (FileDirectory default fullNameFor: aString).	(FileDirectory default directoryNamed:(FileDirectory dirPathFor: fullChangesName )) assureExistence.	FileDirectory default 		copyFileWithoutOverwriteConfirmationNamed: SmalltalkImage current changesName 		toFileNamed: fullChangesName.	Smalltalk setMacFileInfoOn: fullChangesName.! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'tpr 12/15/2003 15:58'!saveImageInFileNamed: aString	| fullImageName |	fullImageName _ (FileDirectory default fullNameFor: aString).	(FileDirectory default directoryNamed:(FileDirectory dirPathFor: fullImageName )) assureExistence.	self		changeImageNameTo: fullImageName;		closeSourceFiles;		openSourceFiles;  "so SNAPSHOT appears in new changes file"		saveImageSegments;		snapshot: true andQuit: false! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'tpr 12/15/2003 12:18'!getFileNameFromUser	| newName |	newName := FillInTheBlank		request: 'New File Name?' translated		initialAnswer: (FileDirectory localNameFor: self imageName).	newName isEmpty ifTrue: [^nil].	((FileDirectory default fileOrDirectoryExists: (self fullNameForImageNamed: newName)) or:	 [FileDirectory default fileOrDirectoryExists: (self fullNameForChangesNamed: newName)]) ifTrue: [		(self confirm: ('{1} already exists. Overwrite?' translated format: {newName})) ifFalse: [^nil]].	^newName! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'tpr 2/17/2004 20:01'!snapshot: save andQuit: quit embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg _ String streamContents: [ :s |			s nextPutAll: '----';			nextPutAll: (save ifTrue: [ quit ifTrue: [ 'QUIT' ] ifFalse: [ 'SNAPSHOT' ] ]							ifFalse: [quit ifTrue: [ 'QUIT/NOSAVE' ] ifFalse: [ 'NOP' ]]);			nextPutAll: '----';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: ' priorSource: ';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming _ embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					["Time to reclaim segment files is immediately after a save"					Smalltalk at: #ImageSegment						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]		ifFalse: [resuming _ false].	quit & (resuming == false) ifTrue: [self quitPrimitive].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self readDocumentFile].	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup].	"Now it's time to raise an error"	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].	^ resuming! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'tpr 12/15/2003 12:09'!fullNameForChangesNamed: aName	| newName |	self deprecated: 'Use SmalltalkImage current fullNameForChangesNamed: aName'.	newName _ FileDirectory baseNameFor: (FileDirectory default fullNameFor: aName).	^newName , FileDirectory dot, FileDirectory changeSuffix.! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'tpr 12/15/2003 12:10'!fullNameForImageNamed: aName	| newName |	self deprecated: 'Use SmalltalkImage current fullNameForImageNamed: aName'.	newName _ FileDirectory baseNameFor: (FileDirectory default fullNameFor: aName).	^newName , FileDirectory dot, FileDirectory imageSuffix.! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'tpr 12/15/2003 12:19'!getFileNameFromUser	| newName |	self deprecated: 'Use SmalltalkImage current getFileNameFromUser'.	newName _ FillInTheBlank		request: 'New File Name?' translated		initialAnswer: (FileDirectory localNameFor: SmalltalkImage current imageName).	newName = '' ifTrue: [^nil].	((FileDirectory default fileOrDirectoryExists: (SmalltalkImage current fullNameForImageNamed: newName)) or:	 [FileDirectory default fileOrDirectoryExists: (SmalltalkImage current fullNameForChangesNamed: newName)]) ifTrue: [		(self confirm: ('{1} already exists. Overwrite?' translated format: {newName})) ifFalse: [^nil]].	^newName! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'tpr 12/15/2003 12:21'!saveAs	"Put up the 'saveAs' prompt, obtain a name, and save the image  under that new name."	| newName |	self deprecated: 'Use SmalltalkImage current saveAs'.	newName _ SmalltalkImage current getFileNameFromUser.	newName isNil ifTrue: [^ self].	(SourceFiles at: 2) ifNotNil:		[SmalltalkImage current closeSourceFiles; "so copying the changes file will always work"			 saveChangesInFileNamed: (SmalltalkImage current fullNameForChangesNamed: newName)].	SmalltalkImage current saveImageInFileNamed: (SmalltalkImage current fullNameForImageNamed: newName)! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'tpr 12/15/2003 12:25'!saveAsNewVersion	"Save the image/changes using the next available version number."	"Smalltalk saveAsNewVersion"	| newName changesName aName anIndex |	self deprecated: 'Use SmalltalkImage current saveAsNewVersion'.	aName _ FileDirectory baseNameFor: (FileDirectory default localNameFor: SmalltalkImage current imageName).	anIndex _ aName lastIndexOf: FileDirectory dot asCharacter ifAbsent: [nil].	(anIndex notNil and: [(aName copyFrom: anIndex + 1 to: aName size) isAllDigits])		ifTrue:			[aName _ aName copyFrom: 1 to: anIndex - 1].	newName _ FileDirectory default nextNameFor: aName extension: FileDirectory imageSuffix.	changesName _ SmalltalkImage current fullNameForChangesNamed: newName.	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"	(FileDirectory default includesKey: changesName)		ifTrue:			[^ self inform:'There is already .changes file of the desired name,', newName, 'curiously already present, even though there isno corresponding .image file.   Please remedymanually and then repeat your request.'].	(SourceFiles at: 2) ifNotNil:		[SmalltalkImage current closeSourceFiles; "so copying the changes file will always work"			saveChangesInFileNamed: (SmalltalkImage current fullNameForChangesNamed: newName)].	SmalltalkImage current saveImageInFileNamed: (SmalltalkImage current fullNameForImageNamed: newName)! !