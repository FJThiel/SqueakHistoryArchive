'From Squeak3.1alpha [latest update: #''Squeak3.1alpha'' of 5 February 2001 update 3911] on 6 April 2001 at 10:38:07 am'!"Change Set:		FasterAllChangeSetsDate:			5 April 2001Author:			Dan IngallsA complete reformulation of the access to ChangeSorter's class var AllChangeSets.By updating AllChangeSets at appropriate points, there should no longer be a need to constantly enumerate and filter the list.  This makes clicking on ChangeSorters much faster when there are a lot of changeSets.Also avoids the hard part of computing ChangeSetCategory>>reconstituteList, except when things have really changed.  This makes clicking on ChangeSorters faster still.Other than for initialization, there should be no further need for calls to gatherChangeSets.  The complete current list is always available via the expression 'ChangeSorter allChangeSets'."!!ChangeList methodsFor: 'menu actions' stamp: 'di 4/6/2001 09:03'!selectConflictsWith	"Selects all method definitions for which there is ALSO an entry in the specified changeSet or changList chosen by the user. 4/11/96 tk"	| aStream all index |	aStream _ WriteStream on: (String new: 200).	(all _ ChangeSorter allChangeSets copy) do:		[:sel | aStream nextPutAll: (sel name contractTo: 40); cr].	ChangeList allSubInstancesDo:		[:sel | aStream nextPutAll: (sel file name); cr.			all addLast: sel].	aStream skip: -1.	index _ (PopUpMenu labels: aStream contents) startUp.	index > 0 ifTrue: [		self selectConflicts: (all at: index)].! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 4/6/2001 09:40'!initialize 	"Initialize the receiver to be empty."	name ifNil:		[^ self error: 'All changeSets must be registered, as in ChangeSorter newChangeSet'].	revertable _ false.	self clear.! !!ChangeSet class methodsFor: 'instance creation' stamp: 'di 4/6/2001 09:43'!basicNewNamed: aName	^ (self basicNew name: aName) initialize! !!ChangeSet class methodsFor: 'instance creation' stamp: 'di 4/6/2001 10:02'!new	"All current changeSets must be registered in the AllChangeSets collection.	Due to a quirk of history, this is maintained as class variable of ChangeSorter."	^ ChangeSorter basicNewChangeSet: ChangeSet defaultName! !!ChangeSet class methodsFor: 'defaults' stamp: 'di 4/5/2001 21:33'!defaultName	^ self uniqueNameLike: 'Unnamed'! !!ChangeSet class methodsFor: 'defaults' stamp: 'di 4/5/2001 21:31'!uniqueNameLike: aString	| try |	1 to: 999999 do:		[:i | try _ aString , i printString.		(ChangeSorter changeSetNamed: try) ifNil: [^ try]]! !!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'di 4/6/2001 10:37'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers _ ChangeSorter allChangeSets select:		[:aChangeSet | ChangeSorter perform: membershipSelector with: aChangeSet].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet] ! !!ChangeSorter methodsFor: 'access' stamp: 'di 4/5/2001 21:20'!showChangeSetNamed: aName	self showChangeSet: (ChangeSorter changeSetNamed: aName) ! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 4/5/2001 17:56'!chooseChangeSetCategory	"Present the user with a list of change-set-categories and let her choose one"	|  cats aMenu result |	self okToChange ifFalse: [^ self].	Smalltalk isMorphic ifTrue: [^ self chooseChangeSetCategoryInMorphic].  "gives balloon help"	cats _ ChangeSetCategories elementsInOrder.	aMenu _ SelectionMenu		labels: (cats collect: [:cat | cat categoryName])		selections: cats.	result _ aMenu startUp.	result ifNotNil:		[changeSetCategory _ result.		self changed: #changeSetList.		(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangeSorter changeSetNamed: self changeSetList first)].		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 4/5/2001 17:56'!chooseCngSet	"Present the user with an alphabetical list of change set names, and let her choose one"	| changeSetsSortedAlphabetically chosen |	self okToChange ifFalse: [^ self].	changeSetsSortedAlphabetically _ self changeSetList asSortedCollection:		[:a :b | a asLowercase withoutLeadingDigits < b asLowercase withoutLeadingDigits].	chosen _ (SelectionMenu selections: changeSetsSortedAlphabetically)			startUp.	chosen ifNil: [^ self].	self showChangeSet: (ChangeSorter changeSetNamed: chosen)! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 4/5/2001 21:16'!findCngSet 	"Search for a changeSet by name.  Pop up a menu of all changeSets whose name contains the string entered by the user.  If only one matches, then the pop-up menu is bypassed"	| index pattern candidates |	self okToChange ifFalse: [^ self].	pattern _ FillInTheBlank request: 'ChangeSet name or fragment?'.	pattern isEmpty ifTrue: [^ self].	candidates _ AllChangeSets select:			[:c | c name includesSubstring: pattern caseSensitive: false].	candidates size = 0 ifTrue: [^ self beep].	candidates size = 1 ifTrue:		[^ self showChangeSet: candidates first].	index _ (PopUpMenu labels: 		(candidates collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (candidates at: index)].! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 4/5/2001 21:18'!removePrompting: doPrompt	"Completely destroy my change set.  Check if it's OK first,  and if doPrompt is true, get the user to confirm his intentions first"	| message aName changeSetNumber |	aName _ myChangeSet name.	myChangeSet okayToRemove ifFalse: [^ self]. "forms current changes for some project"	(myChangeSet isEmpty or: [doPrompt not]) ifFalse:		[message _ 'Are you certain that you want to remove (destroy) the change setnamed  "', aName, '" ?'.		(self confirm: message) ifFalse: [^ self]].	(doPrompt and: [myChangeSet hasPreamble or: [myChangeSet hasPostscript]])		ifTrue:			[(self confirm: 'Caution!!  This change set has a preambleand/or a postscript, which will be lost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [^ self]].	"Go ahead and remove the change set"	changeSetNumber _ myChangeSet name initialIntegerOrNil.	changeSetNumber ifNotNil: [SystemVersion current unregisterUpdate: changeSetNumber].	ChangeSorter removeChangeSet: myChangeSet.	self showChangeSet: Smalltalk changes.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 4/5/2001 21:22'!submergeIntoOtherSide	"Copy the contents of the receiver to the other side, then remove the receiver -- all after checking that all is well."	| other message nextToView i |	self checkThatSidesDiffer: [^ self].	self okToChange ifFalse: [^ self].	other _ (parent other: self) changeSet.	other == myChangeSet ifTrue: [^ self inform: 'Both sides are the same!!'].	myChangeSet isEmpty ifTrue: [^ self inform: 'Nothing to copy.  To remove,simply choose "remove".'].	myChangeSet okayToRemove ifFalse: [^ self].	message _ 'Please confirm:  copy all changesin "', myChangeSet name, '" into "', other name, '"and then destroy the change setnamed "', myChangeSet name, '"?'. 	(self confirm: message) ifFalse: [^ self].	(myChangeSet hasPreamble or: [myChangeSet hasPostscript]) ifTrue:		[(self confirm: 'Caution!!  This change set has a preamble ora postscript or both.  If you submerge it intothe other side, these will be lost.Do you really want to go ahead with this?') ifFalse: [^ self]].	other assimilateAllChangesFoundIn: myChangeSet.	nextToView _ ((AllChangeSets includes: myChangeSet)		and: [(i _ AllChangeSets indexOf: myChangeSet) < AllChangeSets size])		ifTrue: [AllChangeSets at: i+1]		ifFalse: [other].	self removePrompting: false.	self showChangeSet: nextToView.	parent modelWakeUp.! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 21:33'!allChangeSetNames	^ self allChangeSets collect: [:c | c name]! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 21:27'!allChangeSets	"Return the list of all current ChangeSets"	^ AllChangeSets! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 21:34'!allChangeSetsWithClass: class selector: selector	class ifNil: [^ #()].	^ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none]! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 19:42'!changeSetNamed: aName	"Return the change set of the given name, or nil if none found.  1/22/96 sw"	^ AllChangeSets			detect: [:aChangeSet | aChangeSet name = aName]			ifNone: [nil]! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 19:42'!changeSetsNamedSuchThat: nameBlock	"(ChangeSorter changeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger >= 373]])		do: [:cs | AllChangeSets remove: cs wither]"	^ AllChangeSets select: [:aChangeSet | nameBlock value: aChangeSet name]! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/6/2001 09:49'!existingOrNewChangeSetNamed: aName	| newSet |	^(self changeSetNamed: aName) ifNil: [		newSet _ ChangeSet basicNewNamed: aName.		AllChangeSets add: newSet.		newSet	]! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 21:37'!mostRecentChangeSetWithChangeForClass: class selector: selector	| hits |	hits _ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ 'not in any change set'].	^ 'recent cs: ', hits last name! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'di 4/5/2001 20:03'!promoteToTop: aChangeSet	"make aChangeSet the first in the list from now on"	AllChangeSets remove: aChangeSet ifAbsent: [^ self].	AllChangeSets add: aChangeSet.	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup]! !!ChangeSorter class methodsFor: 'adding' stamp: 'di 4/6/2001 09:46'!basicNewChangeSet: newName	| newSet |	newName ifNil: [^ nil].	(self changeSetNamed: newName) ifNotNil:		[self inform: 'Sorry that name is already used'.		^ nil].	newSet _ ChangeSet basicNewNamed: newName.	AllChangeSets add: newSet.	^ newSet! !!ChangeSorter class methodsFor: 'removing' stamp: 'di 4/5/2001 21:12'!removeChangeSetsNamedSuchThat: nameBlock	(ChangeSorter changeSetsNamedSuchThat: nameBlock)		do: [:cs | self removeChangeSet: cs]! !!ChangeSorter class methodsFor: 'removing' stamp: 'di 4/5/2001 21:13'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo _ (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | self removeChangeSet: cs].	self inform: toGo size printString, ' change set(s) removed.'! !!ChangeSorter class methodsFor: 'services' stamp: 'di 4/5/2001 21:34'!browseChangeSetsWithClass: class selector: selector	| hits index |	hits _ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ PopUpMenu notify: class name,'.',selector , 'is not in any change set'].	index _ hits size == 1		ifTrue:	[1]		ifFalse:	[(PopUpMenu labelArray: (hits collect: [:cs | cs name])					lines: #()) startUp].	index = 0 ifTrue: [^ self].	(ChangeSorter new myChangeSet: (hits at: index)) open.! !!ChangeSorter class methodsFor: 'services' stamp: 'di 4/5/2001 21:36'!buildAggregateChangeSet	"Establish a change-set named Aggregate which bears the union of all the changes in all the existing change-sets in the system (other than any pre-existing Aggregate).  This can be useful when wishing to discover potential conflicts between a disk-resident change-set and an image.  Formerly very useful, now some of its unique contributions have been overtaken by new features"	| aggregateChangeSet |	aggregateChangeSet _ self existingOrNewChangeSetNamed: 'Aggregate'.	aggregateChangeSet clear.	self allChangeSets do:		[:aChangeSet | aChangeSet == aggregateChangeSet ifFalse:			[aggregateChangeSet assimilateAllChangesFoundIn: aChangeSet]]"ChangeSorter buildAggregateChangeSet"	! !!ChangeSorter class methodsFor: 'services' stamp: 'di 4/5/2001 21:14'!reorderChangeSets	"Change the order of the change sets to something more convenient:		First come the project changesets that come with the release.  These are mostly empty.		Next come all numbered updates.		Next come all remaining changesets	In a ChangeSorter, they will appear in the reversed order."	"ChangeSorter reorderChangeSets"	| newHead newMid newTail |	newHead _ OrderedCollection new.	newMid _ OrderedCollection new.	newTail _ OrderedCollection new.	AllChangeSets do:		[:aChangeSet |			(self belongsInProjectsInRelease: aChangeSet)				ifTrue:					[newHead add: aChangeSet]				ifFalse:					[(self belongsInNumbered: aChangeSet)						ifTrue:							[newMid add: aChangeSet]						ifFalse:							[newTail add: aChangeSet]]].	AllChangeSets _ newHead, newMid, newTail.	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup]! !!ChangeSorter class methodsFor: 'services' stamp: 'di 4/5/2001 21:15'!secondaryChangeSet	"Answer a likely change set to use as the second initial one in a Dual Change Sorter.  "	AllChangeSets size = 1 ifTrue: [^ AllChangeSets first].	AllChangeSets last == Smalltalk changes		ifTrue: 	[^ AllChangeSets at: (AllChangeSets size - 1)]		ifFalse:	[^ AllChangeSets last]! !!DocLibrary methodsFor: 'doc pane' stamp: 'di 4/5/2001 21:38'!saveDocCheck: aMorph	"Make sure the document gets attached to the version of the code that the user was looking at.  Is there a version of this method in a changeSet beyond the updates we know about?  Works even when the user has internal update numbers and the documentation is for external updates (It always is)."	| classAndMethod parts selector class lastUp beyond ours docFor unNum ok key verList ext response |	classAndMethod _ aMorph valueOfProperty: #classAndMethod.	classAndMethod ifNil: [		^ self error: 'need to know the class and method'].	"later let user set it"	parts _ classAndMethod findTokens: ' .'.	selector _ parts last asSymbol.	class _ Smalltalk at: (parts first asSymbol) ifAbsent: [^ self saveDoc: aMorph].	parts size = 3 ifTrue: [class _ class class].	"Four indexes we are looking for:		docFor = highest numbered below lastUpdate that has method.		unNum = a higher unnumbered set that has method.		lastUp = lastUpdate we know about in methodVersions		beyond = any set about lastUp that has the method."	ChangeSorter allChangeSets doWithIndex: [:cs :ind | "youngest first"		(cs name includesSubString: lastUpdateName) ifTrue: [lastUp _ ind].		(cs atSelector: selector class: class) ~~ #none ifTrue: [			lastUp ifNotNil: [beyond _ ind. ours _ cs name]				ifNil: [cs name first isDigit ifTrue: [docFor _ ind] 						ifFalse: [unNum _ ind. ours _ cs name]]]].	"See if version the user sees is the version he is documenting"	ok _ beyond == nil.	unNum ifNotNil: [docFor ifNotNil: [ok _ docFor > unNum]						ifNil: [ok _ false]].  "old changeSets gone"	ok ifTrue: [^ self saveDoc: aMorph].	key _ DocLibrary properStemFor: classAndMethod.	verList _ (methodVersions at: key ifAbsent: [#()]), #(0 0).	ext _ verList first.	"external update number we will write to"	response _ (PopUpMenu labels: 'Cancel\Broadcast Page' withCRs)				startUpWithCaption: 'You are documenting a method in External Update ', ext asString, '.\There is a more recent version of that method in ' withCRs, ours, '.\If you are explaining the newer version, please Cancel.\Wait until that version appears in an External Update.' withCRs.	response = 2 ifTrue: [self saveDoc: aMorph].! !!Project methodsFor: 'initialization' stamp: 'di 4/6/2001 10:30'!initialize	"Initialize the project, seting the CurrentProject as my parentProject and initializing my project preferences from those of the CurrentProject"	changeSet _ ChangeSet new.	transcript _ TranscriptStream new.	displayDepth _ Display depth.	parentProject _ CurrentProject.	isolatedHead _ false.	self initializeProjectPreferences! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 4/6/2001 10:14'!fileOutAndRemove: classesAndMethodsPair	"classesAndMethodsPair is {set of class names. set of selectors}."	| classNames messageNames changeSet cl |	classNames _ classesAndMethodsPair first.	messageNames _ classesAndMethodsPair second.	changeSet _ ChangeSorter basicNewChangeSet: classNames first, 'EtAl'.	classNames do:		[:n | changeSet addClass: (cl _ Smalltalk at: n).		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | changeSet atSelector: sel class: cls put: #add]]].	Smalltalk classNames do:		[:n | cl _ Smalltalk at: n.		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | (messageNames includes: sel) ifTrue:					[changeSet atSelector: sel class: cls put: #add]]]].	Preferences checkForSlips		ifTrue: [Preferences disable: #checkForSlips.				changeSet fileOut.				Preferences enable: #checkForSlips]		ifFalse: [changeSet fileOut].! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 4/6/2001 10:08'!fileOutAndRemove: classesAndMethodsPair retainingRoots: rootClassNames	"classesAndMethodsPair is {set of class names. set of selectors}."	| classNames messageNames changeSet cl |	"First fileOut all classes and methods..."	classNames _ classesAndMethodsPair first.	messageNames _ classesAndMethodsPair second.	changeSet _ ChangeSorter basicNewChangeSet: classNames first, 'EtAl'.	classNames do:		[:n | changeSet addClass: (cl _ Smalltalk at: n).		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | changeSet atSelector: sel class: cls put: #add]]].	Smalltalk classNames do:		[:n | cl _ Smalltalk at: n.		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | (messageNames includes: sel) ifTrue:					[changeSet atSelector: sel class: cls put: #add]]]].	Preferences checkForSlips		ifTrue: [Preferences disable: #checkForSlips.				changeSet fileOut.				Preferences enable: #checkForSlips]		ifFalse: [changeSet fileOut].	"Now remove all classes and methods..."	classNames do:		[:n | changeSet addClass: (cl _ Smalltalk at: n).		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | changeSet atSelector: sel class: cls put: #add]]].	Smalltalk classNames do:		[:n | cl _ Smalltalk at: n.		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | (messageNames includes: sel) ifTrue:					[changeSet atSelector: sel class: cls put: #add]]]].! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 4/6/2001 10:14'!fileOutAndRemove: rootClasses withOtherClasses: otherClasses andOtherMessages: otherMessages	"classesAndMethodsPair is {set of class names. set of selectors}."	| changeSet cl priorChanges |	"First fileOut all classes and methods..."	changeSet _ ChangeSorter basicNewChangeSet:  rootClasses first, 'EtAl'.	rootClasses , otherClasses do:		[:n | changeSet addClass: (cl _ Smalltalk at: n).		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | changeSet atSelector: sel class: cls put: #add]]].	Smalltalk classNames do:		[:n | cl _ Smalltalk at: n.		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | (otherMessages includes: sel) ifTrue:					[changeSet atSelector: sel class: cls put: #add]]]].	Preferences checkForSlips		ifTrue: [Preferences disable: #checkForSlips.				changeSet fileOut.				Preferences enable: #checkForSlips]		ifFalse: [changeSet fileOut].	"Now remove all classes and methods..."	priorChanges _ Smalltalk changes.  "Save current changeSet"	Smalltalk newChanges: changeSet.  "just a place to dump removals"	rootClasses do:		[:n | cl _ Smalltalk at: n.  "Root classes get left, but all methods removed."		{cl. cl class} do:			[:cls | cls zapOrganization.			cls selectors do: [:sel | cls removeSelectorSimply: sel]]].	(ChangeSet superclassOrder: (otherClasses collect: [:n | (Smalltalk at: n)])) reverseDo:		[:cls | cls removeFromSystem].	Smalltalk classNames do:		[:n | cl _ Smalltalk at: n.		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | (otherMessages includes: sel) ifTrue:					[cls removeSelectorSimply: sel]]]].	Smalltalk newChanges: priorChanges.  "Restore current changeSet"	ChangeSorter removeChangeSet: changeSet.	changeSet _ nil.  "Try to avoid registering this as a normal changeSet."	Smalltalk garbageCollect! !!Environment class methodsFor: 'system conversion' stamp: 'di 4/6/2001 09:47'!reorganizeEverything	"Environment reorganizeEverything."	| bigCat envt pool s |	"First check for clashes between environment names and existing globals..."	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			[(Smalltalk includesKey: bigCat) ifTrue:				[^ self error: bigCat , ' cannot be used to nameboth a package and a class or other global variable.No reorganization will be attempted.']]].	(PopUpMenu confirm:'Your image is about to be partitioned into environments.Many things may not work after this, so you should beworking in a throw-away copy of your working image.Are you really ready to procede?(choose ''no'' to stop here safely)')		ifFalse: [^ PopUpMenu notify: 'No changes were made'].	Smalltalk newChanges: (ChangeSet basicNewNamed: 'Reorganization').	"Recreate the Smalltalk dictionary as the top-level Environment."	Smalltalk _ SmalltalkEnvironment newFrom: Smalltalk.	Smalltalk setName: #Smalltalk inOuterEnvt: nil.	"Don't hang onto old copy of Smalltalk ."	Smalltalk recreateSpecialObjectsArray.	Smalltalk allClassesDo:		[:c | c environment: nil. "Flush any old values"].	"Run through all categories making up new sub-environments"	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			["Not a kernel category ..."			envt _ Smalltalk at: bigCat						ifAbsent: ["... make up a new environment if necessary ..."									Smalltalk makeSubEnvironmentNamed: bigCat].			"... and install the member classes in that category"			envt transferBindingsNamedIn: (SystemOrganization listAtCategoryNamed: cat)									from: Smalltalk].		].	"Move all shared pools that are only referred to in sub environments"	Smalltalk associationsDo:		[:assn | ((pool _ assn value) isMemberOf: Dictionary) ifTrue:			[s _ IdentitySet new.			Smalltalk allClassesAnywhereDo:				[:c | c sharedPools do:					[:p | p == pool ifTrue:						[s add: c environment]]].			(s size = 1 and: [(envt _ s someElement) ~~ Smalltalk]) ifTrue:				[envt declare: assn key from: Smalltalk]]].	Smalltalk rewriteIndirectRefs.	Smalltalk newChanges: (ChangeSet basicNewNamed: 'PostReorganization').	ChangeSorter initialize.	Preferences enable: #browserShowsPackagePane.! !ChangeSorter class removeSelector: #removeChangeSetsBefore:!ChangeSet class removeSelector: #newNamed:!