'From Squeak2.9alpha of 12 June 2000 [latest update: #2657] on 18 September 2000 at 4:59:29 pm'!"Change Set:		PDADate:			18 September 2000Author:			Dan IngallsHerewith a simple PDA-style 'organizer' for Squeak.  Execute in Morphic or MVC...	PDAMorph new openInWorld.It gives you a clock, perpetual calendar, and list-based management of people, to-do items, events (including recurring events), and free-form notes.  Each record can be keyed for the purpose of categorization, and any record can be augmented by idiosyncratic fields.  An entire month's schedule can be printed in PostScript."!Model subclass: #PDA	instanceVariableNames: 'userCategories allPeople allEvents recurringEvents allToDoItems allNotes date category currentItem currentItemText currentItemSelection categoryList categoryListIndex peopleList peopleListIndex scheduleList scheduleListIndex toDoList toDoListIndex notesList notesListIndex dateButtonPressed viewDescriptionOnly '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-PDA'!!PDA commentStamp: 'dhhi 9/18/2000 16:49' prior: 0!PDA help text...A lot about the PDA should be obvious just by opening one up and playing with the sample data.  The PDA holds a complete database of people, events, to-do items and notes.  The date and keyword selected determine which records are visible at any given time.All recordsAll records in the database have a number of pre-allocated fields, and these are displayed in the obvious manner in the current item pane at the bottom, when the record is selected.  Care must be taken to enter only valid data as the contents of any field.  This is usually simple but, for instance, matching string quotes can be a problem (embedded string quotes must be doubled).Any item may be augmented by any number of fields, provided that the field names do not conflict with existing ones, and that the contents are valid Squeak objects.The description field may often carry a long body of text so, for this reason, a special feature is provided for viewing only the description of the current item.  This makes it a lot easier to read long notes (like this one), and it saves the user from worrying about matching quotes and other punctuation.  Sorry it's a mode -- use the menu of the bottom pane to switch modes.PeopleSince the name field is not split into first, middle, last as in some databases, you are encouraged to adopt the following format:	Lastname, First I., Jr. (Nickname) (&Spousename)which allows for useful processing for invitations and the like.ToDoItemsToDo items are designed not to be removed, but only to be marked done.  This allows the database to be browsed retroactively, with the to-do items appearing and disappearing on the dates the tasks were conceived and completed respectively.  Note that toDo items have a deadline field whose obvious associated semantics (see alarms) have not yet been implemented.ScheduleScedule items are relatively simple.  It is intended that if duration is specified, and that if time+duration overlaps ensuing events, that the ensuing events will be show in red or someting like that.  Alarms have not yet been implemented, but they will accept an integer field equal to the number of minutes prior to event time that the alarm should appear.  Presumably an alarm will apppear as a new object on the screen that announces the event, sounds a continuing audible sound, and allows easy dismissal by clicking or keystroke.RecurringEventsRecurring events are treated specially.  Each master event is consulted to generate derivative events in the schedule for any given day.  You can edit the derivative events, at which point they will become permanent events just like any other.  An unedited recurring event is a virtual object -- if you edit the master, its derivative copies may disappear from one time and reappear at another.  For this reason it is recommended that you never alter the date of a recurring event.  Instead, declare its last date, causing an end to that series, and create another recurring evenf for the new schedule if desired.  In this manner all the past schedule will continue to appear as it did when it was current. NotesNotes are simple a place to capture thoughts and information relevant to the different areas of your life while you are in the simple planning mood inspired by using a PDA.  The ability to view the current item's description only is especially useful for notes.Spawn Entire MonthWhile this feature (accessible from bottom pane menu) is very crude and does not offer interaction, its real purpose is for printing.  Use the morph menu to choose 'print PS to File...', and then send the resulting .eps file to your printer.  (At the time of this writing portrait and landscpe options were reversed ;-).!!PDA methodsFor: 'initialization' stamp: 'dhhi 9/18/2000 11:39'!initialize	viewDescriptionOnly _ false.	self userCategories: self sampleCategoryList		allPeople: self samplePeopleList		allEvents: self sampleScheduleList		recurringEvents: self sampleRecurringEventsList		allToDoItems: self sampleToDoList		allNotes: self sampleNotes		dateSelected: Date today	! !!PDA methodsFor: 'initialization' stamp: 'dhhi 9/16/2000 17:56'!labelString	| today |	today _ Date today.	^ String streamContents:		[:s | s nextPutAll: today weekday; space.		Time now print24: false showSeconds: false on: s.		s nextPutAll: '  --  '.		s nextPutAll: today monthName; space; print: today dayOfMonth;			nextPutAll: ', '; print: today year]! !!PDA methodsFor: 'initialization' stamp: 'dhhi 9/17/2000 15:29'!loadDatabase	| aName aFileStream list |	aName _ Utilities chooseFileWithSuffixFromList: #('.pda' '.pda.gz')		withCaption: 'Choose a file to load'.	aName ifNil: [^ self].  "User made no choice"	aName == #none ifTrue: [^ self inform: 'Sorry, no suitable files found(names should end with .data or .data.gz)'].	aFileStream _ FileStream oldFileNamed: aName.	list _ aFileStream fileInObjectAndCode.	userCategories _ list at: 1.	allPeople _ list at: 2.	allEvents _ list at: 3.	recurringEvents _ list at: 4.	allToDoItems _ list at: 5.	allNotes _ list at: 6.	date _ Date today.	self selectCategory: 'all'.! !!PDA methodsFor: 'initialization' stamp: 'dhhi 9/17/2000 17:59'!mergeDatabase	| aName aFileStream list |	aName _ Utilities chooseFileWithSuffixFromList: #('.pda' '.pda.gz')		withCaption: 'Choose a file to load'.	aName ifNil: [^ self].  "User made no choice"	aName == #none ifTrue: [^ self inform: 'Sorry, no suitable files found(names should end with .data or .data.gz)'].	aFileStream _ FileStream oldFileNamed: aName.	list _ aFileStream fileInObjectAndCode.	userCategories _ ((list at: 1) , userCategories) asSet asArray sort.	allPeople _ ((list at: 2) , allPeople) asSet asArray sort.	allEvents _ ((list at: 3) , allEvents) asSet asArray sort.	recurringEvents _ ((list at: 4) , recurringEvents) asSet asArray sort.	allToDoItems _ ((list at: 5) , allToDoItems) asSet asArray sort.	allNotes _ ((list at: 6) , allNotes) asSet asArray sort.	date _ Date today.	self selectCategory: 'all'.! !!PDA methodsFor: 'initialization' stamp: 'dhhi 9/18/2000 16:20'!openAsMorphIn: window  "PDA new openAsMorph openInWorld"	"Create a pluggable version of all the morphs for a Browser in Morphic"	| dragNDropFlag paneColor chooser |	window color: Color black.	paneColor _ (Color r: 0.6 g: 1.0 b: 0.0).	window model: self.	dragNDropFlag _ Preferences browseWithDragNDrop.	window addMorph: ((PluggableListMorph on: self list: #peopleListItems			selected: #peopleListIndex changeSelected: #peopleListIndex:			menu: #peopleMenu: keystroke: #peopleListKey:from:) enableDragNDrop: dragNDropFlag)		frame: (0@0 corner: 0.3@0.25).	window addMorph: ((chooser _ PDAChoiceMorph new color: paneColor) contentsClipped: 'all';			target: self; actionSelector: #chooseFrom:categoryItem:; arguments: {chooser};			getItemsSelector: #categoryChoices)		frame: (0@0.25 corner: 0.3@0.3).	window addMorph: (MonthMorph new model: self; color: paneColor; extent: 148@109)		frame: (0.3@0 corner: 0.7@0.3).	window addMorph: (PDAClockMorph new color: paneColor;						faceColor: (Color r: 0.4 g: 0.8 b: 0.6))  "To match monthMorph"		frame: (0.7@0 corner: 1.0@0.3).	window addMorph: ((PluggableListMorph on: self list: #toDoListItems			selected: #toDoListIndex changeSelected: #toDoListIndex:			menu: #toDoMenu: keystroke: #toDoListKey:from:) enableDragNDrop: dragNDropFlag)		frame: (0@0.3 corner: 0.3@0.7).	window addMorph: ((PluggableListMorph on: self list: #scheduleListItems			selected: #scheduleListIndex changeSelected: #scheduleListIndex:			menu: #scheduleMenu: keystroke: #scheduleListKey:from:) enableDragNDrop: dragNDropFlag)		frame: (0.3@0.3 corner: 0.7@0.7).	window addMorph: ((PluggableListMorph on: self list: #notesListItems			selected: #notesListIndex changeSelected: #notesListIndex:			menu: #notesMenu: keystroke: #notesListKey:from:) enableDragNDrop: dragNDropFlag)		frame: (0.7@0.3 corner: 1@0.7).	window addMorph: (PluggableTextMorph on: self			text: #currentItemText accept: #acceptCurrentItemText:			readSelection: #currentItemSelection menu: #currentItemMenu:)		frame: (0@0.7 corner: 1@1).	window firstSubmorph color: paneColor.	window updatePaneColors.	window step.	^ window! !!PDA methodsFor: 'initialization' stamp: 'dhhi 9/18/2000 11:08'!openMonthView	| row month col paneExtent window paneColor nRows |	month _ date notNil		ifTrue: [date month]		ifFalse: ["But... it's here somewhere..."				((self dependents detect: [:m | m isKindOf: PDAMorph])					findA: MonthMorph) month].	window _ SystemWindow labelled: month printString.	paneColor _ Color transparent.	window color: (Color r: 0.968 g: 1.0 b: 0.355).	nRows _ 0.  month eachWeekDo: [:w | nRows _ nRows + 1].	paneExtent _ ((1.0/7) @ (1.0/nRows)).	row _ 0.	month eachWeekDo:		[:week | col _ 0.		week do:			[:day | day month = month ifTrue:				[window addMorph: ((PluggableListMorph on: self list: nil						selected: nil changeSelected: nil menu: nil keystroke: nil)							list: {(day dayOfMonth printString , '  ' , day weekday) asText allBold}								, (self scheduleListForDay: day))					frame: (paneExtent * (col@row) extent: paneExtent)].			col _ col + 1].		row _ row + 1].	window firstSubmorph color: paneColor.	window updatePaneColors.	window openInWorld! !!PDA methodsFor: 'initialization' stamp: 'dhhi 9/17/2000 21:24'!rekeyAllRecordsFrom: oldKey to: newKey	allPeople do: [:r | r rekey: oldKey to: newKey].	allEvents do: [:r | r rekey: oldKey to: newKey].	recurringEvents do: [:r | r rekey: oldKey to: newKey].	allToDoItems do: [:r | r rekey: oldKey to: newKey].	allNotes do: [:r | r rekey: oldKey to: newKey].! !!PDA methodsFor: 'initialization' stamp: 'dhhi 9/17/2000 15:13'!saveDatabase	(FileStream newFileNamed: (FileDirectory default nextNameFor: 'PDA' extension: 'pda'))		fileOutClass: nil		andObject: {userCategories. allPeople. allEvents. recurringEvents. allToDoItems. allNotes}.! !!PDA methodsFor: 'initialization' stamp: 'dhhi 9/17/2000 15:17'!userCategories: cats allPeople: ppl allEvents: evts recurringEvents: recEvts allToDoItems: todo allNotes: notes dateSelected: aDate	userCategories _ cats.	allPeople _ ppl.	allEvents _ evts.	recurringEvents _ recEvts.	allToDoItems _ todo.	allNotes _ notes.		date _ aDate.  "Because updates ahead will need *both* date and category"	self selectCategory: 'all'.	self selectDate: aDate.  "Superfluous, but might not be"! !!PDA methodsFor: 'date' stamp: 'dhhi 9/16/2000 13:27'!selectDate: aDate	date _ aDate.	self updateScheduleList.	self updateToDoList.	self updateCurrentItem.! !!PDA methodsFor: 'date' stamp: 'dhhi 9/17/2000 20:52'!setDate: aDate fromButton: aButton down: down	dateButtonPressed ifNotNil: [dateButtonPressed setSwitchState: false].	down ifTrue: [self selectDate: aDate.				dateButtonPressed _ aButton]		ifFalse: [self selectDate: nil.				dateButtonPressed _ nil].	self currentItem: nil.	aButton ifNotNil: [aButton owner owner step] "ugly hack to restore highlight for today"! !!PDA methodsFor: 'category' stamp: 'dhhi 9/17/2000 21:13'!categoryChoices	"Return a list for the popup chooser"	| special |	special _ {'all'. 'recurring'. nil}.	(special includes: category) ifTrue:		[^ special , userCategories , {nil. 'add new key'}].	^ special , userCategories , {nil. 'remove ' , self categorySelected. 'rename ' , self categorySelected. nil. 'add new key'}! !!PDA methodsFor: 'category' stamp: 'dhhi 9/14/2000 22:46'!categorySelected	^ category ifNil: ['all']! !!PDA methodsFor: 'category' stamp: 'dhhi 9/18/2000 11:30'!chooseFrom: chooserMorph categoryItem: item	| newKey menu |	newKey _ item.	self okToChange ifFalse: [^ self].	(item = 'add new key') ifTrue:		[newKey _ FillInTheBlank request: 'New key to use'						initialAnswer: self categorySelected.		newKey isEmpty ifTrue: [^ self].		(userCategories includes: newKey) ifTrue: [^ self].		userCategories _ (userCategories copyWith: newKey) sort].	(item beginsWith: 'remove ') ifTrue:		[(self confirm: 'Removal of this category will cause all items formerlycategorized as ''' , self categorySelected , ''' to be reclassified as ''all''.Is this really what you want to do?[unless there are very few, choose ''no'']')			ifFalse: [^ self].		self rekeyAllRecordsFrom: self categorySelected to: 'all'.		userCategories _ userCategories copyWithout: self categorySelected.		newKey _ 'all'].	(item beginsWith: 'rename ') ifTrue:		[menu _ CustomMenu new.		userCategories do: [:key | menu add: key action: key].		newKey _ menu startUpWithCaption: 'Please select the new key foritems now categorized as ''' , self categorySelected , '''.'.		newKey ifNil: [^ self].		(self confirm: 'Renaming this category will cause all items formerlycategorized as ''' , self categorySelected , ''' to be reclassified as ''' , newKey , '''.Is this really what you want to do?')			ifFalse: [^ self].		self rekeyAllRecordsFrom: self categorySelected to: newKey.		userCategories _ userCategories copyWithout: self categorySelected].	self selectCategory: newKey.	chooserMorph contentsClipped: newKey! !!PDA methodsFor: 'category' stamp: 'dhhi 9/16/2000 19:14'!selectCategory: cat	category _ cat.	self updateScheduleList.	self updateToDoList.	self updatePeopleList.	self updateNotesList.	currentItem ifNil: [^ self].	(scheduleListIndex + toDoListIndex + peopleListIndex + notesListIndex) = 0 ifTrue:		["Old current item is no longer current (not in any list)"		currentItem _ nil.		self changed: #currentItemText]! !!PDA methodsFor: 'people' stamp: 'dhhi 9/16/2000 13:30'!addPerson	| newPerson |	newPerson _ PDAPerson new key: self categorySelected; name: 'Last, First'.	allPeople _ allPeople copyWith: newPerson.	self currentItem: newPerson.	self updatePeopleList! !!PDA methodsFor: 'people' stamp: 'dhhi 9/13/2000 17:19'!peopleList	"Return the value of peopleList"	^ peopleList! !!PDA methodsFor: 'people' stamp: 'dhhi 9/13/2000 17:19'!peopleListIndex	"Return the value of peopleListIndex"	^ peopleListIndex! !!PDA methodsFor: 'people' stamp: 'dhhi 9/18/2000 11:30'!peopleListIndex: newValue	"Assign newValue to peopleListIndex."	peopleListIndex = newValue ifTrue: [^ self].	self okToChange ifFalse: [^ self].	peopleListIndex _ newValue.	self currentItem: (peopleListIndex ~= 0						ifTrue: [peopleList at: peopleListIndex]						ifFalse: [nil]).	self changed: #peopleListIndex.! !!PDA methodsFor: 'people' stamp: 'dhhi 9/14/2000 09:54'!peopleListItems	^ peopleList collect: [:p | p asListItem]! !!PDA methodsFor: 'people' stamp: 'dhhi 9/16/2000 12:35'!peopleMenu: aMenu	aMenu add: 'add new person' target: self selector: #addPerson.	peopleListIndex > 0 ifTrue:		[aMenu add: 'remove person' target: self selector: #removePerson].	^ aMenu! !!PDA methodsFor: 'people' stamp: 'dhhi 9/16/2000 13:02'!removePerson	allPeople _ allPeople copyWithout: currentItem.	self currentItem: nil.	self updatePeopleList.! !!PDA methodsFor: 'people' stamp: 'dhhi 9/16/2000 08:44'!updatePeopleList	peopleList _ (allPeople select: [:c | c matchesKey: category]) sort.	peopleListIndex _ peopleList indexOf: currentItem.	self changed: #peopleListItems! !!PDA methodsFor: 'schedule' stamp: 'dhhi 9/17/2000 22:23'!addEvent	| newEvent |	category = 'recurring'		ifTrue: [newEvent _ PDARecurringEvent new key: 'all';						firstDate: date; recurrence: #dateOfYear;						description: 'recurring event'.				recurringEvents _ recurringEvents copyWith: newEvent]		ifFalse: [newEvent _ PDAEvent new key: self categorySelected; date: date;						time: (Time readFromString: '7 am');						description: 'new event'.				allEvents _ allEvents copyWith: newEvent].	self currentItem: newEvent.	self updateScheduleList! !!PDA methodsFor: 'schedule' stamp: 'dhhi 9/17/2000 22:37'!declareLastDate	(self confirm: 'Please confirm termination of this event as of' , date printString , '.')		ifFalse: [^ self].	currentItem lastDate: date.	self currentItem: currentItem! !!PDA methodsFor: 'schedule' stamp: 'dhhi 9/17/2000 22:37'!declarelastDate	(self confirm: 'Please confirm termination of this event as of' , date printString , '.')		ifFalse: [^ self].	currentItem lastDate: date.	self currentItem: currentItem! !!PDA methodsFor: 'schedule' stamp: 'dhhi 9/18/2000 16:13'!removeEvent	(currentItem isKindOf: PDARecurringEvent)	ifTrue: [(self confirm:'Rather than remove a recurring event, it isbetter to declare its last day to keep the record.Do you still wish to remove it?')				ifFalse: [^ self].			recurringEvents _ recurringEvents copyWithout: currentItem]	ifFalse: [allEvents _ allEvents copyWithout: currentItem].	self currentItem: nil.	self updateScheduleList.! !!PDA methodsFor: 'schedule' stamp: 'dhhi 9/13/2000 17:19'!scheduleList	"Return the value of scheduleList"	^ scheduleList! !!PDA methodsFor: 'schedule' stamp: 'dhhi 9/18/2000 09:29'!scheduleListForDay: aDate	| dayList |	dayList _ ((allEvents select: [:c | c matchesKey: 'all' andMatchesDate: aDate])			, ((recurringEvents select: [:c | c matchesKey: 'all' andMatchesDate: aDate])					collect: [:re | (re as: PDAEvent) date: aDate])) sort.	^ dayList collect: [:evt | evt asListItem]! !!PDA methodsFor: 'schedule' stamp: 'dhhi 9/13/2000 17:19'!scheduleListIndex	"Return the value of scheduleListIndex"	^ scheduleListIndex! !!PDA methodsFor: 'schedule' stamp: 'dhhi 9/18/2000 11:30'!scheduleListIndex: newValue	"Assign newValue to scheduleListIndex."	scheduleListIndex = newValue ifTrue: [^ self].	self okToChange ifFalse: [^ self].	scheduleListIndex _ newValue.	self currentItem: (scheduleListIndex ~= 0						ifTrue: [scheduleList at: scheduleListIndex]						ifFalse: [nil]).	self changed: #scheduleListIndex.! !!PDA methodsFor: 'schedule' stamp: 'dhhi 9/14/2000 09:55'!scheduleListItems	^ scheduleList collect: [:p | p asListItem]! !!PDA methodsFor: 'schedule' stamp: 'dhhi 9/17/2000 22:28'!scheduleMenu: aMenu	date ifNil: [^ aMenu add: 'select a date' target: self selector: #yourself.].	aMenu add: 'add new event' target: self selector: #addEvent.	scheduleListIndex > 0 ifTrue:		[(currentItem isKindOf: PDARecurringEvent) ifTrue:			[aMenu add: 'declare last date' target: self selector: #declareLastDate].		aMenu add: 'remove event' target: self selector: #removeEvent].	^ aMenu! !!PDA methodsFor: 'schedule' stamp: 'dhhi 9/18/2000 16:09'!updateScheduleList	(date == nil and: [category ~= 'recurring']) ifTrue:		[scheduleList _ Array new.  scheduleListIndex _ 0.		^ self changed: #scheduleListItems].	category = 'recurring'	ifTrue: ["When 'recurring' is selected, edit actual masters"			scheduleList _ (recurringEvents select:				[:c | c matchesKey: category andMatchesDate: date]) sort]	ifFalse: ["Otherwise, recurring events just spawn copies."			scheduleList _ ((allEvents select: [:c | c matchesKey: category andMatchesDate: date])			, ((recurringEvents select: [:c | c matchesKey: category andMatchesDate: date])					collect: [:re | (re as: PDAEvent) date: date])) sort].	scheduleListIndex _ scheduleList indexOf: currentItem.	self changed: #scheduleListItems! !!PDA methodsFor: 'to do' stamp: 'dhhi 9/16/2000 13:40'!addToDoItem	| newToDoItem |	newToDoItem _ PDAToDoItem new key: self categorySelected; description: 'new item to do';					dayPosted: Date today; priority: 1.	allToDoItems _ allToDoItems copyWith: newToDoItem.	self currentItem: newToDoItem.	self updateToDoList! !!PDA methodsFor: 'to do' stamp: 'dhhi 9/17/2000 22:36'!declareItemDone	| report |	report _ FillInTheBlank request:'This item will be declared done as of' , date printString , '.Please give a short summary of status'		initialAnswer: 'Completed.'.	(report == nil or: [report isEmpty]) ifTrue: [^ self].	currentItem dayDone: date;			result: report.	self currentItem: currentItem! !!PDA methodsFor: 'to do' stamp: 'dhhi 9/17/2000 22:04'!removeToDoItem	(self confirm: 'Rather than remove an item, it isbetter to declare it done with a reason such as''gave up'', or ''not worth it'', to keep the record.Do you still wish to remove it?')		ifFalse: [^ self].	allToDoItems _ allToDoItems copyWithout: currentItem.	self currentItem: nil.	self updateToDoList.! !!PDA methodsFor: 'to do' stamp: 'dhhi 9/13/2000 17:19'!toDoList	"Return the value of toDoList"	^ toDoList! !!PDA methodsFor: 'to do' stamp: 'dhhi 9/13/2000 17:19'!toDoListIndex	"Return the value of toDoListIndex"	^ toDoListIndex! !!PDA methodsFor: 'to do' stamp: 'dhhi 9/18/2000 11:31'!toDoListIndex: newValue	"Assign newValue to toDoListIndex."	toDoListIndex = newValue ifTrue: [^ self].	self okToChange ifFalse: [^ self].	toDoListIndex _ newValue.	self currentItem: (toDoListIndex ~= 0						ifTrue: [toDoList at: toDoListIndex]						ifFalse: [nil]).	self changed: #toDoListIndex.! !!PDA methodsFor: 'to do' stamp: 'dhhi 9/14/2000 09:55'!toDoListItems	^ toDoList collect: [:p | p asListItem]! !!PDA methodsFor: 'to do' stamp: 'dhhi 9/17/2000 22:06'!toDoMenu: aMenu	date ifNil: [^ aMenu add: 'select a date' target: self selector: #yourself.].	aMenu add: 'add new item' target: self selector: #addToDoItem.	toDoListIndex > 0 ifTrue:		[aMenu add: 'declare item done' target: self selector: #declareItemDone.		aMenu add: 'remove item' target: self selector: #removeToDoItem].	^ aMenu! !!PDA methodsFor: 'to do' stamp: 'dhhi 9/17/2000 20:23'!updateToDoList	date ifNil:		[toDoList _ Array new. toDoListIndex _ 0.		^ self changed: #toDoListItems].	toDoList _ (allToDoItems select: [:c | c matchesKey: category andMatchesDate: date]) sort.	toDoListIndex _ toDoList indexOf: currentItem.	self changed: #toDoListItems! !!PDA methodsFor: 'notes' stamp: 'dhhi 9/16/2000 13:38'!addNote	| newNote |	newNote _ PDARecord new key: self categorySelected; description: 'new note'.	allNotes _ allNotes copyWith: newNote.	self currentItem: newNote.	self updateNotesList! !!PDA methodsFor: 'notes' stamp: 'dhhi 9/14/2000 22:55'!notesList	"Return the value of notesList"	^ notesList! !!PDA methodsFor: 'notes' stamp: 'dhhi 9/14/2000 22:55'!notesListIndex	"Return the value of notesListIndex"	^ notesListIndex! !!PDA methodsFor: 'notes' stamp: 'dhhi 9/18/2000 11:31'!notesListIndex: newValue	"Assign newValue to notesListIndex."	notesListIndex = newValue ifTrue: [^ self].	self okToChange ifFalse: [^ self].	notesListIndex _ newValue.	self currentItem: (notesListIndex ~= 0						ifTrue: [notesList at: notesListIndex]						ifFalse: [nil]).	self changed: #notesListIndex.! !!PDA methodsFor: 'notes' stamp: 'dhhi 9/14/2000 22:56'!notesListItems	^ notesList collect: [:p | p asListItem]! !!PDA methodsFor: 'notes' stamp: 'dhhi 9/16/2000 13:40'!notesMenu: aMenu	aMenu add: 'add new note' target: self selector: #addNote.	toDoListIndex > 0 ifTrue:		[aMenu add: 'remove note' target: self selector: #removeNote].	^ aMenu! !!PDA methodsFor: 'notes' stamp: 'dhhi 9/16/2000 13:39'!removeNote	allNotes _ allNotes copyWithout: currentItem.	self currentItem: nil.	self updateNotesList.! !!PDA methodsFor: 'notes' stamp: 'dhhi 9/16/2000 08:54'!updateNotesList	notesList _ (allNotes select: [:c | c matchesKey: self categorySelected]) sort.	self notesListIndex: (notesList indexOf: currentItem).	self changed: #notesListItems! !!PDA methodsFor: 'currentItem' stamp: 'dhhi 9/18/2000 11:48'!acceptCurrentItemText: aText	currentItem ifNil:		[PopUpMenu notify: 'Can''t accept -- no item is selected'. ^ false].	viewDescriptionOnly ifTrue:		[currentItem description: aText string. ^ true].	currentItem readFrom: aText.	(currentItem isKindOf: PDAEvent) ifTrue: [self updateScheduleList].	(currentItem isMemberOf: PDAToDoItem) ifTrue: [self updateToDoList].	(currentItem isMemberOf: PDAPerson) ifTrue: [self updatePeopleList].	(currentItem isMemberOf: PDARecord) ifTrue: [self updateNotesList].	^ true! !!PDA methodsFor: 'currentItem' stamp: 'dhhi 9/18/2000 11:36'!clearUserEditFlag	"Clear the hasUnacceptedEdits flag in all my dependent views."	self changed: #clearUserEdits! !!PDA methodsFor: 'currentItem' stamp: 'dhhi 9/14/2000 10:09'!currentItem	"Return the value of currentItem"	currentItem ifNil: [^ 'No item is selected.'].	^ currentItem! !!PDA methodsFor: 'currentItem' stamp: 'dhhi 9/16/2000 09:03'!currentItem: newValue	"Assign newValue to currentItem."	currentItem class == newValue class ifFalse:		["get rid of this hideous hack"		(currentItem isMemberOf: PDAEvent) ifTrue: [self scheduleListIndex: 0].		(currentItem isMemberOf: PDAToDoItem) ifTrue: [self toDoListIndex: 0].		(currentItem isMemberOf: PDAPerson) ifTrue: [self peopleListIndex: 0].		(currentItem isMemberOf: PDARecord) ifTrue: [self notesListIndex: 0]].	currentItem _ newValue.	self changed: #currentItemText! !!PDA methodsFor: 'currentItem' stamp: 'dhhi 9/18/2000 11:56'!currentItemMenu: aMenu	aMenu add: 'save database' target: self selector: #saveDatabase.	aMenu add: 'load database from file...' target: self selector: #loadDatabase.	aMenu add: 'spawn entire month' target: self selector: #openMonthView.	viewDescriptionOnly		ifTrue: [aMenu add: 'view entire records' target: self selector: #toggleDescriptionMode]		ifFalse: [aMenu add: 'view descriptions only' target: self selector: #toggleDescriptionMode].	aMenu addLine.	aMenu add: 'inspect database' target: self selector: #inspect.	^ aMenu! !!PDA methodsFor: 'currentItem' stamp: 'dhhi 9/14/2000 10:09'!currentItemSelection	"Return the value of currentItemSelection"	currentItemSelection ifNil: [^ 1 to: 0].	^ currentItemSelection! !!PDA methodsFor: 'currentItem' stamp: 'dhhi 9/13/2000 17:19'!currentItemSelection: newValue	"Assign newValue to currentItemSelection."	currentItemSelection _ newValue.! !!PDA methodsFor: 'currentItem' stamp: 'dhhi 9/18/2000 11:51'!currentItemText	currentItem ifNil: [^ 'no item is selected'].	viewDescriptionOnly		ifTrue: [currentItem description ifNil:					[^ 'No description has yet been entered for this item'].				^ currentItem description asText]		ifFalse: [^ currentItem asText]! !!PDA methodsFor: 'currentItem' stamp: 'dhhi 9/18/2000 11:28'!okToChange	self canDiscardEdits ifTrue: [^ true].	self changed: #wantToChange.  "Solicit cancel from view"	^ self canDiscardEdits! !!PDA methodsFor: 'currentItem' stamp: 'dhhi 9/18/2000 11:42'!toggleDescriptionMode	self okToChange ifFalse: [^ self].	viewDescriptionOnly _ viewDescriptionOnly not.	self changed: #currentItemText! !!PDA methodsFor: 'currentItem' stamp: 'dhhi 9/16/2000 13:29'!updateCurrentItem	(peopleList includes: currentItem) ifTrue: [^ self].	(scheduleList includes: currentItem) ifTrue: [^ self].	(toDoList includes: currentItem) ifTrue: [^ self].	(notesList includes: currentItem) ifTrue: [^ self].	self currentItem: nil! !!PDA methodsFor: 'example' stamp: 'dhhi 9/17/2000 15:26'!sampleCategoryList	^ { 'home'. 'work'. 'services' }! !!PDA methodsFor: 'example' stamp: 'dhhi 9/18/2000 16:41'!sampleNotes	^ {	PDARecord new key: 'home'; description: 'sprinkler schedule'.	PDARecord new key: 'home'; description: 'directions to our houseTake the expressway, #93 southThen south on Rte 24East at the T with 195Take exit 12 and go right to Faunce CornerCross rte 6, continue on Old Westport Rdtakes a bend left and becomes Chase RdContinue for 3.5-4 miRt at T intersection on Russell Mills RdPass DPW on leftLg Yellow bldg Davall''s storeleft on Rocko Dundee Rddown a swail and up.  We''re #419 on the left'.	PDARecord new key: 'work'; description: 'archaeology memo'.	PDARecord new key: 'work'; description: 'worlds and envts memo'.	PDARecord new key: 'work'; description: PDA comment string.	}! !!PDA methodsFor: 'example' stamp: 'dhhi 9/18/2000 16:06'!samplePeopleList	^ {	PDAPerson new key: 'work'; name: 'Carson, Kit (&Lilly)'; phone: '888-555-1234'; email: 'Kit.Carson@Cosmo.com'.	PDAPerson new key: 'work'; name: 'Kidd, William (Billy)'; phone: '888-555-1234'; email: 'William.Kidd@Cosmo.com'.	PDAPerson new key: 'services'; name: 'Dewey, Cheatham & Howe'; phone: '888-555-1234'; email: 'AndHow@Cosmo.com'.	PDAPerson new key: 'home'; name: 'Duck, Donald'; phone: '888-555-1234'; email: 'Donald.Duck@Cosmo.com'.	PDAPerson new key: 'home'; name: 'Duck, Huey'; phone: '888-555-1234'; email: 'Huey.Duck@Cosmo.com'.	PDAPerson new key: 'home'; name: 'Duck, Dewey'; phone: '888-555-1234'; email: 'Dewey.Duck@Cosmo.com'.	PDAPerson new key: 'home'; name: 'Duck, Louie'; phone: '888-555-1234'; email: 'Louie.Duck@Cosmo.com'.	}! !!PDA methodsFor: 'example' stamp: 'dhhi 9/17/2000 14:19'!sampleRecurringEventsList	^ {	PDARecurringEvent new key: 'home'; description: 'take out trash'; recurrence: #dayOfWeek; firstDate: (Date readFromString: '7 September 1999').	PDARecurringEvent new key: 'home'; description: 'pay bills'; recurrence: #dayOfMonth; firstDate: (Date readFromString: '1 September 1999').	PDARecurringEvent new key: 'all'; description: 'Columbus Day'; recurrence: #dateOfYear; firstDate: (Date readFromString: '12 October 1999').	PDARecurringEvent new key: 'all'; description: 'Christmas'; recurrence: #dateOfYear; firstDate: (Date readFromString: '25 December 1999').	PDARecurringEvent new key: 'all'; description: 'New Years'; recurrence: #dateOfYear; firstDate: (Date readFromString: '1 January 1999').	PDARecurringEvent new key: 'all'; description: 'April Fools Day'; recurrence: #dateOfYear; firstDate: (Date readFromString: '1 April 1999').	PDARecurringEvent new key: 'all'; description: 'Independence Day'; recurrence: #dateOfYear; firstDate: (Date readFromString: '4 July 1999').	PDARecurringEvent new key: 'all'; description: 'Thanksgiving Day'; recurrence: #nthWeekdayOfMonthEachYear; firstDate: (Date readFromString: '25 November 1999').	}! !!PDA methodsFor: 'example' stamp: 'dhhi 9/18/2000 16:02'!sampleScheduleList	^ {	PDAEvent new key: 'home'; date: Date today; description: 'wake up'; time: (Time new hours: 6).	PDAEvent new key: 'home'; date: Date today; description: 'go for a run'; time: (Time new hours: 7).	PDAEvent new key: 'home'; date: Date today; description: 'take a shower'; time: (Time new hours: 8).	PDAEvent new key: 'home'; date: (Date today addDays: 2); description: 'dinner out'; time: (Time new hours: 18).	PDAEvent new key: 'work'; date: (Date today addDays: 1); description: 'conf call'; time: (Time new hours: 10).	PDAEvent new key: 'work'; date: (Date today addDays: 2); description: 'Leave for Conference'; time: (Time new hours: 8).	PDAEvent new key: 'work'; date: Date today; description: 'call Boss'; time: (Time new hours: 15).	PDAEvent new key: 'work'; date: Date today; description: 'Call about 401k'; time: (Time new hours: 10).	}! !!PDA methodsFor: 'example' stamp: 'dhhi 9/18/2000 16:05'!sampleToDoList	^ {	PDAToDoItem new key: 'work'; dayPosted: (Date today subtractDays: 3); description: 'release external updates'; priority: 2.	PDAToDoItem new key: 'work'; dayPosted: (Date today subtractDays: 3); description: 'first pass of sMovie'; priority: 1.	PDAToDoItem new key: 'work'; dayPosted: (Date today subtractDays: 2); description: 'first pass of PDA'; priority: 2.	PDAToDoItem new key: 'work'; dayPosted: (Date today subtractDays: 2); description: 'changes for finite undo'; priority: 2.	PDAToDoItem new key: 'work'; dayPosted: (Date today subtractDays: 1); description: 'Msg to Freeman Zork'; priority: 1.	PDAToDoItem new key: 'home'; dayPosted: (Date today subtractDays: 1); description: 'Fix fridge'; priority: 1.	PDAToDoItem new key: 'home'; dayPosted: (Date today subtractDays: 3); description: 'Fix roof'; priority: 3.	PDAToDoItem new key: 'home'; dayPosted: (Date today subtractDays: 3); description: 'Call about driveway'; priority: 4.	}! !!PDA methodsFor: 'menus' stamp: 'dhhi 9/16/2000 12:23'!perform: selector orSendTo: otherTarget	"This should be the default in Object"	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PDA class	instanceVariableNames: ''!!PDA class methodsFor: 'as yet unclassified' stamp: 'dhhi 9/13/2000 17:19'!zork  "PDA withAllSubclassesDo: [:c | c zork]"	self instVarNames do: [:varName |	self compile: ('&var	"Return the value of &var"	^ &var'			copyReplaceAll: '&var' with: varName)		classified: 'public access' notifying: nil.	self compile: ('&var: newValue	"Assign newValue to &var."	&var _ newValue.'			copyReplaceAll: '&var' with: varName)		classified: 'public access' notifying: nil.	]! !PopUpChoiceMorph subclass: #PDAChoiceMorph	instanceVariableNames: 'backgroundColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-PDA'!!PDAChoiceMorph methodsFor: 'as yet unclassified' stamp: 'dhhi 9/16/2000 18:05'!color	^ backgroundColor! !!PDAChoiceMorph methodsFor: 'as yet unclassified' stamp: 'dhhi 9/16/2000 18:10'!color: aColor	backgroundColor _ aColor.	self changed! !!PDAChoiceMorph methodsFor: 'as yet unclassified' stamp: 'dhhi 9/16/2000 18:07'!drawOn: aCanvas	| offset |	offset _ 4@(bounds height - self fontToUse height // 2).	aCanvas frameAndFillRectangle: bounds fillColor: backgroundColor			borderWidth: 1 borderColor: Color black.	aCanvas text: contents			bounds: ((bounds translateBy: offset) intersect: bounds)			font: self fontToUse color: Color black.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PDAChoiceMorph class	instanceVariableNames: ''!!PDAChoiceMorph class methodsFor: 'as yet unclassified' stamp: 'dhhi 9/18/2000 15:16'!includeInNewMorphMenu	^ false! !WatchMorph subclass: #PDAClockMorph	instanceVariableNames: 'backgroundColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-PDA'!!PDAClockMorph methodsFor: 'as yet unclassified' stamp: 'dhhi 9/16/2000 18:18'!color	^ backgroundColor! !!PDAClockMorph methodsFor: 'as yet unclassified' stamp: 'dhhi 9/16/2000 18:19'!color: aColor	backgroundColor _ aColor.	self changed! !!PDAClockMorph methodsFor: 'as yet unclassified' stamp: 'dhhi 9/16/2000 18:20'!drawOn: aCanvas	aCanvas frameAndFillRectangle: bounds fillColor: backgroundColor				borderWidth: 1 borderColor: borderColor.	super drawOn: aCanvas.! !!PDAClockMorph methodsFor: 'as yet unclassified' stamp: 'dhhi 9/16/2000 18:18'!faceColor: aColor	super color: aColor! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PDAClockMorph class	instanceVariableNames: ''!!PDAClockMorph class methodsFor: 'as yet unclassified' stamp: 'dhhi 9/18/2000 15:17'!includeInNewMorphMenu	^ false! !SystemWindow subclass: #PDAMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-PDA'!!PDAMorph methodsFor: 'as yet unclassified' stamp: 'dhhi 9/18/2000 15:53'!initialize	super initialize.	color _ Color lightGray.	self extent: 406 @ 408.	PDA new initialize openAsMorphIn: self.! !!PDAMorph methodsFor: 'as yet unclassified' stamp: 'dhhi 9/15/2000 00:16'!stepAt: millisecondsIgnored	self setLabel: model labelString! !!PDAMorph methodsFor: 'as yet unclassified' stamp: 'dhhi 9/15/2000 00:13'!stepTime	^ (60 - Time now seconds + 1) * 1000! !!PDAMorph methodsFor: 'as yet unclassified' stamp: 'di 9/10/2000 11:31'!wantsSteps	^ true  "collapsed or not"! !Object subclass: #PDARecord	instanceVariableNames: 'key description otherFields '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-PDA'!!PDARecord methodsFor: 'key' stamp: 'dhhi 9/13/2000 17:39'!key	"Return the value of key"	^ key! !!PDARecord methodsFor: 'key' stamp: 'dhhi 9/13/2000 17:39'!key: newValue	"Assign newValue to key."	key _ newValue.! !!PDARecord methodsFor: 'key' stamp: 'dhhi 9/16/2000 09:06'!matchesKey: aString	key ifNil: [^ true].  "unkeyed items show up as 'all' "	(aString = 'all' or: [key = 'all']) ifTrue: [^ true].	^ key = aString! !!PDARecord methodsFor: 'key' stamp: 'dhhi 9/17/2000 15:41'!matchesKey: aString andMatchesDate: aDate	"May be overridden for efficiency"	^ (self matchesKey: aString) and: [self matchesDate: aDate]! !!PDARecord methodsFor: 'key' stamp: 'dhhi 9/17/2000 21:25'!rekey: oldKey to: newKey	key = oldKey ifTrue: [key _ newKey]! !!PDARecord methodsFor: 'description' stamp: 'dhhi 9/13/2000 17:39'!description	"Return the value of description"	^ description! !!PDARecord methodsFor: 'description' stamp: 'dhhi 9/13/2000 17:39'!description: newValue	"Assign newValue to description."	description _ newValue.! !!PDARecord methodsFor: 'other fields' stamp: 'dhhi 9/13/2000 17:39'!otherFields	"Return the value of otherFields"	^ otherFields! !!PDARecord methodsFor: 'other fields' stamp: 'dhhi 9/13/2000 17:39'!otherFields: newValue	"Assign newValue to otherFields."	otherFields _ newValue.! !!PDARecord methodsFor: 'comparing' stamp: 'dhhi 9/15/2000 09:58'!<= other	^ (description compare: other description) <= 2  "Case-insensitive"! !!PDARecord methodsFor: 'as text' stamp: 'dhhi 9/15/2000 10:52'!allFieldsWithValuesDo: nameValueBlock	self sharedFieldsWithValuesDo: nameValueBlock.	otherFields ifNotNil:		[otherFields associationsDo:			[:assn | nameValueBlock value: assn key value: assn value]]! !!PDARecord methodsFor: 'as text' stamp: 'dhhi 9/18/2000 09:16'!asListItem	^ description copyUpTo: Character cr! !!PDARecord methodsFor: 'as text' stamp: 'dhhi 9/16/2000 19:06'!asText	^ String streamContents:		[:s | self allFieldsWithValuesDo:			[:field :value | s nextPutAll: field; nextPutAll: ': '; store: value; cr]]! !!PDARecord methodsFor: 'as text' stamp: 'dhhi 9/17/2000 08:22'!printOn: aStream	super printOn: aStream.	aStream space; nextPutAll: self asListItem! !!PDARecord methodsFor: 'as text' stamp: 'dhhi 9/16/2000 08:31'!readField: fieldName fromString: aString fields: sharedFields base: instVarBase	"This message should be overridden in subclasses to recognize the types for the various fields.  If a fieldName is not recognized below, super will invoke this method at the end."	(sharedFields includes: fieldName) ifTrue:		[^ self instVarAt: instVarBase + (sharedFields indexOf: fieldName)				put: (Compiler evaluate: aString)].	otherFields ifNil: [otherFields _ Dictionary new].	otherFields at: fieldName put: (Compiler evaluate: aString)! !!PDARecord methodsFor: 'as text' stamp: 'dhhi 9/15/2000 16:41'!readFrom: aText 	| s line label buffer bufferField |	self sharedFieldsWithBaseDo:		[:fields :instVarBase |		s _ ReadStream on: aText asString.		buffer _ WriteStream on: (String new: 500).		bufferField _ nil.		[s atEnd] whileFalse:			[line _ s nextLine.			((label _ line copyUpTo: $ ) endsWith: ':')			ifTrue:				[buffer isEmpty ifFalse:					[self readField: bufferField						fromString: buffer contents						fields: fields base: instVarBase.					buffer reset].				bufferField _ label allButLast.				buffer nextPutAll: (line allButFirst: label size + 1)]			ifFalse:				[buffer cr; nextPutAll: line]].		buffer isEmpty ifFalse:			[self readField: bufferField				fromString: buffer contents				fields: fields base: instVarBase].	]! !!PDARecord methodsFor: 'as text' stamp: 'dhhi 9/15/2000 15:29'!sharedFieldsWithBaseDo: fieldsAndBaseBlock	| fields base |	fields _ self class allInstVarNames allButFirst: (base _ PDARecord superclass instSize).	fieldsAndBaseBlock value: fields value: base! !!PDARecord methodsFor: 'as text' stamp: 'dhhi 9/15/2000 15:31'!sharedFieldsWithValuesDo: nameValueBlock	self sharedFieldsWithBaseDo:		[:fields :instVarBase |		fields withIndexDo:			[:field :i | field = 'otherFields' ifFalse:				[nameValueBlock value: field value: (self instVarAt: instVarBase + i)]]]! !PDARecord subclass: #PDAEvent	instanceVariableNames: 'date time duration alarm '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-PDA'!!PDAEvent methodsFor: 'date' stamp: 'dhhi 9/13/2000 17:21'!date	"Return the value of date"	^ date! !!PDAEvent methodsFor: 'date' stamp: 'dhhi 9/13/2000 17:21'!date: newValue	"Assign newValue to date."	date _ newValue.! !!PDAEvent methodsFor: 'date' stamp: 'dhhi 9/14/2000 09:23'!matchesDate: aDate	^ date = aDate! !!PDAEvent methodsFor: 'time' stamp: 'dhhi 9/17/2000 20:34'!asListItem	| timeString ampm |	time ifNil: [^ '-- ' , (description copyUpTo: Character cr) , ' --'].	timeString _ time printString.	ampm _ timeString last: 2.	^ (timeString allButLast: 3) , ampm , '  ' , (description copyUpTo: Character cr)! !!PDAEvent methodsFor: 'time' stamp: 'dhhi 9/13/2000 17:21'!time	"Return the value of time"	^ time! !!PDAEvent methodsFor: 'time' stamp: 'dhhi 9/16/2000 13:13'!time: newValue	"Assign newValue to time."	time _ newValue! !!PDAEvent methodsFor: 'duration' stamp: 'dhhi 9/13/2000 17:21'!duration	"Return the value of duration"	^ duration! !!PDAEvent methodsFor: 'duration' stamp: 'dhhi 9/13/2000 17:21'!duration: newValue	"Assign newValue to duration."	duration _ newValue.! !!PDAEvent methodsFor: 'comparing' stamp: 'dhhi 9/17/2000 09:54'!<= other	date = other date ifFalse: [^ date < other date].	time == nil ifTrue: [^ true].	other time == nil ifTrue: [^ false].	^ time <= other time! !PDARecord subclass: #PDAPerson	instanceVariableNames: 'name address phone email '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-PDA'!!PDAPerson methodsFor: 'comparing' stamp: 'dhhi 9/15/2000 10:14'!<= other	^ name <= other name! !!PDAPerson methodsFor: 'public access' stamp: 'dhhi 9/13/2000 17:21'!address	"Return the value of address"	^ address! !!PDAPerson methodsFor: 'public access' stamp: 'dhhi 9/13/2000 17:21'!address: newValue	"Assign newValue to address."	address _ newValue.! !!PDAPerson methodsFor: 'public access' stamp: 'dhhi 9/14/2000 09:57'!asListItem	^ name! !!PDAPerson methodsFor: 'public access' stamp: 'dhhi 9/13/2000 17:21'!email	"Return the value of email"	^ email! !!PDAPerson methodsFor: 'public access' stamp: 'dhhi 9/13/2000 17:21'!email: newValue	"Assign newValue to email."	email _ newValue.! !!PDAPerson methodsFor: 'public access' stamp: 'dhhi 9/13/2000 17:21'!name	"Return the value of name"	^ name! !!PDAPerson methodsFor: 'public access' stamp: 'dhhi 9/13/2000 17:21'!name: newValue	"Assign newValue to name."	name _ newValue.! !!PDAPerson methodsFor: 'public access' stamp: 'dhhi 9/13/2000 17:21'!phone	"Return the value of phone"	^ phone! !!PDAPerson methodsFor: 'public access' stamp: 'dhhi 9/13/2000 17:21'!phone: newValue	"Assign newValue to phone."	phone _ newValue.! !PDAEvent subclass: #PDARecurringEvent	instanceVariableNames: 'recurrence firstDate lastDate '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-PDA'!!PDARecurringEvent methodsFor: 'as yet unclassified' stamp: 'dhhi 9/17/2000 09:31'!firstDate: aDate	firstDate _ aDate! !!PDARecurringEvent methodsFor: 'as yet unclassified' stamp: 'dhhi 9/17/2000 09:32'!lastDate: aDate	lastDate _ aDate! !!PDARecurringEvent methodsFor: 'as yet unclassified' stamp: 'dhhi 9/17/2000 23:37'!matchesDate: aDate	(firstDate == nil or: [firstDate > aDate]) ifTrue: [^ false].	(lastDate ~~ nil and: [lastDate < aDate]) ifTrue: [^ false].	recurrence == #dayOfWeek ifTrue:		[^ aDate weekday = firstDate weekday].	recurrence == #dayOfMonth ifTrue:		[^ aDate dayOfMonth = firstDate dayOfMonth].	recurrence == #dateOfYear ifTrue:		[^ aDate monthIndex = firstDate monthIndex			and: [aDate dayOfMonth = firstDate dayOfMonth]].	recurrence == #nthWeekdayOfMonth ifTrue:		[^ aDate weekday = firstDate weekday			and: [(aDate dayOfMonth - 1 // 7) = (firstDate dayOfMonth - 1 // 7)]].	recurrence == #nthWeekdayOfMonthEachYear ifTrue:		[^ aDate monthIndex = firstDate monthIndex			and: [aDate weekday = firstDate weekday			and: [(aDate dayOfMonth - 1 // 7) = (firstDate dayOfMonth - 1 // 7)]]].	! !!PDARecurringEvent methodsFor: 'as yet unclassified' stamp: 'dhhi 9/17/2000 15:46'!matchesKey: aString andMatchesDate: aDate	aString = 'recurring' ifTrue: [^ true].	^ super matchesKey: aString andMatchesDate: aDate! !!PDARecurringEvent methodsFor: 'as yet unclassified' stamp: 'dhhi 9/17/2000 09:30'!recurrence: rSymbol	(#(dayOfWeek dayOfMonth dateOfYear nthWeekdayOfMonth) includes: rSymbol)		ifFalse: [^ self error: 'only #dayOfWeek #dayOfMonth #dateOfYear #nthWeekdayOfMonth are valid'].	recurrence _ rSymbol! !!PDARecurringEvent methodsFor: 'as yet unclassified' stamp: 'dhhi 9/17/2000 09:31'!startDate: aDate	| startDate |	startDate _ aDate! !PDARecord subclass: #PDAToDoItem	instanceVariableNames: 'dayPosted dayDone priority deadline result '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-PDA'!!PDAToDoItem methodsFor: 'day posted' stamp: 'dhhi 9/13/2000 17:21'!dayPosted	"Return the value of dayPosted"	^ dayPosted! !!PDAToDoItem methodsFor: 'day posted' stamp: 'dhhi 9/13/2000 17:21'!dayPosted: newValue	"Assign newValue to dayPosted."	dayPosted _ newValue.! !!PDAToDoItem methodsFor: 'day posted' stamp: 'dhhi 9/14/2000 09:32'!matchesDate: aDate	dayPosted > aDate ifTrue: [^ false].	dayDone ifNil: [^ true].	^ dayDone >= aDate! !!PDAToDoItem methodsFor: 'day done' stamp: 'dhhi 9/13/2000 17:21'!dayDone	"Return the value of dayDone"	^ dayDone! !!PDAToDoItem methodsFor: 'day done' stamp: 'dhhi 9/13/2000 17:21'!dayDone: newValue	"Assign newValue to dayDone."	dayDone _ newValue.! !!PDAToDoItem methodsFor: 'deadline' stamp: 'dhhi 9/13/2000 17:21'!deadline	"Return the value of deadline"	^ deadline! !!PDAToDoItem methodsFor: 'deadline' stamp: 'dhhi 9/13/2000 17:21'!deadline: newValue	"Assign newValue to deadline."	deadline _ newValue.! !!PDAToDoItem methodsFor: 'priority' stamp: 'dhhi 9/13/2000 17:21'!priority	"Return the value of priority"	^ priority! !!PDAToDoItem methodsFor: 'priority' stamp: 'dhhi 9/13/2000 17:21'!priority: newValue	"Assign newValue to priority."	priority _ newValue.! !!PDAToDoItem methodsFor: 'result' stamp: 'dhhi 9/13/2000 17:21'!result	"Return the value of result"	^ result! !!PDAToDoItem methodsFor: 'result' stamp: 'dhhi 9/13/2000 17:21'!result: newValue	"Assign newValue to result."	result _ newValue.! !!PDAToDoItem methodsFor: 'description' stamp: 'dhhi 9/14/2000 23:27'!asListItem	^ (priority ifNil: [0]) printString , ' ' , super asListItem! !!PDAToDoItem methodsFor: 'comparing' stamp: 'dhhi 9/15/2000 10:12'!<= other	priority = other priority ifFalse: [^ priority < other priority].	^ super <= other! !