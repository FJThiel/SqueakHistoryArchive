'From Squeak2.8alpha of 12 January 2000 [latest update: #1980] on 4 April 2000 at 1:41:46 pm'!"Change Set:		ModularProjects11Date:			4 April 2000Author:			Dan IngallsA number of fixes to the various ChangeSet editing operations supported in the ChangeSorter."!!ChangeSet commentStamp: 'di 4/4/2000 13:41' prior: 0!ChangeSets keep track of the changes made to a system, so they can be written on a file as source code (a "fileOut").  Every project has an associated changeSet.  For simple projects, a different changeSet may be designated to capture changes at any time.This implementation of ChangeSet is capable of remembering and manipulating methods for which the classes are not present in the system.  However at the present time, this capability is not used in normal rearranging and fileOuts, but only for invoking and revoking associated with isolation layers.For isolated projects (see Project class comment), the changeSet binding is semi-permanent.  Every project exists in an isolation layer defined by its closest enclosing parent (or itself) that is isolated.  If a project is not isolated, then changes reported to its designated changeSet must also be reported to the permanent changeSet for that layer, designated in the isolated project.  This ensures that that outer project will be able to revert all changes upon exit.Note that only certain changes may be reverted.  Classes may not be added, removed, renamed or reshaped except in the layer in which they are defined because these operations on non-local classes are not revertable.If a Squeak Project is established as being isolated, then its associated changeSet will be declared to be revertable.  In this case all changes stored can be reverted.  The changeSet associated with an isolated project is tied to that project, and cannot be edited in a changeSorter.------name - a String used to name the changeSet, and thus any associated project or fileOut.preamble and postscript:  two strings that serve as prefix (useful for documentation) and suffix (useful for doits) to the fileout of the changeSet.revertable - a BooleanIf this variable is true, then all of the changes recorded by this changeSet can be reverted.isolationSet - a ChangeSet or nilThe isolationSet is the designated changeSet for an isolation layer.  If this changeSet is an isolationSet, then this variable will be nil.  If not, then it points to the isolationSet for this layer, and all changes reported here will also be reported to the isolationSet.isolatedProject - a Project or nilIf this is an isolationSet, then this variable points to the project with which it is associated.changeRecords -  Dictionary {class name -> a ClassChangeRecord}.These classChangeRecords (qv) remember all of the system changes.structures -    Dictionary {#Rectangle -> #(<classVersionInteger> 'origin' 'corner')}.Of  the names of the instances variables before any changes for all classes in classChanges, and all of their superclasses.  In the same format used in SmartRefStream.  Inst var names are strings.  superclasses -    Dictionary {#Rectangle -> #Object}.Of all classes in classChanges, and all of their superclasses.Structures and superclasses save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp).NOTE:  It should be fairly simple, by adding a bit more information to the classChangeRecords, to reconstruct the information now stored in 'structures' and 'superclasses'.  This would be a welcome simplification.!!ChangeSet methodsFor: 'method changes' stamp: 'di 4/4/2000 11:14'!removeSelectorChanges: selector class: class 	"Remove all memory of changes associated with the argument, selector, in 	this class."	| chgRecord |	(chgRecord _ changeRecords at: class name ifAbsent: [^ self])		removeSelector: selector.	chgRecord hasNoChanges ifTrue: [changeRecords removeKey: class name]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 11:21'!assimilateAllChangesFoundIn: otherChangeSet	"Make all changes in otherChangeSet take effect on self as if they happened just now."	otherChangeSet changedClassNames do:		[:className | self absorbClass: className from: otherChangeSet]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 11:49'!expungeEmptyClassChangeEntries	changeRecords keysAndValuesRemove:		[:className :classRecord | classRecord hasNoChanges]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 12:40'!forgetAllChangesFoundIn: otherChangeSet	"Remove from the receiver all method changes found in aChangeSet. The intention is facilitate the process of factoring a large set of changes into disjoint change sets.  To use:  in a change sorter, copy over all the changes you want into some new change set, then use the subtract-other-side feature to subtract those changes from the larger change set, and continue in this manner."	otherChangeSet == self ifTrue: [^ self].	otherChangeSet changedClassNames do:		[:className | self forgetChangesForClass: className in: otherChangeSet].	self expungeEmptyClassChangeEntries."  Old code...	aChangeSet changedClassNames do: 		[:className |			(cls _ Smalltalk classNamed: className) ~~ nil ifTrue:				[itsMethodChanges _ aChangeSet methodChanges at: className 						ifAbsent: [Dictionary new].				itsMethodChanges associationsDo: [:assoc | 					self forgetChange: assoc value forSelector: assoc key class: cls].				myClassChange _ self classChangeAt: className.				myClassChange size > 0 ifTrue:					[(aChangeSet classChangeAt: className) do:						[:aChange | myClassChange remove: aChange ifAbsent: []]].				self noteClassForgotten: className]].	aChangeSet classRemoves do:		[:className | (recorder _ changeRecords at: className ifAbsent: [])			ifNotNil: [recorder forgetClassRemoval]].	self expungeEmptyClassChangeEntries"! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 12:04'!forgetChangesForClass: className in: otherChangeSet	"See forgetAllChangesFoundIn:.  Used in culling changeSets."	(self changeRecorderFor: className)			forgetChangesIn: (otherChangeSet changeRecorderFor: className).	self noteClassForgotten: className! !!ChangeSorter methodsFor: 'message list' stamp: 'di 4/4/2000 13:11'!messageList	| probe newSelectors |	currentClassName ifNil: [^ #()].	probe _ (currentClassName endsWith: ' class')		ifTrue: [currentClassName]		ifFalse: [currentClassName asSymbol].	newSelectors _ myChangeSet selectorsInClass: probe.	(newSelectors includes: currentSelector) ifFalse: [currentSelector _ nil].	^ (newSelectors collect: [:each | each printString]) asSortedCollection! !!ChangeSorter methodsFor: 'message list' stamp: 'di 4/4/2000 10:54'!removeMessage	"Remove the selected msg from the system.  Real work done by the parent, a ChangeSorter"	| confirmation sel |	self okToChange ifFalse: [^ self].	currentSelector ifNotNil: [		confirmation _ self selectedClassOrMetaClass 			confirmRemovalOf: (sel _ self selectedMessageName).		confirmation == 3 ifTrue: [^ self].		self selectedClassOrMetaClass removeSelector: sel.		self update.		confirmation == 2 ifTrue:			[Smalltalk browseAllCallsOn: sel]]! !!ClassChangeRecord methodsFor: 'removal' stamp: 'di 4/4/2000 12:49'!forgetChangesIn: otherRecord	"See forgetAllChangesFoundIn:.  Used in culling changeSets."	| cls otherMethodChanges selector actionToSubtract |	(cls _ self realClass) == nil ifTrue: [^ self].  "We can do better now, though..."	otherMethodChanges _ otherRecord methodChangeTypes.	otherMethodChanges associationsDo:		[:assoc | selector _ assoc key. actionToSubtract _ assoc value.		(cls includesSelector: selector)			ifTrue: [(#(add change) includes: actionToSubtract)					ifTrue: [methodChanges removeKey: selector ifAbsent: []]]			ifFalse: [(#(remove addedThenRemoved) includes: actionToSubtract)					ifTrue: [methodChanges removeKey: selector ifAbsent: []]]].	changeTypes isEmpty ifFalse:		[changeTypes removeAllFoundIn: otherRecord allChangeTypes.		(changeTypes includes: #rename) ifFalse:			[changeTypes removeAllSuchThat: [:x | x beginsWith: 'oldName: ']]]! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/4/2000 11:05'!noteChangeType: newChangeType	(changeType == #addedThenRemoved and: [newChangeType == #change])		ifTrue: [changeType _ #add]		ifFalse: [changeType _ newChangeType]! !