'From Squeak3.7alpha of 11 September 2003 [latest update: #5816] on 25 March 2004 at 2:29:58 pm'!"Change Set:		addHorzScrollBar37v4-spsDate:			23 March 2004Author:			Steven Swerling(version changes at the bottom of this changeset preamble)Repost of old changeset for adding horizontal scroll bars to ScrollPanes. Updated and cleaned up for 3.7 (and only for 3.7). The scroll pane now ignores the preference for showing scrollbars only when needed -- this is now the default. If you don't like it for a particular pane, you can call one of the #alwaysShow... or #hideXIndefinitely options for the pane (see the method category, 'accessing options'). Calls to some obsolete methods that assume 1 scrollbar are now forwarded to the corresponding method for the vertical scrollbar, see the 'obsolete' method category.WARNING: The last thing you need is for a bug in ScrollPane, as it could prevent the Debugger from functioning. I don't know of any in this code, but better safe then sorry. So consider this a beta. Please tinker around with your applications to make sure everything is working ok before saving your image.CAVEAT: When you file in this changeset, it will add an hScrollBar to all existing ScrollPanes -- the color will be off on these. When you open new windows, the horz scrollbar will take on the appropriate color.Tested on a fresh 3.7 image w/ updates up to #5764.v1: initial release.v2: redirected calls to Font>>widthOfString to use new method #widthOfStringOrText:. If it's a string or text without any sort of emphasis, it returns the string width. If it's a text, it adds about 20% to the string width and returns that. It does not calculate the precise text width this version, which is deferred.v3: Added Doug Way's fix for divide-by-zero bug on resize. Fixed dissappearing hScrollbar in browsers. Replaced #hiddenScrollbars preference with #alwaysShowVScrollbar and #alwaysShowHScrollbar, both of which default to false.v4: Changed #alwaysShowVScrollbar default to true. -dew"!ComponentLikeModel subclass: #ScrollPane	instanceVariableNames: 'scrollBar scroller retractableScrollBar scrollBarOnLeft getMenuSelector getMenuTitleSelector scrollBarHidden hasFocus hScrollBar '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!AbstractFont methodsFor: 'measuring' stamp: 'sps 3/23/2004 15:49'!approxWidthOfText: aText"Return the width of aText -- quickly, and a little bit dirty. Used by lists morphs containing Text objects to get a quick, fairly accurate measure of the width of a list item."    | w |        (aText isNil or: [aText size == 0 ])        ifTrue:[^0].           w _ self        widthOfString: aText asString        from: 1        to: aText size.     "If the text has no emphasis, just return the string size.  If it is empasized,     just approximate the width by adding about 20% to the width"       (((aText runLengthFor: 1) == aText size)        and: [(aText emphasisAt: 1) == 0 ])            ifTrue:[^w]            ifFalse:[ ^w * 6 // 5 ]. ! !!AbstractFont methodsFor: 'measuring' stamp: 'sps 3/23/2004 15:50'!widthOfStringOrText: aStringOrText    aStringOrText ifNil:[^0].    ^aStringOrText isText        ifTrue:[self approxWidthOfText: aStringOrText ]        ifFalse:[self widthOfString: aStringOrText ] ! !!Browser methodsFor: 'initialize-release' stamp: 'sps 3/24/2004 11:50'!addAListPane: aListPane to: window at: nominalFractions plus: verticalOffset	| row switchHeight divider |	row _ AlignmentMorph newColumn		hResizing: #spaceFill;		vResizing: #spaceFill;		layoutInset: 0;		borderWidth: 1;		layoutPolicy: ProportionalLayout new.	switchHeight _ 25.	self 		addMorphicSwitchesTo: row 		at: (			LayoutFrame 				fractions: (0@1 corner: 1@1) 				offsets: (0@(1-switchHeight)  corner: 0@0)		).	divider _ BorderedSubpaneDividerMorph forTopEdge.	Preferences alternativeWindowLook ifTrue:[		divider extent: 4@4; color: Color transparent; borderColor: #raised; borderWidth: 2.	].	row 		addMorph: divider		fullFrame: (			LayoutFrame 				fractions: (0@1 corner: 1@1) 				offsets: (0@switchHeight negated corner: 0@(1-switchHeight))		).		row 		addMorph: aListPane		fullFrame: (			LayoutFrame 				fractions: (0@0 corner: 1@1) 				offsets: (0@0 corner: 0@(switchHeight negated))		).		window 		addMorph: row		fullFrame: (			LayoutFrame 				fractions: nominalFractions 				offsets: (0@verticalOffset corner: 0@0)		).		row on: #mouseEnter send: #paneTransition: to: window.	row on: #mouseLeave send: #paneTransition: to: window.! !!Browser class methodsFor: 'instance creation' stamp: 'sps 3/9/2004 15:54'!openBrowserView: aBrowserView label: aString 	"Schedule aBrowserView, labelling the view aString."	aBrowserView isMorph		ifTrue:  [(aBrowserView setLabel: aString) openInWorld]		ifFalse: [aBrowserView label: aString.				aBrowserView minimumSize: 300 @ 200.				aBrowserView subViews do: [:each | each controller].				aBrowserView controller open].	^ aBrowserView model! !!LazyListMorph methodsFor: 'list management' stamp: 'sps 3/9/2004 17:06'!listChanged	"set newList to be the list of strings to display"	listItems := Array new: self getListSize withAll: nil.	selectedRow := nil.	selectedRows := PluggableSet integerSet.	self adjustHeight.	self adjustWidth.	self changed.! !!LazyListMorph methodsFor: 'drawing' stamp: 'sps 3/9/2004 17:06'!adjustWidth	"private.  Adjust our height to match the length of the underlying list"	self width: ((listSource width max: self hUnadjustedScrollRange) + 20). ! !!LazyListMorph methodsFor: 'scroll range' stamp: 'sps 3/23/2004 16:07'!hUnadjustedScrollRange"Ok, this is a bit messed up. We need to return the width of the widest item in the list. If we grab every item in the list, it defeats the purpose of LazyListMorph. If we don't, then we don't know the size. This is a compromise -- if the list is less then 30 items, we grab them all. If not, we grab currently visible ones, until we've checked itemsToCheck of them, then take the max width out of that 'sampling', then double it. If you know a better way, please chime in."	| maxW count itemsToCheck item |	itemsToCheck _ 30.	maxW _ 0. 	count _ 0.	listItems do: 		[ :each |			each ifNotNil: 				[maxW _ maxW max: (self font widthOfStringOrText: each contents)]].					(count < itemsToCheck) ifTrue:		[1 to: listItems size do: 			[:i | (listItems at: i) ifNil: 							[item _ self item: i.							maxW _ maxW max: (self font widthOfStringOrText: item contents).							((count _ count + 1) > itemsToCheck) ifTrue:[ ^maxW * 2]]]].		^maxW ! !!MulticolumnLazyListMorph methodsFor: 'drawing' stamp: 'sps 3/23/2004 15:51'!setColumnWidthsFor: aCanvas        | row topRow bottomRow |        "set columnWidths for drawing on the specified canvas"		columnWidths ifNil: [		columnWidths := (self item: 1) collect: [ :ignored | 0 ]. ].	topRow := (self topVisibleRowForCanvas: aCanvas) max: 1.	bottomRow :=  (self bottomVisibleRowForCanvas: aCanvas) max: 1.	topRow > bottomRow ifTrue: [ ^ self ].	topRow to: bottomRow do: [ :rowIndex |                row := self item: rowIndex.                columnWidths := columnWidths with: row collect: [ :currentWidth :item |				| widthOfItem |				widthOfItem := (font widthOfStringOrText: item).				widthOfItem > currentWidth					ifTrue: [ self changed.  widthOfItem ]					ifFalse: [ currentWidth ] ] ]! !!ScrollBar methodsFor: 'other events' stamp: 'sps 3/10/2004 10:14'!mouseDownInSlider: event	interval = 1.0 ifTrue:		["make the entire scrollable area visible if a full scrollbar is clicked on"		self setValue: 0.		self model hideOrShowScrollBars.].	super mouseDownInSlider: event! !!ScrollPane methodsFor: 'OBSOLETE' stamp: 'sps 12/25/2002 14:35'!hideScrollBar^self vHideScrollBar! !!ScrollPane methodsFor: 'OBSOLETE' stamp: 'sps 12/26/2002 23:24'!hideScrollBarIndefinitely^self hideScrollBarsIndefinitely! !!ScrollPane methodsFor: 'OBSOLETE' stamp: 'sps 12/25/2002 14:41'!leftoverScrollRange^self vLeftoverScrollRange! !!ScrollPane methodsFor: 'OBSOLETE' stamp: 'sps 12/25/2002 14:47'!resizeScrollBar	^self vResizeScrollBar! !!ScrollPane methodsFor: 'OBSOLETE' stamp: 'sps 12/25/2002 14:58'!scrollBarValue: scrollValue^self vScrollBarValue: scrollValue! !!ScrollPane methodsFor: 'OBSOLETE' stamp: 'sps 12/25/2002 15:40'!scrollbarWidth 		^self scrollBarThickness! !!ScrollPane methodsFor: 'OBSOLETE' stamp: 'sps 12/25/2002 14:42'!totalScrollRange	^self vTotalScrollRange! !!ScrollPane methodsFor: 'access' stamp: 'sps 12/28/2002 01:07'!adoptPaneColor: paneColor	super adoptPaneColor: paneColor.	scrollBar adoptPaneColor: paneColor.	hScrollBar adoptPaneColor: paneColor.! !!ScrollPane methodsFor: 'access' stamp: 'dew 3/23/2002 01:20'!flatColoredScrollBarLook	"Currently only show the flat (not rounded) + colored-to-match-window scrollbar look when inboard."	^ Preferences alternativeScrollbarLook and: [retractableScrollBar not or: [ScrollBar alwaysShowFlatScrollbarForAlternativeLook]]! !!ScrollPane methodsFor: 'access' stamp: 'sps 3/10/2004 11:32'!hMargin"pixels of whitespace at to the left of the scroller when the hScrollBar offset is 0"	^3! !!ScrollPane methodsFor: 'access' stamp: 'dew 10/17/1999 19:40'!hasFocus	"hasFocus is currently set by mouse enter/leave events.	This inst var should probably be moved up to a higher superclass."	^ hasFocus ifNil: [false]! !!ScrollPane methodsFor: 'access options' stamp: 'sps 3/10/2004 10:30'!alwaysShowHScrollBar	self setProperty: #hScrollBarAlways toValue: true.	self hShowScrollBar.! !!ScrollPane methodsFor: 'access options' stamp: 'sps 3/10/2004 10:30'!alwaysShowScrollBars	"Get rid of scroll bar for short panes that don't want it shown."	self 		alwaysShowHScrollBar;		alwaysShowVScrollBar.! !!ScrollPane methodsFor: 'access options' stamp: 'sps 3/10/2004 10:30'!alwaysShowVScrollBar	self setProperty: #vScrollBarAlways toValue: true.	self vShowScrollBar.! !!ScrollPane methodsFor: 'access options' stamp: 'sps 12/26/2002 23:23'!hideHScrollBarIndefinitely	"Get rid of scroll bar for short panes that don't want it shown."	self setProperty: #noHScrollBarPlease toValue: true.	self hHideScrollBar.! !!ScrollPane methodsFor: 'access options' stamp: 'sps 12/26/2002 23:23'!hideScrollBarsIndefinitely	"Get rid of scroll bar for short panes that don't want it shown."	self setProperty: #noHScrollBarPlease toValue: true.	self setProperty: #noVScrollBarPlease toValue: true.	self hideScrollBars.! !!ScrollPane methodsFor: 'access options' stamp: 'sps 12/26/2002 23:24'!hideVScrollBarIndefinitely	"Get rid of scroll bar for short panes that don't want it shown."	self setProperty: #noVScrollBarPlease toValue: true.	self vHideScrollBar.! !!ScrollPane methodsFor: 'access options' stamp: 'sps 3/10/2004 10:28'!showHScrollBarOnlyWhenNeeded	"Get rid of scroll bar for short panes that don't want it shown."	self setProperty: #noHScrollBarPlease toValue: false.	self setProperty: #hScrollBarAlways toValue: false.	self hHideScrollBar.! !!ScrollPane methodsFor: 'access options' stamp: 'sps 3/10/2004 10:29'!showScrollBarsOnlyWhenNeeded	"Get rid of scroll bar for short panes that don't want it shown."	self 		showHScrollBarOnlyWhenNeeded;		showVScrollBarOnlyWhenNeeded.! !!ScrollPane methodsFor: 'access options' stamp: 'sps 3/10/2004 10:28'!showVScrollBarOnlyWhenNeeded	"Get rid of scroll bar for short panes that don't want it shown."	self setProperty: #noVScrollBarPlease toValue: false.	self setProperty: #vScrollBarAlways toValue: false.	self vHideScrollBar.! !!ScrollPane methodsFor: 'event handling' stamp: 'sps 3/10/2004 10:23'!handlesMouseDown: evt	^ true! !!ScrollPane methodsFor: 'event handling' stamp: 'ar 9/18/2000 22:11'!handlesMouseOver: evt	"Could just ^ true, but this ensures that scroll bars won't flop out	if you mouse-over appendages such as connecting pins."	self flag: #arNote. "I have no idea how the code below could've ever worked. If the receiver does not handle mouse over events then it should not receive any #mouseLeave if the mouse leaves the receiver for real. This is because 'evt cursorPoint' describes the *end* point of the movement and considering that the code would return false if the move ends outside the receiver the scroll bars should never pop back in again. Which is exactly what happens with the new event logic if you don't just ^true. I'm leaving the code in for reference - perhaps somebody can make sense from it; I sure cannot."	^true"	| cp |	cp _ evt cursorPoint.	(bounds containsPoint: cp)		ifTrue: [^ true]					ifFalse: [self submorphsDo:					[:m | (m containsPoint: cp) ifTrue:							[m == scrollBar								ifTrue: [^ true]								ifFalse: [^ false]]].				^ false]"! !!ScrollPane methodsFor: 'event handling' stamp: 'bf 4/14/1999 12:39'!keyStroke: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	(self scrollByKeyboard: evt) ifTrue: [^self].	scroller submorphs last keyStroke: evt! !!ScrollPane methodsFor: 'event handling' stamp: 'di 6/30/1998 08:48'!mouseDown: evt	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseDown: (evt transformedBy: (scroller transformFrom: self))]! !!ScrollPane methodsFor: 'event handling' stamp: 'sps 3/9/2004 17:51'!mouseEnter: event	hasFocus _ true.	(owner isSystemWindow) ifTrue: [owner paneTransition: event].	retractableScrollBar ifTrue:[ self hideOrShowScrollBars ].! !!ScrollPane methodsFor: 'event handling' stamp: 'sps 3/9/2004 17:52'!mouseLeave: event	hasFocus _ false.	retractableScrollBar ifTrue: [self hideScrollBars].	(owner isSystemWindow) ifTrue: [owner paneTransition: event]! !!ScrollPane methodsFor: 'event handling' stamp: 'ar 10/10/2000 23:01'!mouseMove: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)."	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseMove: (evt transformedBy: (scroller transformFrom: self))]! !!ScrollPane methodsFor: 'event handling' stamp: 'di 5/7/1998 11:46'!mouseUp: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseUp: (evt transformedBy: (scroller transformFrom: self))]! !!ScrollPane methodsFor: 'event handling' stamp: 'th 12/11/1999 17:21'!scrollByKeyboard: event 	"If event is ctrl+up/down then scroll and answer true"	(event controlKeyPressed or:[event commandKeyPressed]) ifFalse: [^ false].	event keyValue = 30		ifTrue: 			[scrollBar scrollUp: 3.			^ true].	event keyValue = 31		ifTrue: 			[scrollBar scrollDown: 3.			^ true].	^ false! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 3/10/2004 11:53'!extent: newExtent		| oldW oldH oldE wasHShowing wasVShowing noVPlease noHPlease minH minW |		oldW _ self width.	oldH _ self height.	oldE _ self extent.	wasHShowing _ self hIsScrollbarShowing.	wasVShowing _ self vIsScrollbarShowing.	"Figure out the minimum width and height for this pane so that scrollbars will appear"	noVPlease _ self valueOfProperty: #noVScrollBarPlease ifAbsent: [false]. 	noHPlease _ self valueOfProperty: #noHScrollBarPlease ifAbsent: [false]. 	minH _ self scrollBarThickness + 16.	minW _ self scrollBarThickness + 20.	noVPlease ifTrue:[ 		noHPlease			ifTrue:[minH _ 1. minW _ 1 ]			ifFalse:[minH _ self scrollBarThickness ].	] ifFalse:[		noHPlease			ifTrue:[minH _ self scrollBarThickness + 5].	].	super extent: (newExtent max: (minW@minH)).		"If extent has not changed, no need to reset scroll deltas, etc"	(self extent = oldE) ifTrue:[ ^self ].		"Now reset widget sizes"	self resizeScrollBars; resizeScroller; hideOrShowScrollBars.		"Now resetScrollDeltas where appropriate, first the vScrollBar..."	((self height ~~ oldH) or: [ wasHShowing ~~ self hIsScrollbarShowing]) ifTrue:		[(retractableScrollBar or: [ self vIsScrollbarShowing ]) ifTrue:			[ self vSetScrollDelta ]].				"...then the hScrollBar"	((self width ~~ oldW) or: [wasVShowing ~~ self vIsScrollbarShowing]) ifTrue:		[(retractableScrollBar or: [ self hIsScrollbarShowing ]) ifTrue:			[ self hSetScrollDelta ]].! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/24/2002 00:13'!hExtraScrollRange	"Return the amount of extra blank space to include below the bottom of the scroll content."	^ self scrollDeltaWidth! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 3/10/2004 13:17'!hLeftoverScrollRange	"Return the entire scrolling range minus the currently viewed area."	| w |	scroller hasSubmorphs ifFalse:[^0].	w _  bounds width.	self vIsScrollbarShowing ifTrue:[ w _ w - self scrollBarThickness ].	^ (self hTotalScrollRange - w roundTo: self scrollDeltaHeight) max: 0! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/27/2002 01:30'!hResizeScrollBar	| topLeft h border |"TEMPORARY: IF OLD SCROLLPANES LYING AROUND THAT DON'T HAVE A hScrollBar, INIT THEM"	hScrollBar ifNil: [ self hInitScrollBarTEMPORARY].		(self valueOfProperty: #noHScrollBarPlease ifAbsent: [false]) ifTrue: [^self].	bounds ifNil: [ self fullBounds ].		h _ self scrollBarThickness.	border _ borderWidth.		topLeft _ retractableScrollBar				ifTrue: [bounds bottomLeft + (border @ border negated)]				ifFalse: [bounds bottomLeft + (border @ (h + border) negated)].	hScrollBar bounds: (topLeft extent: self hScrollBarWidth@ h)! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/25/2002 16:16'!hScrollBarWidth"Return the width of the horizontal scrollbar"	| w |		w _ bounds width - (2 * borderWidth).		(retractableScrollBar not and: [self vIsScrollbarNeeded])		ifTrue: [w _ w - self scrollBarThickness ].			^w ! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 3/23/2004 23:23'!hSetScrollDelta	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."	| range delta |	scroller hasSubmorphs ifFalse:[scrollBar interval: 1.0. ^self].		delta _ self scrollDeltaWidth.	range _ self hLeftoverScrollRange.	range = 0 ifTrue: [ hScrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; setValue: 0. ^self].	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."	hScrollBar 			scrollDelta: (delta / range) asFloat 			pageDelta: ((self innerBounds width - delta) / range) asFloat.	hScrollBar interval: ((self innerBounds width) / self hTotalScrollRange) asFloat.	hScrollBar setValue: ((scroller offset x / range) min: 1.0) asFloat.! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 3/10/2004 11:51'!hTotalScrollRange	"Return the entire scrolling range."	^ self hUnadjustedScrollRange + self hExtraScrollRange + self hMargin! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/24/2002 16:07'!hUnadjustedScrollRange	"Return the width extent of the receiver's submorphs."	| submorphBounds |	submorphBounds := scroller localSubmorphBounds ifNil: [^ 0].	^ submorphBounds right! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/24/2002 16:18'!innerBounds	| inner |	inner _ super innerBounds.	retractableScrollBar | (submorphs includes: scrollBar) not ifFalse:[		inner _ (scrollBarOnLeft					ifTrue: [scrollBar right @ inner top corner: inner bottomRight]					ifFalse: [inner topLeft corner: scrollBar left @ inner bottom])	].	(retractableScrollBar | self hIsScrollbarShowing not)		ifTrue: [^ inner]		ifFalse: [^ inner topLeft corner: (inner bottomRight - (0@self scrollBarThickness))].! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 10/17/1999 19:41'!resetExtent	"Reset the extent. (may be overridden by subclasses which need to do more than this)"	self resizeScroller! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/25/2002 16:34'!resizeScrollBars	self vResizeScrollBar; hResizeScrollBar! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 09:48'!resizeScroller	scroller bounds: self innerBounds! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/25/2002 15:38'!scrollBarThickness	"Includes border"	| result |	result := Preferences scrollBarsNarrow				ifTrue: [10]				ifFalse: [14].	self flatColoredScrollBarLook		ifFalse: [result := result + 2].		^ (result * Preferences fontFactor) rounded! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 3/10/2004 13:26'!scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled (normally a subclass responsibility)."	^ 10! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 3/9/2004 17:29'!scrollDeltaWidth	"Return the increment in pixels which this pane should be scrolled (normally a subclass responsibility)."		^10! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 3/10/2004 11:46'!setScrollDeltas	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."	scroller hasSubmorphs ifFalse: 		[scrollBar interval: 1.0. 		hScrollBar interval: 1.0. 		^ self].	"NOTE: fullbounds commented out now -- trying to find a case where this expensive step is necessary -- perhaps there is a less expensive way to handle that case."	"scroller fullBounds." "force recompute so that leftoverScrollRange will be up-to-date"	self hideOrShowScrollBars.		(retractableScrollBar or: [ self vIsScrollbarShowing ]) ifTrue:[ self vSetScrollDelta ].	(retractableScrollBar or: [ self hIsScrollbarShowing ]) ifTrue:[ self hSetScrollDelta ].! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/25/2002 14:40'!vExtraScrollRange	"Return the amount of extra blank space to include below the bottom of the scroll content."	"The classic behavior would be ^bounds height - (bounds height * 3 // 4)"	^ self scrollDeltaHeight! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 3/10/2004 13:14'!vLeftoverScrollRange	"Return the entire scrolling range minus the currently viewed area."	| h |	scroller hasSubmorphs ifFalse:[^0].	h _ self vScrollBarHeight.	^ (self vTotalScrollRange - h roundTo: self scrollDeltaHeight) max: 0! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 3/10/2004 13:12'!vResizeScrollBar	| w topLeft borderHeight innerWidth |	w := self scrollBarThickness.	innerWidth := self flatColoredScrollBarLook 		ifTrue: 			[borderHeight := borderWidth.			0]		ifFalse: 			[borderHeight := 0.			 1].	topLeft := scrollBarOnLeft 				ifTrue: 					[retractableScrollBar 						ifTrue: [bounds topLeft - ((w - borderWidth) @ (0 - borderHeight))]						ifFalse: [bounds topLeft + ((borderWidth - innerWidth) @ borderHeight)]]				ifFalse: 					[retractableScrollBar 						ifTrue: [bounds topRight - (borderWidth @ (0 - borderHeight))]						ifFalse: 							[bounds topRight - ((w + borderWidth - innerWidth) @ (0 - borderHeight))]].				scrollBar 		bounds: (topLeft extent: w @ self vScrollBarHeight)	! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/25/2002 16:14'!vScrollBarHeight	| h |	h _ bounds height - (2 * borderWidth).	(retractableScrollBar not and: [self hIsScrollbarNeeded]) 		ifTrue:[ h _ h - self scrollBarThickness. ].		^h! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 3/23/2004 23:25'!vSetScrollDelta	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."	| range delta |	scroller hasSubmorphs ifFalse:[scrollBar interval: 1.0. ^self].		delta _ self scrollDeltaHeight.	range _ self vLeftoverScrollRange.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; setValue: 0].	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."	scrollBar scrollDelta: (delta / range) asFloat 			pageDelta: ((self innerBounds height - delta) / range) asFloat.	scrollBar interval: ((self innerBounds height) / self vTotalScrollRange) asFloat.	scrollBar setValue: (scroller offset y / range min: 1.0) asFloat.! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 3/10/2004 11:06'!vTotalScrollRange	"Return the entire scrolling range."	^ self vUnadjustedScrollRange + self vExtraScrollRange! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/25/2002 14:43'!vUnadjustedScrollRange	"Return the height extent of the receiver's submorphs."	| submorphBounds |	submorphBounds := scroller localSubmorphBounds ifNil: [^ 0].	^ submorphBounds bottom! !!ScrollPane methodsFor: 'geometry testing' stamp: 'sps 3/10/2004 10:22'!containsPoint: aPoint	(super containsPoint: aPoint) ifTrue: [^ true].		"Also include v scrollbar when it is extended..."	((retractableScrollBar and: [submorphs includes: scrollBar]) and:		[scrollBar containsPoint: aPoint])			ifTrue:[ ^true ].			"Also include hScrollbar when it is extended..."	^(retractableScrollBar and: [self hIsScrollbarShowing]) and:		[hScrollBar containsPoint: aPoint]! !!ScrollPane methodsFor: 'geometry testing' stamp: 'sps 3/10/2004 13:46'!hIsScrollable	"If the contents of the pane are too small to scroll, return false."	^ self hLeftoverScrollRange > 0	! !!ScrollPane methodsFor: 'geometry testing' stamp: 'sps 3/10/2004 10:22'!hIsScrollbarShowing	"Return true if a horz scroll bar is currently showing"	^submorphs includes: hScrollBar! !!ScrollPane methodsFor: 'geometry testing' stamp: 'sps 3/10/2004 10:22'!hIsScrolled	"If the scroller is not set to x = 0, then the pane has been h-scrolled."	^scroller offset x > 0! !!ScrollPane methodsFor: 'geometry testing' stamp: 'sps 3/10/2004 10:22'!isAScrollbarShowing	"Return true if a either retractable scroll bar is currently showing"	retractableScrollBar ifFalse:[^true].	^self hIsScrollbarShowing or: [self vIsScrollbarShowing]! !!ScrollPane methodsFor: 'geometry testing' stamp: 'sps 3/10/2004 10:22'!isScrolledFromTop	"Have the contents of the pane been scrolled, so that the top of the contents are not visible?"	^scroller offset y > 0! !!ScrollPane methodsFor: 'geometry testing' stamp: 'sps 3/10/2004 10:22'!scrollBarFills: aRectangle	"Return true if a flop-out scrollbar fills the rectangle"	retractableScrollBar ifFalse:[^false].		((submorphs includes: scrollBar) and: [scrollBar bounds containsRect: aRectangle])				ifTrue:[ ^true ].	^((submorphs includes: hScrollBar) and: [hScrollBar bounds containsRect: aRectangle])! !!ScrollPane methodsFor: 'geometry testing' stamp: 'sps 3/10/2004 13:23'!vIsScrollable"Return whether the verticle scrollbar is scrollable"	"If the contents of the pane are too small to scroll, return false."	^ self vLeftoverScrollRange > 0		"treat a single line as non-scrollable"		and: [self vTotalScrollRange > (self scrollDeltaHeight * 3/2)]! !!ScrollPane methodsFor: 'geometry testing' stamp: 'sps 3/10/2004 10:22'!vIsScrollbarShowing	"Return true if a retractable scroll bar is currently showing"	^submorphs includes: scrollBar! !!ScrollPane methodsFor: 'geometry testing' stamp: 'sps 3/10/2004 10:23'!vIsScrolled	"If the scroller is not set to y = 0, then the pane has been scrolled."	^scroller offset y > 0! !!ScrollPane methodsFor: 'initialization' stamp: 'sps 3/9/2004 18:02'!hInitScrollBarTEMPORARY"This is called lazily before the hScrollBar is accessed in a couple of places. It is provided to transition old ScrollPanes lying around that do not have an hScrollBar. Once it has been in the image for awhile, and all ScrollPanes have an hScrollBar, this method and it's references can be removed. "		"Temporary method for filein of changeset"		hScrollBar ifNil: 			[hScrollBar := ScrollBar new model: self slotName: 'hScrollBar'.			hScrollBar borderWidth: 1; borderColor: Color black.			self 				resizeScrollBars;				setScrollDeltas;				hideOrShowScrollBars].! !!ScrollPane methodsFor: 'initialization' stamp: 'sps 3/25/2004 14:26'!initialize		"initialize the state of the receiver"	super initialize.	""	self initializePreferences.	hasFocus _ false.	self initializeScrollBars.	""	self extent: 150 @ 120.	self hideOrShowScrollBars.! !!ScrollPane methodsFor: 'initialization' stamp: 'sps 3/25/2004 14:28'!initializePreferences	"initialize the receiver's Preferences"	retractableScrollBar _ (Preferences valueOfFlag: #inboardScrollbars) not.	scrollBarOnLeft _ (Preferences valueOfFlag: #scrollBarsOnRight) not.	! !!ScrollPane methodsFor: 'initialization' stamp: 'sps 3/25/2004 14:28'!initializeScrollBars"initialize the receiver's scrollBar"	(scrollBar _ ScrollBar new model: self slotName: 'vScrollBar')			borderWidth: 1; 			borderColor: Color black.	(hScrollBar _ ScrollBar new model: self slotName: 'hScrollBar')			borderWidth: 1; 			borderColor: Color black.	""	scroller _ TransformMorph new color: Color transparent.	scroller offset: -3 @ 0.	self addMorph: scroller.	""	scrollBar initializeEmbedded: retractableScrollBar not.	hScrollBar initializeEmbedded: retractableScrollBar not.	retractableScrollBar ifFalse: 			[self 				addMorph: scrollBar;				addMorph: hScrollBar].	Preferences alwaysShowVScrollbar ifTrue:		[ self alwaysShowVScrollBar ].	Preferences alwaysShowHScrollbar ifTrue:		[ self alwaysShowHScrollBar ].! !!ScrollPane methodsFor: 'menu' stamp: 'sw 9/23/1998 08:47'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu aTitle |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	aTitle _ getMenuTitleSelector ifNotNil: [model perform: getMenuTitleSelector].	getMenuSelector numArgs = 1 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	getMenuSelector numArgs = 2 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu with: shiftKeyState.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!ScrollPane methodsFor: 'menu' stamp: 'di 11/14/97 09:09'!leftOrRight  "Change scroll bar location"	scrollBarOnLeft _ scrollBarOnLeft not.	self extent: self extent! !!ScrollPane methodsFor: 'menu' stamp: 'sw 8/18/1998 12:38'!menuTitleSelector: aSelector	getMenuTitleSelector _ aSelector! !!ScrollPane methodsFor: 'menu' stamp: 'sw 11/5/1998 14:14'!retractable: aBoolean	retractableScrollBar == aBoolean ifFalse: [self retractableOrNot "toggles it"]! !!ScrollPane methodsFor: 'menu' stamp: 'sps 3/9/2004 17:47'!retractableOrNot	"Change scroll bar operation"	retractableScrollBar _ retractableScrollBar not.	retractableScrollBar		ifTrue: [self removeMorph: scrollBar]		ifFalse: [(submorphs includes: scrollBar) 					ifFalse: 						[self privateAddMorph: scrollBar atIndex: 1.						self privateAddMorph: hScrollBar atIndex: 1]].	self extent: self extent.! !!ScrollPane methodsFor: 'menu' stamp: 'sw 1/13/98 21:27'!scrollBarOnLeft: aBoolean	scrollBarOnLeft _ aBoolean.	self extent: self extent! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'sps 12/27/2002 00:13'!hScrollBarMenuButtonPressed: event	^ self scrollBarMenuButtonPressed: event! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!scrollBarMenuButtonPressed: event	^ self yellowButtonActivity: event shiftPressed! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'sw 3/22/2001 12:03'!shiftedTextPaneMenuRequest	"The more... button was hit from the text-pane menu"	^ self yellowButtonActivity: true! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!shiftedYellowButtonActivity	^ self yellowButtonActivity: true! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:32'!unshiftedYellowButtonActivity	^ self yellowButtonActivity: false! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'sps 12/27/2002 00:13'!vScrollBarMenuButtonPressed: event	^ self scrollBarMenuButtonPressed: event! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 6/12/2000 09:02'!yellowButtonActivity: shiftKeyState	| menu |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[menu setInvokingView: self.		menu popUpEvent: self activeHand lastEvent in: self world]! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 12/25/2002 01:10'!hHideOrShowScrollBar	"Hide or show the scrollbar depending on if the pane is scrolled/scrollable."	self hIsScrollbarNeeded		ifTrue:[ self hShowScrollBar ]		ifFalse: [ self hHideScrollBar ].! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 12:08'!hHideScrollBar	self hIsScrollbarShowing ifFalse: [^scroller offset: (self hMargin negated@scroller offset y)].	self removeMorph: hScrollBar.	scroller offset: (self hMargin negated@scroller offset y).	retractableScrollBar ifFalse: [self resetExtent].! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 13:33'!hIsScrollbarNeeded"Return whether the horz scrollbar is needed"	"Don't do anything with the retractable scrollbar unless we have focus"	retractableScrollBar & self hasFocus not ifTrue: [^false].		"Don't show it if we were told not to."	(self valueOfProperty: #noHScrollBarPlease ifAbsent: [false]) ifTrue: [^false].	"Always show it if we were told to"	(self valueOfProperty: #hScrollBarAlways ifAbsent: [false]) ifTrue: [^true].	^self hIsScrollable! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 11:50'!hScrollBarValue: scrollValue	| x |	self hIsScrollbarShowing ifFalse: 		[^scroller offset: (0 - self hMargin)@scroller offset y].	((x _ self hLeftoverScrollRange * scrollValue) <= 0)		ifTrue:[x _ 0 - self hMargin].	scroller offset: (x@scroller offset y)! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 13:42'!hShowScrollBar	self hIsScrollbarShowing ifTrue: [^self].	self hResizeScrollBar.	self privateAddMorph: hScrollBar atIndex: 1.	retractableScrollBar ifFalse: [self resetExtent].! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 12:07'!hideOrShowScrollBars	| wasHShowing wasVShowing |	wasVShowing _ self vIsScrollbarShowing.	wasHShowing _ self hIsScrollbarShowing.	self 		vHideOrShowScrollBar; 		hHideOrShowScrollBar; 		resizeScrollBars.	(wasVShowing and: [self vIsScrollbarShowing not]) ifTrue:		["Make sure the delta is 0"		(scroller offset y == 0) 				ifFalse:[ scroller offset: (scroller offset x@0) ]].				(wasHShowing and: [self hIsScrollbarShowing not]) ifTrue:		[(scroller offset x <= 0)				ifFalse:[ scroller offset: (self hMargin negated@scroller offset y)]].! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 12/25/2002 16:30'!hideScrollBars	self		vHideScrollBar;		hHideScrollBar! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 11:09'!scrollBy: delta	"Move the contents in the direction delta."	| newYoffset r newXoffset |		"Set the offset on the scroller"	newYoffset _ scroller offset y - delta y max: 0.	newXoffset _ scroller offset x - delta x max: -3.		scroller offset: newXoffset@ newYoffset.	"Update the scrollBars"	(r _ self vLeftoverScrollRange) = 0		ifTrue: [scrollBar value: 0.0]		ifFalse: [scrollBar value: newYoffset asFloat / r].	(r _ self hLeftoverScrollRange) = 0		ifTrue: [hScrollBar value: -3.0]		ifFalse: [hScrollBar value: newXoffset asFloat / r]! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 12/25/2002 16:35'!showScrollBars	self  vShowScrollBar; hShowScrollBar! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 12/25/2002 16:31'!vHideOrShowScrollBar	self vIsScrollbarNeeded		ifTrue:[ self vShowScrollBar ]		ifFalse:[ self vHideScrollBar ].! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 12:07'!vHideScrollBar	self vIsScrollbarShowing ifFalse: [^self].	self removeMorph: scrollBar.	retractableScrollBar ifFalse: [self resetExtent].	! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 10:26'!vIsScrollbarNeeded"Return whether the verticle scrollbar is needed"	"Don't do anything with the retractable scrollbar unless we have focus"	retractableScrollBar & self hasFocus not ifTrue: [^false].		"Don't show it if we were told not to."	(self valueOfProperty: #noVScrollBarPlease ifAbsent: [false]) ifTrue: [^false].	"Always show it if we were told to"	(self valueOfProperty: #vScrollBarAlways ifAbsent: [false]) ifTrue: [^true].		^self vIsScrollable! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 12/25/2002 16:32'!vScrollBarValue: scrollValue	scroller hasSubmorphs ifFalse: [^ self].	scroller offset: (scroller offset x @ (self vLeftoverScrollRange * scrollValue) rounded)! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 13:22'!vShowScrollBar	self vIsScrollbarShowing ifTrue: [^ self].	self vResizeScrollBar.	self privateAddMorph: scrollBar atIndex: 1.	retractableScrollBar ifFalse: [self resetExtent]! !!PluggableListMorph methodsFor: 'geometry' stamp: 'sps 3/9/2004 15:33'!extent: newExtent	super extent: newExtent.		"Change listMorph's bounds to the new width. It is either the size	of the widest list item, or the size of self, whatever is bigger"	self listMorph width: ((self width max: listMorph hUnadjustedScrollRange) + 20). ! !!PluggableListMorph methodsFor: 'geometry' stamp: 'sps 3/9/2004 17:31'!scrollDeltaWidth"A guess -- assume that the width of a char is approx 1/2 the height of the font"	^ self scrollDeltaHeight // 2! !!PluggableListMorph methodsFor: 'scrolling' stamp: 'sps 12/24/2002 18:31'!hExtraScrollRange	"Return the amount of extra blank space to include to the right of the scroll content."	^5 ! !!PluggableListMorph methodsFor: 'scrolling' stamp: 'sps 3/9/2004 15:18'!hUnadjustedScrollRange"Return the width of the widest item in the list"	^self listMorph hUnadjustedScrollRange! !!PluggableListMorph methodsFor: 'scrolling' stamp: 'sps 12/26/2002 13:36'!vUnadjustedScrollRange	"Return the height extent of the receiver's submorphs."	(scroller submorphs size > 0) ifFalse:[ ^0 ].	^(scroller submorphs last fullBounds bottom)! !!PluggableMultiColumnListMorph methodsFor: 'scrolling' stamp: 'sps 3/23/2004 15:51'!hUnadjustedScrollRange"Return the width of the widest item in the list"	| max stringW |	max _ 0.	scroller submorphsDo: [ :each |		stringW _ each font widthOfStringOrText: each contents.		max _ max max: (each bounds left + stringW).	].	^max ! !!PluggableTextMorph methodsFor: 'scrolling' stamp: 'sps 3/9/2004 15:55'!hUnadjustedScrollRange"Return the width of the widest item in the list"	textMorph ifNil: [ ^0 ].	textMorph isWrapped ifTrue:[ ^0 ].	^super hUnadjustedScrollRange! !!SimpleHierarchicalListMorph methodsFor: 'geometry' stamp: 'sps 3/9/2004 17:31'!scrollDeltaWidth"A guess -- assume that the width of a char is approx 1/2 the height of the font"	^ self scrollDeltaHeight // 2! !!SimpleHierarchicalListMorph methodsFor: 'scrolling' stamp: 'sps 12/24/2002 18:31'!hExtraScrollRange	"Return the amount of extra blank space to include below the bottom of the scroll content."	^5! !!SimpleHierarchicalListMorph methodsFor: 'scrolling' stamp: 'sps 3/23/2004 15:51'!hUnadjustedScrollRange"Return the width of the widest item in the list"	| max right stringW count |	max _ 0.	count _ 0.	scroller submorphsDo: [ :each |		stringW _ each font widthOfStringOrText: each contents.		right _ (each toggleRectangle right + stringW + 10).		max _ max max: right.		"NOTE: need to optimize this method by caching list item morph widths (can init that cache most efficiently in the #list: method before the item widths are reset to 9999).  For now, just punt on really long lists"		((count _ count + 1) > 200) ifTrue:[ ^max * 3].	].	^max ! !!SimpleHierarchicalListMorph methodsFor: 'scrolling' stamp: 'sps 12/26/2002 13:37'!vUnadjustedScrollRange"Return the width of the widest item in the list"	(scroller submorphs size > 0) ifFalse:[ ^0 ].	^scroller submorphs last fullBounds bottom! !!TransformMorph methodsFor: 'accessing' stamp: 'sps 12/28/2002 02:09'!quickAddAllMorphs: aCollection"A fast add of all the morphs for the PluggableListMorph>>list: method to use -- assumes that fullBounds will get called later by the sender, so it avoids doing any updating on the morphs in aCol or updating layout of this scroller. So the sender should handle those tasks as appropriate"	| myWorld itsWorld |	myWorld _ self world.	aCollection do: [:m |		m owner ifNotNil: [			itsWorld _ m world.			itsWorld == myWorld ifFalse: [m outOfWorld: itsWorld].			m owner privateRemoveMorph: m].		m privateOwner: self.		"inWorld ifTrue: [self addedOrRemovedSubmorph: m]."		itsWorld == myWorld ifFalse: [m intoWorld: myWorld].		].	submorphs _ aCollection.	"self layoutChanged."! !ScrollPane removeSelector: #initializeScrollBar!ScrollPane removeSelector: #isRetractableScrollbarShowing!ScrollPane removeSelector: #isScrollable!ScrollPane removeSelector: #isScrollbarShowing!ScrollPane removeSelector: #isScrolled!ScrollPane removeSelector: #showScrollBar!ScrollPane removeSelector: #unadjustedScrollRange!ComponentLikeModel subclass: #ScrollPane	instanceVariableNames: 'scrollBar scroller retractableScrollBar scrollBarOnLeft getMenuSelector getMenuTitleSelector scrollBarHidden hasFocus hScrollBar'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!ScrollPane reorganize!('OBSOLETE' hideScrollBar hideScrollBarIndefinitely leftoverScrollRange resizeScrollBar scrollBarValue: scrollbarWidth totalScrollRange)('access' adoptPaneColor: flatColoredScrollBarLook hMargin hasFocus retractableScrollBar scrollBarOnLeft scroller scroller: wantsSlot)('access options' alwaysShowHScrollBar alwaysShowScrollBars alwaysShowVScrollBar hideHScrollBarIndefinitely hideScrollBarsIndefinitely hideVScrollBarIndefinitely showHScrollBarOnlyWhenNeeded showScrollBarsOnlyWhenNeeded showVScrollBarOnlyWhenNeeded)('accessing')('event handling' handlesMouseDown: handlesMouseOver: keyStroke: mouseDown: mouseEnter: mouseLeave: mouseMove: mouseUp: scrollByKeyboard:)('geometry' extent: extraScrollRange hExtraScrollRange hLeftoverScrollRange hResizeScrollBar hScrollBarWidth hSetScrollDelta hTotalScrollRange hUnadjustedScrollRange innerBounds resetExtent resizeScrollBars resizeScroller scrollBarThickness scrollDeltaHeight scrollDeltaWidth setScrollDeltas vExtraScrollRange vLeftoverScrollRange vResizeScrollBar vScrollBarHeight vSetScrollDelta vTotalScrollRange vUnadjustedScrollRange)('geometry testing' containsPoint: hIsScrollable hIsScrollbarShowing hIsScrolled isAScrollbarShowing isScrolledFromTop scrollBarFills: vIsScrollable vIsScrollbarShowing vIsScrolled)('initialization' defaultBorderColor hInitScrollBarTEMPORARY initialize initializePreferences initializeScrollBars)('menu' addCustomMenuItems:hand: getMenu: leftOrRight menuTitleSelector: retractable: retractableOrNot scrollBarOnLeft:)('pane events')('scroll bar events' hScrollBarMenuButtonPressed: scrollBarMenuButtonPressed: shiftedTextPaneMenuRequest shiftedYellowButtonActivity unshiftedYellowButtonActivity vScrollBarMenuButtonPressed: yellowButtonActivity:)('scrolling' hHideOrShowScrollBar hHideScrollBar hIsScrollbarNeeded hScrollBarValue: hShowScrollBar hideOrShowScrollBar hideOrShowScrollBars hideScrollBars scrollBy: scrollToShow: showScrollBars vHideOrShowScrollBar vHideScrollBar vIsScrollbarNeeded vScrollBarValue: vShowScrollBar)!Preferences class removeSelector: #hiddenScrollBars!"Postscript:Add the hScrollBar to any existing ScrollPanes."Cursor wait showWhile: [ScrollPane withAllSubclassesDo: [:cls |	cls allInstancesDo: [ :i |		i hInitScrollBarTEMPORARY	]]].(Preferences preferenceAt: #hiddenScrollBars) ifNotNil: 	[Preferences removePreference:  #hiddenScrollBars].Preferences preferenceAt: #alwaysShowVScrollbar ifAbsent: 	[Preferences 		addPreference: #alwaysShowVScrollbar		category: #scrolling		default: true		balloonHelp: 'If true, verticle scrollbar appears even if it''s not needed. Useful if you want the menu button accessable at all times'].Preferences preferenceAt: #alwaysShowHScrollbar ifAbsent: 	[Preferences 		addPreference: #alwaysShowHScrollbar		category: #scrolling		default: false		balloonHelp: 'If true, horizontal scrollbar appears even if it''s not needed.'].!