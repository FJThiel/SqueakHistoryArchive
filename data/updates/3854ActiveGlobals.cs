'From Squeak3.1alpha of 4 February 2001 [latest update: #3862] on 18 March 2001 at 1:57:53 am'!"Change Set:		ActiveGlobalsDate:			22 January 2001Author:			Andreas RaabThis change set introduces three dynamic globals for use in Morphic:ActiveWorld - the world currently in control of handling some event. Usually ActiveWorld is identical with World but for embedded worlds the world will change when event handling reaches the new (inner world) and will be restored when event handling leaves it.ActiveHand - the hand that issued the event responsible for the current action. In a multi-user setup, this hand identifies which user-incarnation invoked the action. Inbetween event handling cycles the ActiveHand is equivalent to the Worlds primary hand [*1].ActiveEvent - the event responsible for the current action. Inbetween event handling cycles the ActiveEvent is nil. It is therefore safer to use ActiveHand for code which cannot be sure if it is run outside of event handling cycles (e.g., during stepping) [*1].The change set establishes the following notions:* World - is always the outermost world. Never nil when in Morphic.* ActiveWorld - is always the 'innermost' world control of the current event/step cycle. Never nil when in Morphic.* ActiveHand - is always the hand controlling the current action. Never nil when in Morphic.* ActiveEvent - is the event triggering the current action. nil if action was not triggered (neither directly nor indirectly) by a user input event.Also, the change set introduces HandMorph>>cursorPoint as a dynamic equivalent of Sensor>>cursorPoint when used in embedded worlds. HandMorph>>cursorPoint will transform its position into the currently active world so that a client sees no difference if running in an embedded world. This greatly simplifies matters when we're trying to put up something next to the current mouse (hand) position and allows for a convenient MVC/Morphic compatibility pattern by using:	(ActiveHand ifNil:[Sensor]) cursorPoint.which can be used in places where MVC compatibility matters and will work correctly even when used in embedded worlds, unless the position of the active hand in *its* (outer) world is needed (in which case ActiveHand>>position should be used).[*1] The reason for making the world's primary hand the ActiveHand inbetween cycles is that most simple-minded code will not really care about what hand is returned inbetween event handling cycles. Code that *does* care can check ActiveEvent to see if it was invoked in a regular event cycle or not.As an example, the change set fixes various issues due to incorrectly computed z-orders when modal loops where used (such as for FITBM) as a direct response to some event. Since HandMorph can now check if it was invoked inside or outside the event cycle it can re-establish the z-order when a modal loop is detected."Smalltalk at: #ActiveWorld put: nil.Smalltalk at: #ActiveHand put: nil.Smalltalk at: #ActiveEvent put: nil.!!Object methodsFor: 'private' stamp: 'ar 3/17/2001 23:52'!primitiveError: aString 	"This method is called when the error handling results in a recursion in 	calling on error: or halt or halt:."	| context |	Sensor eventQueue: nil. "Or else we won't get keyboard and possibly run out of memory"	(String		streamContents: 			[:s |			s nextPutAll: '***System error handling failed***'.			s cr; nextPutAll: aString.			context _ thisContext sender sender.			20 timesRepeat: [context == nil ifFalse: [s cr; print: (context _ context sender)]].			s cr; nextPutAll: '-------------------------------'.			s cr; nextPutAll: 'Type CR to enter an emergency evaluator.'.			s cr; nextPutAll: 'Type any other character to restart.'])		displayAt: 0 @ 0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard = Character cr ifTrue: [Transcripter emergencyEvaluator].	Smalltalk isMorphic		ifTrue: [World install "init hands and redisplay"]		ifFalse: [ScheduledControllers searchForActiveController]! !!Object methodsFor: 'macpal' stamp: 'ar 3/18/2001 00:03'!currentEvent	"Answer the current Morphic event.  This method never returns nil."	^ActiveEvent ifNil:[self currentHand lastEvent]! !!Object methodsFor: 'macpal' stamp: 'ar 3/18/2001 00:03'!currentHand	"Return a usable HandMorph -- the one associated with the object's current environment.  This method will always return a hand, even if it has to conjure one up as a last resort.  If a particular hand is actually handling events at the moment (such as a remote hand or a ghost hand), it will be returned."	^ActiveHand! !!Object methodsFor: 'macpal' stamp: 'ar 3/18/2001 00:08'!currentWorld	"Answer a morphic world that is the current UI focus.		If in an embedded world, it's that world.		If in a morphic project, it's that project's world.  		If in an mvc project, it is the topmost morphic-mvc-window's worldMorph. 		If in an mvc project that has no morphic-mvc-windows, then it's just some existing worldmorph instance.		If in an mvc project in a Squeak that has NO WorldMorph instances, one is created.	This method will never return nil, it will always return its best effort at returning a relevant world morph, but if need be -- if there are no worlds anywhere, it will create a new one."	| aView aSubview |	ActiveWorld ifNotNil:[^ActiveWorld].	World ifNotNil:[^World].	aView _ ScheduledControllers controllerSatisfying:		[:ctrl | (aSubview _ ctrl view firstSubView) notNil and:			[aSubview model isMorph and: [aSubview model isWorldMorph]]].	^aView		ifNotNil:			[aSubview model]		ifNil:			[MVCWiWPasteUpMorph newWorldForProject: nil].! !!Object methodsFor: 'world hacking' stamp: 'ar 3/17/2001 23:45'!couldOpenInMorphic        "is there an obvious morphic world in which to open a new morph?"        ^World notNil or: [ActiveWorld notNil]! !!Debugger methodsFor: 'private' stamp: 'ar 3/17/2001 23:54'!resumeProcess: aTopView 	Smalltalk isMorphic		ifFalse: [aTopView erase].	savedCursor		ifNotNil: [Sensor currentCursor: savedCursor].	isolationHead		ifNotNil: [failedProject enterForEmergencyRecovery.			isolationHead invoke.			isolationHead _ nil].	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate)		ifFalse: [contextStackIndex > 1				ifTrue: [interruptedProcess popTo: self selectedContext]				ifFalse: [interruptedProcess install: self selectedContext].			Smalltalk isMorphic				ifTrue: [errorWasInUIProcess						ifTrue: [Project resumeProcess: interruptedProcess]						ifFalse: [interruptedProcess resume]]				ifFalse: [ScheduledControllers activeControllerNoTerminate: interruptedController andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil.	"Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: [aTopView delete.			World displayWorld]		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.	"restart low space handler"	errorWasInUIProcess == false		ifFalse: [Processor terminateActive]! !!DisplayScreen methodsFor: 'other' stamp: 'ar 3/17/2001 23:53'!restore	Smalltalk isMorphic		ifTrue: [World fullRepaintNeeded]		ifFalse: [ScheduledControllers unCacheWindows; restore].! !!DisplayScreen methodsFor: 'other' stamp: 'ar 3/17/2001 23:53'!restoreAfter: aBlock	"Evaluate the block, wait for a mouse click, and then restore the screen."	aBlock value.	Sensor waitButton.	Smalltalk isMorphic		ifTrue: [World fullRepaintNeeded]		ifFalse: [(ScheduledControllers restore; activeController) view emphasize]! !!DisplayScreen class methodsFor: 'display box access' stamp: 'ar 3/18/2001 00:00'!checkForNewScreenSize	Display extent = DisplayScreen actualScreenSize ifTrue: [^ self].	DisplayScreen startUp.	Smalltalk isMorphic		ifTrue: [World restoreMorphicDisplay]		ifFalse: [ScheduledControllers restore; searchForActiveController]! !!FileList methodsFor: 'file list menu' stamp: 'ar 3/17/2001 23:42'!openBookFromFile	"Reconstitute a Morph from the selected file, presumed to be represent	a Morph saved via the SmartRefStream mechanism, and open it in an	appropriate Morphic world"	| book aFileStream |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ directory readOnlyFileNamed: self fullName.	book _ BookMorph new.	book setProperty: #url toValue: aFileStream url.	book fromRemoteStream: aFileStream.	aFileStream close.	Smalltalk isMorphic 		ifTrue: [ActiveWorld addMorphsAndModel: book]		ifFalse:			[book isMorph ifFalse: [^ self errorMustBeMorph].			book openInWorld].	book goToPage: 1! !!FileList methodsFor: 'file list menu' stamp: 'ar 3/17/2001 23:42'!openMorphFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved	via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ directory readOnlyFileNamed: self fullName.	morphOrList _ aFileStream fileInObjectAndCode.	(morphOrList isKindOf: SqueakPage) ifTrue: [morphOrList _ morphOrList contentsMorph].	Smalltalk isMorphic		ifTrue: [ActiveWorld addMorphsAndModel: morphOrList]		ifFalse:			[morphOrList isMorph ifFalse: [^ self errorMustBeMorph].			morphOrList openInWorld]! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'ar 3/18/2001 00:53'!request: queryString 	"Create an instance of me whose question is queryString. Invoke it 	centered at the cursor, and answer the string the user accepts. Answer 	the empty string if the user cancels."	"FillInTheBlank request: 'Your name?'"	^ self		request: queryString		initialAnswer: ''		centerAt: (ActiveHand ifNil:[Sensor]) cursorPoint! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'ar 3/18/2001 00:54'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given 	initial answer. Invoke it centered at the given point, and answer the 	string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank 		request: 'What is your favorite color?' 		initialAnswer: 'red, no blue. Ahhh!!'"	^ self		request: queryString		initialAnswer: defaultAnswer		centerAt: (ActiveHand ifNil:[Sensor]) cursorPoint! !!HttpUrl methodsFor: 'downloading' stamp: 'ar 3/18/2001 00:54'!askNamePassword	"Authorization is required by the host site.  Ask the user for a userName and password.  Encode them and store under this realm.  Return false if the user wants to give up."	| user password |	(self confirm: 'Host ', self toText, 'wants a different user and password.  Type them now?' orCancel: [false])		ifFalse: [^ false].	"Note: When Scamper is converted to run under MVC, we'll have to pass in topView in order to decide which FillInTheBlank to call."	user _ FillInTheBlank request: 'User account name?' initialAnswer: '' 				centerAt: (ActiveHand ifNil:[Sensor]) cursorPoint - (50@0).	password _ FillInTheBlank requestPassword: 'Password?'.	Passwords at: realm put: (Authorizer new encode: user password: password).	^ true! !!MethodFinder class methodsFor: 'as yet unclassified' stamp: 'ar 3/17/2001 23:34'!methodFor: dataAndAnswers	"Return a Squeak expression that computes these answers.  (This method is called by the comment in the bottom pane of a MethodFinder.  Do not delete this method.)"	| resultOC selFinder resultString |	resultOC _ (self new) load: dataAndAnswers; findMessage.	resultString _ String streamContents: [:strm |		resultOC do: [:exp | strm nextPut: $(; nextPutAll: exp; nextPut: $); space]].	Smalltalk isMorphic ifTrue: [		selFinder _ (ActiveWorld 				submorphThat: [:mm | mm class == SystemWindow and: 									[mm model isKindOf: SelectorBrowser]] 				ifNone: [^ resultString]) model.		selFinder searchResult: resultOC].	^ resultString! !!Morph methodsFor: 'structure' stamp: 'ar 3/18/2001 00:11'!activeHand	^ActiveHand! !!Morph methodsFor: 'structure' stamp: 'ar 3/18/2001 00:12'!outermostWorldMorph	| outer |	World ifNotNil:[^World].	self flag: #arNote. "stuff below is really only for MVC"	outer _ self outermostMorphThat: [ :x | x isWorldMorph].	outer ifNotNil: [^outer].	self isWorldMorph ifTrue: [^self].	^nil! !!Morph methodsFor: 'WiW support' stamp: 'ar 3/18/2001 00:14'!shouldGetStepsFrom: aWorld	^self world == aWorld! !!BookMorph methodsFor: 'menu' stamp: 'ar 3/17/2001 23:44'!getStemUrl	"Try to find the old place where this book was stored. Confirm with the 	user. Else ask for new place."	| initial pg url knownURL |	knownURL _ false.	initial _ ''.	(pg _ currentPage valueOfProperty: #SqueakPage)		ifNotNil: [pg contentsMorph == currentPage				ifTrue: [initial _ pg url.					knownURL _ true]].	"If this page has a url"	pages		doWithIndex: [:aPage :ind | initial isEmpty				ifTrue: [aPage isInMemory						ifTrue: [(pg _ aPage valueOfProperty: #SqueakPage)								ifNotNil: [initial _ pg url]]]].	"any page with a url"	initial isEmpty		ifTrue: [initial _ ServerDirectory defaultStemUrl , '1.sp'].	"A new legal place"	url _ knownURL		ifTrue: [initial]		ifFalse: [FillInTheBlank request: 'url of the place to store a typical page in this book.Must begin with file:// or ftp://' initialAnswer: initial].	^ SqueakPage stemUrl: url! !!BookMorph methodsFor: 'menu' stamp: 'ar 3/17/2001 23:44'!reload	"Fetch the pages of this book from the server again.  For all pages that have not been modified, keep current ones.  Use new pages.  For each, look up in cache, if time there is equal to time of new, and its in, use the current morph.	Later do fancy things when a page has changed here, and also on the server."	| url onServer onPgs sq which |	(url _ self valueOfProperty: #url) ifNil: ["for .bo index file"	url _ FillInTheBlank 		request: 'url of the place where this book''s index is stored.Must begin with file:// or ftp://' 		initialAnswer: (self getStemUrl, '.bo').	url size > 0 ifTrue: [self setProperty: #url toValue: url]				ifFalse: [^ self]].	onServer _ self class new fromURL: url.	"Later: test book times?"	onPgs _ onServer pages collect: [:out |		sq _ SqueakPageCache pageCache at: out url ifAbsent: [nil].		(sq ~~ nil and: [sq contentsMorph isInMemory])			ifTrue: [((out sqkPage lastChangeTime > sq lastChangeTime) or: 					  [sq contentsMorph == nil]) 						ifTrue: [SqueakPageCache atURL: out url put: out sqkPage.							out]						ifFalse: [sq contentsMorph]]			ifFalse: [SqueakPageCache atURL: out url put: out sqkPage.				out]].	which _ (onPgs findFirst: [:pg | pg url = currentPage url]) max: 1.	self newPages: onPgs currentIndex: which.		"later stay at current page"	self setProperty: #modTime toValue: (onServer valueOfProperty: #modTime).	self setProperty: #allText toValue: (onServer valueOfProperty: #allText).	self setProperty: #allTextUrls toValue: (onServer valueOfProperty: #allTextUrls).! !!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'ar 3/17/2001 23:40'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	w _ self world.	w ifNil: [^ response].	done _ false.	[done] whileFalse: [World doOneCycle].	self delete.	World doOneCycle.	^ response! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'ar 3/18/2001 00:54'!request: queryString	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlankMorph request: 'What is your favorite color?'"	^ self		request: queryString		initialAnswer: ''		centerAt: (ActiveHand ifNil:[Sensor]) cursorPoint! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'ar 3/18/2001 00:54'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlankMorph		request: 'What is your favorite color?'		initialAnswer: 'red, no blue. Ahhh!!'"	^ self		request: queryString		initialAnswer: defaultAnswer		centerAt: ActiveHand cursorPoint! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'ar 3/17/2001 23:43'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels.	This variant is only for calling from within a Morphic project."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	 ^ self 		request: queryString 		initialAnswer: defaultAnswer 		centerAt: aPoint 		inWorld: ActiveWorld! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 3/17/2001 23:40'!loadedFrames: aNumber 	self isStreaming		ifTrue: 			[activationKeys _ self collectActivationKeys: aNumber.			aNumber = 1				ifTrue: 					[activeMorphs addAll: activationKeys first.					self changed].			progressValue contents: aNumber asFloat / maxFrames.			"Give others a chance"			Smalltalk isMorphic				ifTrue: [World doOneCycle]				ifFalse: [Processor yield]].	loadedFrames _ aNumber! !!FlashPlayerMorph methodsFor: 'project transition' stamp: 'ar 3/17/2001 23:41'!playProjectTransitionFrom: oldProject to: newProject entering: aBoolean	"Play the transition from the old to the new project."	Smalltalk isMorphic ifFalse: [^ self]. "Not in MVC"	self stopPlaying.	owner ifNotNil:[		self stopStepping.		owner privateRemoveMorph: self.		owner _ nil].	aBoolean ifTrue:[		self updateProjectFillsFrom: newProject.	] ifFalse:[		self updateProjectFillsFrom: oldProject.		self setProperty: #transitionBackground toValue: newProject imageForm.	].	self frameNumber: 1.	self loopFrames: false.	(self valueOfProperty: #fullScreenTransition ifAbsent:[false])		ifTrue:[self bounds: self world bounds].	self comeToFront.	self startStepping.	self startPlaying.	[playing] whileTrue: [World doOneCycleNow].	self stopPlaying.	self stopStepping.	owner privateRemoveMorph: self.	owner _ nil.	self removeProperty: #transitionBackground.	Display deferUpdates: true.	ActiveWorld fullDrawOn: (Display getCanvas).	Display deferUpdates: false.! !!HandMorph methodsFor: 'initialization' stamp: 'ar 3/18/2001 01:25'!interrupted	"Something went wrong - we're about to bring up a debugger. 	Release some stuff that could be problematic."	self releaseAllFoci. "or else debugger might not handle clicks"	self resetGenie. "the same here"! !!HandMorph methodsFor: 'accessing' stamp: 'ar 3/18/2001 00:52'!cursorPoint	"Implemented for allowing embedded worlds in an event cycle to query a hand's position and get it in its coordinates. The same can be achieved by #point:from: but this is simply much more convenient since it will look as if the hand is in the lower world."	| pos |	pos _ self position.	(ActiveWorld == nil or:[ActiveWorld == owner]) ifTrue:[^pos].	^ActiveWorld point: pos from: owner.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 3/18/2001 01:47'!handleEvent: anEvent	| evt ofs |	owner ifNil:[^self].	evt _ anEvent.	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendMouseEvent: evt].ShowEvents == true ifTrue:[	ofs _ (owner hands indexOf: self) - 1 * 60.	evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	self keyboardFocus printString displayAt: (0@ofs)+(0@45).].	"Notify listeners"	self sendListenEvent: evt to: self eventListeners.	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: self keyboardListeners.		self sendKeyboardEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isDropEvent ifTrue:[		self sendEvent: evt focus: nil.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: self mouseListeners.		lastMouseEvent _ evt].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendMouseEvent: evt.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendMouseEvent: evt].	].	ShowEvents == true ifTrue:[self mouseFocus printString displayAt: (0@ofs) + (0@15)].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 3/18/2001 01:28'!processEvents	"Process user input events from the local input devices."	| evt evtBuf type hadAny |	ActiveEvent ifNotNil:[		"Meaning that we were invoked from within an event response.		Make sure z-order is up to date"		self mouseOverHandler processMouseOver: lastMouseEvent].			hadAny _ false.	[(evtBuf _ Sensor nextEvent) == nil] whileFalse:[		evt _ nil. "for unknown event types"		type _ evtBuf at: 1.		(type = EventTypeMouse)			ifTrue:[evt _ self generateMouseEvent: evtBuf].		(type = EventTypeKeyboard) 			ifTrue:[evt _ self generateKeyboardEvent: evtBuf].		(type = EventTypeDragDropFiles)			ifTrue:[evt _ self generateDropFilesEvent: evtBuf].		"All other events are ignored"		evt == nil ifFalse:[			"Finally, handle it"			self handleEvent: evt.			hadAny _ true.			"For better user feedback, return immediately after a mouse event has been processed."			evt isMouse ifTrue:[^self].		].	].	"note: if we come here we didn't have any mouse events"	(mouseClickState notNil) ifTrue:[		"No mouse events during this cycle. Make sure click states time out accordingly"		mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	hadAny ifFalse:[		"No pending events. Make sure z-order is up to date"		self mouseOverHandler processMouseOver: lastMouseEvent.	].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 3/17/2001 23:30'!dropMorph: aMorph event: anEvent	"Drop the given morph which was carried by the hand"	| event dropped |	self privateRemoveMorph: aMorph.	dropped _ aMorph.	(dropped hasProperty: #addedFlexAtGrab) 		ifTrue:[dropped _ aMorph removeFlexShell].	event _ DropEvent new setPosition: self position contents: dropped hand: self.	self sendEvent: event focus: nil.	event wasHandled ifFalse:[aMorph rejectDropMorphEvent: event].	aMorph owner == self ifTrue:[aMorph delete].	self mouseOverHandler processMouseOver: anEvent.! !!HandMorph methodsFor: 'private events' stamp: 'ar 3/18/2001 01:43'!sendEvent: anEvent focus: focusHolder	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."	^self sendEvent: anEvent focus: focusHolder clear:[nil]! !!HandMorph methodsFor: 'private events' stamp: 'ar 3/18/2001 01:42'!sendEvent: anEvent focus: focusHolder clear: aBlock	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."	| result |	focusHolder ifNotNil:[^self sendFocusEvent: anEvent to: focusHolder clear: aBlock].	ActiveEvent _ anEvent.	result _ owner processEvent: anEvent.	ActiveEvent _ nil.	^result! !!HandMorph methodsFor: 'private events' stamp: 'ar 3/18/2001 01:42'!sendFocusEvent: anEvent to: focusHolder clear: aBlock	"Send the event to the morph currently holding the focus"	| result w |	w _ focusHolder world ifNil:[^ aBlock value].	w becomeActiveDuring:[		ActiveHand _ self.		ActiveEvent _ anEvent.		result _ focusHolder handleFocusEvent: 			(anEvent transformedBy: (focusHolder transformedFrom: self)).	].	^result! !!HandMorph methodsFor: 'private events' stamp: 'ar 3/18/2001 01:46'!sendKeyboardEvent: anEvent	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."	^self sendEvent: anEvent focus: self keyboardFocus clear:[self keyboardFocus: nil]! !!HandMorph methodsFor: 'private events' stamp: 'ar 3/18/2001 01:45'!sendMouseEvent: anEvent	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."	^self sendEvent: anEvent focus: self mouseFocus clear:[self mouseFocus: nil]! !!HandMorph methodsFor: 'genie' stamp: 'NS 2/19/2001 19:59'!prepareMouseFocusChangeFrom: oldMorph to: newMorph	^ self genieGestureProcessor isNil or: 		[self genieGestureProcessor prepareMouseFocusChangeFrom: oldMorph to: newMorph]! !!MenuMorph methodsFor: 'control' stamp: 'ar 3/18/2001 00:33'!popUpEvent: evt in: aWorld	| h p |	"Present this menu in response to the given event."	h _ evt hand.	p _ h position truncated.	^self popUpAt: p forHand: h in: aWorld! !!MenuMorph methodsFor: 'control' stamp: 'ar 3/18/2001 00:33'!popUpForHand: hand in: aWorld	| p |	"Present this menu under control of the given hand."	p _ hand position truncated.	^self popUpAt: p forHand: hand in: aWorld! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'ar 3/17/2001 23:43'!displayAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	Smalltalk isMorphic ifFalse: [^ self].	ActiveWorld addMorph: self centeredNear: aPoint.	self world displayWorld.  "show myself"	aBlock value.	self delete! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'ar 3/17/2001 23:43'!informUserAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	| title w |	Smalltalk isMorphic ifFalse: [^ self].	title _ submorphs first submorphs first.	self visible: false.	w _ ActiveWorld.	aBlock value:[:string|		self visible ifFalse:[			w addMorph: self centeredNear: aPoint.			self visible: true].		title contents: string.		self setConstrainedPositionFrom: Sensor cursorPoint.		self changed.		w displayWorld		 "show myself"	]. 	self delete.	w displayWorld! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'ar 3/17/2001 23:54'!initializeNetworkIfFail: errorBlock	"Initialize the network drivers and record the semaphore to be used by the resolver. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails."	"NetNameResolver initializeNetworkIfFail: [self error: 'network initialization failed']"	| semaIndex result |	self resolverStatus = ResolverUninitialized		ifFalse: [			LastContact _ Time totalSeconds.  HaveNetwork _ true.			^ self].  "network is already initialized"	LastContact _ Time totalSeconds.  HaveNetwork _ false.	"in case abort"	ResolverSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: ResolverSemaphore.	Utilities informUser:'Initializing the network drivers; this maytake up to 30 seconds and can''t be interrupted'		during: [result _ self primInitializeNetwork: semaIndex].	Smalltalk isMorphic ifTrue:[World displayWorld].  "take the informer down"	"result is nil if network initialization failed, self if it succeeds"	result ifNil: [errorBlock value]		ifNotNil: [HaveNetwork _ true].! !!PasteUpMorph methodsFor: 'initialization' stamp: 'ar 3/17/2001 23:25'!becomeActiveDuring: aBlock	"Make the receiver the ActiveWorld during the evaluation of aBlock.	Note that this method does deliberately *not* use #ensure: to prevent	re-installation of the world on project switches."	| priorWorld priorHand priorEvent |	priorWorld _ ActiveWorld.	priorHand _ ActiveHand.	priorEvent _ ActiveEvent.	ActiveWorld _ self.	ActiveHand _ self hands first. "default"	ActiveEvent _ nil. "not in event cycle"	aBlock value.	ActiveWorld _ priorWorld.	ActiveEvent _ priorEvent.	ActiveHand _ priorHand.! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'ar 3/17/2001 23:53'!showDesignationsOfObjects	"Momentarily show the designations of objects on the receiver"	| colorToUse aLabel |	self isStackBackground ifFalse: [^ self].		self submorphsDo: [:aMorph | 		aMorph renderedMorph holdsSeparateDataForEachInstance 			ifTrue:				[colorToUse _ Color orange.				aLabel _ aMorph externalName]			ifFalse:				[colorToUse _ aMorph isShared					ifFalse:	[Color red]					ifTrue:	[Color green].				aLabel _ nil].		Display border: (aMorph fullBoundsInWorld insetBy:  -6) width: 6 rule: Form over fillColor: colorToUse.		aLabel ifNotNil:			[aLabel asString displayOn: Display at: (aMorph fullBoundsInWorld bottomLeft + (0 @ 5))]].	Sensor anyButtonPressed		ifTrue:	[Sensor waitNoButton]		ifFalse:	[Sensor waitButton].	World fullRepaintNeeded.! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 3/17/2001 23:57'!checkCurrentHandForObjectToPaste	| response |	self primaryHand pasteBuffer ifNil: [^self].	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			self primaryHand pasteBuffer printString.	response = 1 ifTrue: [self primaryHand pasteBuffer: nil].! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 3/17/2001 23:57'!checkCurrentHandForObjectToPaste2	self primaryHand pasteBuffer ifNil: [^self].	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		self primaryHand pasteBuffer printString.! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 3/18/2001 00:44'!install	owner _ nil.	"since we may have been inside another world previously"	ActiveWorld _ self.	ActiveHand _ self hands first. "default"	ActiveEvent _ nil.	submorphs do: [:ss | ss owner == nil ifTrue: [ss privateOwner: self]].		"Transcript that was in outPointers and then got deleted."	self viewBox: Display boundingBox.	Sensor eventQueue: SharedQueue new.	worldState handsDo: [:h | h initForEvents].	self installFlaps.	self borderWidth: 0. "default"	(Preferences showSecurityStatus and:[SecurityManager default isInRestrictedMode])		ifTrue:[self borderWidth: 2; borderColor: Color red].	self presenter allExtantPlayers do:[:player| player prepareToBeRunning].	SystemWindow noteTopWindowIn: self.	self displayWorldSafely.! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 3/18/2001 00:35'!restoreDisplay	World restoreMorphicDisplay.	"I don't actually expect this to be called"! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 3/17/2001 23:59'!restoreMorphicDisplay	DisplayScreen startUp.	self		extent: Display extent;		viewBox: Display boundingBox;		handsDo: [:h | h visible: true; showTemporaryCursor: nil];		restoreFlapsDisplay;		fullRepaintNeeded.	WorldState addDeferredUIMessage: [		Cursor normal show.	].! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 1/22/2001 14:31'!processEvent: anEvent using: defaultDispatcher	"Reimplemented to install the receiver as the new ActiveWorld if it is one"	| priorWorld result |	self isWorldMorph ifTrue:[^super processEvent: anEvent using: defaultDispatcher].	priorWorld _ ActiveWorld.	ActiveWorld _ self.	result _ super processEvent: anEvent using: defaultDispatcher.	ActiveWorld _ priorWorld.	^result! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 3/18/2001 00:35'!keystrokeInWorld: evt	"A keystroke was hit when no keyboard focus was in set, so it is sent here to the world instead.  This current implementation is regrettably hard-coded; until someone cleans this up, you may be tempted to edit this method to suit your personal taste in interpreting cmd-keys issued to the desktop."	|  aChar isCmd |	aChar _ evt keyCharacter.	isCmd _ evt commandKeyPressed and: [Preferences cmdKeysInText].	(isCmd and: [Preferences honorDesktopCmdKeys]) ifTrue:		[(aChar == $z) ifTrue: [^ self commandHistory undoOrRedoCommand].		(aChar == $w) ifTrue: [^ SystemWindow closeTopWindow].		(aChar == $\) ifTrue: [^ SystemWindow sendTopWindowToBack].		(aChar == $t) ifTrue: [^ self findATranscript: evt].		(aChar == $b) ifTrue: [^ Browser openBrowser].		(aChar == $k) ifTrue: [^ Workspace open].		(aChar == $m) ifTrue: [^ TheWorldMenu new adaptToWorld: World; newMorph].		(aChar == $C) ifTrue: [^ self findAChangeSorter: evt].		(aChar == $R) ifTrue: [^ self openRecentSubmissionsBrowser: evt].		(aChar == $P) ifTrue: [^ self findAPreferencesPanel: evt].		(aChar == $r) ifTrue: [^ World restoreMorphicDisplay].		(aChar == $W) ifTrue: [^ self invokeWorldMenu: evt]]			"This last item is a weirdo feature requested by the Open School in Fall of 2000 as a keyhole to the world menu in systems that normally do not offer a world menu"! !!PasteUpMorph class methodsFor: 'project' stamp: 'ar 3/18/2001 00:00'!startUp		World ifNotNil:[World restoreMorphicDisplay].! !!PluggableFileList methodsFor: 'StandardFileMenu' stamp: 'ar 3/18/2001 00:55'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor,	so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil at: (ActiveHand ifNil:[Sensor cursorPoint]).! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ar 3/18/2001 00:55'!startUpCenteredWithCaption: captionOrNil	"Differs from startUpWithCaption: by appearing with cursor in the menu,	and thus ready to act on mouseUp, without requiring user tweak to confirm"	^ self startUpWithCaption: captionOrNil at: (ActiveHand ifNil:[Sensor]) cursorPoint - (20@0)! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ar 3/18/2001 00:55'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor,	so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil at: (ActiveHand ifNil:[Sensor]) cursorPoint! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ar 3/18/2001 00:21'!startUpWithCaption: captionOrNil at: location	"Display the menu, with caption if supplied. Wait for the mouse button to go down,	then track the selection as long as the button is pressed. When the button is released, 	answer the index of the current selection, or zero if the mouse is not released over 	any menu item. Location specifies the desired topLeft of the menu body rectangle."	| maxHeight |	maxHeight _ Display height*3//4.	self frameHeight > maxHeight ifTrue:		[^ self			startUpSegmented: maxHeight			withCaption: captionOrNil			at: location].	Smalltalk isMorphic		ifTrue:[			selection _ Cursor normal showWhile:				[(MVCMenuMorph from: self title: captionOrNil) 					invokeAt: location 					in: ActiveWorld].			^ selection].	frame ifNil: [self computeForm].	Cursor normal showWhile:		[self			displayAt: location			withCaption: captionOrNil			during: [self controlActivity]].	^ selection! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'ar 3/17/2001 23:54'!noteThatFlag: prefSymbol justChangedTo: aBoolean 	"Provides a hook so that a user's toggling of a preference might precipitate some immediate action"	| keep |	prefSymbol == #useGlobalFlaps ifTrue:		[aBoolean			ifFalse:		"Turning off use of flaps"				[keep _ self confirm:'Do you want to preserve the existingglobal flaps for future use?'.				Utilities globalFlapTabsIfAny do:					[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: keep.					aFlapTab isInWorld ifTrue: [self error: 'Flap problem']].				keep ifFalse: [Utilities clobberFlapTabList]]			ifTrue:		"Turning on use of flaps"				[Smalltalk isMorphic ifTrue:					[self currentWorld enableGlobalFlaps]]].	prefSymbol == #roundedWindowCorners ifTrue: [World fullRepaintNeeded].	prefSymbol == #optionalButtons ifTrue:		[Utilities replacePartSatisfying: [:el | (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isKindOf: FileList]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  FileList openAsMorph applyModelExtent].	(prefSymbol == #optionalButtons  or: [prefSymbol == #annotationPanes]) ifTrue:		[Utilities replaceBrowserInToolsFlap].	(prefSymbol == #smartUpdating) ifTrue:		[SystemWindow allSubInstancesDo:			[:aWindow | aWindow amendSteppingStatus]].	(prefSymbol == #eToyFriendly) ifTrue:		[ScriptingSystem customizeForEToyUsers: aBoolean].	((prefSymbol == #infiniteUndo) and: [aBoolean not]) ifTrue:		[CommandHistory resetAllHistory].	(prefSymbol == #showProjectNavigator) ifTrue:		[Project current assureNavigatorPresenceMatchesPreference].	(prefSymbol == #largeTiles) ifTrue:		[^ self largeTilesSettingToggled].	prefSymbol == #universalTiles ifTrue:		[^ self universalTilesSettingToggled]! !!Project methodsFor: 'menu messages' stamp: 'ar 3/17/2001 23:51'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess |	(world isKindOf: StringMorph) ifTrue: [		self inform: 'This project is not all here. I will try to load a complete version.'.		^self loadFromServer: true	"try to get a fresh copy"	].	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [			CurrentProject finalExitActions.			CurrentProject makeThumbnail.			returningFlag == #specialReturn ifTrue: [				ProjectHistory forget: CurrentProject.		"this guy is irrelevant"				Project forget: CurrentProject.			] ifFalse: [				ProjectHistory remember: CurrentProject.			].		].	(revertFlag | saveForRevert | forceRevert) ifFalse: [		(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [			self storeToMakeRoom]].	CurrentProject abortResourceLoading.	Smalltalk isMorphic ifTrue: [CurrentProject world triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresentAndInMemory:					[:playerClass | playerClass allSubInstancesDo:						[:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject _ nil	] ifFalse: [		returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ World pauseEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			world transferRemoteServerFrom: old world.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		world repairEmbeddedWorlds.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess _ [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!Project methodsFor: 'menu messages' stamp: 'ar 3/17/2001 23:51'!enterForEmergencyRecovery	"This version of enter invokes an absolute minimum of mechanism.	An unrecoverable error has been detected in an isolated project.	It is assumed that the old changeSet has already been revoked.	No new process gets spawned here.  This will happen in the debugger."	self isCurrentProject ifTrue: [^ self].	CurrentProject saveState.	CurrentProject _ self.	Display newDepthNoRestore: displayDepth.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	World pauseEventRecorder.	world isMorph		ifTrue:			["Entering a Morphic project"			World _ world.			world install.			world triggerOpeningScripts]		ifFalse:			["Entering an MVC project"			World _ nil.			Smalltalk at: #ScheduledControllers put: world.			ScheduledControllers restore].	UIProcess _ Processor activeProcess.! !!Project methodsFor: 'menu messages' stamp: 'ar 3/18/2001 01:21'!saveState	"Save the current state in me prior to leaving this project"	changeSet _ Smalltalk changes.	thumbnail ifNotNil: [thumbnail hibernate].	Smalltalk isMorphic		ifTrue:			[world _ World.			world sleep.			ActiveWorld _ ActiveHand _ ActiveEvent _ nil]		ifFalse:			[world _ ScheduledControllers.			ScheduledControllers unCacheWindows].	Sensor eventQueue: nil. "Will be reinstalled by World>>install"	transcript _ Transcript.! !!Project methodsFor: 'file in/out' stamp: 'ar 3/17/2001 23:27'!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder |self halt.  "unused"	"world == World ifTrue: [^ false]."		"self inform: 'Can''t send the current world out'."	world isMorph ifFalse: [		self projectParameters at: #isMVC put: true.		^ false].	"Only Morphic projects for now"	world ifNil: [^ false].  world presenter ifNil: [^ false].	Utilities emptyScrapsBook.	world currentHand pasteBuffer: nil.	  "don't write the paste buffer."	world currentHand mouseOverHandler initialize.	  "forget about any references here"		"Display checkCurrentHandForObjectToPaste."	Command initialize.	world clearCommandHistory.	world fullReleaseCachedState; releaseViewers. 	world cleanseStepList.	world localFlapTabs size = world flapTabs size ifFalse: [		self error: 'Still holding onto Global flaps'].	world releaseSqueakPages.	ScriptEditorMorph writingUniversalTiles: (self projectParameterAt: #universalTiles ifAbsent: [false]).	holder _ Project allProjects.	"force them in to outPointers, where DiskProxys are made"	"Just export me, not my previous version"	revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].	self projectParameters removeKey: #revertToMe ifAbsent: [].	roots _ OrderedCollection new.	roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.	roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).	roots _ roots reject: [ :x | x isNil].	"early saves may not have active hand or thumbnail"	catList do: [:sysCat | 		(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |			roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].	is _ ImageSegment new copySmartRootsExport: roots asArray.		"old way was (is _ ImageSegment new copyFromRootsForExport: roots asArray)"	is state = #tooBig ifTrue: [^ false].	str _ ''.	"considered legal to save a project that has never been entered"	(is outPointers includes: world) ifTrue: [		str _ str, '\Project''s own world is not in the segment.' withCRs].	str isEmpty ifFalse: [		ans _ (PopUpMenu labels: 'Do not write file	Write file anyway	Debug') startUpWithCaption: str.		ans = 1 ifTrue: [			revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].			^ false].		ans = 3 ifTrue: [self halt: 'Segment not written']].	is writeForExportWithSources: aFileName inDirectory: aDirectory.	revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].	holder.	world flapTabs do: [:ft | 			(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].	is arrayOfRoots do: [:obj |		obj class == ScriptEditorMorph ifTrue: [obj unhibernate]].	^ true! !!Project methodsFor: 'file in/out' stamp: 'ar 3/17/2001 23:29'!exportSegmentWithChangeSet: aChangeSetOrNil fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder collector fd mgr |	"An experimental version to fileout a changeSet first so that a project can contain its own classes"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.world currentHand pasteBuffer: nil.	  "don't write the paste buffer."world currentHand mouseOverHandler initialize.	  "forget about any references here"	"Display checkCurrentHandForObjectToPaste."Command initialize.world clearCommandHistory.world fullReleaseCachedState; releaseViewers. world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages.ScriptEditorMorph writingUniversalTiles: (self projectParameterAt: #universalTiles ifAbsent: [false]).holder _ Project allProjects.	"force them in to outPointers, where DiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ OrderedCollection new.roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.roots add: world activeHand.	"; addAll: classList; addAll: (classList collect: [:cls | cls class])"roots _ roots reject: [ :x | x isNil].	"early saves may not have active hand or thumbnail"	fd _ aDirectory directoryNamed: self resourceDirectoryName.	fd assureExistance.	"Clean up resource references before writing out"	mgr _ self resourceManager.	self resourceManager: nil.	ResourceCollector current: ResourceCollector new.	ResourceCollector current localDirectory: fd.	ResourceCollector current baseUrl: self resourceUrl.	ResourceCollector current initializeFrom: mgr.	ProgressNotification signal: '2:findingResources' extra: '(collecting resources...)'.	"Must activate old world because this is run at #armsLength.	Otherwise references to ActiveWorld, ActiveHand, or ActiveEvent 	will not be captured correctly if referenced from blocks or user code."	world becomeActiveDuring:[		is _ ImageSegment new copySmartRootsExport: roots asArray.		"old way was (is _ ImageSegment new copyFromRootsForExport: roots asArray)"	].	self resourceManager: mgr.	collector _ ResourceCollector current.	ResourceCollector current: nil.	ProgressNotification signal: '2:foundResources' extra: ''.	is state = #tooBig ifTrue: [		collector replaceAll.		^ false].str _ ''."considered legal to save a project that has never been entered"(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		collector replaceAll.		^ false].	ans = 3 ifTrue: [		collector replaceAll.		self halt: 'Segment not written']].	is 		writeForExportWithSources: aFileName 		inDirectory: fd		changeSet: aChangeSetOrNil.	SecurityManager default signFile: aFileName directory: fd.	"Compress all files and update check sums"	collector forgetObsolete.	self storeResourceList: collector in: fd.	self storeHtmlPageIn: fd.	self compressFilesIn: fd to: aFileName in: aDirectory resources: collector.	"Now update everything that we know about"	mgr updateResourcesFrom: collector.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.collector replaceAll.world flapTabs do: [:ft | 		(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].is arrayOfRoots do: [:obj |	obj class == ScriptEditorMorph ifTrue: [obj unhibernate]].^ true! !!Project methodsFor: 'file in/out' stamp: 'ar 3/17/2001 23:57'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg.  *** Caller must be holding (Project alInstances) to keep subprojects from going out. ***"| is sizeHint |(World == world) ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ false].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World checkCurrentHandForObjectToPaste.world releaseSqueakPages.sizeHint _ self projectParameters at: #segmentSize ifAbsent: [0].is _ ImageSegment new copyFromRootsLocalFileFor: 			(Array with: world presenter with: world)	"world, and all Players"		 sizeHint: sizeHint.is state = #tooBig ifTrue: [^ false].is segment size < 2000 ifTrue: ["debugging" 	Transcript show: self name, ' only ', is segment size printString, 		'bytes in Segment.'; cr].self projectParameters at: #segmentSize put: is segment size.is extract; writeToFile: self name.^ true! !!Project methodsFor: 'file in/out' stamp: 'ar 3/17/2001 23:58'!storeSegmentNoFile	"For testing.  Make an ImageSegment.  Keep the outPointers in memory.  Also useful if you want to enumerate the objects in the segment afterwards (allObjectsDo:)"| is str |(World == world) ifTrue: [^ self].		" inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ self].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ self].	"Only Morphic projects for now"world ifNil: [^ self].  world presenter ifNil: [^ self]."Do this on project enter"World flapTabs do: [:ft | ft referent adaptToWorld: World].	"Hack to keep the Menu flap from pointing at my project""Preferences setPreference: #useGlobalFlaps toValue: false.""Utilities globalFlapTabsIfAny do:	[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: false].Utilities clobberFlapTabList.	""project world deleteAllFlapArtifacts.""self currentWorld deleteAllFlapArtifacts.	"Utilities emptyScrapsBook.World checkCurrentHandForObjectToPaste2.is _ ImageSegment new copyFromRootsLocalFileFor: 		(Array with: world presenter with: world)	"world, and all Players"	sizeHint: 0.is segment size < 800 ifTrue: ["debugging" 	Transcript show: self name, ' did not get enough objects'; cr.  ^ self beep].false ifTrue: [	str _ String streamContents: [:strm |		strm nextPutAll: 'Only a tiny part of the project got into the segment'.		strm nextPutAll: '\These are pointed to from the outside:' withCRs.		is outPointers do: [:out |			(out class == Presenter) | (out class == ScriptEditorMorph) ifTrue: [				strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]].			(is arrayOfRoots includes: out class) ifTrue: [strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]]]].	self inform: str.	^ is inspect].is extract."is instVarAt: 2 put: is segment clone."		"different memory"! !!Project class methodsFor: 'utilities' stamp: 'ar 3/18/2001 01:29'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	| suspendingList projectProcess |	Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].	ActiveHand ifNotNil:[ActiveHand interrupted].	ActiveWorld _ World. "reinstall active globals"	ActiveHand _ World primaryHand.	ActiveHand interrupted. "make sure this one's interrupted too"	ActiveEvent _ nil.	projectProcess _ self uiProcess.	"we still need the accessor for a while"	(suspendingList _ projectProcess suspendingList) == nil		ifTrue: [projectProcess == Processor activeProcess					ifTrue: [projectProcess suspend]]		ifFalse: [suspendingList remove: projectProcess.				projectProcess offList].	Debugger openInterrupt: labelString onProcess: projectProcess! !!ProjectViewMorph methodsFor: 'events' stamp: 'ar 3/18/2001 01:52'!enter	"Enter my project."	self world == self outermostWorldMorph ifFalse: [^1 beep]. "can't do this at the moment"	project class == DiskProxy ifFalse: [		(project world notNil and: [project world isMorph and:				[project world hasOwner: self outermostWorldMorph]]) ifTrue: [			^1 beep		"project is open in a window already"		].	].	project class == DiskProxy ifTrue: ["When target is not in yet"		self enterWhenNotPresent.	"will bring it in"		project class == DiskProxy ifTrue: [^self inform: 'Project not found']].	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	self showMouseState: 3.	project enter: false revert: false saveForRevert: false.! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'ar 3/17/2001 23:43'!maximumUsableArea	| allowedArea |	allowedArea _ Display usableArea.	Smalltalk isMorphic ifTrue: [		allowedArea _ allowedArea intersect: ActiveWorld viewBox	].	^allowedArea! !!ScreenController methodsFor: 'menu messages' stamp: 'ar 3/18/2001 00:00'!restoreDisplay 	"Clear the screen to gray and then redisplay all the scheduled views."	Smalltalk isMorphic ifTrue: [^ World restoreMorphicDisplay].	Display extent = DisplayScreen actualScreenSize		ifFalse:			[DisplayScreen startUp.			ScheduledControllers unCacheWindows].	ScheduledControllers restore! !!SqueakPage methodsFor: 'saving' stamp: 'ar 3/17/2001 23:36'!prePurge	"Return self if ready to be purged, or nil if not"	self isContentsInMemory ifFalse: [^ nil].	contentsMorph ifNil: [^ nil].  "out already"	url ifNil: [^ nil].	"just to be safe"	^ (World ~~ nil and: [contentsMorph world == World]) 		ifTrue: [nil "showing now"] ifFalse: [self]! !!SystemWindow methodsFor: 'top window' stamp: 'ar 3/17/2001 23:36'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColorToUse.	model modelSleep.	"Control boxes remain active, except in novice mode"	self submorphsDo: [:m |		m == labelArea ifFalse: [			m lock		]	].	labelArea submorphsDo: [:m |		(m == closeBox or: [m == collapseBox]) ifTrue: [			Preferences noviceMode ifTrue: [m lock]		] ifFalse: [			m lock		]	].	self world ifNotNil:  "clean damage now, so dont merge this rect with new top window"		[self world == World ifTrue: [self world displayWorld]].! !!TextMorphEditor methodsFor: 'events' stamp: 'ar 3/17/2001 23:40'!recognizeCharactersWhileMouseIn: box	"Recognize hand-written characters and put them into the receiving TextMorph.  Invokes Alan's character recognizer.  box is in world coordinates."	| aRecognizer |	Cursor marker showWhile:		[aRecognizer _ CharRecog new textMorph: morph.		aRecognizer recognizeAndDispatch:			[:char | morph handleInteraction:				[char == BS					ifTrue:						[self simulatedBackspace]					ifFalse:						[self simulatedKeystroke: char]] fromEvent: nil.			morph updateFromParagraph.			World doOneCycle]		until:			[(box containsPoint: Sensor cursorPoint) not]]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'ar 3/17/2001 23:40'!startMessageTally	(self confirm: 'MessageTally will start now,and stop when the cursor goesto the top of the screen') ifTrue:		[MessageTally spyOn:			[[Sensor peekMousePt y > 0] whileTrue: [World doOneCycle]]]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'ar 3/17/2001 23:40'!startThenBrowseMessageTally	(self confirm: 'MessageTally will start now,and stop when the cursor goesto the top of the screen')		ifTrue: [TimeProfileBrowser				onBlock: [[Sensor peekMousePt y > 10]						whileTrue: [World doOneCycle]]]! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 3/18/2001 00:35'!buildWorldMenu	"Build the menu that is put up when the screen-desktop is clicked on"	| menu |	menu _ MenuMorph new defaultTarget: self.	self colorForDebugging: menu.	menu addStayUpItem.	self fillIn: menu from: {		{'previous project' . { #myWorld . #goBack } }.		{'jump to project...' . { #myWorld . #jumpToProject } }.		{'save project on file...' . { #myWorld  . #saveOnFile } }.		{'load project from file...' . { self  . #loadProject } }.		nil}.	myWorld addUndoItemsTo: menu.		self fillIn: menu from: {		{'restore display (r)' . { World . #restoreMorphicDisplay } }.		nil}.	Preferences simpleMenus ifFalse:		[self fillIn: menu from: { 			{'open...' . { self  . #openWindow } }.			{'windows & flaps...' . { self  . #windowsDo } }.			{'changes...' . { self  . #changesDo } }}].	self fillIn: menu from: { 		{'help...' . { self  . #helpDo } }.		{'appearance...' . { self  . #appearanceDo } }}.	Preferences simpleMenus ifFalse:		[self fillIn: menu from: {			{'do...' . { Utilities . #offerCommonRequests} } }].	self fillIn: menu from: { 		nil.		{'new morph...' . { self  . #newMorph } }.		{'authoring tools...' . { self  . #scriptingDo } }.		{'playfield options...' . { self  . #playfieldDo } }.		{'projects...' . { self  . #projectDo } }}.	Preferences simpleMenus ifFalse:		[self fillIn: menu from: { 			{'print PS to file...' . { self  . #printWorldOnFile } }.			{'debug...' . { self  . #debugDo } }}].	self fillIn: menu from: { 		nil.		{'save' . { self  . #saveSession } }.		{'save as...' . { Smalltalk . #saveAs } }.		{'save and quit' . { self  . #saveAndQuit } }.		{'quit' . { self  . #quitSession } }}.	^ menu! !!TheWorldMenu methodsFor: 'action' stamp: 'ar 3/17/2001 23:46'!doMenuItem: aCollection with: event	| realTarget selector nArgs |	selector _ aCollection second.	nArgs _ selector numArgs.	realTarget _ aCollection first.	realTarget == #myWorld ifTrue: [realTarget _ myWorld].	realTarget == #myHand ifTrue: [realTarget _ myHand].	realTarget == #myProject ifTrue: [realTarget _ self projectForMyWorld].	^nArgs = 0 		ifTrue:[realTarget perform: selector]		ifFalse:[realTarget perform: selector with: event].! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'ar 3/17/2001 23:46'!loadPage	| theProject projectInfo url gotoPage theBook |	projectInfo _ listOfPages at: currentIndex.	url _ projectInfo at: 1.	gotoPage _ projectInfo at: 2 ifAbsent: [nil].	[Project fromUrl: url]			on: ProjectEntryNotification			do: [ :ex | 				self deleteCurrentPage.				theProject _ ex projectToEnter enterAsActiveSubprojectWithin: self world.				theProject world showExpandedView.				loadedProject _ theProject.				gotoPage ifNotNil: [					theBook _ loadedProject world findA: BookMorph.					theBook ifNotNil: [						theBook goToPage: gotoPage					].				].				^loadedProject			].! !!TransferMorphAnimation methodsFor: 'initialization' stamp: 'ar 3/17/2001 23:43'!on: aTransferMorph	self flag: #bob.		"there was a reference to World, but the class seems to be unused"	self color: Color transparent.	transferMorph _ aTransferMorph.	transferMorph addDependent: self.	ActiveWorld addMorph: self	"or perhaps aTransferMorph world"! !!Utilities class methodsFor: 'miscellaneous' stamp: 'ar 3/17/2001 23:36'!storeTextWindowContentsToFileNamed: aName	"Utilities storeTextWindowContentsToFileNamed: 'TextWindows'"	| windows aDict assoc aRefStream textToUse aTextView |	"there is a reference to World, but this method seems to be unused"	aDict _ Dictionary new.	Smalltalk isMorphic		ifTrue:			[windows _ World submorphs select: [:m | m isKindOf: SystemWindow].			windows do:				[:w | assoc _ w titleAndPaneText.				assoc ifNotNil:					[w holdsTranscript ifFalse:						[aDict add: assoc]]]]		ifFalse:			[windows _ ScheduledControllers controllersSatisfying:				[:c | (c model isMemberOf: StringHolder) or: [c model isKindOf: Workspace]].			windows do:				[:aController | 					aTextView _ aController view subViews detect: [:m | m isKindOf: PluggableTextView] ifNone: [nil].					textToUse _ aTextView						ifNil:		[aController model contents]						ifNotNil:	[aTextView controller text].  "The latest edits, whether accepted or not"					aDict at: aController view label put: textToUse]].	aDict size = 0 ifTrue: [^ self inform: 'no windows found to export.'].	aRefStream _ ReferenceStream fileNamed: aName.	aRefStream nextPut: aDict.	aRefStream close.	self inform: 'Done!!  ', aDict size printString, ' window(s) exported.'! !!Utilities class methodsFor: 'flaps' stamp: 'ar 3/17/2001 23:36'!replaceMenuFlap 	"if there is a menu flap, replace it with an updated one." 	| aFlapTab wasGlobal |	aFlapTab _ self currentMenuFlap ifNil: [^ self].	wasGlobal _ aFlapTab isGlobal.	self removeFlapTab: aFlapTab keepInList: false.	self addMenuFlap.  "This will be project local"	wasGlobal ifTrue:		[self currentMenuFlap toggleIsGlobalFlap].	Smalltalk isMorphic ifTrue: [World addGlobalFlaps]"Utilities replaceMenuFlap"! !!Utilities class methodsFor: 'flaps' stamp: 'ar 3/18/2001 00:01'!toggleFlapSuppressionInProject	Preferences useGlobalFlaps ifFalse:		[^ self inform: 'CAUTION!!  Global flaps are currently disabled, and must be reenabled for this option to be meaningful.'].	CurrentProjectRefactoring currentToggleFlapsSuppressed.	World ifNotNil:[World restoreMorphicDisplay].! !!WaveletCodec methodsFor: 'subclass responsibilities' stamp: 'ar 3/17/2001 23:44'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	| frameBase coeffs maxVal minVal c scale nullCount frameI outFrameSize threshold sm outStream cMin val |	threshold _ 2000.	fwt ifNil:		[samplesPerFrame _ self samplesPerFrame.		nLevels _ 8.		"Here are some sample mother wavelets, with the compression achieved on a		sample of my voice at a threshold of 2000:									compression achieved "		alpha _ 0.0.  beta _ 0.0.		"12.1"		alpha _ 1.72.  beta _ 1.51.	"14.0"		alpha _ -1.86.  beta _ -1.53.	"14.4"		alpha _ 1.28.  beta _ -0.86.	"15.9"		alpha _ -1.15.  beta _ 0.69.	"16.0"		fwt _ FWT new.		fwt nSamples: samplesPerFrame nLevels: nLevels.		fwt setAlpha: alpha beta: beta].	(outStream _ WriteStream on: dstByteArray from: dstIndex to: dstByteArray size)		nextNumber: 4 put: frameCount;		nextNumber: 4 put: samplesPerFrame;		nextNumber: 4 put: nLevels;		nextNumber: 4 put: alpha asIEEE32BitWord;		nextNumber: 4 put: beta asIEEE32BitWord.	frameBase _ srcIndex.	1 to: frameCount do:		[:frame | 		"Copy float values into the wavelet sample array"				fwt samples: ((frameBase to: frameBase + samplesPerFrame-1) 				collect: [:i | (srcSoundBuffer at: i) asFloat]).		"Compute the transform"		fwt transformForward: true.		frameI _ outStream position+1.  "Reserve space for frame size"		outStream nextNumber: 2 put: 0.		"Determine and output the scale for this frame"		coeffs _ fwt coeffs.		maxVal _ 0.0.  minVal _ 0.0.		5 to: coeffs size do:			[:i | c _ coeffs at: i.			c > maxVal ifTrue: [maxVal _ c].			c < minVal ifTrue: [minVal _ c]].		scale _ (maxVal max: minVal negated) / 16000.0.  "Will scale all to -16k..16k: 15 bits"		outStream nextNumber: 4 put: scale asIEEE32BitWord.		"Copy scaled values, with run-coded sequences of 0's, to destByteArray"		nullCount _ 0.		cMin _ threshold / scale.		5 to: coeffs size do:			[:i | c _ (coeffs at: i) / scale.			c abs < cMin			ifTrue: ["Below threshold -- count nulls."					nullCount _ nullCount + 1]			ifFalse: ["Above threshold -- emit prior null count and this sample."					nullCount > 0 ifTrue:						[nullCount <= 112						ifTrue: [outStream nextNumber: 1 put: nullCount-1]						ifFalse: [outStream nextNumber: 2 put: (112*256) + nullCount-1].						nullCount _ 0].						val _ c asInteger + 16384 + 32768.  "Map -16k..16k into 32k..64k"						outStream nextNumber: 2 put: val]].					nullCount > 0 ifTrue:						[nullCount <= 112						ifTrue: [outStream nextNumber: 1 put: nullCount-1]						ifFalse: [outStream nextNumber: 2 put: (112*256) + nullCount-1]].		outFrameSize _ outStream position+1 - frameI - 2.  "Write frame size back at the beginning"		(WriteStream on: dstByteArray from: frameI to: dstByteArray size)			nextNumber: 2 put: outFrameSize.		frameBase _ frameBase + samplesPerFrame]."This displays a temporary indication of compression achieved"sm _ TextMorph new contents: (((frameBase - srcIndex) *2.0 / (outStream position+1 - dstIndex) truncateTo: 0.1) printString , ' : 1') asText allBold.sm position: Sensor cursorPoint + (-20@30).ActiveWorld addMorph: sm.World doOneCycleNow.sm delete.	outStream position > dstByteArray size ifTrue:		["The calling routine only provides buffer space for compression of 2:1 or better.  If you are just testing things, you can increase it to, eg, codeFrameSize _ frameSize*3, which would be sufficient for a threshold of 0 (lossless conversion)."		self error: 'Buffer overrun'].	^ Array with: frameBase - srcIndex			with: outStream position+1 - dstIndex! !!WiWPasteUpMorph methodsFor: 'drawing' stamp: 'ar 3/18/2001 00:01'!restoreDisplay	World ifNotNil:[World restoreMorphicDisplay].	"I don't actually expect this to be called"! !!WorldState methodsFor: 'update cycle' stamp: 'ar 1/22/2001 14:26'!doOneCycleInBackground	"Do one cycle of the interactive loop. This method is called repeatedly when this world is not the active window but is running in the background."self halt.		"not ready for prime time"	"process user input events, but only for remote hands"	self handsDo: [:h |		(h isKindOf: RemoteHandMorph) ifTrue: [			ActiveHand _ h.			h processEvents.			ActiveHand _ nil]].	self runStepMethods.	self displayWorldSafely.! !!WorldState methodsFor: 'update cycle' stamp: 'ar 1/25/2001 17:42'!doOneCycleNowFor: aWorld	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	self flag: #bob.		"need to consider remote hands in lower worlds"	"process user input events"	LastCycleTime _ Time millisecondClockValue.	self handsDo: [:h |		ActiveHand _ h.		h processEvents.		ActiveHand _ nil	].	"the default is the primary hand"	ActiveHand _ self hands first.	aWorld runStepMethods.		"there are currently some variations here"	self displayWorldSafely: aWorld.! !!WorldState methodsFor: 'update cycle' stamp: 'ar 1/22/2001 14:26'!doOneSubCycleFor: aWorld	"Like doOneCycle, but preserves activeHand."	| currentHand |	currentHand _ ActiveHand.	self doOneCycleFor: aWorld.	ActiveHand _ currentHand! !!WorldState methodsFor: 'stepping' stamp: 'ar 3/18/2001 01:23'!runLocalStepMethodsIn: aWorld	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now morphToStep stepTime priorWorld |	now _ Time millisecondClockValue.	priorWorld _ ActiveWorld.	ActiveWorld _ aWorld.	self triggerAlarmsBefore: now.	stepList size = 0 ifTrue: [ActiveWorld _ priorWorld. ^ self].	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes: now].  "clock slipped"	[stepList isEmpty not and:[stepList first scheduledTime < now]] whileTrue:[		lastStepMessage _ stepList removeFirst.		morphToStep _ lastStepMessage receiver.		(morphToStep shouldGetStepsFrom: aWorld) ifTrue:[			lastStepMessage value: now.			lastStepMessage ifNotNil:[				stepTime _ lastStepMessage stepTime ifNil:[morphToStep stepTime].				lastStepMessage scheduledTime: now + (stepTime max: 1).				stepList add: lastStepMessage].		].		lastStepMessage _ nil.	].	lastStepTime _ now.	ActiveWorld _ priorWorld.! !!WorldState methodsFor: 'hands' stamp: 'ar 1/22/2001 14:26'!activeHand	^ ActiveHand! !!WorldState methodsFor: 'hands' stamp: 'ar 1/22/2001 14:26'!activeHand: aHandMorph	"still needed until event loop with old code goes away"	ActiveHand _ aHandMorph.! !!WorldState methodsFor: 'hands' stamp: 'ar 1/22/2001 14:26'!removeHand: aHandMorph	"Remove the given hand from the list of hands for this world."	(hands includes: aHandMorph) ifFalse: [^self].	hands _ hands copyWithout: aHandMorph.	ActiveHand == aHandMorph ifTrue: [ActiveHand _ nil].! !Viewer removeSelector: #worldMorphsDo:!ScriptEditorMorph removeSelector: #worldMorphsDo:!PluggableListMorph removeSelector: #worldMorphsDo:!HandMorph removeSelector: #position!HandMorph removeSelector: #sendFocusEvent:to:!Morph removeSelector: #bestGuessOfCurrentWorld!Morph removeSelector: #currentHand!Morph removeSelector: #worldMorphsDo:!Morph removeSelector: #worldUnderCursor!DisplayScreen removeSelector: #bestGuessOfCurrentWorld!DisplayScreen removeSelector: #changeMorphicWorldTo:!DisplayScreen removeSelector: #checkCurrentHandForObjectToPaste!DisplayScreen removeSelector: #checkCurrentHandForObjectToPaste2!DisplayScreen removeSelector: #doOneCycleMorphic!DisplayScreen removeSelector: #doOneCycleNowMorphic!DisplayScreen removeSelector: #getCurrentMorphicWorld!DisplayScreen removeSelector: #getOuterMorphicWorld!DisplayScreen removeSelector: #isCurrentMorphicWorld:!DisplayScreen removeSelector: #lastKnownCursorPoint!DisplayScreen removeSelector: #morphicWorldAt:!DisplayScreen removeSelector: #morphicWorldString!DisplayScreen removeSelector: #pauseMorphicEventRecorder!DisplayScreen removeSelector: #reinstallMorphicWorldAfterError!DisplayScreen removeSelector: #repaintMorphicDisplay!DisplayScreen removeSelector: #repaintMorphicDisplayNow!DisplayScreen removeSelector: #restoreMorphicDisplay!DisplayScreen removeSelector: #useTemporaryHandDuring:!BlockContext removeSelector: #valueWithWorld:!Smalltalk removeClassNamed: #RequestCurrentWorldNotification!Form subclass: #DisplayScreen	instanceVariableNames: 'clippingBox '	classVariableNames: 'DeferringUpdates DisplayChangeSignature ScreenSave '	poolDictionaries: ''	category: 'Graphics-Display Objects'!"Postscript:Install globals."World install.!