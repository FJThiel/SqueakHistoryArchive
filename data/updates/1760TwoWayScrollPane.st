'From Squeak2.6 of 12 October 1999 [latest update: #1559] on 17 November 1999 at 11:09:37 am'!ComponentLikeModel subclass: #TwoWayScrollPane	instanceVariableNames: 'getMenuSelector getMenuTitleSelector xScrollBar yScrollBar scroller '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!TwoWayScrollPane commentStamp: '<historical>' prior: 0!The scroller (a transform) of a scrollPane is driven by the scrollBar.  The scroll values vary from 0.0, meaning zero offset to 1.0 meaning sufficient offset such that the bottom of the scrollable material appears halfway down the pane.  The total distance to achieve this range is called the totalScrollRange.!!TwoWayScrollPane methodsFor: 'initialization' stamp: 'RAA 10/6/1998 19:43'!initialize	| |	super initialize.	borderWidth _ 2.  borderColor _ #inset.	yScrollBar := ScrollBar new model: self slotName: 'yScrollBar'.	yScrollBar borderWidth: 2; borderColor: #inset.	self addMorph: yScrollBar.	xScrollBar := ScrollBar new model: self slotName: 'xScrollBar'.	xScrollBar borderWidth: 2; borderColor: #inset.	self addMorph: xScrollBar.	scroller := TransformMorph new color: Color transparent.	scroller offset: 0@0.	self addMorph: scroller.	self on: #mouseEnter send: #mouseEnter: to: self.	self on: #mouseLeave send: #mouseLeave: to: self.	self extent: 150@120! !!TwoWayScrollPane methodsFor: 'access' stamp: 'sw 2/12/98 00:30'!colorForInsets	"My submorphs use the surrounding color"	| aColor |	(aColor _ owner color) ifKindOf: Color thenDo: [:c | ^ aColor].	"This workaround relates to cases where the scrollPane's color is not a true color but rather an InfiniteForm, which is not happy to be returned here"	^ Color white! !!TwoWayScrollPane methodsFor: 'access' stamp: 'RAA 10/6/1998 19:45'!scroller	^ scroller! !!TwoWayScrollPane methodsFor: 'access' stamp: 'di 6/7/97 10:42'!wantsSlot	"For now do it the old way, until we sort this out"	^ true! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 10/6/1998 18:40'!containsPoint: aPoint	(super containsPoint: aPoint) ifTrue: [^ true].	"Also include scrollbar when it is extended..."	"used to handle retractable scrolbar"	^ false! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'di 4/8/98 13:09'!extent: newExtent	super extent: (newExtent max: 36@16).	self resizeScrollBar; resizeScroller! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 10/6/1998 19:00'!resizeScrollBar	"used to handle left vs right scrollbar"	yScrollBar bounds: (bounds topLeft extent: 16 @ (bounds height - 16)).	xScrollBar bounds: ((bounds left + 16) @ (bounds bottom - 16)  extent: (bounds width - 16) @ 16).! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 10/6/1998 19:49'!resizeScroller	| inner |	"used to handle left vs right scrollbar"	inner _ self innerBounds.	scroller bounds: (inner topLeft + (16@0) corner: (inner bottomRight - (0@16)))! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 10/6/1998 18:40'!scrollBarFills: aRectangle	"Return true if a flop-out scrollbar fills the rectangle"	"used to handle retractable scrolbar"	^ false! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 5/6/1999 10:25'!scrollBy: delta	"Move the contents in the direction delta."	"For now, delta is assumed to have a zero x-component"	| r newOffset |	newOffset _ (scroller offset - delta max: 0@0) min: self totalScrollRange.	scroller offset: newOffset.	r _ self totalScrollRange.	r y = 0		ifTrue: [yScrollBar value: 0.0]		ifFalse: [yScrollBar value: newOffset y asFloat / r y].	r x = 0		ifTrue: [xScrollBar value: 0.0]		ifFalse: [xScrollBar value: newOffset x asFloat / r x].! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 5/11/1999 21:35'!totalScrollRange	| scrollerSubmorphBounds |	scrollerSubmorphBounds _ scroller submorphBounds encompass: 0@0.	^ 	(scrollerSubmorphBounds width - bounds width" + 48" max: 0)						@	(scrollerSubmorphBounds height - bounds height" + 18" max: 0)! !!TwoWayScrollPane methodsFor: 'retractable scroll bar' stamp: 'RAA 10/6/1998 18:38'!mouseEnter: event	"used to handle retractable scrolbar"! !!TwoWayScrollPane methodsFor: 'retractable scroll bar' stamp: 'RAA 10/6/1998 18:38'!mouseLeave: event	"used to handle retractable scrolbar"! !!TwoWayScrollPane methodsFor: 'pane events' stamp: 'di 5/7/1998 09:52'!handlesMouseDown: evt	^ true! !!TwoWayScrollPane methodsFor: 'pane events' stamp: 'di 7/3/1998 12:07'!handlesMouseOver: evt	^ true! !!TwoWayScrollPane methodsFor: 'pane events' stamp: 'RAA 10/6/1998 19:45'!keyStroke: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller submorphs last keyStroke: evt! !!TwoWayScrollPane methodsFor: 'pane events' stamp: 'RAA 10/6/1998 19:45'!mouseDown: evt	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseDown: (evt transformedBy: (scroller transformFrom: self))]! !!TwoWayScrollPane methodsFor: 'pane events' stamp: 'RAA 10/6/1998 19:45'!mouseMove: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseMove: (evt transformedBy: (scroller transformFrom: self))]! !!TwoWayScrollPane methodsFor: 'pane events' stamp: 'RAA 10/6/1998 19:45'!mouseUp: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseUp: (evt transformedBy: (scroller transformFrom: self))]! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!scrollBarMenuButtonPressed: event	^ self yellowButtonActivity: event shiftPressed! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!shiftedYellowButtonActivity	^ self yellowButtonActivity: true! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:32'!unshiftedYellowButtonActivity	^ self yellowButtonActivity: false! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 10/6/1998 22:38'!xScrollBarMenuButtonPressed: event	^ self yellowButtonActivity: event shiftPressed! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 10/6/1998 22:03'!xScrollBarValue: scrollValue 	scroller hasSubmorphs ifFalse: [^ self].	scroller offset: self totalScrollRange x * scrollValue @ scroller offset y! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 10/6/1998 22:37'!yScrollBarMenuButtonPressed: event	^ self yellowButtonActivity: event shiftPressed! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 10/6/1998 19:45'!yScrollBarValue: scrollValue	scroller hasSubmorphs ifFalse: [^ self].	scroller offset: scroller offset x @ (self totalScrollRange y * scrollValue)! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 4/30/1999 10:38'!yellowButtonActivity: shiftKeyState	| menu event |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[event _ self primaryHand lastEvent.		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!TwoWayScrollPane methodsFor: 'menu' stamp: 'RAA 10/6/1998 18:39'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	"used to handle retractable scrolbar"! !!TwoWayScrollPane methodsFor: 'menu' stamp: 'sw 9/23/1998 08:47'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu aTitle |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	aTitle _ getMenuTitleSelector ifNotNil: [model perform: getMenuTitleSelector].	getMenuSelector numArgs = 1 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	getMenuSelector numArgs = 2 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu with: shiftKeyState.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!TwoWayScrollPane methodsFor: 'menu' stamp: 'RAA 10/6/1998 18:41'!leftOrRight  "Change scroll bar location"	"used to handle left vs right scrollbar"! !!TwoWayScrollPane methodsFor: 'menu' stamp: 'sw 8/18/1998 12:38'!menuTitleSelector: aSelector	getMenuTitleSelector _ aSelector! !!TwoWayScrollPane methodsFor: 'menu' stamp: 'RAA 10/6/1998 18:38'!retractableOrNot  "Change scroll bar operation"	"used to handle retractable scrolbar"! !!TwoWayScrollPane methodsFor: 'menu' stamp: 'RAA 10/6/1998 18:41'!scrollBarOnLeft: aBoolean	"used to handle left vs right scrollbar"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TwoWayScrollPane class	instanceVariableNames: ''!!TwoWayScrollPane class methodsFor: 'as yet unclassified' stamp: 'di 2/21/98 11:02'!includeInNewMorphMenu	"OK to instantiate"	^ true! !