'From Squeak 2.4b of April 23, 1999 on 6 May 1999 at 1:06:42 am'!"Change Set:		WCEHeadersDate:			6 May 1999Author:			Andreas RaabFixes the header files for Windows CE based machines."!!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 5/6/1999 01:03'!squeakConfigFile	^ '/* sqConfig.h -- platform identification and configuration */#if defined(__MWERKS__) && !!defined(macintosh)  /* CodeWarrior 8 neglects to define "macintosh" */# define macintosh#endif#if defined(WIN32) || defined(_WIN32) || defined(Win32)  /* Some compilers use different win32 definitions.     Define WIN32 so we have only to check for one symbol. */# if !!defined(WIN32)#  define WIN32# endif#endif#if defined(macintosh)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define SQ_CONFIG_DONE#endif#if defined(ACORN)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define USE_CLOCK_MSECS# define SQ_CONFIG_DONE#endif#if defined(WIN32)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# if defined(_M_IX86) || defined(X86)  /* x86 systems */#  define DOUBLE_WORD_ALIGNMENT#  define DOUBLE_WORD_ORDER  /* Note: We include a generic sqWin32.h to override some settings */#  include "sqWin32.h"#  define SQ_CONFIG_DONE# elif defined(_WIN32_WCE)#  include "sqWin32.h"#  define SQ_CONFIG_DONE# else#  error unsupported win32 processor type (alpha?!!)# endif#endif/* for Unix variants, this file must define the following symbols as appropriate:   HAS_D_NAMLEN      defined if struct dirent has d_namlen field and hence directory names      are not null terminated.  if underfined then directory names are null      terminated.   HAS_TIMEZONE      defined if the external variable timezone is available, containing the      local offset from GMT in seconds.  if  undefined then the tm structure      must contain the same information in the tm_gmtoff field.  (Consider      defining NEED_TZSET too!!)   HAS_ON_EXIT      defined if cleanup functions are declared with on_exit().  If      undefined then cleanup functions are declared with atexit().   HAS_MSB_FIRST      defined if the most significant byte is first in an int.   HAS_LSB_FIRST      defined if the least significant byte is first in an int.      (Complains if neither of the last two are defined.)   HAS_SUN_AUDIO      defined if the platform supports the Sun /dev/audio device.   DOUBLE_WORD_ALIGNMENT      defined if the platform CANNOT support double-word accesses at an      arbitrary word address.         DOUBLE_WORD_ORDER      defined if the platform stores floats in the opposite order      to the Squeak image (the image is always PowerPC order).   SUN_FUN_KEYS      defined for Sun type 3 or 4 keyboards to enable the editing keys      (Again, Undo, Copy, Paste, Cut, Find, Stop on the "left keypad",      and PgUp, PgDn, Home, End keys on the right keypad).   NEED_FILIO      defined if the platform requires <sys/filio.h> to be included      to get a definition for FIONBIO.   NEED_SELECT      defined if the platform requires <sys/select.h> to be included      to get definitions for select().   NEED_TZSET      defined if the platform required tzset() to be called explicitly      before reading the local wall clock.   JUMP_ALIGN_BYTE      defined if the platform has no instruction alignment restrictions      (e.g. Pentium).   JUMP_ALIGN_STRICT      defined if the platform has word-aligned instructions, and cannot      tolerate the low two bits of an address being non-zero (e.g.      Sparc).*/#if defined(sun) && (defined(sparc) || defined(__sparc))# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# include <errno.h># ifdef ECHRNG					/* Sparc/Solaris */#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_FILIO#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# else						/* Sparc/SunOS */#   include <unistd.h>#   define HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   define HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# endif#endif#if defined(sun) && defined(i386)		/* iX86/Solaris */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_FILIO# define NEED_TZSET# define JUMP_ALIGN_BYTE# define SQ_CONFIG_DONE#endif#if defined(mips) || defined(__mips)# if defined(_SYSTYPE_SVR4)			/* (SGI)/IRIX */#  if defined(SQ_CONFIG_DONE)#    error configuration conflict#  endif#  undef  HAS_D_NAMLEN#  define HAS_TIMEZONE#  undef  HAS_ON_EXIT#  define HAS_MSB_FIRST#  undef  HAS_SUN_AUDIO#  define  DOUBLE_WORD_ALIGNMENT#  undef  DOUBLE_WORD_ORDER#  define JUMP_ALIGN_STRICT#  define SQ_CONFIG_DONE# endif#endif#if defined(linux)# if defined(i386)				/* iX86/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define NEED_TZSET#   define JUMP_ALIGN_BYTE#  define SQ_CONFIG_DONE# endif# if defined(powerpc)				/* PPC/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif# if defined(arm)				/* SA110/Linux, maybe Itsy */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif#endif#if defined(__FreeBSD__)# if defined(i386)				/* iX86/FreeBSD */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define JUMP_ALIGN_BYTE#   define SQ_CONFIG_DONE# endif#endif#if defined(__alpha)				/* Alpha/OSF1 */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# undef  HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_TZSET# define SQ_CONFIG_DONE#endif#if defined(hpux) || defined (__hpux)		/* HPPA/HP-UX */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_TZSET  extern int h_errno;	/* loser!! */# define SQ_CONFIG_DONE#endif#if defined(_AIX) || defined(_M_UNIX)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN				/* IBM RS6000/AIX */# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_SELECT# define SQ_CONFIG_DONE#endif#if !!defined(SQ_CONFIG_DONE)# error test for, and describe, your architecture here.#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ar 5/6/1999 01:04'!squeakMachDepFile	^ '/* Platform/compiler dependent support for dynamic translation. */#if defined(__GNUC__)  /* GNU C on any platform */# define initOp(O)	(opcodeAddress= (int)(&&_op_##O) + 1)# if defined(JUMP_ALIGN_BYTE)    /* guarantee an even address for opcode start, then 1-byte no-op */#   define beginOp(O)	asm (".align 2"); _op_##O: asm("nop")# else#   define beginOp(O)	_op_##O:# endif# if defined(JUMP_ALIGN_STRICT)#   define nextOp()	({ goto *(void *)(*(int *)(localIP+= 4)-1); 0; })# else#   define nextOp()	({ goto *(void *)(*(int *)(localIP+= 4)); 0; })# endif# define endOp(O)	nextOp()#elif defined (macintosh)# if defined (__POWERPC__)    /* PowerMac: assumes CodeWarrior 8 or later (other compilers might barf) */#   pragma internal on    static asm int _setLabel(register int *ap, register int tmp)    {      mflr tmp			// address of insn after call site      addi tmp, tmp, 9	// address of opcode start + tag bit      stw  tmp, 0(ap)	// &opcode -> *store      li   r3, 1		// answer "true"      blr    }    static asm int _gotoLabel(register int ip)    {      mtlr ip	// destination address      blr		// dispatch    }#   pragma internal off# else /*!!__POWERPC__*/    /* 68K Mac: assumes CodeWarrior 8 or later (other compilers might barf) */    static asm int _setLabel(register int *ap, int ignored)    {      // the following is gross, but the 68K has a short branch range      // that is just large enough to be used in a few cases.  we have      // to find the opcode start address by "disassembling" the code      // following the call to _setLabel.  (efficiency is irrelevant.)      move.l	(sp), a0	// insn after call site	l:move.w	(a0)+, d0	// next insn	  and.w		#0xFF00, d0	// lose disp8	  cmp.w		#0x6600, d0	// BNE[.S]?	  bne.s		l			// not yet	  move.w	-2(a0), d0	// BNE[.S]	  tst.b		d0			// disp = 0?	  bne.s		s			// no [disp8]	  addq.l	#2, a0		// yes [disp16]	s:move.l	a0, d0		// opcode	  addq.l	#1, d0		// + tag	  move.l	4(sp), a0	// &store      move.l	d0, (a0)	// op -> *store      rts					// ^true    }    static asm int _gotoLabel(register int ip)    {      // I think this is optimal (speedwise), but my 68k is very rusty.      // (the 68020 can probably do the double indirection with index in      // a single instruction, but I''m not convinced it''s any faster.)      // please submit a better (i.e. faster) solution if you have one!!      addq.l	#4, sp		// drop ret addr      move.l	(sp)+, a0	// pop ip      jmp		-1(a0)		// dispatch = ip - tag    }# endif /*!!__POWERPC__*/# define initOp(O)	_setLabel(&opcodeAddress, 0)# define beginOp(O)# define nextOp()	_gotoLabel(*(int *)(localIP+= 4))# define endOp(O)	nextOp()#elif defined(ACORN)# define initOp(O)	_setLabel(&opcodeAddress, 0)# define beginOp(O)# define nextOp()	_gotoLabel(*(int *)(localIP+= 4))# define endOp(O)	nextOp()#elif defined(WIN32)# if defined(_MSC_VER) && defined(_M_IX86)   /* MS VC++ on Intel x86 machines */   int __fastcall set_label(int *address);   int __fastcall goto_label_and_patch_sender(int ip);   int __fastcall goto_label(int ip);#  define initOp(O) set_label(&opcodeAddress)   /* the four nops give us a label after which the opcode sequence starts */#  define beginOp(O) __asm nop __asm nop __asm nop __asm nop#  define nextOp() goto_label_and_patch_sender(*(int*) (localIP += 4))#  define endOp(O) nextOp()# elif defined (_WIN32_WCE)    /* Ignored on Windows CE */# else   /* Drop me a note for your configuration -- ar */#  error "your win32 processor/compiler is not supported"# endif#else# error your platform/compiler is not supported#endif'.! !