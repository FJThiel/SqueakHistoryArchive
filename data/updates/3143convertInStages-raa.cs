'From Squeak2.9alpha of 17 July 2000 [latest update: #3201] on 22 December 2000 at 3:17:26 pm'!"Change Set:		convertInStagesDate:			22 December 2000Author:			Bob ArningSome improvements in the process of converting old instances encountered when loading a saved project. The primary change is the removal of all the various #convertabcdef0:xyz0: methods which could only convert an instance from one particular version to one other version. In their place, there will be a single method per class needing conversions: #convertToCurrentVersion:refStream:. Such methods will make the determination as to the structure of the old instance and perform any necessary conversion. This will enable reading a greater number of old instances without requiring an ever-growing suite of conversion methods."!!Object methodsFor: 'objects from disk' stamp: 'RAA 12/20/2000 16:51'!convertToCurrentVersion: varDict refStream: smartRefStrm	"subclasses should implement if they wish to convert old instances to modern ones"! !!CanvasEncoder methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:44'!convertToCurrentVersion: varDict refStream: smartRefStrm		cachingEnabled ifNil: [cachingEnabled _ true].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!ChangeSet methodsFor: 'converting' stamp: 'RAA 12/20/2000 16:02'!convertApril2000: varDict using: smartRefStrm	| cls info selector pair classChanges methodChanges methodRemoves classRemoves |	"These variables are automatically stored into the new instance:		('name' 'preamble' 'postscript' 'structures' 'superclasses' ).	This method is for additional changes.	It initializes the isolation variables, and then duplicates the logic fo		assimilateAllChangesFoundIn:."	revertable _ false.	isolationSet _ nil.	isolatedProject _ nil.	changeRecords _ Dictionary new.	classChanges _ varDict at: 'classChanges'.	classChanges keysDo:		[:className |	  	(cls _ Smalltalk classNamed: className) ifNotNil:			[info _ classChanges at: className ifAbsent: [Set new].			info do: [:each | self atClass: cls add: each]]].	methodChanges _ varDict at: 'methodChanges'.	methodRemoves _ varDict at: 'methodRemoves'.	methodChanges keysDo:		[:className |	  	(cls _ Smalltalk classNamed: className) ifNotNil:			[info _ methodChanges at: className ifAbsent: [Dictionary new].			info associationsDo:				[:assoc | selector _ assoc key.				(assoc value == #remove or: [assoc value == #addedThenRemoved])					ifTrue:						[assoc value == #addedThenRemoved							ifTrue: [self atSelector: selector class: cls put: #add].						pair _ methodRemoves at: {cls name. selector} ifAbsent: [nil] .						self removeSelector: selector class: cls priorMethod: nil lastMethodInfo: pair]					ifFalse: 						[self atSelector: selector class: cls put: assoc value]]]].	classRemoves _ varDict at: 'classRemoves'.	classRemoves do:		[:className | self noteRemovalOf: className].! !!ChangeSet methodsFor: 'converting' stamp: 'RAA 12/20/2000 17:57'!convertToCurrentVersion: varDict refStream: smartRefStrm		"major change - 4/4/2000"	varDict at: 'classChanges' ifPresent: [ :x | 		self convertApril2000: varDict using: smartRefStrm	].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!EventHandler methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:45'!convertToCurrentVersion: varDict refStream: smartRefStrm		"20 dec 2000 - only a few (old) conversion exists"	varDict at: 'mouseEnterLadenRecipient' ifPresent: [ :x | mouseEnterDraggingRecipient _ x].	varDict at: 'mouseEnterLadenSelector' ifPresent: [ :x | mouseEnterDraggingSelector _ x].	varDict at: 'mouseLeaveLadenRecipient' ifPresent: [ :x | mouseLeaveDraggingRecipient _ x].	varDict at: 'mouseLeaveLadenSelector' ifPresent: [ :x | mouseLeaveDraggingSelector _ x].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!FillInTheBlank methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:59'!convertToCurrentVersion: varDict refStream: smartRefStrm		varDict at: 'responseUponCancel' ifAbsent: [responseUponCancel _ ''].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 12/20/2000 11:07'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots. 	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal ccFixups receiverClasses |	self flag: #bobconv.		mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal 				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is not compatible'].	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		self reshapeClasses: mapFakeClassesToReal refStream: smartRefStream	].	receiverClasses _ self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:importedObject | 		importedObject class class == Metaclass ifTrue: [self declare: importedObject]].	arrayOfRoots do: [:importedObject | 		(importedObject isKindOf: Project) ifTrue: [			importedObject ensureChangeSetNameUnique.			Project addingProject: importedObject.			importedObject restoreReferences]].	arrayOfRoots do: [:importedObject | 		(importedObject respondsTo: #unhibernate) ifTrue: [			importedObject unhibernate].	"ScriptEditors and ViewerFlapTabs"		].	mapFakeClassesToReal isEmpty ifFalse: [		mapFakeClassesToReal keys do: [:aFake | 			aFake indexIfCompact > 0 ifTrue: [aFake becomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 12/20/2000 11:07'!reshapeClasses: mapFakeClassesToReal refStream: smartRefStream 	| bads allVarMaps perfect insts partials in out |	self flag: #bobconv.		partials _ OrderedCollection new.	bads _ OrderedCollection new.	allVarMaps _ IdentityDictionary new.	mapFakeClassesToReal keysAndValuesDo: [ :aFakeClass :theRealClass | 		(theRealClass indexIfCompact > 0) "and there is a fake class"			ifFalse: [insts _ aFakeClass allInstances]			ifTrue: ["instances have the wrong class.  Fix them before anyone notices."				insts _ OrderedCollection new.				self allObjectsDo: [:obj | obj class == theRealClass ifTrue: [insts add: obj]].			].		insts do: [ :misShapen | 			perfect _ smartRefStream convert1: misShapen to: theRealClass allVarMaps: allVarMaps.			bads 				detect: [ :x | x == misShapen] 				ifNone: [					bads add: misShapen.					partials add: perfect				].		].	].	bads isEmpty ifFalse: [		bads asArray elementsForwardIdentityTo: partials asArray	].	in _ OrderedCollection new.	out _ OrderedCollection new.	partials do: [ :each |		perfect _ smartRefStream convert2: each allVarMaps: allVarMaps.		in 			detect: [ :x | x == each]			ifNone: [				in add: each.				out add: perfect			]	].	in isEmpty ifFalse: [		in asArray elementsForwardIdentityTo: out asArray	].! !!Inspector methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:47'!convertToCurrentVersion: varDict refStream: smartRefStrm		timeOfLastListUpdate ifNil: [timeOfLastListUpdate _ 0].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!Morph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 16:42'!convertAugust1998: varDict using: smartRefStrm	"These variables are automatically stored into the new instance ('bounds' 'owner' 'submorphs' 'fullBounds' 'color' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('extension' ) and deal with the information in ('eventHandler' 'properties' 'costumee' )""This method moves all property variables as well as eventHandler, and costumee into a morphicExtension."	| propVal |	"Move refs to eventhandler and costumee into extension"	(varDict at: 'eventHandler') == nil ifFalse: [self eventHandler: (varDict at: 'eventHandler')].	(varDict at: 'costumee') == nil ifFalse: [self player: (varDict at: 'costumee')].	(varDict at: 'properties') == nil ifFalse:		[(varDict at: 'properties') keys do:			[:key |  "Move property extensions into extension"			propVal _ (varDict at: 'properties') at: key.			propVal ifNotNil:				[key == #possessive				ifTrue: [propVal == true ifTrue: [self bePossessive]]				ifFalse: [key ifNotNil: [					self assureExtension.					extension convertProperty: key toValue: propVal]]]].			].! !!Morph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 16:45'!convertNovember2000DropShadow: varDict using: smartRefStrm	| rend |	"Work hard to eliminate the DropShadow.  Inst vars are already stored into."	submorphs size > 0 ifTrue: [		rend _ submorphs first renderedMorph.	"a text?"		rend setProperty: #hasDropShadow toValue: true.		rend setProperty: #shadowColor toValue: (varDict at: 'color').		rend setProperty: #shadowOffset toValue: (varDict at: 'shadowOffset').		"ds owner ifNotNil: [ds owner addAllMorphs: ds submorphs].   ^rend does this"		rend privateOwner: owner.		extension ifNotNil: [			extension actorState ifNotNil: [				rend actorState: extension actorState].			extension externalName ifNotNil: [				rend setNameTo: extension externalName].			extension player ifNotNil: [				rend player: extension player.				extension player rawCostume: rend]].		^ rend].	(rend _ Morph new) color: Color transparent.	^ rend! !!Morph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 18:00'!convertToCurrentVersion: varDict refStream: smartRefStrm		(varDict at: #ClassName) == #DropShadowMorph ifTrue: [		varDict at: #ClassName put: #Morph.	"so we don't repeat this"		^self convertNovember2000DropShadow: varDict using: smartRefStrm	].	varDict at: 'costumee' ifPresent: [ :x | self convertAugust1998: varDict using: smartRefStrm].	"5/18/2000"	varDict at: 'openToDragNDrop' ifPresent: [ :x | self enableDragNDrop: x ].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!AlignmentMorph methodsFor: 'object fileIn' stamp: 'RAA 12/21/2000 11:25'!convertOldAlignmentsNov2000: varDict using: smartRefStrm	"major change - much of AlignmentMorph is now implemented more generally in Morph"	"These are going away 	#('orientation' 'centering' 'hResizing' 'vResizing' 	'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds')"	| orientation centering hResizing vResizing inset minCellSize inAlignment |	orientation _ varDict at: 'orientation'.	centering _ varDict at: 'centering'.	hResizing _ varDict at: 'hResizing'.	vResizing _ varDict at: 'vResizing'.	inset _ varDict at: 'inset'.	minCellSize _ varDict at: 'minCellSize'.	(orientation == #horizontal or:[orientation == #vertical])		ifTrue:[self layoutPolicy: TableLayout new].	self cellPositioning: #topLeft.	self rubberBandCells: true.	orientation == #horizontal 		ifTrue:[self listDirection: #leftToRight].	orientation == #vertical 		ifTrue:[self listDirection: #topToBottom].	centering == #topLeft 		ifTrue:[self wrapCentering: #topLeft].	centering == #bottomRight 		ifTrue:[self wrapCentering: #bottomRight].	centering == #center 		ifTrue:[self wrapCentering: #center.				orientation == #horizontal					ifTrue:[self cellPositioning: #leftCenter]					ifFalse:[self cellPositioning: #topCenter]].	(inset isNumber or:[inset isPoint]) 		ifTrue:[self layoutInset: inset].	(minCellSize isNumber or:[minCellSize isPoint]) 		ifTrue:[self minCellSize: minCellSize].	(self hasProperty: #clipToOwnerWidth)		ifTrue:[self clipSubmorphs: true].	"now figure out if our owner was an AlignmentMorph, even if it is reshaped..."	inAlignment _ false.	(owner isKindOf: Morph) ifTrue:[		(owner isKindOf: AlignmentMorph) ifTrue:[inAlignment _ true].	] ifFalse:[		"e.g., owner may be reshaped"		(owner class instanceVariablesString findString: 'orientation centering hResizing vResizing')			> 0 ifTrue:["this was an alignment morph being reshaped"						inAlignment _ true].	].	"And check for containment in system windows"	(owner isKindOf: SystemWindow) ifTrue:[inAlignment _ true].	(hResizing == #spaceFill and:[inAlignment not])		ifTrue:[self hResizing: #shrinkWrap]		ifFalse:[self hResizing: hResizing].	(vResizing == #spaceFill and:[inAlignment not])		ifTrue:[self vResizing: #shrinkWrap]		ifFalse:[self vResizing: vResizing].! !!AlignmentMorph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 18:00'!convertToCurrentVersion: varDict refStream: smartRefStrm		super convertToCurrentVersion: varDict refStream: smartRefStrm.	"major change - much of AlignmentMorph is now implemented more generally in Morph"	varDict at: 'hResizing' ifPresent: [ :x | 		self convertOldAlignmentsNov2000: varDict using: smartRefStrm	].! !!FillInTheBlankMorph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:59'!convertToCurrentVersion: varDict refStream: smartRefStrm		varDict at: 'responseUponCancel' ifAbsent: [responseUponCancel _ ''].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!FlashSpriteMorph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:45'!convertToCurrentVersion: varDict refStream: smartRefStrm		lastStepTime ifNil: [lastStepTime _ 0].	useTimeSync ifNil: [useTimeSync _ true].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!GraphMorph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:46'!convertToCurrentVersion: varDict refStream: smartRefStrm		hasChanged ifNil: [hasChanged _ false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!HaloMorph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:46'!convertToCurrentVersion: varDict refStream: smartRefStrm		simpleMode ifNil: [simpleMode _ false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!MorphicEvent methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 16:05'!convertOctober2000: varDict using: smartRefStrm	"ar 10/25/2000: This method is used to convert OLD MorphicEvents into new ones."	"These are going away #('type' 'cursorPoint' 'buttons' 'keyValue' 'sourceHand').  Possibly store their info in another variable?"	| type cursorPoint buttons keyValue sourceHand |	type _ varDict at: 'type'.	cursorPoint _ varDict at: 'cursorPoint'.	buttons _ varDict at: 'buttons'.	keyValue _ varDict at: 'keyValue'.	sourceHand _ varDict at: 'sourceHand'.	type == #mouseMove ifTrue:[		^MouseMoveEvent new			setType: #mouseMove 			startPoint: cursorPoint			endPoint: cursorPoint			trail: #() 			buttons: buttons 			hand: sourceHand 			stamp: nil].	(type == #mouseDown) | (type == #mouseUp) ifTrue:[			^MouseButtonEvent new				setType: type				position: cursorPoint				which: 0				buttons: buttons				hand: sourceHand				stamp: nil].	(type == #keystroke) | (type == #keyDown) | (type == #keyUp) ifTrue:[		^KeyboardEvent new			setType: type			buttons: buttons			position: cursorPoint			keyValue: keyValue			hand: sourceHand			stamp: nil].	"All others will be handled there"	^MorphicUnknownEvent new! !!MorphicEvent methodsFor: 'object fileIn' stamp: 'RAA 12/21/2000 11:35'!convertToCurrentVersion: varDict refStream: smartRefStrm		| answer |	"ar 10/25/2000: This method is used to convert OLD MorphicEvents into new ones."	varDict at: 'cursorPoint' ifPresent: [ :x | 		answer _ self convertOctober2000: varDict using: smartRefStrm.		varDict removeKey: 'cursorPoint'.	"avoid doing this again"		^answer	].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!MorphicUnknownEvent methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:48'!convertToCurrentVersion: varDict refStream: smartRefStrm		type ifNil: [type _ #startSound].	source ifNil: [source _ varDict at: 'sourceHand'].	argument ifNil: [argument _ varDict at: 'sound' ifAbsent: [nil]].	"???"	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:48'!convertToCurrentVersion: varDict refStream: smartRefStrm		"transition from project to worldState (8/16/1999)"	worldState ifNil: [varDict at: 'project' ifPresent: [ :x | worldState _ x]].	"elimination of specific gradient stuff (5/6/2000)"	varDict at: 'fillColor2' ifPresent: [ :color2 |		(color isColor and: [color2 isColor and: [color ~= color2]]) ifTrue: [			self useGradientFill.			self fillStyle				colorRamp: {0.0 -> color. 1.0 -> color2};				radial: false;				origin: self position;				direction: ((varDict at: 'gradientDirection') == #vertical 					ifTrue:[0@self height] 					ifFalse:[self width@0]).		]	].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!PluggableTextView methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:48'!convertToCurrentVersion: varDict refStream: smartRefStrm		hasEditingConflicts ifNil: [hasEditingConflicts _ false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!PolygonMorph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:48'!convertToCurrentVersion: varDict refStream: smartRefStrm		smoothCurve ifNil: [smoothCurve _ false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!Project methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		isolatedHead ifNil: [isolatedHead _ false].	inForce ifNil: [inForce _ false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!ProjectViewMorph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		currentBorderColor ifNil: [currentBorderColor _ Color gray].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!ScaleMorph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		labelsAbove ifNil: [labelsAbove _ true].	captionAbove ifNil: [captionAbove _ true].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!SketchMorph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		scalePoint ifNil: [scalePoint _ 1.0@1.0].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!SmartRefStream methodsFor: 'read write' stamp: 'RAA 12/20/2000 17:13'!initShapeDicts	"Initialize me. "	self flag: #bobconv.		"These must stay constant.  When structures read in, then things can change."	steady _ {Array. Dictionary. Association. String. SmallInteger} asSet.	renamed ifNil: [		renamed _ Dictionary new.  "(old class name symbol -> new class name)"		renamedConv _ Dictionary new "(oldClassNameSymbol -> conversionSelectorInNewClass)"	].				! !!SmartRefStream methodsFor: 'read write' stamp: 'RAA 12/20/2000 17:17'!mapClass: incoming	"See if the old class named nm exists.  If so, return it.  If not, map it to a new class, and save the mapping in renamed.  "	| cls oldVer sel nm |	self flag: #bobconv.		nm _ renamed at: incoming ifAbsent: [incoming].	"allow pre-mapping around collisions"	(nm endsWith: ' class') 		ifFalse: [cls _ Smalltalk at: nm ifAbsent: [nil].			cls ifNotNil: [^ cls]]  	"Known class.  It will know how to translate the instance."		ifTrue: [cls _ Smalltalk at: nm substrings first asSymbol ifAbsent: [nil].			cls ifNotNil: [^ cls class]]. 	"Known class.  It will know how to translate the instance."	oldVer _ self versionSymbol: (structures at: nm).	sel _ nm asString.	sel at: 1 put: (sel at: 1) asLowercase.	sel _ sel, oldVer.	"i.e. #rectangleoc4"	Symbol hasInterned: sel ifTrue: [:symb | 		(self class canUnderstand: sel asSymbol) ifTrue: [			cls _ self perform: sel asSymbol]].	"This class will take responsibility"	cls ifNil: [cls _ self writeClassRenameMethod: sel was: nm					fromInstVars: (structures at: nm).			   cls class == String ifTrue: [cls _ nil]].	cls ifNotNil: [renamed at: nm put: cls name].	^ cls! !!SmartRefStream methodsFor: 'read write' stamp: 'RAA 12/20/2000 17:16'!readInstanceSize: instSize clsname: className refPosn: refPosn	"The common code to read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| anObject newName newClass dict oldInstVars |	self flag: #bobconv.		self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	newName _ renamed at: className ifAbsent: [className].	newClass _ Smalltalk at: newName.	(steady includes: newClass) & (newName == className) ifTrue: [	 	anObject _ newClass isVariable "Create it here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].		anObject _ anObject readDataFrom: self size: instSize.		self setCurrentReference: refPosn.  "before returning to next"		^ anObject].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	dict at: #ClassName put: className.	"so conversion method can know it"	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	anObject _ self applyConversionMethodsTo: anObject className: className varMap: dict.	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!SmartRefStream methodsFor: 'read write' stamp: 'RAA 12/20/2000 11:08'!renamed	self flag: #bobconv.		^ renamed! !!SmartRefStream methodsFor: 'read write' stamp: 'RAA 12/20/2000 11:10'!renamedConv	self flag: #bobconv.		^ renamedConv! !!SmartRefStream methodsFor: 'read write' stamp: 'RAA 12/22/2000 15:14'!restoreClassInstVars	"Install the values of the class instance variables of UniClasses(i.e. scripts slotInfo).  classInstVars is ((#Player25 scripts slotInfo)...).  Thank you Mark Wai for the bug fix."	| normal aName newName newCls trans rList start |	self flag: #bobconv.		self moreObjects ifFalse: [^ self]. 	"are no UniClasses with class inst vars"	classInstVars _ super next.	"Array of arrays"	normal _ Object class instSize.	"might give trouble if Player class superclass changes size"	(structures at: #Player ifAbsent: [#()]) = #(0 'dependents' 'costume') ifTrue:		[trans _ 1].	"now (0 costume costumes).  Do the conversion of Player class			inst vars in Update 509."	classInstVars do: [:list |		aName _ (list at: 1) asSymbol.		rList _ list.		newName _ renamed at: aName ifAbsent: [aName].		newCls _ Smalltalk at: newName				ifAbsent: [self error: 'UniClass definition missing'].		("old conversion" trans == 1 and: [newCls inheritsFrom: Player]) ifTrue: [			"remove costumeDictionary from Player class inst vars"			rList _ rList asOrderedCollection.			rList removeAt: 4].	"costumeDictionary's value"		start _ list second = 'Update to read classPool' ifTrue: [4] ifFalse: [2].		newCls class instSize = (normal + (rList size) - start + 1) ifFalse:			[self error: 'UniClass superclass class has changed size'].			"Need to install a conversion method mechanism"		start = 4 ifTrue: [newCls instVarAt: normal - 1 "classPool" put: (list at: 3)].		start to: rList size do: [:ii |			newCls instVarAt: normal + ii - start + 1 put: (rList at: ii)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'RAA 12/20/2000 16:57'!setStream: aStream	"Initialize me. "	self flag: #bobconv.		super setStream: aStream.	self initShapeDicts.! !!SmartRefStream methodsFor: 'read write' stamp: 'RAA 12/20/2000 16:57'!setStream: aStream reading: isReading	"Initialize me. "	self flag: #bobconv.		super setStream: aStream reading: isReading.	isReading ifFalse: [^ false].	self initShapeDicts.! !!SmartRefStream methodsFor: 'read write' stamp: 'RAA 12/20/2000 17:13'!verifyStructure	"Compare the incoming inst var name lists with the existing classes.  Prepare tables that will help to restructure those who need it (renamed, reshaped, steady).    If all superclasses are recorded in the file, only compare inst vars of this class, not of superclasses.  They will get their turn.  "	| newClass newList oldList converting |	self flag: #bobconv.		converting _ OrderedCollection new.	structures keysDo: [:nm "an old className (symbol)" |		"For missing classes, there needs to be a method in SmartRefStream like 			#rectangleoc2 that returns the new class."		newClass _ self mapClass: nm.	   "does (renamed at: nm put: newClass name)"		newClass class == String ifTrue: [^ newClass].  "error, fileIn needed"		newList _ (Array with: newClass classVersion), (newClass allInstVarNames).		oldList _ structures at: nm.		newList = oldList 			ifTrue: [steady add: newClass]  "read it in as written"			ifFalse: [converting add: newClass name]	].	false & converting isEmpty not ifTrue: ["debug" 			self inform: 'These classes are being converted from existing methods:\' withCRs,				converting asArray printString].! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'RAA 12/20/2000 11:09'!writeClassRenameMethod: sel was: oldName fromInstVars: oldList	"The class coming is unknown.  Ask the user for the existing class it maps to.  If got one, write a method, and restart the obj fileIn.  If none, write a dummy method and get the user to complete it later.  "| tell choice  newName answ code oldVer newList newVer instSel |	self flag: #bobconv.	tell _ 'Reading an instance of ', oldName, '.Which modern class should it translate to?'.answ _ (PopUpMenu labels: 'Let me type the name nowLet me think about itLet me find a conversion file on the disk') startUpWithCaption: tell. answ = 1 ifTrue: [	tell _ 'Name of the modern class that ', oldName, 's should it translate to:'.	choice _ FillInTheBlank request: tell.		"class name"	(choice size = 0) 		ifTrue: [answ _ 'conversion method needed']		ifFalse: [newName _ choice.			answ _ Smalltalk at: newName asSymbol 				ifAbsent: ['conversion method needed'].			answ class == String ifFalse: [renamed at: oldName asSymbol put: answ name]]].(answ = 3) | (answ = 0) ifTrue: [self close.		^ 'conversion method needed'].answ = 2 ifTrue: [answ _ 'conversion method needed'].answ = 'conversion method needed' ifTrue: [		self close.  		newName _ 'PutNewClassHere'].answ class == String ifFalse: [	oldVer _ self versionSymbol: (structures at: oldName).	newList _ (Array with: answ classVersion), (answ allInstVarNames).	newVer _ self versionSymbol: newList.	instSel _ 'convert',oldVer,':',newVer, ':'. 	].code _ WriteStream on: (String new: 500).code nextPutAll: sel; cr.answ class == String ifFalse: [	code cr; tab; nextPutAll: 'reshaped at: #', oldName, ' put: #', instSel, '.'.	code cr; tab; tab; nextPutAll: '"Be sure to define that conversion method in class ', answ name, '"'].code cr; tab; nextPutAll: '^ ', newName.	"Return new class"self class compile: code contents classified: 'conversion'.newName = 'PutNewClassHere' ifTrue: [	PopUpMenu notify: 'Please complete the following method and then read-in the object file again.'.	Smalltalk browseAllImplementorsOf: sel asSymbol]. 	"The class version number only needs to change under one specific circumstance.  That is when the first letters of the instance variables have stayed the same, but their meaning has changed.  A conversion method is needed, but this system does not know it.  	If this is true for class Foo, define classVersion in Foo class.  	Beware of previous object fileouts already written after the change in meaning, but before bumping the version number.  They have the old (wrong) version number, say 2.  If this is true, your method must be able to test the data and successfully read files that say version 2 but are really 3."	^ answ! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'RAA 12/20/2000 11:58'!writeConversionMethod: sel class: newClass was: oldName fromInstVars: oldList to: newList	"No method sel was found in newClass.  Writing a default conversion method."	| code keywords newOthers oldOthers copied |	self flag: #bobconv.		code _ WriteStream on: (String new: 500).	keywords _ sel keywords.	code nextPutAll: (keywords at: 1); nextPutAll: ' varDict '; 			nextPutAll: (keywords at: 2); nextPutAll: ' smartRefStrm'; cr; tab.	newOthers _ newList asOrderedCollection "copy".	oldOthers _ oldList asOrderedCollection "copy".	copied _ OrderedCollection new.	newList do: [:instVar |		(oldList includes: instVar) ifTrue: [			instVar isInteger ifFalse: [copied add: instVar].			newOthers remove: instVar.			oldOthers remove: instVar]].	code nextPutAll: '"These variables are automatically stored into the new instance '.	code nextPutAll: copied asArray printString; nextPut: $. .	code cr; tab; nextPutAll: 'This method is for additional changes.'; 		nextPutAll: ' Use statements like (foo _ varDict at: ''foo'')."'; cr; cr; tab.	(newOthers size = 0) & (oldOthers size = 0) 		ifTrue: [code nextPutAll: '"Instance variables are the same.  Only the order changed.  This method should work as written."'].	(newOthers size > 0) ifTrue: [code nextPutAll: '"New variables: ', newOthers asArray printString, '  If a non-nil value is needed, please assign it."\' withCRs].	(oldOthers size > 0) ifTrue: [code nextPutAll: '	"These are going away ', oldOthers asArray printString, '.  Possibly store their info in another variable?"'].	newClass compile: code contents classified: 'object fileIn'.	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe." ! !!SmartRefStream methodsFor: 'import image segment' stamp: 'RAA 12/20/2000 17:01'!applyConversionMethodsTo: objectIn className: className varMap: varMap	| anObject prevObject |	self flag: #bobconv.		anObject _ objectIn.	[		prevObject _ anObject.		anObject _ anObject convertToCurrentVersion: varMap refStream: self.		prevObject == anObject	] whileFalse.	^anObject! !!SmartRefStream methodsFor: 'import image segment' stamp: 'RAA 12/20/2000 11:08'!checkFatalReshape: setOfClasses	| suspects oldInstVars newInstVars bad className |	"Inform the user if any of these classes were reshaped.  A block has a method from the old system whose receiver is of this class.  The method's inst var references might be wrong.  OK if inst vars were only added."	self flag: #bobconv.		setOfClasses isEmpty ifTrue: [^ self].	suspects _ OrderedCollection new.	setOfClasses do: [:aClass |		className _ renamed keyAtValue: aClass name ifAbsent: [aClass name].		oldInstVars _ (structures at: className ifAbsent: [#(0)]) allButFirst.		"should be there"		newInstVars _ aClass allInstVarNames.		oldInstVars size > newInstVars size ifTrue: [bad _ true].		oldInstVars size = newInstVars size ifTrue: [			bad _ oldInstVars ~= newInstVars].		oldInstVars size < newInstVars size ifTrue: [			bad _ oldInstVars ~= (newInstVars copyFrom: 1 to: oldInstVars size)].		bad ifTrue: [suspects add: aClass]].	suspects isEmpty ifFalse: [		self inform: ('Imported foreign methods will run on instances of:\',			suspects asArray printString, 			'\whose shape has changed.  Errors may occur.') withCRs].! !!SmartRefStream methodsFor: 'import image segment' stamp: 'RAA 12/20/2000 11:06'!convert1: misShapenInst to: goodClass allVarMaps: allVarMaps	"Go through the normal instance conversion process and return a modern object."	| className oldInstVars anObject varMap |	self flag: #bobconv.		goodClass isVariable ifTrue: [		goodClass error: 'shape change for variable class not implemented yet'	].	(misShapenInst class name beginsWith: 'Fake37') ifFalse: [self error: 'why mapping?'].	className _ (misShapenInst class name allButFirst: 6) asSymbol.	oldInstVars _ structures at: className.	anObject _ goodClass basicNew.	varMap _ Dictionary new.	"later, indexed vars as (1 -> val) etc."	2 to: oldInstVars size do: [:ind |		varMap at: (oldInstVars at: ind) put: (misShapenInst instVarAt: ind-1)].	varMap at: #ClassName put: className.	"original"	varMap at: #NewClassName put: goodClass name.	"new"	self storeInstVarsIn: anObject from: varMap. 	"ones with the same names"	allVarMaps at: misShapenInst put: varMap.	^ anObject! !!SmartRefStream methodsFor: 'import image segment' stamp: 'RAA 12/20/2000 17:15'!convert2: partiallyCorrectInst allVarMaps: allVarMaps	"Go through the normal instance conversion process and return a modern object."	| className varMap |	self flag: #bobconv.		varMap _ allVarMaps at: partiallyCorrectInst.	className _ varMap at: #ClassName.	"original"	^self applyConversionMethodsTo: partiallyCorrectInst className: className varMap: varMap.! !!SmartRefStream methodsFor: 'import image segment' stamp: 'RAA 12/20/2000 11:09'!reshapedClassesIn: outPointers	"Look for classes in the outPointer array that have changed shape.  Make a fake class for the old shape.  Return a dictionary mapping Fake classes to Real classes.  Substitute fake classes for real ones in outPointers."	| mapFakeClassesToReal fakeCls originalName |	self flag: #bobconv.		mapFakeClassesToReal _ IdentityDictionary new.	outPointers withIndexDo: [:outp :ind | 		outp isBehavior ifTrue: [			originalName _ renamedConv at: ind ifAbsent: [outp name].				"in DiskProxy>>comeFullyUpOnReload: we saved the name at the index"			fakeCls _ self mapClass: outp origName: originalName.			fakeCls == outp ifFalse: [				mapFakeClassesToReal at: fakeCls put: outp.				outPointers at: ind put: fakeCls]]].	^ mapFakeClassesToReal! !!SmartRefStream class methodsFor: 'as yet unclassified' stamp: 'RAA 12/20/2000 14:32'!analyzeConversionMethods"SmartRefStream analyzeConversionMethods"	| prelim syms good notImps temp impClassName impClass impSignature classesFound tokens goodImps badImps correct answer classBucket goodChanges badChanges impSelector |	prelim _ Symbol allInstances select: [ :x | 		(x beginsWith: 'convert') and: [x numArgs = 2]	].	syms _ prelim select: [ :x |		good _ true.		2 to: x size do: [ :i | good _ good and: [(x at: i) ~~ $: or: [(x at: i - 1) isDigit]]].		good	].	classesFound _ IdentityDictionary new.	notImps _ OrderedCollection new.	goodImps _ OrderedCollection new.	badImps _ OrderedCollection new.	goodChanges _ ChangeSorter existingOrNewChangeSetNamed: 'valid converters'.	badChanges _ ChangeSorter existingOrNewChangeSetNamed: 'stale converters'.	syms do: [ :x | 		temp _ (Smalltalk allImplementorsOf: x).		temp size = 0 ifTrue: [			notImps add: x.		] ifFalse: [			temp do: [ :imp |				tokens _ imp findTokens: ' '.				impClassName _ tokens first asSymbol.				impSelector _ tokens second asSymbol.				impClass _ Smalltalk at: impClassName.				impSignature _ 					(String withAll: (impClass allInstVarNames collect: [ :ivn | ivn first])),					impClass classVersion printString.				correct _ impSelector endsWith: ':',impSignature,':'.				(correct ifTrue: [goodImps] ifFalse: [badImps]) add: imp.				classBucket _ (classesFound 					at: impClassName 					ifAbsentPut: [{OrderedCollection new. OrderedCollection new. impClassName}]).				(correct ifTrue: [classBucket first] ifFalse: [classBucket second]) add: impSelector.				(correct ifTrue: [goodChanges] ifFalse: [badChanges])					noteNewMethod: (impClass compiledMethodAt: impSelector) 					forClass: impClass					selector: impSelector 					priorMethod: nil.			].		].		"{temp size. x. temp. impSignature}"	].	{syms. notImps. classesFound. goodImps. badImps} explore.	answer _ WriteStream on: String new."=====	answer cr; nextPutAll: '-- NOT IMPLEMENTED --'; cr; cr.	notImps asSortedCollection do: [ :x | answer nextPutAll: x; cr].====="	answer cr; nextPutAll: '-- STALE IMPLEMENTATIONS --'; cr; cr.	badImps asSortedCollection do: [ :x | answer nextPutAll: x; cr].	answer cr; nextPutAll: '-- GOOD IMPLEMENTATIONS --'; cr; cr.	goodImps asSortedCollection do: [ :x | answer nextPutAll: x; cr].	answer cr; nextPutAll: '-- CLASS TALLIES --'; cr; cr.	(classesFound values asSortedCollection: [ :a :b |		a first size > b first size or: [a first size = b first size and: [a second size > b second size]]	]) do: [ :each |		answer nextPutAll: each first size printString,' - ',			each second size printString,'  ',each third; cr	]. 	StringHolder new contents: answer contents; openLabel: 'conversion methods'.! !!StandardSystemView methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		updatablePanes ifNil: [updatablePanes _ #()].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!SystemWindow methodsFor: 'initialization' stamp: 'RAA 12/21/2000 12:04'!initialize	| aFont |	super initialize.	allowReframeHandles := true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	borderColor _ #raised.	borderWidth _ 1.	color _ Color black.	self layoutPolicy: ProportionalLayout new.	label _ StringMorph new contents: labelString;			font: Preferences windowTitleFont emphasis: 1.	"Add collapse box so #labelHeight will work"	aFont _ Preferences standardButtonFont.	collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 14@14.	stripes _ Array with: (RectangleMorph newBounds: bounds)  "see extent:"				with: (RectangleMorph newBounds: bounds).	self setFramesForLabelArea.	self addMorph: (stripes first borderWidth: 1).	self addMorph: (stripes second borderWidth: 2).	self setLabelWidgetAllowance.	self addCloseBox.	self addMenuControl.	self addMorph: label.	self addMorph: collapseBox.	Preferences noviceMode ifTrue:		[closeBox ifNotNil: [closeBox setBalloonText: 'close window'].		menuBox ifNotNil: [menuBox setBalloonText: 'window menu'].		collapseBox ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].	self on: #mouseEnter send: #spawnReframeHandle: to: self.	self on: #mouseLeave send: #spawnReframeHandle: to: self.	label on: #mouseDown send: #relabelEvent: to: self.	self extent: 300@200.	mustNotClose _ false.	updatablePanes _ Array new.! !!SystemWindow methodsFor: 'initialization' stamp: 'RAA 12/21/2000 13:00'!setFramesForLabelArea	"an aid to converting old instances, but then I found convertAlignment"	| frame |	frame _ LayoutFrame new.	frame leftFraction: 0.5; topFraction: 0; leftOffset: label width negated // 2.	label layoutFrame: frame.	frame _ LayoutFrame new.	frame rightFraction: 1; topFraction: 0; rightOffset: 1; topOffset: 1.	collapseBox layoutFrame: frame.	frame _ LayoutFrame new.	frame leftFraction: 0; topFraction: 0; rightFraction: 1;			leftOffset: 1; topOffset: 1; rightOffset: 1.	stripes first layoutFrame: frame.	stripes first height: self labelHeight - 2.	stripes first hResizing: #spaceFill.	frame _ LayoutFrame new.	frame leftFraction: 0; topFraction: 0; rightFraction: 1;			leftOffset: 3; topOffset: 3; rightOffset: 3.	stripes last layoutFrame: frame.	stripes last height: self labelHeight - 6.	stripes last hResizing: #spaceFill.! !!SystemWindow methodsFor: 'object fileIn' stamp: 'RAA 12/21/2000 13:00'!convertToCurrentVersion: varDict refStream: smartRefStrm		allowReframeHandles ifNil: [allowReframeHandles := true].	self layoutPolicy ifNil: [self convertAlignment].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!SystemWindow class methodsFor: 'fileIn/Out' stamp: 'RAA 12/21/2000 12:01'!classVersion	"Changed to 1 for SystemWindow Dec 2000 - see if this helps loading old ones"	^ 1! !!TextMorphForEditView methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:50'!convertToCurrentVersion: varDict refStream: smartRefStrm		acceptOnCR ifNil: [acceptOnCR _ false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!TranslucentColor methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:50'!convertToCurrentVersion: varDict refStream: smartRefStrm		"1/13/1999 -- old versions did not have alpha??"	varDict at: 'alpha' ifAbsent: [^ Color transparent].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.	! !!Workspace methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:50'!convertToCurrentVersion: varDict refStream: smartRefStrm		acceptDroppedMorphs ifNil: [acceptDroppedMorphs _ false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!WorldState methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:51'!convertToCurrentVersion: varDict refStream: smartRefStrm		"Convert the old to new step lists"	self convertStepList.	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !WorldState removeSelector: #converthavcdsll0:havcdsllc0:!WorldState removeSelector: #converthavcdsll0:havcdsllcal0:!WorldState removeSelector: #converthavcdsllc0:havcdsllcal0:!WorldState removeSelector: #converthavcdsllc0:havcdslllcalrm0:!WorldState removeSelector: #converthavcdsllcal0:havcdslllcal0:!WorldState removeSelector: #converthavcdsllcal0:havcdslllcalrm0:!WorldState removeSelector: #converthavcdslllcal0:havcdslllcalrm0:!Workspace removeSelector: #convertdcb0:dcba0:!WonderlandStyle removeSelector: #convertii0:x0:!WonderlandCameraMorph removeSelector: #convertbosfcemmmelmf0:bosfcemmmelmfmoccccclpprb0:!WonderlandCameraMorph removeSelector: #convertbosfcemmmelmfmoccccclpprb0:bosfcemmmelmfmoccccclpprbpp0:!ViewerRow removeSelector: #convertbosfcebbochvimolpe0:bosfcebbochvimlpe0:!ViewerEntry removeSelector: #convertbosfcebbochvimolph0:bosfcebbochvimlph0:!StandardViewer removeSelector: #convertbosfcebbochvimolpsf0:bosfcebbochvimlpsf0:!CategoryViewer removeSelector: #convertbosfcebbochvimolpsn0:bosfcebbochvimlpsn0:!Viewer removeSelector: #convertbosfcebbochvimolps0:bosfcebbochvimlps0:!UpdatingStringMorph removeSelector: #convertbosfcefchftlgpfgs0:bosfcefechftlgpfgsamm0:!UpdatingStringMorph removeSelector: #convertbosfcefechftlgpfgs0:bosfcefechftlgpfgsamm0:!UpdatingStringMorph removeSelector: #convertbosfcefechftlgpfgsa0:bosfcefechftlgpfgsamm0:!UpdatingMenuItemMorph removeSelector: #convertbosfcefechisitsawwe0:bosfcefechisitsawwew0:!TranslucentColor removeSelector: #convertrcc0:rcca0:!TileMorph removeSelector: #convertbosfcebbtsloadustlnop0:bosfcebbtsloadustlnopr0:!TileMorph removeSelector: #convertbosfcepcbbtsloadustlno0:bosfcebbtsloadustlnop0:!ThumbnailMorph removeSelector: #convertbosfcebbovll0:bosfcebbovlld0:!TextStyle removeSelector: #convertfflbafrrtml0:fflbafrrtmld0:!TextPlusPasteUpMorph removeSelector: #convertbosfcebbpmcpbttliairfidcuwwgt0:bosfcebbpmcpbttliairfidcuwwgts0:!TextPlusMorph removeSelector: #convertbosfcettwpecpss0:bosfcettwpecpssi0:!TextPlusJumpStart removeSelector: #converte0:j0:!TextPlusJumpEnd removeSelector: #converte0:j0:!TextMorphForEditView removeSelector: #convertbosfcettwpecpse0:bosfcettwpecpsea0:!SystemWindow removeSelector: #convertbosfcebbmsolslccappcfi0:bosfcebbmsolslccappcfimmlu0:!SystemWindow removeSelector: #convertbosfcebbmsolslccappcfimml0:bosfcebbmsolslccappcfimmlu0:!SystemWindow removeSelector: #convertbosfcebbmsolslccappcfimmlu0:bosfcebbmsolslccappcfimmlua0:!MenuItemMorph removeSelector: #convertbosfcefechiisitsa0:bosfcefechisitsa0:!StringMorph removeSelector: #convertbosfcefch0:bosfcefech0:!StrikeFont removeSelector: #convertxgnstmmmsadxrssedp0:cxgntmmmsadxrssedp0:!StandardSystemView removeSelector: #convertmcsstvwdibbibllismmcelwb0:mcsstvwdibbibllismmcelwbu0:!StandardFileMenu removeSelector: #convertlflffmssc0:lflffmsscp0:!SoundRecorder removeSelector: #convertssrrrbpmmscn0:ssrrrrbpmmscnc0:!SmartRefStream removeSelector: #convert:to:!SmartRefStream removeSelector: #verifyClass:was:selector:newList:oldList:!SlotInformation removeSelector: #converttd0:tdf0:!SlotInformation removeSelector: #converttdf0:tdfvv0:!SimpleSliderMorph removeSelector: #convertbosfcebbmsosvssstammt0:bosfcebbmsosvsssdtammt0:!Slider removeSelector: #convertbosfcebbmsosvs0:bosfcebbmsosvsss0:!Slider removeSelector: #convertbosfcebbmsosvss0:bosfcebbmsosvsss0:!Slider removeSelector: #convertbosfcebbmsosvsss0:bosfcebbmsosvsssd0:!ColorPickerMorph removeSelector: #convertbosfceorrrsfrossdutsaot0:bosfceorrrsfrossdutsaotc0:!ColorPickerMorph removeSelector: #convertbosfceorrrsfrossdutsaotc0:bosfceorrrsfrossdutsaotcii0:!SketchMorph removeSelector: #convertbosfceorrrfro0:bosfceorrrsfro0:!SketchMorph removeSelector: #convertbosfceorrrsfro0:bosfceorsfr0:!ServerDirectory removeSelector: #convertsdtupgmaus0:sdtupgmausl0:!PluggableTextMorph removeSelector: #convertbosfcebbmsopssrsggstgsghas0:bosfcebbmsopssrsggstgsghash0:!PluggableTextMorph removeSelector: #convertbosfcebbmsopssrsggstgsghash0:bosfcebbmsopssrsggshtgsghash0:!PluggableListMorphByItem removeSelector: #convertbosfcebbmsopssrsggslssggskafllldpi0:bosfcebbmsopssrsggshlssggskafllldpi0:!PluggableListMorph removeSelector: #convertbosfcebbmsopssrsggslssggskafll0:bosfcebbmsopssrsggslssggskafllld0:!PluggableListMorph removeSelector: #convertbosfcebbmsopssrsggslssggskafllldp0:bosfcebbmsopssrsggshlssggskafllldp0:!ScrollPane removeSelector: #convertbosfcebbmsopssrsggs0:bosfcebbmsopssrsggsh0:!ScriptEditorMorph removeSelector: #convertbosfcebbochvimlpsftph0:bosfcebbochvimlpsftphs0:!ScriptEditorMorph removeSelector: #convertbosfcebbochvimlpsftphs0:bosfcebbsftphs0:!ScriptEditorMorph removeSelector: #convertbosfcebbochvimolpsftph0:bosfcebbochvimlpsftph0:!ScriptEditorMorph removeSelector: #convertbosfcebbochvimolsftp0:bosfcebbochvimolpsftph0:!ScorePlayerMorph removeSelector: #convertbosfcebbochvimolpstis0:bosfcebbochvimlpstis0:!ScaleMorph removeSelector: #convertbosfcebbcssmmmmt0:bosfcebbcssmmmmtlc0:!RemoteControlledHandMorph removeSelector: #convertbosfcemkemkmmltdcctthsulev0:bosfcemkemkmmltdcctthsulevn0:!ProjectViewMorph removeSelector: #convertbosfceipl0:bosfceiplcm0:!ProjectNavigationMorph removeSelector: #convertbosfcebbochvimlp0:bosfcebbochvimlpm0:!ProjectNavigationMorph removeSelector: #convertbosfcebbochvimlpm0:bosfcebbochvimlphmmm0:!Project removeSelector: #convertdwctppdaevtngp0:dwctppdaevtngpiicmovue0:!Project removeSelector: #convertdwctppdaevtngpiicmo0:dwctppdaevtngpiicmovu0:!Project removeSelector: #convertdwctppdaevtngpiicmovu0:dwctppdaevtngpiicmovue0:!Project removeSelector: #convertdwctppdaevtngpiicmovue0:dwctppdaevtngpiivue0:!Project removeSelector: #convertdwctppdaevtngpiicmovue0:dwctppdaevtngpiivuel0:!Project removeSelector: #convertdwctppdaevtngpiivue0:dwctppdaevtngpiivuel0:!Project removeSelector: #convertdwctppdaevtngpiivuel0:dwctppdvtngpiivuel0:!Project removeSelector: #convertdwctppdaevtngpiivuel0:dwctppdvtngpiivuell0:!Project removeSelector: #convertdwctppdvtngpiivuel0:dwctppdaevtngpiivuel0:!Project removeSelector: #convertdwctppdvtngpiivuel0:dwctppdvtngpiivuell0:!PostscriptCanvas removeSelector: #converttfocccmgfupti0:tfocccmgfuptis0:!PostscriptCanvas removeSelector: #converttfocccmgfupti0:tfocccmgfuptisc0:!CurveMorph removeSelector: #convertbosfcebbvcfaascpphbcnn0:bosfcebbvcfaascbhb0:!CurveMorph removeSelector: #convertbosfcebbvcfqaahbcnn0:bosfcebbvcfaascbhb0:!CurveMorph removeSelector: #convertbosfcebbvcfqaahbcnn0:bosfcebbvcfaascpphbcnn0:!BalloonMorph removeSelector: #convertbosfcebbvcfaascbhbto0:bosfcebbvcfaascbhbtob0:!PolygonMorph removeSelector: #convertbosfcebbvcfaascpphb0:bosfcebbvcfaascbhb0:!PolygonMorph removeSelector: #convertbosfcebbvcfqaah0:bosfcebbvcfqaahb0:!PolygonMorph removeSelector: #convertbosfcebbvcfqaahb0:bosfcebbvcfaascbhb0:!PolygonMorph removeSelector: #convertbosfcebbvcfqaahb0:bosfcebbvcfaascpphb0:!PluggableTextView removeSelector: #convertmcsstvwdibbibdhagsgg0:mcsstvwdibbibdhagsggh0:!PluggableListView removeSelector: #convertmcsstvwdibbiblstbitggsggka0:mcsstvwdibbiblstbitggsggkai0:!PhraseTileMorph removeSelector: #convertbosfcebbochvimolprbu0:bosfcebbochvimlprbu0:!IndexTabs removeSelector: #convertbosfcebbfgccpmcpbttloiairfidcuwhrbb0:bosfcebbfgccpmcpbttloiairfidcuwwhrbbvf0:!IndexTabs removeSelector: #convertbosfcebbfgccpmcpbttloiairfidcuwwhrbbv0:bosfcebbfgccpmcpbttloiairfidcuwwhrbbvf0:!PasteUpMorph removeSelector: #convertbosfcebbfgccpmcpbttloiairfidcuw0:bosfcebbfgccpmcpbttloiairfidcuww0:!PasteUpMorph removeSelector: #convertbosfcebbfgccpmcpbttloiairfidcuwp0:bosfcebbfgccpmcpbttloiairfidcuww0:!PasteUpMorph removeSelector: #convertbosfcebbfgccpmcpbttloiairfidcuww0:bosfcebbpmcpbttliairfidcuww0:!PasteUpMorph removeSelector: #convertbosfcebbfgccpmcpbttloiairfidcuww0:bosfcebbpmcpbttloiairfidcuww0:!PasteUpMorph removeSelector: #convertbosfcebbpmcpbttliairfidcuww0:bosfcebbpmcpbttliairfidcuwwg0:!PasteUpMorph removeSelector: #convertbosfcebbpmcpbttliairfidcuwwg0:bosfcebbpmcpbttliairwwg0:!PasteUpMorph removeSelector: #convertbosfcebbpmcpbttloiairfidcuww0:bosfcebbpmcpbttliairfidcuww0:!PaintBoxMorph removeSelector: #convertbosfceiatctccccsrscb0:bosfceiatctccccsrscbf0:!NewParagraph removeSelector: #convertttfclpm0:ttfclpomss0:!NewParagraph removeSelector: #convertttfclpom0:ttfclpomss0:!NebraskaServerMorph removeSelector: #convertbosfcessp0:bosfcebbssplcfp0:!MouseOverHandler removeSelector: #convertmeoli0:meol0:!MorphicUnknownEvent removeSelector: #converttcbkss0:tsta0:!MorphicEvent removeSelector: #converttcbks0:ts0:!HandMorphForReplay removeSelector: #convertbosfceekmmmdccffuleatdccttggrtllmhssffacwr0:bosfcemkemkmmlltdcctthsulr0:!HandMorphForReplay removeSelector: #convertbosfceekmmmdccffuleatdccttggrtllmhssffacwr0:bosfcemkemkmmltdcctthsulr0:!HandMorph removeSelector: #convertbosfceekmmmdccffuleatdccttggrtllmhssffa0:bosfceekmmmdccffuleatdccttggrtllmhssffac0:!HandMorph removeSelector: #convertbosfceekmmmdccffuleatdccttggrtllmhssffa0:bosfceekmmmdccffuleatdccttggrtllmhssffacw0:!HandMorph removeSelector: #convertbosfceekmmmdccffuleatdccttggrtllmhssffac0:bosfceekmmmdccffuleatdccttggrtllmhssffacw0:!HandMorph removeSelector: #convertbosfceekmmmdccffuleatdccttggrtllmhssffac0:bosfcemkemkmmltdcctthsul0:!HandMorph removeSelector: #convertbosfceekmmmdccffuleatdccttggrtllmhssffacw0:bosfcemkemkmmlltdcctthsul0:!HandMorph removeSelector: #convertbosfceekmmmdccffuleatdccttggrtllmhssffacw0:bosfcemkemkmmlltdccttrthsul0:!HandMorph removeSelector: #convertbosfceekmmmdccffuleatdccttggrtllmhssffacw0:bosfcemkemkmmltdcctthsul0:!HandMorph removeSelector: #convertbosfcemkemkmmlltdcctthsul0:bosfcemkemkmmltdcctthsul0:!HandMorph removeSelector: #convertbosfcemkemkmmlltdccttrthsu0:bosfcemkemkmmlltdccttrthsul0:!HandMorph removeSelector: #convertbosfcemkemkmmlltdccttrthsul0:bosfcemkemkmmltdcctthsul0:!HaloMorph removeSelector: #convertbosfcetipamg0:bosfcetipamgdhs0:!GraphMorph removeSelector: #convertbosfcebbddcccsmmc0:bosfcebbddcccsmmch0:!GraphMorph removeSelector: #convertbosfcebbddcccsmmcll0:bosfcebbddcccsmmch0:!FlashPlayerMorph removeSelector: #convertbosfcetcpmlfsdsalluaalsp0:bosfcetcpmlfsdsallaalsp0:!FlashSpriteMorph removeSelector: #convertbosfcetcpmlfsdsal0:bosfcetcpmlfsdsall0:!FlashSpriteMorph removeSelector: #convertbosfcetcpmlfsdsall0:bosfcetcpmlfsdsallu0:!FlashSpriteMorph removeSelector: #convertbosfcetcpmlfsdsallu0:bosfcetcpmlfsdsall0:!FillInTheBlankMorph removeSelector: #convertbosfcebbrdt0:bosfcebbrdtr0:!EventRecorderMorph removeSelector: #convertbosfcebbochvimlptstrplltssvsrcj0:bosfcebbochvimlptstdrplltssvsrcj0:!EToyTextNode removeSelector: #convertbosfcettwpecpsc0:bosfcettwpecpscf0:!EToySenderMorph removeSelector: #convertbosfcebbochvimlphmmfr0:bosfcebbochvimlphmmfru0:!EToyFridgeMorph removeSelector: #convertbosfcebbochvimlphmmfrrirug0:bosfcebbochvimlphmmfrug0:!EToyChatMorph removeSelector: #convertbosfcebbochvimlphmmfrlr0:bosfcebbochvimlphmmfrlrr0:!BookMorph removeSelector: #convertbosfcebbochvimolppnpc0:bosfcebbochvimlppnpc0:!BooklikeMorph removeSelector: #convertbosfcebbochvimolppn0:bosfcebbochvimlppn0:!AlignmentMorphBob1 removeSelector: #convertbosfcebbhmm0:bosfcebb0:!AlignmentMorph removeSelector: #convertbosfcebbochvimlp0:bosfcebb0:!AlignmentMorph removeSelector: #convertbosfcebbochvimol0:bosfcebbochvimolp0:!AlignmentMorph removeSelector: #convertbosfcebbochvimolp0:bosfcebbochvimlp0:!Morph removeSelector: #convertbosfcepc0:bosfce0:!Morph removeSelector: #convertbosfces0:bosfce0:!Inspector removeSelector: #convertdcos0:dcost0:!Inspector removeSelector: #convertdcost0:dcosts0:!ImageSegment removeSelector: #convertasossfe0:asossfeu0:!ImageSegment removeSelector: #convertasossfeu0:asossfeur0:!GrafPort removeSelector: #convertdshcddwhsscccccla0:dshcddwhsscccccaf0:!FormCanvas removeSelector: #converttfocsfps0:tfocfps0:!FillInTheBlank removeSelector: #convertdcad0:dcadr0:!EventHandler removeSelector: #convertmmmmmmmmmmkkv0:mmmmmmmmmmmmmmkkv0:!EventHandler removeSelector: #convertmmmmmmmmmmmmmmkkv0:mmmmmmmmmmmmmmkkv0:!EventHandler removeSelector: #convertmmmmmmmmmmmmmmkkv0:mmmmmmmmmmmmmmkkvssdd0:!EventHandler removeSelector: #convertmmmmmmmmmmmmmmkkvssdd0:mmmmmmmmmmmmmmkkvssddcc0:!EventHandler removeSelector: #convertmmmmmmmmmmmmmmkkvssdd0:mmmmmmmmmmmmmmmmkkvssddcc0:!EventHandler removeSelector: #convertmmmmmmmmmmmmmmkkvssddcc0:mmmmmmmmmmmmmmmmkkvssddcc0:!EToyTextNodeWrapper removeSelector: #convertim0:imp0:!EToyHierarchicalTextGizmo removeSelector: #convertcmt0:dcmt0:!DiskProxy removeSelector: #convertgcc0:gpcc0:!CodeHolder removeSelector: #convertdcs0:dcsc0:!CodeHolder removeSelector: #convertdcscm0:dcsc0:!ClassOrganizer removeSelector: #convertgcce0:gccec0:!ChangeSet removeSelector: #convertcmcmnppss0:nppriicss0:!CanvasEncoder removeSelector: #convertcllfjc0:cllfjcc0:!BufferedCanvas removeSelector: #converttfrpld0:tfrpldm0:!AbstractHierarchicalList removeSelector: #convertcm0:dcm0:!