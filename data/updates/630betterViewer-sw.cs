'From Squeak 2.3 of January 14, 1999 on 1 February 1999 at 3:22:12 pm'!"Change Set:		betterViewer-swDate:			1 February 1999Author:			Scott WallaceNumerous changes, both major and minor, to the Viewer facility, including:*	You can now rename an instance variable.*	You can now delete an instance variable.*	You can now rename a method.*	You can now delete a method.*	You can easily drag viewers around now, grabbing them by their darker-green borders.*	The distinction between 'anonymous' and 'named' scripts is eliminated; every new script is given a default name and is 'saved' and is visible in the Viewer.  You can subsequently remove or rename scripts as per the above.*	Automatic placement of viewers: A Preference, 'automaticViewerPlacement', is added.  which, if set, will result in new viewers being automatically positioned near their referents, rather than 'sticking to the hand', when you click on the cyan 'launch viewer' halo handle.  (But note that if, etoy fashion, you're using a template that has 'standard palette' designated for the purpose, viewers will continue to be projected into that palette as before.)*	 Viewers strive to show you 'what you want to see'.  Thus, for example, if you add an instance variable, then the viewer will be sure it's showing you the 'instance variables' category.  Similarly for scripts.*	Pervasive balloon help; every script and every slot in a viewer now offers some balloon help*	The experiment in the previous version of having a slide-in pane to show a script's source or a slot's information (governed by a button labelled '¦') is retracted -- or rather, it is retained, but suppressed by hard-coding the Preference #useDetailPanesInViewers, to false (if you redefine that preference to return 'true' in a browser, that pane again.). *	Likewise, the 'showPlayerSource' preference and the 'showScriptSource' preferences have been removed from the public Preferences dictionary, and are hard-coded to false.  [I didn't like cluttering up the Preferences inspector with a bunch of idomatic and ephemeral things like these.  If you want the effects they govern, you can still re-hard-code them back to true in a Browser.]*	 We also revert to putting the element's balloon help up upon mouseover of the '¥' button which, and when you click on it, gives you a menu of choices.*	Viewer rows representing *scripts* now also have a '¥' menu button (they never used to) with some useful items.*	Fixes bugs that had made user-defined instance variables of types other than number not show the proper type of readout in a viewer.*	Corrects the set of user-defined-inst-var types.*	Does a better job of deterining which readout tiles should have increase/decrease arrows on them and which should not.*	Adds 'is divisible by' to the numeric relationals on tiles.*	Adds // and \\ to the arithmetic operators on tiles (rem and mod)*	Don't put arrows onto constant tiles for which they don't make sense.*	Don't let viewers be dropped into pasteups other than the world.*	 Updated viewers now occupy the same z-position they did before getting updated.*	Makes the default parameter for an assignment phrase be the current value, as per ack request 1/6/98.*	Changes the wording of the uncommon variants on assignment tiles, to wit:  Former wording        New wording      <+                     increase by      <-                     decrease by      <*                     multiply by.*	Fixes a bug that made assignment to a player-valued instance variable NEVER work.*	Several things in viewers now bulletproofed against the situation where the viewer is visible but its referent is no longer 'in the world' -- many such situations could drop you into a debugger.*   etc etc etc."!StringReadoutTile subclass: #SoundReadoutTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!AlignmentMorph subclass: #ViewerRow	instanceVariableNames: 'elementSymbol '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!!Morph methodsFor: 'scripting' stamp: 'sw 1/6/1999 13:25'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putSelector	| aColor aTile viewer |	aColor _ Color lightGray lighter.	aTile _ typeSymbol == #number		ifTrue:			[NumericReadoutTile new typeColor: aColor]		ifFalse:				[typeSymbol == #sound				ifTrue:					[SoundReadoutTile new typeColor: aColor]				ifFalse:					[StringReadoutTile new typeColor: aColor]]. 	viewer _ UpdatingStringMorph new		target: self player;		getSelector: getSelector;		growable: false;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	typeSymbol == #string		ifTrue:			[viewer useStringFormat.			viewer growable: true]		ifFalse:			[(typeSymbol == #sound)				ifTrue: 	[viewer useStringFormat]				ifFalse:	[viewer useDefaultFormat]].	aTile addMorphBack: viewer.	((putSelector ~~ #unused) and: [#(number sound boolean) includes: typeSymbol])  ifTrue: [aTile addArrows].	aTile setLiteralTo: (self scriptPerformer perform: getSelector) width: 30.	^ aTile! !!Morph methodsFor: 'scripting' stamp: 'sw 12/28/1998 15:13'!viewAfreshIn: aPasteUp showingScript: aScriptName at: aPosition	| anEditor |	self player updateAllViewersAndForceToShow: 'scripts'.	aPasteUp addMorph: (anEditor _ self player scriptEditorFor: aScriptName).	anEditor position: aPosition! !!Number methodsFor: 'testing' stamp: 'sw 12/30/1998 13:21'!isDivisibleBy: aNumber	aNumber = 0 ifTrue: [^ false].	aNumber isInteger ifFalse: [^ false].	^ (self \\ aNumber) = 0! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 12/24/1998 12:35'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new		target: self morph;		getSelector: (ScriptingSystem getterSelectorFor: partName);		borderWidth: 1;		extent:  30@22.		putSelector == #unused ifFalse: [readout putSelector: (ScriptingSystem setterSelectorFor: partName)]].	readout ifNil: [readout _ self morph updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 12/28/1998 14:40'!morphToDropFrom: aMorph	| itsSelector aScriptor adjustment anEditor actualObject aUserScript ownersChoice aNail representee |	owner ifNotNil:		[(ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self)			ifNotNil:	[^ ownersChoice]].	self alwaysShowThumbnail ifTrue:		[aNail _ aMorph representativeNoTallerThan: self maxHeightToAvoidThumbnailing norWiderThan: self maximumThumbnailWidth thumbnailHeight: self heightForThumbnails.		aNail == aMorph ifFalse:			[aNail position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (aNail extent / aMorph extent)) rounded)].		^ aNail].	((aMorph isKindOf: MorphThumbnail) and: [(representee _ aMorph morphRepresented) owner == nil])		ifTrue:			[representee position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (representee extent / aMorph extent)) rounded).			^ representee].	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph hasProperty: #newPermanentScript) ifTrue: [^ self emptyPermanentScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	aMorph isCommand ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	actualObject assureUniClass.	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject permanentScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject permanentScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 12/23/1998 23:26'!repelsMorph: aMorph event: ev	(Preferences allowSysWindowEmbedding not and:		[aMorph isKindOf: SystemWindow]) ifTrue: [^ false].	(aMorph isKindOf: Viewer) ifTrue: [^ false].	isPartsBin == true ifTrue: [^ true].	openToDragNDrop ifFalse: [^ true].	(self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].	^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 2/1/1999 14:58'!wantsDroppedMorph: aMorph event: evt	self visible ifFalse: [^ false].  "will be a call to #hidden again very soon"	(self isPartsBin or: [self openToDragNDrop]) not ifTrue: [^ false].	(self bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifFalse: [^ false].	((aMorph isKindOf: SystemWindow) and: [Preferences allowSysWindowEmbedding not])		ifTrue:	[^ false].	((aMorph isKindOf: BookPageSorterMorph) and: [self isWorldMorph not])		ifTrue:	[^ false].	(aMorph isKindOf: Viewer) ifTrue: [^ self isWorldMorph].	^ true! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 12/28/1998 13:16'!emptyPermanentScriptorFrom: aPlaceHoldingMorph	| aScriptor aPlayer |	aPlayer _ aPlaceHoldingMorph valueOfProperty: #player.	aPlayer assureUniClass.	aScriptor _  aPlayer permanentScriptEditorFor: nil.	aScriptor position: (self primaryHand position - (10 @ 10)).	aPlayer updateAllViewersAndForceToShow: 'scripts'.	^ aScriptor! !!PhraseWrapperMorph methodsFor: 'extraction support' stamp: 'sw 2/1/1999 13:41'!repelsMorph: aMorph event: ev	^ ((aMorph isKindOf: PhraseTileMorph) or: [aMorph hasProperty: #newAnonymousScript]) or:		[aMorph hasProperty: #newPermanentScript]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 1/13/1999 12:49'!commandPhraseFor: commandSpec inViewer: aViewer	| entry aRow resultType cmd names argType argTile selfTile aPhrase |	entry _ (commandSpec copy asOrderedCollection removeFirst; yourself) asArray.	names _ self class namedTileScriptSelectors.	resultType _ (entry at: 1).	cmd _ (entry at: 2).	entry size = 2		ifTrue:			[aPhrase _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player]		ifFalse: 			[argType _ entry at: 3.			aPhrase _ PhraseTileMorph new setOperator: cmd				type: resultType				rcvrType: #player				argType: argType.			argTile _ self tileForArgType: argType inViewer: aViewer.			argTile position: aPhrase lastSubmorph position.			aPhrase lastSubmorph addMorph: argTile].	(names includes: cmd) ifTrue: [aPhrase userScriptSelector: cmd].	aPhrase markAsPartsDonor.	selfTile _ aViewer tileForSelf.	selfTile position: aPhrase firstSubmorph position.	aPhrase firstSubmorph addMorph: selfTile.	aRow _ ViewerRow newRow borderWidth: 0; color: aViewer color.	aRow elementSymbol: cmd asSymbol.	aRow addDetailButton.  "only if pref set is something actually added"	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 4@2; beTransparent).	aRow addMorphBack: (aViewer infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	aRow beSticky; openToDragNDrop: false.	^ aRow! !!Player methodsFor: 'slots-user' stamp: 'sw 12/28/1998 09:35'!addInstanceVariable	| itsName initialValue typeChosen suggestedNames usedNames initialAnswer setterSelector |	suggestedNames _ #('cargo' 'speed' 'weight' 'mzee' 'friml' 'verp' 'znak').	usedNames _ self class instVarNames.	initialAnswer _ suggestedNames detect: [:aName |  (usedNames includes: aName) not] ifNone:		[Utilities keyLike: 'var1'  satisfying: [:aKey | (usedNames includes: aKey) not]].	itsName _ FillInTheBlank request: 'name for new inst var: ' initialAnswer: initialAnswer. 	itsName size == 0 ifTrue: [^ self].	(Utilities isLegalInstVarName: itsName) ifFalse: [^ self inform: 'sorry, illegal name, try again.'].	itsName _ itsName asSymbol.	(self class allInstVarNames includes: itsName) ifTrue: [^ self inform: 'that name is already used.'].		self assureUniClass.	typeChosen _ self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: (SlotInformation new type: typeChosen).	initialValue _ self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self class compileAccessorsFor: itsName.	setterSelector _ Utilities setterSelectorFor: itsName.	(self class allInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: 'instance variables'! !!Player methodsFor: 'slots-user' stamp: 'sw 2/1/1999 13:52'!addSlotNamedLike: suggestedName withValue: aValue	| otherNames numericSuffix nameToUse  stem itsInfo |	stem _ suggestedName first asLowercase asString , suggestedName allButFirst.	stem _ stem stemAndNumericSuffix first.	nameToUse _ stem.	otherNames _ self class allInstVarNames.	numericSuffix _ 1.	[otherNames includes: nameToUse]		whileTrue: [numericSuffix _ numericSuffix + 1. (nameToUse _ stem, numericSuffix printString)].	self class addInstVarName: nameToUse.	self instVarAt: self class instSize put: aValue.  "Assumes added as last field"	self class compileAccessorsFor: nameToUse.	itsInfo _ SlotInformation new type: aValue basicType.	self slotInfo at: nameToUse asSymbol put: itsInfo.	^ nameToUse! !!Player methodsFor: 'slots-user' stamp: 'sw 1/6/1999 15:56'!chooseSlotTypeFor: slotName	| typeChoices typeChosen |	self flag: #deferred.  "sound should be reinstated but too much difficulty at present"	typeChoices _ #(number player boolean color string "sound point costume").	typeChosen _ (SelectionMenu selections: typeChoices lines: #()) startUpWithCaption: 'Choose the TYPEfor ', slotName.	(typeChosen size == 0) ifTrue: [^ self].	(self typeForSlot: slotName) = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName)).		anInst updateAllViewers]! !!Player methodsFor: 'slots-user' stamp: 'sw 1/12/1999 16:00'!compileInstVarAccessorsFor: varName	self class compileInstVarAccessorsFor: varName! !!Player methodsFor: 'slots-user' stamp: 'sw 12/28/1998 15:30'!hasUserDefinedScripts	^ self class scripts size > 0! !!Player methodsFor: 'slots-user' stamp: 'sw 12/28/1998 10:27'!hasUserDefinedSlots	^ self class slotInfo size > 0! !!Player methodsFor: 'slots-user' stamp: 'sw 1/12/1999 16:01'!renameSlot: oldSlotName	| reply newSlotName |	reply _   FillInTheBlank request: 'New name for "', oldSlotName, '":' initialAnswer: oldSlotName. 	reply size == 0 ifTrue: [^ self].	reply first isUppercase ifTrue: [^ self inform: 'Must start with lower case letter.'].	(Scanner isLiteralSymbol: reply) ifFalse: [^ self inform: 'Bad script name, please try again'].		((newSlotName _ reply asSymbol) == oldSlotName) ifTrue: [^ self].	(self class slotInfo includesKey: newSlotName) ifTrue: [^ self inform: 'Sorry, that name is already in use'].	(ScriptingSystem isAcceptablePlayerSlotName: newSlotName)		ifFalse:			[^ self inform: 'Sorry, that name is reserved.'].	self renameSlot: oldSlotName newSlotName: newSlotName! !!Player methodsFor: 'slots-user' stamp: 'sw 1/29/1999 16:33'!renameSlot: oldSlotName newSlotName: newSlotName	self class renameSilentlyInstVar: oldSlotName to: newSlotName.	self updateAllViewers.	self flag: #deferred.	"Any scripts that formerly sent oldSlotName should now send newSlotName"	self inform: 'Caution!!  Any scripts that may reference thisinstance variable by its old name may now bebroken -- you may need to fix them up manually.  In some future release, we''ll automaticallyfix those up, hopefully.'.	self costume world presenter allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptReferencing: oldSlotName ofPlayer: self)			ifTrue:				[^ aPlayer noteRenameOf: oldSlotName to: newSlotName inPlayer: self]].	^ true! !!Player methodsFor: 'slots-user' stamp: 'sw 2/1/1999 14:35'!tearOffWatcherFor: aSlotName	| aWatcher |	aWatcher _ UpdatingStringMorph new target: self.	((self typeForSlot: aSlotName) = #number) ifFalse: [aWatcher useStringFormat].	aWatcher growable: true;		getSelector: (ScriptingSystem getterSelectorFor: aSlotName);		putSelector: (ScriptingSystem setterSelectorFor: aSlotName);		setNameTo: aSlotName.	aWatcher step.	aWatcher fitContents.	self currentHand attachMorph: aWatcher! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/12/1999 16:00'!elementTypeFor: aStringOrSymbol	| aSymbol |	aSymbol _ aStringOrSymbol asSymbol.	(ScriptingSystem typeForSystemSlotNamed: aSymbol) ifNotNil: [^ #systemSlot].	(ScriptingSystem scriptInfoFor: aSymbol) ifNotNil: [^ #systemScript].	(self slotInfo includesKey: aSymbol) ifTrue: [^ #userSlot].	^ #userScript! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/16/1999 16:27'!hasScriptReferencing: slotName ofPlayer: aPlayer	"Answer whether the receiver bears any script that references a slot of the given name for  the given player"	self allScriptEditors do:		[:anEditor | (anEditor hasScriptReferencing: slotName ofPlayer: aPlayer) ifTrue: [^ true]].	^ false! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/6/1999 16:52'!infoFor: anElement	"The user made a gesture asking for info/menu relating"	| aMenu selector reply elementType |	self flag: #deferred.  "not used now except from grandfathered viewers; eventually expunge this."	elementType _ self elementTypeFor: anElement.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement].		self flag: #deferred.  "Use a traditional MenuMorph, and reinstate the pacify thing"	aMenu _ MVCMenuMorph new.	(elementType == #userScript)		ifTrue: 			[aMenu add: 'destroy "', anElement, '"' action: #removeScript.			aMenu add: 'rename  "', anElement, '"' action: #renameScript.			"aMenu add: 'pacify "', anElement, '"' action: #pacifyScript"].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: anElement asString, ' (', elementType, ')'.	selector _ anElement asSymbol.	reply _  aMenu invokeAt: self costume primaryHand position in: self costume world.	reply == nil ifTrue: [^ self].	reply == #removeScript ifTrue: [^ self removeScript: selector].	reply == #renameScript ifTrue: [^ self renameScript:  selector].	reply == #pacifyScript ifTrue: [^ self pacifyScript: selector]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/6/1999 14:27'!infoFor: anElement inViewer: aViewer	"The user made a gesture asking for info/menu relating"	| aMenu selector reply elementType |	elementType _ self elementTypeFor: anElement.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement inViewer: aViewer].		self flag: #deferred.  "Use a traditional MenuMorph, and reinstate the pacify thing"	aMenu _ MVCMenuMorph new.	(elementType == #userScript)		ifTrue: 			[aMenu add: 'destroy "', anElement, '"' action: #removeScript.			aMenu add: 'rename  "', anElement, '"' action: #renameScript.			"aMenu add: 'pacify "', anElement, '"' action: #pacifyScript"].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: anElement asString, ' (', elementType, ')'.	selector _ anElement asSymbol.	reply _  aMenu invokeAt: aViewer primaryHand position in: aViewer world.	reply == nil ifTrue: [^ self].	reply == #removeScript ifTrue: [^ self removeScript: selector].	reply == #renameScript ifTrue: [^ self renameScript:  selector].	reply == #pacifyScript ifTrue: [^ self pacifyScript: selector]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/29/1999 16:31'!noteRenameOf: oldSlotName to: newSlotName inPlayer: aPlayer	"Note that aPlayer has renamed a slot formerly known as oldSlotName to be newSlotName"	self allScriptEditors do:		[:anEditor | (anEditor hasScriptReferencing: oldSlotName ofPlayer: aPlayer) ifTrue: 			[self flag: #deferred.   "Now what?  Just implement the following?!!"			anEditor replaceReferencesToSlot: oldSlotName inPlayer: aPlayer with: newSlotName]]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/12/1999 16:01'!pacifyScript: aSymbol	| editor aHandler aUserScript |	aUserScript _ self class userScriptForPlayer: self selector: aSymbol.	aUserScript ifNil: [self flag: #deferred.  ^ self beep].  "Maddeningly, without this line here the thing IS nil and the debugger is in a bad state"	editor _ aUserScript instantiatedScriptEditor.	editor scriptInstantiation status: #normal.	self actorState instantiatedUserScriptsDictionary removeKey: aSymbol.	(aHandler _ costume renderedMorph eventHandler) ifNotNil:		[aHandler forgetDispatchesTo: aSymbol]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/12/1999 16:01'!permanentScriptEditorFor: aPhraseTileMorph	| aScriptEditor aUserScript |	self isFlagshipForClass ifFalse:		[^ aPhraseTileMorph].	aUserScript _ self class permanentUserScriptFor: self unusedScriptName player: self.	aScriptEditor _ aUserScript instantiatedScriptEditor.	aPhraseTileMorph ifNotNil:		[aScriptEditor phrase: aPhraseTileMorph].	aScriptEditor install.	self updateAllViewersAndForceToShow: 'scripts'.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/12/1999 16:01'!removeScript: aSymbol	self pacifyScript: aSymbol.	self class removeScriptNamed: aSymbol.	(self scriptorsForSelector: aSymbol inWorld: costume world) do:		[:s | s privateDelete].	self updateAllViewersAndForceToShow: 'scripts'! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/12/1999 16:01'!renameScript: oldSelector	| reply newSelector |	reply _   FillInTheBlank request: 'Script Name' initialAnswer: oldSelector. 	reply size == 0 ifTrue: [^ self].	reply first isUppercase ifTrue: [^ self inform: 'Illegal script name'].	(Scanner isLiteralSymbol: reply) ifFalse: [^ self inform: 'Bad script name, please try again'].	((newSelector _ reply asSymbol) == oldSelector) ifTrue: [^ self].	(ScriptingSystem isAcceptablePlayerScriptName: newSelector)		ifFalse: [^ self inform: 'Sorry, "', newSelector, '" is reserved.'].	self renameScript: oldSelector newSelector: newSelector! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/12/1999 16:01'!renameScript: oldSelector newSelector: newSelector	|  oldStatus aUserScript aScriptEditor |	aUserScript _ self class userScriptForPlayer: self selector: oldSelector.	aScriptEditor _ aUserScript instantiatedScriptEditor.	oldStatus _ aScriptEditor scriptInstantiation status.	aScriptEditor renameScript: newSelector.	aScriptEditor bringUpToDate.	self class removeScriptNamed: oldSelector.	self class atSelector: newSelector putScriptEditor: aScriptEditor.	aScriptEditor scriptInstantiation status: oldStatus.	self actorState instantiatedUserScriptsDictionary removeKey: oldSelector.	self updateAllViewersAndForceToShow: 'scripts'! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/12/1999 16:02'!scriptorsForSelector: aSelector inWorld: aWorld	| scriptors |	scriptors _ (aWorld allMorphs select:		[:m | (((m isKindOf: ScriptEditorMorph) and: [m playerScripted == self]) and: [m scriptName == aSelector])] thenCollect: [:m | m topEditor]) asSet.	^ scriptors asArray! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/6/1999 17:26'!slotInfoButtonHitFor: aSlotName	"The user made a gesture asking for info/menu relating"	| aMenu slotSym aType |	self flag: #deferred.  "not used now except from grandfathered viewers; eventually expunge this."	slotSym _ aSlotName asSymbol.	aType _ self typeForSlot: aSlotName asSymbol.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'simple watcher' selector: #tearOffWatcherFor: argument: slotSym.	aType == #number "later others" ifTrue:		[aMenu add: 'fancier watcher' selector: #tearOffFancyWatcherFor: argument: slotSym].	(self slotInfo includesKey: slotSym)		ifTrue:  "User slot"			[aMenu add: 'change data type' selector: #chooseSlotTypeFor: argument: slotSym.			aMenu add: 'remove "', aSlotName, '"' selector: #removeSlotNamed: argument: slotSym.			aMenu add: 'rename  "', aSlotName, '"' selector: #renameSlot: argument: slotSym].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: (aSlotName asString, ' (', aType, ')').	aMenu popUpAt:  self costume primaryHand position forHand: self costume primaryHand! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/6/1999 14:27'!slotInfoButtonHitFor: aSlotName inViewer: aViewer	"The user made a gesture asking for info/menu relating"	| aMenu slotSym aType |	slotSym _ aSlotName asSymbol.	aType _ self typeForSlot: aSlotName asSymbol.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'simple watcher' selector: #tearOffWatcherFor: argument: slotSym.	aType == #number "later others" ifTrue:		[aMenu add: 'fancier watcher' selector: #tearOffFancyWatcherFor: argument: slotSym].	(self slotInfo includesKey: slotSym)		ifTrue:  "User slot"			[aMenu add: 'change data type' selector: #chooseSlotTypeFor: argument: slotSym.			aMenu add: 'remove "', aSlotName, '"' selector: #removeSlotNamed: argument: slotSym.			aMenu add: 'rename  "', aSlotName, '"' selector: #renameSlot: argument: slotSym].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: (aSlotName asString, ' (', aType, ')').	aMenu popUpAt:  aViewer primaryHand position forHand: aViewer primaryHand! !!Player methodsFor: 'scripts-standard' stamp: 'sw 1/12/1999 16:01'!makeNewDrawingIn: paintPlacePlayer	| paintPlace |	((paintPlacePlayer == nil or: [((paintPlace _ paintPlacePlayer costume) isKindOf: PasteUpMorph) not])		or: [paintPlace isInWorld not])			ifTrue:				[^ self inform: 'Error: not a plausibleplace in which to makea new drawing'].	paintPlace makeNewDrawingWithin		! !!Player methodsFor: 'misc' stamp: 'sw 12/28/1998 01:09'!allOpenViewers	"Answer a list of all the viewers open on the receiver"	| aWorld |	(aWorld _ self costume world) ifNil: [^ #()].	^ aWorld allMorphs select:		[:m | (m isKindOf: StandardViewer) and: [m scriptedPlayer == self]]! !!Player methodsFor: 'misc' stamp: 'sw 1/12/1999 16:00'!belongsToUniClass	"UnscriptedPlayer reimplements to false"	^ true! !!Player methodsFor: 'misc' stamp: 'sw 1/12/1999 16:00'!browsePlayerClass	Browser newOnClass: self class label: 'Compiled scripts for ', self externalName! !!Player methodsFor: 'misc' stamp: 'sw 2/1/1999 14:04'!getIsOverColor: aColor	^ self seesColor: aColor! !!Player methodsFor: 'misc' stamp: 'sw 1/6/1999 17:44'!stringForReadout	^ self externalName! !!Player methodsFor: 'misc' stamp: 'sw 1/5/1999 12:04'!thumbnailMenuEvt: anEvent forMorph: aMorph	"The mouse went down in the thumbnail of a Viewer for the receiver"	| aMenu aWorld aViewer |	aWorld _ aMorph world.	aViewer _ aMorph ownerThatIsA: Viewer.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'set new costume...' action: #newCostume.	(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume]])		ifTrue:			[aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes].	aMenu addLine.	aMenu add: 'add a new instance variable' target: self action: #addInstanceVariable.	"aMenu add: 'add an empty new script' target: aViewer action: #newEmptyScript."	aMenu add: 'add a new script' target: aViewer action: #newPermanentScript.	aMenu addLine.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	aMenu add: 'reveal me' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab me' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu popUpAt: aWorld primaryHand position event: aWorld primaryHand lastEvent.	aMenu addLine.	aMenu add: 'inspect morph' target: costume selector: #inspect.	aMenu add: 'inspect player' target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' target: self action: #browsePlayerClass.		aMenu add: 'inspect class' target: self class action: #inspect]."	aMenu add: 'switch costume...' target: self selector: #chooseCostumeIn: argument: aWorld.""	aMenu add: 'get info...' action: #getInfo.  "! !!Player methodsFor: 'misc' stamp: 'sw 1/12/1999 16:02'!unusedScriptName	"answer a name of the form 'scriptN', where N is one higher than the highest-numbered similarly-named script"	| highestThus aPair |	highestThus _ 0.	self class tileScriptNames do:		[:aName |			aPair _ aName stemAndNumericSuffix.			aPair first = 'script' ifTrue: [highestThus _ highestThus max: aPair last]].	^ ('script', (highestThus + 1) printString) asSymbol! !!Player methodsFor: 'misc' stamp: 'sw 12/28/1998 01:11'!updateAllViewers	"The receiver's structure has changed, so viewers on it need to be reconstituted."	| aPresenter |	(aPresenter _ self costume presenter) ifNil: [^ self].	self allOpenViewers do:		[:aViewer |			(aViewer isKindOf: PartsViewer) "backward compat"				ifTrue:					[aPresenter updatePartsViewer: aViewer]				ifFalse:					[aPresenter updateViewer: aViewer]]! !!Player methodsFor: 'misc' stamp: 'sw 12/28/1998 01:20'!updateAllViewersAndForceToShow: aCategory	"The receiver's structure has changed, so viewers on it need to be reconstituted."	| aPresenter |	(aPresenter _ self costume presenter) ifNil: [^ self].	self allOpenViewers do:		[:aViewer |			(aViewer isKindOf: PartsViewer) "backward compat"				ifTrue:					[aPresenter updatePartsViewer: aViewer]				ifFalse:					[aPresenter updateViewer: aViewer forceToShow: aCategory]]! !!Player class methodsFor: 'slots' stamp: 'sw 12/18/1998 21:08'!compileAccessorsFor: varName	^ self compileInstVarAccessorsFor: varName! !!Player class methodsFor: 'slots' stamp: 'sw 12/18/1998 21:09'!compileInstVarAccessorsFor: varName	| nameString |	nameString _ varName asString capitalized.	self compileUnlogged: ('get', nameString, '	^ ', varName)		classified: 'access' notifying: nil.	self compileUnlogged: ('set', nameString, ': val	', varName, ' _ val')		classified: 'access' notifying: nil! !!Player class methodsFor: 'slots' stamp: 'sw 12/17/1998 20:30'!removeAccessorsFor: varName	^ self removeInstVarAccessorsFor: varName! !!Player class methodsFor: 'slots' stamp: 'sw 12/17/1998 20:31'!removeInstVarAccessorsFor: varName	| nameString |	nameString _ varName asString capitalized.	self removeSelector: ('get', nameString) asSymbol.	self removeSelector: ('set', nameString, ':') asSymbol! !!Player class methodsFor: 'slots' stamp: 'sw 12/23/1998 14:18'!removeInstVarName: aName	self removeInstVarAccessorsFor: aName.	super removeInstVarName: aName.	self slotInfo removeKey: aName asSymbol! !!Player class methodsFor: 'slots' stamp: 'sw 12/18/1998 21:09'!renameSilentlyInstVar: oldName to: newName	(instanceVariables includes: oldName) = 0 ifTrue:		[self error: oldName , ' is not defined in ', self name].	self removeAccessorsFor: oldName.	super renameSilentlyInstVar: oldName asString to: newName asString.	self compileAccessorsFor: newName.	slotInfo at: newName put: (slotInfo at: oldName).	slotInfo removeKey: oldName! !!Player class methodsFor: 'scripts' stamp: 'sw 12/28/1998 10:57'!permanentUserScriptFor: aSelector player: aPlayer	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	self flag: #deferred.  "That anonymous script will of course contain refs to aPlayer who may well not be the class's prototype.  So if it is then saved, there's a problem"	entry _ UserScript new initializePermanentScriptFor: aPlayer.	scripts at: aSelector put: entry.	^ entry! !!Player class methodsFor: 'scripts' stamp: 'sw 12/28/1998 14:22'!removeScriptNamed: aScriptName	aScriptName ifNotNil:		[scripts removeKey: aScriptName.		self removeSelectorUnlogged: aScriptName]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 1/29/1999 15:34'!chooseInitialSettings 	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	#(	(allowSysWindowEmbedding			false)		(automaticViewerPlacement			true)		(browseWithPrettyPrint				false)		(cmdDotEnabled						true)		(confirmFirstUseOfStyle				true)		(disableSounds						false)		(fastDragWindowForMorphic			false)		(ignoreStyleIfOnlyBold				true)		(inboardScrollbars					false)		(logDebuggerStackToFile				true)		(noviceMode							false)		(printAlternateSyntax				false)		(reverseWindowStagger				true)		(showDebugHaloHandle				true)		(showDiffsInChangeList				true)		(showTimeStampsInMenuTitles		false)		(showProjectZoom					false)		(suppressCheckForSlips				false)		(suppressUpdateServerPrompt		false)		(thoroughSenders					true)		(unlimitedPaintArea					false)		(updateSavesFile						false)		(useAnnotationPanes				false)		(warnIfNoChangesFile				true)		(warnIfNoSourcesFile				true))	do:		[:aPair |			aPair last == #true				ifTrue:					[self enable: aPair first]				ifFalse:					[self disable: aPair first]]! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'sw 2/1/1999 13:32'!showPlayerSource	"Change the definition here to re-hard-code this to your preferred setting"	^ false! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'sw 2/1/1999 13:32'!showScriptSource	"Change the definition here to re-hard-code this to your preferred setting"	^ false! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'sw 2/1/1999 13:32'!useDetailPanesInViewers	"Change the definition here to re-hard-code this to your preferred setting"	^ false! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 1/12/1999 16:02'!classNamesForStandardPartsBin	^	#(			(RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph PaintInvokingMorph  StringMorph)		(  JoystickMorph ClockMorph BasicButton PianoKeyboardMorph RecordingControlsMorph))! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 2/1/1999 13:18'!customPagesForPartsBin	| aPage aWindow  pu pageList aClass |	pageList _ OrderedCollection new.	pageList add: (aPage _ self newPageForStandardPartsBin).	aPage addMorphBack: (PasteUpMorph authoringPrototype color: (Color r: 0.96 g: 0.96 b: 0.96)).	aPage addMorphBack: TabbedPalette authoringPrototype.	aPage addMorphBack: BookMorph authoringPrototype.	aPage addMorphBack: Morph new previousPageButton markAsPartsDonor.	aPage addMorphBack: Morph new nextPageButton markAsPartsDonor.	#(DatumMorph) do:		[:aName | (aClass _ Smalltalk at: aName ifAbsent: [nil]) ifNotNil:			[aPage addMorphBack: aClass authoringPrototype]].	pageList add: (aPage _ self newPageForStandardPartsBin).	aWindow _ Browser new openAsMorphEditing: nil.	aWindow setLabel: 'System Browser'.	aPage addMorphBack: aWindow.	aWindow _ Workspace new embeddedInMorphicWindowLabeled: 'Workspace'.	aPage addMorphBack: aWindow.	aPage addMorphBack: FileList openAsMorph.	aWindow _ SelectorBrowser new morphicWindow.	aWindow setLabel: 'Selector Browser'.	aPage addMorphBack: aWindow.	aPage addMorphBack: ((pu _ PasteUpMorph newSticky borderInset) embeddedInMorphicWindowLabeled: 'assembly').	pageList add: (aPage _ self newPageForStandardPartsBin).	aPage addMorphBack: ScriptingSystem newScriptingSpace.	aPage addMorphBack: ScriptingSystem scriptControlButtons.	aPage addMorphBack: TrashCanMorph new.	aPage addMorphBack: PasteUpMorph authoringPrototype.	aPage addMorphBack: ((pu _ PasteUpMorph newSticky) embeddedInMorphicWindowLabeled: 'assembly').	pu color: (Color r: 0.839 g: 1.0 b: 0.935).	pageList do:		[:page |			page  replaceTallSubmorphsByThumbnails.			page fixLayout].	^ pageList! !!Presenter methodsFor: 'viewer' stamp: 'sw 1/17/1999 21:51'!nascentPartsViewer	^ StandardViewer new! !!Presenter methodsFor: 'viewer' stamp: 'sw 12/23/1998 23:20'!updatePartsViewer: aPartsViewer	| aPlayer aPosition aNewPartsViewer oldOwner wasSticky |		"obsolete branch, only for old PartsViewer objects"	aPlayer _ aPartsViewer scriptedPlayer.	aPosition _ aPartsViewer position.	wasSticky _ aPartsViewer isSticky.	aNewPartsViewer _ aPartsViewer species new visible: false.	wasSticky ifTrue: [aNewPartsViewer beSticky].	oldOwner _ aPartsViewer owner.	aPartsViewer delete.	oldOwner ifNotNil: [oldOwner addMorphBack: aNewPartsViewer].	aNewPartsViewer obtainBankInfoFrom: aPartsViewer.	aNewPartsViewer setPlayer: aPlayer.	aNewPartsViewer position: aPosition.	self harmonizeTileColorPolicyFor: aNewPartsViewer.	aNewPartsViewer visible: true.	aNewPartsViewer layoutChanged! !!Presenter methodsFor: 'viewer' stamp: 'sw 12/28/1998 22:34'!updateViewer: aViewer	self updateViewer: aViewer forceToShow: nil! !!Presenter methodsFor: 'viewer' stamp: 'sw 12/28/1998 18:08'!updateViewer: aViewer forceToShow: aCategory	| aPlayer aPosition newViewer oldOwner wasSticky barHeight |	aPlayer _ aViewer scriptedPlayer.	aPosition _ aViewer position.	wasSticky _ aViewer isSticky.	newViewer _ aViewer species new visible: false.	barHeight _ aViewer submorphs first orientation == #vertical		ifTrue:			[aViewer submorphs first submorphs first height]		ifFalse:			[0].	newViewer initializeFor: aPlayer barHeight: barHeight.	wasSticky ifTrue: [newViewer beSticky].	oldOwner _ aViewer owner.	oldOwner ifNotNil:		[oldOwner replaceSubmorph: aViewer by: newViewer].		"It has happened that old readouts are still on steplist.  We may see again!!"	newViewer obtainBankInfoFrom: aViewer forceToShow: aCategory.	newViewer position: aPosition.	self harmonizeTileColorPolicyFor: newViewer.	newViewer visible: true.	newViewer world startSteppingSubmorphsOf: newViewer.	newViewer layoutChanged! !!Presenter methodsFor: 'viewer' stamp: 'sw 12/23/1998 23:26'!viewMorph: aMorph	| aPlayer aViewer aPalette aRect aPoint nominalHeight |	Sensor leftShiftDown ifFalse:		[((aPalette _ aMorph standardPalette) ~~ nil and: [aPalette isInWorld])			ifTrue:	[^ aPalette viewMorph: aMorph]].	aPlayer _ aMorph assuredPlayer.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	aViewer initializeFor: aPlayer barHeight: 6.	self harmonizeTileColorPolicyFor: aViewer.	Preferences automaticViewerPlacement ifTrue:		[aPoint _ aMorph bounds right @ 			(aMorph center y - ((nominalHeight _ aViewer initialHeightToAllow) // 2)).		aRect _ (aPoint extent: (aViewer width @ nominalHeight)) translatedToBeWithin: associatedMorph world bounds.		aViewer position: aRect topLeft.		aViewer visible: true.		associatedMorph world startSteppingSubmorphsOf: aViewer.		"it's already in the world, somewhat coincidentally"		^ self].	aMorph primaryHand attachMorph: (aViewer visible: true)! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 1/12/1999 16:03'!phrase: aPhraseTileMorph	"Make the receiver be an anonymous editor around aPhraseTileMorph"	firstTileRow _ 2.	self addMorphBack: (AlignmentMorph newRow addMorphBack: aPhraseTileMorph).	self install! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 1/12/1999 16:04'!scriptName: newName	"Smash in a changed script name, with no side effects"	scriptName _ newName! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/12/1999 16:02'!abandon	owner ifNil: [^ self].	self isAnonymous  ifTrue:		[self actuallyDestroyScript.		"this is destructive but the user has deleted the editor via the halo, making a dialog seemingly inappropriate"].	self delete! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 12/28/1998 13:20'!actuallyDestroyScript	| aHandler |	self delete.	playerScripted class removeScriptNamed: scriptName.	playerScripted actorState instantiatedUserScriptsDictionary removeKey: scriptName.		"not quite enough yet in the multiple-instance case..."	(aHandler _ playerScripted costume renderedMorph eventHandler) ifNotNil:		[aHandler forgetDispatchesTo: scriptName].	playerScripted updateAllViewersAndForceToShow: 'scripts'! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 12/28/1998 18:09'!destroyScript	| aMenu reply |	self flag: #deferred.  "Maybe this other branch should be reinstated someday"	true ifTrue:		[^ self inform: 'Please make this request ina Viewer'].	(playerScripted okayToDestroyScriptNamed: scriptName)		ifFalse:			[^ self inform: 'Sorry, this script is being calledfrom another script.'].	(self isAnonymous not and: [submorphs size > 1]) ifTrue:		[aMenu _ SelectionMenu selections: #('destroy it' 'oops, no, don''t destroy').		reply _ aMenu startUpWithCaption: 'Do you really want todestroy this script?'.		(reply = 'destroy it') ifFalse: [^ self]].	self actuallyDestroyScript! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/12/1999 16:03'!dismiss	| aMenu reply |	owner ifNil: [^ self].	scriptName ifNil: [^ self delete].  "ad hoc fixup for bkwrd compat"	self isAnonymous		ifTrue:			[((submorphs size > 3) or: [self scriptInstantiation status ~~ #normal]) ifTrue:				[aMenu _ SelectionMenu selections: #('yes, name it' 'no, discard it' 'cancel').				reply _ aMenu startUpWithCaption: 'Do you want to give this		script a name and save it? '.				(reply size == 0 or: [reply = 'cancel']) ifTrue: [^ self].				(reply = 'yes, name it') ifTrue: [^ self renameScript]].		self actuallyDestroyScript].	self delete! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 12/28/1998 11:34'!explainStatusAlternatives 	(StringHolder new contents: ScriptingSystem statusHelpString)		openLabel: 'Script Status'! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/29/1999 16:34'!hasScriptReferencing: aSlotName ofPlayer: aPlayer	"Answer whether the receiver has any tiles in it which reference the given slot of the given player.  Place-holder for now, needs to be implemented"	self flag: #deferred.  "a feature whose time has now just about come?!!"	^ false! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 12/28/1998 14:51'!offerScriptorMenu	| aMenu result  aList lines title |	self isAnonymous		ifTrue:			[aList _ #(				('name and save this script'		renameScript)				('destroy this script'				destroyScript)				('explain status alternatives' 	explainStatusAlternatives)).			title _ 'temporary script'.			lines _ #()]		ifFalse:			[title _ scriptName asString.			self isTextuallyCoded				ifTrue:					[title _ title, ' (textually coded)'.					aList _ #(						('revert to tile version...'		revertScriptVersion)						('modify textual script'			editScriptTextually)				"		('view all scripts'				browseScripts)"						('destroy this script'				destroyScript)						('rename this script'				renameScript)						('explain status alternatives' 	explainStatusAlternatives)).					lines _ #(2 4)]				ifFalse:					[aList _ #(						('save this version'				saveScriptVersion)						('revert to prior version...'		revertScriptVersion)						('edit this script textually'		editScriptTextually)					"	('view all scripts'				browseScripts)"						('destroy this script'				destroyScript)						('rename this script'				renameScript)						('explain status alternatives' 	explainStatusAlternatives)).					lines _ #(2 3 5)]].	aMenu _ SelectionMenu labelList: (aList collect: [:pair | pair first]) lines: lines selections: (aList collect: [:pair | pair second]).	result _ aMenu startUpWithCaption: title.	result ifNotNil: [self perform: result]"		('add parameter to this script'	addParameter)"! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 12/28/1998 18:09'!renameScript	"Invoked at user menu request"	| reply aPosition oldSelector dflt oldStatus oldOwner |	self flag: #deferred.  "Maybe this other branch should be reinstated someday"	true ifTrue:		[^ self inform: 'Please make this request ina Viewer'].	oldSelector _ self scriptName.	oldStatus _ self scriptInstantiation status.	dflt _ self isAnonymous ifTrue: [''] ifFalse: [self scriptTitle].	reply _   FillInTheBlank request: 'Script Name' initialAnswer: dflt. 	reply size == 0 ifTrue: [^ self].	reply first isUppercase ifTrue: [^ self inform: 'Illegal script name'].	((reply _ reply asSymbol) == scriptName) ifTrue: [^ self].	(Scanner isLiteralSymbol: reply) ifFalse: [^ self inform: 'Bad script name, please try again'].	self titleMorph borderColor: Color black.	scriptName _ reply.	playerScripted class atSelector: reply putScriptEditor: self.	self scriptInstantiation status: oldStatus.	playerScripted class removeScriptNamed: oldSelector.	playerScripted actorState instantiatedUserScriptsDictionary removeKey: oldSelector.	submorphs first delete.  "the button row"	self addMorphFront: self buttonRowForEditor.  "up to date"	self install.	aPosition _ self position.	oldOwner _ self topRendererOrSelf owner.	self delete	playerScripted costume viewAfreshIn: oldOwner showingScript: scriptName at: aPosition! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/12/1999 16:03'!renameScript: newSelector	| aPosition oldStatus existingOwner |	oldStatus _ self scriptInstantiation status.	self titleMorph borderColor: Color black.	scriptName _ newSelector.	self scriptInstantiation status: oldStatus.	submorphs first delete.  "the button row"	self addMorphFront: self buttonRowForEditor.  "up to date"	self install.	aPosition _ self position.	existingOwner _ self topRendererOrSelf owner.	self delete	playerScripted costume viewAfreshIn: existingOwner showingScript: scriptName at: aPosition! !!ScriptInstantiation methodsFor: 'anonymity' stamp: 'sw 12/28/1998 10:56'!initializePermanentScriptFor: aPlayer	anonymous _ false.	player _ aPlayer.	status _ #normal.	selector _ aPlayer unusedScriptName! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 1/12/1999 16:04'!morphicWindow	"Create a Browser that lets you type part of a selector, shows a list of selectors, shows the classes of the one you chose, and spawns a full browser on it.  Answer the window	SelectorBrowser new open "	| window typeInView selectorListView classListView |	window _ (SystemWindow labelled: 'later') model: self.	selectorIndex _ classListIndex _ 0.	typeInView _ PluggableTextMorph on: self 		text: #contents accept: #contents:notifying:		readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	typeInView acceptOnCR: true.	window addMorph: typeInView frame: (0@0 corner: 0.5@0.14).	selectorListView _ PluggableListMorph on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #selectorMenu:		keystroke: #messageListKey:from:.	selectorListView menuTitleSelector: #selectorMenuTitle.	window addMorph: selectorListView frame: (0@0.14 corner: 0.5@1).	classListView _ PluggableListMorph on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: nil		keystroke: #arrowKey:from:.	classListView menuTitleSelector: #classListSelectorTitle.	window addMorph: classListView frame: (0.5@0 corner: 1@1).	window setLabel: 'Selector Browser'.	^ window! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 1/12/1999 16:04'!openAsMorph	"Create a Browser that lets you type part of a selector, shows a list of selectors, shows the classes of the one you chose, and spwns a full browser on it.	SelectorBrowser new open   "	^ self morphicWindow openInWorldExtent: 450@200! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'sw 2/1/1999 13:27'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph	| aPaintBox newPaintBoxBounds worldBounds requiredWidth newOrigin aPosition aPal |	aPaintBox _ self world paintBox.	worldBounds _ self world bounds.	requiredWidth _ aPaintBox width.	aPosition _ (aPal _ aPasteUpMorph standardPalette)		ifNotNil:			[aPal showNoPalette.			aPal topRight + (aPaintBox width negated @ 0 "aPal tabsMorph height")]		ifNil:			[boundsToUse topRight].	newOrigin _ aPosition x  + requiredWidth <= worldBounds right			ifTrue:  "will fit to right of aPasteUpMorph"				[aPosition]			ifFalse:  "won't fit to right, try left"				[boundsToUse topLeft - (requiredWidth @ 0)].	newPaintBoxBounds _ (newOrigin extent: aPaintBox extent) translatedToBeWithin: worldBounds.	self initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: newPaintBoxBounds origin! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'sw 1/29/1999 16:37'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: aPosition	| w  |	(w _ aPasteUpMorph world) addMorphFront: self.	palette _ w paintBox.	hostView _ aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	canvasRectangle _ bounds translateBy: w viewBox origin.	w addMorphFront: palette.  "bring to front"	palette position: aPosition.	paintingForm _ Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	self addRotationScaleHandles.	aSketchMorph ifNotNil:		[aSketchMorph rotationDegrees: 0.		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter]! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 1/17/1999 09:51'!helpStringFor: aSymbol	^ HelpStrings at: aSymbol ifAbsent: ['No help yet available for ', aSymbol]! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 1/29/1999 16:18'!initializeHelpStrings	"ScriptingSystem initializeHelpStrings"	HelpStrings _ IdentityDictionary new.	#((heading		number		'Which direction the object is facing.  0 is straight up') (x				number		'The x coordinate, measured from the left of the container')(y				number'The y-coordinate, measured upward from the bottom of the container')(colorUnder		color'The color under the center of the object')(penDown		boolean'Whether the object''s pen is down (true) or up (false)')(penColor		color'The color of the object''s pen')(penSize			number'The size of the object''s pen')(colorSees		boolean'Whether a given color in the object is over another given color')(isOverColor		boolean'Whether any part of this object is directly over the specified color')(isUnderMouse	boolean'Whether any part of this object is beneath the current mouse-cursor position')(scaleFactor		number'The amount by which the object is scaled')(width			number'The distance between the left and right edges of the object')(height			number'The distance between the top and bottom edges of the object')(isOverColor		color'Whether any part of the object is over a given color')(color			color'The object''s interior color')(borderWidth	number'The width of the object''s border')(borderColor		color'The color of the object''s border')(cursor			number'The index of the chosen element')(valueAtCursor	player'The chosen element')(leftRight		number'The horizontal displacement')(upDown		number'The vertical displacement')(angle			number'The angular displacement')(amount		number'The amount of displacement')(mouseX		number'The x coordinate of the mouse pointer')(mouseY		number'The y coordinate of the mouse pointer')(left		number'My left edge, measured from the left edge of the World')(right		number'My right edge, measured from the left edge of the world')(top		number'My top edge, measured downward from the top edge of the world')(bottom		number'My bottom edge, measured downward from the top edge of the world')(tryMe			command'Click here to run this script once; hold button down to run repeatedly.')(try			command'Run this command once.')(dismiss			command'Click here to dismiss me')(addYesNoToHand	command'Press here to tear off a  TEST/YES/NO unit which you can drop into your script')(chooseTrigger	command'When this script should run."normal" means "only when called".See "explain status alternatives" at leftfor more information.')(offerScriptorMenu	command'Press here to get a menu of options for this Scriptor')(objectNameInHalo  control'Object''s name -- To change: click here; backspace over old name, type in new name; hit ENTER')(userScript		command'This is a script defined by you.  Click here to rename or delete it')(userSlot		control'This is an instance variable defined by you.  Click here to change its type')		) do: [:triplet | HelpStrings at: triplet first put: triplet third].	self setHelpStringsForSystemScripts! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 1/29/1999 16:07'!setHelpStringsForSystemScripts	"ScriptingSystem setHelpStringsForSystemScripts"	#((forward:		command		'Moves the object forward in the direction it is heading') (turn:			command		'Change the heading of the object by the specified amount')(beep:			command'make the specified sound')(show		command'If object was hidden, make it show itself again.')(hide		command'Make the object so that it does not display and cannot handle input')(wearCostumeOf:		command'Wear the same kind of costume as the other object')(startScript:		command'Make a script start running.')(stopScript:		command'Make a script stop running.')(pauseScript:		command'Make a running script become paused.')(moveToward:		command'Move in the direction of another object.')(bounce:		command'If object strayed beyond the boundaries of its container, make it reflect back into it, making the specified noise while doing so.')(wrap		command'If object has strayed beond the boundaries of its container, make it reappear from the opposite edge.')(followPath		command'Retrace the path the object has memorized, if any.')(goToRightOf:		command'Align the object just to the right of any specified object.')(liftAllPens		command'Lift the pens on all the objects in my interior.')(lowerAllPens		command'Lower the pens on all the objects in my interior.')(clearTurtleTrails		command'Clear all the pen trails in the interior.')(goToNextCard		command'Go to the next card')(newCard		command'Create a new card.')(goToPreviousCard		command'Go to the previous card.')(deleteCard		command'Delete the current card.')(nextPage		command'help')(previousPage		command'help')(firstPage		command'help')(lastPage		command'Go to the last page of the book.')(goto:		command'Go to the specfied book page')(unhideHiddenObjects		command'Unhide all hidden objects.')(roundUpStrays		command'Bring all out-of-container subparts back into view.')(initiatePaintingIn:		command'Initiate painting of a new object in the given place.')(initiatePainting		command'Initiate painting of a new object in the standard playfield.')(userSlot		control'This is an instance variable defined by you.  Click here to change its type')		) do: [:triplet | HelpStrings at: triplet first put: triplet third]! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 1/12/1999 16:05'!statusHelpString	^	'normal -- run when calledpaused -- ready to run all the timeticking -- run all the timemouseDown -- run when mouse goes down on memouseStillDown -- while mouse still downmouseUp -- when mouse comes back upmouseEnter -- when mouse enters my bounds, button upmouseLeave -- when mouse exits my bounds, button upmouseEnterDragging -- when mouse enters my bounds, button downmouseLeaveDragging -- when mouse exits my bounds, button downopening -- when I am being openedclosing -- when I am being closed'"'keyStroke -- run when user hits a key' "! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 2/1/1999 14:08'!getterSelectorFor: aSymbol	aSymbol == #isOverColor: ifTrue: [^ #seesColor:].	^ Utilities getterSelectorFor: aSymbol! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 1/12/1999 16:05'!setterSelectorFor: aSymbol	^ Utilities setterSelectorFor: aSymbol! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 1/12/1999 16:05'!typeForSystemSlotNamed: aName	^ SystemSlotDictionary at: aName ifAbsent: [nil]"ScriptingSystem typeForSystemSlotNamed: #colorSeesScriptingSystem typeForSystemSlotnamed: #frog"! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 1/13/1999 13:14'!wordingForAssignmentSuffix: aString	| toTest |	toTest _ aString asString.	#(	(':'					'_')		('Incr:'				'increase by')		('Decr:'				'decrease by')		('Mult:'				'multiply by'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest	"ScriptingSystem wordingForAssignmentSuffix: 'Incr:'"! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 12/30/1998 13:26'!wordingForOperator: aString	| toTest |	toTest _ aString asString.	#(	(beep:					'make sound')		(bounce:				'bounce')		(clearTurtleTrails		'clear pen trails')		(forward:				'forward by')		(moveToward:			'move toward')		(goToRightOf:			'align after')		(isDivisibleBy:			'is divisible by')		(liftAllPens				'lift all pens')		(lowerAllPens			'lower all pens')		(pauseScript:			'pause script')		(max:					'max')		(min:					'min')		(seesColor:				'is over color')		(makeNewDrawingIn:	'start painting in')		(startScript:				'start script')		(stopProgramatically	'stop')		(stopScript				'stop script')		(turn:					'turn by')		(wearCostumeOf:		'look like')		(=						'=?'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 12/30/1998 14:11'!doesOperatorWantArrows: aSymbol	^ aSymbol isInfix or: [#(isDivisibleBy:) includes: aSymbol]! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 12/28/1998 22:37'!isAcceptablePlayerScriptName: aSymbol	(StandardSlotInfo includesKey: aSymbol) ifTrue: [^ false].	(StandardScriptInfo includesKey: aSymbol) ifTrue: [^ false].	self flag: #deferred.   "Flesh out the list below and put it into a class variable"	(#(costume costumes dependents true false size) includes: aSymbol) ifTrue: [^ false].	(Player basicNew respondsTo: aSymbol) ifTrue:		[^ false].	^ true! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 12/28/1998 18:19'!isAcceptablePlayerSlotName: aSymbol	(StandardSlotInfo includesKey: aSymbol) ifTrue: [^ false].	(StandardScriptInfo includesKey: aSymbol) ifTrue: [^ false].	self flag: #deferred.   "Flesh out the list below and put it into a class variable"	(#(costume costumes dependents true false size) includes: aSymbol) ifTrue: [^ false].	^ true! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 2/1/1999 10:01'!viewMorph: aMorph	"The receiver is expected to have a viewer tab; select it, and target it to aMorph"	| aPlayer aViewer |	((currentPage isKindOf: Viewer) and: [currentPage scriptedPlayer == aMorph player])		ifTrue:			[^ self].	self visible: false.	aPlayer _ aMorph assuredPlayer.	aViewer _  StandardViewer new initializeFor: aPlayer barHeight: 6.	self showNoPalette.	currentPage ifNotNil: [currentPage delete].	self addMorphBack: (currentPage _ aViewer).	self snapToEdgeIfAppropriate..	self world startSteppingSubmorphsOf: aViewer.	self visible: true! !!TileMorph methodsFor: 'initialization' stamp: 'sw 12/30/1998 14:12'!setOperator: aString	type _ #operator.	operatorOrExpression _ aString asSymbol. 	self line1: (ScriptingSystem wordingForOperator: aString).	(ScriptingSystem doesOperatorWantArrows: operatorOrExpression)		ifTrue: [self addArrows; updateLiteralLabel].	"operatorOrExpression == #heading ifTrue: [self halt]."! !!TileMorph methodsFor: 'arrows' stamp: 'sw 12/30/1998 13:12'!arrowAction: delta	"Figure out what to do when the up or down arrow is pressed.	May be overridden in subclasses"	| index aList |	owner ifNil: [^ self].	(type == #literal and: [literal isNumber])		ifTrue: [^ self literal: literal + delta].	(type == #literal and: [literal isKindOf: Boolean])		ifTrue: [^ self literal: literal not].	operatorOrExpression ifNotNil:		[aList _ #(+ - * / // \\ min: max:).		index _ aList indexOf: operatorOrExpression.		index  > 0 ifTrue:			[self setOperatorAndUseArrows: (aList atWrap: index + delta)].		aList _ #(< <= = ~= > >= isDivisibleBy:).		index _ aList indexOf: operatorOrExpression.		index  > 0 ifTrue:			[owner firstSubmorph type = #number 				ifTrue: [self setOperator: (aList atWrap: index + delta)]				ifFalse: [self setOperator: (#(= ~=) atWrap: index - 2 + delta)]].						"Color does not understand <"			^ self acceptNewLiteral]	! !!AssignmentTileMorph methodsFor: 'all' stamp: 'sw 1/17/1999 21:10'!addArrowsIfAppropriate	"If the receiver's slot is of an appropriate type, add arrows to the tile"	(#(number sound boolean) includes: dataType)  ifTrue: [self addArrows]! !!AssignmentTileMorph methodsFor: 'all' stamp: 'sw 1/17/1999 21:10'!computeOperatorOrExpression	| aSuffix |	operatorOrExpression _ (assignmentRoot, assignmentSuffix) asSymbol.	aSuffix _ ScriptingSystem wordingForAssignmentSuffix: assignmentSuffix.	operatorReadoutString _ assignmentRoot, ' ', aSuffix. 	self line1: operatorReadoutString.	self addArrowsIfAppropriate! !!AssignmentTileMorph methodsFor: 'all' stamp: 'sw 1/17/1999 21:10'!setAssignmentSuffix: aString	assignmentSuffix _ aString.	self computeOperatorOrExpression.	type _ #operator. 	self line1: (ScriptingSystem wordingForOperator: operatorOrExpression).	self addArrowsIfAppropriate; updateLiteralLabel! !!AssignmentTileMorph methodsFor: 'all' stamp: 'sw 12/24/1998 12:33'!storeCodeOn: aStream indent: tabCount	aStream nextPutAll: ' assign', (assignmentSuffix copyWithout: $:), 'Getter: #'.	aStream nextPutAll: (ScriptingSystem getterSelectorFor: assignmentRoot).	aStream nextPutAll: ' setter: #'.	aStream nextPutAll: (ScriptingSystem setterSelectorFor: assignmentRoot).	aStream nextPutAll: ' amt: '.! !!ColorTileMorph methodsFor: 'other' stamp: 'sw 1/6/1999 10:41'!setLiteral: aLiteral	colorSwatch color: aLiteral! !!ColorTileMorph methodsFor: 'other' stamp: 'sw 1/6/1999 10:43'!updateLiteralLabel	"Do nothing"! !!SoundReadoutTile methodsFor: 'as yet unclassified' stamp: 'sw 1/17/1999 21:51'!setLiteralTo: anObject width: w	| soundChoices index |	self flag: #deferrred.  "This is still in process, and until it's worked through, #sound as a data type for user-added slots will continue to be disallowed"	soundChoices _ #('silence').  "default, if no SampledSound class"	Smalltalk at: #SampledSound ifPresent:		[:sampledSound | soundChoices _ sampledSound soundNames].	index _ soundChoices indexOf: anObject.	self setLiteral: (soundChoices atWrap: index)! !!UnscriptedPlayer methodsFor: 'all' stamp: 'sw 12/28/1998 10:27'!hasUserDefinedScripts	^ false! !!UnscriptedPlayer methodsFor: 'all' stamp: 'sw 12/28/1998 10:27'!hasUserDefinedSlots	^ false! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 2/1/1999 14:39'!acceptValueFromTarget: v	lastValue _ v.	format = #string ifTrue: [^ v asString].	(format = #default and: [v isNumber]) ifTrue:		[v isInteger ifTrue: [^ v asInteger printString].		(v isKindOf: Float) ifTrue: [^ (v roundTo: self floatPrecision) printString]].	^ v printString! !!UserScript methodsFor: 'versions' stamp: 'sw 12/28/1998 15:14'!revertScriptVersionFrom: anEditor	| aMenu result aPosition oldOwner |	formerScriptEditors size == 0 ifTrue: [^ self beep].	aMenu _ SelectionMenu labelList: (formerScriptEditors collect: [:e | e timeStamp])		selections: formerScriptEditors.	result _ aMenu startUp.	result ifNotNil:		[aPosition _ anEditor position.		oldOwner _ anEditor topRendererOrSelf owner.		anEditor delete.		currentScriptEditor _ result bringUpToDate install.		player costume viewAfreshIn: oldOwner showingScript: selector at: aPosition]! !!Viewer methodsFor: 'all' stamp: 'sw 12/28/1998 10:59'!newPermanentScript	| aMorph |	self scriptedPlayer assureUniClass.	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'newScript').	aMorph setProperty: #newPermanentScript toValue: true.	aMorph setProperty: #player toValue: self scriptedPlayer.	self primaryHand attachMorph: aMorph! !!CategoryViewer methodsFor: 'header pane' stamp: 'sw 12/30/1998 12:39'!addHeaderMorph	| header aFont aButton wrpr |	header _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	header addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Delete this Viewer'.	header addTransparentSpacerOfSize: 5@5.	header addUpDownArrowsFor: self.	header beSticky.	self addMorph: header.	(wrpr _ header submorphs last) submorphs second setBalloonText: 'previous category'.		wrpr submorphs first  setBalloonText: 'next category'.		namePane _ (StringButtonMorph contents: '-----' "font: ScriptingSystem fontForScriptorButtons") color: Color black.	namePane target: self; arguments: Array new; actionSelector: #chooseCategory.	namePane actWhen: #buttonDown.	namePane align: namePane topLeft with: (bounds topLeft + (50 @ 0)).	namePane setBalloonText: 'category (click here to choose a different one)'.	header addMorphBack: namePane.	self categoryChoice: 'basic'! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 1/29/1999 16:23'!infoButtonFor: aScriptOrSlotSymbol	| aButton balloonTextSelector |	balloonTextSelector _ nil.	(scriptedPlayer slotInfo includesKey: aScriptOrSlotSymbol asSymbol)		ifTrue: [balloonTextSelector _ #userSlot].	(scriptedPlayer belongsToUniClass and:			[scriptedPlayer class includesSelector: aScriptOrSlotSymbol])		ifTrue: [balloonTextSelector _ #userScript].	aButton _ SimpleButtonMorph new.	aButton target: scriptedPlayer;		actionSelector: #infoFor:inViewer:;		arguments: (Array with: aScriptOrSlotSymbol with: self);		label: '¥' font: (StrikeFont familyName: #ComicBold size: 12);		color: Color transparent;		borderWidth: 0;		actWhen: #buttonDown.	(Preferences useDetailPanesInViewers and: [Preferences showScriptSource])		ifTrue:			[aButton setBalloonText: 'menu']		ifFalse:			[aButton balloonTextSelector: (balloonTextSelector ifNil: [aScriptOrSlotSymbol])].	^ aButton! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 1/13/1999 12:48'!phraseForSlot: slotName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Return a PhraseTileMorph representing the slot in the viewer"	| r anArrow |	r _ ViewerRow newRow		color: self color;		beSticky;		elementSymbol: slotName asSymbol;		centering: #center.	r addDetailButton.	r addMorphBack: (self slotHeaderFor: slotName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self infoButtonFor: slotName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: self tileForSelf bePossessive.	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self getterButtonFor: slotName type: partType).	(slotName == #isOverColor)		ifTrue:			[self addIsOverColorDetailTo: r]		ifFalse:			[readOnly ifFalse:				[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"				r addMorphBack: (anArrow _ self arrowSetterButtonFor: slotName type: partType)].			r addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"			(#(colorSees) includes: slotName) ifFalse:		 		[r addMorphBack: (self readoutFor: slotName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector)]].	anArrow ifNotNil: [anArrow step].	^ r! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 12/24/1998 12:34'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new		target: scriptedPlayer costume;		getSelector: (ScriptingSystem getterSelectorFor: partName);		borderWidth: 1;		extent:  22@22.		putSelector == #unused ifFalse: [readout putSelector: (ScriptingSystem setterSelectorFor: partName)]].	readout ifNil: [readout _ scriptedPlayer costume updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 1/13/1999 13:00'!slotHeaderFor: aSlotName	^ Morph new beTransparent extent:  9@22! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 1/16/1999 18:24'!arrowSetterButtonFor: partName type: partType	| m |	m _ RectangleMorph new		color: (ScriptingSystem colorForType: #command);		extent: 24@TileMorph defaultH;		borderWidth: 0.	m addMorphCentered: (ImageMorph new image: (ScriptingSystem formAtKey: 'Gets')).	m on: #mouseDown send: #makeSetter:from:forPart:		to: self		withValue: (Array with: partName with: partType).	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 1/6/1999 11:20'!makeSetter: evt from: aMorph forPart: args	| argType m argTile selfTile argValue |	argType _ args last.	m _ PhraseTileMorph new setAssignmentRoot: args first asSymbol		type: #command		rcvrType: #player		argType: argType.	argValue _ self scriptedPlayer perform: (ScriptingSystem getterSelectorFor: args first asSymbol).	(argValue isKindOf: Player)		ifTrue:			[argTile _ argValue tileReferringToSelf]		ifFalse:			[argTile _ scriptedPlayer tileForArgType: argType inViewer: self.			argTile setLiteral: argValue; updateLiteralLabel.].	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	self primaryHand attachMorph: m.! !!StandardViewer methodsFor: 'all' stamp: 'sw 12/28/1998 15:22'!addCategoryViewer		self addCategoryViewerFor: self likelyCategoryToShow! !!StandardViewer methodsFor: 'all' stamp: 'sw 1/29/1999 15:17'!addHeaderMorphWithBarHeight: anInteger	| header aFont aButton aTextMorph nail wrpr costs headWrapper |	header _ AlignmentMorph newRow color: self color muchLighter; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	header addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #dismiss;			setBalloonText: 'Delete'.	header addTransparentSpacerOfSize: 4@1.	header addMorphBack: (aButton _ SimpleButtonMorph new label: '+' font: aFont).	aButton target: self; beTransparent; borderWidth: 0;			actionSelector: #addCategoryViewer;			setBalloonText: 'click here to addanother viewer'.	header addTransparentSpacerOfSize: 4@1.	(((costs _ scriptedPlayer costumes) size > 1) or: [costs size == 1 and: [costs first ~~ scriptedPlayer costume]]) ifTrue:		[header addUpDownArrowsFor: self.		(wrpr _ header submorphs last) submorphs second setBalloonText: 'switch to previous costume'.			wrpr submorphs first  setBalloonText: 'switch to next costume'].		nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	header addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.		header addTransparentSpacerOfSize: 5@5."	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'S' font: (aFont _ StrikeFont familyName: #ComicBold size: 16);  color: Color transparent; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		header addMorphBack: aButton.	header addTransparentSpacerOfSize: 8@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'I' font: aFont;  color: Color transparent; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 5@5."	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	aTextMorph step.	header  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		header beSticky.	anInteger > 0		ifTrue:			[headWrapper _ AlignmentMorph newColumn color: self color.			headWrapper addTransparentSpacerOfSize: (0 @ anInteger).			headWrapper addMorphBack: header.			self addMorph: headWrapper]		ifFalse:			[self addMorph: header]! !!StandardViewer methodsFor: 'all' stamp: 'sw 12/23/1998 23:26'!initialHeightToAllow	^ 300! !!StandardViewer methodsFor: 'all' stamp: 'sw 12/28/1998 18:15'!initializeFor: aPlayer barHeight: anInteger	scriptedPlayer _ aPlayer.	self orientation: #vertical;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		borderWidth: 1.	self color: self standardViewerColor.	self addHeaderMorphWithBarHeight: anInteger.	self addCategoryViewer.    "#1"	self addCategoryViewer.    "#2"! !!StandardViewer methodsFor: 'all' stamp: 'sw 12/28/1998 15:22'!likelyCategoryToShow	| aList |	aList _ scriptedPlayer categories asOrderedCollection.	self categoryMorphs do:		[:m | aList remove: m currentCategory ifAbsent: []].	((aList includes: 'instance variables') and: [scriptedPlayer hasUserDefinedSlots])		ifTrue:	[^ 'instance variables'].	((aList includes: 'scripts') and: [scriptedPlayer hasUserDefinedScripts])		ifTrue:	[^ 'scripts'].	^ aList size > 0		ifTrue:			[aList first]		ifFalse:			['basic']! !!StandardViewer methodsFor: 'all' stamp: 'sw 12/28/1998 22:32'!obtainBankInfoFrom: anotherViewer	self obtainBankInfoFrom: anotherViewer forceToShow: nil! !!StandardViewer methodsFor: 'all' stamp: 'sw 12/28/1998 22:30'!obtainBankInfoFrom: anotherViewer forceToShow: aCategory	| showing newCategoryMorphs oldCategoryMorphs count |	showing _ false.	newCategoryMorphs _ self categoryMorphs.	oldCategoryMorphs _ anotherViewer categoryMorphs.	1 to: (count _ newCategoryMorphs size min: oldCategoryMorphs size) do:		[:i | (newCategoryMorphs at: i) obtainBankInfoFrom: (oldCategoryMorphs at: i).		((oldCategoryMorphs at: i) currentCategory = aCategory)		ifTrue:	[showing _ true]].	showing ifFalse:		[aCategory ifNotNil: [(newCategoryMorphs at: count) categoryChoice: aCategory]]! !!StandardViewer methodsFor: 'all' stamp: 'sw 12/23/1998 22:45'!standardViewerColor	 ^ Color r: 0.572 g: 0.883 b: 0.572! !!ViewerBook commentStamp: '<historical>' prior: 0!Serves as the container for displaying one or more viewers in a tabbed palette.  Quite likely disused though present having been grandfathered into the flagship image so can't just be expunged.!!ViewerEntry methodsFor: 'all' stamp: 'sw 1/13/1999 16:26'!contents	| aType  newText sel info |	(info _ self slotDocumentation) ifNotNil:  "handles system and user slots"		[^ info].	((aType _ self entryType) == #userScript or: [aType == #systemScript]) ifTrue:		[sel _ self viewerRow elementSymbol.		newText _ (Preferences showScriptSource or: [self playerBearingCode class tileScriptNames includes: sel])			ifTrue:				[self playerBearingCode sourceCodeFor: sel]			ifFalse:				[ScriptingSystem scriptHelpFor: sel]].	^ newText ifNil: ['?????']! !!ViewerEntry methodsFor: 'all' stamp: 'sw 12/28/1998 13:02'!phraseTileMorph	"Answer the phraseTileMorph within the receiver"	^ ((self entryType == #systemScript) or: [self entryType == #userScript])		ifTrue:			[self viewerRow findA: PhraseTileMorph]		ifFalse:			[self error: 'slot rows do not contain a phrase tile morph']! !!ViewerEntry methodsFor: 'all' stamp: 'sw 12/28/1998 13:01'!playerBearingCode	^ owner owner scriptedPlayer! !!ViewerEntry methodsFor: 'all' stamp: 'sw 2/1/1999 13:00'!slotDocumentation	"Provide some text to fill the detail pane for a slot in a Viewer"	| aSlotName info |	aSlotName _ self slotName.	(self entryType == #systemSlot) ifTrue:			[^ ScriptingSystem helpStringFor: aSlotName].	(self entryType == #userSlot) ifTrue:		[info _ ((info _ self playerBearingCode slotInfo) includesKey: aSlotName)			ifTrue:				[info at: aSlotName]			ifFalse:				[nil].		^ info			ifNil:				['um... here would come documentation for ', aSlotName]			ifNotNil:				[info documentation]].	^ nil! !!ViewerEntry methodsFor: 'all' stamp: 'sw 1/13/1999 12:57'!slotName	"Assuming the receiver represents a slot, return its name"	^  self viewerRow elementSymbol! !!ViewerEntry methodsFor: 'all' stamp: 'sw 12/28/1998 12:50'!userSlotInformation	"If the receiver represents a user-defined slot, then return its info; if not, retun nil"	| aSlotName info |	((self entryType == #systemSlot) or: [self entryType == #userSlot])		ifFalse:			[^ nil].	aSlotName _ self slotName.	^ ((info _ self playerBearingCode slotInfo) includesKey: aSlotName)		ifTrue:			[info at: aSlotName]		ifFalse:			[nil]! !!ViewerRow methodsFor: 'all' stamp: 'sw 1/16/1999 16:16'!addDetailButton	| aButton |	Preferences useDetailPanesInViewers		ifTrue:			[aButton _ SimpleButtonMorph new				target: self;				actionSelector: #detail;				beTransparent;				setBalloonText: 'detail';				borderWidth: 0;				label: '¦']		ifFalse:			[aButton _ Morph new beTransparent; extent: 0@1].  "Place=holder in this case"	self addMorphFront: aButton! !!ViewerRow methodsFor: 'all' stamp: 'sw 2/1/1999 13:00'!elementSymbol	^ elementSymbol! !!ViewerRow methodsFor: 'all' stamp: 'sw 1/13/1999 12:47'!elementSymbol: aSymbol	elementSymbol _ aSymbol! !!ViewerRow methodsFor: 'all' stamp: 'sw 1/13/1999 12:52'!entryType	"systemSlot userSlot systemScript userScript"	^ self playerBearingCode elementTypeFor: elementSymbol! !!ViewerRow methodsFor: 'all' stamp: 'sw 12/28/1998 13:10'!playerBearingCode	^ owner playerBearingCode! !Morph removeSelector: #viewAfreshShowingScript:at:!Player removeSelector: #compileAccessorsFor:!Component class removeSelector: #compileAccessorsFor:!TabbedPalette removeSelector: #oldViewMorph:!StringReadoutTile removeSelector: #addArrows!Viewer removeSelector: #setPlayer:!StandardViewer removeSelector: #initializeFor:!StandardViewer removeSelector: #addHeaderMorph!StandardViewer removeSelector: #categoryNotCurrentlyViewing!"Postscript:"Preferences deletePreference: #showPlayerSource.Preferences deletePreference: #showScriptSource.Preferences deletePreference: #useDetailPanesInViewers.ScriptingSystem initializeHelpStrings.!