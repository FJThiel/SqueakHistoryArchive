'From Squeak2.9alpha of 12 June 2000 [latest update: #2550] on 1 September 2000 at 6:04:36 am'!"Change Set:		VRMLAnimMeshDate:			31 August 2000Author:			Andreas RaabEnable import and animation of interpolated (VRML) meshes into Wonderlands."!B3DGeometry subclass: #B3DMultiMesh	instanceVariableNames: 'meshes '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Meshes'!B3DMultiMesh subclass: #B3DInterpolatedMesh	instanceVariableNames: 'index '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Meshes'!Object subclass: #VRMLScene	instanceVariableNames: 'fileURL nodes defs protos actions sourceNodes targetNodes '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-VRML Definition'!!B3DIndexedMesh methodsFor: 'accessing' stamp: 'ar 8/31/2000 20:03'!animationParameter	^0.0! !!B3DIndexedMesh methodsFor: 'accessing' stamp: 'ar 8/31/2000 20:03'!animationParameter: param! !!B3DMultiMesh methodsFor: 'accessing' stamp: 'ar 8/31/2000 19:32'!meshes	^meshes! !!B3DMultiMesh methodsFor: 'accessing' stamp: 'ar 8/31/2000 19:32'!meshes: aCollection	meshes _ aCollection asArray! !!B3DInterpolatedMesh methodsFor: 'initialize' stamp: 'ar 8/31/2000 19:36'!initialize	index _ 1.! !!B3DInterpolatedMesh methodsFor: 'accessing' stamp: 'ar 8/31/2000 20:02'!animationParameter	^index-1 asFloat / meshes size asFloat! !!B3DInterpolatedMesh methodsFor: 'accessing' stamp: 'ar 8/31/2000 20:11'!animationParameter: param	index _ ((param \\ 1.0) * (meshes size-1)) asInteger + 1.! !!B3DInterpolatedMesh methodsFor: 'accessing' stamp: 'ar 8/31/2000 23:19'!boundingBox	| box origin corner |	box _ meshes first boundingBox.	origin _ box origin.	corner _ box corner.	2 to: meshes size do:[:i|		box _ (meshes at: i) boundingBox.		origin _ origin min: box origin.		corner _ corner max: box corner.	].	^Rectangle origin: origin corner: corner! !!B3DInterpolatedMesh methodsFor: 'displaying' stamp: 'ar 8/31/2000 19:43'!renderOn: aRenderer	^(meshes at: index) renderOn: aRenderer! !!B3DMultiMesh class methodsFor: 'instance creation' stamp: 'ar 8/31/2000 19:31'!withAll: meshList	^self new meshes: meshList! !!FloatArray methodsFor: 'comparing' stamp: 'ar 8/31/2000 21:43'!hash	| result |"WARNING: THE PRIMITIVE SEEMS TO BE BROKEN"	"<primitive:'primitiveFloatArrayHash'>"	result _ 0.	1 to: self size do:[:i| result _ result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!Number methodsFor: 'mathematical functions' stamp: 'ar 8/31/2000 20:05'!interpolateTo: aNumber at: param	^self + (aNumber - self * param)! !!VRMLScene methodsFor: 'actions' stamp: 'ar 8/31/2000 18:48'!routeFrom: fromNode event: outEventName to: toNode event: inEventName	| source target |	sourceNodes ifNil:[		sourceNodes _ IdentitySet new.		targetNodes _ IdentitySet new].	source _ self definedNode: fromNode.	target _ self definedNode: toNode.	sourceNodes add: source.	targetNodes add: target.	source		when: outEventName asSymbol		send: (self eventSelectorFor: inEventName)		to: target! !!VRMLScene methodsFor: 'accessing' stamp: 'ar 8/31/2000 18:56'!sourceNodes	^sourceNodes ifNil:[#()].! !!VRMLScene methodsFor: 'accessing' stamp: 'ar 8/31/2000 18:56'!targetNodes	^targetNodes ifNil:[#()].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 8/31/2000 19:16'!doCoordinate: node	| attr points interpolator |	(attr _ node attributeValueNamed: 'point') notNil ifTrue:[		points _ self mfVec3fFrom: attr.		(scene targetNodes includes: node) ifTrue:[			interpolator _ nil.			scene sourceNodes do:[:n|				n myEvents do:[:set|					set do:[:msg| msg receiver == node ifTrue:[interpolator _ n]]]].			interpolator _ self mfVec3fFromInterpolator: interpolator.		].	].	points == nil		ifTrue:[attributes removeKey: #currentPoints]		ifFalse:[attributes at: #currentPoints put: points].	interpolator == nil		ifTrue:[attributes removeKey: #interpolatorPoints ifAbsent:[]]		ifFalse:[attributes at: #interpolatorPoints put: interpolator].! !!VRMLWonderlandBuilder methodsFor: 'enumerating nodes' stamp: 'ar 8/31/2000 21:39'!doIndexedFaceSet: node	| attr faces points mesh ipPoints meshList map |	attributes at: #currentPoints put: nil.	(attr _ node attributeValueNamed: 'coord') notNil		ifTrue:[attr doWith: self].	points _ attributes at: #currentPoints.	ipPoints _ attributes at: #interpolatorPoints ifAbsent:[nil].	points ifNil:[^self].	(attr _ node attributeValueNamed: 'coordIndex') notNil		ifTrue:[faces _ self facesFrom: attr for: points].	faces ifNil:[^self].	mesh _ B3DSimpleMesh withAll: faces.	self assignIndexedNormals: node in: mesh.	self assignIndexedTexCoords: node in: mesh.	self assignIndexedColors: node in: mesh.	mesh _ mesh asIndexedTriangleMesh.	ipPoints == nil ifFalse:[		"Re-map points for interpolated meshes"		map _ Dictionary new: points size * 2.		points doWithIndex:[:pt :index| map at: pt put: index].		meshList _ ipPoints collect:[:pts|			mesh clone vertices: (mesh vertices collect:[:pt| pts at: (map at: pt)])].		mesh _ B3DInterpolatedMesh new initialize meshes: meshList.	].	"Try to recycle the actors"	(currentActor == nil or:[currentActor hasMesh])		ifTrue:[self createActorFor: mesh]		ifFalse:[	currentActor setMesh: mesh.				attributes at: #currentShape put: currentActor].! !!VRMLWonderlandBuilder methodsFor: 'converting' stamp: 'ar 8/31/2000 19:13'!mfVec3fFromInterpolator: node	| key value len values vv keySize |	key _ node attributeValueNamed: 'key'.	value _ node attributeValueNamed: 'keyValue'.	keySize _ key size.	values _ Array new: keySize.	len _ value size // keySize.	1 to: values size do:[:i|		vv _ B3DVector3Array new: len.		vv replaceFrom: 1 to: len with: value startingAt: (i-1 * len)+1.		values at: i put: (self mfVec3fFrom: vv).	].	^values! !!Wonderland methodsFor: 'creating' stamp: 'ar 8/31/2000 18:40'!makeActorFromVRML: filename	"Creates a new actor using the specification from the given file"	| baseActor parserClass builderClass scene |	parserClass _ Smalltalk at: #VRMLNodeParser ifAbsent:[		self reportErrorToUser:'No VRML parser found'.		^self].	builderClass _ Smalltalk at: #VRMLWonderlandBuilder ifAbsent:[		self reportErrorToUser:'No VRML to Alice converter found'.		^self].	myUndoStack closeStack.	baseActor _ self makeBaseActorFrom: filename.	parserClass == nil		ifFalse:[scene _ parserClass parseFileNamed: filename].	(builderClass == nil or:[scene == nil])		ifFalse:[(builderClass on: scene) 					baseActor: baseActor;					buildActorsFor: self].	scene _ nil.	myUndoStack openStack.	"Ensure that the new actor's name is unique"	myNamespace at: baseActor getName put: baseActor.	scriptEditor updateActorBrowser.	"Add an undo item to undo the creation of this object"	myUndoStack push: (UndoAction new: [ baseActor removeFromScene.											myNamespace removeKey: baseActor getName ifAbsent: [].											scriptEditor updateActorBrowser.  ] ).	^ baseActor.! !!Wonderland methodsFor: 'creating' stamp: 'ar 8/31/2000 17:15'!makeActorFromVRML: filename named: actorName	"Creates a new actor using the specification from the given file"	| baseActor parserClass builderClass scene |	parserClass _ Smalltalk at: #VRMLNodeParser ifAbsent:[		self reportErrorToUser:'No VRML parser found'.		^self].	builderClass _ Smalltalk at: #VRMLWonderlandBuilder ifAbsent:[		self reportErrorToUser:'No VRML to Alice converter found'.		^self].	myUndoStack closeStack.	baseActor _ self makeBaseActorFrom: filename.	baseActor setName: (self uniqueNameFrom: actorName).	parserClass == nil		ifFalse:[scene _ parserClass parseFileNamed: filename].	(builderClass == nil or:[scene == nil])		ifFalse:[(builderClass on: scene) 					baseActor: baseActor;					buildActorsFor: self].	myUndoStack openStack.	"Ensure that the new actor's name is unique"	myNamespace at: baseActor getName put: baseActor.	scriptEditor updateActorBrowser.	"Add an undo item to undo the creation of this object"	myUndoStack push: (UndoAction new: [ baseActor removeFromScene.											myNamespace removeKey: baseActor getName ifAbsent: [].											scriptEditor updateActorBrowser.  ] ).	^ baseActor.! !!WonderlandActor methodsFor: 'initialize' stamp: 'ar 9/1/2000 05:22'!initializeNoReactions	myReactions _ Dictionary new.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'ar 8/31/2000 19:59'!animateMeshTo: param	^ (self animateMeshTo: param duration: 1.0			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'ar 8/31/2000 20:01'!animateMeshTo: param duration: aDuration	^ (self animateMeshTo: param duration: aDuration style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'ar 8/31/2000 19:59'!animateMeshTo: param duration: aDuration style: aStyle	"Turns the object to point at the specified target using the specified style over the specified duration."	| anim |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyNumber: param ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what to animate to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use animating ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to animate ' , myName , ' because ', msg.			^ nil ].	"The parameters check out, so build the animation"	anim _ AbsoluteAnimation new.	anim object: self			update: [:t | self setMeshAnimationParameter: t ]			getStartState: [self getMeshAnimationParameter]			getEndState: [ param ]			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'private' stamp: 'ar 8/31/2000 20:01'!getMeshAnimationParameter	myMesh == nil ifTrue:[^0.0].	^myMesh animationParameter! !!WonderlandActor methodsFor: 'private' stamp: 'ar 8/31/2000 20:03'!setMeshAnimationParameter: param	myMesh == nil ifTrue:[^self].	myMesh animationParameter: param! !