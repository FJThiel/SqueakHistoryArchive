'From Squeak2.9alpha of 16 June 2000 [latest update: #2480] on 15 August 2000 at 12:17:14 pm'!"Change Set:		retractTiles-tkDate:			15 August 2000Author:			Ted KaehlerRedoes how all tiles in the EToy system compute their layout in the horizontal direction.  Is much simpler than before, and allows us to change the look of tiles much more easily.  *All* of the action is now in TileMorph>>fullBounds.  Fixes up existing scripts.  For a moment, the arrows will be in the wrong place in each open script.  Simply lift each line of tiles and drop it back, and it will magically correct itself.  For viewers, click to a different bank of tiles, then click back.  (Alan, If you are willing to click on each line of existing tiles in open scripts, the Flagship should be fine.)Allows 'extended tiles' for plus, minus, etc. to be 'retracted', as John Steinmetz suggested.  (The retract arrow is not added to old tiles.  All new scripts have the retract arrow.)"!RectangleMorph subclass: #TileMorph	instanceVariableNames: 'type slotName literal operatorOrExpression actualObject downArrow upArrow suffixArrow typeColor lastArrowTick nArrowTicks operatorReadoutString possessive retractArrow '	classVariableNames: 'DownPicture RetractPicture SuffixArrowAllowance SuffixPicture UpArrowAllowance UpPicture UpdatingOperators '	poolDictionaries: ''	category: 'Morphic-Scripting Tiles'!!SystemDictionary methodsFor: 'memory space' stamp: 'tk 8/14/2000 13:17'!lowSpaceThreshold	"Return the low space threshold. When the amount of free memory (after garbage collection) falls below this limit, the system is in serious danger of completely exhausting memory and crashing. This limit should be made high enough to allow the user open a debugger to diagnose a problem or to save the image."	thisContext isPseudoContext		ifTrue: [^ 1000000  "Allow for translated methods"]		ifFalse: [^ 1000000  "Enough for interpreter"]! !!TileMorph methodsFor: 'initialization' stamp: 'tk 8/14/2000 14:40'!setLiteral: anObject	| m already |	already _ submorphs detect: [:aSubMorph  | aSubMorph isKindOf: UpdatingStringMorph] ifNone: [nil].	already ifNotNil: [already delete].	type _ #literal.	m _ UpdatingStringMorph contents: ' ' font: ScriptingSystem fontForTiles.	m target: self; getSelector: #literal; putSelector: #literal:.	(anObject isKindOf: String) ifTrue: [m useStringFormat].	self addMorphBack: m.	self literal: anObject.! !!TileMorph methodsFor: 'mouse handling' stamp: 'tk 8/14/2000 22:46'!handlesMouseDown: evt	| aPoint |	aPoint _ evt cursorPoint.	upArrow ifNotNil: [((upArrow boundsInWorld containsPoint: aPoint) or: [downArrow boundsInWorld containsPoint: aPoint])		ifTrue: [^ true]].	suffixArrow ifNotNil: [(suffixArrow boundsInWorld containsPoint: aPoint)		ifTrue: [^ true]].	retractArrow ifNotNil: [(retractArrow boundsInWorld containsPoint: aPoint)		ifTrue: [^ true]].	^ super handlesMouseDown: evt! !!TileMorph methodsFor: 'mouse handling' stamp: 'tk 8/14/2000 22:40'!mouseDown: evt	| aPoint |	aPoint _ evt cursorPoint.	nArrowTicks _ 0.	upArrow ifNotNil:		[(upArrow boundsInWorld containsPoint: aPoint) ifTrue: [^ self].		(downArrow boundsInWorld containsPoint: aPoint) ifTrue: [^ self]].	suffixArrow ifNotNil:		[(suffixArrow boundsInWorld containsPoint: aPoint)			 ifTrue: [self showSuffixChoices.  ^ self]].	retractArrow ifNotNil:		[(retractArrow boundsInWorld containsPoint: aPoint)			 ifTrue: [self deleteLastTwoTiles.  ^ self]].	^ super mouseDown: evt! !!TileMorph methodsFor: 'mouse handling' stamp: 'tk 8/14/2000 23:09'!mouseMove: evt	| aPoint label |	"See if arrows are being pressed and call arrowAction:..."	upArrow ifNotNil:		[aPoint _ evt cursorPoint.		(label _ self labelMorph) ifNotNil:			[label step. literal _ label valueFromContents].		(upArrow containsPoint: aPoint) ifTrue:			[self abandonLabelFocus.			self variableDelay:				[self arrowAction: 1].			^ evt hand noteSignificantEvent: evt].		(downArrow containsPoint: aPoint) ifTrue:			[self abandonLabelFocus.			self variableDelay:				[self arrowAction: -1].			^ evt hand noteSignificantEvent: evt]].	super mouseMove: evt.! !!TileMorph methodsFor: 'arrows' stamp: 'tk 8/14/2000 14:20'!addArrows	downArrow _ ImageMorph new image: DownPicture.	upArrow _ ImageMorph new image: UpPicture.	upArrow position: bounds topLeft + (2@2).	downArrow align: downArrow bottomLeft				with: bounds topLeft + (0 @ TileMorph defaultH) + (2@-2).	self addMorphFront: upArrow.	self addMorphFront: downArrow.! !!TileMorph methodsFor: 'arrows' stamp: 'tk 8/10/2000 14:45'!addSuffixArrow	| retract |	retract _ ImageMorph new image: RetractPicture.	retract align: retract topLeft with:		bounds topRight + (-2@(self height//2)) - (0@(retract height//2))."	(phrase _ self ownerThatIsA: PhraseTileMorph) ifNotNil: [		(phrase ownerThatIsA: TilePadMorph) ifNotNil: ["  "could be retracted""Want to make that test, but not in tree yet, so can't make it!!!!"	retractArrow _ retract.	self addMorphBack: retractArrow.		suffixArrow _ ImageMorph new image: SuffixPicture.	self addMorphBack: suffixArrow.	suffixArrow align: suffixArrow topLeft with:		retract topRight + (-4@0).	self extent: self fullBounds extent! !!TileMorph methodsFor: 'arrows' stamp: 'tk 8/10/2000 12:54'!deleteLastTwoTiles	"Remove the current suffix (last two tiles) in this line of tiles"	| phrase pad goodPad |	(phrase _ self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	(pad _ phrase ownerThatIsA: TilePadMorph) ifNil: [^ self].	goodPad _ phrase firstSubmorph.	goodPad type == pad type ifFalse: [^ self].	pad owner addMorphBack: goodPad.	pad delete.	goodPad lastSubmorph addSuffixArrow.! !!TileMorph methodsFor: 'arrows' stamp: 'tk 8/10/2000 14:34'!deleteSuffixArrow	suffixArrow delete.	suffixArrow _ nil.	retractArrow ifNotNil: ["backward compat"		retractArrow delete.		retractArrow _ nil].	self updateLiteralLabel! !!TileMorph methodsFor: 'private' stamp: 'tk 8/14/2000 22:31'!fullBounds	| pos hh |	"Set the position of all my submorphs.  Compute my bounds.  Caller must call layoutChanged or set fullBounds to nil."	fullBounds ifNil: [		pos _ self topLeft copy + (2@0).		self submorphsDo: [:sub | 			hh _ nil.			sub == upArrow ifTrue: [				hh _ 2.				sub privateBounds: (pos + (0@hh) extent: sub extent).				pos _ sub right + 2 @ pos y.		"2 pixels spacing on right"				].			sub == downArrow ifTrue: [				hh _ -10.	"flag"				sub align: sub topLeft					with: pos + (0 @ (upArrow height+3)).				"do not change pos, so align vertically"				].			hh ifNil: ["normal case"				hh _ (self class defaultH - sub height) // 2.	"center in Y"				sub privateBounds: (pos + (0@hh) extent: sub extent).				pos _ sub right + 2 @ pos y.		"2 pixels spacing on right"				]].		bounds _ bounds topLeft corner: pos + (0 @ self class defaultH).		fullBounds _ bounds.		].	"super fullBounds."	owner class == TilePadMorph ifTrue: [owner bounds: bounds].	^ fullBounds! !!TileMorph methodsFor: 'private' stamp: 'tk 8/14/2000 13:32'!test	| pos hh |	"Set the position of all my submorphs.  Compute my bounds.  Caller must call layoutChanged or set fullBounds to nil."	fullBounds ifNil: [		pos _ self topLeft.		self submorphsDo: [:sub | 			hh _ (self class defaultH - sub height) // 2.	"center in Y"			sub privateBounds: (pos + (2@hh) extent: sub extent).			pos x: (sub right min: 1200)].	"2 pixels spacing on left"		bounds _ bounds topLeft corner: pos + (2 @ self class defaultH).		fullBounds _ bounds.		].	owner class == TilePadMorph ifTrue: [owner bounds: bounds].	^ fullBounds! !!TileMorph methodsFor: 'private' stamp: 'tk 8/14/2000 23:14'!updateLiteralLabel	| myLabel |	(myLabel _ self labelMorph) ifNil: [^ self].	myLabel acceptValue:		(type == #literal			ifTrue:				[literal] 			ifFalse: [operatorReadoutString 				ifNil:		[ScriptingSystem wordingForOperator: operatorOrExpression]				ifNotNil:  	[operatorReadoutString]]).	self changed.! !!TileMorph methodsFor: 'object fileIn' stamp: 'tk 8/10/2000 14:18'!convertbosfcebbtsloadustlnop0: varDict bosfcebbtsloadustlnopr0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'type' 'slotName' 'literal' 'operatorOrExpression' 'actualObject' 'downArrow' 'upArrow' 'suffixArrow' 'typeColor' 'lastArrowTick' 'nArrowTicks' 'operatorReadoutString' 'possessive').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('retractArrow')  If a non-nil value is needed, please assign it."! !!TileMorph methodsFor: 'copying' stamp: 'tk 8/10/2000 14:29'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.type _ type veryDeepCopyWith: deepCopier.slotName _ slotName veryDeepCopyWith: deepCopier.literal _ literal veryDeepCopyWith: deepCopier.operatorOrExpression _ operatorOrExpression veryDeepCopyWith: deepCopier."actualObject _ actualObject.		Weakly copied"downArrow _ downArrow veryDeepCopyWith: deepCopier.upArrow _ upArrow veryDeepCopyWith: deepCopier.suffixArrow _ suffixArrow veryDeepCopyWith: deepCopier.typeColor _ typeColor veryDeepCopyWith: deepCopier.lastArrowTick _ lastArrowTick veryDeepCopyWith: deepCopier.nArrowTicks _ nArrowTicks veryDeepCopyWith: deepCopier.operatorReadoutString _ operatorReadoutString veryDeepCopyWith: deepCopier.possessive _ possessive veryDeepCopyWith: deepCopier.retractArrow _ retractArrow veryDeepCopyWith: deepCopier.! !!MenuTile methodsFor: 'as yet unclassified' stamp: 'tk 8/14/2000 22:41'!initialize	super initialize.	self addArrows; setLiteral: 'send to back'.	self labelMorph useStringFormat! !!NumericReadoutTile methodsFor: 'mouse' stamp: 'tk 8/14/2000 23:08'!mouseMove: evt	"Copied from TileMorph mouseMove to use literal:width: rather than literal:."	| p label |	upArrow ifNotNil:		[p _ evt cursorPoint.		self abandonLabelFocus.		label _ self findA: UpdatingStringMorph.		label ifNotNil:			[label step. literal _ label valueFromContents].		(upArrow containsPoint: p)			ifTrue: [self variableDelay:						[self literal: (self numericValue + 1)].					^ evt hand noteSignificantEvent: evt].		(downArrow containsPoint: p)			ifTrue: [self variableDelay:						[self literal: (self numericValue - 1)].					^ evt hand noteSignificantEvent: evt]].	super mouseMove: evt.! !!RandomNumberTile methodsFor: 'value & label' stamp: 'tk 8/14/2000 23:23'!updateLiteralLabel	| myReadout |	(myReadout _ self labelMorph) ifNil: [^ self].	myReadout contents: literal stringForReadout.! !!SoundTile methodsFor: 'initialization' stamp: 'tk 8/14/2000 22:37'!initialize	super initialize.	self addArrows; setLiteral: 'croak'.	self labelMorph useStringFormat! !!TileMorph class methodsFor: 'class initialization' stamp: 'tk 8/15/2000 11:00'!initialize	"TileMorph readInArrowGraphics    -- call manually if necessary to bring graphics forward"	"TileMorph initialize"	UpdatingOperators _ Dictionary new.	UpdatingOperators at: #incr: put: #+.	UpdatingOperators at: #decr: put: #-.	UpdatingOperators at: #set: put: ''.	RetractPicture ifNil: [		RetractPicture _ (SuffixPicture flipBy: #horizontal centerAt: (SuffixPicture center))].	SuffixArrowAllowance _ 5 + SuffixPicture width + RetractPicture width.	UpArrowAllowance _ 10.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'tk 8/14/2000 23:12'!fitContents	| scanner newExtent |	scanner _ DisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.	newExtent _ (((scanner stringWidth: contents) max: self minimumWidth) min: self maximumWidth)  @ scanner lineHeight.	(self extent = newExtent) ifFalse:		[self extent: newExtent.		self changed]! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'tk 8/14/2000 23:11'!acceptValue: aValue	self updateContentsFrom: (self acceptValueFromTarget: aValue).! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'tk 8/14/2000 23:13'!informTarget	| newValue |	((target ~~ nil) and: [putSelector ~~ nil]) ifTrue:		[newValue _ self valueFromContents.		newValue ifNotNil:			[target scriptPerformer perform: putSelector with: newValue.			target isMorph ifTrue: [target changed]].			self fitContents.			"self growable ifTrue:				[self readFromTarget; fitContents.				owner ifNotNil:  [owner updateLiteralLabel]]"]! !TileMorph initialize!RandomNumberTile removeSelector: #resizeToFitLabel!TileMorph removeSelector: #resizeToFitLabel!"Postscript:Shift the arrows around to the right order in a TileMorph."| upInd dnInd suffInd upArrow downArrow suffixArrow coll |upInd _ (TileMorph allInstVarNames) indexOf: 'upArrow'.dnInd _ (TileMorph allInstVarNames) indexOf: 'downArrow'.suffInd _ (TileMorph allInstVarNames) indexOf: 'suffixArrow'.TileMorph allSubInstancesDo: [:tm | 	coll _ tm submorphs asOrderedCollection.	upArrow _ tm instVarAt: upInd.	upArrow ifNotNil: [		coll remove: upArrow.		coll addFirst: upArrow.		tm privateSubmorphs: coll asArray].	downArrow _ tm instVarAt: dnInd.	downArrow ifNotNil: [		coll remove: downArrow.		coll addFirst: downArrow.		tm privateSubmorphs: coll asArray.		downArrow left: upArrow left].	suffixArrow _ tm instVarAt: suffInd.	suffixArrow ifNotNil: [		coll remove: suffixArrow.		coll addLast: suffixArrow.		tm privateSubmorphs: coll asArray].	tm privateFullBounds: nil].!