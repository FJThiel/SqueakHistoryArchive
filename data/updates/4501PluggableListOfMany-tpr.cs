'From Squeak3.2alpha of 7 October 2001 [latest update: #4474] on 10 November 2001 at 10:55:41 pm'!"Change Set:		PluggableListOfManyFixesDate:			8 October 2001Author:			tim@sumeru.stanford.eduA simple extension to the Pluggable List{Morph|View}OfMany classes to make the set/get of the list of selections pluggable. This allows multiple multilple-selection-lists on the same model without ugly interactions. (Also improved the balloon help for 'recently logged changes...' while in the vicinity. -dew)"!PluggableListMorph subclass: #PluggableListMorphOfMany	instanceVariableNames: 'dragOnOrOff getSelectionListSelector setSelectionListSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!PluggableListView subclass: #PluggableListViewOfMany	instanceVariableNames: 'selections getSelectionListSelector setSelectionListSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!!ChangeList methodsFor: 'initialization-release' stamp: 'tpr 10/4/2001 21:58'!openAsMorphName: labelString multiSelect: multiSelect 	"Open a morphic view for the messageSet, whose label is labelString. 	The listView may be either single or multiple selection type"	| window listHeight listPane |	listHeight _ 0.4.	window _ (SystemWindow labelled: labelString)				model: self.	listPane _ multiSelect				ifTrue: [PluggableListMorphOfMany						on: self						list: #list						primarySelection: #listIndex						changePrimarySelection: #toggleListIndex:						listSelection: #listSelectionAt:						changeListSelection: #listSelectionAt:put:						menu: (self showsVersions								ifTrue: [#versionsMenu:]								ifFalse: [#changeListMenu:])]				ifFalse: [PluggableListMorph						on: self						list: #list						selected: #listIndex						changeSelected: #toggleListIndex:						menu: (self showsVersions								ifTrue: [#versionsMenu:]								ifFalse: [#changeListMenu:])].	listPane keystrokeActionSelector: #changeListKey:from:.	window		addMorph: listPane		frame: (0 @ 0 extent: 1 @ listHeight).	self		addLowerPanesTo: window		at: (0 @ listHeight corner: 1 @ 1)		with: nil.	^ window openInWorld! !!ChangeList class methodsFor: 'instance creation' stamp: 'tpr 10/8/2001 21:02'!open: aChangeList name: aString multiSelect: multiSelect	"Create a standard system view for the messageSet, whose label is aString.	The listView may be either single or multiple selection type"	| topView listHeight annoHeight optButtonHeight codeHeight aListView underPane annotationPane buttonsView aBrowserCodeView |	Smalltalk isMorphic		ifTrue: [^ self openAsMorph: aChangeList name: aString multiSelect: multiSelect].	listHeight _ 70.	annoHeight _ 10.	optButtonHeight _ aChangeList optionalButtonHeight.	codeHeight _ 110.	topView _ (StandardSystemView new)		model: aChangeList;		label: aString;		minimumSize: 200 @ 120;		borderWidth: 1.	aListView _ (multiSelect			ifTrue: [PluggableListViewOfMany						on: aChangeList						list: #list						primarySelection: #listIndex						changePrimarySelection: #toggleListIndex:						listSelection: #listSelectionAt:						changeListSelection: #listSelectionAt:put:						menu: (aChangeList showsVersions								ifTrue: [#versionsMenu:]								ifFalse: [#changeListMenu:])]			ifFalse: [PluggableListView						on: aChangeList						list: #list						selected: #listIndex						changeSelected: #toggleListIndex:						menu: (aChangeList showsVersions								ifTrue: [#versionsMenu:]								ifFalse: [#changeListMenu:])]).	aListView window: (0 @ 0 extent: 200 @ listHeight).	topView addSubView: aListView.	underPane _ aListView.	aChangeList wantsAnnotationPane		ifTrue:			[annotationPane _ PluggableTextView				on: aChangeList				text: #annotation				accept: nil				readSelection: nil				menu: nil.			annotationPane window: (0 @ 0 extent: 200 @ 10).			topView addSubView: annotationPane below: underPane.			underPane _ annotationPane.			codeHeight _ codeHeight - annoHeight].	aChangeList wantsOptionalButtons		ifTrue:			[buttonsView _ aChangeList optionalButtonsView.			buttonsView borderWidth: 1.			topView addSubView: buttonsView below: underPane.			underPane _ buttonsView.			codeHeight _ codeHeight - optButtonHeight].	aBrowserCodeView _ PluggableTextView			on: aChangeList			text: #contents			accept: #contents:			readSelection: #contentsSelection			menu: #codePaneMenu:shifted:.	aBrowserCodeView			controller: ReadOnlyTextController new;			window: (0 @ 0 extent: 200 @ codeHeight).	topView addSubView: aBrowserCodeView below: underPane.	topView controller open.! !!PluggableListControllerOfMany methodsFor: 'control defaults' stamp: 'tpr 10/4/2001 22:19'!redButtonActivity	| selection firstHit turningOn lastSelection pt scrollFlag |	model okToChange ifFalse: [^ self].		"Don't change selection if model refuses to unlock"	firstHit _ true.	scrollFlag _ false.	lastSelection _ 0.	[sensor redButtonPressed] whileTrue: 		[selection _ view findSelection: (pt _ sensor cursorPoint).		selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"			[pt y < view insetDisplayBox top ifTrue:				[self scrollView: view list lineGrid.				scrollFlag _ true.				selection _ view firstShown].			pt y > view insetDisplayBox bottom ifTrue:				[self scrollView: view list lineGrid negated.				scrollFlag _ true.				selection _ view lastShown]].		(selection == nil or: [selection = lastSelection]) ifFalse: 			[firstHit ifTrue:				[firstHit _ false.				turningOn _ (view listSelectionAt: selection) not].			view selection: selection.			(view listSelectionAt: selection) == turningOn ifFalse:				[view displaySelectionBox.				view listSelectionAt: selection put: turningOn].			lastSelection _ selection]].	selection notNil ifTrue:		["Normal protocol delivers change, so unchange first (ugh)"		view listSelectionAt: selection put: (view listSelectionAt: selection) not.		self changeModelSelection: selection].	scrollFlag ifTrue: [self moveMarker]! !!PluggableListMorphOfMany methodsFor: 'initialization' stamp: 'tpr 10/4/2001 21:24'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel	"setup a whole load of pluggability options"	getSelectionListSelector _ getListSel.	setSelectionListSelector _ setListSel.	super on: anObject list: listSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel! !!PluggableListMorphOfMany methodsFor: 'drawing' stamp: 'tpr 10/4/2001 21:31'!drawOn: aCanvas	| onMorph |	super drawOn: aCanvas.	1 to: list size do:  "NOTE: should be optimized to only visible morphs"		[:index |		(self listSelectionAt: index) ifTrue:			[onMorph _ scroller submorphs at: index.			aCanvas fillRectangle:				(((scroller transformFrom: self) localBoundsToGlobal: onMorph bounds)						intersect: scroller bounds)				color: color darker]]! !!PluggableListMorphOfMany methodsFor: 'drawing' stamp: 'tpr 10/4/2001 21:26'!listSelectionAt: index	getSelectionListSelector ifNil:[^false].	^model perform: getSelectionListSelector with: index! !!PluggableListMorphOfMany methodsFor: 'drawing' stamp: 'tpr 10/4/2001 21:27'!listSelectionAt: index put: value	setSelectionListSelector ifNil:[^false].	^model perform: setSelectionListSelector with: index with: value! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'tpr 10/4/2001 21:33'!mouseDown: event	| index oldIndex oldVal aMorph |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	aMorph _ self itemFromPoint: event position.	aMorph ifNil:[^super mouseDown: event].	model okToChange ifFalse: [^ self].  "No change if model is locked"	index _ scroller submorphs indexOf: aMorph.	index = 0 ifTrue: [^ self  "minimize chance of selecting with a pane border drag"].	"Set meaning for subsequent dragging of selection"	dragOnOrOff _ (self listSelectionAt: index) not.	oldIndex _ self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff		ifTrue: [self setSelectedMorph: aMorph]		ifFalse: [self setSelectedMorph: nil].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].	self listSelectionAt: index put: dragOnOrOff.	event hand releaseMouseFocus: aMorph.	aMorph changed! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'tpr 10/4/2001 21:33'!mouseMove: event	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| index oldIndex oldVal aMorph |	event position y < self top		ifTrue:			[scrollBar scrollUp: 1.			aMorph _ self itemFromPoint: scroller topLeft + (1@1)]		ifFalse:			[event position y > self bottom				ifTrue:					[scrollBar scrollDown: 1.					aMorph _ self itemFromPoint: scroller bottomLeft + (1@-1)]				ifFalse:					[aMorph _ self itemFromPoint: event position]].	aMorph ifNil: [^ super mouseDown: event].	model okToChange ifFalse: [^ self].  "No change if model is locked"	index _ scroller submorphs indexOf: aMorph.	index = 0 ifTrue: [^ self  "minimize chance of selecting with a pane border drag"].	dragOnOrOff ifNil:  "Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"		[dragOnOrOff _ (self listSelectionAt: index) not].	"Set meaning for subsequent dragging of selection"	oldIndex _ self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff		ifTrue: [self setSelectedMorph: aMorph]		ifFalse: [self setSelectedMorph: nil].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].	self listSelectionAt: index put: (dragOnOrOff == true).	aMorph changed! !!PluggableListMorphOfMany class methodsFor: 'instance creation' stamp: 'tpr 10/4/2001 21:54'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!PluggableListMorphOfMany class methodsFor: 'instance creation' stamp: 'tpr 10/4/2001 21:52'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel 	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: keyActionSel! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tpr 10/4/2001 21:34'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	selection _ 0.	1 to: self maximumSelection do:		[:i | selection _ i.		(self listSelectionAt: i) ifTrue: [self deEmphasizeSelectionBox]].	selection _ 0! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tpr 10/4/2001 21:34'!highlightFrom: start to: stop	(start == nil or: [stop == nil]) ifTrue: [^ self displayView].	start to: stop do:		[:i | selection _ i.		(self listSelectionAt: selection) ifTrue: [self displaySelectionBox]].	selection _ 0! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tpr 10/4/2001 22:17'!listSelectionAt: index	getSelectionListSelector ifNil:[^false].	^model perform: getSelectionListSelector with: index! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tpr 10/4/2001 22:17'!listSelectionAt: index put: value	setSelectionListSelector ifNil:[^false].	^model perform: setSelectionListSelector with: index with: value! !!PluggableListViewOfMany methodsFor: 'initialization' stamp: 'tpr 10/8/2001 20:53'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel	"setup a whole load of pluggability options"	getSelectionListSelector _ getListSel.	setSelectionListSelector _ setListSel.	super on: anObject list: listSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel! !!PluggableListViewOfMany class methodsFor: 'instance creation' stamp: 'tpr 10/8/2001 20:53'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!PluggableListViewOfMany class methodsFor: 'instance creation' stamp: 'tpr 10/8/2001 20:52'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel 	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: keyActionSel! !!TheWorldMenu methodsFor: 'construction' stamp: 'dew 11/10/2001 22:54'!changesMenu        "Build the changes menu for the world."        | menu |        menu _ self menu: 'changes...'.        self fillIn: menu from: {                { 'file out current change set' . { Utilities . #fileOutChanges}.                                'Write the current change set out to a file whose name reflects the change set name and the current date & time.'}.                { 'create new change set...' . { ChangeSorter . #newChangeSet}. 'Create a new change set and make it the current one.'}.                { 'browse changed methods' . { Smalltalk . #browseChangedMessages}.  'Open a message-list browser showing all methods in the current change set'}.                { 'check change set for slips' . { Smalltalk changes . #lookForSlips}.                                'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'}.                nil.                { 'simple change sorter' . {self. #openChangeSorter1}.  'Open a 3-paned changed-set viewing tool'}.                { 'dual change sorter' . {self. #openChangeSorter2}.                                'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'}.               { 'find a change sorter (C)' . { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.                nil.                { 'browse recent submissions' . { Utilities . #browseRecentSubmissions}.                                'Open a new recent-submissions browser.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'}.                { 'find recent submissions (R)' . { #myWorld . #openRecentSubmissionsBrowser:}.                                'Make an open recent-submissions browser be the front-window, expanding a collapsed one or creating a new one if necessary.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted, latest first.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions at the top of the browser.'}.			nil.                { 'recently logged changes...' . { ChangeList . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'}.                { 'recent log file...' . { Smalltalk . #writeRecentToFile}.                                'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.'}.                nil.                { 'save world as morph file' . {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.'}.                nil.        }.        self projectForMyWorld isIsolated ifTrue: [                self fillIn: menu from: {                         { 'propagate changes upward' . {self. #propagateChanges}.                                'The changes made in this isolated project will propagate to projects up to the next isolation layer.'}.                }.        ] ifFalse: [                self fillIn: menu from: {                         { 'isolate changes of this project' . {self. #beIsolated}.                                'Isolate this project and its subprojects from the rest of the system.  Changes to methods here will be revoked when you leave this project.'}.                }.        ].        ^ menu! !PluggableListView subclass: #PluggableListViewOfMany	instanceVariableNames: 'getSelectionListSelector setSelectionListSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Pluggable Views'!