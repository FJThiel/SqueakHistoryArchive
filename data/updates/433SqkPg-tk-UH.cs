'From Squeak 2.2 of Sept 23, 1998 on 20 November 1998 at 1:41:27 pm'!Object subclass: #SqueakPage	instanceVariableNames: 'url title comment thumbnail contentsMorph creationTime creationAuthor lastChangeTime lastChangeAuthor policy dirty '	classVariableNames: 'MaxThumbnailWidthOrHeight RecentMaxNum RecentStem '	poolDictionaries: ''	category: 'Morphic-WebBooks'!!FileUrl methodsFor: 'access' stamp: 'tk 11/20/1998 13:19'!pathForDirectory	"Path using local file system's delimiter.  $\ or $:"	| first pp |	^String streamContents: [ :s |		first _ true.		1 to: self path size - 1 do: [ :ii |			pp _ path at: ii.			first ifFalse: [ s nextPut: FileDirectory default pathNameDelimiter ].			first _ false.			s nextPutAll: pp ] ]! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/20/1998 11:47'!saveOnURL: suggestedUrlString	"Save myself on a SmartReferenceStream file.  If I don't already have a url, use the suggested one.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg _ self valueOfProperty: #SqueakPage) ifNil: [pg _ SqueakPage new]		ifNotNil: [pg contentsMorph ~~ self ifTrue: [				self inform: 'morph''s SqueakPage property is out of date'.				pg _ SqueakPage new]].	(url _ pg url) ifNil: [url _ pg urlNoOverwrite: suggestedUrlString].	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol _ pg policy) ifNil: [pol _ #neverWrite].	pg policy: #now; dirty: true.  pg write.	"force the write"	pg policy: pol.	^ pg! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/20/1998 10:27'!saveOnURLbasic	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg _ self valueOfProperty: #SqueakPage) ifNil: [pg _ SqueakPage new]		ifNotNil: [pg contentsMorph ~~ self ifTrue: [				self inform: 'morph''s SqueakPage property is out of date'.				pg _ SqueakPage new]].	(url _ pg url) ifNil: [		url _ 'ftp://server/books/myBook/page1.sp'.	"do better?"		url _ FillInTheBlank 				request: 'url of a place to store this object.Must begin with file:// or ftp://' 				initialAnswer: url.		url size == 0 ifTrue: [^ self beep]].	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol _ pg policy) ifNil: [pol _ #neverWrite].	pg policy: #now; dirty: true.  pg write.	"force the write"	pg policy: pol.	^ pg! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:16'!forgetURLs	"About to save these objects in a new place.  Forget where stored now.  Must bring in all pages we don't have."| pg |pages do: [:aPage |	aPage yourself.	"bring it into memory"	(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [		SqueakPageCache removeURL: pg url.		pg contentsMorph setProperty: #SqueakPage toValue: nil]].! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:24'!getStemUrl	"Try to find the old place where this book was stored.  Confirm with the user.  Else ask for new place."| initial pg url ll |initial _ ''.(pg _ currentPage valueOfProperty: #SqueakPage) ifNotNil: [	pg contentsMorph == currentPage ifTrue: [		initial _ pg url]].	"If this page has a url"pages doWithIndex: [:aPage :ind |	initial size = 0 ifTrue: [		aPage isInMemory ifTrue: [			(pg _ aPage valueOfProperty: #SqueakPage) ifNotNil: [				initial _ pg url]]]].	"any page with a url"initial size = 0 ifTrue: [initial _ 'ftp://server/books/myBook/page1.sp'].url _ FillInTheBlank 		request: 'url of the place to store a typical page in this book.Must begin with file:// or ftp://' 		initialAnswer: initial.ll _ url findLast: [:char | char == $.].ll = 0 ifFalse: [url _ url copyFrom: 1 to: ll-1].	"remove .sp"^ (url splitInteger) at: 1		"remove trailing number"! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:22'!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| pg stem |stem _ self getStemUrl.	"user must approve"stem size = 0 ifTrue: [^ self].pages doWithIndex: [:aPage :ind | 	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		pg _ aPage saveOnURL: stem,(ind printString),'.sp'.		]].pages do: [:aPage |	"does write the current page too"	(aPage isInMemory and: [(currentPage == aPage) not]) ifTrue: [		pg _ aPage valueOfProperty: #SqueakPage.		pg purge]].	"recover the space"! !!BookMorph methodsFor: 'menu' stamp: 'tk 11/20/1998 10:17'!savePagesOnURL	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are already totally out will stay that way."	| response curr pg |	response _ (PopUpMenu labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)' withCRs)			startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' withCRs.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].curr _ currentPage.pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		self goToPageMorph: aPage.		aPage saveOnURLbasic.	"ask user if no url"		]].self goToPageMorph: curr.pages do: [:aPage |	"does write the current page too"	(aPage isInMemory and: [(curr == aPage) not]) ifTrue: [		pg _ aPage valueOfProperty: #SqueakPage.		pg purge]].	"recover the space"! !!ObjectOut commentStamp: 'tk 11/12/1998 16:43' prior: 0!I am a stand-in for an object that is out on the disk.  The object that is out on the disk is the head of a tree of objects that are out.  See SqueakPage.When any message is sent to me, I don't understand it, and bring in my true object.  I become myself with the objects and resend the message.  I may not represent the object nil.  The file is represented as a url, and that url may point at any file on the net.  page is a SqueakPage.If the cache already has an object, widely in use, that claims to be the object for my url, what do I do?  I can't become him, since others believe that he is the true object.  Run through memory and replace refs to me with refs to him.  Be careful not to trigger a fault.  Become me to a string, then find pointers and replace?[[[They don't want to end up holding an ObjectOut.  (would oscillate back and forth)  This is a problem.  A user could bring in two trees that both refer to a 3rd url.  (check with cache before installing any new ObjectOut) Two trees could be written to the same url.Or, I remain an ObjectOut, and keep getting notUnderstood, and keep returning the other guy.Or I smash the cache, and install MY page and object.  Other guy is a copy -- still in, but with no place in the cache.  When we both write to the same url, there will be trouble.]  No -- search and replace.]]]Note that my selectors and all my subclasses' selectors are not searched in Senders and Implementors.  Remember that!!!!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/20/1998 12:20'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| returnValue realObject |	recursionFlag == true ifTrue: [		true confirm: 'Object being fetched for a second time.This is an error that needs to be fixed.Do it anyway to recover the data?' orCancel: [		^ aMessage error: 'Recursive not understood error in ObjectOut']].		"We are not an object yet.  There is a problem in the fetching code."	recursionFlag _ true.	"fetch the object"	realObject _ self xxxFetch.		"watch out for the become!!"			"Now we ARE the realObject"	returnValue _ aMessage sentTo: realObject.	^ returnValue! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/16/1998 09:57'!xxxFetch	"Bring in my object and replace all references to me with references to him.  First try looking up my url in the pageCache.  Then try the page (and install it, under its url).  Then start from scratch with the url."	| truePage object existing |	existing _ SqueakPageCache pageCache at: url ifAbsent: [nil].	existing ifNotNil: [existing isContentsInMemory		ifTrue: [page _ truePage _ existing]].	"This url already has an object in this image"	truePage ifNil: [		truePage _ SqueakPageCache atURL: url oldPage: page].	object _ truePage isContentsInMemory 		ifTrue: [truePage contentsMorph]		ifFalse: [truePage fetchInformIfError].	"contents, not the page"			"Later, collect pointers to object and fix them up.  Not scan memory"	object ifNil: [^ 'Object could not be fetched.'].	"recursionFlag _ false."  	"while I still have a pointer to myself"	truePage contentsMorph: object.	page _ truePage.	self xxxFixup.	^ object	"the final object!!" ! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/15/1998 19:59'!xxxFixup	"There is already an object in memory for my url.  All pointers to me need to be pointers to him.  Can't use become, because other pointers to him must stay valid."	| real temp list |	real _ page contentsMorph.	real == self ifTrue: [page error: 'should be converted by now'].	temp _ self.	list _ (Smalltalk pointersTo: temp) asOrderedCollection.	list add: thisContext.  list add: thisContext sender.	list do: [:holder |		1 to: holder class instSize do:			[:i | (holder instVarAt: i) == temp ifTrue: [holder instVarAt: i put: real]].		1 to: holder basicSize do:			[:i | (holder basicAt: i) == temp ifTrue: [holder basicAt: i put: real]].		].	^ real! !!ObjectOut methodsFor: 'access' stamp: 'tk 11/11/1998 11:11'!xxxUrl	^ url! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/15/1998 18:11'!become: otherObject 	"Primitive. Swap the object pointers of the receiver and the argument.	All variables in the entire system that used to point to the 	receiver now point to the argument, and vice-versa.	Fails if either object is a SmallInteger"	(Array with: self)		elementsExchangeIdentityWith:			(Array with: otherObject)! !!ObjectOut methodsFor: 'basics' stamp: 'tk 11/20/1998 10:45'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override."	<primitive: 75>	self primitiveFailed! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 11/20/1998 12:20'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| returnValue aMorph myUrl |	recursionFlag == true ifTrue: [		true confirm: 'Object being fetched for a second time.This is an error that needs to be fixed.Do it anyway to recover the data?' orCancel: [		^ aMessage error: 'Recursive not understood error in ObjectOut']].		"We are not an object yet.  There is a problem in the fetching code."	recursionFlag _ true.	myUrl _ url.	"can't use inst vars after become"	"fetch the object"	aMorph _ self xxxFetch.		"watch out for the become!!"			"Now we ARE a MORPH"	returnValue _ aMessage sentTo: aMorph.		"self == aMorph"	aMorph setProperty: #SqueakPage toValue: 			(SqueakPageCache pageCache at: myUrl).	^ returnValue! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 11/20/1998 13:10'!directory	"urlObject ifNotNil: [^ urlObject directory].  Fix this"	^ directory! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 11/20/1998 13:21'!entries	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name> <creationTime> <modificationTime> <dirFlag> <fileSize>)."	| ftpEntries thisYear tokens dateInSeconds longy |	"We start with ftp directory entries of the form...d---------   1 owner    group               0 Apr 27 22:01 blasttest----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM    1        2   3           4                 5    6  7    8       9   -- token index"	type == #file ifTrue: [		urlObject isAbsolute ifFalse: [urlObject default].		^ (FileDirectory on: urlObject pathForDirectory) entries].	ftpEntries _ self getDirectory contentsOfEntireFile findTokens: FTPSocket crLf.	thisYear _ Date today year.	^ ftpEntries collect:		[:ftpEntry | tokens _ ftpEntry findTokens: ' '.		tokens size >= 9		ifTrue:		[tokens size > 9 ifTrue:			[longy _ tokens at: 9.			10 to: tokens size do: [:i | longy _ longy , ' ' , (tokens at: i)].			tokens at: 9 put: longy].		dateInSeconds _ ((tokens at: 8) includes: $:)			ifTrue: ["Date has no year -- assume this year"					(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: thisYear) asSeconds +					(Time readFrom: (ReadStream on: (tokens at: 8))) asSeconds]			ifFalse: [(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: (tokens at: 8) asNumber) asSeconds].		DirectoryEntry name: (tokens at: 9)  "file name"			creationTime: dateInSeconds "creation date"			modificationTime: dateInSeconds "modification time"			isDirectory: tokens first first = $d "is-a-directory flag"			fileSize: tokens fifth asNumber "file size"]		ifFalse:		[nil]]		thenSelect: [:entry | entry notNil]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 11/20/1998 12:28'!fileAndDirectoryNames	"FileDirectory default fileAndDirectoryNames"	^ self entries collect: [:entry | entry first]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 11/20/1998 12:28'!includesKey: localName	"Answer true if this directory includes a file or directory of the given name. Note that the name should be a local file name, in contrast with fileExists:, which takes either local or full-qualified file names."	^ self fileAndDirectoryNames includes: localName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 11/20/1998 13:10'!fileName	urlObject ifNotNil: [^ urlObject path last].	^ fileName! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 11/11/1998 12:54'!contentsMorph: aPasteUpMorph	contentsMorph _ aPasteUpMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 11/20/1998 10:47'!fetchInformIfError	"Make every effort to get contentsMorph.  Put up a good notice if can't get it.  Assume page is in the cache already.  Overwrite the contentsMorph no matter what."	| strm page temp temp2 |	SqueakPageCache write.		"sorry about the pause"	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	"<<<<< Note Diff"		page _ strm fileInObjectAndCode.	page isMorph ifTrue: [contentsMorph _ page].	"may be a bare morph"	"copy over the state"	temp _ url.	temp2 _ policy.	self copyAddedStateFrom: page.	"including contentsMorph"	url _ temp.	"I know best!!"	temp2 ifNotNil: [policy _ temp2].		"use mine"	contentsMorph setProperty: #pageDirty toValue: nil.	self dirty: false.	^ contentsMorph! !!SqueakPage methodsFor: 'saving' stamp: 'tk 11/20/1998 13:29'!urlNoOverwrite: suggested	"Look in the directory.  If there is a file of this name, create a new name.  Keep track of highest numbers used as a hint."	| dir ll stem num local trial |	dir _ ServerFile new fullPath: suggested.	(dir includesKey: dir fileName) ifFalse: [^ url _ suggested].	"File already exists!!  Create a new name"	"Find the stem file name"	ll _ suggested findLast: [:char | char == $.].	ll = 0 ifFalse: [stem _ suggested copyFrom: 1 to: ll-1].	"remove .sp"	stem _ (stem splitInteger) at: 1.		"remove trailing number"	stem last == $x ifTrue: [stem _ stem allButLast].	num _ stem = RecentStem ifTrue: [RecentMaxNum+1] ifFalse: [1].	local _ dir fileName.	"ugh, take stem again..."	ll _ local findLast: [:char | char == $.].	ll = 0 ifFalse: [local _ local copyFrom: 1 to: ll-1].	"remove .sp"	local _ (local splitInteger) at: 1.		"remove trailing number"	local last == $x ifFalse: [local _ local , 'x'].	[trial _ local, num printString, '.sp'.		dir includesKey: trial] whileTrue: [num _ num + 1].	RecentStem _ stem.  RecentMaxNum _ num.	^ url _ stem, 'x', num printString, '.sp'! !