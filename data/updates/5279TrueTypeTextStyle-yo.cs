'From Squeak3.6alpha of ''17 March 2003'' [latest update: #5278] on 26 June 2003 at 6:37:04 am'!"Change Set:		TrueTypeTextStyle-yoDate:			26 June 2003Author:			Yoshiki Ohshima and Ned Konz26 June:made emphasis use lookup table too.This merges:Yoshiki Ohshima's TrueTypeTextStyle version 5 from SqueakMapTrueTypeTextStyle version 6 betaand Tom Blanchard's VeraTTFCompatibility.2.cs additions.It can be safely loaded into a image with version 5 loaded, or into a virgin image.It should also do the right thing when loading old instances in projects.""Convert existing instances"Smalltalk at: #TTCFont ifPresent: [ :ttcFont |	(ttcFont instVarNames includes: #pixelSize) ifTrue: [		ttcFont addInstVarName: 'pointSize'.		ttcFont allInstancesDo: [ :font |			font instVarNamed: 'pointSize' put: (font pointSize).		]	]].!CharacterScanner subclass: #CanvasCharacterScanner	instanceVariableNames: 'canvas fillBlt foregroundColor runX lineY defaultTextColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!Object subclass: #CanvasDecoder	instanceVariableNames: 'drawingCanvas clipRect transform connection fonts '	classVariableNames: 'CachedForms DecodeTable '	poolDictionaries: ''	category: 'Morphic-Remote'!AbstractFont subclass: #TTCFont	instanceVariableNames: 'ttcDescription pointSize foregroundColor cache derivatives '	classVariableNames: 'NamesToIndexes '	poolDictionaries: ''	category: 'Multilingual-Display'!!TTCFont commentStamp: 'yo 6/23/2003 19:44' prior: 0!I represent a font that uses TrueType derived glyph.  Upon a request for glyph for a character through a call to #formOf: (or #widthOf:), I first search corresponding glyph in the cache.  If there is not, it creates a 32bit depth form with the glyph.  The cache is weakly held.  The entries are zapped at full GC.Structure: ttcDescription	TTFontDescription -- The Squeak data structure for a TrueType font data file. pointSize		Number -- character size in point.  It simply assumes that the resolusion of display device is 96 dpi and an inch is 72 point. foregroundColor	Color -- So far, this font need to know the glyph color in cache. cache			WeakArray pointing to Array(256). derivatives		Array -- stores the fonts in the same family but different emphasis.!Object subclass: #TTFontDescription	instanceVariableNames: 'glyphTable glyphs kernPairs copyright familyName fullName subfamilyName uniqueName versionName postscriptName trademark bounds unitsPerEm ascender descender lineGap '	classVariableNames: 'Default Descriptions '	poolDictionaries: ''	category: 'Balloon-TrueType Fonts'!!AbstractFont methodsFor: 'testing' stamp: 'nk 6/25/2003 12:54'!isTTCFont	^false! !!BitBlt methodsFor: 'private' stamp: 'yo 6/23/2003 18:07'!installTTCFont: aTTCFont foregroundColor: foregroundColor backgroundColor: backgroundColor	"Set up the parameters.  Since the glyphs in a TTCFont is 32bit depth form, it tries to use rule=34 to get better AA result if possible."	((aTTCFont depth = 32)) ifTrue: [		destForm depth <= 8 ifTrue: [			self colorMap: (self cachedFontColormapFrom: aTTCFont depth to: destForm depth).			self combinationRule: Form paint.		] ifFalse: [			self colorMap: nil.			self combinationRule: 34.		].		halftoneForm _ nil.		sourceY _ 0.		height _ aTTCFont height.		^ self.	].! !!CanvasCharacterScanner methodsFor: 'private' stamp: 'yo 6/23/2003 18:09'!defaultTextColor: color	"This defaultTextColor inst var is equivalent to paragraphColor of DisplayScanner."	defaultTextColor _ color.! !!CanvasCharacterScanner methodsFor: 'private' stamp: 'yo 6/8/2003 21:29'!setFont	foregroundColor _ defaultTextColor.	super setFont.	destY _ lineY + line baseline - font ascent! !!CanvasCharacterScanner methodsFor: 'object fileIn' stamp: 'nk 6/17/2003 15:30'!convertToCurrentVersion: varDict refStream: smartRefStrm	"From Squeak3.5 [latest update: #5180] on 17 June 2003"	varDict  at: 'defaultTextColor' put: Color black.	^ super convertToCurrentVersion: varDict refStream: smartRefStrm! !!CanvasDecoder methodsFor: 'decoding' stamp: 'yo 3/21/2003 23:02'!addTTCFontToCache: command	| index font |	index := self class decodeInteger: command second.	font := self class decodeTTCFont: command third.	index > fonts size ifTrue: [		| newFonts |		newFonts  := Array new: index.		newFonts replaceFrom: 1 to: fonts size with: fonts.		fonts := newFonts ].	fonts at: index put: font.! !!CanvasDecoder methodsFor: 'decoding' stamp: 'nk 6/25/2003 12:24'!drawImage: command 	| image point sourceRect rule cacheID cacheNew previousImage |	image := self class decodeImage: command second.	point := self class decodePoint: command third.	sourceRect := self class decodeRectangle: command fourth.	rule := self class decodeInteger: command fifth.	command size >= 7 		ifTrue: 			[false ifTrue: [self showSpaceUsed].	"debugging"			cacheID := self class decodeInteger: (command sixth).			cacheNew := (self class decodeInteger: command seventh) = 1.			cacheID > 0 				ifTrue: 					[					cacheNew 						ifTrue: [CachedForms at: cacheID put: image]						ifFalse: 							[previousImage := CachedForms at: cacheID.							image ifNil: [image := previousImage]								ifNotNil: 									[(previousImage notNil and: [image depth > 8]) 										ifTrue: [image := previousImage addDeltasFrom: image].									CachedForms at: cacheID put: image]]]].	self drawCommand: 			[:c | 			c 				image: image				at: point				sourceRect: sourceRect				rule: rule]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'nk 6/25/2003 12:42'!processCommand: command  onForceDo: forceBlock	"Decode the given string command and perform the required action.	If the command is a forceToScreen command, also pass the forceBlock.	The previous chained equality tests and conditionals have been replaced by a lookup table in my class variable DecodeTable, which is set in the class-side initialize method."	| verb verbCode selector |	command isEmpty ifTrue: [ ^self ].	verb _ command first.	verbCode := verb first.	selector _ DecodeTable		at: (verbCode asciiValue + 1)		ifAbsent: [ self error: 'unknown command: ', verb ].	"note: codeForce is the only odd one"	^(selector == #forceToScreen:)		ifTrue: [ self forceToScreen: command withBlock: forceBlock ]		ifFalse: [ self perform: selector withArguments: { command } ]! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'yo 6/23/2003 20:12'!decodeTTCFont: fontString	"Decode a string that consists of <familyName> <pointSize> <emphasis> (e.g. 'ComicSansMS 12 0') into a proper instance."	| first second |	first _ fontString indexOf: $  startingAt: 1.	second _ fontString indexOf: $  startingAt: first + 1.	(first ~= 0 and: [second ~= 0]) ifTrue: [		^ (TTCFont family: (fontString copyFrom: 1 to: (first - 1))			size: (fontString copyFrom: first + 1 to: second - 1) asNumber)				emphasized: (fontString copyFrom: second + 1 to: fontString size) asNumber.	].	^ TextStyle defaultFont.! !!CanvasDecoder class methodsFor: 'decode table modification' stamp: 'nk 6/25/2003 12:49'!decodeVerb: verb toSelector: selector	"verb is a single character which will be ferformed by my instances using selector"	DecodeTable at: verb asciiValue + 1 put: selector.	! !!CanvasDecoder class methodsFor: 'class initialization' stamp: 'nk 6/25/2003 12:45'!initialize	"CanvasDecoder initialize"	"Set up my cache and decode table if necessary."	CachedForms ifNil: [CachedForms := Array new: 100].	DecodeTable ifNotNil: [ ^self ].	DecodeTable _ Array new: 128.	#((codeClip setClip:)	(codeTransform setTransform:)	(codeText drawText:)	(codeLine drawLine:)	(codeRect drawRect:)	(codeBalloonRect drawBalloonRect:)	(codeBalloonOval drawBalloonOval:)	(codeInfiniteFill drawInfiniteFill:)	(codeOval drawOval:)	(codeImage drawImage:)	(codeReleaseCache releaseImage:)	(codePoly drawPoly:)	(codeStencil drawStencil:)	(codeForce forceToScreen:)	(codeFont addFontToCache:)	(codeTTCFont addTTCFontToCache:)	(codeExtentDepth extentDepth:)	(codeShadowColor shadowColor:))		do: [ :arr |			DecodeTable				at: ((CanvasEncoder perform: arr first) asciiValue + 1)				put: arr second		].! !!CanvasDecoder class methodsFor: 'class initialization' stamp: 'nk 6/25/2003 12:46'!reinitialize	"CanvasDecoder reinitialize"	"Set up my cache and decode table, removing old contents."	CachedForms _ nil.	DecodeTable _ nil.	self initialize.! !!CanvasEncoder methodsFor: 'fonts' stamp: 'nk 6/25/2003 12:58'!sendFont: aFont atIndex: index	"Transmits the given fint to the other side"	| code |	code _ CanvasEncoder codeFont.	aFont isTTCFont ifTrue: [code _ CanvasEncoder codeTTCFont].	self sendCommand: {		String with: code.		self class encodeInteger: index.		self class encodeFont: aFont }.! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'yo 3/21/2003 23:01'!nameForCode: aStringOrChar	| ch |	ch _ (aStringOrChar isKindOf: String) ifTrue: [aStringOrChar first] ifFalse: [aStringOrChar].	ch == self codeBalloonOval ifTrue: [^'balloon oval'].	ch == self codeBalloonRect ifTrue: [^'balloon rectangle'].	ch == self codeClip ifTrue: [^'clip'].	ch == self codeExtentDepth ifTrue: [^'codeExtentDepth'].	ch == self codeFont ifTrue: [^'codeFont'].	ch == self codeTTCFont ifTrue: [^'codeTTCFont'].	ch == self codeForce ifTrue: [^'codeForce'].	ch == self codeImage ifTrue: [^'codeImage'].	ch == self codeLine ifTrue: [^'codeLine'].	ch == self codeOval ifTrue: [^'codeOval'].	ch == self codePoly ifTrue: [^'codePoly'].	ch == self codeRect ifTrue: [^'codeRect'].	ch == self codeReleaseCache ifTrue: [^'codeReleaseCache'].	ch == self codeStencil ifTrue: [^'codeStencil'].	ch == self codeText ifTrue: [^'codeText'].	ch == self codeTransform ifTrue: [^'codeTransform'].	ch == self codeInfiniteFill ifTrue: [^'codeInfiniteFill'].	ch == self codeShadowColor ifTrue: [^'shadowColor'].	^'????'! !!CanvasEncoder class methodsFor: 'codes' stamp: 'yo 3/21/2003 23:00'!codeTTCFont	^ $T.! !!DisplayText methodsFor: 'displaying' stamp: 'yo 6/23/2003 20:05'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"For TT font, rule 34 is used if possible."	"Refer to the comment in 	DisplayObject|displayOn:at:clippingBox:rule:mask:."	| form1 rule |	form1 _ self form.	rule _ (ruleInteger = Form over and: [backColor isTransparent])				ifTrue: [form1 depth = 32 ifTrue: [rule _ 34] ifFalse: [Form paint]]				ifFalse: [ruleInteger].	form1 depth = 32 ifTrue: [rule _ 34].	form1		displayOn: aDisplayMedium		at: aDisplayPoint + offset		clippingBox: clipRectangle		rule: rule		fillColor: aForm! !!DisplayText methodsFor: 'private' stamp: 'nk 6/25/2003 12:51'!composeForm	"For the TT strings in MVC widgets in a Morphic world such as a progress bar, the form is created by Morphic machinery."	| canvas tmpText |	Smalltalk isMorphic		ifTrue:			[tmpText _ TextMorph new contentsAsIs: text deepCopy.			foreColor ifNotNil: [tmpText text addAttribute: (TextColor color: foreColor)].			backColor ifNotNil: [tmpText backgroundColor: backColor].			tmpText setTextStyle: textStyle.			canvas _ FormCanvas on: (Form extent: tmpText extent depth: 32).			tmpText drawOn: canvas.			form _ canvas form.		]		ifFalse: [form _ self asParagraph asForm]! !!GrafPort methodsFor: 'private' stamp: 'yo 6/23/2003 20:34'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	super installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor.	alpha _ foregroundColor privateAlpha.	"dynamically switch between blend modes to support translucent text"	"To handle the transition from TTCFont to StrikeFont, rule 34 must be taken into account."	alpha = 255 ifTrue:[		combinationRule = 30 ifTrue: [combinationRule _ Form over].		combinationRule = 31 ifTrue: [combinationRule _ Form paint].		combinationRule = 34 ifTrue: [combinationRule _ Form paint].	] ifFalse:[		combinationRule = Form over ifTrue: [combinationRule _ 30].		combinationRule = Form paint ifTrue: [combinationRule _ 31].		combinationRule = 34 ifTrue: [combinationRule _ 31].	]! !!Paragraph methodsFor: 'converting' stamp: 'yo 6/23/2003 19:05'!asForm	"Answer a Form made up of the bits that represent the receiver's displayable text."	| theForm oldBackColor oldForeColor |	textStyle isTTCStyle ifTrue: [		theForm _  (Form extent: compositionRectangle extent depth: 32)		offset: offset.	] ifFalse: [		theForm _ (ColorForm extent: compositionRectangle extent)			offset: offset;			colors: (Array				with: (backColor == nil ifTrue: [Color transparent] ifFalse: [backColor])				with: (foreColor == nil ifTrue: [Color black] ifFalse: [foreColor])).	].	oldBackColor _ backColor.	oldForeColor _ foreColor.	backColor _ Color white.	foreColor _ Color black.	self displayOn: theForm		at: 0@0		clippingBox: theForm boundingBox		rule: Form over		fillColor: nil.	backColor _ oldBackColor.	foreColor _ oldForeColor.	^ theForm"Example:| p |p _ 'Abc' asParagraph.p foregroundColor: Color red backgroundColor: Color black.p asForm displayOn: Display at: 30@30 rule: Form over"! !!PopUpMenu methodsFor: 'private' stamp: 'yo 12/13/2002 15:47'!computeForm	"Compute and answer a Form to be displayed for this menu."	| borderInset paraForm menuForm inside |	borderInset _ 2@2.	paraForm _ (DisplayText text: labelString asText textStyle: MenuStyle) form.	menuForm _ Form extent: paraForm extent + (borderInset * 2) depth: paraForm depth.	menuForm borderWidth: 2.	paraForm displayOn: menuForm at: borderInset.	lineArray == nil ifFalse:		[lineArray do:			[ :line |			menuForm fillBlack: (4 @ ((line * font height) + borderInset y)				extent: (menuForm width - 8 @ 1))]].	frame _ Quadrangle new.	frame region: menuForm boundingBox.	frame borderWidth: 4.	inside _ frame inside.	marker _ inside topLeft extent: (inside width @ MenuStyle lineGrid).	selection _ 1.	^ form _ menuForm! !!RemoteCanvas methodsFor: 'drawing' stamp: 'yo 6/23/2003 18:09'!paragraph: paragraph bounds: bounds color: c	| scanner |	scanner _ CanvasCharacterScanner new.	scanner		 canvas: self;		text: paragraph text textStyle: paragraph textStyle;		textColor: c; defaultTextColor: c.	paragraph displayOn: self using: scanner at: bounds topLeft.! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 6/23/2003 19:05'!fromUser: priorFont	"Present a menu of available fonts, and if one is chosen, return it."	| fontList fontMenu style active ptMenu label spec font |	fontList _ StrikeFont familyNames remove: 'DefaultTextStyle' ifAbsent: []; asOrderedCollection.	fontMenu _ MenuMorph new defaultTarget: self.	fontList do: [:fontName |		style _ TextStyle named: fontName.		active _ priorFont familyName sameAs: fontName.		ptMenu _ MenuMorph new defaultTarget: self.		style pointSizes do: [:pt |			(active and:[pt = priorFont pointSize]) 				ifTrue:[label _ '<on>'] 				ifFalse:[label _ '<off>'].			label _ label, pt printString, ' pt'.			ptMenu add: label 				target: fontMenu				selector: #modalSelection:				argument: {fontName. pt}].		style isTTCStyle ifTrue: [			ptMenu add: 'new size'				target: style selector: #addNewFontSizeDialog: argument: {fontName. fontMenu}.		].		active ifTrue:[label _ '<on>'] ifFalse:[label _ '<off>'].		label _ label, fontName.		fontMenu add: label subMenu: ptMenu].	spec _ fontMenu invokeModal: false. "don't allow keyboard control"	spec ifNil: [^ nil].	style _ TextStyle named: spec first.	style ifNil: [^ self].	font _ style fonts detect: [:any | any pointSize = spec last] ifNone: [nil].	^ font! !!TTCFont methodsFor: 'accessing' stamp: 'yo 6/23/2003 18:42'!ascent	^ ttcDescription ascender * self pixelSize // (ttcDescription ascender - ttcDescription descender).! !!TTCFont methodsFor: 'accessing' stamp: 'yo 11/30/2002 22:38'!baseKern	^ 0.! !!TTCFont methodsFor: 'accessing' stamp: 'yo 6/23/2003 20:13'!descent	"One is added to make sure the gap between lines is filled.  If we don't add, multi line selection in a text pane look ugly."	^ ttcDescription descender * self pixelSize // (ttcDescription descender - ttcDescription ascender) + 1.! !!TTCFont methodsFor: 'accessing' stamp: 'yo 11/30/2002 22:39'!descentKern	^ 0.! !!TTCFont methodsFor: 'accessing' stamp: 'nk 6/26/2003 06:36'!emphasis	"Answer the emphasis code (0 to 3) corresponding to my subfamily name"	^self indexOfSubfamilyName: ttcDescription subfamilyName! !!TTCFont methodsFor: 'accessing' stamp: 'nk 5/26/2003 20:13'!emphasis: code	code > 3 ifTrue: [^ self].	code = 0 ifTrue: [^ self].	derivatives isNil ifTrue: [^ self].	^ (derivatives at: code) ifNil: [self].! !!TTCFont methodsFor: 'accessing' stamp: 'yo 12/13/2002 12:46'!emphasized: code	code > 3 ifTrue: [^ self].	code = 0 ifTrue: [^ self].	derivatives isNil ifTrue: [^ self].	^ (derivatives at: code) ifNil: [self].! !!TTCFont methodsFor: 'accessing' stamp: 'yo 12/10/2002 17:08'!familyName	^ ttcDescription name.! !!TTCFont methodsFor: 'accessing' stamp: 'yo 11/30/2002 22:39'!familySizeFace	^ Array		with: self familyName		with: self height		with: 0.! !!TTCFont methodsFor: 'accessing' stamp: 'yo 6/23/2003 18:39'!height	^ self pixelSize.! !!TTCFont methodsFor: 'accessing' stamp: 'yo 11/16/2002 01:00'!maxAscii	^ ttcDescription size.! !!TTCFont methodsFor: 'accessing' stamp: 'yo 11/16/2002 01:00'!minAscii	^ 0.! !!TTCFont methodsFor: 'accessing' stamp: 'yo 11/16/2002 01:00'!name	^ ttcDescription name.! !!TTCFont methodsFor: 'accessing' stamp: 'yo 6/23/2003 18:41'!pixelSize	^ pointSize * 96 / 72.! !!TTCFont methodsFor: 'accessing' stamp: 'yo 6/23/2003 18:39'!pointSize	^ pointSize.! !!TTCFont methodsFor: 'accessing' stamp: 'yo 6/23/2003 18:41'!pointSize: aNumber	pointSize _ aNumber.! !!TTCFont methodsFor: 'accessing' stamp: 'yo 12/2/2002 14:09'!textStyle	^ Utilities actualTextStyles detect:		[:aStyle | aStyle fontArray includes: self] ifNone: [nil]! !!TTCFont methodsFor: 'public' stamp: 'yo 12/10/2002 16:35'!depth	^ 32.! !!TTCFont methodsFor: 'public' stamp: 'yo 11/16/2002 00:59'!foregroundColor	^ foregroundColor.! !!TTCFont methodsFor: 'public' stamp: 'yo 12/10/2002 16:36'!size	^ ttcDescription size.! !!TTCFont methodsFor: 'public' stamp: 'yo 12/10/2002 16:36'!widthOf: aCharacter	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	| f assoc |	assoc _ self cache at: (aCharacter asciiValue + 1).	assoc ifNotNil: [		^ assoc value width	].	f _ self computeForm: aCharacter.	self at: aCharacter put: f.	^ f width.! !!TTCFont methodsFor: 'friend' stamp: 'yo 12/10/2002 17:47'!cache	(cache at: 1) ifNil: [self flushCache].	^ cache at: 1.! !!TTCFont methodsFor: 'friend' stamp: 'tb 6/24/2003 08:54'!derivativeFont: aTTCFont	| index |	aTTCFont ifNil: [derivatives _ nil. ^ self].	derivatives ifNil: [derivatives _ Array new: 4].	index _ self indexOfSubfamilyName: (aTTCFont ttcDescription subfamilyName).	index < 1 ifTrue: [		^ self inform: 'unknown sub family name.  This font will be skipped'.	].	derivatives at: index put: aTTCFont.! !!TTCFont methodsFor: 'friend' stamp: 'yo 12/13/2002 12:13'!derivativeFonts	| result |	derivatives ifNil: [^ #()].	result _ OrderedCollection new.	derivatives do: [:f | result add: f].	^ result asArray.! !!TTCFont methodsFor: 'friend' stamp: 'yo 12/10/2002 16:35'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	| destPoint ascii form |	destPoint _ aPoint.	startIndex to: stopIndex do: [:charIndex | 		ascii _ (aString at: charIndex) asciiValue bitAnd: 16rFFFFFF.		((ascii between: self minAscii and: self maxAscii) not) ifTrue: [			ascii _ self maxAscii].		form _ self formOf: (aString at: charIndex).		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x.		aBitBlt destY: destPoint y.		aBitBlt sourceOrigin: 0 @ 0.		aBitBlt width: form width.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint _ destPoint + (form width + kernDelta @ 0).	].! !!TTCFont methodsFor: 'friend' stamp: 'yo 12/10/2002 16:35'!flushCache	cache at: 1 put: (Array new: 256).! !!TTCFont methodsFor: 'friend' stamp: 'yo 11/16/2002 01:00'!initialize	foregroundColor _ Color black.! !!TTCFont methodsFor: 'friend' stamp: 'yo 12/10/2002 18:15'!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	foregroundColor _ fgColor.	aDisplayContext installTTCFont: self foregroundColor: foregroundColor backgroundColor: bgColor! !!TTCFont methodsFor: 'friend' stamp: 'yo 12/10/2002 16:36'!recreateCache	cache _ WeakArray new: 1.! !!TTCFont methodsFor: 'friend' stamp: 'yo 11/16/2002 01:01'!ttcDescription	^ ttcDescription.! !!TTCFont methodsFor: 'friend' stamp: 'yo 12/10/2002 17:27'!ttcDescription: aTTCDescription	ttcDescription _ aTTCDescription.	self recreateCache.! !!TTCFont methodsFor: 'private' stamp: 'yo 12/10/2002 16:34'!at: char put: form	self cache at: (char asciiValue + 1) put: (foregroundColor -> form).! !!TTCFont methodsFor: 'private' stamp: 'yo 6/23/2003 18:39'!computeForm: char	| ttGlyph scale |	scale _ self pixelSize asFloat / (ttcDescription ascender - ttcDescription descender).	ttGlyph _ ttcDescription at: char.	^ ttGlyph asFormWithScale: scale ascender: ttcDescription ascender descender: ttcDescription descender fgColor: foregroundColor bgColor: Color transparent depth: self depth.! !!TTCFont methodsFor: 'private' stamp: 'yo 12/10/2002 16:35'!formOf: char	| f assoc |	assoc _ self cache at: (char asciiValue + 1).	assoc ifNotNil: [		(assoc key = foregroundColor) ifTrue: [			^ assoc value.		].	].	f _ self computeForm: char.	self at: char put: f.	^ f.! !!TTCFont methodsFor: 'private' stamp: 'nk 6/25/2003 14:01'!indexOfSubfamilyName: aName	NamesToIndexes ifNil:	[		NamesToIndexes := Dictionary new.		NamesToIndexes at: 'Regular' put: 0;		at: 'Roman' put: 0;		at: 'Bold' put:  1;		at: 'Italic' put: 2;		at: 'Oblique' put: 2;		at: 'BoldItalic' put: 3;		at: 'BoldOblique' put: 3.	].	"If you get a halt here - please add the missing synonym to the lookup table above."	^NamesToIndexes at: (aName copyWithout: Character space) ifAbsent: [		self error: 'please add the missing synonym ', aName, ' to the lookup table in TTCFont>>indexOfSubfamilyName:.'	].! !!TTCFont methodsFor: 'copying' stamp: 'yo 12/10/2002 16:35'!copy	^ self.! !!TTCFont methodsFor: 'copying' stamp: 'yo 12/10/2002 16:35'!deepCopy	^ self.! !!TTCFont methodsFor: 'copying' stamp: 'yo 12/10/2002 16:36'!objectForDataStream: refStrm	self flushCache.	^ self.! !!TTCFont methodsFor: 'copying' stamp: 'yo 12/10/2002 16:36'!veryDeepCopyWith: deepCopier	self flushCache.	^ self.! !!TTCFont methodsFor: 'file in/out' stamp: 'yo 6/23/2003 18:44'!encodedForRemoteCanvas	^ self familyName, ' ', self pointSize printString, ' ', self emphasis printString.! !!TTCFont methodsFor: 'testing' stamp: 'nk 6/25/2003 12:55'!isRegular	"Answer true if I am a Regular/Roman font (i.e. not bold, etc.)"	^ (self indexOfSubfamilyName: (ttcDescription subfamilyName)) = 0.! !!TTCFont methodsFor: 'testing' stamp: 'nk 6/25/2003 12:55'!isTTCFont	^true! !!TTCFont methodsFor: 'objects from disk' stamp: 'nk 6/25/2003 13:39'!convertToCurrentVersion: varDict refStream: smartRefStrm	"If we're reading in an old version with a pixelSize instance variable, convert it to a point size".	"Deal with the change from pixelSize to pointSize, assuming 96 dpi."	varDict at: 'pixelSize' ifPresent: [ :x | 		pointSize _ x * 72 / 96.	].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!TTCFont methodsFor: 'as yet unclassified' stamp: 'nk 6/25/2003 13:59'!printOn: aStream	aStream nextPutAll: 'TTCFont(';		nextPutAll: self familyName; space;		print: self pointSize; space;		nextPutAll: ttcDescription subfamilyName;		nextPut: $)! !!TTCFont class methodsFor: 'instance creation' stamp: 'yo 6/23/2003 18:44'!family: f size: s	^ self allInstances detect: [:a | a familyName = f and: [a pointSize = s]] ifNone: [nil].! !!TTCFont class methodsFor: 'instance creation' stamp: 'yo 12/13/2002 12:20'!getExistings: fontArray	| result em |	result _ OrderedCollection new.	result add: fontArray.	1 to: 3 do: [:i |		em _ (fontArray collect: [:f | f emphasized: i]).		(em at: 1) ~= (fontArray at: 1) ifTrue: [			result add: em.		].	].	^ result asArray.! !!TTCFont class methodsFor: 'instance creation' stamp: 'nk 6/25/2003 12:58'!newTextStyleFromTT: description	"Create a new TextStyle from specified TTFontDescription instance."	| array f |	array _ self pointSizes collect: [:pt |		f _ self new initialize.		f ttcDescription: description.		f pointSize: pt.	].	^ self reorganizeForNewFontArray: array name: array first name asSymbol.! !!TTCFont class methodsFor: 'instance creation' stamp: 'yo 6/23/2003 20:17'!newTextStyleFromTTFile: fileName	"Create a new TextStyle from specified file name.  On certain versions of Windows, you can evaluate following to get Arial font into the image.  On other platforms, wait and see someone implements the support code for FontPlugin then we can start relying on the generic font lookup mechanism.	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\ARIAL.TTF'	"	| description |	description _ TTFontDescription addFromTTFile: fileName.	^ self newTextStyleFromTT: description.! !!TTCFont class methodsFor: 'instance creation' stamp: 'tb 6/24/2003 17:12'!newTextStyleFromTTStream: readStream""	| description |	description _ TTFontDescription addFromTTStream: readStream.	^ self newTextStyleFromTT: description.! !!TTCFont class methodsFor: 'instance creation' stamp: 'nk 6/25/2003 14:08'!reorganizeForNewFontArray: array name: styleName	| style existings regular altName |	(TextConstants includesKey: styleName) ifFalse: [		TextConstants at: styleName put: (TextStyle fontArray: array).		^ TextConstants at: styleName.	]. 	"There is a text style with the name I want to use.  See if it is a TTC font..."	style _ TextConstants at: styleName.	style isTTCStyle ifFalse: [		altName _ ((array at: 1) name, 'TT') asSymbol.		^ self reorganizeForNewFontArray: array name: altName.	].	existings _ (self getExistings: style fontArray), (Array with: array).	regular _ existings detect: [:e | (e at: 1) isRegular] ifNone: [existings at: 1].	"The existing array may be different in size than the new one."	existings do: [:e |		(e at: 1) isRegular ifFalse: [			regular do: [ :r | | f |				f _ e detect: [ :ea | ea pointSize = r pointSize ] ifNone: [ ].				f ifNotNil: [ r derivativeFont: f ].			].		].	].	style newFontArray: regular.	self recreateCache.		^ style.! !!TTCFont class methodsFor: 'class initialization' stamp: 'yo 6/23/2003 18:45'!initialize"	self initialize"	| tt |	tt _ TTFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].	(FileList respondsTo: #registerFileReader:) ifTrue: [		FileList registerFileReader: self	].! !!TTCFont class methodsFor: 'class initialization' stamp: 'nk 6/25/2003 13:14'!unload	(FileList respondsTo: #unregisterFileReader:) ifTrue: [		FileList unregisterFileReader: self	]! !!TTCFont class methodsFor: 'other' stamp: 'yo 6/23/2003 19:46'!isCacheAllNil"	self cacheAllNil"	self allInstances do: [:inst |		inst cache do: [:e |			e ifNotNil: [^ false].		].	].	^ true.! !!TTCFont class methodsFor: 'other' stamp: 'yo 6/23/2003 20:18'!pointSizes	"The default sizes that are created when a TextStyle is created.  You can add new sizes by the new-size feature."	^ #(9 12 15 24 36).! !!TTCFont class methodsFor: 'other' stamp: 'yo 12/10/2002 17:38'!recreateCache"	self recreateCache."	self allInstances do: [:inst | inst recreateCache].	Smalltalk garbageCollect.! !!TTCFont class methodsFor: 'other' stamp: 'yo 12/13/2002 14:16'!removeAllDerivatives"	self removeAllDerivatives"	self allInstances do: [:s |		s textStyle ifNotNil: [			s textStyle fontArray do: [:f |				f derivativeFont: nil.			].		].	].! !!TTCFont class methodsFor: 'other' stamp: 'yo 11/30/2002 22:37'!removeStyleName: aString	TextConstants removeKey: aString asSymbol ifAbsent: [].	TTFontDescription removeDescriptionNamed: aString asString.! !!TTCFont class methodsFor: 'other' stamp: 'yo 6/23/2003 19:50'!version	^ '6.0'.! !!TTCFont class methodsFor: 'file list services'!fileReaderServicesForFile: fullName suffix: suffix 	(suffix = 'ttf')		ifTrue: [^self services].	^ OrderedCollection new.! !!TTCFont class methodsFor: 'file list services'!serviceInstallTrueTypeFontStyle	"Return a service to install a true type font as a text style"	^ SimpleServiceEntry		provider: self		label: 'install ttf style'		selector: #newTextStyleFromTTFile: 		description: 'install a true type font as a text style'		buttonLabel: 'install ttf'! !!TTCFont class methodsFor: 'file list services'!services	"Return a set of services for use in FileList"	^ Array with: self serviceInstallTrueTypeFontStyle! !!TTCFont class methodsFor: 'objects from disk' stamp: 'nk 6/25/2003 13:42'!classVersion	"Version 0 had pixelSize; version 1 changed it to pointSize"	^1! !!TTFontDescription methodsFor: 'accessing' stamp: 'yo 11/30/2002 22:38'!name	^ self familyName copyWithout: Character space.! !!TTFontDescription methodsFor: 'accessing' stamp: 'yo 11/30/2002 22:38'!size	^ glyphs size.! !!TTFontDescription methodsFor: 'copying' stamp: 'yo 6/23/2003 18:23'!deepCopy	"Since it shouldn't be copied for transmitting or any reason, it returns self."	^ self.! !!TTFontDescription methodsFor: 'copying' stamp: 'yo 11/30/2002 22:38'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	dp _ DiskProxy global: #TTFontDescription selector: #descriptionNamed:			args: {self name}.	refStrm replace: self with: dp.	^ dp.! !!TTFontDescription methodsFor: 'copying' stamp: 'yo 11/30/2002 22:38'!veryDeepCopyWith: deepCopier	"Return self.  I am shared.  Do not record me."! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'tb 6/24/2003 17:10'!addFromTTFile: fileName"	self addFromTTFile: 'C:\WINDOWS\Fonts\ARIALN.TTF'"	^self addFromTTStream: (FileStream readOnlyFileNamed: fileName).! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'tb 6/24/2003 17:08'!addFromTTStream: readStream"	self addFromTTFile: 'C:\WINDOWS\Fonts\ARIALN.TTF'"	| tt old |	tt _ TTFontReader readFrom: readStream.	old _ Descriptions detect: [:f | f name = tt name and: [f subfamilyName = tt subfamilyName]] ifNone: [nil].	old ifNotNil: [Descriptions remove: old].	Descriptions add: tt.	^ tt.! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'yo 11/30/2002 22:22'!clearDefault"	self clearDefault"	Default _ nil.! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'yo 11/30/2002 22:22'!clearDescriptions"	self clearDescriptions"	Descriptions _ Set new.	Default ifNotNil: [Descriptions add: Default].! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'yo 11/30/2002 22:22'!descriptionNamed: descriptionName	^ Descriptions detect: [:f | f name = descriptionName] ifNone: [Default].! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'yo 11/30/2002 22:22'!initialize"	self initialize"	self clearDescriptions.! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'yo 12/13/2002 13:18'!removeDescriptionNamed: descriptionName	| tts |	Descriptions ifNil: [^ self].	tts _ Descriptions select: [:f | f name = descriptionName].	tts do: [:f | Descriptions remove: f].! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'yo 12/13/2002 13:55'!removeDescriptionNamed: descriptionName subfamilyName: subfamilyName	| tts |	Descriptions ifNil: [^ self].	tts _ Descriptions select: [:f | f name = descriptionName and: [f subfamilyName = subfamilyName]].	tts do: [:f | Descriptions remove: f].! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'yo 12/13/2002 13:20'!setDefault"	self setDefault"	Default _ TTFontReader readFrom: (FileStream readOnlyFileNamed: 'C:\WINDOWS\Fonts\comic.ttf').! !!TTGlyph methodsFor: 'converting' stamp: 'yo 6/23/2003 18:29'!asFormWithScale: scale ascender: ascender descender: descender	^ self		asFormWithScale: scale		ascender: ascender		descender: descender		fgColor: Color black		bgColor: Color white		depth: 8		replaceColor: true.! !!TTGlyph methodsFor: 'converting' stamp: 'yo 6/23/2003 18:27'!asFormWithScale: scale ascender: ascender descender: descender fgColor: fgColor bgColor: bgColor depth: depth	^ self		asFormWithScale: scale		ascender: ascender		descender: descender		fgColor: fgColor		bgColor: bgColor		depth: depth		replaceColor: false.! !!TTGlyph methodsFor: 'converting' stamp: 'yo 6/23/2003 18:26'!asFormWithScale: scale ascender: ascender descender: descender fgColor: fgColor bgColor: bgColor depth: depth replaceColor: replaceColorFlag	| form canvas |	form _ Form extent: (advanceWidth @ (ascender - descender) * scale) rounded depth: depth.	form fillColor: bgColor.	canvas _ BalloonCanvas on: form.	canvas aaLevel: 4.	canvas transformBy: (MatrixTransform2x3 withScale: scale asPoint * (1 @ -1)).	canvas transformBy: (MatrixTransform2x3 withOffset: 0 @ ascender negated).	canvas		drawGeneralBezierShape: self contours		color: fgColor 		borderWidth: 0 		borderColor: fgColor.	replaceColorFlag ifTrue: [		form replaceColor: bgColor withColor: Color transparent.	].	^ form! !!TextStyle methodsFor: 'accessing' stamp: 'nk 6/25/2003 12:54'!isTTCStyle	^ fontArray first isTTCFont.! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'yo 6/23/2003 19:57'!addNewFontSize: pointSize	"Add a font in specified size to the array of fonts."	| f d newArray t |	fontArray first emphasis ~= 0 ifTrue: [		t _ TextConstants at: self fontArray first familyName asSymbol.		t fonts first emphasis = 0 ifTrue: [			^ t addNewFontSize: pointSize.		].	].	pointSize <= 0 ifTrue: [^ nil].	fontArray do: [:s |		s pointSize = pointSize ifTrue: [^ s].	].	f _ TTCFont new initialize.	f ttcDescription: fontArray first ttcDescription.	f pointSize: pointSize.	fontArray first derivativeFonts do: [:proto |		proto ifNotNil: [			d _ TTCFont new initialize.			d ttcDescription: proto ttcDescription.			d pointSize: f pointSize.			f derivativeFont: d.		].	].	newArray _ ((fontArray copyWith: f) asSortedCollection: [:a :b | a pointSize <= b pointSize]) asArray.	self newFontArray: newArray.	^ self fontOfPointSize: pointSize! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'yo 6/23/2003 20:04'!addNewFontSizeDialog: args	"This is called from a modal menu and call back the menu with entered argument."	| f n r |	f _ FillInTheBlank request: 'Enter the point size' initialAnswer: '12'.	n _ f asNumber.	r _ self addNewFontSize: n.	r ifNotNil: [		args second ifNotNil: [args second modalSelection: {args first. n}].	].! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'yo 6/23/2003 19:58'!discardOtherSizes	"This method trys to discard the fonts in non-standard size.  If the size is still in use, there will be a problem."	| newArray |	self isTTCStyle ifFalse: [^ self].	newArray _ fontArray select: [:s | TTCFont pointSizes includes: s pointSize].	self newFontArray: newArray."(TextConstants at: #ComicSansMS) discardOtherSizes"! !!Utilities class methodsFor: 'text styles and fonts' stamp: 'yo 6/23/2003 20:07'!chooseTTCFontSize: args	"Adds the new-size selection to the font size menu."	| f n r |	f _ FillInTheBlank request: 'New Point Size' initialAnswer: '0'.	n _ f asNumber.	r _ (TextConstants at: args first) addNewFontSize: n.	r ifNotNil: [		args second ifNotNil: [args second perform: args third with: r].	].! !!Utilities class methodsFor: 'text styles and fonts' stamp: 'yo 6/23/2003 19:04'!fontMenuForStyle: styleName target: target selector: selector 	| aMenu |	aMenu _ MenuMorph entitled: styleName.	TextConstants at: styleName ifPresent: [:s |		s isTTCStyle ifTrue: [			aMenu add: 'New Size' target: self selector: #chooseTTCFontSize: argument: {styleName. target. selector}.		].	]. 	(Utilities pointSizesFor: styleName) do:		[:aWidth |			aMenu 				add: (aWidth asString, ' Point') 				target: target 				selector: selector				argument: ((TextStyle named: styleName) fontOfPointSize: aWidth).                aMenu lastItem font: ((TextStyle named: styleName) fontOfPointSize: aWidth)].        ^ aMenu! !TTGlyph removeSelector: #asFormWithScale:ascender:descender:fgColor:bgColor:!TTFontDescription initialize!!TTFontDescription class reorganize!('instance creations' addFromTTFile: addFromTTStream: clearDefault clearDescriptions default descriptionNamed: initialize removeDescriptionNamed: removeDescriptionNamed:subfamilyName: setDefault)('upgrade patch')!TTCFont initialize!!TTCFont class reorganize!('instance creation' family:size: getExistings: newTextStyleFromTT: newTextStyleFromTTFile: newTextStyleFromTTStream: reorganizeForNewFontArray:name:)('class initialization' initialize unload)('other' isCacheAllNil pointSizes recreateCache removeAllDerivatives removeStyleName: version)('file list services' fileReaderServicesForFile:suffix: serviceInstallTrueTypeFontStyle services)('objects from disk' classVersion)!!TTCFont reorganize!('accessing' ascent baseKern descent descentKern emphasis emphasis: emphasized: familyName familySizeFace height maxAscii minAscii name pixelSize pointSize pointSize: textStyle)('public' depth foregroundColor size widthOf:)('friend' cache derivativeFont: derivativeFonts displayString:on:from:to:at:kern: flushCache initialize installOn:foregroundColor:backgroundColor: recreateCache ttcDescription ttcDescription:)('private' at:put: computeForm: formOf: indexOfSubfamilyName:)('copying' copy deepCopy objectForDataStream: veryDeepCopyWith:)('file in/out' encodedForRemoteCanvas)('testing' isRegular isTTCFont)('objects from disk' convertToCurrentVersion:refStream:)('as yet unclassified' printOn:)!CanvasDecoder initialize!