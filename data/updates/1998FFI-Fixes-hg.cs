'From Squeak2.8alpha of 16 February 2000 [latest update: #1997] on 17 April 2000 at 11:50:34 am'!"Change Set:		FFI fixesDate:			5 March 2000Author:			Henrik GedenrydMisc fixes and enhancements for the FFI. Should've been out there for quite some time now but was living somewhere on my disk - so here it finally comes (ar)."!Inspector subclass: #ExternalStructureInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!ByteArray methodsFor: 'external access' stamp: 'hg 2/28/2000 15:34'!pointerAt: byteOffset put: value	"Store a pointer object at the given byte address"	value isExternalAddress ifFalse:[^self error:'Only external addresses can be stored'].	1 to: 4 do:[:i|		self unsignedByteAt: byteOffset+i-1 put: (value basicAt: i)].	^value! !!ByteArray methodsFor: 'external access' stamp: 'hg 2/28/2000 13:56'!structAt: byteOffset length: length	"Return a structure of the given length starting at the indicated byte offset."	| value |	value _ ByteArray new: length.	1 to: length do:[:i|		value unsignedByteAt: i put: (self unsignedByteAt: byteOffset+i-1)].	^value! !!ExternalAddress methodsFor: 'converting' stamp: 'hg 3/1/2000 22:27'!asInteger	"convert address to integer"	^self inject: 0 into: [:total :byte | total * 256 + byte]! !!ExternalAddress methodsFor: 'converting' stamp: 'hg 3/1/2000 23:00'!fromInteger: address	"set my handle to point at address"	(4 to: 1 by: -1) inject: address into: [:remainder :index | 		self at: index put: (remainder bitAnd: 255).		remainder // 256]! !!ExternalAddress methodsFor: 'printing' stamp: 'hg 3/1/2000 22:28'!printOn: aStream	"print this as a hex address ('@ 16rFFFFFFFF') to distinguish it from ByteArrays"	aStream nextPutAll: '@ ', self asInteger hex8! !!ExternalStructure methodsFor: 'inspecting' stamp: 'hg 2/28/2000 15:00'!inspect	"Open an ExternalStructureInspector on the receiver.  Use basicInspect to get a normal (less useful) type of inspector."	self class fields size > 0 		ifTrue: [ExternalStructureInspector openOn: self withEvalPane: true]		ifFalse: [super inspect]! !!ExternalStructure methodsFor: 'printing' stamp: 'hg 2/28/2000 15:49'!longPrintOn: aStream 	"Append to the argument, aStream, the names and values of all the record's variables."	| fields |	fields _ self class fields.	(fields isEmpty or: [fields first isNil]) ifTrue: [fields _ #()]		ifFalse: [(fields first isKindOf: Array) ifFalse: [fields _ Array with: fields]].	fields do: [ :field | 		aStream nextPutAll: field first; nextPut: $:; space; tab.		(self perform: field first) printOn: aStream.		aStream cr].! !!ExternalData methodsFor: 'conversion' stamp: 'hg 2/25/2000 14:51'!fromCString	"Assume that the receiver represents a C string and convert it to a Smalltalk string. hg 2/25/2000 14:18"	| stream index char |	type isPointerType ifFalse: [self error: 'External object is not a pointer type.'].	stream _ WriteStream on: String new.	index _ 1.	[(char _ handle unsignedCharAt: index) = 0 asCharacter] whileFalse: [		stream nextPut: char.		index _ index + 1].	^stream contents! !!ExternalStructure class methodsFor: 'field definition' stamp: 'hg 2/29/2000 10:54'!compileFields: specArray withAccessors: aBool	"Define all the fields in the receiver.	Return the newly compiled spec."	| fieldName fieldType isPointerField externalType byteOffset typeSize typeSpec |	(specArray size > 0 and:[specArray first class ~~ Array])		ifTrue:[^self compileAlias: specArray withAccessors: aBool].	byteOffset _ 1.	typeSpec _ WriteStream on: (WordArray new: 10).	typeSpec nextPut: (FFIFlagStructure). "dummy for size"	specArray do:[:spec|		fieldName _ spec first.		fieldType _ spec second.		isPointerField _ fieldType last = $*.		fieldType _ (fieldType findTokens: ' *') first.		externalType _ ExternalType atomicTypeNamed: fieldType.		externalType == nil ifTrue:["non-atomic"			Symbol hasInterned: fieldType ifTrue:[:sym|				externalType _ ExternalType structTypeNamed: sym]].		externalType == nil ifTrue:[			Transcript show:'(', fieldType,' is void)'.			externalType _ ExternalType void].		isPointerField ifTrue:[externalType _ externalType asPointerType].		typeSize _ externalType byteSize.		spec size > 2 ifTrue:["extra size"			spec third < typeSize ifTrue:[^self error:'Explicit type size is less than expected'].			typeSize _ spec third].		(fieldName ~~ #nil and:[aBool]) ifTrue:[			self defineFieldAccessorsFor: fieldName 				startingAt: byteOffset 				type: externalType].		typeSpec nextPutAll: (externalType embeddedSpecWithSize: typeSize).		byteOffset _ byteOffset + typeSize.	].	compiledSpec _ typeSpec contents.	compiledSpec at: 1 put: (byteOffset - 1 bitOr: FFIFlagStructure).	ExternalType noticeModificationOf: self.	^compiledSpec! !!ExternalStructureInspector methodsFor: 'selecting' stamp: 'hg 2/28/2000 14:12'!replaceSelectionValue: anObject 	"Add colon to fieldname to get setter selector, and send it to object with the argument.	 Refer to the comment in Inspector|replaceSelectionValue:."	selectionIndex = 1		ifTrue: [^object]		ifFalse: [^object perform: ((self fieldList at: selectionIndex), ':') asSymbol with: anObject]! !!ExternalStructureInspector methodsFor: 'selecting' stamp: 'hg 2/28/2000 14:22'!selection 	"Refer to the comment in Inspector|selection."	selectionIndex = 0 ifTrue:[^object printString].	selectionIndex = 1 ifTrue: [^object].	selectionIndex = 2 ifTrue:[^object longPrintString].	selectionIndex > 2		ifTrue: [^object perform: (self fieldList at: selectionIndex)]! !!ExternalStructureInspector methodsFor: 'accessing' stamp: 'hg 2/28/2000 14:20'!fieldList	^  (Array with: 'self: ', object defaultLabelForInspector with: 'all inst vars'), self recordFieldList! !!ExternalStructureInspector methodsFor: 'accessing' stamp: 'hg 2/28/2000 14:44'!recordFieldList	| fields |	fields _ object class fields.	(fields first isKindOf: Array) ifFalse: [^Array with: fields first].	^fields collect: [ :field | field first ]! !!Parser methodsFor: 'primitives' stamp: 'hg 2/29/2000 10:41'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module fn |	descriptorClass _ Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^0].	callType _ descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^0].	"Parse return type"	self advance.	retType _ self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName _ here.	(self match: #string) 		ifTrue:[externalName _ externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken:'(' asSymbol) ifFalse:[^self expected:'argument list'].	args _ WriteStream on: Array new.	[here == #)] whileFalse:[		argType _ self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(self matchToken:')' asSymbol) ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn _ xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	^120! !