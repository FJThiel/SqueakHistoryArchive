'From Squeak2.8alpha of 16 February 2000 [latest update: #2176] on 23 May 2000 at 1:01:38 pm'!"Change Set:		CSRework-AADate:			23 May 2000Author:			Andreas RaabCharacter scanner rework part1. Install the new classes and all associated things without activating them yet." !Object subclass: #AbstractFont	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Text'!!AbstractFont commentStamp: '<historical>' prior: 0!AbstractFont defines the generic interface that all fonts need to implement.!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP localHomeContext messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache atCache lkupClass reclaimableContextCount nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals compilerInitialized compilerHooks extraVMMemory interpreterVersion obsoleteIndexedPrimitiveTable obsoleteNamedPrimitiveTable interpreterProxy '	classVariableNames: 'ActiveProcessIndex AtCacheEntries AtCacheFixedFields AtCacheFmt AtCacheMask AtCacheOop AtCacheSize AtCacheTotalSize AtPutBase BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex CompilerHooksSize CrossedX DirBadPath DirEntryFound DirNoMoreEntries EndOfRun ExcessSignalsIndex FirstLinkIndex HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageLookupClassIndex MessageSelectorIndex MethodArrayIndex MethodCacheClass MethodCacheEntries MethodCacheEntrySize MethodCacheMask MethodCacheMethod MethodCachePrim MethodCacheSelector MethodCacheSize MethodIndex MyListIndex NextLinkIndex PrimitiveExternalCallIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'VMConstruction-Interpreter'!Object subclass: #NewCharacterScanner	instanceVariableNames: 'destX lastIndex xTable map destY stopConditions text textStyle alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth emphasisCode kern indentationLevel '	classVariableNames: 'DefaultStopConditions '	poolDictionaries: 'TextConstants '	category: 'Graphics-Text'!!NewCharacterScanner commentStamp: '<historical>' prior: 0!My instances hold the state associated with scanning text. My subclasses scan characters for specified purposes, such as computing a CharacterBlock or placing characters into Forms.!NewCharacterScanner subclass: #NewCharacterBlockScanner	instanceVariableNames: 'characterPoint characterIndex lastCharacter lastCharacterExtent lastSpaceOrTabExtent nextLeftMargin specialWidth '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Text'!!NewCharacterBlockScanner commentStamp: '<historical>' prior: 0!My instances are used to scan text to compute the CharacterBlock for a character specified by its index in the text or its proximity to the cursor location.!NewCharacterScanner subclass: #NewCompositionScanner	instanceVariableNames: 'spaceX spaceIndex lineHeight baseline lineHeightAtSpace baselineAtSpace '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Text'!!NewCompositionScanner commentStamp: '<historical>' prior: 0!CompositionScanners are used to measure text and determine where line breaks and space padding should occur.!NewCharacterScanner subclass: #NewDisplayScanner	instanceVariableNames: 'bitBlt lineY runX foregroundColor backgroundColor fillBlt lineHeight paragraph paragraphColor morphicOffset ignoreColorChanges '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Text'!!NewDisplayScanner commentStamp: '<historical>' prior: 0!My instances are used to scan text and display it on the screen or in a hidden form.!NewCompositionScanner subclass: #NewSegmentScanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Text'!!StrikeFont commentStamp: '<historical>' prior: 0!I represent a compact encoding of a set of Forms corresponding to characters in the ASCII character set. All the forms are placed side by side in a large form whose height is the font height, and whose width is the sum of all the character widths. The xTable variable gives the left-x coordinates of the subforms corresponding to the glyphs. Characters are mapped to glyphs by using the characterToGyphMap.Subclasses can have non-trivial mapping rules as well as different representations for glyphs sizes (e.g., not using an xTable). If so, these classes should return nil when queried for xTable and/or the characterToGlyphMap. This will cause the CharacterScanner primitive to fail and query the font for the width of a character (so that a more programatical approach can be implemented).For display, fonts need to implement two messages:	#installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColorThis method installs the receiver (a font) on the given DisplayContext (which may be an instance of BitBlt or Canvas (or any of it's subclasses). The font should take the appropriate action to initialize the display context so that further display operations can be optimized.	#displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDeltaThis method is called for each subsequent run of characters in aString which is to be displayed with the (previously installed) settings.!!AbstractFont methodsFor: 'accessing' stamp: 'ar 5/19/2000 14:56'!characterToGlyphMap	"Return the character to glyph mapping table. If the table is not provided the character scanner will query the font directly for the width of each individual character."	^nil! !!AbstractFont methodsFor: 'accessing' stamp: 'ar 5/19/2000 14:57'!xTable	"Return the xTable for the font. The xTable defines the left x-value for each individual glyph in the receiver. If such a table is not provided, the character scanner will ask the font directly for the appropriate width of each individual character."	^nil! !!AbstractFont methodsFor: 'measuring' stamp: 'ar 5/19/2000 15:00'!composeWord: aTextLineInterval in: sourceString beginningAt: xInteger 	"Non-primitive composition of a word--add up widths of characters, add 	sum to beginning x and answer the resulting x. Similar to performance 	of scanning primitive, but without stop conditions."	| character resultX |	resultX _ xInteger.	aTextLineInterval do: 		[:i | 		character _ sourceString at: i.		resultX _ resultX + (self widthOf: character)].	^resultX! !!AbstractFont methodsFor: 'measuring' stamp: 'ar 5/19/2000 14:58'!widthOf: aCharacter	"Return the width of the given character"	^self subclassResponsibility! !!AbstractFont methodsFor: 'measuring' stamp: 'ar 5/19/2000 15:00'!widthOfString: aString	^ self composeWord: (1 to: aString size) in: aString beginningAt: 0"	TextStyle default defaultFont widthOfString: 'zort' 21"! !!AbstractFont methodsFor: 'displaying' stamp: 'ar 5/19/2000 14:59'!displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDelta	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) display context."	^self subclassResponsibility! !!AbstractFont methodsFor: 'displaying' stamp: 'ar 5/19/2000 14:59'!installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColor	"Install the receiver on the given DisplayContext (either BitBlt or Canvas) for further drawing operations."	^self subclassResponsibility! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipHeight	^clipHeight! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipWidth	^clipWidth! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipX	^clipX! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipY	^clipY! !!BitBlt methodsFor: 'copying' stamp: 'ar 5/19/2000 15:08'!displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta	destY _ aPoint y.	destX _ aPoint x.	^self primDisplayString: aString from: startIndex to: stopIndex			map: font characterToGlyphMap xTable: font xTable			kern: kernDelta.! !!BitBlt methodsFor: 'private' stamp: 'ar 5/19/2000 15:07'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	| lastSourceDepth |	sourceForm ifNotNil:[lastSourceDepth _ sourceForm depth].	sourceForm _ aStrikeFont glyphs.	(colorMap notNil and:[lastSourceDepth = sourceForm depth]) ifFalse:		["Set up color map for a different source depth (color font)"		"Note this may need some caching for reasonable efficiency"		colorMap _ (Color cachedColormapFrom: sourceForm depth to: destForm depth) copy.		colorMap at: 1 put: (backgroundColor pixelValueForDepth: destForm depth)].	sourceForm depth = 1 ifTrue:		[colorMap at: 2 put: (foregroundColor pixelValueForDepth: destForm depth)].	sourceY _ 0.	height _ aStrikeFont height.! !!BitBlt methodsFor: 'private' stamp: 'ar 5/18/2000 21:49'!primDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta	| ascii glyph |	<primitive:'primitiveDisplayString' module:'BitBltPlugin'>	startIndex to: stopIndex do:[:charIndex|		ascii _ (aString at: charIndex) asciiValue.		glyph _ glyphMap at: ascii + 1.		sourceX _ xTable at: glyph + 1.		width _ (xTable at: glyph + 2) - sourceX.		self copyBits.		destX _ destX + width + kernDelta.	].! !!BitBltSimulation methodsFor: 'primitives' stamp: 'ar 5/18/2000 22:29'!primitiveDisplayString	| kernDelta xTable glyphMap stopIndex startIndex sourceString bbObj maxGlyph ascii glyphIndex sourcePtr left |	self export: true.	self var: #sourcePtr type: 'unsigned char *'.	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	kernDelta _ interpreterProxy stackIntegerValue: 0.	xTable _ interpreterProxy stackObjectValue: 1.	glyphMap _ interpreterProxy stackObjectValue: 2.	((self fetchClassOf: xTable) = self classArray and:[		(self fetchClassOf: glyphMap) = self classArray])			ifFalse:[^self primitiveFail].	(self slotSizeOf: glyphMap) = 256 ifFalse:[^self primitiveFail].	self failed ifTrue:[^nil].	maxGlyph _ (self slotSizeOf: xTable) - 2.	stopIndex _ interpreterProxy stackIntegerValue: 3.	startIndex _ interpreterProxy stackIntegerValue: 4.	sourceString _ interpreterProxy stackObjectValue: 5.	(interpreterProxy isBytes: sourceString) ifFalse:[^interpreterProxy primitiveFail].	(startIndex > 0 and:[stopIndex > 0 and:[		stopIndex <= (interpreterProxy byteSizeOf: sourceString)]])			ifFalse:[^interpreterProxy primitiveFail].	bbObj _ interpreterProxy stackObjectValue: 6.	(self loadBitBltFrom: bbObj) ifFalse:[^interpreterProxy primitiveFail].	left _ destX.	sourcePtr _ interpreterProxy firstIndexableField: sourceString.	startIndex to: stopIndex do:[:charIndex|		ascii _ sourcePtr at: charIndex-1.		glyphIndex _ interpreterProxy fetchInteger: ascii ofObject: glyphMap.		(glyphIndex < 0 or:[glyphIndex > maxGlyph]) 			ifTrue:[^interpreterProxy primitiveFail].		sourceX _ interpreterProxy fetchInteger: glyphIndex ofObject: xTable.		width _ (interpreterProxy fetchInteger: glyphIndex+1 ofObject: xTable) - sourceX.		interpreterProxy failed ifTrue:[^nil].		self clipRange.	"Must clip here"		(bbW > 0 and:[bbH > 0]) ifTrue: [self copyBits].		interpreterProxy failed ifTrue:[^nil].		destX _ destX + width + kernDelta.	].	affectedL _ left.	self showDisplayBits.	interpreterProxy pop: 6. "pop args, return rcvr"! !!Interpreter methodsFor: 'other primitives' stamp: 'ar 5/23/2000 12:59'!primitiveScanCharacters	"Invoke the character scanner primitive."	| kernDelta stops sourceString scanStopIndex scanStartIndex rcvr scanDestX scanLastIndex scanXTable scanMap maxGlyph ascii stopReason glyphIndex sourceX sourceX2 nextDestX scanRightX nilOop |	self methodArgumentCount = 6 ifFalse:[^self primitiveFail].	"Load the arguments"	kernDelta _ self stackIntegerValue: 0.	stops _ self stackObjectValue: 1.	(self fetchClassOf: stops) = self classArray ifFalse:[^self primitiveFail].	(self slotSizeOf: stops) >= 258 ifFalse:[^self primitiveFail].	scanRightX _ self stackIntegerValue: 2.	sourceString _ self stackObjectValue: 3.	(self isBytes: sourceString) ifFalse:[^self primitiveFail].	scanStopIndex _ self stackIntegerValue: 4.	scanStartIndex _ self stackIntegerValue: 5.	(scanStartIndex > 0 and:[scanStopIndex > 0 and:[		scanStopIndex <= (self byteSizeOf: sourceString)]])			ifFalse:[^self primitiveFail].	"Load receiver and required instVars"	rcvr _ self stackObjectValue: 6.	((self isPointers: rcvr) and:[(self slotSizeOf: rcvr) >= 4])		ifFalse:[^self primitiveFail].	scanDestX _ self fetchInteger: 0 ofObject: rcvr.	scanLastIndex _ self fetchInteger: 1 ofObject: rcvr.	scanXTable _ self fetchPointer: 2 ofObject: rcvr.	scanMap _ self fetchPointer: 3 ofObject: rcvr.	((self fetchClassOf: scanXTable) = self classArray and:[		(self fetchClassOf: scanMap) = self classArray])			ifFalse:[^self primitiveFail].	(self slotSizeOf: scanMap) = 256 ifFalse:[^self primitiveFail].	self failed ifTrue:[^nil].	maxGlyph _ (self slotSizeOf: scanXTable) - 2.	"Okay, here we go. We have eliminated nearly all failure conditions,	to optimize the inner fetches."	scanLastIndex _ scanStartIndex.	nilOop _ self nilObject.	[scanLastIndex <= scanStopIndex] whileTrue:[		"Known to be okay since scanStartIndex > 0 and scanStopIndex <= sourceString size"		ascii _ self fetchByte: scanLastIndex-1 ofObject: sourceString.		"Known to be okay since stops size >= 258"		(stopReason _ self fetchPointer: ascii ofObject: stops) = nilOop ifFalse:[			"Store everything back and get out of here"			(self isIntegerValue: scanDestX) ifFalse:[^self primitiveFail].			self storeInteger: 0 ofObject: rcvr withValue: scanDestX.			self storeInteger: 1 ofObject: rcvr withValue: scanLastIndex.			self pop: 7. "args+rcvr"			^self push: stopReason].		"Known to be okay since scanMap size = 256"		glyphIndex _ self fetchInteger: ascii ofObject: scanMap.		(self failed or:[glyphIndex < 0 or:[glyphIndex > maxGlyph]])			ifTrue:[^self primitiveFail].		sourceX _ self fetchInteger: glyphIndex ofObject: scanXTable.		sourceX2 _ self fetchInteger: glyphIndex+1 ofObject: scanXTable.		"Above may fail if non-integer entries in scanXTable"		self failed ifTrue:[^nil].		nextDestX _ scanDestX + sourceX2 - sourceX.		nextDestX > scanRightX ifTrue:[			"Store everything back and get out of here"			(self isIntegerValue: scanDestX) ifFalse:[^self primitiveFail].			self storeInteger: 0 ofObject: rcvr withValue: scanDestX.			self storeInteger: 1 ofObject: rcvr withValue: scanLastIndex.			self pop: 7. "args+rcvr"			^self push: (self fetchPointer: CrossedX-1 ofObject: stops)].		scanDestX _ nextDestX + kernDelta.		scanLastIndex _ scanLastIndex + 1].	(self isIntegerValue: scanDestX) ifFalse:[^self primitiveFail].	self storeInteger: 0 ofObject: rcvr withValue: scanDestX.	self storeInteger: 1 ofObject: rcvr withValue: scanStopIndex.	self pop: 7. "args+rcvr"	^self push: (self fetchPointer: EndOfRun-1 ofObject: stops).! !!Interpreter class methodsFor: 'initialization' stamp: 'ar 5/18/2000 21:11'!initialize	"Interpreter initialize"	super initialize.  "initialize ObjectMemory constants"	self initializeAssociationIndex.	self initializeBytecodeTable.	self initializeCaches.	self initializeCharacterIndex.	self initializeClassIndices.	self initializeCompilerHooks.	self initializeContextIndices.	self initializeDirectoryLookupResultCodes.	self initializeMessageIndices.	self initializeMethodIndices.	self initializePointIndices.	self initializePrimitiveTable.	self initializeSchedulerIndices.	self initializeSmallIntegers.	self initializeStreamIndices.	SemaphoresToSignalSize _ 25.	PrimitiveExternalCallIndex _ 117. "Primitive index for #primitiveExternalCall"	CrossedX _ TextConstants at: #CrossedX.	EndOfRun _ TextConstants at: #EndOfRun.! !!Interpreter class methodsFor: 'initialization' stamp: 'ar 5/23/2000 13:00'!initializePrimitiveTable 	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveArrayBecomeOneWay)	"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveStoreStackp)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveBlockCopy)		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveTestDisplayDepth)			"Blue Book: primitiveCursorLocPut"		(92 primitiveSetDisplayMode)				"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)						"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveObsoleteIndexedPrimitive)	"primitiveCopyBits"		(97 primitiveSnapshot)		(98 primitiveStoreImageSegment)		(99 primitiveLoadImageSegment)		(100 primitivePerformInSuperclass)		"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveObsoleteIndexedPrimitive)	"primitiveDrawLoop"		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFlushCacheByMethod)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)			"Squeak 2.2 and earlier use 119.  Squeak 2.3 and later use 116.			Both are supported for backward compatibility."		"Miscellaneous Primitives (120-127)"		(120 primitiveCalloutToFFI)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveObsoleteIndexedPrimitive)	"primitiveReadJoystick"		(147 primitiveObsoleteIndexedPrimitive)	"primitiveWarpBits"		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 163 primitiveObsoleteIndexedPrimitive)		(164 168 primitiveFail)		(169 primitiveObsoleteIndexedPrimitive)		"Sound Primitives (170-199)"		(170 175 primitiveObsoleteIndexedPrimitive)		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 oldprimSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(186 188 primitiveFail)		(189 194 primitiveObsoleteIndexedPrimitive)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 225 primitiveObsoleteIndexedPrimitive)		(226 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 241 primitiveObsoleteIndexedPrimitive)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 primStringfindSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveInstVarsPutFromStack) "Never used except in Disney tests.  Remove after 2.3 release."		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 529 primitiveObsoleteIndexedPrimitive)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 545 primitiveObsoleteIndexedPrimitive)		(546 547 primitiveFail)		"Pen Tablet Primitives"		(548 primitiveObsoleteIndexedPrimitive)		(549 primitiveObsoleteIndexedPrimitive)		"Sound Codec Primitives"		(550 primADPCMCodecprivateDecodeMono)			(551 primADPCMCodecprivateDecodeStereo)			(552 primADPCMCodecprivateEncodeMono)			(553 primADPCMCodecprivateEncodeStereo)			(554 569 primitiveFail)  "reserved for additional codec primitives"		"External primitive support primitives"		(570 primitiveFlushExternalPrimitives)		(571 primitiveUnloadModule)		(572 primitiveListBuiltinModule)		(573 574 primitiveFail) "reserved for addl. external support prims"		"Unassigned Primitives"		(575 700 primitiveFail)).! !!Interpreter class methodsFor: 'initialization' stamp: 'ar 5/23/2000 13:00'!obsoleteIndexedPrimitiveTable	"Interpreter obsoleteIndexedPrimitiveTableString"	"Initialize the links from the (now obsolete) indexed primitives to	the new named primitives."	| table |	table _ Array new: MaxPrimitiveIndex+1.	#(		(96	(BitBltPlugin primitiveCopyBits))		(104 (BitBltPlugin primitiveDrawLoop))		(147 (BitBltPlugin primitiveWarpBits))		(146 (JoystickTabletPlugin primitiveReadJoystick))		"File Primitives (150-169)"		(150 (FilePlugin primitiveFileAtEnd))		(151 (FilePlugin primitiveFileClose))		(152 (FilePlugin primitiveFileGetPosition))		(153 (FilePlugin primitiveFileOpen))		(154 (FilePlugin primitiveFileRead))		(155 (FilePlugin primitiveFileSetPosition))		(156 (FilePlugin primitiveFileDelete))		(157 (FilePlugin primitiveFileSize))		(158 (FilePlugin primitiveFileWrite))		(159 (FilePlugin primitiveFileRename))		(160 (FilePlugin primitiveDirectoryCreate))		(161 (FilePlugin primitiveDirectoryDelimitor))		(162 (FilePlugin primitiveDirectoryLookup))		(163 (FilePlugin primitiveDirectoryDelete))		(169 (FilePlugin primitiveDirectorySetMacTypeAndCreator))		"Sound Primitives (170-199)"		(170 (SoundPlugin primitiveSoundStart))		(171 (SoundPlugin primitiveSoundStartWithSemaphore))		(172 (SoundPlugin primitiveSoundStop))		(173 (SoundPlugin primitiveSoundAvailableSpace))		(174 (SoundPlugin primitiveSoundPlaySamples))		(175 (SoundPlugin primitiveSoundPlaySilence))		(189 (SoundPlugin primitiveSoundInsertSamples))		(190 (SoundPlugin primitiveSoundStartRecording))		(191 (SoundPlugin primitiveSoundStopRecording))		(192 (SoundPlugin primitiveSoundGetRecordingSampleRate))		(193 (SoundPlugin primitiveSoundRecordSamples))		(194 (SoundPlugin primitiveSoundSetRecordLevel))		"Networking Primitives (200-229)"		(200 (SocketPlugin primitiveInitializeNetwork))		(201 (SocketPlugin primitiveResolverStartNameLookup))		(202 (SocketPlugin primitiveResolverNameLookupResult))		(203 (SocketPlugin primitiveResolverStartAddressLookup))		(204 (SocketPlugin primitiveResolverAddressLookupResult))		(205 (SocketPlugin primitiveResolverAbortLookup))		(206 (SocketPlugin primitiveResolverLocalAddress))		(207 (SocketPlugin primitiveResolverStatus))		(208 (SocketPlugin primitiveResolverError))		(209 (SocketPlugin primitiveSocketCreate))		(210 (SocketPlugin primitiveSocketDestroy))		(211 (SocketPlugin primitiveSocketConnectionStatus))		(212 (SocketPlugin primitiveSocketError))		(213 (SocketPlugin primitiveSocketLocalAddress))		(214 (SocketPlugin primitiveSocketLocalPort))		(215 (SocketPlugin primitiveSocketRemoteAddress))		(216 (SocketPlugin primitiveSocketRemotePort))		(217 (SocketPlugin primitiveSocketConnectToPort))		(218 (SocketPlugin primitiveSocketListenOnPort))		(219 (SocketPlugin primitiveSocketCloseConnection))		(220 (SocketPlugin primitiveSocketAbortConnection))		(221 (SocketPlugin primitiveSocketReceiveDataBufCount))		(222 (SocketPlugin primitiveSocketReceiveDataAvailable))		(223 (SocketPlugin primitiveSocketSendDataBufCount))		(224 (SocketPlugin primitiveSocketSendDone))		(225 (SocketPlugin primitiveSocketAccept))		"Other Primitives (230-249)"		(238 (SerialPlugin primitiveSerialPortOpen))		(239 (SerialPlugin primitiveSerialPortClose))		(240 (SerialPlugin primitiveSerialPortWrite))		(241 (SerialPlugin primitiveSerialPortRead))		"MIDI Primitives (520-539)"		(521 (MIDIPlugin primitiveMIDIClosePort))		(522 (MIDIPlugin primitiveMIDIGetClock))		(523 (MIDIPlugin primitiveMIDIGetPortCount))		(524 (MIDIPlugin primitiveMIDIGetPortDirectionality))		(525 (MIDIPlugin primitiveMIDIGetPortName))		(526 (MIDIPlugin primitiveMIDIOpenPort))		(527 (MIDIPlugin primitiveMIDIParameterGetOrSet))		(528 (MIDIPlugin primitiveMIDIRead))		(529 (MIDIPlugin primitiveMIDIWrite))		"Experimental Asynchrous File Primitives"		(540 (AsynchFilePlugin primitiveAsyncFileClose))		(541 (AsynchFilePlugin primitiveAsyncFileOpen))		(542 (AsynchFilePlugin primitiveAsyncFileReadResult))		(543 (AsynchFilePlugin primitiveAsyncFileReadStart))		(544 (AsynchFilePlugin primitiveAsyncFileWriteResult))		(545 (AsynchFilePlugin primitiveAsyncFileWriteStart))		"Pen Tablet Primitives"		(548 (JoystickTabletPlugin primitiveGetTabletParameters))		(549 (JoystickTabletPlugin primitiveReadTablet))		"Sound Codec Primitives"		"(550 primADPCMCodecprivateDecodeMono)			(551 primADPCMCodecprivateDecodeStereo)			(552 primADPCMCodecprivateEncodeMono)			(553 primADPCMCodecprivateEncodeStereo)"	) do:[:spec| table at: spec first+1 put: spec second].	^table! !!NewCharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!addEmphasis: code	"Set the bold-ital-under-strike emphasis."	emphasisCode _ emphasisCode bitOr: code! !!NewCharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!addKern: kernDelta	"Set the current kern amount."	kern _ kern + kernDelta! !!NewCharacterScanner methodsFor: 'private' stamp: 'ar 5/17/2000 17:13'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	text _ aParagraph text.	textStyle _ aParagraph textStyle. ! !!NewCharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!setActualFont: aFont	"Set the basal font to an isolated font reference."	font _ aFont! !!NewCharacterScanner methodsFor: 'private' stamp: 'ar 5/18/2000 18:02'!setFont	"Set the font and other emphasis."	text == nil ifFalse:[		emphasisCode _ 0.		kern _ 0.		indentationLevel _ 0.		alignment _ textStyle alignment.		font _ nil.		(text attributesAt: lastIndex forStyle: textStyle)			do: [:att | att emphasizeScanner: self]].	font == nil ifTrue:		[self setFont: textStyle defaultFontIndex].	font _ font emphasized: emphasisCode.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space.	xTable _ font xTable.	map _ font characterToGlyphMap.	stopConditions _ DefaultStopConditions.! !!NewCharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:28'!setFont: fontNumber	"Set the font by number from the textStyle."	self setActualFont: (textStyle fontAt: fontNumber)! !!NewCharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:28'!text: t textStyle: ts	text _ t.	textStyle _ ts! !!NewCharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:28'!textColor: ignored	"Overridden in DisplayScanner"! !!NewCharacterScanner methodsFor: 'scanning' stamp: 'ar 5/19/2000 14:45'!characterNotInFont	"Note: All fonts should have some sort of a character to glyph mapping.	If a character is not in the font it should be mapped to the appropriate	glyph (that is the glyph describing a non-existing character). If done	correctly, this method should never be called. It is mainly provided	for backward compatibility (and I'd really like to get rid of it - ar).	All fonts have an illegal character to be used when a character is not 	within the font's legal range. When characters out of ranged are 	encountered in scanning text, then this special character indicates the 	appropriate behavior. The character is usually treated as a unary 	message understood by a subclass of CharacterScanner."	| illegalAsciiString saveIndex stopCondition | 	saveIndex _ lastIndex.	illegalAsciiString _ String with: (font maxAscii + 1) asCharacter.	stopCondition _ self scanCharactersFrom: 1 to: 1			in: illegalAsciiString			rightX: rightMargin stopConditions: stopConditions			kern: kern.	lastIndex _ saveIndex + 1.	stopCondition ~= (stopConditions at: EndOfRun)		ifTrue:	[^self perform: stopCondition]		ifFalse: [lastIndex = runStopIndex					ifTrue:	[^self perform: (stopConditions at: EndOfRun)].				^false]! !!NewCharacterScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 18:20'!indentationLevel	"return the number of tabs that are currently being placed at the beginning of each line"	^indentationLevel ifNil:[0]! !!NewCharacterScanner methodsFor: 'scanning' stamp: 'ar 1/8/2000 14:23'!indentationLevel: anInteger	"set the number of tabs to put at the beginning of each line"	indentationLevel _ anInteger! !!NewCharacterScanner methodsFor: 'scanning' stamp: 'ar 1/8/2000 14:23'!leadingTab	"return true if only tabs lie to the left"	line first to: lastIndex do:		[:i | (text at: i) == Tab ifFalse: [^ false]].	^ true! !!NewCharacterScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 18:20'!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	| w |	destX _ destX + (w _ anchoredMorph width).	(destX > rightMargin and: [(leftMargin + w) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex _ lastIndex + 1.	self setFont.  "Force recalculation of emphasis for next run"	^ true! !!NewCharacterScanner methodsFor: 'scanning' stamp: 'ar 5/23/2000 12:59'!primScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char |	<primitive: 103>	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[char _ (sourceString at: lastIndex).			ascii _ char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextDestX _ destX + (font widthOf: char).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!NewCharacterScanner methodsFor: 'scanning' stamp: 'ar 5/19/2000 14:42'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"This method will perform text scanning with kerning."	line first = startIndex ifTrue: [		"handle indentation"		self indentationLevel timesRepeat: [ self tab ] ].	^self primScanCharactersFrom: startIndex to: stopIndex in: sourceString 			rightX: rightX stopConditions: stops kern: kernDelta! !!NewCharacterScanner methodsFor: 'initialize' stamp: 'ar 5/17/2000 17:33'!initialize	destX _ destY _ 0.! !!NewCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:51'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				lastCharacter _ nil.				characterPoint _ ((text at: lastIndex) = CR								ifTrue: [leftMargin]								ifFalse: [nextLeftMargin]) @ destY.				lastIndex _ lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!NewCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:50'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterPoint x <= (destX + ((lastCharacterExtent x) // 2))		ifTrue:	[lastCharacter _ (text at: lastIndex).				characterPoint _ destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter _ (text at: line last).				characterPoint _ destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex _ lastIndex + 1.	lastCharacter _ text at: lastIndex.	currentX _ destX + lastCharacterExtent x.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint _ currentX @ destY.	"Yukky if next character is space or tab."	(lastCharacter = Space and: [textStyle alignment = Justified])		ifTrue:	[self lastCharacterExtentSetX:					(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1))).				^ true].	lastCharacter = Space		ifTrue:			["See tabForDisplay for illumination on the following awfulness."			leadingTab _ true.			(line first to: lastIndex - 1) do:			[:index |			(text at: index) ~= Tab				ifTrue: [leadingTab _ false]].			(textStyle alignment ~= Justified or: [leadingTab])				ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX							leftMargin: leftMargin rightMargin: rightMargin) -								currentX]				ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -								(line justifiedTabDeltaFor: spaceCount))) -									currentX) max: 0)]].	^ true! !!NewCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:50'!endOfRun	"Before arriving at the cursor location, the selection has encountered an 	end of run. Answer false if the selection continues, true otherwise. Set 	up indexes for building the appropriate CharacterBlock."	| runLength lineStop |	((characterIndex ~~ nil and:		[runStopIndex < characterIndex and: [runStopIndex < text size]])			or:	[characterIndex == nil and: [lastIndex < line last]])		ifTrue:	["We're really at the end of a real run."				runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).				characterIndex ~~ nil					ifTrue:	[lineStop _ characterIndex	"scanning for index"]					ifFalse:	[lineStop _ line last			"scanning for point"].				(runStopIndex _ lastIndex + (runLength - 1)) > lineStop					ifTrue: 	[runStopIndex _ lineStop].				self setStopConditions.				^false].	lastCharacter _ text at: lastIndex.	characterPoint _ destX @ destY.	((lastCharacter = Space and: [textStyle alignment = Justified])		or: [lastCharacter = Tab and: [lastSpaceOrTabExtent notNil]])		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent].	characterIndex ~~ nil		ifTrue:	["If scanning for an index and we've stopped on that index,				then we back destX off by the width of the character stopped on				(it will be pointing at the right side of the character) and return"				runStopIndex = characterIndex					ifTrue:	[self characterPointSetX: destX - lastCharacterExtent x.							^true].				"Otherwise the requested index was greater than the length of the				string.  Return string size + 1 as index, indicate further that off the				string by setting character to nil and the extent to 0."				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"Scanning for a point and either off the end of the line or off the end of the string."	runStopIndex = text size		ifTrue:	["off end of string"				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"just off end of line without crossing x"	lastIndex _ lastIndex + 1.	^true! !!NewCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:51'!paddedSpace	"When the line is justified, the spaces will not be the same as the font's 	space character. A padding of extra space must be considered in trying 	to find which character the cursor is pointing at. Answer whether the 	scanning has crossed the cursor."	| pad |	pad _ 0.	spaceCount _ spaceCount + 1.	pad _ line justifiedPadFor: spaceCount.	lastSpaceOrTabExtent _ lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX:  spaceWidth + pad.	(destX + lastSpaceOrTabExtent x)  >= characterPoint x		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent copy.				^self crossedX].	lastIndex _ lastIndex + 1.	destX _ destX + lastSpaceOrTabExtent x.	^ false! !!NewCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:32'!setFont	specialWidth _ nil.	super setFont! !!NewCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 5/18/2000 16:47'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	textStyle alignment = Justified ifTrue:[		"Make a local copy of stop conditions so we don't modify the default"		stopConditions == DefaultStopConditions 			ifTrue:[stopConditions _ stopConditions copy].		stopConditions at: Space asciiValue + 1 put: #paddedSpace]! !!NewCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:50'!tab	| currentX |	currentX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastSpaceOrTabExtent _ lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX: (currentX - destX max: 0).	currentX >= characterPoint x		ifTrue: 			[lastCharacterExtent _ lastSpaceOrTabExtent copy.			^ self crossedX].	destX _ currentX.	lastIndex _ lastIndex + 1.	^false! !!NewCharacterBlockScanner methodsFor: 'private' stamp: 'ar 5/17/2000 17:20'!buildCharacterBlockIn: para	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(para numberOfLines = 0 or: [text size = 0])		ifTrue:	[^ CharacterBlock new stringIndex: 1  "like being off end of string"					text: para text					topLeft: (para leftMarginForDisplayForLine: 1)								@ para compositionRectangle top					extent: 0 @ textStyle lineGrid].	"find the line"	lineIndex _ para lineIndexOfTop: characterPoint y.	destY _ para topAtLineIndex: lineIndex.	line _ para lines at: lineIndex.	rightMargin _ para rightMarginForDisplay.	(lineIndex = para numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					self characterPointSetX: rightMargin]			ifFalse:	[characterPoint y < (para compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint _ (para compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[self characterPointSetX: rightMargin]].	destX _ (leftMargin _ para leftMarginForDisplayForLine: lineIndex).	nextLeftMargin_ para leftMarginForDisplayForLine: lineIndex+1.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex	"scanning for index"]		ifFalse:	[lineStop _ line last].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0. done  _ false.	[done]	whileFalse:	[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition)		ifTrue:	[^ CharacterBlock new stringIndex: lastIndex text: text					topLeft: characterPoint extent: lastCharacterExtent]]! !!NewCharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!characterPointSetX: xVal	characterPoint _ xVal @ characterPoint y! !!NewCharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!lastCharacterExtentSetX: xVal	lastCharacterExtent _ xVal @ lastCharacterExtent y! !!NewCharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!lastSpaceOrTabExtentSetX: xVal	lastSpaceOrTabExtent _ xVal @ lastSpaceOrTabExtent y! !!NewCharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 19:14'!characterBlockAtPoint: aPoint in: aParagraph	"Answer a CharacterBlock for character in aParagraph at point aPoint. It 	is assumed that aPoint has been transformed into coordinates appropriate 	to the text's destination form rectangle and the composition rectangle."	self initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle.	characterPoint _ aPoint.	^self buildCharacterBlockIn: aParagraph! !!NewCharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 17:21'!characterBlockAtPoint: aPoint index: index in: textLine	| runLength lineStop done stopCondition |	line _ textLine.	characterIndex _ index.  " == nil means scanning for point"	characterPoint _ aPoint.	(characterPoint == nil or: [characterPoint y > line bottom])		ifTrue: [characterPoint _ line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex ~~ nil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	rightMargin _ line rightMargin.	destX _ leftMargin _ line leftMarginForAlignment: textStyle alignment.	destY _ line top.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ text runLengthFor: line first.	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex  "scanning for index"]		ifFalse:	[lineStop _ line last  "scanning for point"].	runStopIndex _ lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0.	done  _ false.	[done] whileFalse:		[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth == nil			ifTrue: [font widthOf: (text at: lastIndex)]			ifFalse: [specialWidth]).		(self perform: stopCondition) ifTrue:			[^ (CharacterBlock new				stringIndex: (characterIndex==nil ifTrue: [lastIndex] ifFalse: [characterIndex])				text: text topLeft: characterPoint extent: lastCharacterExtent)				textLine: line]]! !!NewCharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 19:14'!characterBlockForIndex: targetIndex in: aParagraph 	"Answer a CharacterBlock for character in aParagraph at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destination form rectangle and the composition rectangle."	self 		initializeFromParagraph: aParagraph 		clippedBy: aParagraph clippingRectangle.	characterIndex _ targetIndex.	characterPoint _ 		aParagraph rightMarginForDisplay @ 			(aParagraph topAtLineIndex: 				(aParagraph lineIndexOfCharacterIndex: characterIndex)).	^self buildCharacterBlockIn: aParagraph! !!NewCharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/19/2000 14:46'!characterNotInFont 	"See the note in CharacterScanner>>characterNotInFont.	This does not handle character selection nicely, i.e., illegal characters are a 	little tricky to select.  Since the end of a run or line is subverted here by actually	having the scanner scan a different string in order to manage the illegal 	character, things are not in an absolutely correct state for the character 	location code.  If this becomes too odious in use, logic will be added to accurately 	manage the situation."	lastCharacterExtent _ 		(font widthOf: (font maxAscii + 1) asCharacter) @ line lineHeight.	^super characterNotInFont! !!NewCharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 17:35'!placeEmbeddedObject: anchoredMorph	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	specialWidth _ anchoredMorph width.	^ true! !!NewCharacterScanner class methodsFor: 'class initialization' stamp: 'ar 5/18/2000 16:50'!initialize	"CharacterScanner initialize"	"NewCharacterScanner initialize"	| stopConditions |	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	stopConditions at: Space asciiValue + 1 put: nil.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX.	DefaultStopConditions _ stopConditions.! !!NewCharacterScanner class methodsFor: 'instance creation' stamp: 'ar 1/8/2000 15:00'!new	^super new initialize! !!NewCompositionScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 17:21'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	"Set up margins"	leftMargin _ lineRectangle left.	leftSide ifTrue: [leftMargin _ leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX _ spaceX _ leftMargin.	rightMargin _ lineRectangle right.	rightSide ifTrue: [rightMargin _ rightMargin - textStyle rightIndent].	lastIndex _ startIndex.	"scanning sets last index"	destY _ lineRectangle top.	lineHeight _ baseline _ 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle;				leftMargin: leftMargin.		spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!NewCompositionScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 17:21'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	destX _ spaceX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."	baseline _ textStyle baseline.	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!NewCompositionScanner methodsFor: 'scanning' stamp: 'ar 1/8/2000 14:36'!setActualFont: aFont	"Keep track of max height and ascent for auto lineheight"	| descent |	super setActualFont: aFont.	lineHeight == nil		ifTrue: [descent _ font descent.				baseline _ font ascent.				lineHeight _ baseline + descent]		ifFalse: [descent _ lineHeight - baseline max: font descent.				baseline _ baseline max: font ascent.				lineHeight _ lineHeight max: baseline + descent]! !!NewCompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!cr	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	spaceX _ destX.	line paddingWidth: rightMargin - spaceX.	^true! !!NewCompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	spaceCount >= 1 ifTrue:		["The common case. First back off to the space at which we wrap."		line stop: spaceIndex.		lineHeight _ lineHeightAtSpace.		baseline _ baselineAtSpace.		spaceCount _ spaceCount - 1.		spaceIndex _ spaceIndex - 1.		"Check to see if any spaces preceding the one at which we wrap.			Double space after punctuation, most likely."		[(spaceCount > 1 and: [(text at: spaceIndex) = Space])]			whileTrue:				[spaceCount _ spaceCount - 1.				"Account for backing over a run which might					change width of space."				font _ text fontAt: spaceIndex withStyle: textStyle.				spaceIndex _ spaceIndex - 1.				spaceX _ spaceX - (font widthOf: Space)].		line paddingWidth: rightMargin - spaceX.		line internalSpaces: spaceCount]	ifFalse:		["Neither internal nor trailing spaces -- almost never happens."		lastIndex _ lastIndex - 1.		[destX <= rightMargin]			whileFalse:				[destX _ destX - (font widthOf: (text at: lastIndex)).				lastIndex _ lastIndex - 1].		spaceX _ destX.		line paddingWidth: rightMargin - destX.		line stop: (lastIndex max: line first)].	^true! !!NewCompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!endOfRun	"Answer true if scanning has reached the end of the paragraph. 	Otherwise step conditions (mostly install potential new font) and answer 	false."	| runLength |	lastIndex = text size	ifTrue:	[line stop: lastIndex.			spaceX _ destX.			line paddingWidth: rightMargin - destX.			^true]	ifFalse:	[runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).			runStopIndex _ lastIndex + (runLength - 1).			self setStopConditions.			^false]! !!NewCompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:37'!placeEmbeddedObject: anchoredMorph	| descent |	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	descent _ lineHeight - baseline.	lineHeight _ lineHeight max: anchoredMorph height.	baseline _ lineHeight - descent.	^ true! !!NewCompositionScanner methodsFor: 'stop conditions' stamp: 'ar 5/18/2000 16:48'!setFont	super setFont.	stopConditions == DefaultStopConditions 		ifTrue:[stopConditions _ stopConditions copy].	stopConditions at: Space asciiValue + 1 put: #space.! !!NewCompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:37'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont! !!NewCompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:55'!space	"Record left x and character index of the space character just encounted. 	Used for wrap-around. Answer whether the character has crossed the 	right edge of the composition rectangle of the paragraph."	spaceX _ destX.	destX _ spaceX + spaceWidth.	spaceIndex _ lastIndex.	lineHeightAtSpace _ lineHeight.	baselineAtSpace _ baseline.	lastIndex _ lastIndex + 1.	spaceCount _ spaceCount + 1.	destX > rightMargin ifTrue: 	[^self crossedX].	^false! !!NewCompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:59'!tab	"Advance destination x according to tab settings in the paragraph's 	textStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	destX _ textStyle				nextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex _ lastIndex + 1.	^false! !!NewCompositionScanner methodsFor: 'accessing' stamp: 'ar 1/8/2000 14:35'!rightX	"Meaningful only when a line has just been composed -- refers to the 	line most recently composed. This is a subtrefuge to allow for easy 	resizing of a composition rectangle to the width of the maximum line. 	Useful only when there is only one line in the form or when each line 	is terminated by a carriage return. Handy for sizing menus and lists."	^spaceX! !!NewCompositionScanner methodsFor: 'intialize-release' stamp: 'ar 5/17/2000 19:14'!forParagraph: aParagraph	"Initialize the receiver for scanning the given paragraph."	self		initializeFromParagraph: aParagraph		clippedBy: aParagraph clippingRectangle.! !!NewDisplayScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 20:46'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line _ textLine.	morphicOffset _ offset.	leftMargin _ (line leftMarginForAlignment: textStyle alignment) + offset x.	destX _ runX _ leftMargin.	rightMargin _ line rightMargin + offset x.	lineY _ line top + offset y.	lineHeight _ line lineHeight.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: leftMargin - line left height: lineHeight; copyBits].	lastIndex _ line first.	leftInRun <= 0		ifTrue: [self setStopConditions.  "also sets the font"				nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	destY _ lineY + line baseline - font ascent.	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	done _ false.	string _ text string.	[done] whileFalse:[		startIndex _ lastIndex.		lastPos _ destX@destY.		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern].		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].	fillBlt == nil ifFalse:		[fillBlt destX: destX destY: lineY width: line right-destX height: lineHeight;				copyBits].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!NewDisplayScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 20:47'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	leftInRun _ 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		destX _ (runX _ leftMargin).		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt == nil ifFalse:			[fillBlt destX: visibleRectangle left destY: lineY				width: leftMargin - visibleRectangle left height: lineHeight; copyBits].		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		runStopIndex _ lastIndex + (runLength - 1) min: line last.		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		string _ text string.		[done] whileFalse:[			startIndex _ lastIndex.			lastPos _ destX@destY.			stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.			lastIndex >= startIndex ifTrue:[				font displayString: string on: bitBlt 					from: startIndex to: lastIndex at: lastPos kern: kern].		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].		fillBlt == nil ifFalse:			[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].		lineY _ lineY + lineHeight]! !!NewDisplayScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 17:36'!placeEmbeddedObject: anchoredMorph	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph 		ifTrue: [anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset]		ifFalse: [destY _ lineY.				runX _ destX.				anchoredMorph displayOn: bitBlt destForm at: destX - anchoredMorph width @ destY].	^ true! !!NewDisplayScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:49'!doesDisplaying	^true! !!NewDisplayScanner methodsFor: 'private' stamp: 'ar 5/17/2000 17:36'!fillLeading	"At the end of every run (really only needed when font size changes),	fill any extra leading above and below the font in the larger line height"	fillBlt == nil ifTrue: [^ self].  "No fill requested"	"Fill space above the font"	fillBlt destX: runX destY: lineY width: destX - runX height: destY - lineY;		copyBits.	"Fill space below the font"	fillBlt destY: (destY + font height); height: (lineY + lineHeight) - (destY + font height);		copyBits.! !!NewDisplayScanner methodsFor: 'private' stamp: 'ar 5/17/2000 18:45'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt _ BitBlt toForm: aParagraph destinationForm.	bitBlt fillColor: aParagraph fillColor.	"sets halftoneForm"	bitBlt combinationRule: aParagraph rule.	bitBlt clipRect: clippingRectangle.! !!NewDisplayScanner methodsFor: 'private' stamp: 'ar 5/17/2000 19:26'!setDestForm: df	bitBlt setDestForm: df.! !!NewDisplayScanner methodsFor: 'private' stamp: 'ar 5/17/2000 18:57'!setFont 	foregroundColor _ paragraphColor.	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"	font installOn: bitBlt foregroundColor: foregroundColor backgroundColor: backgroundColor.	text ifNotNil:[destY _ lineY + line baseline - font ascent]! !!NewDisplayScanner methodsFor: 'private' stamp: 'ar 5/17/2000 20:25'!setPort: aBitBlt	"Install the BitBlt to use"	bitBlt _ aBitBlt.	bitBlt sourceForm: nil. "Make sure font installation won't be confused"! !!NewDisplayScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:51'!text: t textStyle: ts foreground: foreColor background: backColor fillBlt: blt ignoreColorChanges: shadowMode	text _ t.	textStyle _ ts. 	foregroundColor _ paragraphColor _ foreColor.	(backgroundColor _ backColor) isTransparent ifFalse:		[fillBlt _ blt.		fillBlt fillColor: backgroundColor].	ignoreColorChanges _ shadowMode! !!NewDisplayScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:51'!textColor: textColor	ignoreColorChanges ifTrue: [^ self].	foregroundColor _ textColor! !!NewDisplayScanner methodsFor: 'stop conditions' stamp: 'ar 5/19/2000 14:46'!characterNotInFont	"See the note in CharacterScanner>>characterNotInFont.	All fonts have an illegal character to be used when a character is not 	within the font's legal range. When characters out of ranged are 	encountered in scanning text, then this special character indicates the 	appropriate behavior. The character is usually treated as a unary 	message understood by a subclass of CharacterScanner."	| illegalAsciiString saveIndex stopCondition lastPos |	saveIndex _ lastIndex.	lastPos _ destX @ destY.	illegalAsciiString _ String with: (font maxAscii + 1) asCharacter.	stopCondition _ self scanCharactersFrom: 1 to: 1			in: illegalAsciiString			rightX: rightMargin stopConditions: stopConditions			kern: kern.	font displayString: illegalAsciiString 			on: bitBlt from: 1 to: 1 at: lastPos kern: kern.	lastIndex _ saveIndex + 1.	stopCondition ~= (stopConditions at: EndOfRun)		ifTrue:	[^self perform: stopCondition]		ifFalse: [lastIndex = runStopIndex					ifTrue:	[^self perform: (stopConditions at: EndOfRun)].				^false]! !!NewDisplayScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:42'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex_ lastIndex + 1.	^false! !!NewDisplayScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:42'!crossedX	"This condition will sometimes be reached 'legally' during display, when, 	for instance the space that caused the line to wrap actually extends over 	the right boundary. This character is allowed to display, even though it 	is technically outside or straddling the clipping ectangle since it is in 	the normal case not visible and is in any case appropriately clipped by 	the scanner."	self fillLeading.	^ true ! !!NewDisplayScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:56'!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	self fillLeading.  "Fill any leading above or below the font"	lastIndex = line last ifTrue: [^true].	runX _ destX.	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).	runStopIndex _ lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!NewDisplayScanner methodsFor: 'stop conditions' stamp: 'ar 5/17/2000 17:36'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	| oldX |	spaceCount _ spaceCount + 1.	oldX _ destX.	destX _ oldX + spaceWidth + (line justifiedPadFor: spaceCount).	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits].	lastIndex _ lastIndex + 1.	^ false! !!NewDisplayScanner methodsFor: 'stop conditions' stamp: 'ar 5/18/2000 16:47'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	textStyle alignment = Justified ifTrue:[		"Make a local copy of stop conditions so we don't modify the default"		stopConditions == DefaultStopConditions 			ifTrue:[stopConditions _ stopConditions copy].		stopConditions at: Space asciiValue + 1 put: #paddedSpace]! !!NewDisplayScanner methodsFor: 'stop conditions' stamp: 'ar 5/17/2000 17:36'!tab	| oldX |	oldX _ destX.	destX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits].	lastIndex _ lastIndex + 1.	^ false! !!NewDisplayScanner methodsFor: 'quick print' stamp: 'ar 5/18/2000 18:00'!drawString: aString at: aPoint	"Draw the given string."	destX _ aPoint x asInteger.	destY _ aPoint y asInteger.	self primScanCharactersFrom: 1 to: aString size in: aString		rightX: bitBlt clipX + bitBlt clipWidth + font maxWidth		stopConditions: stopConditions kern: kern.	font displayString: aString on: bitBlt from: 1 to: lastIndex at: aPoint kern: kern.! !!NewDisplayScanner methodsFor: 'quick print' stamp: 'ar 5/17/2000 17:41'!lineHeight	"Answer the height of the font used by QuickPrint."	^ font height! !!NewDisplayScanner methodsFor: 'quick print' stamp: 'ar 5/17/2000 18:56'!quickPrintOn: aForm box: aRectangle font: aStrikeFont color: textColor	"Initialize myself."	bitBlt _ BitBlt toForm: aForm.	backgroundColor _ Color transparent.	paragraphColor _ textColor.	font _ aStrikeFont ifNil: [TextStyle defaultFont].	emphasisCode _ 0.	kern _ 0.	indentationLevel _ 0.	self setFont.	"Override cbrule and map"	bitBlt combinationRule: Form paint.	bitBlt colorMap: (Bitmap with: 0      "Assumes 1-bit deep fonts"						with: (textColor pixelValueForDepth: bitBlt destForm depth)).	bitBlt clipRect: aRectangle.! !!NewDisplayScanner methodsFor: 'quick print' stamp: 'ar 5/18/2000 18:00'!stringWidth: aString	"Answer the width of the given string."	destX _ destY _ 0.	aString ifNil: [^ 0].	self primScanCharactersFrom: 1 to: aString size in: aString		rightX: 99999	"virtual infinity"		stopConditions: stopConditions		kern: kern.	^ destX"	(1 to: 10) collect: [:i | QuickPrint new stringWidth: (String new: i withAll: $A)]"! !!NewDisplayScanner class methodsFor: 'queries' stamp: 'ar 5/17/2000 17:39'!defaultFont	^ TextStyle defaultFont! !!NewDisplayScanner class methodsFor: 'queries' stamp: 'ar 5/17/2000 17:40'!quickPrintOn: aForm	"Create an instance to print on the given form in the given rectangle."	^(super new) quickPrintOn: aForm box: aForm boundingBox font: self defaultFont color: Color black! !!NewDisplayScanner class methodsFor: 'queries' stamp: 'ar 5/17/2000 17:39'!quickPrintOn: aForm box: aRectangle	"Create an instance to print on the given form in the given rectangle."	^(super new) quickPrintOn: aForm box: aRectangle font: self defaultFont color: Color black! !!NewDisplayScanner class methodsFor: 'queries' stamp: 'ar 5/17/2000 17:40'!quickPrintOn: aForm box: aRectangle font: aStrikeFont	"Create an instance to print on the given form in the given rectangle."	^(super new) quickPrintOn: aForm box: aRectangle font: aStrikeFont color: Color black! !!NewDisplayScanner class methodsFor: 'queries' stamp: 'ar 5/17/2000 17:40'!quickPrintOn: aForm box: aRectangle font: aStrikeFont color: textColor	"Create an instance to print on the given form in the given rectangle."	^ (super new) quickPrintOn: aForm box: aRectangle font: aStrikeFont color: textColor! !!NewDisplayScanner class methodsFor: 'examples' stamp: 'ar 5/17/2000 17:41'!example	"This will quickly print all the numbers from 1 to 100 on the display,	and then answer the default width and height of the string 'hello world'."	"NewDisplayScanner example"	| scanner |	scanner _ self quickPrintOn: Display.	0 to: 99 do: [: i | scanner drawString: i printString at: (i//10*20) @ (i\\10*12) ].	^ (scanner stringWidth: 'hello world') @ (scanner lineHeight)! !!NewSegmentScanner methodsFor: 'as yet unclassified' stamp: 'ar 5/18/2000 16:48'!setFont	super setFont.	"Make a local copy of stop conditions so we don't modify the default"	stopConditions == DefaultStopConditions 		ifTrue:[stopConditions _ stopConditions copy].	stopConditions at: Space asciiValue + 1 put: nil.! !!StrikeFont methodsFor: 'accessing' stamp: 'ar 5/18/2000 18:08'!characterToGlyphMap	^self createCharacterToGlyphMap.! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 5/19/2000 15:09'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) BitBlt."	aBitBlt displayString: aString 			from: startIndex 			to: stopIndex 			at: aPoint 			strikeFont: self			kern: kernDelta.! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 5/19/2000 15:08'!installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColor	^aDisplayContext 		installStrikeFont: self		foregroundColor: foregroundColor 		backgroundColor: backgroundColor! !!StrikeFont methodsFor: 'private' stamp: 'ar 5/18/2000 18:13'!createCharacterToGlyphMap	"Private. Create the character to glyph mapping for a font that didn't have any before. This is basically equivalent to what the former setStopCondition did, only based on indexes."	| map |	map _ Array new: 256.	0 to: minAscii - 1 do:[:i| map at: i + 1 put: maxAscii + 1].	minAscii to: maxAscii do:[:i| map at: i + 1 put: i].	maxAscii + 1 to: 255 do:[:i| map at: i + 1 put: maxAscii + 1].	^map! !NewCharacterScanner initialize!Interpreter initialize!