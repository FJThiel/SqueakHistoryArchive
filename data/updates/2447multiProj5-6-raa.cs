'From Squeak2.9alpha of 13 June 2000 [latest update: #2440] on 6 July 2000 at 1:55:33 pm'!"Change Set:		multiProj5and6Date:			6 July 2000Author:			Bob Arning- adds GZipSurrogateStream which implements required parts of StandardFileStream protocol to enable Projects to be written directly as gzipped files without requiring intermediate write and read of normal file- standardizes category for Player subclasses as 'Morphic-UserObjects'- files out source for player methods which have been modified in a browser- insures ComplexProgressIndicator is fully on screen- implements FileList2 class>>modalFolderSelector as a morphic folder selector- cleans up ServerDirectory and ServerFile use of inst var <type> which could be nil under certain circumstances- modifies Project>>fromMyServerLoad: to use directory project came from if server not available- removes Fake37Xxxx classes from change set- projects are now stored (locally and on servers) in zipped format with version info in file name. Projects are stored locally in a directory 'Squeaklets'- ProjectNavigationMorph enhancements from Karl Ramberg- initial app/factory view options as well as quick world resizing- fixed several world menu glitches- removed class Bob- changes to BookMorphs and their sorters to support building new presentations:--- the sorter now has a button to toggle the parts bin-ishness of the playfield so you can drag pages out and drop them in another sorter without altering the original--- when a BookMorph receives a page from another book, it copies the page to preserve the original and clears the text search attributes since the new page(s) will make it incorrect- Introducing the ThreadNavigationMorph to build sequences for projects. See the class comment for ideas.- adds 2 items to Morph control menu/debug submenu to allow --- the addition of a Smalltalk expression to be evaluated on mouseUp--- the removal of mouseUp actions- introduces a #morphicLayerNumber to aid in keeping navigation morphs from clashing with other front-of-the-world type morphs. Used in limited places now, it could be useful elsewhere- adds Project class>>enterIfThereOrFind: to make it easier to enter a project that exists or can be found, but do nothing otherwise- keep TranslucentProgressMorphs from going behind SystemWindows e.g.- made ProjectNavigationMorph more flap-like in its positioning- fixed HandMorph>>unlockContents (it was missing)- new project save folder locator from Alan's art- made creation of a new blank project when load failed optional- fixed problems with #tellAFriend and Celeste- fixed green halo duplicate/grab of morphs in scaled worlds- fixed decompile string of blocks with more than one arg- fixed rare problem when attempting to resize a SystemWindow resulted in resizing pane instead- added delayed popup to Publish button in ProjectNavigatorMorph- changed some unnecessary #currentWorld sends to #world- Ted's ArmsLengthCmd changes "!FileList subclass: #FileList2	instanceVariableNames: 'showDirsInFileList currentDirectorySelected fileSelectionBlock optionalButtonSpecs another yetanother andanother modalView '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!FileList2 commentStamp: '<historical>' prior: 0!Some variations on FileList that- use a hierarchical pane to show folder structure- use different pane combinations, button layouts and prefiltering for specific usesFileList2 morphicView openInWorld				"an alternative to the standard FileList"FileList2 morphicViewNoFile openInWorld			"useful for selecting, but not viewing"FileList2 morphicViewProjectLoader openInWorld	"useful for finding and loading projects"FileList2 morphicViewImageViewer openInWorld	"useful for finding and using images"FileList2 modalFolderSelector						"allows the user to select a folder"!]style[(169 38 41 43 39 48 41 46 37 36 36 4)f1cblue;,f1,f1cblue;,f1,f1cblue;,f1,f1cblue;,f1,f1cblue;,f1,f1cblue;,f1!Object subclass: #GZipSurrogateStream	instanceVariableNames: 'gZipStream zippedFileStream bufferStream positionThusFar '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compression'!!GZipSurrogateStream commentStamp: '<historical>' prior: 0!A pseudo stream that allows SmartRefStream to write directly to a gzipped file. There are some peculiarities of the project exporting process that require:1. We ignore #close since the file is closed and may be reopened to continue writing. We implement #reallyClose for when we know that all writing is over.2. We use a BitBlt to write WordArrayForSegment objects. Bit of a hack, but there it is.| fileStream wa |wa _ WordArrayForSegment new: 30000.1 to: wa size do: [ :i | wa at: i put: i].fileStream _ GZipSurrogateStream newFileNamed: 'xxx3.gz' inDirectory: FileDirectory default.fileStream nextPutAll: 'this is a test'.fileStream nextPutAll: wa.fileStream reallyClose.!Object subclass: #ImageSegment	instanceVariableNames: 'arrayOfRoots segment outPointers state segmentName fileName endMarker userRootCnt renamedClasses '	classVariableNames: 'BiggestFileNumber '	poolDictionaries: ''	category: 'System-Object Storage'!AlignmentMorph subclass: #EmbeddedWorldBorderMorph	instanceVariableNames: 'heights minWidth minHeight '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!Model subclass: #Project	instanceVariableNames: 'world changeSet transcript parentProject previousProject displayDepth activeProcess exitFlag viewSize thumbnail nextProject guards projectParameters isolatedHead inForce version urlList environment lastDirectory '	classVariableNames: 'CurrentProject GoalFreePercent GoalNotMoreThan UIProcess '	poolDictionaries: ''	category: 'System-Support'!AlignmentMorph subclass: #ProjectNavigationMorph	instanceVariableNames: 'mouseInside '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!Notification subclass: #ProjectViewOpenNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!ProjectViewOpenNotification commentStamp: '<historical>' prior: 0!ProjectViewOpenNotification is signalled to determine if a ProjectViewMorph is needed for a newly created project. The default answer is yes.!ClassCategoryReader subclass: #RenamedClassSourceReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!SimpleButtonMorph subclass: #SimpleButtonDelayedMenuMorph	instanceVariableNames: 'didMenu mouseDownTime '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!AlignmentMorph subclass: #ThreadNavigationMorph	instanceVariableNames: 'listOfPages currentIndex loadedProject '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!TransformationMorph subclass: #BOBTransformationMorph	instanceVariableNames: 'worldBoundsToShow '	classVariableNames: 'BOBDEBUG '	poolDictionaries: ''	category: 'Morphic-Basic'!Morph subclass: #TranslucentProgessMorph	instanceVariableNames: 'opaqueBackgroundColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!ArrayedCollection methodsFor: 'printing' stamp: 'RAA 6/23/2000 08:24'!writeOnGZIPByteStream: aStream 		aStream nextPutAllBytes: self! !!BlockContext methodsFor: 'Worlds' stamp: 'RAA 7/5/2000 11:13'!valueWithWorld: aWorldOrNil	^self		on: RequestCurrentWorldNotification		do: [ :ex | ex resume: aWorldOrNil ]! !!BlockNode methodsFor: 'printing' stamp: 'RAA 7/5/2000 11:43'!printArgumentsOn: aStream indent: level	arguments size = 0		ifTrue: [^ self].	aStream dialect = #SQ00		ifTrue: [aStream				withStyleFor: #setOrReturn				do: [aStream nextPutAll: 'With'].			arguments				do: [:arg | 					aStream space.					aStream						withStyleFor: #blockArgument						do: [aStream nextPutAll: arg key]].			aStream nextPutAll: '. ']		ifFalse: [arguments				do: [:arg | aStream						withStyleFor: #blockArgument						do: [aStream nextPutAll: ':';								 nextPutAll: arg key;								 space]].			aStream nextPutAll: '| '].	"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1		ifTrue: [aStream crtab: level]! !!Class methodsFor: 'subclass creation' stamp: 'RAA 6/22/2000 14:17'!newSubclass	| i className |	i _ 1.	[className _ (self name , i printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [i _ i + 1].	^ self subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: Object categoryForUniclasses"Point newSubclass new"! !!ClassCategoryReader methodsFor: 'fileIn/Out' stamp: 'RAA 6/22/2000 16:08'!scanFromNoCompile: aStream forSegment: anImageSegment	^self scanFromNoCompile: aStream 	"subclasses may care about the segment"! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 6/29/2000 11:29'!forkProgressWatcher	[		[stageCompleted < 999 and: 				[formerProject == Project current and: 				[formerWorld == World and: 				[translucentMorph world notNil and:				[formerProcess suspendedContext notNil and: 				[Project uiProcess == formerProcess]]]]]] whileTrue: [			translucentMorph setProperty: #revealTimes toValue: 					{(Time millisecondClockValue - start max: 1). (estimate * newRatio max: 1)}.			translucentMorph changed.			translucentMorph owner addMorphInLayer: translucentMorph.			self backgroundWorldDisplay.			(Delay forMilliseconds: 100) wait.		].		translucentMorph removeProperty: #revealTimes.		self loadingHistoryAt: 'total' add: (Time millisecondClockValue - start max: 1).		formerWorld == World ifTrue: [			translucentMorph delete.		] ifFalse: [			translucentMorph privateDeleteWithAbsolutelyNoSideEffects.		].	] forkAt: 6.! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 6/29/2000 11:31'!targetMorph: aMorph	targetMorph _ aMorph! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 6/29/2000 11:35'!withProgressDo: aBlock	| safetyFactor totals trialRect delta |	Smalltalk isMorphic ifFalse: [^aBlock value].	formerProject _ Project current.	formerWorld _ World.	formerProcess _ Processor activeProcess.	targetMorph ifNil: [		trialRect _ Rectangle center: Sensor cursorPoint extent: 80@80.		delta _ trialRect amountToTranslateWithin: formerWorld bounds.		trialRect _ trialRect translateBy: delta.		translucentMorph _ TranslucentProgessMorph new			opaqueBackgroundColor: Color white;			bounds: trialRect;			openInWorld: formerWorld.	] ifNotNil: [		translucentMorph _ TranslucentProgessMorph new			bounds: targetMorph bounds;			openInWorld: targetMorph world.	].	stageCompleted _ 0.	safetyFactor _ 1.1.	"better to guess high than low"	translucentMorph setProperty: #progressStageNumber toValue: 1.	totals _ self loadingHistoryDataForKey: 'total'.	newRatio _ 1.0.	estimate _ totals size < 2 ifTrue: [		15000		"be a pessimist"	] ifFalse: [		(totals sum - totals max) / (totals size - 1 max: 1) * safetyFactor.	].	start _ Time millisecondClockValue.	self forkProgressWatcher.	[		aBlock 			on: ProgressInitiationException			do: [ :ex | 				ex sendNotificationsTo: [ :min :max :curr |					"ignore this as it is inaccurate"				].			].	] on: ProgressNotification do: [ :note |		stageCompleted _ (note messageText findTokens: ' ') first asNumber.		cumulativeStageTime _ Time millisecondClockValue - start max: 1.		prevData _ self loadingHistoryDataForKey: stageCompleted.		prevData isEmpty ifFalse: [			newRatio _ (cumulativeStageTime / (prevData average max: 1)) asFloat.		].		self loadingHistoryAt: stageCompleted add: cumulativeStageTime.		translucentMorph setProperty: #progressStageNumber toValue: stageCompleted + 1.		note resume.	].	stageCompleted _ 999.	"we may or may not get here"! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 12:33'!submit: sendNow	| newMessageNumber personalCeleste windows |	personalCeleste _ false.	celeste ifNil: [		personalCeleste _ true.		celeste _ Celeste open.	].	newMessageNumber _ celeste PROTOqueueMessageWithText: (		self breakLines: self completeTheMessage atWidth: 72	).	sendNow ifTrue: [celeste sendMail: {newMessageNumber}].	personalCeleste ifTrue: [		windows _ SystemWindow 			windowsIn: self currentWorld 			satisfying: [ :each | each model == celeste].		celeste close.		windows do: [ :each | each delete].	].	morphicWindow ifNotNil: [ morphicWindow delete ].	mvcWindow ifNotNil: [ mvcWindow controller close ].! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/2000 17:39'!contents	^(item directoryNames sortBy: [ :a :b | a caseInsensitiveLessOrEqual: b]) collect: [ :n | 		FileDirectoryWrapper with: (item directoryNamed: n) name: n model: self	]! !!FileList methodsFor: 'file list menu' stamp: 'RAA 6/21/2000 22:57'!openProjectFromFile	"Reconstitute a Morph from the selected file, presumed to be represent	a Morph saved via the SmartRefStream mechanism, and open it in an	appropriate Morphic world."	Project canWeLoadAProjectNow ifFalse: [^ self].	ProjectViewMorph 		openFromDirectory: directory 		andFileName: fileName! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/2000 12:10'!cancelHit	modalView delete.	currentDirectorySelected _ nil.! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/2000 12:06'!modalView: aSystemWindowOrSuch	modalView _ aSystemWindowOrSuch! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/2000 12:06'!okHit	modalView delete.! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:41'!ascii	self bufferStream ascii! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:42'!binary	self bufferStream binary! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:43'!bufferStream	^bufferStream ifNil: [bufferStream _ RWBinaryOrTextStream on: (ByteArray new: 5000)].! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 09:26'!close		"we don't want to until user is really done"	! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:26'!closed	^false! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:41'!cr	self bufferStream cr! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 19:18'!fileOutClass: extraClass andObject: theObject	"Write a file that has both the source code for the named class and an object as bits.  Any instance-specific object will get its class written automatically."	| class srefStream |	self timeStamp.	extraClass ifNotNil: [		class _ extraClass.	"A specific class the user wants written"		class sharedPools size > 0 ifTrue: [			class shouldFileOutPools ifTrue: [class fileOutSharedPoolsOn: self]		].		class fileOutOn: self moveSource: false toFile: 0	].	"Append the object's raw data"	srefStream _ SmartRefStream on: self.	srefStream nextPut: theObject.  "and all subobjects"	srefStream close.		"also closes me - well it thinks it does, anyway"! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 19:16'!flushBuffer	| data |	bufferStream ifNil: [^self].	data _ bufferStream contents asByteArray.	gZipStream nextPutAll: data.	positionThusFar _ positionThusFar + data size.	bufferStream _ nil.! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/22/2000 18:36'!header	"ignore"! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 19:12'!newFileNamed: fName inDirectory: aDirectory	positionThusFar _ 0.	zippedFileStream _ aDirectory newFileNamed: fName.	zippedFileStream binary; setFileTypeToObject.		"Type and Creator not to be text, so can be enclosed in an email"	gZipStream _ GZipWriteStream on: zippedFileStream.! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 09:23'!next	^self bufferStream next! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:42'!nextChunkPut: aString	self bufferStream nextChunkPut: aString! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:42'!nextInt32Put: int32	^self bufferStream nextInt32Put: int32! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:41'!nextNumber: n put: v 	^self bufferStream nextNumber: n put: v ! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:41'!nextPut: aByte	^self bufferStream nextPut: aByte! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:24'!nextPutAll: aString	^aString writeOnGZIPByteStream: self! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:41'!nextPutAllBytes: aString	^self bufferStream nextPutAll: aString! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 19:27'!nextPutAllWordArray: aWordArray	| ba hackwa hackba blt rowsAtATime sourceOrigin rowsRemaining |	ba _ nil.	rowsAtATime _ 2000.		"or 8000 bytes"	hackwa _ Form new hackBits: aWordArray.	sourceOrigin _ 0@0.	[(rowsRemaining _ hackwa height - sourceOrigin y) > 0] whileTrue: [		rowsAtATime _ rowsAtATime min: rowsRemaining.		(ba isNil or: [ba size ~= (rowsAtATime * 4)]) ifTrue: [			ba _ ByteArray new: rowsAtATime * 4.			hackba _ Form new hackBits: ba.			blt _ (BitBlt toForm: hackba) sourceForm: hackwa.		].		blt 			combinationRule: Form over;			sourceOrigin: sourceOrigin;			destX: 0 destY: 0 width: 4 height: rowsAtATime;			copyBits.		self bufferStream nextPutAll: ba.		self flushBuffer.		sourceOrigin _ sourceOrigin x @ (sourceOrigin y + rowsAtATime).	].! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/22/2000 18:42'!nextStringPut: s 	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."	| length |	(length _ s size) < 192		ifTrue: [self nextPut: length]		ifFalse: 			[self nextPut: (length digitAt: 4)+192.			self nextPut: (length digitAt: 3).			self nextPut: (length digitAt: 2).			self nextPut: (length digitAt: 1)].	self nextPutAll: s.	^s! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:26'!padToEndWith: aChar	"We don't have pages, so we are at the end, and don't need to pad."! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 19:12'!position	^self bufferStream position + positionThusFar! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 19:13'!reallyClose	self flushBuffer.	gZipStream close.! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:30'!reopen	"ignore"! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/22/2000 18:36'!setFileTypeToObject	"ignore"! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:30'!setToEnd	"ignore"! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 09:21'!skip: aNumber	^self bufferStream skip: aNumber! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:41'!timeStamp	"Append the current time to the receiver as a String."	self bufferStream nextChunkPut:	"double string quotes and !!s"		(String streamContents: [:s | Smalltalk timeStamp: s]) printString.	self bufferStream cr! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/22/2000 18:37'!trailer	"ignore"! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 6/23/2000 12:11'!writeForExportWithSources: fName inDirectory: aDirectory	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk.  Append the source code of any classes in roots.  Target system will quickly transfer the sources to its changes file."	| fileStream temp allClassesInRoots classesToWriteEntirely methodsWithSource |	state = #activeCopy ifFalse: [self error: 'wrong state'].	(fName includes: $.) ifFalse: [		^ self inform: 'Please use ''.pr'' or ''.extSeg'' at the end of the file name'.].	temp _ endMarker.	endMarker _ nil.	fileStream _ GZipSurrogateStream newFileNamed: fName inDirectory: aDirectory.	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."	endMarker _ temp.	"append sources"	allClassesInRoots _ arrayOfRoots select: [:cls | cls isKindOf: Behavior].	classesToWriteEntirely _ allClassesInRoots select: [ :cls | cls theNonMetaClass isSystemDefined].	methodsWithSource _ OrderedCollection new.	allClassesInRoots do: [ :cls |		(classesToWriteEntirely includes: cls) ifFalse: [			cls selectorsAndMethodsDo: [ :sel :meth |				meth sourcePointer = 0 ifFalse: [methodsWithSource add: {cls. sel. meth}].			].		].	].	(classesToWriteEntirely isEmpty and: [methodsWithSource isEmpty]) ifTrue: [		fileStream reallyClose.	"since #close is ignored"		^ self	].	"fileStream reopen; setToEnd."	"<--not required with gzipped surrogate stream"	fileStream nextPutAll: '\\!!ImageSegment new!!\\' withCRs.	methodsWithSource do: [ :each |		fileStream nextPut: $!!.	"try to pacify ImageSegment>>scanFrom:"		fileStream nextChunkPut: 'RenamedClassSourceReader formerClassName: ',				each first name printString,' methodsFor: ',				(each first organization categoryOfElement: each second) asString printString,				' stamp: ',(Utilities timeStampForMethod: each third) printString; cr.		fileStream nextChunkPut: (each third getSourceFor: each second in: each first) asString.		fileStream nextChunkPut: ' '; cr.	].	classesToWriteEntirely do: [:cls | 		cls isMeta ifFalse: [fileStream nextPutAll: 						(cls name, ' category: ''', cls category, '''.!!'); cr; cr].		cls organization			putCommentOnFile: fileStream			numbered: 0			moveSource: false			forClass: cls.	"does nothing if metaclass"		cls organization categories do: 			[:heading |			cls fileOutCategory: heading				on: fileStream				moveSource: false				toFile: 0]].	"no class initialization -- it came in as a real object"	fileStream reallyClose.	"since #close is ignored"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 7/4/2000 11:50'!acceptSingleMethodSource: aDictionary	| oldClassInfo oldClassName ismeta newName actualClass selector |	oldClassInfo _ (aDictionary at: #oldClassName) findTokens: ' '.	"'Class' or 'Class class'"	oldClassName _ oldClassInfo first asSymbol.	ismeta _ oldClassInfo size > 1.	newName _ renamedClasses ifNil: [		oldClassName	] ifNotNil: [		renamedClasses at: oldClassName ifAbsent: [oldClassName]	].	actualClass _ Smalltalk at: newName.	ismeta ifTrue: [actualClass _ actualClass class].	selector _ actualClass parserClass new parseSelector: (aDictionary at: #methodText).	(actualClass compiledMethodAt: selector ifAbsent: [^self "hosed input"]) 		putSource: (aDictionary at: #methodText)		fromParseNode: nil		class: actualClass		category: (aDictionary at: #category)		withStamp: (aDictionary at: #changeStamp)		inFile: 2		priorMethod: nil.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 6/22/2000 17:50'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots.	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal fakes goods bads perfect ccFixups real insts receiverClasses |	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal 				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is not compatible'].	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		fakes _ mapFakeClassesToReal keys.		goods _ OrderedCollection new.		bads _ OrderedCollection new.		fakes do: [:aFakeClass | 			real _ mapFakeClassesToReal at: aFakeClass.			(real indexIfCompact > 0) "and there is a fake class"				ifFalse: ["normal case"					aFakeClass allInstancesDo: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]				ifTrue: ["instances have the wrong class.  Fix them before anyone notices."					insts _ OrderedCollection new.					self allObjectsDo: [:obj | obj class == real ifTrue: [insts add: obj]].					insts do: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]].		bads size > 0 ifTrue: [			bads asArray elementsForwardIdentityTo: goods asArray]].	receiverClasses _ self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:aRoot | 		(aRoot isKindOf: Project) ifTrue: [			Project allInstancesDo: [:pp | pp ~~ aRoot ifTrue: [				pp name = aRoot name ifTrue: [					aRoot projectChangeSet name: ChangeSet defaultName]]]].		aRoot class class == Metaclass ifTrue: [			self declare: aRoot]].	mapFakeClassesToReal isEmpty ifFalse: [		fakes do: [:aFake | 			aFake indexIfCompact > 0 ifTrue: [aFake becomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 6/23/2000 09:55'!declare: classThatIsARoot	| nameOnArrival |	"The class just arrived in this segment.  How fit it into the Smalltalk dictionary?  If it had an association, that was installed with associationDeclareAt:."	nameOnArrival _ classThatIsARoot name.	self declareAndPossiblyRename: classThatIsARoot.	nameOnArrival == classThatIsARoot name ifTrue: [^self].	renamedClasses ifNil: [renamedClasses _ Dictionary new].	renamedClasses at: nameOnArrival put: classThatIsARoot name.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 6/22/2000 16:15'!declareAndPossiblyRename: classThatIsARoot	| existing |	"The class just arrived in this segment.  How fit it into the Smalltalk dictionary?  If it had an association, that was installed with associationDeclareAt:."	classThatIsARoot superclass name == #Player 		ifTrue: [classThatIsARoot category: Object categoryForUniclasses]		ifFalse: [classThatIsARoot category: 'Morphic-Imported'].	classThatIsARoot superclass addSubclass: classThatIsARoot.	(Smalltalk includesKey: classThatIsARoot name) ifFalse: [		"Class entry in Smalltalk not referred to in Segment, install anyway."		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	existing _ Smalltalk at: classThatIsARoot name.	existing xxxClass == ImageSegmentRootStub ifTrue: [		"We are that segment!!  Must ask it carefully!!"		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	existing == false | (existing == nil) ifTrue: [		"association is in outPointers, just installed"		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	"Conflict with existing global or copy of the class"	(existing isKindOf: Class) ifTrue: [		classThatIsARoot isSystemDefined not ifTrue: [			"UniClass.  give it a new name"			classThatIsARoot setName: Player chooseUniqueClassName.			^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].		"Take the incoming one"		self inform: 'Using newly arrived version of ', classThatIsARoot name.		classThatIsARoot superclass removeSubclass: classThatIsARoot.	"just in case"		(Smalltalk at: classThatIsARoot name) becomeForward: classThatIsARoot.		^ classThatIsARoot superclass addSubclass: classThatIsARoot].	self error: 'Name already in use by a non-class: ', classThatIsARoot name.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 6/22/2000 17:49'!scanFrom: aStream	"Move source code from a fileIn to the changes file for classes in an ImageSegment.  Do not compile the methods.  They already came in via the image segment.  After the ImageSegment in the file, !!ImageSegment new!! captures control, and scanFrom: is called."	| val chunk |	[aStream atEnd] whileFalse: 		[aStream skipSeparators.		val _ (aStream peekFor: $!!)			ifTrue: ["Move (aStream nextChunk), find the method or class 						comment, and install the file location bytes"					(Compiler evaluate: aStream nextChunk logged: false)						scanFromNoCompile: aStream forSegment: self]			ifFalse: [chunk _ aStream nextChunk.					aStream checkForPreamble: chunk.					Compiler evaluate: chunk logged: true].		aStream skipStyleChunk].	"regular fileIn will close the file"	^ val! !!ImageSegment methodsFor: 'object fileIn' stamp: 'RAA 6/23/2000 16:44'!convertasossfeu0: varDict asossfeur0: smartRefStrm	"These variables are automatically stored into the new instance #('arrayOfRoots' 'segment' 'outPointers' 'state' 'segmentName' 'fileName' 'endMarker' 'userRootCnt').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('renamedClasses')  If a non-nil value is needed, please assign it."! !!Morph methodsFor: 'geometry' stamp: 'RAA 7/4/2000 16:50'!boundsInOutermostWorld	owner ifNil: [^ bounds].	^ owner transformFromOutermostWorld localBoundsToGlobal: bounds.! !!Morph methodsFor: 'rotate scale and flex' stamp: 'RAA 7/6/2000 12:52'!addFlexShell	"Wrap a rotating and scaling shell around this morph."	| oldHalo flexMorph myWorld |	myWorld _ self world.	oldHalo _ self halo.	self owner addMorph:		(flexMorph _ self newTransformationMorph asFlexOf: self).	self transferStateToRenderer: flexMorph.	oldHalo ifNotNil: [oldHalo setTarget: flexMorph].	myWorld ifNotNil: [myWorld startSteppingSubmorphsOf: flexMorph].	^ flexMorph! !!Morph methodsFor: 'halos and balloon help' stamp: 'RAA 7/6/2000 12:54'!halo	(self world ifNil: [^nil]) haloMorphs do: [:h | h target == self ifTrue: [^ h]].	^ nil! !!Morph methodsFor: 'debug and other' stamp: 'RAA 6/28/2000 18:18'!addMouseUpAction	| codeToRun |	codeToRun _ FillInTheBlank request: 'MouseUp expression:'.	codeToRun isEmptyOrNil ifTrue: [^self].	self		on: #mouseUp 		send: #programmedMouseUp:for:with: 		to: self		withValue: codeToRun.! !!Morph methodsFor: 'debug and other' stamp: 'RAA 6/28/2000 18:16'!debuggingMenuFor: aHandMorph	| aMenu aPlayer |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	(self hasProperty: #errorOnDraw) ifTrue:		[aMenu add: 'start drawing again' action: #resumeAfterDrawError.		aMenu addLine].	(self hasProperty: #errorOnStep) ifTrue:		[aMenu add: 'start stepping again' action: #resumeAfterStepError.		aMenu addLine].	aMenu add: 'inspect morph' action: #inspectInMorphic.	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.	Smalltalk isMorphic ifFalse:		[aMenu add: 'inspect morph (in MVC)' action: #inspect].     aMenu add: 'explore morph' target: self selector: #explore.	(aPlayer _ self player) ifNotNil:		[aMenu add: 'inspect player' target: aPlayer action: #inspect.		Smalltalk isMorphic ifFalse: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic]].	aMenu addLine.	aMenu add: 'browse morph class' target: self selector: #browseHierarchy.	aPlayer ifNotNil: 		[aMenu add: 'browse player class' target: aPlayer action: #inspect].	aMenu 		addLine;		add: 'make own subclass' target: aHandMorph action: #subclassMorph;		add: 'internal name ' action: #choosePartName;		add: 'save morph in file'  action: #saveOnFile;		addLine;		add: 'call #tempCommand' target: aHandMorph action: #callTempCommand;		add: 'define #tempCommand' target: aHandMorph action: #defineTempCommand;		addLine;		add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: self;		add: 'edit balloon help' action: #editBalloonHelpText;		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction.	^ aMenu! !!Morph methodsFor: 'debug and other' stamp: 'RAA 6/28/2000 18:11'!programmedMouseUp: anEvent for: aMorph with: aCodeString	(self fullBounds containsPoint: anEvent cursorPoint) ifFalse: [^self].	Compiler evaluate: aCodeString! !!Morph methodsFor: 'debug and other' stamp: 'RAA 6/28/2000 18:18'!removeMouseUpAction	self		on: #mouseUp 		send: #yourself 		to: nil! !!Morph methodsFor: 'WiW support' stamp: 'RAA 6/29/2000 10:49'!addMorphInLayer: aMorph	submorphs do: [ :each |		each == aMorph ifTrue: [^self].		aMorph morphicLayerNumber < each morphicLayerNumber ifTrue: [			^self addMorph: aMorph inFrontOf: each		].	].	self addMorphBack: aMorph! !!Morph methodsFor: 'WiW support' stamp: 'RAA 6/27/2000 18:05'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^100		"leave lots of room for special things"! !!BalloonMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 18:07'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^5		"Balloons are very front-like things"! !!BookMorph methodsFor: 'sorting' stamp: 'RAA 6/28/2000 19:44'!acceptSortedContentsFrom: aHolder	"Update my page list from the given page sorter."	| goodPages rejects toAdd sqPage |	goodPages _ OrderedCollection new.	rejects _ OrderedCollection new.	aHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: PasteUpMorph) ifTrue: [toAdd _ m].		(m isKindOf: BookPageThumbnailMorph) ifTrue: [			toAdd _ m page.			m bookMorph == self ifFalse: [				"borrowed from another book. preserve the original"				toAdd _ toAdd veryDeepCopy.					"since we came from elsewhere, cached strings are wrong"				self removeProperty: #allTextUrls.				self removeProperty: #allText.			].		].		toAdd class == String ifTrue: ["a url"			toAdd _ pages detect: [:aPage | aPage url = toAdd] ifNone: [toAdd]].		toAdd class == String ifTrue: [			sqPage _ SqueakPageCache atURL: toAdd.			toAdd _ sqPage contentsMorph 				ifNil: [sqPage copyForSaving]	"a MorphObjectOut"				ifNotNil: [sqPage contentsMorph]].		toAdd ifNil: [rejects add: m]			ifNotNil: [goodPages add: toAdd]].	self newPages: goodPages.	goodPages size = 0 ifTrue: [self insertPage].	rejects size > 0 ifTrue: [self inform: rejects size printString, ' objects vanished in this process.']! !!BookMorph methodsFor: 'menu' stamp: 'RAA 7/5/2000 11:25'!getStemUrl	"Try to find the old place where this book was stored. Confirm with the 	user. Else ask for new place."	| initial pg url knownURL |	knownURL _ false.	initial _ ''.	(pg _ currentPage valueOfProperty: #SqueakPage)		ifNotNil: [pg contentsMorph == currentPage				ifTrue: [initial _ pg url.					knownURL _ true]].	"If this page has a url"	pages		doWithIndex: [:aPage :ind | initial isEmpty				ifTrue: [aPage isInMemory						ifTrue: [(pg _ aPage valueOfProperty: #SqueakPage)								ifNotNil: [initial _ pg url]]]].	"any page with a url"	initial isEmpty		ifTrue: [initial _ ServerDirectory defaultStemUrl , '1.sp'].	"A new legal place"	url _ knownURL		ifTrue: [initial]		ifFalse: [[FillInTheBlank request: 'url of the place to store a typical page in this book.Must begin with file:// or ftp://' initialAnswer: initial]				valueWithWorld: self world].	^ SqueakPage stemUrl: url! !!BookMorph methodsFor: 'menu' stamp: 'RAA 7/5/2000 11:14'!reload	"Fetch the pages of this book from the server again.  For all pages that have not been modified, keep current ones.  Use new pages.  For each, look up in cache, if time there is equal to time of new, and its in, use the current morph.	Later do fancy things when a page has changed here, and also on the server."	| url onServer onPgs sq which |	(url _ self valueOfProperty: #url) ifNil: ["for .bo index file"		[			url _ FillInTheBlank 				request: 'url of the place where this book''s index is stored.Must begin with file:// or ftp://' 				initialAnswer: (self getStemUrl, '.bo').		] valueWithWorld: self world.		url size > 0 ifTrue: [self setProperty: #url toValue: url]			ifFalse: [^ self]].	onServer _ self class new fromURL: url.	"Later: test book times?"	onPgs _ onServer pages collect: [:out |		sq _ SqueakPageCache pageCache at: out url ifAbsent: [nil].		(sq ~~ nil and: [sq contentsMorph isInMemory])			ifTrue: [((out sqkPage lastChangeTime > sq lastChangeTime) or: 					  [sq contentsMorph == nil]) 						ifTrue: [SqueakPageCache atURL: out url put: out sqkPage.							out]						ifFalse: [sq contentsMorph]]			ifFalse: [SqueakPageCache atURL: out url put: out sqkPage.				out]].	which _ (onPgs findFirst: [:pg | pg url = currentPage url]) max: 1.	self newPages: onPgs currentIndex: which.		"later stay at current page"	self setProperty: #modTime toValue: (onServer valueOfProperty: #modTime).	self setProperty: #allText toValue: (onServer valueOfProperty: #allText).	self setProperty: #allTextUrls toValue: (onServer valueOfProperty: #allTextUrls).! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 12:12'!addControls	| b r aButton str |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow color: Color transparent; borderWidth: 0; inset: 0.	r centering: #center; hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (self wrapperFor: (b fullCopy label: 'Okay';	actionSelector: #acceptSort)).	r addMorphBack: (self wrapperFor: (b fullCopy label: 'Cancel';	actionSelector: #delete)).	r addTransparentSpacerOfSize: 8 @ 0.	r addMorphBack: (self wrapperFor: (aButton _ UpdatingThreePhaseButtonMorph checkBox)).	aButton		target: self;		actionSelector: #togglePartsBinStatus;		arguments: #();		getSelector: #getPartsBinStatus.	str _ StringMorph contents: 'Parts bin'.	r addMorphBack: (self wrapperFor: str lock).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 12:09'!columnWith: aMorph	^AlignmentMorph newColumn		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		centering: #center;		inset: 1;		addMorph: aMorph! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 11:57'!getPartsBinStatus	^pageHolder isPartsBin! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 12:09'!rowWith: aMorph	^AlignmentMorph newColumn		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		centering: #center;		inset: 1;		addMorph: aMorph! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 11:58'!togglePartsBinStatus	pageHolder isPartsBin: pageHolder isPartsBin not! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 12:10'!wrapperFor: aMorph	^self columnWith: (self rowWith: aMorph)! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 11:12'!bookMorph	^bookMorph! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 18:44'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	self firstSubmorph firstSubmorph						"quick hack since this is the only usage pattern at the moment"		addScalingMenuItems: menu 		hand: aHandMorph! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 19:10'!extent: aPoint	bounds extent = aPoint ifFalse: [		self changed.		bounds _ bounds topLeft extent: aPoint.		self myWorldChanged.	].! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 18:47'!fixLayout	submorphs size < 1 ifTrue: [^super fixLayout].	self firstSubmorph bounds: self innerBounds.! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 18:46'!initialize	super initialize.	orientation _ #vertical.	inset _ 0.	borderWidth _ 0.	hResizing _ #rigid.	vResizing _ #rigid.! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 18:45'!minHeight	^minHeight ifNil: [super minHeight]! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 18:45'!minHeight: anInteger	minHeight _ anInteger! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 18:46'!minWidth	^minWidth ifNil: [super minWidth]! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 18:46'!minWidth: anInteger	minWidth _ anInteger! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 19:23'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^20		"Embedded worlds come in front of other worlds' Project navigation morphs"! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 19:23'!myWorldChanged	self layoutChanged.	submorphs isEmpty ifFalse: [		self firstSubmorph extentFromParent: self innerBounds extent.		bounds _ bounds topLeft extent: self firstSubmorph extent + (borderWidth * 2).	].	self changed.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 19:12'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^7		"Halos are very front-like things"! !!HandMorph methodsFor: 'accessing' stamp: 'RAA 7/3/2000 10:36'!setArgument: aMorph	"targetOffset _ menuTargetOffset _ self position."	self flag: #bob.		"do we need this?"	targetOffset _ menuTargetOffset _ aMorph world globalPointToLocal: self position.	argument _ aMorph.! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 7/4/2000 17:43'!handleMouseOver: evt	| mList allMouseOvers leftMorphs enteredMorphs now t oldHalo balloonHelpEnabled localEvt |		self worldUnderCursor ifNil: [^ self].	balloonHelpEnabled _ Preferences balloonHelpEnabled.	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	now _ Time millisecondClockValue.	"Make a list of all potential mouse-overs..."	allMouseOvers _ mList select:		[:m | m wantsHalo or: [(balloonHelpEnabled and: [m wantsBalloon])  "To start a timer"			or: [m handlesMouseOver: (evt transformedBy: (m transformFrom: self))]  "To send mouseEnter:"]].	leftMorphs _ mouseOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (mouseOverMorphs includes: m) not].	"Notify and remove any mouse-overs that have just been left..."	leftMorphs do: [:m |		mouseOverMorphs remove: m.		m wantsBalloon ifTrue: [m deleteBalloon].		m mouseLeave: (evt transformedBy: (m transformFrom: self)).		mouseOverTimes removeKey: m ifAbsent: [] ].	"Add any new mouse-overs and send mouseEnter: and/or start timers..."	enteredMorphs do: [:m |		localEvt _ evt transformedBy: (m transformFrom: self).		mouseOverMorphs add: m.		dragOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		(m handlesMouseOver: localEvt) ifTrue:			[m mouseEnter: localEvt].		(m wantsHalo or: [m wantsBalloon]) ifTrue:			[mouseOverTimes at: m put: now]].	mouseOverTimes keys do:		[:m | "Check pending timers for lingering"		t _ mouseOverTimes at: m.		(now < t "rollover" or: [now > (t+800)]) ifTrue:			["Yes we have lingered for 0.8 seconds..."			mouseOverTimes removeKey: m.			m owner ifNotNil:  "Not deleted during linger (--it happens ;--)"				[m wantsHalo					ifTrue: [oldHalo _ m world haloMorphOrNil.							(oldHalo == nil or: [oldHalo target ~~ m])								ifTrue: ["Put up halo for m"										self popUpHaloFor: m event: evt.										(balloonHelpEnabled and: [m wantsBalloon]) ifTrue:											["...and reschedule balloon after longer linger"											mouseOverTimes at: m put: now]]								ifFalse: ["Halo for m is already up, so show balloon"										(balloonHelpEnabled and: [m wantsBalloon])											ifTrue: [m showBalloon: m balloonText]]]					ifFalse:						[(balloonHelpEnabled and: [m wantsBalloon])							ifTrue: [m showBalloon: m balloonText]]]]]! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 7/3/2000 11:02'!grabMorph: aMorph	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor |	aMorph isTileLike ifTrue: [		editor _ aMorph topEditor	].	(aMorph owner isKindOf: DropShadowMorph) ifTrue: [		self grabMorph: aMorph owner.		^ editor ifNotNil: [editor scriptEdited]	].	self grabMorphInner: ((aMorph aboutToBeGrabbedBy: self) ifNil: [^self]).	editor ifNotNil: [editor scriptEdited].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 7/3/2000 10:52'!grabMorphFromMenu: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	(m owner isKindOf: DropShadowMorph)		ifTrue: [^ self grabMorphFromMenu: m owner].	m aboutToBeGrabbedBy: self.	self grabMorphInner: m.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 7/3/2000 11:03'!grabMorphInner: m	| myPos morphPos localPt trans morphToGrab newT |	formerOwner _ m owner.	formerPosition _ m position.	"Check if the morph will keep it's transform while grabbed"	myPos _ self position.	morphPos _ m position.	(m keepsTransform or: [formerOwner isNil])		ifTrue:[localPt _ myPos]		ifFalse:[localPt _ (m world globalPointToLocal: myPos) truncated].	(formerOwner == nil		or: [m keepsTransform			or: [(trans _ formerOwner transformFromOutermostWorld) isPureTranslation]]) ifTrue: [		m position: myPos + (morphPos - localPt).		morphToGrab _ m.		addedFlexAtGrab _ false.	] ifFalse: ["Morph was in a flexed environment.  Flex it in the hand."		morphToGrab _ m addFlexShell transform: trans asMorphicTransform.		m position: morphPos.  "revert offset from addFlexShell"		newT _ trans withOffset: (trans offset + (trans localPointToGlobal: localPt) - myPos).		morphToGrab position: (morphToGrab localPointToGlobal: morphToGrab position).		morphToGrab transform: newT.		addedFlexAtGrab _ true.	].	gridOn ifTrue: [morphToGrab position: (morphToGrab position grid: grid)].	self addMorphBack: morphToGrab.! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 7/3/2000 11:03'!duplicateMorph	| newMorph aName usedNames |	newMorph _ argument veryDeepCopy.	(aName _ argument knownName) ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo:			(Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	self grabMorphFromMenu: newMorph.	"formerPosition _ argument position."	newMorph player ifNotNil: [newMorph player startRunning].	^ newMorph! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/27/2000 09:11'!newDrawingFromMenu	self flag: #bob.		"possible world confusion here"	self world assureNotPaintingElse: [^ self].	self attachMorph: PaintInvokingMorph new markAsPartsDonor! !!HandMorph methodsFor: 'world menu commands' stamp: 'RAA 6/30/2000 08:50'!unlockContents	argument unlockContents! !!MenuMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 18:07'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^10		"Menus are very front-like things"! !!Object class methodsFor: 'instance creation' stamp: 'RAA 6/22/2000 14:14'!categoryForUniclasses	"Answer the category into which to place unique-class instances"	^ 'Morphic-UserObjects'! !!Celeste class methodsFor: 'instance creation' stamp: 'RAA 6/30/2000 12:36'!openOnDatabase: aMailDB	"Open a MailReader on the given mail database."	| model views buttons topWindow |	model _ self new openOnDatabase: aMailDB.	views _ self buildViewsFor: model.	buttons _ self buildButtonsFor: model.	Smalltalk isMorphic		ifTrue: 			[topWindow _ (SystemWindow labelled: 'Celeste') model: model.			topWindow addMorph: (buttons at: 1) frame: (0.0 @ 0.0 extent: 0.125 @ 0.05).			topWindow addMorph: (buttons at: 2) frame: (0.125 @ 0.0 extent: 0.125 @ 0.05).			topWindow addMorph: (buttons at: 3) frame: (0.25 @ 0.0 extent: 0.125 @ 0.05).			topWindow addMorph: (buttons at: 4) frame: (0.375 @ 0.0 extent: 0.125 @ 0.05).			topWindow addMorph: (buttons at: 5) frame: (0.5 @ 0.0 extent: 0.125 @ 0.05).			topWindow addMorph: (buttons at: 6) frame: (0.625 @ 0.0 extent: 0.125 @ 0.05).			topWindow addMorph: (buttons at: 7) frame: (0.75 @ 0.0 extent: 0.125 @ 0.05).			topWindow addMorph: (buttons at: 8) frame: (0.875 @ 0.0 extent: 0.125 @ 0.05).			topWindow addMorph: (views at: 1) frame: (0.0 @ 0.05 extent: 0.2 @ 0.25).			topWindow addMorph: (views at: 2) frame: (0.2 @ 0.05 extent: 0.8 @ 0.25).			topWindow addMorph: (views at: 3) frame: (0.0 @ 0.3 extent: 1.0 @ 0.65).			topWindow addMorph: (views at: 4) frame: (0.0 @ 0.95 extent: 1.0 @ 0.05).			buttons do: [:b | b onColor: Color lightGray offColor: Color white].			topWindow openInWorld]		ifFalse: 			[topWindow _ StandardSystemView new model: model;					 label: 'Celeste';					 minimumSize: 400 @ 250.			(views at: 1) window: (0 @ 0 extent: 20 @ 25).			(views at: 2) window: (0 @ 0 extent: 80 @ 25).			(views at: 3) window: (0 @ 0 extent: 100 @ 70).			(buttons at: 1) window: (0 @ 0 extent: 12 @ 5).			(buttons at: 2) window: (0 @ 0 extent: 12 @ 5).			(buttons at: 3) window: (0 @ 0 extent: 12 @ 5).			(buttons at: 4) window: (0 @ 0 extent: 10 @ 5).			(buttons at: 5) window: (0 @ 0 extent: 13 @ 5).			(buttons at: 6) window: (0 @ 0 extent: 13 @ 5).			(buttons at: 7) window: (0 @ 0 extent: 15 @ 5).			(buttons at: 8) window: (0 @ 0 extent: 13 @ 5).			topWindow addSubView: (buttons at: 1);			 addSubView: (buttons at: 2) toRightOf: (buttons at: 1);			 addSubView: (buttons at: 3) toRightOf: (buttons at: 2);			 addSubView: (buttons at: 4) toRightOf: (buttons at: 3);			 addSubView: (buttons at: 5) toRightOf: (buttons at: 4);			 addSubView: (buttons at: 6) toRightOf: (buttons at: 5);			 addSubView: (buttons at: 7) toRightOf: (buttons at: 6);			 addSubView: (buttons at: 8) toRightOf: (buttons at: 7);			 addSubView: (views at: 1) below: (buttons at: 1);			 addSubView: (views at: 2) toRightOf: (views at: 1);			 addSubView: (views at: 3) below: (views at: 1).			topWindow controller open].	^model		"in case the sender wants to know"! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 14:49'!fancyText: aString ofSize: pointSize color: aColor	| answer tm |	answer _ self inAColumn: (		tm _ TextMorph new 			beAllFont: ((TextStyle default fontOfSize: pointSize) emphasized: 1);			color: aColor;			contents: aString	).	tm addDropShadow.	tm owner shadowPoint: (5@5) + tm owner bounds center.	tm lock.	^answer! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 14:32'!fill: aMorph with: rampSpecs oriented: aRatio	| fill |	fill _ GradientFillStyle ramp: rampSpecs.	fill origin: aMorph bounds topLeft.	fill direction: (aMorph bounds extent * aRatio) truncated.	fill radial: false.	aMorph fillStyle: fill.! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 10:22'!inAColumn: aMorphOrCollection 	| answer |	answer _ AlignmentMorph newColumn		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent; 		centering: #center;		inset: 0.	aMorphOrCollection isMorph ifTrue: [		answer addMorphBack: aMorphOrCollection	] ifFalse: [		aMorphOrCollection do: [ :each | answer addMorphBack:  each].	].	^answer! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 10:37'!inARow: aMorphOrCollection	| answer |	answer _ AlignmentMorph newRow		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent; 		centering: #center;		inset: 4.	aMorphOrCollection isMorph ifTrue: [		answer addMorphBack: aMorphOrCollection	] ifFalse: [		aMorphOrCollection do: [ :each | answer addMorphBack:  each].	].	^answer! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 16:30'!modalFolderSelector	| window fileModel |	window _ self morphicViewFolderSelector.	fileModel _ window model.	window openInWorld: self currentWorld extent: 300@400.	[window world notNil] whileTrue: [		window outermostWorldMorph doOneCycleNow.	].	^fileModel getSelectedDirectory withoutListWrapper! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 11:01'!modalFolderSelectorForProject: aProject"FileList2 modalFolderSelectorForProject: Project current"	| window fileModel w |	window _ FileList2 morphicViewProjectSaverFor: aProject.	fileModel _ window valueOfProperty: #FileList.	w _ self currentWorld.	window position: w topLeft + (w extent - window extent // 2).	window openInWorld: w.	[window world notNil] whileTrue: [		window outermostWorldMorph doOneCycleNow.	].	^fileModel getSelectedDirectory withoutListWrapper! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 16:35'!morphicViewFolderSelector	| dir aFileList window fileListTop buttonTop |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	aFileList optionalButtonSpecs: self specsForFolderSelector.	window _ (SystemWindow labelled: dir pathName) model: aFileList.	aFileList modalView: window.	buttonTop _ 0.08.	fileListTop _ 0.16.	self addPanesTo: window from: {		{self textRow: 'Please select a folder'. 0 @ 0 corner: 1 @ buttonTop}.		{aFileList optionalButtonRow. 0 @ buttonTop corner: 1 @ fileListTop}.		{aFileList morphicDirectoryTreePane. 0@fileListTop corner: 1@1}.	}.	aFileList postOpen.	^ window ! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 14:52'!morphicViewProjectSaverFor: aProject"(FileList2 morphicViewProjectSaverFor: Project current) openInWorld"	| window dir aFileList buttons ramp1 ramp2 ramp3 treePane pane2 textColor1 |	textColor1 _ Color r: 0.742 g: 0.839 b: 1.0.	ramp1 _ {		0.0->(Color r: 0.516 g: 0.645 b: 1.0).		1.0->(Color r: 0.742 g: 0.871 b: 1.0)	}.	ramp3 _ {		0.0->(Color r: 0.742 g: 0.871 b: 1.0).		1.0->(Color r: 0.516 g: 0.645 b: 1.0).	}.	ramp2 _ {		0.0->(Color r: 0.516 g: 0.645 b: 1.0).		1.0->(TranslucentColor r: 0.645 g: 0.968 b: 1.0 alpha: 0.56078431372549)	}.	dir _ FileDirectory default.	aFileList _ self new directory: dir.	window _ AlignmentMorph newColumn.	aFileList modalView: window.	window		setProperty: #FileList toValue: aFileList;		centering: #center;		borderWidth: 4;		borderColor: (Color r: 0.355 g: 0.516 b: 1.0);		useRoundedCorners.	buttons _ #('OK' 'Cancel') collect: [ :each |		 (self fancyText: each ofSize: 15 color: textColor1)			hResizing: #rigid;			extent: 100@20;			inset: 4;			borderWidth: 0;			useRoundedCorners	].	treePane _ aFileList morphicDirectoryTreePane 		extent: 350@300; 		retractable: false;		borderWidth: 0.	window		addMorphBack: (self inARow: (			self fancyText: 'Publish This Project' ofSize: 21 color: textColor1		));		addMorphBack: (self inARow: {							buttons first. 							(Morph new extent: 30@5) color: Color transparent. 							buttons second						}		);		addMorphBack: (self inARow: (ProjectViewMorph on: aProject) lock);		addMorphBack: (self inARow: (			self fancyText: 'Please select a folder' ofSize: 21 color: Color blue		));		addMorphBack: (			(self inAColumn: ((pane2 _ self inARow: (self inAColumn: treePane)) 				useRoundedCorners; inset: 6)) inset: 10		).	window fixLayout.	window fullBounds.	self fill: window with: ramp1 oriented: 0.65.	self fill: pane2 with: ramp3 oriented: (0.7 @ 0.35).	buttons do: [ :each |		self fill: each with: ramp2 oriented: (0.75 @ 0).	].	buttons first on: #mouseUp send: #okHit to: aFileList.	buttons second on: #mouseUp send: #cancelHit to: aFileList.	^ window ! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/2000 12:03'!specsForFolderSelector	^ #(	('OK' 			okHit				sortingByName	'use the currently selected directory')('Cancel'		cancelHit			sortingByDate	'cancel this request')	)! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 16:41'!textRow: aString 	^AlignmentMorph newRow 		centering: #center;		inset: 0;		addMorph: (			AlignmentMorph newColumn			centering: #center;			color: Color transparent;			vResizing: #shrinkWrap;			inset: 0;			addMorph: (				AlignmentMorph newRow				centering: #center;				color: Color transparent;				hResizing: #shrinkWrap;				vResizing: #shrinkWrap;				inset: 0;				addMorph: ((StringMorph contents: aString) color: Color blue; lock)			)		)! !!GZipSurrogateStream class methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 11:50'!newFileNamed: fName inDirectory: aDirectory	^self new newFileNamed: fName inDirectory: aDirectory! !!Password methodsFor: 'accessing' stamp: 'RAA 6/23/2000 09:40'!passwordFor: serverDir	"Returned the password from one of many sources.  OK if send in a nil arg."	| sp msg |	cache ifNotNil: [^ cache].	sequence ifNotNil: [		(sp _ self serverPasswords) ifNotNil: [			sequence <= sp size ifTrue: [^ sp at: sequence]]].	msg _ (serverDir isKindOf: ServerDirectory)		ifTrue: [serverDir moniker]		ifFalse: ['this directory'].	(serverDir user = 'anonymous') & (serverDir isTypeFTP) ifTrue: [			^ cache _ FillInTheBlank request: 'Please let this anonymous ftp\server know your email address.\This is the polite thing to do.' withCRs			initialAnswer: 'yourName@company.com'].	^ cache _ FillInTheBlank request: 'Password for ', msg, ':'.		"Diff between empty string and abort?"! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/26/2000 11:20'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	self addStackMenuItems: menu hand: aHandMorph.	self addPenMenuItems: menu hand: aHandMorph.	self addPlayfieldMenuItems: menu hand: aHandMorph.	(self isWorldMorph and: [owner isKindOf: BOBTransformationMorph]) ifTrue: [		self addScalingMenuItems: menu hand: aHandMorph.	].	menu addLine! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 7/4/2000 09:56'!addScalingMenuItems: menu hand: aHandMorph	| subMenu |	(subMenu _ MenuMorph new)		defaultTarget: self;		add: 'show application view' action: #showApplicationView;		add: 'show factory view' action: #showFactoryView;		add: 'expand' action: #showExpandedView;		add: 'reduce' action: #showReducedView;		addLine;		add: 'define application view' action: #defineApplicationView;		add: 'define factory view' action: #defineFactoryView.	menu		add: 'world scale and clip...'		subMenu: subMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/26/2000 11:31'!defineApplicationView	| r |	r _ Rectangle fromUser.	self 		setProperty: #applicationViewBounds 		toValue: ((self transformFromOutermostWorld) globalBoundsToLocal: r) truncated ! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/26/2000 11:29'!defineFactoryView	| r |	r _ Rectangle fromUser.	self 		setProperty: #factoryViewBounds 		toValue: ((self transformFromOutermostWorld) globalBoundsToLocal: r) truncated ! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/26/2000 11:33'!showApplicationView	self transformToShow: (self valueOfProperty: #applicationViewBounds ifAbsent: [bounds])		! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/26/2000 11:47'!showExpandedView	owner	"the transform"		owner	"the green border"			bounds: Display boundingBox! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/26/2000 11:33'!showFactoryView	self transformToShow: (self valueOfProperty: #factoryViewBounds ifAbsent: [bounds])		! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/26/2000 11:46'!showReducedView	| r |	r _ Display extent // 4 extent: Display extent // 2.	owner	"the transform"		owner	"the green border"			bounds: r! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/26/2000 19:10'!transformToShow: aRectangle	owner changeWorldBoundsToShow: aRectangle! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/26/2000 19:11'!installAsActiveSubprojectIn: enclosingWorld at: newBounds titled: aString	| window howToOpen tm boundsForWorld |	howToOpen _ self embeddedProjectDisplayMode.	submorphs do: [:ss | ss owner == nil ifTrue: [ss privateOwner: self]].		"Transcript that was in outPointers and then got deleted."	boundsForWorld _ howToOpen == #naked ifTrue: [newBounds] ifFalse: [bounds].	worldState canvas: nil.	worldState viewBox: boundsForWorld.	self bounds: boundsForWorld.	"self viewBox: Display boundingBox."	"worldState handsDo: [:h | h initForEvents]."	self installFlaps.	"SystemWindow noteTopWindowIn: self."	"self displayWorldSafely."	howToOpen == #naked ifTrue: [		enclosingWorld addMorphFront: self.	].	howToOpen == #window ifTrue: [		window _ (NewWorldWindow labelled: aString) model: self.		window addMorph: self frame: (0@0 extent: 1.0@1.0).		window openInWorld: enclosingWorld.	].	howToOpen == #frame ifTrue: [		window _ AlignmentMorphBob1 new			minWidth: 100;			minHeight: 100;			borderWidth: 8;			borderColor: Color green;			heights: #(999999);			bounds: newBounds.		window addMorph: self.		window openInWorld: enclosingWorld.	].	howToOpen == #scaled ifTrue: [		self position: 0@0.		window _ EmbeddedWorldBorderMorph new			minWidth: 100;			minHeight: 100;			borderWidth: 8;			borderColor: Color green;			bounds: newBounds.		tm _ BOBTransformationMorph new.		window addMorph: tm.		tm addMorph: self.		window openInWorld: enclosingWorld.		tm changeWorldBoundsToShow: bounds.		"tm scale: (tm width / self width min: tm height / self height) asFloat."	].! !!Project methodsFor: 'initialization' stamp: 'RAA 6/30/2000 11:23'!initMorphic	"Written so that Morphic can still be removed."	Smalltalk verifyMorphicAvailability ifFalse: [^ nil].	self initialize.	world _ PasteUpMorph newWorldForProject: self.! !!Project methodsFor: 'initialization' stamp: 'RAA 6/21/2000 22:59'!setChangeSet: aChangeSet	isolatedHead == true ifTrue: [^ self].  "ChangeSet of an isolated project cannot be changed"	changeSet _ aChangeSet! !!Project methodsFor: 'accessing' stamp: 'RAA 6/21/2000 19:24'!lastDirectory: aDirectoryOrNil	lastDirectory _ aDirectoryOrNil! !!Project methodsFor: 'file in/out' stamp: 'tk 6/21/2000 16:21'!armsLengthCommand: aCommand	| pvm |	"Set things up so that this aCommand is sent to self as a messageafter jumping to the parentProject.  For things that can't be executedwhile in this project, such as saveAs, loadFromServer, storeOnServer.  SeeProjectViewMorph step."	parentProject ifNil: [^ self inform: 'The top project can''t do that'].	pvm _ parentProject findProjectView: self.	parentProject isMorphic		ifTrue: [			pvm setProperty: #armsLengthCmd toValue: aCommand.			pvm setProperty: #wasStepping toValue: false.			pvm world startStepping: pvm]		ifFalse: [			pvm armsLengthCommand: (Array with: self with:aCommand).			].	self exit.! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 12:48'!bumpVersion: versString	| versInteger |	"Version is literal piece of file name.  Mime encoded and http encoded.  Decode and add one."	versString ifNil: [^'AA'].	versInteger _ versString isInteger ifTrue: [		versString	] ifFalse: [		Base64MimeConverter decodeInteger: versString unescapePercents	].	^ (Base64MimeConverter encodeInteger: versInteger + 1) encodeForHTTP! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 13:12'!currentVersionNumber	version ifNil: [^0].	^Base64MimeConverter decodeInteger: version unescapePercents! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/30/2000 11:36'!decideAboutCreatingBlank: otherProjectName	| resp |	version isNil ifFalse: [	"if saved, then maybe don't create"		resp _ (PopUpMenu labels: 'Yes, make it up\No, skip it' withCRs) 			startUpWithCaption: (				'I cannot locate the project\',				otherProjectName,				'\Would you like me to create a new project\with that name?'			) withCRs.		resp = 1 ifFalse: [^ nil]	].	^Project openBlankProjectNamed: otherProjectName! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 12:37'!exportSegment	"Store my project out on the disk as an *exported* ImageSegment.  Put all outPointers in a form that can be resolved in the target image.  Name it <project name>.extSeg.	Player classes are included automatically."	self flag: #bob.		"probably can be deleted"	^ self exportSegmentWithCatagories: #() classes: #()! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 12:34'!exportSegmentFileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  Put all outPointers in a form that can be resolved in the target image.  Name it <project name>.extSeg.	Player classes are included automatically."	^ self exportSegmentWithCatagories: #() classes: #() fileName: aFileName directory: aDirectory! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 12:37'!exportSegmentWithCatagories: catList classes: classList	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."| is str ans revertSeg roots holder |	self flag: #bob.		"probably can be deleted""world == World ifTrue: [^ false]."	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.Display checkCurrentHandForObjectToPaste.world fullReleaseCachedState. world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages.holder _ Project allInstances.	"force them in to outPointers, where DiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ OrderedCollection new.roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).catList do: [:sysCat | 	(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |		roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].is _ ImageSegment new copyFromRootsForExport: roots asArray.	"world, and all Players"is state = #tooBig ifTrue: [^ false].str _ ''.is segment size < 3000 ifTrue: [	str _ 'Segment is only ', is segment size printString, ' long.'].(is outPointers detect: [:out | out isMorph] ifNone: [nil]) ifNotNil: [	str _ str, '\Morphs are pointed at from the outside.' withCRs].(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		^ false].	ans = 3 ifTrue: [self halt: 'Segment not written']].is writeForExportWithSources: self name, '.pr' inDirectory: self squeakletDirectory.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.^ true! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 12:34'!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."| is str ans revertSeg roots holder |"world == World ifTrue: [^ false]."	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.Display checkCurrentHandForObjectToPaste.world fullReleaseCachedState. world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages.holder _ Project allInstances.	"force them in to outPointers, where DiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ OrderedCollection new.roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).catList do: [:sysCat | 	(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |		roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].is _ ImageSegment new copyFromRootsForExport: roots asArray.	"world, and all Players"is state = #tooBig ifTrue: [^ false].str _ ''.is segment size < 3000 ifTrue: [	str _ 'Segment is only ', is segment size printString, ' long.'].(is outPointers detect: [:out | out isMorph] ifNone: [nil]) ifNotNil: [	str _ str, '\Morphs are pointed at from the outside.' withCRs].(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		^ false].	ans = 3 ifTrue: [self halt: 'Segment not written']].is writeForExportWithSources: aFileName inDirectory: aDirectory.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.^ true! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/30/2000 11:14'!findAFolderToStoreProjectIn	"Alan wants something prettier with a default"	self couldOpenInMorphic ifTrue: [		^FileList2 modalFolderSelectorForProject: self	] ifFalse: [		^PluggableFileList getFolderDialog openLabel: 'Select a folder on a server:'	]! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/30/2000 11:30'!fromMyServerLoad: otherProjectName	| servers pair pr dirToUse |	"If a newer version of me is on the server, load it."	(pr _ Project named: otherProjectName) ifNotNil: ["it appeared"		^ pr enter	].	(servers _ self serverList) isEmpty ifTrue: [		lastDirectory ifNil: [			self inform: 'Current project does not know a server either.'.			^nil		].		dirToUse _ lastDirectory.	] ifFalse: [		dirToUse _ servers first.	].	pair _ self class mostRecent: otherProjectName onServer: dirToUse.	pair first ifNil: [^self decideAboutCreatingBlank: otherProjectName].	"nothing to load"	^self installRemoteNamed: pair first from: dirToUse named: otherProjectName.! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/27/2000 19:26'!installRemoteFrom: strm named: otherProjectName	| projViewer is proj |	"Find the current ProjectViewMorph, fetch the project, install in ProjectViewMorph without changing size, and jump into new project."	ProgressNotification signal: '2 streamSize ',strm size printString.	projViewer _ self findProjectView: otherProjectName.	projViewer ifNil: [		"(SelectionMenu confirm: 'No old thumbnail found. Debug?') ifTrue: [self halt]."		ProjectViewMorph openFromFile: strm.		"Later check rest of servers if fails.  Still have list here"		^self	].	is _ strm asUnZippedStream.	ProgressNotification  signal: '3 unzipped'.	is _ is fileInObjectAndCode.	ProgressNotification  signal: '4 filedIn'.	(is isKindOf: ImageSegment) ifTrue: [		proj _ is arrayOfRoots detect: [:mm | mm class == Project] 					ifNone: [nil].		proj ifNotNil: [			proj versionFrom: strm.			(projViewer project isKindOf: DiskProxy) ifFalse: [				projViewer project changeSet name: ChangeSet defaultName].			proj changeSet name: otherProjectName.			CurrentProjectRefactoring currentBeParentTo: proj.			(projViewer owner isKindOf: SystemWindow) ifTrue: [				projViewer owner model: proj].			projViewer project: proj.			"stop background drawing NOW"			ProgressNotification  signal: '9999 about to enter project'.				^ ProjectEntryNotification signal: proj		]	].	ProjectViewMorph openFromFile: strm.	"Later check rest of servers if fails.  Still have list here"! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 12:53'!loadFromServer: newerAutomatically	| servers pair resp |	"If a newer version of me is on the server, load it."	self isCurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #loadFromServer].	(servers _ self serverList) isEmpty 		ifTrue: [^ self inform: 'This project thinks it has never been on a server'].	pair _ self class mostRecent: self name onServer: servers first.	pair first ifNil: [^ self inform: 'can''t find file on server for ', self name].	self currentVersionNumber > pair second ifTrue: [		^ self inform: 'That server has an older version of the project.'].	version = (pair first findTokens: '|.') second ifTrue: [		resp _ (PopUpMenu labels: 'Reload anyway\Cancel' withCRs) startUpWithCaption: 					'The only changes are the ones you made here.'.		resp ~= 1 ifTrue: [^ nil]	] ifFalse: [		newerAutomatically ifFalse: [			resp _ (PopUpMenu labels: 'Load it\Cancel' withCRs) startUpWithCaption: 						'A newer version exists on the server.'.			resp ~= 1 ifTrue: [^ nil]		].	].	"Find parent project, go there, zap old thumbnail"	parentProject installRemoteNamed: pair first from: servers first named: self name.! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 12:43'!setVersionFromInteger: anInteger	"Version is literal piece of file name.  Mime encoded and http encoded."	version _ (Base64MimeConverter encodeInteger: anInteger) encodeForHTTP! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 11:54'!squeakletDirectory	| squeakletDirectoryName |	squeakletDirectoryName _ 'Squeaklets'.	(FileDirectory default directoryExists: squeakletDirectoryName) ifFalse: [		FileDirectory default createDirectory: squeakletDirectoryName	].	^FileDirectory default directoryNamed: squeakletDirectoryName! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/21/2000 08:26'!storeOnServer	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	world setProperty: #optimumExtentFromAuthor toValue: world extent.	self hasBadNameForStoring ifTrue: [		^self inform: 'The name of this project may cause problems when stored in a file.Please fix it and try again.'	].	self isCurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #storeOnServer].	self storeOnServerWithProgressInfo.! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 13:46'!storeOnServerInnards	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	| servers resp newName local primaryServerDirectory serverVersionPair localDirectory localVersionPair myVersionNumber warning maxNumber |	"Find out what version"	(servers _ self serverList) isEmpty ifTrue: [		(primaryServerDirectory _ self findAFolderToStoreProjectIn) ifNotNil: [			servers _ Array with: primaryServerDirectory.			urlList _ Array with: primaryServerDirectory realUrl, '/'.		].	] ifFalse: [		primaryServerDirectory _ servers first.	].	localDirectory _ self squeakletDirectory.	serverVersionPair _ self class mostRecent: self name onServer: primaryServerDirectory.	localVersionPair _ self class mostRecent: self name onServer: localDirectory.	maxNumber _ myVersionNumber _ self currentVersionNumber.	warning _ ''.	myVersionNumber < serverVersionPair second ifTrue: [		warning _ warning,'\There are newer version(s) on the server'.		maxNumber _ maxNumber max: serverVersionPair second.	].	myVersionNumber < localVersionPair second ifTrue: [		warning _ warning,'\There are newer version(s) in the local directory'.		maxNumber _ maxNumber max: localVersionPair second.	].	warning isEmpty ifFalse: [		myVersionNumber = 0 ifTrue: [			warning _ warning,'\THIS PROJECT HAS NEVER BEEN SAVED'		].		warning _ 'WARNING', '\Project: ',self name,warning.		resp _ (PopUpMenu labels: 'Store anyway\Cancel' withCRs) startUpWithCaption: 			(warning, '\Please cancel, rename this project, and see what is there.') withCRs.			resp ~= 1 ifTrue: [^ nil]	].	version _ self bumpVersion: maxNumber.	"write locally - now zipped automatically"	newName _ self versionedFileName.	self exportSegmentFileName: newName directory: localDirectory.			primaryServerDirectory ifNotNil: [		local _ localDirectory oldFileNamed: newName.		resp _ primaryServerDirectory putFile: local named: newName retry: false.		local close.		resp == true ifFalse: [			self inform: 'the primary server of this project seems to be down (',								resp printString,')'. 			^ self		].	].	"Later, store with same name on secondary servers.  Still can be race conditions.  All machines will go through the server list in the same order."	"2 to: servers size do: [:aServer | aServer putFile: local named: newName]."! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/30/2000 14:10'!storeOnServerShowProgressOn: aMorphOrNil	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	world setProperty: #optimumExtentFromAuthor toValue: world extent.	self hasBadNameForStoring ifTrue: [		^self inform: 'The name of this project may cause problems when stored in a file.Please fix it and try again.'	].	self isCurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #storeOnServer].	self storeOnServerWithProgressInfoOn: aMorphOrNil.! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/30/2000 14:10'!storeOnServerWithProgressInfoOn: aMorphOrNil	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	ComplexProgressIndicator new 		targetMorph: aMorphOrNil;		historyCategory: 'project storing';		withProgressDo: [self storeOnServerInnards]	! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 12:58'!url	| serv |	"compose my url on the server"	urlList ifNotNil: [		urlList size > 0 ifTrue: [			serv _ urlList first last == $/ ifTrue: [urlList first] ifFalse: [urlList first, '/'].			^ serv, self versionedFileName		]	].	^ ''! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 12:28'!versionFrom: aServerFile	| theName uu serverUrl |	"Store the version of the file I actually came from.  My stored version was recorded before I knew the latest version number on the server!!"	self flag: #bob.		"this may become unnecessary once we get the version before writing"	(aServerFile class == String) 		ifTrue: [uu _ aServerFile asUrl.				theName _ uu path last.				serverUrl _ (uu toText copyUpToLast: $/), '/']		ifFalse: [serverUrl _ aServerFile directoryUrl.				theName _ aServerFile localName].	version _ (theName findTokens: '|.') second.	(serverUrl beginsWith: 'ftp:') ifTrue: ["update our server location"		urlList ifNil: [urlList _ Array new: 1].		urlList size = 0 ifTrue: [urlList _ Array new: 1].		urlList at: 1 put: serverUrl].! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/23/2000 12:58'!versionedFileName	^self name,'|',(version ifNil: ['AA']),'.pr'! !!Project methodsFor: 'object fileIn' stamp: 'RAA 6/23/2000 16:44'!convertdwctppdaevtngpiicmovue0: varDict dwctppdaevtngpiivuel0: smartRefStrm	"These variables are automatically stored into the new instance #('dependents' 'world' 'changeSet' 'transcript' 'parentProject' 'previousProject' 'displayDepth' 'activeProcess' 'exitFlag' 'viewSize' 'thumbnail' 'nextProject' 'guards' 'projectParameters' 'isolatedHead' 'inForce' 'version' 'urlList' 'environment').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('lastDirectory')  If a non-nil value is needed, please assign it."	"These are going away #('classArray' 'methodDictArray' 'orgArray').  Possibly store their info in another variable?"! !!Project methodsFor: 'object fileIn' stamp: 'RAA 6/27/2000 19:02'!convertdwctppdaevtngpiivue0: varDict dwctppdaevtngpiivuel0: smartRefStrm	"These variables are automatically stored into the new instance #('dependents' 'world' 'changeSet' 'transcript' 'parentProject' 'previousProject' 'displayDepth' 'activeProcess' 'exitFlag' 'viewSize' 'thumbnail' 'nextProject' 'guards' 'projectParameters' 'isolatedHead' 'inForce' 'version' 'urlList' 'environment').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('lastDirectory')  If a non-nil value is needed, please assign it."! !!Project methodsFor: 'isolation layers' stamp: 'RAA 6/21/2000 23:01'!isIsolated	^ isolatedHead ifNil: [isolatedHead _ false]! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 7/4/2000 16:29'!enterIfThereOrFind: aProjectName	| newProject |	newProject _ Project named: aProjectName.	newProject ifNotNil: [^newProject enter].	ComplexProgressIndicator new 		targetMorph: nil;		historyCategory: 'project loading';		withProgressDo: [			[				newProject _ CurrentProject fromMyServerLoad: aProjectName			] 				on: ProjectViewOpenNotification				do: [ :ex | ex resume: false]							"we probably don't want a project view morph in this case"		].	newProject ifNotNil: [^newProject enter].	1 beep.! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 6/28/2000 18:59'!fromUrl: urlString	| serverFile pair projName proj num triple |	"Load the project, and make a thumbnail to it in the current project.  Replace the old one if necessary.Project fromUrl: 'http://www.squeak.org/Squeak2.0/2.7segments/Squeak_Easy.pr.gz'."	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	Smalltalk isMorphic ifFalse: [^ self inform: 			'Later, allow jumping from MVC to Morphic Projects.'].	serverFile _ ServerFile new fullPath: urlString.	projName _ (serverFile fileName unescapePercents findTokens: '|.') first.	(proj _ Project named: projName) ifNotNil: ["it appeared" ^ ProjectEntryNotification signal: proj].	serverFile isTypeHTTP		ifTrue: [num _ (triple _ serverFile fileName findTokens: '|.') size >= 3 				ifTrue: [Base64MimeConverter decodeInteger: triple second unescapePercents]				ifFalse: [0].			pair _ Array with: serverFile fileName with: num]		ifFalse: [pair _ self mostRecent: serverFile localName onServer: serverFile].	"Pair first is name exactly as it is on the server"	pair first ifNil: ["If none, open a blank project"		^self openBlankProjectNamed: projName	].	CurrentProject installRemoteNamed: pair first from: serverFile named: projName.! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 6/26/2000 11:52'!mostRecent: projName onServer: aServerDirectory	| stem list max goodName triple num stem1 stem2 rawList nothingFound |	"Find the exact fileName of the most recent version of project with the stem name of projName.  Names are of the form 'projName|mm.pr' where mm is a mime-encoded integer version number.	File names may or may not be HTTP escaped, %20 on the server."	self flag: #bob.		"do we want to handle unversioned projects as well?"	nothingFound _ {nil. -1}.	aServerDirectory ifNil: [^nothingFound].	stem _ (projName unescapePercents findTokens: '|.') first, '|'.	"strip it first"	rawList _ aServerDirectory fileNames.	rawList class == String ifTrue: [self inform: 'server is unavailable'. ^nothingFound].	list _ rawList collect: [:nnn | nnn unescapePercents].	max _ -1.  goodName _ nil.	list withIndexDo: [:aName :ind |		(aName beginsWith: stem) ifTrue: [			(triple _ aName findTokens: '|.') size >= 3 ifTrue: [				num _ Base64MimeConverter decodeInteger: triple second unescapePercents.				num > max ifTrue: [max _ num.  goodName _ (rawList at: ind)]]]].	max = -1 ifFalse: [^ Array with: goodName with: max].	"try with underbar for spaces on server"	(stem includes: $ ) ifTrue: [		stem1 _ stem copyReplaceAll: ' ' with: '_'.		list withIndexDo: [:aName :ind |			(aName beginsWith: stem1) ifTrue: [				(triple _ aName findTokens: '|.') size >= 3 ifTrue: [					num _ Base64MimeConverter decodeInteger: triple second unescapePercents.					num > max ifTrue: [max _ num.  goodName _ (rawList at: ind)]]]]].	max = -1 ifFalse: [^ Array with: goodName with: max].		"try without the marker | "	stem1 _ stem allButLast, '.pr'.	stem2 _ stem1 copyReplaceAll: ' ' with: '_'.	"and with spaces replaced"	list withIndexDo: [:aName :ind |		(aName beginsWith: stem1) | (aName beginsWith: stem2) ifTrue: [			(triple _ aName findTokens: '.') size >= 2 ifTrue: [				max _ 0.  goodName _ (rawList at: ind)]]].	"no other versions"	max = -1 ifFalse: [^ Array with: goodName with: max].	^nothingFound		"no matches"! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 6/30/2000 13:22'!openBlankProjectNamed: projName	| pvm proj projViewer |	"If none, open a blank project"	pvm _ (ProjectViewMorph newMorphicProjectOn: nil) findA: ProjectViewMorph.	(proj _ pvm project) changeSet name: projName.	proj world addMorph: (		TextMorph new 			beAllFont: ((TextStyle default fontOfSize: 26) emphasized: 1);			color: Color red;			contents: 'Welcome to a new project - ',projName	).	CurrentProjectRefactoring currentBeParentTo: proj.	projViewer _ (CurrentProject findProjectView: projName) ifNil: [^proj].	(projViewer owner isKindOf: SystemWindow) ifTrue: [			projViewer owner model: proj].	^ projViewer project: proj! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/5/2000 15:26'!addButton: aString balloonText: anotherString for: aSymbol	| b a |	b _ SimpleButtonDelayedMenuMorph new 		target: self;		borderColor: #raised;		color: color darker;		label: aString;		setBalloonText: anotherString;		actionSelector: aSymbol.	a _ AlignmentMorph newColumn.	a color: Color transparent; borderWidth: 0; inset: 2.	a hResizing: #shrinkWrap; vResizing: #shrinkWrap.	a addMorphBack: b.	self addMorphBack: a.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/5/2000 16:24'!color: newColor	| buttonColor |	super color: newColor.	buttonColor _ color darker.	self submorphsDo: [:m | m submorphsDo: [:n | n color: buttonColor]]! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/5/2000 16:12'!doPublishButtonMenuEvent: evt	| menu selection |	menu _ CustomMenu new.	menu 		add: 'publish normally' action: [self publishProject];		add: 'publish to different server' action: [self publishDifferent].	selection _ menu build startUpCenteredWithCaption: 'Publish options'.	selection ifNil: [^self].	selection value.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/29/2000 11:11'!handlesMouseOver: evt	^true! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 13:56'!initialize	super initialize.	self useRoundedCorners.	inset _ 6.	color _ Color orange.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	mouseInside _ false.	self addButtons.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 19:22'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^25		"Navigators are behind menus and balloons, but in front of most other stuff"! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 13:57'!mouseEnter: evt	(self worldBounds containsPoint: evt cursorPoint) ifFalse: [^self].	mouseInside _ true.	self positionVertically.	! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 13:57'!mouseLeave: evt	(self worldBounds containsPoint: evt cursorPoint) ifFalse: [^self].	mouseInside _ false.	self positionVertically.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 13:55'!positionVertically	| wb |	wb _ self worldBounds.	mouseInside == true ifTrue: [		(self top - wb top) abs < (self bottom - wb bottom) abs ifTrue: [			self top: wb top		] ifFalse: [			self bottom: wb bottom		].	] ifFalse: [		(self top - wb top) abs < (self bottom - wb bottom) abs ifTrue: [			self bottom: wb top + 10		] ifFalse: [			self top: wb bottom - 10		].	].! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/5/2000 16:05'!publishDifferent	| p |	p _ (self world ifNil: [^1 beep]) project.	p urlList: nil.	"forget the old server"	p storeOnServerShowProgressOn: self.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/30/2000 14:11'!publishProject	(self world ifNil: [^1 beep]) project storeOnServerShowProgressOn: self.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/5/2000 16:13'!showMenuFor: aSymbol event: evt	aSymbol == #publishProject ifFalse: [^false].	self doPublishButtonMenuEvent: evt.	^true		"we did show the menu"! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/5/2000 16:25'!step	| wb |	owner == self world		ifFalse: [^ self].	self 		findDeepSubmorphThat: [ :m | m isKindOf: SimpleButtonDelayedMenuMorph] 		ifAbsent: [			self removeAllMorphs.			self addButtons.		].	owner addMorphInLayer: self.	wb _ self worldBounds.	self left < wb left ifTrue: [self left: wb left].	self right > wb right ifTrue: [self right: wb right].	self positionVertically.	"button color stuff moved to #color:"! !!ProjectNavigationMorph methodsFor: 'object fileIn' stamp: 'RAA 6/30/2000 13:58'!convertbosfcebbochvimlp0: varDict bosfcebbochvimlpm0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('mouseInside')  If a non-nil value is needed, please assign it."! !!ProjectView methodsFor: 'displaying' stamp: 'tk 6/21/2000 16:22'!displayDeEmphasized	| cmd |	"Display this view with emphasis off.  Check for a command thatcould not be executed in my subproject.  Once it is done, remove thetrigger."	super displayDeEmphasized.	ArmsLengthCmd ifNil: [^ self].	ArmsLengthCmd first == model ifFalse: [^ self].	"not ours"	cmd _ ArmsLengthCmd second.	ArmsLengthCmd _ nil.	model "project" perform: cmd.	model "project" enter.! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 6/30/2000 11:39'!enter	"Enter my project."	self world == self outermostWorldMorph ifFalse: [^1 beep]. "can't do this at the moment"	project class == DiskProxy ifFalse: [		(project world notNil and: 				[project world outermostWorldMorph == self outermostWorldMorph]) ifTrue: [			^1 beep		"project is open in a window already"		].	].	project class == DiskProxy ifTrue: ["When target is not in yet"		self enterWhenNotPresent.	"will bring it in"		project class == DiskProxy ifTrue: [^self inform: 'Project not found']].	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	self showBorderAs: Color gray.	project enter: false revert: false saveForRevert: false.! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 6/30/2000 14:13'!mouseMove: evt	| menu selection |	(self containsPoint: evt cursorPoint) ifFalse: [		self showBorderAs: Color blue.		mouseDownTime _ nil.		^self	].	self showBorderAs: Color red.	mouseDownTime ifNil: [		mouseDownTime _ Time millisecondClockValue.		^self	].	((Time millisecondClockValue - mouseDownTime) > 1100) ifFalse: [^self].					(menu _ CustomMenu new)		add: 'enter this project' action: #enter;		add: 'ENTER ACTIVE' action: #enterAsActiveSubproject;		add: 'save (also saves a local copy)' action: #SERVERSTORE;		add: 'saveAs' action: #NEWSTORE;		add: 'see if server version is more recent' action: #loadFromServer.	selection _ (menu build preSelect: #enter) 		startUpCenteredWithCaption: ('Project Named','"', project name, '"').	selection = #enter ifTrue: [^ self enter].	selection = #enterAsActiveSubproject ifTrue: [		self setProperty: #wasOpenedAsSubproject toValue: true.		^ self enterAsActiveSubproject	].	selection = #SERVERSTORE ifTrue: [^ project storeOnServerShowProgressOn: self].	selection = #NEWSTORE ifTrue: [project urlList: nil. ^ project storeOnServerShowProgressOn: self].	selection = #loadFromServer ifTrue: [ ^ self checkForNewerVersionAndLoad].					! !!ProjectViewMorph methodsFor: 'fileIn/out' stamp: 'RAA 6/23/2000 12:37'!exportSegment	"Store my project out on the disk as an ImageSegment that can be brought into other images.  Write the outPointers on the file also.  Name it <project name>.extSeg"	self flag: #bob.		"probably can be deleted"	project exportSegment.! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'RAA 6/21/2000 19:23'!openFromDirectory: aDirectory andFileName: aFileName	ComplexProgressIndicator new 		targetMorph: nil;		historyCategory: 'project loading';		withProgressDo: [			ProjectViewMorph 				openFromFile: (aDirectory oldFileNamed: aFileName) 				fromDirectory: aDirectory.		]! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'RAA 6/21/2000 19:21'!openFromFile: preStream		^self openFromFile: preStream fromDirectory: nil! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'RAA 7/4/2000 16:36'!openFromFile: preStream fromDirectory: aDirectoryOrNil	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world." 	| morphOrList window proj |	ProgressNotification signal: '2 streamSize ',preStream size printString.	morphOrList _ preStream asUnZippedStream.	ProgressNotification  signal: '3 unzipped'.	morphOrList _ morphOrList fileInObjectAndCode.	ProgressNotification  signal: '4 filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		(morphOrList arrayOfRoots count: [:mm | mm class == Project]) > 1 ifTrue: [			self error: 'which project is main?']. 	"debug"		proj _ morphOrList arrayOfRoots detect: [:mm | mm class == Project] 					ifNone: [nil].		"rename the project if it conflicts?"		proj ifNotNil: [			proj versionFrom: preStream.			proj lastDirectory: aDirectoryOrNil.			window _ (SystemWindow labelled: proj name) model: proj.			window				addMorph: (self on: proj)				frame: (0@0 corner: 1.0@1.0).			ProjectViewOpenNotification signal ifTrue: [window openInWorld].			CurrentProjectRefactoring currentBeParentTo: proj.			^ ProjectEntryNotification signal: proj		]	].	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph	].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'	].	window _ self newMorphicProjectOn: morphOrList.	ProjectViewOpenNotification signal ifTrue: [window openInWorld].	window model enter! !!ProjectViewOpenNotification methodsFor: 'as yet unclassified' stamp: 'RAA 7/4/2000 16:24'!defaultAction	self resume: true! !!RenamedClassSourceReader methodsFor: 'as yet unclassified' stamp: 'RAA 6/22/2000 15:14'!scanFrom: aStream	self flag: #bob. 	"should this ever happen?"	self halt.! !!RenamedClassSourceReader methodsFor: 'as yet unclassified' stamp: 'RAA 6/22/2000 16:28'!scanFromNoCompile: aStream	self flag: #bob. 	"should this ever happen?"	self halt.! !!RenamedClassSourceReader methodsFor: 'as yet unclassified' stamp: 'RAA 6/22/2000 16:35'!scanFromNoCompile: aStream forSegment: anImageSegment	"Just move the source code for the methods from aStream."	| methodText d |	[		(methodText _ aStream nextChunkText) size > 0	] whileTrue: [		(SourceFiles at: 2) ifNotNil: [			d _ Dictionary new.			d				at: #oldClassName put: class;		"may be 'Player1' or 'Player1 class'"				at: #methodText put: methodText;				at: #changeStamp put: changeStamp;				at: #category put: category.			anImageSegment acceptSingleMethodSource: d.		]	]! !!RenamedClassSourceReader class methodsFor: 'as yet unclassified' stamp: 'RAA 6/22/2000 15:35'!formerClassName: formerClassName methodsFor: aCategory stamp: aString	^self new		setClass: formerClassName 		category: aCategory 		changeStamp: aString! !!RenamedClassSourceReader class methodsFor: 'as yet unclassified' stamp: 'RAA 6/22/2000 15:18'!scanner	^self new! !!ServerDirectory methodsFor: 'do ftp' stamp: 'RAA 6/23/2000 09:47'!fileExists: fileName	"Does the file exist on this server directory?  fileName must be simple with no / or references to other directories."	self isTypeFile ifTrue: [^ self fileNames includes: fileName].	self isTypeHTTP ifTrue: [^ (self readOnlyFileNamed: fileName) class ~~ String].	"ftp"	^ (self getFileList contentsOfEntireFile findTokens: FTPSocket crLf) includes: fileName! !!ServerDirectory methodsFor: 'do ftp' stamp: 'RAA 6/23/2000 09:47'!getFileNamed: fileNameOnServer into: dataStream	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	self isTypeFile ifTrue: [		dataStream nextPutAll: 			(resp _ FileStream oldFileNamed: server,(self serverDelimiter asString), 				self bareDirectory, (self serverDelimiter asString),				fileNameOnServer) contentsOfEntireFile.		dataStream dataIsValid.		^ resp].	self isTypeHTTP ifTrue: [		resp _ HTTPSocket httpGet: (self fullNameFor: fileNameOnServer) 				accept: 'application/octet-stream'.		resp class == String ifTrue: [^ dataStream].	"error, no data"		dataStream copyFrom: resp.		dataStream dataIsValid.		^ dataStream].	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieving file ', fileNameOnServer; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; cr."	resp _ dd getDataTo: dataStream whileWatching: so.		"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [socket _ nil.  ^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"226 Transfer complete."	socket ifNil: ["normally leave connection open.  Don't quit"		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"	dd destroy.	dataStream dataIsValid.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'RAA 6/23/2000 09:43'!putFile: fileStream named: fileNameOnServer retry: aBool	"ar 11/24/1998 Do the usual putFile:named: operation but retry if some error occurs and aBool is set. Added due to having severe transmission problems on shell.webpage.com."	| resp |	self isTypeFile ifTrue: [		^ (FileDirectory on: urlObject pathForDirectory)			putFile: fileStream named: fileNameOnServer].	[[resp _ self putFile: fileStream named: fileNameOnServer] 		ifError:[:err :rcvr| resp _ '5xx ',err]. "Report as error"	aBool and:[((resp isKindOf: String) and: [resp size > 0]) and:[resp first ~= $2]]] whileTrue:[		(self confirm:('Error storing ',fileNameOnServer,' on the server.\(',resp,',)\Retry operation?') withCRs) ifFalse:[^resp].	].	^resp! !!ServerDirectory methodsFor: 'accessing' stamp: 'RAA 6/24/2000 10:41'!fullPath: serverAndDirectory	"Parse and save a full path.  Convention:  if ftp://user@server/dir, then dir is relative to user's directory.  dir has no slash at beginning.  If ftp://server/dir, then dir is absolute to top of machine, give dir a slash at the beginning."	| start bare sz userAndServer both slash score match best sd |	bare _ serverAndDirectory.	sz _ serverAndDirectory size.	bare size > 0 ifTrue: [ 		start _ (bare copyFrom: 1 to: (8 min: sz)) asLowercase.		((start beginsWith: 'ftp:') or: [start beginsWith: 'nil:']) "fix bad urls"			ifTrue: [type _ #ftp.				bare _ bare copyFrom: (7 min: sz) to: bare size].		(start beginsWith: 'http:') 			ifTrue: [type _ #http.				bare _ bare copyFrom: (8 min: sz) to: serverAndDirectory size].		((start beginsWith: 'file:') or: [type == #file])			ifTrue: [type _ #file.				urlObject _ FileUrl absoluteFromText: serverAndDirectory.				^ self]].	userAndServer _ bare copyUpTo: self pathNameDelimiter.	both _ userAndServer findTokens: '@'.	slash _ both size.	"absolute = 1, relative = 2"	server _ both last.	both size > 1 ifTrue: [user _ both at: 1].	bare size > (userAndServer size + 1) 		ifTrue: [directory _ bare copyFrom: userAndServer size + slash to: bare size]		ifFalse: [directory _ ''].	"If this server is already known, copy in its userName and password"	type == #ftp ifFalse: [^ self].	score _ -1.	ServerDirectory serverNames do: [:name |		sd _ ServerDirectory serverNamed: name.		server = sd server ifTrue: [			match _ directory asLowercase charactersExactlyMatching: sd directory asLowercase.			match > score ifTrue: [score _ match.  best _ sd]]].	best 		ifNil: [self fromUser]		ifNotNil: [user _ best user.  self password: best password].! !!ServerDirectory methodsFor: 'accessing' stamp: 'RAA 6/23/2000 09:40'!isTypeFTP	^self typeWithDefault == #ftp! !!ServerDirectory methodsFor: 'accessing' stamp: 'RAA 6/23/2000 09:41'!isTypeFile	^self typeWithDefault == #file! !!ServerDirectory methodsFor: 'accessing' stamp: 'RAA 6/23/2000 09:46'!isTypeHTTP	^self typeWithDefault == #http! !!ServerDirectory methodsFor: 'accessing' stamp: 'RAA 6/23/2000 09:44'!realUrl	"a fully expanded version of the url we represent.  Prefix the path with http: or ftp: or file:"	self isTypeFile ifTrue: [		self fileNameRelativeTo: self.		^ urlObject toText	].	^ self typeWithDefault asString, '://', self pathName	! !!ServerDirectory methodsFor: 'accessing' stamp: 'RAA 6/23/2000 09:39'!type	self flag: #bob.		"probably not needed - use #typeWithDefault instead"	^ type! !!ServerDirectory methodsFor: 'accessing' stamp: 'RAA 6/23/2000 09:30'!typeWithDefault	^ type ifNil: [type _ #ftp]! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:08'!asServerFileNamed: aName	| rFile |	rFile _ self as: ServerFile.	(aName includes: self pathNameDelimiter)		ifTrue: [rFile fullPath: aName]			"sets server, directory(path), fileName.  If relative, merge with self."		ifFalse: [rFile fileName: aName].	"JUST a single NAME, already have the rest"			"Mac files that include / in name, must encode it as %2F "	^rFile! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 6/23/2000 09:41'!createDirectory: localName	"Create a new sub directory within the current one"	| so rr |	self isTypeFile ifTrue: [		^FileDirectory createDirectory: localName	].	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'MKD ', localName.	(rr _ so responseOK) == true ifFalse: [socket _ nil.  ^ rr].	""	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 6/23/2000 09:42'!deleteDirectory: localName	"Delete the sub directory within the current one.  Call needs to ask user to confirm."	| so rr |	self isTypeFile ifTrue: [		^FileDirectory deleteFileNamed: localName	].		"Is this the right command???"	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RMD ', localName.	(rr _ so responseOK) == true ifFalse: [socket _ nil.  ^ rr].	""	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:31'!deleteFileNamed: fullName	"Detete a remote file.  fullName is directory path, and does include name of the server.  Or it can just be a fileName."	| file so rr |	file _ self asServerFileNamed: fullName.	file isTypeFile ifTrue: [		^ (FileDirectory forFileName: (file fileNameRelativeTo: self)) 			deleteFileNamed: file fileName	].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'DELE ', file fileName.	(rr _ so responseOK) == true ifFalse: [socket _ nil.  ^ rr].	""	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 6/23/2000 09:42'!entries 	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name> <creationTime> <modificationTime> <dirFlag> <fileSize>)."	| dir ftpEntries thisYear tokens dateInSeconds longy thisMonth theDay theMonth |	"We start with ftp directory entries of the form...d---------   1 owner    group               0 Apr 27 22:01 blasttest----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM    1        2   3           4                 5    6  7    8       9   -- token index"	self isTypeFile ifTrue: [		urlObject isAbsolute ifFalse: [urlObject default].		^ (FileDirectory on: urlObject pathForDirectory) entries	].	dir _ self getDirectory.	(dir respondsTo: #contentsOfEntireFile) ifFalse: [^ #()].	ftpEntries _ dir contentsOfEntireFile findTokens: FTPSocket crLf.	thisYear _ Date today year.	thisMonth _ Date today monthIndex.	^ ftpEntries collect:		[:ftpEntry | tokens _ ftpEntry findTokens: ' '.		tokens size >= 9		ifTrue:		[tokens size > 9 ifTrue:			[longy _ tokens at: 9.			10 to: tokens size do: [:i | longy _ longy , ' ' , (tokens at: i)].			tokens at: 9 put: longy].		theDay _ (tokens at: 7) asNumber.		theMonth _ Date indexOfMonth: (tokens at: 6).		dateInSeconds _ ((tokens at: 8) includes: $:)			ifTrue: ["Date has no year if within six months"					(Date newDay: theDay							month: theMonth							year: (theMonth > thisMonth										ifTrue: [thisYear - 1]										ifFalse: [thisYear])) asSeconds +					(Time readFrom: (ReadStream on: (tokens at: 8))) asSeconds]			ifFalse: [(Date newDay: theDay							month: theMonth							year: (tokens at: 8) asNumber) asSeconds].		DirectoryEntry name: (tokens at: 9)  "file name"			creationTime: dateInSeconds "creation date"			modificationTime: dateInSeconds "modification time"			isDirectory: tokens first first = $d "is-a-directory flag"			fileSize: tokens fifth asNumber "file size"]		ifFalse:		[nil]]		thenSelect: [:entry | entry notNil]! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:31'!fileNamed: fullName	"Create a RemoteFileStream for writing.  If the file exists, do not complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm |	file _ self asServerFileNamed: fullName.	file readWrite.	file isTypeFile ifTrue: [		^ FileStream fileNamed: (file fileNameRelativeTo: self)	].	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	^ remoteStrm	"no actual writing till close"! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 6/23/2000 09:46'!fileNames	"Return a collection of names for the files (but not directories) in this directory."	"(ServerDirectory serverNamed: 'UIUCArchive') fileNames"	self isTypeFTP | self isTypeFile ifFalse: [		^ self error: 'To see a directory, use file:// or ftp://'	].	^ (self entries select: [:entry | (entry at: 4) not])		collect: [:entry | entry first]! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 6/23/2000 09:47'!getOnly: nnn from: fileNameOnServer	| file ff resp |	"Use FTP to just capture the first nnn characters of the file.  Break the connection after that.  Goes faster for long files.  Return the contents, not a stream."	self isTypeFile ifTrue: [		file _ self as: ServerFile.		file fileName: fileNameOnServer.		ff _ FileStream oldFileOrNoneNamed: (file fileNameRelativeTo: self).		^ ff next: nnn].	self isTypeHTTP ifTrue: [		resp _ HTTPSocket httpGet: (self fullNameFor: fileNameOnServer) 				accept: 'application/octet-stream'.			"For now, get the whole file.  This branch not used often."		^ resp truncateTo: nnn].		^ self getOnlyBuffer: (String new: nnn) from: fileNameOnServer! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:32'!newFileNamed: fullName	"Create a RemoteFileStream.  If the file exists, and complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm selection |	file _ self asServerFileNamed: fullName.	file readWrite.	file isTypeFile ifTrue: [		^ FileStream newFileNamed: (file fileNameRelativeTo: self)].	file exists 		ifTrue: [			selection _ (PopUpMenu labels: 'overwrite that filechoose another namecancel')				startUpWithCaption: (file fullNameFor: file fileName) , 'already exists.']		ifFalse: [selection _ 1].	selection = 1 ifTrue:		[remoteStrm _ RemoteFileStream on: (String new: 2000).		remoteStrm remoteFile: file.		remoteStrm dataIsValid.	"empty stream is the real contents!!"		^ remoteStrm].	"no actual writing till close"	selection = 2 ifTrue: [		^ self newFileNamed:			(FillInTheBlank request: 'Enter a new file name'				initialAnswer: file fileName)].	^ nil	"cancel"! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:10'!oldFileNamed: aName	"If the file exists, answer a read-only RemoteFileStream on it.  aName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| rFile |	rFile _ self asServerFileNamed: aName.	rFile readOnly.	rFile isTypeFile ifTrue: [		^ FileStream oldFileNamed: (rFile fileNameRelativeTo: self)].	^self streamOnBeginningOf: rFile! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:09'!oldFileOrNoneNamed: fullName	"If the file exists, answer a read-only RemoteFileStream on it. If it doesn't, answer nil.  fullName is directory path, and does include name of the server.  Or just a simple fileName.  Do prefetch the data."	| file |	Cursor wait showWhile: [		file _ self asServerFileNamed: fullName.		file readOnly.		file isTypeFile ifTrue: [			^ FileStream oldFileOrNoneNamed: (file fileNameRelativeTo: self)].		"file exists ifFalse: [^ nil]."		"on the server"		^self streamOnBeginningOf: file	].! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:08'!readOnlyFileNamed: aName	"If the file exists, answer a read-only RemoteFileStream on it.  aName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| rFile |	rFile _ self asServerFileNamed: aName.	rFile readOnly.	rFile isTypeFile ifTrue: [		^ FileStream oldFileNamed: (rFile fileNameRelativeTo: self)].	^self streamOnBeginningOf: rFile! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:11'!rename: fullName toBe: newName	"Rename a remote file.  fullName is just be a fileName, or can be directory path that includes name of the server.  newName is just a fileName"	| file so rr |	file _ self asServerFileNamed: fullName.	file isTypeFile ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			rename: file fileName toBe: newName	].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RNFR ', file fileName.	(rr _ so responseOK) == true ifFalse: [socket _ nil.  ^ rr].	""	so sendCommand: 'RNTO ', newName.	(rr _ so responseOK) == true ifFalse: [socket _ nil.  ^ rr].	""	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 6/23/2000 09:45'!serverDelimiter	"the separator that is used in the place where the file actually is.  ftp server or local disk."	^ self isTypeFile 		ifTrue: [FileDirectory default pathNameDelimiter]		ifFalse: [$/]	"for ftp, http"! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:03'!streamOnBeginningOf: serverFile	| remoteStrm |	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: serverFile.	serverFile getFileNamed: serverFile fileName into: remoteStrm.	"prefetch data"	^ remoteStrm! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 09:45'!fullPath: serverAndDirectory	"Parse and save a full path.  Separate out fileName at the end."	| delim ii |	super fullPath: serverAndDirectory.		"set server and directory"	self isTypeFile ifTrue: [		fileName _  ''.		^ self	].	delim _ self pathNameDelimiter.	ii _ directory findLast: [:c | c = delim].	ii = 0		ifTrue: [self error: 'expecting directory and fileName']		ifFalse: [fileName _ directory copyFrom: ii+1 to: directory size.			directory _ (directory copyFrom: 1 to: directory size - fileName size - 1)].! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 09:45'!realUrl	"a fully expanded version of the url we represent.  Prefix the path with http: or ftp: or file:"	self isTypeFile ifTrue: [		self fileNameRelativeTo: self.		^ urlObject toText	].	^ self typeWithDefault asString, '://', self pathName, '/', fileName	"note difference!!"	! !!SimpleButtonDelayedMenuMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/5/2000 16:21'!color: x	super color: x.! !!SimpleButtonDelayedMenuMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/5/2000 16:00'!mouseDown: evt	didMenu _ nil.	mouseDownTime _ Time millisecondClockValue.	super mouseDown: evt.! !!SimpleButtonDelayedMenuMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/5/2000 16:37'!mouseMove: evt	(mouseDownTime isNil or: [(Time millisecondClockValue - mouseDownTime) abs < 1000]) ifTrue: [		^super mouseMove: evt	].	didMenu ifNotNil: [^super mouseMove: evt].	self color: oldColor.		"in case menu never returns"	didMenu _ target showMenuFor: actionSelector event: evt.! !!SimpleButtonDelayedMenuMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/5/2000 16:50'!mouseUp: evt	didMenu == true ifFalse: [^super mouseUp: evt].	oldColor ifNotNil: [		self color: oldColor.		oldColor _ nil	].! !!SmartRefStream methodsFor: 'import image segment' stamp: 'RAA 6/21/2000 22:56'!mapClass: newClass installIn: mapFakeClassesToReal	"aClass is has already been mapped!!  Make a fake class for the old shape.  Write it into the dictionary mapping Fake classes to Real classes."	| newName className oldInstVars fakeClass |	newClass isMeta ifTrue: [^ nil].	newName _ newClass name.	className _ renamed keyAtValue: newName ifAbsent: [newName].		"A problem here if two classes map to the same one!!"	(steady includes: newClass) ifTrue: [^ nil].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	fakeClass _ Object subclass: ('Fake37',className) asSymbol		instanceVariableNames: oldInstVars allButFirst		classVariableNames: ''		poolDictionaries: ''		category: 'Obsolete'.	mapFakeClassesToReal at: fakeClass put: newClass.	Smalltalk changes removeClassChanges: fakeClass name.	"reduce clutter"	^ fakeClass! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'RAA 7/5/2000 12:51'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds adjoiningPanes limit |	(self world firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[ ^ self  "Prevent multiple handles"].	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	"don't resize pane side coincident with window side - RAA 5 jul 2000"	(growingPane perform: side) = (self innerBounds perform: side) ifTrue: [^self].	adjoiningPanes _ paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side].	limit _ adjoiningPanes isEmpty		ifFalse: [ (adjoiningPanes collect: [:pane | pane bounds perform: side])			perform: ((#(top left) includes: side) ifTrue: [#max] ifFalse: [#min])]		ifTrue: [self bounds perform: side].	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ growingPane bounds withSideOrCorner: side setToPoint: localPt minExtent: 40@20 limit: limit.			self fastFramingOn 			ifTrue:				["For fast display, only higlight the rectangle during loop"				newBounds _ growingPane bounds					 newRectFrom:					[:f | growingPane bounds withSideOrCorner: side							setToPoint: (self pointFromWorld: Sensor cursorPoint)							minExtent: 40@20 limit: limit].					self reframePanesAdjoining: growingPane along: side						to: newBounds]			ifFalse:				[self reframePanesAdjoining: growingPane along: side to: newBounds]]		lastPointDo: [:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'events' stamp: 'RAA 7/4/2000 16:54'!doFastFrameDrag	| offset newBounds outerWorldBounds |	outerWorldBounds _ self boundsInOutermostWorld.	offset _ outerWorldBounds origin - Sensor cursorPoint.	newBounds _ outerWorldBounds newRectFrom: [:f | 		Sensor cursorPoint + offset extent: outerWorldBounds extent	].	^ self position: (self globalPointToLocal: newBounds topLeft) ! !!SystemWindow methodsFor: 'events' stamp: 'RAA 7/4/2000 17:36'!handlesMouseDown: evt	"If I am not the topWindow, then I will only respond to dragging by the title bar.	Any other click will only bring me to the top"	self flag: #bob.		"#handlesMouseDown: is in global coords, #mouseDown: is in local"	(self fastFramingOn 		and: [self labelRect containsPoint: (self globalPointToLocal: evt cursorPoint)])		ifTrue: [^ true].	^ self activeOnlyOnTop and: [self ~~ TopWindow]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 09:59'!loadProject	| stdFileMenuResult |	"Put up a Menu and let the user choose a '.project' file to load.  Create a thumbnail and jump into the project."	Project canWeLoadAProjectNow ifFalse: [^ self].	stdFileMenuResult _ ((StandardFileMenu new) pattern: '*.pr'; 		oldFileFrom: FileDirectory default ) 			startUpWithCaption: 'Select a File:'.	stdFileMenuResult ifNil: [^ nil].	ProjectViewMorph 		openFromDirectory: stdFileMenuResult directory 		andFileName: stdFileMenuResult name! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 7/4/2000 10:14'!appearanceMenu	"Build the appearance menu for the world."	| screenCtrl |	screenCtrl _ ScreenController new.	^self fillIn: (self menu: 'appearance...') from: {		{'window colors...' . { Preferences . #windowSpecificationPanel} . 'Lets you specify colors for standard system windows.'}.		{'system fonts...' . { self . #standardFontDo} . 'Choose the standard fonts to use for code, lists, menus, window titles, etc.'}.		{'text highlight color...' . { Preferences . #chooseTextHighlightColor} . 'Choose which color should be used for text highlighting in Morphic.'}.		{'insertion point color...' . { Preferences . #chooseInsertionPointColor} . 'Choose which color to use for the text insertion point in Morphic.'}.		nil.		{#menuColorString . { Preferences . #toggleMenuColorPolicy} . 'Governs whether menu colors should be derived from the desktop color.'}.		{#roundedCornersString . { Preferences . #toggleRoundedCorners} . 'Governs whether morphic windows and menus should have rounded corners.'}.		nil.		{'full screen on' . { screenCtrl . #fullScreenOn} . 'puts you in full-screen mode, if not already there.'}.		{'full screen off' . { screenCtrl . #fullScreenOff} . 'if in full-screen mode, takes you out of it.'}.		nil.		{'set display depth...' . {self. #setDisplayDepth} . 'choose how many bits per pixel.'}.		{'set desktop color...' . {self. #changeBackgroundColor} . 'choose a uniform color to use as desktop background.'}.		{'set gradient color...' . {self. #setGradientColor} . 'choose second color to use as gradient for desktop background.'}.		{'use texture background' . { #myWorld . #setStandardTexture} . 'apply a graph-paper-like texture background to the desktop.'}.		nil.		{'clear turtle trails from desktop' . { #myWorld . #clearTurtleTrails} . 'remove any pigment laid down on the desktop by objects moving with their pens down.'}.	}! !!TheWorldMenu methodsFor: 'construction' stamp: 'RAA 6/27/2000 09:13'!newMorph	| menu subMenu catDict shortCat class |	menu _ self menu: 'Add a new morph'.	menu 		add: 'from paste buffer' target: myHand action: #pasteMorph;		add: 'from a file...' target: self action: #readMorphFromAFile;		add: 'from alphabetical list' subMenu: self alphabeticalMorphMenu;		add: 'grab patch from screen' target: myHand action: #grabDrawingFromScreen;		add: 'make new drawing' target: myHand action: #newDrawingFromMenu;		add: 'make link to project...' target: self action: #projectThumbnail;		addLine.	catDict _ Dictionary new.	SystemOrganization categories do:		[:cat |		((cat beginsWith: 'Morphic-')				and: [(#('Morphic-Menus' 'Morphic-Support') includes: cat) not])		ifTrue:			[shortCat _ cat copyFrom: 'Morphic-' size+1 to: cat size.			(SystemOrganization listAtCategoryNamed: cat) do:				[:cName | class _ Smalltalk at: cName.				((class inheritsFrom: Morph)					and: [class includeInNewMorphMenu])					ifTrue:					[(catDict includesKey: shortCat) 					ifTrue: [(catDict at: shortCat) addLast: class]					ifFalse: [catDict at: shortCat put: (OrderedCollection with: class)]]]]].	catDict keys asSortedCollection do:		[:categ |		subMenu _ MenuMorph new.		((catDict at: categ) asSortedCollection: [:c1 :c2 | c1 name < c2 name]) do:			[:cl | subMenu add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl].		menu add: categ subMenu: subMenu].	self doPopUp: menu.! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 6/27/2000 09:09'!projectThumbnail	"Offer the user a menu of project names. Attach to the hand a thumbnail of the project the user selects."	| menu projName pr |	menu _ MVCMenuMorph entitled: 'Select Project'.	menu 		add: (CurrentProjectRefactoring currentProjectName, ' (current)') 		action: CurrentProjectRefactoring currentProjectName.	menu addLine.	Project allNames do: [:n | menu add: n action: n].	projName _ menu invokeAt: myHand position in: myWorld.	projName ifNotNil:		[(pr _ Project named: projName) 			ifNotNil: [myHand attachMorph: (ProjectViewMorph on: pr)]			ifNil: [self inform: 'can''t seem to find that project']].! !!TheWorldMenu methodsFor: 'action' stamp: 'RAA 6/27/2000 09:04'!setGradientColor	myWorld setGradientColor: myHand lastEvent! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 17:56'!addButton: aString balloonText: anotherString for: aSymbol	| b a |	b _ SimpleButtonMorph new 		target: self;		borderColor: #raised;		color: color darker;		label: aString;		setBalloonText: anotherString;		actionSelector: aSymbol.	a _ AlignmentMorph newColumn.	a color: Color transparent; borderWidth: 0; inset: 2.	a hResizing: #shrinkWrap; vResizing: #shrinkWrap.	a addMorphBack: b.	self addMorphBack: a.! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 08:33'!addButtons	self 		addButton: 'First' balloonText: 'First page in sequence' for: #firstPage;		addButton: '< Back' balloonText: 'Previous page in sequence' for: #previousPage;		addButton: 'Forward >' balloonText: 'Next page in sequence' for: #nextPage;		addButton: 'Last' balloonText: 'Last page in sequence' for: #lastPage;		addButton: 'Exit' balloonText: 'Exit the sequence' for: #exitTheSequence.! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 08:29'!deleteCurrentPage	| outerWrapper |	loadedProject ifNil: [^self].	outerWrapper _ loadedProject world ownerThatIsA: EmbeddedWorldBorderMorph.	outerWrapper ifNil: [^self].	outerWrapper delete.	loadedProject _ nil.! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 08:32'!exitTheSequence	self deleteCurrentPage.	self delete.! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 08:26'!firstPage	listOfPages isEmpty ifTrue: [^1 beep].	currentIndex _ 1.	self loadPageWithProgress.! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 19:11'!initialize	super initialize.	self useRoundedCorners.	inset _ 6.	color _ Color red lighter.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	listOfPages _ OrderedCollection new.	currentIndex _ 0.	self addButtons.! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 08:27'!lastPage	listOfPages isEmpty ifTrue: [^1 beep].	currentIndex _ listOfPages size.	self loadPageWithProgress.! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 18:49'!listOfPages: aCollection	listOfPages _ aCollection! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 08:24'!loadPage	| theProject projectInfo url gotoPage theBook |	projectInfo _ listOfPages at: currentIndex.	url _ projectInfo at: 1.	gotoPage _ projectInfo at: 2 ifAbsent: [nil].	[		[Project fromUrl: url]			on: ProjectEntryNotification			do: [ :ex | 				self deleteCurrentPage.				theProject _ ex projectToEnter enterAsActiveSubprojectWithin: self world.				theProject world showExpandedView.				loadedProject _ theProject.				gotoPage ifNotNil: [					theBook _ loadedProject world findA: BookMorph.					theBook ifNotNil: [						theBook goToPage: gotoPage					].				].				^loadedProject			].	]		on: RequestCurrentWorldNotification		do: [ :ex | ex resume: self world ]! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 08:26'!loadPageWithProgress	ComplexProgressIndicator new 		targetMorph: self;		historyCategory: 'project loading';		withProgressDo: [self loadPage]! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 18:09'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^15		"Navigators are behind menus and balloons, but in front of most other stuff"! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 08:27'!nextPage	currentIndex >= listOfPages size ifTrue: [^1 beep].	currentIndex _ currentIndex + 1.	self loadPageWithProgress.! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 08:27'!previousPage	currentIndex <= 1 ifTrue: [^1 beep].	currentIndex _ currentIndex - 1.	self loadPageWithProgress.! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 18:11'!step	| delta testSubmorphColor |	owner == self world		ifFalse: [^ self].	owner addMorphInLayer: self.	delta _ self bounds amountToTranslateWithin: self worldBounds.	delta = (0 @ 0)		ifFalse: [self position: self position + delta].	testSubmorphColor _ self firstSubmorph findA: SimpleButtonMorph.	testSubmorphColor color ~~ color		ifTrue: [self				submorphsDo: [:m | m						submorphsDo: [:n | n color: color darker]]]! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 08:22'!stepTime	^250! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 17:59'!wantsSteps	^true! !!ThreadNavigationMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 6/28/2000 08:20'!example1"ThreadNavigationMorph example1"	self new		listOfPages: #(			('ftp://209.143.91.36/Drive A Car')			('ftp://209.143.91.36/Teachers & NewTech' 1)			('ftp://209.143.91.36/Teachers & NewTech' 2)			('ftp://209.143.91.36/Lander')		);		openInWorld! !!TransformationMorph methodsFor: 'menu' stamp: 'RAA 7/6/2000 12:52'!removeFlexShell	"Remove the shell used to make a morph rotatable and scalable."	| oldHalo unflexed pensDown player myWorld |	myWorld _ self world.	oldHalo _ self halo.	submorphs isEmpty ifTrue: [^ self delete].	unflexed _ self firstSubmorph.	pensDown _ OrderedCollection new.	self allMorphsDo:  "Note any pens down -- must not be down during the move"		[:m | ((player _ m player) notNil and: [player getPenDown]) ifTrue:			[m == player costume ifTrue:				[pensDown add: player.				player setPenDown: false]]].	self submorphs do: [:m |		m position: self center - (m extent // 2).		owner addMorph: m].	unflexed absorbStateFromRenderer: self.	pensDown do: [:p | p setPenDown: true].	oldHalo ifNotNil: [oldHalo setTarget: unflexed].	myWorld ifNotNil: [myWorld startSteppingSubmorphsOf: unflexed].	self delete.	^ unflexed! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 19:24'!changeWorldBoundsToShow: aRectangle	aRectangle area = 0 ifTrue: [^self].	worldBoundsToShow _ aRectangle.	owner myWorldChanged.! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 12:51'!drawSubmorphsOn: aCanvas	(self innerBounds intersects: aCanvas clipRect) ifFalse: [^self].	aCanvas 		transform2By: transform		"#transformBy: for pure WarpBlt"		clippingTo: ((self innerBounds intersect: aCanvas clipRect) expandBy: 1) truncated		during: [:myCanvas |			submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]		]		smoothing: smoothing! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 12:39'!extent: aPoint	| newExtent |	newExtent _ aPoint truncated.	bounds extent = newExtent ifTrue: [^self].	bounds _ bounds topLeft extent: newExtent.	self recomputeExtent.! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 19:23'!extentFromParent: aPoint	| newExtent |	submorphs isEmpty ifTrue: [^self extent: aPoint].	newExtent _ aPoint truncated.	bounds _ bounds topLeft extent: newExtent.	newExtent _ self recomputeExtent.	newExtent ifNil: [^self].	bounds _ bounds topLeft extent: newExtent.! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 12:39'!recomputeExtent	| scalePt newScale theGreenThingie greenIBE myNewExtent |	submorphs isEmpty ifTrue: [^self extent].	worldBoundsToShow ifNil: [worldBoundsToShow _ self firstSubmorph bounds].	worldBoundsToShow area = 0 ifTrue: [^self extent].	scalePt _ owner innerBounds extent / worldBoundsToShow extent.	newScale _ scalePt x min: scalePt y.	theGreenThingie _ owner.	greenIBE _ theGreenThingie innerBounds extent.	myNewExtent _ (greenIBE min: worldBoundsToShow extent * newScale) truncated.	self		scale: newScale;		offset: worldBoundsToShow origin * newScale.	smoothing _ (newScale < 1.0) ifTrue: [2] ifFalse: [1].	^myNewExtent! !!TranslucentProgessMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/4/2000 10:21'!drawOn: aCanvas	| revealPercentage revealingStyle revealingColor revealingBounds revealToggle x baseColor revealTimes secondsRemaining scanner stringToDraw where fontToUse |		opaqueBackgroundColor ifNotNil: [		aCanvas 			frameAndFillRectangle: bounds			fillColor: opaqueBackgroundColor			borderWidth: 1			borderColor: Color red	].	revealTimes _ (self valueOfProperty: #revealTimes) ifNil: [^self].	revealPercentage _ (revealTimes first / revealTimes second) asFloat.	revealingStyle _ self revealingStyle.	x _ self valueOfProperty: #progressStageNumber ifAbsent: [1].	baseColor _ Color perform: (#(red blue green magenta cyan yellow) atPin: x).	revealingColor _ baseColor alpha: 0.2.	revealingStyle = 3 ifTrue: [	"wrap and change color"		revealPercentage > 1.0 ifTrue: [			revealingColor _ baseColor alpha: (0.2 + (revealingStyle / 10) min: 0.5).		].		revealPercentage _ revealPercentage fractionPart.	].	revealingStyle = 2 ifTrue: [	"peg at 75 and blink"		revealPercentage > 0.75 ifTrue: [			revealToggle _ self valueOfProperty: #revealToggle ifAbsent: [true].			self setProperty: #revealToggle toValue: revealToggle not.			revealToggle ifTrue: [revealingColor _ baseColor alpha: 0.8.].		].		revealPercentage _ revealPercentage min: 0.75.	].	revealingBounds _ bounds withLeft: bounds left + (bounds width * revealPercentage) truncated.	aCanvas 		fillRectangle: revealingBounds		color: revealingColor.	secondsRemaining _ (revealTimes second - revealTimes first / 1000) rounded.	secondsRemaining > 0 ifTrue: [		fontToUse _ StrikeFont familyName: 'ComicBold' size: 24.		scanner _ DisplayScanner			quickPrintOn: aCanvas form 			box: bounds 			font: fontToUse 			color: Color black.		stringToDraw _ secondsRemaining printString.		where _ bounds corner - ((scanner stringWidth: stringToDraw) @ scanner lineHeight).		scanner 			drawString: stringToDraw 			at: where.		scanner _ DisplayScanner			quickPrintOn: aCanvas form 			box: bounds 			font: fontToUse 			color: Color white.		scanner 			drawString: stringToDraw 			at: where - (1@1).	]. ! !!TranslucentProgessMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/29/2000 10:51'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^12		"progress morphs are behind menus and balloons, but in front of most other stuff"! !!TranslucentProgessMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/29/2000 11:35'!opaqueBackgroundColor: aColor	opaqueBackgroundColor _ aColor! !!Viewer methodsFor: 'object fileIn' stamp: 'RAA 6/23/2000 17:27'!convertbosfcebbochvimolps0: varDict bosfcebbochvimlps0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'scriptedPlayer').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('openToDragNDrop').  Possibly store their info in another variable?"! !!CategoryViewer methodsFor: 'object fileIn' stamp: 'RAA 6/23/2000 17:27'!convertbosfcebbochvimolpsn0: varDict bosfcebbochvimlpsn0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'scriptedPlayer' 'namePane').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('openToDragNDrop').  Possibly store their info in another variable?"! !!StandardViewer methodsFor: 'object fileIn' stamp: 'RAA 6/23/2000 17:27'!convertbosfcebbochvimolpsf0: varDict bosfcebbochvimlpsf0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'scriptedPlayer' 'firstPanel').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('openToDragNDrop').  Possibly store their info in another variable?"! !!ViewerEntry methodsFor: 'object fileIn' stamp: 'RAA 6/23/2000 17:27'!convertbosfcebbochvimolph0: varDict bosfcebbochvimlph0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'helpPane').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('openToDragNDrop').  Possibly store their info in another variable?"! !!ViewerRow methodsFor: 'object fileIn' stamp: 'RAA 6/23/2000 17:27'!convertbosfcebbochvimolpe0: varDict bosfcebbochvimlpe0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'elementSymbol').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('openToDragNDrop').  Possibly store their info in another variable?"! !!WordArray methodsFor: 'fileIn/Out' stamp: 'RAA 6/23/2000 08:22'!writeOnGZIPByteStream: aStream 		aStream nextPutAllWordArray: self! !TransformationMorph subclass: #BOBTransformationMorph	instanceVariableNames: 'worldBoundsToShow '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!ProjectNavigationMorph removeSelector: #addButton:for:!Project class removeSelector: #bumpVersion:!Project removeSelector: #newVersion:!HandMorph removeSelector: #projectThumbnail!ImageSegment removeSelector: #writeForExportWithSources:!FileList subclass: #FileList2	instanceVariableNames: 'showDirsInFileList currentDirectorySelected fileSelectionBlock optionalButtonSpecs modalView '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!Smalltalk removeClassNamed: #Bob!"Postscript:Fix the global menu flap"Utilities updateMenuFlap!