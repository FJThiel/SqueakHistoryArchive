'From Squeak 2.4c of May 10, 1999 on 12 September 1999 at 11:35:06 pm'!"Change Set:		spectrumAnalyzer-jhmDate:			8 September 1999Author:			John MaloneyAdds support for viewing sound data in real time in severalways: as a time-varying wave, as a frequency spectrum,or as a sonogram (time/frequency plot). See the commentin SpectrumAnalyzerMorph for more details.Part of this facility is SoundInputStream, a subclass ofSoundRecorder designed to let clients process incomingsound data as it arrives.Dan Ingalls implemented the nifty sonogram view."!ImageMorph subclass: #Sonogram	instanceVariableNames: 'lastX scrollDelta columnForm minVal maxVal pixValMap '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Synthesis'!SoundRecorder subclass: #SoundInputStream	instanceVariableNames: 'bufferSize mutex '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Synthesis'!AlignmentMorph subclass: #SpectrumAnalyzerMorph	instanceVariableNames: 'soundInput statusLight levelMeter graphMorph sonogramMorph fft displayType '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!FFT methodsFor: 'initialization' stamp: 'jm 8/25/1999 21:59'!n	^ n! !!FFT methodsFor: 'bulk processing' stamp: 'jm 9/8/1999 17:10'!initializeHammingWindow: alpha	"Initialize the windowing function to the generalized Hamming window. See F. Richard Moore, Elements of Computer Music, p. 100. An alpha of 0.54 gives the Hamming window, 0.5 gives the hanning window."	| v midPoint |	window _ FloatArray new: n.	midPoint _ (n + 1) / 2.0.	1 to: n do: [:i |		v _ alpha + ((1.0 - alpha) * (2.0 * Float pi * ((i - midPoint) / n)) cos).		window at: i put: v].! !!FFT methodsFor: 'bulk processing' stamp: 'jm 9/8/1999 16:42'!initializeTriangularWindow	"Initialize the windowing function to the triangular, or Parzen, window. See F. Richard Moore, Elements of Computer Music, p. 100."	| v |	window _ FloatArray new: n.	0 to: (n // 2) - 1 do: [:i |		v _ i / ((n // 2) - 1).		window at: (i + 1) put: v.		window at: (n - i) put: v].! !!FFT methodsFor: 'bulk processing' stamp: 'jm 9/8/1999 17:40'!setSize: anIntegerPowerOfTwo	"Initialize variables and tables for performing an FFT on the given number of samples. The number of samples must be an integral power of two (e.g. 1024). Prepare data for use with the fast primitive."	self nu: (anIntegerPowerOfTwo log: 2) asInteger.	n = anIntegerPowerOfTwo ifFalse: [self error: 'size must be a power of two'].	sinTable _ sinTable asFloatArray.	permTable _ permTable asWordArray.	realData _ FloatArray new: n.	imagData _ FloatArray new: n.	self initializeHammingWindow: 0.54.  "0.54 for Hamming, 0.5 for hanning"! !!FFT methodsFor: 'bulk processing' stamp: 'jm 9/8/1999 17:55'!transformDataFrom: anIndexableCollection startingAt: index	"Forward transform a block of real data taken from from the given indexable collection starting at the given index. Answer a block of values representing the normalized magnitudes of the frequency components."	| j real imag out |	j _ 0.	index to: index + n - 1 do: [:i |		realData at: (j _ j + 1) put: (anIndexableCollection at: i)].	realData *= window.	imagData _ FloatArray new: n.	self pluginTransformData: true.	"compute the magnitudes of the complex results"	"note: the results are in bottom half; the upper half is just its mirror image"	real _ realData copyFrom: 1 to: (n / 2).	imag _ imagData copyFrom: 1 to: (n / 2).	out _ (real * real) + (imag * imag).	1 to: out size do: [:i | out at: i put: (out at: i) sqrt].	^ out! !!FFT class methodsFor: 'instance creation' stamp: 'jm 8/25/1999 12:49'!new: anIntegerPowerOfTwo	"Answer a new FFT instance for transforming data packets of the given size."	^ self new setSize: anIntegerPowerOfTwo! !!Sonogram commentStamp: '<historical>' prior: 0!Sonograms are imageMorphs that will repeatedly plot arrays of values as black on white columns moving to the right in time and scrolling left as necessary.!!Sonogram methodsFor: 'all' stamp: 'di 8/26/1999 08:59'!extent: newExtent	super image: (Form extent: newExtent depth: Display depth).	lastX _ -1.	columnForm _ Form extent: (32//image depth)@(image height) depth: image depth.	pixValMap _ ((1 to: 256) collect:			[:i | (Color gray: (256-i)/255.0) pixelValueForDepth: columnForm depth])		as: Bitmap.! !!Sonogram methodsFor: 'all' stamp: 'di 8/26/1999 09:01'!extent: extent minVal: min maxVal: max scrollDelta: d	minVal _ min.	maxVal _ max.	scrollDelta _ d.	self extent: extent." try following with scrolldelta = 1, 20, 200	| s data |	s _ Sonogram new extent: 200@50				minVal: 0.0 maxVal: 1.0 scrollDelta: 20.	World addMorph: s.	data _ (1 to: 133) collect: [:i | 0.0].	1 to: 300 do:		[:i | data at: (i\\133)+1 put: 1.0.		s plotColumn: data.		data at: (i\\133)+1 put: 0.0.		World doOneCycleNow].	s delete	"! !!Sonogram methodsFor: 'all' stamp: 'jm 9/7/1999 23:18'!plotColumn: dataArray	| chm1 i normVal r |	chm1 _ columnForm height -1.	0 to: chm1 do:		[:y | 		i _ y*(dataArray size-1)//chm1 + 1.		normVal _ ((dataArray at: i) - minVal) / (maxVal - minVal).		normVal < 0.0 ifTrue: [normVal _ 0.0].		normVal > 1.0 ifTrue: [normVal _ 1.0].		columnForm bits at: chm1-y+1 put: (pixValMap at: (normVal * 255.0) truncated + 1)].	(lastX _ lastX + 1) > (image width - 1) ifTrue:		[self scroll].	image copy: (r _ (lastX@0 extent: 1@image height))			from: (32//image depth-1)@0			in: columnForm rule: Form over.	"self changed."	self invalidRect: (r translateBy: self position)! !!Sonogram methodsFor: 'all' stamp: 'di 8/26/1999 00:40'!scroll	image copy: (scrollDelta@0 extent: (image width-scrollDelta)@image height)			from: image to: 0@0 rule: Form over.	lastX _ lastX - scrollDelta.	self changed! !!SoundInputStream commentStamp: 'jm 9/8/1999 15:26' prior: 0!This subclass of SoundRecorder supports real-time processing of incoming sound data. The sound input process queues raw sound buffers, allowing them to be read and processed by the client as they become available. A semaphore is used to synchronize between the record process and the client process. Since sound data is buffered, the client process may lag behind the input process without losing data.!!SoundInputStream reorganize!('initialization' initialize)('accessing' bufferCount bufferSize bufferSize: isRecording nextBufferOrNil)('recording controls' startRecording stopRecording)('private' allocateBuffer emitBuffer:)!!SoundInputStream methodsFor: 'initialization' stamp: 'jm 9/8/1999 15:22'!initialize	super initialize.	bufferSize _ 1024.	mutex _ nil.! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/8/1999 15:26'!bufferCount	"Answer the number of sound buffers that have been queued."	| n |	mutex ifNil: [^ 0].  "not recording"	mutex critical: [n _ recordedBuffers size].	^ n! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/6/1999 10:36'!bufferSize	^ bufferSize! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/8/1999 15:26'!bufferSize: aNumber	"Set the sound buffer size. Buffers of this size will be queued for the client to process."	bufferSize _ aNumber truncated.! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/8/1999 15:23'!isRecording	"Answer true if the sound input process is running."	^ recordProcess ~~ nil! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/6/1999 10:32'!nextBufferOrNil	"Answer the next input buffer or nil if no buffer is available."	| result |	mutex ifNil: [^ nil].  "not recording"	mutex critical: [		recordedBuffers size > 0			ifTrue: [result _ recordedBuffers removeFirst]			ifFalse: [result _ nil]].	^ result! !!SoundInputStream methodsFor: 'recording controls' stamp: 'jm 9/8/1999 15:23'!startRecording	"Start the sound input process."	recordProcess ifNotNil: [self stopRecording].	recordedBuffers _ OrderedCollection new: 100.	mutex _ Semaphore forMutualExclusion.	super startRecording.	paused _ false.! !!SoundInputStream methodsFor: 'recording controls' stamp: 'jm 9/8/1999 15:23'!stopRecording	"Turn off the sound input process and close the driver."	super stopRecording.	recordedBuffers _ nil.	mutex _ nil.! !!SoundInputStream methodsFor: 'private' stamp: 'jm 9/8/1999 15:24'!allocateBuffer	"Allocate a new buffer and reset nextIndex. This message is sent by the sound input process."	currentBuffer _ SoundBuffer newMonoSampleCount: bufferSize.	nextIndex _ 1.! !!SoundInputStream methodsFor: 'private' stamp: 'jm 9/8/1999 15:24'!emitBuffer: buffer	"Queue a buffer for later processing. This message is sent by the sound input process."	mutex critical: [recordedBuffers addLast: buffer].! !!SpectrumAnalyzerMorph commentStamp: 'jm 9/8/1999 20:00' prior: 0!I am a tool for analyzing sound data from a microphone, CD, or other input source in real time. I have several display modes:	signal		snapshots of the raw signal data as it arrives	spectrum	frequency spectrum of the signal data as it arrives	sonogram	scrolling plot of the frequency spectrum over time,			      where the vertical axis is frequency, the horizontal				  axis is time, and amount of energy at a given				  frequency is shown as a grayscale value with				  larger values being darkerTo use this tool, be sure that you have selected the proper sound source using you host OS facilities. Set the desired sampling rate and FFT size (try 22050 samples/sec and an FFT size of 512) then click on the 'start' button. Use the slider to adjust the level so that the yellow level indicator peaks somewhere between the middle and the right edge at the maximum signal level.Note that if the level meter peaks hit the right edge, you will get 'clipping', which creates a bunch of spurious high frequency noise in the frequency spectrum. If the display is set to 'signal' mode, you can actually see the tops and bottoms of the waveform being cut off when clipping occurs.Many machines may not be able to perform spectrum analysis in real time, especially at higher sampling rates and larger FFT sizes. In both 'signal' and 'spectrum' modes, this tool will skip data to try to keep up with real time. However, in 'sonogram' mode it always processes all the data, even if it falls behind. This allows you to get a complete sonogram without dropouts even on a slower machine. However, as the sonogram display falls behind there will be a larger and larger time lag between when a sound is input and when it appears on the display.The smaller the FFT size, the less frequency resolution you get. The lower the sampling rate, the less total frequency range you get. For an FFT size of N and a sampling rate of R, each of the N/2 'bins' of the frequency spectrum has a frequency resolution of R / N. For example, at a sampleing rate of 22050 samples/second, the total frequency range is 0 to 11025 Hz and an FFT of size 256 would divide this range into 128 bins (the output of an FFT of size N has N/2 bins), each of which covers a frequency band about 86 Hz wide.To increase time resolution, increase the sampling rate and decrease the FFT size.!!SpectrumAnalyzerMorph reorganize!('initialization' initialize)('menu and buttons' invokeMenu resetDisplay setDisplayType setFFTSize setSamplingRate start stop)('stepping' step stepTime stopStepping)('deletion' delete)('private' addButtonRow addLevelSlider buttonName:action: makeLevelMeter makeStatusLight processBuffer: removeAllDisplays showSignal showSonogram showSpectrum updateDisplay)!!SpectrumAnalyzerMorph methodsFor: 'initialization' stamp: 'jm 9/8/1999 17:59'!initialize	super initialize.	borderWidth _ 2.	orientation _ #vertical.	soundInput _ SoundInputStream new samplingRate: 22050.	fft _ FFT new: 512.	displayType _ 'sonogram'.	self addButtonRow.	self addLevelSlider.	self addMorphBack: self makeLevelMeter.	self addMorphBack: (Morph new extent: 10@10; color: Color transparent).  "spacer"	self resetDisplay.  "adds the display morph"! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 15:11'!invokeMenu	"Invoke the settings menu."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('set sampling rate'		setSamplingRate)		('set FFT size'			setFFTSize)		('set display type'		setDisplayType)).	aMenu invokeOn: self defaultSelection: nil.! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 12:52'!resetDisplay	"Recreate my display after changing some parameter such as FFT size."	displayType = 'signal' ifTrue: [self showSignal].	displayType = 'spectrum' ifTrue: [self showSpectrum].	displayType = 'sonogram' ifTrue: [self showSonogram].! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 15:12'!setDisplayType	"Set the display type."	| aMenu choice on |	aMenu _ CustomMenu new title: 'display type (currently ', displayType, ')'.	aMenu addList:	#(		('signal'	'signal')		('spectrum'	'spectrum')		('sonogram'	'sonogram')).	choice _ aMenu startUp.	choice ifNil: [^ self].	on _ soundInput isRecording.	self stop.	displayType _ choice.	self resetDisplay.	on ifTrue: [self start].! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 19:38'!setFFTSize	"Set the size of the FFT used for frequency analysis."	| aMenu sz on |	aMenu _ CustomMenu new title: 'FFT size (currently ', fft n printString, ')'.	((7 to: 10) collect: [:n | 2 raisedTo: n]) do:[:r | aMenu add: r printString action: r].	sz _ aMenu startUp.	sz ifNil: [^ self].	on _ soundInput isRecording.	self stop.	fft _ FFT new: sz.	self resetDisplay.	on ifTrue: [self start].! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 15:12'!setSamplingRate	"Set the sampling rate to be used for incoming sound data."	| aMenu rate on |	aMenu _ CustomMenu new title:		'Sampling rate (currently ', soundInput samplingRate printString, ')'.	#(11025 22050 44100) do:[:r | aMenu add: r printString action: r].	rate _ aMenu startUp.	rate ifNil: [^ self].	on _ soundInput isRecording.	self stop.	soundInput samplingRate: rate.	self resetDisplay.	on ifTrue: [self start].! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 15:12'!start	"Start displaying sound data."	displayType = 'signal'		ifTrue: [soundInput bufferSize: graphMorph width - (2 * graphMorph borderWidth)]		ifFalse: [soundInput bufferSize: fft n].	soundInput startRecording.! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 15:12'!stop	"Stop displaying sound data."	soundInput stopRecording.! !!SpectrumAnalyzerMorph methodsFor: 'stepping' stamp: 'jm 9/8/1999 19:05'!step	"Update the record light, level meter, and display."	| w |	"update the record light and level meter"	soundInput isRecording		ifTrue: [statusLight color: Color yellow]		ifFalse: [statusLight color: Color gray].	w _ ((121 * soundInput meterLevel) // 100) max: 1.	levelMeter width ~= w ifTrue: [levelMeter width: w].	"update the display if any data is available"	self updateDisplay.! !!SpectrumAnalyzerMorph methodsFor: 'stepping' stamp: 'jm 9/7/1999 22:26'!stepTime	^ 0! !!SpectrumAnalyzerMorph methodsFor: 'stepping' stamp: 'jm 9/6/1999 12:12'!stopStepping	"Turn off recording."	super stopStepping.	soundInput stopRecording.! !!SpectrumAnalyzerMorph methodsFor: 'deletion' stamp: 'jm 9/6/1999 14:40'!delete	"Turn off recording when this morph is deleted."	super delete.	soundInput stopRecording.! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 12:44'!addButtonRow	| r |	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Menu' action: #invokeMenu).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Start' action: #start).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Stop' action: #stop).	r addMorphBack: (Morph new extent: 12@1; color: Color transparent).	r addMorphBack: self makeStatusLight.	self addMorphBack: r.! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/7/1999 18:01'!addLevelSlider	| levelSlider r |	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: soundInput;		actionSelector: #recordLevel:;		adjustToValue: soundInput recordLevel.	r _ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jhm 10/15/97 14:30'!buttonName: aString action: aSymbol	^ SimpleButtonMorph new		target: self;		label: aString;		actionSelector: aSymbol! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 13:27'!makeLevelMeter	| outerBox |	outerBox _ RectangleMorph new extent: 125@14; color: Color lightGray.	levelMeter _ Morph new extent: 2@10; color: Color yellow.	levelMeter position: outerBox topLeft + (2@2).	outerBox addMorph: levelMeter.	^ outerBox! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 13:02'!makeStatusLight	| s |	statusLight _ RectangleMorph new extent: 24@19.	statusLight color: Color gray.	s _ StringMorph contents: 'On'.	s position: statusLight center - (s extent // 2).	statusLight addMorph: s.	^ statusLight! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 18:41'!processBuffer: buf	"Analyze one buffer of data."	| data |	displayType = 'signal'		ifTrue: [data _ buf]		ifFalse: [data _ fft transformDataFrom: buf startingAt: 1].	graphMorph ifNotNil: [graphMorph data: data; changed].	sonogramMorph ifNotNil: [		data _ data collect: [:v | v sqrt].  "square root compresses dynamic range"		data /= 400.0.		sonogramMorph plotColumn: (data copyFrom: 1 to: data size // 1)].! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 12:49'!removeAllDisplays	"Remove all currently showing displays."	sonogramMorph ifNotNil: [sonogramMorph delete].	graphMorph ifNotNil: [graphMorph delete].	sonogramMorph _ graphMorph _ nil.! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 19:56'!showSignal	"Display the actual signal waveform."	displayType _ 'signal'.	self removeAllDisplays.	graphMorph _ GraphMorph new.	graphMorph extent: (400 + (2 * graphMorph borderWidth))@128.	graphMorph data: (Array new: 100 withAll: 0).	graphMorph color: (Color r: 0.8 g: 1.0 b: 1.0).	self addMorphBack: graphMorph.	self extent: 10@10.  "shrink to minimum size"! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 19:43'!showSonogram	"Display a sonogram showing the frequency spectrum versus time."	| zeros h w |	displayType _ 'sonogram'.	self removeAllDisplays.	h _ fft n // 2.	h _ h min: 512 max: 64.	w _ 400.	sonogramMorph _		Sonogram new			extent: w@h			minVal: 0.0			maxVal: 1.0			scrollDelta: w.	zeros _ Array new: sonogramMorph height withAll: 0.	sonogramMorph width timesRepeat: [sonogramMorph plotColumn: zeros].	self addMorphBack: sonogramMorph.	self extent: 10@10.  "shrink to minimum size"! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 15:10'!showSpectrum	"Display the frequency spectrum."	displayType _ 'spectrum'.	self removeAllDisplays.	graphMorph _ GraphMorph new.	graphMorph extent: ((fft n // 2) + (2 * graphMorph borderWidth))@128.	graphMorph data: (Array new: fft n // 2 withAll: 0).	self addMorphBack: graphMorph.	self extent: 10@10.  "shrink to minimum size"! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 19:39'!updateDisplay	"Update the display if any data is available."	| buf bufCount |	soundInput bufferCount = 0 ifTrue: [^ self].	graphMorph ifNotNil: [		[soundInput bufferCount > 0] whileTrue: [			"skip to the most recent buffer"			buf _ soundInput nextBufferOrNil].		^ self processBuffer: buf].	sonogramMorph ifNotNil: [		"at small buffer sizes we have to update the sonogram in		 batches or we may get behind; shoot for 8 updates/second"		bufCount _ (soundInput samplingRate / (8 * soundInput bufferSize)) truncated max: 1.		[bufCount > 0 and: [soundInput bufferCount > 0]] whileTrue: [			self processBuffer: (soundInput nextBufferOrNil)]].! !!WaveEditor class methodsFor: 'instance creation' stamp: 'jm 9/6/1999 11:21'!openOn: dataCollection	"Open a new WaveEditor on the given sequencable collection of data."	^ (self new data: dataCollection) openInWorld! !Sonogram removeSelector: #image:minVal:maxVal:scrollDelta:!SoundInputStream removeSelector: #isBufferAvailable!SoundInputStream removeSelector: #emitPartialBuffer!SpectrumAnalyzerMorph removeSelector: #hideSonogram!SpectrumAnalyzerMorph removeSelector: #addRecordLevelSlider!SpectrumAnalyzerMorph removeSelector: #addButtonRows!SpectrumAnalyzerMorph removeSelector: #addSonographMorph!SpectrumAnalyzerMorph removeSelector: #menu!SpectrumAnalyzerMorph removeSelector: #showRawSignal!SpectrumAnalyzerMorph removeSelector: #hideSpectrum!SpectrumAnalyzerMorph removeSelector: #addRecordSlider!SpectrumAnalyzerMorph removeSelector: #removeCurrentDisplay!SpectrumAnalyzerMorph removeSelector: #addSpectrumMorph!Smalltalk removeClassNamed: #SpectrumAnalysisMorph!