'From Squeak2.8alpha of 12 January 2000 [latest update: #1916] on 8 March 2000 at 2:22:02 pm'!"Change Set:		ChangeSetUninstallDate:			8 March 2000Author:			Dan IngallsA hack that has the effect of uninstalling certain simple changeSets."!!ChangeSet commentStamp: 'di 3/8/2000 12:52' prior: 0!My instances keep track of the changes made to a system, so the user can write the changes on a file as source code (a "fileOut").  The order in which changes are made is not remembered.------classChanges -  Dictionary {class name -> Set {eg, #change, #rename, etc}}.methodChanges -  Dictionary {class name -> IdentityDictionary {selector -> {eg, #add, #change, #remove, #addedThenRemoved}}.classRemoves -  Set {class name (original)}.methodRemoves -  Dictionary {(Array with: class name with: selector) -> (Array with: source pointer with: category)}.name - a String used to name the changeSet, and thus any associated project or fileOut.preamble and postscript:  two strings that serve as prefix (useful for documentation) and suffix (useful for doits) to the fileout of the changeSet.structures -    Dictionary {#Rectangle -> #(<classVersionInteger> 'origin' 'corner')}.  Of  the names of the instances variables before any changes for all classes in classChanges, and all of their superclasses.  In the same format used in SmartRefStream.  Inst var names are strings.  superclasses -    Dictionary {#Rectangle -> #Object}.  Of all classes in classChanges, and all of their superclasses.	Structures and superclasses save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp).!!ChangeSet methodsFor: 'reverting methods' stamp: 'di 3/8/2000 14:17'!uninstall	| changes sel changeRecords pair vbOrNil |	"Hey -- it's a start..."	Smalltalk newChanges: self.	self changedClasses do:		[:aClass |		changes _ methodChanges at: aClass name ifAbsent: [nil].		changes ifNotNil:			[changes associationsDo: 				[:assn | sel _ assn key.				assn value == #add ifTrue:					[changeRecords _ aClass changeRecordsAt: sel.					(changeRecords == nil or: [changeRecords size < 1])						ifTrue: [self notify: 'Could not un-add ', 										aClass name, '>>', (sel contractTo: 20)]						ifFalse: [changeRecords first fileIn]].				assn value == #change ifTrue:					[changeRecords _ aClass changeRecordsAt: sel.					(changeRecords == nil or: [changeRecords size < 2])						ifTrue: [self notify: 'Could not un-change ', 										aClass name, '>>', (sel contractTo: 20)]						ifFalse: [changeRecords second fileIn]].				assn value == #remove ifTrue:					[pair _ methodRemoves							at: (Array with: aClass name with: sel)							ifAbsent: [nil].					pair == nil						ifTrue: [self notify: 'Could not un-remove ', 										aClass name, '>>', (sel contractTo: 20)]						ifFalse:						["pair = (sourcePointer category)"						vbOrNil _ VersionsBrowser new							scanVersionsOf: (CompiledMethod toReturnSelf setSourcePointer: pair first)							class: aClass meta: aClass isMeta							category: pair second							selector: sel.						vbOrNil == nil							ifTrue: [self notify: 'Could not un-remove ', 										aClass name, '>>', (sel contractTo: 20)]							ifFalse: [vbOrNil changeList first fileIn]]].				]]].	self clear! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 3/8/2000 13:55'!shiftedChangeSetMenu: aMenu	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.	parent ifNotNil:		[aMenu add: 'conflicts with opposite side' action: #methodConflictsWithOtherSide.			aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in the one on the opposite side of the change sorter.'.].	aMenu addLine.	aMenu add: 'check for slips' action: #lookForSlips.	aMenu balloonTextForLastItem: 'Check this change set for halts and references to Transcript.'.	aMenu add: 'check for unsent messages' action: #checkForUnsentMessages.	aMenu balloonTextForLastItem:'Check this change set for messages that are not sent anywhere in the system'.	aMenu addLine.	aMenu add: 'inspect change set' action: #inspectChangeSet.	aMenu balloonTextForLastItem: 'Open an inspector on this change set. (There are some details in a change set which you don''t see in a change sorter.)'.	aMenu add: 'update' action: #update.	aMenu balloonTextForLastItem: 'Update the display for this change set.  (This is done automatically when you activate this window, so is seldom needed.)'.	aMenu add: 'go to change set''s project' action: #goToChangeSetsProject.	aMenu balloonTextForLastItem: 'If this change set is currently associated with a Project, go to that project right now.'.	aMenu add: 'promote to top of list' action: #promoteToTopChangeSet.	aMenu balloonTextForLastItem:'Make this change set appear first in change-set lists in all change sorters.'.	aMenu add: 'clear this change set' action: #clearChangeSet.	aMenu balloonTextForLastItem: 'Reset this change set to a pristine state where it holds no information. CAUTION: this is destructive and irreversible!!'.	aMenu add: 'uninstall this change set' action: #uninstallChangeSet.	aMenu balloonTextForLastItem: 'Attempt to uninstall this change set. CAUTION: this may not work completely and is irreversible!!'.	aMenu addLine.	aMenu add: 'file into new...' action: #fileIntoNewChangeSet.	aMenu balloonTextForLastItem: 'Load a fileout from disk and place its changes into a new change set (seldom needed -- much better to do this from a file-list browser these days.)'.	aMenu addLine.	aMenu add: 'more...' action: #unshiftedYellowButtonActivity.	aMenu balloonTextForLastItem: 'Takes you back to the primary change-set menu.'.	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 3/8/2000 14:18'!uninstallChangeSet	"Attempt to uninstall the current change set, after confirmation."	self okToChange ifFalse: [^ self].	(self confirm: 'Uninstalling a changeSet is unreliable at best.It will only work if the changeSet consists only of singlechanges, additions and removals of methods, and ifno subsequent changes have been to any of them.No changes to classes will be undone.The changeSet will be cleared after uninstallation.Do you still wish to attempt to uninstall this changeSet?')	ifFalse: [^ self].	myChangeSet uninstall.	self changed: #relabel.	self changed: #classList.	self changed: #messageList.	self setContents.	self contentsChanged.! !