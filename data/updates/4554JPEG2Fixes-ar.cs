'From Squeak3.2alpha of 2 October 2001 [latest update: #4553] on 27 November 2001 at 12:51:29 am'!"Change Set:		JPEG2Fixes-arDate:			27 November 2001Author:			Andreas RaabFixes a problem with JPEG2Plugin - if not present you get #primitiveFailures rather than using the default plugin.Also optimizes various bits of code, removing (unneeded) argument tests against the receiver (which would have pointlessly prevented renaming JPEGReadWriter2 into something else).WARNING: The changes (in particular the first fix) require a new plugin to be build."!!JPEGReadWriter2 methodsFor: 'testing' stamp: 'ar 11/27/2001 00:40'!isPluginPresent	^self primJPEGPluginIsPresent! !!JPEGReadWriter2 methodsFor: 'testing' stamp: 'ar 11/27/2001 00:39'!understandsImageFormat	"Answer true if the image stream format is understood by this decoder."	self isPluginPresent ifFalse:[^false]. "cannot read it otherwise"	self next = 16rFF ifFalse: [^ false].	self next = 16rD8 ifFalse: [^ false].	^ true! !!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'ar 11/27/2001 00:39'!primJPEGPluginIsPresent	<primitive: 'primJPEGPluginIsPresent' module: 'JPEGReadWriter2Plugin'>	^false! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'ar 11/27/2001 00:48'!primImageHeight: aJPEGDecompressStruct	self export: true.	self		primitive: 'primImageHeight'		parameters: #(ByteArray).	"Various parameter checks"	self cCode: '		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(0))) >= (sizeof(struct jpeg_decompress_struct))); 		if (interpreterProxy->failed()) return null;	' inSmalltalk: [].	^(self cCode: '((j_decompress_ptr)aJPEGDecompressStruct)->image_height' inSmalltalk: [0])		 asOop: SmallInteger! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'ar 11/27/2001 00:49'!primImageWidth: aJPEGDecompressStruct	self export: true.	self		primitive: 'primImageWidth'		parameters: #(ByteArray).	"Various parameter checks"	self cCode: '		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(0))) >= (sizeof(struct jpeg_decompress_struct))); 		if (interpreterProxy->failed()) return null;	' inSmalltalk: [].	^(self cCode: '((j_decompress_ptr)aJPEGDecompressStruct)->image_width' inSmalltalk: [0])		asOop: SmallInteger! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'ar 11/27/2001 00:46'!primJPEGCompressStructSize	self export: true.	self		primitive: 'primJPEGCompressStructSize'		parameters: #().	^(self cCode: 'sizeof(struct jpeg_compress_struct)' inSmalltalk: [0])		asOop: SmallInteger! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'ar 11/27/2001 00:46'!primJPEGDecompressStructSize	self export: true.	self		primitive: 'primJPEGDecompressStructSize'		parameters: #().	^(self cCode: 'sizeof(struct jpeg_decompress_struct)' inSmalltalk: [0])		asOop: SmallInteger! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'ar 11/27/2001 00:46'!primJPEGErrorMgr2StructSize	self export: true.	self		primitive: 'primJPEGErrorMgr2StructSize'		parameters: #().	^(self cCode: 'sizeof(struct error_mgr2)' inSmalltalk: [0])		asOop: SmallInteger! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'ar 11/27/2001 00:45'!primJPEGPluginIsPresent	self export: true.	self		primitive: 'primJPEGPluginIsPresent'		parameters: #().	^true asOop: Boolean! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'ar 11/27/2001 00:47'!primJPEGReadHeader: aJPEGDecompressStruct fromByteArray: source errorMgr: aJPEGErrorMgr2Struct	| pcinfo pjerr sourceSize |	self export: true.	self		primitive: 'primJPEGReadHeaderfromByteArrayerrorMgr'		parameters: #(ByteArray ByteArray ByteArray). 	self var: #pcinfo declareC: 'j_decompress_ptr pcinfo'. 	self var: #pjerr declareC: 'error_ptr2 pjerr'.	"Avoid warnings when saving method"	self cCode: '' inSmalltalk: [		pcinfo _ nil. pjerr _ nil. sourceSize _ nil.		pcinfo. pjerr. sourceSize.	].	"Various parameter checks"	self cCode: '		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(2))) >= (sizeof(struct jpeg_decompress_struct)));		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(0))) >= (sizeof(struct error_mgr2))); 		if (interpreterProxy->failed()) return null;	' inSmalltalk: [].	self cCode: '		sourceSize = interpreterProxy->stSizeOf(interpreterProxy->stackValue(1));		pcinfo = (j_decompress_ptr)aJPEGDecompressStruct;		pjerr = (error_ptr2)aJPEGErrorMgr2Struct;		if (sourceSize) {			pcinfo->err = jpeg_std_error(&pjerr->pub);			pjerr->pub.error_exit = error_exit;			if (setjmp(pjerr->setjmp_buffer)) {				jpeg_destroy_decompress(pcinfo);				sourceSize = 0;			}			if (sourceSize) {				jpeg_create_decompress(pcinfo);				jpeg_mem_src(pcinfo, source, sourceSize);				jpeg_read_header(pcinfo, TRUE);			}		}	' inSmalltalk: [].! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'ar 11/27/2001 00:47'!primJPEGReadImage: aJPEGDecompressStruct fromByteArray: source onForm: form errorMgr: aJPEGErrorMgr2Struct	| pcinfo pjerr buffer rowStride formBits formDepth i j formPix ok rOff gOff bOff rOff2 gOff2 bOff2 formWidth formHeight pixPerWord formPitch formBitsSize sourceSize |	self export: true.	self		primitive: 'primJPEGReadImagefromByteArrayonFormerrorMgr'		parameters: #(ByteArray ByteArray Form ByteArray). 	self var: #pcinfo declareC: 'j_decompress_ptr pcinfo'. 	self var: #pjerr declareC: 'error_ptr2 pjerr'.	self var: #buffer declareC: 'JSAMPARRAY buffer'.	self var: #formBits declareC: 'unsigned * formBits'.	"Avoid warnings when saving method"	self cCode: '' inSmalltalk: [		pcinfo _ nil. pjerr _ nil. buffer _ nil. rowStride _ nil.		formDepth _ nil. formBits _ nil. i _ nil. j _ nil. formPix _ nil.		ok _ nil. rOff _ nil. gOff _ nil. bOff _ nil. rOff2 _ nil. gOff2 _ nil. bOff2 _ nil. sourceSize _ nil.		pcinfo. pjerr. buffer. rowStride. formBits. formDepth. i. j. formPix. ok.		rOff. gOff. bOff. rOff2. gOff2. bOff2. sourceSize.	].	formBits _self cCoerce: (interpreterProxy fetchPointer: 0 ofObject: form)  to: 'unsigned *'.	formDepth _ interpreterProxy fetchInteger: 3 ofObject: form.	"Various parameter checks"	self cCode: '		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(3))) >= (sizeof(struct jpeg_decompress_struct)));		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(0))) >= (sizeof(struct error_mgr2))); 		if (interpreterProxy->failed()) return null;	' inSmalltalk: [].	formWidth _ (self cCode: '((j_decompress_ptr)aJPEGDecompressStruct)->image_width' inSmalltalk: [0]).	formHeight _ (self cCode: '((j_decompress_ptr)aJPEGDecompressStruct)->image_height' inSmalltalk: [0]).	pixPerWord _ 32 // formDepth.	formPitch _ formWidth + (pixPerWord-1) // pixPerWord * 4.	formBitsSize _ interpreterProxy byteSizeOf: formBits.	interpreterProxy success: 		((interpreterProxy isWordsOrBytes: formBits)			and: [formBitsSize = (formPitch * formHeight)]).	interpreterProxy failed ifTrue: [^ nil].	self cCode: '		sourceSize = interpreterProxy->stSizeOf(interpreterProxy->stackValue(2));		pcinfo = (j_decompress_ptr)aJPEGDecompressStruct;		pjerr = (error_ptr2)aJPEGErrorMgr2Struct;		pcinfo->err = jpeg_std_error(&pjerr->pub);		pjerr->pub.error_exit = error_exit;		ok = 1;		if (setjmp(pjerr->setjmp_buffer)) {			jpeg_destroy_decompress(pcinfo);			ok = 0;		}		if (ok) {			ok = jpeg_mem_src_newLocationOfData(pcinfo, source, sourceSize);			if (ok) {				jpeg_start_decompress(pcinfo);				rowStride = pcinfo->output_width * pcinfo->output_components;				if (pcinfo->out_color_components == 3) {					rOff = 0; gOff = 1; bOff = 2;					rOff2 = 3; gOff2 = 4; bOff2 = 5;				} else {					rOff = 0; gOff = 0; bOff = 0;					rOff2 = 1; gOff2 = 1; bOff2 = 1;				}				/* Make a one-row-high sample array that will go away when done with image */				buffer = (*(pcinfo->mem)->alloc_sarray)					((j_common_ptr) pcinfo, JPOOL_IMAGE, rowStride, 1);				/* Step 6: while (scan lines remain to be read) */				/*           jpeg_read_scanlines(...); */				/* Here we use the library state variable cinfo.output_scanline as the				 * loop counter, so that we dont have to keep track ourselves.				 */				while (pcinfo->output_scanline < pcinfo->output_height) {					/* jpeg_read_scanlines expects an array of pointers to scanlines.					 * Here the array is only one element long, but you could ask for					 * more than one scanline at a time if thats more convenient.					 */					(void) jpeg_read_scanlines(pcinfo, buffer, 1);					switch (formDepth) {						case 32:							for(i = 0, j = 1; i < rowStride; i +=(pcinfo->out_color_components), j++) {								formPix = (255 << 24) | (buffer[0][i+rOff] << 16) | (buffer[0][i+gOff] << 8) | buffer[0][i+bOff];								formBits [ ((pcinfo->output_scanline - 1) * (pcinfo->image_width)) + j ] = formPix;							}							break;						case 16:							for(i = 0, j = 1; i < rowStride; i +=(pcinfo->out_color_components*2), j++) {								formPix = ((buffer[0][i+rOff] & 248) << 23) | ((buffer[0][i+gOff] & 248) << 18) | 									((buffer[0][i+bOff] & 248) << 13) | ((buffer[0][i+rOff2] & 248) << 7) | 									((buffer[0][i+gOff2] & 248) << 2) | ((buffer[0][i+bOff2] & 248) >> 3);								formBits [ ((pcinfo->output_scanline - 1) * (pcinfo->image_width)) / 2 + j ] = formPix;							}							break;					}				}				jpeg_finish_decompress(pcinfo);			}			jpeg_destroy_decompress(pcinfo);		}	' inSmalltalk: [].! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'ar 11/27/2001 00:48'!primJPEGWriteImage: aJPEGCompressStruct onByteArray: destination form: form quality: quality progressiveJPEG: progressiveFlag errorMgr: aJPEGErrorMgr2Struct	| pcinfo pjerr buffer rowStride formBits formWidth formHeight formDepth i j formPix destinationSize pixPerWord formPitch formBitsSize |	self export: true.	self		primitive: 'primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgr'		parameters: #(ByteArray ByteArray Form SmallInteger Boolean ByteArray). 	self var: #pcinfo declareC: 'j_compress_ptr pcinfo'. 	self var: #pjerr declareC: 'error_ptr2 pjerr'.	self var: #buffer declareC: 'JSAMPARRAY buffer'.	self var: #formBits declareC: 'unsigned * formBits'.	"Avoid warnings when saving method"	self cCode: '' inSmalltalk: [		pcinfo _ nil. pjerr _ nil. buffer _nil. rowStride _ nil. formBits _ nil. 		formWidth _ nil. formHeight _ nil. formDepth _ nil. i _ nil. j _ nil. formPix _ nil. destinationSize _ nil.		pcinfo. pjerr. buffer. rowStride. formBits. formWidth. formHeight. formDepth. i. j. formPix. destinationSize.	].	formBits _self cCoerce: (interpreterProxy fetchPointer: 0 ofObject: form)  to: 'unsigned *'.	formWidth _ interpreterProxy fetchInteger: 1 ofObject: form.	formHeight _ interpreterProxy fetchInteger: 2 ofObject: form.	formDepth _ interpreterProxy fetchInteger: 3 ofObject: form.	"Various parameter checks"	self cCode: '		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(5))) >= (sizeof(struct jpeg_compress_struct)));		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(0))) >= (sizeof(struct error_mgr2))); 		if (interpreterProxy->failed()) return null;	' inSmalltalk: [].	pixPerWord _ 32 // formDepth.	formPitch _ formWidth + (pixPerWord-1) // pixPerWord * 4.	formBitsSize _ interpreterProxy byteSizeOf: formBits.	interpreterProxy success: 		((interpreterProxy isWordsOrBytes: formBits)			and: [formBitsSize = (formPitch * formHeight)]).	interpreterProxy failed ifTrue: [^ nil].	self cCode: '		destinationSize = interpreterProxy->stSizeOf(interpreterProxy->stackValue(4));		pcinfo = (j_compress_ptr)aJPEGCompressStruct;		pjerr = (error_ptr2)aJPEGErrorMgr2Struct;		if (destinationSize) {			pcinfo->err = jpeg_std_error(&pjerr->pub);			pjerr->pub.error_exit = error_exit;			if (setjmp(pjerr->setjmp_buffer)) {				jpeg_destroy_compress(pcinfo);				destinationSize = 0;			}			if (destinationSize) {				jpeg_create_compress(pcinfo);				jpeg_mem_dest(pcinfo, destination, &destinationSize);				pcinfo->image_width = formWidth;				pcinfo->image_height = formHeight;				pcinfo->input_components = 3;				pcinfo->in_color_space = JCS_RGB;				jpeg_set_defaults(pcinfo);				if (quality > 0)					jpeg_set_quality (pcinfo, quality, 1);				if (progressiveFlag)					jpeg_simple_progression(pcinfo);				jpeg_start_compress(pcinfo, TRUE);				rowStride = formWidth * 3;				/* Make a one-row-high sample array that will go away 				  when done with image */				buffer = (*(pcinfo->mem)->alloc_sarray)					((j_common_ptr) pcinfo, JPOOL_IMAGE, rowStride, 1);				while (pcinfo->next_scanline < pcinfo->image_height) {					switch (formDepth) {						case 32:							for(i = 0, j = 1; i < rowStride; i +=3, j++) {								formPix = formBits [ ((pcinfo->next_scanline) * formWidth) + j ];								buffer[0][i] = (formPix >> 16) & 255;								buffer[0][i+1] = (formPix >> 8) & 255;								buffer[0][i+2] = formPix & 255;							}							break;						case 16:							for(i = 0, j = 1; i < rowStride; i +=6, j++) {								formPix = formBits [ ((pcinfo->next_scanline) * formWidth) / 2 + j ];								buffer[0][i] = (formPix >> 23) & 248;								buffer[0][i+1] = (formPix >> 18) & 248;								buffer[0][i+2] = (formPix >> 13) & 248;								buffer[0][i+3] = (formPix >> 7) & 248;								buffer[0][i+4] = (formPix >> 2) & 248;								buffer[0][i+5] = (formPix << 3) & 248;							}							break;					}					(void) jpeg_write_scanlines(pcinfo, buffer, 1);				}				jpeg_finish_compress(pcinfo);				jpeg_destroy_compress(pcinfo);			}		}	' inSmalltalk: [].	^(self cCode: 'destinationSize' inSmalltalk: [0])		asOop: SmallInteger! !