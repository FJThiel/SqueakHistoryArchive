'From Squeak3.1alpha of 6 February 2001 [latest update: #3848] on 24 March 2001 at 9:57:57 pm'!"Change Set:		MacVM3.0.10Date:			24 March 2001Author:			johnmci@smalltalkconsulting.comChange set to bring image upto mac source code 3.0.10"!!Interpreter class methodsFor: 'translation' stamp: 'JMM 3/16/2001 11:14'!translate: fileName doInlining: inlineFlag forBrowserPlugin: pluginFlag	"Note: The pluginFlag is meaningless on Windows and Unix. On these platforms Squeak runs as it's own process and doesn't need any special attention from the VMs point of view. Meaning that NONE of the required additional functions will be supported. In other words, the pluginFlag is not needed and not supported."	"Translate the Smalltalk description of the virtual machine into C. If inlineFlag is true,small method bodies are inlined to reduce procedure call overhead. On the PPC, this results in a factor of three speedup with only 30% increase in code size. If pluginFlag is true, generate code for an interpreter that runs as a browser plugin (Netscape or IE)."	| doInlining cg exports |	doInlining _ inlineFlag.	pluginFlag ifTrue: [doInlining _ true].  "must inline when generating browser plugin"	Interpreter initialize.	ObjectMemory initialize.	GenerateBrowserPlugin _ pluginFlag.	cg _ CCodeGenerator new initialize.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	"Get all the named prims from the VM.	Note: the format of exports is:		pluginName -> Array of: primitiveName.	so we can generate a nice table from it."	exports _ Array with: '' -> cg exportedPrimitiveNames asArray.	cg storeCodeOnFile: fileName doInlining: doInlining.	"Add our plugins"	{		"Graphics"			"Note: BitBltSimulation should go first, 			because three of it's entries might be 			looked up quite often (due to refs from 			InterpreterProxy). This will go away at			some point but for now it's a good idea			to have those entries early in the table."		BitBltSimulation.			BalloonEnginePlugin. 		SurfacePlugin. "To support OS surfaces through FXBlt"		"I/O subsystems"		FilePlugin.		SocketPlugin.		MIDIPlugin. 		SerialPlugin. 		JoystickTabletPlugin. 		AsynchFilePlugin. 		"Sound"		SoundPlugin. 		SoundGenerationPlugin.		ADPCMCodecPlugin.		KlattSynthesizerPlugin.		SoundCodecPlugin.	 	"Numerics"		LargeIntegersPlugin.		FFTPlugin. 		FloatArrayPlugin. 		Matrix2x3Plugin. 		"Compression"		DeflatePlugin.		"Others"		B3DEnginePlugin.		DSAPlugin.		DropPlugin. 		MiscPrimitivePlugin.		SecurityPlugin.		JPEGReaderPlugin.		StarSqueakPlugin.		"Note: Optionally, you can translate the following as builtins.		As of Squeak 2.7 they are not builtins by default:			FFIPlugin.		"	} do:[:plugin|		cg _ plugin translate: plugin moduleName, '.c'					doInlining: doInlining					locally: true.		exports _ exports copyWith: 			(plugin moduleName -> cg exportedPrimitiveNames asArray).	].	self storeExports: exports on: 'sqNamedPrims.h'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 3/24/2001 21:55'!macArchiveBinaryFile	"Answer the binary contents of a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be a folder containing the project files."	"To create the text for this method evaulate:		| in out |		in _ (FileStream oldFileNamed: 'projectArchive.sit') binary.		out _ WriteStream on: (String new: 100000).		out nextPutAll: '#('.		[in atEnd] whileFalse: [out nextPutAll: in next printString; space].		out skip: -1.		out nextPutAll: ')'.		in close.		Clipboard clipboardText: out contents asText	  and then do paste into this method."	^ #(83 116 117 102 102 73 116 32 40 99 41 49 57 57 55 45 49 57 57 56 32 65 108 97 100 100 105 110 32 83 121 115 116 101 109 115 44 32 73 110 99 46 44 32 104 116 116 112 58 47 47 119 119 119 46 97 108 97 100 100 105 110 115 121 115 46 99 111 109 47 83 116 117 102 102 73 116 47 13 10 26 0 5 16 0 0 111 18 0 0 0 114 0 10 0 0 0 114 166 90 0 43 0 5 1 96 1 255 0 0 0 0 0 0 165 165 165 165 1 0 0 62 0 16 181 144 51 21 182 158 25 127 0 0 0 0 0 0 11 3 0 0 0 0 0 14 47 50 0 0 37 20 0 0 9 183 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 46 99 0 1 249 212 84 69 88 84 67 87 73 69 1 0 1 128 1 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 106 0 0 0 0 15 0 66 193 212 138 116 88 41 37 231 118 79 249 86 183 220 130 201 119 237 194 11 107 95 101 129 233 78 237 233 41 2 10 134 65 190 14 57 147 88 117 246 30 129 230 100 86 124 160 181 213 228 113 176 242 110 15 116 236 78 49 113 111 82 137 215 100 243 164 56 26 150 173 165 69 200 187 255 179 112 28 55 170 135 33 198 200 235 206 99 142 62 109 255 116 149 57 0 236 41 186 92 188 174 38 174 192 66 193 212 132 70 70 86 227 229 250 240 216 108 46 2 127 7 118 93 193 98 100 220 19 200 129 89 135 89 82 22 238 49 159 133 108 171 14 212 223 34 215 77 208 114 160 164 237 185 214 129 65 199 201 45 211 163 103 203 58 2 85 140 45 151 178 152 115 9 199 215 95 96 151 105 218 21 183 124 139 66 246 165 122 233 239 249 49 33 230 241 98 152 155 66 5 97 56 210 80 40 74 50 161 38 49 191 246 13 248 37 22 30 82 47 247 193 20 8 253 47 112 160 72 112 53 215 204 3 97 248 96 8 243 221 18 149 108 14 129 125 171 25 125 64 92 146 29 121 208 175 185 114 183 252 116 88 47 20 203 91 54 195 197 212 254 215 49 246 175 214 179 20 62 218 106 240 184 65 250 38 189 140 67 51 74 95 30 3 237 219 189 131 26 139 234 59 182 38 237 228 223 81 228 70 109 151 93 182 102 227 203 12 157 152 107 15 98 148 171 41 204 102 172 62 195 233 155 129 52 241 31 197 124 118 99 45 58 83 248 22 215 210 251 42 253 224 32 223 130 124 29 99 117 213 224 39 13 123 115 248 26 221 26 239 139 238 20 111 20 56 127 75 111 87 227 74 59 31 173 85 118 51 26 21 56 145 199 107 6 134 163 54 13 38 143 9 8 177 101 138 176 126 236 42 83 222 165 174 137 128 18 108 62 172 104 206 82 31 153 2 182 57 73 14 84 208 156 251 177 59 232 160 12 252 203 218 179 103 69 40 108 127 129 76 239 43 241 84 12 202 12 118 247 134 247 28 5 26 17 8 152 197 86 37 168 231 169 178 114 72 86 108 222 32 244 59 133 232 143 193 13 133 147 126 127 149 24 121 2 38 68 52 152 209 111 150 184 27 137 253 238 123 197 0 118 134 239 237 36 138 92 9 194 243 159 213 60 212 20 229 59 28 20 233 18 161 31 106 165 1 110 83 216 106 180 249 207 9 174 17 94 185 168 244 3 4 168 140 63 65 99 190 250 119 64 70 17 171 160 166 169 104 159 33 175 236 14 164 90 174 65 175 124 152 30 15 87 146 118 109 236 131 130 220 219 214 112 125 170 137 231 54 250 21 145 43 231 188 66 60 145 144 78 191 182 237 122 40 55 70 174 38 200 113 225 103 84 13 29 121 130 211 114 223 222 52 197 13 242 137 125 59 249 152 208 14 117 204 232 95 173 10 254 158 64 113 32 71 211 118 10 37 152 22 6 193 1 255 147 16 255 96 95 2 197 244 163 41 80 165 64 231 82 177 26 111 196 195 16 244 124 241 119 42 72 98 152 240 138 13 187 140 50 8 203 25 228 139 176 231 43 188 185 2 244 190 171 127 194 95 139 23 204 75 146 60 62 27 80 38 93 38 145 109 19 117 6 190 225 110 85 211 48 214 67 194 48 118 230 103 121 110 231 193 135 164 195 102 232 253 49 148 47 128 195 236 125 10 219 186 74 154 99 167 196 60 86 195 220 106 181 140 85 69 75 218 24 134 11 31 42 184 151 115 226 63 107 52 127 87 90 27 209 125 49 244 52 72 106 47 168 194 221 133 102 80 172 93 30 180 148 98 219 250 1 131 80 231 16 175 251 155 120 51 58 133 74 44 194 98 69 220 203 116 191 232 6 60 149 104 160 232 101 60 176 56 85 193 184 154 196 187 176 181 220 6 241 108 26 22 183 125 180 240 179 101 192 98 125 237 3 89 114 235 91 209 164 113 1 58 129 69 227 29 19 29 199 223 52 106 86 210 28 98 88 130 229 148 120 16 129 14 17 4 222 44 49 251 34 155 53 1 122 248 192 61 173 28 105 15 199 20 82 30 53 37 81 146 117 100 246 78 108 152 234 93 106 164 44 100 57 126 9 134 155 27 184 21 148 185 94 106 50 113 228 79 94 34 151 21 160 54 33 4 249 230 134 176 70 241 249 85 152 252 212 193 251 181 238 242 57 219 252 62 154 74 65 219 88 115 39 77 236 5 188 230 126 109 127 233 91 10 224 186 224 60 237 252 238 150 54 161 201 94 8 244 145 47 44 217 137 239 234 201 42 8 178 49 89 199 176 56 165 31 101 19 109 234 101 137 162 10 229 183 144 68 242 150 52 133 117 88 173 140 84 230 109 53 133 118 31 127 28 54 7 230 85 169 251 254 192 6 169 172 189 140 22 174 91 19 91 125 223 162 84 237 230 213 183 153 250 131 177 111 6 84 183 247 13 76 39 186 31 198 85 4 65 32 19 1 99 145 201 225 227 243 17 214 185 26 33 101 205 44 160 34 195 147 137 18 207 88 193 239 159 19 49 180 186 110 34 91 81 126 47 101 10 118 12 117 42 111 147 156 94 195 157 204 248 229 229 155 103 232 66 107 220 242 138 252 243 151 217 136 131 173 212 193 219 166 253 173 88 80 220 63 46 109 88 232 90 249 96 67 199 255 136 27 154 43 84 216 241 187 178 227 175 65 114 73 13 15 98 255 39 134 162 119 232 163 16 23 93 129 62 166 157 15 154 27 26 22 115 8 168 226 84 233 64 121 6 75 60 59 127 229 225 29 214 193 226 73 79 102 74 60 56 130 137 229 133 2 50 59 52 230 115 36 203 162 101 18 167 216 183 101 153 45 171 24 125 246 212 22 150 51 149 179 153 191 89 161 218 135 97 19 194 50 34 223 113 101 103 136 83 76 55 48 36 80 56 226 27 48 120 156 42 19 32 20 17 57 39 33 219 123 249 192 127 10 182 75 171 92 189 220 14 220 60 159 227 228 14 241 235 112 90 20 251 157 160 3 36 236 95 173 58 230 127 69 243 123 75 97 113 205 83 246 125 11 125 96 36 176 106 177 61 42 181 20 175 94 167 143 126 251 254 160 166 65 77 62 9 249 97 143 85 228 244 116 212 36 139 27 39 2 205 126 120 142 16 221 171 238 9 71 136 127 183 207 62 15 86 53 15 2 102 101 179 61 141 49 213 40 141 163 67 190 184 255 243 129 31 131 167 254 204 179 48 58 103 182 95 167 251 52 47 18 107 18 137 227 164 93 85 188 234 111 109 2 84 181 250 201 87 56 179 139 122 116 9 72 150 26 201 3 16 131 116 158 40 94 162 107 116 254 167 70 163 135 76 238 186 199 185 34 229 206 216 82 176 11 88 86 57 139 30 2 208 123 57 141 221 171 211 186 142 118 126 139 154 109 57 79 1 35 167 40 44 39 213 242 211 220 168 159 200 169 179 212 88 68 78 200 147 37 40 78 169 30 98 229 242 15 101 5 179 4 239 182 164 66 15 21 205 242 169 118 60 166 24 139 110 88 102 100 95 76 164 156 185 94 78 122 188 84 74 244 3 153 155 54 89 214 52 181 186 49 248 74 61 63 130 1 251 48 92 241 131 25 214 90 146 245 111 208 0 200 130 56 240 165 169 148 206 222 128 170 66 144 165 235 199 35 41 172 79 16 73 84 79 60 126 86 20 84 57 189 173 108 83 108 81 41 110 196 34 198 64 130 167 53 95 252 127 145 160 17 25 107 30 200 4 122 235 171 27 245 83 163 114 251 243 83 92 90 202 225 71 136 233 48 236 166 227 153 9 44 86 152 46 157 33 106 211 38 217 131 189 158 77 118 186 137 83 106 231 38 183 90 52 35 137 96 149 252 106 81 140 59 206 123 111 194 70 128 243 110 236 189 248 13 44 218 175 155 189 61 117 24 11 169 190 120 244 49 97 84 33 238 113 123 121 234 200 117 143 213 164 67 118 136 81 156 181 97 170 195 15 90 84 197 162 128 180 123 146 157 140 166 23 62 191 219 207 52 11 47 102 15 132 239 222 55 33 195 105 219 7 235 139 152 116 60 25 96 195 178 61 14 158 181 173 197 130 3 51 243 102 76 103 143 10 245 92 220 236 141 223 116 227 66 7 57 153 114 238 10 230 232 176 12 175 132 255 205 252 18 152 205 169 191 124 59 188 115 70 80 37 198 61 238 169 19 8 73 36 110 103 133 105 74 11 15 219 222 225 80 37 208 46 80 225 212 115 148 86 235 203 83 7 141 117 136 142 4 23 62 124 10 94 45 49 81 53 68 172 40 141 44 61 248 53 189 171 93 232 151 125 187 242 44 48 78 122 14 155 71 149 26 249 110 4 137 252 232 107 95 133 111 248 39 32 216 250 139 71 199 65 188 109 185 222 173 38 154 41 26 203 164 65 78 224 92 171 208 90 72 55 177 173 76 81 231 243 216 204 118 128 229 102 224 120 76 223 0 232 167 190 139 96 143 251 23 60 117 73 185 52 25 41 30 92 16 109 65 55 254 254 173 95 201 191 193 56 212 8 23 212 173 150 167 92 25 22 96 99 170 165 164 40 36 195 183 62 219 4 67 46 22 63 222 5 189 85 231 135 117 193 81 183 28 185 150 204 45 138 16 29 249 195 34 17 152 49 55 161 150 67 67 238 114 100 72 91 0 22 231 161 15 143 49 222 113 6 12 169 143 119 228 135 153 170 60 177 165 119 120 180 81 178 118 192 182 42 171 188 123 62 224 76 89 178 221 232 21 1 32 55 48 174 83 32 204 196 152 115 160 94 162 76 36 234 130 46 208 158 156 130 16 2 200 63 214 12 68 238 216 11 69 230 210 144 197 49 0 137 72 242 7 201 79 14 15 92 223 226 57 137 113 156 96 94 22 62 239 156 25 246 159 72 150 236 47 148 93 81 82 160 65 193 218 226 5 173 68 149 131 185 38 21 54 28 45 163 133 100 249 71 53 193 81 236 219 46 36 117 122 241 67 70 160 158 137 200 28 140 228 117 216 92 197 139 107 45 76 132 225 120 25 241 135 183 155 93 124 61 178 162 153 124 169 222 88 143 122 87 102 247 47 37 141 255 232 110 183 43 235 205 24 115 77 112 204 130 226 183 244 107 237 88 133 215 112 156 91 244 40 149 126 211 18 61 248 243 242 234 1 67 155 205 165 46 241 183 45 57 192 220 209 108 240 103 75 84 225 56 241 98 50 22 74 38 110 229 178 174 113 149 105 219 99 204 9 187 142 57 11 80 19 222 31 78 163 164 81 225 238 93 139 39 45 77 116 191 122 147 93 63 47 1 43 54 59 33 120 183 197 115 221 125 55 140 107 197 207 252 168 189 93 204 160 15 6 92 87 21 69 13 171 60 68 240 229 169 136 185 10 16 114 157 62 4 62 98 10 25 57 208 210 238 206 221 244 23 46 24 203 6 182 53 192 196 161 244 15 113 51 114 84 111 207 79 49 240 83 61 153 132 114 177 48 194 95 237 67 44 187 237 135 159 159 33 223 31 214 108 74 197 120 50 91 204 64 45 244 193 54 170 53 199 41 10 70 220 145 68 218 10 32 158 205 48 186 18 120 100 158 47 3 157 62 91 7 54 31 217 83 233 226 95 125 28 51 6 123 194 39 147 63 52 100 201 220 96 226 242 131 85 96 214 22 71 194 69 5 99 37 88 48 22 245 153 70 245 85 38 116 133 224 61 191 197 143 169 70 94 167 89 162 114 248 119 73 40 186 97 52 83 229 239 50 37 67 25 0 165 165 165 165 1 0 0 64 0 16 181 144 51 13 182 158 25 127 0 0 0 114 0 0 13 78 0 0 0 0 0 16 118 69 0 0 3 20 0 0 1 114 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 46 112 99 104 0 1 88 136 84 69 88 84 67 87 73 69 1 0 0 192 2 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 103 0 0 0 0 15 0 66 193 212 165 47 158 101 143 90 111 232 62 137 252 56 69 246 56 222 197 11 110 186 70 46 68 245 227 157 58 176 118 108 255 85 62 40 178 85 18 69 169 203 40 18 219 49 207 252 15 57 78 136 238 192 137 69 135 101 84 46 156 13 5 175 9 5 162 245 172 207 165 169 206 88 73 211 171 164 174 112 63 71 184 31 221 37 166 79 5 131 15 114 244 238 207 216 239 17 227 177 67 160 66 193 212 154 175 240 32 110 231 176 220 75 122 67 45 140 218 152 26 188 19 16 70 46 100 12 102 162 171 207 147 232 46 129 230 224 142 44 70 162 102 82 16 65 169 232 58 197 1 226 230 247 241 20 175 215 67 32 203 217 208 134 187 150 162 63 110 169 185 56 142 225 246 180 33 114 124 5 37 84 212 128 30 164 229 208 216 224 187 2 126 209 51 142 7 56 139 220 232 168 56 210 119 197 236 95 113 121 147 62 5 16 6 102 148 120 76 237 88 4 46 152 207 227 190 58 105 25 63 228 30 242 145 30 205 193 119 28 65 161 6 85 113 254 35 25 218 241 155 57 46 34 101 87 219 177 175 90 37 23 192 16 110 135 14 201 90 113 155 204 60 215 16 232 111 135 218 123 36 119 224 93 163 67 233 232 62 127 241 177 118 93 131 253 225 94 147 211 226 106 223 56 140 40 243 210 212 240 205 25 69 158 223 23 7 45 121 161 103 21 93 76 191 131 11 37 220 95 159 108 53 71 237 228 38 192 96 36 234 168 14 101 68 218 187 125 239 67 136 208 224 145 202 41 73 44 92 125 93 164 127 252 148 199 42 76 2 0 50 102 61 155 95 144 49 242 226 212 139 39 169 250 165 133 244 188 11 198 113 244 133 255 208 95 234 165 90 112 27 52 250 90 78 166 0 202 127 35 59 223 131 14 154 81 218 181 53 29 254 103 48 33 191 225 6 186 233 121 161 97 169 147 218 120 247 111 39 193 212 57 27 102 129 167 141 48 58 146 236 83 180 135 36 193 196 77 181 97 218 24 94 119 88 225 88 61 107 38 42 0 165 165 165 165 1 0 0 70 0 16 181 144 51 13 182 158 25 125 0 0 11 3 0 0 15 252 0 0 0 0 0 22 20 235 0 0 3 180 0 0 1 205 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 67 97 114 98 111 110 46 112 99 104 0 1 219 219 84 69 88 84 67 87 73 69 1 0 0 16 0 16 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 105 0 0 0 0 15 0 66 193 212 165 47 158 104 163 81 45 121 217 33 168 151 12 136 51 216 133 159 78 214 216 43 6 93 88 173 49 224 16 210 176 244 190 46 112 249 208 12 31 155 208 114 175 160 237 166 80 129 149 37 165 111 12 49 64 250 168 169 159 82 99 244 238 46 66 203 196 69 63 252 89 175 97 38 187 103 169 162 122 93 198 238 248 174 171 90 231 91 24 116 109 194 102 235 220 101 188 198 239 167 48 0 66 193 212 247 142 41 244 252 170 32 131 125 120 226 219 34 155 40 95 65 156 245 152 111 218 35 102 116 216 131 145 17 84 107 97 158 240 249 195 150 60 120 140 104 228 134 193 204 31 57 215 166 99 44 206 176 32 16 144 208 6 248 187 61 109 226 227 51 211 25 218 191 40 12 114 22 28 230 0 112 11 172 202 32 219 160 175 46 72 139 187 24 169 29 138 113 109 138 194 65 131 26 203 70 229 19 88 5 218 129 23 174 244 179 27 110 213 99 88 249 52 149 107 131 128 11 191 219 77 60 140 147 221 41 5 154 71 244 111 11 122 216 102 224 199 124 224 181 243 197 90 177 66 36 17 3 41 236 155 135 117 157 197 125 86 112 49 216 189 27 139 184 235 236 11 77 248 224 96 79 164 194 90 103 41 162 119 82 173 71 116 83 120 63 237 133 59 95 243 179 182 38 66 89 112 120 57 175 247 2 86 164 221 215 242 66 72 241 206 94 82 185 213 183 84 158 243 111 184 131 123 154 113 69 129 63 216 193 18 183 237 229 86 226 139 223 239 210 173 153 53 67 49 7 198 215 211 213 85 237 110 87 144 203 47 169 210 32 17 124 119 167 84 218 32 64 80 64 213 139 46 73 67 237 85 242 129 68 80 18 116 121 38 21 132 110 38 88 152 155 85 234 152 132 14 186 223 127 213 177 161 118 126 164 93 140 86 9 39 140 158 128 15 121 128 22 82 198 32 125 160 105 176 229 213 67 60 105 93 166 53 20 133 196 110 63 239 200 252 182 252 210 104 194 171 61 38 193 140 109 223 92 105 43 228 169 222 61 252 104 255 66 238 34 62 131 239 211 193 88 118 48 247 65 45 181 8 92 165 55 106 219 2 60 38 114 62 64 145 43 151 179 227 59 232 214 164 43 226 209 187 193 230 212 51 34 107 155 72 0 26 242 4 241 9 64 80 182 179 217 254 181 123 67 245 13 80 221 209 230 9 60 229 105 10 138 253 27 231 68 155 196 137 233 97 229 82 175 213 222 96 165 165 165 165 1 0 0 61 0 0 172 94 103 33 181 100 42 6 0 0 13 78 0 0 28 169 0 0 0 0 0 13 171 241 0 0 7 218 0 0 2 139 0 0 0 0 15 0 77 121 80 108 117 103 105 110 46 112 114 111 106 0 1 46 58 77 77 80 82 67 87 73 69 1 0 3 64 1 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 43 27 0 0 9 179 0 0 0 0 15 0 66 193 212 194 19 180 140 109 220 205 78 57 63 90 66 84 57 156 71 10 240 179 194 234 180 76 49 136 61 86 193 33 87 165 51 39 174 141 114 32 57 229 43 22 87 128 72 84 38 117 129 4 182 215 234 186 97 240 130 6 7 168 37 149 122 3 125 3 195 87 185 151 254 22 251 249 238 210 167 130 219 121 155 186 134 229 95 75 152 58 93 250 123 38 106 43 222 218 75 149 20 150 219 56 44 81 228 23 54 251 165 214 237 251 0 192 205 43 113 64 228 181 201 133 51 84 209 66 37 59 176 144 234 4 186 142 81 128 228 2 55 216 158 134 41 177 194 7 95 252 212 255 73 83 237 231 200 33 245 234 99 190 79 33 76 97 115 253 35 55 46 42 13 118 116 73 161 215 249 23 162 74 26 161 34 208 52 177 148 31 2 225 128 147 212 218 175 235 77 215 179 45 41 42 83 138 73 222 20 4 247 49 227 152 237 224 96 210 249 218 162 93 24 168 187 8 67 87 106 36 240 23 14 253 32 32 233 250 182 103 110 104 23 208 218 230 121 74 225 57 124 53 128 60 111 91 170 168 211 245 68 13 214 181 216 230 12 119 31 218 154 171 103 239 30 230 22 188 226 29 238 162 224 59 253 70 31 56 103 224 36 245 159 238 139 104 201 201 132 39 227 128 0 62 234 60 136 63 255 195 11 172 202 17 37 216 84 146 63 219 54 56 151 166 38 241 106 221 197 103 27 237 182 165 6 183 114 101 218 141 240 64 148 45 222 37 21 103 254 127 46 56 173 37 215 210 155 156 143 214 184 249 118 238 209 196 193 63 132 149 152 85 92 181 13 27 221 176 225 145 152 79 7 62 97 181 120 39 91 165 74 115 184 46 199 3 192 153 218 145 229 140 225 48 115 235 24 105 61 157 168 6 39 4 200 157 182 175 112 130 106 48 11 175 17 0 192 51 97 61 92 231 192 128 4 202 158 82 84 178 6 244 58 194 143 198 197 84 245 194 178 69 38 193 153 99 228 73 197 137 51 95 234 74 220 141 111 161 135 191 121 33 201 254 51 7 28 164 179 195 57 17 73 210 193 161 123 149 11 73 41 75 25 196 86 100 212 137 148 255 191 61 249 212 167 243 124 178 252 243 230 210 105 103 137 88 244 8 170 166 127 33 239 33 76 177 46 165 94 119 60 57 69 82 53 93 97 113 18 211 180 59 221 195 107 202 4 125 117 172 218 169 252 32 46 1 54 41 228 135 201 89 109 105 202 112 20 196 166 41 173 208 173 27 148 202 143 245 25 142 72 111 18 240 135 44 9 113 199 4 252 36 142 207 253 43 184 119 116 86 138 249 177 138 141 63 33 191 93 190 139 209 129 212 216 83 151 194 200 24 252 41 196 242 80 71 41 30 226 43 28 209 35 219 218 177 65 128 188 55 183 237 64 231 242 161 168 189 135 114 61 217 9 64 19 4 196 99 134 88 34 235 184 97 44 234 25 195 176 83 127 209 207 190 234 196 243 14 19 177 134 74 190 120 202 207 65 100 1 59 62 46 48 80 135 3 9 73 242 18 57 109 183 245 222 178 216 183 84 76 56 208 27 8 158 248 66 214 155 165 188 137 94 194 111 156 211 2 200 53 127 166 203 170 79 164 98 8 33 169 242 184 152 189 171 140 226 112 193 38 34 179 149 178 39 37 88 11 56 158 240 172 153 69 71 107 203 187 140 154 176 235 8 151 194 172 241 194 59 173 162 204 166 181 114 97 224 92 71 116 144 235 121 221 159 124 218 189 170 239 83 135 28 243 178 223 131 227 17 146 169 220 93 31 64 246 60 114 194 162 48 94 192 255 37 210 128 223 90 148 255 167 134 204 96 230 126 180 73 114 139 161 17 171 76 130 56 199 160 130 180 229 165 79 185 10 128 134 241 79 80 147 118 89 165 116 61 94 67 177 61 154 226 10 230 26 219 235 251 35 12 194 40 38 35 252 251 191 11 198 3 254 127 229 204 232 61 105 255 53 135 108 128 24 78 193 229 23 109 141 167 141 113 72 6 184 7 83 149 143 141 161 13 193 130 105 121 159 72 83 255 218 246 207 168 2 188 251 220 106 202 121 24 137 85 236 151 184 191 38 29 12 123 142 42 244 196 40 124 66 26 203 78 220 166 73 142 150 63 166 17 119 99 243 166 176 210 220 215 118 253 59 143 35 122 222 50 58 29 51 211 19 174 220 236 227 198 71 227 70 156 97 25 76 78 210 252 109 98 200 134 0 148 114 221 154 66 23 196 248 37 253 225 184 18 33 116 236 252 67 236 135 114 205 157 120 160 155 132 133 60 83 40 206 205 65 122 27 3 244 137 119 158 91 42 59 189 57 230 202 3 71 214 181 17 91 237 71 219 25 87 69 187 54 79 222 40 229 9 229 71 160 174 72 187 107 25 142 156 159 128 201 103 230 130 228 230 37 21 220 76 245 164 173 70 236 120 248 32 0 235 8 226 156 150 195 159 49 115 251 27 199 242 115 185 77 140 190 205 244 7 223 191 94 162 200 1 170 101 82 196 36 62 145 104 149 184 123 177 153 15 220 14 50 253 40 5 192 198 227 129 195 234 3 23 1 199 104 182 67 51 17 31 177 252 147 96 76 24 221 202 12 236 136 115 123 75 165 115 55 2 242 194 9 252 13 250 160 95 132 217 253 162 222 168 205 117 26 224 163 41 136 164 32 42 40 60 7 24 87 230 249 31 58 236 150 135 184 249 22 205 31 97 180 112 137 182 250 89 4 221 38 113 74 247 168 206 215 112 54 174 17 124 134 22 229 141 40 117 220 60 36 142 159 28 196 12 79 250 234 136 200 220 192 151 253 59 63 143 176 44 197 118 7 251 9 88 225 69 165 197 229 146 92 13 230 142 60 188 7 204 81 241 42 116 68 128 100 171 169 163 137 188 9 17 212 4 231 195 226 170 216 196 24 94 172 65 211 52 75 97 206 167 143 24 61 168 230 229 31 239 42 70 74 67 179 96 52 199 96 80 117 42 122 92 36 146 138 21 213 65 96 75 175 232 31 107 43 33 91 231 154 123 5 24 28 139 122 138 127 91 147 185 79 21 150 196 39 242 145 196 148 195 22 235 187 30 46 175 109 249 30 33 44 231 138 19 255 207 171 119 184 201 171 190 52 6 187 143 13 176 206 38 141 52 54 14 234 19 13 72 228 115 134 239 231 78 161 68 240 39 189 238 92 137 134 220 92 228 98 165 0 223 127 16 233 228 150 150 183 157 213 170 18 108 187 193 244 40 94 214 27 214 103 133 11 23 106 140 153 150 249 216 192 173 245 226 15 71 223 152 10 15 241 34 209 142 177 116 19 237 153 115 235 149 33 51 8 136 185 42 26 124 13 143 64 6 191 151 249 2 34 136 141 198 23 227 78 45 51 175 180 143 131 177 93 122 47 116 190 243 99 42 32 159 106 87 251 223 159 179 37 63 143 200 173 119 171 27 79 79 149 2 209 224 156 255 224 213 5 208 114 14 166 128 135 141 222 107 146 148 60 212 87 95 249 62 108 29 151 193 171 48 111 202 218 27 135 180 253 254 184 223 129 63 91 60 123 221 98 165 199 70 36 4 155 209 197 95 213 90 27 172 67 75 182 52 134 225 138 50 128 100 245 153 1 73 95 228 92 254 186 19 225 208 85 38 151 24 215 131 149 191 230 74 57 107 248 227 229 111 209 108 16 211 152 104 163 251 128 215 147 85 150 15 43 134 83 159 42 239 54 28 40 73 52 207 84 129 239 98 214 179 21 102 137 178 110 247 152 202 120 33 245 91 121 128 234 177 58 4 101 109 183 205 222 157 164 79 7 109 210 19 253 233 66 110 212 180 156 55 124 37 83 157 36 52 71 108 27 185 118 84 11 222 1 186 180 176 54 75 2 134 10 200 41 247 243 115 198 166 236 142 190 189 239 126 125 106 88 219 213 89 86 112 164 28 237 40 73 163 214 41 167 51 226 144 185 109 128 31 24 46 11 81 151 124 82 134 29 127 35 25 190 38 212 98 223 126 203 32 60 74 103 251 72 156 19 78 206 72 239 13 5 249 184 234 54 28 128 245 0 249 90 69 3 123 98 160 210 186 41 73 17 3 28 112 129 216 217 199 108 97 59 3 225 73 152 69 217 146 229 62 27 45 119 23 226 20 9 145 94 46 115 121 134 233 179 133 155 94 199 108 100 28 131 175 206 140 90 173 14 18 76 19 202 83 159 22 214 223 144 183 119 149 129 120 70 181 99 68 133 35 149 192 17 182 40 216 129 186 185 222 109 72 135 219 119 115 196 249 44 150 83 58 212 26 210 154 53 109 49 36 39 146 188 84 202 107 117 165 30 161 103 160 138 30 154 85 67 10 214 221 117 225 102 176 143 120 211 187 176 196 245 60 28 179 165 154 167 22 55 97 242 45 252 235 170 218 20 43 72 243 201 54 123 101 20 33 48 168 180 233 60 232 203 7 66 56 124 146 214 112 254 140 37 96 243 38 179 116 69 25 227 129 70 166 160 195 95 119 149 251 212 214 138 62 183 247 149 85 11 116 61 189 17 187 149 100 21 248 121 103 245 72 14 36 248 191 128 103 91 132 118 39 131 121 52 247 206 93 47 82 113 11 31 148 91 121 169 110 211 31 34 248 177 165 90 108 123 99 171 35 104 32 238 176 63 65 30 99 58 169 225 58 211 237 4 229 142 123 59 108 223 136 197 220 218 91 179 0 121 93 76 67 65 204 151 161 33 65 74 212 79 82 70 71 34 30 120 110 193 0 36 170 193 44 45 143 228 131 205 150 244 160 150 106 22 65 152 121 20 125 25 104 52 133 104 165 184 88 121 83 121 93 99 250 114 15 118 56 143 178 96 88 189 162 5 211 244 73 153 40 207 205 71 138 167 60 186 201 213 118 68 181 199 75 78 195 34 132 17 127 183 98 72 65 22 255 140 196 232 205 157 2 110 42 175 37 4 30 101 25 242 48 107 25 105 159 30 213 210 157 118 121 51 157 187 180 131 3 44 5 185 15 215 79 162 2 26 65 168 188 175 126 122 46 117 97 63 225 223 18 22 211 203 44 218 82 158 29 119 110 57 91 14 143 66 109 2 240 56 94 247 35 47 101 146 49 98 29 193 204 226 150 16 203 189 11 251 203 208 29 186 250 218 53 107 74 41 140 45 140 4 31 27 113 69 36 188 128 46 81 132 34 77 101 50 169 28 156 133 164 129 253 215 241 194 174 172 194 42 220 190 205 227 223 125 42 185 109 222 61 100 144 193 147 66 193 232 72 220 164 225 179 24 189 206 106 11 94 84 43 63 244 25 229 114 152 79 232 252 147 54 43 138 6 104 248 81 78 162 136 226 36 206 113 106 248 66 115 193 28 216 164 130 112 222 54 251 213 143 169 214 127 195 37 79 48 191 31 239 222 47 54 197 188 194 74 4 90 50 70 38 100 59 49 223 218 178 37 231 49 12 152 217 227 91 99 20 154 159 152 122 106 149 86 103 187 70 156 1 251 186 172 207 166 67 51 147 24 159 0 66 193 212 209 173 202 54 121 186 247 106 241 139 248 136 144 151 199 247 80 188 144 101 75 21 223 57 158 220 219 236 232 23 100 202 212 173 34 206 147 90 245 218 205 94 143 37 178 123 245 10 207 222 177 255 205 243 59 2 92 205 14 246 210 227 42 114 60 115 43 247 225 110 54 179 180 171 8 226 94 227 206 84 12 108 245 165 220 186 62 202 190 198 31 48 221 104 253 145 8 22 239 235 157 224 89 115 154 66 225 233 26 132 65 101 103 113 198 133 195 218 235 163 15 66 48 130 138 254 104 191 21 132 73 188 3 18 49 233 212 33 173 203 85 255 167 237 129 60 173 232 204 54 14 112 18 11 20 121 253 133 205 30 128 169 42 1 114 138 184 35 247 111 197 232 255 8 125 197 39 27 123 188 217 183 113 101 115 55 200 76 41 136 182 194 36 115 226 46 180 223 15 180 184 199 127 207 175 183 18 108 253 224 68 225 189 230 145 197 113 58 99 64 169 236 231 55 89 138 194 172 139 126 15 235 114 7 190 146 185 206 38 26 160 116 201 4 85 157 75 151 138 219 4 150 5 192 67 120 123 231 151 29 125 34 237 37 125 175 14 219 63 40 148 37 198 227 142 220 5 165 190 80 20 226 226 188 106 110 189 68 213 83 144 111 161 33 212 140 77 52 244 117 247 254 247 134 221 112 95 223 125 162 95 247 113 127 148 138 20 251 103 234 125 73 19 94 81 44 249 114 11 173 196 15 63 229 13 115 251 195 11 98 206 183 202 33 193 89 219 11 110 155 116 53 252 253 48 32 153 170 120 19 185 239 38 248 134 53 99 79 234 178 251 112 68 87 151 119 91 159 228 132 234 207 90 233 251 86 23 140 87 198 204 228 239 33 97 205 23 105 57 191 169 94 234 175 182 54 157 209 165 39 1 23 153 99 4 83 250 118 150 110 225 141 205 108 23 85 157 117 151 134 213 237 178 162 80 51 220 165 2 220 8 167 35 52 225 141 195 156 254 21 76 95 231 237 249 231 199 223 249 56 16 105 49 246 179 86 86 199 222 103 162 50 165 41 77 133 132 4 246 90 221 161 237 175 20 1 224 5 208 134 151 85 245 81 241 166 113 128 176 170 18 208 148 167 107 165 84 201 247 77 110 178 243 212 76 28 185 151 25 3 254 91 135 233 7 181 194 191 189 100 178 100 20 92 126 239 85 113 127 203 20 251 252 161 1 63 35 197 97 30 51 62 136 236 104 162 216 84 86 49 130 181 92 215 169 183 20 181 106 88 75 233 118 139 43 234 2 58 27 15 194 152 140 103 217 39 100 170 4 96 201 205 75 153 189 203 211 117 177 25 176 204 93 16 68 7 53 84 183 210 189 91 68 187 188 136 34 168 145 152 249 26 42 26 225 31 239 15 249 137 120 247 29 172 107 103 137 180 207 217 121 27 149 32 90 137 141 176 165 165 165 165 1 0 0 64 0 0 172 94 103 33 181 100 23 240 0 0 15 252 0 0 40 248 0 0 0 0 0 16 180 253 0 0 7 90 0 0 2 148 0 0 0 0 15 0 77 121 80 108 117 103 105 110 54 56 75 46 112 114 111 106 0 1 162 139 77 77 80 82 67 87 73 69 1 0 3 128 0 129 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 37 135 0 0 9 73 0 0 0 0 15 0 66 193 212 169 9 210 149 55 104 18 166 123 198 254 115 231 189 56 26 63 233 107 89 215 26 41 64 39 168 254 239 247 106 245 213 179 37 162 85 150 47 25 75 142 73 147 42 103 39 18 89 87 185 158 183 144 191 121 197 58 247 237 47 168 4 250 221 80 196 140 250 2 153 82 24 7 101 152 165 56 154 236 133 124 32 161 65 134 202 240 234 38 74 220 207 29 183 187 78 143 128 78 228 25 224 83 50 226 241 200 15 193 111 178 15 246 78 206 228 147 246 197 203 10 10 242 105 41 4 66 205 9 1 225 252 22 138 140 209 6 181 240 179 154 27 24 6 94 118 33 215 71 251 65 6 46 194 156 224 245 152 248 245 163 117 106 184 81 55 44 43 63 12 15 131 173 177 63 58 108 90 116 237 57 130 18 45 207 39 168 184 124 14 234 151 77 158 24 238 174 149 45 154 30 127 131 200 231 47 199 96 208 217 78 147 104 4 219 175 174 33 142 236 210 130 219 100 211 116 254 15 231 119 8 95 0 178 98 122 210 142 229 104 67 70 12 175 141 92 58 110 110 125 213 36 115 84 117 144 245 75 148 181 55 130 172 219 99 192 169 188 102 174 245 3 98 201 249 187 198 155 60 173 205 234 41 227 58 211 109 39 124 98 234 206 156 15 73 86 25 233 109 125 254 184 178 214 178 133 136 246 117 48 173 55 248 26 8 190 78 97 200 67 23 26 223 148 9 135 229 250 93 43 221 207 238 48 11 146 126 167 202 57 129 122 208 16 68 11 171 85 193 55 197 75 206 6 101 225 159 104 37 53 24 149 113 98 108 118 35 180 159 124 25 241 188 82 51 147 186 228 19 144 214 103 241 33 199 95 1 89 148 121 49 217 177 30 75 206 83 68 131 49 235 210 72 87 124 132 117 54 28 248 36 131 82 144 238 147 41 18 75 146 21 97 35 176 24 27 156 45 171 65 232 213 217 183 86 97 199 127 122 105 229 192 146 21 171 163 104 83 164 85 85 159 97 16 133 250 117 123 35 109 109 221 183 95 120 25 237 167 23 213 43 6 178 186 44 154 201 162 86 26 136 87 11 90 163 230 224 102 104 162 19 246 228 233 218 91 12 199 141 183 74 205 224 12 153 150 177 85 0 41 202 28 63 57 160 34 129 152 15 10 240 140 213 45 91 151 230 63 252 32 81 62 58 251 113 147 52 74 212 214 30 114 32 135 185 204 7 224 181 26 172 91 169 81 65 140 201 52 185 195 170 193 233 103 214 112 109 65 219 94 83 253 182 167 152 47 211 90 104 203 34 241 216 55 162 73 128 24 254 18 243 43 51 199 224 93 181 216 4 195 100 21 1 142 111 89 99 181 120 228 69 89 150 166 67 160 133 83 74 25 120 228 202 151 213 197 238 169 7 25 75 215 132 139 13 128 148 42 185 174 244 128 76 188 161 166 164 16 51 147 115 251 235 205 105 232 86 142 76 237 244 167 29 43 177 248 156 194 246 97 15 7 255 213 141 41 156 105 175 207 13 3 192 68 119 2 85 97 230 126 53 40 79 97 45 221 168 205 66 34 36 28 180 173 22 22 180 51 194 56 193 255 243 75 101 57 141 155 154 6 150 42 8 180 204 128 177 95 60 122 220 131 125 225 225 49 227 224 60 187 72 148 80 225 109 173 250 161 103 80 190 248 119 106 225 182 172 156 189 14 39 39 172 51 134 119 87 74 119 174 13 184 80 179 206 211 203 197 4 98 108 88 244 9 167 90 0 179 111 74 175 93 37 151 71 255 226 242 57 3 70 223 10 238 143 109 72 108 218 5 38 140 97 70 133 196 185 229 124 137 190 203 76 81 53 60 4 82 244 201 125 216 66 13 237 218 214 208 120 143 242 251 23 135 220 72 32 82 237 68 189 70 62 224 254 70 62 224 229 134 119 188 130 31 152 255 212 226 149 189 221 60 223 148 73 202 157 18 249 54 56 126 101 207 255 58 91 68 133 67 118 98 230 235 242 45 38 75 183 17 235 204 212 204 222 45 249 140 101 163 86 59 125 195 111 43 228 127 205 120 199 85 241 203 115 36 38 114 138 200 134 12 65 52 23 170 58 186 89 15 23 144 208 141 125 252 131 154 213 103 133 164 20 24 181 20 212 220 255 114 55 158 205 47 147 146 107 120 61 236 170 84 104 212 61 32 201 252 208 92 120 214 182 30 6 28 5 1 22 67 109 244 114 222 27 168 58 178 108 199 187 12 57 225 72 255 253 245 130 250 31 222 250 246 10 101 46 52 182 55 251 253 245 81 49 245 105 93 45 82 221 74 249 125 1 22 82 12 24 109 64 86 153 199 117 92 85 16 118 131 199 159 35 198 115 25 194 53 204 76 60 91 61 99 94 137 235 45 223 47 205 83 53 161 9 165 132 157 86 145 51 163 200 190 148 205 153 118 167 140 3 86 133 127 81 179 26 56 173 105 221 157 174 25 29 252 191 134 231 205 247 66 63 40 168 20 174 40 253 99 88 50 93 57 46 77 42 38 230 44 152 237 96 246 158 174 127 80 223 21 171 208 218 64 83 60 6 39 178 161 246 16 149 28 35 238 182 210 44 48 166 87 16 17 60 128 20 135 242 84 199 79 197 192 216 159 45 88 172 97 28 155 254 95 247 229 19 84 119 64 208 127 23 119 239 50 27 133 55 86 37 222 63 40 63 237 92 219 43 139 185 171 144 78 174 41 45 134 33 179 81 222 241 244 47 230 107 206 53 93 206 223 25 220 198 187 145 188 22 208 189 21 158 201 29 156 207 162 236 106 151 65 58 250 220 39 200 228 244 143 101 56 32 72 194 32 92 161 170 95 226 91 247 74 68 91 243 111 13 53 30 159 155 43 194 142 72 76 100 240 231 155 202 2 170 87 103 101 137 13 158 138 204 152 21 128 163 227 158 239 113 74 203 205 138 28 253 172 176 47 237 128 246 167 129 252 181 12 189 44 9 25 249 55 100 198 20 247 11 221 58 43 244 154 235 66 177 195 182 215 227 81 34 233 12 208 171 215 60 228 237 247 68 237 254 101 72 11 189 214 132 0 237 192 83 247 146 44 29 115 128 161 61 99 89 134 224 142 199 58 193 76 75 167 233 190 242 240 211 62 140 149 132 19 231 30 187 11 119 216 16 130 123 220 109 76 105 8 8 51 177 93 127 176 168 236 224 185 239 147 241 252 89 235 117 89 232 240 134 105 5 97 209 251 211 122 163 130 146 101 27 0 163 26 227 99 143 189 100 252 184 92 204 15 249 41 66 137 162 186 236 108 107 110 37 6 27 122 43 43 183 9 177 188 52 107 174 190 52 142 8 234 72 246 140 207 86 16 62 58 111 246 174 164 206 167 225 25 226 156 194 36 44 43 216 74 52 246 175 115 93 50 77 141 193 52 62 121 123 202 32 231 159 172 154 127 94 71 139 59 99 60 95 93 5 219 230 131 152 119 71 166 108 172 186 159 236 122 151 241 89 190 225 248 70 6 59 222 41 63 1 165 51 242 86 140 13 190 182 4 62 76 202 29 142 235 136 247 213 221 89 87 129 198 64 125 243 139 125 99 248 77 77 161 154 149 206 132 228 19 219 21 20 117 100 106 17 25 129 82 47 223 238 149 91 209 180 62 152 199 225 74 120 88 182 193 105 50 55 18 249 249 177 21 79 110 42 239 129 88 200 29 133 34 98 15 45 175 191 221 140 248 216 149 245 89 166 178 80 182 78 190 69 50 222 205 239 161 190 224 7 58 209 212 252 3 217 253 195 183 64 52 49 155 161 91 219 253 14 98 134 170 152 67 190 151 34 0 244 30 29 40 140 166 74 48 227 156 179 126 37 235 250 104 255 27 136 65 183 130 244 43 240 35 123 226 134 15 235 124 3 209 133 214 35 208 2 203 15 238 71 79 163 249 77 38 232 160 127 174 99 90 151 104 248 47 21 102 40 10 75 7 38 213 12 191 187 208 175 51 104 120 67 247 117 94 241 128 200 6 166 210 115 55 169 169 217 14 21 75 98 182 140 181 241 103 66 242 210 58 92 215 100 223 168 223 224 23 185 68 213 123 36 81 24 49 168 209 69 245 79 245 26 172 28 132 233 201 18 122 188 2 206 212 185 33 163 205 123 122 253 31 107 244 225 171 154 126 238 192 76 97 3 130 6 136 89 106 53 55 117 226 25 20 196 35 147 112 210 205 162 106 50 158 32 159 46 222 213 182 51 197 240 80 51 244 161 110 150 205 10 210 29 211 191 134 8 62 165 173 11 212 161 149 21 59 192 148 10 206 136 162 153 70 254 239 231 184 38 59 63 15 77 159 36 158 37 220 110 219 185 101 189 130 102 113 59 89 8 251 111 16 111 199 206 9 183 37 71 67 15 254 146 122 128 22 246 172 83 255 83 89 0 246 254 92 199 238 49 177 50 56 60 7 47 70 50 98 209 93 12 210 64 75 186 162 82 59 16 42 28 252 150 217 13 179 131 109 44 168 155 109 124 107 172 34 39 56 93 136 156 226 51 195 139 240 86 22 205 163 244 246 122 13 115 134 172 202 203 8 83 178 251 160 6 219 89 67 181 18 209 214 63 231 59 24 227 158 23 7 240 58 71 177 7 113 158 183 64 244 85 7 107 227 60 68 82 254 89 181 121 244 154 127 239 164 100 253 201 24 40 247 95 2 117 74 39 105 8 93 65 60 200 39 164 174 113 104 28 234 29 2 248 240 139 89 240 62 145 199 95 144 239 95 112 133 161 248 7 69 77 160 179 10 214 118 130 47 36 196 113 185 107 12 184 128 166 184 156 240 64 39 22 137 148 42 166 209 186 106 148 29 222 181 182 12 140 98 107 232 202 192 126 214 67 12 90 3 7 248 95 36 76 59 188 66 63 98 47 55 72 103 196 189 55 155 89 36 43 7 171 26 228 14 129 26 180 143 57 83 243 131 55 10 86 141 23 182 84 53 42 118 71 72 221 140 17 103 43 14 243 168 38 236 161 104 222 196 131 99 100 2 95 182 238 89 158 129 168 152 135 33 197 190 201 123 56 211 17 219 71 63 164 17 28 210 229 135 70 215 21 37 111 40 118 238 71 231 185 92 225 238 138 15 196 191 125 76 175 41 229 73 155 45 56 91 234 166 249 104 4 179 127 38 179 30 101 157 148 54 199 109 249 21 239 65 56 118 173 182 77 172 225 67 185 168 180 146 85 179 50 125 131 216 129 42 197 47 124 221 171 199 98 155 4 245 181 64 165 225 148 159 88 65 126 225 27 188 72 65 126 66 80 88 14 250 23 35 36 212 224 92 173 32 66 193 212 120 244 150 156 45 75 143 253 186 160 103 148 110 138 210 209 163 125 11 126 208 172 225 255 129 97 133 7 117 173 34 14 198 74 241 119 114 179 69 78 241 172 212 89 124 91 120 8 205 235 82 98 142 194 32 245 179 201 44 162 110 214 68 254 158 4 147 19 254 191 118 156 232 12 254 184 209 40 217 121 173 182 158 0 168 203 19 227 183 248 42 166 119 134 20 184 72 174 2 197 58 133 29 213 233 74 101 1 85 71 25 150 55 32 225 207 234 168 1 132 48 188 104 84 53 145 212 222 88 12 164 128 218 29 207 78 77 249 16 88 28 232 164 142 192 159 5 8 135 38 217 75 132 1 169 131 180 254 194 85 160 186 146 180 24 82 91 133 163 169 12 134 152 70 138 133 74 186 173 245 88 137 116 233 235 3 118 28 107 126 133 54 54 53 235 170 9 149 65 194 190 72 136 43 247 87 106 245 14 28 216 174 131 61 75 2 32 48 18 90 42 185 42 139 107 94 143 236 239 204 214 131 5 194 198 84 239 253 129 60 182 156 134 15 194 224 152 87 64 148 238 6 49 222 188 124 178 199 34 127 212 174 139 147 19 174 19 177 25 35 173 239 20 162 133 142 35 21 226 49 117 215 117 82 150 137 206 32 224 106 132 88 229 130 225 121 252 199 118 93 193 14 161 171 76 13 36 30 78 89 226 51 243 117 178 220 71 194 253 155 147 117 169 112 214 170 151 80 176 47 113 137 200 71 128 223 66 205 149 141 14 174 254 215 224 212 209 129 71 42 114 80 117 179 6 107 207 86 126 92 5 186 201 125 182 1 242 50 66 210 232 200 192 245 137 242 31 142 235 147 161 97 3 161 124 80 122 86 211 86 19 222 78 188 48 94 226 5 28 139 115 71 189 71 214 76 63 3 208 118 242 103 42 218 166 31 193 172 90 1 221 207 45 41 132 69 109 253 53 20 18 46 39 129 112 108 97 15 218 100 16 0 87 235 39 246 68 156 112 218 135 240 49 235 29 171 113 255 41 197 77 237 159 181 64 19 122 215 56 164 218 187 2 68 137 251 240 202 132 181 223 81 212 100 47 233 101 78 16 141 85 48 151 108 6 121 86 47 13 210 187 225 178 157 228 22 177 139 131 77 189 136 67 214 106 21 35 156 24 206 241 20 160 172 42 105 163 82 42 95 198 28 128 214 182 183 18 226 9 84 238 73 67 7 6 79 149 143 81 6 165 26 204 217 230 127 245 25 64 156 2 31 40 230 31 152 83 16 27 19 48 88 183 13 234 44 214 230 142 115 130 245 184 253 244 91 188 169 175 129 42 172 27 94 36 204 250 103 164 187 225 237 171 117 127 191 201 200 10 17 53 9 251 134 12 155 134 192 93 150 96 13 18 25 200 160 243 9 207 137 253 198 235 76 86 159 204 94 141 69 7 244 119 142 65 54 80 199 204 199 217 168 184 53 128 33 0 165 165 165 165 1 0 0 59 0 16 181 174 127 194 181 175 1 132 0 0 28 169 0 0 43 74 0 0 0 0 0 11 142 68 0 0 2 170 0 0 1 124 0 0 0 0 15 0 83 113 117 101 97 107 65 112 112 46 114 0 1 36 38 84 69 88 84 67 87 73 69 1 0 3 192 0 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 105 0 0 0 0 15 0 66 193 212 165 47 158 101 198 187 5 232 62 137 252 56 69 246 56 206 7 115 110 186 70 46 70 112 68 98 27 12 96 93 177 126 138 205 129 15 225 200 70 141 184 144 238 51 187 21 2 100 253 33 237 17 99 201 74 232 168 36 57 93 93 223 103 146 181 14 19 20 203 255 77 196 6 172 46 213 244 253 180 118 156 135 21 216 169 140 101 119 170 86 133 3 176 82 146 129 56 164 43 198 114 16 66 193 212 157 170 210 35 52 27 93 136 197 106 52 54 31 166 122 205 231 32 32 112 160 40 138 126 3 77 99 4 251 242 199 125 87 169 103 99 226 123 60 70 128 113 18 28 85 6 189 121 109 31 26 249 161 83 169 157 62 74 239 8 51 45 186 94 58 49 252 46 209 169 153 202 106 248 205 178 15 4 139 59 160 209 168 125 168 73 48 103 120 110 199 109 171 159 179 239 33 94 118 136 247 133 234 179 177 46 218 151 77 116 44 159 93 94 44 99 70 93 125 137 53 84 131 32 59 239 13 28 34 65 92 91 104 119 79 119 174 134 219 228 67 30 37 182 200 207 220 0 237 187 20 146 233 200 152 182 39 167 14 242 53 180 240 195 154 154 94 91 182 52 134 249 136 119 67 194 147 228 97 60 211 48 22 65 190 202 99 103 114 208 10 131 161 3 87 31 64 250 4 254 133 169 217 77 183 225 106 142 240 240 180 146 248 39 192 170 88 102 69 95 13 89 148 174 206 78 162 131 133 161 167 150 32 158 248 178 173 101 227 217 102 143 206 171 62 75 41 237 239 9 58 126 14 226 107 122 250 208 40 209 10 252 105 101 26 155 10 18 126 136 104 210 186 8 64 134 82 245 212 110 151 241 61 69 16 181 128 165 251 123 137 63 121 161 161 183 56 176 164 4 136 161 23 48 88 225 129 48 129 37 151 67 233 215 152 90 89 82 27 227 240 224 102 238 138 80 14 201 181 17 19 136 193 127 207 108 171 212 101 238 237 175 10 248 251 8 248 107 203 87 203 119 235 140 103 161 208 168 170 55 199 88 185 214 52 170 233 214 179 94 170 196 230 181 174 40 0 165 165 165 165 1 0 0 68 0 0 181 174 119 219 181 183 37 82 0 0 40 248 0 0 43 246 0 0 0 0 0 20 128 249 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 67 97 114 98 111 110 65 112 112 46 114 115 114 99 0 1 224 122 114 115 114 99 82 83 69 68 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 56 0 0 0 54 0 0 0 0 15 0 66 193 212 120 70 64 63 99 16 59 255 97 202 132 145 70 204 255 242 147 131 117 178 216 188 111 47 148 73 157 252 231 185 213 153 225 248 22 106 46 220 74 229 99 130 75 44 98 229 175 219 67 79 64 165 165 165 165 1 0 0 62 0 0 181 174 77 171 182 215 137 40 0 0 43 74 0 0 57 187 0 0 0 0 0 14 227 43 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 65 112 112 46 114 115 114 99 0 1 17 154 114 115 114 99 82 83 69 68 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 40 93 0 0 13 85 0 0 0 0 15 0 66 193 212 237 37 74 131 13 212 88 66 57 68 3 31 213 109 159 25 64 96 20 198 159 114 115 99 205 240 217 115 235 174 112 106 252 184 120 25 99 93 168 142 26 192 53 220 136 245 209 230 159 89 58 19 149 28 68 22 68 212 89 170 47 148 34 172 65 30 37 200 254 87 194 224 53 142 195 27 79 62 180 61 248 108 185 5 104 160 21 244 0 248 181 162 133 14 47 84 89 102 208 226 97 202 249 19 21 195 54 156 153 63 212 141 59 30 47 243 84 233 22 247 250 178 131 154 191 118 219 100 81 105 95 91 215 160 160 253 250 40 15 43 254 251 213 235 52 74 81 42 167 39 28 80 88 113 79 169 131 95 137 246 11 23 8 4 169 76 121 155 106 61 115 197 82 174 188 78 10 176 120 40 227 98 16 60 223 112 66 165 47 105 117 116 122 184 91 125 42 119 209 169 146 95 47 74 104 16 148 74 255 138 197 188 30 195 79 125 214 231 121 157 138 188 37 120 211 83 54 29 57 212 112 10 45 175 128 255 112 16 175 59 54 183 42 214 43 235 180 193 2 146 218 187 83 77 164 171 140 191 234 117 137 254 57 12 172 187 177 123 222 90 197 194 107 216 166 203 56 46 182 34 12 210 133 33 6 165 63 234 61 211 62 156 67 82 6 12 242 46 106 123 106 161 61 228 192 82 86 202 45 109 129 190 248 65 44 26 196 33 158 22 66 220 127 83 41 3 192 228 48 220 185 255 82 125 234 119 101 211 166 255 73 226 144 118 104 134 46 84 242 12 105 91 209 32 22 136 176 194 136 132 39 119 97 201 233 124 56 18 157 187 127 31 47 66 119 29 237 107 133 84 220 156 197 55 144 188 51 152 175 128 192 11 192 46 84 40 33 185 199 28 27 154 162 145 172 54 188 242 236 6 143 136 180 185 123 155 149 51 106 156 130 92 129 177 226 110 127 95 164 153 59 238 172 19 120 33 19 61 19 50 101 146 74 55 69 232 231 220 248 78 30 91 159 10 138 58 131 145 106 38 46 152 112 87 143 115 57 228 132 46 117 172 77 116 160 141 254 173 251 224 244 50 46 150 143 30 205 104 161 243 62 240 17 66 250 86 46 28 240 205 108 30 130 47 196 176 45 70 124 74 122 243 135 118 2 80 240 143 203 55 59 179 26 146 202 238 165 253 103 2 58 136 232 157 104 32 233 129 147 207 80 99 209 5 207 9 254 48 148 176 118 48 65 120 86 216 72 162 30 23 12 193 159 231 150 76 40 215 228 129 35 44 221 217 213 128 127 73 174 6 72 102 253 93 40 154 44 175 21 200 123 36 113 145 127 196 203 85 118 92 158 79 34 235 176 116 91 17 164 179 51 189 241 123 254 11 64 12 123 120 159 58 69 107 27 107 67 60 116 204 107 85 249 101 89 147 81 187 218 197 59 137 141 236 109 135 118 100 250 196 61 153 158 237 159 242 176 202 122 48 140 90 44 109 121 169 9 233 18 194 224 214 174 35 107 24 41 252 222 223 12 79 227 16 139 153 117 55 158 46 152 83 206 55 152 239 44 12 186 18 187 201 230 23 137 74 183 84 223 37 163 94 139 164 129 225 216 101 169 242 140 121 188 46 110 200 8 17 53 33 33 111 90 201 231 103 163 21 78 113 230 131 219 8 203 51 254 163 29 107 202 95 138 78 140 246 147 164 55 244 130 40 33 58 162 77 1 163 36 113 59 119 183 25 133 247 157 181 207 62 10 171 155 250 124 169 80 152 241 83 132 73 9 226 30 195 88 107 206 77 13 79 140 68 133 98 208 187 44 9 88 214 249 165 65 98 204 17 103 3 249 225 177 133 5 150 112 1 11 65 21 65 58 199 245 119 246 241 245 166 39 72 211 146 56 132 115 237 251 178 193 88 118 151 60 146 205 167 11 164 41 212 18 175 198 95 71 127 247 38 142 201 94 8 239 152 202 39 16 246 48 188 223 82 216 40 48 112 7 156 39 52 252 34 220 70 251 76 182 109 36 48 217 236 83 17 21 252 7 82 249 253 128 224 86 94 151 4 7 230 55 85 175 171 84 42 36 117 218 135 81 186 90 162 168 172 39 131 253 98 14 17 146 86 187 18 255 230 173 191 98 254 120 185 14 221 227 249 62 6 165 154 30 1 197 159 116 197 226 69 143 123 31 48 160 18 212 55 43 253 255 247 204 197 94 170 15 5 84 110 148 236 64 180 136 77 8 168 15 89 223 23 70 51 58 228 189 67 43 38 230 114 156 17 42 131 129 201 96 206 82 207 204 171 216 67 107 148 239 29 218 157 112 119 169 128 142 159 58 194 10 3 75 178 203 183 236 6 127 187 251 26 8 43 109 90 39 187 28 9 2 198 232 63 221 236 33 250 219 161 81 4 55 74 10 233 140 87 91 43 25 252 213 116 83 93 12 150 192 71 85 133 39 158 104 152 160 202 177 166 82 197 222 49 164 154 10 161 182 150 162 253 107 32 247 33 244 57 234 242 113 217 192 53 248 61 185 98 178 157 107 253 128 225 153 53 127 71 132 66 115 31 121 213 46 235 239 36 122 252 113 202 116 230 36 161 220 244 77 8 246 162 207 149 220 222 197 149 253 243 130 51 114 38 24 56 206 20 151 77 189 210 249 183 88 19 105 21 115 46 237 50 84 168 111 169 37 225 221 158 30 186 182 3 143 92 192 76 92 118 241 3 196 209 14 155 238 124 97 210 71 74 152 199 160 47 149 2 56 190 246 144 127 191 182 154 215 2 83 138 254 203 69 50 148 183 141 23 6 20 248 58 80 43 158 8 67 216 232 189 116 77 35 72 51 76 158 76 112 21 83 193 67 183 27 149 117 103 97 40 157 16 215 50 97 207 61 204 211 163 33 194 190 229 112 192 99 227 148 99 228 216 133 113 151 233 170 243 131 42 243 157 109 255 208 232 231 38 150 28 202 185 218 130 8 2 113 74 170 98 203 190 89 48 148 137 37 25 157 65 148 93 34 86 81 192 21 107 139 96 220 63 111 236 75 71 169 141 18 4 141 110 250 202 137 134 206 128 0 46 158 120 62 21 52 87 112 233 41 199 61 11 239 43 102 196 109 64 119 149 118 74 146 163 120 42 188 175 28 165 41 14 95 244 222 144 130 15 225 182 62 107 151 253 103 231 227 193 185 77 48 156 66 3 32 136 219 45 127 34 117 75 138 42 11 15 42 123 43 30 130 196 21 207 101 203 226 105 206 68 244 102 254 117 115 248 4 137 5 138 114 5 231 189 242 219 154 143 25 124 245 252 178 73 1 236 46 115 41 28 7 9 44 103 94 224 41 216 135 1 89 61 77 21 35 226 255 67 253 212 34 238 246 96 159 42 73 226 64 6 158 77 156 255 172 7 107 174 210 116 149 208 166 226 63 240 123 205 22 113 206 150 13 146 46 152 133 218 126 244 56 211 51 253 217 155 138 22 65 209 195 74 104 86 20 174 14 194 168 41 192 254 232 172 24 49 157 94 183 10 186 34 234 203 120 161 122 138 12 106 47 125 63 147 150 83 191 0 139 136 248 200 131 0 61 74 10 251 39 205 216 28 80 228 124 204 227 202 99 207 126 189 95 68 99 112 139 21 60 254 76 37 159 237 3 124 166 102 13 137 74 89 50 106 83 188 124 137 41 143 175 29 21 108 187 249 7 10 107 142 38 248 22 188 239 74 13 30 51 198 62 254 21 110 188 173 173 116 96 209 12 232 170 172 53 170 202 94 162 197 207 98 5 34 158 60 250 251 179 31 88 215 161 193 163 91 227 90 126 91 146 226 224 209 33 68 241 69 107 75 91 45 240 175 12 235 138 156 223 114 250 147 195 113 222 95 203 118 155 58 50 162 149 227 183 203 108 63 185 229 128 18 22 203 146 133 194 236 180 50 171 217 170 187 8 88 6 33 241 128 239 10 98 254 89 20 232 31 246 187 20 36 60 120 17 47 97 161 212 122 88 251 150 28 138 104 87 37 128 102 26 80 68 93 14 64 187 74 62 71 137 90 152 247 165 38 187 187 46 1 239 138 224 240 68 169 84 143 229 28 237 65 205 153 81 220 241 207 231 83 81 221 24 13 180 62 146 85 85 152 213 189 138 44 45 41 4 50 71 217 199 213 9 235 51 81 93 134 159 53 138 42 18 148 206 76 122 71 50 216 28 143 212 28 115 91 25 92 94 87 42 87 123 167 154 34 210 98 148 211 255 93 42 25 121 14 231 80 226 131 178 212 138 94 48 238 113 205 127 16 7 134 206 14 13 174 126 100 10 13 27 161 230 53 229 214 13 44 200 1 143 252 57 33 148 40 204 194 79 236 244 217 5 138 11 187 145 32 115 116 250 175 252 108 224 59 129 178 238 119 215 65 204 11 203 204 237 13 103 4 197 127 152 243 194 75 5 211 56 45 11 160 176 71 178 108 186 112 79 204 149 59 31 242 108 148 3 88 101 8 15 40 15 38 82 121 126 208 216 86 35 178 122 134 47 35 26 133 27 19 21 244 223 105 1 207 206 65 239 19 143 53 162 86 112 88 201 53 33 85 106 220 74 75 95 44 198 94 204 60 11 80 31 145 187 48 204 179 137 92 142 122 196 22 243 223 25 216 174 42 137 223 3 154 158 176 84 252 27 98 40 157 41 161 169 4 0 93 142 62 110 21 145 182 211 109 238 198 142 58 65 134 97 85 180 23 178 170 186 52 102 93 131 159 74 47 214 108 6 96 61 58 233 248 73 219 53 59 234 215 240 116 189 71 116 91 174 102 0 141 177 238 37 180 139 82 15 24 14 42 210 56 92 1 14 99 97 189 131 71 20 120 37 68 219 248 154 85 240 213 223 112 78 78 158 48 53 49 60 255 33 239 72 26 102 97 206 187 16 155 172 74 254 73 112 248 254 20 151 227 60 150 68 146 29 26 171 37 108 146 0 225 180 160 135 178 185 252 188 253 154 213 95 111 7 92 173 116 149 75 205 88 49 232 207 69 195 242 252 72 22 126 191 149 219 94 82 152 20 144 213 149 155 190 98 27 222 157 23 219 81 1 7 63 115 61 170 121 130 65 196 36 55 117 239 164 129 45 141 113 180 236 218 75 42 30 30 222 168 237 238 10 40 52 124 199 99 221 124 250 203 227 194 152 236 195 120 89 134 82 23 10 172 136 154 22 234 70 151 123 107 162 14 131 82 76 4 58 192 81 133 232 56 182 35 149 119 8 251 0 133 96 0 176 229 101 102 133 105 1 149 170 160 104 210 98 48 213 12 171 96 71 118 68 16 0 232 107 7 129 135 171 188 112 196 251 138 1 149 188 158 1 25 11 56 180 166 12 254 251 84 238 175 212 173 82 116 217 123 202 158 200 22 229 92 64 7 247 212 116 64 43 100 130 77 252 97 94 68 85 168 37 126 60 28 26 225 14 40 101 145 242 116 22 114 140 3 249 0 129 225 144 58 37 37 183 36 59 215 170 109 120 67 25 208 151 206 101 242 211 120 180 206 224 112 22 118 216 87 94 134 0 87 193 154 5 244 59 17 196 111 11 94 195 254 51 193 104 165 8 215 97 159 119 24 155 1 127 242 144 169 164 170 228 51 30 164 126 222 225 62 180 166 125 137 200 54 105 176 76 25 153 113 44 241 175 166 84 33 234 118 180 95 140 89 230 43 129 157 52 0 31 59 208 243 76 173 64 235 155 173 188 12 18 37 184 58 152 114 233 251 161 70 68 84 7 84 203 84 76 95 208 248 34 132 53 9 16 197 10 189 14 68 31 50 210 114 118 106 178 11 78 73 62 57 227 180 217 245 177 107 174 57 182 203 64 164 85 81 214 154 109 88 141 251 109 149 198 98 118 234 123 202 58 237 137 249 100 122 99 136 215 91 21 69 93 3 192 187 39 243 86 249 180 1 65 68 65 12 203 239 46 56 27 70 76 220 253 131 157 103 26 32 115 123 181 100 150 59 29 215 174 191 83 168 75 0 143 178 212 63 183 86 137 185 194 29 75 101 46 87 232 4 66 82 42 135 8 99 112 152 117 30 193 164 42 237 219 10 120 196 7 161 143 81 231 124 178 86 39 14 197 130 158 239 101 244 153 23 130 112 69 78 10 45 117 5 194 107 166 93 232 102 103 199 162 100 100 53 232 23 240 244 103 73 168 226 78 232 214 184 25 81 182 127 3 179 107 47 92 253 161 49 220 226 45 154 21 236 65 220 206 163 248 165 143 141 208 17 64 30 116 250 105 42 2 76 93 226 111 188 28 204 0 181 247 228 134 196 222 59 102 58 155 144 91 154 250 29 178 234 153 166 190 25 204 119 96 124 230 102 94 242 249 51 96 252 67 49 185 123 139 252 195 60 84 186 8 87 36 245 83 184 86 10 199 207 135 84 174 209 184 243 45 207 47 116 239 73 14 129 161 213 62 162 106 206 255 132 108 212 170 72 10 30 248 6 220 24 11 72 155 81 175 189 223 156 11 83 199 5 130 83 23 212 12 146 154 114 66 161 203 215 106 159 171 87 117 168 134 185 120 68 6 83 196 92 2 49 100 96 230 178 63 36 11 168 29 3 9 166 156 228 145 52 207 62 252 37 176 237 96 215 0 131 254 28 106 14 10 98 81 227 159 251 120 181 40 129 87 212 30 215 42 202 213 147 77 166 87 180 190 92 37 215 77 229 52 208 119 218 85 197 208 13 91 136 29 64 103 193 101 171 70 197 60 6 80 31 189 211 59 124 183 33 29 34 47 57 56 183 164 24 126 184 25 84 216 21 229 91 36 115 16 228 116 244 76 45 226 95 50 46 6 147 8 251 22 129 128 70 190 118 165 225 54 122 205 98 125 61 75 186 244 97 84 230 34 146 43 207 179 144 13 58 102 244 213 129 106 26 178 171 39 75 44 64 152 194 210 5 223 234 42 106 134 66 205 178 192 192 179 188 119 8 80 23 105 62 57 102 167 214 168 23 122 115 50 204 182 117 138 89 24 243 165 151 62 77 184 145 39 102 55 238 160 76 115 5 47 237 176 184 36 105 40 222 73 157 255 237 172 156 170 151 255 19 138 179 180 116 74 138 226 127 242 65 220 159 173 222 92 90 155 203 246 53 94 45 112 124 192 155 10 137 225 199 146 64 85 231 74 95 222 232 162 216 59 195 143 195 131 3 174 105 79 16 39 101 122 133 171 213 128 241 103 34 168 134 213 2 3 178 84 236 50 217 247 100 136 217 242 127 43 97 242 17 213 15 183 158 48 21 17 125 8 181 43 63 104 94 41 189 162 36 126 44 114 151 54 105 164 110 43 214 118 230 176 237 16 71 85 135 208 80 214 94 6 174 247 19 95 219 74 205 208 5 136 36 8 64 67 168 53 143 211 129 164 134 253 164 10 117 133 19 91 11 54 11 142 171 62 96 90 239 35 197 251 56 211 200 178 133 219 86 241 149 162 159 69 171 72 71 145 132 239 254 10 170 235 63 207 163 217 79 144 225 62 77 86 160 138 166 237 240 84 66 122 105 120 195 50 249 117 254 168 141 132 27 59 137 193 213 228 119 122 178 162 135 102 98 154 88 221 57 9 216 151 231 224 134 220 163 50 177 33 80 217 255 53 130 240 42 18 83 204 6 83 240 0 165 165 165 165 1 0 0 68 0 0 180 207 23 96 182 215 137 59 0 0 43 246 0 0 59 212 0 0 0 0 0 20 8 14 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 114 115 114 99 0 1 211 45 114 115 114 99 82 83 69 68 1 0 4 0 0 129 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 2 33 0 0 1 163 0 0 0 0 15 0 66 193 212 253 94 70 63 156 240 60 107 50 27 91 109 66 186 157 214 237 248 200 242 6 54 65 123 9 52 195 1 191 133 161 152 22 128 106 227 164 112 78 104 40 190 51 247 54 225 188 149 209 157 44 225 177 56 214 31 157 185 0 244 50 13 203 23 1 48 239 40 181 90 141 234 206 137 173 48 146 87 29 60 221 198 47 62 58 191 83 19 52 185 42 187 80 63 148 161 162 99 186 62 138 233 162 95 182 219 11 39 200 30 90 148 105 101 7 144 3 205 26 129 93 108 220 66 148 185 212 253 173 12 22 133 207 40 154 104 118 130 248 54 159 54 28 238 75 20 174 38 91 235 213 224 101 245 179 197 190 6 3 61 115 100 205 230 13 212 236 219 209 144 82 39 80 44 87 13 196 223 237 218 124 209 172 78 198 212 135 42 38 221 228 82 152 162 181 171 83 228 172 19 72 188 169 6 233 144 227 160 42 6 250 168 153 98 228 86 206 236 151 22 111 220 20 165 224 242 31 197 221 197 156 224 163 232 105 145 199 142 36 103 95 220 125 222 145 147 239 204 9 12 126 10 116 48 168 97 207 21 148 111 91 133 201 58 211 210 169 242 31 254 107 82 126 214 203 0 43 91 47 83 228 89 141 127 226 144 168 101 151 87 192 90 152 65 234 199 170 82 142 99 145 201 212 95 236 56 123 80 25 221 141 193 70 86 213 246 51 174 84 225 124 13 241 83 195 104 19 23 13 99 167 213 193 231 225 170 61 85 181 90 123 43 145 131 120 203 230 230 47 78 172 255 222 181 194 42 10 243 40 35 197 17 215 134 156 16 109 7 114 25 214 151 44 113 141 102 12 249 129 161 94 20 209 206 2 136 133 143 169 143 34 17 255 58 33 123 136 99 187 82 43 144 157 127 240 221 99 11 164 143 52 96 22 249 74 128 165 165 165 165 1 0 0 62 0 16 182 226 198 179 182 226 198 179 0 0 57 187 0 0 0 0 0 0 0 0 0 14 1 89 0 12 242 6 0 0 50 151 0 0 0 0 15 0 83 113 117 101 97 107 80 114 111 53 46 120 109 108 0 1 24 118 84 69 88 84 67 87 73 69 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 58 0 0 0 55 0 0 0 0 15 0 66 193 213 11 125 85 254 8 117 111 142 140 82 181 186 187 74 171 61 180 153 142 242 227 96 197 138 213 105 235 219 32 69 226 201 141 88 30 220 145 65 108 249 128 204 126 117 243 82 42 198 235 102 232 0 66 193 212 174 173 171 253 67 94 194 122 214 156 153 110 39 190 88 67 29 141 92 102 185 236 30 77 118 171 202 164 200 15 157 176 142 250 209 140 122 30 170 228 157 77 222 162 121 21 103 136 35 17 248 246 99 204 165 98 137 163 158 70 240 191 153 136 248 7 181 233 205 191 18 242 198 34 85 144 238 82 159 231 173 190 11 99 198 192 204 71 81 147 144 155 20 222 239 237 80 46 209 54 79 105 94 235 220 38 63 20 80 86 85 82 226 47 35 111 174 250 146 95 14 73 150 134 95 254 172 210 126 241 182 207 6 230 183 105 15 152 247 37 9 9 193 171 104 124 225 204 191 158 217 148 13 82 90 12 159 192 217 181 233 214 216 177 163 43 60 118 152 228 6 254 167 35 93 42 134 75 79 183 254 229 226 104 144 31 243 214 1 232 197 119 189 64 35 126 94 27 92 33 60 169 63 124 228 126 56 222 219 185 125 21 154 29 148 238 3 153 221 20 227 179 124 244 119 213 100 183 197 11 130 192 246 248 68 239 248 210 108 76 75 89 70 65 249 35 136 53 184 135 27 250 71 146 92 84 208 8 239 40 155 36 54 83 171 132 75 155 29 191 149 65 214 235 77 14 116 34 242 103 49 110 248 109 249 236 237 101 184 166 158 230 7 13 6 199 102 98 6 14 115 59 0 113 219 221 77 111 166 143 231 124 161 128 233 131 223 62 124 220 232 226 104 243 79 193 162 16 82 251 90 173 165 41 249 57 20 247 25 7 212 224 43 80 229 110 126 209 193 158 142 38 241 174 251 175 247 60 179 3 147 220 113 46 140 154 17 22 85 45 201 140 224 23 97 121 53 192 224 154 227 46 198 180 223 3 238 194 47 234 236 44 50 48 184 31 76 213 246 146 113 214 20 39 245 35 91 150 146 231 25 216 133 229 206 54 56 206 135 111 107 163 14 88 8 69 89 198 152 75 151 68 235 111 140 227 54 84 232 102 217 123 234 86 89 116 179 127 220 163 21 87 10 209 95 134 25 69 49 60 217 208 50 129 1 160 110 7 0 18 204 201 214 76 142 219 97 5 206 102 208 52 118 58 106 45 96 214 180 227 89 50 172 140 242 173 51 59 27 81 178 52 147 32 2 11 114 212 169 110 106 130 161 29 229 19 37 233 30 16 206 234 204 15 26 112 138 112 42 64 244 9 170 130 136 98 172 205 181 159 4 127 49 24 114 3 164 185 136 243 19 199 158 81 73 140 119 161 90 0 200 122 196 76 154 15 205 104 108 67 138 6 162 65 196 96 59 102 238 73 67 157 171 248 243 212 7 137 220 66 23 116 128 178 206 132 38 51 86 18 187 127 75 60 248 185 232 5 56 18 243 34 7 3 80 255 137 84 183 3 64 235 79 144 165 5 251 168 33 253 182 239 101 237 35 107 101 75 156 45 96 0 48 240 82 177 101 69 206 152 162 199 227 149 60 201 169 118 117 227 187 226 66 214 42 43 226 5 217 15 71 75 240 73 215 230 71 54 76 95 25 7 210 187 145 103 97 52 100 170 145 105 96 113 237 234 176 144 104 7 158 51 238 149 182 90 172 1 78 67 228 32 103 29 157 74 61 123 5 63 199 36 225 4 241 101 21 71 45 88 114 60 143 215 62 219 12 79 44 98 180 88 240 247 95 219 77 57 37 21 68 24 235 3 227 203 158 215 127 140 34 98 101 90 250 49 132 180 7 3 212 87 10 19 215 71 215 247 212 254 85 180 236 245 139 157 24 59 30 109 163 221 86 170 118 176 173 67 226 210 99 50 103 145 77 10 61 22 159 64 221 74 192 40 3 58 159 40 150 80 227 44 48 209 166 168 166 52 138 148 106 193 93 179 232 157 223 231 225 126 60 55 17 65 209 118 27 232 228 106 168 241 106 142 234 103 32 123 123 184 37 137 209 183 93 50 223 72 95 186 69 183 9 138 51 69 169 238 35 219 151 42 36 88 89 156 104 33 102 218 31 223 77 3 87 93 244 203 181 3 255 85 68 162 132 13 44 227 26 223 136 112 136 5 142 111 72 85 236 154 115 82 58 205 199 94 31 66 95 59 231 223 9 70 157 227 69 88 189 1 47 70 196 118 71 100 127 25 45 237 241 247 184 67 204 37 28 198 8 22 253 65 213 145 177 114 135 224 28 220 5 179 193 197 147 100 253 158 58 201 43 15 100 184 247 19 231 55 0 121 148 233 105 80 25 30 136 70 82 28 70 33 140 27 177 147 232 150 47 139 23 51 104 249 242 39 29 125 227 3 161 13 248 122 178 169 28 64 111 232 232 47 227 250 25 120 243 34 109 113 182 54 190 99 230 84 154 112 82 106 37 138 244 157 212 210 218 57 114 93 0 185 111 243 148 88 16 120 111 8 35 194 101 60 131 50 253 172 155 75 14 72 118 126 217 24 68 77 240 226 182 25 169 205 77 0 186 39 212 167 7 1 4 117 41 150 160 193 139 222 119 130 230 204 218 2 168 107 205 163 215 100 159 23 169 126 178 77 163 4 61 49 13 140 23 189 112 229 152 34 83 235 128 59 243 195 163 28 204 93 120 188 102 98 218 141 129 15 176 158 214 231 25 22 99 230 128 246 248 41 120 167 210 35 139 242 40 230 220 134 81 78 141 24 82 172 19 165 160 25 216 238 100 96 6 133 135 172 202 129 86 46 198 99 152 178 3 143 228 114 238 58 44 201 32 200 51 234 92 6 235 119 24 39 78 15 181 169 183 33 254 238 146 196 58 66 94 168 186 66 177 217 144 175 41 121 129 55 80 32 33 166 42 237 188 105 178 85 178 22 115 10 23 167 200 200 109 5 82 175 230 238 7 1 222 84 81 98 191 84 103 254 6 236 50 105 186 116 22 230 130 76 194 88 26 104 192 252 53 2 142 79 82 69 183 47 80 123 187 217 132 95 86 206 160 222 4 42 192 227 180 60 136 92 237 238 250 102 99 42 156 100 241 105 157 127 217 80 24 67 156 228 157 247 137 109 251 237 208 214 247 48 190 229 45 39 68 94 130 40 198 200 33 254 131 117 138 165 105 4 53 52 144 43 20 151 125 19 192 43 176 238 144 146 126 96 40 183 8 85 11 101 79 243 104 247 118 17 160 151 210 54 192 25 44 44 235 196 20 146 38 97 18 80 138 195 187 59 74 49 228 41 191 43 38 128 109 204 129 108 24 154 32 130 225 135 126 226 255 20 110 227 198 123 89 220 153 66 218 133 224 135 232 58 187 126 48 102 83 23 32 23 211 53 219 216 120 223 0 49 53 127 102 154 217 30 218 11 115 23 165 68 138 50 246 102 190 51 23 144 6 83 181 90 94 135 170 55 99 151 220 96 77 176 90 131 220 159 152 75 142 126 206 198 35 232 197 69 176 174 68 248 197 232 121 61 176 8 53 17 240 67 42 13 115 128 150 83 52 127 80 153 138 99 158 154 11 30 187 64 13 177 42 212 245 87 38 6 55 52 60 140 86 5 39 93 39 183 67 134 199 140 113 237 64 108 253 162 62 232 184 237 179 104 152 59 182 45 63 218 211 212 112 128 45 250 27 27 118 96 12 235 12 172 107 236 64 173 54 41 97 226 220 136 63 123 114 29 99 208 154 37 236 213 230 251 175 112 182 150 214 56 11 58 65 46 212 236 49 203 210 231 139 195 221 183 82 180 91 207 244 169 85 196 59 234 36 224 9 246 115 115 160 27 13 237 91 73 187 83 123 145 130 125 185 61 115 50 187 20 225 6 169 63 11 136 204 169 230 169 214 2 6 12 123 231 45 78 117 203 16 58 124 237 52 9 224 15 152 113 154 237 93 141 227 218 172 239 143 69 211 18 72 139 148 183 200 248 172 129 80 175 200 185 221 38 177 92 148 161 194 183 123 116 221 70 109 57 174 141 0 85 206 118 184 48 60 14 24 109 212 92 118 252 187 191 216 77 150 178 151 233 56 216 119 238 188 88 254 204 62 89 249 107 95 193 192 4 158 50 64 40 49 115 246 123 171 93 192 76 160 233 213 126 115 183 40 233 204 235 53 244 94 23 247 152 179 83 22 234 27 182 80 35 114 172 48 127 186 214 90 123 140 216 237 131 20 183 73 41 98 182 60 2 52 252 141 4 204 88 167 51 86 108 30 18 83 46 46 183 174 143 245 93 180 147 71 236 225 30 164 244 43 177 34 51 59 174 13 174 174 126 244 180 161 184 118 106 58 179 224 103 173 57 253 71 5 152 129 245 205 20 93 228 9 82 249 217 253 115 63 185 233 177 43 224 51 32 159 233 31 50 118 80 240 126 249 47 138 59 225 192 67 111 69 32 79 218 62 99 104 245 121 208 51 150 22 9 44 60 161 133 4 161 29 198 90 72 252 192 160 105 127 248 21 117 172 29 131 114 168 46 45 91 180 37 37 235 221 136 95 112 75 155 94 171 183 151 94 107 248 162 103 235 108 189 98 57 208 5 5 161 119 169 78 44 129 117 201 96 8 75 94 133 81 196 162 8 204 179 109 164 230 107 138 49 93 44 9 128 82 83 77 188 104 73 116 1 125 86 46 101 131 69 100 200 139 13 121 223 197 37 150 158 63 127 97 162 60 141 54 56 104 52 19 100 236 242 221 218 114 94 97 79 231 101 101 213 1 129 66 16 243 29 123 248 214 161 236 154 189 247 195 136 174 20 177 85 214 105 22 209 28 23 9 105 50 225 29 170 9 158 222 130 97 31 141 105 150 189 217 109 249 96 103 112 221 134 34 19 192 96 179 203 104 104 136 122 67 94 48 223 88 117 32 124 160 172 234 63 210 200 4 133 130 183 229 10 6 64 207 191 130 11 136 253 9 42 202 230 49 28 97 20 160 174 24 207 98 166 222 34 176 118 187 248 96 59 186 195 239 86 67 19 157 31 184 94 200 60 52 161 33 79 118 2 162 101 249 214 94 228 82 30 148 160 171 111 137 27 239 68 109 16 67 15 255 220 207 229 110 122 129 227 38 42 55 206 207 101 161 243 212 184 63 89 111 106 157 160 165 0 255 200 254 91 121 185 28 191 14 171 237 216 133 223 61 91 244 209 207 217 120 39 53 94 66 173 192 50 82 188 248 88 231 20 176 115 199 7 70 31 25 121 190 92 254 249 192 73 241 181 133 18 3 215 109 29 177 6 217 125 228 104 225 41 157 120 49 189 31 19 78 80 151 147 145 208 30 134 225 222 234 23 37 91 46 130 224 246 42 215 166 0 10 78 180 221 24 187 146 129 237 21 125 183 51 160 123 129 141 60 75 37 155 115 155 157 19 100 128 99 35 132 211 17 169 232 131 215 103 210 237 214 55 44 25 152 118 217 100 60 76 69 124 131 214 251 79 222 136 78 95 69 72 3 76 93 162 113 2 104 170 146 72 151 30 29 212 224 3 95 251 246 43 22 194 191 8 13 77 229 193 35 236 173 97 187 138 40 30 118 65 186 249 180 188 95 137 253 106 16 204 132 17 232 224 247 191 177 252 127 1 215 45 39 93 48 159 15 91 204 61 102 177 200 89 207 211 171 14 215 43 103 7 209 179 192 137 89 204 38 203 146 182 93 171 151 255 119 131 246 152 234 8 55 194 56 249 40 240 49 149 40 108 206 39 88 247 105 121 243 161 162 92 169 120 0 207 190 40 14 70 221 23 5 137 180 167 80 221 42 71 137 46 56 94 174 234 57 129 95 78 104 208 248 105 77 4 247 210 144 186 19 180 74 205 92 51 185 223 65 248 78 141 192 77 160 49 100 65 36 225 158 36 225 150 120 144 228 2 175 49 193 194 69 229 120 185 20 174 185 172 243 187 5 37 125 224 159 88 209 244 84 119 247 200 229 216 228 12 31 142 231 255 49 249 58 211 83 72 74 184 10 200 167 84 20 141 98 230 51 50 239 255 233 37 166 189 130 239 185 36 72 54 239 247 96 82 52 9 87 179 132 247 222 173 154 199 105 213 82 21 92 145 164 76 13 77 240 203 134 218 186 38 47 37 112 121 173 130 54 102 132 123 176 232 205 235 192 123 41 198 91 14 0 37 248 139 4 0 194 193 163 76 178 47 217 103 214 239 19 42 165 146 75 246 248 26 238 126 136 5 7 17 108 24 96 37 11 131 245 247 157 165 177 162 217 62 231 67 155 116 132 224 181 131 205 236 247 210 193 128 238 53 34 82 126 160 180 105 150 166 154 189 129 158 15 130 41 91 251 121 68 20 187 98 196 38 95 140 129 107 138 187 245 206 94 74 166 100 243 105 247 157 85 65 188 205 118 158 66 102 221 13 62 147 20 221 160 101 24 204 152 244 90 228 44 27 156 69 37 232 19 134 19 76 104 59 221 55 232 55 187 127 29 142 39 210 165 63 181 138 158 215 170 51 143 150 158 125 47 99 85 124 245 212 198 55 1 92 142 99 113 79 65 99 45 226 182 2 243 3 64 134 239 33 2 235 107 66 47 45 136 207 189 8 109 14 196 233 222 156 197 67 180 168 2 109 134 82 39 80 206 213 224 204 17 182 31 0 211 252 205 73 20 220 40 134 252 3 199 36 254 184 152 175 144 13 218 163 162 222 120 43 167 109 184 173 17 193 83 231 84 16 184 163 47 157 160 73 58 224 231 166 246 200 184 250 201 181 214 225 136 151 22 195 249 144 126 199 179 163 129 34 59 4 188 172 204 80 88 176 27 97 227 151 138 1 33 201 218 162 174 61 188 120 162 63 133 90 161 45 41 107 233 118 207 95 134 132 165 135 233 52 14 225 198 10 59 192 72 133 111 95 99 106 214 51 141 75 201 252 127 221 17 77 85 132 4 128 87 30 188 84 251 215 219 70 128 116 187 116 97 251 210 129 70 48 191 180 14 70 200 23 97 121 54 151 34 120 126 255 51 78 142 107 151 142 139 55 232 139 194 222 4 229 238 184 251 44 107 151 199 134 108 251 5 61 186 205 254 127 38 43 218 250 194 18 119 93 193 69 99 194 122 45 143 146 123 202 88 217 90 83 224 81 26 202 209 44 179 86 206 185 159 127 51 248 195 193 227 242 216 231 11 246 143 102 66 245 71 150 82 23 28 193 140 73 230 103 89 69 34 102 154 97 36 46 211 182 5 77 238 217 55 171 55 40 109 8 119 220 137 110 185 120 74 157 155 232 95 21 45 134 252 205 155 176 128 228 100 0 83 45 162 113 90 48 31 195 233 84 254 220 190 116 126 100 47 153 13 156 8 12 58 126 215 67 19 22 93 232 77 31 241 89 211 73 113 227 23 185 242 67 230 9 90 22 8 137 74 195 244 192 91 182 133 120 108 224 2 253 236 204 254 221 39 255 80 2 78 88 242 180 210 40 132 162 206 58 80 112 176 13 191 46 7 245 35 52 150 254 55 192 200 104 70 140 56 97 37 84 89 176 0 175 42 71 7 173 32 168 169 243 165 147 250 169 190 151 32 79 113 112 18 28 5 91 193 19 17 206 238 8 151 160 168 86 56 129 93 209 91 143 106 89 114 216 215 115 23 181 167 135 187 87 215 196 77 31 151 78 111 78 207 236 11 114 101 10 230 176 22 141 4 99 205 149 15 45 18 232 163 62 92 122 169 130 210 111 67 203 160 22 84 112 59 11 146 195 225 254 173 4 231 4 72 246 113 111 52 221 158 232 2 58 109 81 102 142 114 50 151 103 116 221 143 129 119 145 65 169 92 152 135 136 120 200 217 126 186 201 105 247 251 44 22 38 86 222 157 152 103 244 85 23 251 8 253 42 88 41 180 198 161 186 91 207 147 34 171 241 28 190 247 99 40 64 249 253 99 30 12 174 107 57 120 183 248 156 212 139 226 249 248 225 217 18 35 34 105 114 255 106 59 239 216 29 218 197 101 3 198 224 126 143 218 138 41 100 236 253 87 159 124 130 28 76 85 107 36 113 35 132 86 121 78 121 209 39 144 95 149 131 162 85 94 177 115 213 4 180 27 110 246 121 145 227 156 88 204 85 189 185 234 11 26 175 150 234 182 74 220 206 150 7 230 54 64 83 216 110 238 173 37 95 16 244 76 184 195 179 80 81 217 45 18 231 195 145 220 88 61 12 140 198 56 25 119 60 0 180 70 210 66 3 235 64 94 39 240 166 62 234 158 13 2 23 106 130 190 113 135 55 20 56 156 186 135 6 121 249 169 101 188 239 97 147 102 105 120 77 250 252 91 7 99 97 28 161 35 243 62 12 189 155 217 141 143 54 157 253 203 225 167 81 26 180 248 209 93 229 73 37 51 254 8 105 80 143 33 67 203 72 36 201 12 253 250 45 62 242 93 85 76 120 252 139 89 167 208 97 229 167 120 11 223 146 97 27 182 176 146 122 22 239 91 86 129 86 58 0 207 23 151 122 182 90 21 27 70 205 134 27 217 56 225 224 133 18 156 228 190 129 14 33 2 17 19 103 39 99 72 117 94 74 183 216 230 114 150 89 73 231 163 13 247 123 123 0 221 128 131 15 235 122 213 2 233 199 45 43 89 116 84 57 83 167 173 183 53 127 221 120 16 203 250 25 39 162 186 114 140 53 164 95 223 158 177 94 2 154 249 123 157 71 93 33 225 130 139 5 9 133 174 131 242 99 199 247 41 59 42 40 29 150 49 22 249 150 232 20 219 2 169 181 179 140 173 175 86 223 205 249 250 6 237 224 153 191 100 43 241 134 62 52 119 159 16 61 225 170 23 120 14 214 71 54 120 84 35 0 114 76 201 212 116 234 239 169 47 47 68 147 209 128 126 104 135 230 149 94 87 250 220 163 223 214 148 190 104 131 187 18 85 219 71 49 232 17 147 154 70 146 161 83 69 38 29 190 139 226 42 0 215 211 79 91 248 139 233 47 182 146 84 156 235 147 238 188 169 115 15 24 222 91 232 222 124 208 248 148 100 212 224 10 122 167 50 9 18 107 111 150 197 93 83 169 166 109 28 80 213 40 185 177 48 62 86 77 249 190 26 15 222 72 103 149 130 187 58 4 217 254 95 227 176 165 35 199 128 161 188 204 120 203 181 98 109 208 96 45 9 194 176 35 171 237 38 94 48 250 123 70 202 55 243 0 62 45 139 24 133 194 128 4 45 212 115 244 13 5 233 255 222 27 107 65 156 158 209 144 248 90 87 250 201 247 11 25 198 120 33 137 103 157 84 217 54 135 191 147 123 240 122 203 1 210 39 216 204 131 186 12 167 236 230 29 103 208 115 250 226 2 27 208 56 14 230 76 22 237 59 20 196 13 122 142 64 54 62 31 18 32 4 40 231 254 50 77 143 184 159 31 202 164 10 218 230 169 83 168 102 228 33 84 210 255 221 81 232 145 108 130 187 76 38 151 124 8 12 100 126 254 26 244 13 102 146 153 249 30 173 104 9 175 58 117 8 30 193 187 148 201 3 10 18 95 191 83 58 164 112 194 14 64 30 19 74 212 253 27 178 96 93 104 213 186 201 12 86 197 103 246 25 241 121 67 57 48 151 108 35 181 243 211 255 177 103 41 60 74 206 212 229 189 28 30 205 159 253 71 195 35 135 245 181 178 105 202 26 16 101 45 102 154 232 169 80 136 148 92 104 218 109 238 2 224 182 60 123 201 31 251 5 226 60 119 166 128 62 210 53 153 45 85 183 62 120 64 42 204 139 187 213 93 62 207 49 176 169 173 246 217 163 60 43 80 248 105 84 42 83 45 60 23 11 26 49 209 32 28 172 98 143 95 91 79 173 253 219 211 24 78 229 214 50 101 178 123 22 25 21 182 130 203 64 138 93 251 53 2 58 151 151 194 33 243 119 62 149 24 101 73 34 48 107 170 36 100 176 72 19 23 5 112 196 200 167 161 55 148 71 203 126 214 173 76 93 215 88 246 111 225 174 128 134 19 195 64 173 48 217 207 27 57 66 42 41 82 224 132 175 102 210 255 109 52 149 103 57 107 170 132 106 55 88 124 60 77 104 120 40 223 255 184 184 0 215 10 255 116 252 182 182 95 152 69 255 141 201 96 205 21 34 85 202 230 54 41 248 56 218 128 15 165 197 220 100 156 134 238 248 151 220 235 38 224 94 234 204 52 49 236 18 194 202 200 132 59 7 145 213 30 163 163 57 144 242 197 206 127 155 82 154 15 63 17 105 51 80 164 68 7 219 111 81 204 81 64 175 154 206 242 228 137 180 212 67 68 46 131 186 230 30 151 206 240 158 143 41 164 207 239 173 169 110 237 178 225 89 243 4 14 35 254 107 150 162 222 101 121 222 12 167 5 150 80 175 71 227 213 221 190 146 217 31 49 172 75 192 168 92 92 12 111 63 9 197 78 61 225 247 128 120 245 151 150 42 51 49 20 19 48 139 36 52 221 233 205 25 96 254 170 42 16 175 212 174 233 14 141 26 161 97 190 122 145 52 249 182 219 81 104 198 203 72 2 57 194 74 104 118 15 142 157 170 19 3 212 228 135 73 41 228 18 113 90 164 201 194 213 228 77 133 217 83 54 200 38 217 203 102 78 117 138 173 216 228 241 141 198 23 133 42 235 224 165 183 152 161 46 6 252 179 38 55 33 49 237 133 83 207 59 63 231 16 200 226 35 238 29 139 91 1 183 94 79 132 232 253 32 237 219 157 11 120 154 220 77 177 161 191 9 219 155 81 161 31 3 227 80 155 37 75 161 190 211 238 6 129 46 137 244 240 156 1 15 228 71 197 130 222 51 42 34 243 190 92 66 240 121 237 224 11 194 97 90 101 55 217 112 155 217 216 56 174 92 62 176 152 180 76 132 82 98 79 41 41 76 37 80 98 33 10 181 251 134 98 19 199 211 198 63 26 146 204 17 41 179 69 72 203 179 241 41 168 103 249 180 161 73 203 245 189 82 171 67 205 198 159 228 20 147 252 203 243 76 213 186 167 235 197 241 9 60 182 175 119 146 142 58 211 251 37 210 34 139 205 248 62 217 14 134 158 218 9 43 72 70 208 77 51 2 204 234 200 110 5 43 108 89 157 236 107 172 74 143 202 146 157 145 237 126 182 229 97 175 154 194 202 34 185 156 97 163 44 31 130 33 60 252 117 191 152 2 163 54 138 169 49 150 206 161 168 120 41 135 162 209 225 60 120 195 35 225 60 100 208 213 219 213 54 190 175 167 189 54 36 184 118 235 120 103 141 120 164 27 45 44 213 88 160 8 200 38 47 56 126 115 242 173 81 227 159 88 169 240 185 189 133 74 25 159 107 9 254 91 87 137 199 41 54 252 146 89 89 98 35 123 214 112 19 229 47 77 77 217 191 22 109 242 207 33 41 94 231 23 117 244 60 89 193 28 210 70 65 15 55 1 131 255 184 52 183 202 210 97 87 42 224 17 187 90 135 69 30 100 178 139 105 192 178 110 107 188 115 42 119 193 103 232 125 97 121 238 170 29 189 199 66 116 245 39 201 218 167 96 67 254 70 166 227 62 186 93 248 94 76 229 233 216 25 228 103 235 129 255 64 119 252 16 1 216 62 109 44 159 81 87 209 43 233 53 198 11 139 147 122 29 240 209 163 111 246 66 186 40 187 19 69 98 213 155 186 133 13 219 253 212 25 188 32 55 107 176 227 129 198 96 159 226 127 115 33 29 255 76 231 61 165 81 141 175 97 48 77 67 178 30 154 53 81 125 158 108 201 186 88 104 254 111 166 6 112 28 204 183 237 245 243 120 134 203 253 34 16 130 62 231 27 126 178 119 2 118 39 94 112 147 49 220 108 240 144 108 26 165 150 108 44 166 195 148 23 65 149 200 154 128 57 52 183 221 26 70 189 104 92 152 127 88 171 200 91 61 102 213 75 127 182 5 149 240 116 36 164 31 56 46 231 186 79 90 61 27 74 122 228 157 229 89 109 218 58 187 235 247 71 126 108 158 249 86 207 197 58 47 93 243 202 4 178 165 147 65 187 169 134 208 253 123 152 134 21 143 67 77 200 33 135 27 128 23 189 233 2 106 209 178 17 108 189 245 63 57 166 240 120 242 70 131 161 91 200 177 98 195 18 79 224 203 192 96 129 48 193 240 252 56 83 209 59 44 55 159 140 131 161 11 210 218 139 29 58 225 155 12 233 36 116 246 53 147 84 72 84 100 215 223 107 72 210 252 150 161 233 241 99 150 236 177 85 25 107 210 39 214 194 58 63 9 101 136 171 239 211 196 79 195 88 43 118 140 156 51 240 227 124 129 171 110 247 137 150 192 82 176 2 55 60 176 196 164 230 47 27 163 47 242 205 205 233 103 201 7 35 103 196 142 53 224 149 168 116 195 241 76 0 70 159 248 191 2 48 122 93 158 35 55 67 207 255 42 248 244 226 240 8 83 79 7 42 145 124 130 11 84 101 247 140 212 69 157 75 183 96 214 19 103 54 70 4 135 196 184 136 8 171 149 6 9 175 126 166 18 242 178 202 162 48 48 105 13 253 9 246 4 41 220 114 11 205 49 146 248 231 135 104 1 87 17 51 132 131 2 75 156 225 135 215 8 58 157 60 180 59 126 148 71 180 189 73 205 221 172 160 100 136 16 38 160 66 249 43 240 22 174 154 202 129 74 209 95 100 188 143 254 165 50 102 43 81 210 224 193 22 71 116 153 164 190 161 87 40 225 227 87 92 133 113 130 245 75 98 112 209 42 88 226 15 55 52 181 227 28 76 11 180 53 188 122 15 253 16 75 147 89 190 150 173 232 32 178 41 28 106 32 185 124 239 108 85 162 169 108 21 58 124 232 167 184 159 250 231 77 204 178 216 233 120 253 45 57 243 188 150 7 175 156 130 19 170 114 9 102 240 75 172 222 173 0 215 248 205 115 21 108 251 59 0 208 18 63 140 96 46 155 218 5 126 160 243 208 54 29 225 195 123 95 105 60 240 114 114 83 31 244 27 22 35 224 201 74 129 216 27 171 190 173 221 251 203 231 19 31 36 209 212 115 221 36 172 244 213 41 225 145 174 255 27 53 181 174 232 251 241 118 246 34 134 161 74 21 48 196 92 46 196 84 173 86 229 165 55 72 99 73 131 90 178 6 92 143 8 100 158 154 119 57 155 94 230 134 71 126 36 204 187 5 152 75 109 19 69 191 123 156 163 107 200 54 178 14 117 216 33 111 206 127 103 198 240 161 71 113 46 155 228 56 107 245 197 128 8 83 230 85 33 30 146 76 176 71 82 249 112 211 38 207 59 196 243 10 41 216 16 36 107 253 75 122 155 242 196 225 139 8 3 104 115 151 135 47 188 107 64 41 46 24 7 186 114 146 150 3 247 29 210 128 180 189 88 233 172 150 9 120 116 163 101 194 186 141 225 242 239 75 247 237 220 215 155 30 49 139 197 213 164 181 110 81 153 255 243 29 231 47 176 48 164 137 91 221 52 209 162 6 74 130 90 214 97 213 252 120 237 225 167 150 179 41 77 165 70 52 250 236 47 31 138 249 105 131 36 51 105 35 13 22 38 137 27 234 10 206 28 227 126 236 16 225 169 200 193 200 137 171 229 192 146 79 152 177 33 88 166 28 98 219 68 114 105 131 203 131 254 84 125 163 143 197 25 57 104 14 146 145 80 15 143 7 37 209 78 98 245 66 1 12 90 249 70 157 67 221 86 80 186 29 89 199 125 250 206 190 137 169 206 160 111 138 133 154 179 32 52 105 190 35 7 98 74 219 125 130 113 245 241 138 184 128 231 186 49 18 131 192 209 128 50 99 26 233 189 241 0 126 220 1 108 149 108 180 218 224 222 168 187 92 0 245 114 92 182 201 34 226 6 39 180 151 77 245 118 86 10 140 193 165 96 108 3 183 184 151 127 227 199 3 64 51 91 134 65 203 173 14 136 46 166 183 56 175 224 185 146 94 22 195 164 137 146 118 145 99 196 5 145 171 58 226 47 253 165 143 225 244 220 97 17 250 241 79 71 49 14 121 120 157 225 191 197 165 28 200 218 26 43 216 192 169 44 230 86 7 219 55 18 14 59 120 60 143 223 51 100 13 251 214 132 53 85 172 95 195 145 94 12 190 12 68 212 248 42 142 144 189 171 231 25 80 19 112 254 186 56 12 72 30 193 223 121 12 234 3 242 40 169 197 244 155 58 65 252 239 195 20 238 98 210 13 15 37 84 13 86 191 240 236 109 172 77 245 138 238 94 0 101 76 149 229 248 14 14 39 107 158 15 134 145 231 92 86 253 220 241 110 196 63 174 119 5 37 143 190 135 48 187 138 222 9 238 181 39 101 171 81 142 70 121 46 163 180 133 116 124 120 46 113 202 158 140 137 254 158 50 71 202 1 204 172 20 152 99 246 70 81 115 190 248 25 93 127 175 136 216 97 87 108 106 180 105 185 168 87 74 98 8 225 118 64 9 205 207 202 238 174 49 181 254 63 210 96 221 126 226 76 145 31 136 83 167 178 5 5 189 238 43 19 61 77 167 76 58 15 4 194 144 204 175 123 32 23 67 131 123 185 116 129 227 198 220 145 5 138 242 235 83 39 223 189 220 24 93 166 82 95 65 72 169 217 25 108 195 80 211 68 232 12 183 214 244 221 245 92 36 140 171 178 222 230 245 54 64 9 39 236 223 169 53 154 179 30 41 82 161 137 66 114 29 183 147 74 192 123 162 34 106 217 114 140 116 137 67 155 212 83 107 245 13 194 191 40 209 183 97 143 30 217 26 9 138 9 148 16 33 193 7 168 189 19 113 111 143 77 120 185 96 251 114 100 240 149 230 238 204 96 183 36 150 46 162 157 254 32 104 192 79 20 0 148 186 153 213 82 34 86 135 0 225 232 185 203 25 101 26 60 167 128 162 250 40 92 103 212 165 165 52 207 60 19 223 84 214 170 80 159 176 37 17 21 223 241 118 229 149 85 161 22 63 157 131 16 205 194 182 30 35 216 22 160 12 15 143 49 246 39 208 21 59 97 237 181 135 5 141 47 216 184 253 118 159 96 134 11 25 254 161 206 20 197 17 163 144 154 91 57 63 212 187 36 33 125 136 231 159 89 251 94 238 48 85 236 243 13 72 144 100 130 226 117 243 210 170 170 91 90 58 15 28 226 44 83 72 169 151 216 220 142 71 17 67 82 147 92 215 159 6 21 24 8 137 59 200 45 245 55 189 177 200 86 196 18 176 222 80 134 184 251 230 135 149 105 130 174 63 68 65 195 160 124 199 230 104 71 164 171 200 108 238 193 220 238 88 179 115 0 34 240 24 165 51 105 132 240 105 153 71 139 64 6 181 224 4 160 108 7 149 152 60 93 92 75 119 90 81 48 248 213 97 51 72 147 53 71 10 15 146 235 123 222 169 107 135 68 218 136 39 121 69 121 212 85 29 239 20 92 206 82 231 161 242 206 144 88 175 160 226 165 210 233 226 136 44 163 197 219 98 60 237 172 82 58 167 125 61 105 103 139 176 29 45 59 171 79 235 201 83 11 5 179 62 238 192 160 232 137 155 187 56 77 188 217 155 99 34 87 23 139 179 37 58 63 182 62 197 111 248 41 15 176 68 179 23 246 63 44 221 15 191 239 54 210 136 173 48 219 72 129 50 178 240 28 30 27 84 26 140 98 79 58 77 223 220 26 124 41 123 45 141 237 49 104 27 12 226 184 134 29 200 149 107 101 79 76 142 208 99 2 60 188 28 11 24 206 17 112 18 85 239 143 117 9 142 17 97 174 178 251 96 146 91 179 61 127 43 184 243 98 198 114 53 60 73 161 187 245 115 221 161 89 6 194 10 159 181 115 39 223 156 100 68 219 102 249 158 17 171 239 154 225 106 171 7 241 245 101 110 185 102 1 103 244 153 197 253 137 80 121 69 180 62 205 105 61 93 39 48 41 110 98 83 65 50 109 128 236 13 115 12 22 21 193 88 121 255 58 94 95 216 254 70 115 159 179 165 62 223 41 138 170 172 209 57 188 17 38 38 190 211 20 133 240 241 204 217 26 212 153 129 221 172 81 248 112 209 66 161 65 195 110 165 29 223 100 92 13 155 82 8 184 17 203 144 35 219 91 227 65 172 87 2 177 175 7 178 157 147 133 254 44 22 102 181 15 228 202 192 211 66 184 94 119 206 171 130 24 42 147 136 179 101 177 231 29 204 9 117 11 119 210 55 217 158 91 154 67 223 108 90 233 210 153 114 140 2 143 142 28 173 243 95 33 46 216 150 123 204 1 160 97 2 64 77 101 125 190 23 197 68 220 59 106 151 61 252 230 174 6 59 64 151 162 38 54 110 19 83 11 145 206 208 67 77 52 165 154 1 154 45 151 132 62 193 8 57 64 57 196 23 41 229 77 87 177 111 26 144 5 22 219 20 15 5 8 92 60 77 244 175 151 68 28 48 132 232 154 234 254 0 20 200 38 241 148 17 202 104 35 140 50 12 227 152 157 241 242 250 124 221 3 150 152 56 230 17 106 215 145 163 207 58 217 175 0 173 10 191 68 144 177 224 185 10 106 236 8 2 215 236 111 115 95 232 171 194 26 96 16 11 87 129 157 129 59 103 152 254 126 25 131 35 15 190 176 97 54 42 62 65 225 38 232 201 102 20 76 96 227 65 57 254 144 39 162 129 212 159 255 186 222 239 115 19 1 202 87 216 108 196 213 23 156 80 48 67 67 62 95 8 28 148 90 168 42 246 37 188 167 77 116 241 10 43 139 208 204 30 13 14 224 80 113 68 251 162 244 110 59 186 77 51 123 20 59 114 243 227 39 104 73 69 251 125 98 49 104 161 222 233 160 50 208 225 235 116 149 43 32 79 68 120 111 234 134 226 80 150 182 7 205 112 3 39 112 51 89 41 245 234 205 98 167 19 173 28 225 249 164 64 176 162 76 126 42 67 173 31 55 93 93 232 212 118 117 57 116 12 143 117 8 82 136 125 9 64 72 106 240 226 206 147 61 84 19 120 181 22 69 162 236 124 214 54 95 247 33 70 98 10 56 93 96 102 199 172 209 12 242 105 230 247 174 117 41 50 138 202 136 218 195 194 91 241 148 108 91 125 138 137 246 206 121 17 35 83 114 172 0 13 7 21 42 222 1 223 96 161 97 25 84 156 113 242 133 158 105 101 89 243 147 78 147 93 29 22 146 244 87 206 168 217 191 58 35 95 159 148 53 88 128 106 31 115 51 241 35 47 159 207 5 238 204 63 48 62 130 142 80 217 149 45 14 10 56 86 218 214 14 139 70 62 102 124 218 62 123 7 218 210 111 10 178 132 8 95 12 154 175 57 98 93 47 83 226 67 70 168 5 253 30 133 51 205 202 93 138 200 22 92 142 117 112 20 135 122 73 118 152 155 216 164 243 71 206 43 222 241 22 150 98 81 95 0 16 42 182 196 50 67 55 128 212 47 215 86 253 76 163 95 156 99 157 204 213 113 170 103 157 180 93 78 87 45 121 70 45 217 247 82 223 120 186 215 14 142 237 10 115 12 203 53 50 129 212 255 18 221 207 127 141 73 68 166 68 169 50 140 89 162 56 196 200 235 195 90 181 172 202 203 149 163 58 10 249 85 251 81 155 90 66 4 23 90 42 46 4 58 159 138 115 198 202 13 238 66 13 217 193 212 186 212 170 45 223 160 9 251 202 57 128 249 134 33 135 57 219 200 148 181 53 74 210 118 249 228 182 94 136 113 182 158 104 38 6 54 27 176 104 53 15 134 151 117 196 199 92 212 145 164 77 255 146 150 118 181 60 1 2 243 150 3 123 156 184 177 69 111 106 234 194 239 83 173 138 138 108 64 53 114 211 65 113 201 156 18 169 185 9 153 221 119 3 241 51 18 117 92 76 237 191 162 30 139 97 86 173 166 218 126 45 250 156 161 241 106 122 137 194 0 184 249 86 80 133 220 62 217 7 150 126 114 90 54 131 214 34 186 191 44 202 66 212 10 223 245 195 181 130 141 30 231 136 8 71 38 252 194 8 47 215 155 29 204 74 2 24 59 233 165 3 246 45 156 53 131 160 72 139 61 207 169 35 45 236 36 101 75 206 142 6 176 92 129 4 154 199 146 209 75 65 73 160 165 160 55 58 171 85 205 135 158 117 33 95 64 233 186 58 198 196 139 228 125 250 115 236 12 247 103 35 138 230 107 3 178 153 220 194 169 37 233 30 52 11 118 213 206 220 98 55 21 68 205 165 106 56 126 60 168 68 34 28 47 158 76 155 111 184 221 238 140 242 100 52 44 139 126 15 10 181 162 100 169 166 42 230 187 7 116 76 92 56 111 199 165 231 123 109 30 226 249 109 18 183 176 210 12 176 146 125 125 194 139 22 102 136 32 69 16 136 207 152 175 247 77 9 211 31 234 36 3 233 91 46 210 246 9 126 87 239 34 36 68 199 83 231 186 206 226 74 208 246 209 189 123 128 141 208 243 128 17 252 11 34 108 88 236 101 107 163 172 228 132 73 141 78 34 224 150 169 209 51 60 159 171 100 56 146 57 128 145 104 178 209 28 82 169 62 223 211 30 33 30 128 180 139 19 48 34 228 127 123 56 117 177 79 66 188 80 116 152 38 135 16 28 24 89 120 240 113 206 160 2 114 43 107 240 100 107 225 32 216 164 106 52 29 248 26 121 73 101 252 155 99 49 86 231 30 18 240 54 138 19 26 68 107 92 34 175 11 56 162 200 207 140 37 100 205 134 247 21 40 155 61 42 191 192 101 177 220 130 2 202 221 203 21 2 223 187 85 41 247 162 81 5 101 4 235 33 149 160 172 114 97 210 40 59 34 182 20 225 175 177 202 105 67 159 200 193 170 80 95 240 240 140 89 85 225 178 52 181 230 141 81 253 128 108 50 197 178 237 174 1 55 247 13 74 104 116 179 115 249 91 146 49 55 47 20 35 207 251 29 119 33 60 136 249 40 108 74 0 168 133 52 249 113 97 36 255 231 201 152 130 16 103 119 86 184 117 122 30 74 78 66 121 252 72 222 213 50 110 134 213 156 2 27 216 52 184 235 169 195 170 63 26 68 107 49 74 228 139 16 192 47 218 158 30 77 179 189 203 149 145 136 99 70 4 236 205 5 208 115 191 167 20 69 213 223 113 109 127 182 66 99 211 22 64 84 179 65 68 182 246 231 245 227 33 77 15 229 240 230 99 119 244 177 64 99 179 23 60 43 243 234 45 60 167 187 230 38 125 118 157 172 36 234 182 27 180 178 188 210 60 46 185 34 7 161 78 229 22 189 170 58 2 23 6 105 66 16 225 160 19 251 82 252 251 67 228 206 47 97 216 32 38 240 145 115 221 198 232 47 115 226 32 240 185 246 63 234 4 247 231 174 103 194 29 26 135 111 60 230 175 238 1 192 39 137 182 151 71 35 234 93 189 173 63 205 44 233 252 171 28 57 29 46 170 72 233 153 51 142 177 147 140 26 88 156 83 152 153 108 168 138 129 244 233 106 105 102 38 214 207 138 109 229 159 83 157 10 70 204 197 234 32 50 53 236 238 187 23 249 182 136 116 140 100 71 141 16 96 141 203 10 157 226 78 134 179 145 48 44 67 125 135 174 215 196 55 252 3 62 187 109 62 217 232 32 109 72 166 98 217 254 143 112 27 161 166 250 30 246 216 76 141 246 142 156 88 237 150 51 9 136 42 112 91 113 176 74 154 118 78 196 64 139 250 166 10 163 203 177 23 235 111 145 227 73 5 206 74 199 243 149 255 188 144 22 5 228 234 247 90 197 133 135 1 108 177 19 168 158 181 54 254 230 10 3 125 106 7 165 219 82 223 92 99 177 35 117 213 42 173 30 124 39 124 219 44 141 127 119 244 243 156 149 247 74 80 93 79 171 28 210 240 174 46 97 118 133 208 146 185 229 66 106 55 23 132 67 197 131 145 175 131 28 0 122 63 248 102 217 81 213 152 111 193 33 232 112 222 89 240 149 97 61 192 100 191 110 187 62 57 27 77 86 189 15 35 74 65 161 120 168 196 245 27 61 171 17 72 98 230 120 240 25 155 78 9 108 2 76 187 168 99 129 137 81 62 133 255 165 66 65 221 0 231 48 221 83 165 37 222 92 187 121 100 177 90 186 225 239 186 242 13 16 207 194 28 132 195 12 233 229 201 255 199 4 96 1 153 34 128 220 195 237 160 247 237 77 76 28 114 207 101 10 245 134 174 242 119 4 73 227 243 254 85 216 212 161 196 64 229 163 86 4 218 124 233 205 148 104 59 27 224 2 138 238 196 189 15 170 86 211 154 184 245 242 81 100 25 56 186 179 117 190 146 77 77 240 238 236 107 120 65 35 19 23 202 169 120 120 149 232 89 254 25 237 77 237 91 101 0 199 169 104 137 168 189 86 126 191 13 76 243 209 243 247 81 156 217 229 93 63 194 57 229 211 202 52 217 147 205 113 89 195 86 13 65 123 134 209 151 9 240 180 238 214 245 2 77 95 180 191 116 232 125 55 85 49 217 197 237 147 202 122 76 69 35 6 9 190 138 240 124 66 131 99 154 223 190 104 84 92 210 34 19 62 104 24 108 121 241 90 247 196 186 229 25 17 18 85 97 241 139 150 20 118 86 77 189 12 185 67 234 56 143 19 96 216 54 253 125 157 116 124 142 118 185 239 98 108 56 3 2 193 35 6 255 170 57 178 73 255 155 247 191 161 111 164 129 235 183 147 48 129 74 87 114 108 178 168 84 144 88 4 241 60 5 121 132 195 82 24 172 194 145 138 105 25 54 104 188 227 12 31 7 41 252 188 30 71 242 240 204 25 4 63 104 76 227 157 69 186 100 201 127 240 64 44 87 163 151 21 244 254 187 61 131 85 104 179 150 181 3 29 91 120 36 99 156 160 0 212 79 146 220 241 165 4 223 180 132 151 13 211 117 83 194 69 116 250 30 237 81 228 87 45 17 220 88 225 123 106 183 40 179 177 234 168 195 238 160 208 102 147 170 55 71 196 132 177 1 243 159 95 223 239 61 90 216 122 136 116 76 40 211 127 41 216 142 224 178 153 212 129 143 22 97 73 71 21 18 170 202 110 28 73 247 26 116 87 31 58 145 60 159 45 76 46 188 186 157 195 28 116 36 43 173 154 190 144 27 147 31 157 62 234 178 87 47 155 141 245 130 245 73 32 142 25 14 203 209 99 183 5 142 138 2 196 56 234 171 67 193 185 86 154 220 140 196 226 212 8 29 76 53 118 211 233 8 2 3 115 120 254 136 56 69 128 45 180 145 203 91 213 139 132 39 121 143 212 245 135 165 238 33 152 152 181 62 160 183 22 250 6 102 193 160 21 176 111 245 191 104 162 84 23 174 76 198 108 161 12 174 186 25 97 80 91 247 177 206 149 141 110 250 238 99 80 96 140 107 123 224 82 31 99 178 80 7 241 130 142 177 248 3 228 240 6 140 76 180 69 249 76 137 248 122 174 104 34 215 221 122 152 53 120 136 104 42 97 64 151 3 9 40 234 129 174 18 51 28 183 24 143 151 37 52 166 236 151 30 21 71 85 126 237 19 69 55 51 89 158 41 6 243 199 207 231 210 137 9 154 35 172 172 50 125 35 192 159 24 58 249 40 58 136 164 49 13 209 154 85 19 39 16 14 34 13 74 252 191 168 54 194 219 161 29 239 187 27 61 200 246 221 136 223 184 56 57 79 198 250 235 151 226 158 107 178 254 62 69 151 96 45 225 115 251 71 190 204 250 139 26 218 234 39 143 90 212 200 118 15 109 86 25 226 207 241 55 69 200 209 91 54 115 88 28 156 113 159 93 153 71 49 245 142 127 27 250 201 140 38 49 217 72 124 49 35 203 65 157 212 131 133 33 48 214 105 198 126 74 70 135 224 46 102 3 124 157 151 252 188 51 50 5 8 28 128 205 102 52 234 236 238 193 168 238 167 114 120 209 82 233 248 159 252 107 50 59 178 114 66 190 67 212 236 86 125 160 154 228 4 131 213 162 96 42 51 226 23 196 58 131 50 246 46 65 223 115 47 128 249 43 38 182 237 80 180 54 148 60 188 234 126 138 238 122 115 16 149 197 185 221 217 138 183 135 107 87 50 212 136 15 40 0 229 155 93 235 212 41 218 172 27 122 138 33 23 181 63 216 126 15 113 94 214 93 201 173 216 143 78 66 171 119 14 124 102 39 109 172 42 39 169 182 54 234 57 50 47 44 190 11 3 163 8 22 97 121 11 165 153 175 177 111 186 8 154 222 117 12 38 49 229 116 38 145 65 107 42 227 47 77 87 166 237 248 172 168 64 58 126 153 97 155 215 244 106 92 82 205 253 69 203 50 18 201 125 28 7 239 101 29 64 98 147 52 155 220 176 177 115 128 234 1 109 117 216 25 95 206 167 99 106 248 111 237 237 117 127 204 199 126 96 59 187 183 36 60 55 166 139 19 17 220 247 33 189 105 151 103 40 201 72 136 10 147 63 255 212 233 6 241 144 58 136 229 151 130 125 217 167 74 238 229 150 254 127 89 172 242 34 17 10 207 170 245 39 34 123 179 34 105 233 20 120 203 128 164 124 110 236 18 143 77 213 26 213 95 30 27 246 148 226 122 194 235 78 70 183 89 17 93 9 239 138 210 189 217 34 25 26 24 115 169 53 55 127 53 244 92 231 183 223 200 117 233 45 191 204 57 117 43 77 234 129 193 45 99 91 82 248 111 158 249 102 217 12 160 116 141 7 115 25 90 173 252 173 227 61 59 93 56 81 57 124 163 194 106 5 200 226 1 47 188 110 108 195 247 108 135 144 72 36 182 13 179 70 150 177 206 160 151 127 49 213 183 10 127 40 52 229 244 194 227 250 114 145 103 173 221 59 179 209 104 210 151 23 65 214 67 40 66 57 21 237 120 202 136 52 97 100 69 144 220 95 134 170 134 143 60 144 236 14 176 165 147 62 75 195 206 72 254 21 202 128 142 205 194 192 28 239 59 61 233 89 52 8 115 1 239 137 84 31 108 234 219 14 197 163 191 242 224 54 1 41 104 164 201 195 88 66 213 24 146 26 202 153 34 58 120 169 159 144 218 169 134 45 9 242 27 4 124 141 253 80 43 105 247 129 90 85 130 107 61 111 59 252 22 21 148 185 117 189 191 177 95 91 29 186 51 213 96 199 222 102 14 175 131 73 47 244 54 67 196 180 83 182 206 62 141 204 143 174 52 232 53 74 45 129 87 175 20 43 220 167 27 128 67 212 9 77 145 163 8 247 245 222 181 197 66 193 141 48 17 113 36 95 190 245 78 40 152 225 253 28 255 216 93 244 206 74 143 15 113 223 46 43 60 32 118 144 161 70 248 134 164 238 111 201 28 62 177 176 69 201 154 104 250 31 112 180 213 26 217 76 65 94 135 130 133 60 106 115 35 238 235 227 246 47 236 152 25 12 110 145 182 70 51 199 184 81 249 98 106 189 1 47 248 152 120 197 144 58 21 37 88 231 235 122 14 38 90 239 203 95 199 157 179 227 65 188 87 132 48 70 255 105 73 12 25 0 171 211 25 167 192 150 166 130 200 184 139 55 178 186 181 242 108 171 237 154 22 23 39 101 162 217 138 160 80 26 204 191 237 193 175 87 156 97 6 4 84 194 10 202 42 86 13 120 181 87 177 208 106 161 99 127 4 197 63 229 110 94 212 145 210 189 100 227 211 240 72 37 170 43 128 240 241 73 113 19 99 207 193 197 241 135 95 191 175 69 71 16 15 133 187 45 217 117 163 50 87 58 214 254 45 49 106 29 55 195 1 32 6 209 139 244 16 14 36 49 172 121 1 93 68 198 188 36 153 56 81 159 89 30 124 56 88 91 39 243 171 28 248 213 205 15 162 83 189 207 144 113 12 30 90 34 199 46 47 139 119 223 237 90 44 5 191 154 9 51 8 42 84 153 125 15 113 207 179 144 229 165 197 202 123 123 181 152 175 252 70 202 72 78 210 34 243 112 4 153 59 104 35 31 194 148 106 229 22 22 39 218 170 1 156 44 127 84 30 106 40 39 188 148 120 115 220 217 115 103 168 221 30 12 243 191 4 22 79 211 17 48 208 134 216 126 131 136 49 127 210 97 102 63 165 253 121 28 237 79 64 33 123 60 51 88 170 38 8 116 143 117 145 65 158 169 205 63 22 60 130 75 52 142 238 122 10 159 164 34 172 13 112 95 100 197 190 13 72 59 16 105 230 33 195 90 133 153 126 212 49 1 240 16 252 129 135 58 124 244 168 86 111 140 150 4 168 41 7 215 1 100 16 229 227 55 6 90 239 185 83 52 200 162 82 69 187 73 129 154 46 42 164 8 176 15 136 249 188 178 223 108 210 183 137 111 76 62 111 92 48 14 181 150 131 245 200 150 11 69 147 230 44 106 47 138 207 143 0 185 75 125 64 221 135 74 89 48 169 106 110 79 161 160 47 127 175 61 93 148 25 10 133 247 47 164 38 169 81 101 145 186 209 239 63 251 107 221 179 127 222 65 224 195 57 211 246 243 241 154 251 69 183 163 88 89 104 48 57 151 186 103 109 249 96 113 239 172 19 52 253 6 108 218 237 58 229 209 126 191 97 169 131 42 166 16 21 4 187 101 71 14 104 255 181 109 109 255 204 163 116 45 100 200 166 159 121 234 50 138 193 70 112 9 26 242 137 118 38 132 147 76 207 223 25 47 135 236 19 128 86 20 240 49 183 205 164 79 41 59 63 138 157 195 241 141 250 55 46 93 194 98 239 26 128 203 165 68 236 154 131 211 100 28 6 194 219 172 31 57 111 232 181 3 168 8 128 54 15 84 59 102 107 57 167 103 143 117 103 82 103 49 152 224 157 59 20 190 142 244 182 29 66 184 242 243 27 198 142 56 236 32 119 11 109 147 85 86 87 150 120 231 179 38 247 18 65 141 145 25 126 61 87 70 218 67 53 140 70 234 139 106 65 245 25 72 250 116 91 210 233 246 6 102 49 56 164 209 73 182 76 218 120 121 163 240 231 114 26 0 36 125 180 60 254 7 125 93 194 14 225 182 197 115 196 61 10 170 175 119 146 82 154 69 7 182 129 1 139 129 136 228 229 21 142 88 167 77 77 211 109 211 187 179 195 105 201 212 175 92 214 212 216 142 155 106 226 184 99 178 145 83 69 83 225 155 216 201 128 113 2 85 146 98 107 108 250 140 28 81 45 204 178 132 199 171 172 244 205 84 108 35 126 228 68 129 153 19 7 104 189 62 245 59 182 242 225 111 204 247 108 143 138 106 198 204 19 166 6 7 2 146 1 187 64 50 48 5 108 81 146 218 230 147 97 113 180 37 228 167 94 113 203 34 141 65 202 100 90 146 127 222 71 214 166 12 26 243 112 26 9 120 38 223 135 246 198 70 171 105 174 165 74 8 98 25 130 227 43 248 1 217 215 25 164 216 159 182 110 147 29 144 17 86 109 35 102 89 18 81 205 18 49 0 67 177 204 70 1 3 115 32 191 224 1 222 137 79 20 254 211 140 156 71 77 189 18 246 40 50 36 100 133 9 110 154 148 68 148 185 20 183 93 247 2 70 134 78 198 38 211 7 225 252 51 246 200 199 180 18 27 115 124 124 142 146 227 20 247 47 92 71 251 127 117 133 95 153 80 178 69 114 1 210 71 4 46 30 225 0 25 99 77 131 64 199 158 14 64 22 223 41 219 65 106 197 169 1 143 235 98 228 131 130 246 137 62 161 100 185 67 32 51 126 55 178 253 129 231 254 3 143 44 17 217 49 1 47 52 205 175 216 148 80 76 111 233 178 103 224 243 210 172 152 19 68 38 151 27 80 40 151 140 55 246 118 93 97 221 247 89 8 160 132 98 237 162 179 223 206 167 173 156 120 211 150 35 176 28 189 253 121 90 119 4 106 235 218 71 140 228 130 69 46 64 139 139 142 76 59 217 203 88 132 1 162 238 108 134 161 190 249 193 105 98 40 143 217 201 121 55 144 200 145 232 61 55 0 132 149 63 189 169 174 94 133 247 88 220 93 0 159 107 153 222 49 212 201 22 224 119 144 74 115 73 243 62 245 39 234 51 234 246 137 213 36 18 220 222 7 19 124 61 98 240 84 80 62 34 169 235 130 142 120 97 55 125 237 7 141 223 44 6 72 177 4 48 140 45 46 40 213 114 146 95 147 11 89 61 94 31 99 43 118 47 188 85 174 89 111 173 239 144 84 173 59 64 204 149 10 118 89 9 58 155 200 122 3 54 93 18 97 227 127 213 227 39 73 228 233 63 201 54 147 190 58 47 186 205 163 90 98 208 192 30 113 208 187 232 52 168 120 232 65 60 71 228 104 89 81 186 101 221 90 243 113 104 20 158 171 187 180 155 78 138 105 15 198 34 132 234 112 78 21 139 43 19 242 2 106 74 100 88 141 253 9 78 12 13 241 69 226 123 51 102 196 60 123 59 114 9 118 232 50 110 148 112 49 67 80 224 105 135 87 207 190 71 127 222 145 59 28 167 127 203 237 51 197 41 245 2 149 170 252 140 60 26 190 21 51 160 240 159 132 13 87 44 59 187 233 71 111 145 120 169 239 56 248 102 220 116 95 174 41 43 141 220 52 16 240 131 76 135 31 204 75 141 206 66 201 59 84 142 114 106 155 81 138 120 198 156 126 16 146 179 95 18 68 227 95 166 75 214 85 236 51 110 122 109 52 169 253 246 53 189 132 237 170 121 131 173 120 55 14 84 244 5 50 43 62 174 15 180 232 197 203 93 204 205 153 16 227 99 184 0 167 23 106 152 222 225 9 97 177 214 223 91 126 172 61 114 201 197 148 57 173 101 116 28 73 66 164 251 41 163 105 230 15 47 213 16 248 173 148 145 7 15 55 115 237 160 47 144 91 8 90 21 243 124 173 225 37 115 106 39 14 51 157 131 129 146 182 157 217 211 233 118 67 93 233 232 148 90 187 23 190 141 14 216 218 45 251 149 253 209 51 182 42 82 248 254 130 254 5 32 21 139 166 158 126 230 255 85 24 117 129 152 189 133 168 255 8 184 174 245 35 11 105 225 13 103 187 113 63 149 2 206 216 94 26 225 206 188 85 151 202 184 211 124 14 200 36 136 11 232 213 10 71 90 87 156 130 95 54 149 46 221 38 23 105 48 195 63 151 42 160 66 129 215 8 233 189 52 179 66 172 81 10 166 192 239 239 76 140 33 168 234 243 50 29 87 112 186 11 54 93 175 2 208 195 219 133 75 228 201 72 229 84 103 219 120 29 39 24 170 229 233 139 169 84 20 181 6 48 42 185 83 207 172 69 198 168 168 117 196 162 221 61 136 237 82 206 131 26 22 119 63 244 245 86 192 135 64 228 234 98 187 68 126 243 97 13 193 100 117 55 162 239 190 26 142 155 132 27 198 102 181 26 186 127 19 14 45 214 33 198 114 129 75 162 186 8 179 199 199 19 155 84 9 155 25 214 240 74 163 47 121 137 183 24 76 128 42 185 216 51 186 8 67 142 211 238 227 250 138 189 124 128 231 179 64 253 28 221 51 95 140 176 168 199 39 236 212 50 73 80 74 105 130 214 11 9 139 155 35 11 185 200 203 85 21 127 18 119 184 135 116 78 18 64 127 56 232 158 186 40 131 178 47 47 0 12 0 40 73 220 65 133 71 225 55 7 42 219 108 149 236 167 147 90 131 224 191 18 84 212 145 55 41 11 95 179 228 162 22 172 136 218 114 66 235 91 23 154 152 18 180 27 125 201 138 236 238 5 50 102 252 173 191 164 9 77 47 172 103 204 35 114 216 166 198 136 100 194 141 214 116 136 250 132 77 10 32 17 26 218 39 233 25 115 2 124 34 81 3 123 128 108 101 206 72 29 86 55 202 135 61 111 98 233 9 71 154 78 16 232 234 107 46 90 50 129 228 40 161 43 18 96 179 26 30 161 12 0 210 99 219 192 178 38 47 105 11 235 251 129 224 70 137 247 212 15 237 207 103 88 39 35 179 230 56 251 67 163 137 245 124 188 214 142 153 71 137 164 96 73 91 181 60 34 82 5 174 223 39 110 221 134 175 179 156 66 218 177 236 150 70 222 11 49 179 89 205 78 122 212 193 108 34 219 216 111 176 193 136 104 28 99 218 204 121 117 220 156 57 122 221 25 240 176 48 125 88 187 82 179 71 59 229 246 0 77 27 20 233 47 107 212 13 16 77 86 177 81 142 232 230 101 133 157 143 35 55 151 28 85 148 137 200 193 136 18 17 95 142 87 221 40 201 71 228 31 96 86 208 106 17 159 199 61 94 69 229 58 197 226 153 75 140 129 111 173 105 66 73 124 238 146 13 140 120 185 185 33 150 99 216 158 32 202 62 163 213 142 49 101 165 52 150 90 200 102 215 34 161 60 80 112 99 92 164 118 211 114 61 194 212 54 170 61 96 144 167 57 28 58 111 252 62 78 238 207 103 81 77 42 79 208 128 104 134 18 12 143 178 166 233 75 94 6 29 223 7 132 70 241 44 223 22 40 241 179 194 89 63 250 148 54 233 198 81 1 181 211 126 158 159 191 3 177 22 27 225 52 105 17 115 151 28 226 254 39 20 250 229 129 170 36 42 141 4 145 34 200 52 178 241 207 40 102 188 39 112 177 224 237 12 10 33 113 196 207 69 238 72 254 39 159 43 36 231 121 13 224 34 45 181 64 9 167 246 166 226 26 151 51 95 12 80 245 195 134 196 156 203 26 6 49 186 210 180 58 132 5 58 123 197 53 107 22 54 159 24 122 97 152 238 216 200 105 75 182 213 181 124 149 6 248 96 198 78 28 188 96 154 176 44 104 174 240 128 184 67 78 100 225 155 69 62 116 80 101 239 98 84 222 193 127 12 216 6 5 36 123 114 190 21 241 237 35 128 45 101 129 44 213 215 159 235 200 180 171 155 40 94 107 186 198 95 66 2 123 203 197 19 176 37 61 23 122 111 144 205 16 24 205 39 207 111 130 124 103 96 14 133 234 65 254 189 62 209 109 15 206 55 26 127 127 224 233 108 198 37 150 184 213 64 244 13 187 253 58 191 226 100 178 159 48 133 93 118 216 105 250 215 32 141 74 192 200 128)! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 3/24/2001 21:42'!macBrowserPluginFile	^ '/********** Notes on Browser Plugin VM ************How it Works:The browser plugin VM allows Squeak to be run as a plug-in underversion 4.0 and later of either Netscape Navigator or Internet Explorer.To use it, you must translate a version of interp.c with the browser pluginhooks. Note for fullscreen support NPP_HandleEvent does not return control, it consumes events from waitnextevent. When fullscreen mode is turn off then control is returned to the browser.Relationship of this file to sqMacWindow.c:One can think of this file as specializing and extending sqMacWindow.cfor running within a browser. Certain methods in  sqMacWindow.c arereplaced by functions defined here. The originals are removed fromsqMacWindow.c by defining the PLUGIN flag in that file when compiling.Here is a list of the functions overridden:	ioExit()	ioScreenSize()	ioSetFullScreen()	sqAllocateMemory()In addition, ioProcessEvents() becomes a noop and main() is completelyomitted when sqMacWindow.c is compiled for use in the browser plugin VM. Thing busted 2000 July 26th squeak quit restart has issues with change file open June/July 2000 johnmci@smalltalkconsulting.com Reviewed code readded comments, added FullScreen Support				fixed issues with Carbon, general code cleaning.Sept 27th 2000 johnmci@smalltalkconsulting.com added logic to have more flexibility in memory size.				Fix issue with volume ID, don''t use 0				Fix issue were IE lies about the frame size as it figures out the frame size in real time durning rendering				Added check for file: in URL logic to disallow				Fixed problem in NPP_URLNotify, must call notify complete logic				Ensure NP_memFree is called for plugin arguments				Add logic for URLPostingFeb 8th 2001    johnmci@smalltalkconsulting.com Rewrote to use Apple multithreaded library and ported Squeak VM 3.0Feb 26th 2001   JMM, allocate from application heap if we can do it, fix issue with null event not tracking button state.Mar 23rd 2001   JMM, start interpreter when we get setwindow to fix netscape race condition**********/#include "sq.h"#include "FilePlugin.h"#include "npapi.h"#include <Events.h>#include <Files.h>#include <Gestalt.h>#include <Notification.h>#include <Strings.h>#include <MacWindows.h>#include <Movies.h>#include <Folders.h>#include <string.h>#include <ctype.h>#include <Threads.h>#if TARGET_API_MAC_CARBON    #define EnableMenuItemCarbon(m1,v1)  EnableMenuItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableMenuItem(m1,v1);#else    #define EnableMenuItemCarbon(m1,v1)  EnableItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableItem(m1,v1);        inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}          inline Rect *GetRegionBounds(RgnHandle region, Rect * bounds) { *bounds = (*region)->rgnBBox; return &(*region)->rgnBBox;}        inline RgnHandle GetPortClipRegion(CGrafPtr port,RgnHandle clipRgn) {MacCopyRgn (port->clipRgn,clipRgn); return clipRgn;}          inline BitMap *GetQDGlobalsScreenBits(BitMap *bm){*bm = qd.screenBits; return &qd.screenBits; }        inline BitMap * GetPortBitMapForCopyBits (CGrafPtr w) { return &((GrafPtr)w)->portBits;}        inline pascal long InvalWindowRect(WindowRef  window,  const Rect * bounds) {InvalRect (bounds);}#endif/********** Compilation Options:**	ENABLE_URL_FETCH*	  Define this to compile primitives to fetch URL''s via the browser.**	  Warning: Fetching file URL''s through the URL fetch mechanism allows*	  potentially untrusted code to read files outside of the Squeak*	  file system "sandbox", a serious breach of privacy. *	  There are few uses for use for the browser URL fetch*	  mechanism, since you can always fetch URL''s from remote servers*	  using Squeak''s own HTTPSocket.***********/#define ENABLE_URL_FETCH  #define IMAGE_NAME "SqueakPlugin.image"#define VMPATH_SIZE 300/*** Exported Primitives ***/#ifdef ENABLE_URL_FETCH#pragma export onint primitivePluginBrowserReady(void);int primitivePluginDestroyRequest(void);int primitivePluginRequestFileHandle(void);int primitivePluginRequestState(void);int primitivePluginRequestURL(void);int primitivePluginRequestURLStream(void);int primitivePluginPostURL(void);#pragma export off#endif/* Constants */#define MAX_STRING_LENGTH 255#define MAX_ARG_STRING_LENGTH 100#define STATUS_BAD_HANDLE -1#define STATUS_IDLE 0#define STATUS_IN_PROGRESS 1#define STATUS_FAILED 2#define STATUS_SUCCEEDED 3#define STARTINGsqueakHeapMBytes 20*1024*1024/*** Imported Variables ***/extern int interruptKeycode;extern unsigned char *memory;extern WindowPtr stWindow;extern int fullScreenFlag;extern int successFlag;extern char documentName[];  /* full path to document file */extern char imageName[];  /* full path to image file */extern char shortImageName[];  /* just the image file name */extern char vmPath[];  /* full path to interpreter''s directory */extern struct VirtualMachine *interpreterProxy;extern int thisSession;  /* from sqFilePrims.c: *//*** Local Variables ***/int			exitRequested	= false;Rect    	gSavePortPortRect;RgnHandle   gSavePortClipRgn;CGrafPtr	gOldPort		= nil;int			needsUpdate		= false;NPWindow* 	netscapeWindow	= nil;Str255		notificationMsg = "";NMRec		notifyRec;int			pluginArgCount	= 0;char		*pluginArgName[MAX_ARG_STRING_LENGTH];char		*pluginArgValue[MAX_ARG_STRING_LENGTH];Boolean     ignoreFirstEvent=false;int			squeakHeapMBytes = STARTINGsqueakHeapMBytes;  /* default heap size, override via the "memory" EMBED tag */char		squeakPluginImageName[] = IMAGE_NAME;NPP			thisInstance	= nil;WindowPtr gAFullscreenWindow = nil;char        rememberMemoryString[128]="";extern Boolean         gAllowAccessToFilePlease;#define URL_REQUEST_COUNT 100typedef struct {	int id;  /* used to associate a request with its outcome */	int status;	int semaIndex;	char fileName[MAX_STRING_LENGTH + 1];	char *buffer;} URLRequestRecord;URLRequestRecord urlRequests[URL_REQUEST_COUNT];int nextRequestID = 1;/*** Functions Imported from sqMacWindow ***/int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);void ioSetFullScreenRestore();int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID);extern int dropInit(void);/*** From VM ***/int checkImageVersionFromstartingAt(sqImageFile f, int imageOffset);int getLongFromFileswap(sqImageFile f, int swapFlag);extern int inputSemaphoreIndex;int recordMouseEvent(EventRecord *theEvent, int theButtonState);int MouseModifierState(EventRecord *theEvent);typedef int (*eventMessageHook)(EventRecord* event);extern eventMessageHook postMessageHook;int recordKeyboardEvent(EventRecord *theEvent, int keyType);extern Boolean  gThreadManager;OSErr   createNewThread();extern PixMapHandle	stPixMap;extern ThreadID  gSqueakThread;GDHandle getDominateDevice( WindowPtr theWindow,Rect *windRect);int ioInitSecurity(void);/*** Local Functions ***/int  CaseInsensitiveMatch(char *s1, char *s2);void EndDraw(void);void ExitCleanup(void);int  FindIdleURLRequest(void);int  InitFilePaths(void);void InitURLRequestTable(void);int  IsPrefixedBy(char *s, char *prefix);void OpenFileReadOnly(SQFile *f, char *fileName);void ReadSqueakImage(void);void StartDraw(void);int  StringToInteger(char *s);void URLRequestCompleted(int notifyData, const char* fileName);int  URLRequestCreate(char *url, char *target, int semaIndex);void URLRequestDestroy(int requestHandle);void URLRequestFailed(int notifyData, int reason);char * URLRequestFileName(int requestHandle);int  URLRequestStatus(int requestHandle);int parseMemorySize(int baseSize, char *src);int AbortIfFileURL(char *url);int URLPostCreate(char *url, char *buffer, char * window,int semaIndex);/*** Initialize/Shutdown ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Initialize: * Provides global initialization for a plug-in, and returns an error value.  * * This function is called once when a plug-in is loaded, before the first instance * is created. Allocate any memory or resources shared by all * instances of your plug-in at this time. After the last instance has been deleted, * NPP_Shutdown will be called, where you can release any memory or * resources allocated by NPP_Initialize.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_Initialize(void) {	exitRequested = false;	needsUpdate = false;	netscapeWindow = nil;	pluginArgCount = 0;	thisInstance = nil;	InitURLRequestTable();	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_GetJavaClass: * New in Netscape Navigator 3.0.  * * NPP_GetJavaClass is called during initialization to ask your plugin * what its associated Java class is. If you don''t have one, just return * NULL.  +++++++++++++++++++++++++++++++++++++++++++++++++*/jrefNPP_GetJavaClass(void){	return (jref) NULL;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Shutdown: * Provides global deinitialization for a plug-in.  *  * This function is called once after the last instance of your plug-in is destroyed. * Use this function to release any memory or resources shared across all * instances of your plug-in.  +++++++++++++++++++++++++++++++++++++++++++++++++*/void NPP_Shutdown(void) {	ExitCleanup();}/*** Instance Create/Destroy ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_New: * Creates a new instance of a plug-in and returns an error value.  *  * NPP_New creates a new instance of your plug-in with MIME type specified * by pluginType. The parameter mode is NP_EMBED if the instance was created * by an EMBED tag, or NP_FULL if the instance was created by a separate file. * You can allocate any instance-specific private data in instance->pdata at this * time. The NPP pointer is valid until the instance is destroyed.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_New(NPMIMEType pluginType, NPP instance, uint16 mode,  int16 argc, char* argn[], char* argv[], NPSavedData* saved) {	int i;    long threadGestaltInfo;    OSErr   err;	/* only one Squeak instance can be active at a time */	if (thisInstance !!= nil) return NPERR_GENERIC_ERROR;	for (i = 0; i < MAX_ARG_STRING_LENGTH; i++) {		pluginArgName[i] = pluginArgValue[i] = "";	}	/* record plugin arguments */	pluginArgCount = argc;	for (i = 0; (i < argc) && (i < MAX_ARG_STRING_LENGTH); i++) {		pluginArgName[i] = (char *) NPN_MemAlloc(strlen(argn[i]) + 1);		strcpy(pluginArgName[i], argn[i]);		pluginArgValue[i] = (char *) NPN_MemAlloc(strlen(argv[i]) + 1);		strcpy(pluginArgValue[i], argv[i]);		if (CaseInsensitiveMatch(pluginArgName[i], "memory")) {			strcpy(rememberMemoryString,pluginArgValue[i]);		}	}	memory = nil;	ReadSqueakImage();	if (!!memory) return NPERR_GENERIC_ERROR;	thisInstance = instance;	gSavePortClipRgn = NewRgn();		if ((Gestalt( gestaltThreadMgrAttr, &threadGestaltInfo) == noErr) &&        threadGestaltInfo & (1<<gestaltThreadMgrPresent) &&        ((Ptr) NewThread !!= (Ptr)kUnresolvedCFragSymbolAddress)) {        gThreadManager = true;        err = createNewThread();        if (err !!= noErr)              gThreadManager = false;    }		return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Destroy: * Deletes a specific instance of a plug-in and returns an error value.  * NPP_Destroy is called when a plug-in instance is deleted, typically because the * user has left the page containing the instance, closed the window, or quit the * application. You should delete any private instance-specific information stored * in instance->pdata. If the instance being deleted is the last instance created * by your plug-in, NPP_Shutdown will subsequently be called, where you can * delete any data allocated in NPP_Initialize to be shared by all your plug-in''s * instances. Note that you should not perform any graphics operations in * NPP_Destroy as the instance''s window is no longer guaranteed to be valid.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_Destroy(NPP instance, NPSavedData** save) {	long i;		ExitCleanup();	if (pluginArgCount !!= 0) {		for(i=0;i<pluginArgCount;i++) {			NPN_MemFree(pluginArgName[i]);			NPN_MemFree(pluginArgValue[i]);		}		pluginArgCount = 0;	}	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_SetWindow: * Sets the window in which a plug-in draws, and returns an error value.  *  * NPP_SetWindow informs the plug-in instance specified by instance of the * the window denoted by window in which the instance draws. This NPWindow * pointer is valid for the life of the instance, or until NPP_SetWindow is called * again with a different value. Subsequent calls to NPP_SetWindow for a given * instance typically indicate that the window has been resized. If either window * or window->window are NULL, the plug-in must not perform any additional * graphics operations on the window and should free any resources associated * with the window.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_SetWindow(NPP instance, NPWindow* window) {	NP_Port* port;	if (window == NULL) return NPERR_NO_ERROR;	if (window->window == NULL) return NPERR_NO_ERROR;		netscapeWindow = window;	port = (NP_Port *) netscapeWindow->window;	stWindow = (WindowPtr) port->port;	needsUpdate	= true;	dropInit();	if (gSqueakThread !!= kNoThreadID)	    SetThreadState (gSqueakThread,kReadyThreadState,kNoThreadID); //OK start Squeak	return NPERR_NO_ERROR;}/*** Streaming ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_NewStream: * Notifies an instance of a new data stream and returns an error value.  *  * NPP_NewStream notifies the instance denoted by instance of the creation of * a new stream specifed by stream. The NPStream* pointer is valid until the * stream is destroyed. The MIME type of the stream is provided by the * parameter type.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_NewStream(  NPP instance, NPMIMEType type,  NPStream *stream, NPBool seekable, uint16 *stype) {  /* Call to load the initial URL and to handle explicit URL fetch requests. */	*stype = NP_ASFILEONLY;  /* ask Netscape to cache file and call NPP_StreamAsFile */	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_DestroyStream: * Indicates the closure and deletion of a stream, and returns an error value.  *  * The NPP_DestroyStream function is called when the stream identified by * stream for the plug-in instance denoted by instance will be destroyed. You * should delete any private data allocated in stream->pdata at this time.  +++++++++++++++++++++++++++++++++++++++++++++++++*/NPError NPP_DestroyStream(NPP instance, NPStream *stream, NPError reason) {	return NPERR_NO_ERROR;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_StreamAsFile: * Provides a local file name for the data from a stream.  *  * NPP_StreamAsFile provides the instance with a full path to a local file, * identified by fname, for the stream specified by stream. NPP_StreamAsFile is * called as a result of the plug-in requesting mode NP_ASFILEONLY or * NP_ASFILE in a previous call to NPP_NewStream. If an error occurs while * retrieving the data or writing the file, fname may be NULL.  +++++++++++++++++++++++++++++++++++++++++++++++++*/void NPP_StreamAsFile(NPP instance, NPStream *stream, const char* fname) {	if (fname !!= null) 		URLRequestCompleted((int) stream->notifyData, fname);	 else 		URLRequestFailed((int) stream->notifyData, 1);}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_WriteReady: * Returns the maximum number of bytes that an instance is prepared to accept * from the stream.  *  * NPP_WriteReady determines the maximum number of bytes that the * instance will consume from the stream in a subsequent call NPP_Write. This * function allows Netscape to only send as much data to the instance as the * instance is capable of handling at a time, allowing more efficient use of * resources within both Netscape and the plug-in.  +++++++++++++++++++++++++++++++++++++++++++++++++*/int32 NPP_WriteReady(NPP instance, NPStream *stream) {  /* not used, because we use ASFILEONLY mode */	return 100000;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_Write: * Delivers data from a stream and returns the number of bytes written.  *  * NPP_Write is called after a call to NPP_NewStream in which the plug-in * requested a normal-mode stream, in which the data in the stream is delivered * progressively over a series of calls to NPP_WriteReady and NPP_Write. The * function delivers a buffer buf of len bytes of data from the stream identified * by stream to the instance. The parameter offset is the logical position of * buf from the beginning of the data in the stream.  *  * The function returns the number of bytes written (consumed by the instance). * A negative return value causes an error on the stream, which will * subsequently be destroyed via a call to NPP_DestroyStream.  *  * Note that a plug-in must consume at least as many bytes as it indicated in the * preceeding NPP_WriteReady call. All data consumed must be either processed * immediately or copied to memory allocated by the plug-in: the buf parameter * is not persistent.  +++++++++++++++++++++++++++++++++++++++++++++++++*/int32 NPP_Write(NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer) {  /* not used, because we use ASFILEONLY mode */	return len;}/*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_URLNotify: * Notifies the instance of the completion of a URL request.  *  * NPP_URLNotify is called when Netscape completes a NPN_GetURLNotify or * NPN_PostURLNotify request, to inform the plug-in that the request, * identified by url, has completed for the reason specified by reason. The most * common reason code is NPRES_DONE, indicating simply that the request * completed normally. Other possible reason codes are NPRES_USER_BREAK, * indicating that the request was halted due to a user action (for example, * clicking the "Stop" button), and NPRES_NETWORK_ERR, indicating that the * request could not be completed (for example, because the URL could not be * found). The complete list of reason codes is found in npapi.h.  *  * The parameter notifyData is the same plug-in-private value passed as an * argument to the corresponding NPN_GetURLNotify or NPN_PostURLNotify * call, and can be used by your plug-in to uniquely identify the request.  +++++++++++++++++++++++++++++++++++++++++++++++++*/void NPP_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData) {	if (reason !!= NPRES_DONE) 		URLRequestFailed((int) notifyData, reason);	else		URLRequestCompleted((int) notifyData, null);}/*** Printing ***/void NPP_Print(NPP instance, NPPrint* printInfo) {	/* printing is not supported */}/*** Event Handling ***//*+++++++++++++++++++++++++++++++++++++++++++++++++ * NPP_HandleEvent: * Mac-only, but stub must be present for Windows * Delivers a platform-specific event to the instance.  *  * On the Macintosh, event is a pointer to a standard Macintosh EventRecord. * All standard event types are passed to the instance as appropriate. In general, * return TRUE if you handle the event and FALSE if you ignore the event.  * Note special logic for full screen support +++++++++++++++++++++++++++++++++++++++++++++++++*/int16 NPP_HandleEvent(NPP instance, void *rawEvent) {	EventRecord *eventPtr = (EventRecord*) rawEvent;	EventRecord	theEvent;	int				ok;    Boolean windowActive=true;    static EventRecord oldEvent;    GrafPtr         rememberFrontWindow=null;    Boolean     rememberWindowOnce=true;        if (rememberWindowOnce) { //Remember who the front window is        rememberWindowOnce = false;        rememberFrontWindow = FrontWindow();    }YieldToAnyThread(); //Give some time up, needed for Netscape 	do {		    if (rememberFrontWindow == FrontWindow())			windowActive = true;		else 			windowActive = false;    	if (exitRequested) {    		exitRequested = false;    		ExitCleanup();    		return false;    	}    	if ((thisInstance == nil) || (eventPtr == NULL)) {    		/* no instance or no event; do nothing */    		return false;    	}    	switch (eventPtr->what) {    		case mouseDown:				if (!!windowActive) 				    break;				    				if(inputSemaphoreIndex) {		    		StartDraw();					recordMouseEvent(eventPtr,MouseModifierState(eventPtr));					EndDraw();					break;				}				recordMouseDown(eventPtr);    		break;			case mouseUp:				if (!!windowActive) 				    break;				if(inputSemaphoreIndex) {		    		StartDraw();					recordMouseEvent(eventPtr,MouseModifierState(eventPtr));		    		EndDraw();					break;				}				recordModifierButtons(eventPtr);			break;    		case keyDown:    		case autoKey:  				if(inputSemaphoreIndex) {					recordKeyboardEvent(eventPtr,EventKeyDown);					break;				}				recordModifierButtons(eventPtr);  			    recordKeystroke(eventPtr);    		break;			case keyUp:				if(inputSemaphoreIndex) {					recordKeyboardEvent(eventPtr,EventKeyUp);				}			break;    		case updateEvt:    			needsUpdate = true;    		break;    					case activateEvt:				if (theEvent.modifiers & activeFlag) 					windowActive = true;				else 					windowActive = false;							break;    		case nullEvent:				{    		    	EventRecord peekAtEvent;    		    	EventAvail(everyEvent,&peekAtEvent);    		            				if(inputSemaphoreIndex && windowActive &&     				    !!((oldEvent.what == eventPtr->what) &&     		 		    (oldEvent.message == eventPtr->message) &&    		 		    ((oldEvent.where.v == eventPtr->where.v) && (eventPtr->where.h == eventPtr->where.h)) &&    		 		    (oldEvent.modifiers == peekAtEvent.modifiers))) {     		    		/* Fix bug in some versions of netscape on non-usa systems, does not report modifier bits correctly*/    		    		eventPtr->modifiers = peekAtEvent.modifiers;   		    		    oldEvent = *eventPtr;     		    		StartDraw();    					if (peekAtEvent.what == nullEvent)     					    recordMouseEvent(eventPtr,MouseModifierState(&peekAtEvent));     					     					EndDraw();    		 		}    		 		else    				 oldEvent = *eventPtr;				}    		break;    		    	}    	if (needsUpdate && (netscapeWindow !!= nil) && (memory)) {    		if (fullScreenFlag) {    		    BeginUpdate((WindowPtr) eventPtr->message);     		}            fullDisplayUpdate();  /* ask VM to call ioShowDisplay */    		if (fullScreenFlag) {    		    EndUpdate((WindowPtr) eventPtr->message);   			}    		needsUpdate = false;    	}    	if (ignoreFirstEvent  &&  fullScreenFlag) {    	    ignoreFirstEvent = false;    	    return true;    	}    	if (fullScreenFlag) {     	    ok = WaitNextEvent(everyEvent, &theEvent,0,null);            eventPtr = &theEvent;    		YieldToAnyThread();    	}	} while (fullScreenFlag);	return true;}/*** Drawing ***/void EndDraw(void) {	SetOrigin(gSavePortPortRect.left, gSavePortPortRect.top);	SetClip(gSavePortClipRgn);	SetPort((GrafPtr) gOldPort);}void StartDraw(void) {	NP_Port* port;	Rect clipRect;		port = (NP_Port *) netscapeWindow->window;	/* save old graphics port and switch to ours */	GetPort((GrafPtr *) &gOldPort);	SetPort((GrafPtr) port->port);	stWindow = (WindowPtr) port->port;	/* save old drawing environment */	GetPortBounds(port->port,&gSavePortPortRect);	GetClip(gSavePortClipRgn);	/* setup our drawing environment */	SetOrigin(port->portx, port->porty);	clipRect.top    = netscapeWindow->clipRect.top    + port->porty;	clipRect.left   = netscapeWindow->clipRect.left   + port->portx;	clipRect.bottom = netscapeWindow->clipRect.bottom + port->porty;	clipRect.right  = netscapeWindow->clipRect.right  + port->portx;	if (clipRect.top == 0 && clipRect.left ==0 && clipRect.bottom==0 && clipRect.right==0) {		// Not sure what to do IE is lying... this gets the full screen, not a table cell GetPortBounds(GetWindowPort(stWindow),&clipRect);	}	ClipRect(&clipRect);	BackColor(whiteColor);  /* needed to avoid funny colors */}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;    Boolean     restorePort=false;    	if (stWindow == nil) {		return;	}	restorePort = true;	StartDraw();   /*if (((NP_Port *) netscapeWindow->window)->port !!= (struct CGrafPort *) stWindow) {        StartDraw();        restorePort = true;    }*/    	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;    if (depth<=8) { /*Duane Maxwell <dmaxwell@exobox.com> fix cmpSize Sept 18,2000 */    	(*stPixMap)->cmpSize = depth;    	(*stPixMap)->cmpCount = 1;    } else if (depth==16) {    	(*stPixMap)->cmpSize = 5;    	(*stPixMap)->cmpCount = 3;    } else if (depth==32) {    	(*stPixMap)->cmpSize = 8;    	(*stPixMap)->cmpCount = 3;    }	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPortWindowPort(stWindow);	CopyBits((BitMap *) *stPixMap, GetPortBitMapForCopyBits(GetWindowPort(stWindow)), &srcRect, &dstRect, srcCopy, maskRect);#if TARGET_API_MAC_CARBON	QDFlushPortBuffer (GetWindowPort(stWindow), maskRect);#endif	DisposeRgn(maskRect);		if (restorePort) 	    EndDraw();}/*** Image File Reading ***/void ReadSqueakImage(void) {	sqImageFile f;	char msg[500];    int swapBytes;    int dataSize;    int headerStart;    int headerSize;    int heapSize;    	plugInInit(squeakPluginImageName);	InitFilePaths();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		strcpy(msg, "Could not open Squeak image file \"");		strcat(msg, imageName);		strcat(msg, "\"");		plugInNotifyUser(msg);		return;	}		ioInitSecurity();		//Cheat and peek ahead to get the image size so we can calculate the memory required 		swapBytes = checkImageVersionFromstartingAt(f, 0);	headerStart = (sqImageFilePosition(f)) - 4;	headerSize = getLongFromFileswap(f, swapBytes);	dataSize = getLongFromFileswap(f, swapBytes);		//Close then reopen to reset file position		sqImageFileClose(f);  	f = sqImageFileOpen(imageName, "rb");	squeakHeapMBytes = parseMemorySize(dataSize, rememberMemoryString);	if (squeakHeapMBytes == 0) 	    squeakHeapMBytes = STARTINGsqueakHeapMBytes;	    	readImageFromFileHeapSizeStartingAt(f, squeakHeapMBytes, 0);	sqImageFileClose(f);	interruptKeycode = 515;  /* ctrl-C, since Netscape blocks cmd-. */	fullScreenFlag=false; //Note image can be saved with true}/*** URL Requests ***/int URLRequestCreate(char *url, char *target, int semaIndex) {  /* Start a URL request and return its index. Return -1 if there were     no idle request handles. */	int handle, notifyData;	long junk;	handle = FindIdleURLRequest();	if (handle < 0) return handle;	urlRequests[handle].id = nextRequestID++;	urlRequests[handle].status = STATUS_IN_PROGRESS;	urlRequests[handle].semaIndex = semaIndex;	urlRequests[handle].buffer = null;	/* temporarily return the grafPort to Netscape so it can display feedback: */	EndDraw();	notifyData = (urlRequests[handle].id << 8) + handle;	NPN_GetURLNotify(thisInstance, url, target, (void *) notifyData);	Delay(120, (unsigned long *) &junk);  /* workaround for a bug in Mac Netscape 4.7--						  back-to-back requests to a server sometimes fail						  when the server was heavily loaded Question is this value too long!!*/	StartDraw();	return handle;}int URLPostCreate(char *url, char *buffer, char * window,int semaIndex) {  /* Start a URL request and return its index. Return -1 if there were     no idle request handles. */	int handle, notifyData;	long junk;	NPError error;		handle = FindIdleURLRequest();	if (handle < 0) return handle;	urlRequests[handle].id = nextRequestID++;	urlRequests[handle].status = STATUS_IN_PROGRESS;	urlRequests[handle].semaIndex = semaIndex;	urlRequests[handle].buffer = buffer;	/* temporarily return the grafPort to Netscape so it can display feedback: */	EndDraw();	notifyData = (urlRequests[handle].id << 8) + handle;	error = NPN_PostURLNotify(thisInstance, url, window, strlen(buffer)+1, buffer, false, (void *) notifyData);	if (error !!= NPERR_NO_ERROR) {		StartDraw();		return -1;	}		Delay(120, (unsigned long *) &junk);  /* workaround for a bug in Mac Netscape 4.7--						  back-to-back requests to a server sometimes fail						  when the server was heavily loaded Question is this value too long!!*/	StartDraw();	if (window[0] == 0x00) {		//Bug? unsure, but if window is null, then no notification give so trigger semaphore		URLRequestCompleted(notifyData,null);	}		return handle;}void URLRequestDestroy(int requestHandle) {  /* Clear the url request with the given handle. */	if ((requestHandle < 0) || (requestHandle >= URL_REQUEST_COUNT)) {		return;	}	urlRequests[requestHandle].id = 0;	urlRequests[requestHandle].status = STATUS_IDLE;	urlRequests[requestHandle].semaIndex = 0;	urlRequests[requestHandle].fileName[0] = 0;	urlRequests[requestHandle].buffer = null;}char * URLRequestFileName(int requestHandle) {  /* Return the filename associated with the url request with the given     handle. Return null if the request status is not STATUS_SUCCEEDED. */	if ((requestHandle < 0) ||		(requestHandle >= URL_REQUEST_COUNT) ||		(urlRequests[requestHandle].status !!= STATUS_SUCCEEDED)) {			return null;	}	return urlRequests[requestHandle].fileName;}int URLRequestStatus(int requestHandle) {  /* Return the status of the url request with the given handle. */	if ((requestHandle < 0) ||		(requestHandle >= URL_REQUEST_COUNT) ||		(urlRequests[requestHandle].status < STATUS_IN_PROGRESS)) {			return STATUS_BAD_HANDLE;	}	return urlRequests[requestHandle].status;}int FindIdleURLRequest(void) {  /* Return the index of an idle request or -1 if there are none. */	int i;	for (i = 0; i < URL_REQUEST_COUNT; i++) {		if (urlRequests[i].status == STATUS_IDLE) {			return i;		}	}	return -1;}void URLRequestCompleted(int notifyData, const char* fileName) {  /* Record that the given request has completed, caching the result in     the given file name. */	int handle = notifyData & 0xFF;	if ((handle < 0) || (handle >= URL_REQUEST_COUNT)) {		return;	}	if (urlRequests[handle].id == (notifyData >> 8)) {		if (fileName !!= null) 		    strncpy(urlRequests[handle].fileName, fileName, MAX_STRING_LENGTH);		if (urlRequests[handle].buffer !!= null) {			NPN_MemFree(urlRequests[handle].buffer);			urlRequests[handle].buffer = null;		}		urlRequests[handle].status = STATUS_SUCCEEDED;		signalSemaphoreWithIndex(urlRequests[handle].semaIndex);	}}void URLRequestFailed(int notifyData, int reason) {  /* Record that the given URL request failed. */	int handle = notifyData & 0xFF;	if ((handle < 0) || (handle >= URL_REQUEST_COUNT)) {		return;	}	if (urlRequests[handle].id == (notifyData >> 8)) {		if (urlRequests[handle].buffer !!= null) {			NPN_MemFree(urlRequests[handle].buffer);			urlRequests[handle].buffer = null;		}		/* Note: For local files, we''re informed that there was a network		   error (but only after NPP_StreamAsFile has reported success).		   We could allow local files to be read through the URL request		   mechanism but NOT failing here if the status has already been		   set to success. But we don''t want to allow the URL mechanism		   to be used as a loophole to read files outside the sandbox, so		   we let this fail. */		if (urlRequests[handle].status !!= STATUS_SUCCEEDED) {			urlRequests[handle].status = STATUS_FAILED;			signalSemaphoreWithIndex(urlRequests[handle].semaIndex);		}	}}void InitURLRequestTable(void) {  /* Initialize the table of URL requests. */	int i;	for (i = 0; i < URL_REQUEST_COUNT; i++) {		URLRequestDestroy(i);	}	nextRequestID = 1;}/*** Squeak I/O Support and Memory Allocation ***/int ioExit(void) {  /* Request that we stop running plugin. */	ioSetFullScreenRestore();	exitRequested = true;}int ioScreenSize(void) {	int w = 0, h = 0;	Rect bounds;		if (netscapeWindow !!= nil) {		w = netscapeWindow->clipRect.right - netscapeWindow->clipRect.left;		h = netscapeWindow->clipRect.bottom - netscapeWindow->clipRect.top;	}	    	if (w == 0 && h == 0) { 	    GetPortBounds(GetWindowPort(stWindow),&bounds);		w = bounds.right - bounds.left;		h = bounds.bottom - bounds.top;	}		return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}/* Full Screen logic */Ptr gRestorableStateForScreen = nil;NP_Port	  gFullScreenNPPort;NPWindow  *oldNetscapeWindow,gFullScreenNPWindow;WindowPtr oldStWindow;int ioSetFullScreen(int fullScreen) {	short desiredWidth,desiredHeight;	Rect  windRect;		if (fullScreen) {	    if (fullScreenFlag) return;		desiredWidth = 0;		desiredHeight = 0;		oldNetscapeWindow = netscapeWindow;		oldStWindow = stWindow;		BeginFullScreen	(&gRestorableStateForScreen,getDominateDevice(stWindow,&windRect),								 &desiredWidth,								 &desiredHeight,								 &gAFullscreenWindow,								 nil,								 fullScreenAllowEvents);		fullScreenFlag = true;		stWindow = gAFullscreenWindow;		gFullScreenNPPort.port = (CGrafPort *) gAFullscreenWindow;		gFullScreenNPPort.portx = 0;		gFullScreenNPPort.porty = 0;		gFullScreenNPWindow.window =  &gFullScreenNPPort;		gFullScreenNPWindow.x = 0;		gFullScreenNPWindow.y = 0;		gFullScreenNPWindow.width = desiredWidth;		gFullScreenNPWindow.height = desiredHeight;		gFullScreenNPWindow.clipRect.top = 0;		gFullScreenNPWindow.clipRect.left = 0;		gFullScreenNPWindow.clipRect.bottom = desiredHeight;		gFullScreenNPWindow.clipRect.right = desiredWidth;    	    	netscapeWindow = &gFullScreenNPWindow;    	ignoreFirstEvent = true; 	} else {	    if (!!fullScreenFlag) return;		fullScreenFlag = false;        ioSetFullScreenRestore();	}}void ioSetFullScreenRestore(){	if (gRestorableStateForScreen !!= nil) {		EndFullScreen(gRestorableStateForScreen,nil);	    if (gAFullscreenWindow == nil) 		    return;	    gRestorableStateForScreen = nil;	    netscapeWindow = oldNetscapeWindow;	    stWindow = oldStWindow;	}}void * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {  /* Allocate the Squeak object heap memory from the system heap. */ char *pointer; #if TARGET_API_MAC_CARBON	return NewPtr(desiredHeapSize);#else    pointer = NewPtr(desiredHeapSize);    if (pointer == null) 	    return NewPtrSys(desiredHeapSize);	else 	    return pointer;#endif}/*** File and Access Paths ***/int InitFilePaths(void) {	short vRefNum;	char imageInPreferenceFolder[256];	long dirID;	OSErr err;	FSSpec fileSpec;		/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	strcpy(shortImageName, squeakPluginImageName);	/* get the path to the sytem folder preference area*/	err = FindFolder(kOnSystemDisk, kPreferencesFolderType, kDontCreateFolder, &vRefNum, &dirID);	if (err !!= noErr) {		strcpy(imageName,"Problems finding the System Preference folder");		return err;	}		// Look for folder, if not found abort */	strcpy(imageInPreferenceFolder,":Squeak:Internet:");	strcat(imageInPreferenceFolder,shortImageName);	CopyCStringToPascal(imageInPreferenceFolder,(unsigned char *) imageInPreferenceFolder);	err = FSMakeFSSpec(vRefNum, dirID,(unsigned char *) imageInPreferenceFolder , &fileSpec);	if (err !!= noErr) {		strcpy(imageName,"Problems finding the Internet folder in the Squeak Preference folder or the SqueakPlugin.image");		return err;	}		/* set the vmPath */	PathToWorkingDir(vmPath,VMPATH_SIZE, fileSpec.vRefNum,fileSpec.parID);	strcpy(imageName, vmPath);	strcat(imageName, shortImageName);}int IsPrefixedBy(char *s, char *prefix) {  /* Return true if the given string begins with or equals the given prefix. */	int i;	for (i = 0; prefix[i] !!= 0; i++) {		if (s[i] !!= prefix[i]) 			return false;	}	return true;}/*** Optional URL Fetch Primitives ***/#ifdef ENABLE_URL_FETCHint primitivePluginBrowserReady(void) {	/* Args: none.	   Always return true on Macintosh. */	interpreterProxy->pop(1);	interpreterProxy->pushBool(1);}int primitivePluginDestroyRequest(void) {	/* Args: handle.	   Destroy the given request. */	int handle;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	URLRequestDestroy(handle);	interpreterProxy->pop(1);}int primitivePluginRequestFileHandle(void) {	/* Args: handle.	   Return a file handle for the completed request. Fail if	   the request handle is not valid or hasn''t successfully completed. */	int handle, fileObj;	char *fileName;	SQFile *filePtr;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	fileName = URLRequestFileName(handle);	if (fileName == null) {		interpreterProxy->success(false);		return null;	}	fileObj = interpreterProxy->instantiateClassindexableSize(		interpreterProxy->classByteArray(), sizeof(SQFile));	filePtr = (SQFile *) (fileObj + 4);	/* Note: OpenFileReadOnly() allows any file on the disk to be read via a file URL.	   However, we are using it for now because we are not sure where the Netscape cache	   folder will be--it''s folder might even be user-name dependent. sqFileOpen() will	   only allow opening files within the sandbox, which would be better. Here''s the	   sandbox-safe alternative:		  sqFileOpen(filePtr, (int) fileName, strlen(fileName), false);	*/	OpenFileReadOnly(filePtr, fileName);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(2);	interpreterProxy->push(fileObj);}int primitivePluginRequestState(void) {	/* Args: handle.	   Return true if the request succeeded, false if it failed, and nil if	   it is still in progress. Fail if the request handle is not valid. */	int handle;	int status;	int resultObj;	handle = interpreterProxy->stackIntegerValue(0);	if (interpreterProxy->failed()) {		return null;	}	status = URLRequestStatus(handle);	if (status == STATUS_BAD_HANDLE) {		interpreterProxy->success(false);		return null;	}	/* default return object: (nil means "in progress") */	resultObj = interpreterProxy->nilObject();	if (status == STATUS_FAILED) {		resultObj = interpreterProxy->falseObject();	}	if (status == STATUS_SUCCEEDED) {		resultObj = interpreterProxy->trueObject();	}	interpreterProxy->pop(2);	interpreterProxy->push(resultObj);}int primitivePluginRequestURL(void) {	/* Args: url, target, semaphoreIndex.	   Start a URL request to fetch the given URL to the given target.	   (See the Netscape Plugin programmer''s manual for possible targets.)	   Return a handle that can be used to identify this request. Fail if	   there are already too many outstanding requests. */	char *urlPtr;	char *targetPtr;	int semaIndex;	int urlObj, urlSize;	int targetObj, targetSize;	char url[MAX_STRING_LENGTH + 1];	char target[MAX_STRING_LENGTH + 1];	int i;	int handle;	semaIndex = interpreterProxy->stackIntegerValue(0);	targetObj = interpreterProxy->stackObjectValue(1);	urlObj = interpreterProxy->stackObjectValue(2);	interpreterProxy->success(interpreterProxy->isBytes(targetObj));	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	targetSize = interpreterProxy->stSizeOf(targetObj);	targetPtr = interpreterProxy->firstIndexableField(targetObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	interpreterProxy->success(AbortIfFileURL(url));	if (interpreterProxy->failed()) {		return null;	}		/* copy target into a C string */	if (targetSize > MAX_STRING_LENGTH) targetSize = MAX_STRING_LENGTH;	for (i = 0; i < targetSize; i++) {		target[i] = targetPtr[i];	}	target[targetSize] = 0;	handle = URLRequestCreate(url, target, semaIndex);	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(4);	interpreterProxy->pushInteger(handle);}int primitivePluginPostURL(void) {	/* Args: url, target, semaphoreIndex.	   Start a URL request to post the given URL to the given target.	   (See the Netscape Plugin programmer''s manual for possible targets.)	   Return a handle that can be used to identify this request. Fail if	   there are already too many outstanding requests. */	char *urlPtr;	char *targetPtr;	char *bufferPtr,*buffer;	int semaIndex;	int urlObj, urlSize;	int targetObj, targetSize;	int bufferObj, bufferSize;	char url[MAX_STRING_LENGTH + 1];	char target[MAX_STRING_LENGTH + 1];	int i;	int handle;	semaIndex = interpreterProxy->stackIntegerValue(0);	bufferObj = interpreterProxy->stackObjectValue(1);	targetObj = interpreterProxy->stackObjectValue(2);	urlObj = interpreterProxy->stackObjectValue(3);		interpreterProxy->success(interpreterProxy->isBytes(targetObj));	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	interpreterProxy->success(interpreterProxy->isBytes(bufferObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	targetSize = interpreterProxy->stSizeOf(targetObj);	targetPtr = interpreterProxy->firstIndexableField(targetObj);	bufferSize = interpreterProxy->stSizeOf(bufferObj);	bufferPtr = interpreterProxy->firstIndexableField(bufferObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	interpreterProxy->success(AbortIfFileURL(url));	if (interpreterProxy->failed()) {		return null;	}		/* copy target into a C string */	if (targetSize > MAX_STRING_LENGTH) targetSize = MAX_STRING_LENGTH;	for (i = 0; i < targetSize; i++) {		target[i] = targetPtr[i];	}	target[targetSize] = 0;	/* copy over the post buffer which might be large*/		buffer = (char *) NPN_MemAlloc(bufferSize+1);	for (i = 0; i < bufferSize; i++) {		buffer[i] = bufferPtr[i];	}	buffer[bufferSize] = 0;	handle = URLPostCreate(url, buffer,target,semaIndex) ;	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(5);	interpreterProxy->pushInteger(handle);}int primitivePluginRequestURLStream(void) {	/* Args: url, semaphoreIndex.	   Start a URL request to fetch the given URL. Return a handle that	   can be used to identify this request. Fail if there are already	   too many outstanding requests. */	int urlObj, urlSize, semaIndex;	char *urlPtr;	char url[MAX_STRING_LENGTH + 1];	int handle, i;	semaIndex = interpreterProxy->stackIntegerValue(0);	urlObj = interpreterProxy->stackObjectValue(1);	interpreterProxy->success(interpreterProxy->isBytes(urlObj));	if (interpreterProxy->failed()) {		return null;	}	urlSize = interpreterProxy->stSizeOf(urlObj);	urlPtr = interpreterProxy->firstIndexableField(urlObj);	/* copy url into a C string */	if (urlSize > MAX_STRING_LENGTH) urlSize = MAX_STRING_LENGTH;	for (i = 0; i < urlSize; i++) {		url[i] = urlPtr[i];	}	url[urlSize] = 0;	interpreterProxy->success(AbortIfFileURL(url));	if (interpreterProxy->failed()) {		return null;	}	handle = URLRequestCreate(url, null, semaIndex);	interpreterProxy->success(handle >= 0);	if (interpreterProxy->failed()) {		return null;	}	interpreterProxy->pop(3);	interpreterProxy->pushInteger(handle);}void OpenFileReadOnly(SQFile *f, char *fileName) {	/* Opens the given file for reading using the supplied sqFile	   structure. This is a simplified version of sqFileOpen() that	   avoids the "sandbox" access check, since the browser''s	   cache folder is outside the Squeak sandbox. That is why	   we only allow reading of this file. Sets the primitive	   failure flag if not successful. */	f->file = fopen(fileName, "rb");	f->writable = false;	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		interpreterProxy->success(false);		return;	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}	f->lastOp = 0;}#endif/*** Other ***/int CaseInsensitiveMatch(char *s1, char *s2) {  /* Return true if the two strings are the same, not considering case. */	int len, i, c1, c2;	len = strlen(s1);	if (strlen(s2) !!= len) return false;	for (i = 0; i < len; i++) {		c1 = s1[i];		c2 = s2[i];		if ((c1 >= ''a'') && (c1 <= ''z'')) {			c1 = c1 - (''a'' - ''A'');		}		if ((c2 >= ''a'') && (c2 <= ''z'')) {			c2 = c2 - (''a'' - ''A'');		}		if (c1 !!= c2) return false;	}	return true;}int StringToInteger(char *s) {  /* Answer the integer resulting from converting the given     string, assumed to be decimal integer. */	int sign, n, i, ch;	sign = 1;	n = 0;	i = 0;	while ((ch = s[i++]) !!= 0) {		if ((ch == ''-'') && (i == 1)) {			sign = -1;		} else {			if ((ch >= ''0'') && (ch <= ''9'')) {				n = (10 * n) + (ch - ''0'');			} else {				return sign * n;			}		}	}	return sign * n;}void ExitCleanup(void) {  /* Clean up and stop running plugin. */	if (thisInstance == nil) return;	thisInstance = nil;	exitRequested = true;	while(gSqueakThread !!= kNoThreadID && YieldToThread(gSqueakThread) == noErr){};		plugInShutdown();	ioSetFullScreenRestore();	NPP_Initialize();  /* reset local variables */}/*** Interpreter Hooks ***/int plugInNotifyUser(char *msg) {  /* Notify the user that there was a problem starting Squeak. */	CopyCStringToPascal(msg,notificationMsg); /* copy message, since notification is asynchronous */	notifyRec.qType = nmType;	notifyRec.nmMark = false;			/* no mark in applications menu */	notifyRec.nmIcon = nil;				/* no menu bar icon */	notifyRec.nmSound = (Handle) -1;	/* -1 means system beep */	notifyRec.nmStr = notificationMsg;	notifyRec.nmResp = (NMUPP) -1;		/* -1 means remove notification when user confirms */	/* add to notification queue */	NMInstall(&notifyRec);}void plugInSetStartTime(void) {}int plugInTimeToReturn(void) {    if (exitRequested)        return true;    return false;}int parseMemorySize(int baseSize, char *src){	char buf[50], *tmp;	int imageSize = 0, requestedSize;	while(*src) {		switch(*src) {			case '' '': /* white spaces; ignore */			case ''"'':				src++; break;			case ''*'': /* multiple of image size */				tmp = buf; src++;				while(*src && isdigit(*src)) *(tmp++) = *(src++); /* integer part */				if(*src == ''.'') { /* fraction part */					*(tmp++) = *(src++);					while(*src && isdigit(*src)) *(tmp++) = *(src++);				}				*(tmp++) = 0;				imageSize += (int) (baseSize * atof(buf));				break;			case ''+'': /* additional space in bytes */				tmp = buf; src++;				while(*src && isdigit(*src)) *(tmp++) = *(src++);				*(tmp++) = 0;				if (imageSize == 0) 					imageSize = baseSize;				requestedSize = atoi(buf);				imageSize += (requestedSize <= 1000) ? requestedSize*1024*1024 : requestedSize;				break;			default: /* absolute size */				tmp = buf;				*(tmp++) = *(src++);				while(*src && isdigit(*src)) *(tmp++) = *(src++);				*(tmp++) = 0;				requestedSize = atoi(buf);				imageSize = (requestedSize <= 1000) ? requestedSize*1024*1024 : requestedSize;		}	}	return imageSize;}int AbortIfFileURL(char *url){   char lookFor[6];	int i=0,placement=0;		lookFor[5] = 0x00;	while (true) {		if (*url == 0x00) break;		if (*url == '' '') {			url++;		} else {		  lookFor[placement++] = *url++;		  if (placement == 5) break;		}	}	return !!CaseInsensitiveMatch(lookFor,"file:");}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 3/24/2001 21:41'!macDirectoryFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism.  Feb 2nd 2001, JMM rewrote, using more current file manager logic. 3.0.7 return correct response on findimage 3.0.10 Mimimal VM logic */#include "sq.h"#include "FilePlugin.h"/* End of adjustments for pluginized VM */#include <Files.h>#include <Strings.h>#ifndef __MPW__#include <path2fss.h>#else#include <Aliases.h>#include <StandardFile.h>#include <Gestalt.h>#endif#include <Navigation.h>/***	The interface to the directory primitive is path based.	That is, the client supplies a Squeak string describing	the path to the directory on every call. To avoid traversing	this path on every call, a cache is maintained of the last	path seen, along with the Mac volume and folder reference	numbers corresponding to that path.***//*** Constants ***/#define ENTRY_FOUND     0#define NO_MORE_ENTRIES 1#define BAD_PATH        2#define DELIMITOR '':''#define MAX_PATH 2000/*** Variables ***/char lastPath[MAX_PATH + 1];int  lastPathValid = false;FSSpec lastSpec;/*** Functions ***/int convertToSqueakTime(int macTime);int equalsLastPath(char *pathString, int pathStringLength);int lookupPath(char *pathString, int pathStringLength, FSSpec *spec,Boolean noDrillDown);int recordPath(char *pathString, int pathStringLength, FSSpec *spec);void makePascalStringFromSqName(char *pathString, int pathStringLength,unsigned char *name);OSErr makeFSSpec(char *pathString, int pathStringLength,FSSpec *spec);OSErr getSpecAndFInfo(char *filename, int filenameSize,FSSpec *spec,FInfo *finderInfo);int fetchFileInfo(CInfoPBRec *pb,int dirIndex,FSSpec *spec,unsigned char *name, Boolean doAlias, Boolean *isFolder);int doItTheHardWay(unsigned char *pathString,FSSpec *spec,CInfoPBRec *pb,Boolean noDrillDown);pascal	OSErr	FSMakeFSSpecCompat(short vRefNum,								   long dirID,								   ConstStr255Param fileName,								   FSSpec *spec);OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec);									 pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath);pascal	OSErr	FSpGetFullPath(const FSSpec *spec,							   short *fullPathLength,							   Handle *fullPath);							   OSErr squeakFindImage(const FSSpecPtr defaultLocationfssPtr,FSSpecPtr documentfsSpec);pascal void findImageEventProc(NavEventCallbackMessage callBackSelector,                         NavCBRecPtr callBackParms,                         NavCallBackUserData callBackUD);pascal Boolean findImageFilterProc(AEDesc* theItem, void* info,                             NavCallBackUserData callBackUD,                            NavFilterModes filterMode);                        						pascal short DialogHook(short item, DialogPtr theDialog, 	void *userData);	OSErr __path2fss(const char * pathName, FSSpecPtr spec){    return lookupPath((char *) pathName, strlen(pathName),spec,true);}									 								 int convertToSqueakTime(int macTime) {	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */	return macTime + (3 * 365 * 24 * 60 * 60);}void makePascalStringFromSqName(char *pathString, int pathStringLength,unsigned char *name){	/* copy file name into a Pascal string */		name[0] = pathStringLength;	strncpy((char *)name+1,pathString,pathStringLength);} OSErr makeFSSpec(char *pathString, int pathStringLength,FSSpec *spec){		char name[256];		if (pathStringLength > 255 ) 	    return -1;       strncpy((char *) name,pathString,pathStringLength);    name[pathStringLength] = 0x00;    return __path2fss((char *) name, spec);}int dir_Create(char *pathString, int pathStringLength) {	/* Create a new directory with the given path. By default, this	   directory is created in the current directory. Use	   a full path name such as "MyDisk:Working:New Folder" to	   create folders elsewhere. */    //JMM tests create file in Vm directory, other place, other volume        FSSpec spec;    OSErr  err;    long  createdDirID;        if ((err = makeFSSpec(pathString, pathStringLength,&spec)) == -1)        return false;           	return FSpDirCreate(&spec,smSystemScript,&createdDirID) == noErr;}int dir_Delete(char *pathString, int pathStringLength) {	/* Delete the existing directory with the given path. */    FSSpec spec;    OSErr  err;    if ((err = makeFSSpec(pathString, pathStringLength,&spec)) == -1)        return false;           	return FSpDelete(&spec) == noErr;}int dir_Delimitor(void) {	return DELIMITOR;}int dir_Lookup(char *pathString, int pathStringLength, int index,  /* outputs: */  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile) {	/* Lookup the index-th entry of the directory with the given path, starting	   at the root of the file system. Set the name, name length, creation date,	   creation time, directory flag, and file size (if the entry is a file).	   Return:	0 	if a entry is found at the given index	   			1	if the directory has fewer than index entries	   			2	if the given path has bad syntax or does not reach a directory	*/	int okay;	HVolumeParam volumeParams;	CInfoPBRec dirParams;    FSSpec      spec;    Boolean     isFolder;    OSErr       err;    	/* default return values */	*name             = 0;	*nameLength       = 0;	*creationDate     = 0;	*modificationDate = 0;	*isDirectory      = false;	*sizeIfFile       = 0;	if ((pathStringLength == 0)) {		/* get volume info */		volumeParams.ioNamePtr = (unsigned char *) name;		volumeParams.ioVRefNum = 0;		volumeParams.ioVolIndex = index;		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);			*isDirectory      = true;			*sizeIfFile       = 0;			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	} else {		/* get file or directory info */		if (!!equalsLastPath(pathString, pathStringLength)) {			/* lookup and cache the refNum for this path */			err = lookupPath(pathString, pathStringLength, &spec,false);			if (err == noErr) 				recordPath(pathString, pathStringLength, &spec);			else 				return BAD_PATH;		}	    spec = lastSpec;		okay = fetchFileInfo(&dirParams,index,&spec,(unsigned char *) name,true,&isFolder);		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);			if (((dirParams.hFileInfo.ioFlAttrib & kioFlAttribDirMask) !!= 0) || isFolder) {				*isDirectory  = true;				*sizeIfFile   = 0;			} else {				*isDirectory  = false;				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;			}			return ENTRY_FOUND;		} else			return NO_MORE_ENTRIES;	}}OSErr getSpecAndFInfo(char *filename, int filenameSize,FSSpec *spec,FInfo *finderInfo) {    OSErr err;        if ((err = makeFSSpec(filename, filenameSize,spec)) !!= noErr)        return err;            if ((err= FSpGetFInfo(spec,finderInfo)) !!= noErr)         return err;            return noErr;}dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Set the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */    FSSpec spec;    FInfo   finderInfo;        if (getSpecAndFInfo(filename,filenameSize,&spec,&finderInfo) !!= noErr)        return false;       	finderInfo.fdType = *((int *) fType);	finderInfo.fdCreator = *((int *) fCreator);	    return FSpSetFInfo(&spec,&finderInfo) == noErr;}dir_GetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Get the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */    FSSpec spec;    FInfo   finderInfo;        if (getSpecAndFInfo(filename,filenameSize,&spec,&finderInfo) !!= noErr)        return false;       	*((int *) fType) = finderInfo.fdType;	*((int *) fCreator) = finderInfo.fdCreator;	return true;}int equalsLastPath(char *pathString, int pathStringLength) {	/* Return true if the lastPath cache is valid and the	   given Squeak string equals it. */	int i, ch;	if (!!lastPathValid ||		(pathStringLength > MAX_PATH)) {			return false;	}	for (i = 0; i < pathStringLength; i++) {		ch = lastPath[i];		if ((ch == 0) || (ch !!= pathString[i])) return false;	}	return lastPath[i] == 0;}/*JMM 2001/02/02 rewrote */int lookupPath(char *pathString, int pathStringLength, FSSpec *spec,Boolean noDrillDown) {	/* Resolve the given path and return the resulting folder or volume	   reference number in *refNumPtr. Return error if the path is bad. */	CInfoPBRec      pb;	Str255          tempName; 	OSErr		    err;    Boolean         ignore;     /* First locate by farily normal methods, with perhaps an alias lookup */    strncpy((char*)tempName,pathString,pathStringLength);    tempName[0] = pathStringLength;    err = FSMakeFSSpecCompat(0,0,tempName,spec);    if (err == noErr) {        if (noDrillDown == false) {            fetchFileInfo(&pb,0,spec,spec->name,true,&ignore);        }        return noErr;    }                      /* Than failed, we might have an alias chain, or other issue so     first setup for directory or file then do it the hard way */        strncpy((char *)tempName,pathString,pathStringLength);    if (noDrillDown) {        tempName[pathStringLength] = 0x00;    }    else {        tempName[pathStringLength] = '':'';        tempName[pathStringLength+1] = 0x00;    }    err = doItTheHardWay(tempName,spec,&pb,noDrillDown);    return err;}/* This method is used to lookup paths, chunk by chunk. It builds specs for each chuck and fetchs the file information, Note the special case when noDrilldown */int doItTheHardWay(unsigned char *pathString,FSSpec *spec,CInfoPBRec *pb,Boolean noDrillDown) {    char *token;    Str255 lookup;    Boolean ignore,firstTime=true;    OSErr   err;        token = strtok((char*) pathString,":");    if (token == 0) return -1;    while (token)     {        if (firstTime) {            strncpy((char*) lookup+1,(char*) token,63);            lookup[0] = strlen(token)+1;            lookup[lookup[0]] = '':'';            firstTime = false;        } else {            strncpy((char*) lookup+2,(char*) token,63);            lookup[0] = strlen(token)+1;            lookup[1] = '':'';        }        if ((err = FSMakeFSSpecCompat(spec->vRefNum,spec->parID, lookup, spec)) !!= noErr)             return err;                fetchFileInfo(pb,0,spec,spec->name,true,&ignore);        token = strtok(NULL,":");     }   if (noDrillDown)        spec->parID = pb->dirInfo.ioDrParID;     return noErr;}/*Get the file ID that unique IDs this file or directory, also resolve any alias if required */int fetchFileInfo(CInfoPBRec *pb,int dirIndex,FSSpec *spec,unsigned char *name,Boolean doAlias,Boolean *isFolder) {    int i;    long    aliasGestaltInfo;         *isFolder = false;    pb->hFileInfo.ioNamePtr = name;	pb->hFileInfo.ioFVersNum = 0;	pb->hFileInfo.ioFDirIndex = dirIndex;	pb->hFileInfo.ioVRefNum = spec->vRefNum;	pb->hFileInfo.ioDirID = spec->parID;	if (PBGetCatInfoSync(pb) == noErr) {		if ((pb->hFileInfo.ioFlFndrInfo.fdFlags & kIsAlias) && doAlias) {		    FSSpec spec2;		    Boolean isAlias;		    OSErr   err;		    		   		   err = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, name,&spec2);#if TARGET_CPU_PPC           if ((Gestalt(gestaltAliasMgrAttr, &aliasGestaltInfo) == noErr) &&                aliasGestaltInfo & (1<<gestaltAliasMgrResolveAliasFileWithMountOptions)  &&                ((Ptr) ResolveAliasFileWithMountFlags !!= (Ptr)kUnresolvedCFragSymbolAddress)) {                err = ResolveAliasFileWithMountFlags(&spec2,false,isFolder,&isAlias,kResolveAliasFileNoUI);            }             else #endif    			err = ResolveAliasFile(&spec2,false,isFolder,&isAlias);    		    			            if (err == noErr) {            	if (dirIndex == 0) {            	    fetchFileInfo(pb,dirIndex,&spec2,spec2.name,false,isFolder);            	    *spec = spec2;            	}        		return true;			}		}        spec->parID = pb->hFileInfo.ioDirID;		return true;	}	return false;}int recordPath(char *pathString, int pathStringLength, FSSpec *spec) {	/* Copy the given Squeak string into the lastPath cache. */	if (pathStringLength > MAX_PATH) {		lastPath[0] = 0; /* set to empty string */		lastPathValid = false;		lastSpec = *spec;		return;	}	strncpy(lastPath,pathString,pathStringLength);	lastPath[pathStringLength] = 0; /* string terminator */	lastPathValid = true;	lastSpec = *spec;}pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath){	OSErr		result;	FSSpec		spec;		*fullPathLength = 0;	*fullPath = NULL;		result = FSMakeFSSpecCompat(vRefNum, dirID, name, &spec);	if ( (result == noErr) || (result == fnfErr) )	{		result = FSpGetFullPath(&spec, fullPathLength, fullPath);	}		return ( result );}pascal	OSErr	FSpGetFullPath(const FSSpec *spec,							   short *fullPathLength,							   Handle *fullPath){	OSErr		result;	OSErr		realResult;	FSSpec		tempSpec;	CInfoPBRec	pb;		*fullPathLength = 0;	*fullPath = NULL;			/* Default to noErr */	realResult = result = noErr;	#if 0//The following code doesn''t seem to work in OS X, the BlockMoveData crashes the// machine, the the FSMakeFSSpecCompat works, so go figure...  KG 4/1/01	/* work around Nav Services "bug" (it returns invalid FSSpecs with empty names) */	if ( spec->name[0] == 0 )	{		result = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, spec->name, &tempSpec);	}	else	{		/* Make a copy of the input FSSpec that can be modified */		BlockMoveData(spec, &tempSpec, sizeof(FSSpec));	}#endif 0	result = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, spec->name, &tempSpec);	if ( result == noErr )	{		if ( tempSpec.parID == fsRtParID )		{			/* The object is a volume */						/* Add a colon to make it a full pathname */			++tempSpec.name[0];			tempSpec.name[tempSpec.name[0]] = '':'';						/* We''re done */			result = PtrToHand(&tempSpec.name[1], fullPath, tempSpec.name[0]);			*fullPathLength = tempSpec.name[0];		}		else		{			/* The object isn''t a volume */						/* Is the object a file or a directory? */			pb.dirInfo.ioNamePtr = tempSpec.name;			pb.dirInfo.ioVRefNum = tempSpec.vRefNum;			pb.dirInfo.ioDrDirID = tempSpec.parID;			pb.dirInfo.ioFDirIndex = 0;			result = PBGetCatInfoSync(&pb);			// Allow file/directory name at end of path to not exist.			realResult = result;			if ( (result == noErr) || (result == fnfErr) )			{				/* if the object is a directory, append a colon so full pathname ends with colon */				if ( (result == noErr) && (pb.hFileInfo.ioFlAttrib & kioFlAttribDirMask) !!= 0 )				{					++tempSpec.name[0];					tempSpec.name[tempSpec.name[0]] = '':'';				}								/* Put the object name in first */				result = PtrToHand(&tempSpec.name[1], fullPath, tempSpec.name[0]);				*fullPathLength = tempSpec.name[0];				if ( result == noErr )				{					/* Get the ancestor directory names */					pb.dirInfo.ioNamePtr = tempSpec.name;					pb.dirInfo.ioVRefNum = tempSpec.vRefNum;					pb.dirInfo.ioDrParID = tempSpec.parID;					do	/* loop until we have an error or find the root directory */					{						pb.dirInfo.ioFDirIndex = -1;						pb.dirInfo.ioDrDirID = pb.dirInfo.ioDrParID;						result = PBGetCatInfoSync(&pb);						if ( result == noErr )						{							/* Append colon to directory name */							++tempSpec.name[0];							tempSpec.name[tempSpec.name[0]] = '':'';														/* Add directory name to beginning of fullPath */							(void) Munger(*fullPath, 0, NULL, 0, &tempSpec.name[1], tempSpec.name[0]);							*fullPathLength += tempSpec.name[0];							result = MemError();						}					} while ( (result == noErr) && (pb.dirInfo.ioDrDirID !!= fsRtDirID) );				}			}		}	}		if ( result == noErr )	{		/* Return the length *////		*fullPathLength = GetHandleSize(*fullPath);		result = realResult;	// return realResult in case it was fnfErr	}	else	{		/* Dispose of the handle and return NULL and zero length */		if ( *fullPath !!= NULL )		{			DisposeHandle(*fullPath);		}		*fullPath = NULL;		*fullPathLength = 0;	}		return ( result );}pascal	OSErr	FSMakeFSSpecCompat(short vRefNum,								   long dirID,								   ConstStr255Param fileName,								   FSSpec *spec){	OSErr	result;		/* Let the file system create the FSSpec if it can since it does the job */	/* much more efficiently than I can. */	result = FSMakeFSSpec(vRefNum, dirID, fileName, spec);	/* Fix a bug in Macintosh PC Exchange''s MakeFSSpec code where 0 is */	/* returned in the parID field when making an FSSpec to the volume''s */	/* root directory by passing a full pathname in MakeFSSpec''s */	/* fileName parameter. Fixed in Mac OS 8.1 */	if ( (result == noErr) && (spec->parID == 0) )		spec->parID = fsRtParID;	return ( result );}OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec){	AliasHandle	alias;	OSErr		result;	Boolean		wasChanged;	Str32		nullString;		/* Create a minimal alias from the full pathname */	nullString[0] = 0;	/* null string to indicate no zone or server name */	result = NewAliasMinimalFromFullPath(fullPathLength, fullPath, nullString, nullString, &alias);	if ( result == noErr )	{		/* Let the Alias Manager resolve the alias. */		result = ResolveAlias(NULL, alias, spec, &wasChanged);				/* work around Alias Mgr sloppy volume matching bug */		if ( spec->vRefNum == 0 )		{			/* invalidate wrong FSSpec */			spec->parID = 0;			spec->name[0] =  0;			result = nsvErr;		}		DisposeHandle((Handle)alias);	/* Free up memory used */	}	return ( result );}typedef struct {	StandardFileReply *theSFR;	FSSpec *itemSpec;} HookRecord, *HookRecordPtr;OSErr squeakFindImage(const FSSpecPtr defaultLocationfssPtr,FSSpecPtr documentFSSpec){    NavDialogOptions    dialogOptions;    AEDesc              defaultLocation;    NavEventUPP         eventProc = NewNavEventUPP(findImageEventProc);    NavObjectFilterUPP  filterProc =  NewNavObjectFilterUPP(findImageFilterProc);    OSErr               anErr = noErr;    #if !!TARGET_API_MAC_CARBON #if   MINIMALVM  if (true) {#else  if ((Ptr) NavGetDefaultDialogOptions==(Ptr)kUnresolvedCFragSymbolAddress ) {#endif      	//System pre 8.5 or system 7.x    	// point my hook data record at the reply record and at		// the file spec for the system file		     	StandardFileReply mySFR;    	HookRecord hookRec;	    DlgHookYDUPP	myDlgHookUPP;    	SFTypeList mySFTypeList;	    Point dialogPt;	    		hookRec.itemSpec = defaultLocationfssPtr;		hookRec.theSFR = &mySFR;		SetPt(&dialogPt, -1, -1);		// Set up the universal proc pointer to your hook routine with this 		// macro defined in StandardFile.h.  **NOTE** This is different		// from the macro used for System 6 dialog hooks, and you should get		// a compiler error if you try to use the wrong UPP with the wrong call.		myDlgHookUPP = NewDlgHookYDProc(DialogHook);				// call Std File		CustomGetFile(nil, -1, mySFTypeList, &mySFR, 0, dialogPt, myDlgHookUPP,			nil, nil, nil, &hookRec);					// Dispose of the routine descriptor, since they do allocate memory..		DisposeRoutineDescriptor(myDlgHookUPP);		*documentFSSpec = mySFR.sfFile; 		return !!mySFR.sfGood;	}#endif#if !!MINIMALVM    //  Specify default options for dialog box    anErr = NavGetDefaultDialogOptions(&dialogOptions);    if (anErr == noErr)    {        //  Adjust the options to fit our needs        //  Set default location option        dialogOptions.dialogOptionFlags |= kNavSelectDefaultLocation;        dialogOptions.dialogOptionFlags |= kNavNoTypePopup;        //  Clear preview option        dialogOptions.dialogOptionFlags ^= kNavAllowPreviews;                // make descriptor for default location        anErr = AECreateDesc(typeFSS, defaultLocationfssPtr,                             sizeof(*defaultLocationfssPtr),                             &defaultLocation );        if (anErr == noErr)        {            // Get ''open'' resource. A nil handle being returned is OK,            // this simply means no automatic file filtering.            NavTypeListHandle typeList = (NavTypeListHandle)GetResource(                                        ''open'', 128);            NavReplyRecord reply;                        // Call NavGetFile() with specified options and            // declare our app-defined functions and type list            anErr = NavGetFile (&defaultLocation, &reply, &dialogOptions,                                eventProc, nil, filterProc,                                typeList, nil);            if (anErr == noErr && reply.validRecord)            {                //  Deal with multiple file selection                long    count;                                anErr = AECountItems(&(reply.selection), &count);                // Set up index for file list                if (anErr == noErr)                {                    long index;                                        for (index = 1; index <= 1; index++)                    {                        AEKeyword   theKeyword;                        DescType    actualType;                        Size        actualSize;                                                // Get a pointer to selected file                        anErr = AEGetNthPtr(&(reply.selection), index,                                            typeFSS, &theKeyword,                                            &actualType,documentFSSpec,                                            sizeof(FSSpec),                                            &actualSize);                     }                }                //  Dispose of NavReplyRecord, resources, descriptors                anErr = NavDisposeReply(&reply);            }            if (typeList !!= NULL)            {                ReleaseResource( (Handle)typeList);            }            (void) AEDisposeDesc(&defaultLocation);        }    }    DisposeNavEventUPP(eventProc);    DisposeNavObjectFilterUPP(filterProc);    return anErr;#endif}pascal void findImageEventProc(NavEventCallbackMessage callBackSelector,                         NavCBRecPtr callBackParms,                         NavCallBackUserData callBackUD){   // WindowPtr window =    //                 (WindowPtr)callBackParms->eventData.event->message;    switch (callBackSelector)    {        case kNavCBEvent:            switch (((callBackParms->eventData)                    .eventDataParms).event->what)            {                case updateEvt:                   // MyHandleUpdateEvent(window,                     //    (EventRecord*)callBackParms->eventData.event);                    break;            }            break;    }}pascal Boolean findImageFilterProc(AEDesc* theItem, void* info,                             NavCallBackUserData callBackUD,                            NavFilterModes filterMode){    OSErr theErr = noErr;    Boolean display = true;    NavFileOrFolderInfo* theInfo = (NavFileOrFolderInfo*)info;        if (theItem->descriptorType == typeFSS)        if (!!theInfo->isFolder)            if (theInfo->fileAndFolder.fileInfo.finderInfo.fdType                 !!= ''STim'')                display = false;    return display;}#if !!TARGET_API_MAC_CARBON// this dialog hook for System 7 std file selects// the file specified by the hookRecord supplied as userDatapascal short DialogHook(short item, DialogPtr theDialog, 	void *userData){	HookRecordPtr hookRecPtr;		hookRecPtr = (HookRecordPtr) userData;		// hookRecPtr->itemSpec points to the FSSpec of the item to be selected	// hookRecPtr->theSFR points to the standard file reply record	// make sure we''re dealing with the proper dialog	if (GetWRefCon(theDialog) == sfMainDialogRefCon) {			// just when opening the dialog...		if (item == sfHookFirstCall) {				// make the reply record hold the spec of the specified item			hookRecPtr->theSFR->sfFile = *hookRecPtr->itemSpec;						// Theres a gotcha in Standard File when using sfHookChangeSelection. 			// Even though New Inside Macintosh: Files has a sample that doesn''t set			// the sfScript field, it should be set, or the last object in the			// selected directory  will always be selected.			hookRecPtr->theSFR->sfScript = smSystemScript;			// tell std file to change the selection to that item			item = sfHookChangeSelection;		}	}						return item;}#endif#ifndef __MPW__#include <ansi_files.h>#include <buffer_io.h>int fflush(FILE * file){	fpos_t	position;                    /* mm 970708 */	ParamBlockRec pb;    OSErr error;		if (!!file)		return(__flush_all());		if (file->state.error || file->mode.file_kind == __closed_file)		return(EOF);		if (file->mode.io_mode == __read)		/* mm 980430 */		return 0;							/* mm 980430 */		if (file->state.io_state >= __rereading)		file->state.io_state = __reading;		if (file->state.io_state == __reading)		file->buffer_len = 0;		if (file->state.io_state !!= __writing)	{		file->state.io_state = __neutral;  /* mm 970905 */		return(0);	}	#ifndef _No_Disk_File_OS_Support	if (file->mode.file_kind !!= __disk_file || (position = ftell(file)) < 0)		position = 0;#else	position = 0;#endif		if (__flush_buffer(file, NULL))	{		set_error(file);		return(EOF);	}		file->state.io_state = __neutral;	file->position       = position;	file->buffer_len     = 0;		pb.ioParam.ioRefNum = file->handle;    error = PBFlushFileSync(&pb); 	return(0);}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 3/24/2001 21:45'!macWindowFile	^ '#include "sq.h"#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#ifndef __MPW__#include <profiler.h>#endif#include <sound.h>#include <Math64.h>#ifndef __MPW__#include <cstddef>#endif#include <processes.h>#include <OpenTransport.h>#include <Threads.h>#include <DriverServices.h>#include <stddef.h>/*** Compilation Options:**	define PLUGIN		to compile code for Netscape or IE Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE//#define IHAVENOHEAD#define MINIMALVM 0//Aug 7th 2000,JMM Added logic for interrupt driven dispatching//Sept 1st 2000, JMM fix problem with modifier information being passed back incorrectly.//Sept 1st 2000, JMM use floating point for time versus 64bit math (faster!!)//Sept 1st 2000, JMM watch mouse movement foreground only, ignore when squeak in background.//Sept 18th 2000, JMM fix to cmpSize //Sept 19th 2000, JMM Sept 1st fix to keyboard modifier info broke cmd shift//Sept 27 2000, JMM fix to documentPath//Nov 13 2000, JMM logic to read/write image from VM. //Nov 22 2000, JMM Bob Arning found a bug with the duplicate mouse event logic (we were altering the event then recording the altered value)//Nov 30 2000, JMM Use Open Transport clock versus upTime, solves some issues for jitter and it''s faster//Dec 5th 2000, JMM poll 60 times a second... do event polling via checkForInterrupts and drive semaphore//Dec 6th 2000, JMM added logic to interface with power manger (1997 was there but dropped..., back again for ibooks)//Jan 14th 2001, KG Did some carbon porting.//Feb 2nd 2001, JMM V3.0 added zoom window support, full path support//Feb 2nd 2001, JMM V3.04 do an open window dialog at startup time if no image file//Feb 14th 2001, JMM V3.06 don''t cache image read/writes//Feb 17th 2001, JMM V3.07 fix OS bug in 7.5.5 on activate event//Feb 22nd 2001, JMM v3.08 no caps lock//Mar 9th  2001, JMM v3.10 broken full screen update redaw on cmd-tab via ignoring activate events 3.0.7.//Mar 15th 2001, JMM v3.10 added minimal vm logic, fix mouse down reporting.//Mar 23rd 2001, JMM v3.10 start interpreter suspended for plugin to fix race at startup with netscape 4.x#if TARGET_API_MAC_CARBON    #define EnableMenuItemCarbon(m1,v1)  EnableMenuItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableMenuItem(m1,v1);#else    #ifndef NewAEEventHandlerUPP    	#define NewAEEventHandlerUPP NewAEEventHandlerProc     #endif    #define EnableMenuItemCarbon(m1,v1)  EnableItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableItem(m1,v1);        inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}          inline Rect *GetRegionBounds(RgnHandle region, Rect * bounds) { *bounds = (*region)->rgnBBox; return &(*region)->rgnBBox;}        inline BitMap *GetQDGlobalsScreenBits(BitMap *bm){*bm = qd.screenBits; return &qd.screenBits; }        inline BitMap * GetPortBitMapForCopyBits (CGrafPtr w) { return &((GrafPtr)w)->portBits;}        inline pascal long InvalWindowRect(WindowRef  window,  const Rect * bounds) {InvalRect (bounds);}#endif#if MINIMALVMpascal short YieldToAnyThread(void) {}#endif/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/* The following prototype is missing from the CW11 header files: */pascal void ExitToShell(void);/*** Variables -- Imported from Browser Plugin Module ***/#ifdef PLUGINextern int pluginArgCount;extern char *pluginArgName[100];extern char *pluginArgValue[100];#endif/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image file */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document file */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;OTTimeStamp     timeStart;Boolean         gTapPowerManager=false;Boolean         gDisablePowerManager=false;const long      gDisableIdleTickCount=60*10;long            gDisableIdleTickLimit=0;Boolean         gThreadManager=false;ThreadID        gSqueakThread = kNoThreadID;ThreadEntryUPP  gSqueakThreadUPP;Boolean         gAllowAccessToFilePlease=false;#ifdef __MPW__QDGlobals 		qd;#endif/*** Variables -- Event Recording ***/#if MINIMALVM#define MAX_EVENT_BUFFER 128#else#define MAX_EVENT_BUFFER 1024#endifint inputSemaphoreIndex = 0;/* if non-zero the event semaphore index */sqInputEvent eventBuffer[MAX_EVENT_BUFFER];int eventBufferGet = 0;int eventBufferPut = 0;/* declaration of the event message hook */typedef int (*eventMessageHook)(EventRecord* event);eventMessageHook messageHook = NULL;eventMessageHook postMessageHook = NULL;#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */int cachedButtonState = 0;	/* buffered mouse button and modifier state for							   last mouse click even if button has since gone up;							   this cache is kept until the next time ioGetButtonState()							   is called to avoid missing short clicks */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).  This was true for squeak upto 3.0.7. Then in 3.0.8 we    decided to not map the cap lock key to shift   		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {//	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13, caps lock//	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15    0,  8, 1,  9, 0,  8, 1,  9, 4, 12, 5, 13, 4, 12, 5, 13, //no caps lock    2, 10, 3, 11, 2, 10, 3, 11, 6, 14, 7, 15, 6, 14, 7, 15	 };/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent,EventRecord *oldEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath);void MenuBarHide(void);void MenuBarRestore(void);int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID);int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short VolumeNumber,long directoryID);void SqueakTerminate();void ExitCleanup();int calculateStartLocationForImage();extern int dropInit(void);Boolean RunningOnCarbonX(void);void DoZoomWindow (EventRecord* theEvent, WindowPtr theWindow, short zoomDir, short hMax, short vMax);GDHandle getDominateDevice(WindowPtr theWindow,Rect *windRect);void getDominateGDeviceRect(GDHandle dominantGDevice,Rect *dGDRect,Boolean forgetMenuBar);int fetchFileInfo(CInfoPBRec *pb,int dirIndex,FSSpec *spec,unsigned char *name,Boolean doAlias,Boolean *isFolder);OSStatus GetApplicationDirectory(short *vRefNum, long *dirID);extern pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath);OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec);OSErr squeakFindImage(const FSSpecPtr defaultLocationfssPtr,FSSpecPtr documentFSSpec);int ioInitSecurity(void);/* event capture */sqInputEvent *nextEventPut(void);int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);int recordMouseEvent(EventRecord *theEvent, int theButtonState);int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType);int recordKeyboardEvent(EventRecord *theEvent, int keyType);int MouseModifierState(EventRecord *theEvent);WindowPtr getSTWindow(void);int setMessageHook(eventMessageHook theHook);int setPostMessageHook(eventMessageHook theHook);void PowerMgrCheck(void);static pascal void* squeakThread(void *threadParm);OSErr   createNewThread(); /*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);static pascal OSErr HandleOpenDocEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);static pascal OSErr HandlePrintDocEvent(const AEDescList *aevt, AEDescList *reply, long refCon);static pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerUPP(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerUPP(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerUPP(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */    int                 checkValueForEmbeddedImage;    OSErr               err;	Str32                name; 	/* record path to VM''s home folder */	short vRefNum;	long dirID;	// Get the Volume ref and Directory id of the Application''s directory.    err = GetApplicationDirectory(&vRefNum, &dirID);    if (err !!= noErr) return err;	// Convert that to a full path string.	PathToWorkingDir(vmPath, VMPATH_SIZE, vRefNum, dirID);	checkValueForEmbeddedImage = calculateStartLocationForImage();	if (checkValueForEmbeddedImage == 0) {	    /* use default image name in same directory as the VM */	    strcpy(shortImageName, "squeak.image");	    return noErr;	}	if (err !!= noErr) {		strcpy(shortImageName, "squeak.image");	    return noErr;	}		CopyPascalStringToC(name,shortImageName);	StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);    return noErr;}pascal OSErr HandleOpenDocEvent(const AEDescList *aevt, AEDescList *reply, long refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	FInfo		finderInformation;	char 		tempShortName[SHORTIMAGE_NAME_SIZE + 1];		short vRefNum;	long dirID;		reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */    err = GetApplicationDirectory(&vRefNum, &dirID);    if (err !!= noErr) return err;    	PathToWorkingDir(vmPath, VMPATH_SIZE, vRefNum, dirID);		/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) return errAEEventNotHandled;;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;		if (shortImageName[0] !!= 0) {#ifdef IHAVENOHEAD		/* get image name */		err = AEGetNthPtr(&fileList, 1, typeFSS,						  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);		if (err) goto done;				err = FSpGetFInfo(&fileSpec,&finderInformation);		if (err) goto done;					CopyPascalStringToC(fileSpec.name,tempShortName);		if (finderInformation.fdType == ''SOBJ'') {			StoreFullPathForLocalNameInto(tempShortName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		}#endif		goto done;	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;		err = FSpGetFInfo(&fileSpec,&finderInformation);	if (err) goto done;			CopyPascalStringToC(fileSpec.name,shortImageName);	if (!!(IsImageName(shortImageName) || finderInformation.fdType == ''STim'') || finderInformation.fdType == ''STch'') {		/* record the document name, but run the default image in VM directory */		if (finderInformation.fdType == ''SOBJ'')			StoreFullPathForLocalNameInto(shortImageName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);	} else {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return noErr;  //Note under Carbon it sends us a Quit event, but we don''t process because image might not get saved?}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowRef		wp;	int				isDeskAccessory;	wp = FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = GetWindowKind(wp) < 0;	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableMenuItemCarbon(editMenu, 1);		EnableMenuItemCarbon(editMenu, 3);		EnableMenuItemCarbon(editMenu, 4);		EnableMenuItemCarbon(editMenu, 5);		EnableMenuItemCarbon(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableMenuItemCarbon(editMenu, 1);		DisableMenuItemCarbon(editMenu, 3);		DisableMenuItemCarbon(editMenu, 4);		DisableMenuItemCarbon(editMenu, 5);		DisableMenuItemCarbon(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	static EventRecord oldEvent;	int				ok;	Rect    bounds;	ok = WaitNextEvent(everyEvent, &theEvent,0,null);	if((messageHook) && (messageHook(&theEvent))) {        return ok;    }	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent,&oldEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case mouseUp:				if(inputSemaphoreIndex) {					recordMouseEvent(&theEvent,MouseModifierState(&theEvent));    				if(postMessageHook) postMessageHook(&theEvent);					return false;				}				recordModifierButtons(&theEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyDown);					break;				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;						case keyUp:				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyUp);				}			break;#ifndef IHAVENOHEAD			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				//GetPortBounds(GetWindowPort(stWindow),&bounds);				//InvalWindowRect(stWindow,&bounds);				fullDisplayUpdate();  /* Fix for full screen menu bar tabbing*/			break;#endif			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;						case osEvt: 				if (((theEvent.message>>24)& 0xFF) == suspendResumeMessage) {									//JMM July 4th 2000					//Fix for menu bar tabbing, thanks to Javier Diaz-Reinoso for pointing this out					//					if (fullScreenFlag) {						if ((theEvent.message & resumeFlag) == 0) {							MenuBarRestore();						}						else {							MenuBarHide();						}					}				}				break;		}	}	else {		if(inputSemaphoreIndex && windowActive && 		    !!((oldEvent.what == theEvent.what) &&  		    (oldEvent.message == theEvent.message) && 		    ((oldEvent.where.v == theEvent.where.v) && (oldEvent.where.h == theEvent.where.h)) && 		    (oldEvent.modifiers == theEvent.modifiers))) {    		oldEvent = theEvent; //JMM Nov 11th 2000 bug fix 			recordMouseEvent(&theEvent,MouseModifierState(&theEvent)); 		} 		else		 oldEvent = theEvent;	}	if(postMessageHook) postMessageHook(&theEvent); 	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);#if !!TARGET_API_MAC_CARBON			OpenDeskAcc(name);#endif 			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:#if !!TARGET_API_MAC_CARBON			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}#endif		break;	}}void HandleMouseDown(EventRecord *theEvent,EventRecord *oldEvent) {	WindowPtr	theWindow;	static Rect		growLimits = { 20, 20, 10000, 10000 };	Rect        dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:#if !!TARGET_API_MAC_CARBON			SystemClick(theEvent, theWindow);#endif		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;#ifndef IHAVENOHEAD		case inDrag:			GetRegionBounds(GetGrayRgn(), &dragBounds);			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inZoomIn:		case inZoomOut:			if (theWindow == stWindow) {					DoZoomWindow(theEvent,stWindow, windowCode,10000, 10000);				}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				if(inputSemaphoreIndex) {					*oldEvent = *theEvent;					oldEvent->what = nullEvent;					recordMouseEvent(theEvent,MouseModifierState(theEvent));					break;				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;#endif	}}#if TARGET_API_MAC_CARBONvoid InitMacintosh(void) {	FlushEvents(everyEvent, 0);	InitCursor();}void MenuBarHide(void) { 	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */    menuBarRegion = (RgnHandle) 1;    HideMenuBar();}void MenuBarRestore(void) {	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */    ShowMenuBar();    menuBarRegion = nil;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {}void FreeClipboard(void) {}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;       	clipSize = clipboardSize(); 	charsToMove = (count < clipSize) ? count : clipSize;    err = GetScrapFlavorData(scrap,kScrapFlavorTypeText,(long *) &charsToMove,(char *) byteArrayIndex + startIndex);    if (err !!= noErr) {         FreeClipboard();        return 0;           }	return charsToMove;}int clipboardSize(void) {	long count;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;           err = GetScrapFlavorSize (scrap, kScrapFlavorTypeText, &count); 	if (err !!= noErr) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ScrapRef scrap;	OSErr err;	err = ClearCurrentScrap();    err = GetCurrentScrap (&scrap);	err = PutScrapFlavor ( scrap, kScrapFlavorTypeText, kScrapFlavorMaskNone , count,  (const void *) (byteArrayIndex + startIndex));}#else void InitMacintosh(void) {#if TARGET_CPU_68K    long currentLimit;    currentLimit = (long) GetApplLimit();    SetApplLimit((char *) currentLimit-32*1024);#endif	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */  	WindowPtr win; 		if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	LMSetMBarHeight(menuBarHeight);		win = FrontWindow();	if (win) {		CalcVis(win);		CalcVisBehind(win,menuBarRegion);	}	HiliteMenu(0);	DisposeRgn(menuBarRegion);		menuBarRegion = nil;	DrawMenuBar();}/*** Clipboard Support (text only for now) ***/Handle			clipboardBuffer = nil;void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;    //JMM locking    HLock(clipboardBuffer); 	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}    HUnlock(clipboardBuffer); 	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}#endifvoid SetUpMenus(void) {	long decideOnQuitMenu;		InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();#if TARGET_API_MAC_CARBON    Gestalt( gestaltMenuMgrAttr, &decideOnQuitMenu);    if (!!(decideOnQuitMenu & gestaltMenuMgrAquaLayoutMask) || true)	        AppendMenu(fileMenu, "\pQuit");#else	AppendResMenu(appleMenu, ''DRVR'');    AppendMenu(fileMenu, "\pQuit");#endif 	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};#ifndef IHAVENOHEAD	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, zoomDocProc, (WindowPtr) -1L, false, 0);#endif}void SetWindowTitle(char *title) {    Str255 tempTitle;	CopyCStringToPascal(title,tempTitle);#ifndef IHAVENOHEAD	SetWTitle(stWindow, tempTitle);#endif}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int asciiChar, modifierBits, keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = modifierMap[(theEvent->modifiers >> 8) & 0x1F];	if ((modifierBits & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	keystate = (modifierBits << 8) | asciiChar;	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState = MouseModifierState(theEvent);	cachedButtonState = cachedButtonState | buttonState;}int MouseModifierState(EventRecord *theEvent) {	int stButtons;	stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {  /* is false if button is down */		stButtons = 4;		/* red button by default */		if ((theEvent->modifiers & optionKey) !!= 0) {			stButtons = 2;	/* yellow button if option down */		}		if ((theEvent->modifiers & cmdKey) !!= 0) {			stButtons = 1;	/* blue button if command down */		}	} 	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	return ((modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7));}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordMouseEvent(EventRecord *theEvent, int theButtonState) {	sqMouseEvent *evt;		evt = (sqMouseEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeMouse;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	/* then the buttons */	evt->buttons = theButtonState & 0x07;	/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType) {	sqDragDropFilesEvent *evt;		evt = (sqDragDropFilesEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeDragDropFiles;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	evt->numFiles = numberOfItems;	evt->dragType = dragType;		/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordKeyboardEvent(EventRecord *theEvent, int keyType) {	int stButtons = 0;	int asciiChar, modifierBits;	sqKeyboardEvent *evt, *extra;	evt = (sqKeyboardEvent*) nextEventPut();	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = MouseModifierState(theEvent); //Capture mouse/option states	if (((modifierBits >> 3) & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	/* first the basics */	evt->type = EventTypeKeyboard;	evt->timeStamp = ioMSecs();	/* now the key code */	/* press code must differentiate */	evt->charCode = (theEvent->message & keyCodeMask) >> 8;	evt->pressCode = keyType;	evt->modifiers = modifierBits >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;	/* generate extra character event */	if (keyType == EventKeyDown) {		extra = (sqKeyboardEvent*)nextEventPut();		*extra = *evt;		extra->charCode = asciiChar;		extra->pressCode = EventKeyChar;	}//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}static sqInputEvent *nextEventPut(void) {	sqInputEvent *evt;	evt = eventBuffer + eventBufferPut;	eventBufferPut = (eventBufferPut + 1) % MAX_EVENT_BUFFER;	if (eventBufferGet == eventBufferPut) {		/* buffer overflow; drop the last event */		eventBufferGet = (eventBufferGet + 1) % MAX_EVENT_BUFFER;	}	return evt;}int ioSetInputSemaphore(int semaIndex) {	inputSemaphoreIndex = semaIndex;	return 1;}int ioGetNextEvent(sqInputEvent *evt) {	if (eventBufferGet == eventBufferPut) {		if (gThreadManager)    		YieldToAnyThread();		else		    ioProcessEvents();	}	if (eventBufferGet == eventBufferPut) 		return false;	*evt = eventBuffer[eventBufferGet];	eventBufferGet = (eventBufferGet+1) % MAX_EVENT_BUFFER;	return true;}/*** Mac Specific External Primitive Support ***//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName) {	char pluginDirPath[1000];	CFragConnectionID libHandle;	Ptr mainAddr;	Str255 errorMsg,tempPluginName;	OSErr err;        	/* first, look in the "<Squeak VM directory>Plugins" directory for the library */	strcpy(pluginDirPath, vmPath);	#ifdef PLUGIN	strcat(pluginDirPath, ":Plugins");#else	strcat(pluginDirPath, "Plugins");#endif 	        libHandle = LoadLibViaPath(pluginName, pluginDirPath);	if (libHandle !!= nil) return (int) libHandle;#ifndef PLUGIN	/* second, look directly in Squeak VM directory for the library */	libHandle = LoadLibViaPath(pluginName, vmPath);	if (libHandle !!= nil) return (int) libHandle;        /* Lastly look for it as a shared import library */        CopyCStringToPascal(pluginName,tempPluginName);    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kLoadCFrag, &libHandle, &mainAddr, errorMsg);	if (err == noErr) 	    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kFindCFrag, &libHandle, &mainAddr, errorMsg);	if (libHandle !!= nil) return (int) libHandle;#endif    	return nil;}/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle) {	CFragSymbolClass ignored;	Ptr functionPtr = 0;	OSErr err;    Str255 tempLookupName;    	if (!!moduleHandle) return 0;	/* get the address of the desired primitive function */	CopyCStringToPascal(lookupName,tempLookupName);	err = FindSymbol(		(CFragConnectionID) moduleHandle, (unsigned char *) tempLookupName,		&functionPtr, &ignored);	if (err) return 0;	return (int) functionPtr;}/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle) {	CFragConnectionID libHandle;	OSErr err;	if (!!moduleHandle) return 0;	libHandle = (CFragConnectionID) moduleHandle;	err = CloseConnection(&libHandle);	return 0;}CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath) {	short 				vRefNum;	long				ignore;	CInfoPBRec 			pb;	FSSpec				fileSpec;	Str255				problemLibName,fileSpecName,tempPlugindirPath;    Ptr					junk;	CFragConnectionID	libHandle = 0;	OSErr				err = noErr;	/* get the default volume */	HGetVol( nil, &vRefNum, &ignore);	/* get the directory ID for the given path */	CopyCStringToPascal(pluginDirPath,tempPlugindirPath);	pb.hFileInfo.ioNamePtr = tempPlugindirPath;	pb.hFileInfo.ioVRefNum = 0;  /* use the default volume */	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	err = PBGetCatInfoSync(&pb);	if (err) return nil; /* bad plugin directory path */	/* make a file spec for the given file name in the plugin directory */	CopyCStringToPascal(libName,fileSpecName);	FSMakeFSSpec(vRefNum,pb.hFileInfo.ioDirID,fileSpecName,&fileSpec);	err = GetDiskFragment(		&fileSpec, 0, kCFragGoesToEOF, nil, kLoadCFrag, &libHandle, &junk, problemLibName);	if (err) 	    return nil;	return libHandle;}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}#ifndef PLUGINint ioExit(void) {	ioShutdownAllModules();	MenuBarRestore();	ExitToShell();}#endifint ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if ((cachedButtonState & 0x7) !!= 0) {		int result = cachedButtonState;		cachedButtonState = 0;  /* clear cached button state */		return result;	}	cachedButtonState = 0;  /* clear cached button state */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioHasDisplayDepth(int depth) {	/* Return true if this platform supports the given color display depth. */	switch (depth) {	case 1:	case 2:	case 4:	case 8:	case 16:	case 32:		return true;	}	return false;}int ioMicroMSecsExpensive(void);int ioMicroMSecsExpensive(void) {	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}#if TARGET_CPU_PPC & !!MINIMALVM#if TARGET_API_MAC_CARBONint ioMicroMSecs(void) { //Some versions of mac os/x return 0 when using OTElapsedMilliseconds	Nanoseconds elapsedNanoseconds;   // an UnsignedWide integer	if((Ptr)UpTime!!=(Ptr)kUnresolvedCFragSymbolAddress){		elapsedNanoseconds=AbsoluteToNanoseconds(UpTime());		// NOTE: 4294967296.0 == (double)0x10000*0x10000		return (4294967296.0*elapsedNanoseconds.hi+elapsedNanoseconds.lo)*1e-6;	}else {	    return ioMicroMSecsExpensive();	}}#elseint ioMicroMSecs(void) {	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. */		register long check;		if((Ptr)OTElapsedMilliseconds!!=(Ptr)kUnresolvedCFragSymbolAddress){    	check = OTElapsedMilliseconds(&timeStart);    	if (check !!= -1)     	    return check;    	OTGetTimeStamp(&timeStart);	    return ioMicroMSecs();	}else {	    return ioMicroMSecsExpensive();	}}#endif#elseint ioMicroMSecs(void) {    return ioMicroMSecsExpensive();}#endifint ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	return ioMicroMSecs();}int ioMousePoint(void) {	Point p;	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	const int nextPollOffsetCheck = CLOCKS_PER_SEC/60, nextPowerCheckOffset=CLOCKS_PER_SEC/2; 	static clock_t nextPollTick = 0, nextPowerCheck=0;	long    clockTime;#ifndef PLUGIN	if (clock() >= nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		        clockTime = clock();                if (gDisablePowerManager && gTapPowerManager) {            if (clockTime > gDisableIdleTickLimit)                gDisableIdleTickLimit = IdleUpdate() + gDisableIdleTickCount;                #if TARGET_CPU_PPC & !!MINIMALVM            if (clockTime > nextPowerCheck) {                 UpdateSystemActivity(UsrActivity);                 nextPowerCheck = clockTime + nextPowerCheckOffset;            }#endif        }        		/* wait a while before trying again */		nextPollTick = clockTime + nextPollOffsetCheck;	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. 	 */       microSeconds;    if (gThreadManager)		YieldToAnyThread();	else	    ioProcessEvents();}int ioScreenDepth(void) {    Rect ignore;        GDHandle mainDevice = getDominateDevice(stWindow,&ignore);    if (mainDevice == null)         return 8;        return (*(*mainDevice)->gdPMap)->pixelSize;}#ifndef PLUGINint ioScreenSize(void) {	int w = 10, h = 10;    Rect portRect;    #ifndef IHAVENOHEAD	if (stWindow !!= nil) {        GetPortBounds(GetWindowPort(stWindow),&portRect);		w =  portRect.right -  portRect.left;		h =  portRect.bottom - portRect.top;	}#endif	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}#endifint ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag) {	/* Set the window to the given width, height, and color depth. Put the window	   into the full screen mode specified by fullscreenFlag. */	/* Note: Changing display depth is not yet, and may never be, implemented	   on the Macintosh, where (a) it is considered inappropriate and (b) it may	   not even be a well-defined operation if the Squeak window spans several	   displays (which display''s depth should be changed?). */	depth;#ifndef IHAVENOHEAD	ioSetFullScreen(fullscreenFlag);	if (!!fullscreenFlag) {		SizeWindow(stWindow, width, height, true);	}#endif}#ifndef PLUGINint ioSetFullScreen(int fullScreen) {	Rect                screen,portRect,windRect;	int                 width, height, maxWidth, maxHeight;	int                 oldWidth, oldHeight;    static Rect		    rememberOldLocation = {44,8,0,0};		    GDHandle            	dominantGDevice;    dominantGDevice = getDominateDevice(stWindow,&windRect);    getDominateGDeviceRect(dominantGDevice,&screen,true);    	if (fullScreen) {		rememberOldLocation = windRect;		if (dominantGDevice == GetMainDevice()) {		    rememberOldLocation.top += GetMBarHeight();		    rememberOldLocation.bottom += GetMBarHeight();		}		MenuBarHide();		GetPortBounds(GetWindowPort(stWindow),&portRect);		oldWidth =  portRect.right -  portRect.left;		oldHeight =  portRect.bottom -  portRect.top;		width  = screen.right - screen.left; 		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, screen.left, screen.top, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, rememberOldLocation.left, rememberOldLocation.top, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;    if (depth<=8) { /*Duane Maxwell <dmaxwell@exobox.com> fix cmpSize Sept 18,2000 */    	(*stPixMap)->cmpSize = depth;    	(*stPixMap)->cmpCount = 1;    } else if (depth==16) {    	(*stPixMap)->cmpSize = 5;    	(*stPixMap)->cmpCount = 3;    } else if (depth==32) {    	(*stPixMap)->cmpSize = 8;    	(*stPixMap)->cmpCount = 3;    }	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPortWindowPort(stWindow);	CopyBits((BitMap *) *stPixMap, GetPortBitMapForCopyBits(GetWindowPort(stWindow)), &srcRect, &dstRect, srcCopy, maskRect);#if TARGET_API_MAC_CARBON	QDFlushPortBuffer (GetWindowPort(stWindow), maskRect);#endif	DisposeRgn(maskRect);}#endif/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short volumeNumber,long directoryID) {	int offset, sz, i;	offset = PathToWorkingDir(fullName, length, volumeNumber, directoryID);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*****************************************************************************************GetApplicationDirectoryGet the volume reference number and directory id of this application.Code taken from Apple:	Technical Q&As: FL 14 - Finding your application''s directory (19-June-2000)Karl Goiser 14/01/01*****************************************************************************************/        /* GetApplicationDirectory returns the volume reference number        and directory ID for the current application''s directory. */    OSStatus GetApplicationDirectory(short *vRefNum, long *dirID) {        ProcessSerialNumber PSN;        ProcessInfoRec pinfo;        FSSpec pspec;        OSStatus err;            /* valid parameters */        if (vRefNum == NULL || dirID == NULL) return paramErr;            /* set up process serial number */        PSN.highLongOfPSN = 0;        PSN.lowLongOfPSN = kCurrentProcess;            /* set up info block */        pinfo.processInfoLength = sizeof(pinfo);        pinfo.processName = NULL;        pinfo.processAppSpec = &pspec;            /* grab the vrefnum and directory */        err = GetProcessInformation(&PSN, &pinfo);        if (err == noErr) {            *vRefNum = pspec.vRefNum;            *dirID = pspec.parID;        }        return err;    }/*** Initializing the path to Working Dir ***/int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	short	fullPathLength;	Handle	fullPathHandle;	if (GetFullPath(volumeNumber, directoryID, nil, &fullPathLength, &fullPathHandle) !!= noErr) {		//Some sort of random guff for failure:		pathName[0] = 1;		pathName[1] = (char)":";		return 1;	}	strncpy((char *) pathName, (char *) *fullPathHandle, fullPathLength);	DisposeHandle(fullPathHandle);	return fullPathLength;}/*****************************************************************************/int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		return pathNameSize;	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = '':'';  /* insert delimitor */	return pathNameSize + offset;}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	fullImagePath;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;#if TARGET_CPU_PPC & !!MINIMALVM	if((Ptr)OTGetTimeStamp!!=(Ptr)kUnresolvedCFragSymbolAddress) 	    OTGetTimeStamp(&timeStart);#endif	PowerMgrCheck();	SetUpClipboard();	SetUpPixmap();}int plugInShutdown(void) {	ioShutdownAllModules();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {	    DisposeThread(gSqueakThread,null,true);		DisposePtr((void *) memory);		memory = nil;	}}/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	/* Note: 1.3x images will try to read the image as a document because they	   expect attribute #1 to be the document name. A 1.3x image can be patched	   using a VM of 2.6 or earlier. */	if (id == 1) return imageName;	if (id == 2) return documentName;#ifdef PLUGIN	/* When running in browser, return the EMBED tag info */	if ((id > 2) && (id <= (2 + (2 * pluginArgCount)))) {		int i = id - 3;		if ((i & 1) == 0) {  /* i is even */			return pluginArgName[i/2];		} else {			return pluginArgValue[i/2];		}	}#endif	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	Str255 tempPascalFileName;     FInfo fileInfo;	CopyCStringToPascal(fileName,tempPascalFileName);	if (strchr(mode, ''w'') !!= null) 	    err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);	 else	    err = HOpenDF(0,0,tempPascalFileName,fsRdPerm, &fRefNum);	    	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = HCreate(0,0,tempPascalFileName,  ''FAST'', ''STim'');		if (err2 == 0) {			err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);		}	}	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {        err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);        if (err !!= noErr) return 0; //This should not happen                //On the mac we start at location 0 if this isn''t an VM            	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')){    		/* truncate non-VM file if opening in write mode */    		err = SetEOF(fRefNum, 0);    		if (err !!= 0) {    			FSClose(fRefNum);    			return null;    		}	    }	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	ParamBlockRec pb;    OSErr error;	pb.ioParam.ioRefNum = f;    pb.ioParam.ioCompletion = NULL;    pb.ioParam.ioBuffer = (Ptr)ptr;    pb.ioParam.ioReqCount = byteCount;    pb.ioParam.ioPosMode = fsAtMark + noCacheMask;    pb.ioParam.ioPosOffset = 0;    error = PBReadSync(&pb);    byteCount = pb.ioParam.ioActCount;           	if (error !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	ParamBlockRec pb;    OSErr error;    pb.ioParam.ioRefNum = f;    pb.ioParam.ioCompletion = NULL;    pb.ioParam.ioBuffer = (Ptr)ptr;    pb.ioParam.ioReqCount = byteCount;    pb.ioParam.ioPosMode = fsAtMark + noCacheMask;    pb.ioParam.ioPosOffset = 0;    error = PBWriteSync(&pb);    byteCount = pb.ioParam.ioActCount;           	if (error !!= 0) 	    return 0;	return byteCount / elementSize;}int calculateStartLocationForImage() { 	Handle cfrgResource;  	long	memberCount,i;	CFragResourceMember *target;		cfrgResource = GetResource(kCFragResourceType,0); 	if (cfrgResource == nil || ResError() !!= noErr) { return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {        ReleaseResource(cfrgResource);	    return 0; //Need FAT to get counters right	}		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {					    ReleaseResource(cfrgResource);		    return target->offset;		}		target = NextCFragResourceMemberPtr(target); 	}    ReleaseResource(cfrgResource);	return 0;}int sqImageFileStartLocation(int fileRef, char *filename, int imageSize){    FInfo fileInfo;	Str255 tempPascalFileName;	OSErr   err;     int     resFileRef;	Handle  cfrgResource,newcfrgResource;  	UInt32	maxOffset=0,maxOffsetLength,targetOffset;	long    memberCount,i;	CFragResourceMember *target;      	CopyCStringToPascal(filename,tempPascalFileName);    err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);    if (err !!= noErr) return 0; //This should not happen        //On the mac we start at location 0 if this isn''t an VM    	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')) return 0;        //Ok we have an application file, open the resource part and attempt to find the crfg        resFileRef = HOpenResFile(0,0,tempPascalFileName,fsWrPerm);    if (resFileRef == -1) return 0;    	cfrgResource = GetResource(kCFragResourceType,0);	if (cfrgResource == nil || ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};  //Need FAT to get counters right		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {		    targetOffset = target->offset;		    target->length = imageSize;		    ChangedResource(cfrgResource);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		    UpdateResFile(resFileRef);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};             ReleaseResource(cfrgResource); 		    CloseResFile(resFileRef);			return targetOffset;		}		if (target->offset > maxOffset) {			maxOffset = target->offset;			maxOffsetLength = target->length;		}		target = NextCFragResourceMemberPtr(target);	}		//Ok at this point we need to alter the crfg to add the new tag for the image part		newcfrgResource = cfrgResource;	err = HandToHand(&newcfrgResource);	if (err !!= noErr || MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 	SetHandleSize(newcfrgResource,GetHandleSize(cfrgResource)+AlignToFour(kBaseCFragResourceMemberSize + 1));	if (MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		target = &((CFragResource *)(*newcfrgResource))->firstMember; 	for(i=0;i<memberCount;i++) {		target = NextCFragResourceMemberPtr(target); 	}    target->architecture = ''FAST'';    target->reservedA = 0;                  /* !! Must be zero!!*/    target->reservedB = 0;                  /* !! Must be zero!!*/    target->updateLevel = 0;    target->currentVersion = 0;    target->oldDefVersion = 0;    target->uUsage1.appStackSize = 0;    target->uUsage2.appSubdirID = 0;    target->uUsage2.libFlags = 0;    target->usage = kApplicationCFrag;    target->where = kDataForkCFragLocator;    target->offset = maxOffset + maxOffsetLength;    targetOffset = target->offset;    target->length = imageSize;    target->uWhere1.spaceID = 0;    target->extensionCount = 0;             /* The number of extensions beyond the name.*/    target->memberSize = AlignToFour(kBaseCFragResourceMemberSize + 1);   /* Size in bytes, includes all extensions.*/    target->name[0] = 0x00;	((CFragResource *)(*newcfrgResource))->memberCount = memberCount+1;	RemoveResource(cfrgResource);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  	AddResource(newcfrgResource,kCFragResourceType,0,nil);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     UpdateResFile(resFileRef);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     CloseResFile(resFileRef);    	return targetOffset;}#ifndef PLUGINvoid * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* Application allocates Squeak object heap memory from its own heap. */		minHeapSize;	return NewPtr(desiredHeapSize);;}#endif#if TARGET_API_MAC_CARBONint sqGrowMemoryBy(int memoryLimit, int delta) {    SetPtrSize ((char *) memory,  GetPtrSize((char *) memory) + delta);    if (MemError() == noErr)         return memoryLimit + delta;   return memoryLimit;}int sqShrinkMemoryBy(int memoryLimit, int delta) {    return sqGrowMemoryBy(memoryLimit,0-delta);}int sqMemoryExtraBytesLeft(Boolean flag) {    if (flag)         return FreeMem();    else        return 0;}#elseint sqGrowMemoryBy(int memoryLimit, int delta) {    return memoryLimit;}int sqShrinkMemoryBy(int memoryLimit, int delta) {    return memoryLimit;}int sqMemoryExtraBytesLeft(Boolean flag) {    return 0;}#endifvoid PowerMgrCheck(void) {	long pmgrAttributes;		gTapPowerManager = false;	gDisablePowerManager = false;#if !!MINIMALVM	if (!! Gestalt(gestaltPowerMgrAttr, &pmgrAttributes))		if ((pmgrAttributes & (1<<gestaltPMgrExists)) 		    && (pmgrAttributes & (1<<gestaltPMgrDispatchExists))		    && (PMSelectorCount() >= 0x24)) {		    gTapPowerManager = true;			gDisableIdleTickLimit = clock();		}#endif}int ioDisablePowerManager(int disableIfNonZero) {    gDisablePowerManager = disableIfNonZero;}Boolean RunningOnCarbonX(void){    UInt32 response;        return (Gestalt(gestaltSystemVersion,                     (SInt32 *) &response) == noErr)                && (response >= 0x01000);}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	short vRefNum;	long dirID;	OSErr err;    long threadGestaltInfo;    	InitMacintosh();	PowerMgrCheck();		SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();#if !!MINIMALVM	 dropInit();#endif	SetEventMask(everyEvent); // also get key up events	#if TARGET_CPU_PPC & !!MINIMALVM	if((Ptr)OTGetTimeStamp!!=(Ptr)kUnresolvedCFragSymbolAddress) 	    OTGetTimeStamp(&timeStart);#endif 	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		err = GetApplicationDirectory(&vRefNum, &dirID);		if (err !!= noErr) error("Could not obtain default directory");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */#ifdef JITTER	reservedMemory = 1000000;#else#if MINIMALVM	reservedMemory = 128000;#else	reservedMemory = 500000;#endif#endif	if (RunningOnCarbonX())	    availableMemory = 1000*1024*1024 - reservedMemory;	else     	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeak to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 50K to that.)	    	    JMM Note changed to 500k for Open Transport support on 68K machines	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	while (f == NULL) {	    //Failure attempt to ask the user to find the image file	    	    FSSpec vmfsSpec,imageFsSpec;	    WDPBRec wdPB;	    	    err =  FSpLocationFromFullPath(vmPathSize(),vmPath,&vmfsSpec);	    if (err) 	        ioExit();		err = squeakFindImage(&vmfsSpec,&imageFsSpec);	    if (err) 	        ioExit();	    CopyPascalStringToC(imageFsSpec.name,shortImageName);        StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, imageFsSpec.vRefNum, imageFsSpec.parID);			/* make the image or document directory the working directory */    	wdPB.ioNamePtr = NULL;    	wdPB.ioVRefNum = imageFsSpec.vRefNum;    	wdPB.ioWDDirID = imageFsSpec.parID;    	PBHSetVolSync(&wdPB);    	f = sqImageFileOpen(imageName, "rb"); 	}		readImageFromFileHeapSizeStartingAt(f, availableMemory, calculateStartLocationForImage());	sqImageFileClose(f);#if !!MINIMALVM    ioInitSecurity();#endif    #ifndef IHAVENOHEAD	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);#endif#if (!!(defined JITTER) && defined(__MPW__))	atexit(SqueakTerminate);#endif#if TARGET_CPU_PPC & !!MINIMALVM     if( Gestalt( gestaltThreadMgrAttr, &threadGestaltInfo) == noErr &&        threadGestaltInfo & (1<<gestaltThreadMgrPresent) &&        ((Ptr) NewThread !!= (Ptr)kUnresolvedCFragSymbolAddress)) {        gThreadManager = true;        err = createNewThread();        if (err == noErr) {            while(true)  {                ioProcessEvents();        		YieldToAnyThread();            }            return;        }    }        #endif    gThreadManager = false;    /* run Squeak */    squeakThread(0);}#endifOSErr createNewThread() {#if TARGET_CPU_PPC    gSqueakThreadUPP = NewThreadEntryUPP(squeakThread); //We should dispose of someday#else    gSqueakThreadUPP = (ThreadEntryProcPtr) NewRoutineDescriptor((ProcPtr)(squeakThread), uppThreadEntryProcInfo, GetCurrentArchitecture()); #endif #ifndef PLUGIN	return NewThread( kCooperativeThread, gSqueakThreadUPP, nil, 80*1024, kCreateIfNeeded, 0L, &gSqueakThread);#else	return NewThread( kCooperativeThread, gSqueakThreadUPP, nil, 80*1024, kCreateIfNeeded+kNewSuspend, 0L, &gSqueakThread);#endif}static pascal void* squeakThread(void *threadParm) {	/* run Squeak */#	ifdef JITTER	j_interpret();#	else	interpret();#	endif}void SqueakTerminate() {#ifdef PLUGIN	ExitCleanup();#else	ioShutdownAllModules();#endif}WindowPtr getSTWindow(void) {    return stWindow;}int setMessageHook(eventMessageHook theHook) {    messageHook = theHook;}int setPostMessageHook(eventMessageHook theHook) {    postMessageHook = theHook;}#if !!TARGET_API_MAC_CARBON////	CopyPascalStringToC converts the source pascal string to a destination//	C string as it copies. //void CopyPascalStringToC(ConstStr255Param src, char* dst){	if ( src !!= NULL )	{		short   length  = *src++;			while ( length > 0 ) 		{			*dst++ = *(char*)src++;			--length;		}	}	*dst = ''\0'';}////	CopyCStringToPascal converts the source C string to a destination//	pascal string as it copies. The dest string will//	be truncated to fit into an Str255 if necessary.//  If the C String pointer is NULL, the pascal string''s length is set to zero//void CopyCStringToPascal(const char* src, Str255 dst){	short 	length  = 0;		// handle case of overlapping strings	if ( (void*)src == (void*)dst )	{		unsigned char*		curdst = &dst[1];		unsigned char		thisChar;						thisChar = *(const unsigned char*)src++;		while ( thisChar !!= ''\0'' ) 		{			unsigned char	nextChar;						// use nextChar so we don''t overwrite what we are about to read			nextChar = *(const unsigned char*)src++;			*curdst++ = thisChar;			thisChar = nextChar;						if ( ++length >= 255 )				break;		}	}	else if ( src !!= NULL )	{		unsigned char*		curdst = &dst[1];		short 				overflow = 255;		// count down so test it loop is faster		register char		temp;			// Can''t do the K&R C thing of while (*s++ = *t++) because it will copy trailing zero		// which might overrun pascal buffer.  Instead we use a temp variable.		while ( (temp = *src++) !!= 0 ) 		{			*(char*)curdst++ = temp;							if ( --overflow <= 0 )				break;		}		length = 255 - overflow;	}	dst[0] = length;}#endif#define rectWidth(aRect) ((aRect).right - (aRect).left)#define rectHeight(aRect) ((aRect).bottom - (aRect).top)#define MinWindowWidth(foo) 72*3#define MinWindowHeight(foo) 72*3#define max(X, Y) ( ((X)>(Y)) ? (X) : (Y) )#define min(X, Y) (  ((X)>(Y)) ? (Y) : (X) )#define pin(VALUE, MIN, MAX) ( ((VALUE) < (MIN)) ? (MIN) : ( ((VALUE) > (MAX)) ? (MAX) : (VALUE) ) )void DoZoomWindow (EventRecord* theEvent, WindowPtr theWindow, short zoomDir, short hMax, short vMax){	Rect				zoomRect,windRect,globalPortRect, dGDRect;	GDHandle			dominantGDevice;   	if (TrackBox(theWindow, theEvent->where, zoomDir)) {		SetPortWindowPort(theWindow);		GetPortBounds(GetWindowPort(stWindow),&windRect);		EraseRect(&windRect);	// recommended for cosmetic reasons		if (zoomDir == inZoomOut) {			/*			 *	ZoomWindow() is a good basic tool, but it doesn''t do everything necessary to			 *	implement a good human interface when zooming. In fact it''s not even close for			 *	more high-end hardware configurations. We must help it along by calculating an			 *	appropriate window size and location any time a window zooms out.			 */            dominantGDevice = getDominateDevice(theWindow,&windRect);			/*			 *	At this point, we know the dimensions of the window we''re zooming, and we know			 *	what screen we''re going to put it on. To be more specific, however, we need a			 *	rectangle which defines the maximum dimensions of the resized window''s contents.			 *	This rectangle accounts for the thickness of the window frame, the menu bar, and			 *	one or two pixels around the edges for cosmetic compatibility with ZoomWindow().			 */            getDominateGDeviceRect(dominantGDevice,&dGDRect,false);            			GetPortBounds(GetWindowPort(theWindow),&globalPortRect);			LocalToGlobal(&(((Point *) &(globalPortRect))[0]));		// calculate the window''s portRect			LocalToGlobal(&(((Point *) &(globalPortRect))[1]));		// in global coordinates			// account for the window frame and inset it a few pixels			dGDRect.left	+= 2 + globalPortRect.left - windRect.left;			dGDRect.top		+= 2 + globalPortRect.top - windRect.top;			dGDRect.right	-= 1 + windRect.right - globalPortRect.right;			dGDRect.bottom	-= 1 + windRect.bottom - globalPortRect.bottom;			/*			 *	Now we know exactly what our limits are, and since there are input parameters			 *	specifying the dimensions we''d like to see, we can move and resize the zoom			 *	state rectangle for the best possible results. We have three goals in this:			 *	1. Display the window entirely visible on a single device.			 *	2. Resize the window to best represent the dimensions of the document itself.			 *	3. Move the window as short a distance as possible to achieve #1 and #2.			 */			GetWindowStandardState(theWindow, &zoomRect);			/*			 *	Initially set the zoom rectangle to the size requested by the input parameters,			 *	although not smaller than a minimum size. We do this without moving the origin.			 */			zoomRect.right = (zoomRect.left = globalPortRect.left) +									max(hMax, MinWindowWidth(theWindow));			zoomRect.bottom = (zoomRect.top = globalPortRect.top) +									max(vMax, MinWindowHeight(theWindow));			// Shift the entire rectangle if necessary to bring its origin inside dGDRect.			OffsetRect(&zoomRect,						max(dGDRect.left - zoomRect.left, 0),						max(dGDRect.top - zoomRect.top, 0));			/*			 *	Shift the rectangle up and/or to the left if necessary to accomodate the view,			 *	and if it is possible to do so. The rectangle may not be moved such that its			 *	origin would fall outside of dGDRect.			 */			OffsetRect(&zoomRect,						-pin(zoomRect.right - dGDRect.right, 0, zoomRect.left - dGDRect.left),						-pin(zoomRect.bottom - dGDRect.bottom, 0, zoomRect.top - dGDRect.top));			// Clip expansion to dGDRect, in case view is larger than dGDRect.			zoomRect.right = min(zoomRect.right, dGDRect.right);			zoomRect.bottom = min(zoomRect.bottom, dGDRect.bottom);			SetWindowStandardState(theWindow, &zoomRect);		}		ZoomWindow(theWindow, zoomDir, false);		// all it needed was a brain transplant	}}GDHandle getDominateDevice( WindowPtr theWindow,Rect *windRect) {	GDHandle			nthDevice, dominantGDevice;	long				sectArea, greatestArea;    long                quickDrawAttributes;	Rect				theSect;    RgnHandle           windowRegion;    #if TARGET_API_MAC_CARBON			windowRegion = NewRgn();			GetWindowRegion(theWindow,kWindowStructureRgn,windowRegion);			GetRegionBounds(windowRegion,windRect);#else			*windRect = (**((WindowPeek) theWindow)->strucRgn).rgnBBox;#endif			dominantGDevice = nil;    	    if (!! Gestalt(gestaltQuickdrawFeatures, &quickDrawAttributes) &&     	        (quickDrawAttributes & (1<<gestaltHasColor))) {				/*				 *	Color QuickDraw implies the possibility of multiple monitors. This is where				 *	zooming becomes more interesting. One should zoom onto the monitor containing				 *	the greatest portion of the window. This requires walking the gDevice list.				 */				nthDevice = GetDeviceList();				greatestArea = 0;				while (nthDevice !!= nil) {					if (TestDeviceAttribute(nthDevice, screenDevice)) {						if (TestDeviceAttribute(nthDevice, screenActive)) {							SectRect(windRect, &(**nthDevice).gdRect, &theSect);							sectArea = (long) rectWidth(theSect) * (long) rectHeight(theSect);							if (sectArea > greatestArea) {								greatestArea = sectArea;		// save the greatest intersection								dominantGDevice = nthDevice;	// and which device it belongs to							}						}					}					nthDevice = GetNextDevice(nthDevice);				}			}    return dominantGDevice;}void getDominateGDeviceRect(GDHandle dominantGDevice,Rect *dGDRect,Boolean forgetMenuBar) {    BitMap              bmap;	if (dominantGDevice !!= nil) {			*dGDRect = (**dominantGDevice).gdRect;			if (dominantGDevice == GetMainDevice())		// account for menu bar on main device				if (!!forgetMenuBar) 				        dGDRect->top += GetMBarHeight();		}		else {			GetQDGlobalsScreenBits(&bmap);			*dGDRect = bmap.bounds;				// if no gDevice, use default monitor			if (!!forgetMenuBar)			    dGDRect->top += GetMBarHeight();		}}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 3/24/2001 21:40'!squeakPlatSpecFile	^ '/* sqPlatformSpecific.h -- Platform-specific prototypes and definitions *//* How to use this file:   This file is for general platform-specific macros and declarations.   Function prototypes that are unlikely to introduce name conflicts on   other platforms can be added directly. Macro re-definitions or conflicting   function prototypes can be wrapped in a #ifdefs. Alternatively, a customized   version of this file can be used on that platform. The goal is to keep all   the other header files generic across platforms. To override a definition or   macro from sq.h, you must first #undef it, then provide the new definition.*/#ifdef UNIX/* unix-specific prototypes and definitions */void aioPollForIO(int microSeconds, int extraFd);#define SQ_FORM_FILENAME	"squeak-form.ppm"/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs#undef ioLowResMSecs#endif /* UNIX */#ifdef macintosh// CARBON/*#ifdef TARGET_API_MAC_CARBON      #undef TARGET_API_MAC_CARBON    #define TARGET_API_MAC_CARBON 1#else    #define TARGET_API_MAC_CARBON 1#endif *//* replace the image file manipulation macros with functions */#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#undef sqImageFileStartLocation#undef sqAllocateMemorytypedef int sqImageFile;void        sqImageFileClose(sqImageFile f);sqImageFile sqImageFileOpen(char *fileName, char *mode);int         sqImageFilePosition(sqImageFile f);int         sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f);void        sqImageFileSeek(sqImageFile f, int pos);int         sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f);int         sqImageFileStartLocation(int fileRef, char *filename, int imageSize);void *						sqAllocateMemory(int minHeapSize, int desiredHeapSize);/* override reserveExtraCHeapBytes() macro to reduce Squeak object heap size on Mac */#undef reserveExtraCHeapBytes#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) (origHeapSize - bytesToReserve)/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs/* macro to return from interpret() loop in browser plugin VM */#define ReturnFromInterpret() return/* prototypes missing from CW11 headers */#include <textutils.h>void CopyPascalStringToC(ConstStr255Param src, char* dst);void CopyCStringToPascal(const char* src, Str255 dst);/* undef the memory routines for our logic */#undef sqGrowMemoryBy#undef sqShrinkMemoryBy#undef sqMemoryExtraBytesLeftint sqGrowMemoryBy(int memoryLimit, int delta);int sqShrinkMemoryBy(int memoryLimit, int delta);int sqMemoryExtraBytesLeft(Boolean flag);#endif /* macintosh */#ifdef ACORN/* acorn memory allocation */#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) platAllocateMemory(desiredHeapSize)#undef sqFilenameFromString#define sqFilenameFromString(dst, src, num) sqFilenameFromString(dst, src, num)/* string copying macro to compensate for bug in Acorn library code */#define copyNCharsFromTo(num, src, dst)\if(1) {int sqfni;\	char cc;\	for (sqfni = 0; sqfni < num; sqfni++) {\		dst[sqfni] = cc = *((char *) (src + sqfni));\		if ( cc == 0) break;\	}\	dst[num] = 0;\}/* undefine clock macros that are implemented as functions */#undef ioMicroMSecs#undef ioMSecs#define ioMSecs() (10* (int)os_read_monotonic_time())#undef ioLowResMSecs#define ioLowResMSecs() (ioMSecs())#endif /* ACORN */#ifdef WIN32/* Override necessary definitions */#undef putchar#include "sqWin32Alloc.h"#ifdef WIN32_FILE_SUPPORT#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#define sqImageFile unsigned longint sqImageFileClose(sqImageFile h);sqImageFile sqImageFileOpen(char *fileName, char *mode);int sqImageFilePosition(sqImageFile h);int sqImageFileRead(void *ptr, int sz, int count, sqImageFile h);int sqImageFileSeek(sqImageFile h, int pos);int sqImageFileWrite(void *ptr, int sz, int count, sqImageFile h);#endif /* WIN32_FILE_SUPPORT *//* pluggable primitive support */#if defined(_MSC_VER) || defined(__MINGW32__)#  undef EXPORT#  define EXPORT(returnType) __declspec( dllexport ) returnType#endif /* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioLowResMSecs#undef ioMicroMSecs/* Declare GetTickCount() in case <windows.h> is not included */#if !!defined(_WINDOWS_) && !!defined(_WIN32_WCE) && !!defined(_WINDOWS_H)__declspec(dllimport) unsigned long __stdcall GetTickCount(void);#endif#define ioLowResMSecs() GetTickCount()#endif /* WIN32 */#if defined(BEOS_SQUEAK) // BeOS supportvoid AsyncSignalSemaphoreWithIndex(int semaIndex); // external SYNCHRONIZED signaling of semaphoresvoid SignalSqSemaphores(); // signal semaphores signalled with/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs/* pluggable primitive support */# undef EXPORT# define EXPORT(returnType) __declspec( dllexport ) returnType#endif /* BeOS */    '! !