Object subclass: #Clipboard	instanceVariableNames: 'contents recent interpreter '	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!Morph subclass: #HandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset hasChanged savedPatch userInitials lastEventBuffer genieGestureProcessor keyboardInterpreter '	classVariableNames: 'CompositionWindowManager DoubleClickTime EventStats NewEventRules NormalCursor PasteBuffer ShowEvents '	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Kernel'!Object subclass: #ImmAbstractPlatform	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-ImmPlugin'!ImmAbstractPlatform subclass: #ImmWin32	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-ImmPlugin'!ImmAbstractPlatform subclass: #ImmX11	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-ImmPlugin'!LanguageEnvironment subclass: #JapaneseEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Languages'!LanguageEnvironment subclass: #KoreanEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Languages'!ScrollController subclass: #ParagraphEditor	instanceVariableNames: 'paragraph startBlock stopBlock beginTypeInBlock emphasisHere initialText selectionShowing otherInterval '	classVariableNames: 'ChangeText CmdActions FindText Keyboard ShiftCmdActions TextEditorYellowButtonMenu UndoInterval UndoMessage UndoParagraph UndoSelection Undone '	poolDictionaries: 'TextConstants '	category: 'Kernel-ST80 Remnants'!LanguageEnvironment subclass: #SimplifiedChineseEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Languages'!Object subclass: #SparseXTable	instanceVariableNames: 'tables xTables '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Display'!IdentityDictionary subclass: #SystemDictionary	instanceVariableNames: 'cachedClassNames '	classVariableNames: 'LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore MemoryHogs PrimaryLanguage ShutDownList SourceFileVersionString SpecialSelectors StartUpList StartupStamp SystemChanges SystemLanguage '	poolDictionaries: ''	category: 'System-Support'!ArrayedCollection subclass: #Text	instanceVariableNames: 'string runs '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Collections-Text'!Object subclass: #XTableForFixedFont	instanceVariableNames: 'width maxCode '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Display'!Object subclass: #XTableForUnicodeFont	instanceVariableNames: 'ranges xTables '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Display'!!SketchEditorMorph methodsFor: 'initialization' stamp: 'yo 7/16/2003 15:10'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: aPosition	"NB: if aPosition is nil, then it's assumed that the paintbox is obtained from a flap or some such, so do nothing special regarding a palette in this case.  The palette needs already to be in the world for this to work."	| w  |	(w _ aPasteUpMorph world) addMorphInLayer: self.	"in back of palette"	enclosingPasteUpMorph _ aPasteUpMorph.	hostView _ aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	palette _ w paintBox focusMorph: self.	palette beStatic.		"give Nebraska whatever help we can"	palette fixupButtons.	palette addWeakDependent: self.	aPosition ifNotNil:		[w addMorphFront: palette.  "bring to front"		palette position: aPosition].	paintingForm _ Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	self addRotationScaleHandles.	aSketchMorph ifNotNil:		[		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin - hostView form offset)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth".			undoBuffer _ paintingForm deepCopy.		rotationCenter _ aSketchMorph rotationCenter]! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'yo 11/17/2002 21:32'!mouseDown: evt	"Start a new stroke.  Check if any palette setting have changed.  6/11/97 20:30 tk"	| cur pfPen myAction |	"verify that we are in a good state"	self verifyState: evt.		"includes prepareToPaint and #scalingOrRotate"	pfPen _ self get: #paintingFormPen for: evt.	paintingForm extent = undoBuffer extent ifTrue: [		paintingForm displayOn: undoBuffer at: 0@0 rule: Form over.	] ifFalse: [		undoBuffer _ paintingForm deepCopy.	"know we will draw something"	].	pfPen place: (evt cursorPoint - bounds origin).	myAction _ self getActionFor: evt.	myAction == #paint: ifTrue:[		palette recentColor: (self getColorFor: evt)].	self set: #strokeOrigin for: evt to: evt cursorPoint.		"origin point for pickup: rect: ellispe: polygon: line: star:.  Always take it."	myAction == #pickup: ifTrue: [		cur _ Cursor corner clone.		cur offset: 0@0  "cur offset abs".		evt hand showTemporaryCursor: cur].	myAction == #polygon: ifTrue: [self polyNew: evt].	"a mode lets you drag vertices"	self mouseMove: evt.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'ka 11/19/2002 17:41'!undo: evt	"revert to a previous state.  "	| temp poly pen |	self flag: #bob.		"what is undo in multihand environment?"	undoBuffer ifNil: [^ self beep].	"nothing to go back to"	(poly _ self valueOfProperty: #polygon) ifNotNil:		[poly delete.		self setProperty: #polygon toValue: nil.		^ self].	temp _ paintingForm.	paintingForm _ undoBuffer.	undoBuffer _ temp.		"can get back to what you had by undoing again"	pen _ self get: #paintingFormPen for: evt.	pen ifNil: [^ self beep].	pen setDestForm: paintingForm.	formCanvas _ paintingForm getCanvas.	"used for lines, ovals, etc."	formCanvas _ formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	self render: bounds.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'sumim 11/20/2003 18:13'!nextChunkText	"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk."	| string runsRaw strm runs peek pos |	"Read the plain text"	string _ self nextChunk.		"Test for ]style[ tag"	pos _ self position.	peek _ self skipSeparatorsAndPeekNext.	peek = $] ifFalse: [self position: pos. ^ string asText].  "no tag"	(self upTo: $[) = ']style' ifFalse: [self position: pos. ^ string asText].  "different tag"	"Read and decode the style chunk"	runsRaw _ self basicNextChunk.	"style encoding"	strm _ ReadStream on: runsRaw from: 1 to: runsRaw size.	runs _ RunArray scanFrom: strm.	^ Text basicNew setString: string setRunsChecking: runs.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'sumim 11/20/2003 18:11'!parseLangTagFor: aString	| string peek runsRaw pos |	string _ aString.	"Test for ]lang[ tag"	pos _ self position.	peek _ self skipSeparatorsAndPeekNext.	peek = $] ifFalse: [self position: pos. ^ string].  "no tag"	(self upTo: $[) = ']lang' ifTrue: [		runsRaw _ self basicNextChunk.		string _ self decodeString: aString andRuns: runsRaw	] ifFalse: [		self position: pos	].	^ string.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 8/7/2003 13:04'!basicNextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator _ $!!.	out _ WriteStream on: (String new: 1000).	self skipSeparators.	[(ch _ self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 7/29/2003 22:58'!decodeString: string andRuns: runsRaw	| strm runLength runValues newString index |	strm _ ReadStream on: runsRaw from: 1 to: runsRaw size.	(strm peekFor: $( ) ifFalse: [^ nil].	runLength _ OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[runLength add: (Number readFrom: strm)].	runValues _ OrderedCollection new.	[strm atEnd not] whileTrue: 		[runValues add: (Number readFrom: strm).		strm next.].	newString _ MultiString new: string size.	index _ 1.	runLength with: runValues do: [:length :leadingChar |		index to: index + length - 1 do: [:pos |			newString at: pos put: (MultiCharacter leadingChar: leadingChar code: (string at: pos) charCode).		].		index _ index + length.	].	^ newString.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 8/13/2003 11:59'!nextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator _ $!!.	out _ WriteStream on: (String new: 1000).	self skipSeparators.	[(ch _ self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ self parseLangTagFor: out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ self parseLangTagFor: out contents.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 8/30/2002 14:47'!copyPreamble: preamble from: aStream	"Look for a changeStamp for this method by peeking backward.	Write a method preamble, with that stamp if found."	| terminator methodPos p last50 stamp i |	terminator _ $!!.	"Look back to find stamp in old preamble, such as...	Polygon methodsFor: 'private' stamp: 'di 6/25/97 21:42' prior: 34957598!! "	methodPos _ aStream position.	(aStream isMemberOf: MultiByteFileStream) ifTrue: [		aStream position: (p _ 0 max: methodPos-100).		last50 _ aStream basicNext: methodPos - p.	] ifFalse: [		aStream position: (p _ 0 max: methodPos-50).		last50 _ aStream next: methodPos - p.	].	stamp _ String new.	(i _ last50 findString: 'stamp:' startingAt: 1) > 0 ifTrue:		[stamp _ (last50 copyFrom: i+8 to: last50 size) copyUpTo: $'].	"Write the new preamble, with old stamp if any."	self cr; nextPut: terminator.	self nextChunkPut: (String streamContents:		[:strm |		strm nextPutAll: preamble.		stamp size > 0 ifTrue:			[strm nextPutAll: ' stamp: '; print: stamp]]).	self cr! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 8/4/2003 20:34'!fileInSilentlyAnnouncing: announcement	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title."	| val chunk |		[self atEnd]			whileFalse: 				[				self skipSeparators.				[					val _ (self peekFor: $!!) ifTrue: [						(Compiler evaluate: self nextChunk logged: false) scanFrom: self					] ifFalse: [						chunk _ self nextChunk.						self checkForPreamble: chunk.						Compiler evaluate: chunk logged: true					].				]					on: InMidstOfFileinNotification					do: [ :ex | ex resume: true].				self skipStyleChunk].		self close.	"Note:  The main purpose of this banner is to flush the changes file."	Smalltalk logChange: '----End fileIn of ' , self name , '----'.	self flag: #ThisMethodShouldNotBeThere. "sd"	SystemNavigation new allBehaviorsDo: [ :cl | 		cl removeSelectorSimply: #DoIt; removeSelectorSimply: #DoItIn:	].	^ val! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 10/15/2003 15:36'!copyPreamble: preamble from: aStream at: pos	"Look for a changeStamp for this method by peeking backward.	Write a method preamble, with that stamp if found."	| terminator methodPos p last50 stamp i |	terminator _ $!!.	"Look back to find stamp in old preamble, such as...	Polygon methodsFor: 'private' stamp: 'di 6/25/97 21:42' prior: 34957598!! "	aStream position: pos.	methodPos _ aStream position.	(aStream isMemberOf: MultiByteFileStream) ifTrue: [		aStream position: (p _ 0 max: methodPos-100).		last50 _ aStream basicNext: methodPos - p.	] ifFalse: [		aStream position: (p _ 0 max: methodPos-50).		last50 _ aStream next: methodPos - p.	].	stamp _ String new.	(i _ last50 findLastOccuranceOfString: 'stamp:' startingAt: 1) > 0 ifTrue:		[stamp _ (last50 copyFrom: i+8 to: last50 size) copyUpTo: $'].	"Write the new preamble, with old stamp if any."	self cr; nextPut: terminator.	self nextChunkPut: (String streamContents:		[:strm |		strm nextPutAll: preamble.		stamp size > 0 ifTrue:			[strm nextPutAll: ' stamp: '; print: stamp]]).	self cr! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 10/15/2003 19:02'!copyMethodChunkFrom: aStream at: pos	"Copy the next chunk from aStream (must be different from the receiver)."	| chunk |	aStream position: pos.	chunk _ aStream nextChunkText.	chunk runs values size = 1 "Optimize for unembellished text"		ifTrue: [self nextChunkPut: chunk asString]		ifFalse: [self nextChunkPutWithStyle: chunk]! !!SequenceableCollection methodsFor: 'converting' stamp: 'yo 8/28/2002 15:39'!asStringWithCr	"Convert to a string with returns between items.  Elements areusually strings.	 Useful for labels for PopUpMenus."	| labelStream |	labelStream _ WriteStream on: (String new: 200).	self do: [:each |		(each isKindOf: AbstractString)			ifTrue: [labelStream nextPutAll: each; cr]			ifFalse: [each printOn: labelStream. labelStream cr]].	self size > 0 ifTrue: [labelStream skip: -1].	^ labelStream contents! !!SequenceableCollection methodsFor: 'private' stamp: 'yo 9/2/2002 18:22'!copyReplaceAll: oldSubstring with: newSubstring asTokens: ifTokens	"Answer a copy of the receiver in which all occurrences of	oldSubstring have been replaced by newSubstring.	ifTokens (valid for Strings only) specifies that the characters	surrounding the recplacement must not be alphanumeric.		Bruce Simth,  must be incremented by 1 and not 	newSubstring if ifTokens is true.  See example below. "	| aString startSearch currentIndex endIndex |	(ifTokens and: [(self isString) not])		ifTrue: [(self isKindOf: Text) ifFalse: [			self error: 'Token replacement only valid for Strings']].	aString _ self.	startSearch _ 1.	[(currentIndex _ aString indexOfSubCollection: oldSubstring startingAt: startSearch)			 > 0]		whileTrue: 		[endIndex _ currentIndex + oldSubstring size - 1.		(ifTokens not			or: [(currentIndex = 1					or: [(aString at: currentIndex-1) isAlphaNumeric not])				and: [endIndex = aString size					or: [(aString at: endIndex+1) isAlphaNumeric not]]])			ifTrue: [aString _ aString					copyReplaceFrom: currentIndex					to: endIndex					with: newSubstring.				startSearch _ currentIndex + newSubstring size]			ifFalse: [				ifTokens 					ifTrue: [startSearch _ currentIndex + 1]					ifFalse: [startSearch _ currentIndex + newSubstring size]]].	^ aString"Test case:	'test te string' copyReplaceAll: 'te' with: 'longone' asTokens: true   "! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'yo 11/11/2002 10:31'!isStandardSetterKeyword: key	self flag: #yoCharCases.	key size > 4 ifFalse: [^false].	(key endsWith: ':') ifFalse: [^false].	(key beginsWith: 'set') ifFalse: [^false].	key fourth isUppercase ifFalse: [^false].	^true! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'yo 11/11/2002 10:32'!splitAtCapsAndDownshifted: aString	self flag: #yoCharCases.	^String streamContents: [ :strm |		aString do: [ :each | 			each = $: ifFalse: [				each isUppercase ifTrue: [strm nextPut: (Character value: 0);  						 	nextPut: (Character value: 0); 						 	nextPut: (Character value: 0); 							nextPut: each asLowercase]					ifFalse: [strm nextPut: each]			].		]	].! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'yo 11/11/2002 10:30'!isStandardGetterSelector: key	self flag: #yoCharCases.	key size > 3 ifFalse: [^false].	(key beginsWith: 'get') ifFalse: [^false].	key fourth isUppercase ifFalse: [^false].	^true! !!KoreanEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 10/4/2003 15:30'!charsetClass	^ UnicodeKorean.! !!KoreanEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 18:29'!defaultEncodingName	| platformName osVersion |	platformName _ Smalltalk platformName.	osVersion _ Smalltalk getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) ifTrue: [^ 'utf-8' copy].	(#('Win32' 'Mac OS' 'ZaurusOS') includes: platformName) ifTrue: [^ 'euc-kr' copy].	(#('unix') includes: platformName) ifTrue: [^ 'euc-kr' copy].	^ nil! !!SystemNavigation methodsFor: 'query' stamp: 'yo 7/16/2003 14:19'!allUnimplementedNonPrimitiveCalls	"Answer an Array of each message that is sent by an expression in a  	method but is not implemented by any object in the system."	| aStream secondStream all meth |	all _ self systemNavigation allImplementedMessages.	aStream _ WriteStream				on: (Array new: 50).	Cursor execute		showWhile: [self systemNavigation				allBehaviorsDo: [:cl | cl						selectorsDo: [:sel | 							secondStream _ WriteStream										on: (String new: 5).							meth _ cl compiledMethodAt: sel.							meth primitive = 0 ifTrue: [								meth messages									do: [:m | (all includes: m)											ifFalse: [secondStream nextPutAll: m;													 space]].								secondStream position = 0									ifFalse: [aStream nextPut: cl name , ' ' , sel , ' calls: ' , secondStream contents]]]]].	^ aStream contents! !!SystemNavigation methodsFor: 'query' stamp: 'yo 7/16/2003 15:18'!allGlobalRefsWithout: classesAndMessagesPair 	"Answer a set of symbols that may be refs to Global names. In some  	sense we should only need the associations, but this will also catch, eg,  	HTML tag types. This method computes its result in the absence of  	specified classes and messages."	"may be a problem if namespaces are introduced as for the moment  	only Smalltalk is queried. sd 29/4/03"	| globalRefs absentClasses absentSelectors |	globalRefs _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	absentSelectors _ classesAndMessagesPair second.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:.	"sd 29/04/03"	Cursor execute		showWhile: [Smalltalk classNames				do: [:cName | ((absentClasses includes: cName)						ifTrue: [{}]						ifFalse: [{Smalltalk at: cName. (Smalltalk at: cName) class}])						do: [:cl | (absentSelectors isEmpty								ifTrue: [cl selectors]								ifFalse: [cl selectors copyWithoutAll: absentSelectors])								do: [:sel | "Include all capitalized symbols for good 									measure"									(cl compiledMethodAt: sel) literals										do: [:m | 											((m isSymbol)													and: [m size > 0															and: [m first canBeGlobalVarInitial]])												ifTrue: [globalRefs add: m].											(m isMemberOf: Array)												ifTrue: [m														do: [:x | ((x isSymbol)																	and: [x size > 0																			and: [x first canBeGlobalVarInitial]])																ifTrue: [globalRefs add: x]]].											m isVariableBinding												ifTrue: [m key														ifNotNil: [globalRefs add: m key]]]]]]].	^ globalRefs! !!DocLibrary methodsFor: 'database of updates' stamp: 'yo 7/16/2003 15:53'!updateMethodVersions	"See if any new updates have occurred, and put their methods into the database."	| indexFile list result |	indexFile _ 'latest.ix'.	list _ OrderedCollection new.	[result _ self absorbAfter: lastUpdate from: indexFile.	"boolean if succeeded, or we are up to date, or server not available"	 result isString] whileTrue: [		"result is the prev file name"		list addFirst: indexFile.		indexFile _ result].	list do: [:aFile | self absorbAfter: lastUpdate from: aFile].		"should always work this time"! !!MenuMorph methodsFor: 'construction' stamp: 'yo 7/16/2003 15:15'!labels: labelList lines: linesArray selections: selectionsArray 	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelArray := (labelList isString) 				ifTrue: [labelList findTokens: String cr]				ifFalse: [labelList]. 	1 to: labelArray size		do: 			[:i | 			self add: (labelArray at: i) action: (selectionsArray at: i).			(linesArray includes: i) ifTrue: [self addLine]]! !!Class methodsFor: 'class variables' stamp: 'yo 7/15/2003 20:55'!addClassVarName: aString 	"Add the argument, aString, as a class variable of the receiver.	Signal an error if the first character of aString is not capitalized,	or if it is already a variable named in the class."	| symbol |	aString first canBeGlobalVarInitial		ifFalse: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].	symbol _ aString asSymbol.	self withAllSubclasses do: 		[:subclass | 		(subclass bindingOf: symbol) ifNotNil:[			^ self error: aString 				, ' is already used as a variable name in class ' 				, subclass name]].	classPool == nil ifTrue: [classPool _ Dictionary new].	(classPool includesKey: symbol) ifFalse: 		["Pick up any refs in Undeclared"		Smalltalk changes changeClass: self from: self.		classPool declare: symbol from: Undeclared]! !!Class methodsFor: 'initialize-release' stamp: 'yo 7/15/2003 20:58'!declare: varString 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	| newVars conflicts |	newVars _ 		(Scanner new scanFieldNames: varString)			collect: [:x | x asSymbol].	newVars do:		[:var | var first canBeGlobalVarInitial			ifFalse: [self error: var, ' class variable name should be capitalized; proceed to include anyway.']].	conflicts _ false.	classPool == nil 		ifFalse: [(classPool keys reject: [:x | newVars includes: x]) do: 					[:var | self removeClassVarName: var]].	(newVars reject: [:var | self classPool includesKey: var])		do: [:var | "adding"			"check if new vars defined elsewhere"			(self bindingOf: var) notNil				ifTrue: 					[self error: var , ' is defined elsewhere'.					conflicts _ true]].	newVars size > 0		ifTrue: 			[classPool _ self classPool.			"in case it was nil"			newVars do: [:var | classPool declare: var from: Undeclared]].	^conflicts! !!Class methodsFor: 'fileIn/Out' stamp: 'yo 8/30/2002 14:00'!fileOutAsHtml: useHtml	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: self name, FileDirectory dot, 'html') asHtml]		ifFalse: [FileStream newFileNamed: (self name, FileDirectory dot, 'st') asFileName].	fileStream header; timeStamp.	self sharedPools size > 0 ifTrue: [		self shouldFileOutPools			ifTrue: [self fileOutSharedPoolsOn: fileStream]].	self fileOutOn: fileStream moveSource: false toFile: 0.	fileStream trailer; close.	"DeepCopier new checkVariables."! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'yo 8/5/2003 19:13'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots. 	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal ccFixups receiverClasses rootsToUnhiberhate myProject m |	self flag: #bobconv.		RecentlyRenamedClasses _ nil.		"in case old data hanging around"	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal 				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is not compatible'].	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		self reshapeClasses: mapFakeClassesToReal refStream: smartRefStream	].	arrayOfRoots do: [:importedObject |		(importedObject isKindOf: MultiString) ifTrue: [			importedObject mutateJISX0208StringToUnicode.			importedObject class = MultiSymbol ifTrue: [				"self halt."				MultiSymbol hasInternedALoadedSymbol: importedObject ifTrue: [:multiSymbol |					multiSymbol == importedObject ifFalse: [						multiSymbol becomeForward: importedObject.					].				].			].		].	].	Smalltalk garbageCollect.	MultiSymbol rehash.	receiverClasses _ self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:importedObject | 		importedObject class class == Metaclass ifTrue: [self declare: importedObject]].	arrayOfRoots do: [:importedObject | 		(importedObject isKindOf: CompiledMethod) ifTrue: [			importedObject sourcePointer > 0 ifTrue: [importedObject zapSourcePointer]].		(importedObject isKindOf: Project) ifTrue: [			myProject _ importedObject.			importedObject ensureChangeSetNameUnique.			Project addingProject: importedObject.			importedObject restoreReferences.			self dependentsRestore: importedObject.			ScriptEditorMorph writingUniversalTiles: 				((importedObject projectPreferenceAt: #universalTiles) ifNil: [false])]].		rootsToUnhiberhate _ arrayOfRoots select: [:importedObject | 		importedObject respondsTo: #unhibernate	"ScriptEditors and ViewerFlapTabs"	].	myProject ifNotNil: [		myProject world setProperty: #thingsToUnhibernate toValue: rootsToUnhiberhate	].	mapFakeClassesToReal isEmpty ifFalse: [		mapFakeClassesToReal keys do: [:aFake | 			aFake indexIfCompact > 0 ifTrue: [aFake becomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"	MultiSymbol allInstances do: [:each | 		m _ MultiSymbol intern: each asString.		each == m ifFalse: [			"For a project from older m17n image, this is necessary."			"self halt."			m becomeForward: each.		].	].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'yo 11/11/2002 17:30'!copyFromRootsForExport: rootArray 	"When possible, use copySmartRootsExport:.  This way may not copy a complete tree of objects.  Add to roots: all of the methods pointed to from the outside by blocks."	| newRoots list segSize symbolHolder |	arrayOfRoots _ rootArray.	Smalltalk forgetDoIts.	"self halt."	symbolHolder _ Symbol allInstances, MultiSymbol allInstances.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	(newRoots _ self rootsIncludingPlayers) ifNotNil: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	"Creation of the segment happens here"	self copyFromRoots: arrayOfRoots sizeHint: 0.	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods, blocks from outPointers"	"classes of receivers of blocks"	list _ self compactClassesArray.	outPointers _ outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	"Zap sender of a homeContext. Can't send live stacks out."	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil]].	symbolHolder.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'yo 3/31/2003 12:09'!copySmartRootsExport: rootArray 	"Use SmartRefStream to find the object.  Make them all roots.  Create the segment in memory.  Project should be in first five objects in rootArray."	| newRoots list segSize symbolHolder dummy replacements naughtyBlocks goodToGo allClasses sizeHint proj |	Smalltalk forgetDoIts.	"self halt."	symbolHolder _ Symbol allInstances, MultiSymbol allInstances.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy insideASegment: true.	"So Uniclasses will be traced"	dummy rootObject: rootArray.	"inform him about the root"	dummy nextPut: rootArray.	(proj _dummy project) ifNotNil: [self dependentsSave: dummy].	allClasses _ SmartRefStream new uniClassInstVarsRefs: dummy.		"catalog the extra objects in UniClass inst vars.  Put into dummy"	allClasses do: [:cls | 		dummy references at: cls class put: false.	"put Player5 class in roots"		dummy blockers removeKey: cls class ifAbsent: []].	"refs _ dummy references."	arrayOfRoots _ self smartFillRoots: dummy.	"guaranteed none repeat"	self savePlayerReferences: dummy references.	"for shared References table"	replacements _ dummy blockers.	dummy project "recompute it" ifNil: [self error: 'lost the project!!'].	dummy project class == DiskProxy ifTrue: [self error: 'saving the wrong project'].	dummy _ nil.	"force GC?"	naughtyBlocks _ arrayOfRoots select: [ :each |		(each isKindOf: ContextPart) and: [each hasInstVarRef]	].	"since the caller switched ActiveWorld, put the real one back temporarily"	naughtyBlocks isEmpty ifFalse: [		World becomeActiveDuring: [			goodToGo _ PopUpMenu				confirm: 'Some block(s) which reference instance variables are included in this segment. These may fail whenthe segment is loaded if the class has been reshaped.What would you like to do?' 				trueChoice: 'keep going' 				falseChoice: 'stop and take a look'.			goodToGo ifFalse: [				naughtyBlocks inspect.				self error: 'Here are the bad blocks'].		].	].	"Creation of the segment happens here"	"try using one-quarter of memory min: four megs to publish (will get bumped later)"	sizeHint _ (Smalltalk garbageCollect // 4 // 4) min: 1024*1024.	self copyFromRoots: arrayOfRoots sizeHint: sizeHint areUnique: true.	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods, blocks from outPointers"	list _ self compactClassesArray.	outPointers _ outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil].		"substitute new object in outPointers"		(replacements includesKey: (outPointers at: ii)) ifTrue: [			outPointers at: ii put: (replacements at: (outPointers at: ii))]].	proj ifNotNil: [self dependentsCancel: proj].	symbolHolder.! !!SimplifiedChineseEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 18:27'!charsetClass	^ GB2312.! !!SimplifiedChineseEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/11/2003 18:27'!defaultEncodingName	| platformName osVersion |	platformName _ Smalltalk platformName.	osVersion _ Smalltalk getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) ifTrue: [^ 'utf-8' copy].	(#('Win32' 'Mac OS' 'ZaurusOS') includes: platformName) ifTrue: [^ 'gb2312' copy].	(#('unix') includes: platformName) ifTrue: [^ 'euc-cn' copy].	^ nil! !!SuperSwikiServer methodsFor: 'accessing' stamp: 'yo 11/4/2002 22:21'!defaultEncodingName	^ 'shift_jis' copy! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'yo 8/30/2002 14:52'!fileOutCategory: category asHtml: useHtml	"FileOut all the classes in the named system category."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: category , '.html') asHtml]		ifFalse: [FileStream newFileNamed: (category , '.st') asFileName].	self fileOutCategory: category on: fileStream initializing: true.	fileStream close! !!TextMorph methodsFor: 'editing' stamp: 'yo 11/7/2002 19:11'!setCompositionWindow	| hand |	hand _ self primaryHand.	hand ifNotNil: [hand compositionWindowManager keyboardFocusForAMorph: self].! !!TextMorph methodsFor: 'geometry' stamp: 'yo 12/18/2002 19:06'!minimumExtent	| minExt |	textStyle ifNil: [^ 9@16].	borderWidth ifNil: [^ 9@16].	minExt _ (12@(textStyle lineGrid+2)) + (borderWidth*2).	margins ifNil: [^ minExt].	^ ((0@0 extent: minExt) expandBy: margins) extent! !!TextMorph methodsFor: 'drawing' stamp: 'yo 1/23/2003 18:04'!drawOnTest: aCanvas	"Draw the receiver on a canvas"	| fauxBounds |	self setDefaultContentsIfNil.	super drawOn: aCanvas.  "Border and background if any"	false ifTrue: [self debugDrawLineRectsOn: aCanvas].  "show line rects for debugging"	(self startingIndex > text size)		ifTrue: [self drawNullTextOn: aCanvas].	"Hack here:  The canvas expects bounds to carry the location of the text, but we also need to communicate clipping."	fauxBounds _ self bounds topLeft corner: self innerBounds bottomRight.	aCanvas paragraph3: self paragraph bounds: fauxBounds color: color! !!TextMorph methodsFor: 'editing' stamp: 'yo 11/7/2002 18:56'!prefereredKeyboardPosition	| default rects |	default  _ (self bounds: self bounds in: World) topLeft.	paragraph ifNil: [^ default].	rects _ paragraph selectionRects.	rects size = 0 ifTrue: [^ default].	^ rects first topLeft.	"^ (self bounds: self bounds in: World) topLeft."! !!TextMorph methodsFor: 'editing' stamp: 'Tsutomu Hiroshima 11/17/2003 08:50'!handleInteraction: interactionBlock fromEvent: evt	"Perform the changes in interactionBlock, noting any change in selection	and possibly a change in the size of the paragraph (ar 9/22/2001 - added for TextPrintIts)"	"Also couple ParagraphEditor to Morphic keyboard events"	| oldEditor oldParagraph oldSize |	self editor sensor: (KeyboardBuffer new startingEvent: evt).	oldEditor _ editor.	oldParagraph _ paragraph.	oldSize _ oldParagraph text size.	self selectionChanged.  "Note old selection"		interactionBlock value.	(oldParagraph == paragraph) ifTrue:[		"this will not work if the paragraph changed"		editor _ oldEditor.     "since it may have been changed while in block"	].	self selectionChanged.  "Note new selection"	(oldSize = paragraph text size)		ifFalse:[self updateFromParagraph].	self setCompositionWindow.! !!TextMorph methodsFor: 'event handling' stamp: 'Tsutomu Hiroshima 11/17/2003 08:49'!keyStroke: evt	"Handle a keystroke event."	| action |	evt keyValue = 13 ifTrue:["CR - check for special action"		action _ self crAction.		action ifNotNil:[			"Note: Code below assumes that this was some			input field reacting on CR. Break the keyboard			focus so that the receiver can be safely deleted."			evt hand newKeyboardFocus: nil.			^action value]].	self handleInteraction: [editor readKeyboard] fromEvent: evt.	"self updateFromParagraph."	super keyStroke: evt  "sends to keyStroke event handler, if any"! !!TextMorph methodsFor: 'private' stamp: 'Tsutomu Hiroshima 11/17/2003 08:50'!updateFromParagraph	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be released, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, undo state, and current typing emphasis."	| newStyle sel oldLast oldEditor back |	paragraph ifNil: [^self].	wrapFlag ifNil: [wrapFlag := true].	editor ifNotNil: 			[oldEditor := editor.			sel := editor selectionInterval.			editor storeSelectionInParagraph].	text := paragraph text.	paragraph textStyle = textStyle 		ifTrue: [self fit]		ifFalse: 			["Broadcast style changes to all morphs"			newStyle := paragraph textStyle.			(self firstInChain text: text textStyle: newStyle) recomposeChain.			editor ifNotNil: [self installEditorToReplace: editor]].	super layoutChanged.	sel ifNil: [^self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil: 			[sel first <= (self paragraph lines first last + 1) 				ifTrue: 					[oldLast := predecessor lastCharacterIndex.					predecessor paragraph 						recomposeFrom: oldLast						to: text size						delta: 0.					oldLast = predecessor lastCharacterIndex 						ifFalse: 							[predecessor changed.	"really only last line"							self predecessorChanged]]].	((back := predecessor notNil 				and: [sel first <= self paragraph firstCharacterIndex]) or: 				[successor notNil 					and: [sel first > (self paragraph lastCharacterIndex + 1)]]) 		ifTrue: 			["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."			back ifTrue: [predecessor recomposeChain] ifFalse: [self recomposeChain].			self firstInChain withSuccessorsDo: 					[:m | 					(sel first between: m firstCharacterIndex and: m lastCharacterIndex + 1) 						ifTrue: 							[m installEditorToReplace: oldEditor.							^self passKeyboardFocusTo: m]].			self error: 'Inconsistency in text editor'	"Must be somewhere in the successor chain"].	editor ifNil: 			["Reinstate selection after, eg, style change"			self installEditorToReplace: oldEditor].	"self setCompositionWindow."! !!FilePackage methodsFor: 'initialize' stamp: 'yo 8/27/2003 07:03'!fromFileNamed: aName encoding: encodingName	| stream |	fullName := aName.	stream := FileStream readOnlyFileNamed: aName.	self fileInFrom: stream.! !!ReadWriteStream methodsFor: 'converting' stamp: 'yo 7/16/2003 14:59'!asUnZippedStream	| isGZip outputStream first strm archive which |	"Decompress this file if needed, and return a stream.  No file is written.  File extension may be .gz or anything else.  Also works on archives (.zip, .gZip)."	strm _ self binary.	strm isZipArchive ifTrue: [		archive _ ZipArchive new readFrom: strm.		which _ archive members detect: [:any | any fileName asLowercase endsWith: '.ttf'] 								ifNone: [nil].		which ifNil: [archive close.					^ self error: 'Can''t find .ttf file in archive'].		strm _ which contentStream.		archive close].	first _ strm next.	isGZip _ (strm next * 256 + first) = (GZipConstants gzipMagic).	strm skip: -2.	isGZip 		ifTrue: [outputStream _ (MultiByteBinaryOrTextStream with:									(GZipReadStream on: strm) upToEnd) reset.				strm close]		ifFalse: [outputStream _ strm].	^ outputStream! !!Array methodsFor: 'converting' stamp: 'yo 9/2/2002 18:23'!evalStrings	   "Allows you to construct literal arrays.    #(true false nil '5@6' 'Set new' '''text string''') evalStrings    gives an array with true, false, nil, a Point, a Set, and a String    instead of just a bunch of Symbols"    | it |    ^ self collect: [:each |        it _ each.        each == #true ifTrue: [it _ true].		      each == #false ifTrue: [it _ false].        each == #nil ifTrue: [it _ nil].        ((each class == String) or: [each class == MultiString]) ifTrue: [			it _ Compiler evaluate: each].        each class == Array ifTrue: [it _ it evalStrings].        it]! !!ChangeSet methodsFor: 'moving changes' stamp: 'yo 8/30/2002 13:59'!removeClassChanges: class	"Remove all memory of changes associated with this class"	| cname |	(class isString)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	changeRecords removeKey: cname ifAbsent: [].	self noteClassForgotten: cname.! !!ChangeSet methodsFor: 'private' stamp: 'yo 8/30/2002 13:59'!changeRecorderFor: class	| cname |	(class isString)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	"Later this will init the changeRecords so according to whether they should be revertable."	^ changeRecords at: cname			ifAbsent: [^ changeRecords at: cname							put: (ClassChangeRecord new initFor: cname revertable: revertable)]! !!CustomMenu methodsFor: 'construction' stamp: 'yo 8/28/2002 22:34'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelList isString		ifTrue: [labelArray _ labelList findTokens: String cr]		ifFalse: [labelArray _ labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!ImmAbstractPlatform methodsFor: 'all' stamp: 'yo 11/7/2002 17:43'!keyboardFocusForAMorph: aMorph	"do nothing"! !!FileDirectory methodsFor: 'file operations' stamp: 'yo 11/5/2002 15:56'!rename: oldFileName toBe: newFileName	| selection oldName newName |	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name."	"Modified for retry after GC ar 3/21/98 18:09"	oldName _ self fullNameFor: oldFileName.	newName _ self fullNameFor: newFileName.	(StandardFileStream 		retryWithGC:[self primRename: oldName convertToSystemString to: newName convertToSystemString]		until:[:result| result notNil]		forFileNamed: oldName) ~~ nil ifTrue:[^self].	(self fileExists: oldFileName) ifFalse:[		^self error:'Attempt to rename a non-existent file'.	].	(self fileExists: newFileName) ifTrue:[		selection _ (PopUpMenu labels:'delete old versioncancel')				startUpWithCaption: 'Trying to rename a file to be', newFileName , 'and it already exists.'.		selection = 1 ifTrue:			[self deleteFileNamed: newFileName.			^ self rename: oldFileName toBe: newFileName]].	^self error:'Failed to rename file'.! !!FileDirectory methodsFor: 'file operations' stamp: 'yo 11/5/2002 16:03'!setMacFileNamed: fileName type: typeString creator: creatorString	"Set the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4. Does nothing on other platforms (where the underlying primitive is a noop)."	"FileDirectory default setMacFileNamed: 'foo' type: 'TEXT' creator: 'ttxt'" 	self primSetMacFileNamed: (self fullNameFor: fileName) convertToSystemString		type: typeString		creator: creatorString convertToSystemString.! !!FileDirectory methodsFor: 'file operations' stamp: 'yo 11/5/2002 15:56'!deleteFileNamed: localFileName ifAbsent: failBlock	"Delete the file of the given name if it exists, else evaluate failBlock.	If the first deletion attempt fails do a GC to force finalization of any lost references. ar 3/21/98 17:53"	| fullName |	fullName _ self fullNameFor: localFileName.	(StandardFileStream 		retryWithGC:[self primDeleteFileNamed: (self fullNameFor: localFileName) convertToSystemString]		until:[:result| result notNil]		forFileNamed: fullName) == nil			ifTrue: [^failBlock value].! !!FileDirectory methodsFor: 'path access' stamp: 'sumim 11/14/2002 21:34'!pathParts	"Return the path from the root of the file system to this directory as an array of directory names."	pathName class == String ifTrue: [pathName _ pathName convertFromSystemString].	^ pathName findTokens: self pathNameDelimiter asString! !!FileDirectory methodsFor: 'private' stamp: 'yo 11/5/2002 15:53'!directoryContentsFor: fullPath	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	| entries index done entryArray |	entries _ OrderedCollection new: 200.	index _ 1.	done _ false.	[done] whileFalse: [		entryArray _ self primLookupEntryIn: fullPath convertToSystemString index: index.		#badDirectoryPath = entryArray ifTrue: [			^(InvalidDirectoryError pathName: pathName) signal].		entryArray == nil			ifTrue: [done _ true]			ifFalse: [entries addLast: (DirectoryEntry fromArray: entryArray)].		index _ index + 1].	^ entries asArray! !!FileDirectory methodsFor: 'file operations' stamp: 'yo 11/5/2002 15:58'!createDirectory: localFileName	"Create a directory with the given name in this directory. Fail if the name is bad or if a file or directory with that name already exists." 	self primCreateDirectory: (self fullNameFor: localFileName) convertToSystemString.! !!FileDirectory methodsFor: 'file operations' stamp: 'yo 11/5/2002 15:58'!deleteDirectory: localDirName	"Delete the directory with the given name in this directory. Fail if the path is bad or if a directory by that name does not exist." 	self primDeleteDirectory: (self fullNameFor: localDirName) convertToSystemString.! !!FileDirectory methodsFor: 'enumeration' stamp: 'yo 11/5/2002 15:02'!entries	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name><creationTime><modificationTime><dirFlag><fileSize>). See primLookupEntryIn:index: for further details."	"FileDirectory default entries"	| entries |	entries _ self directoryContentsFor: pathName.	^ entries collect: [:s | s convertFromSystemName].! !!FileDirectory methodsFor: 'enumeration' stamp: 'yo 11/5/2002 15:57'!statsForDirectoryTree: rootedPathName	"Return the size statistics for the entire directory tree starting at the given root. The result is a three element array of the form: (<number of folders><number of files><total bytes in all files>). This method also serves as an example of how recursively enumerate a directory tree."	"wod 6/16/1998: add Cursor wait, and use 'self pathNameDelimiter asString' rather than hardwired ':' "	"FileDirectory default statsForDirectoryTree: '\smalltalk'"	| dirs files bytes todo p entries |	Cursor wait showWhile: [		dirs _ files _ bytes _ 0.		todo _ OrderedCollection with: rootedPathName.		[todo isEmpty] whileFalse: [			p _ todo removeFirst.			entries _ self directoryContentsFor: p.			entries _ entries collect: [:s | s convertFromSystemName].			entries do: [:entry |				(entry at: 4)					ifTrue: [						todo addLast: (p, self pathNameDelimiter asString, (entry at: 1)).						dirs _ dirs + 1]					ifFalse: [						files _ files + 1.						bytes _ bytes + (entry at: 5)]]]].	^ Array with: dirs with: files with: bytes! !!FileDirectory methodsFor: 'file operations' stamp: 'yo 11/5/2002 16:04'!getMacFileTypeAndCreator: fileName 	| results typeString creatorString |	"get the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4. Does nothing on other platforms (where the underlying primitive is a noop)."	"FileDirectory default getMacFileNamed: 'foo'"	typeString _ ByteArray new: 4 withAll: ($? asInteger).	creatorString _ ByteArray new: 4 withAll: ($? asInteger).	[self primGetMacFileNamed: (self fullNameFor: fileName) convertToSystemString		type: typeString		creator: creatorString.] ensure: 		[typeString _ typeString asString. 		creatorString _ creatorString asString].	results _ Array with: typeString convertFromSystemString with: creatorString convertFromSystemString.	^results! !!WeakSet methodsFor: 'private' stamp: 'yo 11/11/2002 23:10'!scanForLoadedSymbol: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements"	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == flag or: [element asString = anObject asString])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == flag or: [element asString = anObject asString])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakSet methodsFor: 'public' stamp: 'yo 11/11/2002 23:11'!likeLoadedSymbol: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| index element |	^(index _ self scanForLoadedSymbol: anObject) = 0		ifFalse: [(element _ array at: index) == flag ifFalse: [element]]! !!ByteArray methodsFor: 'accessing' stamp: 'yo 10/23/2002 23:35'!asMultiString	^ MultiString fromByteArray: self.! !!FileStream class methodsFor: 'concrete classes' stamp: 'yo 11/4/2002 14:49'!concreteStream	"Who should we really direct class queries to?  "	^ MultiByteFileStream "may change this to CrLfFileStream"	"^ StandardFileStream may change this to CrLfFileStream"! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sumim 9/2/2003 14:36'!fileOutChangedMessagesHistorically: aSet on: aFileStream moveSource: moveSource toFile: fileIndex 	"File all historical description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."	| org sels |	(org _ self organization) categories do: 		[:cat | 		sels _ (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		sels do:			[:sel |  self printMethodChunkHistorically: sel on: aFileStream							moveSource: moveSource toFile: fileIndex]]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'yo 7/15/2003 20:51'!fileOutMethod: selector asHtml: useHtml	"Write source code of a single method on a file in .st or .html format"	| fileStream nameBody |	(selector == #Comment) ifTrue: [^ self inform: 'Sorry, cannot file out class comment in isolation.'].	(self includesSelector: selector) ifFalse: [^ self error: 'Selector ', selector asString, ' not found'].	nameBody _ self name , '-' , (selector copyReplaceAll: ':' with: '').	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: nameBody , '.html') asHtml]		ifFalse: [FileStream newFileNamed: (nameBody , '.st') asFileName].	fileStream header; timeStamp.	self printMethodChunk: selector withPreamble: true		on: fileStream moveSource: false toFile: 0.	fileStream close! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'yo 10/15/2003 17:10'!printMethodChunk: selector withPreamble: doPreamble on: outStream		moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile endPos |	doPreamble 		ifTrue: [preamble _ self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble _ ''].	method _ self methodDict at: selector.	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos _ method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: (self decompilerClass new decompile: selector											in: self method: method) decompileString]		ifFalse:		[sourceFile _ SourceFiles at: method fileIndex.		preamble size > 0 ifTrue:    "Copy the preamble"			[outStream copyPreamble: preamble from: sourceFile at: oldPos].		"Copy the method chunk"		newPos _ outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.      "The following chunk may have ]style["		sourceFile peek == $] ifTrue: [			outStream cr; copyMethodChunkFrom: sourceFile].		moveSource ifTrue:    "Set the new method source pointer"			[endPos _ outStream position.			method checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'yo 8/30/2002 14:00'!fileOutCategory: catName asHtml: useHtml	"FileOut the named category, possibly in Html format."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: self name , '-' , catName , '.html') asHtml]		ifFalse: [FileStream newFileNamed: (self name , '-' , catName , '.st') asFileName].	fileStream header; timeStamp.	self fileOutCategory: catName on: fileStream moveSource: false toFile: 0.	fileStream trailer; close! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'yo 10/15/2003 17:10'!printMethodChunkHistorically: selector on: outStream moveSource: moveSource toFile: fileIndex	"Copy all source codes historically for the method associated with selector onto the 	fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method newPos sourceFile endPos category changeList prior |	category _ self organization categoryOfElement: selector.	preamble _ self name , ' methodsFor: ', category asString printString.	method _ self methodDict at: selector.	((method fileIndex = 0	or: [(SourceFiles at: method fileIndex) == nil])	or: [method filePosition = 0])	ifTrue: [		outStream cr; nextPut: $!!; nextChunkPut: preamble; cr.		outStream nextChunkPut: (			self decompilerClass new 				decompile: selector in: self method: method) decompileString.		outStream nextChunkPut: ' '; cr]	ifFalse: [		changeList _ (VersionsBrowser new 			scanVersionsOf: method 			class: self 			meta: self isMeta			category: category 			selector: selector) changeList.		newPos _ nil.		sourceFile _ SourceFiles at: method fileIndex.		changeList reverseDo: [ :chgRec |			chgRec fileIndex = fileIndex ifTrue: [				outStream copyPreamble: preamble from: sourceFile at: chgRec position.				(prior _ chgRec prior) ifNotNil: [					outStream position: outStream position - 2.					outStream nextPutAll: ' prior: ', (						prior first = method fileIndex ifFalse: [prior third] ifTrue: [							SourceFiles 								sourcePointerFromFileIndex: method fileIndex 								andPosition: newPos]) printString.					outStream nextPut: $!!; cr].				"Copy the method chunk"				newPos _ outStream position.				outStream copyMethodChunkFrom: sourceFile at: chgRec position.				sourceFile skipSeparators.      "The following chunk may have ]style["				sourceFile peek == $] ifTrue: [					outStream cr; copyMethodChunkFrom: sourceFile].				outStream nextChunkPut: ' '; cr]].		moveSource ifTrue: [			endPos _ outStream position.			method checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	^ outStream! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sumim 9/2/2003 14:37'!moveChangesWithVersionsTo: newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| changes |	changes _ self methodDict keys select: [:sel | (self methodDict at: sel) fileIndex > 1].	self fileOutChangedMessagesHistorically: changes		on: newFile		moveSource: true		toFile: 2! !!ObjectScanner methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 10:27'!lookAhead: aChunk	"See if this chunk is a class Definition, and if the new class name already exists and is instance-specific.  Modify the chunk, and record the rename in the SmartRefStream and in me."	| pieces sup oldName existing newName newDefn |	aChunk size < 90 ifTrue: [^ aChunk].		"class defn is big!!"	(aChunk at: 1) == $!! ifTrue: [^ aChunk].	"method def, fast exit"	pieces _ (aChunk copyFrom: 1 to: (300 min: aChunk size)) findTokens: ' #	\' withCRs.	pieces size < 3 ifTrue: [^ aChunk].	"really bigger, but just took front"	(pieces at: 2) = 'subclass:' ifFalse: [^ aChunk].	sup _ Smalltalk at: (pieces at: 1) asSymbol ifAbsent: [^ aChunk].	sup class class == Metaclass ifFalse: [^ aChunk].	((oldName _ pieces at: 3) at: 1) canBeGlobalVarInitial ifFalse: [^ aChunk].	oldName _ oldName asSymbol.	(Smalltalk includesKey: oldName) ifFalse: [^ aChunk].	"no conflict"	existing _ Smalltalk at: oldName.	(existing isKindOf: Class) ifFalse: [^ aChunk].	"Write over non-class global"	existing isSystemDefined ifTrue: [^ aChunk].	"Go ahead and redefine it!!"	"Is a UniClass"	newName _ sup chooseUniqueClassName.	newDefn _ aChunk copyReplaceAll: oldName with: newName.	Compiler evaluate: newDefn for: self logged: true.	"Create the new class"	self rename: oldName toBe: newName.	^ newName asString		"to be evaluated"! !!HandMorph methodsFor: 'private events' stamp: 'yo 7/25/2003 16:56'!generateKeyboardEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	| buttons modifiers type pressType stamp char |	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	pressType := evtBuf fourth.	pressType = EventKeyDown ifTrue: [type := #keyDown].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [type := #keystroke].	modifiers := evtBuf fifth.	buttons := modifiers bitShift: 3.	char _ self keyboardInterpreter nextCharFrom: Sensor firstEvt: evtBuf.	^ KeyboardEvent new		setType: type		buttons: buttons		position: self position		keyValue: char asciiValue		hand: self		stamp: stamp.! !!HandMorph methodsFor: 'multilingual' stamp: 'yo 9/26/2003 22:11'!clearKeyboardInterpreter	keyboardInterpreter _ nil.! !!HandMorph methodsFor: 'multilingual' stamp: 'yo 9/26/2003 11:51'!keyboardInterpreter	keyboardInterpreter ifNil: [keyboardInterpreter _ Smalltalk systemLanguage defaultInputInterpreter].	^ keyboardInterpreter.! !!HandMorph methodsFor: 'focus handling' stamp: 'yo 11/7/2002 19:10'!compositionWindowManager	^ self class compositionWindowManager.! !!HandMorph methodsFor: 'focus handling' stamp: 'yo 11/7/2002 19:11'!newKeyboardFocus: aMorphOrNil	"Make the given morph the new keyboard focus, canceling the previous keyboard focus if any. If the argument is nil, the current keyboard focus is cancelled."	| oldFocus |	oldFocus _ self keyboardFocus.	self keyboardFocus: aMorphOrNil.	oldFocus ifNotNil: [oldFocus == aMorphOrNil ifFalse: [oldFocus keyboardFocusChange: false]].	aMorphOrNil ifNotNil: [aMorphOrNil keyboardFocusChange: true. self compositionWindowManager keyboardFocusForAMorph: aMorphOrNil].! !!HandMorph class methodsFor: 'accessing' stamp: 'yo 11/24/2003 06:23'!compositionWindowManager	CompositionWindowManager ifNotNil: [^ CompositionWindowManager].	(Smalltalk platformName = 'Win32') ifTrue: [		^ CompositionWindowManager _ ImmWin32 new.	].	((Smalltalk platformName = 'unix') and: [(Smalltalk getSystemAttribute: 1005) = 'X11']) ifTrue: [		^ CompositionWindowManager _ ImmX11 new.	].	^ CompositionWindowManager _ ImmAbstractPlatform new.! !!HandMorph class methodsFor: 'initialization' stamp: 'yo 8/13/2003 15:45'!clearInterpreters	self allInstances do: [:each | each clearKeyboardInterpreter].! !!HandMorph class methodsFor: 'initialization' stamp: 'yo 8/13/2003 15:49'!startUp	self clearCompositionWindowManager.	self clearInterpreters.! !!HandMorph class methodsFor: 'initialization' stamp: 'yo 8/13/2003 15:49'!clearCompositionWindowManager	CompositionWindowManager _ nil.! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'yo 11/7/2002 18:44'!mouseUp: evt	super mouseUp: evt.	self stopSteppingSelector: #autoScrollView:.	editView scrollSelectionIntoView: evt.	self setCompositionWindow.! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'yo 11/7/2002 18:55'!prefereredKeyboardPosition	| pos |	pos _ super prefereredKeyboardPosition.	^ pos + (self bounds: self bounds in: World) topLeft.! !!Number class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 22:41'!readFrom: stringOrStream base: base	"Answer a number as described on aStream in the given number base."	| aStream sign |	aStream _ (stringOrStream isString)		ifTrue: [ReadStream on: stringOrStream]		ifFalse: [stringOrStream].	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].	^ self readRemainderOf: (Integer readFrom: aStream base: base)			from: aStream base: base withSign: sign! !!Number class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 22:40'!readFrom: stringOrStream 	"Answer a number as described on aStream.  The number may	include a leading radix specification, as in 16rFADE"	| value base aStream sign |	aStream _ (stringOrStream isString)		ifTrue: [ReadStream on: stringOrStream]		ifFalse: [stringOrStream].	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].	base _ 10.	value _ Integer readFrom: aStream base: base.	(aStream peekFor: $r)		ifTrue: 			["<base>r<integer>"			(base _ value) < 2 ifTrue: [^self error: 'Invalid radix'].			(aStream peekFor: $-) ifTrue: [sign _ sign negated].			value _ Integer readFrom: aStream base: base].	^ self readRemainderOf: value from: aStream base: base withSign: sign.! !!ImmWin32 methodsFor: 'all' stamp: 'yo 11/30/2003 16:06'!keyboardFocusForAMorph: aMorph	| left top pos |	aMorph ifNil: [^ self].	[		pos _ aMorph prefereredKeyboardPosition.		left _ (pos x min: Display width max: 0) asInteger.		top _ (pos y min: Display height max: 0) asInteger.		self setCompositionWindowPositionX: left y: top	] on: Error	do: [:ex |].! !!ImmWin32 methodsFor: 'as yet unclassified' stamp: 'yo 11/7/2002 16:47'!setCompositionWindowPositionX: x y: y	<primitive: 'primSetCompositionWindowPosition' module: 'ImmWin32Plugin'>	^ nil! !!ImmX11 methodsFor: 'as yet unclassified' stamp: 'yo 11/24/2003 06:21'!keyboardFocusForAMorph: aMorph	| left top pos |	aMorph ifNil: [^ self].	[		pos _ aMorph prefereredKeyboardPosition.		left _ (pos x min: Display width max: 0) asInteger.		top _ (pos y min: Display height max: 0) asInteger			 + (aMorph textStyle lineGrid).		self setCompositionWindowPositionX: left y: top	] on: Error	do: [:ex |].! !!ImmX11 methodsFor: 'as yet unclassified' stamp: 'Tsutomu Hiroshima 11/8/2003 08:46'!setCompositionWindowPositionX: x y: y	<primitive: 'primSetCompositionWindowPosition' module: 'ImmX11Plugin'>	^ nil! !!Scanner methodsFor: 'multi-character scans' stamp: 'yo 8/28/2002 17:33'!xLetter	"Form a word or keyword."	| type c |	buffer reset.	[c _ hereChar asciiValue.	(type _ typeTable at: c ifAbsent: [#xLetter]) == #xLetter or: [type == #xDigit]]		whileTrue: ["open code step for speed"			buffer nextPut: hereChar.			hereChar _ aheadChar.			source atEnd				ifTrue: [aheadChar _ 30 asCharacter					"doit"]				ifFalse: [aheadChar _ source next]].	(type == #colon or: [type == #xColon and: [aheadChar ~= $=]])		ifTrue: [buffer nextPut: self step.			["Allow any number of embedded colons in literal symbols"			(typeTable at: hereChar asciiValue ifAbsent: [#xLetter])				== #xColon]				whileTrue: [buffer nextPut: self step].			tokenType _ #keyword]		ifFalse: [tokenType _ #word].	token _ buffer contents.	token isOctetString ifTrue: [token _ token asOctetString].! !!Scanner methodsFor: 'multi-character scans' stamp: 'yo 8/28/2002 17:43'!xSingleQuote	"String."	self step.	buffer reset.	[hereChar = $' and: [aheadChar = $' ifTrue: [self step. false] ifFalse: [true]]] whileFalse: [		buffer nextPut: self step.		(hereChar = 30 asCharacter and: [source atEnd])			ifTrue: [^self offEnd: 'Unmatched string quote']].	self step.	token _ buffer contents.	token isOctetString ifTrue: [token _ token asOctetString].	tokenType _ #string.! !!Scanner methodsFor: 'multi-character scans' stamp: 'yo 8/28/2002 17:46'!xLitQuote	"Symbols and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse: #'abc'."	| start |	start _ mark.	self step. "litQuote"	self scanToken.	tokenType = #leftParenthesis		ifTrue: 			[self scanToken; scanLitVec.			mark _ start+1.			tokenType == #doIt				ifTrue: [self offEnd: 'Unmatched parenthesis']]		ifFalse: 			[(#(word keyword colon ) includes: tokenType) 				ifTrue:					[self scanLitWord]				ifFalse:					[(tokenType==#literal)						ifTrue:							[((token isMemberOf: Symbol) or: [token isMemberOf: MultiSymbol])								ifTrue: "##word"									[token _ token "May want to move toward ANSI here"]]						ifFalse:							[tokenType==#string ifTrue: [token _ token asSymbol]]]].	mark _ start.	tokenType _ #literal"	#(Pen)	#Pen	#'Pen'	##Pen	###Pen"! !!Scanner methodsFor: 'expression types' stamp: 'yo 8/28/2002 17:52'!scanLitWord	"Accumulate keywords and asSymbol the result."	| t |	[(typeTable at: hereChar asciiValue ifAbsent: [#xLetter]) = #xLetter] whileTrue: [		t _ token.		self xLetter.		token _ t , token	].	token _ token asSymbol.! !!Scanner methodsFor: 'expression types' stamp: 'yo 8/28/2002 22:21'!scanToken	[(tokenType _ typeTable at: hereChar asciiValue ifAbsent: [#xLetter]) == #xDelimiter]		whileTrue: [self step].  "Skip delimiters fast, there almost always is one."	mark _ source position - 1.	(tokenType at: 1) = $x "x as first letter"		ifTrue: [self perform: tokenType "means perform to compute token & type"]		ifFalse: [token _ self step asSymbol "else just unique the first char"].	^ token.! !!Scanner methodsFor: 'expression types' stamp: 'yo 8/28/2002 17:51'!scanLitVec 	| s |	s _ WriteStream on: (Array new: 16).	[tokenType = #rightParenthesis or: [tokenType = #doIt]] whileFalse: [		tokenType = #leftParenthesis ifTrue: [			self scanToken; scanLitVec		] ifFalse: [			tokenType = #word | (tokenType = #keyword) | (tokenType = #colon) ifTrue: [				self scanLitWord			] ifFalse: [				(token == #- and: [					(typeTable at: hereChar asciiValue ifAbsent: [#xLetter]) = #xDigit]) ifTrue: [						self scanToken.						token _ token negated]]].		s nextPut: token.		self scanToken].	token _ s contents.! !!Scanner methodsFor: 'error handling' stamp: 'yo 8/28/2002 17:43'!errorMultibyteCharacter	self error: 'multi-byte character is found at unexpected place'.! !!Scanner methodsFor: 'multi-character scans' stamp: 'yo 8/28/2002 17:40'!xBinary	tokenType _ #binary.	token _ self step asSymbol.	[| type | 	type _ typeTable at: hereChar asciiValue ifAbsent: [#xLetter].	type == #xBinary and: [hereChar ~= $-]] whileTrue: [		token _ (token, (String with: self step)) asSymbol].! !!Scanner methodsFor: 'multi-character scans' stamp: 'yo 8/28/2002 17:31'!xDoubleQuote    "Collect a comment."    "wod 1/10/98: Allow 'empty' comments by testing the first characterfor $"" rather than blindly adding it to the comment being collected."    | aStream stopChar |    stopChar _ 30 asCharacter.    aStream _ WriteStream on: (String new: 200).    self step.    [hereChar = $"]        whileFalse:            [(hereChar = stopChar and: [source atEnd])                ifTrue: [^self offEnd: 'Unmatched comment quote'].            aStream nextPut: self step.].    self step.    currentComment == nil        ifTrue: [currentComment _ OrderedCollection with: aStreamcontents]        ifFalse: [currentComment add: aStream contents].    self scanToken.! !!Scanner class methodsFor: 'testing' stamp: 'yo 8/30/2002 15:00'!isLiteralMultiSymbol: aMultiSymbol	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type |	i _ aMultiSymbol size.	i = 0 ifTrue: [^ false].	i = 1 ifTrue: [('$''"()#0123456789' includes: (aMultiSymbol at: 1))		ifTrue: [^ false] ifFalse: [^ true]].	ascii _ (aMultiSymbol at: 1) asciiValue.	"TypeTable should have been origined at 0 rather than 1 ..."	(ascii = 0			or: [ascii > 255])		ifTrue: [^ false].	type _ TypeTable at: ascii.	(type == #xColon or: [type == #verticalBar]) ifTrue: [^ i = 1].	type == #xBinary ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aMultiSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					(TypeTable at: ascii) == #xBinary ifFalse: [^ false].					i _ i - 1].			^ true].	type == #xLetter ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aMultiSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					type _ TypeTable at: ascii ifAbsent: [#xLetter].					(type == #xLetter or: [type == #xDigit or: [type == #xColon]])						ifFalse: [^ false].					i _ i - 1].			^ true].	^ false! !!DirectoryEntry methodsFor: 'multilingual system' stamp: 'yo 11/5/2002 14:02'!convertFromSystemName	name isString ifTrue: [name _ name convertFromSystemString].! !!ResourceCollector methodsFor: 'resource writing' stamp: 'yo 11/13/2002 23:30'!writeResourceForm: aForm fromLocator: aLocator	"The given form has been externalized before. If it was reasonably compressed, use the bits of the original data - this allows us to recycle GIF, JPEG, PNG etc. data without using the internal compression (which is in most cases inferior). If necessary the data will be retrieved from its URL location. This retrieval is done only if the resouce comes from either		* the local disk (in which case the file has never been published)		* the browser cache (in which case we don't cache the resource locally)	In any other case we will *not* attempt to retrieve it, because doing so can cause the system to connect to the network which is probably not what we want. It should be a rare case anyways; could only happen if one clears the squeak cache selectively."	| fName fStream url data |	"Try to be smart about the name of the file"	fName _ (aLocator urlString includes: $:)		ifTrue: [			url _ aLocator urlString asUrl.			url path last]		ifFalse: [aLocator urlString].	fName isEmptyOrNil ifFalse:[fName _ fName asFileName].	(fName isEmptyOrNil or:[localDirectory isAFileNamed: fName]) ifTrue:[		"bad luck -- duplicate name"		fName _ localDirectory 				nextNameFor:'resource' 				extension: (FileDirectory extensionFor: aLocator urlString)].	"Let's see if we have cached it locally"	ResourceManager		lookupCachedResource: self baseUrl , aLocator urlString		ifPresentDo:[:stream | data _ stream upToEnd].	"Check if the cache entry is without qualifying baseUrl. Workaround for older versions."	data ifNil:[		ResourceManager			lookupCachedResource: aLocator urlString			ifPresentDo:[:stream | data _ stream upToEnd]].	data ifNil:[		"We don't have it cached locally. Retrieve it from its original location."		((url notNil and: [url hasRemoteContents]) and:[HTTPClient isRunningInBrowser not])			ifTrue:[^nil]. "see note above"		(Url schemeNameForString: aLocator urlString)			ifNil: [^nil].		data _ HTTPLoader default retrieveContentsFor: aLocator urlString.		data ifNil:[^nil].		data _ data content.	].	"data size > aForm bits byteSize ifTrue:[^nil]."	fStream _ localDirectory newFileNamed: fName.	fStream binary.	fStream nextPutAll: data.	fStream close.	^{fName. data size}! !!JapaneseEnvironment class methodsFor: 'language methods' stamp: 'yo 8/14/2003 15:40'!beCurrentNaturalLanguage	super beCurrentNaturalLanguage.	Preferences restoreDefaultFontsForJapanese.! !!JapaneseEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 12/1/2003 14:25'!setClipboardInterpreterClass	| platformName osVersion |	platformName _ Smalltalk platformName.	osVersion _ Smalltalk getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE'])		ifTrue: [clipboardInterpreter _ NoConversionClipboardInterpreter. ^ self].	platformName = 'Win32'		ifTrue: [clipboardInterpreter _ WinShiftJISClipboardInterpreter. ^ self].	platformName = 'Mac OS'		ifTrue: [clipboardInterpreter _ MacShiftJISClipboardInterpreter. ^ self].	((platformName = 'unix') and: [(Smalltalk getSystemAttribute: 1005) = 'X11'])		ifTrue: [clipboardInterpreter _ UnixEUCJPClipboardInterpreter. ^ self].	clipboardInterpreter _ NoConversionClipboardInterpreter.! !!JapaneseEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 4/2/2003 07:32'!defaultEncodingName	| platformName osVersion |	platformName _ Smalltalk platformName.	osVersion _ Smalltalk getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) ifTrue: [^ 'utf-8' copy].	(#('Win32' 'Mac OS' 'ZaurusOS') includes: platformName) ifTrue: [^ 'shift-jis' copy].	(#('unix') includes: platformName) ifTrue: [^ 'euc-jp' copy].	^ nil! !!JapaneseEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/5/2003 22:38'!charsetClass	^ UnicodeJapanese.! !!JapaneseEnvironment class methodsFor: 'language methods' stamp: 'yo 11/12/2002 11:09'!removeFonts! !!JapaneseEnvironment class methodsFor: 'language methods' stamp: 'yo 10/4/2003 16:04'!flapTabTextFor: aString in: aFlapTab	^ aString.! !!JapaneseEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 11/24/2003 06:24'!defaultInputInterpreter	| platformName osVersion |	platformName _ Smalltalk platformName.	osVersion _ Smalltalk getSystemAttribute: 1002.	(platformName = 'Win32' and: [osVersion = 'CE']) ifTrue: [^ NoInputInterpreter new].	platformName = 'Win32' ifTrue: [^ WinShiftJISInputInterpreter new].	platformName = 'Mac OS'		ifTrue: [('10*' match: Smalltalk osVersion)				ifTrue: [^ MacUnicodeInputInterpreter new]				ifFalse: [^ MacShiftJISInputInterpreter new]].	((platformName = 'unix') and: [(Smalltalk getSystemAttribute: 1005) = 'X11']) ifTrue: [		^ UnixEUCJPInputInterpreter new].	^ NoInputInterpreter new.! !!Integer methodsFor: 'converting' stamp: 'yo 8/30/2002 16:32'!asCharacter	"Answer the Character whose value is the receiver."	self > 255		ifTrue: [^ MultiCharacter value: self]		ifFalse: [^ Character value: self]! !!InputSensor methodsFor: 'keyboard' stamp: 'yo 8/18/2003 23:36'!keyboard	"Answer the next character from the keyboard."	| firstCharacter secondCharactor stream multiCharacter converter |	firstCharacter _ self characterForKeycode: self primKbdNext.	secondCharactor _ self characterForKeycode: self primKbdPeek.	secondCharactor isNil		ifTrue: [^ firstCharacter].	converter _ TextConverter defaultSystemConverter.	converter isNil		ifTrue: [^ firstCharacter].	stream _ ReadStream				on: (String with: firstCharacter with: secondCharactor).	multiCharacter _ converter nextFromStream: stream.	multiCharacter isOctetCharacter		ifTrue: [^ multiCharacter].	self primKbdNext.	^ multiCharacter! !!Clipboard methodsFor: 'accessing' stamp: 'yo 9/26/2003 11:51'!setInterpreter	interpreter _ Smalltalk systemLanguage defaultClipboardInterpreter.	interpreter ifNil: [interpreter _ NoConversionClipboardInterpreter new].! !!Clipboard methodsFor: 'accessing' stamp: 'yo 8/11/2003 19:04'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| string decodedString |	string _ self primitiveClipboardText.	(string isEmpty			or: [string = contents asString])		ifTrue: [^ contents].	decodedString _ self interpreter fromSystemClipboard: string.	^ decodedString = contents asString		ifTrue: [contents]		ifFalse: [decodedString asText].! !!Clipboard methodsFor: 'accessing' stamp: 'yo 8/11/2003 19:12'!clipboardText: text 	| string |	string _ text asString.	self noteRecentClipping: text asText.	contents _ text asText.	string _ self interpreter toSystemClipboard: string.	self primitiveClipboardText: string.! !!Clipboard methodsFor: 'accessing' stamp: 'yo 8/11/2003 19:07'!clearInterpreter	interpreter _ nil.! !!Clipboard methodsFor: 'accessing' stamp: 'yo 8/11/2003 18:23'!interpreter	interpreter ifNil: [self setInterpreter].	^ interpreter.! !!Clipboard class methodsFor: 'class initialization' stamp: 'yo 8/11/2003 22:43'!clearInterpreters	self allInstances do: [:each | each clearInterpreter].! !!StandardFileStream methodsFor: 'open/close' stamp: 'yo 10/14/2003 16:19'!open: fileName forWrite: writeMode 	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	"Changed to do a GC and retry before failing ar 3/21/98 17:25"	| f |	f _ fileName.	(fileName isKindOf: MultiString) ifTrue: [		fileName isOctetString ifTrue: [			f _ fileName asOctetString.		] ifFalse: [			f _ fileName convertToSystemString.		].	].	fileID _ StandardFileStream retryWithGC:[self primOpen: f writable: writeMode] 					until:[:id| id notNil] 					forFileNamed: fileName.	fileID ifNil: [^ nil].  "allows sender to detect failure"	self register.	name _ fileName.	rwmode _ writeMode.	buffer1 _ String new: 1.! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'yo 10/31/2002 22:33'!readOnlyCopy	^ self class readOnlyFileNamed: self name.! !!FileList methodsFor: 'file list menu' stamp: 'ka 8/3/2001 21:12'!compressFile	"Compress the currently selected file"	| f |	f _ StandardFileStream				readOnlyFileNamed: (directory fullNameFor: self fullName).	f compressFile.	self updateFileList! !!FileList methodsFor: 'own services' stamp: 'yo 3/31/2003 11:24'!serviceGetEncodedText	^  (SimpleServiceEntry 			provider: self 			label: 'view as encoded text'			selector: #getEncodedText			description: 'view as encoded text')! !!FileList methodsFor: 'private' stamp: 'mu 8/22/2003 01:46'!selectEncoding	| aMenu encodingItems |	aMenu _ CustomMenu new.	encodingItems _ OrderedCollection new.	TextConverter allSubclasses do: [:each | | names |		names _ each encodingNames.		names notEmpty ifTrue: [ | label |			label _ '' writeStream.			names do: [:eachName | label nextPutAll: eachName ] separatedBy: [ label nextPutAll: ', '].			encodingItems add: {label contents. names first asSymbol}.		].	].	aMenu addList: encodingItems.	brevityState _ aMenu startUp.	brevityState ifNil: [brevityState _ #needToGetBrief].! !!FileList methodsFor: 'private' stamp: 'yo 8/13/2003 13:59'!readContentsAsEncoding: encodingName	| f writeStream converter |	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream _ WriteStream on: String new.	converter _ TextConverter defaultConverterClassForEncoding: encodingName.	converter ifNil: [^ 'This encoding is not supported'].	f converter: converter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!FileList methodsFor: 'file menu action' stamp: 'yo 3/31/2003 11:25'!getEncodedText	Cursor read showWhile: [		self selectEncoding.		self changed: #contents].! !!FileList methodsFor: 'private' stamp: 'ka 8/24/2000 18:56'!readContentsEUCKR	| f writeStream |	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream _ WriteStream on: String new.	f converter: EUCKRTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!FileList methodsFor: 'private' stamp: 'ka 8/24/2000 18:31'!readContentsEUCJP	| f writeStream |	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream _ WriteStream on: String new.	f converter: EUCJPTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!FileList methodsFor: 'private' stamp: 'mu 8/22/2003 01:32'!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	(TextConverter allEncodingStates includes: brevityState) 		ifTrue: [ ^self readContentsAsEncoding: brevityState].	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'private' stamp: 'ka 8/24/2000 18:55'!readContentsCNGB	| f writeStream |	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream _ WriteStream on: String new.	f converter: CNGBTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!FileList methodsFor: 'file list menu' stamp: 'yo 11/14/2002 15:04'!openMorphFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved	via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ (MultiByteBinaryOrTextStream with: ((FileStream readOnlyFileNamed: self fullName) binary contentsOfEntireFile)) binary reset.	morphOrList _ aFileStream fileInObjectAndCode.	(morphOrList isKindOf: SqueakPage) ifTrue: [morphOrList _ morphOrList contentsMorph].	Smalltalk isMorphic		ifTrue: [ActiveWorld addMorphsAndModel: morphOrList]		ifFalse:			[morphOrList isMorph ifFalse: [^ self errorMustBeMorph].			morphOrList openInWorld]! !!FileList methodsFor: 'file list menu' stamp: 'yo 3/31/2003 11:30'!fileContentsMenu: aMenu shifted: shifted	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| shiftMenu services maybeLine extraLines |	shifted ifTrue:		[shiftMenu _ ParagraphEditor shiftedYellowButtonMenu.		^ aMenu 			labels: shiftMenu labelString 			lines: shiftMenu lineArray			selections: shiftMenu selections].	fileName ifNotNil:		[services _ OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue:			[services add: self serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse:			[services add: self serviceGetHex].		(#(needToGetShiftJIS needToGetEUCJP needToGetCNGB needToGetEUCKR needToGetUTF8) includes: brevityState) ifFalse:			[services add: self serviceGetEncodedText].		maybeLine _ services size.		(#('st' 'cs') includes: self suffixOfSelectedFile) ifTrue:			[services addAll:				(self servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines _ OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: self fullName			extraLines: extraLines].	aMenu addList: #( 			('find...(f)'				find)			('find again (g)'		findAgain)			('set search string (h)'	setSearchString)			-			('do again (j)'			again)			('undo (z)'				undo)			-			('copy (c)'				copySelection)			('cut (x)'				cut)			('paste (v)'				paste)			('paste...'				pasteRecent)			-			('do it (d)'				doIt)			('print it (p)'			printIt)			('inspect it (i)'			inspectIt)			('fileIn selection (G)'	fileItIn)			-			('accept (s)'				accept)			('cancel (l)'				cancel)			-			('more...'				shiftedYellowButtonActivity)).	^ aMenu! !!FileList methodsFor: 'private' stamp: 'ka 8/26/2000 18:48'!readContentsShiftJIS	| f writeStream |	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream _ WriteStream on: String new.	f converter: ShiftJISTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!FileList methodsFor: 'private' stamp: 'ka 6/23/2002 15:55'!readContentsUTF8	| f writeStream |	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream _ WriteStream on: String new.	f converter: UTF8TextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!FileList methodsFor: 'private' stamp: 'ka 4/21/2001 01:16'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f _ directory oldFileOrNoneNamed: self fullName. 	f == nil ifTrue: [^ 'For some reason, this file cannot be read'].	f binary.	((size _ f size)) > 5000 & brevity		ifTrue: [data _ f next: 10000. f close. brevityState _ #briefHex]		ifFalse: [data _ f contentsOfEntireFile. brevityState _ #fullHex].	s _ WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (Character value: (data at: i)) hex; space].		s cr].	hexData _ s contents.	^ contents _ ((size > 5000) & brevity		ifTrue: ['File ''', fileName, ''' is ', size printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', hexData , '------------------------------------------... end of the first 5000 characters.']		ifFalse: [hexData]).! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'yo 11/5/2002 16:56'!refreshLocalFileHeaderTo: aStream	"Re-writes my local header to the given stream.	To be called after writing the data stream.	Assumes that fileName and localExtraField sizes didn't change since last written."	| here systemFileName |	here _ aStream position.	systemFileName _ fileName convertToSystemString.	aStream position: writeLocalHeaderRelativeOffset.	aStream nextPutAll: LocalFileHeaderSignature.	aStream nextLittleEndianNumber: 2 put: versionNeededToExtract.	aStream nextLittleEndianNumber: 2 put: bitFlag.	aStream nextLittleEndianNumber: 2 put: desiredCompressionMethod.	aStream nextLittleEndianNumber: 4 put: lastModFileDateTime.	aStream nextLittleEndianNumber: 4 put: crc32.	aStream nextLittleEndianNumber: 4 put: (desiredCompressionMethod = CompressionStored												ifTrue: [ uncompressedSize ] ifFalse: [ compressedSize ]).	aStream nextLittleEndianNumber: 4 put: uncompressedSize.	aStream nextLittleEndianNumber: 2 put: systemFileName size.	aStream nextLittleEndianNumber: 2 put: localExtraField size.	aStream position: here.! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'yo 11/23/2003 19:01'!centralDirectoryHeaderSize	| systemFileName systemFileComment systemCdExtraField |	systemFileName _ fileName convertToSystemString.	systemFileComment _ fileComment convertToSystemString.	systemCdExtraField _ cdExtraField.	^ 46 + systemFileName size + systemCdExtraField size + systemFileComment size! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'yo 11/23/2003 18:59'!writeCentralDirectoryFileHeaderTo: aStream	"C2 v3 V4 v5 V2"	| systemFileName systemFileComment systemCdExtraField |	systemFileName _ fileName convertToSystemString.	systemFileComment _ fileComment convertToSystemString.	systemCdExtraField _ cdExtraField.	aStream nextPutAll: CentralDirectoryFileHeaderSignature.	aStream nextLittleEndianNumber: 1 put: versionMadeBy.	aStream nextLittleEndianNumber: 1 put: fileAttributeFormat.	aStream nextLittleEndianNumber: 2 put: versionNeededToExtract.	aStream nextLittleEndianNumber: 2 put: bitFlag.	aStream nextLittleEndianNumber: 2 put: desiredCompressionMethod.	aStream nextLittleEndianNumber: 4 put: lastModFileDateTime.	"These next 3 should have been updated during the write of the data"	aStream nextLittleEndianNumber: 4 put: crc32.	aStream nextLittleEndianNumber: 4 put: (desiredCompressionMethod = CompressionStored												ifTrue: [ uncompressedSize ] ifFalse: [ compressedSize ]).	aStream nextLittleEndianNumber: 4 put: uncompressedSize.	aStream nextLittleEndianNumber: 2 put: systemFileName size.	aStream nextLittleEndianNumber: 2 put: systemCdExtraField size.	aStream nextLittleEndianNumber: 2 put: systemFileComment size.	aStream nextLittleEndianNumber: 2 put: 0.		"diskNumberStart"	aStream nextLittleEndianNumber: 2 put: internalFileAttributes.	aStream nextLittleEndianNumber: 4 put: externalFileAttributes.	aStream nextLittleEndianNumber: 4 put: writeLocalHeaderRelativeOffset.	aStream nextPutAll: systemFileName asByteArray.	aStream nextPutAll: systemCdExtraField asByteArray.	aStream nextPutAll: systemFileComment asByteArray.! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'yo 4/2/2003 06:54'!contentStream	"Answer my contents as a string."	| s |	s _ MultiByteBinaryOrTextStream on: (String new: self uncompressedSize).	self extractTo: s.	^s reset! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'yo 11/5/2002 16:57'!writeLocalFileHeaderTo: aStream	"Write my local header to a file handle.	Stores the offset to the start of the header in my	writeLocalHeaderRelativeOffset member."	| systemFileName |	systemFileName _ fileName convertToSystemString.	aStream nextPutAll: LocalFileHeaderSignature.	aStream nextLittleEndianNumber: 2 put: versionNeededToExtract.	aStream nextLittleEndianNumber: 2 put: bitFlag.	aStream nextLittleEndianNumber: 2 put: desiredCompressionMethod.	aStream nextLittleEndianNumber: 4 put: lastModFileDateTime.	aStream nextLittleEndianNumber: 4 put: crc32.	aStream nextLittleEndianNumber: 4 put: (desiredCompressionMethod = CompressionStored												ifTrue: [ uncompressedSize ] ifFalse: [ compressedSize ]).	aStream nextLittleEndianNumber: 4 put: uncompressedSize.	aStream nextLittleEndianNumber: 2 put: systemFileName size.	aStream nextLittleEndianNumber: 2 put: localExtraField size.	aStream nextPutAll: systemFileName asByteArray.	aStream nextPutAll: localExtraField asByteArray.! !!SoundTile methodsFor: 'user interface' stamp: 'ka 5/11/2002 21:18'!mouseStillDown: evt	"See if arrows are being pressed and call arrowAction:..."	| aPoint |	self flag: #arNote. "Fix 'significant' events below"	upArrow ifNotNil:		[aPoint _ evt cursorPoint.		(upArrow containsPoint: aPoint) ifTrue:			[self abandonLabelFocus.			self variableDelay:				[self arrowAction: self arrowDelta].			^ evt "hand noteSignificantEvent: evt"].		(downArrow containsPoint: aPoint) ifTrue:			[self abandonLabelFocus.			self variableDelay:				[self arrowAction: self arrowDelta negated].			^ evt "hand noteSignificantEvent: evt"]].	self eventHandler ifNotNil:		[self eventHandler mouseStillDown: evt fromMorph: self]! !!XTableForFixedFont methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 16:15'!width: anInteger	width _ anInteger.! !!XTableForFixedFont methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 16:14'!at: anInteger	(anInteger < 1 or: [maxCode + 2 < anInteger]) ifTrue: [		self error: 'subscript out of bounds'.	].	^(anInteger - 1) * width.! !!XTableForFixedFont methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 16:14'!maxAscii: anInteger	maxCode _ anInteger.! !!XTableForFixedFont methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 16:15'!width	^ width.! !!XTableForFixedFont methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 16:14'!maxCode	^ maxCode.! !!XTableForFixedFont methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 16:14'!size	^ maxCode.! !!Project methodsFor: 'language' stamp: 'yo 11/4/2002 21:48'!naturalLanguage	"Answer the natural language for the project"	^ self projectParameterAt: #naturalLanguage		ifAbsentPut: [			self previousProject projectParameterAt: #naturalLanguage ifAbsent: [#EnglishEnvironment]]! !!Project methodsFor: 'language' stamp: 'sumim 12/1/2003 23:41'!setNaturalLanguageTo: aLanguageSymbol	"Set the project's natural language as indicated"	| className |	Vocabulary assureTranslationsAvailableFor: aLanguageSymbol.	aLanguageSymbol = self naturalLanguage ifFalse: [		self projectParameterAt: #naturalLanguage put: aLanguageSymbol.		ActiveWorld allTileScriptingElements do: [:viewerOrScriptor |			viewerOrScriptor setNaturalLanguageTo: aLanguageSymbol]].	className _ Vocabulary languageClassNameForLanguageSymbol: aLanguageSymbol.	(Smalltalk at: className ifAbsent: [EnglishEnvironment]) beCurrentNaturalLanguage.	Smalltalk primaryLanguage: className.	Smalltalk systemLanguage: className.	#(PartsBin ParagraphEditor BitEditor FormEditor StandardSystemController) 		do: [ :key | Smalltalk at: key ifPresent: [ :class | class initialize ]].	self setFlaps.	self setPaletteFor: aLanguageSymbol.! !!Project methodsFor: 'language' stamp: 'yo 8/11/2003 16:46'!setPaletteFor: aLanguageSymbol 	| prototype formKey form |	prototype _ PaintBoxMorph prototype.	formKey _ ('offPalette' , aLanguageSymbol) asSymbol.	form _ Imports default imports				at: formKey				ifAbsent: [Imports default imports						at: #offPaletteEnglish						ifAbsent: []].	form isNil ifFalse: [prototype loadOffForm: form].	formKey _ ('pressedPalette' , aLanguageSymbol) asSymbol.	form _ Imports default imports				at: formKey				ifAbsent: [Imports default imports						at: #pressedPaletteEnglish						ifAbsent: []].	form isNil ifFalse: [prototype loadPressedForm: form].! !!Project methodsFor: 'file in/out' stamp: 'yo 11/7/2002 11:50'!writeFileNamed: localFileName fromDirectory: localDirectory toServer: primaryServerDirectory	| local resp gifFileName f |	local _ localDirectory oldFileNamed: localFileName.	resp _ primaryServerDirectory upLoadProject: local named: localFileName resourceUrl: self resourceUrl retry: false.	local close.	resp == true ifFalse: [		"abandon resources that would've been stored with the project"		self resourceManager abandonResourcesThat:			[:loc| loc urlString beginsWith: self resourceUrl].		self inform: 'the primary server of this project seems to be down (',							resp printString,')'. 		^ self	].	gifFileName _ self name,'.gif'.	localDirectory deleteFileNamed: gifFileName ifAbsent: [].	local _ localDirectory fileNamed: gifFileName.	thumbnail ifNil: [		(thumbnail _ Form extent: 100@80) fillColor: Color orange	] ifNotNil: [		thumbnail unhibernate.	].	f _ thumbnail colorReduced.  "minimize depth"	f depth > 8 ifTrue: [		f _ thumbnail asFormOfDepth: 8	].	GIFReadWriter putForm: f onStream: local.	local close.	local _ StandardFileStream fileNamed: (localDirectory fullNameFor: gifFileName).	"(primaryServerDirectory isKindOf: FileDirectory)		ifTrue: [primaryServerDirectory deleteFileNamed: gifFileName ifAbsent: []]."	resp _ primaryServerDirectory putFile: local named: gifFileName retry: false.	local close.	primaryServerDirectory updateProjectInfoFor: self.	primaryServerDirectory sleep.	"if ftp, close the connection"! !!ProjectLoading class methodsFor: 'as yet unclassified' stamp: 'yo 7/16/2003 14:57'!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNil withProjectView: existingView	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world." 	| morphOrList proj trusted localDir projStream archive mgr projectsToBeDeleted baseChangeSet |	(preStream isNil or: [preStream size = 0]) ifTrue: [		ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"		^self inform: 'It looks like a problem occurred whilegetting this project. It may be temporary,so you may want to try again,'	].	ProgressNotification signal: '2:fileSizeDetermined ',preStream size printString.	preStream isZipArchive 		ifTrue:[	archive _ ZipArchive new readFrom: preStream.				projStream _ self projectStreamFromArchive: archive]		ifFalse:[projStream _ preStream].	trusted _ SecurityManager default positionToSecureContentsOf: projStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		(preStream respondsTo: #close) ifTrue:[preStream close].		^self]].	localDir _ Project squeakletDirectory.	aFileName ifNotNil: [		(aDirectoryOrNil isNil or: [aDirectoryOrNil pathName ~= localDir pathName]) ifTrue: [			localDir deleteFileNamed: aFileName.			(localDir fileNamed: aFileName) binary				nextPutAll: preStream contents;				close.		].	].	morphOrList _ projStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	ResourceCollector current: ResourceCollector new.	baseChangeSet _ ChangeSet current.	self useTempChangeSet.		"named zzTemp"	"The actual reading happens here"	[morphOrList _ morphOrList fileInObjectAndCode] ensure: [				ChangeSet  newChanges: baseChangeSet].	mgr _ ResourceManager new initializeFrom: ResourceCollector current.	mgr registerUnloadedResources.	archive ifNotNil:[mgr preLoadFromArchive: archive cacheName: aFileName].	(preStream respondsTo: #close) ifTrue:[preStream close].	ResourceCollector current: nil.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj _ morphOrList arrayOfRoots 			detect: [:mm | mm class == Project] 			ifNone: [^self inform: 'No project found in this file'].		proj resourceManager: mgr.		"proj versionFrom: preStream."		proj lastDirectory: aDirectoryOrNil.		CurrentProjectRefactoring currentBeParentTo: proj.		projectsToBeDeleted _ OrderedCollection new.		existingView ifNil: [			Smalltalk isMorphic ifTrue: [				proj createViewIfAppropriate.			] ifFalse: [				ChangeSorter allChangeSets add: proj changeSet.				ProjectView openAndEnter: proj.				"Note: in MVC we get no further than the above"			].		] ifNotNil: [			(existingView project isKindOf: DiskProxy) ifFalse: [				existingView project changeSet name: ChangeSet defaultName.				projectsToBeDeleted add: existingView project.			].			(existingView owner isSystemWindow) ifTrue: [				existingView owner model: proj			].			existingView project: proj.		].		ChangeSorter allChangeSets add: proj changeSet.		Project current projectParameters 			at: #deleteWhenEnteringNewProject 			ifPresent: [ :ignored | 				projectsToBeDeleted add: Project current.				Project current removeParameter: #deleteWhenEnteringNewProject.			].		projectsToBeDeleted isEmpty ifFalse: [			proj projectParameters 				at: #projectsToBeDeleted 				put: projectsToBeDeleted.		].		^ ProjectEntryNotification signal: proj	].	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph	].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'	].	(Project newMorphicOn: morphOrList) enter! !!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'yo 8/18/2003 18:31'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	w _ self world.	w ifNil: [response isOctetString ifTrue: [^ response asOctetString] ifFalse: [^ response]].	done _ false.	w activeHand newKeyboardFocus: textPane.	[done] whileFalse: [w doOneCycle].	self delete.	w doOneCycle.	^ response isOctetString ifTrue: [response asOctetString] ifFalse: [response].! !!SmartRefStream methodsFor: 'read write' stamp: 'yo 11/14/2002 15:20'!readInstanceSize: instSize clsname: className refPosn: refPosn	"The common code to read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| anObject newName newClass dict oldInstVars isMultiSymbol |	self flag: #bobconv.		self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	newName _ renamed at: className ifAbsent: [className].	isMultiSymbol _ newName = #MultiSymbol.	newClass _ Smalltalk at: newName asSymbol.	(steady includes: newClass) & (newName == className) ifTrue: [	 	anObject _ newClass isVariable "Create it here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].		anObject _ anObject readDataFrom: self size: instSize.		self setCurrentReference: refPosn.  "before returning to next"		isMultiSymbol ifTrue: [^ MultiSymbol internLoadedSymbol: anObject.].		^ anObject].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	dict at: #ClassName put: className.	"so conversion method can know it"	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	anObject _ self applyConversionMethodsTo: anObject className: className varMap: dict.	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!MethodNode methodsFor: 'code generation' stamp: 'yo 8/30/2002 14:07'!selector 	"Answer the message selector for the method represented by the receiver."	(selectorOrFalse isSymbol)		ifTrue: [^selectorOrFalse].	^selectorOrFalse key.! !!Object methodsFor: 'testing' stamp: 'yo 8/28/2002 13:41'!isCharacter	^ false.! !!Parser methodsFor: 'expression types' stamp: 'yo 8/30/2002 14:41'!messagePart: level repeat: repeat	| start receiver selector args precedence words keywordStart |	[receiver _ parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start _ self startOfNextToken.			selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			words _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart _ self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector _ sym])				ifFalse: [ selector _ self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence _ 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2])				ifTrue: 					[start _ self startOfNextToken.					selector _ self advance asOctetString asSymbol.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args _ Array with: parseNode.					precedence _ 2]				ifFalse: [hereType == #word						ifTrue: 							[start _ self startOfNextToken.							selector _ self advance.							args _ #().							words _ OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym])								ifFalse: [ selector _ self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence _ 1]						ifFalse: [^args notNil]]].	parseNode _ MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!Parser methodsFor: 'error correction' stamp: 'yo 11/11/2002 10:20'!correctVariable: proposedVariable interval: spot	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps, and uppercase variables as Globals or ClassVars,	depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable."	| alternatives aStream choice userSelection temp binding globalToo |	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^ encoder undeclared: proposedVariable].	temp _ proposedVariable first canBeNonGlobalVarInitial.	"First check to see if the requestor knows anything about the variable"	(temp and: [(binding _ requestor bindingOf: proposedVariable) notNil])		ifTrue: [^ encoder global: binding name: proposedVariable].	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	alternatives _ encoder possibleVariablesFor: proposedVariable.	aStream _ WriteStream on: (String new: 200).	globalToo _ 0.	aStream nextPutAll: 'declare ' ,		(temp ifTrue: ['temp']			ifFalse: [encoder classEncoding == UndefinedObject					ifTrue: ['Global']					ifFalse: [globalToo _ 1.  'Class Variable']]); cr.	globalToo = 1 ifTrue: [aStream nextPutAll: 'declare Global'; cr].	alternatives do:		[:sel | aStream nextPutAll: sel; cr].	aStream nextPutAll: 'cancel'.	choice _ (PopUpMenu				labels: aStream contents				lines: (Array with: (globalToo + 1) with: (globalToo + alternatives size + 1)))		startUpWithCaption:(('Unknown variable: ', proposedVariable, 'please correct, or cancel:') asText makeBoldFrom: 19 to: 19 + proposedVariable size).	(choice = 0) | (choice > (globalToo + alternatives size + 1))		ifTrue: [^ self fail].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice =1 ifTrue:			[temp ifTrue: [^ self declareTempAndPaste: proposedVariable]				ifFalse: [encoder classEncoding == UndefinedObject					ifTrue: [^ self declareGlobal: proposedVariable]					ifFalse: [^ self declareClassVar: proposedVariable]]].	(choice = 2) & (globalToo = 1) ifTrue: [^ self declareGlobal: proposedVariable].	"Spelling correction"	self substituteWord: (alternatives at: choice-1-globalToo)			wordInterval: spot			offset: 0.	^ encoder encodeVariable: (alternatives at: choice-1-globalToo)! !!Parser methodsFor: 'error correction' stamp: 'yo 8/28/2002 22:32'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ Symbol possibleSelectorsFor: proposedKeyword.	self flag: #toBeFixed.	"alternatives addAll: (MultiSymbol possibleSelectorsFor: proposedKeyword)."	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	((proposedKeyword last ~= $:) and: [correctSelector last == $:]) ifTrue: [		^ abortAction value].	^ correctSelector.! !!Text methodsFor: 'converting' stamp: 'yo 8/28/2002 16:10'!asOctetStringText	string class == MultiString ifTrue: [		^ self class string: string asOctetString runs: self runs deepCopy.	].	^self.! !!Text methodsFor: 'converting' stamp: 'yo 8/28/2002 16:11'!asMultiStringText	string class == MultiString ifFalse: [		^ self class string: (MultiString from: string) runs: self runs deepCopy.	].	^ self.! !!ChangeRecord methodsFor: 'access' stamp: 'sumim 9/1/2003 18:27'!fileIndex	^ (SourceFiles collect: [ :sf | sf name]) 		indexOf: file name ifAbsent: [^ nil].! !!ChangeRecord methodsFor: 'access' stamp: 'sumim 9/2/2003 14:07'!position	^ position! !!ChangeRecord methodsFor: 'access' stamp: 'sumim 9/2/2003 13:33'!prior	| currFile preamble prevPos tokens prevFileIndex |	currFile _ file readOnlyCopy.	currFile position: (0 max: position - 150).	[currFile position < (position - 1)] whileTrue: [preamble _ currFile nextChunk].	currFile close.	prevPos _ nil.	(preamble findString: 'methodsFor:' startingAt: 1) > 0		ifTrue: [tokens _ Scanner new scanTokens: preamble]		ifFalse: [tokens _ Array new].	((tokens size between: 7 and: 8)	and: [(tokens at: tokens size - 5) == #methodsFor:]) ifTrue: [		(tokens at: tokens size - 3) == #stamp:		ifTrue: [			prevPos _ tokens last.			prevFileIndex _ SourceFiles fileIndexFromSourcePointer: prevPos.			prevPos _ SourceFiles filePositionFromSourcePointer: prevPos]		ifFalse: [			prevPos _ tokens at: tokens size - 2.			prevFileIndex _ tokens last].		(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos _ nil]].	prevPos ifNil: [^ nil].	^ {prevFileIndex. prevPos. 		SourceFiles sourcePointerFromFileIndex: prevFileIndex andPosition: prevPos}! !!DiskProxy methodsFor: 'as yet unclassified' stamp: 'yo 11/14/2002 15:23'!comeFullyUpOnReload: smartRefStream	"Internalize myself into a fully alive object after raw loading from a DataStream. (See my class comment.)  DataStream will substitute the object from this eval for the DiskProxy."	| globalObj symbol pr nn arrayIndex |	symbol _ globalObjectName.	"See if class is mapped to another name"	(smartRefStream respondsTo: #renamed) ifTrue: [		"If in outPointers in an ImageSegment, remember original class name.  		 See mapClass:installIn:.  Would be lost otherwise."		((thisContext sender sender sender sender sender sender 			sender sender receiver class == ImageSegment) and: [ 		thisContext sender sender sender sender method == 			(DataStream compiledMethodAt: #readArray)]) ifTrue: [				arrayIndex _ (thisContext sender sender sender sender) tempAt: 4.					"index var in readArray.  Later safer to find i on stack of context."				smartRefStream renamedConv at: arrayIndex put: symbol].	"save original name"		symbol _ smartRefStream renamed at: symbol ifAbsent: [symbol]].	"map"	globalObj _ Smalltalk at: symbol ifAbsent: [		preSelector == nil & (constructorSelector = #yourself) ifTrue: [			Transcript cr; show: symbol, ' is undeclared.'.			(Undeclared includesKey: symbol) ifTrue: [^ Undeclared at: symbol].			Undeclared at: symbol put: nil.			^ nil].		^ self error: 'Global "', symbol, '" not found'].	((symbol == #World) and: [Smalltalk isMorphic not]) ifTrue: [		self inform: 'These objects will work better if opened in a Morphic World.Dismiss and reopen all menus.'].	preSelector ifNotNil: [		Symbol hasInterned: preSelector ifTrue: [:selector |			[globalObj _ globalObj perform: selector] on: Error do: [:ex |				ex messageText = 'key not found' ifTrue: [^ nil].				^ ex signal]]	].	symbol == #Project ifTrue: [		(constructorSelector = #fromUrl:) ifTrue: [			nn _ (constructorArgs first findTokens: '/') last.			nn _ (nn findTokens: '.|') first.			pr _ Project named: nn. 			^ pr ifNil: [self] ifNotNil: [pr]].		pr _ globalObj perform: constructorSelector withArguments: constructorArgs.		^ pr ifNil: [self] ifNotNil: [pr]].	"keep the Proxy if Project does not exist"	constructorSelector ifNil: [^ globalObj].	Symbol hasInterned: constructorSelector ifTrue: [:selector |		[^ globalObj perform: selector withArguments: constructorArgs] on: Error do: [:ex |			ex messageText = 'key not found' ifTrue: [^ nil].			^ ex signal]	].				"args not checked against Renamed"	^ nil 	"was not in proper form"! !!ZipFileMember methodsFor: 'private-reading' stamp: 'yo 11/5/2002 16:58'!readLocalDirectoryFileHeaderFrom: aStream 	"Positions stream as necessary. Will return stream to its original position"	| fileNameLength extraFieldLength xcrc32 xcompressedSize xuncompressedSize sig oldPos |	oldPos _ aStream position.	aStream position: localHeaderRelativeOffset.	sig _ aStream next: 4.	sig = LocalFileHeaderSignature asByteArray		ifFalse: [ aStream position: oldPos.				^self error: 'bad LH signature at ', localHeaderRelativeOffset hex ].	versionNeededToExtract _ aStream nextLittleEndianNumber: 2.	bitFlag _ aStream nextLittleEndianNumber: 2.	compressionMethod _ aStream nextLittleEndianNumber: 2.	lastModFileDateTime _ aStream nextLittleEndianNumber: 4.	xcrc32 _ aStream nextLittleEndianNumber: 4.	xcompressedSize _ aStream nextLittleEndianNumber: 4.	xuncompressedSize _ aStream nextLittleEndianNumber: 4.	fileNameLength _ aStream nextLittleEndianNumber: 2.	extraFieldLength _ aStream nextLittleEndianNumber: 2.	fileName _ (aStream next: fileNameLength) asString convertFromSystemString.	localExtraField _ (aStream next: extraFieldLength) asByteArray.	dataOffset _ aStream position.	"Don't trash these fields if we already got them from the central directory"	self hasDataDescriptor ifFalse: [		crc32 _ xcrc32.		compressedSize _ xcompressedSize.		uncompressedSize _ xuncompressedSize.	].	aStream position: oldPos.! !!ZipFileMember methodsFor: 'private-reading' stamp: 'yo 11/23/2003 19:00'!readCentralDirectoryFileHeaderFrom: aStream	"Assumes aStream positioned after signature"	| fileNameLength extraFieldLength fileCommentLength |	versionMadeBy _ aStream nextLittleEndianNumber: 1.	fileAttributeFormat _ aStream nextLittleEndianNumber: 1.	versionNeededToExtract _ aStream nextLittleEndianNumber: 2.	bitFlag _ aStream nextLittleEndianNumber: 2.	compressionMethod _ aStream nextLittleEndianNumber: 2.	lastModFileDateTime _ aStream nextLittleEndianNumber: 4.	crc32 _ aStream nextLittleEndianNumber: 4.	compressedSize _ aStream nextLittleEndianNumber: 4.	uncompressedSize _ aStream nextLittleEndianNumber: 4.	fileNameLength _ aStream nextLittleEndianNumber: 2.	extraFieldLength _ aStream nextLittleEndianNumber: 2.	fileCommentLength _ aStream nextLittleEndianNumber: 2.	aStream nextLittleEndianNumber: 2. 	"disk number start"	internalFileAttributes _ aStream nextLittleEndianNumber: 2.	externalFileAttributes _ aStream nextLittleEndianNumber: 4.	localHeaderRelativeOffset _ aStream nextLittleEndianNumber: 4.	fileName _ (aStream next: fileNameLength) asString convertFromSystemString.	cdExtraField _ (aStream next: extraFieldLength) asByteArray asString.	fileComment _ (aStream next: fileCommentLength) asString convertFromSystemString.	self desiredCompressionMethod: compressionMethod! !!BuildPriority class methodsFor: 'as yet unclassified' stamp: 'yo 9/26/2003 11:50'!makeNihongoImage	| ps |	ps _ Project allInstances reject: [:p | p = Project current].	ps do: [:p | Project forget: p].	ps do: [:p | Project deletingProject: p].	ps do: [:p | Project current deletingProject: p].	ps _ nil.	Utilities emptyScrapsBook.	Smalltalk garbageCollect.	Smalltalk noChanges.	ChangeSorter classPool at: #AllChangeSets 		put: (OrderedCollection with: Smalltalk changes).	ChangeSorter initializeChangeSetCategories.	ChangeSet allInstances size = 1 ifFalse: [		self error: 'please discard all changes'.	].	ChangeSet allInstances first name: 'abc'.	Display setExtent: 960@720 depth: 16.	World color: (Color r: 0.935 g: 0.935 b: 0.935).	Preferences setPreference: #magicHalos toValue: false.	Preferences setPreference: #magicHalos toValue: true.	Preferences setPreference: #mouseOverHalos toValue: false.	Preferences setPreference: #mouseOverHalos toValue: true.	Preferences offerThemesMenu	TTCFontSet discardDefault.	TTCFontDescription clearDefault	Player abandonUnnecessaryUniclasses.	Player freeUnreferencedSubclasses.	Player removeUninstantiatedSubclassesSilently.	PartsBin initialize.	Flaps disableGlobalFlaps: false.	Flaps addAndEnableEToyFlaps.	ActiveWorld addGlobalFlaps.	Flaps sharedFlapsAlongBottom.	Vocabulary initializeLanguageTable.	Project current setNaturalLanguageTo: #EnglishEnvironment.	Project current setNaturalLanguageTo: #'Japanese(children)'.	Preferences setPreference: #showProjectNavigator toValue: false.	Smalltalk primaryLanguage: #JapaneseEnvironment.	Smalltalk systemLanguage: #JapaneseEnvironment.	Preferences restoreDefaultFontsForJapanese.	Smalltalk condenseChanges.! !!String methodsFor: '*packageinfo-base' stamp: 'ab 5/31/2003 17:13'!escapeEntities	^ String streamContents: [:s | self do: [:c | s nextPutAll: c escapeEntities]]! !!ClassBuilder methodsFor: 'validation' stamp: 'yo 11/11/2002 10:22'!validateClassName: aString	"Validate the new class name"	aString first canBeGlobalVarInitial ifFalse:[		self error: 'Class names must be capitalized'.		^false].	environ at: aString ifPresent:[:old|		(old isKindOf: Behavior) ifFalse:[			self notify: aString asText allBold, 						' already exists!!\Proceed will store over it.' withCRs]].	^true! !!SparseXTable methodsFor: 'as yet unclassified' stamp: 'yo 7/30/2003 17:38'!tableFor: code	| div t table |	div _ code // 65536.	t _ xTables at: div ifAbsent: [table _ Array new: 65536 withAll: 0. xTables at: div put: table. table].	^ t.! !!XTableForUnicodeFont methodsFor: 'as yet unclassified' stamp: 'yo 12/28/2002 22:39'!at: indexPlusOne	| index |	index _ indexPlusOne.	ranges with: xTables do: [:range :xTable |		(range first <= index and: [index <= range last]) ifTrue: [			^ xTable at: index - range first + 1.		].	].	^ 0.! !!XTableForUnicodeFont methodsFor: 'as yet unclassified' stamp: 'yo 12/28/2002 21:40'!at: index put: value	ranges with: xTables do: [:range :xTable |		(range first <= index and: [index <= range last]) ifTrue: [			^ xTable at: index - range first + 1 put: value.		].	].	^ 0.! !!XTableForUnicodeFont methodsFor: 'as yet unclassified' stamp: 'yo 12/29/2002 00:04'!size	^ ranges last last - ranges first first + 1.! !!XTableForUnicodeFont methodsFor: 'as yet unclassified' stamp: 'yo 12/29/2002 00:19'!ranges: pairArray	xTables _ Array new: 0.	pairArray do: [:range |		xTables _ xTables copyWith: (Array new: range last - range first + 1 withAll: 0).	].	ranges _ pairArray.! !!LanguageEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 13:55'!startUp	clipboardInterpreter _ nil.	inputInterpreter _ nil.	defaultSystemConverter _ nil.	Clipboard clearInterpreters.	HandMorph startUp.! !!CompiledMethod methodsFor: 'source code management' stamp: 'yo 3/16/2004 12:48'!qCompress: string firstTry: firstTry	"A very simple text compression routine designed for method temp names.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble.	Last char of str must be a space so it may be dropped without	consequence if output ends on odd nibble.	Normal call is with firstTry == true."	| charTable odd ix oddNibble names shorterStr maybe str temps |	 str _ string isOctetString				ifTrue: [string]				ifFalse: [temps _ string findTokens: ' '.					String						streamContents: [:stream | 1								to: temps size								do: [:index | 									stream nextPut: $t.									stream nextPutAll: index asString.									stream space]]].	charTable _  "Character encoding table must match qDecompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ ByteArray streamContents:		[:strm | odd _ true.  "Flag for odd or even nibble out"		oddNibble _ nil.		str do:			[:char | ix _ (charTable indexOf: char) - 1.			(ix <= 12 ifTrue: [Array with: ix]				ifFalse: [Array with: ix//16+12 with: ix\\16])				do:				[:nibble | (odd _ odd not)					ifTrue: [strm nextPut: oddNibble*16 + nibble]					ifFalse: [oddNibble _ nibble]]].		strm position > 251 ifTrue:			["Only values 1...251 are available for the flag byte			that signals compressed temps. See the logic in endPC."			"Before giving up completely, we attempt to encode most of			the temps, but with the last few shortened to tNN-style names."			firstTry ifFalse: [^ nil "already tried --give up now"].			names _ str findTokens: ' '.			names size < 8 ifTrue: [^ nil  "weird case -- give up now"].			4 to: names size//2 by: 4 do:				[:i | shorterStr _ String streamContents:					[:s |					1 to: names size - i do: [:j | s nextPutAll: (names at: j); space].					1 to: i do: [:j | s nextPutAll: 't' , j printString; space]].				(maybe _ self qCompress: shorterStr firstTry: false) ifNotNil: [^ maybe]].			^ nil].		strm nextPut: strm position]"  | m s |  m _ CompiledMethod new.s _ 'charTable odd ix oddNibble '.^ Array with: s size with: (m qCompress: s) size	with: (m qDecompress: (m qCompress: s))"! !!Character methodsFor: 'converting' stamp: 'yo 10/4/2003 15:00'!asUppercase	"If the receiver is lowercase, answer its matching uppercase Character."		(8r141 <= value and: [value <= 8r172])  "self isLowercase"		ifTrue: [^ Character value: value - 8r40]		ifFalse: [^ self]! !!Character methodsFor: 'converting' stamp: 'yo 10/4/2003 15:00'!asLowercase	"If the receiver is uppercase, answer its matching lowercase Character."		(8r101 <= value and: [value <= 8r132])  "self isUppercase"		ifTrue: [^ Character value: value + 8r40]		ifFalse: [^ self]! !!Character class methodsFor: 'class initialization' stamp: 'yo 10/4/2003 16:03'!initialize	"Create the table of unique Characters.""	self initializeClassificationTable"! !!Encoder methodsFor: 'encoding' stamp: 'yo 11/11/2002 10:22'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode _ scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode _ self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [action value]].	range ifNotNil: [		name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]. ].	(varNode isTemp and: [varNode scope < 0]) ifTrue: [		OutOfScopeNotification signal ifFalse: [ ^self notify: 'out of scope'].	].	^ varNode! !!Encoder methodsFor: 'private' stamp: 'yo 11/11/2002 10:23'!possibleVariablesFor: proposedVariable	| results |	results _ proposedVariable correctAgainstDictionary: scopeTable								continuedFrom: nil.	proposedVariable first canBeGlobalVarInitial ifTrue:		[ results _ class possibleVariablesFor: proposedVariable						continuedFrom: results ].	^ proposedVariable correctAgainst: nil continuedFrom: results.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'yo 7/16/2003 15:00'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry brow |	self flag: #yoCharCases.	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[anEntry _ (Smalltalk					at: aSymbol					ifAbsent:						[ self systemNavigation browseAllImplementorsOf: aSymbol.						^ nil]).				anEntry isNil ifTrue: [^ view flash].				(anEntry isKindOf: Class)					ifFalse:	[anEntry _ anEntry class].				brow _ Preferences browseToolClass new.				brow setClass: anEntry selector: nil.				brow class					openBrowserView: (brow openEditString: nil)					label: 'System Browser']			ifFalse:				[ self systemNavigation browseAllImplementorsOf: aSymbol]]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'yo 12/3/2003 00:00'!nihongoVersion	^ 'Nihongo5.4' copy! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'yo 12/3/2003 00:00'!m17nVersion	^ 'M17n 3.4' copy! !!SystemDictionary methodsFor: 'accessing' stamp: 'yo 9/26/2003 11:48'!systemLanguage	SystemLanguage ifNil: [		SystemLanguage _ self at: #EnglishEnvironment ifAbsent: [LanguageEnvironment].	].	^ SystemLanguage! !!SystemDictionary methodsFor: 'accessing' stamp: 'yo 8/11/2003 18:59'!primaryLanguage	PrimaryLanguage ifNil: [		PrimaryLanguage _ self at: #EnglishEnvironment ifAbsent: [LanguageEnvironment].	].	^ PrimaryLanguage! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'yo 11/4/2002 22:30'!aboutThisSystem 	"Identify software version"	^ self inform: (self systemInformationString, '\', self m17nVersion, '\', self nihongoVersion) withCRs.! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'sumim 9/2/2003 14:57'!reconstructChanges		"Move all the changes and its histories onto another sources file."	"Smalltalk reconstructChanges"	| f oldChanges classCount |	f _ FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class moveChangesWithVersionsTo: f.			class putClassCommentToCondensedChangesFile: f.			class class moveChangesWithVersionsTo: f]].	LastQuitLogPosition _ f position.	f trailer; close.	oldChanges _ SourceFiles at: 2.	oldChanges close.	FileDirectory default 		deleteFileNamed: oldChanges name , '.old';		rename: oldChanges name toBe: oldChanges name , '.old';		rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles at: 2			put: (FileStream oldFileNamed: oldChanges name)! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'yo 8/4/2003 18:35'!reformatChangesToUTF8	"Smalltalk reformatChangesToUTF8"	| f oldChanges classCount |	f _ FileStream fileNamed: 'ST80.temp'.	f converter: (UTF8TextConverter new).	f header; timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class moveChangesTo: f.			class putClassCommentToCondensedChangesFile: f.			class class moveChangesTo: f]].	LastQuitLogPosition _ f position.	f trailer; close.	oldChanges _ SourceFiles at: 2.	oldChanges close.	FileDirectory default 		deleteFileNamed: oldChanges name , '.old';		rename: oldChanges name toBe: oldChanges name , '.old';		rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles at: 2			put: (FileStream oldFileNamed: oldChanges name).	MultiByteFileStream codeConverterClass: UTF8TextConverter.	(SourceFiles at: 2) converter: (UTF8TextConverter new).! !!SmalltalkImage methodsFor: 'sources, change log' stamp: 'yo 10/4/2002 02:39'!logChange: aStringOrText 	"Write the argument, aString, onto the changes file."	| aString changesFile |	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^ self].	self assureStartupStampLogged.	aStringOrText isText		ifTrue: [aString _ aStringOrText string]		ifFalse: [aString _ aStringOrText].	(aString isKindOf: AbstractString)		ifFalse: [self error: 'can''t log this change'].	(aString findFirst: [:char | char isSeparator not]) = 0		ifTrue: [^ self].  "null doits confuse replay"	(changesFile _ SourceFiles at: 2).	changesFile isReadOnly ifTrue:[^self].	changesFile setToEnd; cr; cr.	changesFile nextChunkPut: aString.		"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"	self forceChangesToDisk.! !!SystemDictionary methodsFor: 'accessing' stamp: 'yo 9/26/2003 11:48'!systemLanguage: aSymbol	SystemLanguage _ self at: aSymbol ifAbsent: [nil].! !!SystemDictionary methodsFor: 'accessing' stamp: 'yo 8/13/2003 21:54'!primaryLanguage: aSymbol	PrimaryLanguage _ self at: aSymbol ifAbsent: [nil].	LanguageEnvironment startUp.! !!Stream methodsFor: 'accessing' stamp: 'yo 8/30/2002 17:13'!basicNext	^ self next.! !!Stream methodsFor: 'accessing' stamp: 'yo 8/30/2002 17:13'!basicNextPutAll: aCollection 	^ self nextPutAll: aCollection.! !!Stream methodsFor: 'accessing' stamp: 'yo 8/30/2002 17:13'!basicNextPut: anObject 	^ self nextPut: anObject! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'yo 8/30/2002 17:02'!labels: labels lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string  	with embedded CRs, or a collection of strings. Record the given array of 	selections corresponding to the items in labels."	| labelString |	(labels isString)		ifTrue: [labelString _ labels]		ifFalse: [labelString _ String streamContents:					[:s |					labels do: [:l | s nextPutAll: l; cr].					s skip: -1]].	^ (self labels: labelString lines: linesArray) selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'yo 8/30/2002 17:00'!labels: labels lines: linesArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string 	with embedded CRs, or a collection of strings."	(labels isString)		ifTrue: [^ super labels: labels lines: linesArray]		ifFalse: [^ super labelArray: labels lines: linesArray]! !!WriteStream methodsFor: 'fileIn/Out' stamp: 'yo 8/28/2002 16:13'!nextChunkPutWithStyle: aStringOrText	"Append the argument, aText, to the receiver, doubling embedded terminators.  Put out one chunk for the string and one for the style runs.  Mark the style with ]style[."	aStringOrText isString ifTrue: [^ self nextChunkPut: aStringOrText].	aStringOrText runs coalesce.	aStringOrText unembellished ifTrue: [^ self nextChunkPut: aStringOrText asString].	self nextChunkPut: aStringOrText asString.	self cr; nextPutAll: ']style['.	self nextChunkPut: 		(String streamContents: [:strm | 			aStringOrText runs writeScanOn: strm]).! !!WriteStream methodsFor: 'fileIn/Out' stamp: 'yo 8/13/2003 12:18'!nextChunkPut: aString	"Append the argument, aString, to the receiver, doubling embedded terminators."	| i remainder terminator |	terminator _ $!!.	remainder _ aString.	[(i _ remainder indexOf: terminator) = 0] whileFalse:		[self nextPutAll: (remainder copyFrom: 1 to: i).		self nextPut: terminator.  "double imbedded terminators"		remainder _ remainder copyFrom: i+1 to: remainder size].	self nextPutAll: remainder.	aString includesUnifiedCharacter ifTrue: [		self nextPut: terminator.		self nextPutAll: ']lang['.		aString writeLeadingCharRunsOn: self.	].	self nextPut: terminator.! !!WriteStream methodsFor: 'accessing' stamp: 'yo 8/28/2002 16:12'!nextPut: anObject 	"Primitive. Insert the argument at the next position in the Stream	represented by the receiver. Fail if the collection of this stream is not an	Array or a String. Fail if the stream is positioned at its end, or if the	position is out of bounds in the collection. Fail if the argument is not	of the right type for the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 66>	((collection class == String) and: [anObject class == MultiCharacter]) ifTrue: [		 collection _ (MultiString from: collection).		^self nextPut: anObject.	].	position >= writeLimit		ifTrue: [^ self pastEndPut: anObject]		ifFalse: 			[position _ position + 1.			^collection at: position put: anObject]! !!PseudoClass methodsFor: 'fileIn/fileOut' stamp: 'hg 9/6/2000 12:45'!fileOutDefinitionOn: aStream	self hasDefinition ifFalse:[^self].	aStream nextChunkPut: self definition; cr.	self hasComment		ifTrue:			[aStream cr.			self organization commentRemoteStr fileOutOn:aStream]! !!Morph methodsFor: 'event handling' stamp: 'yo 11/7/2002 18:06'!prefereredKeyboardBounds	^ self bounds: self bounds in: World.! !!Morph methodsFor: 'event handling' stamp: 'yo 11/7/2002 18:06'!prefereredKeyboardPosition	^ (self bounds: self bounds in: World) topLeft.! !!Morph class methodsFor: 'fileIn/Out' stamp: 'yo 8/7/2003 11:02'!fromFileName: fullName	"Reconstitute a Morph from the file, presumed to be represent a Morph saved	via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	aFileStream _ (MultiByteBinaryOrTextStream with: ((FileStream readOnlyFileNamed: fullName) binary contentsOfEntireFile)) binary reset.	morphOrList _ aFileStream fileInObjectAndCode.	(morphOrList isKindOf: SqueakPage) ifTrue: [morphOrList _ morphOrList contentsMorph].	Smalltalk isMorphic		ifTrue: [ActiveWorld addMorphsAndModel: morphOrList]		ifFalse:			[morphOrList isMorph ifFalse: [self inform: 'Can only load a single morphinto an mvc project via this mechanism.'].			morphOrList openInWorld]! !Character initialize!Smalltalk primaryLanguage: #EnglishEnvironment!Smalltalk systemLanguage: #EnglishEnvironment!Object subclass: #AbstractFont	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ' '	category: 'Graphics-Text'!!AbstractFont commentStamp: '<historical>'!AbstractFont defines the generic interface that all fonts need to implement.!CharacterScanner subclass: #CharacterBlockScanner	instanceVariableNames: 'characterPoint characterIndex lastCharacter lastCharacterExtent lastSpaceOrTabExtent nextLeftMargin specialWidth '	classVariableNames: ''	poolDictionaries: ' '	category: 'Graphics-Text'!!CharacterBlockScanner commentStamp: '<historical>'!My instances are used to scan text to compute the CharacterBlock for a character specified by its index in the text or its proximity to the cursor location.!Object subclass: #CharacterScanner	instanceVariableNames: 'destX lastIndex xTable map destY stopConditions text textStyle alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth emphasisCode kern indentationLevel wantsColumnBreaks '	classVariableNames: 'DefaultStopConditions NilCondition PaddedSpaceCondition SpaceCondition '	poolDictionaries: ' TextConstants'	category: 'Graphics-Text'!!CharacterScanner commentStamp: '<historical>'!My instances hold the state associated with scanning text. My subclasses scan characters for specified purposes, such as computing a CharacterBlock or placing characters into Forms.!Object subclass: #CombinedChar	instanceVariableNames: 'codes combined '	classVariableNames: 'Compositions Decompositions Diacriticals '	poolDictionaries: ''	category: 'Multilingual-Scanning'!CharacterScanner subclass: #DisplayScanner	instanceVariableNames: 'bitBlt lineY runX foregroundColor backgroundColor fillBlt lineHeight paragraph paragraphColor morphicOffset ignoreColorChanges '	classVariableNames: ''	poolDictionaries: ' '	category: 'Graphics-Text'!Object subclass: #MultiCharacterScanner	instanceVariableNames: 'destX lastIndex xTable map destY stopConditions text textStyle alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth emphasisCode kern indentationLevel wantsColumnBreaks presentation presentationLine numOfComposition '	classVariableNames: 'DefaultStopConditions NilCondition PaddedSpaceCondition SpaceCondition '	poolDictionaries: ' TextConstants'	category: 'Multilingual-Scanning'!!DisplayScanner commentStamp: '<historical>'!My instances are used to scan text and display it on the screen or in a hidden form.!BDFFontReader subclass: #EFontBDFFontReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Display'!EFontBDFFontReader subclass: #EFontBDFFontReaderForRanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Display'!MultiCharacterScanner subclass: #MultiCanvasCharacterScanner	instanceVariableNames: 'canvas fillBlt foregroundColor runX lineY '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Scanning'!MultiCharacterScanner subclass: #MultiCharacterBlockScanner	instanceVariableNames: 'characterPoint characterIndex lastCharacter lastCharacterExtent lastSpaceOrTabExtent nextLeftMargin specialWidth '	classVariableNames: ''	poolDictionaries: ' '	category: 'Multilingual-Scanning'!MultiCharacterScanner subclass: #MultiCompositionScanner	instanceVariableNames: 'spaceX lineHeight baseline breakableIndex lineHeightAtBreak baselineAtBreak breakAtSpace '	classVariableNames: ''	poolDictionaries: ' '	category: 'Multilingual-Scanning'!MultiCharacterScanner subclass: #MultiDisplayScanner	instanceVariableNames: 'bitBlt lineY runX foregroundColor backgroundColor fillBlt lineHeight paragraph paragraphColor morphicOffset ignoreColorChanges '	classVariableNames: ''	poolDictionaries: ' '	category: 'Multilingual-Scanning'!NewParagraph subclass: #MultiNewParagraph	instanceVariableNames: 'presentationText presentationLines '	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Multilingual-Scanning'!TTCFont subclass: #MultiTTCFont	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Display'!TextComposer subclass: #MultiTextComposer	instanceVariableNames: 'presentation presentationLines '	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'Multilingual-Scanning'!DisplayText subclass: #Paragraph	instanceVariableNames: 'clippingRectangle compositionRectangle destinationForm rule mask marginTabsLevel lines lastLine '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'ST80-Support'!!Paragraph commentStamp: '<historical>'!I represent displayable text that has been decoraged with margin alignment, line leading, and tab settings.!AbstractFont subclass: #StrikeFont	instanceVariableNames: 'characterToGlyphMap xTable glyphs name type minAscii maxAscii maxWidth strikeLength ascent descent xOffset raster subscript superscript emphasis derivativeFonts pointSize '	classVariableNames: 'DefaultStringScanner '	poolDictionaries: 'TextConstants '	category: 'Graphics-Text'!!StrikeFont commentStamp: '<historical>'!I represent a compact encoding of a set of Forms corresponding to characters in the ASCII character set. All the forms are placed side by side in a large form whose height is the font height, and whose width is the sum of all the character widths. The xTable variable gives the left-x coordinates of the subforms corresponding to the glyphs. Characters are mapped to glyphs by using the characterToGyphMap.Subclasses can have non-trivial mapping rules as well as different representations for glyphs sizes (e.g., not using an xTable). If so, these classes should return nil when queried for xTable and/or the characterToGlyphMap. This will cause the CharacterScanner primitive to fail and query the font for the width of a character (so that a more programatical approach can be implemented).For display, fonts need to implement two messages:	#installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColorThis method installs the receiver (a font) on the given DisplayContext (which may be an instance of BitBlt or Canvas (or any of it's subclasses). The font should take the appropriate action to initialize the display context so that further display operations can be optimized.	#displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDeltaThis method is called for each subsequent run of characters in aString which is to be displayed with the (previously installed) settings.!Object subclass: #StrikeFontFixer	instanceVariableNames: 'strikeFont charForms newFont '	classVariableNames: 'MappingTable NoFontTable '	poolDictionaries: ''	category: 'Multilingual-Display'!AbstractFont subclass: #StrikeFontSet	instanceVariableNames: 'fontArray emphasis derivativeFonts name '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Display'!TTFontDescription subclass: #TTCFontDescription	instanceVariableNames: ''	classVariableNames: 'TTCDefault TTCDescriptions '	poolDictionaries: ''	category: 'Multilingual-Display'!TTFontReader subclass: #TTCFontReader	instanceVariableNames: 'fonts '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Display'!AbstractFont subclass: #TTCFontSet	instanceVariableNames: 'name fontArray foregroundColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Display'!Object subclass: #TextStyle	instanceVariableNames: 'fontArray fontFamilySize lineGrid baseline alignment firstIndent restIndent rightIndent tabsArray marginTabsArray leading defaultFontIndex '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Text'!!TextStyle commentStamp: '<historical>'!A textStyle comprises the formatting information for composing and displaying a unit (usually a paragraph) of text.  Typically one makes a copy of a master textStyle (such as TextStyle default), and then that copy may get altered in the process of editing.  Bad things can happen if you do not copy first.Each of my instances consists of...	fontArray		An array of StrikeFonts	fontFamilySize	unused	lineGrid			An integer; default line spacing for paragraphs	baseline			An integer; default baseline (dist from line top to bottom of an 'a')	alignment		An integer; text alignment, see TextStyle alignment:	firstIndent		An integer; indent of first line in pixels	restIndent		An integer; indent of remaining lines in pixels	rightIndent		An integer; indent of right margin rel to section	tabsArray		An array of integers giving tab offsets in pixels	marginTabsArray	An array of margin tabs	leading			An integer giving default vertical line separationFor a concrete example, look at TextStyle default copy inspect!ArrayedCollection variableSubclass: #SparseLargeTable	instanceVariableNames: 'base size chunkSize defaultValue '	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Collection'!!MultiCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:53'!setFont	| priorFont |	"Set the font and other emphasis."	priorFont _ font.	text == nil ifFalse:[		emphasisCode _ 0.		kern _ 0.		indentationLevel _ 0.		alignment _ textStyle alignment.		font _ nil.		(text attributesAt: lastIndex forStyle: textStyle)			do: [:att | att emphasizeScanner: self]].	font == nil ifTrue:		[self setFont: textStyle defaultFontIndex].	font _ font emphasized: emphasisCode.	priorFont ifNotNil: [destX _ destX + priorFont descentKern].	destX _ destX - font descentKern.	"NOTE: next statement should be removed when clipping works"	leftMargin ifNotNil: [destX _ destX max: leftMargin].	kern _ kern - font baseKern.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space.	xTable _ font xTable.	map _ font characterToGlyphMap.	stopConditions _ DefaultStopConditions.! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'yo 8/18/2003 17:49'!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| charCode encoding f nextDestX maxAscii startEncoding combining combined combiningIndex |	lastIndex _ startIndex.	lastIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].	startEncoding _ (sourceString at: startIndex) leadingChar.	font ifNil: [font _ (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f _ font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f _ font fontArray at: 1].		f ifNil: [ f _ font fontArray at: 1].		maxAscii _ f maxAscii.		spaceWidth _ f widthOf: Space.	] ifFalse: [		maxAscii _ font maxAscii.	].	combining _ nil.	[lastIndex <= stopIndex] whileTrue: [		charCode _ (sourceString at: lastIndex) charCode.		combining ifNil: [			combining _ CombinedChar new.			combining add: charCode.			combiningIndex _ lastIndex.			lastIndex _ lastIndex + 1.		] ifNotNil: [			(combining add: charCode) ifFalse: [				self addCharToPresentation: (combined _ combining combined).				combining _ CombinedChar new.				combining add: charCode.				charCode _ combined charCode.				encoding _ combined leadingChar.				encoding ~= startEncoding ifTrue: [lastIndex _ lastIndex - 1. ^ stops at: EndOfRun].				charCode > maxAscii ifTrue: [charCode _ maxAscii].				""				(encoding = 0 and: [(stopConditions at: charCode + 1) ~~ nil]) ifTrue: [					combining ifNotNil: [						self addCharToPresentation: (combining combined).					].					^ stops at: charCode + 1				].				(self isBreakableAt: lastIndex in: sourceString in: Latin1) ifTrue: [					self registerBreakableIndex.				].				nextDestX _ destX + (self widthOf: combined inFont: font).				nextDestX > rightX ifTrue: [					lastIndex _ combiningIndex.					self removeLastCharFromPresentation.					^ stops at: CrossedX].				destX _ nextDestX + kernDelta.				combiningIndex _ lastIndex.				lastIndex _ lastIndex + 1.			] ifTrue: [				lastIndex _ lastIndex + 1.				numOfComposition _ numOfComposition + 1.			].		].	].	lastIndex _ stopIndex.	combining ifNotNil: [		combined _ combining combined.		self addCharToPresentation: combined.		"assuming that there is always enough space for at least one character".		destX _ destX + (self widthOf: combined inFont: font).	].	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:53'!indentationLevel: anInteger	"set the number of tabs to put at the beginning of each line"	indentationLevel _ anInteger! !!MultiCharacterScanner methodsFor: 'multilingual scanning' stamp: 'yo 1/1/2003 10:43'!widthOf: char inFont: aFont	(char isMemberOf: CombinedChar) ifTrue: [		^ aFont widthOf: char base.	] ifFalse: [		^ aFont widthOf: char.	].! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'yo 8/6/2003 05:56'!scanJapaneseCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex _ startIndex.	lastIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].	startEncoding _ (sourceString at: startIndex) leadingChar.	font ifNil: [font _ (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f _ font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f _ font fontArray at: 1].		f ifNil: [ f _ font fontArray at: 1].		maxAscii _ f maxAscii.		"xTable _ f xTable.		maxAscii _ xTable size - 2."		spaceWidth _ f widthOf: Space.	] ifFalse: [		maxAscii _ font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		"self halt."		encoding _ (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex _ lastIndex - 1. ^ stops at: EndOfRun].		ascii _ (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii _ maxAscii].		(encoding = 0 and: [(stopConditions at: ascii + 1) ~~ nil]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: (EncodedCharSet charsetAt: encoding)) ifTrue: [			self registerBreakableIndex.		].		nextDestX _ destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX _ nextDestX + kernDelta.		lastIndex _ lastIndex + 1.	].	lastIndex _ stopIndex.	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'yo 12/27/2002 04:33'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isKindOf: String) ifTrue: [^ self basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isKindOf: MultiString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].		startEncoding _  (sourceString at: startIndex) leadingChar.		selector _ (EncodedCharSet charsetAt: startEncoding) scanSelector.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stopConditions with: kernDelta).	].		^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'yo 8/18/2003 17:49'!scanMultiCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex _ startIndex.	lastIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].	startEncoding _ (sourceString at: startIndex) leadingChar.	font ifNil: [font _ (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f _ font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f _ font fontArray at: 1].		f ifNil: [ f _ font fontArray at: 1].		maxAscii _ f maxAscii.		spaceWidth _ f widthOf: Space.	] ifFalse: [		maxAscii _ font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding _ (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex _ lastIndex - 1. ^ stops at: EndOfRun].		ascii _ (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii _ maxAscii].		(encoding = 0 and: [(stopConditions at: ascii + 1) ~~ nil]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: Latin1) ifTrue: [			self registerBreakableIndex.		].		nextDestX _ destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX _ nextDestX + kernDelta.		lastIndex _ lastIndex + 1.	].	lastIndex _ stopIndex.	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:53'!leadingTab	"return true if only tabs lie to the left"	line first to: lastIndex do:		[:i | (text at: i) == Tab ifFalse: [^ false]].	^ true! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:53'!embeddedObject	| savedIndex |	savedIndex _ lastIndex.	text attributesAt: lastIndex do:[:attr| 		attr anchoredMorph ifNotNil:[			"Following may look strange but logic gets reversed.			If the morph fits on this line we're not done (return false for true) 			and if the morph won't fit we're done (return true for false)"			(self placeEmbeddedObject: attr anchoredMorph) ifFalse:[^true]]].	lastIndex _ savedIndex + 1. "for multiple(!!) embedded morphs"	^false! !!MultiCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:53'!text: t textStyle: ts	text _ t.	textStyle _ ts! !!MultiCharacterScanner methodsFor: 'initialize' stamp: 'yo 12/18/2002 13:53'!initializeStringMeasurer	stopConditions _ Array new: 258.	stopConditions at: CrossedX put: #crossedX.	stopConditions at: EndOfRun put: #endOfRun.! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:53'!columnBreak	^true! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:53'!indentationLevel	"return the number of tabs that are currently being placed at the beginning of each line"	^indentationLevel ifNil:[0]! !!MultiCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:53'!addKern: kernDelta	"Set the current kern amount."	kern _ kern + kernDelta! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'yo 12/30/2002 22:59'!combinableChar: char for: prevEntity! !!MultiCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:53'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	text _ aParagraph text.	textStyle _ aParagraph textStyle. ! !!MultiCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:53'!addEmphasis: code	"Set the bold-ital-under-strike emphasis."	emphasisCode _ emphasisCode bitOr: code! !!MultiCharacterScanner methodsFor: 'multilingual scanning' stamp: 'yo 1/23/2003 14:25'!removeLastCharFromPresentation! !!MultiCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:53'!setActualFont: aFont	"Set the basal font to an isolated font reference."	font _ aFont! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'yo 8/18/2003 17:49'!scanMultiCharactersR2LFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Note that 'rightX' really means 'endX' in R2L context.  Ie.  rightX is usually smaller than destX."	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex _ startIndex.	lastIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].	startEncoding _ (sourceString at: startIndex) leadingChar.	font ifNil: [font _ (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f _ font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f _ font fontArray at: 1].		f ifNil: [ f _ font fontArray at: 1].		maxAscii _ f maxAscii.		spaceWidth _ f widthOf: Space.	] ifFalse: [		maxAscii _ font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding _ (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex _ lastIndex - 1. ^ stops at: EndOfRun].		ascii _ (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii _ maxAscii].		(encoding = 0 and: [(stopConditions at: ascii + 1) ~~ nil]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: Latin1) ifTrue: [			self registerBreakableIndex.		].		nextDestX _ destX - (font widthOf: (sourceString at: lastIndex)).		nextDestX < rightX ifTrue: [^ stops at: CrossedX].		destX _ nextDestX - kernDelta.		lastIndex _ lastIndex + 1.	].	lastIndex _ stopIndex.	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'initialize' stamp: 'yo 12/18/2002 13:53'!wantsColumnBreaks: aBoolean	wantsColumnBreaks _ aBoolean! !!MultiCharacterScanner methodsFor: 'private' stamp: 'yo 12/19/2002 02:05'!setConditionArray: aSymbol	aSymbol == #paddedSpace ifTrue: [^stopConditions _ PaddedSpaceCondition "copy"].	"aSymbol == #space ifTrue: [^stopConditions _ SpaceCondition copy]."	aSymbol == nil ifTrue: [^stopConditions _ NilCondition "copy"].	self error: 'undefined stopcondition for space character'.! !!MultiCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:53'!textColor: ignored	"Overridden in DisplayScanner"! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'yo 12/18/2002 13:53'!basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char |	<primitive: 103>	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[char _ (sourceString at: lastIndex).			ascii _ char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextDestX _ destX + (font widthOf: char).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:53'!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	| w |	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	destX _ destX + (w _ anchoredMorph width).	(destX > rightMargin and: [(leftMargin + w) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex _ lastIndex + 1.	self setFont.  "Force recalculation of emphasis for next run"	^ true! !!MultiCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:53'!setAlignment: style	alignment _ style.	! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:53'!handleIndentation	self indentationLevel timesRepeat: [		self plainTab]! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:53'!measureString: aString inFont: aFont from: startIndex to: stopIndex	"WARNING: In order to use this method the receiver has to be set up using #initializeStringMeasurer"	destX _ destY _ lastIndex _ 0.	xTable _ aFont xTable.	map _ aFont characterToGlyphMap.	self scanCharactersFrom: startIndex to: stopIndex in: aString rightX: 999999 stopConditions: stopConditions kern: 0.	^destX! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:53'!plainTab	"This is the basic method of adjusting destX for a tab."	destX _ (alignment == Justified and: [self leadingTab not])		ifTrue:		"embedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin]! !!MultiCharacterScanner methodsFor: 'multilingual scanning' stamp: 'yo 1/3/2003 12:09'!addCharToPresentation: char! !!MultiCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:53'!setFont: fontNumber	"Set the font by number from the textStyle."	self setActualFont: (textStyle fontAt: fontNumber)! !!MultiCharacterScanner methodsFor: 'initialize' stamp: 'yo 12/18/2002 13:53'!initialize	destX _ destY _ leftMargin _ 0.! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'yo 12/20/2002 11:46'!isBreakableAt: index in: sourceString in: encodingClass	^ encodingClass isBreakableAt: index in: sourceString.! !!MultiCharacterScanner methodsFor: 'multilingual scanning' stamp: 'yo 12/20/2002 16:15'!registerBreakableIndex	"Record left x and character index of the line-wrappable point. 	The default implementation here does nothing."	^ false.! !!MultiCharacterScanner class methodsFor: 'instance creation' stamp: 'yo 12/18/2002 13:54'!new	^super new initialize! !!TextContainer methodsFor: 'access' stamp: 'yo 1/3/2003 12:21'!paragraphClass	^ NewParagraph! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'yo 8/6/2003 17:06'!composeOneLine	| rectangles |	rectangles := theContainer rectanglesAt: currentY height: defaultLineHeight.	(rectangles size = 1 and: [rectangles first width < 20]) ifTrue: [		rectangles _ Array with: (rectangles first outsetBy: (0@0 corner: 20@0)).	].	rectangles notEmpty 		ifTrue: [(self composeAllRectangles: rectangles) ifNil: [^nil]]		ifFalse: [currentY := currentY + defaultLineHeight].	self checkIfReadyToSlide! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'yo 12/20/2002 11:51'!isBreakableAt: index in: sourceString in: encodingClass	^ encodingClass isBreakableAt: index in: sourceString.! !!MultiCompositionScanner methodsFor: 'accessing' stamp: 'yo 1/3/2003 02:33'!presentation	^ presentation.! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'yo 1/3/2003 11:56'!placeEmbeddedObject: anchoredMorph	| descent |	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	(super placeEmbeddedObject: anchoredMorph) ifFalse: ["It doesn't fit"		"But if it's the first character then leave it here"		lastIndex < line first ifFalse:[			line stop: lastIndex-1.			^ false]].	descent _ lineHeight - baseline.	lineHeight _ lineHeight max: anchoredMorph height.	baseline _ lineHeight - descent.	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	^ true! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'yo 1/3/2003 11:55'!endOfRun	"Answer true if scanning has reached the end of the paragraph. 	Otherwise step conditions (mostly install potential new font) and answer 	false."	| runLength |	lastIndex = text size	ifTrue:	[line stop: lastIndex.			presentationLine stop: lastIndex - numOfComposition.			spaceX _ destX.			line paddingWidth: rightMargin - destX.			presentationLine paddingWidth: rightMargin - destX.			^true]	ifFalse:	[runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).			runStopIndex _ lastIndex + (runLength - 1).			self setStopConditions.			^false]! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'yo 1/23/2003 17:58'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	"Set up margins"	leftMargin _ lineRectangle left.	leftSide ifTrue: [leftMargin _ leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX _ spaceX _ leftMargin.	rightMargin _ lineRectangle right.	rightSide ifTrue: [rightMargin _ rightMargin - textStyle rightIndent].	lastIndex _ startIndex.	"scanning sets last index"	destY _ lineRectangle top.	lineHeight _ baseline _ 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	presentationLine _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	numOfComposition _ 0.	spaceCount _ 0.	self handleIndentation.	leftMargin _ destX.	line leftMargin: leftMargin.	presentationLine leftMargin: leftMargin.	presentation _ TextStream on: (Text fromString: (MultiString new: text size)).	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading.						^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'yo 1/3/2003 11:56'!columnBreak	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	spaceX _ destX.	line paddingWidth: rightMargin - spaceX.	presentationLine paddingWidth: rightMargin - spaceX.	^true! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 21:47'!setFont	super setFont.	breakAtSpace _ false.	wantsColumnBreaks == true ifTrue: [		stopConditions _ stopConditions copy.		stopConditions at: TextComposer characterForColumnBreak asciiValue + 1 put: #columnBreak.	].! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'yo 1/3/2003 11:54'!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	(breakAtSpace) ifTrue: [		spaceCount >= 1 ifTrue:			["The common case. First back off to the space at which we wrap."			line stop: breakableIndex.			presentationLine stop: breakableIndex - numOfComposition.			lineHeight _ lineHeightAtBreak.			baseline _ baselineAtBreak.			spaceCount _ spaceCount - 1.			breakableIndex _ breakableIndex - 1.			"Check to see if any spaces preceding the one at which we wrap.				Double space after punctuation, most likely."			[(spaceCount > 1 and: [(text at: breakableIndex) = Space])]				whileTrue:					[spaceCount _ spaceCount - 1.					"Account for backing over a run which might						change width of space."					font _ text fontAt: breakableIndex withStyle: textStyle.					breakableIndex _ breakableIndex - 1.					spaceX _ spaceX - (font widthOf: Space)].			line paddingWidth: rightMargin - spaceX.			presentationLine paddingWidth: rightMargin - spaceX.			presentationLine internalSpaces: spaceCount.			line internalSpaces: spaceCount]		ifFalse:			["Neither internal nor trailing spaces -- almost never happens."			lastIndex _ lastIndex - 1.			[destX <= rightMargin]				whileFalse:					[destX _ destX - (font widthOf: (text at: lastIndex)).					lastIndex _ lastIndex - 1].			spaceX _ destX.			line paddingWidth: rightMargin - destX.			presentationLine paddingWidth: rightMargin - destX.			presentationLine stop: (lastIndex max: line first).			line stop: (lastIndex max: line first)].		^true	].	(breakableIndex isNil or: [breakableIndex < line first]) ifTrue: [		"Any breakable point in this line.  Just wrap last character."		breakableIndex _ lastIndex - 1.		lineHeightAtBreak _ lineHeight.		baselineAtBreak _ baseline.	].	"It wasn't a space, but anyway this is where we break the line."	line stop: breakableIndex.	presentationLine stop: breakableIndex.	lineHeight _ lineHeightAtBreak.	baseline _ baselineAtBreak.	^ true.! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'yo 1/23/2003 17:58'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	destX _ spaceX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."	baseline _ textStyle baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	presentationLine _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	numOfComposition _ 0.	presentation _ TextStream on: (Text fromString: (MultiString new: text size)).	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading.						^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!MultiCompositionScanner methodsFor: 'accessing' stamp: 'yo 1/3/2003 02:33'!presentationLine	^ presentationLine.! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'yo 1/3/2003 12:09'!addCharToPresentation: char	presentation nextPut: char.! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'yo 1/3/2003 11:56'!cr	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	spaceX _ destX.	line paddingWidth: rightMargin - spaceX.	presentationLine paddingWidth: rightMargin - spaceX.	^true! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:57'!tab	"Advance destination x according to tab settings in the paragraph's 	textStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	destX _ textStyle				nextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex _ lastIndex + 1.	^false! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'yo 1/23/2003 14:26'!removeLastCharFromPresentation	presentation ifNotNil: [		presentation position: presentation position - 1.	].! !!MultiCompositionScanner methodsFor: 'intialize-release' stamp: 'yo 12/18/2002 13:57'!forParagraph: aParagraph	"Initialize the receiver for scanning the given paragraph."	self		initializeFromParagraph: aParagraph		clippedBy: aParagraph clippingRectangle.! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'yo 12/20/2002 16:28'!registerBreakableIndex	"Record left x and character index of the line-wrappable point. 	Used for wrap-around. Answer whether the character has crossed the 	right edge of the composition rectangle of the paragraph."	(text at: lastIndex) = Character space ifTrue: [		breakAtSpace _ true.		spaceX _ destX.		spaceCount _ spaceCount + 1.		lineHeightAtBreak _ lineHeight.		baselineAtBreak _ baseline.		breakableIndex _ lastIndex.		destX > rightMargin ifTrue: 	[^self crossedX].	] ifFalse: [		breakAtSpace _ false.		lineHeightAtBreak _ lineHeight.		baselineAtBreak _ baseline.		breakableIndex _ lastIndex - 1.	].	^ false.! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:57'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'yo 1/16/2003 17:28'!getPresentationLine	^ presentationLine.! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:57'!setActualFont: aFont	"Keep track of max height and ascent for auto lineheight"	| descent |	super setActualFont: aFont.	lineHeight == nil		ifTrue: [descent _ font descent.				baseline _ font ascent.				lineHeight _ baseline + descent]		ifFalse: [descent _ lineHeight - baseline max: font descent.				baseline _ baseline max: font ascent.				lineHeight _ lineHeight max: baseline + descent]! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'yo 1/16/2003 17:38'!getPresentation	^ presentation contents.! !!MultiCompositionScanner methodsFor: 'accessing' stamp: 'yo 12/18/2002 14:56'!rightX	"Meaningful only when a line has just been composed -- refers to the 	line most recently composed. This is a subtrefuge to allow for easy 	resizing of a composition rectangle to the width of the maximum line. 	Useful only when there is only one line in the form or when each line 	is terminated by a carriage return. Handy for sizing menus and lists."	breakAtSpace ifTrue: [^ spaceX].	^ destX.! !!CanvasDecoder methodsFor: 'decoding' stamp: 'yo 10/23/2002 23:37'!drawMultiText: command	| boundsEnc colorEnc  text bounds color fontIndexEnc fontIndex |	text := MultiString fromByteArray: (command at: 2) asByteArray.	"text asByteArray printString displayAt: 800@0."	"self halt."	boundsEnc := command at: 3.	fontIndexEnc := command at: 4.	colorEnc := command at: 5.	bounds _ self class decodeRectangle: boundsEnc.	fontIndex := self class decodeInteger: fontIndexEnc.	color _ self class decodeColor: colorEnc.	self drawCommand: [ :c |		c drawString: text in: bounds font: (fonts at: fontIndex) color: color ]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'yo 10/23/2002 23:36'!addFontSetToCache: command	| index font |	index := self class decodeInteger: command second.	font := self class decodeFontSet: command third.	index > fonts size ifTrue: [		| newFonts |		newFonts  := Array new: index.		newFonts replaceFrom: 1 to: fonts size with: fonts.		fonts := newFonts ].	fonts at: index put: font! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'yo 10/23/2002 23:39'!decodeFontSet: fontString	^ StrikeFontSet fontNamed: fontString! !!MultiNewParagraph methodsFor: 'as yet unclassified' stamp: 'yo 1/23/2003 12:53'!multiComposeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines	atY: startingY	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| newResult composer presentationInfo |	composer _ MultiTextComposer new.	presentationLines _ nil.	presentationText _ nil.	newResult _ composer		multiComposeLinesFrom: start 		to: stop 		delta: delta 		into: lineColl 		priorLines: priorLines		atY: startingY		textStyle: textStyle 		text: text 		container: container		wantsColumnBreaks: wantsColumnBreaks == true.	lines _ newResult first asArray.	maxRightX _ newResult second.	presentationInfo _ composer getPresentationInfo.	presentationLines _ presentationInfo first asArray.	presentationText _ presentationInfo second.	"maxRightX printString displayAt: 0@0."	^maxRightX! !!MultiNewParagraph methodsFor: 'as yet unclassified' stamp: 'yo 1/23/2003 17:31'!presentationText	^ presentationText.! !!MultiNewParagraph methodsFor: 'as yet unclassified' stamp: 'yo 1/23/2003 16:09'!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| visibleRectangle offset leftInRun line |	visibleRectangle _ aCanvas clipRect.	offset _ somePosition - positionWhenComposed.	leftInRun _ 0.	(self lineIndexForPoint: visibleRectangle topLeft)		to: (self lineIndexForPoint: visibleRectangle bottomRight)		do: [:i | line _ lines at: i.			self displaySelectionInLine: line on: aCanvas.			line first <= line last ifTrue:				[leftInRun _ displayScanner displayLine: line								offset: offset leftInRun: leftInRun]].! !!MultiNewParagraph methodsFor: 'as yet unclassified' stamp: 'yo 1/23/2003 17:31'!presentationLines	^ presentationLines.! !!MultiNewParagraph methodsFor: 'as yet unclassified' stamp: 'yo 1/23/2003 22:33'!displayOnTest: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| visibleRectangle offset leftInRun line |	(presentationText isNil or: [presentationLines isNil]) ifTrue: [		^ self displayOn: aCanvas using: displayScanner at: somePosition.	].	visibleRectangle _ aCanvas clipRect.	offset _ somePosition - positionWhenComposed.	leftInRun _ 0.	(self lineIndexForPoint: visibleRectangle topLeft)		to: (self lineIndexForPoint: visibleRectangle bottomRight)		do: [:i | line _ presentationLines at: i.			self displaySelectionInLine: line on: aCanvas.			line first <= line last ifTrue:				[leftInRun _ displayScanner displayLine: line								offset: offset leftInRun: leftInRun]].! !!CanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'yo 10/4/2002 20:44'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	self setConditionArray: (textStyle alignment = Justified ifTrue: [#paddedSpace]).! !!CompoundTileMorph methodsFor: 'testing' stamp: 'yo 11/4/2002 20:33'!isTileScriptingElement	^ true! !!ArchiveViewer methodsFor: 'initialization' stamp: 'yo 7/16/2003 15:40'!createButtonBar	| bar button narrowFont asciiFont |	asciiFont := StrikeFont allSubInstances select: [:each | each maxAscii < 256].	narrowFont := asciiFont detectMin: [ :ea | ea widthOfString: 'Contents' from: 1 to: 8 ].	bar := AlignmentMorph newRow.	bar		color: self backgroundColor;		rubberBandCells: false;		vResizing: #shrinkWrap;		cellInset: 6 @ 0.	#(#('New\Archive' #canCreateNewArchive #createNewArchive 'Create a new, empty archive and discard this one') #('Load\Archive' #canOpenNewArchive #openNewArchive 'Open another archive and discard this one') #('Save\Archive As' #canSaveArchive #saveArchive 'Save this archive under a new name') #('Extract\All' #canExtractAll #extractAll 'Extract all this archive''s members into a directory') #('Add\File' #canAddMember #addMember 'Add a file to this archive') #('Add from\Clipboard' #canAddMember #addMemberFromClipboard 'Add the contents of the clipboard as a new file') #('Add\Directory' #canAddMember #addDirectory 'Add the entire contents of a directory, with all of its subdirectories') #('Extract\Member As' #canExtractMember #extractMember 'Extract the selected member to a file') #('Delete\Member' #canDeleteMember #deleteMember 'Remove the selected member from this archive') #('Rename\Member' #canRenameMember #renameMember 'Rename the selected member') #('View All\Contents' #canViewAllContents #changeViewAllContents 'Toggle the view of all the selected member''s contents')) 		do: 			[:arr | 			| buttonLabel |			buttonLabel := (TextMorph new)						string: arr first withCRs							fontName: narrowFont familyName							size: narrowFont pointSize							wrap: false;						hResizing: #shrinkWrap;						lock;						yourself.			(button := PluggableButtonMorph 						on: self						getState: arr second						action: arr third)				vResizing: #shrinkWrap;				hResizing: #spaceFill;				onColor: self buttonOnColor offColor: self buttonOffColor;				label: buttonLabel;				setBalloonText: arr fourth.			bar addMorphBack: button.			buttonLabel composeToBounds].	^bar! !!TextMorph methodsFor: 'private' stamp: 'yo 1/3/2003 12:21'!paragraphClass	container ifNil: [^ MultiNewParagraph].	^ container paragraphClass! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:56'!characterBlockForIndex: targetIndex in: aParagraph 	"Answer a CharacterBlock for character in aParagraph at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destination form rectangle and the composition rectangle."	self 		initializeFromParagraph: aParagraph 		clippedBy: aParagraph clippingRectangle.	characterIndex _ targetIndex.	characterPoint _ 		aParagraph rightMarginForDisplay @ 			(aParagraph topAtLineIndex: 				(aParagraph lineIndexOfCharacterIndex: characterIndex)).	^self buildCharacterBlockIn: aParagraph! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:56'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop done stopCondition |	line _ textLine.	rightMargin _ line rightMargin.	lastIndex _ line first.	self setStopConditions.		"also sets font"	characterIndex _ index.  " == nil means scanning for point"	characterPoint _ aPoint.	(characterPoint == nil or: [characterPoint y > line bottom])		ifTrue: [characterPoint _ line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex ~~ nil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	destX _ leftMargin _ line leftMarginForAlignment: alignment.	destY _ line top.	runLength _ text runLengthFor: line first.	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex  "scanning for index"]		ifFalse:	[lineStop _ line last  "scanning for point"].	runStopIndex _ lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0.	done  _ false.	[done] whileFalse:		[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth == nil			ifTrue: [font widthOf: (text at: lastIndex)]			ifFalse: [specialWidth]).		(self perform: stopCondition) ifTrue:			[characterIndex == nil				ifTrue: ["Result for characterBlockAtPoint: "						^ (CharacterBlock new stringIndex: lastIndex							text: text topLeft: characterPoint + (font descentKern @ 0)							extent: lastCharacterExtent - (font baseKern @ 0))									textLine: line]				ifFalse: ["Result for characterBlockForIndex: "						^ (CharacterBlock new stringIndex: characterIndex							text: text topLeft: characterPoint + ((font descentKern) - kern @ 0)							extent: lastCharacterExtent)									textLine: line]]]! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:56'!lastSpaceOrTabExtentSetX: xVal	lastSpaceOrTabExtent _ xVal @ lastSpaceOrTabExtent y! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:56'!tab	| currentX |	currentX _ (alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastSpaceOrTabExtent _ lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX: (currentX - destX max: 0).	currentX >= characterPoint x		ifTrue: 			[lastCharacterExtent _ lastSpaceOrTabExtent copy.			^ self crossedX].	destX _ currentX.	lastIndex _ lastIndex + 1.	^false! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:56'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				lastCharacter _ nil.				characterPoint _ (nextLeftMargin ifNil: [leftMargin]) @ destY.				lastIndex _ lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:56'!indentationLevel: anInteger	super indentationLevel: anInteger.	nextLeftMargin _ leftMargin.	indentationLevel timesRepeat: [		nextLeftMargin _ textStyle nextTabXFrom: nextLeftMargin					leftMargin: leftMargin					rightMargin: rightMargin]! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:56'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	self setConditionArray: (textStyle alignment = Justified ifTrue: [#paddedSpace]).! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:56'!buildCharacterBlockIn: para	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(para numberOfLines = 0 or: [text size = 0])		ifTrue:	[^ CharacterBlock new stringIndex: 1  "like being off end of string"					text: para text					topLeft: (para leftMarginForDisplayForLine: 1 alignment: (alignment ifNil:[textStyle alignment]))								@ para compositionRectangle top					extent: 0 @ textStyle lineGrid].	"find the line"	lineIndex _ para lineIndexOfTop: characterPoint y.	destY _ para topAtLineIndex: lineIndex.	line _ para lines at: lineIndex.	rightMargin _ para rightMarginForDisplay.	(lineIndex = para numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					self characterPointSetX: rightMargin]			ifFalse:	[characterPoint y < (para compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint _ (para compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[self characterPointSetX: rightMargin]].	destX _ (leftMargin _ para leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment])).	nextLeftMargin_ para leftMarginForDisplayForLine: lineIndex+1 alignment: (alignment ifNil:[textStyle alignment]).	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex == nil		ifTrue:	[lineStop _ line last  "characterBlockAtPoint"]		ifFalse:	[lineStop _ characterIndex  "characterBlockForIndex"].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0. done  _ false.	self handleIndentation.	[done]	whileFalse:	[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition) ifTrue:		[characterIndex == nil			ifTrue: ["characterBlockAtPoint"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + (font descentKern @ 0)						extent: lastCharacterExtent]			ifFalse: ["characterBlockForIndex"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + ((font descentKern) - kern @ 0)						extent: lastCharacterExtent]]]! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:56'!paddedSpace	"When the line is justified, the spaces will not be the same as the font's 	space character. A padding of extra space must be considered in trying 	to find which character the cursor is pointing at. Answer whether the 	scanning has crossed the cursor."	| pad |	pad _ 0.	spaceCount _ spaceCount + 1.	pad _ line justifiedPadFor: spaceCount.	lastSpaceOrTabExtent _ lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX:  spaceWidth + pad.	(destX + lastSpaceOrTabExtent x)  >= characterPoint x		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent copy.				^self crossedX].	lastIndex _ lastIndex + 1.	destX _ destX + lastSpaceOrTabExtent x.	^ false! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:56'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterIndex == nil ifFalse: [		"If the last character of the last line is a space,		and it crosses the right margin, then locating		the character block after it is impossible without this hack."		characterIndex > text size ifTrue: [			lastIndex _ characterIndex.			characterPoint _ (nextLeftMargin ifNil: [leftMargin]) @ (destY + line lineHeight).			^true]].	characterPoint x <= (destX + (lastCharacterExtent x // 2))		ifTrue:	[lastCharacter _ (text at: lastIndex).				characterPoint _ destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter _ (text at: line last).				characterPoint _ destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex _ lastIndex + 1.	lastCharacter _ text at: lastIndex.	currentX _ destX + lastCharacterExtent x + kern.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint _ currentX @ destY.	lastCharacter = Space ifFalse: [^ true].	"Yukky if next character is space or tab."	alignment = Justified ifTrue:		[self lastCharacterExtentSetX:			(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1))).		^ true].	true ifTrue: [^ true].	"NOTE:  I find no value to the following code, and so have defeated it - DI"	"See tabForDisplay for illumination on the following awfulness."	leadingTab _ true.	line first to: lastIndex - 1 do:		[:index | (text at: index) ~= Tab ifTrue: [leadingTab _ false]].	(alignment ~= Justified or: [leadingTab])		ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX					leftMargin: leftMargin rightMargin: rightMargin) -						currentX]		ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -						(line justifiedTabDeltaFor: spaceCount))) -							currentX) max: 0)].	^ true! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:56'!lastCharacterExtentSetX: xVal	lastCharacterExtent _ xVal @ lastCharacterExtent y! !!MultiCharacterBlockScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:56'!characterPointSetX: xVal	characterPoint _ xVal @ characterPoint y! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:56'!endOfRun	"Before arriving at the cursor location, the selection has encountered an 	end of run. Answer false if the selection continues, true otherwise. Set 	up indexes for building the appropriate CharacterBlock."	| runLength lineStop |	(((characterIndex ~~ nil and:		[runStopIndex < characterIndex and: [runStopIndex < text size]])			or:	[characterIndex == nil and: [lastIndex < line last]]) or: [				((lastIndex < line last)				and: [((text at: lastIndex) leadingChar ~= (text at: lastIndex+1) leadingChar)					and: [lastIndex ~= characterIndex]])])		ifTrue:	["We're really at the end of a real run."				runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).				characterIndex ~~ nil					ifTrue:	[lineStop _ characterIndex	"scanning for index"]					ifFalse:	[lineStop _ line last			"scanning for point"].				(runStopIndex _ lastIndex + (runLength - 1)) > lineStop					ifTrue: 	[runStopIndex _ lineStop].				self setStopConditions.				^false].	lastCharacter _ text at: lastIndex.	characterPoint _ destX @ destY.	((lastCharacter = Space and: [alignment = Justified])		or: [lastCharacter = Tab and: [lastSpaceOrTabExtent notNil]])		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent].	characterIndex ~~ nil		ifTrue:	["If scanning for an index and we've stopped on that index,				then we back destX off by the width of the character stopped on				(it will be pointing at the right side of the character) and return"				runStopIndex = characterIndex					ifTrue:	[self characterPointSetX: destX - lastCharacterExtent x.							^true].				"Otherwise the requested index was greater than the length of the				string.  Return string size + 1 as index, indicate further that off the				string by setting character to nil and the extent to 0."				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"Scanning for a point and either off the end of the line or off the end of the string."	runStopIndex = text size		ifTrue:	["off end of string"				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"just off end of line without crossing x"	lastIndex _ lastIndex + 1.	^true! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:56'!setFont	specialWidth _ nil.	super setFont! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:56'!characterBlockAtPoint: aPoint in: aParagraph	"Answer a CharacterBlock for character in aParagraph at point aPoint. It 	is assumed that aPoint has been transformed into coordinates appropriate 	to the text's destination form rectangle and the composition rectangle."	self initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle.	characterPoint _ aPoint.	^self buildCharacterBlockIn: aParagraph! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:56'!placeEmbeddedObject: anchoredMorph	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	specialWidth _ anchoredMorph width.	^ true! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'yo 8/6/2003 05:55'!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| encoding f nextDestX maxAscii startEncoding char charValue |	lastIndex _ startIndex.	lastIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].	startEncoding _ (sourceString at: startIndex) leadingChar.	font ifNil: [font _ (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f _ font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f _ font fontArray at: 1].		f ifNil: [ f _ font fontArray at: 1].		maxAscii _ f maxAscii.		spaceWidth _ f widthOf: Space.	] ifFalse: [		maxAscii _ font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding _ (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex _ lastIndex - 1. ^ stops at: EndOfRun].		char _ (sourceString at: lastIndex).		charValue _ char charCode.		charValue > maxAscii ifTrue: [charValue _ maxAscii].		(encoding = 0 and: [(stopConditions at: charValue + 1) ~~ nil]) ifTrue: [			^ stops at: charValue + 1		].		nextDestX _ destX + (self widthOf: char inFont: font).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX _ nextDestX + kernDelta.		lastIndex _ lastIndex + 1.	].	lastIndex _ stopIndex.	^ stops at: EndOfRun! !!BDFFontReader methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 05:08'!read	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx array width blt lastAscii pointSize ret stream |	form _ encoding _ bbx _ nil.	self initialize.	self readAttributes.	height _ Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent _ Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent _ Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	pointSize _ (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.		maxWidth _ 0.	minAscii _ 9999.	strikeWidth _ 0.	maxAscii _ 0.	charsNum _ Integer readFromString: (properties at: #CHARS) first.	chars _ Set new: charsNum.	1 to: charsNum do: [:i |		array _ self readOneCharacter.		stream _ ReadStream on: array.		form _ stream next.		encoding _ stream next.		bbx _ stream next.		form ifNotNil: [			width _ bbx at: 1.			maxWidth _ maxWidth max: width.			minAscii _ minAscii min: encoding.			maxAscii _ maxAscii max: encoding.			strikeWidth _ strikeWidth + width.			chars add: array.		].	].	chars _ chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum _ chars size. "undefined encodings make this different"	charsNum > 256 ifTrue: [		"it should be 94x94 charset, and should be fixed width font"		strikeWidth _ 94*94*maxWidth.		maxAscii _ 94*94.		minAscii _ 0.		xTable _ XTableForFixedFont new.		xTable maxAscii: 94*94.		xTable width: maxWidth.	] ifFalse: [		xTable _ (Array new: 258) atAllPut: 0.	].	glyphs _ Form extent: strikeWidth@height.	blt _ BitBlt toForm: glyphs.	lastAscii _ 0.		charsNum > 256 ifTrue: [		1 to: charsNum do: [:i |			stream _ ReadStream on: (chars at: i).			form _ stream next.			encoding _ stream next.			bbx _ stream next.			encoding _ ((encoding // 256) - 33) * 94 + ((encoding \\ 256) - 33).			blt copy: ((encoding * maxWidth)@0 extent: maxWidth@height)				from: 0@0 in: form.		].	] ifFalse: [		1 to: charsNum do: [:i |			stream _ ReadStream on: (chars at: i).			form _ stream next.			encoding _ stream next.			bbx _ stream next.			lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].			blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))					extent: (bbx at: 1)@(bbx at: 2))				from: 0@0 in: form.			xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).			lastAscii _ encoding.		]	].	ret _ Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!BDFFontReader methodsFor: 'as yet unclassified' stamp: 'yo 8/5/2003 11:31'!readChars	| strikeWidth ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx array width pointSize stream |	form _ encoding _ bbx _ nil.	self initialize.	self readAttributes.	height _ Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent _ Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent _ Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	pointSize _ (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.		maxWidth _ 0.	minAscii _ 9999.	strikeWidth _ 0.	maxAscii _ 0.	charsNum _ Integer readFromString: (properties at: #CHARS) first.	chars _ Set new: charsNum.	1 to: charsNum do: [:i |		array _ self readOneCharacter.		stream _ ReadStream on: array.		form _ stream next.		encoding _ stream next.		bbx _ stream next.		form ifNotNil: [			width _ bbx at: 1.			maxWidth _ maxWidth max: width.			minAscii _ minAscii min: encoding.			maxAscii _ maxAscii max: encoding.			strikeWidth _ strikeWidth + width.			chars add: array.		].	].	chars _ chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	^ chars.! !!BDFFontReader methodsFor: 'as yet unclassified' stamp: 'yo 8/28/2002 05:09'!readOneCharacter	| str a encoding bbx form bits hi low pos char |	((str _ self getLine) beginsWith: 'STARTCHAR') ifFalse: [self errorFileFormat].	char _ str substrings second.	((str _ self getLine) beginsWith: 'ENCODING') ifFalse: [self errorFileFormat].	encoding _ Integer readFromString: str substrings second.	(self getLine beginsWith: 'SWIDTH') ifFalse: [self errorFileFormat].	(self getLine beginsWith: 'DWIDTH') ifFalse: [self errorFileFormat].		((str _ self getLine) beginsWith: 'BBX') ifFalse: [self errorFileFormat].	a _ str substrings.	bbx _ (2 to: 5) collect: [:i | Integer readFromString: (a at: i)].	((str _ self getLine) beginsWith: 'ATTRIBUTES') ifTrue: [str _ self getLine].	(str beginsWith: 'BITMAP') ifFalse: [self errorFileFormat].	form _ Form extent: (bbx at: 1)@(bbx at: 2).	bits _ form bits.	pos _ 0.	1 to: (bbx at: 2) do: [:t |		1 to: (((bbx at: 1) - 1) // 8 + 1) do: [:i |			hi _ (('0123456789ABCDEF' indexOf: (self next asUppercase)) - 1) bitShift: 4.			low _ ('0123456789ABCDEF' indexOf: (self next asUppercase)) - 1.						bits byteAt: (pos+i) put: (hi+low).		].		self next ~= Character cr ifTrue: [self errorFileFormat].		pos _ pos + ((((bbx at: 1) // 32) + 1) * 4).	].	(self getLine beginsWith: 'ENDCHAR') ifFalse: [self errorFileFormat].	encoding < 0 ifTrue: [^{nil. nil. nil}].	^{form. encoding. bbx}.			! !!TTFontReader methodsFor: 'private' stamp: 'yo 8/11/2003 21:19'!macToWin: index	^ (index - 1) asCharacter squeakToIso asciiValue + 1! !!TTFontReader methodsFor: 'processing' stamp: 'th 6/27/2003 16:58'!processCharMap: assoc	"Process the given character map"	| charTable glyph cmap |	cmap _ assoc value.	charTable _ Array new: 256 withAll: glyphs first. "Initialize with default glyph"	assoc key = 1 ifTrue: "Mac encoded table"		[1 to: (cmap size min: charTable size) do:			[:i |			glyph _ glyphs at: (cmap at: i) + 1.			charTable at: (self macToWin: i) put: glyph]].	assoc key = 3 ifTrue: "Win encoded table"		[1 to: (cmap size min: charTable size) do:			[:i |			glyph _ glyphs at: (cmap at: i) + 1.			charTable at: i put: glyph]].	^ charTable! !!NewParagraph methodsFor: 'composition' stamp: 'yo 12/17/2002 14:48'!testNewComposeAll2	| newResult |	newResult _ TextComposer new		composeLinesFrom: firstCharacterIndex 		to: text size 		delta: 0		into: OrderedCollection new 		priorLines: Array new 		atY: container top		textStyle: textStyle 		text: text 		container: container		wantsColumnBreaks: false.	^{newResult. {lines. maxRightX}}! !!NewParagraph methodsFor: 'composition' stamp: 'yo 12/20/2002 16:18'!composeAll	text string isOctetString ifTrue: [		^ self composeLinesFrom: firstCharacterIndex to: text size delta: 0			into: OrderedCollection new priorLines: Array new atY: container top.	].	^ self multiComposeLinesFrom: firstCharacterIndex to: text size delta: 0		into: OrderedCollection new priorLines: Array new atY: container top.! !!NewParagraph methodsFor: 'selection' stamp: 'yo 1/1/2003 15:09'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ ((text string isKindOf: MultiString) ifTrue: [		MultiCharacterBlockScanner new text: text textStyle: textStyle	] ifFalse: [CharacterBlockScanner new text: text textStyle: textStyle])		characterBlockAtPoint: aPoint index: nil		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'yo 1/1/2003 15:11'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line |	line _ lines at: (self lineIndexForCharacter: index).	^ ((text string isKindOf: MultiString) ifTrue: [		MultiCharacterBlockScanner new text: text textStyle: textStyle	] ifFalse: [		CharacterBlockScanner new text: text textStyle: textStyle	])		characterBlockAtPoint: nil index: ((index max: line first) min: text size+1)		in: line! !!NewParagraph methodsFor: 'composition' stamp: 'yo 12/18/2002 15:00'!testNewComposeAll3	| newResult |	newResult _ TextComposer new		multiComposeLinesFrom: firstCharacterIndex 		to: text size 		delta: 0		into: OrderedCollection new 		priorLines: Array new 		atY: container top		textStyle: textStyle 		text: text 		container: (0@0 extent: 31@60)		wantsColumnBreaks: false.	^{newResult. {lines. maxRightX}}! !!NewParagraph methodsFor: 'composition' stamp: 'yo 1/3/2003 12:17'!multiComposeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines	atY: startingY	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| newResult |	newResult _ MultiTextComposer new		multiComposeLinesFrom: start 		to: stop 		delta: delta 		into: lineColl 		priorLines: priorLines		atY: startingY		textStyle: textStyle 		text: text 		container: container		wantsColumnBreaks: wantsColumnBreaks == true.	lines _ newResult first asArray.	maxRightX _ newResult second.	"maxRightX printString displayAt: 0@0."	^maxRightX! !!NewParagraph methodsFor: 'composition' stamp: 'yo 12/20/2002 16:18'!recomposeFrom: start to: stop delta: delta	"Recompose this paragraph.  The altered portion is between start and stop.	Recomposition may continue to the end of the text, due to a ripple effect.	Delta is the amount by which the current text is longer than it was	when its current lines were composed."	| startLine newLines |	"Have to recompose line above in case a word-break was affected."	startLine _ (self lineIndexForCharacter: start) - 1 max: 1.	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]		whileTrue: [startLine _ startLine - 1].  "Find leftmost of line pieces"	newLines _ OrderedCollection new: lines size + 1.	1 to: startLine-1 do: [:i | newLines addLast: (lines at: i)].	text string isOctetString ifTrue: [		^ self composeLinesFrom: (lines at: startLine) first to: stop delta: delta			into: newLines priorLines: lines			atY: (lines at: startLine) top.	].	self multiComposeLinesFrom: (lines at: startLine) first to: stop delta: delta		into: newLines priorLines: lines		atY: (lines at: startLine) top.! !!CharacterScanner class methodsFor: 'class initialization' stamp: 'yo 12/18/2002 14:09'!initialize"	CharacterScanner initialize"	| a |	a _ Array new: 258.	a at: 1 + 1 put: #embeddedObject.	a at: Tab asciiValue + 1 put: #tab.	a at: CR asciiValue + 1 put: #cr.	a at: EndOfRun put: #endOfRun.	a at: CrossedX put: #crossedX.	NilCondition _ a copy.	DefaultStopConditions _ a copy.	PaddedSpaceCondition _ a copy.	PaddedSpaceCondition at: Space asciiValue + 1 put: #paddedSpace.		SpaceCondition _ a copy.	SpaceCondition at: Space asciiValue + 1 put: #space.! !CharacterScanner initialize!!CharacterScanner methodsFor: 'scanning' stamp: 'yo 12/27/2002 04:32'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isKindOf: String) ifTrue: [^ self basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isKindOf: MultiString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].		startEncoding _  (sourceString at: startIndex) leadingChar.		selector _ (EncodedCharSet charsetAt: startEncoding) scanSelector.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stopConditions with: kernDelta).	].		^ stops at: EndOfRun! !!CharacterScanner methodsFor: 'scanner methods' stamp: 'yo 12/27/2002 04:33'!scanMultiCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex _ startIndex.	lastIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].	startEncoding _ (sourceString at: startIndex) leadingChar.	font ifNil: [font _ (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		maxAscii _ font maxAsciiFor: startEncoding.		f _ font fontArray at: startEncoding + 1.		spaceWidth _ f widthOf: Space.	] ifFalse: [		maxAscii _ font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding _ (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex _ lastIndex - 1. ^ stops at: EndOfRun].		ascii _ (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii _ maxAscii].		(encoding = 0 and: [(stopConditions at: ascii + 1) ~~ nil]) ifTrue: [^ stops at: ascii + 1].		nextDestX _ destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX _ nextDestX + kernDelta.		"destX printString displayAt: 0@(lastIndex*20)."		lastIndex _ lastIndex + 1.	].	lastIndex _ stopIndex.	^ stops at: EndOfRun! !!CharacterScanner methodsFor: 'scanning' stamp: 'yo 9/23/2002 16:13'!basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char |	<primitive: 103>	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[char _ (sourceString at: lastIndex).			ascii _ char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextDestX _ destX + (font widthOf: char).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CharacterScanner methodsFor: 'scanner methods' stamp: 'yo 12/18/2002 12:32'!isBreakableAtIndex: index	^ (EncodedCharSet at: ((text at: index) leadingChar + 1)) isBreakableAt: index in: text.! !!CharacterScanner methodsFor: 'private' stamp: 'yo 10/7/2002 14:33'!setConditionArray: aSymbol	aSymbol == #paddedSpace ifTrue: [^stopConditions _ PaddedSpaceCondition copy].	aSymbol == #space ifTrue: [^stopConditions _ SpaceCondition copy].	aSymbol == nil ifTrue: [^stopConditions _ NilCondition copy].	self error: 'undefined stopcondition for space character'.! !!CharacterScanner methodsFor: 'scanner methods' stamp: 'yo 3/13/2003 11:57'!scanJapaneseCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex _ startIndex.	lastIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].	startEncoding _ (sourceString at: startIndex) leadingChar.	font ifNil: [font _ (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		maxAscii _ font maxAsciiFor: startEncoding.		f _ font fontArray at: startEncoding + 1.		"xTable _ f xTable.		maxAscii _ xTable size - 2."		spaceWidth _ f widthOf: Space.	] ifFalse: [		maxAscii _ font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding _ (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex _ lastIndex - 1. ^ stops at: EndOfRun].		ascii _ (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii _ maxAscii].		(encoding = 0 and: [(stopConditions at: ascii + 1) ~~ nil]) ifTrue: [^ stops at: ascii + 1].		nextDestX _ destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX _ nextDestX + kernDelta.		"destX printString displayAt: 0@(lastIndex*20)."		lastIndex _ lastIndex + 1.	].	lastIndex _ stopIndex.	^ stops at: EndOfRun! !!Vocabulary methodsFor: 'translation' stamp: 'yo 8/11/2003 21:59'!translateCategories: categoryTriplets language: aLanguage	"Establish the category-name translations as per (internalCategorySymbol newCategoryWording balloon-help)"	categoryTriplets do: [:aTriplet |		categories do: [:aCategory |			aCategory categoryName = aTriplet first ifTrue: [				aCategory absorbTranslation: (ElementTranslation new						wording: aTriplet second						helpMessage: aTriplet third						language: aLanguage)]]]! !!Vocabulary class methodsFor: 'class initialization' stamp: 'yo 8/13/2003 21:49'!initializerForLanguageSymbol: natLangSymbol	"Answer the name of the Vocabulary method to call in order to initialize the translations for the given natural-language symbol"	| result |	LanguageTable ifNil: [self initializeLanguageTable].	result _ LanguageTable at: natLangSymbol ifAbsent: [nil].	result ifNil: [^ nil].	^ result first."	Vocabulary initializerForLanguageSymbol: #Deutsch	Vocabulary initializerForLanguageSymbol: #Elmer"! !!Vocabulary class methodsFor: 'class initialization' stamp: 'yo 8/13/2003 21:51'!languageSymbols	"Answer the language symbols currently known to the vocabulary system.  The informtion is held in the LanguageTable, which can be dynamically added to by calling #setTranslationInitializer:forLanguageSymbol:languageClass:"	LanguageTable ifNil: [self initializeLanguageTable].	^ LanguageTable keys asSortedArray	"Vocabulary languageSymbols"! !!Vocabulary class methodsFor: 'class initialization' stamp: 'yo 8/13/2003 21:50'!setTranslationInitializer: aSelector forLanguageSymbol: aLanguageSymbol languageClass: languageClassName	"Make a note of the availability of a language, and of the name of the method that would be invoked to do the actual translation into the language.  This method typically has no senders in an image, but rather is intended to be called by do-its in the preambles or postscripts of updates, etc."	LanguageTable ifNil: [self initializeLanguageTable].	LanguageTable at: aLanguageSymbol put: (Array with: aSelector with: languageClassName)."Vocabulary setTranslationInitializer: #addSalamanderVocabulary forLanguageSymbol: #Salamander languageClass: #English"! !!Vocabulary class methodsFor: 'class initialization' stamp: 'yo 8/13/2003 21:52'!languageClassNameForLanguageSymbol: natLangSymbol	"Answer the name of the Vocabulary method to call in order to initialize the translations for the given natural-language symbol"	| result |	LanguageTable ifNil: [self initializeLanguageTable].	result _ LanguageTable at: natLangSymbol ifAbsent: [nil].	result ifNil: [^ nil].	^ result second."	Vocabulary languageClassNameForLanguageSymbol: #Deutsch	Vocabulary languageClassNameForLanguageSymbol: #Elmer"! !!StrikeFont methodsFor: 'displaying' stamp: 'yo 9/23/2002 20:00'!characters: anInterval in: sourceString displayAt: aPoint 	clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm 	"Simple, slow, primitive method for displaying a line of characters.	No wrap-around is provided."	^ self characters: anInterval in: sourceString displayAt: aPoint 	clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm kernDelta: 0.! !!StrikeFont methodsFor: 'displaying' stamp: 'yo 12/20/2002 18:54'!displayStringR2L: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta	"You are screwed if you reach this method."	self halt.	aBitBlt displayString: aString 			from: startIndex 			to: stopIndex 			at: aPoint 			strikeFont: self			kern: kernDelta.! !!StrikeFont methodsFor: 'file in/out' stamp: 'yo 10/31/2002 22:34'!readBDFFromFile: fileName name: aString	"This builds a StrikeFont instance by reading the X11 Binary 	Distribution Format font source file.  See the BDFFontReader class	comment."	"StrikeFont new readBDFFromFile: 'helvR12' name: 'Helvetica12'."	| fontReader stream |	fontReader _ BDFFontReader oldFileNamed: fileName.	stream _ ReadStream on: fontReader read.	xTable _ stream next.	glyphs _ stream next.	minAscii _ stream next.	maxAscii _ stream next.	maxWidth _ stream next.	ascent _ stream next.	descent _ stream next.	pointSize _ stream next.	name _ aString.	xTable size <= 256 ifTrue: [		self setStopConditions.	].	type _ 0. "no one see this"	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	self reset.! !!StrikeFont methodsFor: 'accessing' stamp: 'yo 8/28/2002 16:33'!xTable: anObject	xTable _ anObject.! !!StrikeFont methodsFor: 'migration' stamp: 'yo 8/11/2003 21:17'!migrateSqueakToIso	| map |	map _ characterToGlyphMap.	map ifNil:[^self "Don't know how to migrate"].	(self name beginsWith: 'NewYork')		ifTrue:[			128 to: 255 do:[:ascii |				map at: ascii + 1 put: ascii]].	((self name beginsWith: 'Comic') or:[self name beginsWith: 'Atlanta'] )		ifTrue:[			128 to: 255 do:[:ascii |				map at: ascii + 1 put: (Character value: ascii) isoToSqueak asciiValue]].! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 8/28/2002 16:35'!fixXTable	| newXTable val |	xTable size >= 258 ifTrue: [		^ self.	].	newXTable _ Array new: 258.	1 to: xTable size do: [:i |		newXTable at: i put: (xTable at: i).	].	val _ xTable at: (xTable size).		xTable size + 1 to: 258 do: [:i |		newXTable at: i put: val.	].	minAscii _ 0.	maxAscii _ 255.	xTable _ newXTable.! !!StrikeFont methodsFor: 'private' stamp: 'yo 9/23/2002 20:17'!createCharacterToGlyphMap	"Private. Create the character to glyph mapping for a font that didn't have any before. This is basically equivalent to what the former setStopCondition did, only based on indexes."	| map |	maxAscii > 258 ifTrue: [^ GlyphMapForFixedFont new].	map _ Array new: 256.	0 to: minAscii - 1 do:[:i| map at: i + 1 put: maxAscii + 1].	minAscii to: maxAscii do:[:i| map at: i + 1 put: i].	maxAscii + 1 to: 255 do:[:i| map at: i + 1 put: maxAscii + 1].	^map! !!StrikeFont methodsFor: 'displaying' stamp: 'yo 7/31/2003 17:20'!characters: anInterval in: sourceString displayAt: aPoint 	clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm kernDelta: kernDelta 	"Simple, slow, primitive method for displaying a line of characters.	No wrap-around is provided."	| ascii destPoint bb leftX rightX sourceRect |	destPoint _ aPoint.	bb _ BitBlt current toForm: Display.	anInterval do: 		[:i | 		ascii _ (sourceString at: i) charCode.		(ascii < minAscii or: [ascii > maxAscii])			ifTrue: [ascii _ maxAscii].		leftX _ xTable at: ascii + 1.		rightX _ xTable at: ascii + 2.		sourceRect _ leftX@0 extent: (rightX-leftX) @ self height.		bb copyFrom: sourceRect in: glyphs to: destPoint.		destPoint _ destPoint + ((rightX-leftX+kernDelta)@0).		"destPoint printString displayAt: 0@(i*20)"].	^ destPoint! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 8/28/2002 16:37'!readCharacter: aBits from: aStream	| pos |	pos _ 0.	12 timesRepeat: [		1 to: 2 do: [ :w |			aBits byteAt: (pos+w) put: (aStream next ). 		].		pos _ pos + 4.	].! !!StrikeFont methodsFor: 'character shapes' stamp: 'yo 12/28/2002 22:37'!characterFormAtMulti: character 	"Answer a Form copied out of the glyphs for the argument, character."	| ascii leftX rightX |	ascii _ character charCode.	(ascii between: minAscii and: maxAscii) ifFalse: [ascii _ maxAscii + 1].	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	^ glyphs copy: (leftX @ 0 corner: rightX @ self height)! !!StrikeFont methodsFor: 'file in/out' stamp: 'yo 9/23/2002 16:30'!readF12FromStream: aStream	| box blt |	minAscii _ 0.	maxAscii _ 94*94.	ascent _ 12.	descent _ 0.	pointSize _ 12.	superscript _ 0.	subscript _ 0.	emphasis _ 0.	maxWidth _ 12.		box _ Form extent: 12@12.	glyphs  _ Form extent: (94*94*12)@12.	blt _ BitBlt toForm: glyphs. 	xTable _ XTableForFixedFont new.	xTable maxAscii: maxAscii + 3.	xTable width: 12.	1 to: 256 do:  [:index | 		1 to: 12 do: [:i |			aStream next.		].	].	(minAscii + 1 to: 94*94) do:  [:index | 		self readCharacter: (box bits) from: aStream.		blt copy: ((12*(index-1))@0 extent: 12@12) from: 0@0 in: box.	].! !!StrikeFont methodsFor: 'file in/out' stamp: 'yo 11/30/2003 17:08'!readEFontBDFForJapaneseFromFile: fileName name: aString overrideWith: otherFileName	| fontReader stream |	fontReader _ EFontBDFFontReaderForRanges readOnlyFileNamed: fileName.	stream _ ReadStream on: (fontReader readRanges: fontReader rangesForJapanese overrideWith: otherFileName otherRanges: {Array with: 8481 with: 12320} additionalOverrideRange: fontReader additionalRangesForJapanese).	xTable _ stream next.	glyphs _ stream next.	minAscii _ stream next.	maxAscii _ stream next.	maxWidth _ stream next.	ascent _ stream next.	descent _ stream next.	pointSize _ stream next.	name _ aString.	type _ 0. "no one see this"	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	self reset.! !!StrikeFont methodsFor: 'file in/out' stamp: 'yo 12/28/2002 21:02'!readEFontBDFFromFile: fileName name: aString rangeFrom: startRange to: endRange	| fontReader stream |	fontReader _ EFontBDFFontReader readOnlyFileNamed: fileName.	stream _ ReadStream on: (fontReader readFrom: startRange to: endRange).	xTable _ stream next.	glyphs _ stream next.	minAscii _ stream next.	maxAscii _ stream next.	maxWidth _ stream next.	ascent _ stream next.	descent _ stream next.	pointSize _ stream next.	name _ aString.	type _ 0. "no one see this"	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	self reset.! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 11/12/2002 12:56'!fixAscent: a andDescent: d head: h	| bb newGlyphs |	"(a + d) = (ascent + descent) ifTrue: ["		ascent _ a.		descent _ d.		newGlyphs _ Form extent: (glyphs width@(h + glyphs height)).		bb _ BitBlt toForm: newGlyphs.		bb copy: (0@h extent: (glyphs extent)) from: 0@0 in: glyphs			fillColor: nil rule: Form over.		glyphs _ newGlyphs.	"]."! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 3/18/2004 00:10'!fixAccuISO8859From: aStrikeFont	| f |	self reset.	xTable _ aStrikeFont xTable copy.	glyphs _ Form extent: aStrikeFont glyphs extent.	maxAscii _ 255.	minAscii _ 0.	"stopConditions _ nil."	0 to: 127 do: [:i |		f _ aStrikeFont characterFormAt: (Character value: i) isoToSqueak.		f width  = 0 ifTrue: [f _ Form extent: 1@f height].				self characterFormAt: (Character value: i) put: f.	].	128 to: 159 do: [:i |		f _ Form extent: 1@f height.		self characterFormAt: (Character value: i) put: f.	].	160 to: 255 do: [:i |		f _ aStrikeFont characterFormAt: (Character value: i) isoToSqueak.		f width  = 0 ifTrue: [f _ Form extent: 1@f height].				self characterFormAt: (Character value: i) put: f.	].			^ self.	! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 9/16/2002 15:07'!fixForISO8859From: aStrikeFont	| fixer m mappingTable |	fixer _ StrikeFontFixer newOn: aStrikeFont.	self reset.	xTable _ aStrikeFont xTable copy.	glyphs _ Form extent: aStrikeFont glyphs extent.	maxAscii _ 255.	minAscii _ 0.	mappingTable _ fixer mappingTable.	"stopConditions _ nil."	0 to: 255 do: [:i |		(m _ mappingTable at: i+1) ~= nil ifTrue: [			self characterFormAt: (Character value: i)				put: (aStrikeFont characterFormAt: (Character value: m)).		] ifFalse: [			self characterFormAt: (Character value: i)				put: (aStrikeFont characterFormAt: (Character space)).		]	].	^self.	! !!StrikeFont methodsFor: 'character shapes' stamp: 'yo 12/1/2003 17:01'!characterFormAt: character 	"Answer a Form copied out of the glyphs for the argument, character."	| ascii leftX rightX |	ascii _ character charCode.	(ascii between: minAscii and: maxAscii) ifFalse: [ascii _ maxAscii + 1].	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	leftX < 0 ifTrue: [^ glyphs copy: (0@0 corner: 0@self height)].	^ glyphs copy: (leftX @ 0 corner: rightX @ self height)! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 8/5/2003 13:11'!newForJapaneseFromEFontBDFFile: fileName name: aString overrideWith: otherFileName	| n |	n _ self new.	n readEFontBDFForJapaneseFromFile: fileName name: aString overrideWith: otherFileName.	^ n.! !!StrikeFont class methodsFor: 'accessing' stamp: 'yo 8/18/2003 22:01'!actualFamilyNames	"Answer a sorted list of actual family names, without the Default aliases"	^(self familyNames copyWithoutAll: #(DefaultTextStyle DefaultFixedTextStyle DefaultMultiStyle)) asOrderedCollection! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 9/23/2002 16:28'!newFromF12File: aFileName	"StrikeFont newFromF12File: 'kaname.f12'"	| file n |	('*.F12' match: aFileName) ifFalse: ["self halt. " "likely incompatible"].	file _ FileStream readOnlyFileNamed: aFileName.	file binary.	n _ self new.	n name: (FileDirectory baseNameFor: (FileDirectory localNameFor: aFileName)).	n readF12FromStream: file.	^ n.! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 9/16/2002 15:55'!fixForISO8859From: aStrikeFont	^aStrikeFont copy fixForISO8859From: aStrikeFont.! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 3/18/2004 00:10'!fixAccuISO8859From: aStrikeFont	^aStrikeFont copy fixAccuISO8859From: aStrikeFont.! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 12/27/2002 16:57'!newFromEFontBDFFile: aFileName name: aString startRange: start endRange: end	| n |	n _ self new.	n readEFontBDFFromFile: aFileName name: aString rangeFrom: start to: end.	^n.	"TextConstants at: #Helvetica put: (TextStyle fontArray: {StrikeFont newFromBDFFile: 'helvR12.bdf' name: 'Helvetica12'})"	"TextConstants at: #Lucida put: (TextStyle fontArray: {StrikeFont newFromBDFFile: 'luRS12.bdf' name: 'Lucida'})"	"TextStyle default fontAt: 5 put: (StrikeFont new readFromStrike2: 'helv12.sf2')."! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:50'!installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColor 	^ aDisplayContext		installStrikeFont: self		foregroundColor: foregroundColor		backgroundColor: backgroundColor.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 16:43'!ascent	^ fontArray first ascent.! !!StrikeFontSet methodsFor: 'character shapes' stamp: 'yo 12/27/2002 04:35'!characterFormAt: character 	| encoding ascii xTable leftX rightX |	encoding _ character leadingChar + 1.	ascii _ character charCode.	(ascii < (fontArray at: encoding) minAscii or: [ascii > (fontArray at: encoding) maxAscii])		ifTrue: [ascii _ (fontArray at: encoding) maxAscii].	xTable _ (fontArray at: encoding) xTable.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	^ (fontArray at: encoding) glyphs copy: (leftX @ 0 corner: rightX @ self height).! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:02'!descentKern	^ fontArray first descentKern.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:15'!copy	| s a |	s _ self class new.	s name: self name.	s emphasis: self emphasis.	s reset.	a _ Array new: fontArray size.	1 to: a size do: [:i |		a at: i put: (fontArray at: i) copy.	].	s fontArray: a.	^ s.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:56'!xTable	"Answer an Array of the left x-coordinate of characters in glyphs."	^ fontArray first xTable.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:06'!emphasis	"Answer the integer code for synthetic bold, italic, underline, and 	strike-out."	^ emphasis.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 12/1/2003 18:00'!bonk: glyphForm with: bonkForm at: j	"Bonking means to run through the glyphs clearing out black pixels	between characters to prevent them from straying into an adjacent	character as a result of, eg, bolding or italicizing"	"Uses the bonkForm to erase at every character boundary in glyphs."	| bb offset font x |	font _ (fontArray at: j).	offset _ bonkForm offset x.	bb _ BitBlt toForm: glyphForm.	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;		combinationRule: Form erase; destY: 0.	x _ font xTable.	(x isMemberOf: SparseLargeTable) ifTrue: [		x base to: x size-1 do: [:i | bb destX: (x at: i) + offset; copyBits].	] ifFalse: [		1 to: x size-1 do: [:i | bb destX: (x at: i) + offset; copyBits].	].! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:52'!maxWidth	^ (fontArray at: 2) maxWidth.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:52'!maxEncoding	^ fontArray size.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:50'!initializeWithFontArray: anArray	fontArray _ anArray.	emphasis _ 0.	name _ anArray first name.	self reset.! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'yo 12/27/2002 13:51'!makeUnderlinedGlyphs	"Make an underlined set of glyphs with same widths"	| g font |	1 to: fontArray size do: [:i |		font _ (fontArray at: i).		font ifNotNil: [			g _ font glyphs deepCopy.			g fillBlack: (0 @ (font ascent+1) extent: g width @ 1).			font setGlyphs: g		].	].! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 16:49'!baseKern	^ fontArray first baseKern.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:49'!fontNameWithPointSize	^ fontArray first fontNameWithPointSize.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:02'!descent	^ fontArray first descent.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:50'!height	^ fontArray first height.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:55'!widthOfString: aString	aString ifNil:[^0].	^ self widthOfString: aString from: 1 to: aString size."	TextStyle default defaultFont widthOfString: 'zort' 21"! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'yo 12/27/2002 13:51'!makeItalicGlyphs	"Make an italic set of glyphs with same widths by skewing left and right		(may require more intercharacter space)"	| g bonkForm bc font |	1 to: fontArray size do: [:j |		font _ (fontArray at: j).		font ifNotNil: [			g _ font glyphs deepCopy.			"BonkForm will have bits where slanted characters overlap their neighbors."			bonkForm _ Form extent: (self height//4+2) @ self height.			bc _ font descent//4 + 1.  "Bonker x-coord corresponding to char boundary."			bonkForm fill: (0 @ 0 corner: (bc+1) @ font ascent) fillColor: Color black.			4 to: font ascent-1 by: 4 do:				[:y | 		"Slide ascenders right..."				g copy: (1@0 extent: g width @ (font ascent - y))					from: 0@0 in: g rule: Form over.				bonkForm copy: (1@0 extent: bonkForm width @ (font ascent - y))					from: 0@0 in: bonkForm rule: Form over].			bonkForm fill: (0 @ 0 corner: (bc+1) @ font ascent) fillColor: Color white.			bonkForm fill: (bc @ font ascent corner: bonkForm extent) fillColor: Color black.			font ascent to: font height-1 by: 4 do:				[:y | 		"Slide descenders left..."				g copy: (0@y extent: g width @ g height)					from: 1@y in: g rule: Form over.				bonkForm copy: (0@0 extent: bonkForm width @ bonkForm height)					from: 1@0 in: bonkForm rule: Form over].			bonkForm fill: (bc @ font ascent corner: bonkForm extent) fillColor: Color white.			"Now use bonkForm to erase at every character boundary in glyphs."			bonkForm offset: (0-bc) @ 0.			font bonk: g with: bonkForm.			font setGlyphs: g		].	].! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 16:49'!ascentKern	^ fontArray first ascentKern.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 20:59'!familyName	^ fontArray first familyName.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:07'!emphasis: code 	"Set the integer code for synthetic bold, itallic, underline, and strike-out, 	where bold=1, italic=2, underlined=4, and struck out=8."	emphasis _ code.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:52'!name	^ name! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:49'!fontArray: anArray	fontArray _ anArray.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:53'!reset	"Reset the cache of derivative emphasized fonts"	derivativeFonts _ Array new: 32.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:53'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , self name.	aStream space.	self height printOn: aStream.	aStream nextPut: $).! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:52'!name: aString	name _ aString! !!StrikeFontSet methodsFor: 'accessing' stamp: 'yo 8/5/2003 15:31'!textStyle	^ TextStyle actualTextStyles detect: [:aStyle | (aStyle fontArray collect: [:s | s name]) includes: self name]		ifNone: [].! !!StrikeFontSet methodsFor: 'character shapes' stamp: 'yo 12/27/2002 04:35'!characterFormAt: character put: characterForm 	| ascii leftX rightX widthDif newGlyphs encoding xTable glyphs |	encoding _ character leadingChar + 1.	ascii _ character charCode.	ascii < (fontArray at: encoding) minAscii ifTrue: [		^ self error: 'Cant store characters below min ascii'	].	ascii > (fontArray at: encoding) maxAscii ifTrue: [		^ self error: 'No change made'	].	xTable _ (fontArray at: encoding) xTable.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	glyphs _ (fontArray at: encoding) glyphs.	widthDif _ characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue: [		newGlyphs _ Form extent: glyphs width + widthDif @ glyphs height.		newGlyphs copy: (0 @ 0 corner: leftX @ glyphs height) from: 0 @ 0			in: glyphs rule: Form over.		newGlyphs				copy: (rightX + widthDif @ 0 corner: newGlyphs width @ glyphs height)				from: rightX @ 0 in: glyphs rule: Form over.		glyphs _ newGlyphs.		"adjust further entries on xTable"		xTable _ xTable copy.		ascii + 2 to: xTable size do: [:i |			xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 extent: characterForm extent) from: 0 @ 0 in: characterForm rule: Form over.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'yo 12/1/2003 23:26'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	| destPoint f noFont |	destPoint _ aPoint.	startIndex to: stopIndex do: [:charIndex | 		| encoding ascii xTable leftX rightX | 		encoding _ (aString at: charIndex) leadingChar + 1.		noFont _ false.		[f _ fontArray at: encoding]			on: Exception do: [:ex | noFont _ true. f _ fontArray at: 1].		f ifNil: [noFont _ true. f _ fontArray at: 1].		ascii _ noFont ifTrue: [$? asciiValue] ifFalse: [(aString at: charIndex) charCode].		((ascii between: f minAscii and: f maxAscii) not) ifTrue: [			ascii _ f maxAscii].		xTable _ f xTable.		leftX _ xTable at: ascii + 1.		leftX < 0 ifTrue: [			leftX _ xTable at: f maxAscii + 2.			rightX _ xTable at: f maxAscii + 3		] ifFalse: [			rightX _ xTable at: ascii + 2.		].		aBitBlt sourceForm: f glyphs.		aBitBlt destX: destPoint x.		aBitBlt destY: destPoint y.		aBitBlt sourceOrigin: leftX @ 0.		aBitBlt width: rightX - leftX.		aBitBlt height: self height.		aBitBlt copyBits.		destPoint _ destPoint + (rightX - leftX + kernDelta @ 0).	].! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:02'!displayLine: aString at: aPoint 	"Display the characters in aString, starting at position aPoint."	self characters: (1 to: aString size)		in: aString		displayAt: aPoint		clippedBy: Display boundingBox		rule: Form over		fillColor: nil.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'yo 8/6/2003 06:10'!characters: anInterval in: sourceString displayAt: aPoint clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm kernDelta: kernDelta	"Simple, slow, primitive method for displaying a line of characters.	No wrap-around is provided."	| ascii encoding destPoint bb leftX rightX sourceRect xTable noFont f |	destPoint _ aPoint.	bb _ BitBlt toForm: Display.	anInterval do: 		[:i |		encoding _ (sourceString at: i) leadingChar + 1.		noFont _ false.		[f _ fontArray at: encoding]			on: Exception do: [:ex | noFont _ true. f _ fontArray at: 1].		f ifNil: [noFont _ true. f _ fontArray at: 1].		ascii _ noFont ifTrue: [$?] ifFalse: [(sourceString at: i) charCode].		(ascii < f minAscii			or: [ascii > f maxAscii])			ifTrue: [ascii _ f maxAscii].		xTable _ f xTable.		leftX _ xTable at: ascii + 1.		rightX _ xTable at: ascii + 2.		sourceRect _ leftX@0 extent: (rightX-leftX) @ self height.		bb copyFrom: sourceRect in: f glyphs to: destPoint.		destPoint _ destPoint + ((rightX-leftX+kernDelta)@0).		"destPoint printString displayAt: 0@(i*20)."	].	^ destPoint.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:50'!lineGrid	| f |	f _ fontArray first.	^ f ascent + f descent.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'yo 12/27/2002 04:35'!displayStringR2L: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	| destPoint font |	destPoint _ aPoint.	startIndex to: stopIndex do: [:charIndex | 		| encoding ascii xTable leftX rightX | 		encoding _ (aString at: charIndex) leadingChar + 1.		ascii _ (aString at: charIndex) charCode.		font _ fontArray at: encoding.		((ascii between: font minAscii and: font maxAscii) not) ifTrue: [			ascii _ font maxAscii].		xTable _ font xTable.		leftX _ xTable at: ascii + 1.		rightX _ xTable at: ascii + 2.		aBitBlt sourceForm: font glyphs.		aBitBlt destX: destPoint x - (rightX - leftX).		aBitBlt destY: destPoint y.		aBitBlt sourceOrigin: leftX @ 0.		aBitBlt width: rightX - leftX.		aBitBlt height: self height.		aBitBlt copyBits.		destPoint _ destPoint - (rightX - leftX + kernDelta @ 0).	].! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:38'!familySizeFace	^ Array		with: fontArray first name		with: self height		with: fontArray first emphasis! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:50'!glyphsEncoding: anInteger	^ (fontArray at: (anInteger+1)) glyphs.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:15'!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base safeCode |	code = 0 ifTrue: [^ self].	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].	derivative _ derivativeFonts at: (safeCode _ code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis _ 1 bitShift: safeCode highBit - 1.	base _ self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative _ (base copy name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative _ (base copy name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative _ (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative _ (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative _ (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:53'!subscript	^ fontArray first subscript! !!StrikeFontSet methodsFor: 'accessing' stamp: 'yo 12/4/2003 20:23'!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| ascii encoding f left right |	((aCharacter isMemberOf: Character) or: [aCharacter leadingChar = 0]) ifTrue: [		f _ (fontArray at: 1).		ascii _ (aCharacter asciiValue min: f maxAscii) max: f minAscii.		^ (f xTable at: ascii + 2) - (f xTable at: ascii + 1).	].	encoding _ aCharacter leadingChar + 1.	ascii _ aCharacter charCode.	[f _ fontArray at: encoding] on: Exception do: [:ex | f _ fontArray at: 1].	f ifNil: [f _ fontArray at: 1].	ascii _ (ascii min: f maxAscii) max: f minAscii.	left _ (f xTable at: ascii + 1).	right _  (f xTable at: ascii + 2).	(left < 0 or: [right < 0]) ifTrue: [^ 10] ifFalse: [^ right - left].! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 21:17'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	dp _ DiskProxy global: #StrikeFontSet selector: #familyName:size:emphasized:			args: (Array with: self familyName with: self pointSize					with: self emphasis).	refStrm replace: self with: dp.	^ dp.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:53'!pointSize	^ fontArray first pointSize.! !!StrikeFontSet methodsFor: 'testing' stamp: 'yo 12/27/2002 04:35'!checkCharacter: aCharacter	| ascii encoding |	encoding _ aCharacter leadingChar + 1.	ascii _ aCharacter charCode.	((ascii < (fontArray at: encoding) minAscii)		or: [ascii > (fontArray at: encoding) maxAscii]) ifTrue: [			^ (fontArray at: 1) maxAscii asCharacter.	] ifFalse: [^ aCharacter].! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:55'!widthOfString: aString from: startIndex to: stopIndex	"Measure the length of the given string between start and stop index"	| character resultX |	resultX _ 0.	startIndex to: stopIndex do:[:i | 		character _ aString at: i.		resultX _ resultX + (self widthOf: character)].	^ resultX.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:56'!xTableEncoding: anInteger	"Answer an Array of the left x-coordinate of characters in glyphs."	^(fontArray at: anInteger + 1) xTable.! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:55'!writeNameOn: file	file nextPutAll: self name.	file close.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'yo 9/23/2002 19:52'!characters: anInterval in: sourceString displayAt: aPoint clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm	"Simple, slow, primitive method for displaying a line of characters.	No wrap-around is provided."	^ self characters: anInterval in: sourceString displayAt: aPoint clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm kernDelta: 0.! !!StrikeFontSet methodsFor: 'private' stamp: 'yo 12/27/2002 13:39'!addNewFont: aFont at: encodingIndex	| newArray |	encodingIndex > fontArray size ifTrue: [		newArray _ Array new: encodingIndex.		newArray replaceFrom: 1 to: fontArray size with: fontArray startingAt: 1.	] ifFalse: [		newArray _ fontArray.	].	newArray at: encodingIndex put: aFont.	self initializeWithFontArray: newArray.! !!StrikeFontSet methodsFor: 'accessing' stamp: 'yo 9/23/2002 20:08'!fontArray	^ fontArray! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:50'!glyphs	^ fontArray first glyphs! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'yo 12/27/2002 13:52'!makeBoldGlyphs	"Make a bold set of glyphs with same widths by ORing 1 bit to the right		(requires at least 1 pixel of intercharacter space)"	| g bonkForm font |	1 to: fontArray size do: [:i |		font _ fontArray at: i.		font ifNotNil: [			g _ font glyphs deepCopy.			bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.			self bonk: g with: bonkForm at: i.			g copyBits: g boundingBox from: g at: (1@0)				clippingBox: g boundingBox rule: Form under fillColor: nil.			(fontArray at: i) setGlyphs: g.		].	].! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 16:57'!characterToGlyphMap	^ fontArray first characterToGlyphMap.! !!StrikeFontSet methodsFor: 'displaying' stamp: 'yo 9/26/2003 22:01'!fontDisplay	"TextStyle default defaultFont fontDisplay."	Display restoreAfter:		[(Form extent: 440@400) displayAt: 90@90.		 0 to: 15 do:			[:i |			i hex displayAt: 100 @ (20 * i + 100).			0 to: 15 do:				[:j |				((16*i+j) between: 1 and: (self xTable size - 2)) ifTrue:					[(self characterFormAt: (16 * i + j) asCharacter)						displayAt: (20 * j + 150) @ (20 * i + 100)]]].			'Click to continue...' asDisplayText displayAt: 100@450]! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:53'!superscript	^ fontArray first superscript! !!StrikeFontSet methodsFor: 'as yet unclassified' stamp: 'yo 9/17/2002 17:23'!encodedForRemoteCanvas	| stream |	stream := RWBinaryOrTextStream on: ''.	self writeNameOn: stream.	^ stream contents asString.! !!StrikeFontSet methodsFor: 'emphasis' stamp: 'yo 12/27/2002 13:53'!makeStruckOutGlyphs	"Make a struck-out set of glyphs with same widths"	| g font |	1 to: fontArray size do: [:i |		font _ (fontArray at: i).		font ifNotNil: [			g _ font glyphs deepCopy.			g fillBlack: (0 @ (font ascent - (font ascent//3)) extent: g width @ 1).			font setGlyphs: g		].	].! !!StrikeFontSet methodsFor: 'accessing' stamp: 'yo 11/15/2002 14:22'!maxAsciiFor: encoding	| f |	f _ (fontArray at: encoding+1).	f ifNotNil: [^ f maxAscii].	^ 0.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 1/27/2003 22:56'!createExternalFontFileForArmenian: fileName"	StrikeFontSet createExternalFontFileForArmenian: 'armenianFont.out'."	| file array f installDirectory |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array _ Array				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'EFontArmenian10' startRange: 16r530 endRange: 16r58F)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'EFontArmenian12' startRange: 16r530 endRange: 16r58F)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'EFontArmenian14' startRange: 16r530 endRange: 16r58F)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'EFonArmenian20' startRange: 16r530 endRange: 16r58F).	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2003 13:04'!familyName: aName size: aSize	"Answer a font (or the default font if the name is unknown) in the specified size."	| collection |	collection _  self allInstances select: [:inst | (inst name beginsWith: aName) and: [inst emphasis = 0]].	collection isEmpty ifTrue: [		(aName = 'DefaultMultiStyle') ifTrue: [			collection _ (TextConstants at: #DefaultMultiStyle) fontArray.		] ifFalse: [			^ TextStyle defaultFont		]	].	collection _ collection asSortedCollection: [:a :b | a pointSize <= b pointSize].	collection do: [:s | (s pointSize >= aSize) ifTrue: [^ s]].	^ TextStyle defaultFont.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 1/25/2003 00:45'!createExternalFontFileForCyrillic: fileName"	StrikeFontSet createExternalFontFileForCyrillic: 'cyrillicFont.out'."	| file array f installDirectory |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array _ Array				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'EFontCyrillic10' startRange: 16r400 endRange: 16r52F)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'EFontCyrillic12' startRange: 16r400 endRange: 16r52F)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'EFontCyrillic14' startRange: 16r400 endRange: 16r52F)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'EFontCyrillic20' startRange: 16r400 endRange: 16r52F).	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 1/27/2003 22:59'!createExternalFontFileForGreek: fileName"	StrikeFontSet createExternalFontFileForGreek: 'greekFont.out'."	| file array f installDirectory |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array _ Array				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'EFontGreek10' startRange: 16r370 endRange: 16r3FF)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'EFontGreek12' startRange: 16r370 endRange: 16r3FF)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'EFontGreek14' startRange: 16r370 endRange: 16r3FF)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'EFonGreek20' startRange: 16r370 endRange: 16r3FF).	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 12/27/2002 15:41'!createExternalFontFileForDefault: fileName	| file array f installDirectory |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array _ Array				with: (self familyName: 'NewYork' size: 12 emphasized: 0)				with: (self familyName: 'NewYork' size: 15 emphasized: 0)				with: (self familyName: 'NewYork' size: 21 emphasized: 0)				with: (self familyName: 'NewYork' size: 26 emphasized: 0).	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 11/12/2002 12:29'!createExternalFontFileForJapanese: fileName	| file array f installDirectory strikeFont |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	strikeFont _ StrikeFont newFromBDFFile: installDirectory , 'kanji18.bdf' name: 'kanji15'.	array _ Array				with: (StrikeFont newFromF12File: installDirectory , 'kaname.f12')				with: ((StrikeFont newFromBDFFile: installDirectory , 'k14.bdf' name: 'Kagotani12')							fixAscent: 12							andDescent: 2							head: 1)				with: (strikeFont copy							fixAscent: 16							andDescent: 2							head: 3)				with: (strikeFont copy							fixAscent: 16							andDescent: 2							head: 8).	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 10/14/2003 14:20'!installExternalFontFileName: fileName encoding: encoding encodingName: aString textStyleName: styleName	^ self installExternalFontFileName: fileName inDir: FileDirectory default encoding: encoding encodingName: aString textStyleName: styleName."StrikeFontSet createExternalFontFileForJapanese: 'japaneseFont.out'.StrikeFontSet createExternalFontFileForChinese: 'chineseFont.out'.StrikeFontSet createExternalFontFileForKorean: 'koreanFont.out'.StrikeFontSet createExternalFontFileForCyrillic: 'cyrillicFont.out'.StrikeFontSet installExternalFontFileName: 'chineseFont.out' encoding: 2 encodingName: #Gb2312 textStyleName: #DefaultMultiStyle.StrikeFontSet installExternalFontFileName: 'japaneseFont.out' encoding: 1 encodingName: #JisX0208 textStyleName: #DefaultMultiStyle.StrikeFontSet installExternalFontFileName: 'defaultFont.out' encoding: 0 encodingName: #Latin1 textStyleName: #DefaultMultiStyle.StrikeFontSet installExternalFontFileName: 'cyrillicFont.out' encoding: UnicodeCyrillic leadingChar encodingName: #Cyrillic textStyleName: #DefaultMultiStyle.StrikeFontSet installExternalFontFileName: 'extendedLatinFont.out' encoding: UnicodeLatinExtendedAB leadingChar encodingName: #ExtendedLatin textStyleName: #DefaultMultiStyle.StrikeFontSet installExternalFontFileName: 'ipaExtensionsFont.out' encoding: UnicodeIPA leadingChar encodingName: #IPAExtensions textStyleName: #DefaultMultiStyle.StrikeFontSet installExternalFontFileName: 'armenianFont.out' encoding: UnicodeArmenian leadingChar encodingName: #Armenian textStyleName: #DefaultMultiStyle.StrikeFontSet installExternalFontFileName: 'greekFont.out' encoding: UnicodeGreek leadingChar encodingName: #Greek textStyleName: #DefaultMultiStyle.StrikeFontSet installExternalFontFileName: 'arrowFont.out' encoding: UnicodeArrows leadingChar encodingName: #Arrow textStyleName: #DefaultMultiStyle.StrikeFontSet installExternalFontFileName: 'uJapaneseFont.out' encoding: UnicodeJapanese leadingChar encodingName: #Japanese textStyleName: #DefaultMultiStyle.StrikeFontSet removeFontsForEncoding: 2 encodingName: #Gb2312.self halt.StrikeFontSet removeFontsForEncoding: 3 encodingName: #KsX1001."! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 10/14/2003 14:17'!createExternalFontFileForArrow: fileName"	StrikeFontSet createExternalFontFileForArrow: 'arrowFont.out'."	| file array f installDirectory |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array _ Array				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'EFontArrow10' startRange: 16r2190 endRange: 16r21FF)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'EFontArrow12' startRange: 16r2190 endRange: 16r21FF)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'EFontArrow14' startRange: 16r2190 endRange: 16r21FF)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'EFonArrow20' startRange: 16r2190 endRange: 16r21FF).	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 1/27/2003 21:35'!createExternalFontFileForIPA: fileName"	StrikeFontSet createExternalFontFileForIPA: 'ipaExtensionsFont.out'."	| file array f installDirectory |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array _ Array				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'EFontIPAExtensions10' startRange: 16r250 endRange: 16r2AF)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'EFontIPAExtensions12' startRange: 16r250 endRange: 16r2AF)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'EFontIPAExtensions14' startRange: 16r250 endRange: 16r2AF)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'EFontIPAExtensions20' startRange: 16r250 endRange: 16r2AF).	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 11/12/2002 12:33'!createExternalFontFileForKorean: fileName	| file array f installDirectory strikeFont |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	strikeFont _ StrikeFont newFromBDFFile: installDirectory, 'hanglm16.bdf' name: 'hanglm16'.	array _ Array				with: (strikeFont copy fixAscent: 16 andDescent: 0 head: -4)				with: (strikeFont copy fixAscent: 16 andDescent: 0 head: -1)				with: (strikeFont copy fixAscent: 16 andDescent: 0 head: 5)				with: (strikeFont copy fixAscent: 16 andDescent: 0 head: 10).	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 12/27/2002 14:08'!duplicateArrayElementsForLeadingCharShift"	self duplicateArrayElementsForLeadingCharShift"	| array font |	self allInstances do: [:s |		s emphasis = 0 ifTrue: [			array _ s fontArray.			2 to: (4 min: array size) do: [:i |				font _ array at: i.				s addNewFont: font at: ((i - 1) << 2) + 1.			].		] ifFalse: [			s reset		].	].! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 8/18/2003 21:03'!familyName: aName size: aSize emphasized: emphasisCode	"Create the font with this emphasis"	^ (self familyName: aName size: aSize) emphasized: emphasisCode! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 11/12/2002 12:57'!createExternalFontFileForChinese: fileName	| file array f installDirectory strikeFont |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	strikeFont _ StrikeFont newFromBDFFile: installDirectory, 'gb16st.bdf' name: 'gb16st'.	array _ Array				with: (strikeFont copy fixAscent: 17 andDescent: 0 head: -5)				with: (strikeFont copy fixAscent: 17 andDescent: 0 head: -2)				with: (strikeFont copy fixAscent: 17 andDescent: 0 head: 4)				with: (strikeFont copy fixAscent: 16 andDescent: 2 head: 8).	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2003 10:57'!createExternalFontFileForUnicodeJapanese: fileName"	StrikeFontSet createExternalFontFileForUnicodeJapanese: 'uJapaneseFont.out'."	| file array f installDirectory |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array _ Array				with: (StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'Japanese10' overrideWith: 'shnmk12.bdf')				with: ((StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'Japanese12' overrideWith: 'shnmk14.bdf') "fixAscent: 14 andDescent: 1 head: 1")				with: ((StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'Japanese14' overrideWith: 'shnmk16.bdf') fixAscent: 16 andDescent: 4 head: 4)				with: (StrikeFont newForJapaneseFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'Japanese18' overrideWith: 'kanji24.bdf').	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 9/23/2002 16:32'!fontNamed: aString	^ self allInstances detect: [:inst | inst name = aString] ifNone: [TextStyle defaultFont]! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 9/23/2002 16:32'!newFontArray: anArray 	^super new initializeWithFontArray: anArray! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2003 00:32'!installExternalFontFileName: fileName inDir: dir encoding: encoding encodingName: aString textStyleName: styleName	| array arrayFour oldStyle arrayOfFS fs fonts newFonts |	array _ (ReferenceStream on: (dir readOnlyFileNamed: fileName)) next.	arrayFour _ Array new: 4 withAll: array last.	arrayFour replaceFrom: 1 to: array size with: array startingAt: 1.	TextConstants at: aString asSymbol put: arrayFour.	oldStyle _ TextConstants at: styleName asSymbol.	arrayOfFS _ oldStyle fontArray.	arrayOfFS _ (1 to: 4) collect: [:i |		fs _ arrayOfFS at: i.		fonts _ fs fontArray.		encoding + 1 > fonts size ifTrue: [			newFonts _ Array new: encoding + 1.			newFonts replaceFrom: 1 to: fonts size with: fonts startingAt: 1.			newFonts at: encoding + 1 put: (arrayFour at: i).			fs initializeWithFontArray: newFonts.		] ifFalse: [			fonts at: encoding + 1 put: (arrayFour at: i).		].		fs.	].	TextConstants at: styleName asSymbol put: (TextStyle fontArray: arrayOfFS).	oldStyle becomeForward: (TextConstants at: styleName asSymbol).! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 1/25/2003 00:45'!createExternalFontFileForExtendedLatin: fileName"	StrikeFontSet createExternalFontFileForExtendedLatin: 'extendedLatinFont.out'."	| file array f installDirectory |	file _ FileStream newFileNamed: fileName.	installDirectory _ Smalltalk at: #M17nInstallDirectory ifAbsent: [].	installDirectory _ installDirectory		ifNil: [String new]		ifNotNil: [installDirectory , FileDirectory pathNameDelimiter asString].	array _ Array				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b12.bdf' name: 'EFontExtendedLatin10' startRange: 16r100 endRange: 16r24F)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b14.bdf' name: 'EFontExtendedLatin12' startRange: 16r100 endRange: 16r24F)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b16.bdf' name: 'EFontExtendedLatin14' startRange: 16r100 endRange: 16r24F)				with: (StrikeFont newFromEFontBDFFile: installDirectory , 'b24.bdf' name: 'EFontExtendedLatin20' startRange: 16r100 endRange: 16r24F).	TextConstants at: #forceFontWriting put: true.	f _ ReferenceStream on: file.	f nextPut: array.	file close.	TextConstants removeKey: #forceFontWriting.! !!StrikeFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 11/12/2002 13:32'!removeFontsForEncoding: leadingChar encodingName: encodingSymbol	| insts fonts newFonts index |	leadingChar = 0 ifTrue: [^ self error: 'you cannot delete the intrinsic fonts'].	insts _ self allInstances.	insts do: [:inst |		fonts _ inst fontArray.		fonts size >= (leadingChar + 1) ifTrue: [			leadingChar + 1 = fonts size ifTrue: [				newFonts _ fonts copyFrom: 1 to: fonts size - 1.				index _ newFonts indexOf: nil.				index > 0 ifTrue: [newFonts _ newFonts copyFrom: 1 to: index - 1].				inst initializeWithFontArray: newFonts.			] ifFalse: [				fonts at: leadingChar + 1 put: nil.			].		].	].	TextConstants removeKey: encodingSymbol asSymbol.! !!AbstractFont methodsFor: 'accessing' stamp: 'yo 12/20/2002 18:59'!isL2R	self subclassResponsibility! !!AbstractFont methodsFor: 'displaying' stamp: 'yo 12/20/2002 18:58'!displayStringR2L: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDelta	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) display context."	^self subclassResponsibility! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'yo 4/2/2003 06:54'!contentStream	"Answer my contents as a string."	| s |	s _ MultiByteBinaryOrTextStream on: (String new: self uncompressedSize).	self extractTo: s.	^s reset! !!CanvasEncoder methodsFor: 'drawing' stamp: 'yo 10/23/2002 23:40'!drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c	| fontIndex str |	fontIndex := self establishFont: (fontOrNil ifNil: [ TextStyle defaultFont ]).	str _ s asString.	str class = MultiString ifTrue: [		self sendCommand: {			String with: CanvasEncoder codeMultiText.			(str copyFrom: firstIndex to: lastIndex) asByteArray asString.			self class encodeRectangle: boundsRect.			self class encodeInteger: fontIndex.			self class encodeColor: c		}	] ifFalse: [		self sendCommand: {			String with: CanvasEncoder codeText.			s asString copyFrom: firstIndex to: lastIndex.			self class encodeRectangle: boundsRect.			self class encodeInteger: fontIndex.			self class encodeColor: c		}	].! !!CanvasEncoder class methodsFor: 'codes' stamp: 'yo 10/23/2002 23:42'!codeMultiText	^ $c! !!CanvasEncoder class methodsFor: 'codes' stamp: 'yo 10/23/2002 23:41'!codeFontSet	^ $S! !!MultiDisplayScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:58'!setDestForm: df	bitBlt setDestForm: df.! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:58'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex_ lastIndex + 1.	^false! !!MultiDisplayScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:58'!setFont 	foregroundColor _ paragraphColor.	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"	font installOn: bitBlt foregroundColor: foregroundColor backgroundColor: Color transparent.	text ifNotNil:[destY _ lineY + line baseline - font ascent]! !!MultiDisplayScanner methodsFor: 'MVC-compatibility' stamp: 'yo 12/18/2002 13:58'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	morphicOffset _ 0@0.	leftInRun _ 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment]).			destX _ (runX _ leftMargin).			line _ aParagraph lines at: lineIndex.			lineHeight _ line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex _ line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun _ text runLengthFor: line first].			destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"			runLength _ leftInRun.			runStopIndex _ lastIndex + (runLength - 1) min: line last.			leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).			spaceCount _ 0.			done _ false.			string _ text string.			self handleIndentation.			[done] whileFalse:[				startIndex _ lastIndex.				lastPos _ destX@destY.				stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern].				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].			fillBlt == nil ifFalse:				[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY _ lineY + lineHeight]]! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:58'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	spaceCount _ spaceCount + 1.	destX _ destX + spaceWidth + (line justifiedPadFor: spaceCount).	lastIndex _ lastIndex + 1.	^ false! !!MultiDisplayScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:58'!text: t textStyle: ts foreground: foreColor background: backColor fillBlt: blt ignoreColorChanges: shadowMode	text _ t.	textStyle _ ts. 	foregroundColor _ paragraphColor _ foreColor.	(backgroundColor _ backColor) isTransparent ifFalse:		[fillBlt _ blt.		fillBlt fillColor: backgroundColor].	ignoreColorChanges _ shadowMode! !!MultiDisplayScanner methodsFor: 'multilingual scanning' stamp: 'yo 12/20/2002 11:52'!isBreakableAt: index in: sourceString in: encodingClass	^ false.! !!MultiDisplayScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:58'!textColor: textColor	ignoreColorChanges ifTrue: [^ self].	foregroundColor _ textColor! !!MultiDisplayScanner methodsFor: 'MVC-compatibility' stamp: 'yo 12/18/2002 13:58'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt _ BitBlt current toForm: aParagraph destinationForm.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt combinationRule: Form paint.	bitBlt colorMap:		(Bitmap with: 0      "Assumes 1-bit deep fonts"				with: (bitBlt destForm pixelValueFor: aParagraph foregroundColor)).	bitBlt clipRect: clippingRectangle.! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:58'!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	lastIndex = line last ifTrue: [^true].	runX _ destX.	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).	runStopIndex _ lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!MultiDisplayScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:58'!setPort: aBitBlt	"Install the BitBlt to use"	bitBlt _ aBitBlt.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt sourceForm: nil. "Make sure font installation won't be confused"! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:58'!placeEmbeddedObject: anchoredMorph	anchoredMorph relativeTextAnchorPosition ifNotNil:[		anchoredMorph position: 			anchoredMorph relativeTextAnchorPosition +			(anchoredMorph owner textBounds origin x @ 0)			- (0@morphicOffset y) + (0@lineY).		^true	].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph ifTrue: [		anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset	] ifFalse: [		destY _ lineY.		runX _ destX.		anchoredMorph 			displayOn: bitBlt destForm 			at: destX - anchoredMorph width @ destY			clippingBox: bitBlt clipRect	].	^ true! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:58'!tab	self plainTab.	lastIndex _ lastIndex + 1.	^ false! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:58'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	self setConditionArray: (alignment = Justified ifTrue: [#paddedSpace])."	alignment = Justified ifTrue: [		stopConditions == DefaultStopConditions 			ifTrue:[stopConditions _ stopConditions copy].		stopConditions at: Space asciiValue + 1 put: #paddedSpace]"! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:58'!plainTab	| oldX |	oldX _ destX.	super plainTab.	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits]! !!MultiDisplayScanner methodsFor: 'multilingual scanning' stamp: 'yo 8/6/2003 05:57'!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| encoding f nextDestX maxAscii startEncoding char charValue |	lastIndex _ startIndex.	lastIndex > stopIndex ifTrue: [lastIndex _ stopIndex. ^ stops at: EndOfRun].	startEncoding _ (sourceString at: startIndex) leadingChar.	font ifNil: [font _ (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f _ font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f _ font fontArray at: 1].		f ifNil: [ f _ font fontArray at: 1].		maxAscii _ f maxAscii.		spaceWidth _ f widthOf: Space.	] ifFalse: [		maxAscii _ font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding _ (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex _ lastIndex - 1. ^ stops at: EndOfRun].		char _ (sourceString at: lastIndex).		charValue _ char charCode.		charValue > maxAscii ifTrue: [charValue _ maxAscii].		(encoding = 0 and: [(stopConditions at: charValue + 1) ~~ nil]) ifTrue: [			^ stops at: charValue + 1		].		nextDestX _ destX + (self widthOf: char inFont: font).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX _ nextDestX + kernDelta.		lastIndex _ lastIndex + 1.	].	lastIndex _ stopIndex.	^ stops at: EndOfRun! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:58'!crossedX	"This condition will sometimes be reached 'legally' during display, when, 	for instance the space that caused the line to wrap actually extends over 	the right boundary. This character is allowed to display, even though it 	is technically outside or straddling the clipping ectangle since it is in 	the normal case not visible and is in any case appropriately clipped by 	the scanner."	^ true ! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'yo 8/6/2003 11:48'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line _ textLine.	morphicOffset _ offset.	lineY _ line top + offset y.	lineHeight _ line lineHeight.	rightMargin _ line rightMargin + offset x.	lastIndex _ line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin _ (line leftMarginForAlignment: alignment) + offset x.	destX _ runX _ leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex _ line first.	leftInRun <= 0		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	destY _ lineY + line baseline - font ascent.	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	done _ false.	string _ text string.	[done] whileFalse:[		startIndex _ lastIndex.		lastPos _ destX@destY.		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern].		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition.		"lastIndex > runStopIndex ifTrue: [done _ true]."	].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!MultiDisplayScanner methodsFor: 'private' stamp: 'yo 1/23/2003 14:40'!presentationText: t	text _ t.! !!MultiDisplayScanner class methodsFor: 'queries' stamp: 'yo 12/18/2002 13:58'!defaultFont	^ TextStyle defaultFont! !!ScriptableButton methodsFor: 'label' stamp: 'yo 11/4/2002 22:13'!label: aString font: aFontOrNil	"Set the receiver's label and font as indicated"	| oldLabel m aFont |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	aFont _ aFontOrNil ifNil: [TextStyle defaultFont].	m _ StringMorph contents: aString font: aFont.	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!TextStyle methodsFor: 'accessing' stamp: 'yo 10/17/2002 15:27'!printOn: aStream	super printOn: aStream.	(fontArray first isMemberOf: StrikeFont) ifTrue: [		aStream space; nextPutAll: self defaultFont familySizeFace first	] ifFalse: [		aStream space; nextPutAll: self defaultFont familySizeFace first; nextPutAll: '(FontSet)'	]! !!TextStyle class methodsFor: 'TextConstants access' stamp: 'yo 8/18/2003 22:02'!actualTextStyles	| aDict |	"TextStyle actualTextStyles"	"Answer dictionary whose keys are the names of styles in the system and whose values are the actual styles"	aDict _ TextConstants select: [:thang | thang isKindOf: self ].	aDict removeKey: #DefaultTextStyle.	aDict removeKey: #DefaultFixedTextStyle.	aDict removeKey: #DefaultMultiStyle.	^ aDict! !!FlapTab methodsFor: 'textual tabs' stamp: 'yo 7/16/2003 15:25'!assumeString: aString font: aFont orientation: orientationSymbol color: aColor 	| aTextMorph workString tabStyle |	labelString := aString asString.	workString := orientationSymbol == #vertical 				ifTrue: 					[String streamContents: 							[:s | 							labelString do: [:c | s nextPut: c] separatedBy: [s nextPut: Character cr]]]				ifFalse: [labelString]. 	tabStyle := (TextStyle new)				leading: 0;				newFontArray: (Array with: aFont).	aTextMorph := (TextMorph new setTextStyle: tabStyle) 				contents: (workString asText addAttribute: (TextKern kern: 3)).	self removeAllMorphs.	self		borderWidth: 2;		borderColor: #raised.	aColor ifNotNil: [self color: aColor].	self addMorph: aTextMorph centered.	aTextMorph lock	"FlapTab allSubInstancesDo: [:ft | ft reformatTextualTab]"! !!CombinedChar methodsFor: 'as yet unclassified' stamp: 'yo 12/31/2002 21:43'!combined	^ Unicode value: combined.! !!CombinedChar methodsFor: 'as yet unclassified' stamp: 'yo 12/31/2002 18:57'!add: unicode	| dict elem |	codes ifNil: [codes _ Array with: unicode. combined _ unicode. ^ true].	dict _ Compositions at: combined ifAbsent: [^ false].	elem _ dict at: unicode ifAbsent: [^ false].	codes _ codes copyWith: unicode.	combined _ elem.	^ true.! !!CombinedChar methodsFor: 'as yet unclassified' stamp: 'yo 1/1/2003 10:42'!base	^ Unicode value: codes first.! !!CombinedChar class methodsFor: 'as yet unclassified' stamp: 'yo 12/31/2002 19:09'!parseCompositionMappingFrom: stream"	self halt.	self parseCompositionMapping"	| line fieldEnd point fieldStart compositions toNumber diacritical result |	toNumber _ [:quad | ('16r', quad) asNumber].	Compositions _ IdentityDictionary new: 2048.	Decompositions _ IdentityDictionary new: 2048.	Diacriticals _ IdentitySet new: 2048.	[(line _ stream upTo: Character cr) size > 0] whileTrue: [		fieldEnd _ line indexOf: $; startingAt: 1.		point _ ('16r', (line copyFrom: 1 to: fieldEnd - 1)) asNumber.		2 to: 6 do: [:i |			fieldStart _ fieldEnd + 1.			fieldEnd _ line indexOf: $; startingAt: fieldStart.		].		compositions _ line copyFrom: fieldStart to: fieldEnd - 1.		(compositions size > 0 and: [compositions first ~= $<]) ifTrue: [			compositions _ compositions substrings collect: toNumber.			compositions size > 1 ifTrue: [				diacritical _ compositions first.				Diacriticals add: diacritical.				result _ compositions second.				(Decompositions includesKey: point) ifTrue: [					self error: 'should not happen'.				] ifFalse: [					Decompositions at: point put: (Array with: diacritical with: result).				].				(Compositions includesKey: diacritical) ifTrue: [					(Compositions at: diacritical) at: result put: point.				] ifFalse: [					Compositions at: diacritical						put: (IdentityDictionary new at: result put: point; yourself).				].			].		].	].! !!CombinedChar class methodsFor: 'as yet unclassified' stamp: 'yo 12/31/2002 19:21'!isDiacriticals: unicode	^ Diacriticals includes: unicode.! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'yo 10/4/2002 20:43'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	self setConditionArray: (alignment = Justified ifTrue: [#paddedSpace])."	alignment = Justified ifTrue: [		stopConditions == DefaultStopConditions 			ifTrue:[stopConditions _ stopConditions copy].		stopConditions at: Space asciiValue + 1 put: #paddedSpace]"! !!DisplayScanner methodsFor: 'scanning' stamp: 'yo 10/7/2002 18:38'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line _ textLine.	morphicOffset _ offset.	lineY _ line top + offset y.	lineHeight _ line lineHeight.	rightMargin _ line rightMargin + offset x.	lastIndex _ line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin _ (line leftMarginForAlignment: alignment) + offset x.	destX _ runX _ leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex _ line first.	leftInRun <= 0		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	destY _ lineY + line baseline - font ascent.	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	done _ false.	string _ text string.	[done] whileFalse:[		startIndex _ lastIndex.		lastPos _ destX@destY.		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern].		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition.		lastIndex > runStopIndex ifTrue: [done _ true].	].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!TTCFontDescription methodsFor: 'as yet unclassified' stamp: 'yo 12/27/2002 04:25'!at: aCharOrInteger	| char |	char _ aCharOrInteger asCharacter.	^ glyphs at: (char charCode) + 1.! !!TTCFontDescription methodsFor: 'as yet unclassified' stamp: 'yo 11/14/2002 18:28'!size	^ glyphs size.! !!TTCFontDescription methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2002 22:50'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	dp _ DiskProxy global: #TTCFontDescription selector: #descriptionNamed:at:			args: {self name. ((TTCFontDescription descriptionNamed: self name) indexOf: self)}.	refStrm replace: self with: dp.	^ dp.! !!TTCFontDescription methodsFor: 'as yet unclassified' stamp: 'yo 11/14/2002 18:42'!name	^ self familyName copyWithout: Character space.! !!TTCFontDescription methodsFor: 'as yet unclassified' stamp: 'yo 11/14/2002 22:40'!deepCopy	^ self.! !!TTCFontDescription methodsFor: 'as yet unclassified' stamp: 'yo 11/14/2002 22:41'!veryDeepCopyWith: deepCopier	"Return self.  I am shared.  Do not record me."! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2002 22:44'!default	^ TTCDefault.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 19:47'!addFromTTFile: fileName"	Execute the following only if you know what you are doing.	self addFromTTFile: 'C:\WINDOWS\Fonts\msgothic.TTC'"	| tt old |	tt _ TTCFontReader readFrom: (FileStream readOnlyFileNamed: fileName).	old _ TTCDescriptions detect: [:f | f first name = tt first name] ifNone: [nil].	old ifNotNil: [TTCDescriptions remove: old].	TTCDescriptions add: tt.	^ tt.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2002 23:10'!initialize"	self initialize"	self clearDescriptions.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2002 23:13'!descriptionNamed: descriptionName at: index	| array |	array _  self descriptionNamed: descriptionName.	^ array at: index.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2002 23:27'!setDefault"	self setDefault"	TTCDefault _ TTCFontReader readFrom: (FileStream readOnlyFileNamed: 'C:\WINDOWS\Fonts\msgothic.ttc').	self clearDescriptions.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2002 23:10'!clearDescriptions"	self clearDescriptions"	TTCDescriptions _ Set new.	TTCDefault ifNotNil: [TTCDescriptions add: TTCDefault].! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 19:29'!descriptionNamed: descriptionName	^ TTCDescriptions detect: [:f | f first name = descriptionName] ifNone: [TTCDefault].! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 02:01'!clearDefault"	self clearDefault"	TTCDefault _ nil.! !!TTCFontDescription class methodsFor: 'as yet unclassified' stamp: 'yo 12/1/2002 00:10'!removeDescriptionNamed: descriptionName	| tt |	TTCDescriptions ifNil: [^ self].	tt _ TTCDescriptions detect: [:f | f name = descriptionName] ifNone: [nil].	tt ifNotNil: [TTCDescriptions remove: tt].! !!Workspace methodsFor: 'drag and drop' stamp: 'yo 11/4/2002 22:50'!acceptDroppingMorph: dropee event: evt inMorph: targetMorph 	"Return the dropee to its old position, and add a reference to it at the cursor point."	| bindingName externalName |	externalName _ dropee externalName.	externalName _ externalName isOctetString		ifTrue: [externalName] ifFalse: ['a' , externalName].	bindingName _ externalName translateToLowercase, dropee identityHash printString.	targetMorph correctSelectionWithString: bindingName, ' '.	(self bindingOf: bindingName) value: dropee.	dropee rejectDropMorphEvent: evt.	^ true "success"! !!Preferences class methodsFor: 'fonts' stamp: 'yo 11/5/2002 12:13'!restoreDefaultFontsForJapanese	"Preferences restoreDefaultFontsForJapanese"	#(	"(setButtonFontTo:		ComicBold		15)"		(setTextButtonFontTo:		NewYork		12)		"(setCodeFontTo:			NewYork		12)"  "Later"		(setFlapsFontTo:			NewYork		15)		(setListFontTo:			NewYork		12)		(setMenuFontTo:			NewYork		12)		(setWindowTitleFontTo:	NewYork		15)		(setSystemFontTo:		NewYork		12)) do:			[:triplet |				self perform: triplet first with: (StrikeFontSet familyName: triplet second size: triplet third)].	self setButtonFontTo: (StrikeFont familyName: #ComicBold size: 16).	Smalltalk at: #BalloonMorph ifPresent:		[:thatClass | thatClass setBalloonFontTo: (StrikeFontSet familyName: #NewYork size: 12)].	"Note:  The standardCodeFont is not currently used -- the default font is instead; later hopefully we can split the code font out as  a separate choice, but only after we're able to have the protocols reorganized such that we can know whether it's code or not when we launch the text object.	Note:  The standard button font is reset by this code but is not otherwise settable by a public UI (too many things can go afoul) "! !!NebraskaNavigationMorph methodsFor: 'as yet unclassified' stamp: 'yo 11/4/2002 21:06'!fontForButtons	^ TextStyle defaultFont.	"^Preferences standardButtonFont"! !!SparseXTable methodsFor: 'as yet unclassified' stamp: 'yo 7/30/2003 17:38'!tableFor: code	| div t table |	div _ code // 65536.	t _ xTables at: div ifAbsent: [table _ Array new: 65536 withAll: 0. xTables at: div put: table. table].	^ t.! !!FormCanvas methodsFor: 'drawing' stamp: 'yo 1/23/2003 17:50'!paragraph3: para bounds: bounds color: c	| scanner |	self setPaintColor: c.	scanner _ (port clippedBy: (bounds translateBy: origin)) displayScannerForMulti: para		foreground: (self shadowColor ifNil:[c]) background: Color transparent		ignoreColorChanges: self shadowColor notNil.	para displayOnTest: (self copyClipRect: bounds) using: scanner at: origin+ bounds topLeft.! !!TTFontDescription methodsFor: 'printing' stamp: 'th 6/27/2003 17:08'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	familyName printOn: aStream.	aStream nextPut:$).! !!TTFontDescription methodsFor: 'migration' stamp: 'yo 8/11/2003 21:17'!migrateSqueakToIso	| tempTable |	tempTable _ glyphTable copy.	128 to: 255 do:[:ascii |		glyphTable			at: ascii + 1			put:(tempTable at:(Character value: ascii) isoToSqueak asciiValue + 1)]! !!EFontBDFFontReader methodsFor: 'as yet unclassified' stamp: 'yo 12/1/2003 22:21'!readFrom: start to: end	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx width blt lastAscii pointSize ret lastValue |	form _ encoding _ bbx _ nil.	self initialize.	self readAttributes.	height _ Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent _ Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent _ Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	(properties includesKey: 'POINT_SIZE' asSymbol) ifTrue: [		pointSize _ (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.	] ifFalse: [		pointSize _ (ascent + descent) * 72 // 96.	].				maxWidth _ 0.	minAscii _ 16r200000.	strikeWidth _ 0.	maxAscii _ 0.	charsNum _ Integer readFromString: (properties at: #CHARS) first.	chars _ Set new: charsNum.	self readCharactersInRangeFrom: start to: end totalNums: charsNum storeInto: chars.	chars _ chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum _ chars size. "undefined encodings make this different"	chars do: [:array |		encoding _ array at: 2.		bbx _ array at: 3..		width _ bbx at: 1.		maxWidth _ maxWidth max: width.		minAscii _ minAscii min: encoding.		maxAscii _ maxAscii max: encoding.		strikeWidth _ strikeWidth + width.	].	glyphs _ Form extent: strikeWidth@height.	blt _ BitBlt toForm: glyphs.	"xTable _ XTableForUnicodeFont new ranges: (Array with: (Array with: start with: end))."	xTable _ SparseLargeTable new: end + 3 chunkSize: 32 arrayClass: Array base: start defaultValue: -1.	lastAscii _ start.		1 to: charsNum do: [:i |		form _ (chars at: i) first.		encoding _ (chars at: i) second.		bbx _ (chars at: i) third.		"lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)]."		lastValue _ xTable at: lastAscii + 1 + 1.		xTable at: encoding + 1 put: lastValue.		blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form.		xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).		lastAscii _ encoding.	].	xTable zapDefaultOnlyEntries.	ret _ Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!EFontBDFFontReader methodsFor: 'as yet unclassified' stamp: 'yo 12/28/2002 22:03'!readCharactersInRangeFrom: start to: stop totalNums: upToNum storeInto: chars	| array form code |	1 to: upToNum do: [:i |		array _ self readOneCharacter.		code _ array at: 2.		code > stop ifTrue: [^ self].		(code between: start and: stop) ifTrue: [			form _ array at: 1.			form ifNotNil: [				chars add: array.			].		].	].! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2003 20:03'!processCharMap: assoc	"Process the given character map"	| glyph cmap encode0 encode1 char value null |	cmap _ assoc value.	null _ (glyphs at: (cmap at: Character space asUnicode + 1) + 1) copy.	null contours: #().	encode0 _ Array new: 256 withAll: glyphs first.	encode1 _ Array new: 65536 withAll: glyphs first.	0 to: 255 do: [:i |		char _ Character value: i.		glyph _ glyphs at: (cmap at: char asUnicode + 1) + 1.		encode0 at: i+1 put: glyph.	].	Character separators do: [:c |		encode0 at: (c asciiValue + 1) put: null.	].	0 to: 65536 - 1 do: [:i |		value _ cmap at: i+1.		encode1 at: i+1 put: (glyphs at: value+1).	].	^ {encode0. encode1}.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2003 20:03'!readFrom: aStream	"Read the raw font byte data"	| fontData |	(aStream respondsTo: #binary) ifTrue:[aStream binary].	fontData _ aStream contents asByteArray.	fonts _ self parseTTCHeaderFrom: fontData.	^ ((Array with: fonts first) collect: [:offset |		fontDescription _ TTCFontDescription new.		self readFrom: fontData fromOffset: offset.	]) at: 1.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2002 15:12'!getTableDirEntry: tagString from: fontData offset: offset	"Find the table named tagString in fontData and return a table directory entry for it."	| nTables pos currentTag tag |	nTables _ fontData shortAt: 5 + offset bigEndian: true.	tag _ ByteArray new: 4.	1 to: 4 do:[:i| tag byteAt: i put: (tagString at: i) asInteger].	tag _ tag longAt: 1 bigEndian: true.	pos _ 13 + offset.	1 to: nTables do:[:i|		currentTag _ fontData longAt: pos bigEndian: true.		currentTag = tag ifTrue:[^TTFontTableDirEntry on: fontData at: pos].		pos _ pos+16].	^nil! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2003 19:27'!readFrom: fontData fromOffset: offset	| headerEntry maxProfileEntry nameEntry indexLocEntry charMapEntry glyphEntry horzHeaderEntry horzMetricsEntry kerningEntry glyphOffset cmap numHMetrics indexToLocFormat fontDescription0 fontDescription1 array |	"Search the tables required to build the font"	(headerEntry _ self getTableDirEntry: 'head' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a header table'].	(maxProfileEntry _ self getTableDirEntry: 'maxp' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a maximum profile table'].	(nameEntry _ self getTableDirEntry: 'name' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a name table'].	(indexLocEntry _ self getTableDirEntry: 'loca' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a relocation table'].	(charMapEntry _ self getTableDirEntry: 'cmap' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a character map table'].	(glyphEntry _ self getTableDirEntry: 'glyf' from: fontData  offset: offset) == nil ifTrue:[		^self error:'This font does not have a glyph table'].	(horzHeaderEntry _ self getTableDirEntry: 'hhea' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a horizontal header table'].	(horzMetricsEntry _ self getTableDirEntry: 'hmtx' from: fontData offset: offset) == nil ifTrue:[		^self error:'This font does not have a horizontal metrics table'].	(kerningEntry _ self getTableDirEntry: 'kern' from: fontData offset: offset) == nil ifTrue:[		Transcript cr; show:'This font does not have a kerning table';endEntry].	"Process the data"	indexToLocFormat _ self processFontHeaderTable: headerEntry.	self processMaximumProfileTable: maxProfileEntry.	self processNamingTable: nameEntry.	glyphOffset _ self processIndexToLocationTable: indexLocEntry format: indexToLocFormat.	cmap _ self processCharacterMappingTable: charMapEntry.	(cmap == nil or:[cmap value == nil])		ifTrue:[^self error:'This font has no suitable character mappings'].	self processGlyphDataTable: glyphEntry offsets: glyphOffset.	numHMetrics _ self processHorizontalHeaderTable: horzHeaderEntry.	self processHorizontalMetricsTable: horzMetricsEntry length: numHMetrics.	kerningEntry isNil 		ifTrue:[kernPairs _ #()]		ifFalse:[self processKerningTable: kerningEntry].	array _ self processCharMap: cmap.	fontDescription0 _ fontDescription clone.	fontDescription1 _ fontDescription clone.	fontDescription0 setGlyphs: (array at: 1) mapping: nil.	fontDescription1 setGlyphs: (array at: 2) mapping: nil.	"fontDescription setKernPairs: kernPairs."	^{fontDescription0. nil. nil. nil. nil. fontDescription1}.! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2002 15:47'!parseTTCHeaderFrom: fontData	| pos nTables |	nTables _ fontData longAt: 9 bigEndian: true.	fonts _ Array new: nTables.	pos _ 13.	1 to: nTables do: [:i |		fonts at: i put: (fontData longAt: pos bigEndian: true).		pos _ pos + 4.	].	^ fonts! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2002 23:35'!decodeCmapFmtTable: entry	| cmapFmt length cmap firstCode entryCount segCount segments offset code |	cmapFmt _ entry nextUShort.	length _ entry nextUShort.	entry skip: 2. "skip version"	cmapFmt = 0 ifTrue: "byte encoded table"		[length _ length - 6. 		"should be always 256"		length <= 0 ifTrue: [^ nil].	"but sometimes, this table is empty"		cmap _ Array new: length.		entry nextBytes: length into: cmap startingAt: entry offset.		^ cmap].	cmapFmt = 4 ifTrue: "segment mapping to deltavalues"		[segCount _ entry nextUShort // 2.		entry skip: 6. "skip searchRange, entrySelector, rangeShift"		segments _ Array new: segCount.		segments _ (1 to: segCount) collect: [:e | Array new: 4].		1 to: segCount do: [:i | (segments at: i) at: 2 put: entry nextUShort]. "endCount"		entry skip: 2. "skip reservedPad"		1 to: segCount do: [:i | (segments at: i) at: 1 put: entry nextUShort]. "startCount"		1 to: segCount do: [:i | (segments at: i) at: 3 put: entry nextShort]. "idDelta"		offset _ entry offset.		1 to: segCount do: [:i | (segments at: i) at: 4 put: entry nextUShort]. "idRangeOffset"		cmap _ Array new: 65536 withAll: 0.		segments withIndexDo:			[:seg :si |			seg first to: seg second do:				[:i |					seg last > 0 ifTrue:						["offset to glypthIdArray - this is really C-magic!!"						entry offset: i - seg first - 1 * 2 + seg last + si + si + offset.						code _ entry nextUShort.						code > 0 ifTrue: [code _ code + seg third]]					ifFalse:						["simple offset"						code _ i + seg third].					cmap at: i + 1 put: (code \\ 16r10000)]].		^ cmap].	cmapFmt = 6 ifTrue: "trimmed table"		[firstCode _ entry nextUShort.		entryCount _ entry nextUShort.		cmap _ Array new: entryCount + firstCode withAll: 0.		entryCount timesRepeat:			[cmap at: (firstCode _ firstCode + 1) put: entry nextUShort].		^ cmap].	^ nil! !!TTCFontReader methodsFor: 'as yet unclassified' stamp: 'yo 11/8/2002 19:02'!processCharacterMappingTable: entry	"Read the font's character to glyph index mapping table.	If an appropriate mapping can be found then return an association	with the format identifier and the contents of the table"	| copy initialOffset nSubTables pID sID offset cmap assoc |	initialOffset _ entry offset.	entry skip: 2. "Skip table version"	nSubTables _ entry nextUShort.	1 to: nSubTables do:[:i|		pID _ entry nextUShort.		sID _ entry nextUShort.		offset _ entry nextULong.		"Check if this is either a Macintosh encoded table		or a Windows encoded table"		(pID = 1 or:[pID = 3]) ifTrue:[			"Go to the beginning of the table"			copy _ entry copy.			copy offset: initialOffset + offset.			cmap _ self decodeCmapFmtTable: copy.			"(pID = 1 and: [cmap notNil])" "Prefer Macintosh encoding over everything else"				"ifTrue: [pID -> cmap]."			assoc _ pID -> cmap. "Keep it in case we don't find a Mac encoded table"		].	].	^assoc! !!MultiCanvasCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:55'!doesDisplaying	^false   "it doesn't do displaying using copyBits"! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:55'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	self setConditionArray: (textStyle alignment = Justified ifTrue: [#paddedSpace]).! !!MultiCanvasCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:55'!setFont	foregroundColor ifNil: [foregroundColor _ Color black].	super setFont.	destY _ lineY + line baseline - font ascent! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:55'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	destX _ destX + spaceWidth + (line justifiedPadFor: spaceCount).	lastIndex _ lastIndex + 1.	^ false! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:55'!tab	destX _ (alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastIndex _ lastIndex + 1.	^ false! !!MultiCanvasCharacterScanner methodsFor: 'accessing' stamp: 'yo 12/18/2002 13:55'!canvas: aCanvas	"set the canvas to draw on"	canvas ifNotNil: [ self inform: 'initializing twice!!' ].	canvas _ aCanvas! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:55'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex_ lastIndex + 1.	^false! !!MultiCanvasCharacterScanner methodsFor: 'private' stamp: 'yo 12/18/2002 13:55'!textColor: color	foregroundColor _ color! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:55'!crossedX	"This condition will sometimes be reached 'legally' during display, when, 	for instance the space that caused the line to wrap actually extends over 	the right boundary. This character is allowed to display, even though it 	is technically outside or straddling the clipping ectangle since it is in 	the normal case not visible and is in any case appropriately clipped by 	the scanner."	"self fillLeading."	^ true ! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'yo 12/18/2002 13:55'!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	lastIndex = line last ifTrue: [^true].	runX _ destX.	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).	runStopIndex _ lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!MultiCanvasCharacterScanner methodsFor: 'scanning' stamp: 'yo 12/18/2002 13:55'!displayLine: textLine  offset: offset  leftInRun: leftInRun	|  nowLeftInRun done startLoc startIndex stopCondition |	"largely copied from DisplayScanner's routine"	line _ textLine.	foregroundColor ifNil: [ foregroundColor _ Color black ].	leftMargin _ (line leftMarginForAlignment: alignment) + offset x.	rightMargin _ line rightMargin + offset x.	lineY _ line top + offset y.	lastIndex _ textLine first.	leftInRun <= 0		ifTrue: [self setStopConditions.  "also sets the font"				nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	runX _ destX _ leftMargin.	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	done _ false.	[done] whileFalse: [		"remember where this portion of the line starts"		startLoc _ destX@destY.		startIndex _ lastIndex.		"find the end of this portion of the line"		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: text string rightX: rightMargin stopConditions: stopConditions						kern: kern "displaying: false".		"display that portion of the line"		canvas drawString: text string			from: startIndex to: lastIndex			at: startLoc			font: font			color: foregroundColor.		"handle the stop condition"		done _ self perform: stopCondition	].	^runStopIndex - lastIndex! !!GrafPort methodsFor: 'accessing' stamp: 'yo 1/23/2003 17:48'!displayScannerForMulti: para foreground: foreColor background: backColor ignoreColorChanges: shadowMode	((para isMemberOf: MultiNewParagraph) or: [para text string class == String]) ifTrue: [		^ (MultiDisplayScanner new text: para presentationText textStyle: para textStyle				foreground: foreColor background: backColor fillBlt: self				ignoreColorChanges: shadowMode)			setPort: self clone	].	^ (DisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self			ignoreColorChanges: shadowMode)		setPort: self clone! !!GrafPort methodsFor: 'accessing' stamp: 'yo 1/23/2003 17:33'!displayScannerFor: para foreground: foreColor background: backColor ignoreColorChanges: shadowMode	((para isMemberOf: MultiNewParagraph) or: [para text string class == String]) ifTrue: [		^ (MultiDisplayScanner new text: para text textStyle: para textStyle				foreground: foreColor background: backColor fillBlt: self				ignoreColorChanges: shadowMode)			setPort: self clone	].	^ (DisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self			ignoreColorChanges: shadowMode)		setPort: self clone! !!MultiTextComposer methodsFor: 'as yet unclassified' stamp: 'yo 1/23/2003 12:53'!composeEachRectangleIn: rectangles	| myLine lastChar |	1 to: rectangles size do: [:i | 		currCharIndex <= theText size ifFalse: [^false].		myLine _ scanner 			composeFrom: currCharIndex 			inRectangle: (rectangles at: i)							firstLine: isFirstLine 			leftSide: i=1 			rightSide: i=rectangles size.		lines addLast: myLine.		presentationLines addLast: scanner getPresentationLine.		presentation ifNil: [presentation _ scanner getPresentation]			ifNotNil: [presentation _ presentation, scanner getPresentation].		actualHeight _ actualHeight max: myLine lineHeight.  "includes font changes"		currCharIndex _ myLine last + 1.		lastChar _ theText at: myLine last.		lastChar = Character cr ifTrue: [^#cr].		wantsColumnBreaks ifTrue: [			lastChar = TextComposer characterForColumnBreak ifTrue: [^#columnBreak].		].	].	^false! !!MultiTextComposer methodsFor: 'as yet unclassified' stamp: 'yo 1/23/2003 12:53'!getPresentationInfo	^ Array with: presentationLines with: presentation.! !!MultiTextComposer methodsFor: 'as yet unclassified' stamp: 'yo 1/16/2003 17:30'!multiComposeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks	wantsColumnBreaks _ argWantsColumnBreaks.	lines _ argLinesCollection.	presentationLines _ argLinesCollection copy.	theTextStyle _ argTextStyle.	theText _ argText.	theContainer _ argContainer.	deltaCharIndex _ argDelta.	currCharIndex _ startCharIndex _ argStart.	stopCharIndex _ argStop.	prevLines _ argPriorLines.	currentY _ argStartY.	defaultLineHeight _ theTextStyle lineGrid.	maxRightX _ theContainer left.	possibleSlide _ stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding _ false.	prevIndex _ 1.	scanner _ MultiCompositionScanner new text: theText textStyle: theTextStyle.	scanner wantsColumnBreaks: wantsColumnBreaks.	isFirstLine _ true.	self composeAllLines.	isFirstLine ifTrue: ["No space in container or empty text"		self 			addNullLineWithIndex: startCharIndex			andRectangle: (theContainer topLeft extent: 0@defaultLineHeight)	] ifFalse: [		self fixupLastLineIfCR	].	^{lines asArray. maxRightX}! !!BitBlt methodsFor: 'copying' stamp: 'yo 9/29/2002 08:44'!displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta	destY _ aPoint y.	destX _ aPoint x.	"the following are not really needed, but theBitBlt primitive will fail if not set"	sourceX ifNil: [sourceX _ 100].	width ifNil: [width _ 100].	(aString class == MultiString) ifTrue: [^ font characters: (startIndex to: stopIndex) in: aString displayAt: aPoint clippedBy: (clipX@clipY extent: clipWidth@clipHeight) rule: combinationRule fillColor: sourceForm kernDelta: kernDelta.].	^self primDisplayString: aString from: startIndex to: stopIndex			map: font characterToGlyphMap xTable: font xTable			kern: kernDelta.! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2003 16:55'!additionalRangesForJapanese	| basics |	basics _ {		Array with: 16r5C with: 16rFF3C.		Array with: 16r3013 with: 16rFFFD.	}.	^ basics! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'yo 7/31/2003 18:20'!readCharactersInRanges: ranges storeInto: chars	| array form code rangeStream currentRange |	rangeStream _ ReadStream on: ranges.	currentRange _ rangeStream next.	[true] whileTrue: [		array _ self readOneCharacter.		code _ array at: 2.		"code = 16r3000 ifTrue: [self halt]."		code > currentRange last ifTrue: [			[rangeStream atEnd not and: [currentRange _ rangeStream next. currentRange last < code]] whileTrue.			rangeStream atEnd ifTrue: [^ self].		].		(code between: currentRange first and: currentRange last) ifTrue: [			form _ array at: 1.			form ifNotNil: [				chars add: array.			].		].	].! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2003 19:32'!override: chars with: otherFileName ranges: pairArray transcodingTable: table additionalRange: additionalRange	| other rangeStream currentRange newChars code form u newArray j |	other _ BDFFontReader readOnlyFileNamed: otherFileName.	rangeStream _ ReadStream on: pairArray.	currentRange _ rangeStream next.	newChars _ PluggableSet new.	newChars hashBlock: [:elem | (elem at: 2) hash].	newChars equalBlock: [:a :b | (a at: 2) = (b at: 2)].	other readChars do: [:array | 		code _ array at: 2.		code hex printString displayAt: 0@0.		code > currentRange last ifTrue: [			[rangeStream atEnd not and: [currentRange _ rangeStream next. currentRange last < code]] whileTrue.			rangeStream atEnd ifTrue: [				newChars addAll: chars.				^ newChars.			].		].		(code between: currentRange first and: currentRange last) ifTrue: [			form _ array at: 1.			form ifNotNil: [				j _ array at: 2.				u _ table at: (((j // 256) - 33 * 94 + ((j \\ 256) - 33)) + 1).				u ~= -1 ifTrue: [					array at: 2 put: u.					newChars add: array.					additionalRange do: [:e |						e first = (array at: 2) ifTrue: [							newArray _ array clone.							newArray at: 2 put: e second.							newChars add: newArray						].					]				].			].		].	].	self error: 'should not reach here'.! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'yo 12/1/2003 23:11'!readRanges: ranges overrideWith: otherFileName otherRanges: otherRanges additionalOverrideRange: additionalRange	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx width blt lastAscii pointSize ret lastValue start end |	form _ encoding _ bbx _ nil.	self initialize.	self readAttributes.	height _ Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent _ Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent _ Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	(properties includesKey: 'POINT_SIZE' asSymbol) ifTrue: [		pointSize _ (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.	] ifFalse: [		pointSize _ (ascent + descent) * 72 // 96.	].				maxWidth _ 0.	minAscii _ 16r200000.	strikeWidth _ 0.	maxAscii _ 0.	charsNum _ Integer readFromString: (properties at: #CHARS) first.	chars _ Set new: charsNum.	self readCharactersInRanges: ranges storeInto: chars.	chars _ self override: chars with: otherFileName ranges: otherRanges transcodingTable: (UCSTable jisx0208Table) additionalRange: additionalRange.	chars _ chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum _ chars size. "undefined encodings make this different"	chars do: [:array |		encoding _ array at: 2.		bbx _ array at: 3..		width _ bbx at: 1.		maxWidth _ maxWidth max: width.		minAscii _ minAscii min: encoding.		maxAscii _ maxAscii max: encoding.		strikeWidth _ strikeWidth + width.	].	glyphs _ Form extent: strikeWidth@height.	blt _ BitBlt toForm: glyphs.	start _ ((ranges collect: [:r | r first]), (additionalRange collect: [:r2 | r2 first])) min.	end _ ((ranges collect: [:r | r second]), (additionalRange collect: [:r2 | r2 second])) max + 3.	"xRange _ Array with: (Array with: ((ranges collect: [:r | r first]), (additionalRange collect: [:r2 | r2 first])) min						with: (((ranges collect: [:r | r second]), (additionalRange collect: [:r2 | r2 second])) max + 2))."	"xTable _ XTableForUnicodeFont new		ranges: xRange."	xTable _ SparseLargeTable new: end chunkSize: 64 arrayClass: Array base: start defaultValue: -1.	lastAscii _ start.	xTable at: lastAscii + 2 put: 0.	1 to: charsNum do: [:i |		form _ (chars at: i) first.		encoding _ (chars at: i) second.		bbx _ (chars at: i) third.		"lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)]."		lastValue _ xTable at: lastAscii + 1 + 1.		xTable at: encoding + 1 put: lastValue.		blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))				extent: (bbx at: 1)@(bbx at: 2))			from: 0@0 in: form.		xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).		lastAscii _ encoding.	].	xTable at: xTable size put: (xTable at: xTable size - 1).	xTable zapDefaultOnlyEntries.	ret _ Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'yo 7/31/2003 12:16'!rangesForJapanese	| basics etc |	basics _ {		Array with: 16r5C with: 16r5C.		Array with: 16rA2 with: 16rA3.		Array with: 16rA7 with: 16rA8.		Array with: 16rAC with: 16rAC.		Array with: 16rB0 with: 16rB1.		Array with: 16rB4 with: 16rB4.		Array with: 16rB6 with: 16rB6.		Array with: 16rD7 with: 16rD7.		Array with: 16rF7 with: 16rF7	}.	etc _ {		Array with: 16r370 with: 16r3FF. "greek"		Array with: 16r400 with: 16r52F. "cyrillic"		Array with: 16r1D00 with: 16r1D7F. "phonetic"		Array with: 16r1E00 with: 16r1EFF. "latin extended additional"		Array with: 16r2000 with: 16r206F. "general punctuation"		Array with: 16r20A0 with: 16r20CF. "currency symbols"		Array with: 16r2100 with: 16r214F. "letterlike"		Array with: 16r2150 with: 16r218F. "number form"		Array with: 16r2190 with: 16r21FF. "arrows"		Array with: 16r2200 with: 16r22FF. "math operators"		Array with: 16r2300 with: 16r23FF. "misc tech"		Array with: 16r2460 with: 16r24FF. "enclosed alnum"		Array with: 16r2500 with: 16r257F. "box drawing"		Array with: 16r2580 with: 16r259F. "box elem"		Array with: 16r25A0 with: 16r25FF. "geometric shapes"		Array with: 16r2600 with: 16r26FF. "misc symbols"		Array with: 16r2700 with: 16r27BF. "dingbats"		Array with: 16r27C0 with: 16r27EF. "misc math A"		Array with: 16r27F0 with: 16r27FF. "supplimental arrow A"		Array with: 16r2900 with: 16r297F. "supplimental arrow B"		Array with: 16r2980 with: 16r29FF. "misc math B"		Array with: 16r2A00 with: 16r2AFF. "supplimental math op"		Array with: 16r2900 with: 16r297F. "supplimental arrow B"		Array with: 16r2E80 with: 16r2EFF. "cjk radicals suppliment"		Array with: 16r2F00 with: 16r2FDF. "kangxi radicals"		Array with: 16r3000 with: 16r303F. "cjk symbols"		Array with: 16r3040 with: 16r309F. "hiragana"		Array with: 16r30A0 with: 16r30FF. "katakana"		Array with: 16r3190 with: 16r319F. "kanbun"		Array with: 16r31F0 with: 16r31FF. "katakana extension"		Array with: 16r3200 with: 16r32FF. "enclosed CJK"		Array with: 16r3300 with: 16r33FF. "CJK compatibility"		Array with: 16r3400 with: 16r4DBF. "CJK unified extension A"		Array with: 16r4E00 with: 16r9FAF. "CJK ideograph"		Array with: 16rF900 with: 16rFAFF. "CJK compatiblity ideograph"		Array with: 16rFE30 with: 16rFE4F. "CJK compatiblity forms"		Array with: 16rFF00 with: 16rFFEF. "half and full"	}.	^ basics, etc.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 18:20'!familyName	^ 'Multi', (fontArray at: 1) familyName.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 18:28'!depth	^ (fontArray at: 1) depth.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:16'!emphasized: code! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 12/27/2002 04:36'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	| destPoint font form encoding ascii |	destPoint _ aPoint.	startIndex to: stopIndex do: [:charIndex | 		encoding _ (aString at: charIndex) leadingChar + 1.		ascii _ (aString at: charIndex) charCode.		font _ fontArray at: encoding.		((ascii between: font minAscii and: font maxAscii) not) ifTrue: [			ascii _ font maxAscii].		form _ font formOf: (aString at: charIndex).		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x.		aBitBlt destY: destPoint y.		aBitBlt sourceOrigin: 0 @ 0.		aBitBlt width: form width.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint _ destPoint + (form width + kernDelta @ 0).	].! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:16'!descentKern	^ 0.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:15'!ascent	^ (fontArray at: 1) ascent.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:17'!pointSize	^ fontArray first pixelSize * 72 // 96.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:16'!descent	^ (fontArray at: 1) descent.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:16'!familySizeFace	^ Array		with: fontArray first name		with: self height		with: 0.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:17'!maxAsciiFor: encoding	| f |	f _ (fontArray at: encoding+1).	f ifNotNil: [^ f maxAscii].	^ 0.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:16'!height	^ (fontArray at: 1) pixelSize.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 18:20'!initializeWithFontArray: anArray	fontArray _ anArray.	"name _ anArray first name."! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 12/27/2002 04:36'!displayStringR2L: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	| destPoint font form encoding ascii |	destPoint _ aPoint.	startIndex to: stopIndex do: [:charIndex | 		encoding _ (aString at: charIndex) leadingChar + 1.		ascii _ (aString at: charIndex) charCode.		font _ fontArray at: encoding.		((ascii between: font minAscii and: font maxAscii) not) ifTrue: [			ascii _ font maxAscii].		form _ font formOf: (aString at: charIndex).		aBitBlt sourceForm: form.		aBitBlt destX: destPoint x - form width.		aBitBlt destY: destPoint y.		aBitBlt sourceOrigin: 0 @ 0.		aBitBlt width: form width.		aBitBlt height: form height.		aBitBlt copyBits.		destPoint _ destPoint - (form width + kernDelta @ 0).	].! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:17'!widthOf: aCharacter	| encoding |	encoding _ aCharacter leadingChar.	^ (fontArray at: encoding + 1) widthOf: aCharacter.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:16'!baseKern	^ 0.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:27'!pointSizes	^ self class pointSizes.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:16'!fontArray	^ fontArray! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 8/20/2003 22:51'!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	foregroundColor _ fgColor.	fontArray do: [:s | s ifNotNil: [s installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor]].! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 8/5/2003 15:31'!textStyle	^ TextStyle actualTextStyles		detect: [:aStyle | (aStyle fontArray collect: [:s | s name]) includes: self name]		ifNone: [].! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2002 23:47'!discardDefault"	self discardDefault"	| ttc |	ttc _ TTCFontDescription default.	ttc ifNotNil: [		TextConstants removeKey: ttc name asSymbol ifAbsent: [].	].! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2002 22:21'!pointSizes	^ TTCFont pointSizes.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 19:08'!removeStyleName: aString	TextConstants removeKey: ('Multi', aString) asSymbol ifAbsent: [].	TTCFontDescription removeDescriptionNamed: aString asString.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2002 23:15'!initialize"	self initialize"	| tt |	tt _ TTCFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 11/30/2002 23:19'!newTextStyleFromTTFile: fileName"	self newTextStyleFromTTFile: 'C:\WINDOWS\Fonts\msmincho.TTC'"	| description |	description _ TTCFontDescription addFromTTFile: fileName.	^ self newTextStyleFromTT: description.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 11/16/2002 01:18'!newFontArray: anArray 	^super new initializeWithFontArray: anArray! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 12/1/2002 00:03'!setDefault"	self setDefault"	| tt |	tt _ TTCFontDescription default.	tt ifNil: [TTCFontDescription setDefault].	tt _ TTCFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'yo 8/19/2003 19:28'!newTextStyleFromTT: descriptionArray	| array f textStyle styleName arrayOfArray |	arrayOfArray _ self pointSizes collect: [:pt |		descriptionArray collect: [:ttc |			ttc ifNil: [nil] ifNotNil: [				f _ (ttc size > 256)					ifTrue: [MultiTTCFont new initialize]					ifFalse: [TTCFont new initialize].				f ttcDescription: ttc.				f pointSize: pt.			].		].	].	array _ arrayOfArray collect: [:fonts |		self newFontArray: fonts.	].	styleName _ (array at: 1) familyName asSymbol.	textStyle _ TextStyle fontArray: array.	TextConstants at: styleName put: textStyle.		^ TextConstants at: styleName.! !!MultiCharacterScanner class methodsFor: 'class initialization' stamp: 'yo 12/18/2002 14:09'!initialize"	MultiCharacterScanner initialize"	| a |	a _ Array new: 258.	a at: 1 + 1 put: #embeddedObject.	a at: Tab asciiValue + 1 put: #tab.	a at: CR asciiValue + 1 put: #cr.	a at: EndOfRun put: #endOfRun.	a at: CrossedX put: #crossedX.	NilCondition _ a copy.	DefaultStopConditions _ a copy.	PaddedSpaceCondition _ a copy.	PaddedSpaceCondition at: Space asciiValue + 1 put: #paddedSpace.		SpaceCondition _ a copy.	SpaceCondition at: Space asciiValue + 1 put: #space.! !MultiCharacterScanner initialize.!!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 18:08'!access: char at: index	| wcache entry |	wcache _ self cache.	entry _ wcache at: index.	wcache replaceFrom: index to: wcache size - 1 with: wcache startingAt: index + 1.	wcache at: wcache size put: entry.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 18:30'!widthOf: char	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	| newForm |	self hasCached: char ifTrue: [:form :index |		self access: char at: index.		^ form width.	].	newForm _ self computeForm: char.	self at: char put: newForm.	^ newForm width.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 18:27'!flushCache	cache at: 1 put: ((1 to: 128) collect: [:i | Array with: -1 with: nil with: nil]).! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 18:39'!hasCached: char ifTrue: twoArgBlock	| value elem |	value _ char asciiValue.	self cache size to: 1 by: -1 do: [:i |		elem _ self cache at: i.		(elem first = value and: [elem second = foregroundColor]) ifTrue: [			^ twoArgBlock value: elem third value: i.		].	].	^ false.! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 18:09'!at: char put: form	| wcache |	wcache _ self cache.	wcache replaceFrom: 1 to: wcache size - 1 with: wcache startingAt: 2.	wcache at: wcache size		put: (Array with: char asciiValue with: foregroundColor with: form).! !!MultiTTCFont methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 21:04'!formOf: char	| newForm |	self hasCached: char ifTrue: [:form :index |		self access: char at: index.		^ form.	].	newForm _ self computeForm: char.	self at: char put: newForm.	^ newForm.! !!MultiTTCFont class methodsFor: 'as yet unclassified' stamp: 'yo 12/10/2002 18:34'!cacheAllNil"	self cacheAllNil"	self allInstances do: [:inst |		inst cache do: [:e |			e third ifNotNil: [^ false].		].	].	^ true.! !!Paragraph methodsFor: 'composition' stamp: 'yo 1/23/2003 22:47'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines _ Array new: 32.	lastLine _ 0.	maximumRightX _ 0.	text size = 0		ifTrue:			[compositionRectangle _ compositionRectangle withHeight: 0.			^maximumRightX].	startIndex _ lineIndex _ 1.	stopIndex _ text size.	compositionScanner _ MultiCompositionScanner new forParagraph: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX _ compositionScanner rightX max: maximumRightX.		 startIndex _ (lines at: lineIndex) last + 1.		 lineIndex _ lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'private' stamp: 'yo 1/23/2003 22:48'!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	"Save some time by only displaying visible lines"	firstLineIndex _ self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex _ linesInterval first].	lastLineIndex _ self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex _ lastLine]		  		ifFalse: [lastLineIndex _ linesInterval last]].	lastLineIndexBottom _ (self bottomAtLineIndex: lastLineIndex).	((Rectangle 		origin: affectedRectangle left @ (topY _ self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ lastLineIndexBottom)	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"				MultiDisplayScanner new					displayLines: (firstLineIndex to: lastLineIndex)					in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 15:03'!characterFormAt: aCharacter at: aPoint	| f |	f _ charForms at: aCharacter asciiValue + 1.	(f magnifyBy: 3) displayAt: aPoint.	^ f.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 15:04'!mappingTable	^ MappingTable.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 15:03'!font: aStrikeFont	strikeFont _ aStrikeFont.	self forms.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 15:04'!initialize	charForms _ Array new: 256.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 15:04'!forms	1 to: 256 do: [:i |		charForms at: i put: (strikeFont characterFormAt: (Character value: (i - 1)))	].! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 15:03'!displayOn: aDisplayObject at: aPoint magnifyBy: aNumber	| form hStep vStep bb source nextPoint |	hStep _ (strikeFont maxWidth * aNumber * 1.2) asInteger.	vStep _ (strikeFont height * aNumber *  1.2) asInteger.		form _ Form extent: (hStep * 16)@(vStep * 16).	bb _ BitBlt toForm: form.	0 to: 15 do: [:i |		1 to: 16 do: [:j |			source _ ((charForms at: (i * 16 + j)) magnifyBy: aNumber).			nextPoint _ (hStep * (j - 1)@(vStep * i)).			bb copy: ((nextPoint+((hStep@vStep - source extent) // 2)) extent: source extent)				from: 0@0 in: source fillColor: Color black rule: Form over.		].	].	form displayOn: aDisplayObject at: aPoint.! !!StrikeFontFixer methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 15:04'!storeEditedGlyphsOn: aStream	| n |	NoFontTable do: [:i |		n _ strikeFont name.		(n beginsWith: 'NewYork') ifTrue: [n _ 'NewYork'].		aStream nextPutAll: '((StrikeFont familyName: ''', n, ''' size: ',			strikeFont height asString, ')'.		aStream nextPutAll: ' characterFormAt: '.		aStream nextPutAll: '(Character value: ', i asString, ')'.		aStream nextPutAll: ' put: '.		(strikeFont characterFormAt: (Character value: i)) storeOn: aStream base: 2.		aStream nextPutAll: ')!!'.		aStream nextPut: Character cr.		aStream nextPut: Character cr.	].! !!StrikeFontFixer class methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 15:06'!initialize"	StrikeFontFixer initialize"	| d |	self initializeNoFontTable.	d _ Array new: 256.	0 to: 127 do: [:i | d at: i+1 put: i].	16r80 to: 16r9F do: [:i | d at: i+1 put: nil].	d at: 16rA0+1 put: 16r20.	d at: 16rA1+1 put: 16rC1.	d at: 16rA2+1 put: 16rA2.	d at: 16rA3+1 put: 16rA3.	d at: 16rA4+1 put: 16rA9. "CURRENCY SIGN"	d at: 16rA5+1 put: 16rB4.	d at: 16rA6+1 put: 16r7C. "BROKEN BAR"	d at: 16rA7+1 put: 16rA4.	d at: 16rA8+1 put: 16r80. "DIAERESIS"	d at: 16rA9+1 put: 16rA9.	d at: 16rAA+1 put: 16rBB.	d at: 16rAB+1 put: 16rC7.	d at: 16rAC+1 put: 16rD1. "NOT SIGN"	d at: 16rAD+1 put: 16rD0.	d at: 16rAE+1 put: 16rA8.	d at: 16rAF+1 put: 16rD1. "MACRON"	d at: 16rB0+1 put: 16rA1.	d at: 16rB1+1 put: 16r2B. "PLUS-MINUS SIGN"	d at: 16rB2+1 put: 16rAB. "SUPERSCRIPT TWO"	d at: 16rB3+1 put: 16rAB. "SUPERSCRIPT THREE"	d at: 16rB4+1 put: 16rAB.	d at: 16rB5+1 put: 16r75. "MICRO SIGN"	d at: 16rB6+1 put: 16rA6.	d at: 16rB7+1 put: 16rA5.	d at: 16rB8+1 put: 16r82. "CEDILLA"	d at: 16rB9+1 put: 16rAB. "SUPERSCRIPT ONE"	d at: 16rBA+1 put: 16rBC.	d at: 16rBB+1 put: 16rC8.	d at: 16rBC+1 put: 16r4D. "VULGAR FRACTION ONE QUARTER"	d at: 16rBD+1 put: 16r4D. "VULGAR FRACTIOIN ONE HALF"	d at: 16rBE+1 put: 16r4D. "VALGAR FRACTION THREE QUARTERS"	d at: 16rBF+1 put: 16rC0.	d at: 16rC0+1 put: 16rCB.	d at: 16rC1+1 put: 16rCB. "CAPITAL A WITH ACUTE"	d at: 16rC2+1 put: 16rCB. "CAPITAL A WITH CIRCUMFLEX"	d at: 16rC3+1 put: 16rCC.	d at: 16rC4+1 put: 16r80.	d at: 16rC5+1 put: 16r81.	d at: 16rC6+1 put: 16rAE.	d at: 16rC7+1 put: 16r82.	d at: 16rC8+1 put: 16r83. "CAPITAL E WITH GRAVE"	d at: 16rC9+1 put: 16r83.	d at: 16rCA+1 put: 16r83. "CAPITAL E WITH CIRCUMFLEX"	d at: 16rCB+1 put: 16r83. "CAPITAL E WITH DIAERESIS"	d at: 16rCC+1 put: 16r49. "CAPITAL I WITH GRAVE"	d at: 16rCD+1 put: 16r49. "CAPITAL I WITH ACUTE"	d at: 16rCE+1 put: 16r49. "CAPITAL I WITH CIRCUMFLEX"	d at: 16rCF+1 put: 16r49. "CAPITAL I WITH DIAERESIS"	d at: 16rD0+1 put: 16r44. "CAPITAL ETH"	d at: 16rD1+1 put: 16r84.	d at: 16rD2+1 put: 16rCD. "CAPITAL O WITH GRAVE"	d at: 16rD3+1 put: 16rCD. "CAPITAL O WITH ACUTE"	d at: 16rD4+1 put: 16rCD. "CAPITAL O WITH CIRCUMFLEX"	d at: 16rD5+1 put: 16rCD.	d at: 16rD6+1 put: 16r85.	d at: 16rD7+1 put: 16r2B. "MULTIPLICATION SIGN"	d at: 16rD8+1 put: 16rBF.	d at: 16rD9+1 put: 16r86. "CAPITAL U WITH GRAVE"	d at: 16rDA+1 put: 16r86. "CAPITAL U WITH ACUTE"	d at: 16rDB+1 put: 16r86. "CAPITAL U WITH CIRCUMFLEX"	d at: 16rDC+1 put: 16r86. "CAPTIAL U WITH DIAERESIS"	d at: 16rDD+1 put: 16r59. "CAPITAL Y WITH ACUTE"	d at: 16rDE+1 put: 16r50. "CAPITAL THORN"	d at: 16rDF+1 put: 16rA7.	d at: 16rE0+1 put: 16r88.	d at: 16rE1+1 put: 16r87.	d at: 16rE2+1 put: 16r89.	d at: 16rE3+1 put: 16r8B.	d at: 16rE4+1 put: 16r8A.	d at: 16rE5+1 put: 16r8C.	d at: 16rE6+1 put: 16rBE.	d at: 16rE7+1 put: 16r8D.	d at: 16rE8+1 put: 16r8F.	d at: 16rE9+1 put: 16r8E.	d at: 16rEA+1 put: 16r90.	d at: 16rEB+1 put: 16r91.	d at: 16rEC+1 put: 16r93.	d at: 16rED+1 put: 16r92.	d at: 16rEE+1 put: 16r94.	d at: 16rEF+1 put: 16r95.	d at: 16rF0+1 put: 16r64. "SMALL ETH"	d at: 16rF1+1 put: 16r96.	d at: 16rF2+1 put: 16r98.	d at: 16rF3+1 put: 16r97.	d at: 16rF4+1 put: 16r99.	d at: 16rF5+1 put: 16r9B.	d at: 16rF6+1 put: 16r9A.	d at: 16rF7+1 put: 16r2D. "DIVISION SIGN"	d at: 16rF8+1 put: 16rBF.	d at: 16rF9+1 put: 16r9D.	d at: 16rFA+1 put: 16r9C.	d at: 16rFB+1 put: 16r9E.	d at: 16rFC+1 put: 16r9F.	d at: 16rFD+1 put: 16rD8. "SMALL Y WITH ACUTE"	d at: 16rFE+1 put: 16r70. "SMALL THORN"	d at: 16rFF+1 put: 16rD8.	MappingTable _ d.! !!StrikeFontFixer class methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 15:05'!newOn: aStrikeFont	^ super new initialize font: aStrikeFont.! !!StrikeFontFixer class methodsFor: 'as yet unclassified' stamp: 'yo 9/16/2002 15:05'!initializeNoFontTable	| n |	n _ #(	16rA4 "CURRENCY SIGN"	16rA6 "BROKEN BAR"	16rA8 "DIAERESIS"	16rAC "NOT SIGN"	16rAF "MACRON"	16rB1 "PLUS-MINUS SIGN"	16rB2 "SUPERSCRIPT TWO"	16rB3 "SUPERSCRIPT THREE"	16rB5 "MICRO SIGN"	16rB8 "CEDILLA"	16rB9 "SUPERSCRIPT ONE"	16rBC "VULGAR FRACTION ONE QUARTER"	16rBD "VULGAR FRACTIOIN ONE HALF"	16rBE "VALGAR FRACTION THREE QUARTERS"	16rC1 "CAPITAL A WITH ACUTE"	16rC2 "CAPITAL A WITH CIRCUMFLEX"	16rC8 "CAPITAL E WITH GRAVE"	16rCA "CAPITAL E WITH CIRCUMFLEX"	16rCB "CAPITAL E WITH DIAERESIS"	16rCC "CAPITAL I WITH GRAVE"	16rCD "CAPITAL I WITH ACUTE"	16rCE "CAPITAL I WITH CIRCUMFLEX"	16rCF "CAPITAL I WITH DIAERESIS"	16rD0 "CAPITAL ETH"	16rD2 "CAPITAL O WITH GRAVE"	16rD3 "CAPITAL O WITH ACUTE"	16rD4 "CAPITAL O WITH CIRCUMFLEX"	16rD7 "MULTIPLICATION SIGN"	16rD9 "CAPITAL U WITH GRAVE"	16rDA "CAPITAL U WITH ACUTE"	16rDB "CAPITAL U WITH CIRCUMFLEX"	16rDD "CAPITAL Y WITH ACUTE"	16rDE "CAPITAL THORN"	16rF0 "SMALL ETH"	16rF7 "DIVISION SIGN"	16rFD "SMALL Y WITH ACUTE"	16rFE "SMALL THORN"	).	NoFontTable _ n.! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'yo 10/4/2002 20:44'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	self setConditionArray: (textStyle alignment = Justified ifTrue: [#paddedSpace]).! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'yo 11/18/2002 13:16'!endOfRun	"Before arriving at the cursor location, the selection has encountered an 	end of run. Answer false if the selection continues, true otherwise. Set 	up indexes for building the appropriate CharacterBlock."	| runLength lineStop |	(((characterIndex ~~ nil and:		[runStopIndex < characterIndex and: [runStopIndex < text size]])			or:	[characterIndex == nil and: [lastIndex < line last]]) or: [				((lastIndex < line last)				and: [((text at: lastIndex) leadingChar ~= (text at: lastIndex+1) leadingChar)					and: [lastIndex ~= characterIndex]])])		ifTrue:	["We're really at the end of a real run."				runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).				characterIndex ~~ nil					ifTrue:	[lineStop _ characterIndex	"scanning for index"]					ifFalse:	[lineStop _ line last			"scanning for point"].				(runStopIndex _ lastIndex + (runLength - 1)) > lineStop					ifTrue: 	[runStopIndex _ lineStop].				self setStopConditions.				^false].	lastCharacter _ text at: lastIndex.	characterPoint _ destX @ destY.	((lastCharacter = Space and: [alignment = Justified])		or: [lastCharacter = Tab and: [lastSpaceOrTabExtent notNil]])		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent].	characterIndex ~~ nil		ifTrue:	["If scanning for an index and we've stopped on that index,				then we back destX off by the width of the character stopped on				(it will be pointing at the right side of the character) and return"				runStopIndex = characterIndex					ifTrue:	[self characterPointSetX: destX - lastCharacterExtent x.							^true].				"Otherwise the requested index was greater than the length of the				string.  Return string size + 1 as index, indicate further that off the				string by setting character to nil and the extent to 0."				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"Scanning for a point and either off the end of the line or off the end of the string."	runStopIndex = text size		ifTrue:	["off end of string"				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"just off end of line without crossing x"	lastIndex _ lastIndex + 1.	^true! !!TextContainer methodsFor: 'access' stamp: 'yo 1/3/2003 12:21'!paragraphClass	^ MultiNewParagraph! !!SparseLargeTable methodsFor: 'accessing' stamp: 'yo 12/1/2003 15:58'!arrayClass	^(self basicAt: 1) class! !!SparseLargeTable methodsFor: 'accessing' stamp: 'yo 12/1/2003 15:58'!at: index	self pvtCheckIndex: index.	^self noCheckAt: index.! !!SparseLargeTable methodsFor: 'accessing' stamp: 'yo 12/1/2003 15:58'!at: index put: value		self pvtCheckIndex: index.	^self noCheckAt: index put: value! !!SparseLargeTable methodsFor: 'accessing' stamp: 'yo 12/1/2003 17:56'!base	^ base.! !!SparseLargeTable methodsFor: 'accessing' stamp: 'yo 12/1/2003 15:58'!chunkSize	^chunkSize! !!SparseLargeTable methodsFor: 'accessing' stamp: 'yo 12/1/2003 19:21'!noCheckAt: index	| chunkIndex t |	chunkIndex := index - base // chunkSize + 1.	chunkIndex > self basicSize ifTrue: [^ defaultValue].	t _ self basicAt: chunkIndex.	t ifNil: [^ defaultValue].	^ t at: (index - base + 1 - (chunkIndex - 1 * chunkSize))! !!SparseLargeTable methodsFor: 'accessing' stamp: 'yo 12/1/2003 19:18'!noCheckAt: index put: value	| chunkIndex t |	chunkIndex := index - base // chunkSize + 1.	chunkIndex > self basicSize ifTrue: [^ value].	t _  self basicAt: chunkIndex.	t ifNil: [^ value].	^ t at: (index - base + 1 - (chunkIndex - 1 * chunkSize)) put: value! !!SparseLargeTable methodsFor: 'accessing' stamp: 'yo 12/1/2003 15:58'!size	^size! !!SparseLargeTable methodsFor: 'accessing' stamp: 'yo 12/1/2003 22:34'!zapDefaultOnlyEntries	| lastIndex newInst |	1 to: self basicSize do: [:i |		(self allDefaultValueSubtableAt: i) ifTrue: [self basicAt: i put: nil].	].	lastIndex _ self findLastNonNilSubTable.	lastIndex = 0 ifTrue: [^ self].		newInst _ self class new: lastIndex*chunkSize chunkSize: chunkSize arrayClass: (self basicAt: lastIndex) class base: base defaultValue: defaultValue.	newInst privateSize: self size.	base to: newInst size do: [:i | newInst at: i put: (self at: i)].	1 to: newInst basicSize do: [:i |		(newInst allDefaultValueSubtableAt: i) ifTrue: [newInst basicAt: i put: nil].	].	self becomeForward: newInst.	^ newInst.! !!SparseLargeTable methodsFor: 'initialization' stamp: 'yo 12/1/2003 16:58'!initChunkSize: aChunkSize size: aSize arrayClass: aClass base: b defaultValue: d	| lastChunkSize |	chunkSize := aChunkSize.	size := aSize.	base _ b.	defaultValue _ d.	1 to: (self basicSize - 1) do: [ :in | self basicAt: in put: (aClass new: chunkSize withAll: defaultValue) ].	lastChunkSize := size \\ chunkSize.	lastChunkSize = 0 ifTrue: [lastChunkSize := chunkSize].	size = 0 		ifTrue: [self basicAt: 1 put: (aClass new: 0)]		ifFalse: [self basicAt: self basicSize put: (aClass new: lastChunkSize withAll: defaultValue)].! !!SparseLargeTable methodsFor: 'printing' stamp: 'yo 12/1/2003 17:06'!printElementsOn: aStream	| element |	aStream nextPut: $(.	base to: size do: [:index | element _ self at: index. aStream print: element; space].	self isEmpty ifFalse: [aStream skip: -1].	aStream nextPut: $)! !!SparseLargeTable methodsFor: 'printing' stamp: 'yo 12/1/2003 15:58'!printOn: aStream	(#(String) includes: self arrayClass name) 		ifTrue: [^self storeOn: aStream].	^super printOn: aStream! !!SparseLargeTable methodsFor: 'printing' stamp: 'yo 12/1/2003 15:59'!storeOn: aStream	| x |	(#(String) includes: self arrayClass name) ifTrue: 		[aStream nextPut: $'.		1 to: self size do:			[:i |			aStream nextPut: (x _ self at: i).			x == $' ifTrue: [aStream nextPut: x]].		aStream nextPutAll: ''' asLargeArrayChunkSize: '.		aStream nextPutAll: self chunkSize asString.		^self].	^super storeOn: aStream! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 18:58'!allDefaultValueSubtableAt: index	| t |	t _ self basicAt: index.	t ifNil: [^ true].	t do: [:e |		e ~= defaultValue ifTrue: [^ false].	].	^ true.! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 17:10'!analyzeSpaceSaving	| total elems tablesTotal nonNilTables |	total _ size - base + 1.	elems _ 0.	base to: size do: [:i | (self at: i) ~= defaultValue ifTrue: [elems _ elems + 1]].	tablesTotal _ self basicSize.	nonNilTables _ 0.	1 to: self basicSize do: [:i | (self basicAt: i) ifNotNil: [nonNilTables _ nonNilTables + 1]].	^ String streamContents: [:strm |		strm nextPutAll: 'total: '.		strm nextPutAll: total printString.		strm nextPutAll: ' elements: '.		strm nextPutAll: elems printString.		strm nextPutAll: ' tables: '.		strm nextPutAll: tablesTotal printString.		strm nextPutAll: ' non-nil: '.		strm nextPutAll: nonNilTables printString.	].! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 22:34'!findLastNonNilSubTable	(self basicAt: self basicSize) ifNotNil: [^ self basicSize].	self basicSize - 1 to: 1 by: -1 do: [:lastIndex |		(self basicAt: lastIndex) ifNotNil: [^ lastIndex].	].	^ 0.! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 19:19'!privateSize: s	size _ s.! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 17:34'!pvtCheckIndex: index 	index isInteger ifFalse: [self errorNonIntegerIndex].	index < 1 ifTrue: [self errorSubscriptBounds: index].	index > size ifTrue: [self errorSubscriptBounds: index].! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 15:59'!similarInstance	^self class		new: self size 		chunkSize: self chunkSize 		arrayClass: self arrayClass! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 15:59'!similarInstance: newSize	^self class		new: newSize 		chunkSize: self chunkSize 		arrayClass: self arrayClass! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 15:59'!similarSpeciesInstance	^self similarInstance! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 16:00'!similarSpeciesInstance: newSize	^self similarInstance: newSize! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 16:00'!speciesNew	^self species		new: self size 		chunkSize: self chunkSize 		arrayClass: self arrayClass! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 16:00'!speciesNew: newSize	^self species		new: newSize 		chunkSize: self chunkSize 		arrayClass: self arrayClass! !!SparseLargeTable class methodsFor: 'instance creation' stamp: 'yo 12/1/2003 16:06'!new: size	^self new: size chunkSize: self defaultChunkSize! !!SparseLargeTable class methodsFor: 'instance creation' stamp: 'yo 12/1/2003 16:07'!new: size chunkSize: chunkSize	^self new: size chunkSize: chunkSize arrayClass: Array! !!SparseLargeTable class methodsFor: 'instance creation' stamp: 'yo 12/1/2003 16:08'!new: size chunkSize: chunkSize arrayClass: aClass	^self new: size chunkSize: chunkSize arrayClass: Array base: 1.! !!SparseLargeTable class methodsFor: 'instance creation' stamp: 'yo 12/1/2003 16:37'!new: size chunkSize: chunkSize arrayClass: aClass base: b	^self new: size chunkSize: chunkSize arrayClass: Array base: 1 defaultValue: nil.! !!SparseLargeTable class methodsFor: 'instance creation' stamp: 'yo 12/1/2003 16:37'!new: size chunkSize: chunkSize arrayClass: aClass base: b defaultValue: d	| basicSize |	(basicSize := ((size - 1) // chunkSize) + 1) = 0		ifTrue: [basicSize := 1].	^(self basicNew: basicSize)		initChunkSize: chunkSize size: size arrayClass: aClass base: b defaultValue: d;		yourself! !!SparseLargeTable class methodsFor: 'accessing' stamp: 'yo 12/1/2003 15:54'!defaultChunkSize	^100! !!SparseLargeTable class methodsFor: 'accessing' stamp: 'yo 12/1/2003 15:54'!defaultChunkSizeForFiles	^8000! !"Postscript: "| textStyles someTextStyles newTextStyles oldFonts newFonts |CharacterScanner initialize.TTCFontDescription initialize.TTCFontSet initialize.MultiCharacterScanner initialize.StrikeFontFixer initialize.TextConstants	at: #OldDefaultTextStyle	put: (TextConstants at: #DefaultTextStyle).TextConstants	at: #DefaultMultiStyle	put: (TextStyle			fontArray: ((1 to: 6)					collect: [:i | StrikeFontSet							newFontArray: (Array									with: ((TextStyle named: 'Accuny')											fontAt: i)									)])).(StrikeFont allInstances	select: [:e | e name beginsWith: 'NewYork'])	do: [:s | s fixXTable].TextConstants	at: #DefaultTextStyle	put: (TextConstants at: #DefaultMultiStyle)."ListParagraph initialize"."StandardSystemView initialize"."PopUpMenu initialize".Smalltalk garbageCollect.textStyles _ OrderedCollection new.someTextStyles _ TextStyle allInstances			select: [:textStyle | 				| strikeFont | 				strikeFont _ textStyle fontArray first.				(strikeFont isMemberOf: StrikeFont)					and: [strikeFont name = 'Accuny10']].someTextStyles	do: [:textStyle | 		| owners | 		owners _ Smalltalk pointersTo: textStyle.		owners			detect: [:owner | owner isKindOf: LookupKey]			ifNone: [textStyles add: textStyle]].newTextStyles _ (1 to: textStyles size)			collect: [:index | TextStyle default copy].textStyles asArray elementsForwardIdentityTo: newTextStyles."Make something close to Latin1 encoded fonts."StrikeFontSet allInstancesDo: [:strikeFontSet | strikeFontSet reset].StrikeFont allInstancesDo: [:strikeFont | strikeFont reset].oldFonts _ (StrikeFont allInstances select: [:e | e familyName beginsWith: 'Accu']) select: [:f | f emphasis = 0].newFonts _ oldFonts collect: [:e | StrikeFont fixAccuISO8859From: e].oldFonts elementsForwardIdentityTo: newFonts..StrikeFontSet allInstancesDo: [:strikeFontSet | strikeFontSet reset].StrikeFont allInstancesDo: [:strikeFont | strikeFont reset]..TextConstants removeKey: #OldDefaultTextStyle.TextConstants at: #Accuny put: (TextConstants at: #DefaultMultiStyle).
Smalltalk closeSourceFiles.Smalltalk garbageCollect.Smalltalk openSourceFiles."Change the .changes file format."SmalltalkImage current reconstructChanges2.CharacterBlockScanner removeSelector: #characterNotInFont.CharacterScanner removeSelector: #characterNotInFont. CharacterScanner removeSelector: #primScanCharactersFrom:to:in:rightX:stopConditions:kern: .DisplayScanner removeSelector: #characterNotInFont. ServerDirectory class removeSelector: #parseServerEntryArgsFrom:. String removeSelector: #translateFrom:to:table:. String removeSelector: #asEncodedString:. String removeSelector: #isAsciiOrJISX0208String. JISX0208 class removeSelector: #isBreakableTmpAt:in:. String removeSelector: #escapeEntities. Symbol removeSelector: #stringhash. !