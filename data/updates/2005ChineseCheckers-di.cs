'From Squeak2.8alpha of 12 January 2000 [latest update: #1991] on 13 April 2000 at 2:30:15 pm'!"Change Set:		ChineseCheckersDate:			13 March 2000Author:			Dan IngallsAn implementation of the game Chinese Checkers.  It allows humans to play, and it will also play by itself.  See the class comment.Whether in Morphic or MVC, execute...	ChineseCheckers new openInWorldHopefully this will grow into a game that can be played over the internet, either between people or as a game between programs."!EllipseMorph subclass: #ChineseCheckerPiece	instanceVariableNames: 'boardLoc myBoard '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!!ChineseCheckerPiece commentStamp: 'di 4/11/2000 08:52' prior: 0!I represent a player piece for Chinese Checkers.  Mostly I act as an ellipse, but my special methods ensure that I cannot be picked up or dropped except in the proper circumstances.Structure: myBoard		a ChineseCheckers morph boardLoc		my current logical position on the board.!BorderedMorph subclass: #ChineseCheckers	instanceVariableNames: 'board sixDeltas teams homes autoPlay whoseMove plannedMove plannedMovePhase colors movePhase animateMoves pathMorphs '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games'!!ChineseCheckers commentStamp: 'di 4/13/2000 14:29' prior: 0!An implementation of Chinese Checkers by Dan Ingalls.  April 9, 2000.board:  A 19x19 rhombic array, addressed by row@col points, in which is imbedded the familiar six-pointed layout of cells.  A cell outside the board is nil (-).  - - - - - - - - - - - - - - - - - - -   - - - - - - - - - - - - - 5 - - - - -    - - - - - - - - - - - - 5 5 - - - - -     - - - - - - - - - - - 5 5 5 - - - - -      - - - - - - - - - - 5 5 5 5 - - - - -       - - - - - 6 6 6 6 0 0 0 0 0 4 4 4 4 -        - - - - - 6 6 6 0 0 0 0 0 0 4 4 4 - -         - - - - - 6 6 0 0 0 0 0 0 0 4 4 - - -          - - - - - 6 0 0 0 0 0 0 0 0 4 - - - -           - - - - - 0 0 0 0 0 0 0 0 0 - - - - -            - - - - 1 0 0 0 0 0 0 0 0 3 - - - - -             - - - 1 1 0 0 0 0 0 0 0 3 3 - - - - -              - - 1 1 1 0 0 0 0 0 0 3 3 3 - - - - -               - 1 1 1 1 0 0 0 0 0 3 3 3 3 - - - - -                - - - - - 2 2 2 2 - - - - - - - - - -                 - - - - - 2 2 2 - - - - - - - - - - -                  - - - - - 2 2 - - - - - - - - - - - -                   - - - - - 2 - - - - - - - - - - - - -                    - - - - - - - - - - - - - - - - - - -Cells within the board contain 0 if empty, or a team number (1..6) if occupied by a piece of that team.  An extra border of nils around the whole reduces bounds checking to a nil test.sixDeltas:  An array giving the x@y deltas for the 6 valid steps in CCW order from a given cell.  For team 1 they are: in fr, fl, l, bl, br, r.  To get, eg fl for a given team, use (sixDeltas atWrap: team+1).teams:  An array of six teams, each of which is an array of the x@y locations of the 10 pieces.homes:  The x@y coordinates of the six home points, namely 14@2, 18@6, 14@14, 6@18, 2@14, 6@6.  The goal, or farthest point in destination triangle, is thus (homes atWrap: teamNo+3).autoPlay:  An array of booleans, parallel to teams, where true means that Squeak will make the moves for the corresponding team.whoseMove:  A team number specifying whose turn it is next.  Set to 0 when game is over.plannedMove:  If not nil, it means the board is in a state where it is animating the next move to be made so that it can be seen.movePhase:  Holds the state of display of the planned move so that, eg, it can appear one jump at a time.  Advances from 1 to (plannedMove size * 2).A move is an array of locs which are the path of the move.Once the morph is open, the menu command 'reset...' allows you to reset the board and change the number of players.  The circle at turnIndicatorLoc indicates the color of the team whose turn it is.  If it is a human, play waits for drag and drop of a piece of that color.The current strategy is very simple: generate all moves, score them and pick the best.  Beyond this, it will look ahead a number of moves, but this becomes very expensive without pruning.  Pruning would help the speed of play, especially in the end game where we look a little deeper.  A more effective strategy would consider opponents' possible moves as well, but this is left as an exercise for the serious programmer.!!ChineseCheckerPiece methodsFor: 'all' stamp: 'di 4/9/2000 08:31'!boardLoc	^ boardLoc! !!ChineseCheckerPiece methodsFor: 'all' stamp: 'di 4/11/2000 08:36'!handlesMouseDown: evt	^ true! !!ChineseCheckerPiece methodsFor: 'all' stamp: 'di 4/11/2000 08:37'!justDroppedInto: newOwner event: evt	newOwner == myBoard ifFalse:		["Only allow dropping into my board."		^ evt hand rejectDropMorph: self event: evt]! !!ChineseCheckerPiece methodsFor: 'all' stamp: 'di 4/9/2000 09:27'!mouseDown: evt	((owner isKindOf: ChineseCheckers)		and: [owner okToPickUpPieceAt: boardLoc])		ifTrue: [evt hand grabMorph: self]! !!ChineseCheckerPiece methodsFor: 'all' stamp: 'di 4/11/2000 08:34'!setBoard: aBoard loc: aBoardLoc	myBoard _ aBoard.	boardLoc _ aBoardLoc! !!ChineseCheckerPiece class methodsFor: 'as yet unclassified' stamp: 'di 4/9/2000 11:17'!includeInNewMorphMenu	^ false! !!ChineseCheckers methodsFor: 'initialization'!board: b teams: t	board := b.	teams := t! !!ChineseCheckers methodsFor: 'initialization' stamp: 'di 4/9/2000 20:55'!copyBoard	"Return a copy of the board for the purpose of looking ahead one or more moves."	^ self copy		board: (board collect: [:row | row copy])		teams: (teams collect: [:team | team copy])! !!ChineseCheckers methodsFor: 'initialization' stamp: 'di 4/13/2000 13:35'!initialize	"Default creation is for one person against Squeak."	super initialize.	self extent: 382@413.	self color: (Color r: 0.6 g: 0.4 b: 0.0).	self borderWidth: 2.	animateMoves _ true.	self teams: #(2 5) autoPlay: {false. true}.! !!ChineseCheckers methodsFor: 'initialization' stamp: 'di 4/12/2000 23:44'!teams: teamsPlaying autoPlay: ifAuto	"Initialize board, teams, steps, jumps"	| p q teamInPlay |	colors _ (#(gray) , #(red green blue cyan magenta yellow white) shuffled)				collect: [:c | Color perform: c].  "New set of colors each time."	self removeAllMorphs.  "eg, from previous game."	board := (1 to: 19) collect: [:i | Array new: 19].	sixDeltas := {0@1. -1@1. -1@0. 0@-1. 1@-1. 1@0}.	homes := {14@2. 18@6. 14@14. 6@18. 2@14. 6@6}.	teams := (1 to: 6) collect: [:i | OrderedCollection new].	autoPlay := (1 to: 6) collect: [:i | false].	1 to: 6 do:		[:team | p:= homes at: team.		(teamInPlay := teamsPlaying includes: team) ifTrue:			[autoPlay at: team put: (ifAuto at: (teamsPlaying indexOf: team))].		"Place empty cells in rhombus extending out from each		home, and occupied cells in active home triangles."		1 to: 5 do: [:i | q := p.			1 to: 5 do: [:j |				(teamInPlay and: [j <= (5 - i)])					ifTrue: [self at: q put: team.							(teams at: team) add: q.							self addMorph:								((ChineseCheckerPiece									newBounds: ((self cellPointAt: q) extent: self pieceSize)									color: (colors at: team+1))										setBoard: self loc: q)]					ifFalse: [self at: q put: 0].				q := q + (sixDeltas at: team).  "right,forward"].			p := p + (sixDeltas atWrap: team+1).  "left,forward"].		teams at: team put: (teams at: team) asArray].	whoseMove _ teamsPlaying first.	self addMorph:		((ChineseCheckerPiece			newBounds: ((self cellPointAt: self turnIndicatorLoc) extent: self pieceSize)			color: (colors at: whoseMove+1))				setBoard: self loc: self turnIndicatorLoc).	plannedMove _ nil.	self changed! !!ChineseCheckers methodsFor: 'board geometry'!at: p	^ (board at: p x) at: p y! !!ChineseCheckers methodsFor: 'board geometry'!at: p put: x	^ (board at: p x) at: p y put: x! !!ChineseCheckers methodsFor: 'board geometry'!boardCenter	^ 10@10! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/9/2000 10:00'!boardLocAt: cellPoint	| dx dy row col |	dx _ self width/15.0.  dy _ dx * 0.8660254037844385 "(Float pi / 3) sin".	row _ (cellPoint y - self position y) // dy + 1.	col _ (cellPoint x - self position x) / (dx/2.0) + 16 - row // 2.	^ row @ col! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/11/2000 17:18'!cellPointAt: boardLoc	| dx dy row col |	dx _ self width/15.0.  dy _ dx * 0.8660254037844385 "(Float pi / 3) sin".	row _ boardLoc x.	col _ boardLoc y.	^ self position + ((col*2+row-16*dx//2)@(row-1*dy)) asIntegerPoint! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 3/13/2000 19:50'!distFrom: a to: b	"The six possible moves are: 1@0, 1@-1, 0@1, 0@-1, -1@0, -1@1."	| dx dy |	dx _ b x - a x.	dy _ b y - a y.	dx abs >= dy abs	ifTrue: ["Major change is in x-coord..."			dx >= 0			ifTrue: [(dy between: (0-dx) and: 0)						ifTrue: [^ dx  "no lateral motion"].					^ dx + ((0-dx) - dy max: dy - 0)  "added lateral dist"]			ifFalse: ["Reverse sign and rerun same code"					^ self distFrom: b to: a]]	ifFalse: ["Transpose and re-run same code"			^ self distFrom: a transposed to: b transposed]! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/11/2000 09:21'!extent: newExtent	| extraY |	extraY _ (newExtent x / 15.0 * 1.25) asInteger.	super extent: (newExtent x) @ (newExtent x + extraY).	self submorphsDo:		[:m | (m isKindOf: ChineseCheckerPiece) ifTrue:				[m position: (self cellPointAt: m boardLoc); extent: self pieceSize]]! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/11/2000 09:20'!pieceSize	^ self width asPoint // 20! !!ChineseCheckers methodsFor: 'board geometry' stamp: 'di 4/9/2000 09:44'!turnIndicatorLoc	^ 16@11! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/13/2000 14:18'!allMovesFrom: boardLoc  "boardLoc must be occupied"	| team stepMoves jumpDict |	team := self at: boardLoc.	stepMoves := (sixDeltas collect: [:d | boardLoc + d])		select: [:p | (self at: p) notNil and: [(self at: p) = 0]].	jumpDict := Dictionary new.	jumpDict at: boardLoc put: (Array with: boardLoc).	self jumpFor: team from: boardLoc havingVisited: jumpDict.	jumpDict removeKey: boardLoc.	^ (stepMoves collect: [:p | {boardLoc. p}]) , jumpDict values		reject:		[:move |  "Don't include any moves that land in other homes."		(self distFrom: move last to: self boardCenter) >= 5  "In a home..."			and: [(self distFrom: move last to: (homes atWrap: team+3)) > 3  "...not my goal..."			and: [(self distFrom: move last to: (homes at: team)) > 3  "...nor my home"]]]! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:23'!bestMove: ply forTeam: team	| score bestScore bestMove |	bestScore := -999.	(teams at: team) do:		[:boardLoc |		(self allMovesFrom: boardLoc) do:			[:move |			score := self score: move for: team.			(score > -99 and: [ply > 0]) ifTrue: 				[score := score  "Add 0.7 * score of next move (my guess)"					+ (0 max: ((self score: ((self copyBoard makeMove: move)							bestMove: ply - 1 forTeam: team) for: team) * 0.7))].			score > bestScore ifTrue:				[bestScore := score.  bestMove := move]]].	^ bestMove! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/10/2000 08:27'!checkDoneAfter: move	| team locsAfterMove |	(team := self at: move first) = 0 ifTrue: [^ false].	(locsAfterMove _ (teams at: team) copy) replaceAll: move first with: move last.	^ self testDone: locsAfterMove for: team! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:40'!endGameFor: team	"Return true if we are in the end game (all players within 1 of home triangle)."	| goalLoc |	goalLoc _ homes atWrap: team+3.  "Farthest cell across the board"	(teams at: team)		do: [:boardLoc | (self distFrom: boardLoc to: goalLoc) > 4 ifTrue: [^ false]].	^ true! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 20:36'!jumpFor: team from: loc havingVisited: dict	"Recursively explore all jumps from loc, leaving in dict	the prior position from which we got there"	"Fasten seatbelts..."	((((sixDeltas		collect: [:d | loc + d])		select: [:p | (self at: p) notNil and: [(self at: p) > 0]])		collect: [:p | p + (p - loc)])		select: [:p | (self at: p) notNil and: [(self at: p) = 0]])		do: [:p | (dict includesKey: p) ifFalse:			[dict at: p put: ((dict at: loc) copyWith: p).			self jumpFor: team from: p havingVisited: dict]]! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/10/2000 08:17'!makeMove: move	| team |	team := self at: move first.	self at: move last put: team.	self at: move first put: 0.	(teams at: team) replaceAll: move first with: move last! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/13/2000 14:21'!score: move for: team	"Return the decrease in distance toward this team's goal"	| goal closerToGoal wasBack nowBack |	goal _ homes atWrap: team+3.	wasBack _ self distFrom: move first to: goal.	nowBack _ self distFrom: move last to: goal.	closerToGoal _ wasBack - nowBack.	closerToGoal < -1 ifTrue: [^ -99].  "Quick rejection if move backward more than 1"	(nowBack <= 3 and: [self checkDoneAfter: move]) ifTrue: [^ 999].	"Reward closerToGoal, but add bias to move those left far behind."	^ (closerToGoal*5) + wasBack! !!ChineseCheckers methodsFor: 'moves' stamp: 'di 4/12/2000 23:40'!testDone: teamLocs for: team	"Return true if we are done (all players in home triangle)."	| goalLoc |	goalLoc _ homes atWrap: team+3.	teamLocs		do: [:boardLoc | (self distFrom: boardLoc to: goalLoc) > 3 ifTrue: [^ false]].	^ true! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'di 4/13/2000 14:07'!acceptDroppingMorph: aPiece event: evt	| dropLoc |	super acceptDroppingMorph: aPiece event: evt.	dropLoc _ self boardLocAt: evt cursorPoint.	dropLoc = aPiece boardLoc ifTrue:  "Null move"		[^ evt hand rejectDropMorph: aPiece event: evt].	(plannedMove _ (self allMovesFrom: aPiece boardLoc)				detect: [:move | move last = dropLoc]				ifNone: [nil])		ifNil: [^ evt hand rejectDropMorph: aPiece event: evt.   "Not a valid move"].	movePhase _ 1.  "Start the animation if any."! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'di 4/8/2000 23:45'!okToPickUpPieceAt: boardLoc	^ (self at: boardLoc) = whoseMove and: [(autoPlay at: whoseMove) not]! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'di 4/9/2000 08:30'!pieceAt: boardLoc	self submorphsDo:		[:m | ((m isMemberOf: ChineseCheckerPiece) and: [m boardLoc = boardLoc])				ifTrue: [^ m]].	^ nil! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'di 4/9/2000 10:44'!wantsDroppedMorph: aPiece event: evt	^ aPiece isKindOf: ChineseCheckerPiece! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:23'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Include our modest command set in the ctrl-menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	self addMenuItemsTo: aCustomMenu hand: aHandMorph! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 14:01'!addMenuItemsTo: aMenu hand: aHandMorph	aMenu add: 'new game' target: self action: #newGame.	aMenu add: 'reset...' target: self action: #reset.	animateMoves		ifTrue: [aMenu add: 'don''t animate moves' target: self action: #dontAnimateMoves]		ifFalse: [aMenu add: 'animate moves' target: self action: #animateMoves]! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:36'!animateMoves	animateMoves _ true! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:36'!dontAnimateMoves	animateMoves _ false! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:10'!handlesMouseDown: evt	"Prevent stray clicks from picking up the whole game in MVC."	^ World == nil or: [evt yellowButtonPressed]! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:24'!mouseDown: evt	| menu |	evt yellowButtonPressed ifFalse: [^ self].	menu _ MenuMorph new defaultTarget: self.	self addMenuItemsTo: menu hand: evt hand.	evt hand invokeMenu: menu event: evt.! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:32'!newGame	"Reset the board, with same teams."	| teamNumbers |	teamNumbers _ (1 to: 6) reject: [:i | (teams at: i) isEmpty].	self teams: teamNumbers		 autoPlay: (teamNumbers collect: [:i | autoPlay at: i]).! !!ChineseCheckers methodsFor: 'menu' stamp: 'di 4/13/2000 13:31'!reset	"Reset the board, choosing anew how many teams."	| nPlayers nHumans |	nPlayers _ (SelectionMenu selections: (1 to: 6)) startUpWithCaption: 'How many players?'.	nPlayers ifNil: [nPlayers _ 2].	nHumans _ (SelectionMenu selections: (0 to: nPlayers)) startUpWithCaption: 'How many humans?'.	nHumans ifNil: [nHumans _ 1].	self teams: (#((1) (2 5) (2 4 6) (1 2 4 5) (1 2 3 4 6) (1 2 3 4 5 6)) at: nPlayers)		 autoPlay: ((1 to: nPlayers) collect: [:i | i > nHumans]).! !!ChineseCheckers methodsFor: 'display' stamp: 'di 4/11/2000 09:22'!drawOn: aCanvas	| dot row1 row2 offset |	super drawOn: aCanvas.   "Draw square board"	"Only draw rows in the clipping region"	dot _ Form dotOfSize: self width//25.	offset _ self pieceSize - dot extent + 1 // 2.  "Offset of smaller dots rel to larger"	row1 _ (self boardLocAt: aCanvas clipRect topLeft) x max: 1.	row2 _ (self boardLocAt: aCanvas clipRect bottomRight) x min: board size.	row1 to: row2 do:		[:row | (board at: row) doWithIndex:			[:cell :i | cell ifNotNil:				[aCanvas stencil: dot					at: (self cellPointAt: (row@i)) + offset					color: (colors at: cell+1)]]]! !!ChineseCheckers methodsFor: 'display' stamp: 'di 4/10/2000 11:29'!printOn: s  "For testing only"	1 to: board size do: [:row |		s cr; next: row put: $ .		(board at: row) do:			[:cell | s space; nextPut:				(cell == nil					ifTrue: [$-]					ifFalse: [cell printString last])]]! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'di 4/13/2000 14:25'!nextTurn	(self testDone: (teams at: whoseMove) for: whoseMove) ifTrue:		[(self pieceAt: self turnIndicatorLoc) extent: self width asPoint//6; borderWidth: 2.		^ whoseMove _ 0.  "Game over."].		[whoseMove _ whoseMove\\6 + 1.	(teams at: whoseMove) isEmpty]  "Turn passes to the next player"		whileTrue: [].	(self pieceAt: self turnIndicatorLoc) color: (colors at: whoseMove+1)! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'di 4/11/2000 08:35'!showNextMoveSegment	"Display the current move in progress.  Starts with movePhase = 1.	Increments movePhase at each tick.  Ends by setting movePhase to 0."	| dot p1 p2 delta secondPhase line |	delta _ self width//40.	movePhase <= plannedMove size	ifTrue:		["First we trace the move with dots and lines..."		movePhase = 1 ifTrue: [pathMorphs _ OrderedCollection new].		p1 _ self cellPointAt: (plannedMove at: movePhase).		dot _ (ImageMorph new image: (Form dotOfSize: 7)) position: p1 + delta - (7//2).		self addMorph: dot.  pathMorphs addLast: dot.		movePhase > 1 ifTrue:			[p2 _ self cellPointAt: (plannedMove at: movePhase-1).			line _ PolygonMorph vertices: {p2 + delta. p1 + delta} color: Color black					borderWidth: 3 borderColor: Color black.			self addMorph: line.  pathMorphs addLast: line]]	ifFalse:		["...then we erase the path while moving the piece."		secondPhase _ movePhase - plannedMove size.		pathMorphs removeFirst delete.		secondPhase > 1 ifTrue:			[pathMorphs removeFirst delete.			self makeMove: {plannedMove at: secondPhase - 1. plannedMove at: secondPhase}.			(self pieceAt: (plannedMove at: secondPhase - 1))				position: (self cellPointAt: (plannedMove at: secondPhase));				setBoard: self loc: (plannedMove at: secondPhase).			self changed]].	(movePhase _ movePhase + 1) > (plannedMove size * 2)		ifTrue: [movePhase _ 0  "End of animated move"].! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'di 4/13/2000 13:52'!step	whoseMove = 0 ifTrue: [^ self].  "Game over."	plannedMove == nil ifTrue:		[(autoPlay at: whoseMove) ifFalse: [^ self].  "Waiting for a human."		(self endGameFor: whoseMove)  "Look deeper at the end."			ifTrue: [plannedMove _ self bestMove: 2 forTeam: whoseMove]			ifFalse: [plannedMove _ self bestMove: 1 forTeam: whoseMove].		movePhase _ 1.  "Start the animated move"].	animateMoves		ifTrue: ["Display the move in phases..."				movePhase > 0 ifTrue: [^ self showNextMoveSegment]]		ifFalse: ["... or skip the entire animated move if requested."				self makeMove: plannedMove.				(self pieceAt: plannedMove first)						position: (self cellPointAt: plannedMove last);						setBoard: self loc: plannedMove last.				self changed.				movePhase _ 0].	plannedMove _ nil.  "End the animated move"	self nextTurn! !!ChineseCheckers methodsFor: 'game sequence' stamp: 'di 4/12/2000 23:43'!stepTime	^ 200! !