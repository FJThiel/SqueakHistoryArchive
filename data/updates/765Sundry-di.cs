'From Squeak 2.3 of January 14, 1999 on 29 March 1999 at 11:47:40 am'!"Change Set:		SundryDate:			29 March 1999Author:			Dan IngallsA couple of changes to prevent gratuitous responses to inappropiate messages.	'abc' asNumber no longer responds with 0.	123 size no longer responds with 0. (requires new VM)	nil size no longer responds with 0. (requires new VM)All these are now errors, as they should be.Attempts to use at: or at:put: with non-indexable objects no longer complain about subscript bounds, but properly complain about indexability."!!Object methodsFor: 'accessing' stamp: 'di 3/29/1999 11:39'!at: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue:		[self class isVariable			ifTrue: [self errorSubscriptBounds: index]			ifFalse: [self error: (self class name) , 's are not indexable']].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'di 3/29/1999 11:41'!at: index put: value 	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[self class isVariable			ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]]			ifFalse: [self error: (self class name) , 's are not indexable']].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Integer class methodsFor: 'instance creation' stamp: 'di 2/9/1999 15:37'!readFrom: aStream base: base 	"Answer an instance of one of my concrete subclasses. Initial minus sign 	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not 	allowed--use Number readFrom: for that. Answer zero (not an error) if 	there are no digits."	| digit value neg startPos |	neg _ aStream peekFor: $-.	value _ 0.	startPos _ aStream position.	[aStream atEnd]		whileFalse: 			[digit _ aStream next digitValue.			(digit < 0 or: [digit >= base])				ifTrue: 					[aStream skip: -1.					aStream position = startPos ifTrue: [self error: 'At least one digit expected here'].					neg ifTrue: [^ value negated].					^ value]				ifFalse: [value _ value * base + digit]].	neg ifTrue: [^ value negated].	^ value! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 3/29/1999 11:28'!primitiveSize	| rcvr sz |	rcvr _ self stackTop.	(self isIntegerObject: rcvr) ifTrue: [^ self primitiveFail].  "Integers are not indexable"	(self formatOf: rcvr) < 2 ifTrue: [^ self primitiveFail].  "This is not an indexable object"	sz _ self stSizeOf: rcvr.	successFlag ifTrue:		[self pop: 1 thenPush: (self positive32BitIntegerFor: sz)]! !!Parser methodsFor: 'error handling' stamp: 'di 2/9/1999 15:43'!offEnd: aString 	"Notify a problem beyond 'here' (in lookAhead token). Don't be offEnded!!"	requestorOffset == nil		ifTrue: [^ self notify: aString at: mark]		ifFalse: [^ self notify: aString at: mark + requestorOffset]! !