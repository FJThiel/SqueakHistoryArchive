'From Squeak2.7 of 5 January 2000 [latest update: #1793] on 21 January 2000 at 3:42:29 pm'!"Change Set:		exportFixes-tkMXDate:			20 January 2000Author:			Ted KaehlerImageSegments keep track of how many roots were supplied by the user, and only return those (in the original order). You ask it with the message 'originalRoots'."!Object subclass: #ImageSegment	instanceVariableNames: 'arrayOfRoots segment outPointers state segmentName fileName endMarker userRootCnt '	classVariableNames: 'BiggestFileNumber '	poolDictionaries: ''	category: 'System-Object Storage'!!CompiledMethod class methodsFor: 'instance creation' stamp: 'tk 1/21/2000 15:25'!new: size	self error: 'CompiledMethods may only be created with newMethod:header:'! !!ImageSegment commentStamp: 'tk 1/20/2000 19:58' prior: 0!I represent a segment of Squeak address space.  I am created from an array of root objects.  After storing, my segment contains a binary encoding of every object accessible from my roots but not otherwise accessible from anywhere else in the system.  My segment contains outward pointers that are indices into my table of outPointers.	When a segment is written out onto a file, it goes in a folder called <image name>_segs.  If your image is called "Squeak2.6.image", the folder "Squeak2.6_segs" must accompany the image whenever your move, copy, or rename it.	Whenever a Class is in arrayOfRoots, its class (aClass class) must also be in the arrayOfRoots.	There are two kinds of image segments.  Normal image segments are a piece of a specific Squeak image, and can only be read back into that image.  The image holds the array of outPointers that are necessary to turn the bits in the file into objects.	To put out a normal segment that holds a Project (not the current project), execute (Project named: 'xxx') storeSegment.	The second kind of image segment is an Export Segment.  It can be read into a different Squeak image.  To create one:(ImageSegment new copyFromRootsForExport: (Array with: Baz with: Baz class))		writeForExport: 'myFile.extSeg'.To create one for a project:	(Project named: 'Play With Me - 3') exportSegment.To read it into another image:  Select 'myFile.extSeg' in a FileList, Menu 'load as project'.  It will install its classes automatically.  If you need to see the roots array, it is temporarily stored in (SmartRefStream scannedObject).arrayOfRoots	The objects that head the tree we will trace.segment			The WordArray of raw bits of all objects in the tree.outPointers		Oops of all objects outside the segment pointed to from inside.state			(see below)segmentName	Its basic name.  Often the name of a Project.fileName		The local name of the file.  'Foo-23.seg'endMarker		An object located in memory somewhere after a segment that has 		just been brought in.  To enumerate the objects in the segment, start at 		the segment and go to this object.userRootCnt		number of roots submitted by caller.  Extras are added in preparation for saving.state that an ImageSegment may exist in...#activeCopy			(has been copies, with the intent to become active)arrayOfRoots, segment, and outPointers have been created by copyFromRoots:.  The tree of objects has been encoded in the segment, but those objects are still present in the Squeak system.#active				(segment is actively holding objects)The segment is now the only holder of tree of objects.  Each of the original roots has been transmuted into an ImageSegmentRootStub that refers back to this image segment.  The original objects in the segment will all be garbageCollected.#onFileThe segment has been written out to a file and replaced by a file pointer.  Only ImageSegmentRootStubs and the array of outPointers remains in the image.  To get this far:(ImageSegment new copyFromRoots: (Array with: Baz with: Baz class))		writeToFile: 'myFile.seg'.#inactiveThe segment has been brought back into memory and turned back into objects.  rootsArray is set, but the segment is invalid.#onFileWithSymbolsThe segment has been written out to a file, along with the text of all the symbols in the outPointers array, and replaced by a file pointer.  This reduces the size of the outPointers array, and also allows the system to reclaim any symbols that are not referred to from elsewhere in the image.  The specific format used is that of a literal array as follows:	#(symbol1 symbol2 # symbol3 symbol4 'symbolWithSpaces' # symbol5).In this case, the original outPointers array was 8 long, but the compacted table of outPointers retains only two entries.  These get inserted in place of the #'s in the array of symbols after it is read back in.  Symbols with embedded spaces or other strange characters are written as strings, and converted back to symbols when read back in.  The symbol # is never written out.	NOTE: All IdentitySets or dictionaries must be rehashed when being read back from this format.  The symbols are effectively internal.  (No, not if read back into same image.  If a different image, then use #imported.  -tk)#importedThe segment is on an external file or just read in from one.  The segment and outPointers are meant to be read into a foreign image.   In this form, the image segment can be read from a URL, and installed.  A copy of the original array of root objects is constructed, with former outPointers bound to existing objects in the host system.  	(Any Class inside the segment MUST be in the arrayOfRoots.  This is so its association can be inserted into Smalltalk.  The class's metaclass must be in roots also.  Methods that are in outPointers because blocks point at them, were found and added to the roots.	All IdentitySets and dictionaries are rehashed when being read back from exported segments.) To discover why only some of the objects in a project are being written out, try this (***Destructive Test***).  This breaks lots of backpointers in the target project, and puts up an array of suspicious objects, a list of the classes of the outPointers, and a debugger."Close any transcripts in the target project"World currentHand objectToPaste ifNotNil: [	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString].PV _ Project named: 'xxxx'.(IS _ ImageSegment new) findRogueRootsImSeg: 	(Array with: PV world presenter with: PV world).IS findOwnersOutPtrs.	"Optionally: write a file with owner chains""Quit and DO NOT save"!!ImageSegment methodsFor: 'access' stamp: 'tk 1/20/2000 20:16'!originalRoots	"Return only the roots that the user submitted, not the ones we had to add."	userRootCnt ifNil: [^ arrayOfRoots].	^ arrayOfRoots copyFrom: 1 to: userRootCnt! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 1/20/2000 20:51'!copyFromRoots: aRootArray sizeHint: segSizeHint	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize rootSet uniqueRoots |	aRootArray ifNil: [self errorWrongState].	rootSet _ IdentitySet new: 150.	uniqueRoots _ OrderedCollection new.	1 to: aRootArray size do: [:ii |	"Don't include any roots twice"		(rootSet includes: (aRootArray at: ii)) 			ifFalse: [				uniqueRoots addLast: (aRootArray at: ii).				rootSet add: (aRootArray at: ii)]			ifTrue: [userRootCnt ifNotNil: ["adjust the count"						ii <= userRootCnt ifTrue: [userRootCnt _ userRootCnt - 1]]]].	arrayOfRoots _ uniqueRoots asArray.	rootSet _ uniqueRoots _ nil.	"be clean"	userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].	arrayOfRoots do: [:aRoot | (aRoot respondsTo: #indexIfCompact) ifTrue: [		aRoot indexIfCompact > 0 ifTrue: [			self error: 'Compact class ', aRoot name, ' cannot be a root']].		aRoot _ nil].	"clean up"	outPointers _ nil.	"may have used this instance before"	segSize _ segSizeHint > 0 ifTrue: [segSizeHint *3 //2] ifFalse: [50000].	["Guess a reasonable segment size"	segmentWordArray _ WordArray new: segSize.	endMarker _ 'End' clone.	"for enumeration of objects"	[outPointerArray _ Array new: segSize // 20] ifError: [		state _ #tooBig.  ^ self].	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 1/20/2000 20:11'!copyFromRootsForExport: rootArray 	"Add to roots:  Any methods pointed to from the outside by blocks."	| newRoots list segSize |	arrayOfRoots _ rootArray.	Smalltalk forgetDoIts.  	(newRoots _ self rootsIncludingPlayers) ifNotNil: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	"Creation of the segment happens here"	Smalltalk garbageCollect.	"get contexts with Players"	self copyFromRoots: arrayOfRoots sizeHint: 0.	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].	"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].	"with methods, blocks from outPointers"	list _ self compactClassesArray.	outPointers _ outPointers, (list select: [:cls | cls ~~ nil]),		(Array with: 1717 with: list).	"Zap sender of a homeContext. Can't send live stacks out."	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil]].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 1/20/2000 20:12'!rootsIncludingBlockMethods	"Return a new roots array with more objects.  (Caller should store into rootArray.) Any CompiledMethods that create blocks will be in outPointers if the block is held outside of this segment.  Put such methods into the roots list.  Then ask for the segment again."| extras myClasses gotIt |userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].extras _ OrderedCollection new.myClasses _ OrderedCollection new.arrayOfRoots do: [:aRoot | aRoot class class == Metaclass ifTrue: [					myClasses add: aRoot]].myClasses isEmpty ifTrue: [^ nil].	"no change"outPointers do: [:anOut | 	anOut class == CompiledMethod ifTrue: [		"specialized version of who"		gotIt _ false.		myClasses detect: [:class |			class selectorsDo: [:sel |				(class compiledMethodAt: sel) == anOut 					ifTrue: [extras add: anOut.  gotIt _ true]].			gotIt] 			ifNone: []		].	anOut _ nil].extras isEmpty ifTrue: [^ nil].	"no change"^ arrayOfRoots, extras! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 1/20/2000 20:12'!rootsIncludingBlocks	"For export segments only.  Return a new roots array with more objects.  (Caller should store into rootArray.)  Collect Blocks and external methods pointed to by them.  Put them into the roots list.  Then ask for the segment again."	| extras have |	userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].	extras _ OrderedCollection new.	outPointers do: [:anOut | 		anOut class == CompiledMethod ifTrue: [extras add: anOut].		(anOut class == BlockContext) ifTrue: [extras add: anOut].		(anOut class == MethodContext) ifTrue: [extras add: anOut].		anOut _ nil].	"don't hang onto it"	extras isEmpty ifTrue: [^ nil].	"no change"	[have _ extras size.	 extras copy do: [:anOut |		(anOut class == BlockContext) ifTrue: [			anOut home ifNotNil: [extras add: anOut home]].		(anOut class == MethodContext) ifTrue: [			anOut method ifNotNil: [extras add: anOut method]]].	 have = extras size] whileFalse.	^ arrayOfRoots, extras! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 1/20/2000 20:12'!rootsIncludingPlayers	"Return a new roots array with more objects.  (Caller should store into rootArray.) Player (non-systemDefined) gets its class and metaclass put into the Roots array.  Then ask for the segment again."| extras havePresenter players morphs |userRootCnt ifNil: [userRootCnt _ arrayOfRoots size].extras _ OrderedCollection new.arrayOfRoots do: [:root | 	(root isKindOf: Presenter) ifTrue: [havePresenter _ root].	(root isKindOf: PasteUpMorph) ifTrue: [			root isWorldMorph ifTrue: [havePresenter _ root presenter]].	(root isKindOf: Project) ifTrue: [havePresenter _ root world presenter]].havePresenter ifNotNil: [	havePresenter flushPlayerListCache.		"old and outside guys"	morphs _ IdentitySet new: 400.	havePresenter associatedMorph allMorphsAndBookPagesInto: morphs.	players _ (morphs select: [:m | m player ~~ nil] 				thenCollect: [:m | m player]) asArray.	players _ players select: [:ap | (arrayOfRoots includes: ap class) not		& (ap class isSystemDefined not)].	extras addAll: (players collect: [:each | each class]).	extras addAll: (players collect: [:each | each class class]).	].extras isEmpty ifTrue: [^ nil].	"no change"^ arrayOfRoots, extras	"will contain multiples of some, but reduced later"! !!ImageSegment methodsFor: 'object fileIn' stamp: 'tk 1/20/2000 20:52'!convertasossfe0: varDict asossfeu0: smartRefStrm	"These variables are automatically stored into the new instance ('arrayOfRoots' 'segment' 'outPointers' 'state' 'segmentName' 'fileName' 'endMarker' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('userRootCnt' )  If a non-nil value is needed, please assign it."! !