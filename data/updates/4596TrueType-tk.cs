'From Squeak3.2alpha of 4 October 2001 [latest update: #4589] on 10 December 2001 at 5:50:29 pm'!"Change Set:		TrueType-tkDate:			10 December 2001Author:			Ted KaehlerAttempt to make TrueType text available to users for headlines.  	Menu items for a TTSampleStringMorph:edit contents...		change the texthow to find more fonts...	tells what web site and what url to copy.load font from web...		loads and uses a new font.Install a default font in TTFontDescription class.Also, make Fancy Number morph not get an error when Option-clicked.  (No menu outside when a method.)"!Object subclass: #TTFontDescription	instanceVariableNames: 'glyphTable glyphs kernPairs copyright familyName fullName subfamilyName uniqueName versionName postscriptName trademark bounds unitsPerEm ascender descender lineGap '	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Balloon-TrueType Fonts'!!TTFontDescription commentStamp: 'tk 12/10/2001 17:03' prior: 0!Holds a TrueType font in memory.  Is used by TTSampleStringMorph as its font.  Class owns a default example.  !!TTSampleFontMorph commentStamp: 'tk 12/10/2001 17:15' prior: 0!!!TTSampleStringMorph commentStamp: 'tk 12/10/2001 17:16' prior: 0!I allow the display of a string in a TrueType font as a stand-alone morph.Morph's color changes the inside of the characters.Morph's borderColor changes the outline.Many free fonts are stored at www.FontGuy.com.  Use a normal web browser (not our Scamper) and go there.  Choose 'categories' and browse to a font you like.  Hold the mouse down on the example text in that font.  When the menu comes up, choose "Copy this link location".  Come back into Squeak, choose "load font from web..."from my menu, and paste in the url.!!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 12/7/2001 17:36'!httpGet: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGet: url accept: '*/*'! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 12/7/2001 17:37'!httpGet: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.	Note: To fetch raw data, you can use the MIME type 'application/octet-stream'.  To accept anything, use '*/*'."	^self httpGet: url  args: nil accept: mimeType! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 12/7/2001 12:27'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index connectToHost connectToPort type newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ self defaultPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [page _ page, (self argString: args) ].	HTTPProxyServer isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxyServer.			connectToPort _ HTTPProxyPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name "' , connectToHost , '".  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr;show: url; cr.	Transcript show: page; cr.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: header; cr."	firstData _ list at: 3.	header isEmpty 		ifTrue: [aStream _ 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length _ sock getHeader: 'content-length'.			length ifNotNil: [ length _ length asNumber ].			type _ sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl _ sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					newUrl _ self expandUrl: newUrl ip: serverAddr port: connectToPort.					^self httpGetDocument: newUrl args: args  accept: mimeType] ].			aStream _ sock getRestOfBuffer: firstData totalLength: length.			sock responseCode = '401' ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifFalse: [		]	].{'HTTPSocket class>>httpGetDocument:args:accept:request:'. aStream. url} inspect.	^'some other bad thing happened!!'! !!HTTPSocket class methodsFor: 'utilities' stamp: 'tk 12/7/2001 12:24'!expandUrl: newUrl ip: byteArrayIP port: portNum^ (newUrl beginsWith: '../') 	ifTrue: [		String streamContents: [:strm | 			byteArrayIP do: [:bb | bb printOn: strm.  strm nextPut: $.].			strm skip: -1; nextPut: $:.			portNum printOn: strm.			strm nextPutAll: (newUrl allButFirst: 2)]]	ifFalse: [newUrl]! !!ReadWriteStream methodsFor: 'converting' stamp: 'tk 12/10/2001 16:28'!asUnZippedStream	| isGZip outputStream first strm archive which |	"Decompress this file if needed, and return a stream.  No file is written.  File extension may be .gz or anything else.  Also works on archives (.zip, .gZip)."	strm _ self binary.	strm isZipArchive ifTrue: [		archive _ ZipArchive new readFrom: strm.		which _ archive members detect: [:any | any fileName asLowercase endsWith: '.ttf'] 								ifNone: [nil].		which ifNil: [archive close.					^ self error: 'Can''t find .ttf file in archive'].		strm _ which contentStream.		archive close].	first _ strm next.	isGZip _ (strm next * 256 + first) = (GZipConstants at: #GZipMagic).	strm skip: -2.	isGZip 		ifTrue: [outputStream _ (RWBinaryOrTextStream with:									(GZipReadStream on: strm) upToEnd) reset.				strm close]		ifFalse: [outputStream _ strm].	^ outputStream! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 12/10/2001 17:48'!showMenu: evt	| menu |	menu _ MenuMorph new.	self rootTile isMethodNode ifTrue:		[menu add: 'accept method' target: self selector: #accept.		menu addLine.		menu add: 'new temp variable' target: self selector: #attachTileForCode:nodeType: 					argumentList: {'| temp | temp'. TempVariableNode}.		menu addLine.		self parsedInClass allInstVarNames do: [:nn |			menu add: nn,' tile' target: self selector: #instVarTile: argument: nn].		menu addLine.		menu add: 'show code' target: self selector: #showCode.		menu add: 'try out' target: self selector: #try.		menu popUpAt: evt hand position forHand: evt hand in: World].! !!TTFontDescription class methodsFor: 'instance creations' stamp: 'tk 12/10/2001 17:12'!default	^ Default! !!TTSampleStringMorph methodsFor: 'initialize' stamp: 'tk 12/10/2001 17:36'!initializeToStandAlone	"Make me into an example"	| dd |	dd _ TTFontDescription default.	dd ifNil: [^ RectangleMorph initializeToStandAlone].	"not available"	super initializeToStandAlone.	self font: dd; color: (TranslucentColor r: 1.0 g: 0.097 b: 1.0 alpha: 0.6).	self string: 'TrueType fonts are beautiful'.! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'tk 12/10/2001 16:21'!font: aTTFontDescription	font _ aTTFontDescription.	string ifNil: [self string: aTTFontDescription fullName]		ifNotNil: [self initializeString].! !!TTSampleStringMorph methodsFor: 'menus' stamp: 'tk 12/7/2001 18:03'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'edit contents...' action: #edit.	aCustomMenu add: 'how to find more fonts...' action: #howTo.	aCustomMenu add: 'load font from web...' action: #loadFromURL.! !!TTSampleStringMorph methodsFor: 'menus' stamp: 'tk 12/7/2001 11:24'!edit	"Allow the user to change the text in a crude way"	| str |	str _ FillInTheBlankMorph request: 'Type in new text for this TrueType displayer.'				 initialAnswer: 'some text'.	str isEmpty ifTrue: [^ self].	self string: str.! !!TTSampleStringMorph methodsFor: 'menus' stamp: 'tk 12/10/2001 16:02'!howTo	self inform: 'Many free fonts are stored at www.FontGuy.com.  Use a normal web browser (not our Scamper) and go there.  Choose ''categories'' and browse to a font you like.  Hold the mouse down on the example text in that font.  When the menu comes up, choose "Copy this link location".  Come back into Squeak, choose "load font from web..."from this menu, and paste in the url.'! !!TTSampleStringMorph methodsFor: 'menus' stamp: 'tk 12/10/2001 16:03'!loadFromURL	"Allow the user to change the text in a crude way"	| url |	url _ FillInTheBlankMorph request: ' Type in the url for a TrueType font on the web. '				 initialAnswer: 'http://www.fontguy.com/download.asp?fontid=1494'.	url isEmpty ifTrue: [^ self].	self loadFromURL: url.! !!TTSampleStringMorph methodsFor: 'menus' stamp: 'tk 12/10/2001 16:03'!loadFromURL: urlString	"Fetch the file, unarchive, unzip, and use as my font."	| rawStrm |	rawStrm _ HTTPSocket httpGet: urlString. 	"Later use an HttpURL?"	self font: (TTFontReader readFrom: rawStrm asUnZippedStream).! !!TTSampleStringMorph class methodsFor: 'parts bin' stamp: 'tk 12/10/2001 17:34'!descriptionForPartsBin	^ self partName:	'TrueType banner'		categories:		#('Text' ' Basic 2 ')		documentation:	'A short text in a beautiful font.  Use the resize handle to change size.'! !"Postscript:Find the TrueType font in the system, and install it as the default in TTFontDescription.  It is MS Comic Sans from the Squeak Rulez example in the project 'Squeak in 3D'."| ttfdCls |ttfdCls _ Smalltalk at: #TTFontDescription ifAbsent: [^ nil].ttfdCls allInstancesDo: [:aTTFD |	aTTFD fullName = 'Comic Sans MS' ifTrue: [		ttfdCls classPool at: #Default put: aTTFD]].!