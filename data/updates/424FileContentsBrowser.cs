'From Squeak 2.0 of May 22, 1998 on 25 May 1998 at 1:01:41 am'!Browser subclass: #FileContentsBrowser	instanceVariableNames: 'packages infoString '	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!Object subclass: #FilePackage	instanceVariableNames: 'packageName fullName sourceSystem classes doIts classOrder '	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!Object subclass: #PseudoClass	instanceVariableNames: 'name definition organization source metaClass '	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!ClassOrganizer subclass: #PseudoClassOrganizer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!PseudoClass subclass: #PseudoMetaclass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!Object subclass: #TextDiffBuilder	instanceVariableNames: 'realSrc realDst srcMap dstMap srcLines dstLines srcPos dstPos added removed shifted runs matches multipleMatches patchSequence '	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!TextDiffBuilder subclass: #ClassDiffBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FileContentsBrowser'!!ChangeRecord methodsFor: 'access'!category	^category! !!ChangeRecord methodsFor: 'access'!isMetaClassChange	^meta! !!ChangeRecord methodsFor: 'access'!methodClassName	^class! !!Color class methodsFor: 'named colors' stamp: 'wod 5/24/1998 01:56'!tan	^  Color r: 0.8 g: 0.8 b: 0.5! !!FileContentsBrowser reorganize!('accessing' contents contents:notifying: packages packages: selectedPackage)('removing' removeClass removeMessage removeMessageCategory removePackage removeUnmodifiedCategories removeUnmodifiedClasses removeUnmodifiedMethods)('class list' classList findClass renameClass selectedClass)('edit pane' selectedMessage)('diffs' methodDiffFor:class:selector:meta: modifiedClassDefinition)('fileIn/fileOut' fileInClass fileInMessage fileInMessageCategories fileInPackage fileOutClass fileOutMessage fileOutMessageCategories fileOutPackage)('infoView' infoString infoViewContents packageInfo: updateInfoView)('metaclass' selectedClassOrMetaClass setClassOrganizer)('other' browseSenders changeMessageCategories:)('creation' createViews defaultBackgroundColor openAsMorph)('menus' classListMenu: messageCategoryMenu: messageListMenu: packageListMenu:)!!FileContentsBrowser methodsFor: 'accessing'!contents	self updateInfoView.	(editSelection == #newClass and:[self selectedPackage notNil])		ifTrue: [^self selectedPackage packageInfo].	editSelection == #editClass		ifTrue:[^self modifiedClassDefinition].	^super contents! !!FileContentsBrowser methodsFor: 'accessing'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be 	updated. The information can be a variety of things, depending on the 	list selections (such as templates for class or message definition, methods) 	or the user menu commands (such as definition, comment, hierarchy). 	Answer the result of updating the source."	| aString aText theClass |	aString _ input asString.	aText _ input asText.	editSelection == #editComment 		ifTrue: [theClass _ self selectedClass.				theClass ifNil: [PopUpMenu notify: 'You must select a classbefore giving it a comment.'.				^ false].				theClass comment: aText. ^ true].	editSelection == #editMessageCategories 		ifTrue: [^ self changeMessageCategories: aString].	self inform:'You cannot change the current selection'.	^false! !!FileContentsBrowser methodsFor: 'accessing'!packages	^packages! !!FileContentsBrowser methodsFor: 'accessing'!packages: aDictionary	packages := aDictionary.! !!FileContentsBrowser methodsFor: 'accessing'!selectedPackage	| cat |	cat := self selectedSystemCategoryName.	cat isNil ifTrue:[^nil].	^self packages at: cat asString ifAbsent:[nil]! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:37'!removeClass	| class |	classListIndex = 0 ifTrue: [^ self].	class _ self selectedClass.	(self confirm:'Are you certain that youwant to delete the class ', class name, '?') ifFalse:[^self].	self selectedPackage removeClass: class.	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:46'!removeMessage	| messageName |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	(self selectedClassOrMetaClass confirmRemovalOf: messageName) ifFalse:[^false].	self selectedClassOrMetaClass removeMethod: self selectedMessageName.	self messageListIndex: 0.	self setClassOrganizer.  "In case organization not cached"	self changed: #messageList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:51'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	messageCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageCategoryName _ self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?']) ifFalse: [^ self].	self selectedClassOrMetaClass removeCategory: messageCategoryName.	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:52'!removePackage	systemCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(self confirm: 'Are you sure you want toremove this package and all its classes?') ifFalse:[^self].	(systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) do:[:el|		systemOrganizer removeElement: el].	self packages removeKey: self selectedPackage packageName.	systemOrganizer removeCategory: self selectedSystemCategoryName.	self systemCategoryListIndex: 0.	self changed: #systemCategoryList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:41'!removeUnmodifiedCategories	| theClass |	self okToChange ifFalse:[^self].	theClass := self selectedClass.	theClass isNil ifTrue:[^self].	Cursor wait showWhile:[		theClass removeUnmodifiedMethods: (theClass selectors).	].	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:37'!removeUnmodifiedClasses	| packageList |	self okToChange ifFalse:[^self].	packageList := self selectedPackage isNil						ifTrue:[self packages] 						ifFalse:[Array with: self selectedPackage].	packageList do:[:package|		package classes copy do:[:theClass|			Cursor wait showWhile:[				theClass removeAllUnmodified.			].			theClass hasChanges ifFalse:[				package removeClass: theClass.			].		]].	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:44'!removeUnmodifiedMethods	| theClass cat |	self okToChange ifFalse:[^self].	theClass := self selectedClass.	theClass isNil ifTrue:[^self].	cat := self selectedMessageCategoryName.	cat isNil ifTrue:[^self].	Cursor wait showWhile:[		theClass removeUnmodifiedMethods: (theClass organization listAtCategoryNamed: cat).	].	self messageListIndex: 0.	self changed: #messageList.! !!FileContentsBrowser methodsFor: 'class list'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	(systemCategoryListIndex = 0 or:[self selectedPackage isNil])		ifTrue: [^Array new]		ifFalse: [^self selectedPackage classes keys asSortedCollection].! !!FileContentsBrowser methodsFor: 'class list'!findClass	| pattern foundClass classNames index foundPackage |	self okToChange ifFalse: [^ self classNotFound].	pattern _ (FillInTheBlank request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self].	classNames := Set new.	self packages do:[:p| classNames addAll: p classes keys].	classNames := classNames asArray select: 		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].	classNames isEmpty ifTrue: [^ self].	index _ classNames size == 1				ifTrue:	[1]				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].	index = 0 ifTrue: [^ self].	foundPackage := nil.	foundClass := nil.	self packages do:[:p| 		(p classes includesKey: (classNames at: index)) ifTrue:[			foundClass := p classes at: (classNames at: index).			foundPackage := p]].	foundClass isNil ifTrue:[^self]. 	self systemCategoryListIndex: (self systemCategoryList indexOf: foundPackage packageName asSymbol).	self classListIndex: (self classList indexOf: foundClass name). ! !!FileContentsBrowser methodsFor: 'class list' stamp: 'wod 5/24/1998 20:37'!renameClass	| oldName newName |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	oldName _ self selectedClass name.	newName _ (self request: 'Please type new class name'						initialAnswer: oldName) asSymbol.	(newName isEmpty or:[newName = oldName]) ifTrue: [^ self].	(self selectedPackage classes includesKey: newName)		ifTrue: [^ self error: newName , ' already exists in the package'].	systemOrganizer classify: newName under: self selectedSystemCategoryName.	systemOrganizer removeElement: oldName.	self selectedPackage renameClass: self selectedClass to: newName.	self changed: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) indexOf: newName).! !!FileContentsBrowser methodsFor: 'class list'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."	self selectedClassName == nil ifTrue: [^nil].	^self selectedPackage classAt: self selectedClassName! !!FileContentsBrowser methodsFor: 'edit pane'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	contents _ class sourceCodeAt: selector.	^self methodDiffFor: contents class: self selectedClass selector: self selectedMessageName meta: self metaClassIndicated! !!FileContentsBrowser methodsFor: 'diffs'!methodDiffFor: aString class: aPseudoClass selector: selector meta: meta	| theClass source diff |	theClass := Smalltalk at: aPseudoClass name ifAbsent:[^aString copy].	meta ifTrue:[theClass := theClass class].	(theClass includesSelector: selector) ifFalse:[^aString copy].	source := theClass sourceCodeAt: selector.	Cursor wait showWhile:[		diff := TextDiffBuilder buildDisplayPatchFrom: source to: aString.	].	^diff! !!FileContentsBrowser methodsFor: 'diffs'!modifiedClassDefinition	| pClass rClass old new diff |	pClass := self selectedClassOrMetaClass.	pClass hasDefinition ifFalse:[^pClass definition].	rClass := Smalltalk at: self selectedClass name asSymbol ifAbsent:[nil].	rClass isNil ifTrue:[^pClass definition].	self metaClassIndicated ifTrue:[ rClass := rClass class].	old := rClass definition.	new := pClass definition.	Cursor wait showWhile:[		diff := ClassDiffBuilder buildDisplayPatchFrom: old to: new	].	^diff! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileInClass	Cursor read showWhile:[		self selectedClass fileIn.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileInMessage	Cursor read showWhile:[		self selectedClass fileInMethod: self selectedMessageName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileInMessageCategories	Cursor read showWhile:[		self selectedClass fileInCategory: self selectedMessageCategoryName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 12:50'!fileInPackage	Cursor read showWhile:[		self selectedPackage fileIn.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileOutClass	Cursor write showWhile:[		self selectedClass fileOut.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileOutMessage	Cursor write showWhile:[		self selectedClass fileOutMethod: self selectedMessageName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 14:19'!fileOutMessageCategories	Cursor write showWhile:[		self selectedClass fileOutCategory: self selectedMessageCategoryName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 14:19'!fileOutPackage	Cursor write showWhile:[		self selectedPackage fileOut.	].! !!FileContentsBrowser methodsFor: 'infoView'!infoString	^infoString isNil		ifTrue:[infoString := StringHolder new]		ifFalse:[infoString]! !!FileContentsBrowser methodsFor: 'infoView'!infoViewContents	| theClass |	editSelection == #newClass ifTrue:[^self packageInfo: self selectedPackage].	self selectedClass isNil ifTrue:[^''].	theClass := Smalltalk at: (self selectedClass name asSymbol) ifAbsent:[nil].	editSelection == #editClass ifTrue:[		^(theClass notNil)			ifTrue:['Class exists already in the system']			ifFalse:['New class']].	(editSelection == #editMessage) ifFalse:[^''].	(theClass notNil and:[self metaClassIndicated]) ifTrue:[theClass := theClass class].	^(theClass notNil and:[theClass includesSelector: self selectedMessageName])		ifTrue:['Method already exists in the system']		ifFalse:['New method']! !!FileContentsBrowser methodsFor: 'infoView'!packageInfo: p	| nClasses newClasses oldClasses |	p isNil ifTrue:[^''].	nClasses := newClasses := oldClasses := 0.	p classes do:[:cls|		nClasses := nClasses + 1.		(Smalltalk includesKey: (cls name asSymbol))			ifTrue:[oldClasses := oldClasses + 1]			ifFalse:[newClasses := newClasses + 1]].	^nClasses printString,' classes (', newClasses printString, ' new / ', oldClasses printString, ' modified)'! !!FileContentsBrowser methodsFor: 'infoView' stamp: 'wod 5/19/1998 17:34'!updateInfoView	Smalltalk isMorphic 		ifTrue: [self changed: #infoViewContents]		ifFalse: [			self infoString contents: self infoViewContents.			self infoString changed].! !!FileContentsBrowser methodsFor: 'metaclass'!selectedClassOrMetaClass	"Answer the selected class or metaclass."	self metaClassIndicated		ifTrue: [^ self selectedClass metaClass]		ifFalse: [^ self selectedClass]! !!FileContentsBrowser methodsFor: 'metaclass'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer _ nil.	metaClassOrganizer _ nil.	classListIndex = 0 ifTrue: [^ self].	classOrganizer _ (theClass _ self selectedClass) organization.	metaClassOrganizer _ theClass metaClass organization.! !!FileContentsBrowser methodsFor: 'other' stamp: 'wod 5/25/1998 00:46'!browseSenders	"Create and schedule a message set browser on all senders of the 	currently selected message selector. Do nothing if no message is selected."	messageListIndex ~= 0 		ifTrue: [Smalltalk browseAllCallsOn: self selectedMessageName]! !!FileContentsBrowser methodsFor: 'other'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	self classOrMetaClassOrganizer changeFromString: aString.	self unlock.	self editClass.	self classListIndex: classListIndex.	^ true! !!FileContentsBrowser methodsFor: 'creation' stamp: 'wod 5/19/1998 18:24'!createViews	"Create a pluggable version of all the views for a Browser, including views and controllers."	| hasSingleFile width topView packageListView classListView switchView messageCategoryListView messageListView browserCodeView infoView |	Smalltalk isMorphic ifTrue: [^ self openAsMorph].	(hasSingleFile _ self packages size = 1)		ifTrue: [width _ 150]		ifFalse: [width _ 200].	(topView _ StandardSystemView new) 		model: self;		borderWidth: 1.		"label and minSize taken care of by caller"		hasSingleFile 		ifTrue: [			self systemCategoryListIndex: 1.			packageListView _ PluggableListView on: self				list: #systemCategorySingleton				selected: #indexIsOne 				changeSelected: #indexIsOne:				menu: #packageListMenu:.			packageListView window: (0 @ 0 extent: width @ 12)]		ifFalse: [			packageListView _ PluggableListView on: self				list: #systemCategoryList				selected: #systemCategoryListIndex				changeSelected: #systemCategoryListIndex:				menu: #packageListMenu:.			packageListView window: (0 @ 0 extent: 50 @ 70)].	topView addSubView: packageListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 50 @ 62).	hasSingleFile 		ifTrue: [topView addSubView: classListView below: packageListView]		ifFalse: [topView addSubView: classListView toRightOf: packageListView].	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: width@110).	topView 		addSubView: browserCodeView 		below: (hasSingleFile 			ifTrue: [switchView]			ifFalse: [packageListView]).	infoView _ StringHolderView new		model: self infoString;		window: (0@0 extent: width@12);		borderWidth: 1.	topView addSubView: infoView below: browserCodeView.	^ topView! !!FileContentsBrowser methodsFor: 'creation' stamp: 'wod 5/24/1998 01:56'!defaultBackgroundColor	^ #tan! !!FileContentsBrowser methodsFor: 'creation' stamp: 'wod 5/19/1998 19:04'!openAsMorph	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window aListExtent next |	window _ (SystemWindow labelled: 'later') model: self.	self packages size = 1		ifTrue: [			aListExtent _ 0.333333 @ 0.34.			self systemCategoryListIndex: 1.			window addMorph: (PluggableListMorph on: self list: #systemCategorySingleton					selected: #indexIsOne changeSelected: #indexIsOne:					menu: #packageListMenu:)				frame: (0@0 extent: 1.0@0.06).			next := 0@0.06]		ifFalse: [			aListExtent _ 0.25 @ 0.4.			window addMorph: (PluggableListMorph on: self list: #systemCategoryList					selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:					menu: #packageListMenu:)				frame: (0@0 extent: aListExtent).			next := aListExtent x @ 0].	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu:)		frame: (next extent: aListExtent - (0.0 @ 0.05)).	window addMorph: self buildMorphicSwitches		frame: (next + (0 @ (aListExtent y - 0.05)) extent: aListExtent x @ 0.05).	next := next + (aListExtent x @ 0).	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (next extent: aListExtent).	next := next + (aListExtent x @ 0).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:)		frame: (next extent: aListExtent).	window addMorph: (PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.4 corner: 1@0.94).	window addMorph: (PluggableTextMorph on: self text: #infoViewContents accept: nil			readSelection: nil menu: nil)		frame: (0@0.94 corner: 1@1).	^ window! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 13:18'!classListMenu: aMenu	^ aMenu 		labels:'definitioncommentclass refsfileInfileOutrename...removeremove existing'		lines: #(2 3 5 7)		selections: #(editClass editComment browseClassRefs fileInClass fileOutClass renameClass removeClass removeUnmodifiedCategories) ! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 17:39'!messageCategoryMenu: aMenu	^ aMenu 		labels:'fileInfileOutreorganizeadd item...rename...removeremove existing'		lines: #(2 3 6)		selections: #(fileInMessageCategories fileOutMessageCategories editMessageCategories addCategory renameCategory removeMessageCategory removeUnmodifiedMethods)! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 14:37'!messageListMenu: aMenu	^ aMenu 		labels:'fileInfileOutsendersimplementorsremove'		lines: #(2 4)		selections: #(fileInMessage fileOutMessage browseSenders browseImplementors removeMessage).! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 13:09'!packageListMenu: aMenu	^ aMenu 		labels:'find class...fileInfileOutremoveremove existing'		lines: #(1 3 4)		selections: #(findClass fileInPackage fileOutPackage removePackage removeUnmodifiedClasses)! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'wod 5/13/1998 18:17'!browseFile: aFilename	self browseFiles: (Array with: aFilename).! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'wod 5/14/1998 23:40'!browseFiles: fileList	| package organizer packageDict browser |	Cursor wait showWhile: [		packageDict _ Dictionary new.		organizer _ SystemOrganizer defaultList: Array new.		fileList do: [:fileName |			package _ FilePackage fromFileNamed: fileName.			packageDict 				at: package packageName 				put: package.			organizer 				classifyAll: package classes keys 				under: package packageName].		(browser := self new)			systemOrganizer: organizer;			packages: packageDict].	self		openBrowserView: browser createViews		label: 'Package Browser'.! !!FileList methodsFor: 'file list menu' stamp: 'wod 5/13/1998 14:50'!fileSelectedMenu: aMenu	^ aMenu		labels:'fileInfile into new change setbrowse changesbrowse codespawn this filecopy name to clipboardopen image in a windowread image into GIFImportsplay midi filesort by namesort by sizesort by daterenamedeleteadd new filebroadcast as update'		lines: # (2 6 8 9 12)		selections: #(fileInSelection fileIntoNewChangeSet browseChanges browseFile editFile copyName openImageInWindow importImage playMidiFile sortByName sortBySize sortByDate renameFile deleteFile addNewFile putUpdate)! !!FileList methodsFor: 'file list menu' stamp: 'wod 5/13/1998 04:12'!noFileSelectedMenu: aMenu	^ aMenu		labels:'sort by namesort by sizesort by datebrowse code filesadd new file'		lines: # (3 4)		selections: #(sortByName sortBySize sortByDate browseFiles addNewFile)! !!FileList methodsFor: 'menu messages' stamp: 'wod 5/13/1998 04:10'!browseFile	FileContentsBrowser browseFile: self fullName.! !!FileList methodsFor: 'menu messages' stamp: 'wod 5/13/1998 04:10'!browseFiles	| selectionPattern fileList |	selectionPattern := FillInTheBlank request:'What files?' initialAnswer: self pattern.	fileList _ (directory fileNamesMatching: selectionPattern) 		collect: [:each | directory fullNameFor: each].	FileContentsBrowser browseFiles: fileList.! !!FilePackage methodsFor: 'accessing'!classAt: className	^self classes at: className! !!FilePackage methodsFor: 'accessing'!classes	^classes! !!FilePackage methodsFor: 'accessing'!fullPackageName	^fullName! !!FilePackage methodsFor: 'accessing'!packageInfo	^String streamContents:[:s|		s nextPutAll:'Package: '.		s nextPutAll: self fullPackageName; cr; cr.		sourceSystem isEmpty ifFalse:[			s nextPutAll: sourceSystem; cr; cr].		doIts isEmpty ifFalse:[			s nextPutAll:'Unresolvable doIts:'; cr; cr.			doIts do:[:chgRec|				s nextPut:$!!; nextPutAll: chgRec string; nextPut: $!!; cr]]].! !!FilePackage methodsFor: 'accessing'!packageName	^packageName! !!FilePackage methodsFor: 'accessing'!removeClass: aPseudoClass	(self classes removeKey: aPseudoClass name).	classOrder copy do:[:cls|		cls name = aPseudoClass name ifTrue:[ classOrder remove: cls].	].! !!FilePackage methodsFor: 'accessing'!renameClass: aPseudoClass to: newName	| oldName |	oldName := aPseudoClass name.	self classes removeKey: oldName.	self classes at: newName put: aPseudoClass.	aPseudoClass renameTo: newName.! !!FilePackage methodsFor: 'initialize'!fromFileNamed: aName	| stream |	fullName := aName.	packageName := FileDirectory localNameFor: fullName.	stream := FileStream readOnlyFileNamed: aName.	doIts := OrderedCollection new.	classOrder := OrderedCollection new.	sourceSystem := ''.	self fileInFrom: stream.! !!FilePackage methodsFor: 'private'!classDefinition: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	tokens size = 11 ifFalse:[^doIts add: chgRec].	theClass := self getClass: (tokens at: 3).	theClass definition: string.	classOrder add: theClass.! !!FilePackage methodsFor: 'private'!getClass: className	| pseudoClass |	(classes includesKey: className) ifTrue:[		^classes at: className.	].	pseudoClass := PseudoClass new.	pseudoClass name: className.	classes at: className put: pseudoClass.	^pseudoClass.! !!FilePackage methodsFor: 'private'!metaClassDefinition: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	theClass := self getClass: (tokens at: 1).	theClass metaClass definition: string.	classOrder add: theClass metaClass.! !!FilePackage methodsFor: 'private'!msgClassComment: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	(tokens size = 3 and:[(tokens at: 3) class == String]) ifTrue:[		theClass := self getClass: tokens first.		^theClass commentString: tokens last].	(tokens size = 4 and:[(tokens at: 3) asString = 'class' and:[(tokens at: 4) class == String]]) ifTrue:[		theClass := self getClass: tokens first.		theClass metaClass commentString: tokens last].! !!FilePackage methodsFor: 'private'!possibleSystemSource: chgRec	| tokens |	sourceSystem isEmpty ifTrue:[		tokens := Scanner new scanTokens: chgRec string.		(tokens size = 1 and:[tokens first class == String]) ifTrue:[			sourceSystem := tokens first.			^self]].	doIts add: chgRec.! !!FilePackage methodsFor: 'private'!removedMethod: string with: chgRec	| class tokens |	tokens := Scanner new scanTokens: string.	(tokens size = 3 and:[(tokens at: 2) == #removeSelector: ]) ifTrue:[		class := self getClass: (tokens at: 1).		^class removeSelector: (tokens at: 3).	].	(tokens size = 4 and:[(tokens at: 2) == #class and:[(tokens at: 3) == #removeSelector:]]) ifTrue:[		class := self getClass: (tokens at: 1).		^class metaClass removeSelector: (tokens at: 4).	].	doIts add: chgRec! !!FilePackage methodsFor: 'private'!sampleMethod"	In an existing method there are always a number of changes.	Other stuff		will be deleted	Or even better,		some things may be just modified."! !!FilePackage methodsFor: 'change record types'!classComment: chgRec	(self getClass: chgRec methodClassName) classComment: chgRec! !!FilePackage methodsFor: 'change record types'!doIt: chgRec	| string |	string := chgRec string.	('*ubclass:*instanceVariableNames:*classVariableNames:*poolDictionaries:*category:*'		match: string) ifTrue:[^self classDefinition: string with: chgRec].	('* class*instanceVariableNames:*'		match: string) ifTrue:[^self metaClassDefinition: string with: chgRec].	('* removeSelector: *'		match: string) ifTrue:[^self removedMethod: string with: chgRec].	('* comment:*'		match: string) ifTrue:[^self msgClassComment: string with: chgRec].	('* initialize'		match: string) ifTrue:[^self]. "Initialization is done based on class>>initialize"	('''From *'		match: string) ifTrue:[^self possibleSystemSource: chgRec].	doIts add: chgRec.! !!FilePackage methodsFor: 'change record types'!method: chgRec	(self getClass: chgRec methodClassName) methodChange: chgRec! !!FilePackage methodsFor: 'change record types'!preamble: chgRec	self doIt: chgRec! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 15:57'!askForDoits	| menu choice choices |	choices := #('do not process' 'at the beginning' 'at the end' 'cancel').	menu _ SelectionMenu selections: choices.	choice := nil.	[choices includes: choice] whileFalse: [		choice _ menu startUpWithCaption: 'The package contains unprocessed doIts.When would like to process those?'].	^choices indexOf: choice! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 16:00'!fileIn	| doitsMark |	doitsMark := 1.	doIts isEmpty ifFalse:[doitsMark := self askForDoits].	doitsMark = 4 ifTrue: [^nil].	doitsMark = 2 ifTrue:[self fileInDoits].	classOrder do:[:cls|		cls fileInDefinition.	].	classes do:[:cls|		Transcript cr; show:'Filing in ', cls name.		cls fileInMethods.		cls hasMetaclass ifTrue:[cls metaClass fileInMethods].	].	doitsMark = 3 ifTrue:[self fileInDoits].! !!FilePackage methodsFor: 'fileIn/fileOut'!fileInDoits	doIts do:[:chgRec| chgRec fileIn].! !!FilePackage methodsFor: 'fileIn/fileOut'!fileOut	| fileName stream |	fileName := FillInTheBlank request: 'Enter the file name' initialAnswer:''.	stream := FileStream newFileNamed: fileName.	sourceSystem isEmpty ifFalse:[		stream nextChunkPut: sourceSystem printString;cr ].	self fileOutOn: stream.	stream cr; cr.	self classes do:[:cls|		cls needsInitialize ifTrue:[			stream cr; nextChunkPut: cls name,' initialize']].	stream cr.	stream close.! !!FilePackage methodsFor: 'fileIn/fileOut'!fileOutDoits: aStream	doIts do:[:chgRec| chgRec fileOutOn: aStream].! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 15:59'!fileOutOn: aStream	| doitsMark |	doitsMark := 1.	doIts isEmpty ifFalse:[doitsMark := self askForDoits].	doitsMark = 4 ifTrue: [^nil].	doitsMark = 2 ifTrue:[self fileOutDoits: aStream].	classOrder do:[:cls|		cls fileOutDefinitionOn: aStream.	].	classes do:[:cls|		cls fileOutMethodsOn: aStream.		cls hasMetaclass ifTrue:[cls metaClass fileOutMethodsOn: aStream].	].	doitsMark = 3 ifTrue:[self fileOutDoits: aStream].! !!FilePackage methodsFor: 'reading'!fileInFrom: aStream	| chgRec changes |	changes := (ChangeList new scanFile: aStream from: 0 to: aStream size) changeList.	aStream close.	classes := Dictionary new.	('Processing ', self packageName) 		displayProgressAt: Sensor cursorPoint		from: 1		to: changes size		during:[:bar|			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				self perform: (chgRec type copyWith: $:) asSymbol with: chgRec.			].		].! !!FilePackage class methodsFor: 'instance creation'!fromFileNamed: aName	^self new fromFileNamed: aName! !!OrderedCollection methodsFor: 'adding'!add: newObject beforeIndex: index 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just preceding index. Answer newObject."	self insert: newObject before: firstIndex + index.	^newObject! !!PseudoClass methodsFor: 'class'!classComment: aChangeRecord	self organization classComment: aChangeRecord! !!PseudoClass methodsFor: 'class'!comment	| rStr |	rStr := self organization commentRemoteStr.	^rStr isNil		ifTrue:[self name,' has not been commented']		ifFalse:[rStr string]! !!PseudoClass methodsFor: 'class'!comment: aString	self commentString: aString.! !!PseudoClass methodsFor: 'class' stamp: 'wod 4/15/98 17:21'!commentString	^self organization classComment asString! !!PseudoClass methodsFor: 'class'!commentString: aString	self classComment: aString asText. "Just wrap it"! !!PseudoClass methodsFor: 'class'!definition	^definition ifNil:['There is no class definition for this class'].! !!PseudoClass methodsFor: 'class'!definition: aString	definition := aString! !!PseudoClass methodsFor: 'class'!metaClass	^metaClass ifNil:[metaClass := PseudoMetaclass new name: (self name)].! !!PseudoClass methodsFor: 'class'!renameTo: aString	self hasDefinition ifTrue:[		self isMetaClass ifTrue:[			self definition: (self definition				copyReplaceAll: name,' class'				with: aString, ' class').		] ifFalse:[			self definition: (self definition 					copyReplaceAll:'ubclass: #',name					with:'ubclass: #', aString)]].	name := aString.	metaClass ifNotNil:[metaClass renameTo: aString].! !!PseudoClass methodsFor: 'accessing'!fullName	^self name! !!PseudoClass methodsFor: 'accessing'!name	^name! !!PseudoClass methodsFor: 'accessing'!name: anObject	name _ anObject! !!PseudoClass methodsFor: 'accessing'!organization	^organization ifNil:[organization := PseudoClassOrganizer defaultList: SortedCollection new].! !!PseudoClass methodsFor: 'accessing'!realClass	^Smalltalk at: self name asSymbol! !!PseudoClass methodsFor: 'accessing' stamp: 'wod 5/19/1998 17:42'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^self! !!PseudoClass methodsFor: 'removing'!removeAllUnmodified	| stClass |	self exists ifFalse:[^self].	self removeUnmodifiedMethods: self selectors.	stClass := self realClass.	(self hasDefinition and:[stClass definition = self definition]) ifTrue:[definition := nil].	(self hasComment and:[stClass comment asString = self commentString]) ifTrue:[ self classComment: nil].	metaClass isNil ifFalse:[metaClass removeAllUnmodified].! !!PseudoClass methodsFor: 'removing'!removeUnmodifiedMethods: aCollection	| stClass |	self exists ifFalse:[^self].	stClass := self realClass.	aCollection do:[:sel|		(self sourceCodeAt: sel) = (stClass sourceCodeAt: sel ifAbsent:['']) asString ifTrue:[			self removeMethod: sel.		].	].	self organization removeEmptyCategories.! !!PseudoClass methodsFor: 'private'!confirmRemovalOf: aString	^self confirm:'Remove ',aString,' ?'! !!PseudoClass methodsFor: 'private'!evaluate: aString	^Compiler evaluate: aString for: nil logged: true! !!PseudoClass methodsFor: 'private'!makeSureClassExists: aString	| theClass |	theClass := Smalltalk at: (aString asSymbol) ifAbsent:[nil].	theClass ifNotNil:[^true].	^self confirm: aString,' does not exist in the system. Use nil instead?'.! !!PseudoClass methodsFor: 'private'!makeSureSuperClassExists: aString	| theClass |	theClass := Smalltalk at: (aString asSymbol) ifAbsent:[nil].	theClass ifNotNil:[^true].	^self confirm: 'The super class ',aString,' does not exist in the system. Use nil instead?'.! !!PseudoClass methodsFor: 'private'!parserClass	^Parser! !!PseudoClass methodsFor: 'testing'!exists	^(Smalltalk at: self name asSymbol ifAbsent:[^false]) isKindOf: Behavior! !!PseudoClass methodsFor: 'testing'!hasChanges	self sourceCode isEmpty ifFalse:[^true].	self organization hasNoComment ifFalse:[^true].	definition isNil ifFalse:[^true].	metaClass isNil ifFalse:[^metaClass hasChanges].	^false! !!PseudoClass methodsFor: 'testing'!hasComment	^self organization commentRemoteStr notNil! !!PseudoClass methodsFor: 'testing'!hasDefinition	^definition notNil! !!PseudoClass methodsFor: 'testing'!hasMetaclass	^metaClass notNil! !!PseudoClass methodsFor: 'testing'!isMetaClass	^false! !!PseudoClass methodsFor: 'testing'!nameExists	^Smalltalk includesKey: self name asSymbol! !!PseudoClass methodsFor: 'testing'!needsInitialize	^self hasMetaclass and:[		self metaClass selectors includes: #initialize]! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileIn	"FileIn the receiver"	self hasDefinition ifTrue:[self fileInDefinition].	self fileInMethods: self selectors.	metaClass ifNotNil:[metaClass fileIn].	self needsInitialize ifTrue:[		self evaluate: self name,' initialize'.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInCategory: aCategory	^self fileInMethods: (self organization listAtCategoryNamed: aCategory)! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInDefinition	(self makeSureSuperClassExists: (definition copyUpTo: Character space)) ifFalse:[^self].	self hasDefinition ifTrue:[		Transcript cr; show:'Defining ', self name.		self evaluate: self definition].	self exists ifFalse:[^self].	self hasComment ifTrue:[self realClass classComment: self comment].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethod: selector	^self fileInMethods: (Array with: selector)! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethods	^self fileInMethods: self selectors! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethods: aCollection	"FileIn all methods with selectors taken from aCollection"	| theClass cat |	self exists ifFalse:[^self classNotDefined].	theClass := self realClass.	aCollection do:[:sel|		cat := self organization categoryOfElement: sel.		cat = self removedCategoryName ifFalse:[			theClass 				compile: (self sourceCodeAt: sel) 				classified: cat				withStamp: (self stampAt: sel)				notifying: nil.		].	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOut	| f |	f := (FileStream newFileNamed: self name,'.st').	self fileOutOn: f.	self needsInitialize ifTrue:[		f cr; nextChunkPut: self name,' initialize'.	].	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutCategory: categoryName	| f |	f := (FileStream newFileNamed: self name,'-',categoryName,'.st').	self fileOutMethods: (self organization listAtCategoryNamed: categoryName)			on: f.	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutDefinitionOn: aStream	self hasDefinition ifFalse:[^self].	aStream nextChunkPut: self definition; cr.	self hasComment ifTrue:[		aStream cr; nextPut: $!!; nextChunkPut: self name,' comment: '; cr.		aStream nextChunkPut: self commentString printString.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethod: selector	| f |	f := (FileStream newFileNamed: self name,'-', selector, '.st').	self fileOutMethods: (Array with: selector)			on: f.	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethods: aCollection on: aStream	"FileOut all methods with selectors taken from aCollection"	| cat categories |	categories := Dictionary new.	aCollection do:[:sel|		cat := self organization categoryOfElement: sel.		cat = self removedCategoryName ifFalse:[			(categories includesKey: cat) 				ifFalse:[categories at: cat put: Set new].			(categories at: cat) add: sel].	].	categories associationsDo:[:assoc|		cat := assoc key.		aStream cr; cr; nextPut:$!!; nextChunkPut:(String streamContents:[:s|			s nextPutAll: self fullName; nextPutAll:' methodsFor: '; print: cat asString]).		assoc value do:[:sel|			aStream cr.			aStream nextChunkPut: (self sourceCodeAt: sel).		].		aStream space; nextPut:$!!.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethodsOn: aStream	^self fileOutMethods: self selectors on: aStream.! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutOn: aStream	"FileOut the receiver"	self fileOutDefinitionOn: aStream.	metaClass ifNotNil:[metaClass fileOutDefinitionOn: aStream].	self fileOutMethods: self selectors on: aStream.	metaClass ifNotNil:[metaClass fileOutMethods: metaClass selectors on: aStream].! !!PseudoClass methodsFor: 'errors'!classNotDefined	^self inform: self name,' is not defined in the system.You have to define this class first.'.! !!PseudoClass methodsFor: 'categories'!removeCategory: selector	(self organization listAtCategoryNamed: selector) do:[:sel|		self organization removeElement: sel.		self sourceCode removeKey: sel.	].	self organization removeCategory: selector.! !!PseudoClass methodsFor: 'categories'!removedCategoryName	^'*** removed methods ***' asSymbol! !!PseudoClass methodsFor: 'categories'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	^ self organization categoryOfElement: aSelector! !!PseudoClass methodsFor: 'methods'!addMethodChange: aChangeRecord	| selector |	selector := Parser new parseSelector: aChangeRecord string.	self organization classify: selector under: aChangeRecord category.	self sourceCodeAt: selector put: aChangeRecord! !!PseudoClass methodsFor: 'methods'!methodChange: aChangeRecord	aChangeRecord isMetaClassChange ifTrue:[		^self metaClass addMethodChange: aChangeRecord.	] ifFalse:[		^self addMethodChange: aChangeRecord.	].! !!PseudoClass methodsFor: 'methods'!removeMethod: selector	self organization removeElement: selector.	self sourceCode removeKey: selector.! !!PseudoClass methodsFor: 'methods'!removeSelector: aSelector	| catName |	catName := self removedCategoryName.	self organization addCategory: catName before: self organization categories first.	self organization classify: aSelector under: catName.	self sourceCodeAt: aSelector put:'methodWasRemoved' asText.! !!PseudoClass methodsFor: 'methods'!selectors	^self sourceCode keys! !!PseudoClass methodsFor: 'methods'!sourceCode	^source ifNil:[source := Dictionary new]! !!PseudoClass methodsFor: 'methods'!sourceCodeAt: sel	^(self sourceCode at: sel) string! !!PseudoClass methodsFor: 'methods'!sourceCodeAt: sel put: object	self sourceCode at: sel put: object! !!PseudoClass methodsFor: 'methods'!sourceCodeTemplate	^''! !!PseudoClass methodsFor: 'methods'!stampAt: selector	^(self sourceCode at: selector) stamp! !!PseudoClassOrganizer methodsFor: 'all' stamp: 'wod 4/15/98 17:08'!classComment	"Answer the comment associated with the object that refers to the receiver."	globalComment == nil ifTrue: [^''].	^globalComment! !!PseudoClassOrganizer methodsFor: 'all'!classComment: aChangeRecord	globalComment := aChangeRecord! !!PseudoClassOrganizer methodsFor: 'all'!setDefaultList: aCollection	super setDefaultList: aCollection.	self classComment: nil.! !!PseudoMetaclass methodsFor: 'accessing'!fullName	^self name,' class'! !!PseudoMetaclass methodsFor: 'accessing'!realClass	^super realClass class! !!PseudoMetaclass methodsFor: 'testing'!isMetaClass	^true! !!TextDiffBuilder methodsFor: 'printing'!printPatchSequence: ps on: aStream	| type line attr |	ps do:[:assoc|		type := assoc key.		line := assoc value.		attr := TextEmphasis normal.		type == #insert ifTrue:[attr := TextColor red].		type == #remove ifTrue:[attr := TextEmphasis struckOut].		aStream withAttribute: attr do:[aStream nextPutAll: line; cr].	].	! !!TextDiffBuilder methodsFor: 'initialize'!destString: aString	realDst := self split: aString.	dstLines := OrderedCollection new.	dstMap := OrderedCollection new.	realDst doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			dstLines add: line.			dstMap add: realIndex.		"]."	].	dstPos := Dictionary new: dstLines size.	dstLines doWithIndex:[:line :index|		(dstPos includesKey: line)			ifTrue:[(dstPos at: line) add: index. multipleMatches := true]			ifFalse:[dstPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'initialize'!from: sourceString to: destString	self sourceString: sourceString.	self destString: destString.! !!TextDiffBuilder methodsFor: 'initialize'!sourceString: aString	realSrc := self split: aString.	srcLines := OrderedCollection new.	srcMap := OrderedCollection new.	realSrc doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			srcLines add: line.			srcMap add: realIndex.		"]."	].	srcPos := Dictionary new: srcLines size.	srcLines doWithIndex:[:line :index| 		(srcPos includesKey: line)			ifTrue:[(srcPos at: line) add: index. multipleMatches := true]			ifFalse:[srcPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'initialize'!split: aString	^self split: aString by: self splitCharacter! !!TextDiffBuilder methodsFor: 'testing'!hasMultipleMatches	^multipleMatches == true! !!TextDiffBuilder methodsFor: 'creating patches'!buildDisplayPatch	^Text streamContents:[:stream|		self printPatchSequence: self buildPatchSequence on: stream.	]! !!TextDiffBuilder methodsFor: 'creating patches'!buildPatchSequence	"@@ TODO: Das funktioniert noch nicht für n-m matches"	matches := Dictionary new.	self buildReferenceMap.	runs := self processDiagonals.	self validateRuns: runs.	"There may be things which have just been moved around. Find those."	shifted := self detectShiftedRuns.	self processShiftedRuns.	"Now generate a patch sequence"	patchSequence := self generatePatchSequence.	^patchSequence! !!TextDiffBuilder methodsFor: 'creating patches'!buildReferenceMap	dstLines doWithIndex:[:line :index|		(srcPos includesKey: line) 			ifTrue:[(srcPos at: line) do:[:index2|						matches at: index@index2 put: line]]	].	srcLines doWithIndex:[:line :index|		(dstPos includesKey: line)			ifTrue:[(dstPos at: line) do:[:index2|						matches at: index2@index put: line]]	].! !!TextDiffBuilder methodsFor: 'creating patches'!collectRunFrom: todo startingWith: startIndex into: run	| next start |	start := startIndex.	self remove: start from: todo.	run add: (matches at: start).	"Search downwards"	next := start.	[next := next + (1@1).	todo includes: next] whileTrue:[		run addLast: (matches at: next).		self remove: next from: todo].	"Search upwards"	next := start.	[next := next - (1@1).	todo includes: next] whileTrue:[		run addFirst: (matches at: next).		self remove: next from: todo.		start := next. "To use the first index"	].	^start! !!TextDiffBuilder methodsFor: 'creating patches'!detectShiftedRuns	| sortedRuns lastY run shiftedRuns |	runs size < 2 ifTrue: [^ nil].	shiftedRuns _ OrderedCollection new.	sortedRuns _ SortedCollection sortBlock: [:a1 :a2 | a1 key x < a2 key x].	runs associationsDo: [:assoc | sortedRuns add: assoc].	lastY _ sortedRuns first key y.	2 to: sortedRuns size do:[:i | 		run _ sortedRuns at: i.		run key y > lastY			ifTrue: [lastY _ run key y]			ifFalse: [shiftedRuns add: run]].	^ shiftedRuns! !!TextDiffBuilder methodsFor: 'creating patches'!generatePatchSequence	| ps |	ps := OrderedCollection new: srcLines size.	srcLines size timesRepeat:[ps add: nil].	self incorporateMatchesInto: ps.	self incorporateRemovalsInto: ps.	self incorporateAddsInto: ps.	^ps! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateAddsInto: aPatchSequence	"Incorporate adds"	| lastMatch lastIndex index |	added ifNil:[^self].	added := added sortBy:[:a1 :a2| a1 key < a2 key].	lastMatch := 1.	lastIndex := 0.	1 to: added size do:[:i|		index := (added at: i) key.		[index > lastMatch] whileTrue:[			[lastIndex := lastIndex + 1.			(aPatchSequence at: lastIndex) key == #match] whileFalse.			lastMatch := lastMatch + 1.		].		aPatchSequence add: #insert->(added at: i) value beforeIndex: lastIndex.		lastIndex := lastIndex + 1.		lastMatch := lastMatch + 1.	].! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateMatchesInto: aPatchSequence	"Incorporate matches"	| index |	runs associationsDo:[:assoc|		index := assoc key y.		assoc value do:[:line|			self assert:[(aPatchSequence at: index) isNil].			aPatchSequence at: index put: (#match -> line).			index := index + 1.		].	].! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateRemovalsInto: aPatchSequence	"Incorporate removals"	| index |	removed ifNil:[^self].	removed do:[:assoc|		index := assoc key.		self assert:[(aPatchSequence at: index) isNil].		aPatchSequence at: index put: #remove -> assoc value.	].! !!TextDiffBuilder methodsFor: 'creating patches'!processDiagonals	^self processDiagonalsFrom: matches keys asSet! !!TextDiffBuilder methodsFor: 'creating patches'!processDiagonalsFrom: todoList	| runList start run todo |	todo := todoList copy.	runList := Dictionary new.	[todo isEmpty] whileFalse:[		start := todo detect:[:any| true].		run := OrderedCollection new.		start := self 					collectRunFrom: todo 					startingWith: start 					into: run.		runList at: start put: run.	].	"If we have multiple matches we might have chosen a bad sequence.	There we redo the whole thing recursively"	self hasMultipleMatches  ifFalse:[^runList].	runList size < 2 ifTrue:[^runList].	run := nil.	start := 0.	runList associationsDo:[:assoc|		(run isNil or:[assoc value size > run size]) ifTrue:[			run := assoc value.			start := assoc key]].	"Now found the longest run"	run := OrderedCollection new.	start := self				collectRunFrom: todoList				startingWith: start				into: run.	"Find the diagonals in the remaining set"	runList := self processDiagonalsFrom: todoList.	runList at: start put: run.	^runList! !!TextDiffBuilder methodsFor: 'creating patches'!processShiftedRuns	| key |	shifted isNil ifTrue:[^self].	shifted do:[:assoc|		key := assoc key.		assoc value doWithIndex:[:line :idx|			removed add: (key y + idx - 1) -> line.			added add: (key x + idx - 1) -> line].		runs removeKey: assoc key.	].! !!TextDiffBuilder methodsFor: 'creating patches'!validateRuns: runList	| srcPosCopy dstPosCopy lines srcIndex dstIndex |	srcPosCopy := Dictionary new: srcPos size.	srcPos associationsDo:[:assoc| srcPosCopy at: assoc key put: assoc value asSet].	dstPosCopy := Dictionary new: dstPos size.	dstPos associationsDo:[:assoc| dstPosCopy at: assoc key put: assoc value asSet].	runList associationsDo:[:assoc|		srcIndex := assoc key y.		dstIndex := assoc key x.		lines := assoc value.		lines do:[:string|			(srcPosCopy at: string) remove: srcIndex.			(dstPosCopy at: string) remove: dstIndex.			srcIndex := srcIndex + 1.			dstIndex := dstIndex + 1.		].	].	removed := OrderedCollection new.	srcPosCopy associationsDo:[:assoc|		assoc value do:[:index| removed add: (index -> assoc key)].	].	removed := removed sortBy:[:a1 :a2| a1 key < a2 key].	added := OrderedCollection new.	dstPosCopy associationsDo:[:assoc|		assoc value do:[:index| added add: (index -> assoc key)].	].	added := added sortBy:[:a1 :a2| a1 key < a2 key].! !!TextDiffBuilder methodsFor: 'private'!assert: aBlock	aBlock value ifFalse:[self error: 'Assertion failed']! !!TextDiffBuilder methodsFor: 'private'!remove: pointKey from: aSet	| sArray obj |	self hasMultipleMatches ifFalse:[^aSet remove: pointKey].	sArray := aSet asArray.	1 to: sArray size do:[:i|		obj := sArray at: i.		obj x = pointKey x ifTrue:[			aSet remove: obj.		] ifFalse:[			obj y = pointKey y ifTrue:[				aSet remove: obj.			].		]	].! !!TextDiffBuilder methodsFor: 'private'!split: aString by: splitChar	| lines in out c |	lines := OrderedCollection new.	in := ReadStream on: aString.	out := WriteStream on: String new.	[in atEnd] whileFalse:[		(c := in next) = splitChar ifTrue:[			lines add: out contents.			out reset.		] ifFalse:[			out nextPut: c.		].	].	out position = 0 ifFalse:[		lines add: out contents.	].	^lines! !!TextDiffBuilder methodsFor: 'private'!splitCharacter	^Character cr! !!ClassDiffBuilder methodsFor: 'initialize'!split: aString	| lines in out c |	lines := OrderedCollection new.	in := ReadStream on: aString.	out := WriteStream on: String new.	[in atEnd] whileFalse:[		(c := in next) isSeparator ifTrue:[			out nextPut: c.			lines add: out contents.			out reset.		] ifFalse:[			out nextPut: c.		].	].	out position = 0 ifFalse:[		lines add: out contents.	].	^lines! !!ClassDiffBuilder methodsFor: 'printing'!printPatchSequence: ps on: aStream	| type line attr |	ps do:[:assoc|		type := assoc key.		line := assoc value.		attr := TextEmphasis normal.		type == #insert ifTrue:[attr := TextColor red].		type == #remove ifTrue:[attr := TextEmphasis struckOut].		aStream withAttribute: attr do:[aStream nextPutAll: line].	].! !!TextDiffBuilder class methodsFor: 'instance creation'!buildDisplayPatchFrom: srcString to: dstString	^(self from: srcString to: dstString) buildDisplayPatch! !!TextDiffBuilder class methodsFor: 'instance creation'!from: srcString to: dstString	^self new from: srcString to: dstString! !