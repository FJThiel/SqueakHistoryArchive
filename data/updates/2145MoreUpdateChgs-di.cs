'From Squeak2.8alpha of 12 January 2000 [latest update: #2143] on 16 May 2000 at 1:48:08 pm'!"Change Set:		MoreUpdateChgsDate:			16 May 2000Author:			Dan IngallsA few more changes required by Torge Husfeldt's change that made downloaded updates go in their own directory."!!ServerDirectory methodsFor: 'updates' stamp: 'di 5/16/2000 13:47'!putUpdateMulti: list fromDirectory: updateDirectory	"Put these files out as an Update on the servers of my group.  List is an array of local file names without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence myName response restOfText seq add newNames file |	(self checkNames: list) ifFalse: [^ nil].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	(myServers _ self checkServers) size = 0 ifTrue: [self closeGroup.  ^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	sequence _ Utilities lastUpdateNum: updateStrm.	add _ WriteStream on: (String new: 200).	newNames _ list collect: [:each | 		seq _ (sequence _ sequence+1) printString.		seq size = 1 ifTrue: [seq _ '00', seq].		seq size = 2 ifTrue: [seq _ '0', seq].		add nextPutAll: seq; nextPutAll: each; cr.		seq, each].	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: add contents; nextPutAll: restOfText.	myServers do: [:aServer |		list doWithIndex: [:local :ind |			file _ updateDirectory oldFileNamed: local.			aServer putFile: file named: (newNames at: ind) retry: true.			file close].		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript cr; show: 'Updates succeeded on server ', aServer moniker].	self closeGroup.		Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally"	list with: newNames do:		[:local :newName | updateDirectory rename: local toBe: newName].! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 5/16/2000 13:33'!broadcastUpdatesFrom: n1 to: n2 except: skipList"	ChangeSorter removeChangeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialIntegerOrNil > 412]].	Utilities readServerUpdatesSaveLocally: true updateImage: true.	Utilities broadcastUpdatesFrom: 413 to: 999 except: #().	Utilities readServerUpdatesSaveLocally: true updateImage: false       The expression above ftps all updates not in the current imageover to the local       hard disk, but does NOT absorb them into the current image"	| fileNames fileNamesInOrder fileNamesUnnumbered names choice filecsname updateDirectory |	updateDirectory _ FileDirectory default directoryNamed: 'updates'.	fileNames _ updateDirectory fileNames select:		[:n | n first isDigit			and: [(n initialIntegerOrNil between: n1 and: n2)			and: [(skipList includes: n initialIntegerOrNil) not]]].	fileNamesInOrder _ fileNames asSortedCollection: [:a :b | ainitialIntegerOrNil < b initialIntegerOrNil].	fileNamesUnnumbered _ fileNamesInOrder collect:		[:n | n copyFrom: (n findFirst: [:c | c isDigit not]) to: n size].	(csname _ fileNamesUnnumbered asBag sortedCounts first) key > 1		ifTrue: [self halt: 'Repeated name: ' , csname value].	(file _ fileNamesUnnumbered select: [:n | (n occurrencesOf: $.) > 1])size > 0		ifTrue: [self halt: file first , ' has multiple periods'].	fileNamesInOrder with: fileNamesUnnumbered do:		[:n :nu | updateDirectory rename: n toBe: nu].	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	(ServerDirectory groupNamed: choice) putUpdateMulti:fileNamesUnnumbered fromDirectory: updateDirectory! !ServerDirectory removeSelector: #putUpdateMulti:!