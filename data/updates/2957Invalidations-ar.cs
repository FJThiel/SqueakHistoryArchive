'From Squeak2.9alpha of 13 June 2000 [latest update: #3005] on 13 November 2000 at 1:54:05 am'!"Change Set:		Invalidations-arDate:			12 November 2000Author:			Andreas RaabA whole new run on invalidations. Fixes up the #addMorph: #removeMorph: methods to suppress unneeded sends of #layoutChanged and also invalidates the regions rather than sending #changed, since we know that the region needs to be redrawn but we don't know if that other guy has changed or not.Also changes the #invalidRect: protocol to use #invalidRect:from: so that it easier for morphs to figure out if an invalidation came from a child or not (useful for transforms and clipping)."!!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 11/12/2000 22:31'!shuffleSubmorphs	"Randomly shuffle the order of my submorphs.  Don't call this method lightly!!"	| bg |	self invalidRect: self fullBounds.	(submorphs size > 0 and: [submorphs last mustBeBackmost]) ifTrue:		[bg _ submorphs last.		bg privateDelete].	submorphs _ submorphs shuffled.	bg ifNotNil: [self addMorphBack: bg].	self layoutChanged! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/13/2000 01:43'!addAllMorphs: aCollection	| any box invalidate |	invalidate _ self isInWorld.	box _ nil.	aCollection do: [:m |		any _ m.		m owner ifNotNil: [m owner privateRemoveMorph: m].		invalidate ifTrue:[			box ifNil:[box _ m fullBounds copy] 				ifNotNil:[box _ box quickMerge: m fullBounds]].		m privateOwner: self].	submorphs _ submorphs, aCollection.	self layoutChanged.	box ifNotNil:[self invalidRect: box from: any].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/13/2000 01:44'!addAllMorphs: aCollection after: anotherMorph	| index box any invalidate |	invalidate _ self isInWorld.	box _ nil.	index _ submorphs indexOf: anotherMorph ifAbsent: [submorphs size].	aCollection do: [:m |		any _ m.		m owner ifNotNil: [m owner privateRemoveMorph: m].		invalidate ifTrue:[			box ifNil:[box _ m fullBounds copy] 				ifNotNil:[box _ box quickMerge: m fullBounds]].		m privateOwner: self].	submorphs _ (submorphs copyFrom: 1 to: index), aCollection,			(submorphs copyFrom: index+1 to: submorphs size).	self layoutChanged.	box ifNotNil:[self invalidRect: box from: any].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/13/2000 01:42'!addMorph: aMorph after: anotherMorph	"Add the given morph as one of my submorphs, inserting it after anotherMorph"	| index |		aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph privateOwner: self.	index _ submorphs indexOf: anotherMorph ifAbsent: [submorphs size].		"important to get this index AFTER removing aMorph, since it might have been		one of my submorphs"	submorphs _ (submorphs copyFrom: 1 to: index), (OrderedCollection with: aMorph),			(submorphs copyFrom: index+1 to: submorphs size).	self layoutChanged.	self isInWorld ifTrue:[self invalidRect: aMorph fullBounds from: aMorph].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/13/2000 01:41'!addMorph: newMorph behind: aMorph	"Add a morph to the list of submorphs behind the specified morph"	| newSubmorphs index |	newMorph owner ifNotNil: [newMorph owner privateRemoveMorph: newMorph].	newMorph privateOwner: self.	newSubmorphs _ submorphs species new: submorphs size + 1.	index _ 1.	[ (submorphs at: index) = aMorph ]		whileFalse: [ newSubmorphs at: index put: (submorphs at: index).					  index _ index + 1 ].	newSubmorphs at: index put: aMorph.	newSubmorphs at: (index + 1) put: newMorph.	newSubmorphs		replaceFrom: (index + 2)		to: newSubmorphs size		with: submorphs		startingAt: (index + 1).	submorphs _ newSubmorphs.	self layoutChanged.	self isInWorld ifTrue:[self invalidRect: newMorph fullBounds from: newMorph].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/13/2000 01:41'!addMorph: newMorph inFrontOf: aMorph	"Add a morph to the list of submorphs in front of the specified morph"	| newSubmorphs index |	newMorph owner ifNotNil: [newMorph owner privateRemoveMorph: newMorph].	newMorph privateOwner: self.	newSubmorphs _ submorphs species new: submorphs size + 1.	index _ 1.	[ (submorphs at: index) = aMorph ]		whileFalse: [ newSubmorphs at: index put: (submorphs at: index).					  index _ index + 1 ].	newSubmorphs at: index put: newMorph.	newSubmorphs		replaceFrom: (index + 1)		to: newSubmorphs size		with: submorphs		startingAt: index.	submorphs _ newSubmorphs.	self layoutChanged.	self isInWorld ifTrue:[self invalidRect: newMorph fullBounds from: newMorph].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/13/2000 01:44'!addMorphBack: aMorph	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph privateOwner: self.	submorphs _ submorphs copyWith: aMorph.	self layoutChanged.	self isInWorld ifTrue:[self invalidRect: aMorph fullBounds from: aMorph].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/13/2000 01:42'!addMorphFront: aMorph	| newSubmorphs |	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph privateOwner: self.	newSubmorphs _ submorphs species new: submorphs size + 1.	newSubmorphs at: 1 put: aMorph.	newSubmorphs		replaceFrom: 2		to: newSubmorphs size		with: submorphs		startingAt: 1.	submorphs _ newSubmorphs.	self layoutChanged.	self isInWorld ifTrue:[self invalidRect: aMorph fullBounds from: aMorph].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/13/2000 01:42'!removeAllMorphs	(fullBounds notNil or:[self isInWorld]) ifTrue:[self invalidRect: self fullBounds].	submorphs do: [:m | m privateOwner: nil].	submorphs _ EmptyArray.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/13/2000 01:42'!removeAllMorphsIn: aCollection	"greatly speeds up the removal of *lots* of submorphs"	| set |	(fullBounds notNil or:[self isInWorld]) ifTrue:[self invalidRect: self fullBounds].	aCollection do: [:m | m privateOwner: nil].	set _ IdentitySet new: aCollection size * 4 // 3.	aCollection do: [:each | set add: each].	submorphs _ submorphs reject: [ :each | set includes: each].	self layoutChanged.! !!Morph methodsFor: 'drawing' stamp: 'ar 11/12/2000 18:47'!clipSubmorphs: aBool	"Drawing specific. If this property is set, clip the receiver's submorphs to the receiver's clipping bounds."	self invalidRect: self fullBounds.	aBool == false		ifTrue:[self removeProperty: #clipSubmorphs]		ifFalse:[self setProperty: #clipSubmorphs toValue: aBool].	self invalidRect: self fullBounds.! !!Morph methodsFor: 'geometry' stamp: 'ar 11/12/2000 22:06'!outerBounds	"Return the 'outer' bounds of the receiver, e.g., the bounds that need to be invalidated when the receiver changes."	| box |	box _ self bounds.	self hasDropShadow ifTrue:[box _ self expandFullBoundsForDropShadow: box].	self hasRolloverBorder ifTrue:[box _ self expandFullBoundsForRolloverBorder: box].	^box! !!Morph methodsFor: 'geometry' stamp: 'ar 11/13/2000 01:07'!position: aPoint	"Change the position of this morph and and all of its submorphs."	| delta box |	delta _ aPoint - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"	box _ self fullBounds.	box _ box merge: (box translateBy: delta).	self invalidRect: box.	self privateFullMoveBy: delta.! !!Morph methodsFor: 'change reporting' stamp: 'ar 11/12/2000 22:21'!changed	"Report that the area occupied by this morph should be redrawn."	^self invalidRect: self outerBounds! !!Morph methodsFor: 'change reporting' stamp: 'ar 11/12/2000 18:50'!invalidRect: damageRect	^self invalidRect: damageRect from: self! !!Morph methodsFor: 'change reporting' stamp: 'ar 11/12/2000 18:41'!invalidRect: aRectangle from: aMorph	| damageRect |	damageRect _ aRectangle.	aMorph == self ifFalse:[		"Clip to receiver's clipping bounds if the damage came from a child"		self clipSubmorphs 			ifTrue:[damageRect _ aRectangle intersect: self clippingBounds]].	owner ifNotNil: [owner invalidRect: damageRect from: self].	self wonderlandTexture ifNotNil:[self isValidWonderlandTexture: false].! !!Morph methodsFor: 'caching' stamp: 'ar 11/12/2000 18:41'!releaseCachedState	"Release any state that can be recomputed on demand, such as the pixel values for a color gradient or the editor state for a TextMorph. This method may be called to save space when a morph becomes inaccessible. Implementations of this method should do 'super releaseCachedState'."	self wonderlandTexture: nil. "We can recreate it if needed"! !!Morph methodsFor: 'debug and other' stamp: 'ar 11/12/2000 19:00'!addMouseActionIndicatorsWidth: anInteger color: aColor	self deleteAnyMouseActionIndicators.	self changed.	self hasRolloverBorder: true.	self setProperty: #rolloverWidth toValue: anInteger@anInteger.	self setProperty: #rolloverColor toValue: aColor.	fullBounds ifNotNil:[fullBounds _ self privateFullBounds].	self changed.! !!Morph methodsFor: 'debug and other' stamp: 'ar 11/12/2000 22:52'!deleteAnyMouseActionIndicators	self changed.	(self valueOfProperty: #mouseActionIndicatorMorphs ifAbsent: [#()]) do: [ :each |		each deleteWithSiblings		"one is probably enough, but be safe"	].	self removeProperty: #mouseActionIndicatorMorphs.	self hasRolloverBorder: false.	self removeProperty: #rolloverWidth.	self removeProperty: #rolloverColor.	self changed.! !!Morph methodsFor: 'private' stamp: 'ar 11/13/2000 01:42'!privateAddMorph: aMorph atIndex: index	((index >= 1) and: [index <= (submorphs size + 1)])		ifFalse: [^ self error: 'index out of range'].	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph privateOwner: self.	submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).	self layoutChanged.	self isInWorld ifTrue:[self invalidRect: aMorph fullBounds from: aMorph].! !!Morph methodsFor: 'private' stamp: 'ar 11/12/2000 18:58'!privateMoveBy: delta	"Private!! Use 'position:' instead."	| fill |	extension ifNotNil:[		extension player ifNotNil:[			"Most cases eliminated fast by above test"			self getPenDown ifTrue:[				"If this is a costume for a player with its pen down, draw a line."				self moveWithPenDownBy: delta]]].	bounds _ bounds translateBy: delta.	fullBounds ifNotNil:[fullBounds _ fullBounds translateBy: delta].	fill _ self fillStyle.	fill isOrientedFill ifTrue:[fill origin: fill origin + delta].! !!Morph methodsFor: 'private' stamp: 'ar 11/13/2000 01:43'!privateRemoveMorph: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	self isInWorld ifTrue:[self invalidRect: aMorph fullBounds from: aMorph].	submorphs _ submorphs copyWithout: aMorph.	self layoutChanged.! !!Morph methodsFor: 'visual properties' stamp: 'ar 11/12/2000 18:59'!fillStyle	"Return the current fillStyle of the receiver."	extension ifNil:[^color ifNil:[self defaultColor]].	^self valueOfProperty: #fillStyle ifAbsent:[		"Workaround already converted morphs"		color ifNil:[self defaultColor]].! !!Morph methodsFor: 'texture support' stamp: 'ar 11/12/2000 18:40'!asTexture	"Represent the receiver as a Wonderland texture."	| canvas texture hqTexture texExtent tempForm valid |	hqTexture _ self valueOfProperty: #highQualityTexture ifAbsent:[false].	valid _ self isValidWonderlandTexture.	texture _ self wonderlandTexture.	"Determine the size we expect the texture to be.	Note: This size must never be less than the receiver's since	this will lead to (unwanted) clipping."	texExtent _ self extent.	hqTexture ifTrue:[		"High quality textures round up to next power of two"		texExtent _ texExtent x asLargerPowerOfTwo @ texExtent y asLargerPowerOfTwo.	].	(texture == nil or:[texture extent ~= texExtent]) ifTrue:[		self removeProperty: #wonderlandTexture.		texture _ nil. "Clean up for GC"		texture _ B3DTexture extent: texExtent depth: 32.		texture interpolate: false.		texture wrap: false.		texture envMode: 0.		valid _ false].	valid ifFalse:[		canvas _ texture getCanvas.		canvas translateBy: self topLeft negated			during:[:tempCanvas| tempCanvas fullDrawMorph: self].		self isValidWonderlandTexture: true.		"High quality textures need an extra pass here"		(texExtent ~= self extent) ifTrue:[			tempForm _ texture contentsOfArea: (0@0 extent: self extent).			tempForm displayInterpolatedOn: texture].	].	self setProperty: #wonderlandTexture toValue: texture.	^ texture! !!Morph methodsFor: 'texture support' stamp: 'ar 11/12/2000 18:40'!isValidWonderlandTexture	"Return true if the receiver is a valid wonderland texture"	extension == nil ifTrue:[^false].	^self valueOfProperty: #isValidWonderlandTexture ifAbsent:[true]! !!Morph methodsFor: 'texture support' stamp: 'ar 11/12/2000 18:40'!isValidWonderlandTexture: aBool	"Return true if the receiver is a valid wonderland texture"	aBool == true		ifTrue:[self removeProperty: #isValidWonderlandTexture]		ifFalse:[self setProperty: #isValidWonderlandTexture toValue: aBool].! !!Morph methodsFor: 'texture support' stamp: 'ar 11/12/2000 18:35'!wonderlandTexture	"Return the current wonderland texture associated with the receiver"	extension == nil ifTrue:[^nil].	^self valueOfProperty: #wonderlandTexture ifAbsent:[nil]! !!Morph methodsFor: 'texture support' stamp: 'ar 11/12/2000 18:36'!wonderlandTexture: aTexture	"Return the current wonderland texture associated with the receiver"	aTexture == nil		ifTrue:[self removeProperty: #wonderlandTexture]		ifFalse:[self setProperty: #wonderlandTexture toValue: aTexture].! !!Morph methodsFor: 'drop shadows' stamp: 'ar 11/12/2000 18:58'!addDropShadow	self hasDropShadow ifTrue:[^self].	self changed.	self hasDropShadow: true.	self shadowOffset: 3@3.	fullBounds ifNotNil:[fullBounds _ self privateFullBounds].	self changed.! !!Morph methodsFor: 'drop shadows' stamp: 'ar 11/12/2000 23:22'!hasDropShadow	extension == nil ifTrue:[^false].	^self valueOfProperty: #hasDropShadow ifAbsent:[false]! !!Morph methodsFor: 'drop shadows' stamp: 'ar 11/12/2000 23:23'!hasRolloverBorder	extension == nil ifTrue:[^false].	^self valueOfProperty: #hasRolloverBorder ifAbsent:[false]! !!Morph methodsFor: 'drop shadows' stamp: 'ar 11/12/2000 18:57'!removeDropShadow	self hasDropShadow ifFalse:[^self].	self changed.	self hasDropShadow: false.	fullBounds ifNotNil:[fullBounds _ self privateFullBounds].	self changed.! !!Morph methodsFor: 'drop shadows' stamp: 'ar 11/12/2000 18:58'!shadowPoint: newPoint	self changed.	self shadowOffset: newPoint - self center // 5.	fullBounds ifNotNil:[fullBounds _ self privateFullBounds].	self changed.! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 23:19'!doLayoutIn: layoutBounds	"Compute a new layout based on the given layout bounds."	| layout box priorBounds |	"Note: Testing for #bounds or #layoutBounds would be sufficient to	figure out if we need an invalidation afterwards but #outerBounds	is what we need for all leaf nodes so we use that."	priorBounds _ self outerBounds.	submorphs size = 0 ifTrue:[^fullBounds _ priorBounds].	"Send #ownerChanged to our children"	submorphs do:[:m| m ownerChanged].	layout _ self layoutPolicy.	layout ifNotNil:[layout layout: self in: layoutBounds].	self adjustLayoutBounds.	fullBounds _ self privateFullBounds.	box _ self outerBounds.	box = priorBounds		ifFalse:[self invalidRect: (priorBounds quickMerge: box)].! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 23:10'!layoutBounds	"Return the bounds for laying out children of the receiver"	| inset box |	inset _ self layoutInset.	box _ self innerBounds.	inset isZero ifTrue:[^box].	^box insetBy: inset.! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 22:32'!layoutChanged	fullBounds ifNil:[^self]. "layout will be recomputed so don't bother"	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	"note: does not send #ownerChanged here - we'll do this when computing the new layout"! !!Morph methodsFor: 'layout' stamp: 'ar 11/13/2000 01:51'!layoutInBounds: cellBounds	"Layout specific. Apply the given bounds to the receiver after being layed out in its owner."	| box aSymbol delta |	fullBounds ifNil:["We are getting new bounds here but we haven't computed the receiver's layout yet. Although the receiver has reported its minimal size before the actual size it has may differ from what would be after the layout. Normally, this isn't a real problem, but if we have #shrinkWrap constraints then the receiver's bounds may be larger than the cellBounds. THAT is a problem because the centering may not work correctly if the receiver shrinks after the owner layout has been computed. To avoid this problem, we compute the receiver's layout now. Note that the layout computation is based on the new cell bounds rather than the receiver's current bounds."		cellBounds origin = self bounds origin ifFalse:[			box _ self outerBounds.			delta _ cellBounds origin - self bounds origin.			self invalidRect: (box merge: (box translateBy: delta)).			self privateFullMoveBy: delta]. "sigh..."		box _ cellBounds origin extent: "adjust for #rigid receiver"			(self hResizing == #rigid ifTrue:[self bounds extent x] ifFalse:[cellBounds extent x]) @			(self vResizing == #rigid ifTrue:[self bounds extent y] ifFalse:[cellBounds extent y]).		"Compute inset of layout bounds"		box _ box origin - (self bounds origin - self layoutBounds origin) corner:					box corner - (self bounds corner - self layoutBounds corner).		"And do the layout within the new bounds"		self layoutBounds: box.		self doLayoutIn: box].	cellBounds = bounds ifTrue:[^self]. "already up to date"	cellBounds extent = bounds extent "nice fit"		ifTrue:[^self position: cellBounds origin].	box _ bounds.	"match #spaceFill constraints"	self hResizing == #spaceFill 		ifTrue:[box _ box origin extent: cellBounds width @ box height].	self vResizing == #spaceFill		ifTrue:[box _ box origin extent: box width @ cellBounds height].	"align accordingly"	aSymbol _ (owner ifNil:[self]) cellPositioning.	box _ box align: (box perform: aSymbol) with: (cellBounds perform: aSymbol).	"and install new bounds"	self bounds: box.! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 23:12'!privateFullBounds	"Private. Compute the actual full bounds of the receiver"	| box |	submorphs size = 0 ifTrue: [^self outerBounds].	box _ self outerBounds copy.	self clipSubmorphs		ifTrue:[box _ box quickMerge: (self submorphBounds intersect: self clippingBounds)]		ifFalse:[box _ box quickMerge: self submorphBounds].	^ box origin asIntegerPoint corner: box corner asIntegerPoint! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/12/2000 23:09'!layoutInset	"Return the extra inset for layouts"	extension == nil ifTrue:[^0].	^self valueOfProperty: #layoutInset ifAbsent:[0]! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'ar 11/12/2000 18:42'!invalidRect: damageRect from: aMorph	"Try setting 'quickRedraw' to true. This invalidates the entire morph, whose bounds typically subsume all it's submorphs. (However, this code checks that assumption and passes through any damage reports for out-of-bounds submorphs. Note that atoms with super-high velocities do occaisionally shoot through the walls!!) An additional optimization is to only submit only damage report per display cycle by using the damageReported flag, which is reset to false when the morph is drawn."	| quickRedraw |	quickRedraw _ true.  "false gives the original invalidRect: behavior"	(quickRedraw and:	 [(bounds origin <= damageRect topLeft) and:	 [damageRect bottomRight <= bounds corner]]) ifTrue: [		"can use quick redraw if damage is within my bounds"		damageReported ifFalse: [super invalidRect: bounds from: self].  "just report once"		damageReported _ true.	] ifFalse: [super invalidRect: damageRect from: aMorph].  "ordinary damage report"! !!CachingMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/12/2000 18:43'!invalidRect: damageRect from: aMorph	"Record the given rectangle in the damage list."	damageRecorder recordInvalidRect: (damageRect translateBy: self fullBounds origin negated).	super invalidRect: damageRect from: aMorph! !!HandMorph methodsFor: 'geometry' stamp: 'ar 11/12/2000 18:43'!invalidRect: damageRect from: aMorph	"Note that a change has occurred and record the given damage rectangle relative to the origin this hand's cache."	hasChanged _ true.	fullBounds == nil		ifTrue: [damageRecorder recordInvalidRect: damageRect]		ifFalse: [damageRecorder recordInvalidRect: (damageRect translateBy: fullBounds origin negated)].! !!HandMorph methodsFor: 'drawing' stamp: 'ar 11/12/2000 18:46'!restoreSavedPatchOn: aCanvas	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged _ false.	savedPatch ifNotNil: [		aCanvas drawImage: savedPatch at: savedPatch offset.		self hasUserInformation ifTrue: [^self].	"cannot use hw cursor if so"		submorphs size > 0 ifTrue: [^self].		temporaryCursor ifNotNil: [^self].		"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."		super invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset) from: self.		Sensor currentCursor == Cursor normal ifFalse: [Cursor normal show].  "show hardware cursor"		savedPatch _ nil.	].! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 11/12/2000 18:51'!changed	^self invalidRect: (self fullBounds insetBy: -1)! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 11/12/2000 18:44'!invalidRect: rect from: aMorph	aMorph == self		ifTrue:[super invalidRect: rect from: self]		ifFalse:[super invalidRect: (self transform localBoundsToGlobal: rect) from: aMorph].! !!FlashSpriteMorph methodsFor: 'change reporting' stamp: 'ar 11/12/2000 18:43'!invalidRect: rect from: aMorph	damageRecorder isNil ifTrue:[		super invalidRect: rect from: aMorph	] ifFalse:[		damageRecorder recordInvalidRect: rect.	].! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/12/2000 18:43'!invalidRect: rect from: aMorph	damageRecorder isNil ifTrue:[		super invalidRect: rect from: aMorph	] ifFalse:[		damageRecorder recordInvalidRect: rect.	].! !!PasteUpMorph methodsFor: 'misc' stamp: 'ar 11/12/2000 18:53'!invalidRect: damageRect from: aMorph        "Clip damage reports to my bounds, since drawing is clipped to my bounds."        self == self outermostWorldMorph                 ifTrue: [worldState recordDamagedRect: damageRect]                ifFalse: [super invalidRect: damageRect from: aMorph]! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/12/2000 22:37'!sortSubmorphsBy: sortOrderSymbol	"Sort the receiver's submorphs by the criterion indicated in the provided symbol"	self invalidRect: self fullBounds.	submorphs _ submorphs sortBy:[:a :b | (a perform: sortOrderSymbol) <= (b perform: sortOrderSymbol)].	self layoutChanged.! !!MVCWiWPasteUpMorph methodsFor: 'drawing' stamp: 'ar 11/12/2000 18:43'!invalidRect: damageRect from: aMorph	worldState recordDamagedRect: damageRect! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!reverse	self invalidRect: self fullBounds.	submorphs _ submorphs reversed.	self layoutChanged.! !!PlayingCardDeck methodsFor: 'shuffling/dealing' stamp: 'ar 11/12/2000 22:40'!shuffle	self invalidRect: self fullBounds.	submorphs _ submorphs shuffledBy: (Random new seed: seed).	self layoutChanged.! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 11/12/2000 19:10'!intersect: aRectangle 	"Answer a Rectangle that is the area in which the receiver overlaps with 	aRectangle. Optimized for speed; old code read:		^Rectangle 			origin: (origin max: aRectangle origin)			corner: (corner min: aRectangle corner)	"	| aPoint left right top bottom |	aPoint _ aRectangle origin.	aPoint x > origin x ifTrue:[left _ aPoint x] ifFalse:[left _ origin x].	aPoint y > origin y ifTrue:[top _ aPoint y] ifFalse:[top _ origin y].	aPoint _ aRectangle corner.	aPoint x < corner x ifTrue:[right _ aPoint x] ifFalse:[right _ corner x].	aPoint y < corner y ifTrue:[bottom _ aPoint y] ifFalse:[bottom _ corner y].	^Rectangle		origin: (left@top)		corner: (right@bottom)! !!SyntaxMorph methodsFor: 'insertion caret' stamp: 'ar 11/13/2000 01:40'!addCaretFront: aMorph	"Add a caret morph without triggering re-layout.	This is just a copy of addMorphFront: without layoutChanged"	| newSubmorphs |	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph privateOwner: self.	newSubmorphs _ submorphs species new: submorphs size + 1.	newSubmorphs at: 1 put: aMorph.	newSubmorphs		replaceFrom: 2		to: newSubmorphs size		with: submorphs		startingAt: 1.	submorphs _ newSubmorphs.	self invalidRect: aMorph fullBounds from: aMorph.! !!SyntaxMorph methodsFor: 'insertion caret' stamp: 'ar 11/13/2000 01:41'!removeCaret: aMorph	"Remove the caret morph without triggering layout.	This is a copy of privateRemoveMorph: without layoutChanged."	submorphs _ submorphs copyWithout: aMorph.	self invalidRect: aMorph fullBounds from: aMorph.! !!TransformMorph methodsFor: 'change reporting' stamp: 'ar 11/12/2000 18:49'!invalidRect: damageRect from: aMorph	"Translate damage reports from submorphs by the scrollOffset."	aMorph == self		ifTrue:[super invalidRect: damageRect from: self]		ifFalse:[super invalidRect: (((transform localBoundsToGlobal: damageRect) intersect: bounds) expandBy: 1) from: self].! !!WorldState methodsFor: 'update cycle' stamp: 'ar 11/12/2000 23:21'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"	"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	"*make this true to flash damaged areas for testing*"	false ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !TransformMorph removeSelector: #changed!TransformMorph removeSelector: #invalidRect:!MVCWiWPasteUpMorph removeSelector: #invalidRect:!PasteUpMorph removeSelector: #invalidRect:!FlashPlayerMorph removeSelector: #invalidRect:!FlashSpriteMorph removeSelector: #invalidRect:!MatrixTransformMorph removeSelector: #invalidRect:!HandMorph removeSelector: #invalidRect:!CachingMorph removeSelector: #invalidRect:!BouncingAtomsMorph removeSelector: #invalidRect:!Morph removeSelector: #priorFullBounds!Morph removeSelector: #priorFullBounds:!