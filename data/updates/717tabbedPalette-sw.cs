'From Squeak 2.3 of January 14, 1999 on 8 March 1999 at 10:42:37 pm'!"Change Set:		tabbedPalette-swDate:			8 March 1999Author:			Scott WallaceA substantial rewrite of the tabbedPalette functioning, supporting:*  Any morph -- no longer just bookMorphs -- can be associated with a tab.*  Any tab can be pictorial.*  More straightforward scripting of tabs -- bring up a tab's halo, open up its viewer, and write a mouseUp script for it.*  Special handling when a PaintBoxMorph is dropped into a tab sorter -- a paint-palette icon is deposited within.  You can subsequently script that tab so that it initiates painting in a given playfield."!PasteUpMorph subclass: #IndexTabs	instanceVariableNames: 'highlightColor regularColor basicHeight basicWidth verticalPadding '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Palettes'!BorderedMorph subclass: #ReferenceMorph	instanceVariableNames: 'referent isHighlighted '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Palettes'!BorderedMorph subclass: #SorterTokenMorph	instanceVariableNames: 'morphRepresented '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Palettes'!!Morph methodsFor: 'accessing' stamp: 'sw 11/30/1998 12:44'!highlight	"The receiver is being asked to appear in a highlighted state.  Mostly used for textual morphs"	self color: self highlightColor! !!Morph methodsFor: 'accessing' stamp: 'sw 11/30/1998 12:44'!unHighlight	self color: self regularColor! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 12/22/1998 17:00'!submorphOfClass: aClass	^ self submorphs detect: [:p | p isKindOf: aClass] ifNone: [nil]! !!IndexTabs methodsFor: 'initialization' stamp: 'sw 12/3/1998 21:07'!initialize	super initialize.	padding _ 10.	verticalPadding _ 4.	basicHeight _ 14.	basicWidth _ 200.	color _ Color r: 0.0 g: 0.6 b: 0.6.	fillColor2 _ color.	borderWidth _ 0! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 12/2/1998 17:53'!addTabForBook: aBook	|  aTab |	aTab _ ReferenceMorph forMorph: aBook.	self addMorphBack: aTab.	aTab highlightColor: self highlightColor; regularColor: self regularColor.	aTab unHighlight.	self laySubpartsOutInOneRow; layoutChanged.	^ aTab! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 12/3/1998 15:16'!ownerChanged	self laySubpartsOutInOneRow! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 12/3/1998 15:28'!tabMorphs	"Presently all the submorphs are tabMorphs, but this still supports an earlier design where spacers are interleaved."	^ submorphs select: [:m | (m isKindOf: TabMorph) or: [m isKindOf: ReferenceMorph]]! !!IndexTabs methodsFor: 'layout' stamp: 'sw 11/30/1998 15:38'!basicWidth	basicWidth ifNil: [basicWidth _ owner ifNotNil: [owner width] ifNil: [100]].	^ basicWidth! !!IndexTabs methodsFor: 'layout' stamp: 'sw 12/7/1998 17:31'!laySubpartsOutInOneRow	| aPosition neededHeight widthToUse mid |	aPosition _ self topLeft.	neededHeight _ self basicHeight.	submorphs do:		[:aMorph |			aMorph position: (aPosition + (padding @ 0)).			aPosition _ aMorph topRight.			neededHeight _ neededHeight max: aMorph height].	neededHeight _ neededHeight + (verticalPadding * 2).	mid _ self top + (neededHeight // 2).	submorphs do:		[:aMorph |			aMorph top: (mid - (aMorph height // 2))].	widthToUse _ self widthImposedByOwner max: self requiredWidth.	self extent: (((aPosition x + padding - self left) max: widthToUse) @ neededHeight)! !!IndexTabs methodsFor: 'layout' stamp: 'sw 12/7/1998 17:29'!requiredWidth	submorphs size = 0		ifTrue:			[^ self basicWidth].	^ (submorphs detectSum: [:m | m width]) + (submorphs size * padding)! !!IndexTabs methodsFor: 'layout' stamp: 'sw 12/7/1998 19:50'!widthImposedByOwner	((owner == nil or: [owner isWorldOrHandMorph]) or: [owner submorphs size < 2])		ifTrue:			[^ self basicWidth].	^ owner submorphs second width! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 11/30/1998 12:43'!highlightTab: aTab	self tabMorphs do:		[:m | m == aTab			ifTrue: [m highlight]			ifFalse: [m unHighlight]]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 11/30/1998 12:44'!highlightTabFor: aBook	| theOne |	self tabMorphs do: [:m |		(m morphToInstall == aBook)				ifTrue: [m highlight.  theOne _ m]				ifFalse: [m unHighlight]].	^ theOne! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 12/2/1998 12:30'!highlightedTab	^ self tabMorphs detect: [:m | m isHighlighted] ifNone: [nil]! !!MenuItemMorph methodsFor: 'events' stamp: 'sw 3/2/1999 13:39'!mouseDown: evt	"Handle a mouse down event. Menu items get activated when the mouse is over them."	self isInMenu ifFalse: [^ super mouseDown: evt].	evt shiftPressed ifTrue: [^ super mouseDown: evt].  "enable label editing" 	(owner hasProperty: #paletteMenu)		ifFalse:			[self bringMenuChainToFront].	self selectFromHand: evt hand! !!Player methodsFor: 'costume' stamp: 'sw 3/2/1999 23:00'!existingCostumeOfClass: aClass	| actualCostume |	((actualCostume _ costume renderedMorph) isKindOf: aClass) ifTrue: [^ actualCostume].	costumes ifNotNil: [costumes do:		[:aCostume | ((actualCostume _ aCostume renderedMorph) isKindOf: aClass) ifTrue:			[^ actualCostume]]].	^ nil! !!Player methodsFor: 'slots-kernel' stamp: 'sw 3/2/1999 17:46'!categories	| aList aRef |	(self hasCostumeOfClass: WorldMorph)		ifTrue:	[^ self categoriesForWorld].	aList _ #('basic' ) asOrderedCollection.	self slotNames size > 0 ifTrue:		[aList add: 'instance variables'].	self class scripts size > 0 ifTrue:		[aList add: 'scripts'].	(self hasCostumeOfClass: JoystickMorph)		ifTrue:	[aList add: 'joystick'].	(self hasCostumeOfClass: BookMorph)		ifTrue:	[aList add: 'book navigation'].	(self hasCostumeOfClass: PaintBoxMorph)		ifTrue:	[aList add: 'paintbox'].	(self hasCostumeOfClass: PasteUpMorph)		ifTrue:	[aList addAll: #('pen trails' 'card/stack' 'playfield')].	aList addAll: #('tests' 'color & border' 'geometry' 'motion' 'pen use' 'miscellaneous' ).	((aRef _ self existingCostumeOfClass: ReferenceMorph) notNil and:		[aRef referent isKindOf: PaintBoxMorph])			ifTrue:	[aList add: 'paintbox'].	Preferences showPlayerSource ifTrue:		[aList addAll: Player organization categories].	aList removeAllFoundIn: #('card/stack commands' 'object fileIn').	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 3/8/1999 12:32'!tilePhrasesSpecsForCategory: aCategory	"Return an array of slot and script names and info for use in a viewer on the receiver.  These can be of two flavors - script and slot.		(slot		heading		number				readWrite	getHeading		setHeading:)		(script		command 	wearCostumeOf: 	player)"	| aList nameString isWorld categorySymbol categoryString |	categoryString _ aCategory asString.	isWorld _ self hasCostumeOfClass: WorldMorph.	(categoryString = 'instance variables') ifTrue:		[^ self slotNames collect: [:aName |		nameString _ aName asString capitalized.		Array			with:	#slot			with: 	aName 								"name"			with: 	(self typeForSlot: aName asSymbol)	"type"			with:	#readWrite							"r/w"			with:	('get', nameString) asSymbol		"get selector"			with:	('set', nameString, ':') asSymbol]].	"set selector"	(categoryString = 'scripts') ifTrue:		[^ self tileScriptCommands].	(categoryString = 'basic') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot x) (slot y) (slot heading) (slot colorUnder) (script forward:) (script turn:) (script beep:))]			ifTrue:				[#((script beep:))]].	(categoryString = 'tests') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot isOverColor) (slot isUnderMouse) (slot colorSees))]			ifTrue:				[#()]].	(categoryString = 'color & border') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot color) (slot colorUnder) (slot borderColor) (slot borderWidth))]			ifTrue:				[#((slot color))]].	(categoryString = 'geometry') ifTrue:		[aList _ #((slot left) (slot right) (slot top) (slot bottom) (slot width) (slot height) (slot x) (slot y) (slot heading))].	(categoryString = 'miscellaneous') ifTrue:		[aList _ isWorld			ifFalse:				[#((script show) (script hide) (script wearCostumeOf:) (script startScript:) (script stopScript:) (script pauseScript:))]			ifTrue:				[#((script startScript:) (script stopScript:) (script pauseScript:))]].	(categoryString = 'motion') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (script forward:) (script moveToward:) (script turn:) (script bounce:) (script wrap) (script followPath) (script goToRightOf:))].	(categoryString = 'pen trails') ifTrue:		[aList _ #((script liftAllPens) (script lowerAllPens) (script clearTurtleTrails))].	(categoryString = 'pen use') ifTrue:		[aList _ #((slot penColor) (slot penSize) (slot penDown))].	(categoryString = 'card/stack') ifTrue:		[aList _ #((script goToNextCard) (script goToPreviousCard) (script deleteCard) (script newCard))].	(categoryString = 'joystick') ifTrue:		[aList _ #((slot amount) (slot angle) (slot leftRight) (slot upDown))].	(categoryString = 'playfield') ifTrue:		[aList _ #((script initiatePainting) (slot cursor) (slot valueAtCursor) (slot mouseX) (slot mouseY)(script roundUpStrays) (script unhideHiddenObjects))].	(categoryString = 'paintbox') ifTrue:		[aList _ #((script makeNewDrawingIn:))].	(categoryString = 'book navigation') ifTrue:		[aList _ #((script nextPage) (script previousPage) (script firstPage) (script lastPage) (script goto:))].	aList ifNil:		[^ (Player organization categories includes: (categorySymbol _ aCategory asSymbol))			ifTrue:				[self tilePhraseSpecsForPlayerCategory: categorySymbol]			ifFalse:				[self error: 'faulty category: ', categorySymbol.				Array new]].	^ aList collect: [:aPair | self phraseSpecFor: aPair]! !!ReferenceMorph methodsFor: 'misc' stamp: 'sw 3/7/1999 00:25'!initialize	super initialize.	isHighlighted _ false.	borderWidth _ 0.	self color: Color transparent.	referent _ nil! !!ReferenceMorph methodsFor: 'misc' stamp: 'sw 12/1/1998 11:59'!sorterToken	^ SorterTokenMorph new forMorph: self! !!ReferenceMorph methodsFor: 'misc' stamp: 'sw 3/3/1999 13:03'!unHighlight	| str |	isHighlighted _ false.	self borderWidth: 0.	submorphs size > 0		ifTrue:			[((str _ submorphs first) isKindOf: StringMorph orOf: RectangleMorph)				ifTrue:					[str color: self regularColor]]! !!ReferenceMorph methodsFor: 'events' stamp: 'sw 3/7/1999 00:29'!mouseDown: evt	self setProperty: #oldColor toValue: color! !!ReferenceMorph methodsFor: 'events' stamp: 'sw 3/7/1999 00:30'!mouseMove: evt	| aColor |	(aColor _ self valueOfProperty: #oldColor) ifNotNil:		[(self containsPoint: evt cursorPoint)			ifTrue:				[self color: (aColor mixed: 1/2 with: Color white)]			ifFalse: [self color: aColor]]! !!ReferenceMorph methodsFor: 'events' stamp: 'sw 3/7/1999 00:29'!mouseUp: evt	| aColor |	(aColor _ self valueOfProperty: #oldColor) ifNotNil: [self color: aColor].	(self containsPoint: evt cursorPoint)		ifTrue: [self doButtonAction].	super mouseUp: evt "send to evt handler if any"! !!SorterTokenMorph methodsFor: 'all' stamp: 'sw 12/1/1998 12:38'!fitContents	submorphs size == 1 ifTrue: [self bounds: (submorphs first bounds insetBy: (-1 @ -1))]! !!SorterTokenMorph methodsFor: 'all' stamp: 'sw 12/1/1998 12:38'!forMorph: aMorph	| it |	morphRepresented _ aMorph.	aMorph submorphs size > 0 ifTrue:		[self addMorphBack: (it _ aMorph submorphs first fullCopy).		it position: self position + (1@1).		it lock].	self fitContents! !!SorterTokenMorph methodsFor: 'all' stamp: 'sw 12/1/1998 12:31'!initialize	super initialize.	color _ Color transparent.	borderWidth _ 1.	borderColor _ Color blue! !!SorterTokenMorph methodsFor: 'all' stamp: 'sw 12/1/1998 12:27'!morphRepresented	^ morphRepresented! !!TabMorph methodsFor: 'all' stamp: 'sw 3/2/1999 15:55'!convertToReferenceMorph	| aMorph |	aMorph _ ReferenceMorph new referent: morphToInstall.	aMorph position: self position.	self become: aMorph.! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 3/2/1999 17:50'!acceptSort	"Reconstitute the palette based on what is found in the sorter"	| rejects toAdd oldOwner tabsToUse appearanceMorph oldTop aMenu |	tabsToUse _ OrderedCollection new.	rejects _ OrderedCollection new.	pageHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: BookMorph) ifTrue:			[toAdd _ SorterTokenMorph forMorph: m].		(m isKindOf: TabTokenMorph) ifTrue:			[toAdd _ m tabRepresented contents: m contents].		(m isKindOf: SorterTokenMorph) ifTrue:			[toAdd _ m morphRepresented.			(toAdd referent isKindOf: MenuMorph) ifTrue:				[(aMenu _ toAdd referent) setProperty: #paletteMenu toValue: true.				((aMenu submorphs size > 1) and: [(aMenu submorphs second isKindOf: MenuItemMorph) and: [aMenu submorphs second contents = 'dismiss this menu']])					ifTrue:						[aMenu submorphs first delete.   "delete title"						aMenu submorphs first delete.   "delete stay-up item"						(aMenu submorphs first isKindOf: MenuLineMorph) ifTrue:							[aMenu submorphs first delete]]].			toAdd removeAllMorphs.			toAdd addMorph: (appearanceMorph _ m submorphs first).			appearanceMorph position: toAdd position.			appearanceMorph lock.			toAdd fitContents].		toAdd ifNil:				[rejects add: m]			ifNotNil:				[tabsToUse add: toAdd]].	tabsToUse size == 0 ifTrue: [^ self inform: 'Sorry, must have at least one tab'].	book newTabs: tabsToUse.	book tabsMorph color: pageHolder color.	oldTop _ self topRendererOrSelf.  "in case some maniac has flexed the sorter"	oldOwner _ oldTop owner.	oldTop delete.	oldOwner addMorphFront: book! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 3/2/1999 16:47'!sortTabsFor: aTabbedPalette	| actualTabs |	actualTabs _ aTabbedPalette tabMorphs.	self book: aTabbedPalette morphsToSort:		(actualTabs collect: [:aTab | aTab sorterToken]).	pageHolder color: aTabbedPalette tabsMorph color. 	self position: aTabbedPalette position.	pageHolder extent: self extent.	self setNameTo: 'Tab Sorter for ', aTabbedPalette externalName.	aTabbedPalette owner addMorphFront: self! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 12/7/1998 19:48'!substituteForMorph: aMorph beingDroppedOn: aPage	| aTab token |	(aMorph isKindOf: PaintBoxMorph) ifTrue:		[aTab _ ReferenceMorph new morphToInstall: aMorph.		aTab removeAllMorphs.		aTab addMorph: (SketchMorph new form: (ScriptingSystem formAtKey: 'PaintTab')).		aTab fitContents.		token _ SorterTokenMorph new forMorph: aTab.		^ token].	(aMorph isKindOf: SorterTokenMorph) ifTrue: [^ nil].  "Let it stand"	^ SorterTokenMorph new forMorph: (ReferenceMorph new morphToInstall: aMorph)! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 12/2/1998 17:18'!initialize	super initialize.	pageSize _ self defaultPageSize.	self removeEverything.	color _ Color transparent.	borderWidth _ 0.	tabsMorph _ IndexTabs new.	self addMorph: tabsMorph! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 12/7/1998 17:26'!newTabs: tabsList	"Reconstitute the palette based on info in the tabs list"	| itsBook color1 color2 color3 |	pages _ pages species new.	tabsMorph ifNotNil:		[color1 _ tabsMorph  highlightColor.		color2 _ tabsMorph regularColor.		color3 _ tabsMorph color.		tabsMorph delete].	tabsMorph _ IndexTabs new.	self addMorphFront: tabsMorph.	color1 ifNotNil:		[tabsMorph highlightColor: color1 regularColor: color2; color: color3].	currentPage ifNotNil:		[currentPage delete.		currentPage _ nil].	tabsList do:		[:aTab |			tabsMorph addTab: aTab.			aTab unHighlight.			(itsBook _ aTab morphToInstall) ifNotNil:					[pages add: itsBook.					currentPage ifNil: [currentPage _ itsBook]]].	tabsMorph position: self position + self borderWidth! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 3/2/1999 15:55'!undergoMarch99Conversion	"A one-time conversion to be applied to old instances of TabbedPalette that still have TabMorphs in them instead of the newer ReferenceMorphs.  Return an integer telling how many tabs were changed"	"TabbedPalette allInstancesDo: [:m | m undergoMarch99Conversion]"	| count |	tabsMorph ifNil: [^ 0].	count _ 0.	tabsMorph submorphs do:		[:m | (m isKindOf: TabMorph)			ifTrue:				[m convertToReferenceMorph.				count _ count + 1]].	^ count! !!TabbedPalette methodsFor: 'parts & controls tabs' stamp: 'sw 3/8/1999 15:10'!addControlsTab	| controlPage |	controlPage _ AlignmentMorph newColumn beSticky color: Color white.	controlPage addMorphBack:		(Preferences buttonRepresenting: #balloonHelpEnabled wording: 'Balloon Help' color: nil).	controlPage addMorphBack:		(Preferences buttonRepresenting: #fenceEnabled wording: 'Fence Enabled' color: nil).	controlPage addMorphBack:		(Preferences buttonRepresenting: #mouseOverHalosEnabled wording: 'Halos' color: nil).	controlPage addMorphBack:		(Preferences buttonRepresenting: #disableSounds wording: 'Disable Sounds' color: nil).	controlPage setNameTo: 'controls'.	self addTabForBook: controlPage  withBalloonText:'controls to turn sound,balloon help, etc., on and off'! !!TabbedPalette methodsFor: 'parts & controls tabs' stamp: 'sw 3/8/1999 15:19'!addPartsTab	| partsBook aPage |	partsBook _ BookMorph new pageSize: pageSize; setNameTo: 'supplies'.	partsBook removeEverything.	aPage _ self presenter newPageForStandardPartsBin.	aPage extent: pageSize.	#(PaintInvokingMorph RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph JoystickMorph) do:		[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].	aPage replaceTallSubmorphsByThumbnails.	aPage fixLayout.	partsBook insertPage: aPage pageSize: pageSize.	self addTabForBook: partsBook withBalloonText: 'parts bin'! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 3/7/1999 00:44'!addScrapsTab	| scrapsBook |	self hasScrapsTab ifTrue: [^ self beep].	scrapsBook _ BookMorph new pageSize: pageSize; setNameTo: 'scraps'.	scrapsBook removeEverything; showPageControls; insertPage.	scrapsBook currentPage addMorph: (SketchMorph new form: ScriptingSystem squeakyMouseForm).	scrapsBook setProperty: #scraps toValue: true.	self addTabForBook: scrapsBook  withBalloonText: 'a storage place for anything; also, objects dragged into the trash can will be found here.'.	self presenter ownStandardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 3/8/1999 14:56'!showScrapsTab	self selectTabOfBook: self scrapsBook! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 3/3/1999 13:17'!viewMorph: aMorph	"The receiver is expected to have a viewer tab; select it, and target it to aMorph"	| aPlayer aViewer oldOwner |	((currentPage isKindOf: Viewer) and: [currentPage scriptedPlayer == aMorph player])		ifTrue:			[^ self].	oldOwner _ owner.	self delete.	self visible: false.	aPlayer _ aMorph assuredPlayer.	self showNoPalette.	aViewer _  StandardViewer new initializeFor: aPlayer barHeight: 0.	aViewer enforceTileColorPolicy.	self showNoPalette.	currentPage ifNotNil: [currentPage delete].	self addMorphBack: (currentPage _ aViewer beSticky).	self snapToEdgeIfAppropriate.	tabsMorph highlightTab: nil.	self visible: true.	oldOwner addMorphFront: self.	self world startSteppingSubmorphsOf: aViewer.	self layoutChanged! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 12/27/1998 23:33'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	aCustomMenu add: 'add palette menu' action: #addMenuTab.	aCustomMenu add: 'become the Standard palette' action: #becomeStandardPalette! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 12/22/1998 16:16'!addMenuTab	| aMenu aTab aGraphic sk |	aMenu _ MenuMorph new defaultTarget: self.	aMenu stayUp: true.	aMenu add:  'clear' action: #showNoPalette.	aMenu add:  'sort tabs' action: #sortTabs:.	aMenu add:  'choose new colors for tabs' action: #recolorTabs.	aMenu setProperty: #paletteMenu toValue: true.	aMenu add:  'make me the Standard palette' action: #becomeStandardPalette.	aMenu add:  'add "scraps" tab' action: #addScrapsTab.	aTab _ self addTabForBook: aMenu  withBalloonText: 'a menu of palette-related controls'.	aTab highlightColor: tabsMorph highlightColor; regularColor: tabsMorph regularColor.	tabsMorph laySubpartsOutInOneRow; layoutChanged.	aGraphic _ ScriptingSystem formAtKey: 'Menu'.	aGraphic ifNotNil:		[aTab removeAllMorphs.		aTab addMorph: (sk _ SketchMorph new form: aGraphic).		sk position: aTab position.		sk lock.		aTab fitContents].	self layoutChanged! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 12/20/1998 14:37'!showPaletteMenu	| aMenu evt |	evt _ self primaryHand lastEvent.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add:  'clear' action: #showNoPalette.	aMenu addLine.	aMenu add:  'sort tabs' action: #sortTabs:.	aMenu add:  'choose new colors for tabs' action: #recolorTabs.	(self presenter standardPaletteIsAlready: self) ifFalse:		[aMenu add:  'make me the Standard palette' action: #becomeStandardPalette].	self hasScrapsTab ifFalse:	[aMenu add:  'add "scraps" tab' action: #addScrapsTab].	aMenu addTitle: 'Palette'.	aMenu popUpAt: self cursorPoint event: evt! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 12/27/1998 23:34'!showNoPalette	self showNoPaletteAndHighlightTab: nil! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 3/3/1999 13:06'!showNoPaletteAndHighlightTab: aTab	| oldTab morphToInstall aSketchEditor |	oldTab _ tabsMorph highlightedTab.	(oldTab notNil and: [(morphToInstall _ oldTab morphToInstall) isKindOf: PaintBoxMorph])		ifTrue:			[(aSketchEditor _ self world submorphOfClass: SketchEditorMorph) ifNotNil:				[aSketchEditor cancelOutOfPainting].			morphToInstall delete].	currentPage ifNotNil: [currentPage delete].	currentPage _ nil.	submorphs size > 1 ifTrue: "spurious submorphs, yecch"		[(submorphs copyFrom: 2 to: submorphs size) do: [:m | m delete]].	tabsMorph highlightTab: aTab! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 12/27/1998 23:28'!selectTab: aTab	| currentPalette morphToInstall oldTab aSketchEditor |	currentPage ifNotNil:		[self currentPalette currentPlayerDo:			[:aPlayer | aPlayer runAllClosingScripts]].	oldTab _ tabsMorph highlightedTab.	(oldTab notNil and: [(morphToInstall _ oldTab morphToInstall) isKindOf: PaintBoxMorph])		ifTrue:			[(aSketchEditor _ self world submorphOfClass: SketchEditorMorph) ifNotNil:				[aSketchEditor cancelOutOfPainting].			morphToInstall delete].	tabsMorph selectTab: aTab.	morphToInstall _ aTab morphToInstall.	(morphToInstall isKindOf: PaintBoxMorph) "special case, maybe generalize this need?"		ifFalse:			[self goToPageMorph: morphToInstall]		ifTrue:			[self showNoPaletteAndHighlightTab: aTab.			self world addMorphFront: morphToInstall.			morphToInstall position: ((self left max: 90) "room for the pop-out-to-left panel"				@ (tabsMorph bottom))].		(currentPalette _ self currentPalette) ifNotNil:		[currentPalette layoutChanged.		currentPalette currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts]].	self snapToEdgeIfAppropriate! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 12/22/1998 16:37'!transitionSpecFor: aMorph	^ aMorph valueOfProperty: #transitionSpec  " check for special propety"		ifAbsent: [Array with: 'silence'  " ... otherwise this is the default"						with: #none						with: #none]! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 3/2/1999 13:04'!wantsDroppedMorph: aMorph event: evt	(tabsMorph bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifTrue:		[^ false  "unless it's a book, perhaps, someday"].	^ currentPage == nil or: [currentPage wantsDroppedMorph: aMorph event: evt]! !!TabbedPalette class methodsFor: 'all' stamp: 'sw 3/2/1999 15:55'!march99Conversion	"TabbedPalette march99Conversion"	| palettes grandCount itsCount |	palettes _ 0.	grandCount _ 0.	self allInstancesDo:		[:m |			itsCount _ m undergoMarch99Conversion.			itsCount > 0 ifTrue:				[palettes _ palettes + 1.				grandCount _ grandCount + itsCount]].	Transcript cr; show: (palettes printString, ' palettes amended, with a total of', grandCount printString, ' tabs converted to ReferenceMorphs.')! !TabbedPalette removeSelector: #addScriptableTab!"Postscript:"Preferences enable: #fenceEnabled.Preferences initializeHelpMessages.ScriptingSystem saveForm: (Form extent: 14@14 depth: 16	fromArray: #( 0 1 65537 65537 65537 65536 0 0 65537 0 0 0 65537 0 1 65536 0 0 0 1 65536 65537 0 0 0 0 0 65537 65536 0 0 65537 65536 0 1 65536 0 1 65537 65537 0 1 65536 0 65537 65537 65537 65536 1 65536 0 65537 65537 65537 65536 1 65536 0 65537 65537 65537 65536 1 65536 0 1 65537 65537 0 1 65537 0 0 65537 65536 0 65537 1 65536 0 0 0 1 65536 0 65537 0 0 0 65537 0 0 1 65537 65537 65537 65536 0) offset: 0@0)		atKey: #ButtonOn.ScriptingSystem saveForm: (Form extent: 14@14 depth: 16	fromArray: #( 0 1 65537 65537 65537 65536 0 0 65537 0 0 0 65537 0 1 65536 0 0 0 1 65536 65537 0 0 0 0 0 65537 65536 0 0 0 0 0 1 65536 0 0 0 0 0 1 65536 0 0 0 0 0 1 65536 0 0 0 0 0 1 65536 0 0 0 0 0 1 65536 0 0 0 0 0 1 65537 0 0 0 0 0 65537 1 65536 0 0 0 1 65536 0 65537 0 0 0 65537 0 0 1 65537 65537 65537 65536 0) offset: 0@0)		atKey: #ButtonOff.ScriptingSystem resetStandardPartsBin.Utilities reinstateDefaultFlaps.!