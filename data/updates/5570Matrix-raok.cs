'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5566] on 24 November 2003 at 7:02:51 pm'!"Change Set:		Matrix-raokDate:			18 October 2002Author:			Richard A. O'KeefeThis started with me noticing that many of the Collection methods that makesense for 2D arrays did not work for Squeak's Array2D class.  Having fixedthat, I went on to provide a lot of other good stuff, but realised too late thatArray2D has its subscripts in the wrong order so I don't want to use it anyway.Therefore I created a new Matrix class which does the same job as Array2D butis free of Array2D's more glaring defects.  In particular, elementwise arithmetic,matrix multiplication, transposition, swapping rows and swapping columns, printing,and element searches are provided.This change set also adds unary math functions to Collection so they can be used with Matrix and other collections.  aSet cos makes sense.Some new methods for submatrices were added in November, in response to somequestions from Bert Freudenberg.  Unfortunately, they were added to the wrongversion, hence the need for a correction."!Collection subclass: #Matrix	instanceVariableNames: 'nrows ncols contents '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!Matrix commentStamp: '<historical>' prior: 0!I represent a two-dimensional array, rather like Array2D.There are three main differences between me and Array2D:(1) Array2D inherits from ArrayedCollection, but isn't one.  A lot of things that should work    do not work in consequence of this.(2) Array2D uses "at: column at: row" index order, which means that nothing you write using    it is likely to work either.  I use the almost universal "at: row at: column" order, so it is    much easier to adapt code from other languages without going doolally.(3) Array2D lets you specify the class of the underlying collection, I don't.Structure:  nrows : a non-negative integer saying how many rows there are.  ncols : a non-negative integer saying how many columns there are.  contents : an Array holding the elements in row-major order.  That is, for a 2x3 array    the contents are (11 12 13 21 22 23).  Array2D uses column major order.    You can specify the class of 'contents' when you create a new Array2D,    but Matrix always gives you an Array.    There is a reason for this.  In strongly typed languages like Haskell and Clean,    'unboxed arrays' save you both space AND time.  But in Squeak, while    WordArray and FloatArray and so on do save space, it costs time to use them.    A LOT of time.  I've measured aFloatArray sum running nearly twice as slow as    anArray sum.  The reason is that whenever you fetch an element from an Array,    that's all that happens, but when you fetch an element from aFloatArray, a whole    new Float gets allocated to hold the value.  This takes time and churns memory.    So the paradox is that if you want fast numerical stuff, DON'T use unboxed arrays!!    Another reason for always insisting on an Array is that letting it be something    else would make things like #, and #,, rather more complicated.  Always using Array    is the simplest thing that could possibly work, and it works rather well.I was trying to patch Array2D to make more things work, but just couldn't get my headaround the subscript order.  That's why I made Matrix.Element-wise matrix arithmetic works; you can freely mix matrices and numbers butdon't try to mix matrices and arrays (yet).Matrix multiplication, using the symbol +* (derived from APL's +.x), works between(Matrix or Array) +* (Matrix or Array).  Don't try to use a number as an argument of +*.Matrix * Number and Number * Matrix work fine, so you don't need +* with numbers.Still to come: oodles of stuff.  Gaussian elimination maybe, other stuff probably not.!!Collection methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 00:17'!raisedTo: arg	^ arg adaptToCollection: self andSend: #raisedTo:! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:20'!arcCos	^self collect: [:each | each arcCos]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:20'!arcSin	^self collect: [:each | each arcSin]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:20'!arcTan	^self collect: [:each | each arcTan]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:20'!cos	^self collect: [:each | each cos]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:20'!degreeCos	^self collect: [:each | each degreeCos]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:21'!degreeSin	^self collect: [:each | each degreeSin]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:21'!exp	^self collect: [:each | each exp]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:21'!ln	^self collect: [:each | each ln]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:23'!sign	^self collect: [:each | each sign]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:22'!sin	^self collect: [:each | each sin]! !!Collection methodsFor: 'math functions' stamp: 'raok 10/22/2002 00:22'!tan	^self collect: [:each | each tan]! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:37'!anyOne	^contents anyOne! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:37'!at: row at: column	^contents at: (self indexForRow: row andColumn: column)! !!Matrix methodsFor: 'accessing' stamp: 'raok 11/28/2002 14:14'!at: r at: c ifInvalid: v	"If r,c is a valid index for this matrix, answer the corresponding element.	 Otherwise, answer v."	(r between: 1 and: nrows) ifFalse: [^v].	(c between: 1 and: ncols) ifFalse: [^v].	^contents at: (r-1)*ncols + c! !!Matrix methodsFor: 'accessing' stamp: 'raok 11/22/2002 12:37'!at: row at: column incrementBy: value	"Array2D>>at:at:add: was the origin of this method, but in Smalltalk add:	 generally suggests adding an element to a collection, not doing a sum.	 This method, and SequenceableCollection>>at:incrementBy: that supports	 it, have been renamed to reveal their intention more clearly."	^contents at: (self indexForRow: row andColumn: column) incrementBy: value! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:40'!at: row at: column put: value	^contents at: (self indexForRow: row andColumn: column) put: value! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:42'!atAllPut: value	contents atAllPut: value! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:43'!atRandom	^contents atRandom! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:43'!atRandom: aGenerator	^contents atRandom: aGenerator! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:44'!columnCount	^ncols! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:48'!identityIndexOf: anElement	^self identityIndexOf: anElement ifAbsent: [0@0]! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:48'!identityIndexOf: anElement ifAbsent: anExceptionBlock	^self rowAndColumnForIndex:		 (contents identityIndexOf: anElement ifAbsent: [^anExceptionBlock value])! !!Matrix methodsFor: 'accessing' stamp: 'raok 11/22/2002 13:13'!indexOf: anElement	"If there are integers r, c such that (self at: r at: c) = anElement,	 answer some such r@c, otherwise answer 0@0.  This kind of perverse	 result is provided by analogy with SequenceableCollection>>indexOf:.	 The order in which the receiver are searched is UNSPECIFIED except	 that it is the same as the order used by #indexOf:ifAbsent: and #readStream."	^self indexOf: anElement ifAbsent: [0@0]! !!Matrix methodsFor: 'accessing' stamp: 'raok 11/22/2002 13:10'!indexOf: anElement ifAbsent: anExceptionBlock	"If there are integers r, c such that (self at: r at: c) = anElement,	 answer some such r@c, otherwise answer the result of anExceptionBlock."	^self rowAndColumnForIndex:		 (contents indexOf: anElement ifAbsent: [^anExceptionBlock value])! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:49'!replaceAll: oldObject with: newObject	contents replaceAll: oldObject with: newObject! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:44'!rowCount	^nrows! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:49'!size	^contents size! !!Matrix methodsFor: 'accessing' stamp: 'raok 10/21/2002 22:52'!swap: r1 at: c1 with: r2 at: c2	contents swap: (self indexForRow: r1 andColumn: c1)			 with: (self indexForRow: r2 andColumn: c2)! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/22/2002 12:41'!atColumn: column	|p|	p _ (self indexForRow: 1 andColumn: column)-ncols.	^(1 to: nrows) collect: [:row | contents at: (p _ p+ncols)]! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:21'!atColumn: column put: aCollection	|p|	aCollection size = nrows ifFalse: [self error: 'wrong column size'].	p _ (self indexForRow: 1 andColumn: column)-ncols.	aCollection do: [:each | contents at: (p _ p+ncols) put: each].	^aCollection! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 10/21/2002 23:32'!atRow: row	(row between: 1 and: nrows)		ifFalse: [self error: '1st subscript out of range'].	^contents copyFrom: (row-1)*ncols+1 to: row*ncols! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/22/2002 12:42'!atRow: row put: aCollection	|p|	aCollection size = ncols ifFalse: [self error: 'wrong row size'].	p _ (self indexForRow: row andColumn: 1)-1.	aCollection do: [:each | contents at: (p _ p+1) put: each].	^aCollection! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 10/23/2002 20:41'!diagonal	"Answer (1 to: (nrows min: ncols)) collect: [:i | self at: i at: i]"	|i|	i _ ncols negated.	^(1 to: (nrows min: ncols)) collect: [:j | contents at: (i _ i + ncols + 1)]! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:21'!swapColumn: anIndex withColumn: anotherIndex	|a b|	a _ self indexForRow: 1 andColumn: anIndex.	b _ self indexForRow: 1 andColumn: anotherIndex.	nrows timesRepeat: [		contents swap: a with: b.		a _ a + ncols.		b _ b + ncols].! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:22'!swapRow: anIndex withRow: anotherIndex	|a b|	a _ self indexForRow: anIndex andColumn: 1.	b _ self indexForRow: anotherIndex andColumn: 1.	ncols timesRepeat: [		contents swap: a with: b.		a _ a + 1.		b _ b + 1].! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 10/22/2002 00:13'!transposed	self assert: [nrows = ncols].	^self indicesCollect: [:row :column | self at: column at: row]! !!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 13:09'!atRows: rs columns: cs	"Answer a Matrix obtained by slicing the receiver.	 rs and cs should be sequenceable collections of positive integers."	^self class rows: rs size columns: cs size tabulate: [:r :c |		self at: (rs at: r) at: (cs at: c)]! !!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 12:30'!atRows: r1 to: r2 columns: c1 to: c2	"Answer a submatrix [r1..r2][c1..c2] of the receiver."	|rd cd|	rd _ r1 - 1.	cd _ c1 - 1.	^self class rows: r2-rd columns: c2-cd tabulate: [:r :c| self at: r+rd at: c+cd]! !!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 13:05'!atRows: r1 to: r2 columns: c1 to: c2 ifInvalid: element	"Answer a submatrix [r1..r2][c1..c2] of the receiver.	 Portions of the result outside the bounds of the original matrix	 are filled in with element."	|rd cd|	rd _ r1 - 1.	cd _ c1 - 1.	^self class rows: r2-rd columns: c2-cd tabulate: [:r :c| self at: r+rd at: c+cd ifInvalid: element]! !!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 12:32'!atRows: r1 to: r2 columns: c1 to: c2 put: aMatrix	"Set the [r1..r2][c1..c2] submatrix of the receiver	 from the [1..r2-r1+1][1..c2-c1+1] submatrix of aMatrix.	 As long as aMatrix responds to at:at: and accepts arguments in the range shown,	 we don't care if it is bigger or even if it is a Matrix at all."	|rd cd|	rd _ r1 - 1.	cd _ c1 - 1.	r1 to: r2 do: [:r |		c1 to: c2 do: [:c |			self at: r at: c put: (aMatrix at: r-rd at: c-cd)]].	^aMatrix! !!Matrix methodsFor: 'adding' stamp: 'raok 10/21/2002 22:53'!add: newObject	self shouldNotImplement! !!Matrix methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:01'!+* aCollection	"Premultiply aCollection by self.  aCollection should be an Array or Matrix.	 The name of this method is APL's +.x squished into Smalltalk syntax."	^aCollection preMultiplyByMatrix: self! !!Matrix methodsFor: 'arithmetic' stamp: 'raok 11/28/2002 14:22'!preMultiplyByArray: a	"Answer a +* self where a is an Array."	nrows = 1 ifFalse: [self error: 'dimensions do not conform'].	^Matrix rows: a size columns: ncols tabulate: [:row :col |		(a at: row) * (contents at: col)]! !!Matrix methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:02'!preMultiplyByMatrix: m	"Answer m +* self where m is a Matrix."	|s|	nrows = m columnCount ifFalse: [self error: 'dimensions do not conform'].	^Matrix rows: m rowCount columns: ncols tabulate: [:row :col |		s _ 0.		1 to: nrows do: [:k | s _ (m at: row at: k) * (self at: k at: col) + s].		s]! !!Matrix methodsFor: 'comparing' stamp: 'raok 11/22/2002 12:58'!= aMatrix	^aMatrix class == self class and: [	 aMatrix rowCount = nrows and: [	 aMatrix columnCount = ncols and: [	 aMatrix privateContents = contents]]]! !!Matrix methodsFor: 'comparing' stamp: 'raok 11/22/2002 13:14'!hash	"I'm really not sure what would be a good hash function here.	 The essential thing is that it must be compatible with #=, and	 this satisfies that requirement."	^contents hash! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:57'!asArray	^contents shallowCopy! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:57'!asBag	^contents asBag! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asByteArray	^contents asByteArray! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asCharacterSet	^contents asCharacterSet! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 23:00'!asFloatArray	^contents asFloatArray! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asIdentitySet	^contents asIdentitySet! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 23:00'!asIntegerArray	^contents asIntegerArray! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asOrderedCollection	^contents asOrderedCollection! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asSet	^contents asSet! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:58'!asSortedArray	^contents asSortedArray! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:59'!asSortedCollection	^contents asSortedCollection! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 22:59'!asSortedCollection: aBlock	^contents asSortedCollection: aBlock! !!Matrix methodsFor: 'converting' stamp: 'raok 10/21/2002 23:00'!asWordArray	^contents asWordArray! !!Matrix methodsFor: 'converting' stamp: 'raok 11/22/2002 13:02'!readStream	"Answer a ReadStream that returns all the elements of the receiver	 in some UNSPECIFIED order."	^ReadStream on: contents! !!Matrix methodsFor: 'copying' stamp: 'raok 11/22/2002 12:57'!, aMatrix	"Answer a new matrix having the same number of rows as the receiver and aMatrix,	 its columns being the columns of the receiver followed by the columns of aMatrix."	|newCont newCols anArray oldCols a b c|	self assert: [nrows = aMatrix rowCount].	newCont _ Array new: self size + aMatrix size.	anArray _ aMatrix privateContents.	oldCols _ aMatrix columnCount.	newCols _ ncols + oldCols.	a _ b _ c _ 1.	1 to: nrows do: [:r |		newCont replaceFrom: a to: a+ncols-1 with: contents startingAt: b.		newCont replaceFrom: a+ncols to: a+newCols-1 with: anArray startingAt: c.		a _ a + newCols.		b _ b + ncols.		c _ c + oldCols].	^self class rows: nrows columns: newCols contents: newCont		! !!Matrix methodsFor: 'copying' stamp: 'raok 11/22/2002 12:58'!,, aMatrix	"Answer a new matrix having the same number of columns as the receiver and aMatrix,	 its rows being the rows of the receiver followed by the rows of aMatrix."	self assert: [ncols = aMatrix columnCount].	^self class rows: nrows + aMatrix rowCount columns: ncols		contents: contents , aMatrix privateContents! !!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:07'!copy	^self class rows: nrows columns: ncols contents: contents copy! !!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:07'!shallowCopy	^self class rows: nrows columns: ncols contents: contents shallowCopy! !!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:27'!shuffled	^self class rows: nrows columns: ncols contents: (contents shuffled)! !!Matrix methodsFor: 'copying' stamp: 'raok 10/21/2002 23:27'!shuffledBy: aRandom	^self class rows: nrows columns: ncols contents: (contents shuffledBy: aRandom)! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:41'!collect: aBlock	"Answer a new matrix with transformed elements; transformations should be independent."	^self class rows: nrows columns: ncols contents: (contents collect: aBlock)! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!difference: aCollection	"Union is in because the result is always a Set.	 Difference and intersection are out because the result is like the receiver,	 and with irregular seleection that cannot be."	self shouldNotImplement! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:40'!do: aBlock	"Pass elements to aBlock one at a time in row-major order."	contents do: aBlock! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/23/2002 20:57'!indicesCollect: aBlock	|r i|	r _ Array new: nrows * ncols.	i _ 0.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			r at: (i _ i+1) put: (aBlock value: row value: column)]].	^self class rows: nrows columns: ncols contents: r! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:49'!indicesDo: aBlock	1 to: nrows do: [:row |		1 to: ncols do: [:column |			aBlock value: row value: column]].! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:51'!indicesInject: start into: aBlock	|current|	current _ start.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			current _ aBlock value: current value: row value: column]].	^current! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!intersection: aCollection	"Union is in because the result is always a Set.	 Difference and intersection are out because the result is like the receiver,	 and with irregular seleection that cannot be."	self shouldNotImplement! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!reject: aBlock	self shouldNotImplement! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:42'!select: aBlock	self shouldNotImplement! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/22/2002 00:15'!with: aCollection collect: aBlock	"aCollection must support #at:at: and be at least as large as the receiver."	^self withIndicesCollect: [:each :row :column |		aBlock value: each value: (aCollection at: row at: column)]! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:53'!with: aCollection do: aBlock	"aCollection must support #at:at: and be at least as large as the receiver."	self withIndicesDo: [:each :row :column |		aBlock value: each value: (aCollection at: row at: column)].! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:55'!with: aCollection inject: startingValue into: aBlock	"aCollection must support #at:at: and be at least as large as the receiver."	^self withIndicesInject: startingValue into: [:value :each :row :column |		aBlock value: value value: each value: (aCollection at: row at: column)]! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!withIndicesCollect: aBlock	|i r|	i _ 0.	r _ contents shallowCopy.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			i _ i+1.			r at: i put: (aBlock value: (r at: i) value: row value: column)]].	^self class rows: nrows columns: ncols contents: r! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!withIndicesDo: aBlock	|i|	i _ 0.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			aBlock value: (contents at: (i _ i+1)) value: row value: column]].! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!withIndicesInject: start into: aBlock	|i current|	i _ 0.	current _ start.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			current _ aBlock value: current value: (contents at: (i _ i+1)) 							  value: row value: column]].	^current! !!Matrix methodsFor: 'printing' stamp: 'raok 10/21/2002 23:22'!storeOn: aStream	aStream nextPut: $(; nextPutAll: self class name;		nextPutAll: ' rows: '; store: nrows;		nextPutAll: ' columns: '; store: ncols;		nextPutAll: ' contents: '; store: contents;		nextPut: $)! !!Matrix methodsFor: 'removing' stamp: 'raok 10/21/2002 22:54'!remove: anObject ifAbsent: anExceptionBlock	self shouldNotImplement! !!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:24'!identityIncludes: anObject	^contents identityIncludes: anObject! !!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:23'!includes: anObject	^contents includes: anObject! !!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:24'!includesAllOf: aCollection	^contents includesAllOf: aCollection! !!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:24'!includesAnyOf: aCollection	^contents includesAnyOf: aCollection! !!Matrix methodsFor: 'testing' stamp: 'raok 11/22/2002 13:03'!isSequenceable	"LIE so that arithmetic on matrices will work.	 What matters for arithmetic is not that there should be random indexing	 but that the structure should be stable and independent of the values of	 the elements.  #isSequenceable is simply the wrong question to ask."	^true! !!Matrix methodsFor: 'testing' stamp: 'raok 10/21/2002 23:25'!occurrencesOf: anObject	^contents occurrencesOf: anObject! !!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 22:40'!indexForRow: row andColumn: column	(row between: 1 and: nrows)		ifFalse: [self error: '1st subscript out of range'].	(column between: 1 and: ncols)		ifFalse: [self error: '2nd subscript out of range'].	^(row-1) * ncols + column! !!Matrix methodsFor: 'private' stamp: 'raok 11/22/2002 12:56'!privateContents	"Only used in #, #,, and #= so far.	 It used to be called #contents, but that clashes with Collection>>contents."	^contents! !!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 22:47'!rowAndColumnForIndex: index	|t|	t _ index - 1.	^(t // ncols + 1)@(t \\ ncols + 1)! !!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 23:05'!rows: rows columns: columns contents: anArray	self assert: [rows isInteger and: [rows >= 0]].	self assert: [columns isInteger and: [columns >= 0]].	self assert: [rows * columns = anArray size].	nrows _ rows.	ncols _ columns.	contents _ anArray.	^self! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/23/2002 20:58'!column: aCollection	"Should this be called #fromColumn:?"	^self rows: aCollection size columns: 1 contents: aCollection asArray shallowCopy! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 00:09'!diagonal: aCollection	|r i|	r _ self zeros: aCollection size.	i _ 0.	aCollection do: [:each | i _ i+1. r at: i at: i put: each].	^r! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/23/2002 20:59'!identity: n	|r|	r _ self zeros: n.	1 to: n do: [:i | r at: i at: i put: 1].	^r! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 00:06'!new: dim	"Answer a dim*dim matrix.  Is this an abuse of #new:?  The argument is NOT a size."	^self rows: dim columns: dim! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 11/25/2002 12:51'!new: dim element: element	"Answer a dim*dim matrix with all elements set to element.	 Is this an abuse of #new:?  The argument is NOT a size."	^self rows: dim columns: dim element: element! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 19:54'!new: dim tabulate: aBlock	"Answer a dim*dim matrix where it at: i at: j is aBlock value: i value: j."	^self rows: dim columns: dim tabulate: aBlock! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 11/28/2002 14:08'!ones: n	^self new: n element: 1! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/23/2002 20:59'!row: aCollection	"Should this be called #fromRow:?"	^self rows: 1 columns: aCollection size contents: aCollection asArray shallowCopy! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 00:04'!rows: rows columns: columns	^self rows: rows columns: columns contents: (Array new: rows*columns)! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 11/28/2002 14:10'!rows: rows columns: columns element: element	^self rows: rows columns: columns		contents: ((Array new: rows*columns) atAllPut: element; yourself)! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 19:51'!rows: rows columns: columns tabulate: aBlock	"Answer a new Matrix of the given dimensions where	 result at: i at: j     is   aBlock value: i value: j"	|a i|	a _ Array new: rows*columns.	i _ 0.	1 to: rows do: [:row |		1 to: columns do: [:column |			a at: (i _ i+1) put: (aBlock value: row value: column)]].	^self rows: rows columns: columns contents: a! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 11/28/2002 14:09'!zeros: n	^self new: n element: 0! !!Matrix class methodsFor: 'private' stamp: 'raok 10/21/2002 23:06'!rows: rows columns: columns contents: contents	^self new rows: rows columns: columns contents: contents! !!SequenceableCollection methodsFor: 'accessing' stamp: 'raok 11/22/2002 12:34'!at: index incrementBy: value	^self at: index put: (self at: index) + value! !!Array methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:09'!+* aCollection	"Premultiply aCollection by self.  aCollection should be an Array or Matrix.	 The name of this method is APL's +.x squished into Smalltalk syntax."	^aCollection preMultiplyByArray: self! !!Array methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:10'!preMultiplyByArray: a	"Answer a+*self where a is an Array.  Arrays are always understood as column vectors,	 so an n element Array is an n*1 Array.  This multiplication is legal iff self size = 1."	self size = 1 ifFalse: [self error: 'dimensions do not conform'].	^a * self first! !!Array methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:08'!preMultiplyByMatrix: m	"Answer m+*self where m is a Matrix."	|s|	m columnCount = self size ifFalse: [self error: 'dimensions do not conform'].	^(1 to: m rowCount) collect: [:row |		s _ 0.		1 to: self size do: [:k | s _ (m at: row at: k) * (self at: k) + s].		s]! !!Matrix class reorganize!('instance creation' column: diagonal: identity: new: new:element: new:tabulate: ones: row: rows:columns: rows:columns:element: rows:columns:tabulate: zeros:)('private' rows:columns:contents:)!!Matrix reorganize!('accessing' anyOne at:at: at:at:ifInvalid: at:at:incrementBy: at:at:put: atAllPut: atRandom atRandom: columnCount identityIndexOf: identityIndexOf:ifAbsent: indexOf: indexOf:ifAbsent: replaceAll:with: rowCount size swap:at:with:at:)('accessing rows/columns' atColumn: atColumn:put: atRow: atRow:put: diagonal swapColumn:withColumn: swapRow:withRow: transposed)('accessing submatrices' atRows:columns: atRows:to:columns:to: atRows:to:columns:to:ifInvalid: atRows:to:columns:to:put:)('adding' add:)('arithmetic' +* preMultiplyByArray: preMultiplyByMatrix:)('comparing' = hash)('converting' asArray asBag asByteArray asCharacterSet asFloatArray asIdentitySet asIntegerArray asOrderedCollection asSet asSortedArray asSortedCollection asSortedCollection: asWordArray readStream)('copying' , ,, copy shallowCopy shuffled shuffledBy:)('enumerating' collect: difference: do: indicesCollect: indicesDo: indicesInject:into: intersection: reject: select: with:collect: with:do: with:inject:into: withIndicesCollect: withIndicesDo: withIndicesInject:into:)('printing' storeOn:)('removing' remove:ifAbsent:)('testing' identityIncludes: includes: includesAllOf: includesAnyOf: isSequenceable occurrencesOf:)('private' indexForRow:andColumn: privateContents rowAndColumnForIndex: rows:columns:contents:)!