'From Squeak2.8alpha of 13 January 2000 [latest update: #1950] on 29 March 2000 at 5:47:52 pm'!"Change Set:		fileList-tkNXDate:			29 March 2000Author:			Ted KaehlerA FileList looking at a remote server cuts off the read when more than 3500 characters have been received.  Only when the user asks to 'get entire file' does it read the whole thing."!!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 3/23/2000 22:10'!getOnlyBuffer: ubuffer whileWatching: otherSocket	"Reel in all data until the buffer is full.  At the same time, watch for errors on otherSocket.  Caller will break the connection after we have the data."	| bytesRead ind |	ind _ 1.	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: ubuffer 			startingAt: ind count: ubuffer size - ind + 1.		(ind _ ind + bytesRead) > ubuffer size ifTrue: [^ ubuffer].		].	^ ubuffer	"file was shorter"! !!FileList methodsFor: 'private' stamp: 'tk 3/23/2000 16:21'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	brevityFlag ifTrue: [		(directory isKindOf: ServerDirectory) ifTrue: [^ self readServerBrief]].	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	(brevityFlag not or: [(fileSize _ f size) <= 100000]) ifTrue:		[contents _ f contentsOfEntireFile.		brevityState _ #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 _ f next: 5000.	f close.	contents _ 'File ''', fileName, ''' is ', fileSize printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', first5000 , '------------------------------------------... end of the first 5000 characters.'.	brevityState _ #briefFile.   "don't change till actually read"	^ contents.! !!FileList methodsFor: 'private' stamp: 'tk 3/24/2000 10:52'!readServerBrief	| lString sizeStr fsize ff first5000 parts |	"If file on server is known to be long, just read the beginning.  Cheat badly by reading the fileList string."	listIndex = 0 ifTrue: [^ self].	"Get size from file list entry"	lString _ list at: listIndex.	parts _ lString findTokens: '()'.	sortMode = #name ifTrue: [sizeStr _ (parts second findTokens: ' ') third].	sortMode = #date ifTrue: [sizeStr _ (parts first findTokens: ' ') third].	sortMode = #size ifTrue: [sizeStr _ (parts first findTokens: ' ') first].	fsize _ (sizeStr copyWithout: $,) asNumber.	fsize <= 50000 ifTrue:		[ff _ directory oldFileOrNoneNamed: self fullName.		ff ifNil: [^ 'For some reason, this file cannot be read'].		contents _ ff contentsOfEntireFile.		brevityState _ #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 _ directory getOnly: 3500 from: fileName.	contents _ 'File ''', fileName, ''' is ', sizeStr, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 3500 characters...------------------------------------------', first5000 , '------------------------------------------... end of the first 3500 characters.'.	brevityState _ #briefFile.   "don't change till actually read"	^ contents.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 3/24/2000 11:20'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index connectToHost connectToPort type newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ self defaultPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [page _ page, (self argString: args) ].	HTTPProxyServer isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxyServer.			connectToPort _ HTTPProxyPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr; cr; show: url; cr.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: header; cr."	firstData _ list at: 3.	header isEmpty 		ifTrue: [aStream _ 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length _ sock getHeader: 'content-length'.			length ifNotNil: [ length _ length asNumber ].			type _ sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl _ sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].			aStream _ sock getRestOfBuffer: firstData totalLength: length.			sock responseCode = '401' ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifFalse: [		]	].! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 3/23/2000 22:56'!getFileNamed: fileNameOnServer	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieving file ', fileNameOnServer; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; space;		show: fileNameOnServer; cr."	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [socket _ nil.  ^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"226 Transfer complete."	socket ifNil: ["normally leave connection open.  Don't quit"		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"	dd destroy.	^ resp	"a RWBinaryOrTextStream"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 3/23/2000 22:57'!getFileNamed: fileNameOnServer into: dataStream	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	type == #file ifTrue: [		dataStream nextPutAll: 			(resp _ FileStream oldFileNamed: server,(self serverDelimiter asString), 				self bareDirectory, (self serverDelimiter asString),				fileNameOnServer) contentsOfEntireFile.		dataStream dataIsValid.		^ resp].	type == #http ifTrue: [		resp _ HTTPSocket httpGet: (self fullNameFor: fileNameOnServer) 				accept: 'application/octet-stream'.		resp class == String ifTrue: [^ dataStream].	"error, no data"		dataStream copyFrom: resp.		dataStream dataIsValid.		^ dataStream].	type ifNil: [type _ #ftp].	"type == #ftp"	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieving file ', fileNameOnServer; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; cr."	resp _ dd getDataTo: dataStream whileWatching: so.		"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [socket _ nil.  ^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"226 Transfer complete."	socket ifNil: ["normally leave connection open.  Don't quit"		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"	dd destroy.	dataStream dataIsValid.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 3/24/2000 11:05'!getOnlyBuffer: buffer from: fileNameOnServer	"Open ftp, fill the buffer, and close the connection.  Only first part of a very long file."	| so dd resp rr |	"type == #ftp"	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieving beginning of file ', fileNameOnServer; cr.	resp _ dd getOnlyBuffer: buffer whileWatching: so.	(resp == #error:) ifTrue: [socket _ nil.  ^ resp].	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"150 Opening binary conn on foo (3113 bytes)"	dd destroy.	so sendCommand: 'ABOR'.	socket _ nil.	so destroy.	"Just be as rude as possible"	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 3/23/2000 22:54'!getOnly: nnn from: fileNameOnServer	| file ff resp |	"Use FTP to just capture the first nnn characters of the file.  Break the connection after that.  Goes faster for long files.  Return the contents, not a stream."	type == #file ifTrue: [		file _ self as: ServerFile.		file fileName: fileNameOnServer.		ff _ FileStream oldFileOrNoneNamed: (file fileNameRelativeTo: self).		^ ff next: nnn].	type == #http ifTrue: [		resp _ HTTPSocket httpGet: (self fullNameFor: fileNameOnServer) 				accept: 'application/octet-stream'.			"For now, get the whole file.  This branch not used often."		^ resp truncateTo: nnn].		^ self getOnlyBuffer: (String new: nnn) from: fileNameOnServer! !