'From Squeak2.6 of 11 October 1999 [latest update: #1684] on 6 December 1999 at 11:22:51 am'!"Change Set:		SundryFixesDate:			6 December 1999Author:			Dan Ingalls and fellow SqueakersImplements AbstractSound>>asSampledSound (Mark Guzdial)Adds PluggableTextMorphWithModel (Mark Guzdial)Fixes typo in nextLitteEndian method and its sender (Andrew Greenberg)Defines ProtoObject>>doesNotUnderstand: (Iam Piumarta)Restores Interval>>includes to reasonable behavior (Mostly Bob Jarvis)"!PluggableTextMorph subclass: #PluggableTextMorphWithModel	instanceVariableNames: 'myContents '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!ProtoObject methodsFor: 'system primitives' stamp: 'di 12/6/1999 10:24'!doesNotUnderstand: aMessage	(MessageNotUnderstood new message: aMessage)		signal! !!AbstractSound methodsFor: 'conversion' stamp: 'mjg 12/3/1999 12:58'!asSampledSound	^SampledSound samples: (self computeSamplesForSeconds: self duration) samplingRate: (self samplingRate)*2.! !!Form methodsFor: 'fileIn/Out' stamp: 'di 12/6/1999 10:14'!writeBMPfileNamed: fName  "Display writeBMPfileNamed: 'display'"	| fileName bhSize biSize biClrUsed f biSizeImage bfOffBits rowBytes rgb data colorValues |	self unhibernate.	(#(1 4 8 32) includes: depth) ifFalse: [self halt  "depth must be one of these"].	((fileName _ fName) asUppercase endsWith: '.BMP')		ifFalse: [fileName _ fName , '.BMP'].	bhSize _ 14.  "# bytes in file header"	biSize _ 40.  "info header size in bytes"	biClrUsed _ depth = 32 ifTrue: [0] ifFalse:[1 << depth].  "No. color table entries"	bfOffBits _ biSize + bhSize + (4*biClrUsed).	rowBytes _ ((depth min: 24) * width + 31 // 32) * 4.	biSizeImage _ height * rowBytes. 	f _ (FileStream newFileNamed: fileName) binary.	"Write the file header"	f position: 0.	f nextLittleEndianNumber: 2 put: 19778.  "bfType = BM"	f nextLittleEndianNumber: 4 put: bfOffBits + biSizeImage.  "Entire file size in bytes"	f nextLittleEndianNumber: 4 put: 0.  "bfReserved"	f nextLittleEndianNumber: 4 put: bfOffBits.  "Offset of bitmap data from start of hdr (and file)"	"Write the bitmap info header"	f position: bhSize.	f nextLittleEndianNumber: 4 put: biSize.  "info header size in bytes"	f nextLittleEndianNumber: 4 put: width.  "biWidth"	f nextLittleEndianNumber: 4 put: height.  "biHeight"	f nextLittleEndianNumber: 2 put: 1.  "biPlanes"	f nextLittleEndianNumber: 2 put: (depth min: 24).  "biBitCount"	f nextLittleEndianNumber: 4 put: 0.  "biCompression"	f nextLittleEndianNumber: 4 put: biSizeImage.  "size of image section in bytes"	f nextLittleEndianNumber: 4 put: 2800.  "biXPelsPerMeter"	f nextLittleEndianNumber: 4 put: 2800.  "biYPelsPerMeter"	f nextLittleEndianNumber: 4 put: biClrUsed.	f nextLittleEndianNumber: 4 put: 0.  "biClrImportant"	biClrUsed > 0 ifTrue: [		"write color map; this works for ColorForms, too"		colorValues _ self colormapIfNeededForDepth: 32.		1 to: biClrUsed do: [:i |			rgb _ colorValues at: i.			0 to: 24 by: 8 do: [:j | f nextPut: (rgb >> j bitAnd: 16rFF)]]].	'Writing image data' displayProgressAt: Sensor cursorPoint		from: 1 to: height during: [:bar |			1 to: height do:				[:i | bar value: i.				data _ (self copy: (0@(height-i) extent: width@1)) bits.				depth = 32				ifTrue: [1 to: data size do: [:j | f nextLittleEndianNumber: 3 put: (data at: j)].						1 to: (data size*3)+3//4*4-(data size*3) do: [:j | f nextPut: 0 "pad to 32-bits"]]				ifFalse: [1 to: data size do: [:j | f nextNumber: 4 put: (data at: j)]]]].	f position = (bfOffBits + biSizeImage) ifFalse: [self halt].	f close.! !!Interval methodsFor: 'accessing' stamp: 'rpj 11/30/1999 11:04'!includes: aNumber	"Determine if aNumber is an element of this interval."	^ (self rangeIncludes: aNumber) and: [ self valuesInclude: aNumber ]! !!Interval methodsFor: 'accessing' stamp: 'di 12/6/1999 11:00'!rangeIncludes: aNumber	"Return true if the number lies in the interval between start and stop."	step >= 0		ifTrue: [^ aNumber between: start and: stop]		ifFalse: [^ aNumber between: stop and: start]! !!Interval methodsFor: 'private' stamp: 'rpj 11/30/1999 15:22'!valuesInclude: aNumber	"Private - answer whether or not aNumber is one of the enumerated values in this interval."	| val |	val _ aNumber - self first / self increment.	^ (val - val rounded) abs < (step * 1e-10)! !!PluggableTextMorphWithModel methodsFor: 'as yet unclassified' stamp: 'mjg 12/3/1999 11:57'!getMyText	^myContents! !!PluggableTextMorphWithModel methodsFor: 'as yet unclassified' stamp: 'mjg 12/3/1999 11:59'!initialize	super initialize.	self on: self		text: #getMyText		accept: #setMyText:		readSelection: nil		menu: nil.! !!PluggableTextMorphWithModel methodsFor: 'as yet unclassified' stamp: 'mjg 12/3/1999 11:59'!setMyText: someText	myContents _ someText.	^true.! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'di 12/6/1999 10:13'!nextLittleEndianNumber: n put: value	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| bytes |	bytes _ ByteArray new: n.	1 to: n do: [: i | bytes at: i put: (value digitAt: i)].	self nextPutAll: bytes! !PositionableStream removeSelector: #nextLitteEndianNumber:put:!