'From Squeak3.8gamma of ''24 November 2004'' [latest update: #6569] on 24 February 2005 at 6:39:34 pm'!"Change Set:		OldSocketRefFixes-nkDate:			24 February 2005Author:			Ned KonzWhen Socket was renamed to OldSocket, references to the class weren't renamed.This CS does that renaming."!!OldSocket methodsFor: 'accessing' stamp: 'nk 2/24/2005 14:37'!localAddress	self waitForConnectionUntil: self class standardDeadline.	self isConnected ifFalse: [^ByteArray new: 4].	^self primSocketLocalAddress: socketHandle! !!OldSocket methodsFor: 'accessing' stamp: 'nk 2/24/2005 14:37'!localPort	self waitForConnectionUntil: self class standardDeadline.	self isConnected ifFalse: [^0].	^self primSocketLocalPort: socketHandle! !!OldSocket methodsFor: 'connection open/close' stamp: 'nk 2/24/2005 14:37'!accept	"Accept a connection from the receiver socket.	Return a new socket that is connected to the client"	^self class acceptFrom: self! !!OldSocket methodsFor: 'connection open/close' stamp: 'nk 2/24/2005 14:37'!closeAndDestroy: timeoutSeconds 	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil 		ifFalse: 			[self isConnected 				ifTrue: 					[self close.	"close this end"					(self waitForDisconnectionUntil: (self class deadlineSecs: timeoutSeconds)) 						ifFalse: 							["if the other end doesn't close soon, just abort the connection"							self primSocketAbortConnection: socketHandle]].			self destroy]! !!OldSocket methodsFor: 'sending-receiving' stamp: 'nk 2/24/2005 14:37'!getData	"Get some data"	| buf bytesRead |	(self waitForDataUntil: self class standardDeadline) 		ifFalse: [self error: 'getData timeout'].	buf := String new: 4000.	bytesRead := self 				primSocket: socketHandle				receiveDataInto: buf				startingAt: 1				count: buf size.	^buf copyFrom: 1 to: bytesRead! !!OldSocket methodsFor: 'sending-receiving' stamp: 'nk 2/24/2005 14:37'!readInto: aStringOrByteArray startingAt: aNumber 	"Read data into the given buffer starting at the given index and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	(self waitForDataUntil: self class standardDeadline) 		ifFalse: [self error: 'receive timeout'].	^self 		primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: aNumber		count: aStringOrByteArray size - aNumber + 1! !!OldSocket methodsFor: 'sending-receiving' stamp: 'nk 2/24/2005 14:37'!sendData: aStringOrByteArray 	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent."	"An experimental version use on slow lines: Longer timeout and smaller writes to try to avoid spurious timeouts."	| bytesSent bytesToSend count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[bytesSent < bytesToSend] whileTrue: 			[(self waitForSendDoneUntil: (self class deadlineSecs: 60)) 				ifFalse: [self error: 'send data timeout; data not sent'].			count := self 						primSocket: socketHandle						sendData: aStringOrByteArray						startIndex: bytesSent + 1						count: (bytesToSend - bytesSent min: 5000).			bytesSent := bytesSent + count].	^bytesSent! !!OldSocket methodsFor: 'sending-receiving' stamp: 'nk 2/24/2005 14:37'!sendSomeData: aStringOrByteArray startIndex: startIndex count: count 	"Send up to count bytes of the given data starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	| bytesSent |	(self waitForSendDoneUntil: (self class deadlineSecs: 20)) 		ifTrue: 			[bytesSent := self 						primSocket: socketHandle						sendData: aStringOrByteArray						startIndex: startIndex						count: count]		ifFalse: [self error: 'send data timeout; data not sent'].	^bytesSent! !!OldSocket methodsFor: 'datagrams' stamp: 'nk 2/24/2005 14:37'!sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber 	"Send a UDP packet containing the given data to the specified host/port."	| bytesToSend bytesSent count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[bytesSent < bytesToSend] whileTrue: 			[(self waitForSendDoneUntil: (self class deadlineSecs: 20)) 				ifFalse: [self error: 'send data timeout; data not sent'].			count := self 						primSocket: socketHandle						sendUDPData: aStringOrByteArray						toHost: hostAddress						port: portNumber						startIndex: bytesSent + 1						count: bytesToSend - bytesSent.			bytesSent := bytesSent + count].	^bytesSent! !!OldSocket methodsFor: 'other' stamp: 'nk 2/24/2005 14:37'!getResponseNoLF	"Get the response to the last command."	| buf response bytesRead c lf |	(self waitForDataUntil: (self class deadlineSecs: 20)) 		ifFalse: [self error: 'getResponse timeout'].	lf := Character lf.	buf := String new: 1000.	response := WriteStream on: ''.	[self dataAvailable] whileTrue: 			[bytesRead := self 						primSocket: socketHandle						receiveDataInto: buf						startingAt: 1						count: buf size.			1 to: bytesRead				do: [:i | (c := buf at: i) ~= lf ifTrue: [response nextPut: c]]].	^response contents! !!OldSocket class methodsFor: 'network initialization' stamp: 'nk 2/24/2005 14:38'!ensureNetworkConnected	"Try to ensure that an intermittent network connection, such as a dialup or ISDN line, is actually connected. This is necessary to make sure a server is visible in order to accept an incoming connection."	"Socket ensureNetworkConnected"	self initializeNetwork.	Utilities informUser: 'Contacting domain name server...'		during: 			[NetNameResolver addressForName: 'bogusNameToForceDNSToBeConsulted.org'				timeout: 30]! !!OldSocket class methodsFor: 'tests' stamp: 'nk 2/24/2005 14:38'!loopbackTest	"Send data from one socket to another on the local machine. Tests most of the socket primitives."	"100 timesRepeat: [Socket loopbackTest]"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived t extraBytes packetsSent packetsRead |	Transcript		cr;		show: 'starting loopback test';		cr.	Transcript		show: '---------- Connecting ----------';		cr.	self initializeNetwork.	sock1 := self new.	sock2 := self new.	sock1 listenOn: 54321.	sock2 connectTo: NetNameResolver localHostAddress port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	sock1 isConnected ifFalse: [self error: 'sock1 not connected'].	sock2 isConnected ifFalse: [self error: 'sock2 not connected'].	Transcript		show: 'connection established';		cr.	bytesToSend := 5000000.	sendBuf := String new: 5000 withAll: $x.	receiveBuf := String new: 50000.	done := false.	packetsSent := packetsRead := bytesSent := bytesReceived := 0.	t := Time millisecondsToRun: 					[[done] whileFalse: 							[(sock1 sendDone and: [bytesSent < bytesToSend]) 								ifTrue: 									[packetsSent := packetsSent + 1.									bytesSent := bytesSent + (sock1 sendSomeData: sendBuf)].							sock2 dataAvailable 								ifTrue: 									[packetsRead := packetsRead + 1.									bytesReceived := bytesReceived + (sock2 receiveDataInto: receiveBuf)].							done := bytesSent >= bytesToSend and: [bytesReceived = bytesSent]]].	Transcript		show: 'closing connection';		cr.	sock1 waitForSendDoneUntil: self standardDeadline.	sock1 close.	sock2 waitForDisconnectionUntil: self standardDeadline.	extraBytes := sock2 discardReceivedData.	extraBytes > 0 		ifTrue: 			[Transcript				show: ' *** received ' , extraBytes size printString , ' extra bytes ***';				cr].	sock2 close.	sock1 waitForDisconnectionUntil: self standardDeadline.	sock1 isUnconnectedOrInvalid ifFalse: [self error: 'sock1 not closed'].	sock2 isUnconnectedOrInvalid ifFalse: [self error: 'sock2 not closed'].	Transcript		show: '---------- Connection Closed ----------';		cr.	sock1 destroy.	sock2 destroy.	Transcript		show: 'loopback test done; time = ' , t printString;		cr.	Transcript		show: (bytesToSend asFloat / t roundTo: 0.01) printString 					, ' 1000Bytes/sec';		cr.	Transcript endEntry! !!OldSocket class methodsFor: 'tests' stamp: 'nk 2/24/2005 14:38'!sendTest	"Send data to the 'discard' socket of the given host. Tests the speed of one-way data transfers across the network to the given host. Note that many host hosts do not run a discard server."	"Socket sendTest"	| sock bytesToSend sendBuf bytesSent t serverName serverAddr |	Transcript		cr;		show: 'starting send test';		cr.	self initializeNetwork.	serverName := FillInTheBlank request: 'What is the destination server?'				initialAnswer: 'create.ucsb.edu'.	serverAddr := NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil 		ifTrue: [^self inform: 'Could not find an address for ' , serverName].	sock := self new.	Transcript		show: '---------- Connecting ----------';		cr.	sock connectTo: serverAddr port: 9.	sock waitForConnectionUntil: self standardDeadline.	sock isConnected 		ifFalse: 			[sock destroy.			^self inform: 'could not connect'].	Transcript		show: 'connection established; sending data';		cr.	bytesToSend := 1000000.	sendBuf := String new: 64 * 1024 withAll: $x.	bytesSent := 0.	t := Time millisecondsToRun: 					[[bytesSent < bytesToSend] whileTrue: 							[sock sendDone 								ifTrue: [bytesSent := bytesSent + (sock sendSomeData: sendBuf)]]].	sock waitForSendDoneUntil: self standardDeadline.	sock destroy.	Transcript		show: '---------- Connection Closed ----------';		cr.	Transcript		show: 'send test done; time = ' , t printString;		cr.	Transcript		show: (bytesToSend asFloat / t roundTo: 0.01) printString 					, ' 1000Bytes/sec';		cr.	Transcript endEntry! !!OldSocket class methodsFor: 'utilities' stamp: 'nk 2/24/2005 14:38'!ping: hostName 	"Ping the given host. Useful for checking network connectivity. The host must be running a TCP echo server."	"Socket ping: 'squeak.cs.uiuc.edu'"	| tcpPort sock serverAddr startTime echoTime |	tcpPort := 7.	"7 = echo port, 13 = time port, 19 = character generator port"	self initializeNetwork.	serverAddr := NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil 		ifTrue: [^self inform: 'Could not find an address for ' , hostName].	sock := self new.	sock connectTo: serverAddr port: tcpPort.		[sock waitForConnectionUntil: (self deadlineSecs: 10).	sock isConnected] 			whileFalse: 				[(self confirm: 'Continue to wait for connection to ' , hostName , '?') 					ifFalse: 						[sock destroy.						^self]].	sock sendData: 'echo!!'.	startTime := Time millisecondClockValue.		[sock waitForDataUntil: (self deadlineSecs: 15).	sock dataAvailable] 			whileFalse: 				[(self confirm: 'Packet sent but no echo yet; keep waiting?') 					ifFalse: 						[sock destroy.						^self]].	echoTime := Time millisecondClockValue - startTime.	sock destroy.	self inform: hostName , ' responded in ' , echoTime printString 				, ' milliseconds'! !!OldSocket class methodsFor: 'utilities' stamp: 'nk 2/24/2005 14:38'!pingPorts: portList on: hostName timeOutSecs: timeOutSecs 	"Attempt to connect to each of the given sockets on the given host. Wait at most timeOutSecs for the connections to be established. Answer an array of strings indicating the available ports."	"Socket pingPorts: #(7 13 19 21 23 25 80 110 119) on: 'squeak.cs.uiuc.edu' timeOutSecs: 15"	| serverAddr sockets sock deadline done unconnectedCount connectedCount waitingCount result |	self initializeNetwork.	serverAddr := NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil 		ifTrue: 			[self inform: 'Could not find an address for ' , hostName.			^#()].	sockets := portList collect: 					[:portNum | 					sock := self new.					sock connectTo: serverAddr port: portNum].	deadline := self deadlineSecs: timeOutSecs.	done := false.	[done] whileFalse: 			[unconnectedCount := 0.			connectedCount := 0.			waitingCount := 0.			sockets do: 					[:s | 					s isUnconnectedOrInvalid 						ifTrue: [unconnectedCount := unconnectedCount + 1]						ifFalse: 							[s isConnected ifTrue: [connectedCount := connectedCount + 1].							s isWaitingForConnection ifTrue: [waitingCount := waitingCount + 1]]].			waitingCount = 0 ifTrue: [done := true].			connectedCount = sockets size ifTrue: [done := true].			Time millisecondClockValue > deadline ifTrue: [done := true]].	result := (sockets select: [:s | s isConnected]) 				collect: [:s | self nameForWellKnownTCPPort: s remotePort].	sockets do: [:s | s destroy].	^result! !!OldSocket class methodsFor: 'utilities' stamp: 'nk 2/24/2005 14:38'!pingPortsOn: hostName 	"Attempt to connect to a set of well-known sockets on the given host, and answer the names of the available ports."	"Socket pingPortsOn: 'www.disney.com'"	^self 		pingPorts: #(7 13 19 21 23 25 80 110 119)		on: hostName		timeOutSecs: 20! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!clientServerTestUDP	"Socket clientServerTestUDP"	"Performa 6400/200, Linux-PPC 2.1.24:		client/server UDP test done; time = 2820		2500 packets, 10000000 bytes sent (3546 kBytes/sec)		2500 packets, 10000000 bytes received (3546 kBytes/sec)		4000 bytes/packet, 886 packets/sec, 0 packets dropped"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t |	Transcript		show: 'starting client/server UDP test';		cr.	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	Transcript		show: 'creating endpoints';		cr.	sock1 := self newUDP.	"the sender"	sock2 := self newUDP.	"the recipient"	sock2 setPort: 54321.	sock1 setPeer: NetNameResolver localHostAddress port: sock2 port.	Transcript		show: 'endpoints created';		cr.	bytesToSend := 10000000.	sendBuf := String new: 4000 withAll: $x.	receiveBuf := String new: 50000.	done := false.	bytesSent := bytesReceived := packetsSent := packetsReceived := 0.	t := Time millisecondsToRun: 					[[done] whileFalse: 							[(sock1 sendDone and: [bytesSent < bytesToSend]) 								ifTrue: 									[packetsSent := packetsSent + 1.									bytesSent := bytesSent + (sock1 sendData: sendBuf)].							sock2 dataAvailable 								ifTrue: 									[packetsReceived := packetsReceived + 1.									bytesReceived := bytesReceived + (sock2 receiveDataInto: receiveBuf)].							done := bytesSent >= bytesToSend].					sock1 waitForSendDoneUntil: self standardDeadline.					bytesReceived := bytesReceived + sock2 discardReceivedData].	Transcript		show: 'closing endpoints';		cr.	sock1 close.	sock2 close.	sock1 destroy.	sock2 destroy.	Transcript		show: 'client/server UDP test done; time = ' , t printString;		cr.	Transcript		show: packetsSent printString , ' packets, ' , bytesSent printString 					, ' bytes sent (' , (bytesSent * 1000 // t) printString 					, ' Bytes/sec)';		cr.	Transcript		show: packetsReceived printString , ' packets, ' 					, bytesReceived printString , ' bytes received (' 					, (bytesReceived * 1000 // t) printString , ' Bytes/sec)';		cr.	Transcript		show: (bytesSent // packetsSent) printString , ' bytes/packet, ' 					, (packetsReceived * 1000 // t) printString , ' packets/sec, ' 					, (packetsSent - packetsReceived) printString , ' packets dropped';		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!clientServerTestUDP2	"Socket clientServerTestUDP2"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t datagramInfo |	Transcript		show: 'starting client/server UDP test';		cr.	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	Transcript		show: 'creating endpoints';		cr.	sock1 := self newUDP.	"the sender"	sock2 := self newUDP.	"the recipient"	sock2 setPort: 54321.	Transcript		show: 'endpoints created';		cr.	bytesToSend := 100000000.	sendBuf := String new: 4000 withAll: $x.	receiveBuf := String new: 2000.	done := false.	bytesSent := bytesReceived := packetsSent := packetsReceived := 0.	t := Time millisecondsToRun: 					[[done] whileFalse: 							[(sock1 sendDone and: [bytesSent < bytesToSend]) 								ifTrue: 									[packetsSent := packetsSent + 1.									bytesSent := bytesSent + (sock1 														sendData: sendBuf														toHost: NetNameResolver localHostAddress														port: sock2 port)].							sock2 dataAvailable 								ifTrue: 									[packetsReceived := packetsReceived + 1.									datagramInfo := sock2 receiveUDPDataInto: receiveBuf.									bytesReceived := bytesReceived + (datagramInfo at: 1)].							done := bytesSent >= bytesToSend].					sock1 waitForSendDoneUntil: self standardDeadline.					bytesReceived := bytesReceived + sock2 discardReceivedData].	Transcript		show: 'closing endpoints';		cr.	sock1 close.	sock2 close.	sock1 destroy.	sock2 destroy.	Transcript		show: 'client/server UDP test done; time = ' , t printString;		cr.	Transcript		show: packetsSent printString , ' packets, ' , bytesSent printString 					, ' bytes sent (' , (bytesSent * 1000 // t) printString 					, ' Bytes/sec)';		cr.	Transcript		show: packetsReceived printString , ' packets, ' 					, bytesReceived printString , ' bytes received (' 					, (bytesReceived * 1000 // t) printString , ' Bytes/sec)';		cr.	Transcript		show: (bytesSent // packetsSent) printString , ' bytes/packet, ' 					, (packetsReceived * 1000 // t) printString , ' packets/sec, ' 					, (packetsSent - packetsReceived) printString , ' packets dropped';		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!remoteTestClientTCP	"FIRST start up another image, and execute: Socket remoteTestServerTCP.	THEN come back to this image and execute:"	"Socket remoteTestClientTCP"	"Performa 6400/200, Linux-PPC 2.1.24, both images on same CPU:		remoteClient TCP test done; time = 5680		250 packets, 1000000 bytes sent (176 kBytes/sec)		60 packets, 1000000 bytes received (176 kBytes/sec)"	| socket bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t serverName |	Transcript		show: 'starting client/server TCP test';		cr.	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	socket := self newTCP.	serverName := FillInTheBlank request: 'What is your remote Test Server?'				initialAnswer: ''.	socket connectTo: (NetNameResolver addressFromString: serverName)		port: 54321.	socket waitForConnectionUntil: self standardDeadline.	Transcript		show: 'client endpoint created';		cr.	bytesToSend := 1000000.	sendBuf := String new: 4000 withAll: $x.	receiveBuf := String new: 50000.	done := false.	bytesSent := bytesReceived := packetsSent := packetsReceived := 0.	t := Time millisecondsToRun: 					[[done] whileFalse: 							[(socket sendDone and: [bytesSent < bytesToSend]) 								ifTrue: 									[packetsSent := packetsSent + 1.									bytesSent := bytesSent + (socket sendData: sendBuf)].							socket dataAvailable 								ifTrue: 									[packetsReceived := packetsReceived + 1.									bytesReceived := bytesReceived + (socket receiveDataInto: receiveBuf)].							done := bytesSent >= bytesToSend].					[bytesReceived < bytesToSend] whileTrue: 							[socket dataAvailable 								ifTrue: 									[packetsReceived := packetsReceived + 1.									bytesReceived := bytesReceived + (socket receiveDataInto: receiveBuf)]]].	socket closeAndDestroy.	Transcript		show: 'remoteClient TCP test done; time = ' , t printString;		cr.	Transcript		show: packetsSent printString , ' packets, ' , bytesSent printString 					, ' bytes sent (' , (bytesSent * 1000 // t) printString 					, ' bytes/sec)';		cr.	Transcript		show: packetsReceived printString , ' packets, ' 					, bytesReceived printString , ' bytes received (' 					, (bytesReceived * 1000 // t) printString , ' bytes/sec)';		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!remoteTestClientTCPOpenClose1000	"Socket remoteTestClientTCPOpenClose1000"	| number t1 socket serverName |	Transcript		show: 'starting client/server TCP test';		cr.	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	number := 1000.	serverName := FillInTheBlank request: 'What is your remote Test Server?'				initialAnswer: ''.	t1 := Time millisecondsToRun: 					[number timesRepeat: 							[socket := self newTCP.							socket connectTo: (NetNameResolver addressFromString: serverName)								port: 54321.							socket waitForConnectionUntil: self standardDeadline.							socket closeAndDestroy]].	Transcript		cr;		show: 'connects/close per second ' , (number / t1 * 1000.0) printString;		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!remoteTestClientTCPOpenClosePutGet	"Socket remoteTestClientTCPOpenClosePutGet"	| checkLength number bytesExpected sendBuf receiveBuf t1 socket bytesReceived serverName |	Transcript		show: 'starting client/server TCP test';		cr.	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	serverName := FillInTheBlank request: 'What is your remote Test Server?'				initialAnswer: ''.	number := 1000.	bytesExpected := 20000.	sendBuf := String new: 80 withAll: $x.	receiveBuf := String new: 50000.	t1 := Time millisecondsToRun: 					[number timesRepeat: 							[socket := self newTCP.							socket connectTo: (NetNameResolver addressFromString: serverName)								port: 54321.							socket waitForConnectionUntil: self standardDeadline.							socket sendData: sendBuf.							socket waitForSendDoneUntil: (self deadlineSecs: 5).							socket waitForDataUntil: (self deadlineSecs: 5).							bytesReceived := 0.							[bytesReceived < bytesExpected] whileTrue: 									[checkLength := socket receiveDataInto: receiveBuf.									bytesReceived := bytesReceived + checkLength].							socket closeAndDestroy]].	Transcript		cr;		show: 'connects/get/put/close per second ' 					, (number / t1 * 1000.0) printString;		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!remoteTestClientUDP	"FIRST start up another image, and execute: Socket remoteTestServerUDP.	THEN come back to this image and execute:"	"Socket remoteTestClientUDP"	"Performa 6400/200, Linux-PPC 2.1.24:		remoteClient UDP test done; time = 4580		2500 packets, 10000000 bytes sent (2183 kBytes/sec)		180 packets, 720000 bytes received (157 kBytes/sec)		4000 bytes/packet, 39 packets/sec, 2320 packets dropped"	| socket bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t serverName |	Transcript		show: 'starting client/server UDP test';		cr.	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	serverName := FillInTheBlank request: 'What is your remote Test Server?'				initialAnswer: ''.	socket := self newUDP.	socket setPeer: (NetNameResolver addressFromString: serverName) port: 54321.	Transcript		show: 'client endpoint created';		cr.	bytesToSend := 10000000.	sendBuf := String new: 4000 withAll: $x.	receiveBuf := String new: 4000.	done := false.	bytesSent := bytesReceived := packetsSent := packetsReceived := 0.	t := Time millisecondsToRun: 					[[done] whileFalse: 							[(socket sendDone and: [bytesSent < bytesToSend]) 								ifTrue: 									[packetsSent := packetsSent + 1.									bytesSent := bytesSent + (socket sendData: sendBuf)].							socket dataAvailable 								ifTrue: 									[packetsReceived := packetsReceived + 1.									bytesReceived := bytesReceived + (socket receiveDataInto: receiveBuf)].							done := bytesSent >= bytesToSend].										[socket waitForDataUntil: (self deadlineSecs: 1).					socket dataAvailable] 							whileTrue: 								[packetsReceived := packetsReceived + 1.								bytesReceived := bytesReceived + (socket receiveDataInto: receiveBuf)]].	socket closeAndDestroy.	Transcript		show: 'remoteClient UDP test done; time = ' , t printString;		cr.	Transcript		show: packetsSent printString , ' packets, ' , bytesSent printString 					, ' bytes sent (' , (bytesSent * 1000 // t) printString 					, ' bytes/sec)';		cr.	Transcript		show: packetsReceived printString , ' packets, ' 					, bytesReceived printString , ' bytes received (' 					, (bytesReceived * 1000 // t) printString , ' bytes/sec)';		cr.	Transcript		show: (bytesSent // packetsSent) printString , ' bytes/packet, ' 					, (packetsReceived * 1000 // t) printString , ' packets/sec, ' 					, (packetsSent - packetsReceived) printString , ' packets dropped';		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!remoteTestServerTCP	"See remoteTestClientTCP for instructions on running this method."	"OldSocket remoteTestServerTCP"	| socket client buffer n |	Transcript show: 'initializing network ... '.	self initializeNetwork.	Transcript		show: 'ok';		cr.	socket := OldSocket newTCP.	socket 		listenOn: 54321		backlogSize: 5		interface: (NetNameResolver addressFromString: '127.0.0.1').	"or: 0.0.0.0"	Transcript		show: 'server endpoint created -- run client test in other image';		cr.	buffer := String new: 4000.	socket waitForConnectionUntil: self standardDeadline.	client := socket accept.	[client isConnected] whileTrue: 			[client dataAvailable 				ifTrue: 					[n := client receiveDataInto: buffer.					client sendData: buffer count: n]].	client closeAndDestroy.	socket closeAndDestroy.	Transcript		cr;		show: 'server endpoint destroyed';		cr.	^socket! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!remoteTestServerTCPOpenClose1000	"The version of #remoteTestServerTCPOpenClose1000 using the BSD style accept() mechanism."	"Socket remoteTestServerTCPOpenClose1000"	| socket server |	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	server := self newTCP.	server listenOn: 54321 backlogSize: 20.	server isValid ifFalse: [self error: 'Accept() is not supported'].	Transcript		show: 'server endpoint created -- run client test in other image';		cr.	1000 timesRepeat: 			[socket := server waitForAcceptUntil: (self deadlineSecs: 300).			socket closeAndDestroy].	server closeAndDestroy.	Transcript		cr;		show: 'server endpoint destroyed';		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!remoteTestServerTCPOpenClosePutGet	"The version of #remoteTestServerTCPOpenClosePutGet using the BSD style accept() mechanism."	"Socket remoteTestServerTCPOpenClosePutGet"	| socket server bytesIWantToSend bytesExpected receiveBuf sendBuf checkLength |	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	server := self newTCP.	server listenOn: 54321 backlogSize: 20.	server isValid ifFalse: [self error: 'Accept() is not supported'].	Transcript		show: 'server endpoint created -- run client test in other image';		cr.	bytesIWantToSend := 20000.	bytesExpected := 80.	receiveBuf := String new: 40000.	sendBuf := String new: bytesIWantToSend withAll: $x.	1000 timesRepeat: 			[socket := server waitForAcceptUntil: (self deadlineSecs: 300).			socket waitForDataUntil: (self deadlineSecs: 5).			checkLength := socket receiveDataInto: receiveBuf.			checkLength ~= bytesExpected ifTrue: [self halt].			socket sendData: sendBuf.			socket waitForSendDoneUntil: (self deadlineSecs: 5).			socket closeAndDestroy].	server closeAndDestroy.	Transcript		cr;		show: 'server endpoint destroyed';		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!remoteTestServerTCPUsingAccept	"The version of #remoteTestServer using the BSD style accept() mechanism."	"Socket remoteTestServerTCPUsingAccept"	| socket buffer n server |	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	server := self newTCP.	server listenOn: 54321 backlogSize: 4.	server isValid ifFalse: [self error: 'Accept() is not supported'].	Transcript		show: 'server endpoint created -- run client test in other image';		cr.	buffer := String new: 40000.	10 timesRepeat: 			[socket := server waitForAcceptUntil: (self deadlineSecs: 300).			[socket isConnected] whileTrue: 					[socket dataAvailable 						ifTrue: 							[n := socket receiveDataInto: buffer.							socket sendData: buffer count: n]]].	socket closeAndDestroy.	server closeAndDestroy.	Transcript		cr;		show: 'server endpoint destroyed';		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!remoteTestServerUDP	"See remoteTestClientUDP for instructions on running this method."	"Socket remoteTestServerUDP"	| socket buffer n |	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	socket := self newUDP.	socket setPort: 54321.	Transcript		show: 'server endpoint created -- run client test in other image';		cr.	buffer := String new: 4000.	[true] whileTrue: 			[socket dataAvailable 				ifTrue: 					[n := socket receiveDataInto: buffer.					socket sendData: buffer count: n]]! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!remoteTestServerUDP2	"See remoteTestClientUDP for instructions on running this method."	"Socket remoteTestServerUDP2"	| socket buffer datagramInfo |	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	socket := self newUDP.	socket setPort: 54321.	Transcript		show: 'server endpoint created -- run client test in other image';		cr.	buffer := String new: 65000.	[true] whileTrue: 			[socket dataAvailable 				ifTrue: 					[datagramInfo := socket receiveUDPDataInto: buffer.					Transcript						show: datagramInfo printString;						cr.					socket sendData: buffer count: (datagramInfo at: 1)]]! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!remoteTestSinkTCP	"See sendTest for instructions on running this method."	"Socket remoteTestSinkTCP"	| socket buffer n |	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	socket := self newTCP.	socket listenOn: 9.	Transcript		show: 'server endpoint created -- run client test in other image';		cr.	buffer := String new: 64000.	socket waitForConnectionUntil: self standardDeadline.	[socket isConnected] whileTrue: 			[socket dataAvailable ifTrue: [n := socket receiveDataInto: buffer]].	socket closeAndDestroy.	Transcript		cr;		show: 'sink endpoint destroyed';		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:10'!timeTest	"OldSocket timeTest"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	serverName := FillInTheBlank request: 'What is your time server?'				initialAnswer: 'localhost'.	serverName isEmpty 		ifTrue: 			[^Transcript				show: 'never mind';				cr].	serverAddr := NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil 		ifTrue: [self error: 'Could not find the address for ' , serverName].	s := self new.	Transcript		show: '---------- Connecting ----------';		cr.	s connectTo: serverAddr port: 13.	"13 is the 'daytime' port number"	s waitForConnectionUntil: (self deadlineSecs: 1).	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript		show: '---------- Connection Closed ----------';		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!timeTestUDP	"Socket timeTestUDP"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	serverName := FillInTheBlank request: 'What is your time server?'				initialAnswer: 'localhost'.	serverName isEmpty 		ifTrue: 			[^Transcript				show: 'never mind';				cr].	serverAddr := NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil 		ifTrue: [self error: 'Could not find the address for ' , serverName].	s := self newUDP.	"a 'random' port number will be allocated by the system"	"Send a packet to the daytime port and it will reply with the current date."	Transcript		show: '---------- Sending datagram from port ' , s port printString 					, ' ----------';		cr.	s 		sendData: '!!'		toHost: serverAddr		port: 13.	"13 is the daytime service"	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript		show: '---------- Socket closed ----------';		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!timeTestUDP2	"Socket timeTestUDP2"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	serverName := FillInTheBlank request: 'What is your time server?'				initialAnswer: 'localhost'.	serverName isEmpty 		ifTrue: 			[^Transcript				show: 'never mind';				cr].	serverAddr := NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil 		ifTrue: [self error: 'Could not find the address for ' , serverName].	s := self newUDP.	"The following associates a port with the UDP socket, but does NOT create a connectable endpoint"	s setPort: 54321.	"Send a packet to the daytime port and it will reply with the current date."	Transcript		show: '---------- Sending datagram from port ' , s port printString 					, ' ----------';		cr.	s 		sendData: '!!'		toHost: serverAddr		port: 13.	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript		show: '---------- Socket closed ----------';		cr! !!OldSocket class methodsFor: 'examples' stamp: 'nk 2/24/2005 14:38'!timeTestUDP3	"Socket timeTestUDP3"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	self initializeNetworkIfFail: [^Transcript show: 'failed'].	Transcript		show: 'ok';		cr.	serverName := FillInTheBlank request: 'What is your time server?'				initialAnswer: 'localhost'.	serverName isEmpty 		ifTrue: 			[^Transcript				show: 'never mind';				cr].	serverAddr := NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil 		ifTrue: [self error: 'Could not find the address for ' , serverName].	s := self newUDP.	"The following associates a port with the UDP socket, but does NOT create a connectable endpoint"	s setPort: self wildcardPort.	"explicitly request a default port number"	"Send a packet to the daytime port and it will reply with the current date."	Transcript		show: '---------- Sending datagram from port ' , s port printString 					, ' ----------';		cr.	s 		sendData: '!!'		toHost: serverAddr		port: 13.	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript		show: '---------- Socket closed ----------';		cr! !