'From Squeak 2.2 of Sept 23, 1998 on 31 October 1998 at 1:49:48 pm'!Object subclass: #FWT	instanceVariableNames: 'alpha beta coeffs h g hTilde gTilde samples nSamples nLevels transform '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!!FWT commentStamp: 'di 10/31/1998 09:03' prior: 0!This class implements the Fast Wavelet Transform.  It follows Mac Cody's article in Dr. Dobb's Journal, April 1992.Notable features of his implementation include...1.  The ability to generate a large family of wavelets (including the Haar (alpha=beta) and Daubechies) from two parameters, alpha and beta, which range between -pi and pi.2.  All data arrays have 5 elements added on to allow for convolution overrun with filters up to 6 in length (the max for this implementation).3.  After a forward transform, the detail coefficients of the deomposition are found in transform at: 2*i, for i = 1, 2, ... nLevels;  and the approximation coefficients are in transform at: (2*nLevels-1).  these together comprise the complete wavelet transform.The following changes from cody's listings should also be noted...1.  The three DotProduct routines have been merged into one.2.  The four routines WaveletDecomposition, DecomposeBranches, WaveletReconstruction, ReconstructBranches have all been merged into transformForward:.3.  All indexing follows the Smalltalk 1-to-N convention, naturally.!!FWT methodsFor: 'initialization' stamp: 'di 10/31/1998 12:23'!nSamples: n nLevels: nLevs	"Initialize a wavelet transform."	"Note the sample array size must be N + 5, where N is a multiple of 2^nLevels"	| dyadSize |	(n // (1 bitShift: nLevs)) > 0 ifFalse: [self error: 'Data size error'].	(n \\ (1 bitShift: nLevs)) = 0 ifFalse: [self error: 'Data size error'].	nSamples _ n.	samples _ Array new: n + 5.	nLevels _ nLevs.	transform _ Array new: nLevels*2.  "Transformed data is stored as a tree of coeffs"	dyadSize _ nSamples.	1 to: nLevels do:		[:i |  dyadSize _ dyadSize // 2.		transform at: 2*i-1 put: (Array new: dyadSize + 5).		transform at: 2*i put: (Array new: dyadSize + 5)]! !!FWT methodsFor: 'initialization' stamp: 'di 10/30/1998 10:59'!setAlpha: alph beta: bet	"Set alpha and beta, compute wavelet coeefs, and derive hFilter and lFilter"	| tcosa tcosb tsina tsinb |	alpha _ alph.	beta _ bet.	"WaveletCoeffs..."	"precalculate cosine of alpha and sine of beta"	tcosa _ alpha cos.	tcosb _ beta cos.	tsina _ alpha sin.	tsinb _ beta sin.	coeffs _ Array new: 6.		"calculate first two wavelet coefficients a _ a(-2) and b _ a(-1)"	coeffs at: 1 put: ((1.0 + tcosa + tsina) * (1.0 - tcosb - tsinb)					+ (2.0 * tsinb * tcosa)) / 4.0.	coeffs at: 2 put: ((1.0 - tcosa + tsina) * (1.0 + tcosb - tsinb)					- (2.0 * tsinb * tcosa)) / 4.0.	"precalculate cosine and sine of alpha minus beta"	tcosa _ (alpha - beta) cos.	tsina _ (alpha - beta) sin.	"calculate last four wavelet coefficients c _ a(0), d _ a(1), e _ a(2), and f _ a(3)"	coeffs at: 3 put: (1.0 + tcosa + tsina) / 2.0.	coeffs at: 4 put: (1.0 + tcosa - tsina) / 2.0.	coeffs at: 5 put: 1.0 - (coeffs at: 1) - (coeffs at: 3).	coeffs at: 6 put: 1.0 - (coeffs at: 2) - (coeffs at: 4).	"MakeFiltersFromCoeffs..."	"Select the non-zero wavelet coefficients"	coeffs _ coeffs copyFrom: (coeffs findFirst: [:c | c abs > 1.0e-14])						to: (coeffs findLast: [:c | c abs > 1.0e-14]).	"Form the low pass and high pass filters for decomposition"	hTilde _ coeffs reversed collect: [:c | c / 2.0].	gTilde _ coeffs collect: [:c | c / 2.0].	1 to: gTilde size by: 2 do:		[:i | gTilde at: i put: (gTilde at: i) negated].	"Form the low pass and high pass filters for reconstruction"	h _ coeffs copy.	g _ coeffs reversed.	2 to: g size by: 2 do:		[:i | g at: i put: (g at: i) negated]! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:19'!coeffs	"Return all coefficients neede to reconstruct the original samples"	| header csize strm |	header _ Array with: nSamples with: nLevels with: alpha with: beta.	csize _ header size.	1 to: nLevels do: [:i | csize _ csize + (transform at: i*2) size].	csize _ csize + (transform at: nLevels*2-1) size.	coeffs _ Array new: csize.	strm _ WriteStream on: coeffs.	strm nextPutAll: header.	1 to: nLevels do: [:i | strm nextPutAll: (transform at: i*2)].	strm nextPutAll: (transform at: nLevels*2-1).	^ coeffs! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:23'!coeffs: coeffArray	"Initialize this instance from the given coeff array (including header)."	| header strm |	strm _ ReadStream on: coeffArray.	header _ strm next: 4.	self nSamples: header first nLevels: header second.	self setAlpha: header third beta: header fourth.	1 to: nLevels do: [:i | transform at: i*2 put: (strm next: (transform at: i*2) size)].	transform at: nLevels*2-1 put: (strm next: (transform at: nLevels*2-1) size).	strm atEnd ifFalse: [self error: 'Data size error'].! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:26'!samples	^ samples copyFrom: 1 to: nSamples! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:25'!samples: anArray	1 to: anArray size do:		[:i | samples at: i put: (anArray at: i)].	nSamples+1 to: nSamples+5 do:		[:i | samples at: i put: 0.0]! !!FWT methodsFor: 'computation' stamp: 'di 10/31/1998 09:20'!convolveAndDec: inData dataLen: inLen filter: filter out: outData	"convolve the input sequence with the filter and decimate by two"	| filtLen offset outi dotp |	filtLen _ filter size.	outi _ 1.	1 to: inLen+9 by: 2 do:		[:i | 		i < filtLen		ifTrue:			[dotp _ self dotpData: inData endIndex: i filter: filter						start: 1 stop: i inc: 1]		ifFalse:			[i > (inLen+5)			ifTrue:				[offset _ i - (inLen+5).				dotp _ self dotpData: inData endIndex: inLen+5 filter: filter						start: 1+offset stop: filtLen inc: 1]			ifFalse:				[dotp _ self dotpData: inData endIndex: i filter: filter						start: 1 stop: filtLen inc: 1]].		outData at: outi put: dotp.		outi _ outi + 1]! !!FWT methodsFor: 'computation' stamp: 'di 10/30/1998 09:51'!convolveAndInt: inData dataLen: inLen filter: filter sumOutput: sumOutput into: outData	"insert zeros between each element of the input sequence and	   convolve with the filter to interpolate the data"	| outi filtLen oddTerm evenTerm |	outi _ 1.	filtLen _ filter size.	"every other dot product interpolates the data"	filtLen // 2 to: inLen + filtLen - 2 do:		[:i |		oddTerm _ self dotpData: inData endIndex: i filter: filter									start: 2 stop: filter size inc: 2.		evenTerm _ self dotpData: inData endIndex: i+1 filter: filter									start: 1 stop: filter size inc: 2.		sumOutput			ifTrue:				["summation with previous convolution if true"				outData at: outi put: (outData at: outi) + oddTerm.				outData at: outi+1 put: (outData at: outi+1) + evenTerm]			ifFalse:				["first convolution of pair if false"				outData at: outi put: oddTerm.				outData at: outi+1 put: evenTerm].		outi _ outi + 2].	"Ought to be able to fit this last term into the above loop."	i _ inLen + filtLen - 1.	oddTerm _ self dotpData: inData endIndex: i filter: filter									start: 2 stop: filter size inc: 2.	sumOutput		ifTrue: [outData at: outi put: (outData at: outi) + oddTerm]		ifFalse: [outData at: outi put: oddTerm].! !!FWT methodsFor: 'computation' stamp: 'di 10/31/1998 12:55'!dotpData: data endIndex: endIndex filter: filter start: start stop: stop inc: inc	| sum i j |	sum _ 0.0.	j _ endIndex.	i _ start.	[i <= stop] whileTrue:		[sum _ sum + ((data at: j) * (filter at: i)).		i _ i + inc.		j _ j - 1].	^ sum! !!FWT methodsFor: 'computation' stamp: 'di 10/30/1998 15:53'!transformForward: forward	| inData inLen outData |	forward	ifTrue:		["first InData is input signal, following are intermediate approx coefficients"		inData _ samples.  inLen _ nSamples.		1 to: nLevels do:			[:i |			self convolveAndDec: inData dataLen: inLen					filter: hTilde out: (transform at: 2*i-1).			self convolveAndDec: inData dataLen: inLen					filter: gTilde out: (transform at: 2*i).			inData _ transform at: 2*i-1.  inLen _ inLen // 2]]	ifFalse:		[inLen _ nSamples >> nLevels.		"all but last outData are next higher intermediate approximations,		last is final reconstruction of samples"		nLevels to: 1 by: -1 do:			[:i |			outData _ i = 1 ifTrue: [samples]						ifFalse: [transform at: 2*(i-1)-1].			self convolveAndInt: (transform at: 2*i-1) dataLen: inLen					filter: h sumOutput: false into: outData.			self convolveAndInt: (transform at: 2*i) dataLen: inLen					filter: g sumOutput: true into: outData.			inLen _ inLen * 2]]! !!FWT methodsFor: 'testing' stamp: 'di 10/31/1998 12:25'!doWaveDemo  "FWT new doWaveDemo"	"Printing the above should yield a small number -- I get 1.1e-32"	| originalData |	self nSamples: 312 nLevels: 3.	self setAlpha: 0.0 beta: 0.0.	"Install a sine wave as sample data"	self samples: ((1 to: nSamples) collect: [:i | ((i-1) * 0.02 * Float pi) sin]).	originalData _ samples copy.	FFT new plot: (samples copyFrom: 1 to: nSamples) in: (0@0 extent: nSamples@100).	"Transform forward and plot the decomposition"	self transformForward: true.	transform withIndexDo:		[:w :i |		FFT new plot: (w copyFrom: 1 to: w size-5)			in: (i-1\\2*320@(i+1//2*130) extent: (w size-5)@100)].	"Test copy out and read in the transform coefficients"	self coeffs: self coeffs.	"Ttransform back, plot the reconstruction, and return the error figure"	self transformForward: false.	FFT new plot: (samples copyFrom: 1 to: nSamples) in: (320@0 extent: nSamples@100).	^ self meanSquareError: originalData! !!FWT methodsFor: 'testing' stamp: 'di 10/30/1998 15:58'!meanSquareError: otherData	"Return the mean-square error between the current sample array and	some other data, presumably to evaluate a compression scheme."	| topSum bottomSum pointDiff |	topSum _ bottomSum _ 0.0.	1 to: nSamples do:		[:i |  pointDiff _ (samples at: i) - (otherData at: i).		topSum _ topSum + (pointDiff * pointDiff).		bottomSum _ bottomSum + ((otherData at: i) * (otherData at: i))].	^ topSum / bottomSum! !!FWT methodsFor: 'testing' stamp: 'di 10/30/1998 15:53'!viewPhiAndPsi  "(FWT new sampleSize: 256 nLevels: 6) viewPhiAndPsi"	"View the scaling function and mother wavelets for this transform"	| p |	Display fillWhite: (0@0 extent: 300@300).	Display border: (0@0 extent: 300@300) width: 2.	[Sensor anyButtonPressed] whileFalse:		["Move mouse around in the outer rectangle to explore"		p _ Sensor cursorPoint min: 300@300.		self setAlpha: (p x - 150) / 150.0 * Float pi				beta: (p y - 150) / 150.0 * Float pi.		'alpha=', (alpha roundTo: 0.01) printString, '   ',			'beta=', (beta roundTo: 0.01) printString, '    ' displayAt: 50@5.		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size - 1) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@30 extent: nSamples@100).		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@170 extent: nSamples@100)].	Sensor waitNoButton! !