'From Squeak 2.4c of May 10, 1999 on 9 July 1999 at 11:37:36 pm'!"Change Set:		sampledSndFix-jhmDate:			9 July 1999Author:			John MaloneyFixes a bug in SampledSound that caused a VM crash if thesound exceeded about 49 seconds. SampledSound now allowssounds up to 2^30 samples long.Add checks to prevent creating LoopedSampledSounds longerthan the primitive supports. Typically, LoopedSampledSoundsare used for sampled instruments, which are fairly short.For playing long sampled sounds (minutes or hours), usea SampledSound.Note: SampledSound's now play via a new primitive. The old primitiveis still supported for backward compatability."!AbstractSound subclass: #SampledSound	instanceVariableNames: 'initialCount count samples originalSamplingRate samplesSize scaledIndex indexHighBits scaledIncrement '	classVariableNames: 'CoffeeCupClink DefaultSampleTable IncrementFractionBits IncrementScaleFactor NominalSamplePitch ScaledIndexOverflow SoundLibrary '	poolDictionaries: ''	category: 'Music-Synthesis'!!Interpreter class methodsFor: 'initialization' stamp: 'jm 7/9/1999 22:36'!initializePrimitiveTable 	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveArrayBecomeOneWay)	"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveStoreStackp)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveBlockCopy)		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveTestDisplayDepth)			"Blue Book: primitiveCursorLocPut"		(92 primitiveSetDisplayMode)				"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)						"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveStoreImageSegment)		(99 primitiveLoadImageSegment)		(100 primitivePerformInSuperclass)		"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFlushCacheByMethod)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)			"Squeak 2.2 and earlier use 119.  Squeak 2.3 and later use 116.			Both are supported for backward compatibility."		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 primitiveDirectoryDelete)		(164 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 oldprimSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(186 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 primStringfindSubstringinstartingAtmatchTable)		(247 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveInstVarsPutFromStack) "Never used except in Disney tests.  Remove after 2.3 release."		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		(546 547 primitiveFail)		"Pen Tablet Primitives"		(548 primitiveGetTabletParameters)		(549 primitiveReadTablet)		"Sound Codec Primitives"		(550 primADPCMCodecprivateDecodeMono)			(551 primADPCMCodecprivateDecodeStereo)			(552 primADPCMCodecprivateEncodeMono)			(553 primADPCMCodecprivateEncodeStereo)			(554 569 primitiveFail)  "reserved for additional codec primitives"		"Unassigned Primitives"		(570 700 primitiveFail)).! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 7/9/1999 22:57'!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#include "sqVirtualMachine.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* pluggable primitives macros *//* Note: All pluggable primitives are defined as	EXPORT(int) somePrimitive(void)   If the platform requires special declaration modifiers   the EXPORT macro can be redefined*/#define EXPORT(returnType) returnType/* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delete(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);int ioHasDisplayDepth(int depth);int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag);/* cheap clock with coarse resolution (about 17 msecs on Mac) */# define ioLowResMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)/* optional millisecond clock macro */#ifdef USE_CLOCK_MSECS# define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)#endif/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(sqImageFile f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);int oldprimSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringfindSubstringinstartingAtmatchTable(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* serial port primitives */int serialPortClose(int portNum);int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int serialPortReadInto(int portNum, int count, int bufferPtr);int serialPortWriteFrom(int portNum, int count, int bufferPtr);/* MIDI primitives */int sqMIDIGetClock(void);int sqMIDIGetPortCount(void);int sqMIDIGetPortDirectionality(int portNum);int sqMIDIGetPortName(int portNum, int namePtr, int length);int sqMIDIClosePort(int portNum);int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate);int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIPortReadInto(int portNum, int count, int bufferPtr);int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time);/*** Experimental Asynchronous File I/O ***/typedef struct {	int			sessionID;	void		*state;} AsyncFile;int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** pluggable primitive support ***/int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength,  int moduleNameIndex, int moduleNameLength);/*** sound compression primitives ***/int primADPCMCodecprivateDecodeMono(void);int primADPCMCodecprivateDecodeStereo(void);int primADPCMCodecprivateEncodeMono(void);int primADPCMCodecprivateEncodeStereo(void);/*** tablet support ***/int tabletGetParameters(int cursorIndex, int result[]);int tabletRead(int cursorIndex, int result[]);int tabletResultSize(void);'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 7/9/1999 22:59'!squeakOldSoundPrimsFile	^ '/* Automatically generated from Squeak on (4 January 1998 3:05:25 am ) */#include "sq.h"/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Imported Functions/Variables ***/extern int stackValue(int);extern int successFlag;/*** Variables ***//*** Function Prototypes ***/int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);int primWaveTableSoundmixSampleCountintostartingAtpan(void);int oldprimSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primFMSoundmixSampleCountintostartingAtpan(void) {    int rcvr;    int n;    short int *aSoundBuffer;    int startIndex;    int pan;    int mySample;    int sample;    int lastIndex;    int channelIndex;    int i;    short int *waveTable;    int waveTableSize;    int count;    int amplitude;    int increment;    int index;    int modulation;    int offsetIncrement;    int offsetIndex;	rcvr = stackValue(4);	n = checkedIntegerValueOf(stackValue(3));	aSoundBuffer = arrayValueOf(stackValue(2));	startIndex = checkedIntegerValueOf(stackValue(1));	pan = checkedIntegerValueOf(stackValue(0));	waveTable = fetchArrayofObject(1, rcvr);	waveTableSize = fetchIntegerofObject(2, rcvr);	count = fetchIntegerofObject(4, rcvr);	amplitude = fetchIntegerofObject(6, rcvr);	increment = fetchIntegerofObject(8, rcvr);	index = fetchIntegerofObject(9, rcvr);	modulation = fetchIntegerofObject(11, rcvr);	offsetIncrement = fetchIntegerofObject(14, rcvr);	offsetIndex = fetchIntegerofObject(15, rcvr);	if (!!(successFlag)) {		return null;	}	lastIndex = (startIndex + n) - 1;	for (i = startIndex; i <= lastIndex; i += 1) {		mySample = (amplitude * (waveTable[index - 1])) / 1000;		if (pan > 0) {			channelIndex = 2 * i;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * pan) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		if (pan < 1000) {			channelIndex = (2 * i) - 1;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * (1000 - pan)) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		index = (index + increment) + ((modulation * (waveTable[offsetIndex - 1])) / 1000000);		if (index > waveTableSize) {			index -= waveTableSize;		}		if (index < 1) {			index += waveTableSize;		}		offsetIndex += offsetIncrement;		if (offsetIndex > waveTableSize) {			offsetIndex -= waveTableSize;		}	}	count -= n;	storeIntegerofObjectwithValue(4, rcvr, count);	storeIntegerofObjectwithValue(9, rcvr, index);	storeIntegerofObjectwithValue(15, rcvr, offsetIndex);	pop(4);}int primPluckedSoundmixSampleCountintostartingAtpan(void) {    int rcvr;    int n;    short int *aSoundBuffer;    int startIndex;    int pan;    int lastIndex;    int channelIndex;    int i;    int sample;    int mySample;    int thisIndex;    int nextIndex;    int count;    short int *ring;    int ringSize;    int ringIndx;	rcvr = stackValue(4);	n = checkedIntegerValueOf(stackValue(3));	aSoundBuffer = arrayValueOf(stackValue(2));	startIndex = checkedIntegerValueOf(stackValue(1));	pan = checkedIntegerValueOf(stackValue(0));	count = fetchIntegerofObject(2, rcvr);	ring = fetchArrayofObject(4, rcvr);	ringSize = fetchIntegerofObject(5, rcvr);	ringIndx = fetchIntegerofObject(6, rcvr);	if (!!(successFlag)) {		return null;	}	lastIndex = (startIndex + n) - 1;	thisIndex = ringIndx;	for (i = startIndex; i <= lastIndex; i += 1) {		nextIndex = (thisIndex % ringSize) + 1;		mySample = ((ring[thisIndex - 1]) + (ring[nextIndex - 1])) / 2;		ring[thisIndex - 1] = mySample;		thisIndex = nextIndex;		if (pan > 0) {			channelIndex = 2 * i;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * pan) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		if (pan < 1000) {			channelIndex = (2 * i) - 1;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * (1000 - pan)) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}	}	ringIndx = nextIndex;	count -= n;	storeIntegerofObjectwithValue(2, rcvr, count);	storeIntegerofObjectwithValue(6, rcvr, ringIndx);	pop(4);}int primSampledSoundmixSampleCountintostartingAtpan(void) {    int rcvr;    int n;    short int *aSoundBuffer;    int startIndex;    int pan;    int lastIndex;    int i;    int channelIndex;    int sample;    int sampleIndex;    int thisSample;    short int *samples;    int samplesSize;    int incrementTimes1000;    int count;    int indexTimes1000;	rcvr = stackValue(4);	n = checkedIntegerValueOf(stackValue(3));	aSoundBuffer = arrayValueOf(stackValue(2));	startIndex = checkedIntegerValueOf(stackValue(1));	pan = checkedIntegerValueOf(stackValue(0));	samples = fetchArrayofObject(1, rcvr);	samplesSize = fetchIntegerofObject(2, rcvr);	incrementTimes1000 = fetchIntegerofObject(3, rcvr);	count = fetchIntegerofObject(5, rcvr);	indexTimes1000 = fetchIntegerofObject(6, rcvr);	if (!!(successFlag)) {		return null;	}	lastIndex = (startIndex + n) - 1;	i = startIndex;	sampleIndex = indexTimes1000 / 1000;	while ((sampleIndex <= samplesSize) && (i <= lastIndex)) {		thisSample = samples[sampleIndex - 1];		if (pan > 0) {			channelIndex = 2 * i;			sample = (aSoundBuffer[channelIndex - 1]) + ((thisSample * pan) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		if (pan < 1000) {			channelIndex = (2 * i) - 1;			sample = (aSoundBuffer[channelIndex - 1]) + ((thisSample * (1000 - pan)) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		indexTimes1000 += incrementTimes1000;		sampleIndex = indexTimes1000 / 1000;		i += 1;	}	count -= n;	storeIntegerofObjectwithValue(5, rcvr, count);	storeIntegerofObjectwithValue(6, rcvr, indexTimes1000);	pop(4);}int primWaveTableSoundmixSampleCountintostartingAtpan(void) {    int rcvr;    int n;    short int *aSoundBuffer;    int startIndex;    int pan;    int lastIndex;    int channelIndex;    int i;    int mySample;    int sample;    short int *waveTable;    int waveTableSize;    int count;    int amplitude;    int increment;    int index;	rcvr = stackValue(4);	n = checkedIntegerValueOf(stackValue(3));	aSoundBuffer = arrayValueOf(stackValue(2));	startIndex = checkedIntegerValueOf(stackValue(1));	pan = checkedIntegerValueOf(stackValue(0));	waveTable = fetchArrayofObject(1, rcvr);	waveTableSize = fetchIntegerofObject(2, rcvr);	count = fetchIntegerofObject(4, rcvr);	amplitude = fetchIntegerofObject(6, rcvr);	increment = fetchIntegerofObject(8, rcvr);	index = fetchIntegerofObject(9, rcvr);	if (!!(successFlag)) {		return null;	}	lastIndex = (startIndex + n) - 1;	for (i = startIndex; i <= lastIndex; i += 1) {		mySample = (amplitude * (waveTable[index - 1])) / 1000;		if (pan > 0) {			channelIndex = 2 * i;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * pan) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		if (pan < 1000) {			channelIndex = (2 * i) - 1;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * (1000 - pan)) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		index += increment;		if (index > waveTableSize) {			index -= waveTableSize;		}	}	count -= n;	storeIntegerofObjectwithValue(4, rcvr, count);	storeIntegerofObjectwithValue(9, rcvr, index);	pop(4);}int oldprimSampledSoundmixSampleCountintostartingAtleftVolrightVol(void) {    int rcvr;    int n;    short int *aSoundBuffer;    int startIndex;    int leftVol;    int rightVol;    int sliceIndex;    int sampleIndex;    int sample;    int s;    int lastIndex;    int i;    int scaledVol;    int scaledVolIncr;    int scaledVolLimit;    int count;    short int *samples;    int samplesSize;    int incrementTimes1000;    int indexTimes1000;	rcvr = stackValue(5);	n = checkedIntegerValueOf(stackValue(4));	aSoundBuffer = arrayValueOf(stackValue(3));	aSoundBuffer -= 1;	startIndex = checkedIntegerValueOf(stackValue(2));	leftVol = checkedIntegerValueOf(stackValue(1));	rightVol = checkedIntegerValueOf(stackValue(0));	scaledVol = fetchIntegerofObject(3, rcvr);	scaledVolIncr = fetchIntegerofObject(4, rcvr);	scaledVolLimit = fetchIntegerofObject(5, rcvr);	count = fetchIntegerofObject(7, rcvr);	samples = fetchArrayofObject(8, rcvr);	samples -= 1;	samplesSize = fetchIntegerofObject(10, rcvr);	incrementTimes1000 = fetchIntegerofObject(11, rcvr);	indexTimes1000 = fetchIntegerofObject(12, rcvr);	if (!!(successFlag)) {		return null;	}	lastIndex = (startIndex + n) - 1;	sliceIndex = startIndex;	sampleIndex = indexTimes1000 / 1000;	while ((sampleIndex <= samplesSize) && (sliceIndex <= lastIndex)) {		sample = ((int) ((samples[sampleIndex]) * scaledVol) >> 15);		if (leftVol > 0) {			i = (2 * sliceIndex) - 1;			s = (aSoundBuffer[i]) + (((int) (sample * leftVol) >> 15));			if (s > 32767) {				s = 32767;			}			if (s < -32767) {				s = -32767;			}			aSoundBuffer[i] = s;		}		if (rightVol > 0) {			i = 2 * sliceIndex;			s = (aSoundBuffer[i]) + (((int) (sample * rightVol) >> 15));			if (s > 32767) {				s = 32767;			}			if (s < -32767) {				s = -32767;			}			aSoundBuffer[i] = s;		}		if (scaledVolIncr !!= 0) {			scaledVol += scaledVolIncr;			if (((scaledVolIncr > 0) && (scaledVol >= scaledVolLimit)) || ((scaledVolIncr < 0) && (scaledVol <= scaledVolLimit))) {				scaledVol = scaledVolLimit;				scaledVolIncr = 0;			}		}		indexTimes1000 += incrementTimes1000;		sampleIndex = indexTimes1000 / 1000;		sliceIndex += 1;	}	count -= n;	if (!!(successFlag)) {		return null;	}	storeIntegerofObjectwithValue(3, rcvr, scaledVol);	storeIntegerofObjectwithValue(4, rcvr, scaledVolIncr);	storeIntegerofObjectwithValue(7, rcvr, count);	storeIntegerofObjectwithValue(12, rcvr, indexTimes1000);	pop(5);}'! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/9/1999 22:28'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound use the given samples array with a loop of the given length starting at the given index. The loop length may have a fractional part; this is necessary to achieve pitch accuracy for short loops."	| loopStartIndex |	super initialize.	loopStartIndex _ (loopEndIndex - loopSampleCount) truncated + 1.	((1 <= loopStartIndex) and:	 [loopStartIndex < loopEndIndex and:	 [loopEndIndex <= aSoundBuffer size]])		ifFalse: [self error: 'bad loop parameters'].	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitch _ perceivedPitchInHz asFloat.	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	lastSample >= (SmallInteger maxVal // LoopIndexScaleFactor) ifTrue: [		self error: 'cannot handle more than ',			(SmallInteger maxVal // LoopIndexScaleFactor) printString, ' samples'].	loopEnd _ loopEndIndex.	scaledLoopLength _ (loopSampleCount * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/9/1999 22:28'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound play the given samples unlooped. The samples have the given perceived pitch when played at the given sampling rate. By convention, unpitched sounds such as percussion sounds should specify a pitch of nil or 100 Hz."	super initialize.	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitchInHz		ifNil: [perceivedPitch _ 100.0]		ifNotNil: [perceivedPitch _ perceivedPitchInHz asFloat].	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	lastSample >= (SmallInteger maxVal // LoopIndexScaleFactor) ifTrue: [		self error: 'cannot handle more than ',			(SmallInteger maxVal // LoopIndexScaleFactor) printString, ' samples'].	loopEnd _ leftSamples size.	scaledLoopLength _ 0.  "zero length means unlooped"	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!SampledSound methodsFor: 'initialization' stamp: 'jm 7/9/1999 19:23'!setSamples: anArray samplingRate: rate	"Set my samples array to the given array with the given nominal sampling rate. Altering the rate parameter allows the sampled sound to be played back at different pitches."	"Note: There are two ways to use sampled sound: (a) you can play them through once (supported by this method) or (b) you can make them the default waveform with which to play a musical score (supported by the class method defaultSampleTable:)."	"Assume: anArray is either a SoundBuffer or a collection of signed 16-bit sample values."	"(SampledSound		samples: SampledSound coffeeCupClink		samplingRate: 5000) play"	"copy the array into a SoundBuffer if necessary"	anArray class isWords		ifTrue: [samples _ anArray]		ifFalse: [samples _ SoundBuffer fromArray: anArray].	samplesSize _ samples size.	samplesSize >= SmallInteger maxVal ifTrue: [  "this is unlikely..."		self error: 'sample count must be under ',  SmallInteger maxVal printString].	originalSamplingRate _ rate.	initialCount _ (samplesSize * self samplingRate) // originalSamplingRate.	self loudness: 1.0.	self reset.! !!SampledSound methodsFor: 'playing' stamp: 'jm 7/9/1999 22:33'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1."	| lastIndex outIndex sampleIndex sample i s overflow |	<primitive: 185>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #samples declareC: 'short int *samples'.	lastIndex _ (startIndex + n) - 1.	outIndex _ startIndex.    "index of next stereo output sample pair"	sampleIndex _ indexHighBits + (scaledIndex >> IncrementFractionBits).	[(sampleIndex <= samplesSize) and: [outIndex <= lastIndex]] whileTrue: [		sample _ ((samples at: sampleIndex) * scaledVol) // ScaleFactor.		leftVol > 0 ifTrue: [			i _ (2 * outIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * outIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]].		scaledIndex _ scaledIndex + scaledIncrement.		scaledIndex >= ScaledIndexOverflow ifTrue: [			overflow _ scaledIndex >> IncrementFractionBits.			indexHighBits _ indexHighBits + overflow.			scaledIndex _ scaledIndex - (overflow << IncrementFractionBits)].		sampleIndex _ indexHighBits + (scaledIndex >> IncrementFractionBits).		outIndex _ outIndex + 1].	count _ count - n.! !!SampledSound methodsFor: 'playing' stamp: 'jm 7/9/1999 18:29'!reset	"Details: The sample index and increment are scaled to allow fractional increments without having to do floating point arithmetic in the inner loop."	super reset.	scaledIncrement _		((originalSamplingRate asFloat / self samplingRate) * IncrementScaleFactor) rounded.	count _ initialCount.	scaledIndex _ IncrementScaleFactor.  "index of the first sample, scaled"	indexHighBits _ 0.! !!SampledSound class methodsFor: 'class initialization' stamp: 'jm 7/9/1999 19:07'!initialize	"SampledSound initialize"	IncrementFractionBits _ 16.	IncrementScaleFactor _ 2 raisedTo: IncrementFractionBits.	ScaledIndexOverflow _ 2 raisedTo: 29.  "handle overflow before needing LargePositiveIntegers"	self useCoffeeCupClink.	SoundLibrary ifNil: [SoundLibrary _ Dictionary new].! !GraphMorph removeSelector: #loadCoffeeCupClink!SampledSound removeSelector: #setSamples:!SampledSound class removeSelector: #defaultSampleTable!SampledSound class removeSelector: #defaultSamplesFromAIFF:samplePitch:!SampledSound initialize!SampledSound class removeSelector: #leftSamples:rightSamples:samplingRate:!