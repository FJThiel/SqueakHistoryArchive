'From Squeak3.1alpha of 28 February 2001 [latest update: #4252] on 16 August 2001 at 4:06:36 pm'!"Change Set:		WindowResize-arDate:			16 August 2001Author:			Andreas RaabUse cursor feedback for resizing windows rather than plain handles."!!Cursor class methodsFor: 'instance creation' stamp: 'ar 8/16/2001 15:52'!resizeForEdge: aSymbol	"Cursor resizeForEdge: #top"	"Cursor resizeForEdge: #bottomLeft"	^self perform: ('resize', aSymbol first asString asUppercase, (aSymbol copyFrom: 2 to: aSymbol size)) asSymbol.! !!Cursor class methodsFor: 'constants' stamp: 'ar 8/16/2001 14:48'!resizeBottom	"Cursor resizeBottom showWhile: [Sensor waitButton]"	^self resizeTop! !!Cursor class methodsFor: 'constants' stamp: 'ar 8/16/2001 14:46'!resizeBottomLeft	"Cursor resizeBottomLeft showWhile: [Sensor waitButton]"	^self resizeTopRight! !!Cursor class methodsFor: 'constants' stamp: 'ar 8/16/2001 14:45'!resizeBottomRight	"Cursor resizeBottomRight showWhile: [Sensor waitButton]"	^self resizeTopLeft! !!Cursor class methodsFor: 'constants' stamp: 'ar 8/16/2001 14:50'!resizeLeft	"Cursor resizeLeft showWhile: [Sensor waitButton]"	^(Cursor extent: 16@16 fromArray: #(		2r0000000000000000		2r0000001010000000		2r0000001010000000		2r0000001010000000		2r0000101010010000		2r0001101010011000		2r0011101010011100		2r0111111011111110		2r0011101010011100		2r0001101010011000		2r0000101010010000		2r0000001010000000		2r0000001010000000		2r0000001010000000		2r0000001010000000		2r0000000000000000 )	offset: -7@-7 ) withMask! !!Cursor class methodsFor: 'constants' stamp: 'ar 8/16/2001 14:45'!resizeRight	"Cursor resizeRight showWhile: [Sensor waitButton]"	^self resizeLeft! !!Cursor class methodsFor: 'constants' stamp: 'ar 8/16/2001 14:49'!resizeTop	"Cursor resizeTop showWhile: [Sensor waitButton]" 	^(Cursor extent: 16@16 fromArray: #(		2r0000000000000000		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000111111100000		2r0000000100000000		2r0111111111111110		2r0000000000000000		2r0111111111111110		2r0000000100000000		2r0000000100000000		2r0000111111100000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000)	offset: -7@-7) withMask! !!Cursor class methodsFor: 'constants' stamp: 'ar 8/16/2001 15:58'!resizeTopLeft	"Cursor resizeTopLeft showWhile: [Sensor waitButton]"	^  (Cursor extent: 16@16 fromArray: #(		2r0000000000000000		2r0111110000010000		2r0111100000100000		2r0111000001000100		2r0110100010001000		2r0100010100010000		2r0000001000100000		2r0000010001000000		2r0000100010000000		2r0001000100100010		2r0010001000010110		2r0000010000001110		2r0000100000011110		2r0000000000111110		2r0000000000000000		2r0000000000000000)	offset: -7@-7) withMask! !!Cursor class methodsFor: 'constants' stamp: 'ar 8/16/2001 16:00'!resizeTopRight	"Cursor resizeTopRight showWhile: [Sensor waitButton]"	^ (Cursor extent: 16@16 fromArray: #(		2r0000000000000000		2r0000100000111110		2r0000010000011110		2r0010001000001110		2r0001000100010110		2r0000100010100010		2r0000010001000000		2r0000001000100000		2r0000000100010000		2r0100010010001000		2r0110100001000100		2r0111000000100000		2r0111100000010000		2r0111110000000000		2r0000000000000000		2r0000000000000000)	offset: -7@-7) withMask.! !!NewHandleMorph methodsFor: 'initialize' stamp: 'ar 8/16/2001 15:38'!delete	hand ifNotNil:[		hand showTemporaryCursor: nil.	].	super delete.! !!NewHandleMorph methodsFor: 'all' stamp: 'ar 8/16/2001 15:48'!followHand: aHand forEachPointDo: block1 lastPointDo: block2 withCursor: aCursor	hand _ aHand.	hand showTemporaryCursor: aCursor "hotSpotOffset: aCursor offset negated".	borderWidth _ 0.	color _ Color transparent.	pointBlock _ block1.	lastPointBlock _ block2.	self position: hand lastEvent cursorPoint - (self extent // 2)! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'ar 8/16/2001 15:51'!spawnOffsetReframeHandle: event divider: divider	"The mouse has crossed a secondary (fixed-height) pane divider.  Spawn a reframe handle."	"Only supports vertical adjustments."	| siblings topAdjustees bottomAdjustees topOnly bottomOnly resizer pt delta minY maxY cursor |	allowReframeHandles ifFalse: [^ self].	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) ifTrue:  [^ self].	((self world ifNil: [^ self]) firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[^ self  "Prevent multiple handles"].	divider layoutFrame ifNil: [^ self].	(#(top bottom) includes: divider resizingEdge) ifFalse: [^ self].	siblings _ divider owner submorphs select: [:m | m layoutFrame notNil ].	divider resizingEdge = #bottom ifTrue:		[		cursor _ Cursor resizeTop.		topAdjustees _ siblings select: [:m |			m layoutFrame topFraction = divider layoutFrame bottomFraction and:				[m layoutFrame topOffset >= divider layoutFrame topOffset] ].		bottomAdjustees _ siblings select: [:m |			m layoutFrame bottomFraction = divider layoutFrame topFraction and:				[m layoutFrame bottomOffset >= divider layoutFrame topOffset] ].		].	divider resizingEdge = #top ifTrue:		[		cursor _ Cursor resizeBottom.		topAdjustees _ siblings select: [:m |			m layoutFrame topFraction = divider layoutFrame bottomFraction and:				[m layoutFrame topOffset <= divider layoutFrame bottomOffset] ].		bottomAdjustees _ siblings select: [:m |			m layoutFrame bottomFraction = divider layoutFrame topFraction and:				[m layoutFrame bottomOffset <= divider layoutFrame bottomOffset] ].		].	topOnly := topAdjustees copyWithoutAll: bottomAdjustees.	bottomOnly := bottomAdjustees copyWithoutAll: topAdjustees.	(topOnly isEmpty or: [bottomOnly isEmpty]) ifTrue: [^self].	minY := bottomOnly inject: -9999 into: [:y :m | 		y max: m top + (m minHeight max: 16) + (divider bottom - m bottom)].	maxY := topOnly inject: 9999 into: [:y :m |		y min: m bottom - (m minHeight max: 16) - (m top - divider top)].	pt _ event cursorPoint.	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo: [:p |			delta := (p y min: maxY max: minY) - pt y.			topAdjustees do:				[:m | m layoutFrame topOffset: m layoutFrame topOffset + delta ].			bottomAdjustees do:				[:m | m layoutFrame bottomOffset: m layoutFrame bottomOffset + delta ].			divider layoutChanged.			pt := pt + delta.		]		lastPointDo: [:p | ]		withCursor: cursor.	event hand world addMorphInLayer: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'ar 8/16/2001 16:03'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds adjoiningPanes limit cursor |	(self world firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[ ^ self  "Prevent multiple handles"].	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	"don't resize pane side coincident with window side - RAA 5 jul 2000"	(growingPane perform: side) = (self innerBounds perform: side) ifTrue: [^self].	(side == #top and: [growingPane top = self panelRect top]) ifTrue: [^self].	adjoiningPanes _ paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side].	limit _ adjoiningPanes isEmpty		ifFalse: [ (adjoiningPanes collect: [:pane | pane bounds perform: side])			perform: ((#(top left) includes: side) ifTrue: [#max] ifFalse: [#min])]		ifTrue: [self bounds perform: side].	cursor _ Cursor resizeForEdge: side.	resizer _ NewHandleMorph new		sensorMode: self fastFramingOn;		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ growingPane bounds withSideOrCorner: side setToPoint: localPt minExtent: 40@20 limit: limit.			self fastFramingOn 			ifTrue:				["For fast display, only higlight the rectangle during loop"				Cursor currentCursor == cursor ifFalse:[					event hand visible: false; refreshWorld; visible: true.					cursor show].				newBounds _ growingPane bounds				  newRectButtonPressedDo:					[:f | growingPane bounds withSideOrCorner: side							setToPoint: (self pointFromWorld: Sensor cursorPoint)							minExtent: 40@20 limit: limit].					self reframePanesAdjoining: growingPane along: side						to: newBounds]			ifFalse:				[self reframePanesAdjoining: growingPane along: side to: newBounds]]		lastPointDo: [:p | ]		withCursor: cursor.	event hand world addMorphInLayer: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'ar 8/16/2001 16:03'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds cursor |	allowReframeHandles ifFalse: [^ self].	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) ifTrue:  [^ self].	((self world ifNil: [^ self]) firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[^ self  "Prevent multiple handles"].	pt _ event cursorPoint.	"prevent spurios mouse leave when dropping morphs"	owner morphsInFrontOf: self overlapping: (pt-2 extent: 4@4)		do:[:m| (m fullContainsPoint: pt) ifTrue:[^self]].	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	cursor _ Cursor resizeForEdge: ptName.	resizer _ NewHandleMorph new		sensorMode: self fastFramingOn;		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ self bounds				withSideOrCorner: ptName				setToPoint: localPt				minExtent: self minimumExtent.			self fastFramingOn 			ifTrue:				[Cursor currentCursor == cursor ifFalse:[					event hand visible: false; refreshWorld; visible: true.					cursor show].				self doFastWindowReframe: ptName]			ifFalse:				[self bounds: newBounds.				(Preferences roundedWindowCorners					and: [#(bottom right bottomRight) includes: ptName])					ifTrue:					["Complete kluge: causes rounded corners to get painted correctly,					in spite of not working with top-down displayWorld."					ptName = #bottom ifFalse:						[self invalidRect: (self bounds topRight - (6@0) extent: 7@7)].					ptName = #right ifFalse:						[self invalidRect: (self bounds bottomLeft - (0@6) extent: 7@7)].					self invalidRect: (self bounds bottomRight - (6@6) extent: 7@7)]]]		lastPointDo:			[:p | ]		withCursor: cursor.	event hand world addMorphInLayer: resizer.	resizer startStepping! !