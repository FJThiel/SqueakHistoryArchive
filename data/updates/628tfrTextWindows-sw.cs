'From Squeak 2.3 of January 14, 1999 on 1 February 1999 at 3:16:52 pm'!"Change Set:		tfrTextWindows-swDate:			2 February 1999Author:			Scott WallaceA couple of utility methods that allow you to transport multiple text windows from one image to another and from one project to another.  Transcript windows are specifically excluded.  You can transport sets of text windows from any project (morphic or mvc), to any other project, (morphic or mvc), in the same image or in any other image.To use:In any project that has one or more workspaces or other text-windows you wish to transport, evaluate an expression of the form   Utilities storeTextWindowContentsToFileNamed: 'TextWindows'	(use any file name you wish)To create text windows with the same contents in another image or another project, evaluate an expression of the form:	Utilities reconstructTextWindowsFromFileNamed: 'TextWindows'Also fixes a bad bug in RealEstateAgent in the morphic/nonstagger case, and makes a small but significant change to StringHolder.contents: so that StringHolders can hold text, not just strings.  This is as agreed with Dan earlier -- there may be consequences here and there but we will track them down and deal with them."!!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'sw 1/5/1999 01:43'!initialFrameFor: aView	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen."	| allOrigins screenRight screenBottom initialExtent putativeOrigin putativeFrame allowedArea staggerOrigin otherFrames |	Preferences reverseWindowStagger ifTrue:		[^ self strictlyStaggeredInitialFrameFor: aView].	allowedArea _ Display usableArea.	screenRight _ allowedArea right.	screenBottom _ allowedArea bottom.	initialExtent _ aView initialExtent.	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: World satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	allOrigins _ otherFrames collect: [:f | f origin].	self standardPositions do:  "First see if one of the standard positions is free"		[:aPosition | (allOrigins includes: aPosition)			ifFalse:				[^ (aPosition extent: initialExtent) squishedWithin: allowedArea]].	staggerOrigin _ self standardPositions first.  "Fallback: try offsetting from top left"	putativeOrigin _ staggerOrigin.	[putativeOrigin _ putativeOrigin + StaggerOffset.	putativeFrame _ putativeOrigin extent: initialExtent.	(putativeFrame bottom < screenBottom) and:					[putativeFrame right < screenRight]]				whileTrue:					[(allOrigins includes: putativeOrigin)						ifFalse:							[^ (putativeOrigin extent: initialExtent) squishedWithin: allowedArea]].	^ (self scrollBarSetback @ self screenTopSetback extent: initialExtent) squishedWithin: allowedArea! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 12/22/1998 00:16'!openLabel: aString 	"Create a standard system view of the model, me, a StringHolder and open it.  If in mvc, terminate the active controller so that the new window will immediately be activated."	self openLabel: aString andTerminate: true! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 12/22/1998 00:14'!openLabel: aString andTerminate: terminateBoolean	"Create a standard system view of the model, me, a StringHolder and open it.; do not terminate the active process if in mvc"	| topView codeView |	World ifNotNil: [^ self openAsMorphLabel: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView _ PluggableTextView on: self 			text: #contents accept: #acceptContents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	"self contents size > 0 ifTrue: [			codeView hasUnacceptedEdits: true].  Is it already saved or not??"	terminateBoolean		ifTrue:			[topView controller open]		ifFalse:			[topView controller openNoTerminate]! !!StringHolder methodsFor: 'accessing' stamp: 'sw 1/12/1999 11:47'!contents: textOrString 	"Set textOrString to be the contents of the receiver."	contents _ textOrString "asString"! !!SystemWindow methodsFor: 'panes' stamp: 'sw 1/14/1999 10:52'!holdsTranscript	"ugh"	| plug |	^ paneMorphs size == 1 and: [((plug _ paneMorphs first) isKindOf: PluggableTextMorph) and: [plug model isKindOf: TranscriptStream]]! !!SystemWindow methodsFor: 'panes' stamp: 'sw 12/21/1998 23:24'!titleAndPaneText	"If the receiver represents a workspace, return an Association between the title and that text, else return nil"	(paneMorphs size ~~ 1 or: [(paneMorphs first isKindOf: PluggableTextMorph) not])		ifTrue: [^ nil].	^ labelString -> paneMorphs first text! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 1/5/1999 01:30'!reconstructTextWindowsFromFileNamed: aName	"Utilities reconstructTextWindowsFromFileNamed: 'TextWindows'"	| aReferenceStream aDict |	aReferenceStream _ ReferenceStream fileNamed: aName.	aDict _ aReferenceStream next.	aReferenceStream close.	aDict associationsDo:		[:assoc |			(StringHolder new contents: assoc value) openLabel: assoc key andTerminate: false].	Smalltalk isMorphic ifFalse:		[ScheduledControllers restore.		Processor terminateActive]! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 1/5/1999 01:30'!storeTextWindowContentsToFileNamed: aName	"Utilities storeTextWindowContentsToFileNamed: 'TextWindows'"	| windows aDict assoc aRefStream textToUse aTextView |	aDict _ Dictionary new.	Smalltalk isMorphic		ifTrue:			[windows _ World submorphs select: [:m | m isKindOf: SystemWindow].			windows do:				[:w | assoc _ w titleAndPaneText.				assoc ifNotNil:					[w holdsTranscript ifFalse:						[aDict add: assoc]]]]		ifFalse:			[windows _ ScheduledControllers controllersSatisfying:				[:c | (c model isMemberOf: StringHolder) or: [c model isKindOf: Workspace]].			windows do:				[:aController | 					aTextView _ aController view subViews detect: [:m | m isKindOf: PluggableTextView] ifNone: [nil].					textToUse _ aTextView						ifNil:		[aController model contents]						ifNotNil:	[aTextView controller text].  "The latest edits, whether accepted or not"					aDict at: aController view label put: textToUse]].	aDict size = 0 ifTrue: [^ self inform: 'no windows found to export.'].	aRefStream _ ReferenceStream fileNamed: aName.	aRefStream nextPut: aDict.	aRefStream close.	self inform: 'Done!!  ', aDict size printString, ' window(s) exported.'! !!Utilities class methodsFor: 'common requests' stamp: 'sw 1/29/1999 00:35'!initializeCommonRequestStrings	"Initialize an array of common request strings.  2/1/96 sw"	CommonRequestStrings _ StringHolder new contents: 'Utilities emergencyCollapseUtilities closeAllDebuggersSensor keyboardCursor normal show----------------------------------ScriptingSystem inspectFormDictionaryPreferences enable: #showTimeStampsInMenuTitlesPreferences enable: #cmdDotEnabledForm fromUser bitEditDisplay border: (0@0 extent: 640@480) width: 2----------------------------------Undeclared inspectUndeclared removeUnreferencedKeys; inspectTranscript clearChangeSorter removeEmptyUnnamedChangeSetsUtilities reconstructTextWindowsFromFileNamed: ''TextWindows''.Utilities storeTextWindowContentsToFileNamed: ''TextWindows'''"Utilities initializeCommonRequestStrings"! !!Utilities class methodsFor: 'common requests' stamp: 'sw 1/22/1999 14:02'!offerCommonRequests	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| reply result aMenu index normalItemCount strings |	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].	strings _ CommonRequestStrings contents.	normalItemCount _ strings asString lineCount.	aMenu _ PopUpMenu labels: (strings asString, 'edit this menu') lines: (Array with: normalItemCount).	index _ aMenu startUp.	index == 0 ifTrue: [^ self].	reply _ aMenu labelString lineNumber: index.	reply size == 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editCommonRequestStrings].	result _ self evaluate: reply in: nil to: nil.	(result isKindOf: Number) | (result isKindOf: String)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."!