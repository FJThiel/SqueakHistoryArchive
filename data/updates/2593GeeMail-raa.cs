'From Squeak2.9alpha of 17 July 2000 [latest update: #2592] on 10 September 2000 at 1:16:08 pm'!"Change Set:		GeeMailDate:			6 September 2000Author:			Bob Arning- a text-with-morphs-on-the-side widget for Alan. You can get one from the new morph menu under GeeMail.- to add a morph, just drop it on the right side- to link/unlink a morph's y pos to some text or to delete the morph,--select a word in the text--pick the appropriate item from the red menu on the morph7 Sept 2000 - enabled drag selection of multiple morphs- removed the blue handle and moved link commands to red menuTO DO LIST- adjust x position of morphs?- overlap of morphs??"!ScrollPane subclass: #AlansTextPlusMorph	instanceVariableNames: 'theTextMorph thePasteUp '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-GeeMail'!!AlansTextPlusMorph commentStamp: '<historical>' prior: 0!The code is here, but the class you really want to use is GeeMailMorph (nicer name).!AlansTextPlusMorph subclass: #GeeMailMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-GeeMail'!!GeeMailMorph commentStamp: '<historical>' prior: 0!Well, what can I say? GeeMail is a scrolling playfield with a text morph (typically on the left) and room on the right for other morphs to be placed. The morphs on the right can be linked to text selections on the left so that they remain positioned beside the pertinent text as the text is reflowed. Probably the best thing is and example and Alan will be making some available soon.!TextAnchor subclass: #TextAnchorPlus	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-GeeMail'!TextAction subclass: #TextPlusJumpStart	instanceVariableNames: 'evalString '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-GeeMail'!TextMorph subclass: #TextPlusMorph	instanceVariableNames: 'scrollerOwner '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-GeeMail'!PasteUpMorph subclass: #TextPlusPasteUpMorph	instanceVariableNames: 'theTextMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-GeeMail'!!CharacterScanner methodsFor: 'as yet unclassified' stamp: 'RAA 9/6/2000 13:31'!setYFor: anchoredMorph! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'RAA 9/6/2000 15:56'!setYFor: anchoredMorph	anchoredMorph top: (lineY - morphicOffset y).	^ true! !!Morph methodsFor: 'menus' stamp: 'RAA 9/10/2000 13:15'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	aCustomMenu add: 'add drop-shadow' action: #addDropShadow.	(self isKindOf: SystemWindow)		ifFalse: [aCustomMenu add: 'put in a window' action: #embedInWindow].	aCustomMenu addUpdating: #stickinessString target: self action: #toggleStickiness.	aCustomMenu add: 'adhere to edge...' action: #adhereToEdge.	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aCustomMenu hand: aHandMorph].	(owner isKindOf: TextPlusPasteUpMorph) ifTrue: [		aCustomMenu add: 'GeeMail stuff...' subMenu: (owner textPlusMenuFor: self)	].! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 11:41'!adjustPasteUpSize	| newBottom |	thePasteUp ifNil: [^self].	newBottom _ thePasteUp bottom max: thePasteUp boundingBoxOfSubmorphs bottom + 20.	thePasteUp height: newBottom - thePasteUp top.	thePasteUp width: (thePasteUp width max: scroller innerBounds width - 5).! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 11:55'!drawOn: aCanvas	super drawOn: aCanvas.! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 15:33'!handlesMouseDown: evt	^false! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 12:02'!initialize	super initialize.	color _ Color white.	thePasteUp _ TextPlusPasteUpMorph new borderWidth: 0; color: color.	scroller addMorph: thePasteUp.	theTextMorph _ TextPlusMorph new position: 4@4; scrollerOwner: self.	thePasteUp theTextMorph: theTextMorph.	self position: 100@100.	self extent: Display extent // 3.	self useRoundedCorners.! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 11:32'!layoutChanged	self setScrollDeltas.	super layoutChanged.	self adjustPasteUpSize.! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 11:58'!leftoverScrollRange	"Return the entire scrolling range minus the currently viewed area."	^ self totalScrollRange - bounds height max: 0! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/10/2000 13:08'!mouseUp: evt inMorph: aMorph	evt hand grabMorph: aMorph	"old instances may have a handler we no longer use"! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/6/2000 16:15'!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere selectionInterval |	selectionInterval _ theTextMorph editor selectionInterval.	selRects _ theTextMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform localPointToGlobal: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ transform localBoundsToGlobal: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	selRect bottom > bounds bottom ifTrue: [		self scrollBy: 0@(bounds bottom - selRect bottom - 30).		^ true	].	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 11:42'!wantsDroppedMorph: aMorph event: evt	"Return true if the receiver wishes to accept the given morph, which is being dropped by a hand in response to the given event. The default implementation returns false.NOTE: the event is assumed to be in global (world) coordinates."	^false! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/6/2000 16:25'!wantsSlot	^false! !!AlansTextPlusMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 9/10/2000 12:52'!includeInNewMorphMenu	^ false		"to encourage the use of GeeMail instead"! !!GeeMailMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 9/10/2000 12:52'!includeInNewMorphMenu	^ true! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 9/9/2000 19:16'!testEvent: evt ifQuickClick: quickClickBlock ifMoved: movedBlock	| firstPt |	"The mouse just went down.  Pause briefly and then check to see whether it is still down and whether it has moved a significant amount; evaluate quickClickBlock or movedBlock as appropriate."	firstPt _ Sensor cursorPoint.	"evt may be translated from normal coords"	(Delay forMilliseconds: 200) wait.	Sensor anyButtonPressed ifFalse: [^ quickClickBlock value].	((Sensor cursorPoint - firstPt) abs < (3@3)) ifFalse: [^ movedBlock value]! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 9/7/2000 16:56'!grabMorphInner: aMorph	"The real work of grabbing a morph.  Set up a command object to represent the forthcoming move (in support of Undo), then actually wrench the morph out of its old home and add it as one of MY submorphs."	| myPos morphPos localPt trans morphToGrab newT w |	formerOwner _ aMorph owner.	formerPosition _ aMorph position.	(formerOwner notNil and: [(aMorph isKindOf: NewHandleMorph orOf: MenuMorph) not]) ifTrue:		[(currentCommand _ Command new)			cmdWording: 'move ', (aMorph externalName truncateTo: 10);			undoTarget: aMorph				selector: #undoMove:redo:owner:bounds:predecessor:				arguments: {currentCommand. false. formerOwner. aMorph bounds. (formerOwner morphPreceding: aMorph)}].	"Check if the morph will keep its transform while grabbed"	myPos _ self position.	morphPos _ aMorph position.	w _ aMorph world ifNil: [self worldUnderCursor]. 	aMorph keepsTransform ifTrue: [		localPt _ myPos	] ifFalse: [		"fix grabbing new morph in embedded world"		localPt _ (w globalPointToLocal: myPos) truncated.	].		(formerOwner == nil		or: [aMorph keepsTransform			or: [(trans _ formerOwner transformFromOutermostWorld) isPureTranslation]]) ifTrue: [		formerOwner ifNotNil: [			localPt _ (formerOwner transformFrom: w) globalPointToLocal: localPt.		].		aMorph position: myPos + (morphPos - localPt).		morphToGrab _ aMorph.		addedFlexAtGrab _ false.	] ifFalse: ["Morph was in a flexed environment.  Flex it in the hand."		morphToGrab _ aMorph addFlexShell transform: trans asMorphicTransform.		aMorph position: morphPos.  "revert offset from addFlexShell"		newT _ trans withOffset: (trans offset + (trans localPointToGlobal: localPt) - myPos).		morphToGrab position: (morphToGrab localPointToGlobal: morphToGrab position).		morphToGrab transform: newT.		addedFlexAtGrab _ true.	].	(morphToGrab isKindOf: PhraseTileMorph) ifTrue:		[morphToGrab position: Sensor cursorPoint].	self addMorphBack: morphToGrab! !!HandMorph methodsFor: 'from EToyHand' stamp: 'RAA 9/9/2000 18:53'!makeNewDrawingInBounds: rect pasteUpMorph: aPasteUpMorph	| w newSketch newPlayer sketchEditor aPaintBox aPalette tfx |	self world assureNotPaintingElse: [^ self].	aPalette _ aPasteUpMorph standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new player: (newPlayer _ UnscriptedPlayer newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: aPasteUpMorph.	sketchEditor		afterNewPicDo: [:aForm :aRect |			newSketch form: aForm.tfx _ aPasteUpMorph transformFrom: aPasteUpMorph world.			newSketch position: (tfx globalPointToLocal: aRect origin).			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch setupAngle: sketchEditor forwardDirection.			newSketch privateOwner: aPasteUpMorph.  "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			aPasteUpMorph addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			self presenter drawingJustCompleted: newSketch]		 ifNoBits:			[(aPaintBox _ self world paintBox) ifNotNil:				[aPaintBox delete].			aPalette ifNotNil: [aPalette showNoPalette].]! !!PolygonMorph methodsFor: 'object fileIn' stamp: 'RAA 9/9/2000 18:31'!convertbosfcebbvcfqaahb0: varDict bosfcebbvcfaascpphb0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'vertices' 'closed' 'filledForm' 'arrows' 'arrowForms' 'handles' 'borderForm').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('smoothCurve' 'coeffs' 'ptAfterFirst' 'ptBeforeLast')  If a non-nil value is needed, please assign it."	"These are going away #('quickFill').  Possibly store their info in another variable?"	smoothCurve _ false.! !!CurveMorph methodsFor: 'object fileIn' stamp: 'RAA 9/9/2000 18:18'!convertbosfcebbvcfqaahbcnn0: varDict bosfcebbvcfaascpphbcnn0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'vertices' 'closed' 'filledForm' 'arrows' 'arrowForms' 'handles' 'borderForm' 'coefficients' 'ntfPoint' 'ntlPoint').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('smoothCurve' 'coeffs' 'ptAfterFirst' 'ptBeforeLast')  If a non-nil value is needed, please assign it."	"These are going away #('quickFill').  Possibly store their info in another variable?"! !!SelectionMorph methodsFor: 'initialization' stamp: 'RAA 9/7/2000 12:20'!extendByHandPlus: aHand	"Assumes selection has just been created and added to some pasteUp or world"	| startPoint handle localPt |	startPoint _ self position.	handle _ NewHandleMorph new 		followHand: aHand		forEachPointDo: [ :newPoint | 			localPt _ (self transformFrom: self world) globalPointToLocal: newPoint.			self bounds: (startPoint rect: localPt)		]		lastPointDo: [ :newPoint | 			selectedItems isEmpty ifTrue: [self delete] ifFalse: [self doneExtending]		].	aHand attachMorph: handle.	handle startStepping.! !!TextAnchorPlus methodsFor: 'as yet unclassified' stamp: 'RAA 9/6/2000 13:32'!emphasizeScanner: scanner	scanner setYFor: anchoredMorph! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/6/2000 16:18'!addAlansAnchorFor: aMorph	| ed attribute selRects |	self removeAlansAnchorFor: aMorph.	ed _ self editor.	attribute _ TextAnchorPlus new anchoredMorph: aMorph.	ed replaceSelectionWith: (ed selection addAttribute: attribute).	selRects _ self paragraph selectionRects.	selRects isEmpty ifFalse: [		aMorph top: selRects first top	].	self releaseParagraphReally.	self layoutChanged.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 15:42'!doYellowButtonPress: evt	| menu selection aMorph |aMorph _ nil.	menu _ CustomMenu new.	menu 		add: 'Define as jump target' 		action: [self addAlansAnchorFor: aMorph];		add: 'Unlink from text selection' 		action: [self removeAlansAnchorFor: aMorph];		add: 'Delete' 		action: [			self removeAlansAnchorFor: aMorph.			aMorph delete.		].	selection _ menu build startUpCenteredWithCaption: 'Morph linking options'.	selection ifNil: [^self].	selection value.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/6/2000 15:55'!extent: aPoint 	self releaseParagraphReally.	super extent: aPoint ! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 11:51'!handleInteraction: interactionBlock fromEvent: evt		super handleInteraction: interactionBlock fromEvent: evt.	scrollerOwner ifNil: [^self].	scrollerOwner scrollSelectionIntoView: nil.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 16:25'!mouseDown: evt	"evt yellowButtonPressed ifTrue: [		^self doYellowButtonPress: evt	]."	^super mouseDown: evt! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/6/2000 15:50'!releaseEditor! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/6/2000 15:49'!releaseParagraph! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/6/2000 15:52'!releaseParagraphReally	"Paragraph instantiation is lazy -- it will be created only when needed"	editor ifNotNil: [		self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.		editor _ nil].	paragraph ifNotNil: [paragraph _ nil].	container ifNotNil: [container releaseCachedState]! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 15:22'!removeAlansAnchorFor: aMorph	| anchors |	anchors _ OrderedCollection new.	text runs withStartStopAndValueDo: [:start :stop :attributes |		attributes do: [:att |			(att isMemberOf: TextAnchorPlus) ifTrue: [				(att anchoredMorph == aMorph or: [att anchoredMorph world isNil]) ifTrue: [					anchors add: {att. start. stop}				]			]		]	].	anchors do: [ :old |		text removeAttribute: old first from: old second to: old third.	].! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 11:50'!scrollerOwner: x	scrollerOwner _ x! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 16:23'!textPlusMenuFor: aMorph	| menu |	menu _ MenuMorph new.	menu 		add: 'Link to text selection' 		target: [self addAlansAnchorFor: aMorph] fixTemps		selector: #value;		add: 'Unlink from text selection' 		target: [self removeAlansAnchorFor: aMorph] fixTemps		selector: #value;		add: 'Delete' 		target: [			self removeAlansAnchorFor: aMorph.			aMorph delete.		] fixTemps		selector: #value.	^menu! !!TextPlusMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 9/6/2000 16:26'!includeInNewMorphMenu	^ false! !!TextPlusPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 16:25'!acceptDroppingMorph: aMorph event: evt	(aMorph isKindOf: NewHandleMorph) ifTrue: [^self].	self addMorph: aMorph.! !!TextPlusPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/10/2000 12:55'!dragThroughOnDesktop: evt	"Draw out a selection rectangle"	| selection |	"globalPt _ (self transformFrom: self world) localPointToGlobal: evt cursorPoint."	selection _ SelectionMorph newBounds: (evt cursorPoint extent: 8@8).	self addMorph: selection.	^ selection extendByHandPlus: evt hand! !!TextPlusPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/10/2000 13:02'!handlesMouseDown: evt	| localPt |	localPt _ (self transformFrom: self world) globalPointToLocal: evt cursorPoint.	submorphs do: [ :each | (each fullBounds containsPoint: localPt) ifTrue: [^false]].	^ true! !!TextPlusPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/10/2000 12:56'!mouseDown: evt	"Handle a mouse down event."	evt hand 		testEvent: evt		ifQuickClick: ["^ self" "quickClickOnDesktop: evt"]		ifMoved: [^ self dragThroughOnDesktop: evt].! !!TextPlusPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 16:19'!textPlusMenuFor: aMorph	^theTextMorph textPlusMenuFor: aMorph! !!TextPlusPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 11:53'!theTextMorph: x	self addMorph: (theTextMorph _ x)! !!TextPlusPasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 12:02'!includeInNewMorphMenu	^ false! !