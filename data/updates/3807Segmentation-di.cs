'From Squeak3.1alpha of 28 February 2001 [latest update: #3816] on 8 March 2001 at 8:57:41 pm'!"Change Set:		SegmentingChangesDate:			5 March 2001Author:			Dan IngallsSeveral changes that make it possible to partition a current Squeak 3.1 image into a kernel image plus about a dozen segments.Also includes changes to discoverActiveClasses with support for analyzing the specific history of each first reference to a class during the discovery process.Also a number of changes that reduce the incidence of gratuitous references to classes that aren't really in use, thus reducing the need to (download and) bring in non-kernel segments.There are still a number of kinks in this process, but it has produces a full current 3.1alpha image with a 4MB kernel with 16 segments, capable of downloading a project over the internet with no need to bring in any of the peripheral segments.The following changes were made to the image before final segmentation:	Smalltalk removeFromStartUpList: Applescript.	Smalltalk removeFromStartUpList: ExternalObject.	Smalltalk removeFromShutDownList: MailDB.	Smalltalk removeFromShutDownList: PWS."!!Behavior methodsFor: 'accessing' stamp: 'di 3/7/2001 17:05'!methodDict	methodDict == nil ifTrue: [self recoverFromMDFaultWithTrace].	^ methodDict! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 3/7/2001 17:05'!recoverFromMDFault	"This method handles methodDict faults to support, eg, discoverActiveClasses (qv)."	(organization isMemberOf: Array) ifFalse: [^ self error: 'oops'].	methodDict _ organization first.	organization _ organization second.! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 3/7/2001 16:16'!recoverFromMDFaultWithTrace	"This method handles emthodDict faults to support, eg, discoverActiveClasses (qv)."	self recoverFromMDFault.	Smalltalk at: #MDFaultDict ifPresent:		[:faultDict | faultDict at: self name put:			(String streamContents:				[:strm | (thisContext stackOfSize: 20) do: [:item | strm print: item; cr]])]"Execute the following statement to induce MD fault tracing.  This means that, not only will all active classes be recorded but, after a test run, MDFaultDict will contain, for every class used, a stack trace showing how it came to be used.  This statement should be executed just prior to any such text, in order to clear the traces.	Smalltalk at: #MDFaultDict put: Dictionary new."! !!ClassDescription methodsFor: 'organization' stamp: 'di 3/7/2001 17:05'!organization	"Answer the instance of ClassOrganizer that represents the organization 	of the messages of the receiver."	organization ifNil:		[organization _ ClassOrganizer defaultList: 						self methodDict keys asSortedCollection asArray].	(organization isMemberOf: Array) ifTrue:		[self recoverFromMDFaultWithTrace].	^ organization! !!ClassDescription methodsFor: 'compiling' stamp: 'di 3/7/2001 17:08'!compile: code notifying: requestor trailer: bytes 		ifFail: failBlock		elseSetSelectorAndNode: selAndNodeBlock	"Intercept this message in order to remember system changes.	 5/15/96 sw: modified so that if the class does not wish its methods logged in the changes file, then they also won't be accumulated in the current change set.	7/12/96 sw: use wantsChangeSetLogging to determine whether to put in change set"	| methodNode selector newMethod priorMethodOrNil |	methodNode _ self compilerClass new				compile: code				in: self				notifying: requestor				ifFail: failBlock.	selector _ methodNode selector.	selAndNodeBlock value: selector value: methodNode.	requestor ifNotNil:		["Note this change for recent submissions list"		Utilities noteMethodSubmission: selector forClass: self].	methodNode encoder requestor: requestor.  "Why was this not preserved?"	newMethod _ methodNode generate: bytes.	priorMethodOrNil _ (self methodDict includesKey: selector)		ifTrue: [self compiledMethodAt: selector]		ifFalse: [nil].	Smalltalk changes noteNewMethod: newMethod forClass: self		selector: selector priorMethod: priorMethodOrNil.	self addSelector: selector withMethod: newMethod.	^ newMethod! !!Debugger methodsFor: 'private' stamp: 'di 3/7/2001 15:30'!process: aProcess controller: aController context: aContext isolationHead: projectOrNil	super initialize.	Smalltalk at: #MessageTally ifPresentAndInMemory: [:c | c new close].	contents _ nil. 	interruptedProcess _ aProcess.	interruptedController _ aController.	contextStackTop _ aContext.	self newStack: (contextStackTop stackOfSize: 1).	contextStackIndex _ 1.	externalInterrupt _ false.	selectingPC _ true.	isolationHead _ projectOrNil! !!Dictionary methodsFor: 'accessing' stamp: 'di 3/7/2001 15:29'!at: key ifPresentAndInMemory: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| v |	v _ self at: key ifAbsent: [^ nil].	v isInMemory ifFalse: [^ nil].	^ aBlock value: v! !!Form methodsFor: 'displaying' stamp: 'di 3/7/2001 15:30'!displayResourceFormOn: aForm	"a special display method for blowing up resource thumbnails"	| engine tx cmap blitter |	self extent = aForm extent ifTrue:[^self displayOn: aForm].	Smalltalk at: #B3DRenderEngine ifPresentAndInMemory:		[:engineClass | engine _ engineClass defaultForPlatformOn: aForm].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aForm boundingBox;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	tx _ self asTexture.	(blitter _ BitBlt current toForm: tx)		sourceForm: self; destRect: aForm boundingBox;		sourceOrigin: 0@0;		combinationRule: Form paint.	"map transparency to current World background color"	(World color respondsTo: #pixelWordForDepth:) ifTrue: [		cmap _ Bitmap new: (depth <= 8 ifTrue: [1 << self depth] ifFalse: [4096]).		cmap at: 1 put: (World color pixelWordForDepth: tx depth).		blitter colorMap: cmap.	].	blitter copyBits.	engine viewport: aForm boundingBox.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: tx.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.	"the above, using bilinear interpolation doesn't leave transparent pixel values intact"	(WarpBlt current toForm: aForm)		sourceForm: self destRect: aForm boundingBox;		combinationRule: Form and;		colorMap: (Color maskingMap: self depth);		warpBits.! !!ImageSegmentRootStub methodsFor: 'fetch from disk' stamp: 'di 3/4/2001 22:45'!doesNotUnderstand: aMessage 	 | segmentName |"Any normal message sent to this object is really intended for another object that is in a non-resident imageSegment.  Reinstall the segment and resend the message."	segmentName _ imageSegment segmentName.	imageSegment install.	LoggingFaults ifTrue:		"Save the stack printout to show who caused the fault"		[FaultLogs at: Time millisecondClockValue printString			put: (String streamContents:				[:strm | 				strm nextPutAll: segmentName; cr.				strm print: self class; space; print: aMessage selector; cr.				(thisContext sender stackOfSize: 30)					do: [:item | strm print: item; cr]])].	"NOTE:  The following should really be (aMessage sentTo: self)		in order to recover properly from a fault in a super-send,		however, the lookupClass might be bogus in this case, and it's		almost unthinkable that the first fault would be a super send."	^ self perform: aMessage selector withArguments: aMessage arguments! !!ImageSegment class methodsFor: 'testing' stamp: 'di 3/7/2001 17:07'!discoverActiveClasses   "ImageSegment discoverActiveClasses" 	"Run this method, do a few things, maybe save and resume the image.	This will leave unused classes with MDFaults.	You MUST follow this soon by activeClasses, or by swapOutInactiveClasses."	"NOTE:  discoverActiveClasses uses Squeak's ability to detect and recover from faults due to a nil method dictionary.  It staches the method dict in with the organization during the time when discovery is in progress (Gag me with a spoon).  This is why the faults need to be cleared promptly before resuming normal work with the system.  It is also important that classes *do not* refer directly to their method dictionary, but only via the accessor message."	| ok |	Smalltalk allClasses do:		[:c | ok _ true.		#(Array Object Class Message MethodDictionary) do:			[:n | ((Smalltalk at: n) == c or:				[(Smalltalk at: n) inheritsFrom: c]) ifTrue: [ok _ false]].		ok ifTrue: [c induceMDFault]]."	ImageSegment discoverActiveClasses.		-- do something typical --	PopUpMenu notify: ImageSegment activeClasses size printString , ' classes were active out of ' ,			Smalltalk allClasses size printString."! !!Project methodsFor: 'menu messages' stamp: 'di 3/7/2001 15:35'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess |	(world isKindOf: StringMorph) ifTrue: [		self inform: 'This project is not all here. I will try to load a complete version.'.		^self loadFromServer: true	"try to get a fresh copy"	].	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [			CurrentProject finalExitActions.			CurrentProject makeThumbnail.			returningFlag == #specialReturn ifTrue: [				ProjectHistory forget: CurrentProject.		"this guy is irrelevant"				Project forget: CurrentProject.			] ifFalse: [				ProjectHistory remember: CurrentProject.			].		].	(revertFlag | saveForRevert | forceRevert) ifFalse: [		(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [			self storeToMakeRoom]].	CurrentProject abortResourceLoading.	Smalltalk isMorphic ifTrue: [Display bestGuessOfCurrentWorld triggerClosingScripts].		"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresentAndInMemory:					[:playerClass | playerClass allSubInstancesDo:						[:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject _ nil	] ifFalse: [		returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ Display pauseMorphicEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[Display changeMorphicWorldTo: world.  "Signifies Morphic"			world install.			world transferRemoteServerFrom: old world.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[Display changeMorphicWorldTo: nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		world repairEmbeddedWorlds.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess _ [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'di 3/3/2001 08:47'!spaceReclaimed	"Reclaim space from the EToy system, and return the number of bytes reclaimed"	"ScriptingSystem spaceReclaimed"	| oldFree  |	oldFree _ Smalltalk garbageCollect.	ThumbnailMorph recursionReset.	Player removeUninstantiatedSubclassesSilently.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	^ Smalltalk garbageCollect - oldFree.! !!SystemDictionary methodsFor: 'retrieving' stamp: 'di 3/7/2001 15:20'!poolUsers 	"Answer a dictionary of pool name -> classes that refer to it."	"Smalltalk poolUsers"	| poolUsers pool refs |	poolUsers _ Dictionary new.	Smalltalk keys do:		[:k | ((pool _ Smalltalk at: k) isKindOf: Dictionary) ifTrue:			[refs _ Smalltalk allClasses select: [:c | c sharedPools identityIncludes: pool]						thenCollect: [:c | c name].			refs add: (Smalltalk allCallsOn: (Smalltalk associationAt: k)).			poolUsers at: k put: refs]].	^ poolUsers! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 3/3/2001 08:31'!cleanUpUndoCommands	"Smalltalk cleanUpUndoCommands"  "<== print this to get classes involved"	| classes i p |	classes _ Bag new.	'Ferreting out obsolete undo commands'		displayProgressAt: Sensor cursorPoint		from: 0 to: Morph withAllSubclasses size		during:	[:bar | i _ 0.	Morph withAllSubclassesDo:		[:c | bar value: (i _ i+1).		c allInstancesDo:			[:m | (p _ m otherProperties) ifNotNil:				[p keys do:					[:k | (p at: k) class == Command ifTrue:						[classes add: c name.						m removeProperty: k]]]]]].	^ classes! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 3/7/2001 15:18'!computeImageSegmentation	"Smalltalk computeImageSegmentation""Here's how the segmentation works:For each partition, we collect the classes involved, and also all messages no longer used in the absence of this partition.  We start by computing a 'Miscellaneous' segment of all the unused classes in the system as is."	|  partitions unusedCandM newClasses expandedCandM |	partitions _ Dictionary new.	unusedCandM _ Smalltalk unusedClassesAndMethodsWithout: {{}. {}}.	partitions at: 'Miscellaneous' put: unusedCandM.	newClasses _ Array streamContents:		[:s | (SystemOrganization categoriesMatching: 'VMConstruction-*') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'VMConstruction' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | (SystemOrganization categoriesMatching: 'ST80-*') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'ST80' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | (SystemOrganization categoriesMatching: 'Morphic-Games') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'Games' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | (SystemOrganization categoriesMatching: 'Morphic-Remote') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'Nebraska' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | ((SystemOrganization categoriesMatching: 'Network-*')				copyWithoutAll: #('Network-Kernel' 'Network-Url' 'Network-Protocols' 'Network-ObjectSocket')) do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'Network' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | (SystemOrganization categoriesMatching: 'Balloon3D-*') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'Balloon3D' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | (SystemOrganization categoriesMatching: 'FFI-*') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'FFI' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | (SystemOrganization categoriesMatching: 'Genie-*') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'Genie' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | (SystemOrganization categoriesMatching: 'Speech-*') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'Speech' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | #('Morphic-Components') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	newClasses _ newClasses copyWithoutAll: #(ComponentLikeModel).	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'Components' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | #('Sound-Scores' 'Sound-Interface') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	newClasses _ newClasses , #(WaveletCodec Sonogram FWT AIFFFileReader).	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'Sound' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | ((SystemOrganization categoriesMatching: 'Tools-*') copyWithout: 'Tools-Menus') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	newClasses _ newClasses copyWithoutAll: #(Debugger Inspector ContextVariablesInspector SyntaxError ChangeSet ChangeRecord ClassChangeRecord ChangeList VersionsBrowser).	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'Tools' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | (SystemOrganization categoriesMatching: 'Balloon-MMFlash*') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	newClasses _ newClasses , #(ADPCMCodec).	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'Flash' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | (SystemOrganization categoriesMatching: 'Balloon-TrueType*') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'TrueType' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	newClasses _ Array streamContents:		[:s | (SystemOrganization categoriesMatching: 'Graphics-Files') do:			[:cat | (SystemOrganization superclassOrder: cat) do: [:c | s nextPut: c name]]].	expandedCandM _ Smalltalk unusedClassesAndMethodsWithout: {unusedCandM first asArray , newClasses. unusedCandM second}.	partitions at: 'GraphicFiles' put:		{(expandedCandM first copyWithoutAll: unusedCandM first) addAll: newClasses; yourself.		expandedCandM second copyWithoutAll: unusedCandM second}.	unusedCandM _ expandedCandM.	#(	#AliceConstants 'Balloon3D'		#B3DEngineConstants 'Balloon3D'		#WonderlandConstants 'Balloon3D'		#FFIConstants 'FFI'		#KlattResonatorIndices 'Speech') pairsDo:			[:poolName :part | (partitions at: part) first add: poolName].	partitions keysDo: [:k | k = 'Miscellaneous' ifFalse:		[(partitions at: 'Miscellaneous') first removeAllFoundIn:	(partitions at: k) first]].	^ partitions! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 3/8/2001 20:55'!writeImageSegmentsFrom: segmentDictionary withKernel: kernel	"segmentDictionary is associates segmentName -> {classNames. methodNames},	and kernel is another set of classNames determined to be essential.	Add a partition, 'Secondary' with everything not in partitions and not in the kernel.	Then write segments based on this partitioning of classes."	| metas secondary dups segDict overlaps classes n symbolHolder |	"First, put all classes that are in no other partition, and not in kernel into a new partition called 'Secondary'.  Also remove any classes in kernel from putative partitions."	secondary _ Smalltalk classNames asIdentitySet.	segmentDictionary keysDo:		[:segName |		secondary removeAllFoundIn: (segmentDictionary at: segName) first.		(segmentDictionary at: segName) first removeAllFoundIn: kernel].	secondary removeAllFoundIn: kernel.	secondary removeAllFoundIn: #(PseudoContext TranslatedMethod Utilities Preferences OutOfScopeNotification FakeClassPool CurrentProjectRefactoring BlockCannotReturn FormSetFont ExternalSemaphoreTable NetNameResolver ScreenController InterpreterPlugin Command WeakSet).	FileDirectory allSubclassesDo: [:c | secondary remove: c name ifAbsent: []].	segmentDictionary at: 'Secondary' put: {secondary. {}}.	"Now build segDict giving className -> segName, and report any duplicates."	dups _ Dictionary new.	segDict _ IdentityDictionary new: 3000.	segmentDictionary keysDo:		[:segName | (segmentDictionary at: segName) first do:			[:className |			(segDict includesKey: className) ifTrue:				[(dups includesKey: className) ifFalse: [dups at: className put: Array new].				dups at: className put: (dups at: className) , {segName}].			segDict at: className put: segName]].	dups size > 0 ifTrue: [dups inspect.  ^ self error: 'Duplicate entries'].	"Then for every class in every partition, make sure that neither it	nor any of its superclasses are in any other partition.  If they are,	enter them in a dictionary of overlaps.	If the dictionary is not empty, then stop and report it."	overlaps _ Dictionary new.	segmentDictionary keysDo:		[:segName |  		classes _ (segmentDictionary at: segName) first asArray collect: [:k | Smalltalk at: k].		classes do:			[:c | (c isKindOf: Class) ifTrue:				[c withAllSuperclasses do:					[:sc | n _ segDict at: sc name ifAbsent: [segName].					n ~= segName ifTrue:						[n = 'Secondary'							ifTrue: [(segmentDictionary at: 'Secondary') first										remove: sc name ifAbsent: []]							ifFalse: [overlaps at: c name put: 										(c withAllSuperclasses collect: [:cc | segDict associationAt: cc name ifAbsent: [cc name -> 'Kernel']])]]]]]].	overlaps size > 0 ifTrue: [overlaps inspect.  ^ self error: 'Superclasses in separate segments'].	"If there are no overlaps, then proceed to write the partitioned classes."	symbolHolder _ Symbol allInstances.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	segmentDictionary keysDo:		[:segName |  Utilities informUser: segName during:			[classes _ (segmentDictionary at: segName) first asArray collect: [:k | Smalltalk at: k].			metas _ classes select: [:c | c isKindOf: Class] thenCollect: [:c | c class].			(ImageSegment new copyFromRoots: classes , metas sizeHint: 0) extract; 					writeToFile: segName]].	symbolHolder.  "Keep compiler for getting uppity."! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 3/3/2001 09:26'!zapAllOtherProjects 	"Smalltalk zapAllOtherProjects""Note: as of this writing, the only reliable way to get rid of all but the current project is te execute the following, one line at a time...		Smalltalk zapAllOtherProjects.		ProjectHistory currentHistory initialize.		Smalltalk garbageCollect.		Project rebuildAllProjects."		Project allInstancesDo: [:p | p setParent: nil].	Project current setParent: Project current.	Project current isMorphic ifTrue: [ScheduledControllers _ nil].	TheWorldMenu allInstancesDo: [:m | 1 to: m class instSize do: [:i | m instVarAt: i put: nil]].	ChangeSorter classPool at: #AllChangeSets put: nil.	Project classPool at: #AllProjects put: nil.	ProjectHistory currentHistory initialize.	ChangeSorter initialize.	Project rebuildAllProjects.  "Does a GC"	Project allProjects size > 1 ifTrue: [Project allProjects inspect]! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 3/7/2001 01:26'!send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument	"Send the message #startUp: or #shutDown: to each class named in the list.	The argument indicates if the system is about to quit (for #shutDown:) or if	the image is resuming (for #startUp:).	If any name cannot be found, then remove it from the list."	| removals class |	removals _ OrderedCollection new.	startUpOrShutDownList do:		[:name |		class _ self at: name ifAbsent: [nil].		class == nil			ifTrue: [removals add: name]			ifFalse: [class isInMemory ifTrue:						[class perform: startUpOrShutDown with: argument]]].	"Remove any obsolete entries, but after the iteration"	startUpOrShutDownList removeAll: removals! !!SystemOrganizer methodsFor: 'remove' stamp: 'di 3/3/2001 16:07'!categoriesMatching: matchString	"Return all matching categories"	^ self categories select: [:c | matchString match: c]! !!SystemOrganizer methodsFor: 'remove' stamp: 'di 3/3/2001 16:08'!removeCategoriesMatching: matchString	"Remove all matching categories with their classes"	(self categoriesMatching: matchString) do:		[:c | self removeSystemCategory: c]! !!Utilities class methodsFor: 'recent method submissions' stamp: 'di 3/7/2001 08:45'!purgeRecentSubmissionsOfMissingMethods	"Utilities purgeRecentSubmissionsOfMissingMethods"	| keep |	RecentSubmissions _ RecentSubmissions select:		[:aSubmission | Utilities setClassAndSelectorFrom: aSubmission in: 				[:aClass :aSelector |				keep _ (aClass == nil) not					and: [aClass isInMemory					and: [(aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil]]].		keep]! !Object class removeSelector: #copyMethodDictionaryFrom:!