'From Squeak2.9alpha of 12 June 2000 [latest update: #2535] on 29 August 2000 at 11:16:43 pm'!"Change Set:		BetterGriddingDate:			29 August 2000Author:			Dan IngallsGridding is now specified in PasteUpMorphs rather than the hand -- see 'playfield options...'.Grid origin can be specified as well as the modulus.The grid can be made visible or hidden."!Morph subclass: #HandMorph	instanceVariableNames: 'eventSubscribers keyboardFocus mouseDownMorph mouseOverMorphs mouseOverTimes dragOverMorphs clickClient clickState firstClickEvent firstClickTime userInitials lastEvent eventTransform argument targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset grid gridOn remoteConnections transmitBuffer lastEventTransmitted lastWorldExtent menuTargetOffset hasChanged savedPatch suppressDrawing formerOwner formerPosition addedFlexAtGrab currentCommand '	classVariableNames: 'DoubleClickTime NormalCursor PasteBuffer '	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Kernel'!!InfiniteForm methodsFor: 'displaying' stamp: 'di 8/25/2000 00:26'!displayOnPort: aPort at: offset	| targetBox patternBox savedMap top left |	(patternForm isKindOf: Form) ifFalse: [		"patternForm is a Pattern or Color; just use it as a mask for BitBlt"		^ aPort fill: aPort clipRect fillColor: patternForm rule: Form over].	"do it iteratively"	targetBox _ aPort clipRect.	patternBox _ patternForm boundingBox.	savedMap _ aPort colorMap.	aPort sourceForm: patternForm;		fillColor: nil;		combinationRule: Form paint;		sourceRect: (0@0 extent: patternBox extent);		colorMap: (patternForm colormapIfNeededForDepth: aPort destForm depth).	top _ (targetBox top truncateTo: patternBox height) "- (offset y \\ patternBox height)".	left _  (targetBox left truncateTo: patternBox width) "- (offset x \\ patternBox width)".	left to: (targetBox right - 1) by: patternBox width do:		[:x | top to: (targetBox bottom - 1) by: patternBox height do:			[:y | aPort destOrigin: x@y; copyBits]].	aPort colorMap: savedMap.! !!Morph methodsFor: 'geometry' stamp: 'di 8/25/2000 00:35'!gridPoint: ungriddedPoint	^ ungriddedPoint! !!Morph methodsFor: 'geometry' stamp: 'di 8/28/2000 17:48'!griddedPoint: ungriddedPoint	| griddingContext |	(griddingContext _ self pasteUpMorph) ifNil: [^ ungriddedPoint].	^ griddingContext gridPoint: ungriddedPoint! !!Morph methodsFor: 'e-toy support' stamp: 'di 8/29/2000 20:46'!gridFormOrigin: origin grid: smallGrid background: backColor line: lineColor	| bigGrid gridForm gridOrigin |	gridOrigin _ origin \\ smallGrid.	bigGrid _ (40 roundTo: smallGrid asPoint x) @ (40 roundTo: smallGrid asPoint y).	gridForm _ Form extent: bigGrid depth: Display depth.	backColor ifNotNil: [gridForm fillWithColor: backColor].	gridOrigin x to: gridForm width by: smallGrid x do:		[:x | gridForm fill: (x@0 extent: 1@gridForm height) fillColor: lineColor].	gridOrigin y to: gridForm height by: smallGrid y do:		[:y | gridForm fill: (0@y extent: gridForm width@1) fillColor: lineColor].	^ InfiniteForm with: gridForm! !!Morph methodsFor: 'e-toy support' stamp: 'di 8/24/2000 16:31'!makeGraphPaperGrid: smallGrid background: backColor line: lineColor	| gridForm |	gridForm _ self gridFormOrigin: 0@0 grid: smallGrid background: backColor line: lineColor.	self color: (InfiniteForm with: gridForm).	self world ifNotNil: [self world fullRepaintNeeded].	self changed: #newColor.  "propagate to view"! !!BorderedMorph methodsFor: 'menu' stamp: 'di 8/24/2000 14:05'!changeBorderWidth: evt	| handle origin aHand |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	handle _ HandleMorph new forEachPointDo:		[:newPoint | handle removeAllMorphs.		handle addMorph:			(PolygonMorph vertices: (Array with: origin with: newPoint)				color: Color black borderWidth: 1 borderColor: Color black).		self borderWidth: (newPoint - origin) r asInteger // 5].	aHand attachMorph: handle.	handle startStepping! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'di 8/24/2000 14:05'!changeBorderWidth: evt	| handle origin aHand |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	handle _ HandleMorph new forEachPointDo:		[:newPoint | handle removeAllMorphs.		handle addMorph:			(PolygonMorph vertices: (Array with: origin with: newPoint)				color: Color black borderWidth: 1 borderColor: Color black).		self borderWidth: (newPoint - origin) abs // 5].	aHand attachMorph: handle.	handle startStepping! !!HaloMorph methodsFor: 'private' stamp: 'di 8/28/2000 17:48'!doDrag: evt with: dragHandle	target setConstrainedPositionFrom:		(target griddedPoint: (evt cursorPoint - positionOffset)). "evt is local here"! !!HaloMorph methodsFor: 'private' stamp: 'di 8/29/2000 21:01'!doGrow: evt with: growHandle	"Called while the mouse is down in the grow handle"	| newExtent extentToUse aCommand |	newExtent _ (target pointFromWorld: (target griddedPoint: evt cursorPoint - positionOffset))								- target topLeft.	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].	target renderedMorph extent: (extentToUse _ newExtent max: minExtent).	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.	(aCommand _ self valueOfProperty: #command) ifNotNil:  "There is a command I need to nurture along"		[aCommand parameterAt: #newExtent put: extentToUse.		aCommand redoBlock:			[:aCmd | aCmd commandee target extent: (aCmd parameterAt: #newExtent)]]! !!HandMorph methodsFor: 'initialization' stamp: 'di 8/28/2000 19:12'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	mouseOverMorphs _ OrderedCollection new.	dragOverMorphs _ OrderedCollection new.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	cachedCanvasHasHoles _ false.	remoteConnections _ OrderedCollection new.	lastEventTransmitted _ MorphicEvent new.	temporaryCursor _ temporaryCursorOffset _ nil! !!HandMorph methodsFor: 'geometry' stamp: 'di 8/28/2000 19:13'!position: aPoint	"Overridden to align submorph origins to the grid if gridding is on."	| adjustedPosition |	adjustedPosition := aPoint.	temporaryCursor ifNotNil: [adjustedPosition := adjustedPosition + temporaryCursorOffset].	^ super position: adjustedPosition! !!HandMorph methodsFor: 'event handling' stamp: 'di 8/29/2000 21:59'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown: evt."Transcript show: m printString; cr."	m ifNotNil:		[aHalo _ m world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [m world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				clickState == #firstClickDown					ifTrue: [clickClient click: firstClickEvent]					ifFalse:					["ensure that at least one mouseMove: is reported for each mouse transaction:"					m mouseMove: (localEvt copy setType: #mouseMove).					(m handlesMouseOverDragging: localEvt) ifTrue:						["If m also handles dragOver, enter it in the list"						dragOverMorphs add: m.						mouseOverMorphs remove: m ifAbsent: []]]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab					ifNotNil:						[self grabMorph: rootForGrab]					ifNil:						[self newMouseFocus: m   "trigger automatic viewing, for example"]].		mouseOverTimes removeKey: m ifAbsent: []]! !!HandMorph methodsFor: 'event handling' stamp: 'di 8/28/2000 18:59'!processEvents	"Process user input events from the local input devices.	Note: Ugly as it is, several places in Morphic currently rely on sending at least one mouse event per cycle. There's no way around this so we're checking if the first event is a mouse event and if not, we synthesize one.	Another interesting problem. Morphic is always supposed to run in an event driven environment but for now it is possible that a Morphic window is run from MVC so that we have to synthesize events in the sensor. That's quite a bit of a problem because it means that we'll get endless mouse events. To compensate for this, EventSensor will always return keyboard events first if synthesized so if we're running into a mouse event AND Sensor doesn't have an event queue we can safely break out of the event processing loop. See also EventSensor>>nextEventSynthesized."	| evt currentExtent evtBuf type hadMouse |	hadMouse _ false. "see first note above"	[evtBuf _ Sensor nextEvent.	evtBuf isNil and:[hadMouse]] whileFalse:[		evtBuf == nil ifTrue:[			"Make us a fake mouse event so hadMouse will be true"			evtBuf _ Array with: EventTypeMouse							with: Time millisecondClockValue							with: lastEvent cursorPoint x							with: lastEvent cursorPoint y							with: (lastEvent buttons bitAnd: 7)							with: (lastEvent buttons bitShift: 3)].		evt _ nil. "for unknown event types"		type _ evtBuf at: 1.		type = EventTypeMouse ifTrue:[			hadMouse _ true.			evt _ MorphicEvent new				setMousePoint: (evtBuf at: 3) @ (evtBuf at: 4)				buttons: (evtBuf at: 5)				modifiers: (evtBuf at: 6)				lastEvent: lastEvent				hand: self].		(type = EventTypeKeyboard) ifTrue:[			evt _ MorphicEvent new				setKeyValue: (evtBuf at: 3)				type: (evtBuf at: 4)				mousePoint: self position				modifiers: (evtBuf at: 5)				hand: self].		"All other events are ignored"		(evt notNil and:[remoteConnections size > 0]) ifTrue: [			"Transmit the event to interested listeners"			currentExtent _ self worldBounds extent.			lastWorldExtent ~= currentExtent ifTrue: [				self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).				lastWorldExtent _ currentExtent].			self transmitEvent: evt].		"Finally, handle it"		self handleEvent: evt.		"See the note on running a World in MVC in the method comment"		(hadMouse and:[Sensor eventQueue == nil]) ifTrue:[^self].	].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 8/28/2000 19:02'!attachMorph: m	"Position the center of the given morph under this hand, then grab it.	This method is used to grab far away or newly created morphs."	| delta |	delta _ m bounds extent // 2.	m position: (formerPosition _ self position - delta).	self addMorphBack: m.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 8/29/2000 22:31'!dropMorphsEvent: evt 	"Drop all the morphs this hand is currently holding in response to the 	given event."	"Details: All submorphs of the front-most composite morph under the 	hand are given an opportunity to accept the dropping morph. If none 	of these accepts it, or if there is no morph under the hand, then the 	morph drops into the world."	| newOwner morphToDrop localPt grabbedMorph pos worldUnderCursor |	worldUnderCursor _ self worldUnderCursor.	worldUnderCursor		ifNil: [^ self].	self changed.	self		submorphsReverseDo: [:m | 			"drop in reverse order to maintain back-to-front ordering"			addedFlexAtGrab == true				ifTrue: [pos _ m firstSubmorph position.					grabbedMorph _ m removeFlexShell.					self privateRemoveMorph: grabbedMorph.					grabbedMorph position: pos					"undo offset from removeFlexShell"]				ifFalse: [grabbedMorph _ m].			newOwner _ self dropTargetFor: grabbedMorph event: evt.			newOwner				ifNil: ["Drop not allowed"					self rejectDropMorph: grabbedMorph event: evt.					addedFlexAtGrab == true						ifTrue: [self privateRemoveMorph: m.							addedFlexAtGrab _ false].					^ self].			"Transcript show: newOwner printString; cr."			morphToDrop _ newOwner morphToDropFrom: grabbedMorph.			morphToDrop == grabbedMorph				ifFalse: [submorphs size == 1						ifTrue: [self privateRemoveMorph: m.							m privateOwner: nil.							addedFlexAtGrab _ false]].			"the above says: the thing to drop is not what I was carrying; 			silently vaporize what I was carrying lest it cause trouble 			later; keep the owner/submorph relationship invariant, but 			don't go through the standard delete protocol"			localPt _ newOwner globalPointToLocal: self position.			addedFlexAtGrab == true				ifTrue: [morphToDrop position: (localPt + (morphToDrop position								- (m transform globalPointToLocal: self position))) rounded.					self privateRemoveMorph: m.					addedFlexAtGrab _ false]				ifFalse: [morphToDrop position:							(newOwner gridPoint:								(newOwner globalPointToLocal: morphToDrop position) rounded)].			newOwner acceptDroppingMorph: morphToDrop event: evt.			morphToDrop justDroppedInto: newOwner event: evt.			morphToDrop owner = self				ifTrue: [self world addMorphFront: m]].	currentCommand ifNotNil:		[Command rememberCommand: currentCommand.		currentCommand _ nil].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 8/29/2000 22:59'!grabMorphInner: aMorph	"The real work of grabbing a morph.  Set up a command object to represent the forthcoming move (in support of Undo), then actually wrench the morph out of its old home and add it as one of MY submorphs."	| myPos morphPos localPt trans morphToGrab newT commandee newOwner newBounds newPredecessor oldOwner oldPredecessor |	formerOwner _ aMorph owner.	formerPosition _ aMorph position.	(formerOwner notNil and: [(aMorph isKindOf: NewHandleMorph orOf: MenuMorph) not]) ifTrue:		[currentCommand _ Command new commandee: aMorph.		currentCommand cmdWording: 'move ', (aMorph externalName truncateTo: 10).		currentCommand parameterAt: #oldOwner put: formerOwner.		currentCommand parameterAt: #oldBounds put: aMorph bounds.		currentCommand parameterAt: #oldPredecessor put: (formerOwner morphPreceding: aMorph).		currentCommand undoBlock:			[:cmd | 				(commandee _ cmd commandee) owner					ifNil:						[self beep]					ifNotNil:						[cmd parameterAt: #newOwner put: (newOwner _ commandee owner).						cmd parameterAt: #newBounds put: (newBounds _ commandee bounds).						cmd parameterAt: #newPredecessor put: (newPredecessor _ (commandee owner morphPreceding: commandee)).						(oldOwner _ cmd parameterAt: #oldOwner) ifNotNil:								[(oldPredecessor _ cmd parameterAt: #oldPredecessor)									ifNil:										[oldOwner addMorphBack: commandee]									ifNotNil:										[oldOwner addMorph: commandee after: oldPredecessor]].						commandee bounds: (cmd parameterAt: #oldBounds).						(commandee isKindOf: SystemWindow) ifTrue: [commandee activate]]].		currentCommand redoBlock:			[:cmd | 				(newOwner _ cmd parameterAt: #newOwner) ifNotNil:					[commandee _ cmd commandee.					(newPredecessor _ cmd parameterAt: #newPredecessor)						ifNil:							[newOwner addMorphBack: commandee]						ifNotNil:							[newOwner ifNotNil: [newOwner addMorph: commandee after: newPredecessor]].					commandee bounds: newBounds.					(commandee isKindOf: SystemWindow) ifTrue: [commandee activate]]]].	"Check if the morph will keep its transform while grabbed"	myPos _ self position.	morphPos _ aMorph position.	localPt _ (aMorph keepsTransform "or: [formerOwner isNil]")		ifTrue:[myPos]		ifFalse:[((aMorph world ifNil: [self worldUnderCursor]) 							globalPointToLocal: myPos) truncated].						"fix grabbing new morph in embedded world"	(formerOwner == nil		or: [aMorph keepsTransform			or: [(trans _ formerOwner transformFromOutermostWorld) isPureTranslation]]) ifTrue: [		aMorph position: myPos + (morphPos - localPt).		morphToGrab _ aMorph.		addedFlexAtGrab _ false.	] ifFalse: ["Morph was in a flexed environment.  Flex it in the hand."		morphToGrab _ aMorph addFlexShell transform: trans asMorphicTransform.		aMorph position: morphPos.  "revert offset from addFlexShell"		newT _ trans withOffset: (trans offset + (trans localPointToGlobal: localPt) - myPos).		morphToGrab position: (morphToGrab localPointToGlobal: morphToGrab position).		morphToGrab transform: newT.		addedFlexAtGrab _ true.	].	(morphToGrab isKindOf: PhraseTileMorph) ifTrue:		[morphToGrab position: Sensor cursorPoint].	self addMorphBack: morphToGrab! !!HandMorph methodsFor: 'world menu' stamp: 'di 8/28/2000 19:18'!gridOnString	^ self world griddingOn		ifTrue:			['turn gridding off']		ifFalse:			['turn gridding on']! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 8/28/2000 17:49'!resizeMorph	| handle minExtent |	argument isAlignmentMorph		ifTrue: [minExtent _ argument minWidth @ argument minHeight]		ifFalse: [minExtent _ 1@1].	handle _ HandleMorph new forEachPointDo:		[:newPoint | argument extent: (((argument griddedPoint: newPoint)											 - argument bounds topLeft)										max: minExtent)].	self attachMorph: handle.	handle startStepping.! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 8/28/2000 19:33'!setGridSize	| response result |	response _ FillInTheBlank			request:'Gridding control has moved to the ''playfield options...'' menuand is now local to each pasteUp or playfield.  Just to be nice,though, you may still set the grid for the world here.New grid size: '			initialAnswer: self world gridModulus printString.	response isEmpty ifTrue: [^ self].	result _ Compiler evaluate: response.	self world griddingOn ifFalse: [self world griddingOnOff].	((result isKindOf: Point) and: [(result > (0@0)) & (result < (37 @ 37))]) ifTrue:		[^ self world gridModulus: result].	((result isKindOf: SmallInteger) and: [(result > 0) & (result < 37)]) ifTrue:		[^ self world gridModulus: result @ result].	self inform: 'Must be a Point or an Integer withcoordinates between 1 & 36'	! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 8/28/2000 19:34'!setGridding	PopUpMenu notify:'Gridding control has moved to the ''playfield options...''menu and is now local to each pasteUp or playfield.Just to be nice, though, we''ll assume you wish to' , self gridOnString , ' for the world'.	self world griddingOnOff! !!HandMorph methodsFor: 'special gestures' stamp: 'di 8/28/2000 22:40'!specialDrag: evt	"Special drag (cmd-mouse on the Macintosh) allows a morph to be dragged without grabbing it and thus without removing it from its owner or changing its z-order." 	| halo itsOwner |	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	mouseDownMorph		ifNil:    ["Waiting for more than 5 pixels move to start drag"				(self position dist: targetOffset) > 5					ifTrue: [(halo _ self world haloMorphOrNil) ifNil: [^ self].							mouseDownMorph _ halo target.							targetOffset _ targetOffset - mouseDownMorph positionInWorld.							halo removeAllHandlesBut: nil.							mouseDownMorph setProperty: #specialDragging toValue: true]]		ifNotNil: [mouseDownMorph isWorldMorph ifFalse:					[mouseDownMorph setConstrainedPositionFrom:						(mouseDownMorph pointFromWorld:							(mouseDownMorph griddedPoint: self position - targetOffset))].	 mouseDownMorph ifNotNil:		[((itsOwner _ mouseDownMorph topRendererOrSelf owner) notNil and:			[itsOwner automaticViewing]) ifTrue:				[mouseDownMorph openViewerForArgument]]]! !!HandMorph methodsFor: 'private' stamp: 'di 8/28/2000 19:01'!releaseCachedState	| oo |	super releaseCachedState.	cacheCanvas _ nil.	oo _ owner.	self removeAllMorphs.	self initialize.	"nuke everything"	self privateOwner: oo.	mouseDownMorph _ nil.	argument _ nil.	formerOwner _ nil.! !!MagnifierMorph methodsFor: 'menu' stamp: 'di 8/24/2000 14:02'!chooseMagnification: evt	| handle origin aHand currentMag |	currentMag _ magnification.	aHand _ evt ifNil: [self currentHand] ifNotNil: [evt hand].	origin _ aHand position y.	handle _ HandleMorph new forEachPointDo:		[:newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag].	aHand attachMorph: handle.	handle startStepping.	self changed. "Magnify handle"! !!PasteUpMorph methodsFor: 'display' stamp: 'di 8/28/2000 23:24'!drawOn: aCanvas	"Update and draw the turtleTrails form. See the comment in updateTrailsForm."	super drawOn: aCanvas.	(self griddingOn and: [self gridVisible]) ifTrue:		[aCanvas fillRectangle: self bounds fillStyle:			(self gridFormOrigin: self gridOrigin + self position grid: self gridModulus background: nil line: Color lightGray)].	self updateTrailsForm.	turtleTrailsForm ifNotNil: [aCanvas paintImage: turtleTrailsForm at: self position].	(submorphs size > 0 and: [self indicateCursor]) ifTrue:		[aCanvas			frameRectangle: self selectedRect			width: 2			color: Color black].! !!PasteUpMorph methodsFor: 'display' stamp: 'di 8/24/2000 23:44'!pseudoDraw: aRectangle on: aCanvas	| c f |	c _ aCanvas copyClipRect: aRectangle.	f _ self fillStyle.	f isTranslucent ifTrue: [c fillColor: Color black].	c fillRectangle: bounds fillStyle: f.	turtleTrailsForm ifNotNil: [c paintImage: turtleTrailsForm at: 0@0].	^ c! !!PasteUpMorph methodsFor: 'display' stamp: 'di 8/24/2000 17:18'!pseudoDraw: aRectangle withGrid: gridOrNil on: aCanvas	| c f |	c _ aCanvas copyClipRect: aRectangle.	f _ self fillStyle.	f isTranslucent ifTrue: [c fillColor: Color black].	c fillRectangle: bounds fillStyle: f.	gridOrNil ifNotNil:		[aCanvas fillRectangle: bounds fillStyle: gridOrNil].	turtleTrailsForm ifNotNil: [c paintImage: turtleTrailsForm at: 0@0].	^c! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 13:29'!gridModulus	^ self gridSpec extent! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 16:47'!gridModulus: newModulus	self gridSpecPut: (self gridOrigin extent: newModulus).	self changed! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 13:28'!gridOrigin	^ self gridSpec origin! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 13:29'!gridOrigin: newOrigin	^ self gridSpecPut: (newOrigin extent: self gridModulus)! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/28/2000 23:13'!gridPoint: ungriddedPoint	self griddingOn ifFalse: [^ ungriddedPoint].	^ (ungriddedPoint - self position - self gridOrigin grid: self gridModulus)					+ self position + self gridOrigin! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 13:26'!gridSpec	"Gridding rectangle provides origin and modulus"	^ self valueOfProperty: #gridSpec ifAbsent: [0@0 extent: 8@8]! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 13:28'!gridSpecPut: newSpec	"Gridding rectangle provides origin and modulus"	^ self setProperty: #gridSpec toValue: newSpec! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 16:11'!gridVisible	^ self hasProperty: #gridVisible! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 16:47'!gridVisibleOnOff	self setProperty: #gridVisible toValue: self gridVisible not.	self changed! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 13:15'!griddingOn	^ griddingOn ifNil: [false]! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 16:48'!griddingOnOff	griddingOn _ self griddingOn not.	self changed! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/28/2000 21:04'!setGridSpec	"Gridding rectangle provides origin and modulus"	| response result mx |	mx _ 36.  "... because it was that way before ..."	response _ FillInTheBlank			request: 'New grid origin (usually 0@0):'			initialAnswer: self gridOrigin printString.	response isEmpty ifTrue: [^ self].	result _ [Compiler evaluate: response] ifError: [^ self].	(result isPoint and: [(result >= (0@0)) & (result < (mx @ mx))])		ifTrue: [self gridOrigin: result]		ifFalse: [self inform: 'Must be a Point with coordinates between 0 & '								, (mx-1) printString].	response _ FillInTheBlank			request: 'New grid spacing:'			initialAnswer: self gridModulus printString.	response isEmpty ifTrue: [^ self].	result _ [Compiler evaluate: response] ifError: [^ self].	(result isPoint and: [(result > (0@0)) & (result <= (mx @ mx))])		ifTrue: [self gridModulus: result]		ifFalse: [self inform: 'Must be a Point with coordinates between 1 & '								, mx printString].! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'di 8/28/2000 22:02'!playfieldOptionsMenu	| aMenu isWorld |	isWorld _ self isWorldMorph.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu add: 'save on file...' action: #saveOnFile.	aMenu add: 'save as SqueakPage at url...' action: #saveOnURL.	aMenu add: 'update all from resources' action: #updateAllFromResources.	(self valueOfProperty: #classAndMethod) ifNotNil:		[aMenu add: 'broadcast as documentation' action: #saveDocPane].	aMenu add: 'round up strays' action: #roundUpStrays.	aMenu balloonTextForLastItem:  'Bring back all objects whose current coordinates keep them from being visible, so that at least a portion of each of my interior objects can be seen.'.	aMenu addLine.	self griddingOn		ifTrue: [aMenu add: 'turn gridding off' action: #griddingOnOff.				aMenu add: (self gridVisible ifTrue: ['hide'] ifFalse: ['show']) , ' grid'						action: #gridVisibleOnOff.				aMenu add: 'set grid spacing...' action: #setGridSpec]		ifFalse: [aMenu add: 'turn gridding on' action: #griddingOnOff].	aMenu addLine.	#(	(autoLineLayoutString	toggleAutoLineLayout			'whether submorphs should automatically be laid out in lines')		(indicateCursorString	toggleIndicateCursor			'whether the "current" submorph should be indicated with a dark black border')		(isPartsBinString		toggleIsPartsBin			'whether dragging an object from the interior should produce a COPY of the object')		(isOpenForDragNDropString	toggleDragNDrop			'whether objects can be dropped into and dragged out of me')		(mouseOverHalosString	toggleMouseOverHalos			'whether objects should put up halos when the mouse is over them')		(autoExpansionString	toggleAutomaticPhraseExpansion			'whether tile phrases, dropped on me, should automatically sprout Scriptors around them')		(originAtCenterString	toggleOriginAtCenter			'whether the cartesian origin of the playfield should be at its lower-left corner or at the center of the playfield')		(showThumbnailString	toggleAlwaysShowThumbnail			'whether large objects should be represented by thumbnail miniatures of themselves')) do:			[:triplet |				(isWorld and: [#(toggleAutoLineLayout toggleIndicateCursor toggleIsPartsBin toggleAlwaysShowThumbnail) includes: triplet second]) ifFalse:					[aMenu addUpdating: triplet first action: triplet second.					aMenu balloonTextForLastItem: triplet third]]. 	isWorld ifFalse:		[aMenu add: 'set thumbnail height...' action: #setThumbnailHeight.		aMenu balloonTextForLastItem: 'if currently showing thumbnails governs the standard height for them'].	aMenu addUpdating: #autoViewingString action: #toggleAutomaticViewing.	aMenu balloonTextForLastItem:  'governs whether, when an object is touched inside me, a viewer should automatically be launched for it.'.	isWorld ifFalse:		[aMenu add: 'behave like a Holder' action: #becomeLikeAHolder.		aMenu balloonTextForLastItem: 'Set properties to make this object nicely set up to hold frames of a scripted animation.'].	self backgroundSketch ifNotNil:		[aMenu add: 'delete background painting' action: #deleteBackgroundPainting.		aMenu balloonTextForLastItem: 'delete the graphic that forms the background for this me.'].	presenter ifNil:		[aMenu add: 'make detachable' action: #makeDetachable.		aMenu balloonTextForLastItem: 'Allow this area to be separately governed by its own controls.'].	aMenu addLine.	aMenu add: 'use standard texture' action: #setStandardTexture.	aMenu balloonTextForLastItem: 'use a pale yellow-and-blue background texture here.'.	aMenu add: 'make graph paper...' action: #makeGraphPaper.	aMenu balloonTextForLastItem: 'Design your own graph paper and use it as the background texture here.'.	aMenu addTitle: 'playfield options...'.	^ aMenu! !!PolygonMorph methodsFor: 'editing' stamp: 'di 8/28/2000 17:49'!dragVertex: evt fromHandle: handle vertIndex: ix	| p |	p _ self griddedPoint: evt cursorPoint.	vertices at: ix put: p.	handle position: p - (handle extent//2).	self computeBounds! !!SelectionMorph methodsFor: 'geometry' stamp: 'di 8/28/2000 22:10'!privateFullMoveBy: delta	| griddedDelta griddingMorph |	selectedItems isEmpty ifTrue: [^ super privateFullMoveBy: delta].	griddingMorph _ self pasteUpMorph.	griddingMorph ifNil: [^ super privateFullMoveBy: delta].	griddedDelta _ (griddingMorph gridPoint: self position + delta + slippage) -					(griddingMorph gridPoint: self position).	slippage _ slippage + (delta - griddedDelta).  "keep track of how we lag the true movement."	griddedDelta = (0@0) ifTrue: [^ self].	super privateFullMoveBy: griddedDelta.	selectedItems do:		[:m | m privateFullMoveBy: griddedDelta]! !!SelectionMorph methodsFor: 'drag and drop' stamp: 'di 8/26/2000 02:07'!aboutToBeGrabbedBy: aHand	slippage _ 0@0.	^ super aboutToBeGrabbedBy: aHand! !!WorldState methodsFor: 'update cycle' stamp: 'di 8/29/2000 22:24'!drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas thatwere redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect gridFill |	rectList _ damageRecorder invalidRectsFullBounds: aWorld viewBox.	damageRecorder reset.	aWorld updateTrailsForm.	(aWorld griddingOn and: [aWorld gridVisible]) ifTrue:		[gridFill _ aWorld gridFormOrigin: aWorld gridOrigin grid: aWorld gridModulus					background: nil line: Color veryLightGray].	n _ submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	rectList do: [:r |		true		ifTrue:			["Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:				[mm _ submorphs at: i.				((mm fullBounds intersects: r) and: [mm visible]) ifTrue:					[morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]].				i _ i+1].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:				[c _ aWorld pseudoDraw: rectToFill on: aCanvas.				gridFill ifNotNil:					[aCanvas fillRectangle: rectToFill fillStyle: gridFill]].			[morphs isEmpty] whileFalse:				[(rect _ rects removeLast) == rectToFill ifFalse:					[c _ aCanvas copyClipRect: (rectToFill _ rect)].				morphs removeLast fullDrawOn: c].			morphs reset.  rects reset]		ifFalse: [c _ aWorld pseudoDraw: r on: aCanvas.				submorphs reverseDo: [:m | m fullDrawOn: c]].	].	^ rectList! !PasteUpMorph removeSelector: #griddingOn:!HandMorph removeSelector: #gridPointRaw!HandMorph removeSelector: #griddedPoint:!