'From Squeak 2.1 of June 30, 1998 on 11 September 1998 at 10:32:08 am'!"Change Set:		swikistuffDate:			27 July 1998Author:			Tim Rowledge, rowledge@interval.comAdd a way to get a page listing all the comment spaces on a Swiki. As aside effect, tidy up some poorly factored code, and add a new form ofreference to access actions like 'chat', 'comment' etc. and to allow localrefs to images.The listing page is <swiki>/comment - which is caught by Commentclass>process: and passed to #showAllComments:.Local images are 'rooted' in the swiki directory - thus fred.gif stored in<serverdir>/bill for the swiki 'bill' is refered to simply as '*fred.gif*'.External URLS still work as before.Actions such as Chat are refered to with the new form '*!!chat!!*' whichseems a bit cumbersome, but it can trivially be changed inURLMap>isStringALocaAction: if anyone has a form with better style."!Object subclass: #HTMLformatter	instanceVariableNames: 'formattingBlock specialCharacter '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!HTMLformatter subclass: #LessHTMLformatter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!ServerAction subclass: #SwikiAction	instanceVariableNames: 'urlmap source name formatters formatter '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!AuthorizedSwikiAction subclass: #RenderingSwikiAction	instanceVariableNames: 'serverDirectory '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!RenderingSwikiAction subclass: #RendererSwikiAction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!RendererSwikiAction subclass: #RenderedSwikiAction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!Object subclass: #SwikiPage	instanceVariableNames: 'url map formatted address file date timecoreID name user editReqDate editReqTime temp pageStatus '	classVariableNames: 'OutputFormat '	poolDictionaries: ''	category: 'PluggableWebServer'!!Comment class methodsFor: 'URL processing' stamp: 'mjg 9/1/1998 12:58'!process: request	"URLs are of the form Comment.commentKey or	Comment.commentKey.note of Comment.commentKey.gif.	If commentKey is accessed but not created, create an empty one.	If note is accessed, display it."	| commentKey noteIndex newNote |	(request message size > 1) ifTrue: [commentKey _ request message at: 2]	ifFalse: [^request reply: (self showAllComments: CommentsTable)].	(CommentsTable includesKey: commentKey)		ifFalse:			[CommentsTable at: commentKey put: Discussion new.			(CommentsTable at: commentKey)				title: commentKey.			(CommentsTable at: commentKey)				description: 'Discussion on ' , commentKey].	request fields isNil		ifFalse:			["Are there input fields?"			newNote _ self createComment: request.			newNote parent: commentKey.			(CommentsTable at: commentKey)				addNote: newNote.			newNote url: ('Comment.',commentKey,'.',				(CommentsTable at: commentKey) notes sizeprintString)].	request message size > 2		ifTrue:			["There's a note reference or a request for astatus image"			noteIndex _ request message at: 3.			noteIndex asUppercase = 'GIF'			ifTrue: [			request reply: (PWS success),(PWS content:'image/gif').			request reply: (HTMLformatter textToGIF:				(CommentsTable at: commentKey) status)]			ifFalse: [request reply: (self showNote:((CommentsTable at: commentKey)						at: noteIndex asNumber))]]		ifFalse: [request reply: (self showComment: (CommentsTableat: commentKey))]! !!Comment class methodsFor: 'URL processing' stamp: 'TPR 7/20/1998 18:07'!showAllComments: aDictionaryOfCommentSpaces	| fileName |	fileName := (ServerAction serverDirectory) , 'ShowAllComments.html'.	^HTMLformatter evalEmbedded: (FileStream fileNamed: fileName)contentsOfEntireFile with: aDictionaryOfCommentSpaces! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:57'!author	^self description! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:57'!children	^#()! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:45'!timestamp	^String new:0! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:53'!url	"fake the url as the title"	^'Comment.', self title! !!FileDirectory methodsFor: 'file status' stamp: 'ls 5/7/98 21:54'!entryAt: fileName  	"find the entry with local name fileName"	^self entryAt: fileName ifAbsent: [ self error: 'file not indirectory: ', fileName ].! !!FileDirectory methodsFor: 'file status' stamp: 'ls 5/7/98 21:53'!entryAt: fileName  ifAbsent: aBlock	"find the entry with local namefileName"	^self entries 		detect: [ :entry | (entry at: 1) =fileName ] 		ifNone: [ aBlock value ]! !!FileList methodsFor: 'file list menu' stamp: 'mjg 9/8/1998 09:44'!fileSelectedMenu: aMenu	^ aMenu		labels:'fileInfile into new change setbrowse changescopy name to clipboardopen image in a windowread image into GIFImportsplay midi filesort by namesort by sizesort by daterenamedeleteadd new filegenerate HTMLbroadcast as update'		lines: # (4 6 7 10)		selections: #(fileInSelection fileIntoNewChangeSetbrowseChanges  copyNameopenImageInWindow importImage playMidiFile sortByName sortBySize sortByDaterenameFile deleteFile addNewFile renderFile putUpdate)! !!FileList methodsFor: 'file list menu' stamp: 'mjg 9/3/1998 17:24'!renderFile	"Render the currently selected file"	| map action file renderedFile formatPage |	listIndex = 0 ifTrue: [^ self].	map _ URLmap new.	action _ RenderedSwikiAction new.	action name: '.'.  "For image references, refer to this directory"	map action: action.	map directory: directory.	(directory fileExists: 'glossary')	ifFalse: [Cursor wait showWhile: [		(directory newFileNamed: 'glossary') close].].	map readGlossary: (directory oldFileNamed: 'glossary').	formatPage _ SwikiPage new.	formatPage map: map.	formatPage coreID: (fileName allButFirst).	formatPage formatted: (HTMLformatter		evalEmbedded: (directory oldFileNamed: fileName)contentsOfEntireFile		with: formatPage		unlessContains: (Set new)).	formatPage name isNil		ifTrue: [self notify: 'You forgot to name the page!!<?request name: ''myname''?>'.				formatPage name: 'defaultName'.].	map pages at: (formatPage name asLowercase) put: formatPage.	formatPage formatted: (LessHTMLformatter swikify: (formatPageformatted)			linkhandler: [:link | map					linkFor: link					from: 'Nowhere'					storingTo: OrderedCollection new]).	"Make a template if one does not exist"	(directory fileExists: 'template.html')	ifFalse: [Cursor wait showWhile: [		(directory newFileNamed: 'template.html') nextPutAll: (selftemplateFile); close].].	renderedFile _ (directory pathName),(ServerActionpathSeparator),(formatPage coreID).	(directory fileExists: renderedFile)		ifTrue: [directory deleteFileNamed: renderedFile].	file _ FileStream fileNamed: renderedFile.	file nextPutAll: (HTMLformatter evalEmbedded:		(directory oldFileNamed: 'template.html') contentsOfEntireFile			with: formatPage).	file close.	FileDirectory default setMacFileNamed: renderedFile		type: 'TEXT'		creator: 'MOSS'.	map writeGlossary. "Directory is already in the map, so write tothe glossary there"	self updateFileList.! !!FileList methodsFor: 'file list menu' stamp: 'mjg 9/1/1998 14:10'!templateFile	^'<head><title><?request name?></title></head><body><?request formatted?></body>'! !!HTMLformatter methodsFor: 'formatting' stamp: 'ls 4/18/98 16:46'!format: requestObject	"format text with requestObject as the argument forthe code blocks"	^String streamContents: [ :stream |	formattingBlock value: requestObject value: stream ]! !!HTMLformatter methodsFor: 'private-initialization' stamp: 'ls 4/18/98 13:23'!formattingBlock: aBlock	formattingBlock _ aBlock! !!HTMLformatter methodsFor: 'private-initialization' stamp: 'mjg 8/28/199820:56'!initialize	specialCharacter = $*.! !!HTMLformatter methodsFor: 'translating' stamp: 'mjg 8/28/1998 21:03'!rangesOfAngleBrackets: sourceStrm	"Return an OrderedCollection of intervals of position within anglebrackets < and >.  Caller wants to avoid putting <br> in there."	| list char intervals start |	list _ OrderedCollection new: 10.	[sourceStrm atEnd] whileFalse: [		(char _ sourceStrm next) == $< ifTrue: [list add:sourceStrm position].	"a start"		char == $> ifTrue: [list add: sourceStrm positionnegated]].	"an end"	sourceStrm reset.	intervals _ OrderedCollection new: 10.	start _ nil.	list do: [:each |		(each > 0) & (start == nil) ifTrue: [start _ each].		(each < 0) & (start ~~ nil) ifTrue: [			intervals add: (start to: each negated). start _ nil]].	^ intervals"	HTMLformatter rangesOfAngleBrackets: (ReadStream on: '1234 <good><456 <good> 567> <ok>')	"! !!HTMLformatter methodsFor: 'translating' stamp: 'mjg 8/31/1998 12:48'!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacterasString) startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to:start+1 with: specialCharacter.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection:(specialCharacter asString)  startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom:start to: end						with: (aBlock value: (aLinecopyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>']			ifFalse: [targetStream nextPutAll: aLine].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in aseparator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue:[ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStreamnextPutAll: '<p>'; cr.]				ifFalse: [targetStream nextPutAll: '<br>';cr.]]].	^targetStream contents.! !!HTMLformatter methodsFor: 'accessing' stamp: 'mjg 8/28/1998 21:00'!specialCharacter	^specialCharacter! !!HTMLformatter methodsFor: 'accessing' stamp: 'mjg 8/28/1998 21:01'!specialCharacter: someCharacter	specialCharacter _ someCharacter! !!HTMLformatter class methodsFor: 'translating' stamp: 'ls 4/18/98 16:23'!evalEmbedded: stringOrStream with: request	| formatter |	formatter _self forEvaluatingEmbedded: stringOrStream.	^formatter format: request!!!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 6/3/98 10:29'!fixForIE: text	| ch targetStream sourceStream |	targetStream := WriteStream on: String new.	sourceStream := ReadStream on: text.	[sourceStream atEnd] whileFalse:	[ch := sourceStream next.	ch = $> ifTrue: [targetStream nextPutAll: '&gt;']	ifFalse: [ch = $< ifTrue: [targetStream nextPutAll: '&lt;']		ifFalse: [targetStream nextPut: ch]].].	^targetStream contents! !!HTMLformatter class methodsFor: 'translating' stamp: 'tk 7/15/1998 12:02'!forEvaluatingEmbedded: stringOrStream	"stringOrStream is text with <?expr?> expressions intermingled.This creates a HTLMLformatter instance which will substitute the <?expr?>expressions with the value of the argument (named request), and whichleaves all other text in stringOrStream alone"	| blockStream sourceStream doingEval ch |	blockStream _ WriteStream on: String new. 	blockStream nextPutAll: '[ :request :output | output nextPutAll: '''.	(stringOrStream isKindOf: Stream)		ifTrue: [sourceStream := stringOrStream]		ifFalse: [sourceStream := ReadStream on: stringOrStream].	doingEval _ false.	[sourceStream atEnd] whileFalse:  [		ch := sourceStream next.		(doingEval not and: [ ch = $<  and: [ sourceStream peek =$? ]]) ifTrue: [			"beginning of an <?...?> expression"			blockStream nextPutAll: '''.  output nextPutAll: ['.			sourceStream next.  "Skip the ?"			doingEval _ true]		ifFalse: [		(doingEval and: [ ch = $? and: [ sourceStream peek = $> ]])ifTrue: [			"end of a <?...?> expression"			blockStream nextPutAll: '] value asString.  outputnextPutAll: '''.			sourceStream next.  "Skip the >"			doingEval _ false.]		ifFalse: [			"normal char"			blockStream nextPut: ch.			(doingEval not and: [ ch = $' ]) ifTrue: [				 "double $' marks"  blockStream nextPut: $'] ] ] ].	"end the block"	doingEval		ifTrue: [ blockStream nextPutAll: '] value asString' ]		ifFalse: [ blockStream nextPutAll: '''' ].	blockStream nextPutAll: ']'.	^HTMLformatter new formattingBlock: (Compiler evaluate: blockStreamcontents)! !!HTMLformatter class methodsFor: 'translating' stamp: 'ls 4/18/98 16:38'!oldEvalEmbedded: stringOrStream with: request	| sourceStream targetStreamevalStream currentStream evalValue peekValue ch |	(stringOrStreamisKindOf: Stream)		ifTrue: [sourceStream := stringOrStream]		ifFalse: [sourceStream := ReadStream on: stringOrStream].	targetStream := WriteStream on: String new.	currentStream :=targetStream. 	[sourceStream atEnd] whileFalse: 		[ch :=sourceStream next.		ch = $< ifTrue:			[peekValue := sourceStream peek. (peekValue = $?) ifTrue:		[evalStream := WriteStream on: String new.		currentStream := evalStream.	sourceStream next. "Eat the ?"				ch :=sourceStream next.]].		((currentStream = evalStream) and: [ch =$?]) ifTrue:			[ peekValue := sourceStream peek.(peekValue = $>) ifTrue:				[sourceStream next."Eat the >"				currentStream := targetStream.			evalValue := (Compiler new evaluate: (evalStreamcontents) 					in: thisContext to: selfnotifying: nil ifFail: [^nil]).				(evalValueisKindOf: String)				ifFalse: [evalValue :=evalValue printString].				currentStreamnextPutAll: evalValue.]]			ifFalse: [currentStreamnextPut: ch].].	^targetStream contents! !!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 9/3/1998 16:58'!swikify: aStringOrStream linkhandler: aBlock	| formatter |	formatter _ self new.	formatter specialCharacter: $*.	^formatter swikify: aStringOrStream linkhandler: aBlock! !!LessHTMLformatter commentStamp: 'mjg 9/11/1998 10:32' prior: 0!The LessHTMLformatter provides a few more plaintext notations to swikify,to avoid typing HTML a bit more.  Used in rendering -- see FileListrenderFile!]style[(133 19)f1,f1LFileList renderFile;!!LessHTMLformatter reorganize!('translating' swikify:linkhandler:)!!LessHTMLformatter methodsFor: 'translating' stamp: 'mjg 9/3/1998 17:31'!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacterasString) startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to:start+1 with: specialCharacter.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection:(specialCharacter asString)  startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom:start to: end						with: (aBlock value: (aLinecopyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>' ; cr.]			ifFalse: [				(aLine beginsWith: '-')				ifTrue: [targetStream nextPutAll:'<li>',aLine allButFirst; cr.]				ifFalse: [				(aLine beginsWith: '====')				ifTrue: [targetStream nextPutAll:'<h4>',(aLine copyFrom: 5 to: aLine size),'</h4>';cr.]				ifFalse: [				(aLine beginsWith: '===')				ifTrue: [targetStream nextPutAll:'<h3>',(aLine copyFrom: 4 to: aLine size),'</h3>';cr.]				ifFalse: [				(aLine beginsWith: '==')				ifTrue: [targetStream nextPutAll:'<h2>',(aLine copyFrom: 3 to: aLine size),'</h2>';cr.]				ifFalse: [				(aLine beginsWith: '=')				ifTrue: [targetStream nextPutAll:'<h1>',aLine allButFirst,'</h1>';cr.]				ifFalse: [				(aLine beginsWith: '!!')				ifTrue: [targetStream nextPutAll:'<b>',aLine allButFirst,'</b>';cr.]				ifFalse: [targetStream nextPutAll:aLine].]]]]]].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in aseparator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue:[ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStreamnextPutAll: '<p>'; cr.]				ifFalse: [targetStream nextPutAll: '<br>';cr.]]].	^targetStream contents.! !!PWS methodsFor: 'Initializing' stamp: 'ls 7/22/1998 22:47'!initializeFrom: aSocket	"Initialize me from aSocket."	| request idx |	log _ WriteStream on: ''.	connection _ aSocket.	request _ self readRequest.	"sets header"	header _ header substrings.	url _ self unEscape: (header at: 2).	((idx _ header indexOf: 'Authorization:') ~= 0 and: [(header at:idx + 1)			= 'Basic'])		ifTrue: [userId _ header at: idx + 2].	peerName _ self clientName: connection remoteAddress.	log		nextPutAll: Time totalSeconds asString; tab;		nextPutAll: peerName asString; tab;		nextPutAll: userId asString; tab;		nextPutAll: url; tab;		nextPutAll: request last asString; tab.	request last notNil		ifTrue: [ fields := self decodeFields: request last ]		ifFalse: [ (url includes: $?) ifTrue: [			idx _ url indexOf: $?.			idx = url size				ifTrue: [ "empty request" fields _Dictionary new ]				ifFalse: [					fields _ self decodeFields:						(url copyFrom: idx+1 to:url size) ].			url _ url copyFrom: 1 to: idx-1 ] ].	message := url findTokens: '/.\?:='.! !!PWS methodsFor: 'Initializing' stamp: 'ls 7/22/1998 22:44'!readRequest	"Read the request and return an array of header and query."	| idx request query length |	request := ''.	[	request := request, connection getData.		(idx := request findString: (self class crlfcrlf)startingAt: 1) = 0 ] whileTrue.	header := request copyFrom: 1 to: idx - 1.	(request beginsWith: 'POST') ifTrue: [		(length := request asUppercase findString:'CONTENT-LENGTH:' startingAt: 1) = 0			ifTrue: [ self error: '* noLength' ].		length := (request copyFrom: length + 15 to:		  (request indexOf: Character cr startingAt: lengthifAbsent: []))			withBlanksTrimmed asNumber + idx + 3.		[ request size < length ] whileTrue: [ request := request,connection getData ].		query := (request copyFrom: idx + 3 to: request size)withBlanksTrimmed ].	"Transcript show: request."	^{ header. query }! !!PWS methodsFor: 'Processing' stamp: 'tk 7/15/1998 12:06'!report: msg for: rec	"Write an error report."	| s |	self log: '*** ', rec asString, ': ', msg.	s _ (msg indexOfSubCollection: 'HTTP' startingAt: 1) = 1		ifTrue: [msg]		ifFalse: ['HTTP/1.0 400 Bad Request -- ', self classcrlfcrlf, msg].	[self reply: s] ifError: [:m :r | "ignore errors"].! !!PWS methodsFor: 'Processing' stamp: 'ls 7/28/1998 01:09'!unEscape: aString  "Convert escape sequences to their proper characters."	| rs ws c |	rs := ReadStream on: aString.	ws := WriteStream on: ''.	[ rs atEnd ] whileFalse: [		c := rs next.		ws nextPut:			(c = $+ ifTrue: [ $  ] ifFalse: [				c = $%					ifTrue: [ (Number readFrom: (rsnext: 2) asUppercase base: 16) asCharacter ]					ifFalse: [ c ]				]).		].	^ws contents ! !!PWS class methodsFor: 'Initializing' stamp: 'mjg 9/1/1998 14:19'!howToStart	"To set up your new Swiki, you need a copy of the 'Server' folderfound at:http://www.cc.gatech.edu/fac/mark.guzdial/squeak/pws/Put the 'Server' folder into the folder that your image is in.Modify this method to be a path to your Server folder, select it, andchoose fileItIn:!!ServerAction class methodsFor: 'System Services' stamp: 'tk 1/19/98 12:52'!!serverDirectory	^ 'Hard Disk:Squeak1.31:Server:'!! !!Then do:	PWS initializeAll.To enable a new Swiki called OurOwnArea.Make a folder named OurOwnArea in the Server folder.  Then do:	SwikiAction setUp: 'OurOwnArea'.	(its main URL is http://thisMachine:80/OurOwnArea.1)Suppose you already have a Swiki called 'myswiki'.To start up:	SwikiAction new restore: 'myswiki'.		'<- New line foreach additional Swiki area'.	SwikiAction new restore: 'myswiki'.		'Case DOES matterin the name of Swiki here.'.	PWS serveOnPort: 80 loggingTo: 'log.txt'.To stop the server:	PWS stopServer.-----------------------To purge a particular file of all except the latest version:	((PWS actions at: 'myswiki' asLowercase) urlmap atID: '3')condenseChanges.To roll the entire wiki back to a previous time:	""This does not erase data, it just copies the older page to the end""	(PWS actions at: 'myswiki' asLowercase) rollBack: '1/28/98' asDate			at: '1:30 am' asTime.The look of a served page is controlled by a template.  Templates live inthe 'swiki' folder in the 'Server' folder.  Beware that templates arecached by HTMLformatter.  If you change a template, you will not see theeffect until you reload the Swiki.To set up a Swiki with a password (same for all users), seeAuthorizedSwikiAction comment.To enable a privledged user to execute code remotely (on a workspace page):	(PWS actions at: 'authorized') mapName: 'JSmith' password:'hard2guess' to: 'JSmith'.	(URL is http://thisMachine:80/authorized.workspace.html)To backup the user data to the disk, do nothing.  All info is alreadyinside the page files on the disk.To enable a new Swiki that evaluates Squeak code submitted by the user.Make a folder named SqkEval in the Server folder.  Then do:	ActiveSwikiAction setUp: 'SqkEval'.	(this is dangerous, because there are still ways a user could crashyour server)To convert a Swiki with LineFeed line endings to CarriageReturn lineendings, execute these lines:          (PWS actions select: [ :action | action isKindOf: SwikiAction ])		do: [ :action | action fixAllLineENdings ]To convert from an old pre-Squeak1.3 Swiki to the new page format:	(In the old image, do a backup:)		| mine | mine _ PWS actions at: 'myswiki'.		mine saveTo: mine path,'backup28JanA'.	(Quit.  Start the new image which has this version of the Swiki code)	(Do not start the server!!!!!!)		PWS initializeAll.		SwikiAction restore: 'myswiki' from:			(ServerAction serverDirectory), 'myswiki:backup28JanA'.		(PWS actions at: 'myswiki' asLowercase) convert.	(do these steps for each Swiki you have)	(now, start the server)	PWS serveOnPort: 80 loggingTo: 'log.txt'."!]style[(10 1647 21 1382)f1b,f1,f1LAuthorizedSwikiAction Comment;,f1! !!PWS class methodsFor: 'Serving' stamp: 'tk 7/15/1998 11:27'!serveShowingErrorsOnPort: portNumber	"Start up the HTTP server loop for debugging!!  Operate in thisprocess, synchronously.  Force errors to stop the server and show on thescreen.."	| socket logEntry inst |	self stopServer.	Socket initializeNetwork.	ServerLog _ FileStream fileNamed: 'dummy.log'.	ServerLog position: ServerLog size.	ServerPort _ ConnectionQueue portNumber: portNumber queueLength: 6.	ClientNameCache _ Dictionary new.	[true] whileTrue: [		socket _ ServerPort getConnectionOrNil.		socket notNil			ifTrue: ["serve:"				inst _ self new.				inst initializeFrom: socket.				inst getReply.				socket closeAndDestroy: 30.				logEntry _ inst log contents]		"nologging for now"			ifFalse: [(Delay forMilliseconds: 100) wait]].! !!String methodsFor: 'internet' stamp: 'ls 7/27/1998 23:17'!withInternetLineEndings	"change line endings from CR's to CRLF's.  This is probably inprepration for sending a string over the Internet"	| cr lf |	cr _ Character cr.	lf _ Character linefeed.	^self class streamContents: [ :stream |		self do: [ :c |			stream nextPut: c.			c = cr ifTrue:[ stream nextPut: lf ]. ] ].! !!String methodsFor: 'internet' stamp: 'ls 7/27/1998 23:16'!withSqueakLineEndings	"assume the string is textual, and that CR, LF, and CRLF are allvalid line endings.  Replace each occurence with a single CR"	| cr lf input c |	cr _ Character cr.	lf _ Character linefeed.	^String streamContents: [ :str |		input _ ReadStream on: self.		[input atEnd] whileFalse: [			c _ input next.			c == cr ifTrue: [				str cr.				input peek == lf ifTrue: [ input next ] ]			ifFalse: [				c == lf ifTrue: [ str cr ] ifFalse: [ strnextPut: c ] ] ] ]! !!SwikiAction commentStamp: 'mjg 9/11/1998 10:32' prior: 0!SwikiAction is the action to implement a Swiki, a collaborative website.This is a web server in Squeak.  Each page served has an "Edit this Page"link.  The syntax rules for editing pages (from any web browser) are in thefile FormattingRules.The pages may be viewed from any web browser, and the URL ishttp://thisMachine:80/OurOwnArea.1  ('OurOwnArea' is the name of the Swikiarea.)  See http://guzdial.cc.gatech.edu:8080/myswiki for an examplefocused on discussing Swikis.Swiki is based on the Wiki Server, designed and implemented by WardCunningham.  See the original Wiki at http://c2.com/cgi-bin/wiki, or theSqueak-focused one at http://c2.com:8080/See PWS class howToStart.Modified by Ted Kaehler to have all state on the disk at all times.  Do notsnapshot the image during normal server operation.  Restart the server byloading all state from the disk.Each separate Wiki is a folder inside the Server folder.  The name of thefolder is the name of the Wiki.  Each page is a file.  (Inefficient on Macsbecause of large minimum page size, but that's an OS problem.)  Allversions of all pages are kept.  Each page contains chunks, just like achanges file.  Each chunk is one version of one page:self name: 'Ted''s Page' date: '1/28/1998' time: '12:47:21' by: 'tk' text:'Here is the body of the page' back: 116!!The last item is number of bytes in the chunk.  It is the number of bytesfrom the start of the chunk to just in front of the number.  This allowsback-chaining to old versions.  On startup, the chunk is executedexplicitly using evaluate:for:logged:.  It supplies the page name to aSwikiPage and installs it in the URLmap.  By doing this for all files inthe folder, the map (url->page) is built.  During operation, the chunk isnot executed.  Instead, take the file directly, look at 'back:' at the end,jump back to the start of the chunk, scan for 'text:' and read the text.The looks of the pages served are controlled by templates.  They live inthe 'swiki' folder in the 'Server' folder.  See page.html for how to changethe look of a served page.  Beware that templates are cached byHTMLformatter.  If you change a template, you will not see the effect untilyou reload the Swiki.A symbol *append here* may be added anywhere in the page.  Clicking on itwill bring up a page with a text editing form.  The what you type will beinserted just before the *append here* marker.  This allows append-onlypages, or multiple questions with places to add to the answer.!]style[(671 20 1830)f1,f1LPWS class howToStart;,f1!!SwikiAction methodsFor: 'accessing' stamp: 'mjg 8/28/1998 20:58'!formatter	^formatter! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 8/28/1998 20:58'!formatter: anHTMLformatter	formatter _ anHTMLformatter! !!SwikiAction methodsFor: 'accessing' stamp: 'TPR 7/21/1998 18:06'!url	"Answer the receiver's 'name'."	^name! !!SwikiAction methodsFor: 'save and restore' stamp: 'ls 7/27/1998 23:26'!fixAllLineEndings	"for each page in the swiki, fixes line endings to be CR only.This is used to bring older Swikis up to date with the newer convention.If a page has no LF's, then it is left alone"	| origText newText pagesDone |	pagesDone _ 0.	'updating pages...' displayProgressAt: Sensor cursorPoint from: 0to: urlmap pages size during: [ :bar |		urlmap pages do: [ :page |			origText _ page text.			newText _ origText withSqueakLineEndings.			origText = newText ifFalse: [ page text: newText ].			pagesDone _ pagesDone + 1.			bar value: pagesDone. ] ]! !!SwikiAction methodsFor: 'save and restore' stamp: 'mjg 8/28/1998 21:05'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct theurl map."	| map page folder dir rep templateFolder |	map _ URLmap new.	self map: map.	self formatter: (HTMLformatter new initialize).	self formatter specialCharacter: $*.	self name: nameOfSwiki.	templateFolder _ 'swiki'.	self source: templateFolder,(ServerAction pathSeparator).	map action: self.	map pages: (Dictionary new).	map directory: nameOfSwiki. "This is where the pages are."	folder _ (ServerAction serverDirectory), nameOfSwiki.	dir _ FileDirectory on: folder.	dir fileNames do: [:fName |		rep _ fName detect: [:char | char isDigit not] ifNone: [$3].		rep isDigit ifTrue: ["all are digits"			page _ self class pageClass new.			page fromFileNamed: folder,(ServerActionpathSeparator),fName action: self.			(page time isNil) ifTrue: [page time: Time now].			map at: page name put: page]].	PWS link: nameOfSwiki to: self.! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/28/1998 20:59'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage htmlForUser |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	"format using the cached formatter"	htmlForUser _ ((self formatterFor: 'page') format: formattedPage).	htmlForUser size = 0 ifTrue: [self error: 'template file''page.html'' not found'].	request reply: htmlForUser.! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/31/1998 15:32'!edit: pageRef from: request	request reply: (HTMLformatter evalEmbedded:							(self fileContents:source , 'edit.html')						with: pageRef).	pageRef noteEditRequest.	^ self! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 9/10/1998 15:31'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit""	{swikiname}.{coreID}  {with a field named 'text'}  store an edited page	{swikiname}.{coreID}  {with a field named 'text-placeID'}  store textin a specific place	{swikiname}.searchresult  {with a field named 'searchFor'} conducts thesearch for that text and sends back the result"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			((self formatterFor: 'recent') format: (urlmapsearchFor:						(request fields at:'searchFor' ifAbsent:['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!SwikiAction methodsFor: 'URL processing' stamp: 'BJP 9/7/1998 00:55'!pageURL: aPage	"make the URL suited to aPage in this Action"	^(self name),'.',aPage coreID! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/31/1998 15:32'!process: request	"URLs are of the form:	{swikiname} 		browse Front Page	{swikiname}.{coreID} browse the page number coreID	{swikiname}.{coreID}.edit  request to edit the page	{swikiname}.{coreID}.versions show the last three versions of the page	{swikiname}.{coreID}  {with a field named 'text'}  store an edited page	{swikiname}.{coreID}.insert.{placeID}  request to insert text in aspecific place in a page	{swikiname}.{coreID}  {with a field named 'text-placeID'}  storetext in a specific place	-------	{swikiname}.{coreID}.all  displays the page and all its references	{swikiname}.searchresult  conducts the search and displays the result	{swikiname}.recent  to bring up the recent changes list	{swikiname}.{coreID}.searchresult  returns a search for referencesto coreID's key	{swikiname}.{picName}.gif   or .jpeg, .jpg, .jpe, .html (upper orlower case) return	the picture or static page stored in the {swikiname} folder."	| coreRef pageRef command formattedPage theLast pvtPageRefhtmlForUser |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype:'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype:'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype:'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype:'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype:'text/html'].	request reply: PWS success;		reply: PWS contentHTML.	Transcript show: 'In process: ' , request message printString; cr.	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"			(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue:			[request reply: PWS crlf , ((self formatterFor:'recent')						format: urlmap recent).			^ self].	request reply: PWS crlf.	"End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue:			["SearchResult, All, Versions, or Edit"			command _ request message at: 3.			command = 'edit' ifTrue:					[request reply: ((selfformatterFor: 'edit') format: pageRef).					pageRef noteEditRequest.					^ self].			command = 'versions' ifTrue:					[request reply: ((selfformatterFor: 'versions') format: pageRef).					^self].			command = 'insert' ifTrue:					[pvtPageRef _ pageRef clone.					pvtPageRef placeID: (requestmessage at: 4).	"so <?request placeID?> can get it"					htmlForUser _ ((self formatterFor:'insert') format: pvtPageRef).					htmlForUser size = 0 ifTrue: [						self error: 'template file''insert.html'' not found'].					request reply: htmlForUser.					pageRef noteEditRequest.					^ self].			command = 'searchresult' ifTrue:					[request reply: ((selfformatterFor: 'results')						format: (urlmap searchFor:pageRef name)).					^ self].			command = 'all' ifTrue:					[formattedPage _ urlmapallPagesFrom: pageRef for: request.					request reply: ((self formatterFor:'page') format: formattedPage).					^ self].			Transcript show: 'Unknown command: ' , command; cr.			^ self].	"Just a browse"	^ self browse: pageRef from: request! !!SwikiAction methodsFor: 'URL processing' stamp: 'ls 4/18/98 18:09'!smtlk: request	"Return Smalltalk sourcecode.  URL =machine:80/myswiki.smtlk.Point|at;  included are:  Point|at:Point|Comment   Point|Hierarchy  Point|Definition   Point|class|x;y;  NOTE:use ; instead of : in selector names!!!!!!"	| classAndMethod set |	classAndMethod _ request message atPin: 3.	classAndMethod _classAndMethod copyReplaceAll: '|' with: ' '.	classAndMethod _classAndMethod copyReplaceAll: ';' with: ':'.	set _ LinkedMessageSetmessageList: (Array with: classAndMethod).	request reply: PWS crlf,((self formatterFor: 'smtlk') format: set).! !!SwikiAction methodsFor: 'formatters' stamp: 'ls 5/5/98 17:20'!clearFormatterCache	"remove all formatters"	formatters _ nil.! !!SwikiAction methodsFor: 'formatters' stamp: 'ls 5/7/98 22:04'!formatterFor: formatterName	"get the formatter for the given name.uses lazy initialization.  Could eventually check whether the on-disk filehas been updated."	| fileName fileModTime |		"first,create the dictionary of formatters if it isn't already"	formatters== nil ifTrue: [		formatters _ Dictionary new. ].	"get the filename for the template source"	fileName _formatterName, '.html'.	"get its modification time"	fileModTime_ ((FileDirectory on: ServerAction serverDirectory, source) entryAt:fileName) at: 3.	"create the formatter if necessary"	((formatters includesKey: formatterName) not or: [	((formatters at: formatterName) at: 2) < fileModTime ])	ifTrue: [		Transcript show: '(recompiling formatter ',formatterName, ')'; cr.		formatters at: formatterName put:(Array with:			(HTMLformatter forEvaluatingEmbedded: (selffileContents: (source, formatterName, '.html')))	with: fileModTime)	].	"return the formatter"	^(formatters at: formatterName) at: 1! !!ActiveSwikiAction methodsFor: 'as yet unclassified' stamp: 'mjg 9/1/199812:44'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage liveText|	liveText _ HTMLformatter evalEmbedded: (pageRef text)		with: request unlessContains: (self dangerSet).	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: liveText			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	request reply: ((self formatterFor: 'page') format: formattedPage).! !!ActiveSwikiAction methodsFor: 'as yet unclassified' stamp: 'mjg 9/10/199815:33'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents:source, 'results.html')				with: (urlmap searchFor: (request fieldsat: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!! -- but don't complain!! Could be for ActivePage!!""	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr."! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 7/6/1998 07:31'!checkAuthorization: request	^ authorizer ifNotNil: [authorizer user: request userID].! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/31/199815:32'!process: request	self checkAuthorization: request.	^(super process: request).! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 9/1/1998 12:44'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (HTMLformatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	request reply: (HTMLformatter evalEmbedded: (self fileContents:source ,'page.html')			with: formattedPage).! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'TPR 7/21/1998 18:14'!generate: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage peer cacheFile file|	(request isKindOf: PWS)	ifFalse: [(request isKindOf: String) ifTrue: [peer _ request]ifFalse: [peer _ ' ']]	ifTrue: [peer _ request peerName].	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (HTMLformatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: peer					storingTo: OrderedCollection new]).	cacheFile _ (self cacheDirectory),(self name),(ServerActionpathSeparator),(pageRef coreID),'.html'.	(StandardFileStream isAFileNamed: cacheFile)	ifTrue: [FileDirectory deleteFilePath: cacheFile].	file _ FileStream fileNamed: cacheFile.	file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents:source ,'page.html')			with: formattedPage).	file close.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'TPR 7/21/1998 18:15'!generateRecent	| file |	file _ FileStream fileNamed: (self cacheDirectory),(selfname),(ServerAction pathSeparator),'recent.html'.	file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents:source, 'recent.html')					with: urlmap recent).	file close.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 9/10/1998 15:34'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents:source, 'results.html')				with: (urlmap searchFor: (request fieldsat: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"		self generate: (urlmap atID: coreRef) from: request.		self generateRecent.			^ self]].		"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'BJP 9/9/1998 21:34'!pageURL: aPage	"make the url suited to aPage"	^(self url),(self name),'/',aPage coreID,'.html'! !!CachedSwikiAction methodsFor: 'access' stamp: 'TPR 7/21/1998 18:05'!url	^cacheURL! !!PSwikiAction methodsFor: 'all' stamp: 'mjg 9/10/1998 15:35'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents:source, 'results.html')				with: (urlmap searchFor: (request fieldsat: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(request fields includesKey: 'text') ifTrue: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			username: (request fields at: 'username' ifAbsent:[''])			password: (request fields at: 'password' ifAbsent: [''])			privs: (request fields at: 'privs' ifAbsent: [''])			text: (request fields at: 'text' ifAbsent: ['blanktext'])			from: request peerName.		page user: request userID.  "Address is machine, user onlyif logged in"		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!PSwikiAction methodsFor: 'all' stamp: 'mjg 8/31/1998 12:50'!process: request	"URLs are of the form:	{swikiname} to browse Front Page	{swikiname}.{coreID} to browse the page	{swikiname}.{coreID}.edit  to edit the page	{swikiname}.{coreID}.all  displays the page and all its references	{swikiname}.{coreID}.versions displays the last three versions ofthe page	{swikiname}.searchresult  conducts the search and displays the result	{swikiname}.recent  to bring up the recent changes list	{swikiname}.{coreID}.searchresult  returns a search for referencesto coreID's key	{swikiname}.{picName}.gif (or jpeg, jpg, jpe, upper or lower case)return the picture stored in the {swikiname} folder."	"Transcript show: 'Got request ',(request url); cr."	| coreRef pageRef command formattedPage theLast |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype:'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype:'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype:'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype:'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype:'text/html'].	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"		(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue:			[request reply: PWS crlf, (HTMLformatter					evalEmbedded: (self fileContents:source, 'recent.html')					with: urlmap recent).			^ self]."	request reply: PWS crlf.		End of header.  Move thiswhen we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue: ["SearchResult, All, Versions, orEdit"		command _ request message at: 3.		command = 'edit' ifTrue:			[^self edit: pageRef from: request].		command = 'versions' ifTrue:					[request reply: ((selfformatterFor: 'versions') format: pageRef).					^self].		command = 'searchresult' ifTrue:			[request reply: (HTMLformatter evalEmbedded:							(self fileContents:source , 'results.html')						with: (urlmap searchFor:pageRef name)).			^ self].		command = 'all' ifTrue:			[formattedPage _ urlmap allPagesFrom: pageRef for:request.			request reply: (HTMLformatter evalEmbedded:							(self fileContents:source, 'page.html')						with: formattedPage).			^ self].		Transcript show: 'Unknown command: ', command; cr.		^ self].	"Just a browse"	^ self browse: pageRef from: request! !!RenderingSwikiAction commentStamp: 'mjg 9/11/1998 10:32' prior: 0!An authorized Swiki that can generate cached pages with no link back to theSwikiExamples of setting them up:Here's one that renders to an external, FTP-accessible website:| sd auth |sd _ ServerDirectory new.sd directory: '/net/www/fac/mark.guzdial/testSwiki'; server: 'flintstone.com';	user: 'fred'; password: 'flintstone'.RenderingSwikiAction new restore: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.Here's one that renders to a local directory accessible from a webserver:| sd auth |sd _ 'Guz 7600:WebSTAR 2.0:testSwiki:'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.!!RenderingSwikiAction reorganize!('accessing' serverDirectory:)('process and generate' browse:from: generate: pageURL: process:)!!RenderingSwikiAction methodsFor: 'accessing' stamp: 'mjg 8/31/1998 14:40'!serverDirectory: anObject	serverDirectory _ anObject. "Should be an instance ofServerDirectory, or a path string."! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg8/31/1998 12:57'!browse: pageRef from: request	"Just reply with a page in HTML format -- use the rendering pagetemplate rpage.html"	| formattedPage htmlForUser |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	"format using the cached formatter"	htmlForUser _ ((self formatterFor: 'rpage') format: formattedPage).	htmlForUser size = 0 ifTrue: [self error: 'template file''rpage.html'' not found'].	request reply: htmlForUser.! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg8/31/1998 16:42'!generate: pageRef	"Generate the page to the serverDirectory. Use the render.html pageas a template"	| formattedPage renderedFile newmap file|	"Make a copy, then format the text."	formattedPage _ pageRef copy.	newmap _ urlmap copy.		" Create a new action withdifferent action for cached form."	newmap action: (RendererSwikiAction new).	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | newmap					linkFor: link					from: 'Nowhere'					storingTo: OrderedCollection new]).	(serverDirectory isKindOf: String)	ifTrue: [ "Just save the file into the directory"		renderedFile _ (serverDirectory),(pageRef coreID),'.html'.		(StandardFileStream isAFileNamed: renderedFile)		ifTrue: [FileDirectory deleteFilePath: renderedFile].		file _ FileStream fileNamed: renderedFile.		file nextPutAll: (HTMLformatter evalEmbedded: (selffileContents: source ,'render.html')			with: formattedPage).		file close.]	ifFalse: [ "Assume it's FTP and send it off"		renderedFile _ (pageRef coreID),'.html'.		(StandardFileStream isAFileNamed: renderedFile)		ifTrue: [FileDirectory deleteFilePath: renderedFile].		file _ FileStream fileNamed: renderedFile.		file nextPutAll: (HTMLformatter evalEmbedded: (selffileContents: source ,'render.html')			with: formattedPage).		file close.		serverDirectory putFile: (FileStream fileNamed:renderedFile) named: renderedFile.		"FileDirectory deleteFilePath: renderedFile"]! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'BJP9/9/1998 21:35'!pageURL: aPage	"make the URL suited to aPage"	^(self name),'.',aPage coreID! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg9/9/1998 14:24'!process: request	"Handle requests of the form {swikiname}.{coreRef}.render"	(request message size > 2) ifTrue: [		((request message at: 3) = 'render') ifTrue:		[ self generate: (urlmap atID: (request message at: 2)).		request reply: (PWS success) ; reply: (PWS contentHTML).		^self browse: (urlmap atID: (request message at: 2)) from:request].		((request message at: 3) = 'html') ifTrue: "Handle 1.html refs"		[^self browse: (urlmap atID: (request message at: 2)) from:request]].	super process: request.! !!RendererSwikiAction commentStamp: 'mjg 9/11/1998 10:32' prior: 0!This class only exists to provide a different pageURL for the rendered pagesHere's how to set them up:For FTP rendering:| sd auth |sd _ ServerDirectory new.sd directory: '/net/www/fac/mark.guzdial/testSwiki'; server:'cleon.cc.gatech.edu';	user: 'fred'; password: 'flintstone'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.For local rendering:| sd auth |sd _ 'Guz 7600:WebSTAR 2.0:testSwiki:'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.!!RendererSwikiAction methodsFor: 'as yet unclassified' stamp: 'BJP 9/9/199821:35'!pageURL: aPage	"make the url suited to rendered aPage"	^aPage coreID,'.html'! !!RenderedSwikiAction commentStamp: 'mjg 9/11/1998 10:32' prior: 0!Used for creating the right HTML links for Rendered Files!!RenderedSwikiAction methodsFor: 'as yet unclassified' stamp: 'BJP 9/9/199821:35'!pageURL: aPage	"make the url suited to rendered aPage"	^aPage coreID! !!SwikiAction class methodsFor: 'initialization' stamp: 'BJP 9/9/1998 21:41'!setUp: actionName	"Set up a named Swiki"	| action map page dir |	action _ self new.	map _ self mapClass new.	"URLmap or PURLmap"	action formatter: (HTMLformatter new initialize).	action formatter specialCharacter: $*.	action map: map.	action name: actionName.	action source: 'swiki',(ServerAction pathSeparator).	map action: action.	map pages: (Dictionary new).	map directory: actionName.	dir _ FileDirectory on: (ServerAction serverDirectory).	(dir directoryNames includes: actionName) ifFalse: [		^ self inform: 'You need to create a folder in Server called ',actionName].		"A directory in the ServerDirectory for storing pages."	page _ map newpage: actionName,': Front Page' from: 'Beginning'.	page pageStatus: #standard.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerActionserverDirectory),'swiki',				(ServerAction pathSeparator),'FrontPage')contentsOfEntireFile) with:actionName).	page _ map newpage: 'Formatting Rules' from: 'Beginning'.	page pageStatus: #standard.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerActionserverDirectory),'swiki',				(ServerAction pathSeparator),'FormattingRules')contentsOfEntireFile)with: actionName).	PWS link: actionName to: action.	^action! !!SwikiPage reorganize!('accessing' address address: by by: coreID coreID: date date: file file:formatted formatted: lastEditTime map map: name name: noteEditRequestoutputFormat pageStatus pageStatus: placeID placeID: text text:textVersion: time time: timeOfAccept url url: user user:)('save & restore' backupAChunk: chunk1 condenseChanges formatForOutputfromFileNamed:action: name:date:time:by:text:back: rollBack:at: scanFrom:text:back:)('insertion points' unique:in: uniqueInsertionPoints:)!!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/3/1998 21:32'!by	| who |	who _ user class == String					ifFalse: [address]					ifTrue: [user].		who ifNil: [who _ 'unknown user'].	^who.! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 9/10/1998 15:26'!by: who	self address: who.! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 18:34'!date: anObject	"Set the receiver's instance variable 'date' to be anObject."		(anObject isKindOf: String)			ifTrue: [date _ anObject asDate]			ifFalse: [date := anObject]! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 9/1/1998 09:58'!name: anObject	"Set the receiver's instance variable 'name' to be anObject."	name := anObject.	^''! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/10/1998 14:14'!outputFormat	^self class outputFormat! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 19:41'!pageStatus	"The basic stati ;) are #new and #standard. If the pageStatus is nil,we make make the page #standard, as that is the old behavior. You could addother types to get e.g., different kinds of URLs, or to exclude pages froma search, or alter the formatter, or..."	pageStatus ifNil: [pageStatus _ #standard].	^pageStatus! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/3/1998 13:55'!pageStatus: aSymbol	"While I'm trying to be careful about default behavior if the type isunknown, one should still be careful to check all the places that pageTypeis used."	pageStatus _ aSymbol.! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/12/1998 22:50'!placeID	"Temporarily hold onto the placeID value.  For putting into theFORM in insert.html"	^ temp! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/12/1998 22:50'!placeID: idNum	"Temporarily hold onto the placeID value.  For putting into theFORM in insert.html"	temp _ idNum! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/13/1998 12:37'!text: aString	"Add onto the end of the file"	| this aFile start end realString |	realString _ self uniqueInsertionPoints: aString.	this _ String streamContents: [:ss |		ss nextPutAll: self chunk1.		realString storeOn: ss.		ss nextPutAll: ' back: '].	(aFile _ FileStream fileNamed: file) setToEnd.	start _ aFile position.	aFile nextChunkPut: this; skip: -1.	"undo the !! at end"	end _ aFile position.	aFile nextPutAll: (end - start) printString; nextPut: $!!; cr; close.! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 8/28/1998 20:37'!textVersion: steps	"One step back gets the original"	| theFile theText real bb gotTo |	theFile _ FileStream oldFileNamed: file.	theFile setToEnd.	steps timesRepeat: [bb _ self backupAChunk: theFile.].	bb = 0 ifTrue: ["Went back beyond beginning"		theFile close.		^'<Too Far Back>'.].	bb _ bb - 7.		"before the back:"	"Be careful about occurances of 'text:' in the name or other field"	[theFile match: 'text:'.	gotTo _ theFile position.	theFile upTo: $'; skip: -1.	theText _ theFile nextDelimited: $'.	real _ (ReadStream on: theText) nextDelimited: $!!.	"Removedouble !!"	theFile skipSeparators.	theFile position >= bb] whileFalse: [theFile position: gotTo].	theFile close.	^ real! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 8/28/1998 19:41'!time	"Answer the receiver's 'time'."	^time! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 18:29'!time: anObject	"Set the receiver's instance variable 'time' to be anObject."	(anObject isKindOf: String)		ifTrue: [time _ anObject asTime]		ifFalse: [time := anObject]! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 20:36'!backupAChunk: aFile	"We are positioned at the end of a chunk.  Read the size of thischunk from its end.  Back up one chunk.  Return the position of the spacebefore the back number."	| back pp aPiece isDigitFlag |	aFile skip: -2.	isDigitFlag _ false.	[isDigitFlag] whileFalse:	[aPiece := aFile next. aPiece isNil ifTrue: [^0].	aPiece isDigit ifFalse: [aFile skip: -2] ifTrue: [isDigitFlag _true].].	"[aFile next isDigit] whileFalse: [aFile skip: -2]." "This wasTed's elegant version.									Theuglier one above is to be able to test backing up too far."	aFile skip: -2.	[pp _ aFile position + 1. aFile next isDigit] whileTrue: [		aFile skip: -2].	back  _ (aFile upTo: $!!) asNumber.	aFile position: pp; skip: 0-back.	^ pp "now positioned at the end"! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/7/1998 11:30'!chunk1	^self formatForOutput	"| who |	^ String streamContents: [:ss |		ss nextPutAll: 'self name: '; nextPutAll: name printString;		nextPutAll: ' date: '''; nextPutAll: date mmddyyyy.		ss nextPutAll: ''' time: '''.  time print24: true on: ss.		who _ user class == String ifFalse: [address] ifTrue: [user].		who ifNil: [who _ 'unknown user'].		ss nextPutAll: ''' by: '; nextPutAll: who printString.		ss nextPutAll: ' text: ']"! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/10/1998 14:16'!formatForOutput	^ String streamContents: [:ss |		ss nextPutAll: 'self '.		self outputFormat do: [:block |							ss nextPutAll:(block value: self)					"ifError: [:msg :rec |							 ss nextPutAll:'*** ', rec asString, ': ', msgasString ]"].		ss nextPutAll: 'text: ']."		   nextPutAll: name printString;		   nextPutAll: ' date: ''';		   nextPutAll: date mmddyyyy.		ss nextPutAll: ''' time: '''.		     Time now print24: true on: ss.		who _ user class == String					ifFalse: [address]					ifTrue: [user].		who ifNil: [who _ 'unknown user'].		ss nextPutAll: ''' by: ';		   nextPutAll: who printString.		ss nextPutAll: ' text: ']"! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 20:15'!fromFileNamed: filePath action: aSwikiAction	"Fill in all parts of this page from the info in its file"	| theFile |	map _ aSwikiAction urlmap.	file _ filePath.	theFile _ FileStream oldFileNamed: file.	coreID _ theFile localName.	url _ aSwikiAction name, '.', coreID.	self scanFrom: theFile.	"name, date"! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 19:43'!name: pageName date: dateString time: timeString by: who text: theStringback: bytes	"Record the name of this page during startup.  When reading thepage in order to serve it, this is NOT executed.  The text is read from thefile explicitly."	name _ pageName.	date _ dateString asDate.	time _ timeString asTime.	address _ who! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/8/1998 18:08'!text: theString back: bytes	"Record the name of this page during startup.  When reading the page inorder to serve it, this is NOT executed.  The text is read from the fileexplicitly.""Which means that you'd better not cascade text & back or you're royallyscrewed ;) BJP"! !!SwikiPage methodsFor: 'insertion points' stamp: 'tk 7/13/1998 13:33'!unique: aTag in: aSet	"If aTag is not in aSet, put it in and return aTag.  If it's there,make up a new tag, insert it, and return it.  For keeping insertion pointsin text unique, so can tell where to put incoming text."	| base new |	((aSet includes: aTag) not and: [aTag size > 0]) ifTrue: [aSet add:aTag.  ^ aTag].	base _ 0.	[new _ (100 atRandom + base) printString.		aSet includes: new] whileTrue:			[base _ base + 50].	aSet add: new.	^ new! !!SwikiPage methodsFor: 'insertion points' stamp: 'tk 7/14/1998 20:52'!uniqueInsertionPoints: aString	"Find all occurances of '*append here'.  Make them lower case.  Ifthey don't have a number after them, assign one.  Don't use the same numbertwice in this page.  Place ID can actually be any string."| sourceStream targetStream ids char pos inside rest |sourceStream := ReadStream on: aString.targetStream := WriteStream on: String new.ids _ Set new.	"id numbers that have been used"[sourceStream atEnd	] whileFalse: [	targetStream nextPut: (char _ sourceStream next).	char == $* ifTrue: [		pos _ sourceStream position.		inside _ sourceStream upTo: $*.		(inside asLowercase beginsWith: 'append here')			ifFalse: [sourceStream position: pos.	"ignore"				((inside = '') and: [sourceStream atEndnot]) ifTrue: [					targetStream nextPut: (char _sourceStream next)]]	"Honor **"			ifTrue: ["See if it has a number"				targetStream nextPutAll: 'append here '.				rest _ inside copyFrom: (13 min: insidesize +1) to: inside size.				targetStream nextPutAll: (self unique: restin: ids); nextPut: $*]]].^ targetStream contents! !!PSwikiPage methodsFor: 'all' stamp: 'BJP 9/10/1998 14:33'!outputFormat	| formatCollection textBlock |"Ah, yes, my first experience with class vars. I need to think about thisscheme a bit, but it's only	 a placeholder anyway. BJP"	formatCollection _ OrderedCollection newFrom: super outputFormat.	textBlock _ formatCollection last.	^ formatCollection		add: [:thePage | 'authName: ', thePage usernameprintString, '; ']before: textBlock;		add: [:thePage | 'authPW: ', thePage password printString,'; ']before: textBlock;		add: [:thePage | 'privs: ', thePage privs printString, '; ']before: textBlock.! !!SwikiPage class reorganize!('initialization' initialize)('accessing' outputFormat)!!SwikiPage class methodsFor: 'initialization' stamp: 'BJP 9/7/1998 12:23'!initialize	"SwikiPage initialize"	OutputFormat _ OrderedCollection new.	OutputFormat		add: [:thePage | 'name: ', thePage name printString, '; '];		add: [:thePage | 'date: ', thePage date mmddyyyyprintString, '; '];		add: [:thePage | 'time: ''', thePage time asString, '''; '];		add: [:thePage | 'by: ', thePage by printString, '; '];		add: [:thePage | 'pageStatus: #', thePage pageStatus, '; ']";		add: [:thePage | 'text: ']."! !!SwikiPage class methodsFor: 'accessing' stamp: 'BJP 9/7/1998 11:32'!outputFormat	^OutputFormat! !!URLmap methodsFor: 'linking' stamp: 'mjg 9/1/1998 12:41'!linkFor: string from: peer storingTo: aList	| uString newpage |	uString _ string asUppercase.	(self isStringRooted: uString)		ifTrue: ["an external URL"			(self isStringAnImage: uString)				ifTrue: ["Looks like an image URL"						^self imageURL: string]				ifFalse: [^self externalURL: string]]		ifFalse: [ "Serious!! Gotta provide-a-link!! But check forimage or local action first"				(self isStringAnImage: uString)					ifTrue: [^self localImageURL: string].				(self isStringALocalAction: uString)					ifTrue:[^self localActionURL: string].			newpage _ pages at: string asLowercase ifAbsent: [nil].			newpage isNil				ifTrue: [ "Create a new page"					newpage _ self newpage: stringfrom: peer.].			(aList indexOf: newpage) ~= 0				ifFalse: [aList add: newpage]. "Add only ifnot there"			^self pageURL: newpage]! !!URLmap methodsFor: 'linking' stamp: 'mjg 9/1/1998 12:47'!linkFor: string from: peer storingTo: aList page: aPage	| uString placeID |	uString _ string asUppercase.	(uString beginsWith: 'APPEND HERE') ifTrue: [		placeID _ uString copyFrom: (13 min: uString size) to:uString size.		^'<a href="', aPage url, '.insert.', placeID ,'">','AppendHere','</a>'].			"later an image here"	^self linkFor: string from: peer storingTo: aList.! !!URLmap methodsFor: 'searching' stamp: 'BJP 9/7/1998 01:06'!recent	| response sortedPages currentDate |	sortedPages _ pages reject: [:page | page pageStatus = #new]."We definitely want the reject: first, so we sort a smaller collection.Having the variable name be 'sortedPages' is a bit of a misnomer, though.""I think we shouldn't do all this for each call to recent changes. Afterall, most of the time, it's *hasn't* changed, and when it *has*, it'spretty much only added something to the end. At the very least we shouldcache the sorted, filtered collection.""And really, why is this in URLmap? Recent Changes is a kind of page. I'drather see it as a swikipage, perhaps standardly defined (that is, when youset up a swiki, you get a front page, a formatting page, and a RecentChanges page). That is, SwikiPages could store text (as they do now) orcgi-ish functions (like recent). That way, we could design custom templatesfor them, etc.At the very least, there needs to be better labeling. Why not call thecategory with these page functions, 'dynamic pages', or somethign similar?""A different condsideration: It would be nice to have arbitrary filters:e.g., 'past ten days', 'all pages *not* yet edited', etc., and be able tocombine them. Would work as a 'search for various attributes' feature whichone might or might not expose to the user."	sortedPages _ sortedPages asSortedCollection: [:a :b | (a date = bdate) ifTrue: [a time > b time]			ifFalse: [a date > b date]].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'.	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDateprintString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageURL: page),'...',(pageaddress).].	response nextPutAll: '</ul>'.	^response contents		! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:16'!externalURL: aString	"make a non-local  URL"	^'<a href="',aString,'">',aString,'</a>'! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:15'!imageURL: aString	"make a non-local image URL"	^'<img src="', aString,'" alt="', aString,'">'! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:10'!localActionURL: aString	|string|	"fake up a more ordinary URL by dropping the shriek chars"	string _ aString copyWithout: $!!.	^'<a href="',string,'">',string,'</a>'! !!URLmap methodsFor: 'accessing' stamp: 'mjg 9/1/1998 12:32'!localImageURL: aString	"make a local image URL"	^'<img src="',action name, '/', aString,'" alt="', action name,'/',aString,'">'! !!URLmap methodsFor: 'accessing' stamp: 'mjg 9/11/1998 10:32'!pageURL: aPage	(aPage pageStatus = #new)		ifTrue:			[^'<u>',(aPage name),'</u><a href="', (actionpageURL: aPage),'.edit">?</a>'] "Underlines new but not yet edited pages"		ifFalse:			[^'<a href="', (action pageURL: aPage),'">',(aPagename),'</a>']"Logically, there should be editPageUrl in SwikiAction as well. After all,we might want to define other URL schemes." ! !!URLmap methodsFor: 'creating' stamp: 'BJP 9/7/1998 00:52'!allPagesFrom: pageRef for: request	| formattedPage refPages allPages peer |	(request isKindOf: PWS) ifTrue: [peer _ request peerName] ifFalse:[peer_''].	formattedPage _ pageRef copy.  "Make a copy, then format the text."	refPages _ OrderedCollection new.	formattedPage formatted: (action formatter swikify: (pageRef text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo: refPages]).	"This filtering should be generalized a tad, methinks. Perhapsincorparated into the	linkhandler."	refPages _ refPages reject: [:page | page pageStatus = #new].	"Now, put all referenced pages into the page"	allPages _ WriteStream on: String new.	allPages nextPutAll: '<h2>',(pageRef name),'</h2>', formattedPageformatted.	refPages do: [:page |		allPages nextPutAll: '<h2>',(page name),'</h2>'.		allPages nextPutAll: (HTMLformatter swikify: (page text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo:(OrderedCollection new)]).].	formattedPage formatted: allPages contents. "Put all the pages into THEpage"	^formattedPage! !!URLmap methodsFor: 'creating' stamp: 'mjg 9/10/1998 15:24'!newpage: label from: peer	| newpage newfile |	newfile _ ((pages inject: 0 into: [:max :p |		p coreID asNumber > max ifTrue: [p coreID asNumber]				ifFalse: [max]]) + 1) printString.	newpage _ SwikiPage new.	self at: label put: newpage.	newpage address: peer.	newpage date: (Date today).	newpage time: (Time now).	newpage coreID: newfile.	newpage name: label.	newpage file: ((ServerAction serverDirectory),		directory, (ServerAction pathSeparator), newfile).	newpage pageStatus: #new.	newpage text: 'Describe ',label,' here'.	newpage map: self.	newpage url: (action name),'.',newfile.	^newpage! !!URLmap methodsFor: 'creating' stamp: 'mjg 8/28/1998 19:48'!storeID: id text: text from: peer	| page |	page _ self atID: id.	page date: (Date today).	page time: (Time now).	page text: text.	page address: peer.	^ page! !!URLmap methodsFor: 'creating' stamp: 'tk 7/14/1998 19:32'!storeID: id text: insertedText insertAt: idString	"Insert in a place in the text.  Just before '*append here 34*' ifidString is '34'."	| page bigText ind toInsert |	page _ self atID: id.	page date: (Date today).	bigText _ page text.	ind _ bigText findString: '*append here ',idString,'*' startingAt:1.	"always lower case"	ind = 0 ifTrue: [^ page].		"could not find that place"	"Make sure new text surrounded by line feeds"	toInsert _ (insertedText last == Character linefeed)		ifTrue: [insertedText]		ifFalse: [insertedText, (String with: Character linefeed)].	((insertedText first == Character linefeed) or: [		(bigText at: (ind-1 max: 1)) == Character linefeed])			ifFalse: [toInsert _ (String with: Characterlinefeed), toInsert].	page text: (bigText copyReplaceFrom: ind to: ind-1 with: toInsert).	"page address: peer.  Don't sign with person who only added"	^ page! !!URLmap methodsFor: 'private' stamp: 'TPR 7/27/1998 14:51'!isStringALocalAction: anUpperCasedString	"check the string to see if it starts and end with  a shriek - codefor a Swiki action such as Comment or whatever"	^(anUpperCasedString size >=2) and:	[anUpperCasedString first = $!! and:	[anUpperCasedString last= $!!]]! !!URLmap methodsFor: 'private' stamp: 'TPR 7/27/1998 14:39'!isStringAnImage: anUpperCasedString	"check the string to see if it end with something that makes itlkely to be an image URL"	^(anUpperCasedString endsWith: 'GIF') or:		[(anUpperCasedString endsWith: 'JPEG') or:		[anUpperCasedString endsWith: 'JPG']]! !!URLmap methodsFor: 'private' stamp: 'TPR 7/27/1998 14:37'!isStringRooted: anUpperCasedString	"check the string to see if it starts with something that makes itlkely to be a rooted URL"	^(anUpperCasedString indexOfSubCollection: 'HTTP' startingAt: 1) =1 or:	[(anUpperCasedString indexOfSubCollection: 'FTP' startingAt: 1) = 1 or:	[(anUpperCasedString indexOfSubCollection: 'MAILTO' startingAt: 1)= 1]]! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 8/31/1998 16:53'!addToGlossary: myName as: myURL	|aStream |	"Add to a CR-delimited file of 'pageName' and 'URL' separated byvertical bars '|'"	aStream _ directory oldFileNamed: 'glossary'.	aStream open.	aStream setToEnd.	aStream nextPutAll: myName,'|',myURL; cr.	aStream close.	! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 9/1/1998 09:44'!readGlossary: aStream	|aLine pieces name url newpage|	"Expect a CR-delimited file of 'pageName' and 'URL' separated byvertical bars '|'"	self pages: (Dictionary new).	aStream open.	[aStream atEnd] whileFalse:		[aLine := aStream upTo: (Character cr).		pieces _ aLine findTokens: '|'.		name _ pieces at: 1.		url _ pieces at: 2.		newpage _ SwikiPage new.		newpage coreID: url.		newpage map: self.		newpage name: name.		pages at: name asLowercase put: newpage].	aStream close.	! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 9/1/1998 09:47'!writeGlossary	"Write out the pages dictionary as a CR-delimited file of pagenameand URL"	|aStream |	aStream _ directory oldFileNamed: 'glossary'.	aStream open.	pages keys asSortedCollection do: [:each |		aStream nextPutAll: (pages at: each) name,'|',(pages at:each) coreID; cr.].	aStream close.	! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:40'!allPagesFrom: pageRef for: request	| formattedPage refPages allPages peer |	(request isKindOf: PWS) ifTrue: [peer _ request peerName] ifFalse:[peer_''].	formattedPage _ pageRef copy.  "Make a copy, then format the text."	refPages _ OrderedCollection new.	formattedPage formatted: (action formatter swikify: (pageRef text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo: refPages]).	refPages _ refPages reject: [:page | page pageStatus = #new].	"Now, put all referenced pages into the page"	allPages _ WriteStream on: String new.	allPages nextPutAll: '<h2>',(pageRef name),'</h2>', formattedPageformatted.	refPages do: [:page |		(page privs includesSubString: 'read') ifTrue:			[(action auth user: request userID) = page coreID			ifFalse: [self error: (PWS unauthorizedFor: (pagename))]].		allPages nextPutAll: '<h2>',(page name),'</h2>'.		allPages nextPutAll: (HTMLformatter swikify: (page text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo:(OrderedCollection new)]).].	formattedPage formatted: allPages contents. "Put all the pages into THEpage"	^formattedPage! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:36'!newpage: label from: peer	| newpage newfile |		newpage _ PSwikiPage new.		self at: label put: newpage.		newfile _ pages size printString.		newpage address: peer.		newpage date: (Date today).		newpage coreID: newfile.		newpage name: label.		newpage username: ''.		newpage password: ''.		newpage privs: ''.		newpage pageStatus: #new.		newpage file: ((ServerAction serverDirectory),			directory, (ServerAction pathSeparator), newfile).		newpage text: 'Describe ',label,' here'.		newpage map: self.		newpage url: (action name),'.',newfile.	^newpage! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:39'!recent	| response sortedPages currentDate |	sortedPages _ pages reject: [:page | page pageStatus = #new].	sortedPages _ sortedPages asSortedCollection: [:a :b | (a date = bdate) ifTrue: [a time > b time]			ifFalse: [a date > b date]].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'.	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDateprintString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageURL:page),'...',(page address).		(page privs includesSubString: 'read') ifTrue:			[response nextPutAll: '  <b>Read protected</b>'.].		(page privs includesSubString: 'write') ifTrue:			[response nextPutAll: '  <b>Write protected</b>'.].].	response nextPutAll: '</ul>'.	^response contents! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:41'!storeID: id  username: theUsername password: thePassword privs: thePrivstext: text from: peer	| page |	page _ self atID: id.	page date: (Date today).	page address: peer.	(theUsername size > 1) ifTrue: [		page username: theUsername.		page password: thePassword.		page privs: thePrivs.		"Set up the authorization"		action auth mapName: theUsername password: thePassword			to: id.].	page text: text.	^ page! !RenderingSwikiAction removeSelector: #generate:from:!PSwikiPage removeSelector: #chunk1!SwikiPage initialize!URLmap removeSelector: #linkFor:to:withPrefix:storingTo:!URLmap removeSelector: #pageCacheURL:!URLmap removeSelector: #linkForCache:from:storingTo:!URLmap removeSelector: #searchCacheFor:!URLmap removeSelector: #recentCache!URLmap removeSelector: #storePage:text:from:!"Postscript:The new save and restore code requires the SwikiPage class var'OutputFormat' to be initialized to the standard set."SwikiPage initialize.!