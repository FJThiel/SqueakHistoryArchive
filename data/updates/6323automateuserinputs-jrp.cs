'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 17 October 2004 at 12:23:15 pm'!"Change Set:		automate.user.inputs-jrpDate:			4 October 2004Author:			John PierceWhen performing batch processing activities, like a configuration script that I've worked up to auto-build my Squeak images with my favorite programs, you will inevitably run into SqueakMap packages, Monticello packages, and other programs that require user input during their installation.This changeset will add an enhancement to PopUpMenu and FillInTheBlankMorph such that they can request answers to their questions by signaling a ProvideAnswerNotification.  On BlockContext I provide helpers to catch this notification and look for an appropriate answer in one of the provided parameters.  The basic syntax looks like:	[self confirm: 'Install spyware?'] valueSupplyingAnswer: #('Install spyware?' false)There a few variants on this theme making it easy to provide a literal list of answers for the block so that you can handle a bunch of questions in a block with appropriate answers.Additionally, I make it possible to suppress Object>>inform: modal messages as these get in the way of automated batch scripts.  After applying this changeset you should be able to tryout the following code snippets to see the variants I made available.Note:  I could be convinced that the 'helpers' should not be on BlockContext, but I started there as it was the simplest syntax and, thus, my first choice.  For advanced usage, check out my configuration script that auto-builds a fresh 3.7 image at: www.saltypickle.com/Home/xp and most definitely needs this sort of automation.Examples:So you don't need any introduction here -- this one works like usual.[self inform: 'hello'. #done] value.Now lets suppress all inform: messages.[self inform: 'hello'; inform: 'there'. #done] valueSuppressingAllMessages.Here we can just suppress a single inform: message.[self inform: 'hi'; inform: 'there'. #done] valueSuppressingMessages: #('there')Here you see how you can suppress a list of messages.[self inform: 'hi'; inform: 'there'; inform: 'bill'. #done] valueSuppressingMessages: #('hi' 'there')Enough about inform:, let's look at confirm:. As you see this one works as expected.[self confirm: 'You like Squeak?'] valueLet's supply answers to one of the questions -- check out the return value.[{self confirm: 'You like Smalltalk?'. self confirm: 'You like Squeak?'}]	valueSupplyingAnswer: #('You like Smalltalk?' true)Here we supply answers using only substrings of the questions (for simplicity).[{self confirm: 'You like Squeak?'. self confirm: 'You like MVC?'}]	valueSupplyingAnswers: #( ('Squeak' true) ('MVC' false) )This time let's answer all questions exactly the same way.[{self confirm: 'You like Squeak?'. self confirm: 'You like Morphic?'}]	valueSupplyingAnswer: true	And, of course, we can answer FillInTheBlank questions in the same manner.[FillInTheBlank request: 'What day is it?']	valueSupplyingAnswer: 'the first day of the rest of your life'	We can also return whatever the initialAnswer of the FillInTheBlank was by using the #default answer.[FillInTheBlank request: 'What day is it?' initialAnswer: DateAndTime now dayOfWeekName]	valueSupplyingAnswer: #default	Finally, I made it so you can also do regex matches on any of the question text (or inform text).[FillInTheBlank request: 'What day is it?']	valueSupplyingAnswers: { {'What day.*\?'. DateAndTime now dayOfWeekName} }"!!BlockContextTest commentStamp: 'jrp 10/17/2004 12:22' prior: 0!I am an SUnit Test of BlockContext and its supertype ContextPart.  See also MethodContextTest.My fixtures are:aBlockContext     - just some trivial block, i.e., [100@100 corner: 200@200].NOTES ABOUT AUTOMATING USER INPUTSWhen executing non-interactive programs you will inevitably run into programs (like SqueakMap or Monticello installation packages -- and other programs, to be fair) that require user input during their execution and these sort of problems shoot the whole non-interactiveness of your enclosing program.BlockContext helper methods have been made available and tests of these helpers are provided in this class to demonstrate that it can intercept PopUpMenu and FillInTheBlankMorph requests for user interaction.  Of course, PopUpMenu and FillInTheBlankMorph were modified to first signal a ProvideAnswerNotification and if someone handles that (e.g. the enclosing block) then the user interaction will be circumvented and the provided answer of the enclosing block will be used.  The basic syntax looks like:	[self confirm: 'Install spyware?'] valueSupplyingAnswer: #('Install spyware?' false)There a few variants on this theme making it easy to provide a literal list of answers for the block so that you can handle a bunch of questions in a block with appropriate answers.Additionally, it is possible to suppress Object>>inform: modal dialog boxes as these get in the way of automating anything.  After applying this changeset you should be able to tryout the following code snippets to see the variants on this theme that are available.Examples:So you don't need any introduction here -- this one works like usual.[self inform: 'hello'. #done] value.Now let's suppress all inform: messages.[self inform: 'hello'; inform: 'there'. #done] valueSuppressingAllMessages.Here we can just suppress a single inform: message.[self inform: 'hi'; inform: 'there'. #done] valueSuppressingMessages: #('there')Here you see how you can suppress a list of messages.[self inform: 'hi'; inform: 'there'; inform: 'bill'. #done] valueSuppressingMessages: #('hi' 'there')Enough about inform:, let's look at confirm:. As you see this one works as expected.[self confirm: 'You like Squeak?'] valueLet's supply answers to one of the questions -- check out the return value.[{self confirm: 'You like Smalltalk?'. self confirm: 'You like Squeak?'}]	valueSupplyingAnswer: #('You like Smalltalk?' true)Here we supply answers using only substrings of the questions (for simplicity).[{self confirm: 'You like Squeak?'. self confirm: 'You like MVC?'}]	valueSupplyingAnswers: #( ('Squeak' true) ('MVC' false) )This time let's answer all questions exactly the same way.[{self confirm: 'You like Squeak?'. self confirm: 'You like Morphic?'}]	valueSupplyingAnswer: true	And, of course, we can answer FillInTheBlank questions in the same manner.[FillInTheBlank request: 'What day is it?']	valueSupplyingAnswer: 'the first day of the rest of your life'	We can also return whatever the initialAnswer of the FillInTheBlank was by using the #default answer.[FillInTheBlank request: 'What day is it?' initialAnswer: DateAndTime now dayOfWeekName]	valueSupplyingAnswer: #default	Finally, you can also do regex matches on any of the question text (or inform text) (should you have VB-Regex enhancements in your image).[FillInTheBlank request: 'What day is it?']	valueSupplyingAnswers: { {'What day.*\?'. DateAndTime now dayOfWeekName} }!Notification subclass: #ProvideAnswerNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!BlockContext methodsFor: 'evaluating' stamp: 'jrp 10/10/2004 22:28'!valueSupplyingAnswer: anObject	^ (anObject isCollection and: [anObject isString not])		ifTrue: [self valueSupplyingAnswers: {anObject}]		ifFalse: [self valueSupplyingAnswers: {{'*'. anObject}}]! !!BlockContext methodsFor: 'evaluating' stamp: 'jrp 10/10/2004 22:15'!valueSupplyingAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^ [self value] 		on: ProvideAnswerNotification		do: 			[:notify | | answer caption tryRegex |						caption _ notify messageText withSeparatorsCompacted. "to remove new lines"			answer _ aListOfPairs				detect: 					[:each | caption = each first or:						[caption includesSubstring: each first caseSensitive: false] or:						[each first match: caption] or: 						[(String includesSelector: #matchesRegex:) and: 							[[caption matchesRegex: each first] on: RegexError do: [:ex | false]]]]					ifNone: [nil].			answer				ifNotNil: [notify resume: answer second]				ifNil: 					[ | outerAnswer |					outerAnswer _ ProvideAnswerNotification signal: notify messageText.					outerAnswer 						ifNil: [notify resume] 						ifNotNil: [notify resume: outerAnswer]]]! !!BlockContext methodsFor: 'evaluating' stamp: 'jrp 10/10/2004 22:28'!valueSuppressingAllMessages	^ self valueSuppressingMessages: #('*')! !!BlockContext methodsFor: 'evaluating' stamp: 'jrp 10/4/2004 18:59'!valueSuppressingMessages: aListOfStrings	^ self		valueSuppressingMessages: aListOfStrings		supplyingAnswers: #()! !!BlockContext methodsFor: 'evaluating' stamp: 'jrp 10/4/2004 18:58'!valueSuppressingMessages: aListOfStrings supplyingAnswers: aListOfPairs	^ self valueSupplyingAnswers: aListOfPairs, (aListOfStrings collect: [:each | {each. true}])! !!BlockContextTest methodsFor: 'testing' stamp: 'jrp 10/4/2004 19:29'!testSupplyAnswerOfFillInTheBlank	self should: ['blue' = ([FillInTheBlank request: 'Your favorite color?'] 		valueSupplyingAnswer: #('Your favorite color?' 'blue'))]! !!BlockContextTest methodsFor: 'testing' stamp: 'jrp 10/4/2004 19:30'!testSupplyAnswerOfFillInTheBlankUsingDefaultAnswer	self should: ['red' = ([FillInTheBlank request: 'Your favorite color?' initialAnswer: 'red'] 		valueSupplyingAnswer: #('Your favorite color?' #default))]! !!BlockContextTest methodsFor: 'testing' stamp: 'jrp 10/10/2004 22:19'!testSupplyAnswerThroughNestedBlocks	self should: [true = ([[self confirm: 'You like Smalltalk?'] 		valueSupplyingAnswer: #('Blub' false)] valueSupplyingAnswer: #('Smalltalk' true))]! !!BlockContextTest methodsFor: 'testing' stamp: 'jrp 10/4/2004 19:27'!testSupplyAnswerUsingOnlySubstringOfQuestion	self should: [false = ([self confirm: 'You like Smalltalk?'] 		valueSupplyingAnswer: #('like' false))]! !!BlockContextTest methodsFor: 'testing' stamp: 'jrp 10/10/2004 22:31'!testSupplyAnswerUsingRegexMatchOfQuestion	(String includesSelector: #matchesRegex:) ifFalse: [^ self].		self should: [true = ([self confirm: 'You like Smalltalk?'] 		valueSupplyingAnswer: #('.*Smalltalk\?' true))]! !!BlockContextTest methodsFor: 'testing' stamp: 'jrp 10/10/2004 22:17'!testSupplyAnswerUsingTraditionalMatchOfQuestion	self should: [true = ([self confirm: 'You like Smalltalk?'] 		valueSupplyingAnswer: #('*Smalltalk#' true))]! !!BlockContextTest methodsFor: 'testing' stamp: 'jrp 10/4/2004 19:25'!testSupplySameAnswerToAllQuestions	self should: [true = ([self confirm: 'You like Smalltalk?'] valueSupplyingAnswer: true)].		self should: [#(true true) = ([{self confirm: 'One'. self confirm: 'Two'}] valueSupplyingAnswer: true)].! !!BlockContextTest methodsFor: 'testing' stamp: 'jrp 10/4/2004 19:39'!testSupplySeveralAnswersToSeveralQuestions	self should: [#(false true) = ([{self confirm: 'One'. self confirm: 'Two'}] 		valueSupplyingAnswers: #( ('One' false) ('Two' true) ))].		self should: [#(true false) = ([{self confirm: 'One'. self confirm: 'Two'}] 		valueSupplyingAnswers: #( ('One' true) ('Two' false) ))]! !!BlockContextTest methodsFor: 'testing' stamp: 'jrp 10/4/2004 19:26'!testSupplySpecificAnswerToQuestion	self should: [false = ([self confirm: 'You like Smalltalk?'] 		valueSupplyingAnswer: #('You like Smalltalk?' false))]! !!BlockContextTest methodsFor: 'testing' stamp: 'jrp 10/4/2004 19:35'!testSuppressInform	self should: [[nil inform: 'Should not see this message or this test failed!!'] valueSuppressingAllMessages isNil]! !!BlockContextTest methodsFor: 'testing' stamp: 'jrp 10/10/2004 22:29'!testSuppressInformUsingStringMatchOptions	self should: [([nil inform: 'Should not see this message or this test failed!!'] valueSuppressingMessages: #('Should not see this message or this test failed!!')) isNil].		self should: [([nil inform: 'Should not see this message or this test failed!!'] valueSuppressingMessages: #('not see this message')) isNil].		self should: [([nil inform: 'Should not see this message or this test failed!!'] valueSuppressingMessages: #('*message*failed#')) isNil].! !!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'jrp 10/4/2004 16:06'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	w _ self world.	w ifNil: [^ response].		(ProvideAnswerNotification signal:		(self submorphOfClass: TextMorph) userString) ifNotNilDo:		[:answer |		self delete.		w doOneCycle.		^ response _ (answer == #default) ifTrue: [response] ifFalse: [answer]].	done _ false.	w activeHand newKeyboardFocus: textPane.	[done] whileFalse: [w doOneCycle].	self delete.	w doOneCycle.	^ response! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jrp 10/4/2004 16:06'!startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released,	Answer the index of the current selection, or zero if the mouse is not released over  any menu item. Location specifies the desired topLeft of the menu body rectangle. The final argument indicates whether the menu should seize the keyboard focus in order to allow the user to navigate it via the keyboard."	| maxHeight |	(ProvideAnswerNotification signal: captionOrNil) ifNotNilDo:		[:answer | ^ selection _ answer ifTrue: [1] ifFalse: [2]].		 	maxHeight _ Display height*3//4.	self frameHeight > maxHeight ifTrue:		[^ self			startUpSegmented: maxHeight			withCaption: captionOrNil			at: location			allowKeyboard: aBoolean].	Smalltalk isMorphic		ifTrue:[			selection _ Cursor normal showWhile:				[(MVCMenuMorph from: self title: captionOrNil) 					invokeAt: location 					in: ActiveWorld					allowKeyboard: aBoolean].			^ selection].	frame ifNil: [self computeForm].	Cursor normal showWhile:		[self			displayAt: location			withCaption: captionOrNil			during: [self controlActivity]].	^ selection! !