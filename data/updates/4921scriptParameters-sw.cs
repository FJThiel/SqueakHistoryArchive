'From Squeak3.3alpha of 18 January 2002 [latest update: #4920] on 20 July 2002 at 2:39:21 pm'!"Change Set:		scriptParameters-swDate:			20 July 2002Author:			Scott WallaceAllows any user-defined etoy script to have a parameter.To add a parameter, invoke 'add parameter' from Scriptor or Viewer menu.Change parameter *type* from the Scriptor header, using up/down arrows or clicking for menu.Obtain a parameter tile by dragging from the parameter position in the Scriptor header.Caution: This applies to 'classic tiles' only.  'Universal tiles' are not handled by this work.Note: the following is a hand-jimmied class-definition for ParameterTile to make it ok both on 3.2 and 3.3"TileMorph subclass: #ParameterTile	instanceVariableNames: 'scriptEditor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting Tiles'	module: #(Squeak EToy Scripting Tiles).!TileMorph subclass: #ParameterTile	instanceVariableNames: 'scriptEditor '	classVariableNames: ''	module: #(Squeak EToy Scripting Tiles)!!ParameterTile commentStamp: '<historical>' prior: 0!Represents a parameter in a user-defined script in "classic" tile-scripting.  The type of a script's parameter is declared in the ScriptEditor for the script, and a parameter tile gets its type from the script.  But because the user can change the parameter type *after* having created parameter tiles, we can later have type mismatches.  Which however we at least deal with reasonably cleverly.!!SymbolListTile commentStamp: '<historical>' prior: 0!Instances of SymbolListTile are literal tiles whose literals are choosable from a finite list.!SymbolListTile subclass: #TypeListTile	instanceVariableNames: ''	classVariableNames: ''	module: #(Squeak EToy Scripting Tiles)!!TypeListTile commentStamp: '<historical>' prior: 0!A tile that offers a list of supported data types.!!CategoryViewer methodsFor: 'entries' stamp: 'sw 7/17/2002 19:13'!phraseForCommandFrom: aMethodInterface	"Answer a phrase for the non-slot-like command represented by aMethodInterface - classic tiles"	| aRow resultType cmd names argType argTile selfTile aPhrase balloonTextSelector stat inst aDocString universal tileBearingHelp |	aDocString _ aMethodInterface documentationOrNil.	aDocString = 'no help available' ifTrue: [aDocString _ nil].	names _ scriptedPlayer class namedTileScriptSelectors.	resultType _ aMethodInterface resultType.	cmd _ aMethodInterface selector.	(universal _ scriptedPlayer isUniversalTiles)		ifTrue:			[aPhrase _ scriptedPlayer universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs == 0			ifTrue:				[aPhrase _ PhraseTileMorph new vocabulary: self currentVocabulary.				aPhrase setOperator: cmd					type: resultType					rcvrType: #Player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType _ aMethodInterface typeForArgumentNumber: 1.				aPhrase _ PhraseTileMorph new vocabulary: self currentVocabulary.				aPhrase setOperator: cmd					type: resultType					rcvrType: #Player					argType: argType.				argTile _ ScriptingSystem tileForArgType: argType.				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(scriptedPlayer slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector _ #userSlot].	(scriptedPlayer belongsToUniClass and: [scriptedPlayer class includesSelector: cmd])		ifTrue:			[aDocString ifNil:				[aDocString _ (scriptedPlayer class userScriptForPlayer: scriptedPlayer selector: cmd) documentationOrNil].			aDocString ifNil:				[balloonTextSelector _ #userScript]].	tileBearingHelp _ universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]. 	aDocString		ifNotNil:			[tileBearingHelp setBalloonText: aDocString]		ifNil:			[balloonTextSelector ifNil:				[tileBearingHelp setProperty: #inherentSelector toValue: cmd.				balloonTextSelector _ #methodComment].			tileBearingHelp balloonTextSelector: balloonTextSelector].	aPhrase markAsPartsDonor.	cmd == #emptyScript ifTrue:		[aPhrase setProperty: #newPermanentScript toValue: true.		aPhrase setProperty: #newPermanentPlayer toValue: scriptedPlayer.		aPhrase submorphs second setBalloonText: 'drag and drop to add a new script'].	universal ifFalse:		[selfTile _ self tileForSelf.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile].	aRow _ ViewerLine newRow borderWidth: 0; color: self color.	aRow elementSymbol: cmd asSymbol.	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 4@2; beTransparent).	aRow addMorphBack: (self infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	(names includes: cmd) ifTrue:		[aPhrase userScriptSelector: cmd.		cmd numArgs == 0 ifTrue:			[aPhrase beTransparent.			aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.			aRow addMorphBack: (stat _ (inst _ scriptedPlayer scriptInstantiationForSelector: cmd) statusControlMorph).			inst updateStatusMorph: stat]].	aRow beSticky; disableDragNDrop.	^ aRow! !!MethodWithInterface methodsFor: 'rename' stamp: 'sw 7/18/2002 02:20'!renameScript: newSelector fromPlayer: aPlayer	"The receiver's selector has changed to the new selector.  Get various things right, including the physical appearance of any Scriptor open on this method"	self allScriptEditors do:		[:aScriptEditor | aScriptEditor renameScriptTo: newSelector].	(selector numArgs = 0 and: [newSelector numArgs = 1])		ifTrue:			[self argumentVariables: (OrderedCollection with:				(Variable new name: #parameter type: #Number))].	(selector numArgs = 1 and: [newSelector numArgs = 0])		ifTrue:			[self argumentVariables: OrderedCollection new].	selector _ newSelector asSymbol.	self bringUpToDate.	self playerClass atSelector: selector putScript: self.! !!ParameterTile methodsFor: 'initialization' stamp: 'sw 7/18/2002 02:32'!forScriptEditor: aScriptEditor	"Make the receiver be associated with the given script editor"	scriptEditor _ aScriptEditor.	self line1: aScriptEditor typeForParameter! !!ParameterTile methodsFor: 'initialization' stamp: 'sw 7/18/2002 02:32'!initialize	"Initialize the receiver"	super initialize.	self typeColor: Color red! !!ParameterTile methodsFor: 'access' stamp: 'sw 7/4/2002 23:41'!scriptEditor	"Answer the receiver's script editor.  The slightly strange code here is in order to contend with the unusual situation where a parameter tile obtained from one script editor is later dropped into a different script editor.  As long as the parameter tile is *in* a script editor, that containing scriptEditor is the one; if it is *not*, then we use the last known one"	| aScriptEditor |	^ (aScriptEditor _ self ownerThatIsA: ScriptEditorMorph)		ifNotNil:			[scriptEditor _ aScriptEditor]		ifNil:			[scriptEditor]! !!ParameterTile methodsFor: 'code generation' stamp: 'sw 7/18/2002 10:59'!storeCodeOn: aStream indent: tabCount	"Store code on the stream" 	| myTypeString |	myTypeString _ submorphs first contents.	(self scriptEditor hasParameter and: [self scriptEditor typeForParameter = myTypeString])		ifTrue:			[aStream nextPutAll: 'parameter']		ifFalse:			["This script no longer bears a parameter, yet there's an orphaned Parameter tile in it"			aStream nextPutAll: '(self defaultValueOfType: #', myTypeString, ')']! !!ParameterTile methodsFor: 'type' stamp: 'sw 7/18/2002 02:45'!resultType	"Answer the result type of the receiver"	^ self scriptEditor typeForParameter! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 7/20/2002 12:52'!scriptSelectorToTriggerFor: aButtonMorph	"Answer a new selector which will bear the code for aButtonMorph in the receiver"	| buttonName selectorName |	buttonName _ aButtonMorph externalName.	selectorName _ self assuredPlayer acceptableScriptNameFrom: buttonName  forScriptCurrentlyNamed: nil.	buttonName ~= selectorName ifTrue:		[aButtonMorph setNameTo: selectorName].	^ selectorName! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'sw 7/18/2002 10:38'!try	"Evaluate the given phrase once"	| aPlayer |	(userScriptSelector notNil and: [userScriptSelector numArgs = 0])		ifTrue:			[aPlayer _ self objectViewed player.			aPlayer perform: userScriptSelector]		ifFalse:			[Compiler evaluate:				self codeString				for: self associatedPlayer				logged: false]! !!Player methodsFor: 'costume' stamp: 'sw 7/18/2002 10:25'!ceaseHavingAParameterFor: aSelector	"Make the script represented by aSelector cease bearing a parameter"	self renameScript: aSelector newSelector: (aSelector copyWithout: $:) asSymbol! !!Player methodsFor: 'costume' stamp: 'sw 7/18/2002 11:26'!changeParameterTypeFor: aSelector	"Change the parameter type for the given selector.  Not currently sent, since types are now set by direct manipulation in the Scriptor header.  If this were reinstated someday, there would probably be an issue about getting correct-looking Parameter tile(s) into the Scriptor header(s)"	| current typeChoices typeChosen |	current _ self typeforParameterFor: aSelector.	typeChoices _ Vocabulary typeChoices.	typeChosen _ (SelectionMenu selections: typeChoices lines: #()) startUpWithCaption: 		('Choose the TYPEfor the parameter (currently ', current, ')').	self setParameterFor: aSelector toType: typeChosen! !!Player methodsFor: 'costume' stamp: 'sw 7/17/2002 19:31'!setParameterFor: aSelector toType: aTypeSymbol	"Set the parameter type for the given selector"	| aUniclassScript |	aTypeSymbol isEmptyOrNil ifTrue: [^ self].	(self typeforParameterFor: aSelector) = aTypeSymbol ifTrue: [^ self].	aUniclassScript _ self class scripts at: aSelector.	aUniclassScript argumentVariables first variableType: aTypeSymbol.	self updateAllViewersAndForceToShow: #scripts	! !!Player methodsFor: 'costume' stamp: 'sw 7/17/2002 16:50'!startHavingParameterFor: aSelector	"Start having a parameter for the given selector.  After this change, the script name will change by the addition of a colon."	self renameScript: aSelector newSelector: (aSelector, ':') asSymbol! !!Player methodsFor: 'costume' stamp: 'sw 7/5/2002 22:16'!typeforParameterFor: aSelector	"Answer the type of the parameter for the given selector"	(self class scripts at: aSelector ifAbsent: [nil]) ifNotNilDo:		[:aScript | ^ aScript argumentVariables first variableType].	self error: 'No parameter type for ', aSelector.	^ #Number! !!Player methodsFor: 'slots-user' stamp: 'sw 7/18/2002 11:15'!defaultValueOfType: aSymbol	"Answer a default value for the given type -- invoked in compiled user scripts when a parameter tile of the wrong type is present"	^ self initialValueForSlotOfType: aSymbol	"Not really intended for that purpose but seemingly serves adequately"! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 7/20/2002 14:24'!acceptableScriptNameFrom: originalString forScriptCurrentlyNamed: currentName	"Produce an acceptable script name, derived from the current name, for the receiver.  This method will always return a valid script name that will be suitable for use in the given situation, though you might not like its beauty sometimes."	| aString stemAndSuffix proscribed stem suffix withoutColon currentNumArgs withColon |	currentNumArgs _ currentName ifNil: [0] ifNotNil: [currentName numArgs].	withoutColon _ currentNumArgs = 1		ifFalse:			[originalString]		ifTrue:			[originalString copyWithout: $:].	aString _ withoutColon asIdentifier: false.  "get an identifier starting with a lowercase letter"	stemAndSuffix _ aString stemAndNumericSuffix.	proscribed _ #(self super thisContext costume costumes dependents true false size).	stem _ stemAndSuffix first.	suffix _ stemAndSuffix last.	withoutColon _ aString asSymbol.	withColon _ (withoutColon, ':') asSymbol.	[(withoutColon ~~ currentName) and: [(proscribed includes: withoutColon)		or: [self respondsTo: withoutColon]		or: [self respondsTo: withColon]		or:	[Smalltalk includesKey: withoutColon]		or: [Smalltalk includesKey: withColon]]]	whileTrue:		[suffix _ suffix + 1.		withoutColon _ (stem, suffix printString) asSymbol.		withColon _ (withoutColon, ':') asSymbol].	^ currentNumArgs = 0		ifTrue:			[withoutColon]		ifFalse:			[withColon]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 7/18/2002 10:27'!infoFor: anElement inViewer: aViewer	"The user made a gesture asking for info/menu relating"	| aMenu elementType aSelector |	elementType _ self elementTypeFor: anElement vocabulary: aViewer currentVocabulary.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement inViewer: aViewer].		aMenu _ MenuMorph new defaultTarget: self.	aMenu defaultTarget: self.	aSelector _ anElement asSymbol.	(elementType == #userScript)		ifTrue:			[aMenu add: 'destroy "', anElement, '"' selector: #removeScriptWithSelector: argument: aSelector.			aMenu add: 'rename  "', anElement, '"' selector: #renameScript: argument: aSelector.			aMenu add: 'textual scripting pane'  selector: #makeIsolatedCodePaneForSelector: argument: aSelector.			aSelector numArgs > 0				ifTrue:					[aMenu add: 'remove parameter' selector: #ceaseHavingAParameterFor: argument: aSelector]				ifFalse:					[aMenu add: 'add parameter' selector: #startHavingParameterFor: argument: aSelector.					aMenu add: 'button to fire this script' selector: #tearOffButtonToFireScriptForSelector: argument: aSelector].			aMenu add: 'edit balloon help' selector: #editDescriptionForSelector: argument: aSelector].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: anElement asString, ' (', elementType, ')'.	aMenu popUpInWorld: aViewer world! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 7/17/2002 16:41'!newTextualScriptorFor: aSelector	"Sprout a scriptor for aSelector, opening up in textual mode.  Rather special-purpose, consult my lone sender"	| aMethodWithInterface aScriptEditor |	(self class selectors includes: aSelector) ifTrue: [self error: 'selector already exists'].	aMethodWithInterface _ self class permanentUserScriptFor: aSelector player: self.	aScriptEditor _ aMethodWithInterface instantiatedScriptEditorForPlayer: self.	aScriptEditor install.	aScriptEditor showSourceInScriptor.	aMethodWithInterface selector numArgs == 0 ifTrue:		[self class allSubInstancesDo: [:anInst | anInst scriptInstantiationForSelector: aMethodWithInterface selector]].		"The above assures the presence of a ScriptInstantiation for the new selector in all siblings"	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 7/20/2002 12:50'!renameScript: oldSelector	"The user has asked to rename the script formerly known by oldSelector; obtain a new selector from the user, check it out, and if all is well, ascribe the new name as appropriate"	| reply newSelector aUserScript |	self flag: #deferred.	"Relax the restriction below, before too long"	aUserScript _ self class userScriptForPlayer: self selector: oldSelector.	aUserScript okayToRename ifFalse:		[self inform: 'Sorry, we do not permit you to renameclassic-tiled scripts that are currentlytextually coded.  Go back to tile scriptsand try again.  Humble apologies.'.		^ self].	reply _   FillInTheBlank request: 'Script Name' initialAnswer: oldSelector. 	reply size == 0 ifTrue: [^ self].	reply = oldSelector ifTrue:[^ self beep].	newSelector _ self acceptableScriptNameFrom: reply  forScriptCurrentlyNamed:  oldSelector.	Preferences universalTiles		ifTrue:			["allow colons"			(reply copyWithout: $:) = newSelector 				ifTrue: [newSelector _ reply asSymbol]				ifFalse: [self inform: 'name will be modified']].		self renameScript: oldSelector newSelector: newSelector! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 7/18/2002 02:30'!renameScript: oldSelector newSelector: newSelector	"Rename the given script to have the new selector"	|  aUserScript anInstantiation aDict |	oldSelector = newSelector ifTrue: [^ self].	oldSelector numArgs == 0		ifTrue:			[self class allSubInstancesDo:				[:aPlayer |					anInstantiation _ aPlayer scriptInstantiationForSelector: oldSelector.					newSelector numArgs == 0						ifTrue:							[anInstantiation changeSelectorTo: newSelector].					aDict _ aPlayer costume actorState instantiatedUserScriptsDictionary.					aDict removeKey: oldSelector.					newSelector numArgs  == 0 ifTrue:						[aDict at: newSelector put: anInstantiation.						anInstantiation assureEventHandlerRepresentsStatus]]]		ifFalse:			[newSelector numArgs == 0 ifTrue:				[self class allSubInstancesDo:					[:aPlayer |						anInstantiation _ aPlayer scriptInstantiationForSelector: newSelector.						anInstantiation assureEventHandlerRepresentsStatus]]].	aUserScript _ self class userScriptForPlayer: self selector: oldSelector.	aUserScript renameScript: newSelector fromPlayer: self.		"updates all script editors, and inserts the new script in my scripts directory"	self class removeScriptNamed: oldSelector.	((self existingScriptInstantiationForSelector: newSelector) notNil and:		[newSelector numArgs > 0]) ifTrue: [self error: 'ouch'].			self updateAllViewersAndForceToShow: 'scripts'! !!Player methodsFor: 'misc' stamp: 'sw 7/4/2002 23:27'!unusedScriptName	"answer a name of the form 'scriptN', where N is one higher than the highest-numbered similarly-named script"	| highestThus aPair |	highestThus _ 0.	self class tileScriptNames do:		[:aName |			aPair _ (aName copyWithout: $:) stemAndNumericSuffix.			aPair first = 'script' ifTrue: [highestThus _ highestThus max: aPair last]].	^ ('script', (highestThus + 1) printString) asSymbol! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/19/2002 15:07'!buttonRowForEditor	"Answer a row of buttons that comprise the header at the top of the Scriptor"	| aRow aString buttonFont aStatusMorph aButton aColumn aTile |	buttonFont _ Preferences standardButtonFont.	aRow _ AlignmentMorph newRow color: Color transparent; layoutInset: 0.	aRow hResizing: #shrinkWrap.	aRow vResizing: #shrinkWrap.	self hasParameter ifFalse:		[aRow addMorphFront:			(SimpleButtonMorph new				label: '!!' font: (StrikeFont familyName: #ComicBold size: 16);				target: self;				color: Color yellow;				borderWidth: 0;				actWhen: #whilePressed;				actionSelector: #tryMe;				balloonTextSelector: #tryMe).		aRow addTransparentSpacerOfSize: 6@10].	self addDismissButtonTo: aRow.	aRow addTransparentSpacerOfSize: 6@1.	aColumn _ AlignmentMorph newColumn beTransparent.	aColumn addTransparentSpacerOfSize: 0@4.	aButton _ UpdatingThreePhaseButtonMorph checkBox.	aButton		target: self;		actionSelector: #toggleWhetherShowingTiles;		getSelector: #showingMethodPane.	aButton setBalloonText: 'toggle between showing tiles and showing textual code'.	aColumn addMorphBack: aButton.	aRow addMorphBack: aColumn.	aRow addTransparentSpacerOfSize: 6@10.	aString _ playerScripted externalName.	aRow addMorphBack:		(aButton _ SimpleButtonMorph new useSquareCorners label: aString font: buttonFont; target: self; setNameTo: 'title').	aButton actWhen: #buttonDown; actionSelector: #offerScriptorMenu.	aButton		on: #mouseEnter send: #menuButtonMouseEnter: to: aButton;		on: #mouseLeave send: #menuButtonMouseLeave: to: aButton.	aButton borderColor: (Color fromRgbTriplet: #(0.065 0.258 1.0)).	aButton color: ScriptingSystem uniformTileInteriorColor.	aButton balloonTextSelector: #offerScriptorMenu.	aRow addTransparentSpacerOfSize: 4@1.	aButton _ (Preferences universalTiles ifTrue: [SyntaxUpdatingStringMorph] 					ifFalse: [UpdatingStringMorph]) new.	aButton useStringFormat;		target:  self;		getSelector: #scriptTitle;		setNameTo: 'script name';		font: ScriptingSystem fontForNameEditingInScriptor;		putSelector: #setScriptNameTo:;		setProperty: #okToTextEdit toValue: true;		step;		yourself.	aRow addMorphBack: aButton.	aButton setBalloonText: 'Click here to edit the name of the script.'.	aRow addTransparentSpacerOfSize: 6@0.	self hasParameter		ifTrue:			[aTile _ TypeListTile new choices: Vocabulary typeChoices dataType: nil.			aTile addArrows.			aTile setLiteral: #Number.			aTile on: #mouseDown send: #handUserParameterTile to: self.	"(aButton _ SimpleButtonMorph new useSquareCorners label: 'parameter' font: buttonFont; target: self; setNameTo: 'parameter').			aButton actWhen: #buttonDown; actionSelector: #handUserParameterTile."			aRow addMorphBack: aTile.			aTile borderColor: Color red.			aTile color: ScriptingSystem uniformTileInteriorColor.			aTile setBalloonText: 'Drag from here to get a parameter tile']		ifFalse:			[aRow addMorphBack: (aStatusMorph _ self scriptInstantiation statusControlMorph)].	aRow addTransparentSpacerOfSize: 6@1.	aRow addMorphBack:		(IconicButton new borderWidth: 0;			labelGraphic: (ScriptingSystem formAtKey: 'AddTest'); color: Color transparent; 			actWhen: #buttonDown;			target: self;			actionSelector: #addYesNoToHand;			shedSelvedge;			balloonTextSelector: #addYesNoToHand).	aRow addTransparentSpacerOfSize: 12@10.	self addDestroyButtonTo: aRow.	(playerScripted existingScriptInstantiationForSelector: scriptName)		ifNotNilDo:			[:inst | inst updateStatusMorph: aStatusMorph].	^ aRow! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/18/2002 02:43'!setParameterType: typeChosen	"Set the parameter type as indicated"	playerScripted setParameterFor: scriptName toType: typeChosen! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 7/5/2002 00:04'!actuallyDestroyScript	"Carry out the actual destruction of the associated script."	| aHandler |	self delete.	playerScripted class removeScriptNamed: scriptName.	playerScripted actorState instantiatedUserScriptsDictionary removeKey: scriptName ifAbsent: [].		"not quite enough yet in the multiple-instance case..."	(aHandler _ playerScripted costume renderedMorph eventHandler) ifNotNil:		[aHandler forgetDispatchesTo: scriptName].	playerScripted updateAllViewersAndForceToShow: #scripts! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 7/18/2002 02:42'!hasParameter	"Answer whether the receiver has a parameter"	^ scriptName numArgs > 0! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 7/9/2002 00:48'!tryMe	"Evaluate the given script on behalf of the scripted object"	scriptName numArgs = 0		ifTrue:			[self playerScripted perform: scriptName asSymbol]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 7/20/2002 14:30'!updateStatusMorph: statusMorph	"My status button may need to reflect an externally-induced change in status"	(playerScripted existingScriptInstantiationForSelector: scriptName) ifNotNilDo:		[:scriptInstantiation |			scriptInstantiation updateStatusMorph: statusMorph]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/17/2002 17:05'!addParameter	"Transform the receiver so that it bears a parameter.  This will require a selector change, e.g. from #script3 to #script3:"	playerScripted startHavingParameterFor: scriptName 	! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/18/2002 10:26'!ceaseHavingAParameter	"Cease having a parameter"	playerScripted ceaseHavingAParameterFor: scriptName! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/2/2002 21:04'!handUserParameterTile	"Hand the user a parameter, presumably to drop in the script"		| aTileMorph |	aTileMorph _ ParameterTile new forScriptEditor: self.	self currentHand attachMorph: aTileMorph! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/2/2002 14:07'!methodString	"Answer the source-code string for the receiver.  This is for use by classic tiles, but is also used in universal tiles to formulate an initial method declaration for a nascent user-defined script; in universalTiles mode, the codeString (at present anyway) is empty -- the actual code derives from the SyntaxMorph in that case"	^ String streamContents:		[:aStream |			aStream nextPutAll: scriptName.			scriptName numArgs > 0 ifTrue:				[aStream nextPutAll: ' parameter'].			aStream cr; cr; tab.			aStream nextPutAll: self codeString]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/19/2002 15:13'!offerScriptorMenu	"Put up a menu in response to the user's clicking in the menu-request area of the scriptor's heaer"	| aMenu  count |	self modernize.	ActiveHand showTemporaryCursor: nil.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: scriptName asString.	Preferences universalTiles ifFalse:		[count _ self savedTileVersionsCount.		self showingMethodPane			ifFalse:				"currently showing tiles"				[aMenu add: 'show code textually' action: #showSourceInScriptor.				count > 0 ifTrue: 					[aMenu add: 'revert to tile version...' action:	 #revertScriptVersion].				aMenu add: 'save this version'	action: #saveScriptVersion]			ifTrue:				"current showing textual source"				[count >= 1 ifTrue:					[aMenu add: 'revert to tile version' action: #revertToTileVersion]]].	aMenu addList: #(		-		('destroy this script'					destroyScript)		('rename this script'					renameScript)).	self hasParameter ifFalse:		[aMenu addList: #(('button to fire this script'			tearOfButtonToFireScript))].	aMenu addList: #(		('edit balloon help for this script'	editMethodDescription)		-		('explain status alternatives' 		explainStatusAlternatives)		-		('hand me a tile for self'			handUserTileForSelf)		('hand me a "random number" tile'	handUserRandomTile)		('hand me a "button down?" tile'		handUserButtonDownTile)		('hand me a "button up?" tile'		handUserButtonUpTile)).	aMenu addList: (self hasParameter		ifTrue: [#(			-			('remove parameter'					ceaseHavingAParameter))]		ifFalse: [#(			('fires per tick...'					chooseFrequency)			-			('add parameter'					addParameter))]).	aMenu popUpInWorld: self currentWorld.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/20/2002 14:34'!renameScriptTo: newSelector	"Rename the receiver's script so that it bears a new selector"	| aMethodNodeMorph methodMorph methodSource pos newMethodSource |	scriptName _ newSelector.	self updateHeader.	Preferences universalTiles		ifFalse:  "classic tiles"			[self showingMethodPane				ifTrue:					["textually coded -- need to change selector"					methodMorph _ self findA: MethodMorph.					methodSource _ methodMorph text string.					pos _ methodSource indexOf: Character cr ifAbsent: [self error: 'no cr'].					newMethodSource _ newSelector.					newSelector numArgs > 0 ifTrue: [newMethodSource _ newMethodSource, ' t1'].  "for the parameter"					newMethodSource _ newMethodSource, (methodSource copyFrom: pos to: methodSource size).					methodMorph editString: newMethodSource.					methodMorph model changeMethodSelectorTo: newSelector.					playerScripted class compile: newMethodSource classified: 'scripts'.					methodMorph accept]				ifFalse:					[self install]]		ifTrue:  "universal tiles..."			[(aMethodNodeMorph _ self methodNodeMorph) ifNotNil:				[aMethodNodeMorph acceptInCategory: 'scripts']]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/20/2002 14:31'!setScriptNameTo: aNewName	"The user has typed into the script-name pane.  Accept the changed contents as the new script name, and take action accordingly"	playerScripted renameScript: self scriptName newSelector:		(playerScripted acceptableScriptNameFrom: aNewName forScriptCurrentlyNamed:  self scriptName)! !!ScriptEditorMorph methodsFor: 'testing' stamp: 'sw 7/18/2002 02:44'!typeForParameter	"Answer a symbol representing the type of my parameter"	scriptName numArgs > 0 ifTrue:		[(playerScripted class scripts at: scriptName ifAbsent: [nil]) ifNotNilDo:			[:aScript | ^ aScript argumentVariables first variableType]].	^ #Number! !!SymbolListTile methodsFor: 'user interface' stamp: 'sw 7/19/2002 15:02'!acceptNewLiteral: aLiteral	"Accept the new literal"	self labelMorph useStringFormat.	self literal: aLiteral.	self adjustHelpMessage.	self acceptNewLiteral.  "so tile scriptor can recompile if necessary"	self labelMorph informTarget! !!SymbolListTile methodsFor: 'user interface' stamp: 'sw 7/20/2002 14:30'!adjustHelpMessage	"Adjust the help message to reflect the new literal"	self labelMorph setBalloonText: (ScriptingSystem helpStringForOperator: literal)  "Often the desired thing, but subclasses may override"! !!SymbolListTile methodsFor: 'user interface' stamp: 'sw 7/19/2002 15:03'!arrowAction: delta	"Do what is appropriate when an arrow on the tile is pressed; delta will be +1 or -1"	| index |	owner ifNil: [^ self].	literal ifNotNil:		[(index _ choices indexOf: literal) > 0			ifTrue:				[self literal: (choices atWrap: index + delta).				self adjustHelpMessage.				self acceptNewLiteral.				self labelMorph informTarget]]! !!TypeListTile methodsFor: 'initialization' stamp: 'sw 7/20/2002 14:29'!initialize	"Initialize the receiver.  Cheesily, we use the extension arrow graphic for a menu icon temporarily"	super initialize.	self addSuffixArrow.  "Piggybacked upon for type-choices popup menu"	suffixArrow setBalloonText: 'click here to choose a new type for this parameter'! !!TypeListTile methodsFor: 'mechanics' stamp: 'sw 7/19/2002 14:48'!acceptNewLiteral: aLiteral	"Accept the new literal"	| scriptEditor |	super acceptNewLiteral: aLiteral.	(scriptEditor _ self ownerThatIsA: ScriptEditorMorph) ifNotNil:			[scriptEditor setParameterType: aLiteral asSymbol]! !!TypeListTile methodsFor: 'mechanics' stamp: 'sw 7/19/2002 14:58'!adjustHelpMessage	"In this case, don't"! !!TypeListTile methodsFor: 'mechanics' stamp: 'sw 7/19/2002 15:03'!arrowAction: delta	"Do what is appropriate when an arrow on the tile is pressed; delta will be +1 or -1"	| index newTypeSymbol scriptEditor |	owner ifNil: [^ self].	literal ifNotNil:		[(index _ choices indexOf: literal) > 0			ifTrue:				[self literal: (newTypeSymbol _ choices atWrap: index + delta).				self adjustHelpMessage.				self acceptNewLiteral.				self labelMorph informTarget.				(scriptEditor _ self ownerThatIsA: ScriptEditorMorph) ifNotNil:					[scriptEditor setParameterType: newTypeSymbol]]]! !!TypeListTile methodsFor: 'menu' stamp: 'sw 7/19/2002 14:49'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'choose type...' action: #offerAllChoicesInAPopUp! !!TypeListTile methodsFor: 'menu' stamp: 'sw 7/19/2002 15:18'!showSuffixChoices	"When the user clicks on the suffix arrow, put up the type-choices menu"	 self offerAllChoicesInAPopUp! !!UniclassScript methodsFor: 'initialization' stamp: 'sw 7/2/2002 14:13'!playerClass: aPlayerClass selector: aSelector	"Set the playerClass and selector of the receiver"	super playerClass: aPlayerClass selector: aSelector.	aSelector numArgs = 1 ifTrue:		[argumentVariables _ {Variable new name: 'parameter' type: #Number}]! !!UniclassScript methodsFor: 'script editor' stamp: 'sw 7/20/2002 14:27'!instantiatedScriptEditorForPlayer: aPlayer	"Return the current script editor, creating it if necessary"	currentScriptEditor ifNil:		[currentScriptEditor _ (self playerClass includesSelector: selector) 			ifTrue:				[Preferences universalTiles					ifFalse:						[self error: 'duplicate selector'].				ScriptEditorMorph new fromExistingMethod: selector forPlayer: aPlayer]			ifFalse:				[ScriptEditorMorph new setMorph: aPlayer costume scriptName: selector].		(defaultStatus == #ticking and: [selector numArgs == 0]) ifTrue:			[aPlayer costume arrangeToStartStepping]].		^ currentScriptEditor! !StandardScriptingSystem removeSelector: #acceptableScriptNameFrom:forScriptCurrentlyNamed:asScriptNameIn:world:!