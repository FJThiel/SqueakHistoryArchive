'From Squeak3.0 of 4 February 2001 [latest update: #3414] on 11 February 2001 at 4:36:55 pm'!"Change Set:		RoundCornersHack-arDate:			11 February 2001Author:			Andreas RaabA really bad hack - but it makes dragging morphs with rounded corners as fast as dragging morphs with square corners. The difference is highly noticable and applies to any morph using rounded corners."!!HandMorph methodsFor: 'drawing' stamp: 'ar 2/11/2001 16:34'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds roundCorners rounded |	self visible ifFalse:[^self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue:		[cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvas: aCanvas.	(cacheCanvas == nil or: [cachedCanvasHasHoles and: [cacheCanvas depth = 1]])		ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"--> begin rounded corners hack <---"	roundCorners _ (cachedCanvasHasHoles == false) and:[		submorphs size = 1 and:[submorphs first wantsRoundedCorners]].	roundCorners ifTrue:[		rounded _ submorphs first.			aCanvas asShadowDrawingCanvas				translateBy: self shadowOffset during:[:shadowCanvas|			shadowCanvas roundCornersOf: rounded during:[				(subBnds areasOutside: (rounded boundsWithinCorners translateBy: self shadowOffset negated)) do:					[:r | shadowCanvas fillRectangle: r color: Color black]]].		aCanvas roundCornersOf: rounded during:[			aCanvas drawImage: cacheCanvas form at: subBnds origin					sourceRect: cacheCanvas form boundingBox].		^self drawOn: aCanvas.  "draw the hand itself in front of morphs"].	"--> end rounded corners hack <---"	"draw the shadow"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		cachedCanvasHasHoles			ifTrue: ["Have to draw the real shadow of the form"					shadowCanvas paintImage: cacheCanvas form at: subBnds origin]			ifFalse: ["Much faster if only have to shade the edge of a solid rectangle"					(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do:						[:r | shadowCanvas fillRectangle: r color: Color black]]].	"draw morphs in front of the shadow using the cached Form"	cachedCanvasHasHoles		ifTrue: [aCanvas paintImage: cacheCanvas form at: subBnds origin]		ifFalse: [aCanvas drawImage: cacheCanvas form at: subBnds origin					sourceRect: cacheCanvas form boundingBox].	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'ar 2/11/2001 16:35'!updateCacheCanvas: aCanvas	"Update the cached image of the morphs being held by this hand."	| subBnds rectList nPix |	"Note: The following is an attempt to quickly get out if there's no change"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	(rectList isEmpty and:[cacheCanvas notNil and:[cacheCanvas extent = subBnds extent]])		ifTrue:[^self].	"Always check for real translucency -- can't be cached in a form"	self allMorphsDo: [:m |		m hasTranslucentColor ifTrue: [			cacheCanvas _ nil.			cachedCanvasHasHoles _ true.			^ self]].	(cacheCanvas == nil or: [cacheCanvas extent ~= subBnds extent]) ifTrue: [		cacheCanvas _ (aCanvas allocateForm: subBnds extent) getCanvas.		cacheCanvas translateBy: subBnds origin negated			during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].		self submorphsDo:			[:m | (m areasRemainingToFill: subBnds) isEmpty				ifTrue: [^ cachedCanvasHasHoles _ false]].		nPix _ cacheCanvas form tallyPixelValues at: 1.		"--> begin rounded corners hack <---"		(nPix = 48 and:[submorphs size = 1 and:[submorphs first wantsRoundedCorners]])			ifTrue:[cachedCanvasHasHoles _ false]			ifFalse:[cachedCanvasHasHoles _ nPix > 0].		"--> end rounded corners hack <---"		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	damageRecorder reset.	rectList do: [:r |		cacheCanvas translateTo: subBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			self drawSubmorphsOn: c]].! !