'From Squeak 2.3 of January 14, 1999 on 3 April 1999 at 12:56:17 am'!"Change Set:		ScannerTweaksDate:			3 April 1999Author:			Dan IngallsAllows sequences of more than two special characters to work as binary selectors.Fixes String numArgs so that , and -> return 1, as do the above multi-char symbols.Retracts the nearly absurd interpretations of ##name and ###name in Scanner."!!Character methodsFor: 'testing' stamp: 'di 4/3/1999 00:38'!isSpecial	"Answer whether the receiver is one of the special characters"	^'+-/\*~<>=@,%|&?!!' includes: self! !!Scanner methodsFor: 'multi-character scans' stamp: 'di 5/29/1998 12:25'!xBinary	tokenType _ #binary.	token _ Symbol internCharacter: self step.	[(typeTable at: hereChar asciiValue) = #xBinary and: [hereChar ~= $-]]		whileTrue: [token _ (token , (String with: self step)) asSymbol]! !!Scanner methodsFor: 'multi-character scans' stamp: 'di 4/3/1999 00:52'!xLitQuote	"UniqueStrings and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse:.	 For ##x answer #x->nil.  For ###x answer nil->#x."	| start |	self step. "litQuote"	self scanToken.	tokenType = #leftParenthesis		ifTrue: 			[start _ mark.			self scanToken; scanLitVec.			tokenType == #doIt				ifTrue: [mark _ start.						self offEnd: 'Unmatched parenthesis']]		ifFalse: 			[(#(word keyword colon ) includes: tokenType) 				ifTrue:					[self scanLitWord]				ifFalse:					[(token isMemberOf: Symbol)							ifTrue: "##word"								[token _ token  "May want to move toward ANSI here"]]].	tokenType _ #literal"	#(Pen) (Pen )	#Pen class Symbol	##Pen class Symbol	###Pen class Symbol"! !!String methodsFor: 'system primitives' stamp: 'di 4/3/1999 00:37'!numArgs	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector.  Note that currently this will answer -1 for anything begining with an uppercase letter even though the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."	| firstChar numColons |	firstChar _ self at: 1.	firstChar isLetter ifTrue:		[ firstChar isUppercase ifTrue: [ ^ -1 ].		numColons _ 0. 		self do: [ :ch |			ch tokenish ifFalse: [ ^ -1 ].			(ch = $:) ifTrue: [numColons _ numColons + 1] ].		^ (self last = $:)			ifTrue: [ numColons > 0 ifTrue: [ numColons ] ifFalse: [ -1 ] ]			ifFalse: [ numColons > 0 ifTrue: [ -1 ] ifFalse: [ 0 ] ] ].	firstChar isSpecial ifTrue:		[self size = 1 ifTrue: [^ 1].		2 to: self size do: [:i | (self at: i) isSpecial ifFalse: [^ -1]].		^ 1].	^ -1.! !