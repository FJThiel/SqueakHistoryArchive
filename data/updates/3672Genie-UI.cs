'From Squeak2.9alpha of 13 June 2000 [latest update: #3412] on 20 February 2001 at 10:33:05 pm'!"Change Set:		Genie-UIDate:			20 February 2001Author:			Nathanael ScharliGenie is a character and gesture recognition system for Squeak.This changeset contains the UI to configure Genie (Inspect/edit/load/save/copy/delete gesture dictionaries, display properties, etc.).NOTES:- Make sure that Genie-Engine is filed in before you file in this change-set!!- To get a ready-to-use Genie environment, file in the following changesets in this order:a) Genie-Engine.csb) Genie-UI.csc) Genie-Integration.cs"!AlignmentMorph subclass: #CRAddFeatureMorph	instanceVariableNames: 'model featureMorph defaultChar backColor showLast featureCountMorph featuresAndStrokeDistances hotspot '	classVariableNames: ''	poolDictionaries: ''	category: 'Genie-UI'!!CRAddFeatureMorph commentStamp: '<historical>' prior: 0!This class is used for the Genie UI. It allows to enter a new feature for a certain character.!CRAddFeatureMorph class	instanceVariableNames: ''!MorphicEventDispatcher subclass: #CRAddFeatureMorphEventDispatcher	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Genie-UI'!!CRAddFeatureMorphEventDispatcher commentStamp: 'NS 2/20/2001 19:41' prior: 0!Special event dispatcher that is only used for CRAddFeature morph.It is necessary to make sure that all the red button downs are handled bythe CRAddFeatureMorph and not by its submorphs. Exception: The button-submorphs have to handle the events itself.!Model subclass: #CRDictionaryBrowser	instanceVariableNames: 'appModel subPaneDict displayProperties nextFeatureCount areNextFeatureGraphicsShown areCapturedPointsShown orientation imageSize relativeSize hasOkayButton showDistanceToFeaturesInParents '	classVariableNames: 'DefaultLayoutInstance '	poolDictionaries: ''	category: 'Genie-UI'!!CRDictionaryBrowser commentStamp: '<historical>' prior: 0!This class is used to browse a dictionary. As all the other parts of the genie UI, the dictionary browser is built according to the MVC model.Here a short description of all the classes participating in a single dictionary browser.(Note: There are different views on a dictionary. Here, only the browser view is described)CRDictionary  (Model)	Instances of this class store and manage all the dictionary data.CRDictionaryBrowserAppModel  (Application Model)	This is the application model of a dictionary. Every dictionary browser uses an	application model to communicate with the dictionary. (As an example, the application 	model has a cache holding distances between the features in the dictionary). 	Every browser opened on a certain dictionary should use the same application model.	(However, it would also be possible to use more than one application model per dictionary)CRDictionaryBrowser  (View)	This class is part of the view in the MVC model. It manages all the properties of a 	single browser view (layout properties, etc). The actual visual representation is	realized by using a (nested) PluggableCollectionMorph.	(Basically it's possible to open multiple visual representations on one single instance of this	class. But, all these instances share common layout properties. This is usually not	wanted and thus it is better to create a new instance of this class for every view).PluggableCollectionMorph  (View)	Objects of this class can represent the contents of a collection in a very flexible way.	The class is built in according to all the other pluggable morphs in Squeak. In the	case of the dictionary browser, objects of CRDictionaryBrowser are the models of	the PluggableCollectionMorphs.!CRDictionaryBrowser class	instanceVariableNames: ''!Model subclass: #CRDictionaryBrowserAppModel	instanceVariableNames: 'dictionary resultCache resultCacheWithParents '	classVariableNames: ''	poolDictionaries: ''	category: 'Genie-UI'!!CRDictionaryBrowserAppModel commentStamp: '<historical>' prior: 0!This is the application model of a dictionary browser.Instances of CRDictionaryBrowser use an instances of this class to access a dictionary.As an example, the application model encapsulates the lookup process and introduces a cachefor performance improvement.Usually, there is one Application model for all open instance browsers.See also description of class CRDictionaryBrowser.!CRDictionaryBrowserAppModel class	instanceVariableNames: ''!TabbedPalette subclass: #CRDictionaryMorph	instanceVariableNames: 'steppingWorld model name exportedName includeCapturedPoints parameters oldName oldExportedName oldIncludeCapturedPoints oldParameters createdSubmorphs hasCloseButton oldParents parentCount parents '	classVariableNames: ''	poolDictionaries: ''	category: 'Genie-UI'!!CRDictionaryMorph commentStamp: '<historical>' prior: 0!This Morph provides a view on a dictionary.This view includes a dictionary browser, but also graphical representations of otherproperties of the dictionary.!CRDictionaryMorph class	instanceVariableNames: ''!Model subclass: #CRDisplayPropertiesInstanceBrowser	instanceVariableNames: 'collection '	classVariableNames: ''	poolDictionaries: ''	category: 'Genie-UI'!!CRDisplayPropertiesInstanceBrowser commentStamp: '<historical>' prior: 0!Instances of this class are used to browse the named display property instances.The actual graphical representation is realized by using a PluggableCollectionMorph.(Actually, this class serves as the model for the PluggableCollectionMorph).!CRDisplayPropertiesInstanceBrowser subclass: #CRDictionaryInstanceBrowser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Genie-UI'!!CRDictionaryInstanceBrowser commentStamp: '<historical>' prior: 0!Instances of this class are used to browse the named dictionary instances.The actual graphical representation is realized by using a PluggableCollectionMorph.(Actually, this class serves as the model for the PluggableCollectionMorph).!CRDisplayPropertiesInstanceBrowser class	instanceVariableNames: ''!AlignmentMorph subclass: #CRDisplayPropertiesMorph	instanceVariableNames: 'steppingWorld model isActive oldIsActive tempProperties oldTempProperties createdSubmorphs '	classVariableNames: ''	poolDictionaries: ''	category: 'Genie-UI'!!CRDisplayPropertiesMorph commentStamp: '<historical>' prior: 0!This morph provides a view on a dictionary properties instance!CRDisplayPropertiesMorph class	instanceVariableNames: ''!FillInTheBlankMorph subclass: #FillInTheBlankMorphWithCharMenu	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Genie-UI'!!FillInTheBlankMorphWithCharMenu commentStamp: '<historical>' prior: 0!This class inherits from FillInTheBlankMorph and adds a menu that allows to select commonly used characters.!AlignmentMorph subclass: #PluggableCollectionMorph	instanceVariableNames: 'collection collectionKeys currentIndex model collectionOrSelector okaySelector cancelSelector addSelector deleteSelector changeSelector valueMorphSelector menuSelector keyMorphSelector objectToStringSelector releaseSelector valueMorph keyMorph gotoSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Genie-UI'!!PluggableCollectionMorph commentStamp: '<historical>' prior: 0!This class allows the user to inspect (and modify) any kind of collection (flat collection, but also Dictionaries, etc.). Instances are morphs with a few navigate buttons. Whenever a collection element has to be shown, it converts this element to a morph and shows it. As all the other Pluggable components in Squeak, a PluggableCollectionMorph can be based on a model and there are a lot selectors that can be set to specify a special behavior. Examples: Per default, all collection elements that are not already Morphs are just converted into a StringMorph. To refine this behavior, just set a selector for 'valueMorphSelector' (resp. keyMorphSelector) and implement your one conversion method in the model.To allow a user to add and remove elements in the collection, the selectors 'assSelector' and 'deleteSelector' have to be set.This class is used for big parts of the Genie UI. Sometimes, even nested pluggable collection morphs are used.Instance variables:collection  <OrderedCollection>	A collection that holds the elements of the inspected collection. However, this collection	is for internal use and is not necessarily the same as the inspected collection.collectionKeys  <OrderedCollection>	If the source collection of a Dictionary, the keys are the dictionary keys. If not, the keys	are just the numbers from 1 to the size of the collction. This concept is used to treat usual	collection and dictionaries the same way.currentIndex  <SmallInteger>	The index of the element currently shown.model	The model. Selectors are sent to this receiver.collectionOrSelector	Either the source collection (the collection to inspect) or a selector to retrieve the collection	from the model.okaySelector	Selector is sent to the model when okay button is pressed. (If selector undefinied, no okay	button is available). The selectors must have one argument. When the selector is	invoked, the invoking PluggableCollectionMorph itself is sent as the argument.	Then, methods as currentValue or currentKey can be used to determine the current state of	the morph.cancelSelector	Similar to okaySelector.addSelector	Similar to okaySelector.deleteSelector	Similar to okaySelector.changeSelector	It is invoked before a change is executed. Return false if the change shouldn't be allowed.	Rest is similar to okaySelector.valueMorphSelector	Is called whenever a collection element has to be wrapped into a morph.	Must take two arguments: 1) object to be wrapped, 2) sending PluggableCollectionMorph.keyMorphSelector	Is called whenever a key element has to be wrapped into a morph.	Must take two arguments: 1) object to be wrapped, 2) sending PluggableCollectionMorph.menuSelector	Is invoked whenever the user hits the menu button. Should return the menu. See also	method resendMenuAction:gotoSelector	Similar to okaySelector. Primitive goto is available even if selector is nil.objectToStringSelector	Selector toconvert an object to a string. Usually not used.releaseSelector	Gets invoked whenever a morph is not shown anymore. (E.g. when the currently shown	collection element changes). It must take 3 arguments: 1) The released morph, 2) the morph	replacing the released morph, 3) the sending PluggableCollectionMorph.	Usually not used.valueMorph	The morph currently shown as the value at the current collection position.keyMorph	The morph currently shown as the key at the current collection position.!PluggableCollectionMorph class	instanceVariableNames: ''!UpdatingStringMorph subclass: #UpdatingNumericStringMorph	instanceVariableNames: 'min max '	classVariableNames: ''	poolDictionaries: ''	category: 'Genie-UI'!!UpdatingNumericStringMorph commentStamp: '<historical>' prior: 0!Similar to UpdatingStringMorph, but adds some new features for handling numbers.!!CRAddFeatureMorph methodsFor: 'accessing' stamp: 'NS 7/18/2000 09:51'!addFeatureAndUpdate: aCRFeature	self addFeature: aCRFeature.	self updateContents.! !!CRAddFeatureMorph methodsFor: 'accessing' stamp: 'NS 6/3/2000 22:47'!defaultChar	^ defaultChar! !!CRAddFeatureMorph methodsFor: 'accessing' stamp: 'NS 6/3/2000 22:47'!defaultChar: charObject	defaultChar _ charObject! !!CRAddFeatureMorph methodsFor: 'accessing' stamp: 'NS 6/3/2000 23:15'!model	^ model! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 7/18/2000 15:15'!addFeature: aCRFeature	| totalDist |	(aCRFeature isEmpty not) ifTrue:		[featuresAndStrokeDistances isEmpty ifTrue: [hotspot _ aCRFeature hotspot].		totalDist _ featuresAndStrokeDistances inject: 0 into: [:sum :each | | dist |			dist _ self strokeDistance: aCRFeature and: each key.			each value: each value + dist.			sum + dist].		featuresAndStrokeDistances add: aCRFeature -> totalDist].! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 8/7/2000 16:10'!avgFeature	"Calcualtes the avarage of all the entered features. The avarage is definied like this:	Take the point sequence of the feature that has the least stroke-distance to all the	other features. Then set all the secondary features (angle sum, aspect ratio, etc) to the	avarage of all the features"	| feature |	featuresAndStrokeDistances size < 1 ifTrue: [^ self lastFeature].	feature _ self bestStrokeFeature copy.	^ feature isStroke ifTrue: [feature setValuesToAvg: (featuresAndStrokeDistances collect: [:each | each key])] ifFalse: [feature].! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 8/7/2000 16:11'!bestStrokeFeature	"Return the feature that as the least stroke-distance to all the other features"	| min best |	min _ SmallInteger maxVal.	best _ nil.	featuresAndStrokeDistances do: [:each |		each value < min ifTrue: [best _ each key. min _ each value]].	^ best.! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 6/16/2000 13:11'!featureMorph	^ featureMorph! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 6/16/2000 13:11'!featureMorph: aMorph	featureMorph _ aMorph.! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 7/18/2000 11:51'!lastFeature	^ featuresAndStrokeDistances isEmpty ifTrue: [CREmptyFeature new] ifFalse: [featuresAndStrokeDistances last key].! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 2/16/2001 11:28'!menuAction	| menu string items hotspotMenu |	menu _ MenuMorph new.	string _ showLast				ifTrue: ['Show average']				ifFalse: ['Show last'].	menu add: string target: self selector: #switchShowLastAction.	featuresAndStrokeDistances isEmptyOrNil ifFalse:		[menu add: 'Remove last' target: self selector: #removeLastAction].	self shownFeature isStroke ifTrue: [		items _ {'start'. 'end'. 'line'. 'top'. 'bottom'. 'left'. 'right'. 'line'. 				'topLeft'. 'topRight'. 'bottomLeft'. 'bottomRight' }.		hotspotMenu _ MenuMorph new.		items do: [:each | 			each = 'line' 				ifTrue: [hotspotMenu addLine]				ifFalse: [hotspotMenu add: each target: self						selector: #setHotspotAction: argument: each asSymbol]].		menu addMorphBack: (MenuItemMorph new contents: 'Hotspot: ', hotspot asString, ' ';							 arguments: #(); subMenu: hotspotMenu)].	menu popUpInWorld: World.! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 7/20/2000 13:16'!model: anObject	self model isNil ifFalse: [self model removeDependent: self].	model _ anObject.	model isNil ifFalse: [self model addDependent: self].! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 8/7/2000 16:12'!removeLastAction	"Remove the last feature from the set of new features"	| item |	featuresAndStrokeDistances isEmpty		ifTrue: [^ self].	item _ featuresAndStrokeDistances removeLast.	featuresAndStrokeDistances		do: [:each | each value: each value - (self strokeDistance: item key and: each key)].	self updateContents! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 8/7/2000 16:12'!resetAction	"Reset: Remove all the new features"	featuresAndStrokeDistances _ OrderedCollection new.	self updateContents.! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 8/7/2000 16:12'!setHotspotAction: aSymbol	"Set hotspot for the new feature"	hotspot _ aSymbol.! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 8/7/2000 16:13'!shownFeature	"Return the feature that should currently be displayed"	^ showLast ifTrue: [self lastFeature] ifFalse: [self avgFeature].! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 8/9/2000 16:58'!strokeDistance: aCRFeature and: bCRFeature	"Calculate the stroke-distance between the two features.	Use to determine which feature is most similar to all the others"	^ (aCRFeature isStroke and: [bCRFeature isStroke]) 					ifTrue: [(aCRFeature sameClassAbsoluteStrokeDistance: bCRFeature forReference: false) // 1000] 			ifFalse: [SmallInteger maxVal // 1000].! !!CRAddFeatureMorph methodsFor: 'private' stamp: 'NS 8/7/2000 16:14'!switchShowLastAction	"Switch between showing the last feature and showing the avarage feature"	showLast _ showLast not.	self updateContents.! !!CRAddFeatureMorph methodsFor: 'updating' stamp: 'NS 7/20/2000 10:55'!update: anObject	self updateContents! !!CRAddFeatureMorph methodsFor: 'updating' stamp: 'NS 2/20/2001 19:25'!updateContents	featureCountMorph removeAllMorphs.	featureCountMorph addMorph: (StringMorph contents: featuresAndStrokeDistances size printString).	self featureMorph removeAllMorphs.	self featureMorph addMorph: self createMorphForFeature.	"self featureMorph layoutChanged."! !!CRAddFeatureMorph methodsFor: 'model access' stamp: 'NS 8/3/2000 10:39'!addToActionAskUser: aBoolean 	| tempString |	self avgFeature isEmpty ifTrue: [^ self inform: 'Cannot add empty feature'].	tempString _ (aBoolean or: [self defaultChar isNil])				ifTrue: 					[| default | 					default _ self defaultChar isNil								ifTrue: ['']								ifFalse: [self defaultChar string].					FillInTheBlankMorphWithCharMenu request: 'Please enter character' initialAnswer: default]				ifFalse: [self defaultChar string].	tempString isEmptyOrNil		ifFalse: [self model				addFeature: (self avgFeature hotspot: hotspot)				to: (CRChar string: tempString)				requestor: self]! !!CRAddFeatureMorph methodsFor: 'model access' stamp: 'NS 6/16/2000 14:48'!addToDefaultAction	^ self addToActionAskUser: false.! !!CRAddFeatureMorph methodsFor: 'model access' stamp: 'NS 6/16/2000 14:49'!addToXAction	^ self addToActionAskUser: true.! !!CRAddFeatureMorph methodsFor: 'model access' stamp: 'NS 6/15/2000 16:34'!cancelAction	self model cancelAddFeatureTo: self defaultChar requestor: self.	^ self delete! !!CRAddFeatureMorph methodsFor: 'model access' stamp: 'NS 7/31/2000 09:33'!createMorphForFeature	| morph |	morph _ self model createMorphForFeature: self shownFeature.	morph borderColor: self color darker.	^ morph.! !!CRAddFeatureMorph methodsFor: 'model access' stamp: 'NS 6/16/2000 14:56'!objectToString: anObject	^ self model objectToString: anObject! !!CRAddFeatureMorph methodsFor: 'initialize-release' stamp: 'NS 7/20/2000 13:16'!initializeModel: anObject	super initialize.	self model: anObject.	featuresAndStrokeDistances _ OrderedCollection new.	self featureMorph: AlignmentMorph new.	self color: Color lightRed.	showLast _ true.	featureCountMorph _ AlignmentMorph new.	self updateContents.! !!CRAddFeatureMorph methodsFor: 'initialize-release' stamp: 'NS 2/20/2001 19:25'!layout	| buttons topRow |	self color: Color lightRed.	self borderColor: Color blue.	self borderWidth: 1.	self hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	self listDirection: #topToBottom.	self listCentering: #bottomRight.	self featureMorph color: Color transparent.	featureCountMorph color: Color transparent.	topRow _ AlignmentMorph newRow color: Color transparent.	topRow addMorph: featureCountMorph.	buttons _ AlignmentMorph new color: Color transparent.	buttons listDirection: #leftToRight;	 listCentering: #bottomRight.	buttons addMorphBack: self menuButton.	buttons addTransparentSpacerOfSize: 5@5.	buttons addMorphBack: self resetButton.	buttons addTransparentSpacerOfSize: 5@5.	buttons addMorphBack: self addToDefaultButton.	buttons addTransparentSpacerOfSize: 5@5.	buttons addMorphBack: self addToXButton.	buttons addTransparentSpacerOfSize: 5@5.	buttons addMorphBack: self cancelButton.	topRow addMorphBack: buttons.	self addMorphBack: topRow.	self addMorphBack: self featureMorph.! !!CRAddFeatureMorph methodsFor: 'buttons' stamp: 'NS 6/16/2000 14:55'!addToDefaultButton	^ self basicButton label: 'Add';	 actionSelector: #addToDefaultAction;	 actWhen: #buttonDown! !!CRAddFeatureMorph methodsFor: 'buttons' stamp: 'NS 7/18/2000 09:40'!addToXButton	^ self basicButton label: 'Add to';	 actionSelector: #addToXAction;	 actWhen: #buttonDown! !!CRAddFeatureMorph methodsFor: 'buttons' stamp: 'NS 6/28/2000 10:19'!basicButton	^ SimpleButtonMorph new target: self; color: Color lightBlue; borderColor: #raised.! !!CRAddFeatureMorph methodsFor: 'buttons' stamp: 'NS 6/3/2000 22:54'!cancelButton	^ self basicButton label: 'Cancel';	 actionSelector: #cancelAction;	 actWhen: #buttonDown! !!CRAddFeatureMorph methodsFor: 'buttons' stamp: 'NS 7/18/2000 09:38'!menuButton	^ self basicButton label: 'M';	 actionSelector: #menuAction;	 actWhen: #buttonDown! !!CRAddFeatureMorph methodsFor: 'buttons' stamp: 'NS 7/18/2000 09:38'!resetButton	^ self basicButton label: 'Reset';	 actionSelector: #resetAction;	 actWhen: #buttonDown! !!CRAddFeatureMorph methodsFor: 'genie-processing' stamp: 'NS 2/20/2001 19:37'!allowsGestureEscape	"Is it allowed to escape from recognizing a gesture for this morph?"	^ false! !!CRAddFeatureMorph methodsFor: 'genie-processing' stamp: 'NS 2/19/2001 20:56'!allowsGesturePreprocessing	"Don't allow gesture preprocessing by the HandMorph.	This is important because we need here the originally entered feature!!"	^ false! !!CRAddFeatureMorph methodsFor: 'genie-processing' stamp: 'NS 7/30/2000 20:55'!gestureDictionary	^ self model dictionary.! !!CRAddFeatureMorph methodsFor: 'genie-processing' stamp: 'NS 2/20/2001 19:32'!handlesGestureStart: anEvent	"If true, the gesture handler is started when the morph gets a red button down	event"	^ true! !!CRAddFeatureMorph methodsFor: 'genie-processing' stamp: 'NS 2/20/2001 19:36'!processEvent: anEvent using: defaultDispatcher	"Use a special dispatcher instead of the default one.	This is necessary to make sure that all the red button downs are handled by	this morph and not by its submorphs. 	Exception: The button-submorphs have to handle the events itself."	| return |	(self rejectsEvent: anEvent) ifTrue: [^#rejected].	return _ CRAddFeatureMorphEventDispatcher new dispatchEvent: anEvent with: self.	(anEvent wasHandled not and: 		[anEvent hand allowsGestureStart: anEvent target: self])			ifTrue: 				[anEvent handler: self.				self handleEvent: anEvent].	^ return! !!CRAddFeatureMorph methodsFor: 'genie-dispatching' stamp: 'NS 2/20/2001 19:25'!gesture: aCRGesture	"Special gesture handling: Just get the entered feature and add consider it as a new	master feature"	self addFeatureAndUpdate: aCRGesture capturedFeature.! !!CRAddFeatureMorph class methodsFor: 'instance creation' stamp: 'NS 6/16/2000 15:06'!model: anObject	^ self new initializeModel: anObject! !!CRAddFeatureMorphEventDispatcher methodsFor: 'dispatching' stamp: 'NS 2/20/2001 19:45'!dispatchMouseDown: anEvent with: aMorph	"This method is very similar to the super class method. The only difference is that	it lets only buttons and CRAddFeatureMorphs handle events"	| globalPt localEvt index child morphs handler inside lastHandler |	"Try to get out quickly"	globalPt _ anEvent cursorPoint.	(aMorph fullBounds containsPoint: globalPt) ifFalse:[^#rejected].	"Install the prospective handler for the receiver"	lastHandler _ anEvent handler. "in case the mouse wasn't even in the receiver"	handler _ aMorph handlerForMouseDown: anEvent.	handler ifNotNil:[anEvent handler: handler].	"Now give our submorphs a chance to handle the event"	index _ 1.	morphs _ aMorph submorphs.	[index <= morphs size] whileTrue:[		child _ morphs at: index.		localEvt _ anEvent transformedBy: (child transformedFrom: aMorph).		(child processEvent: localEvt using: self) == #rejected ifFalse:[			"Some child did contain the point so we're part of the top-most chain."			inside _ false.			localEvt wasHandled ifTrue:[anEvent copyHandlerState: localEvt].			index _ morphs size].		index _ index + 1.	].	(inside == false or:[aMorph containsPoint: anEvent cursorPoint event: anEvent]) ifTrue:[		"Receiver is in the top-most unlocked, visible chain."		"Only handle the event if the handler is a button or a CRAddFeatureMorph"		(handler notNil and:			[(handler isKindOf: SimpleButtonMorph) or: [handler isKindOf: CRAddFeatureMorph]])			ifTrue: [handler handleEvent: anEvent].		"Note: Re-installing the handler is not really necessary but good style."		anEvent handler: lastHandler.		^self	].	"Mouse was not on receiver nor any of its children"	anEvent handler: lastHandler.	^#rejected! !!CRDictionaryBrowser methodsFor: 'initialize-release' stamp: 'NS 6/27/2000 17:28'!asMorph	^ self newMorph ensureLayout! !!CRDictionaryBrowser methodsFor: 'initialize-release' stamp: 'NS 8/8/2000 10:35'!initializeAppModel: aCRDictionaryBrowserAppModel	"This method sets the application model and initilizes the instance"	self appModel: aCRDictionaryBrowserAppModel.	self subPaneDict: IdentityDictionary new.	self displayProperties: #activeInstance.	self hasOkayButton: self class hasOkayButton.	self setLayoutPropertiesToDefault.! !!CRDictionaryBrowser methodsFor: 'initialize-release' stamp: 'NS 8/8/2000 10:35'!initializeLayoutProperties	"This method sets the layout properties of the dictionary according to the default	value specified on the class side."	orientation _ self class orientation.	imageSize _ self class imageSize.	relativeSize _ self class relativeSize.	nextFeatureCount _ self class nextFeatureCount.	areNextFeatureGraphicsShown _ self class areNextFeatureGraphicsShown.	areCapturedPointsShown _ self class areCapturedPointsShown.	showDistanceToFeaturesInParents _ self class showDistanceToFeaturesInParents.! !!CRDictionaryBrowser methodsFor: 'initialize-release' stamp: 'NS 2/16/2001 11:18'!newMorph	"Create and initialize a new PluggableCollectionMorph which serves as my	graphical representation. There can be many graphical representations for one browser	objects. However, all the graphical representations share the same layout properties.	Create multiple instances of this clss to open multiple browsers with independent layout	properties."	| m |	m _ PluggableCollectionMorph		model: self		collectionOrSelector: self dictSelector		okaySelector: (self hasOkayButton ifTrue: [#okayActionRequestor:])		cancelSelector: nil		addSelector: #addCharActionRequestor:		deleteSelector: #deleteCharActionRequestor:		gotoSelector: #gotoCharActionRequestor:		menuSelector: #menuActionRequestor:		changeSelector: #changeCharRequestRequestor:		valueMorphSelector: #subPaneMorph:requestor:		keyMorphSelector: #charKeyMorph:requestor:		objectToStringSelector: #objectToString:		releaseSelector: nil.	m listDirection: #topToBottom.	m layout.	^ m.! !!CRDictionaryBrowser methodsFor: 'initialize-release' stamp: 'NS 8/8/2000 10:34'!newMorphWithFeature: aCRFeature	"Initialize a morph containing aCRFeature as a new feature."	| m |	m _ self newMorph.	self addCharActionRequestor: m newChar: (CRChar string: 'Last gesture').	m currentValue addFeatureAndUpdate: aCRFeature; defaultChar: nil.	^ m! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 6/30/2000 08:50'!appModel	^ appModel! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 6/29/2000 17:03'!areCapturedPointsShown	^ areCapturedPointsShown! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 6/29/2000 17:03'!areCapturedPointsShown: aBoolean	areCapturedPointsShown _ aBoolean! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 8/8/2000 10:36'!areNextFeatureGraphicsShown	"Are graphical representations of the most similar features in the dictionary shown?"	^ areNextFeatureGraphicsShown! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 6/29/2000 16:54'!areNextFeatureGraphicsShown: aBoolean	areNextFeatureGraphicsShown _ aBoolean! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 2/16/2001 21:08'!createMorphForFeature: aCRFeature 	"Create a morph representing the given featue"	| morph items string isEmpty |	"Calculate all the shown features. (The given feature and the most similar features	in the dictionary)"	(isEmpty _ aCRFeature isEmpty)				ifTrue: [items _ OrderedCollection new.						nextFeatureCount timesRepeat: 							[items add: (CRLookupItem feature: aCRFeature char: nil distance: 0)]]				ifFalse: [items _ self shownResultItemsFor: aCRFeature].	"Create the morph for the given feature"	morph _ self createBasicMorphForFeature: aCRFeature.	"Iterate through the collection of similar features and add them to the morph"	(items size > 0 and: [self areNextFeatureGraphicsShown])		ifTrue: [| tempMorph | 			tempMorph _ morph.			morph _ AlignmentMorph new listDirection: self orientation;				 color: Color transparent.			morph addMorphFront: tempMorph.			items				do: [:each | 					| feature | 					feature _ each isNil								ifTrue: [CREmptyFeature new]								ifFalse: [each feature].					morph addTransparentSpacerOfSize: (self imageSize // 10 max: 2@2).					tempMorph _ self createBasicMorphForFeature: feature.					morph addMorphBack: tempMorph]].	string _ isEmpty				ifTrue: ['Empty feature']				ifFalse: [self createStringForItems: items].	string isEmptyOrNil		ifTrue: [^ morph].	morph _ AlignmentMorph newColumn addMorphBack: morph;				color: Color transparent; listCentering: #topLeft; cellPositioning: #topLeft.	morph		addMorphFront: (morph transparentSpacerOfSize: (self imageSize // 15 max: 2@2));		addMorphFront: (StringMorph contents: string).	^ morph! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 7/14/2000 13:06'!createRecognizer	^ CRRecognizer dictionary: self dictionary displayProperties: self displayProperties! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 7/14/2000 13:06'!dictionary	^ self appModel dictionary! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 8/8/2000 10:40'!displayProperties	"Return the display properties associated to this dictionary"	^ displayProperties = #activeInstance ifTrue: [CRDisplayProperties activeInstance] ifFalse: [displayProperties].! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 8/8/2000 10:40'!displayProperties: aCRDisplayProperties	"Set the display propertis forthis dictionary.	Set the display properties to #activeIntance to always use the currently active	properties"	displayProperties _ aCRDisplayProperties.	displayProperties = #activeInstance ifTrue: [self displayProperties addDependent: self].! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 6/26/2000 13:59'!hasOkayButton	^ hasOkayButton! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 6/26/2000 13:59'!hasOkayButton: aBoolean	hasOkayButton _ aBoolean.! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 8/8/2000 10:41'!imageSize	"the image size of a features graphica representation"	^ imageSize! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 6/15/2000 15:36'!imageSize: anInteger	imageSize _ anInteger! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 8/8/2000 10:41'!invertedDict	"The inverted dictionary"	^ self dictionary invertedDictionary! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 8/8/2000 10:42'!nextFeatureCount	"How many similar features shall be shown?"	^ nextFeatureCount min: 2! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 6/29/2000 16:54'!nextFeatureCount: anInteger	"0, 1, 2"	nextFeatureCount _ anInteger! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 8/8/2000 10:42'!orientation	"Orientation of the browser: #horizontal or #vertical"	^ orientation! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 2/16/2001 11:21'!orientation: aSymbol	"Orientation of the browser: #topToBottom or #leftToRight"	orientation _ aSymbol! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 8/8/2000 10:43'!relativeSize	"Shall the size of the features be relative to the absolute maximum size?"	^ relativeSize! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 6/26/2000 14:14'!relativeSize: aBoolean	relativeSize _ aBoolean! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 6/30/2000 13:49'!saveLayoutPropertiesAsDefault	self class defaultLayoutInstance setLayoutProperties: self.! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 2/16/2001 11:23'!setLayoutProperties: aCRDictionaryBrowser	self orientation: aCRDictionaryBrowser orientation.	self imageSize: aCRDictionaryBrowser imageSize.	self relativeSize: aCRDictionaryBrowser relativeSize.	self nextFeatureCount: aCRDictionaryBrowser nextFeatureCount.	self areNextFeatureGraphicsShown: aCRDictionaryBrowser areNextFeatureGraphicsShown.	self areCapturedPointsShown: aCRDictionaryBrowser areCapturedPointsShown.	self showDistanceToFeaturesInParents: aCRDictionaryBrowser showDistanceToFeaturesInParents.! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 6/30/2000 13:49'!setLayoutPropertiesToDefault	self setLayoutProperties: self class defaultLayoutInstance.! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 8/8/2000 10:44'!showDistanceToFeaturesInParents	"Shall distances to features in parents also be shown?"	^ showDistanceToFeaturesInParents! !!CRDictionaryBrowser methodsFor: 'accessing' stamp: 'NS 8/8/2000 11:57'!showDistanceToFeaturesInParents: aBoolean	showDistanceToFeaturesInParents _ aBoolean! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 6/30/2000 08:55'!appModel: aCRDictionaryBrowserAppModel	self appModel isNil ifFalse: [self appModel removeDependent: self].	appModel _ aCRDictionaryBrowserAppModel.	self appModel isNil ifFalse: [self appModel addDependent: self].! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 6/30/2000 09:52'!clearResultCache	self resultCache: Dictionary new.	! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 8/8/2000 10:45'!createAddFeatureMorphDefaultChar: charObject	"Create a morph to add a new feature for the given character"	| m |	m _ CRAddFeatureMorph model: self.	m defaultChar: charObject.	m layout.	^ m.! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 8/8/2000 10:46'!createBasicMorphForFeature: aCRFeature 	"Create a morph representing the given feature"	| m |	m _ aCRFeature				asMorphSize: self imageSize				border: (self imageSize // 10 max: 2 @ 2)				relative: self relativeSize				properties: self displayProperties				showPoints: self areCapturedPointsShown				orientation: self orientation.	aCRFeature isEmpty not		ifTrue: [m borderWidth: 1;				 borderColor: Color blue twiceLighter twiceLighter].	(self dictionary indirectParentIncludesFeature: aCRFeature)		ifTrue: [m color: (Color r: 0 g: 0 b: 0 alpha: 0.15)].	^ m! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 8/8/2000 10:47'!createStringForItems: anOrderedCollection 	"Create a string representing the most similar features that are passed as the argument"	| string |	anOrderedCollection isEmptyOrNil ifTrue: [^ nil].	string _ 'Next: '.	anOrderedCollection		withIndexDo: [:each :index | 			| position distance dict | 			each isNil				ifTrue: [string _ string , '-']				ifFalse: [position _ (dict _ self appModel featureCollectionOfChar: each char) size > 1								ifTrue: [dict indexOf: each feature].					distance _ each distance * 100 // CRFeature maxNormDistance.					string _ string , (self objectToString: each char).					position ifNotNil: [string _ string , ' [' , (self objectToString: position) , ']'].					string _ string , ' dist: ' , (self objectToString: distance)].			index ~= anOrderedCollection size				ifTrue: [string _ string , '  /  ']].	^ string.! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 6/30/2000 08:59'!dictSelector	^ #invertedDict! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 8/8/2000 10:50'!isParentPane: anObject	"Is anObject a parent pane in one of my graphical representations"	^ self subPaneDict includesKey: anObject! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 8/8/2000 10:51'!isSubPane: anObject	"Is an object a subpane in one of my graphical representations"	^ self subPaneDict includes: anObject! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 2/16/2001 11:10'!orthoOrientation: aSymbol	"Return the orthogonal orientation"	^ aSymbol = #topToBottom ifTrue: [#leftToRight] ifFalse: [#topToBottom].! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 8/8/2000 10:54'!parentPaneOf: anObject	"Rturn the parent pane of anObject"	^ self subPaneDict keyAtIdentityValue: anObject ifAbsent: [nil]! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 7/20/2000 14:05'!prepareAddFeatureAt: charObject parentPane: aPluggableCollectionMorph 	| newDict |	newDict _ Dictionary new.	newDict at: charObject put: (self createAddFeatureMorphDefaultChar: charObject).	aPluggableCollectionMorph collectionOrSelector: newDict.! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 8/8/2000 10:55'!removeSubPaneOf: anObject	"Remove the subpane of anObject, if anObject is a parent pane in one of my graphical	representations"	(self isParentPane: anObject) ifTrue:		[self removeDependent: (self subPaneDict at: anObject).		self subPaneDict removeKey: anObject]! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 8/8/2000 10:56'!shownResultItemsFor: aCRFeature	"Calculate the features that are most similar to aCRFeature."	| collection isNew result |	isNew _ (self dictionary selfOrIndirectParentIncludesFeature: aCRFeature) not.	result _ self appModel lookup: aCRFeature fast: (self nextFeatureCount = 0) 				includeParents: self showDistanceToFeaturesInParents.	collection _ OrderedCollection new.	self nextFeatureCount = 0 ifTrue: [^ collection].	self nextFeatureCount = 1		ifTrue: [collection add: (isNew 								ifTrue: [result at: 1] 								ifFalse: [result distinctCharItem: 1])]		ifFalse: [| index | 			index _ isNew ifTrue: [1] ifFalse: [2].			collection add: (result at: index).			index _ isNew						ifTrue: [result indexOfDistinctChar: 1]						ifFalse: [(index = (result indexOfDistinctChar: 1))								ifTrue: [(result indexOfDistinctChar: 1) + 1]								ifFalse: [result indexOfDistinctChar: 1]].			collection add: (result at: index)].	^ collection! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 6/15/2000 16:59'!statsCache	^ statsCache! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 6/15/2000 16:59'!statsCache: aDictionary	statsCache _ aDictionary! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 8/8/2000 10:57'!subPaneAt: anObject put: subObject	"Register subObject as the subPane of anObject in one of my graphical representations"	(self subPaneOf: anObject) == subObject ifTrue: [^ self].	self removeSubPaneOf: anObject.	self subPaneDict at: anObject put: subObject.! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 6/3/2000 12:07'!subPaneDict	^ subPaneDict! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 6/3/2000 12:07'!subPaneDict: aDictionary	subPaneDict _ aDictionary! !!CRDictionaryBrowser methodsFor: 'private' stamp: 'NS 8/8/2000 10:57'!subPaneOf: anObject	"If anObject is a parent pane in one of my graphical representations, return its sub-pane"	^ self subPaneDict at: anObject ifAbsent: [].! !!CRDictionaryBrowser methodsFor: 'menu' stamp: 'NS 6/30/2000 13:33'!menuChangeImageSizeRequestor: aPluggableCollectionMorph	| size |	size _ FillInTheBlank request: 'Enter new image size' initialAnswer: self imageSize printString.	(size isEmptyOrNil not and: [size isAllDigits]) ifTrue:		[self imageSize: size asNumber.		self changed].! !!CRDictionaryBrowser methodsFor: 'menu' stamp: 'NS 6/30/2000 14:05'!menuSaveLayoutAsDefaultRequestor: aPluggableCollectionMorph	self saveLayoutPropertiesAsDefault.! !!CRDictionaryBrowser methodsFor: 'menu' stamp: 'NS 6/30/2000 14:05'!menuSetLayoutToDefaultRequestor: aPluggableCollectionMorph	self setLayoutPropertiesToDefault.	self changed.! !!CRDictionaryBrowser methodsFor: 'menu' stamp: 'NS 6/30/2000 13:07'!menuSetNextFeatureCountRequestor: aPluggableCollectionMorph value: anInteger	self nextFeatureCount: anInteger.	self changed.! !!CRDictionaryBrowser methodsFor: 'menu' stamp: 'NS 6/30/2000 13:25'!menuSwitchCapturedPointsShownRequestor: aPluggableCollectionMorph	self areCapturedPointsShown: self areCapturedPointsShown not.	self changed.! !!CRDictionaryBrowser methodsFor: 'menu' stamp: 'NS 7/3/2000 16:46'!menuSwitchNextFeatureGraphicsShownRequestor: aPluggableCollectionMorph	self areNextFeatureGraphicsShown: self areNextFeatureGraphicsShown not.	self changed.! !!CRDictionaryBrowser methodsFor: 'menu' stamp: 'NS 2/16/2001 11:22'!menuSwitchOrientationRequestor: aPluggableCollectionMorph	self orientation: (self orthoOrientation: self orientation).	self changed.! !!CRDictionaryBrowser methodsFor: 'menu' stamp: 'NS 6/30/2000 14:00'!menuSwitchRelativeSizeRequestor: aPluggableCollectionMorph	self relativeSize: self relativeSize not.	self changed.! !!CRDictionaryBrowser methodsFor: 'menu' stamp: 'NS 7/30/2000 21:18'!menuSwitchShowDistanceToFeaturesInParentsRequestor: aPluggableCollectionMorph	self showDistanceToFeaturesInParents: self showDistanceToFeaturesInParents not.	self changed.! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 10:58'!addCharActionRequestor: aPluggableCollectionMorph 	"A view calls this method when a new character should be added"	| newString |	newString _ FillInTheBlankMorphWithCharMenu request: 'Please enter new character'.	^ newString isEmptyOrNil 		ifFalse: [self addCharActionRequestor: aPluggableCollectionMorph newChar: (CRChar string: newString)].! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 10:58'!addCharActionRequestor: aPluggableCollectionMorph newChar: anObject	"A view calls this method when a new character should be added"	(self dictionary includesChar: anObject)		ifTrue: [aPluggableCollectionMorph setKey: anObject]		ifFalse: [self prepareAddFeatureAt: anObject parentPane: aPluggableCollectionMorph]! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 10:58'!addFeature: aCRFeature to: charObject requestor: aCRAddFeatureMorph	"A view calls this method when a new feature should be added"	| parentPane |	self appModel addFeature: aCRFeature toChar: charObject.	parentPane _ self parentPaneOf: aCRAddFeatureMorph.	parentPane collectionOrSelector: self dictSelector key: charObject.	(self subPaneOf: parentPane) setKey: (self appModel featureCountOfChar: charObject).! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 10:59'!cancelAddFeatureTo: charObject requestor: aCRAddFeatureMorph	"A view calls this method when adding of a new chaacter should be canceled"	| parentPane |	parentPane _ self parentPaneOf: aCRAddFeatureMorph.	parentPane collectionOrSelector: self invertedDict key: charObject.! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 2/20/2001 19:37'!changeCharRequestRequestor: aPluggableCollectionMorph	"A view calls this method when the currently displayed character changes"	^ ((self subPaneOf: aPluggableCollectionMorph)		isKindOf: CRAddFeatureMorph)		ifTrue: 			[Smalltalk beep.			false]		ifFalse: [true]! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/14/2000 09:35'!charKeyMorph: anObject requestor: aPluggableTextMorph	"A view calls this method to obtain the morph that represents the index (key) of the	currently displayed character"	| morph string |	anObject isNil ifTrue: [^ StringMorph contents: 'Empty'].	morph _ AlignmentMorph new color: aPluggableTextMorph color lighter lighter lighter.	morph hResizing: #shrinkWrap.	string _ anObject headerString.	morph _ morph addMorph: (StringMorph contents: string).	morph on: #mouseDown send: #renameCharAction:sourceMorph:requestor: to: self withValue: aPluggableTextMorph.	morph setBalloonText: 'Click to edit or inspect'.	^ morph.! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 11:01'!deleteCharActionRequestor: aPluggableCollectionMorph 	"A view calls this method in order to delete a character"	| char |	char _ aPluggableCollectionMorph currentKey.	self appModel removeChar: char.! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 11:01'!deleteFeatureActionRequestor: aPluggableCollectionMorph	"A view calls this method in order to delete a feature"	self appModel removeFeature: aPluggableCollectionMorph currentValue.! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 11:02'!featureKeyMorph: anObject requestor: aPluggableCollectionMorph 	"This method is called by one of my views to obtain the morph representing the	index (key) of the current feature."	| parent |	parent _ self parentPaneOf: aPluggableCollectionMorph.	^ (parent isNil or: [anObject isNil])		ifTrue: [StringMorph contents: 'Empty']		ifFalse: 			[| size | 			size _ self appModel featureCountOfChar: (self parentPaneOf: aPluggableCollectionMorph) currentKey.			^ StringMorph contents: (self objectToString: anObject)					, ' / ' , (self objectToString: size)]! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 11:03'!featureMorph: anObject requestor: aPluggableCollectionMorph 	"This method is called by a view to obtain the morph representing a feature"	anObject isNil ifTrue: [^ StringMorph contents: 'Empty'].	^ self createMorphForFeature: anObject.! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 11:03'!gotoCharActionRequestor: aPluggableCollectionMorph	"Called when goto action of a view is executed"	| request key char |	aPluggableCollectionMorph currentKey ifNil: [^ self].		request _ 'Goto: Enter character or beginning of character'.	key _ FillInTheBlankMorphWithCharMenu request: request initialAnswer: aPluggableCollectionMorph currentKey string.	key isEmptyOrNil ifFalse: 		[char _ self invertedDict keys detect: [:each | each string = key] ifNone: [].		char ifNil: [char _ self invertedDict keys detect: [:each | each headerString = key] ifNone: []].		char ifNil: [char _ self invertedDict keys detect: [:each | each string beginsWith: key] ifNone: []].		char isNil			ifTrue: [self inform: key, ' not found']			ifFalse: [(aPluggableCollectionMorph setKey: char toString: false)]]! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 2/16/2001 11:12'!menuActionRequestor: aPluggableCollectionMorph 	"Called to pop up the menu in a view"	| menu string |	aPluggableCollectionMorph currentValue isNil		ifTrue: [^ nil].	menu _ MenuMorph new.	menu 		add: 'Browse'		target: self dictionary		selector: #openBrowser.	self dictionary hasParents ifTrue:		[menu addMorphFront: 			(MenuItemMorph new contents: 'Browse parent'; 				arguments: #(); 				subMenu: (self dictionary parentMenuSelector: #openBrowser)).		menu addMorphFront: 			(MenuItemMorph new contents: 'Inspect parent'; 				arguments: #(); 				subMenu: (self dictionary parentMenuSelector: #openMorph))].	menu addLine.	0 to: 2 do: [:index | 			string _ index = 0						ifTrue: ['Don''t calculate next chars']						ifFalse: [index = 1								ifTrue: ['Calculate next char']								ifFalse: ['Calculate next two chars']].			self nextFeatureCount ~= index				ifTrue: [menu						add: string						target: aPluggableCollectionMorph						selector: #resendMenuAction:						argument: {#menuSetNextFeatureCountRequestor:value:. index}]].		menu addLine.	self dictionary hasParents ifTrue:		[string _ self showDistanceToFeaturesInParents					ifTrue: ['Don''t show distances to features in parents']					ifFalse: ['Show distances to features in parents'].		menu			add: string			target: aPluggableCollectionMorph			selector: #resendMenuAction:			argument: #menuSwitchShowDistanceToFeaturesInParentsRequestor:].	string _ self areNextFeatureGraphicsShown				ifTrue: ['Don''t show next char graphical']				ifFalse: ['Show next char graphical'].	menu		add: string		target: aPluggableCollectionMorph		selector: #resendMenuAction:		argument: #menuSwitchNextFeatureGraphicsShownRequestor:.	menu addLine.	string _ self relativeSize				ifTrue: ['Full feature size']				ifFalse: ['Relative Feature size'].	menu		add: string		target: aPluggableCollectionMorph		selector: #resendMenuAction:		argument: #menuSwitchRelativeSizeRequestor:.	string _ self areCapturedPointsShown				ifTrue: ['Don''t show captured points']				ifFalse: ['Show captured points'].	menu		add: string		target: aPluggableCollectionMorph		selector: #resendMenuAction:		argument: #menuSwitchCapturedPointsShownRequestor:.	menu addLine.	menu		add: 'Change feature graphics size...'		target: aPluggableCollectionMorph		selector: #resendMenuAction:		argument: #menuChangeImageSizeRequestor:.	string _ self orientation = #topToBottom				ifTrue: ['Horizontal orientation']				ifFalse: ['Vertical orientation'].	menu		add: string		target: aPluggableCollectionMorph		selector: #resendMenuAction:		argument: #menuSwitchOrientationRequestor:.	menu addLine.	menu		add: 'Reset layout to default'		target: aPluggableCollectionMorph		selector: #resendMenuAction:		argument: #menuSetLayoutToDefaultRequestor:.	menu		add: 'Save layout as default'		target: aPluggableCollectionMorph		selector: #resendMenuAction:		argument: #menuSaveLayoutAsDefaultRequestor:.	^ menu! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 11:04'!objectToString: anObject 	"General method that converts an object to a string. This is used by my views to	get printable representations of certain objects"	^ (anObject isKindOf: String)		ifTrue: [anObject]		ifFalse: [anObject printString]! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 6/3/2000 12:05'!okayActionRequestor: aPluggableCollectionMorph	^ true! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 11:04'!prepareAddFeatureActionRequestor: aPluggableCollectionMorph	"Called by one of my views to prepare the add feature action"	| parentPane |	parentPane _ self parentPaneOf: aPluggableCollectionMorph.	self prepareAddFeatureAt: parentPane currentKey parentPane: parentPane.	! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 11:04'!renameCharAction: evt sourceMorph: aMorph requestor: aPluggableTextMorph	"Called by a view to rename the current character"	| oldChar newChar newString |	(self changeCharRequestRequestor: aPluggableTextMorph) ifFalse: [^ self].	oldChar _ aPluggableTextMorph currentKey.	newString _ FillInTheBlankMorphWithCharMenu request: 'Edit character' initialAnswer: oldChar string.	newString isEmptyOrNil 	ifFalse:		[newChar _ CRChar string: newString.		newChar ~= oldChar		ifTrue: 			[self appModel renameChar: oldChar to: newChar.			aPluggableTextMorph setKey: newChar]].	! !!CRDictionaryBrowser methodsFor: 'view hooks' stamp: 'NS 2/20/2001 19:46'!subPaneMorph: anObject requestor: aPluggableCollectionMorph 	"Called by a feature to retrieve the subPane with all the features"	| subPane |	subPane _ self subPaneOf: aPluggableCollectionMorph.	anObject isNil ifTrue:		[subPane ifNotNil: [self removeSubPaneOf: aPluggableCollectionMorph].		^ StringMorph contents: 'Empty'].	(anObject isKindOf: CRAddFeatureMorph)		ifTrue: 			[self subPaneAt: aPluggableCollectionMorph put: anObject.			^ anObject].	(subPane isKindOf: PluggableCollectionMorph)		ifFalse: 			[subPane _ PluggableCollectionMorph						model: self						collectionOrSelector: anObject						okaySelector: nil						cancelSelector: nil						addSelector: #prepareAddFeatureActionRequestor:						deleteSelector: #deleteFeatureActionRequestor:						gotoSelector: nil						menuSelector: nil						changeSelector: nil						valueMorphSelector: #featureMorph:requestor:						keyMorphSelector: #featureKeyMorph:requestor:						objectToStringSelector: #objectToString:						releaseSelector: nil.			self removeDependent: subPane.			self subPaneAt: aPluggableCollectionMorph put: subPane.			subPane listDirection: #topToBottom;				layout]		ifTrue: [subPane collectionOrSelector: anObject].	^ subPane! !!CRDictionaryBrowser methodsFor: 'updating' stamp: 'NS 7/20/2000 13:56'!removeDependent: anObject 	super removeDependent: anObject.	self removeSubPaneOf: anObject.	self dependents isEmpty		ifTrue: 			[self appModel: nil.			self displayProperties removeDependent: self]! !!CRDictionaryBrowser methodsFor: 'updating' stamp: 'NS 8/8/2000 11:07'!update: aParameter 	| source symbol object |	"Decompose argument into parts and execute appropriate actions"	((aParameter isKindOf: Array) and: [aParameter size = 3]) ifTrue:		[source _ aParameter first.		symbol _ aParameter second.		object _ aParameter at: 3.		((source isKindOf: CRDisplayProperties) and: [symbol = #activeInstance]) ifTrue:			[source removeDependent: self.			object addDependent: self.			self changed: aParameter]].	self changed: aParameter.! !!CRDictionaryBrowser class methodsFor: 'class initialization' stamp: 'NS 8/8/2000 11:08'!initialize	"DefaultLayoutInstance holds the current default layout for dictionary browsers.	Here a new default layout instance gets created"	"	CRDictionaryBrowser initialize	"	self defaultLayoutInstance: self layoutInstance.! !!CRDictionaryBrowser class methodsFor: 'default layout' stamp: 'NS 6/29/2000 16:38'!areCapturedPointsShown	^ false! !!CRDictionaryBrowser class methodsFor: 'default layout' stamp: 'NS 6/29/2000 16:43'!areNextFeatureGraphicsShown	^ true! !!CRDictionaryBrowser class methodsFor: 'default layout' stamp: 'NS 6/28/2000 17:09'!displayMode	^ #capturedPoints! !!CRDictionaryBrowser class methodsFor: 'default layout' stamp: 'NS 6/26/2000 13:59'!hasOkayButton	^ true! !!CRDictionaryBrowser class methodsFor: 'default layout' stamp: 'NS 6/15/2000 14:50'!imageSize	^ 80! !!CRDictionaryBrowser class methodsFor: 'default layout' stamp: 'NS 7/30/2000 19:39'!nextFeatureCount	"0, 1, 2"	^ 2! !!CRDictionaryBrowser class methodsFor: 'default layout' stamp: 'NS 2/16/2001 11:13'!orientation	^ #leftToRight! !!CRDictionaryBrowser class methodsFor: 'default layout' stamp: 'NS 6/26/2000 14:15'!relativeSize	^ false! !!CRDictionaryBrowser class methodsFor: 'default layout' stamp: 'NS 7/30/2000 19:40'!showDistanceToFeaturesInParents	^ true! !!CRDictionaryBrowser class methodsFor: 'instance creation' stamp: 'NS 6/30/2000 08:51'!appModel: aCRDictionaryBrowserAppModel	^ super new initializeAppModel: aCRDictionaryBrowserAppModel! !!CRDictionaryBrowser class methodsFor: 'instance creation' stamp: 'NS 6/30/2000 08:53'!dictionary: aCRDictionary	^ self appModel: aCRDictionary browserAppModel! !!CRDictionaryBrowser class methodsFor: 'instance creation' stamp: 'NS 8/8/2000 11:09'!layoutInstance	"Return an instance with the layout properties according to the class defaults"	^ super new initializeLayoutProperties! !!CRDictionaryBrowser class methodsFor: 'accessing' stamp: 'NS 6/30/2000 13:53'!defaultLayoutInstance	^ DefaultLayoutInstance! !!CRDictionaryBrowser class methodsFor: 'accessing' stamp: 'NS 6/30/2000 13:54'!defaultLayoutInstance: aCRDictionaryBrowser	DefaultLayoutInstance _ aCRDictionaryBrowser! !!CRDictionaryBrowserAppModel methodsFor: 'updating' stamp: 'NS 7/14/2000 12:57'!removeDependent: anObject 	super removeDependent: anObject.	self dependents isEmpty		ifTrue: [self dictionary: nil]! !!CRDictionaryBrowserAppModel methodsFor: 'updating' stamp: 'NS 7/14/2000 13:04'!update: aParameter 	| object symbol |	(aParameter isKindOf: Array)		ifTrue: 			[object _ aParameter first.			symbol _ aParameter second]		ifFalse: [object _ aParameter].	self clearResultCache.	self changed: aParameter.! !!CRDictionaryBrowserAppModel methodsFor: 'initialize-release' stamp: 'NS 7/14/2000 12:57'!initializeDictionary: aCRDictionary	self dictionary: aCRDictionary.	self clearResultCache.	! !!CRDictionaryBrowserAppModel methodsFor: 'initialize-release' stamp: 'NS 8/8/2000 12:27'!newBrowser	"Create a new browser that shows the contents of this application model"	^ CRDictionaryBrowser appModel: self! !!CRDictionaryBrowserAppModel methodsFor: 'private' stamp: 'NS 8/8/2000 12:28'!clearResultCache	"Clear the result cache.	There are two result caches: One includes features of the parent dictionary while the	other on doesn't."	self resultCache: Dictionary new.	self resultCacheWithParents: Dictionary new.! !!CRDictionaryBrowserAppModel methodsFor: 'private' stamp: 'NS 7/14/2000 13:53'!dictionary: aCRDictionary	self dictionary isNil ifFalse: [self dictionary removeDependent: self].	dictionary _ aCRDictionary.	self dictionary isNil ifFalse: [self dictionary addDependent: self].! !!CRDictionaryBrowserAppModel methodsFor: 'private' stamp: 'NS 6/30/2000 09:51'!resultCache: aDictionary	resultCache _ aDictionary! !!CRDictionaryBrowserAppModel methodsFor: 'private' stamp: 'NS 8/8/2000 11:34'!resultCacheWithParents: aDictionary	resultCacheWithParents _ aDictionary! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 7/14/2000 13:05'!addFeature: aCRFeature toChar: anObject	self dictionary atFeature: aCRFeature put: anObject.	self dictionary changed: {self. #addFeature}.! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 7/14/2000 13:01'!charOfFeature: aCRFeature	^ self dictionary atFeature: aCRFeature ifAbsent: [].! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 7/14/2000 12:57'!dictionary	^ dictionary! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 7/14/2000 13:01'!featureCollectionOfChar: anObject	^ self dictionary atChar: anObject ifAbsent: [OrderedCollection new].! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 8/8/2000 12:30'!featureCollectionWithFeature: aCRFeature 	"Return the collection of all the features that are associated to the same character as	aCRFeature is associated to."	| char |	^ (char _ self charOfFeature: aCRFeature) isNil		ifTrue: [OrderedCollection new]		ifFalse: [self featureCollectionOfChar: char]! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 6/30/2000 09:09'!featureCountOfChar: anObject	^ (self featureCollectionOfChar: anObject) size! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 8/8/2000 12:30'!featureCountWithFeature: aCRFeature 	"Return the number of features associated to the character aCRFeature is associated to"	^ (self featureCollectionWithFeature: aCRFeature) size! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 8/8/2000 12:24'!lookup: aCRFeature fast: fastBoolean includeParents: aBoolean	"Lookup the given feature in the dictionary and update the cache"	| size symmetric result |	"Determine the minimum size of the lookup result"	size _ fastBoolean				ifTrue: [1]				ifFalse: [self dictionary totalMaxMultipleDefinitions + 1 max: 3].	"Check the cache holding lookup results including parent features"	(self resultCacheWithParents includesKey: aCRFeature) ifTrue: 		[result _ self resultCacheWithParents at: aCRFeature.		result size >= size ifTrue:			[^ aBoolean ifTrue: [result] ifFalse: [result copyWithoutParentFeatures]]].		"Check the cache holding lookup results without parent features"	(aBoolean not and: [self resultCache includesKey: aCRFeature]) ifTrue: 		[result _ self resultCache at: aCRFeature.		result size > size ifTrue: [^ result]].	"Do a real lookup"	symmetric _ (self dictionary selfOrIndirectParentIncludesFeature: aCRFeature).	result _ self dictionary lookup: aCRFeature minResultSize: size 				symmetric: symmetric maxSpeed: 50 includeParents: aBoolean.	"If lookup was symmetric ((A dist: B) = (B dist: A)): Update caches"	symmetric ifTrue: [		aBoolean			ifTrue: 				[self resultCacheWithParents at: aCRFeature put: result.				(self resultCache includesKey: aCRFeature) ifTrue: 					[self resultCache removeKey: aCRFeature]]			ifFalse: 				[self resultCache at: aCRFeature put: result]].	result.	^ result.! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 7/14/2000 12:56'!removeChar: anObject	self dictionary removeChar: anObject.	self dictionary changed: {self. #removeChar}.! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 7/14/2000 12:56'!removeFeature: aCRFeature	self dictionary removeFeature: aCRFeature.	self dictionary changed: {self. #removeFeature}.! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 7/19/2000 13:10'!renameChar: anObject to: newObject	self dictionary renameChar: anObject to: newObject.	self dictionary changed: {self. #renameChar}.! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 6/30/2000 09:51'!resultCache	^ resultCache! !!CRDictionaryBrowserAppModel methodsFor: 'accessing' stamp: 'NS 8/8/2000 11:34'!resultCacheWithParents	^ resultCacheWithParents! !!CRDictionaryBrowserAppModel class methodsFor: 'instance creation' stamp: 'NS 6/30/2000 08:33'!dictionary: aCRDictionary	^ super new initializeDictionary: aCRDictionary! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 8/8/2000 12:38'!acceptAdvanced	"This method is called when a user accepts the advanced section.	It updates the model"	model parameters setAdvanced: parameters.	model changed: {self. #advanced}.	self setOldValues.	! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 2/17/2001 10:26'!acceptBasic	"This method is called when a user accepts the basic section.	It updates the model"	"Dictionaries without name ar not accessible from the dictionary instance browser	and they cannot have an exported name!!"	self name isEmptyOrNil ifTrue:		[self exportedName isEmptyOrNil			ifTrue: [oldName isEmptyOrNil ifFalse: 						[(self confirm: 'Dictionary without a name are not accessiblefrom withhin the dictionary tool and they cannot act as parents. Ok to continue?') ifFalse: [^ self]]]			ifFalse: 				[Smalltalk beep.				^ self inform: 'Only named dictionaries can have an exported name']].	"Update the model"	(model name: name asSymbol makeDistinct: false) ifFalse: 		[Smalltalk beep.		self inform: 'Name already used. Please choose another name'.		^ self].	model exportedName: exportedName asSymbol.	model parentsFromString: parents.	parents _ model parentsAsString.	parentCount _ model parentCount.	model parameters setBasic: parameters.	model changed: {self. #basic}.	self setOldValues.! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 8/8/2000 12:40'!acceptCapturing	"This method is called when a user accepts the capturing section.	It updates the model"	"Properties can only be changed when dictionary is empty or when dictionary	includes captured points!!"	(parameters angleSector ~= model parameters angleSector		or: [parameters minAngle ~= model parameters minAngle			or: [parameters minDirectionLengthPercentage 				~= model parameters minDirectionLengthPercentage]]) ifTrue: 					[self modelIncludeCapturedPoints ifTrue: 						[(model isEmpty or: 							[self confirm: 'Accept and recalculate the existing features?'])								ifTrue: [[model parameters setCapturing: parameters.										model recalculate] valueUninterruptably]] 								ifFalse: [self inform: 'Cannot change parameters without captured points']. 										self cancelAction].	self includeCapturedPoints		ifTrue: [model storeAllCapturedPoints]		ifFalse: [self modelIncludeCapturedPoints				ifTrue: [(self confirm: 'Delete all the captured points?')						ifTrue: [[model storeNoCapturedPoints] valueUninterruptably]						ifFalse: [self cancelAction]]].	model changed: {self. #capturing}.	self setOldValues.! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 8/17/2000 10:21'!canChange	"Returns false if there are unaccepted changes"	^ self canChangeAsk: true! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 8/17/2000 10:27'!canChangeAsk: aBoolean	"Returns false if there are unaccepted changes"	^ (self currentPage notNil and: [self currentPage externalName = 'Browse']) 		ifTrue:			[self currentPage submorphs isEmpty or: 				[self currentPage submorphs first changeRequest]]		ifFalse:			[((oldName isNil				or: [oldName = name						and: [oldExportedName = exportedName								and: [oldIncludeCapturedPoints = includeCapturedPoints										and: [oldParameters = parameters											and: [oldParents = parents]]]]])			or: [aBoolean and: [self confirm: 'Changes have not been saved.Is it OK to cancel those changes?']])]! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 8/17/2000 10:32'!changed	self indicateChanged.	^ super changed.! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 8/17/2000 10:31'!indicateChanged	self borderColor: ((self canChangeAsk: false) ifTrue: [Color blue] ifFalse: [Color red]).! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 7/7/2000 16:26'!update: aParameter 	| object symbol |	(aParameter isKindOf: Array)		ifTrue: [object _ aParameter first.			symbol _ aParameter second]		ifFalse: [object _ aParameter].	(object isKindOf: self class)		ifTrue: [symbol = #advanced				ifTrue: [self updateAdvanced].			symbol = #basic				ifTrue: [self updateBasic].			symbol = #capturing				ifTrue: [self updateCapturing]].! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 8/8/2000 12:45'!updateAdvanced	"Update the advanced section of the view with the model's values"	parameters setAdvanced: model parameters.	oldParameters setAdvanced: parameters.! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 6/26/2000 11:01'!updateAll	self updateBasic.	self updateAdvanced.	self updateCapturing.	! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 8/8/2000 12:45'!updateBasic	"Update the basic section of the view with the model's values"	name _ oldName _ model nameAsString.	exportedName _ oldExportedName _ model exportedNameAsString.	parents _ oldParents _ model parentsAsString.	parentCount _ model parentCount.	parameters setBasic: model parameters.	oldParameters setBasic: parameters.! !!CRDictionaryMorph methodsFor: 'updating' stamp: 'NS 8/8/2000 12:45'!updateCapturing	"Update the capturing section of the view with the model's values"	includeCapturedPoints _ oldIncludeCapturedPoints _ self modelIncludeCapturedPoints.	parameters setCapturing: model parameters.	oldParameters setCapturing: parameters.! !!CRDictionaryMorph methodsFor: 'private' stamp: 'NS 6/27/2000 10:49'!modelIncludeCapturedPoints	^ model hasAllCapturedPoints! !!CRDictionaryMorph methodsFor: 'private' stamp: 'NS 8/17/2000 10:32'!setOldValues	"Store the current values as the old values.	The old values are used to know wheter a section has been changed by the user"	oldName _ name copy.	oldExportedName _ exportedName copy.	oldParents _ parents copy.	oldIncludeCapturedPoints _ includeCapturedPoints copy.	oldParameters _ parameters copy.	self indicateChanged.! !!CRDictionaryMorph methodsFor: 'initialize-release' stamp: 'NS 2/16/2001 17:38'!initializeDictionary: aCRDictionary	super initialize.	self tabsMorph disableDragNDrop.	aCRDictionary addDependent: self.	model _ aCRDictionary.	parameters _ CRParameters new.	oldParameters _ CRParameters new.	createdSubmorphs _ Set new.	hasCloseButton _ false.	self updateAll.! !!CRDictionaryMorph methodsFor: 'initialize-release' stamp: 'NS 2/16/2001 17:37'!layout	"Layout the morph and all submorphs"	| currentWorld browser |	self borderColor: Color blue.	self borderWidth: 1.	"Create the tabs"	self addTabForBook: (self createBasicTabMorph beSticky setNameTo: 'Basic').	self addTabForBook: (self createAdvancedTabMorph beSticky setNameTo: 'Advanced').	self addTabForBook: (self createCapturingTabMorph beSticky setNameTo: 'Capturing').	self addTabForBook: (self createStatsTabMorph beSticky setNameTo: 'Stats').	self addTabForBook: (browser _ self createBrowseTabMorph beSticky setNameTo: 'Browse').	self color: browser color.	self selectTabNamed: 'Basic'.		"Make the widgets stat stepping"	currentWorld _ steppingWorld isNil ifTrue: [World] ifFalse: [steppingWorld].	createdSubmorphs do: [:each | 		((each isKindOf: UpdatingThreePhaseButtonMorph) or: [each isKindOf: UpdatingStringMorph]) 			ifTrue: [each startSteppingIn: currentWorld]].	self startSteppingIn: currentWorld.! !!CRDictionaryMorph methodsFor: 'initialize-release' stamp: 'NS 6/28/2000 10:16'!openInWorld: aWorld	steppingWorld _ aWorld.	self ensureLayout.	^ super openInWorld: aWorld.! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 7/30/2000 13:37'!acceptAction	| pageName |	pageName _ self currentPage externalName.	pageName = 'Basic' ifTrue: [self acceptBasic].	pageName = 'Advanced' ifTrue: [self acceptAdvanced].	pageName = 'Capturing' ifTrue: [self acceptCapturing].! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:54'!acuteAngleRelevance	^ parameters acuteAngleRelevance! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:54'!acuteAngleRelevance: anInteger	parameters acuteAngleRelevance: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:44'!alertDistance	^ parameters alertDistance! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:44'!alertDistance: anInteger	parameters alertDistance: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:48'!alertDistanceDifference	^ parameters alertDistanceDifference! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:48'!alertDistanceDifference: anInteger	parameters alertDistanceDifference: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:49'!alertRelativeDistanceDifference	^ parameters alertRelativeDistanceDifference! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:49'!alertRelativeDistanceDifference: anInteger	parameters alertRelativeDistanceDifference: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:54'!angleRelevance	^ parameters angleRelevance! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:54'!angleRelevance: anInteger	parameters angleRelevance: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:56'!angleSector	^ parameters angleSector! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:56'!angleSector: anInteger	parameters angleSector: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 6/27/2000 12:07'!cancelAction	self updateAll.	self setOldValues.! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 7/18/2000 08:19'!closeAction	self canChange ifTrue: [self delete].! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:34'!editParents	| answer |	answer _ FillInTheBlank request: 'Enter the parents (enclose names in '''', '''' = none)' initialAnswer: parents.	(answer isEmptyOrNil not and: [answer ~= parents])			ifTrue: [ | array |			parents _ answer.			array _ model getParentsAndErrorForString: answer.			parentCount _ array first size.			(answer ~= '''''' and: [array second notNil]) ifTrue:				[self inform: 'The following parents are not available:' , array second]].	self indicateChanged.! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:50'!escapeTime	^ parameters escapeTime! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:46'!escapeTime: anInteger	parameters escapeTime: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 11:44'!exportedName	^ exportedName isEmptyOrNil 		ifTrue: ['     ']		ifFalse: [exportedName]! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 11:46'!exportedName: aString	exportedName _ (aString detect: [:each | each ~= Character space] ifNone: []) isNil						ifTrue: ['']						ifFalse: [aString].! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 6/26/2000 11:13'!includeCapturedPoints	^ includeCapturedPoints! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 6/24/2000 16:22'!isAlertEnabled	^ parameters isAlertEnabled.! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 7/26/2000 09:30'!isRejectEnabled	^ parameters isRejectEnabled.! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:56'!minAngle	^ parameters minAngle! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:56'!minAngle: anInteger	parameters minAngle: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:57'!minDirectionLengthPercentage	^ parameters minDirectionLengthPercentage! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:57'!minDirectionLengthPercentage: anInteger	parameters minDirectionLengthPercentage: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 6/24/2000 16:47'!name	^ name! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 6/26/2000 10:33'!name: aString	name _ aString.! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/1/2000 14:32'!parentCount	^ parentCount! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:45'!rejectDistance	^ parameters rejectDistance! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:44'!rejectDistance: anInteger	parameters rejectDistance: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:48'!rejectDistanceDifference	^ parameters rejectDistanceDifference! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:48'!rejectDistanceDifference: anInteger	parameters rejectDistanceDifference: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:49'!rejectRelativeDistanceDifference	^ parameters rejectRelativeDistanceDifference! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:49'!rejectRelativeDistanceDifference: anInteger	parameters rejectRelativeDistanceDifference: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:53'!shapeRelevance	^ parameters shapeRelevance! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:53'!shapeRelevance: anInteger	parameters shapeRelevance: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:46'!sizeRelevance	^ parameters sizeRelevance! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:46'!sizeRelevance: anInteger	parameters sizeRelevance: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:46'!speedPercentage	^ parameters speedPercentage! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:47'!speedPercentage: anInteger	parameters speedPercentage: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:54'!startEndRelevance	^ parameters startEndRelevance! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:53'!startEndRelevance: anInteger	parameters startEndRelevance: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:53'!strokeRelevance	^ parameters strokeRelevance! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:52'!strokeRelevance: anInteger	parameters strokeRelevance: anInteger! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 6/24/2000 16:23'!switchAlert	parameters isAlertEnabled: parameters isAlertEnabled not! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 6/27/2000 10:52'!switchIncludeCapturedPoints	(includeCapturedPoints or: [self modelIncludeCapturedPoints or: [model isEmpty]])		ifTrue: [includeCapturedPoints _ includeCapturedPoints not]		ifFalse: [self inform: 'Cannot be enabled in non-empty dictionary!!']! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 7/26/2000 09:30'!switchReject	parameters isRejectEnabled: parameters isRejectEnabled not! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:47'!timeRelevance	^ parameters timeRelevance! !!CRDictionaryMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:47'!timeRelevance: anInteger	parameters timeRelevance: anInteger! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 7/18/2000 08:23'!createAcceptButton	^ self createBasicButton label: 'Accept';	 actionSelector: #acceptAction;	 actWhen: #buttonDown! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 8/28/2000 10:43'!createAdvancedTabMorph	| morph labels maxLen items |	morph _ self createEmptyTabMorph.	labels _ {'Stroke relevance'. 'Shape relevance'. 'Start / end relevance'. 'Angle relevance'. 'Curvature relevance'}.	labels _ labels collect: [:each | self createBasicLabelStringMorph: each].	maxLen _ labels inject: 0 into: [:max :each | max _ max max: each extent x].	morph addMorphBack: ((TextMorph new contents: 'Use this section to define the relevance ofthe size-independent geometric features.(Note: The default preferences seem to be appropriate for real character dictionaries. But for non-character gesture dictionaries you  might want to change the settings (E.g. set the shape relevance to 0))') color: Color blue).	items _ {(self createBasicUpdatingNumberMorphOn: self				get: #strokeRelevance put: #strokeRelevance:				min: 0 max: 1000)				setBalloonText: 'Relevance of the whole stroke sequence. This is the most powerful part of the recognizer and therefore this value should be much higher than the others'. 			(self createBasicUpdatingNumberMorphOn: self				get: #shapeRelevance put: #shapeRelevance:				min: 0 max: 1000)				setBalloonText: 'Relevance of the bounding box'' aspect ratio'. 			(self createBasicUpdatingNumberMorphOn: self				get: #startEndRelevance put: #startEndRelevance:				min: 0 max: 1000)				setBalloonText: 'Relevance of the stroke''s start / end position'.			(self createBasicUpdatingNumberMorphOn: self				get: #angleRelevance put: #angleRelevance:				min: 0 max: 1000)				setBalloonText: 'Relevance of the strokes angles (total angle sum, sum of positive / negative angles, etc.)'.  			(self createBasicUpdatingNumberMorphOn: self				get: #acuteAngleRelevance put: #acuteAngleRelevance:				min: 0 max: 1000)				setBalloonText: 'Relevance of the curvature (Acute angles, etc)'}.	1 to: labels size do: 		[:index | 		| label item row spacerLen | 		label _ labels at: index.		item _ items at: index.		spacerLen _ maxLen - label extent x + 20.		row _ AlignmentMorph newRow.		row addMorphBack: label.		row addTransparentSpacerOfSize: spacerLen @ 0.		row addMorphBack: item.		morph addMorphBack: row].	morph addTransparentSpacerOfSize: 5 @ 5.	morph addMorphBack: self createDefaultButtons.	^ morph! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 6/28/2000 10:18'!createBasicButton	^ createdSubmorphs add: (SimpleButtonMorph new target: self; borderColor: #raised).! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 6/28/2000 09:36'!createBasicLabelStringMorph: aString	^ StringMorph contents: aString.! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 8/17/2000 10:49'!createBasicTabMorph	| morph labels maxLen items alertRejectText |	morph _ self createEmptyTabMorph.	labels _ {'Exported name'. 'Name'. 'Direct parents (click to inspect)'. 'Speed (%)'. 'Size relevance (%)'. 'Time relevance (%)'. 'Escape time (ms)'. 'Alert / Reject'. '- Max. distance (0-100)'. '- Min. difference (0-100)'. '- Min. relative difference (%)'}.	labels _ labels collect: [:each | self createBasicLabelStringMorph: each].	maxLen _ labels inject: 0 into: [:max :each | max _ max max: each extent x].	alertRejectText _ 'Alert / reject if:distance > max. distance OR(difference < min. difference ANDrelative difference < min. relative difference). The relative difference means the difference of the best two matches divided by the distance of the best match'.	items _ {(self createBasicUpdatingStringMorphOn: self				get: #exportedName put: #exportedName:)				setBalloonText: 'Dictionaries can be assigned to morphs using their exported name'. 			(self createBasicUpdatingStringMorphOn: self				get: #name put: #name:) 				setBalloonText: 'Dictionaries are internally identified by their name'. 			(self createBasicUpdatingStringMorphOn: self				get: #parentCount put: nil) 				setBalloonText: 'Click to inspect / edit the parent dictionaries';				on: #mouseUp send: #editParents to: self. 			(self createBasicUpdatingNumberMorphOn: self				get: #speedPercentage put: #speedPercentage:				min: 0 max: 100)				setBalloonText: 'Speed-accuracy tradeoff.0% = max. accuracy.100% = max. speed'. 			(self createBasicUpdatingNumberMorphOn: self				get: #sizeRelevance put: #sizeRelevance:				min: 0 max: 100)				setBalloonText: 'Relevance of the stroke''s absolute size. A value of 100% means that it is as important as the size-independent geometric features. (See Advanced section)'. 			(self createBasicUpdatingNumberMorphOn: self				get: #timeRelevance put: #timeRelevance:				min: 0 max: 100) 				setBalloonText: 'Relevance of the time used to draw the entire stroke. A value of 100% means that it is as important as the size-independent geometric features. (See Advanced section)'.			(self createBasicUpdatingNumberMorphOn: self				get: #escapeTime put: #escapeTime:				min: 0 max: 100000)				setBalloonText: 'If you leave the pen at the starting point for this amount of time, the recognizer gets escaped'. 			AlignmentMorph new addMorphBack: (				self createBasicUpdatingButtonOn: self action: #switchAlert				get: #isAlertEnabled); addTransparentSpacerOfSize: 15@0;				addMorphBack: (				self createBasicUpdatingButtonOn: self action: #switchReject				get: #isRejectEnabled); setBalloonText: alertRejectText maxLineLength: 50. 			AlignmentMorph new addMorphBack: (				self createBasicUpdatingNumberMorphOn: self				get: #alertDistance put: #alertDistance:				min: 0 max: 100); addTransparentSpacerOfSize: 20@0;				addMorphBack: (				self createBasicUpdatingNumberMorphOn: self				get: #rejectDistance put: #rejectDistance:				min: 0 max: 100); setBalloonText: alertRejectText maxLineLength: 50.			AlignmentMorph new addMorphBack: (				self createBasicUpdatingNumberMorphOn: self				get: #alertDistanceDifference put: #alertDistanceDifference:				min: 0 max: 100); addTransparentSpacerOfSize: 20@0;				addMorphBack: (				self createBasicUpdatingNumberMorphOn: self				get: #rejectDistanceDifference put: #rejectDistanceDifference:				min: 0 max: 100); setBalloonText: alertRejectText maxLineLength: 50.			AlignmentMorph new addMorphBack: (				self createBasicUpdatingNumberMorphOn: self				get: #alertRelativeDistanceDifference put: #alertRelativeDistanceDifference:				min: 0 max: 100); addTransparentSpacerOfSize: 20@0;				addMorphBack: (				self createBasicUpdatingNumberMorphOn: self				get: #rejectRelativeDistanceDifference put: #rejectRelativeDistanceDifference:				min: 0 max: 100); setBalloonText: alertRejectText maxLineLength: 50}.	1 to: labels size do: 		[:index | 		| label item row spacerLen | 		label _ labels at: index.		item _ items at: index.		spacerLen _ maxLen - label extent x + 20.		row _ AlignmentMorph newRow.		row addMorphBack: label.		row addTransparentSpacerOfSize: spacerLen @ 0.		row addMorphBack: item.		morph addMorphBack: row].	morph addTransparentSpacerOfSize: 5 @ 5.	morph addMorphBack: self createDefaultButtons.	^ morph.! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 7/27/2000 15:38'!createBasicUpdatingButtonOn: anObject action: actionSelector get: getSelector	| morph |	morph _ UpdatingThreePhaseButtonMorph checkBox.	morph target: anObject; actionSelector: actionSelector; getSelector: getSelector.	^ createdSubmorphs add: morph! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 7/27/2000 15:39'!createBasicUpdatingNumberMorphOn: anObject get: getSelector put: putSelector min: minNumber max: maxNumber	| morph |	morph _ UpdatingNumericStringMorph on: anObject selector: getSelector.	morph stepTime: (morph stepTime max: 500).	morph putSelector: putSelector;	 min: minNumber;	 max: maxNumber.	^ createdSubmorphs add: morph! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 7/27/2000 15:39'!createBasicUpdatingStringMorphOn: anObject get: getSelector put: putSelector	| morph |	morph _ UpdatingStringMorph on: anObject selector: getSelector.	morph stepTime: (morph stepTime max: 500).	morph putSelector: putSelector;	 useStringFormat.	^ createdSubmorphs add: morph! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 8/14/2000 16:51'!createBrowseTabMorph	| morph |	morph _ model newBrowser hasOkayButton: false;					 newMorph.	morph borderWidth: 0.	morph vResizing: #shrinkWrap;		hResizing: #shrinkWrap.			"Wrap Browser into alignment morph. Else the browser dependencies are deleted	by changing the tabs!!"	createdSubmorphs add: morph.	morph _ AlignmentMorph newColumn addMorph: morph; yourself.	morph hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	self hasCloseButton ifTrue: [morph addMorphBack: self createCloseButton].	^ morph.! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 6/24/2000 13:53'!createCancelButton	^ self createBasicButton label: 'Cancel';	 actionSelector: #cancelAction;	 actWhen: #buttonDown! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 8/17/2000 10:57'!createCapturingTabMorph	| morph labels maxLen items |	morph _ self createEmptyTabMorph.	labels _ {'Include captured points'. 'Angle sector'. 'Min. angle'. 'Min. direction length (%)'.}.	labels _ labels collect: [:each | self createBasicLabelStringMorph: each].	maxLen _ labels inject: 0 into: [:max :each | max _ max max: each extent x].	morph addMorphBack: ((TextMorph new contents: 'Use this section to control the capturingprocess.(Attention: Unappropriate changes can decrease the recognition quality!!)') color: Color blue).	items _ {(self createBasicUpdatingButtonOn: self action: #switchIncludeCapturedPoints				get: #includeCapturedPoints) 				setBalloonText: 'Shall the unprocessed sequence of captured points be stored? It needs a lot of space and has no impact on the recognition quality. Hovewer, it allows to change the capturing properties even after strokes are captured.' maxLineLength: 40. 			(self createBasicUpdatingNumberMorphOn: self				get: #angleSector put: #angleSector:				min: 0 max: 359)				setBalloonText: 'The 360 degrees range gets partitioned into sectors of this size. Whenever the stroke direction changes the sector, a new point gets added to the sequence of relevant points. It should be a divisor of 360 and 45 seems to be a very suitable value!! (Smaller values are NOT necessarily better values!!)' maxLineLength: 50. 			(self createBasicUpdatingNumberMorphOn: self				get: #minAngle put: #minAngle:				min: 0 max: 359)				setBalloonText: 'New relevant points are added only if the angle between the last vector and the new vector is more that this value. It seems to be suitable if it is approximately half the value of the angle sector' maxLineLength: 40. 			(self createBasicUpdatingNumberMorphOn: self				get: #minDirectionLengthPercentage put: #minDirectionLengthPercentage:				min: 0 max: 100)				setBalloonText: 'New relevant points are added only if the distance to the last relevant point is at least this portion of the strokes size. (Nice to decrease noise)'}.	1 to: labels size do: 		[:index | 		| label item row spacerLen | 		label _ labels at: index.		item _ items at: index.		spacerLen _ maxLen - label extent x + 20.		row _ AlignmentMorph newRow.		row addMorphBack: label.		row addTransparentSpacerOfSize: spacerLen @ 0.		row addMorphBack: item.		morph addMorphBack: row].	morph addTransparentSpacerOfSize: 5 @ 5.	morph addMorphBack: self createDefaultButtons.	^ morph! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 7/17/2000 18:15'!createCloseButton	^ self createBasicButton label: 'Close';	 actionSelector: #closeAction;	 actWhen: #buttonDown! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 2/16/2001 11:57'!createDefaultButtons	| morph |	morph _ AlignmentMorph newRow.	morph listCentering: #bottomRight.	morph addMorphBack: self createAcceptButton.	morph addTransparentSpacerOfSize: 5@5.	morph addMorphBack: self createCancelButton.	self hasCloseButton ifTrue: [		morph addTransparentSpacerOfSize: 5@5.		morph addMorphBack: self createCloseButton].	^ morph.! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 2/16/2001 11:25'!createEmptyTabMorph	| morph |	morph _ AlignmentMorph newColumn.	morph listCentering: #center.	^ createdSubmorphs add: morph! !!CRDictionaryMorph methodsFor: 'submorphs' stamp: 'NS 7/31/2000 10:24'!createStatsTabMorph	| morph labels maxLen items |	morph _ self createEmptyTabMorph.	labels _ {'Size'. 'Max. multiple definitions'. 'Direct parents'. 'Total parents'. 'Total size'. 'Total max. multiple definitions'}.	labels _ labels collect: [:each | self createBasicLabelStringMorph: each].	maxLen _ labels inject: 0 into: [:max :each | max _ max max: each extent x].	items _ {(self createBasicUpdatingNumberMorphOn: model				get: #size put: nil				min: 0 max: SmallInteger maxVal)				setBalloonText: 'Number of features in the dictionary'. 			(self createBasicUpdatingNumberMorphOn: model				get: #maxMultipleDefinitions put: nil				min: 0 max: SmallInteger maxVal)				setBalloonText: 'Maximum number of different strokes for one character'.			(self createBasicUpdatingNumberMorphOn: model				get: #parentCount put: nil				min: 0 max: SmallInteger maxVal)				setBalloonText: 'Number of direct parent dictionaries'.			(self createBasicUpdatingNumberMorphOn: model				get: #totalParentCount put: nil				min: 0 max: SmallInteger maxVal)				setBalloonText: 'Number of all parent dictionaries'.			(self createBasicUpdatingNumberMorphOn: model				get: #totalSize put: nil				min: 0 max: SmallInteger maxVal)				setBalloonText: 'Total size (including parent dictionaries)'.			(self createBasicUpdatingNumberMorphOn: model				get: #totalMaxMultipleDefinitions put: nil				min: 0 max: SmallInteger maxVal)				setBalloonText: 'Maximum number of different strokes for one character (including parent dictionaries)'}.	1 to: labels size do: 		[:index | 		| label item row spacerLen | 		label _ labels at: index.		item _ items at: index.		spacerLen _ maxLen - label extent x + 20.		row _ AlignmentMorph newRow.		row addMorphBack: label.		row addTransparentSpacerOfSize: spacerLen @ 0.		row addMorphBack: item.		morph addMorphBack: row].	morph addTransparentSpacerOfSize: 5 @ 5.	self hasCloseButton ifTrue: [morph addMorphBack: self createCloseButton].	^ morph! !!CRDictionaryMorph methodsFor: 'submorphs-add/remove' stamp: 'NS 8/8/2000 14:28'!delete	"Delete also all the created submorphs"	createdSubmorphs do: [:each | each delete].	super delete.	model removeDependent: self.! !!CRDictionaryMorph methodsFor: 'user-interface' stamp: 'NS 8/8/2000 14:28'!selectTab: aTab 	"Ceck before changing tabs"	self canChange		ifTrue: [super selectTab: aTab.			self updateAll.			self setOldValues]! !!CRDictionaryMorph methodsFor: 'accessing' stamp: 'NS 6/30/2000 12:09'!ensureLayout	self hasLayout ifFalse: [self layout].! !!CRDictionaryMorph methodsFor: 'accessing' stamp: 'NS 7/17/2000 18:20'!hasCloseButton	^ hasCloseButton! !!CRDictionaryMorph methodsFor: 'accessing' stamp: 'NS 7/17/2000 18:19'!hasCloseButton: aBoolean	hasCloseButton _ aBoolean! !!CRDictionaryMorph methodsFor: 'accessing' stamp: 'NS 6/26/2000 15:51'!hasLayout	^ self currentPage isNil not! !!CRDictionaryMorph methodsFor: 'stepping' stamp: 'NS 2/20/2001 17:15'!arrangeToStartSteppingIn: aWorld	aWorld ifNotNil:		[aWorld startStepping: self].! !!CRDictionaryMorph methodsFor: 'stepping' stamp: 'NS 2/16/2001 17:25'!step	(self tabsMorph notNil and: [self submorphs size > 1 and: 		[self submorphs second extent x ~= self tabsMorph extent x]])			ifTrue: [self layoutChanged].! !!CRDictionaryMorph methodsFor: 'stepping' stamp: 'NS 2/16/2001 16:37'!stepTime	^ 10! !!CRDictionaryMorph class methodsFor: 'instance creation' stamp: 'NS 7/7/2000 16:13'!dictionary: aCRDictionary	^ super new initializeDictionary: aCRDictionary! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'collection accessing' stamp: 'NS 8/15/2000 10:22'!add: anObject	(anObject isNil or: [anObject name isEmptyOrNil]) ifTrue: [^ false].	anObject addDependent: self.	collection add: anObject.	^ true.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'collection accessing' stamp: 'NS 6/26/2000 18:17'!isEmpty	^ collection isEmpty! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'collection accessing' stamp: 'NS 7/31/2000 13:09'!remove: anObject	anObject removeDependent: self.	^ collection removeAllSuchThat: [:each | each == anObject].! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'collection accessing' stamp: 'NS 7/31/2000 13:10'!removeAll	collection copy do: [:each | self remove: each].! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'collection accessing' stamp: 'NS 6/26/2000 18:17'!size	^ collection size! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'testing' stamp: 'NS 8/17/2000 11:09'!isOpenInWorld: aWorld	^ self dependents notNil and: 		[(self dependents detect: 			[:each | each isMorph and: [each world == aWorld]] ifNone: []) notNil]! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 8/15/2000 10:23'!add: anObject requestor: aPluggableCollectionMorph	"Add a new object to the collection of all the instances"	(self add: anObject) ifFalse: [^ false].	self changed.	aPluggableCollectionMorph setToValue: anObject.	^ true.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 7/31/2000 10:34'!checkFilenameAndSave: anObject toFileNamed: aString overwrite: aBoolean 	| dir stream name |	[dir _ FileDirectory forFileName: aString.	(dir fileExists: aString)		ifTrue: [name _ aBoolean						ifTrue: [aString]						ifFalse: [self confirmSaveOnExistingFileName: aString].			name isEmptyOrNil				ifTrue: [^ self].			dir deleteFileNamed: name]		ifFalse: [name _ aString].	stream _ ReferenceStream newFileNamed: name]		on: Error		do: [:ex | 			ex messageText = 'Please close this to abort file opening'				ifFalse: [self inform: 'Error on file system access: ' , ex description].			^ self].	^ self save: anObject on: stream named: name.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 6/28/2000 11:59'!confirmSaveOnExistingFileName: aString 	| choice |	choice _ (PopUpMenu labels: 'overwrite that filechoose another namecancel') startUpWithCaption: aString , 'already exists.'.	choice = 1		ifTrue: [^ aString].	choice = 2		ifTrue: [^ self promptForFileNameInitialPath: aString].	^ nil! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 6/28/2000 12:10'!defaultFileName: anObject	^ anObject name , self defaultFileNameSuffix.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 7/20/2000 15:41'!defaultFileNameSuffix	^ '.', CRDisplayProperties fileNameSuffix! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 6/28/2000 12:09'!defaultPath	| default |	default _ FileDirectory default pathName.	default last = FileDirectory default pathNameDelimiter		ifFalse: [default _ default , FileDirectory default pathNameDelimiter asString].	^ default! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 8/7/2000 12:16'!gotoActionRequestor: aPluggableCollectionMorph goto: aString matchSelector: aSymbol	| value |	aString isEmptyOrNil ifFalse: 		[value _ collection detect: [:each | 			(each perform: aSymbol withArguments: #()) = aString] ifNone: [].		value ifNil: [value _ collection detect: [:each | 			(each perform: aSymbol withArguments: #()) beginsWith: aString] ifNone: []].		^ value notNil and: [(aPluggableCollectionMorph setToValue: value). true]].	^ true.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 7/30/2000 11:39'!instanceClass	^ CRDisplayProperties! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 8/15/2000 12:11'!loadAndAddFromFileNamed: aString requestor: aPluggableCollection	| object |	object _ self loadFromFileNamed: aString.	self updateInstanceCollection.	aPluggableCollection setToValue: object.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 8/17/2000 11:20'!loadFromFileNamed: aString 	"Load a new instance from a file"	| dir stream object |	[dir _ FileDirectory forFileName: aString.	(dir fileExists: aString)		ifFalse: 			[self inform: 'File ' , aString , ' does not exist'.			^ nil].	stream _ ReferenceStream oldFileNamed: aString]		on: Error do: 		[:ex | 		self inform: 'Error on file system access: ' , ex description.		^ nil].	(stream isKindOf: ReferenceStream)		ifFalse: [self inform: 'Cannot access file ' , aString. ^ nil].		"[Cursor write showWhile: ["object _ stream next."]]		on: Error do: 		[:ex | 		stream close.		self inform: 'Error on loading: ' , ex description. ^ nil]."	stream close.	^ object! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 8/7/2000 10:53'!newCollection	^ Set new.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 6/28/2000 12:00'!promptForFileNameInitialPath: aString	^ self promptForFileNameInitialPath: aString initialFile: nil.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 6/28/2000 12:09'!promptForFileNameInitialPath: pathString initialFile: fileString 	| default |	default _ pathString isEmptyOrNil				ifTrue: [self defaultPath]				ifFalse: [pathString].	fileString isEmptyOrNil		ifFalse: [default last = FileDirectory default pathNameDelimiter				ifFalse: [default _ default , FileDirectory default pathNameDelimiter asString].			default _ default , fileString].	^ FillInTheBlank request: 'Filename:' initialAnswer: default! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'private' stamp: 'NS 7/31/2000 10:48'!save: anObject on: aStream named: aString	(aStream isKindOf: ReferenceStream)		ifFalse: [^ self inform: 'Cannot access file ' , aString].	[Cursor write showWhile: [aStream nextPut: anObject]]		on: Error		do: [:ex | 			aStream close.			self inform: 'Error on saving: ' , ex description].	aStream close! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/8/2000 14:47'!addActionRequestor: aPluggableCollectionMorph	self add: self instanceClass new requestor: aPluggableCollectionMorph.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/15/2000 16:26'!changeRequestor: aPluggableCollectionMorph	^ (aPluggableCollectionMorph currentValueMorph class canUnderstand: #canChange) not or: 		[aPluggableCollectionMorph currentValueMorph canChange].! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/15/2000 16:31'!copyActionRequestor: aPluggableCollectionMorph	(self changeRequestor: aPluggableCollectionMorph) ifFalse: [^ self].	aPluggableCollectionMorph currentValue isNil ifTrue: [self inform: 'Nothing to copy'].	self add: aPluggableCollectionMorph currentValue copy requestor: aPluggableCollectionMorph.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/7/2000 11:51'!deleteActionRequestor: aPluggableCollectionMorph	| item |	item _ aPluggableCollectionMorph currentValue.	item isActive ifTrue: [^ self inform: 'Cannot delete active instance'].	(self confirm: 'Delete ' , item nameAsString , '?') ifTrue: [		self remove: item.		item name: nil.		self changed.	].! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/7/2000 12:16'!gotoActionRequestor: aPluggableCollectionMorph	| name |	aPluggableCollectionMorph currentKey ifNil: [^ self].		name _ FillInTheBlankMorph request: 'Goto: Enter name or beginning of name'		 initialAnswer: aPluggableCollectionMorph currentValue nameAsString.	(self gotoActionRequestor: aPluggableCollectionMorph 		goto: name		matchSelector: #nameAsString) ifFalse: [self inform: name, ' not found'].! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 6/27/2000 15:18'!keyMorph: anObject requestor: aPluggableCollectionMorph	^ anObject isNil ifTrue: [StringMorph contents: 'Empty'] ifFalse: [StringMorph contents: anObject printString , ' / ', self size printString]! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/15/2000 16:31'!loadActionRequestor: aPluggableCollectionMorph	| name |	(self changeRequestor: aPluggableCollectionMorph) ifFalse: [^ self].	name _ self promptForFileNameInitialPath: nil initialFile: self defaultFileNameSuffix.	name isEmptyOrNil		ifFalse: [self loadAndAddFromFileNamed: name requestor: aPluggableCollectionMorph]! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/15/2000 16:34'!menuActionRequestor: aPluggableCollectionMorph	| menu |	menu _ MenuMorph new.	aPluggableCollectionMorph currentValue isNil ifFalse:		[menu add: 'Resort' target: aPluggableCollectionMorph selector: #resendMenuAction:argument: #resortRequestor:.		menu addLine.		menu add: 'Copy' target: aPluggableCollectionMorph selector: #resendMenuAction: argument: #copyActionRequestor:.		menu add: 'Save' target: aPluggableCollectionMorph selector: #resendMenuAction: argument: #saveActionRequestor:.		menu add: 'Save as ...' target: aPluggableCollectionMorph selector: #resendMenuAction: argument: #saveAsActionRequestor:].	menu add: 'Load' target: aPluggableCollectionMorph selector: #resendMenuAction: argument: #loadActionRequestor:.	^ menu! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 6/26/2000 18:36'!okayActionRequestor: aPluggableCollectionMorph	^ true! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/15/2000 16:35'!resortRequestor: aPluggableCollectionMorph	(self changeRequestor: aPluggableCollectionMorph) ifFalse: [^ self].	aPluggableCollectionMorph updateAll.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/15/2000 16:32'!saveActionRequestor: aPluggableCollectionMorph 	| object name |	(self changeRequestor: aPluggableCollectionMorph) ifFalse: [^ self].	object _ aPluggableCollectionMorph currentValue.	name _ self defaultPath , (self defaultFileName: object).	self		checkFilenameAndSave: object		toFileNamed: name		overwrite: false! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/15/2000 16:32'!saveAsActionRequestor: aPluggableCollectionMorph 	| object name |	(self changeRequestor: aPluggableCollectionMorph) ifFalse: [^ self].	object _ aPluggableCollectionMorph currentValue.	name _ self promptForFileNameInitialPath: nil initialFile: (self defaultFileName: object).	name isEmptyOrNil		ifFalse: [self				checkFilenameAndSave: object				toFileNamed: name				overwrite: false]! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 6/28/2000 10:06'!valueMorph: anObject requestor: aPluggableCollectionMorph 	^ anObject isNil		ifTrue: [StringMorph contents: 'Empty']		ifFalse: [anObject asMorph]! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'initialize-release' stamp: 'NS 6/26/2000 18:43'!asMorph	^ self newMorph! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'initialize-release' stamp: 'NS 7/30/2000 12:03'!initialize	collection _ self newCollection.	self updateInstanceCollection.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'initialize-release' stamp: 'NS 8/8/2000 14:48'!newMorph	"Create a new morph representing my contents. There can be many morphs	representing the same contents without consistency problems"	| m |	self updateInstanceCollection.	m _ PluggableCollectionMorph		model: self		collectionOrSelector: collection		okaySelector: #okayActionRequestor:		cancelSelector: nil		addSelector: #addActionRequestor:		deleteSelector: #deleteActionRequestor:		gotoSelector: #gotoActionRequestor:		menuSelector: #menuActionRequestor:		changeSelector: #changeRequestor:		valueMorphSelector: #valueMorph:requestor:		keyMorphSelector: #keyMorph:requestor:		objectToStringSelector: nil		releaseSelector: nil.	m layout.	^ m! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'initialize-release' stamp: 'NS 8/17/2000 11:19'!newMorphWithFileNamed: aString	"Load the file named aString into the system and open a morph showing the 	files contents"	| morph |	morph _ self newMorph.	self loadAndAddFromFileNamed: aString requestor: morph.	^ morph.! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'updating' stamp: 'NS 7/31/2000 13:02'!update: aParameter	| object symbol |	(aParameter isKindOf: Array)		ifTrue: 			[object _ aParameter first.			symbol _ aParameter second]		ifFalse: [object _ aParameter].	symbol = #deleteName ifTrue: [self updateInstanceCollection].! !!CRDisplayPropertiesInstanceBrowser methodsFor: 'updating' stamp: 'NS 8/15/2000 10:22'!updateInstanceCollection	"Update the collection of all the named instances"	| oldCollection |	oldCollection _ collection copy.	self removeAll.	self instanceClass allInstancesDo: [:each | self add: each].	oldCollection ~= collection ifTrue: [self changed].! !!CRDictionaryInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 6/30/2000 11:32'!browseActionRequestor: aPluggableCollectionMorph	aPluggableCollectionMorph currentValue isNil ifTrue: [^ self inform: 'Nothing to browse'].	aPluggableCollectionMorph currentValue newBrowser asMorph openInWorld.! !!CRDictionaryInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 7/30/2000 13:45'!deleteActionRequestor: aPluggableCollectionMorph	| item |	item _ aPluggableCollectionMorph currentValue.	(self confirm: 'Delete ' , item nameAsString , '?') ifTrue: [		self remove: item.		item name: nil.		item exportedName: nil.		self changed.	].! !!CRDictionaryInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/7/2000 12:18'!gotoActionRequestor: aPluggableCollectionMorph	| name |	aPluggableCollectionMorph currentKey ifNil: [^ self].		name _ FillInTheBlankMorph request: 'Goto: Enter name, exported nameor beginning of (exported) name'		 initialAnswer: aPluggableCollectionMorph currentValue nameAsString.	(self gotoActionRequestor: aPluggableCollectionMorph goto: name		matchSelector: #nameAsString) ifFalse:		[(self gotoActionRequestor: aPluggableCollectionMorph goto: name			matchSelector: #exportedNameAsString) 			ifFalse: [self inform: name, ' not found']].! !!CRDictionaryInstanceBrowser methodsFor: 'view hooks' stamp: 'NS 8/7/2000 13:44'!menuActionRequestor: aPluggableCollectionMorph	| menu newMenu currentDict |	menu _ super menuActionRequestor: aPluggableCollectionMorph.	aPluggableCollectionMorph currentValue ifNil: [^ menu].	newMenu _ MenuMorph new.	newMenu add: 'Browse' target: aPluggableCollectionMorph selector: #resendMenuAction: argument: #browseActionRequestor:.	currentDict _ aPluggableCollectionMorph currentValue.	currentDict hasParents ifTrue:		[newMenu addMorphFront: 			(MenuItemMorph new contents: 'Browse parent'; 				arguments: #(); 				subMenu: (currentDict parentMenuSelector: #openBrowser)).		newMenu addMorphFront: 			(MenuItemMorph new contents: 'Inspect parent'; 				arguments: #(); 				subMenu: (currentDict parentMenuSelector: #openMorph))].	menu addMorphFront: MenuLineMorph new.	newMenu items do: [:each | menu addMorphFront: each].	^ menu! !!CRDictionaryInstanceBrowser methodsFor: 'private' stamp: 'NS 7/20/2000 15:40'!defaultFileNameSuffix	^ '.' , CRDictionary fileNameSuffix.! !!CRDictionaryInstanceBrowser methodsFor: 'private' stamp: 'NS 7/30/2000 11:46'!instanceClass	^ CRDictionary! !!CRDictionaryInstanceBrowser methodsFor: 'private' stamp: 'NS 8/15/2000 16:06'!loadAndAddFromFileNamed: aString requestor: aPluggableCollection	| object |	object _ self loadFromFileNamed: aString.	self updateInstanceCollection.	(object notNil and: [object name isEmptyOrNil])		ifTrue: [object _ CRDictionary name: object storedName].	aPluggableCollection setToValue: object.! !!CRDictionaryInstanceBrowser methodsFor: 'private' stamp: 'NS 7/31/2000 11:06'!save: anObject on: aStream named: aString	| includeParents |	includeParents _ anObject hasParents and: [self confirm: 'Include parent dictionaries?'].	anObject storeParents: includeParents.	super save: anObject on: aStream named: aString.! !!CRDictionaryInstanceBrowser methodsFor: 'updating' stamp: 'NS 7/30/2000 12:35'!removeDependent: anObject 	super removeDependent: anObject.	self dependents isEmptyOrNil		ifTrue: [].! !!CRDisplayPropertiesInstanceBrowser class methodsFor: 'instance creation' stamp: 'NS 6/26/2000 18:09'!new	^ super new initialize! !!CRDisplayPropertiesMorph methodsFor: 'updating' stamp: 'NS 2/17/2001 10:26'!accept	"This is triggered if a user accepts the settings. It writes the current settings to the model."	"Instances without a name are treated as deleted"	tempProperties name isEmptyOrNil ifTrue:		[self modelIsActive 			ifTrue:				[Smalltalk beep.				self inform: 'Active instance needs a name'.				^ self]			ifFalse: 				[(self confirm: 'Properties without a name are deleted.Ok to continue?') ifFalse: [^ self]]].	model set: tempProperties.	self isActive ifTrue: [model activate].	model changed.	self setOldValues.! !!CRDisplayPropertiesMorph methodsFor: 'updating' stamp: 'NS 8/17/2000 10:36'!canChange	"Return false if there are unaccepte changes"	^ self canChangeAsk: true! !!CRDisplayPropertiesMorph methodsFor: 'updating' stamp: 'NS 8/17/2000 10:36'!canChangeAsk: aBoolean	"Return false if there are unaccepte changes"	^ ((oldTempProperties hasSameContents: tempProperties) and: [isActive = oldIsActive])			or: [aBoolean and: [self confirm: 'Changes have not been saved.Is it OK to cancel those changes?']]! !!CRDisplayPropertiesMorph methodsFor: 'updating' stamp: 'NS 8/17/2000 10:36'!changed	self indicateChanged.	^ super changed.! !!CRDisplayPropertiesMorph methodsFor: 'updating' stamp: 'NS 8/17/2000 10:38'!indicateChanged	self borderColor: ((self canChangeAsk: false) ifTrue: [Color blue] ifFalse: [Color red]).! !!CRDisplayPropertiesMorph methodsFor: 'updating' stamp: 'NS 7/3/2000 22:13'!update: aParameter 	| symbol |	symbol _ ((aParameter isKindOf: Array) and: [aParameter size > 1]) ifTrue: [aParameter second].	symbol ~= #activeInstance ifTrue: [self updateAll].! !!CRDisplayPropertiesMorph methodsFor: 'updating' stamp: 'NS 6/27/2000 20:08'!updateAll	tempProperties set: model.	isActive _ self modelIsActive.	self setOldValues.! !!CRDisplayPropertiesMorph methodsFor: 'accessing' stamp: 'NS 8/8/2000 14:53'!ensureLayout	"Make sure that the morph is properly layed out. (The layout routine must have been	called at leat once)."	self hasLayout ifFalse: [self layout].! !!CRDisplayPropertiesMorph methodsFor: 'accessing' stamp: 'NS 8/8/2000 14:54'!hasLayout	"Is the morph correctly layed out?"	^ self submorphs isEmpty not! !!CRDisplayPropertiesMorph methodsFor: 'private' stamp: 'NS 6/27/2000 17:14'!modelIsActive	^ model isActive! !!CRDisplayPropertiesMorph methodsFor: 'private' stamp: 'NS 8/17/2000 11:01'!setOldValues	"Set the old values to the current values. The old values are used to determine wheter	the user has really changed values"	oldIsActive _ isActive copy.	oldTempProperties set: tempProperties.	self indicateChanged.! !!CRDisplayPropertiesMorph methodsFor: 'initialize-release' stamp: 'NS 8/8/2000 14:57'!initializeProperties: aCRDisplayProperties	"Set the model and initialize the instance"	super initialize.	createdSubmorphs _ Set new.	aCRDisplayProperties addDependent: self.	model _ aCRDisplayProperties.	tempProperties _ CRTempDisplayProperties new.	oldTempProperties _ CRTempDisplayProperties new.	self updateAll.! !!CRDisplayPropertiesMorph methodsFor: 'initialize-release' stamp: 'NS 2/16/2001 11:19'!layout	"Layout the current morph and create all the submorphs"	| labels maxLen items currentWorld |	self borderColor: Color blue.	self borderWidth: 1.	self listDirection: #topToBottom.	labels _ {'Active'. 'Name'. 'Max. size (pixels)'. 'Aspect ratio'. 'Min. move distance (pixels)'. 'Min. capture distance (pixels)'}.	labels _ labels collect: [:each | self createBasicLabelStringMorph: each].	maxLen _ labels inject: 0 into: [:max :each | max _ max max: each extent x].	items _ {self createBasicUpdatingButtonOn: self action: #switchActive				get: #isActive. 			self createBasicUpdatingStringMorphOn: self				get: #name put: #name:. 			(self createBasicUpdatingNumberMorphOn: self				get: #maxSize put: #maxSize:				min: 0 max: 10000)				setBalloonText: 'If the longer side of a stroke''s bounding box is equal to (or bigger than) this number, the size of the stroke is considered as 100%'.			(self createBasicUpdatingStringMorphOn: self				get: #aspectRatio put: #aspectRatio:)				setBalloonText: 'Aspect ratio of the display resp. input device'. 			(self createBasicUpdatingNumberMorphOn: self				get: #minMoveDistance put: #minMoveDistance:				min: 0 max: 10000)				setBalloonText: 'If the size of the stroke (in pixels) is less than this value, the stroke is considered as a point and the recognizer is going to escape after the escape time is over).' maxLineLength: 40. 			(self createBasicUpdatingNumberMorphOn: self				get: #minCaptureDistance put: #minCaptureDistance:				min: 0 max: 10000)				setBalloonText: 'A new point is only captured when the distance to the last one is at least this amount of pixels'}.	1 to: labels size do: 		[:index | 		| label item row spacerLen | 		label _ labels at: index.		item _ items at: index.		spacerLen _ maxLen - label extent x + 20.		row _ AlignmentMorph newRow.		row addMorphBack: label.		row addTransparentSpacerOfSize: spacerLen @ 0.		row addMorphBack: item.		self addMorphBack: row].	self addTransparentSpacerOfSize: 5 @ 5.	self addMorphBack: self createDefaultButtons.	currentWorld _ steppingWorld isNil ifTrue: [World] ifFalse: [steppingWorld].	createdSubmorphs do: [:each | each startSteppingIn: currentWorld].! !!CRDisplayPropertiesMorph methodsFor: 'initialize-release' stamp: 'NS 6/28/2000 10:14'!openInWorld: aWorld	self ensureLayout.	steppingWorld _ World.	^ super openInWorld: aWorld.! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 7/31/2000 13:22'!acceptAction	self accept.! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 6/27/2000 18:32'!aspectRatio	^ tempProperties aspectRatio! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 7/6/2000 09:50'!aspectRatio: aString	| point |	[point _ Point readFromString: aString] on: Error do: [].	((point isKindOf: Point) and: [point x isNumber and: [point y isNumber]]) ifTrue: 		[tempProperties aspectRatio: (point min: 1000@1000 max: 0@0)].! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 6/27/2000 20:32'!cancelAction	self updateAll.	self setOldValues.! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 6/27/2000 17:14'!isActive	^ isActive! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:59'!maxSize	^ tempProperties maxSize! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:59'!maxSize: anInteger	tempProperties maxSize: anInteger! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 11:01'!minCaptureDistance	^ tempProperties minCaptureDistance! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 11:00'!minCaptureDistance: anInteger	tempProperties minCaptureDistance: anInteger! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 11:00'!minMoveDistance	^ tempProperties minMoveDistance! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 11:00'!minMoveDistance: anInteger	tempProperties minMoveDistance: anInteger! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:58'!name	^ tempProperties name! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 8/17/2000 10:58'!name: aString	tempProperties name: aString! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'NS 6/27/2000 17:14'!switchActive	(isActive and: [self modelIsActive])		ifTrue: [self inform: 'Cannot deactivate active dictionary']		ifFalse: [isActive _ isActive not]! !!CRDisplayPropertiesMorph methodsFor: 'submorphs' stamp: 'NS 6/27/2000 17:14'!createAcceptButton	^ self createBasicButton label: 'Accept';	 actionSelector: #acceptAction;	 actWhen: #buttonDown! !!CRDisplayPropertiesMorph methodsFor: 'submorphs' stamp: 'NS 6/28/2000 10:14'!createBasicButton	^ createdSubmorphs add: (SimpleButtonMorph new target: self; borderColor: #raised).! !!CRDisplayPropertiesMorph methodsFor: 'submorphs' stamp: 'NS 6/27/2000 17:14'!createBasicLabelStringMorph: aString	^ StringMorph contents: aString.! !!CRDisplayPropertiesMorph methodsFor: 'submorphs' stamp: 'NS 6/28/2000 10:11'!createBasicUpdatingButtonOn: anObject action: actionSelector get: getSelector	| morph |	morph _ UpdatingThreePhaseButtonMorph checkBox.	morph target: anObject; actionSelector: actionSelector; getSelector: getSelector.	^ createdSubmorphs add: morph! !!CRDisplayPropertiesMorph methodsFor: 'submorphs' stamp: 'NS 6/28/2000 10:11'!createBasicUpdatingNumberMorphOn: anObject get: getSelector put: putSelector min: minNumber max: maxNumber	| morph |	morph _ UpdatingNumericStringMorph on: anObject selector: getSelector.	morph putSelector: putSelector;	 min: minNumber;	 max: maxNumber.	^ createdSubmorphs add: morph! !!CRDisplayPropertiesMorph methodsFor: 'submorphs' stamp: 'NS 6/28/2000 10:11'!createBasicUpdatingStringMorphOn: anObject get: getSelector put: putSelector	| morph |	morph _ UpdatingStringMorph on: anObject selector: getSelector.	morph putSelector: putSelector;	 useStringFormat.	^ createdSubmorphs add: morph! !!CRDisplayPropertiesMorph methodsFor: 'submorphs' stamp: 'NS 6/27/2000 17:14'!createCancelButton	^ self createBasicButton label: 'Cancel';	 actionSelector: #cancelAction;	 actWhen: #buttonDown! !!CRDisplayPropertiesMorph methodsFor: 'submorphs' stamp: 'NS 2/16/2001 11:57'!createDefaultButtons	| morph |	morph _ AlignmentMorph newRow.	morph listCentering: #bottomRight.	morph addMorphBack: self createAcceptButton.	morph addTransparentSpacerOfSize: 5@5.	morph addMorphBack: self createCancelButton.	^ morph.! !!CRDisplayPropertiesMorph methodsFor: 'submorphs-add/remove' stamp: 'NS 6/27/2000 18:14'!delete	super delete.	model removeDependent: self.! !!CRDisplayPropertiesMorph class methodsFor: 'instance creation' stamp: 'NS 6/27/2000 17:18'!properties: aCRDisplayProperties	^ self new initializeProperties: aCRDisplayProperties! !!FileList methodsFor: 'file list menu' stamp: 'NS 7/20/2000 15:40'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix ='form') | (suffix = '*') | (suffix = 'png') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports' 'open image as background').		selectors addAll: #(openImageInWindow importImage openAsBackground)].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = 'sp') |(suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile.		labels add: 'load as project'.		selectors add: #openProjectFromFile].	(suffix = 'extseg') | (suffix = 'project') | (suffix = 'pr') ifTrue:		[labels add: 'load as project'.		selectors add: #openProjectFromFile].	(suffix = 'bo') | (suffix = '*') ifTrue:[		labels add: 'load as book'.		selectors add: #openBookFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set''browse changes' 'browse code' 'remove line feeds' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSetbrowseChanges browseFile removeLinefeeds putUpdate)].	(suffix = 'swf') | (suffix = '*') ifTrue:[		labels add:'open as Flash'.		selectors add: #openAsFlash].	(suffix = 'ttf') | (suffix = '*') ifTrue:[		labels add: 'open true type font'.		selectors add: #openAsTTF].	(suffix = 'gz') | (suffix = '*') ifTrue:[		labels addAll: #('view decompressed' 'decompress to file').		selectors addAll: #(viewGZipContents saveGZipContents)].	(suffix = '3ds') | (suffix = '*') ifTrue:[		labels add: 'Open 3DS file'.		selectors add: #open3DSFile].	(suffix = 'tape') | (suffix = '*') ifTrue:		[labels add: 'open for playback'.		selectors add: #openTapeFromFile].	(suffix = 'wrl') | (suffix = '*') ifTrue:		[labels add: 'open in Wonderland'.		selectors add: #openVRMLFile].	(suffix = 'htm') | (suffix = 'html') ifTrue:		[labels add: 'open in browser'.		selectors add: #openInBrowser].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	(suffix = CRDictionary fileNameSuffix) ifTrue:		[labels add: 'load Genie Gesture Dictionary'.		selectors add: #loadCRDictionary].	(suffix = CRDisplayProperties fileNameSuffix) ifTrue:		[labels add: 'load Genie Display Properties'.		selectors add: #loadCRDisplayProperties].	^ Array with: labels with: lines with: selectors! !!FileList methodsFor: 'file list menu' stamp: 'NS 8/17/2000 11:32'!loadCRDictionary	| morph |	Smalltalk isMorphic ifFalse: 		[self beep.		^ self inform: 'Only available within morphic'].	morph _ CRDictionary instanceBrowser newMorphWithFileNamed: self fullName.	(CRDictionary instanceBrowser isOpenInWorld: World) 		ifTrue: [morph delete]		ifFalse: [morph openInWorld].! !!FileList methodsFor: 'file list menu' stamp: 'NS 8/17/2000 11:35'!loadCRDisplayProperties	| morph |	Smalltalk isMorphic ifFalse: 		[self beep.		^ self inform: 'Only available within morphic'].	morph _ CRDisplayProperties instanceBrowser newMorphWithFileNamed: self fullName.	(CRDisplayProperties instanceBrowser isOpenInWorld: World) 		ifTrue: [morph delete]		ifFalse: [morph openInWorld].! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'NS 2/9/2001 17:09'!setQuery: queryString initialAnswer: initialAnswer answerExtent: answerExtent acceptOnCR: acceptBoolean	| query frame topOffset accept cancel buttonAreaHeight |	response _ initialAnswer.	done _ false.	self removeAllMorphs.	self layoutPolicy: ProportionalLayout new.	query _ TextMorph new contents: queryString.	query extent: answerExtent. 	query setNameTo: 'query'.	query lock.		frame _ LayoutFrame new.		frame topFraction: 0.0; topOffset: 2.		frame leftFraction: 0.5; leftOffset: (query width // 2) negated.	query layoutFrame: frame.	self addMorph: query.	topOffset _ query height + 4.	accept _ SimpleButtonMorph new target: self; color: Color veryLightGray.	accept label: 'Accept(s)'; actionSelector: #accept.	accept setNameTo: 'accept'.		frame _ LayoutFrame new.		frame rightFraction: 0.5; rightOffset: -10; bottomFraction: 1.0; bottomOffset: -2.	accept layoutFrame: frame.	self addMorph: accept.	cancel _ SimpleButtonMorph new target: self; color: Color veryLightGray.	cancel label: 'Cancel(l)'; actionSelector: #cancel.	cancel setNameTo: 'cancel'.		frame _ LayoutFrame new.		frame leftFraction: 0.5; leftOffset: 10; bottomFraction: 1.0; bottomOffset: -2.	cancel layoutFrame: frame.	self addMorph: cancel.	buttonAreaHeight _ (accept height max: cancel height) + 4.	textPane _ PluggableTextMorph on: self		text: #response		accept: #response:		readSelection: #selectionInterval		menu: #codePaneMenu:shifted:.	textPane hResizing: #spaceFill; vResizing: #spaceFill.	textPane borderWidth: 2.	textPane hasUnacceptedEdits: true.	textPane acceptOnCR: acceptBoolean.	textPane setNameTo: 'textPane'.		frame _ LayoutFrame new.		frame leftFraction: 0.0; rightFraction: 1.0; topFraction: 0.0; topOffset: topOffset; bottomFraction: 1.0; bottomOffset: buttonAreaHeight negated.	textPane layoutFrame: frame.	self addMorph: textPane.	self extent: (200 max: query width) + 4 @ (topOffset + answerExtent y + 4 + buttonAreaHeight).! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'NS 8/1/2000 11:44'!setQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight acceptOnCR: acceptBoolean	self setQuery: queryString initialAnswer: initialAnswer 		answerExtent: (self class defaultAnswerExtent x @ answerHeight) 		acceptOnCR: acceptBoolean! !!FillInTheBlankMorph class methodsFor: 'default constants' stamp: 'NS 8/1/2000 11:42'!defaultAnswerExtent	^ 200@50.! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'NS 8/1/2000 11:44'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."	^ self request: queryString initialAnswer: defaultAnswer centerAt: aPoint 		inWorld: aWorld onCancelReturn: returnOnCancel 		acceptOnCR: acceptBoolean answerExtent: self defaultAnswerExtent! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'NS 8/1/2000 11:39'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean answerExtent: answerExtent	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| aFillInTheBlankMorph |	aFillInTheBlankMorph _ self new		setQuery: queryString		initialAnswer: defaultAnswer		answerExtent: answerExtent		acceptOnCR: acceptBoolean.	aFillInTheBlankMorph responseUponCancel: returnOnCancel.	aWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.	^ aFillInTheBlankMorph getUserResponse! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'NS 8/1/2000 11:43'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean answerHeight: answerHeight	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."	^ self request: queryString initialAnswer: defaultAnswer centerAt: aPoint 		inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean 		answerExtent: self defaultAnswerExtent x @ answerHeight! !!FillInTheBlankMorphWithCharMenu methodsFor: 'code pane menu' stamp: 'NS 8/11/2000 11:37'!codePaneMenu: aMenu shifted: shifted	| menu subMenu |	menu _ super codePaneMenu: aMenu shifted: shifted.	menu addMorphFront: MenuLineMorph new.	subMenu _ MenuItemMorph new contents: 'Genie'; arguments: #(); subMenu: self createGenieMenu.	menu addMorphFront: subMenu.	subMenu _ MenuItemMorph new contents: 'Text editing'; arguments: #(); subMenu: self createTextMenu.	menu addMorphFront: subMenu.	subMenu _ MenuItemMorph new contents: 'Mouse & Halos'; arguments: #(); subMenu: self createMouseMenu.	menu addMorphFront: subMenu.	subMenu _ MenuItemMorph new contents: 'Command keys'; arguments: #(); subMenu: self createCommandKeysMenu.	menu addMorphFront: subMenu.	subMenu _ MenuItemMorph new contents: 'Modifier keys'; arguments: #(); subMenu: self createModifierKeysMenu.	menu addMorphFront: subMenu.	subMenu _ MenuItemMorph new contents: 'Special chars'; arguments: #(); subMenu: self createSpecialCharsMenu.	menu addMorphFront: subMenu.	subMenu _ MenuItemMorph new contents: 'Digits'; arguments: #(); subMenu: self createDigitsMenu.	menu addMorphFront: subMenu.	subMenu _ MenuItemMorph new contents: 'Capital letters'; arguments: #(); subMenu: self createCapitalLettersMenu.	menu addMorphFront: subMenu.	subMenu _ MenuItemMorph new contents: 'Small letters'; arguments: #(); subMenu: self createSmallLettersMenu.	menu addMorphFront: subMenu.	^ menu	! !!FillInTheBlankMorphWithCharMenu methodsFor: 'code pane menu' stamp: 'NS 6/30/2000 15:54'!createBasicMenu	^ MenuMorph new defaultTarget: self.	! !!FillInTheBlankMorphWithCharMenu methodsFor: 'code pane menu' stamp: 'NS 7/7/2000 10:16'!createCapitalLettersMenu	| menu |	menu _ self createBasicMenu.	($A to: $Z) do: [:each | menu add: each asString selector: #simulateString: argument: each asString].	^ menu! !!FillInTheBlankMorphWithCharMenu methodsFor: 'code pane menu' stamp: 'NS 7/11/2000 09:22'!createCommandKeysMenu	| menu ops |	menu _ self createBasicMenu.	ops _ {	'#return'. '#tab'. '#insert'. '#delete'. '#backspace'. '#escape'.			'#home'. '#end'. '#pageUp'. '#pageDown'.			'#arrowUp'. '#arrowDown'. '#arrowLeft'. '#arrowRight'.}.	ops do: [:each | menu add: each selector: #simulateString: argument: each].	^ menu! !!FillInTheBlankMorphWithCharMenu methodsFor: 'code pane menu' stamp: 'NS 7/7/2000 10:16'!createDigitsMenu	| menu |	menu _ self createBasicMenu.	0 to: 9 do: [:each | menu add: each asString selector: #simulateString: argument: each printString].	^ menu! !!FillInTheBlankMorphWithCharMenu methodsFor: 'code pane menu' stamp: 'NS 2/18/2001 16:19'!createGenieMenu	| menu ops help |	menu _ self createBasicMenu.	ops _ {	'#disableGenie'. '#inspectLastGesture'.			'#switchFocus'. '#inspectActiveDictionary'. '#browseActiveDictionary'. 			'#inspectDictionaries'. '#inspectDisplayProperties'	.	}.	help _ {	'Disable genie for the current HandMorph'.			'Inspect the last entered gesture'.			'Start / stop recognize all gesture exclusively for the target Morph. This can be very useful if the Morph is small'.			'Inspect the dictionary that is associated to the target morph'.			'Browse the gestures imn the dictionary associated to the target morph'.			'Inspect all the named gesture dictionaries in the system'.			'Inspect all the display properties in the system'. }.	ops withIndexDo: [:each :index | 		menu add: each selector: #simulateString: argument: each.		menu balloonTextForLastItem: (help at: index)].	^ menu! !!FillInTheBlankMorphWithCharMenu methodsFor: 'code pane menu' stamp: 'NS 7/28/2000 16:59'!createModifierKeysMenu	| menu ops |	menu _ self createBasicMenu.	ops _ {	'#shift'. '#commandKey'. '#controlKey'. '#macOptionKey'. '#capsLock' }.	ops do: [:each | menu add: each selector: #simulateString: argument: each].	^ menu! !!FillInTheBlankMorphWithCharMenu methodsFor: 'code pane menu' stamp: 'NS 8/10/2000 17:01'!createMouseMenu	| menu ops help |	menu _ self createBasicMenu.	ops _ {	'#redClick'. '#yellowClick'. '#blueClick'.			'#redMouseAction'. '#yellowMouseAction'. '#blueMouseAction'.			'#nextHalo'. '#previousHalo'. '#abandonHalos'	}.	help _ {	'Simulate a red mouse click at the hotspot of the gesture'.			'Simulate a yellow mouse click at the hotspot of the gesture'.			'Simulate a blue click at the hotspot of the gesture'.			'Escape the recognizer for the next mouse action (drag) and treat the action as if it would be done using the red mouse button'.			'Escape the recognizer for the next mouse action (drag) and treat the action as if it would be done using the yellow mouse button (Can be used to show the context menu)'.			'Escape the recognizer for the next mouse action (drag) and treat the action as if it would be done using the blue mouse button (Can be used to invoke the halos)'.			'Bring up the halos for the next morph'.			'Bring up the halos for the previous morph'.			'Abandon all the halos'}.	ops withIndexDo: [:each :index | 		menu add: each selector: #simulateString: argument: each.		menu balloonTextForLastItem: (help at: index)].	^ menu! !!FillInTheBlankMorphWithCharMenu methodsFor: 'code pane menu' stamp: 'NS 7/7/2000 10:17'!createSmallLettersMenu	| menu |	menu _ self createBasicMenu.	($a to: $z) do: [:each | menu add: each asString selector: #simulateString: argument: each asString].	^ menu! !!FillInTheBlankMorphWithCharMenu methodsFor: 'code pane menu' stamp: 'NS 7/18/2000 17:28'!createSpecialCharsMenu	| menu chars |	menu _ self createBasicMenu.	chars _ { $~. $`. $!!. $@. $#. $$. $%. $^. $&. $*. $(. $). $_. $-. $+. $+. $=. ${. $}. $[. $]. $|. $\. $:. $;. $". $'. $<. $>. $,. $.. $?. $/}.	menu add: 'Space' selector: #simulateString: argument: ' '.	chars do: [:each | menu add: each asString selector: #simulateString: argument: each asString].	^ menu! !!FillInTheBlankMorphWithCharMenu methodsFor: 'code pane menu' stamp: 'NS 8/11/2000 11:27'!createTextMenu	| menu ops help |	menu _ self createBasicMenu.	ops _ {	'#switchCase'. '#nextMatch'. '#alignment'	}.	help _ {	'Switch the case of the last recognized character'.			'Replace the last recognized character by the next best match'.			'Set the alignment (left flush, centered, right flush) dependending on where (horizontal position) in the text pane the gesture occurs'}.	ops withIndexDo: [:each :index | 		menu add: each selector: #simulateString: argument: each.		menu balloonTextForLastItem: (help at: index)].	^ menu! !!FillInTheBlankMorphWithCharMenu methodsFor: 'private' stamp: 'NS 7/10/2000 19:27'!simulateString: aString	self response: aString.	self changed: #response.! !!FillInTheBlankMorphWithCharMenu methodsFor: 'initialization' stamp: 'NS 8/11/2000 11:04'!initialize	super initialize.	self setBalloonText: 'There are 3 different character types:- Strings: Any character sequence (Enclose in '' to enter strings starting with ''#'')- Commands: Symbols (e.g. #redClick)- Code: Use the format ''#Header#Code'' to enter any squeak code. Example: #beep#Smalltalk beep.(See context menu for predefined characters)' maxLineLength: 50.! !!FillInTheBlankMorphWithCharMenu class methodsFor: 'default constants' stamp: 'NS 8/1/2000 12:04'!defaultAnswerExtent	^ 300@100! !!FillInTheBlankMorphWithCharMenu class methodsFor: 'instance creation' stamp: 'NS 8/1/2000 11:54'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel	^ self request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: false! !!PluggableCollectionMorph methodsFor: 'initialize-release' stamp: 'NS 6/27/2000 16:43'!addButtonsTo: aMorph space: aPoint 	| nextSpace |	aMorph addMorphBack: self prevButton.	aMorph addTransparentSpacerOfSize: aPoint.	aMorph addMorphBack: self gotoButton.	aMorph addTransparentSpacerOfSize: aPoint.	aMorph addMorphBack: self nextButton.	nextSpace _ 3 * aPoint.	self isMenuAvailable		ifTrue: 			[aMorph addTransparentSpacerOfSize: nextSpace.			nextSpace _ aPoint.			aMorph addMorphBack: self menuButton].	self isAddAvailable		ifTrue: 			[aMorph addTransparentSpacerOfSize: nextSpace.			nextSpace _ aPoint.			aMorph addMorphBack: self addButton].	self isDeleteAvailable		ifTrue: 			[aMorph addTransparentSpacerOfSize: nextSpace.			aMorph addMorphBack: self deleteButton].	self isOkayAvailable		ifTrue: 			[aMorph addTransparentSpacerOfSize: nextSpace.			nextSpace _ aPoint.			aMorph addMorphBack: self okayButton].	self isCancelAvailable		ifTrue: 			[aMorph addTransparentSpacerOfSize: nextSpace.			aMorph addMorphBack: self cancelButton].	^ aMorph! !!PluggableCollectionMorph methodsFor: 'initialize-release' stamp: 'NS 2/16/2001 11:19'!initialize	super initialize.	self listDirection: #topToBottom.	self keyMorph: AlignmentMorph new.	self valueMorph: AlignmentMorph new.! !!PluggableCollectionMorph methodsFor: 'initialize-release' stamp: 'NS 2/16/2001 11:53'!layout	"Define the morphs layout and add the submorphs"	| buttonOrientation topRight buttons |	self borderColor: Color blue.	self borderWidth: 1.	self hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	buttonOrientation _ self listDirection = #topToBottom				ifTrue: [#leftToRight]				ifFalse: [#topToBottom].	topRight _ AlignmentMorph new.	topRight listDirection: buttonOrientation.	buttonOrientation = #topToBottom ifTrue: [topRight listCentering: #bottomRight].	buttons _ AlignmentMorph new.	buttons listDirection: buttonOrientation;		listCentering: #bottomRight.	self addButtonsTo: buttons space: 5 @ 5.	topRight addMorphBack: self keyMorph.	topRight addTransparentSpacerOfSize: 20 @ 20.	topRight addMorphBack: buttons.	self addMorphBack: topRight.	buttonOrientation = #vertical		ifTrue: [self addMorph: self valueMorph]		ifFalse: [self addMorphBack: self valueMorph].	self updateAll.! !!PluggableCollectionMorph methodsFor: 'initialize-release' stamp: 'NS 6/22/2000 14:43'!openInWorld: aWorld	self ensureLayout.	super openInWorld: aWorld.! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 5/15/2000 16:44'!addSelector	^ addSelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 5/15/2000 16:44'!addSelector: aSymbol	addSelector _ aSymbol! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 5/15/2000 08:55'!cancelSelector	^ cancelSelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 5/15/2000 08:55'!cancelSelector: aSymbol	cancelSelector _ aSymbol! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/3/2000 18:09'!changeSelector	^ changeSelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/3/2000 18:09'!changeSelector: aSymbol	changeSelector _ aSymbol! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/2/2000 17:05'!collectionOrSelector	^ collectionOrSelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/26/2000 13:46'!collectionOrSelector: aSymbolOrCollection	self collectionOrSelector: aSymbolOrCollection key: nil.! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 8/9/2000 18:07'!collectionOrSelector: aSymbolOrCollection key: anObject	"Set the collection and jump to the spcified key if available"	collectionOrSelector _ aSymbolOrCollection.	self updateCollection.	anObject ifNotNil: [self setKeyNoUpdate: anObject].	self updateContents.! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 8/9/2000 18:07'!currentKey	"The currently shown key"	^ self keyAtIndex: (self currentIndex)! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 8/9/2000 18:08'!currentKeyMorph	"The morph for the currently shown key"	^ self keyMorph submorphs first! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 8/9/2000 18:08'!currentValue	"The currently shown value"	^ self valueAtIndex: self currentIndex! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 8/9/2000 18:08'!currentValueMorph	"The morph for the currently shown value"	^ self valueMorph submorphs first! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 5/15/2000 08:57'!deleteSelector	^ deleteSelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 5/15/2000 08:58'!deleteSelector: aSymbol	deleteSelector _ aSymbol! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 8/9/2000 18:09'!ensureLayout	"Ensure that the layout method was called at leat once"	self hasLayout ifFalse: [self layout].! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 7/28/2000 09:38'!gotoSelector	^ gotoSelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 7/28/2000 09:38'!gotoSelector: aSymbol	gotoSelector _ aSymbol! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/22/2000 14:42'!hasLayout	^ self submorphs isEmpty not.! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 5/15/2000 15:55'!keyMorphSelector	^ keyMorphSelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/24/2000 10:18'!keyMorphSelector: aSymbol	keyMorphSelector _ aSymbol.! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/27/2000 16:00'!menuSelector	^ menuSelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/27/2000 16:00'!menuSelector: aSymbol	menuSelector _ aSymbol! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 5/15/2000 08:53'!model	^ model! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/26/2000 17:56'!model: anObject	model ifNotNil: [model removeDependent: self].	model _ anObject.	model ifNotNil: [model addDependent: self].! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/16/2000 14:38'!objectToStringSelector	^ objectToStringSelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/16/2000 14:38'!objectToStringSelector: aSymbol	objectToStringSelector _ aSymbol! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 5/15/2000 08:54'!okaySelector	^ okaySelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 5/15/2000 08:55'!okaySelector: aSymbol	okaySelector _ aSymbol! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/28/2000 08:44'!releaseSelector	^ releaseSelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/28/2000 08:44'!releaseSelector: aSymbol	releaseSelector _ aSymbol! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 8/9/2000 18:09'!setKey: anObject	"Switch to the given key"	^ self setKey: anObject toString: false.! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 8/9/2000 18:10'!setKey: anObject toString: aBoolean 	"Switch to the given key. If aBoolean is true, all th keys are converted to	strings before they are compared to anObject"	^ (self setKeyNoUpdate: anObject toString: aBoolean)		and: 			[self updateContents.			true]! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 8/9/2000 18:10'!setToValue: anObject	"Switch to the given value"	| key |	key _ (self collection isKindOf: Dictionary) 			ifTrue: [collection keyAtValue: anObject ifAbsent: []]			ifFalse: [collection indexOf: anObject ifAbsent: []].	^ key notNil ifTrue: [self setKey: key] ifFalse: [false].! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 5/15/2000 15:12'!valueMorphSelector	^ valueMorphSelector! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'NS 6/24/2000 10:19'!valueMorphSelector: aSymbol	valueMorphSelector _ aSymbol.! !!PluggableCollectionMorph methodsFor: 'updating' stamp: 'NS 6/26/2000 14:59'!update: aParameter	self updateAll.! !!PluggableCollectionMorph methodsFor: 'updating' stamp: 'NS 6/26/2000 13:49'!updateAll	self updateCollection.	self updateContents! !!PluggableCollectionMorph methodsFor: 'updating' stamp: 'NS 6/26/2000 13:49'!updateCollection	self setCollection: self getCollection.! !!PluggableCollectionMorph methodsFor: 'updating' stamp: 'NS 7/3/2000 22:32'!updateContents	self		wrap: self currentKey		into: self keyMorph		modelSelector: self keyMorphSelector.	"self keyMorph layoutChanged."	self		wrap: self currentValue		into: self valueMorph		modelSelector: self valueMorphSelector.	"self valueMorph layoutChanged."! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 17:51'!arrayOfDictionaryKeys: aDictionary	| array index |	array _ Array new: aDictionary size.	index _ 1.	aDictionary keysDo: [:each | array at: index put: each. index _ index + 1].	^ array.! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/2/2000 12:00'!close	self delete! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 8/9/2000 18:11'!collection	"Internal representation of the inspected collection"	^ collection! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/2/2000 10:57'!collection: aCollection 	collection _ aCollection! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 8/9/2000 18:12'!collectionKeys	"Internal representation of the inspected collection's keys.	If the inspected collection is not a Dictionary, the keys are just numbers"	^ collectionKeys! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 10:34'!collectionKeys: aSortedCollection	collectionKeys _ aSortedCollection! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 08:53'!currentIndex	^ currentIndex! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/24/2000 09:55'!currentIndex: anInteger	currentIndex _ anInteger! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/2/2000 11:01'!decrementIndex	self currentIndex: self currentIndex - 1.	self normalizeCurrentIndexRotate: true.! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/2/2000 11:01'!incrementIndex	self currentIndex: self currentIndex + 1.	self normalizeCurrentIndexRotate: true.! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 8/9/2000 18:12'!indexOfKey: anObject toString: aBoolean 	| index key |	self collection isEmpty ifTrue: [^ nil].	index _ self normalizeIndex: self currentIndex + 1 rotate: true.		[key _ self collectionKeys at: index.	aBoolean ifTrue: [key _ self objectToString: key].	anObject = key or: [index = self currentIndex]]		whileFalse: [index _ self normalizeIndex: index + 1 rotate: true].	^ anObject = key		ifTrue: [index]		ifFalse: [nil]! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 16:44'!isAddAvailable	^ self isModelAvailable and: [self addSelector notNil].! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 16:29'!isCancelAvailable	^ self isModelAvailable and: [self cancelSelector notNil].! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/3/2000 18:20'!isChangeAvailable	^ self isModelAvailable and: [self changeSelector notNil].! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/3/2000 15:49'!isCurrentIndexValid	^ self isIndexValid: self currentIndex! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 16:35'!isDeleteAvailable	^ self isModelAvailable and: [self deleteSelector notNil].! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 7/28/2000 09:38'!isGotoAvailable	^ self isModelAvailable and: [self gotoSelector notNil].! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/22/2000 15:54'!isIndexValid: anIntegerOrNil	^ anIntegerOrNil notNil and: [(1 to: self collection size) includes: anIntegerOrNil].! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/27/2000 16:10'!isMenuAvailable	^ self isModelAvailable and: [self menuSelector notNil].! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 09:03'!isModelAvailable	^ model notNil! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/16/2000 14:41'!isObjectToStringAvailable	^ self isModelAvailable and: [self objectToStringSelector notNil].! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 16:30'!isOkayAvailable	^ self isModelAvailable and: [self okaySelector notNil].! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/28/2000 08:44'!isReleaseAvailable	^ self isModelAvailable and: [self releaseSelector notNil].! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/24/2000 10:34'!keyAtIndex: anInteger	^ (self collection isEmptyOrNil or: [(self isIndexValid: anInteger) not])		ifTrue: [nil]		ifFalse: [self collectionKeys at: anInteger]! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 11:41'!keyMorph	^ keyMorph! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 11:41'!keyMorph: aMorph	keyMorph _ aMorph.! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/2/2000 11:01'!normalizeCurrentIndexRotate: aBoolean	self currentIndex: (self normalizeIndex: self currentIndex in: (1 to: self collection size) rotate: aBoolean).	^ self currentIndex! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/17/2000 09:46'!normalizeIndex: anInteger in: anInterval rotate: aBoolean 	anInterval isEmpty ifTrue: [^ 0].	((anInteger > anInterval last and: [aBoolean])		or: [anInteger < anInterval first and: [aBoolean not]])		ifTrue: [^ anInterval first].	((anInteger < anInterval first and: [aBoolean])		or: [anInteger > anInterval last and: [aBoolean not]])		ifTrue: [^ anInterval last].	^ anInteger! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/17/2000 09:27'!normalizeIndex: anInteger rotate: aBoolean	^ self normalizeIndex: anInteger in: (1 to: self collection size) rotate: aBoolean.! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/26/2000 18:41'!objectToMorph: anObject 	anObject isMorph ifTrue: [^ anObject].	(anObject class canUnderstand: #asMorph) ifTrue: [^ anObject asMorph].	^ StringMorph contents: (self objectToString: anObject).! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/2/2000 12:23'!setCollection: aCollection	self setCollection: aCollection key: self currentKey.! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 8/9/2000 18:14'!setCollection: aCollection key: keyObject 	"Set aCllection as the inspected collection and goto the key keyObject if available"	| sortBlock oldKey oldValue |	oldKey _ self currentKey.	oldValue _ self currentValue.	sortBlock _ [:a :b | (((a isKindOf: b class)				or: [b isKindOf: a class])				and: [a class canUnderstand: #<])				ifTrue: [a < b]				ifFalse: [true]].	(aCollection isKindOf: Dictionary)		ifTrue: 			[self collection: aCollection.			self collectionKeys: ((self arrayOfDictionaryKeys: aCollection)					asSortedCollection: sortBlock)]		ifFalse: 			[self collection: ((aCollection isKindOf: SequenceableCollection)					ifTrue: [aCollection]					ifFalse: [aCollection asSortedCollection: sortBlock]).			self collectionKeys: (1 to: aCollection size)].	self currentIndex: ((oldKey isNil			or: [oldValue isNil					or: [(self valueAtKey: oldKey)							~= oldValue]])			ifTrue: [1]			ifFalse: [self indexOfKey: oldKey toString: false]).	self normalizeCurrentIndexRotate: false.	keyObject isNil ifTrue: [self setKeyNoUpdate: keyObject]! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/24/2000 09:43'!setKeyNoUpdate: anObject	^ self setKeyNoUpdate: anObject toString: false.! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/24/2000 09:41'!setKeyNoUpdate: anObject toString: aBoolean 	| index |	index _ self indexOfKey: anObject toString: aBoolean.	^ (self isIndexValid: index)		and: 			[self currentIndex: index.			true]! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 7/28/2000 09:32'!setModel: anObject collectionOrSelector: aCollectionOrSymbol okaySelector: okaySymbol cancelSelector: cancelSymbol addSelector: addSymbol deleteSelector: deleteSymbol gotoSelector: gotoSymbol menuSelector: menuSymbol changeSelector: changeSymbol valueMorphSelector: valueMorphSymbol keyMorphSelector: keyMorphSymbol objectToStringSelector: objectToStringSymbol releaseSelector: releaseSymbol	self model: anObject.	collectionOrSelector _ aCollectionOrSymbol.	okaySelector _ okaySymbol.	cancelSelector _ cancelSymbol.	addSelector _ addSymbol.	deleteSelector _ deleteSymbol.	gotoSelector _ gotoSymbol.	menuSelector _ menuSymbol.	changeSelector _ changeSymbol.	valueMorphSelector _ valueMorphSymbol.	keyMorphSelector _ keyMorphSymbol.	objectToStringSelector _ objectToStringSymbol.	releaseSelector _ releaseSymbol.! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/24/2000 10:57'!valueAtIndex: anInteger	(self keyAtIndex: anInteger) ifNil: [^ nil].	^ self valueAtKey: (self keyAtIndex: anInteger).! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 6/24/2000 10:43'!valueAtKey: anObject	self collection isNil ifTrue: [^ nil].	^ self collection at: anObject ifAbsent: [].! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 15:13'!valueMorph	^ valueMorph! !!PluggableCollectionMorph methodsFor: 'private' stamp: 'NS 5/15/2000 15:14'!valueMorph: aMorph	valueMorph _ aMorph! !!PluggableCollectionMorph methodsFor: 'buttons' stamp: 'NS 5/20/2000 19:07'!addButton	^ self basicButton label: 'Add';	 actionSelector: #addAction;	 actWhen: #buttonDown.! !!PluggableCollectionMorph methodsFor: 'buttons' stamp: 'NS 6/28/2000 10:18'!basicButton	^ SimpleButtonMorph new target: self; borderColor: #raised.! !!PluggableCollectionMorph methodsFor: 'buttons' stamp: 'NS 5/15/2000 09:18'!cancelButton	^ self basicButton label: 'Cancel';	 actionSelector: #cancelAction;	 actWhen: #buttonDown! !!PluggableCollectionMorph methodsFor: 'buttons' stamp: 'NS 5/15/2000 15:05'!deleteButton	^ self basicButton label: 'Del';	 actionSelector: #deleteAction;	 actWhen: #buttonDown! !!PluggableCollectionMorph methodsFor: 'buttons' stamp: 'NS 5/15/2000 09:17'!gotoButton	^ self basicButton label: 'Goto';	 actionSelector: #gotoAction;	 actWhen: #buttonDown! !!PluggableCollectionMorph methodsFor: 'buttons' stamp: 'NS 6/27/2000 16:06'!menuButton	^ self basicButton label: 'M';	 actionSelector: #menuAction;	 actWhen: #buttonDown.! !!PluggableCollectionMorph methodsFor: 'buttons' stamp: 'NS 6/30/2000 10:54'!nextButton	^ self basicButton label: ' >';	 actionSelector: #nextAction;	 actWhen: #buttonDown! !!PluggableCollectionMorph methodsFor: 'buttons' stamp: 'NS 5/20/2000 15:22'!okayButton	^ self basicButton label: 'OK';	 actionSelector: #okayAction;	 actWhen: #buttonDown! !!PluggableCollectionMorph methodsFor: 'buttons' stamp: 'NS 6/30/2000 10:54'!prevButton	^ self basicButton label: '< ';	 actionSelector: #prevAction;	 actWhen: #buttonDown! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 7/3/2000 17:42'!addAction	(self isAddAvailable and: [self changeRequest]) ifFalse: [^ self].	self model perform: self addSelector withArguments: (Array with: self).! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 7/3/2000 17:42'!cancelAction	| close |	(self isCancelAvailable and: [self changeRequest]) ifFalse: [^ self].	close _ self model perform: self cancelSelector withArguments: (Array with: self).	close ifTrue: [self close]! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 6/3/2000 18:20'!changeRequest	^ self isChangeAvailable not or: [self model perform: self changeSelector withArguments: (Array with: self)]! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 6/15/2000 16:45'!deleteAction	(self isDeleteAvailable and: [self changeRequest]) ifFalse: [^ self].	self model perform: self deleteSelector withArguments: (Array with: self).! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 6/3/2000 15:29'!getCollection	^ (self collectionOrSelector isKindOf: Symbol)		ifTrue: [self model perform: self collectionOrSelector]		ifFalse: [self collectionOrSelector]! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 8/15/2000 16:30'!gotoAction	| request key |	self isGotoAvailable ifTrue: [		^ self changeRequest 			ifTrue: [self model perform: gotoSelector withArguments: (Array with: self)]			ifFalse: [self]].	(self collection isEmpty or: [self changeRequest not]) ifTrue: [^ self].	request _ 'Goto (' , (self objectToString: self collectionKeys first) , ' - ' , (self objectToString: self collectionKeys last) , ')'.	key _ FillInTheBlank request: request initialAnswer: (self objectToString: self currentKey).	key isEmptyOrNil		ifFalse: 			[(self setKey: key toString: true) ifFalse: [self inform: key, ' not found']]! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 2/16/2001 11:28'!menuAction	| menu |	self isMenuAvailable ifFalse: [^ self].	menu _ self model perform: self menuSelector withArguments: (Array with: self).	menu isNil ifFalse: [menu popUpInWorld: World].	! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 6/3/2000 18:26'!nextAction	self changeRequest ifFalse: [^ self].	self incrementIndex.	self updateContents! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 6/16/2000 15:04'!objectToString: anObject 	^ self isObjectToStringAvailable		ifTrue: [self model perform: self objectToStringSelector withArguments: (Array with: anObject)]		ifFalse: [(anObject isKindOf: String)				ifTrue: [anObject]				ifFalse: [anObject printString]]! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 6/3/2000 18:26'!okayAction	| close |	(self isOkayAvailable and: [self changeRequest]) ifFalse: [^ self].	close _ self model perform: self okaySelector withArguments: (Array with: self).	close ifTrue: [self close]! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 6/3/2000 18:26'!prevAction	self changeRequest ifFalse: [^ self].	self decrementIndex.	self updateContents! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 6/28/2000 08:49'!release: aMorph	self isReleaseAvailable		ifTrue: [self model				perform: self addSelector				withArguments: (Array with: aMorph with: self)]		ifFalse: [self currentValueMorph delete.			self currentKeyMorph delete]! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 8/9/2000 18:02'!release: releaseMorph replaceBy: replaceMorph	self isReleaseAvailable		ifTrue: [self model				perform: self releaseSelector				withArguments: (Array with: releaseMorph with: replaceMorph with: self)]		ifFalse: [releaseMorph ~~ replaceMorph ifTrue: [releaseMorph delete]]! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 6/27/2000 16:48'!resendMenuAction: argObjectOrArray 	| selector argumentArray |	argumentArray _ (argObjectOrArray isKindOf: Array)				ifTrue: [argObjectOrArray]				ifFalse: [Array with: argObjectOrArray].	selector _ argumentArray first.	argumentArray at: 1 put: self.	^ self model perform: selector withArguments: argumentArray! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'NS 7/3/2000 22:31'!wrap: anObject into: aMorph modelSelector: aSymbol 	| morphicObject |	morphicObject _ (self isModelAvailable and: [aSymbol notNil])				ifTrue: [self model perform: aSymbol withArguments: (Array with: anObject with: self)]				ifFalse: [self objectToMorph: (self collection isEmpty							ifTrue: ['Empty']							ifFalse: [anObject])].	aMorph submorphs isEmpty not ifTrue: [		self release: aMorph submorphs first replaceBy: morphicObject].	aMorph removeAllMorphs.	aMorph addMorph: morphicObject.	"aMorph layoutChanged"! !!PluggableCollectionMorph methodsFor: 'submorphs-add/remove' stamp: 'NS 6/28/2000 09:06'!delete	super delete.	self release: self currentValueMorph replaceBy: nil.	self release: self currentKeyMorph replaceBy: nil.	self isModelAvailable ifTrue: [self model removeDependent: self]! !!PluggableCollectionMorph class methodsFor: 'instance creation' stamp: 'NS 6/2/2000 17:11'!collection: aCollection 	^ self new initialize collectionOrSelector: aCollection! !!PluggableCollectionMorph class methodsFor: 'instance creation' stamp: 'NS 7/28/2000 09:29'!model: anObject collectionOrSelector: aCollectionOrSymbol okaySelector: okaySymbol cancelSelector: cancelSymbol addSelector: addSymbol deleteSelector: deleteSymbol gotoSelector: gotoSymbol menuSelector: menuSymbol changeSelector: changeSymbol valueMorphSelector: valueMorphSymbol keyMorphSelector: keyMorphSymbol objectToStringSelector: objectToStringSymbol releaseSelector: releaseSymbol	^ self new initialize		setModel: anObject		collectionOrSelector: aCollectionOrSymbol		okaySelector: okaySymbol		cancelSelector: cancelSymbol		addSelector: addSymbol		deleteSelector: deleteSymbol		gotoSelector: gotoSymbol		menuSelector: menuSymbol		changeSelector: changeSymbol		valueMorphSelector: valueMorphSymbol		keyMorphSelector: keyMorphSymbol		objectToStringSelector: objectToStringSymbol		releaseSelector: releaseSymbol.! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'NS 8/17/2000 10:17'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionSelector withArguments: arguments].		target isMorph ifTrue: [target changed]].! !!UpdatingNumericStringMorph methodsFor: 'target access' stamp: 'NS 6/24/2000 16:40'!acceptValueFromTarget: v 	^ super acceptValueFromTarget: ((format = #default and: [v isNumber])			ifTrue: 				[| t | 				t _ v.				min ifNotNil: [t _ t max: min].				max ifNotNil: [t _ t min: max]]			ifFalse: [v])! !!UpdatingNumericStringMorph methodsFor: 'accessing' stamp: 'NS 6/24/2000 16:31'!max	^ max! !!UpdatingNumericStringMorph methodsFor: 'accessing' stamp: 'NS 6/24/2000 16:31'!max: aNumber	max _ aNumber! !!UpdatingNumericStringMorph methodsFor: 'accessing' stamp: 'NS 6/24/2000 16:32'!min	^ min! !!UpdatingNumericStringMorph methodsFor: 'accessing' stamp: 'NS 6/24/2000 16:31'!min: aNumber	min _ aNumber! !!FillInTheBlankMorph class reorganize!('default constants' defaultAnswerExtent)('instance creation' request: request:initialAnswer: request:initialAnswer:centerAt: request:initialAnswer:centerAt:inWorld: request:initialAnswer:centerAt:inWorld:onCancelReturn: request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR: request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:answerExtent: request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:answerHeight: requestPassword: requestPassword:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:)!CRDictionaryBrowser initialize!!CRAddFeatureMorph reorganize!('accessing' addFeatureAndUpdate: defaultChar defaultChar: model)('private' addFeature: avgFeature bestStrokeFeature featureMorph featureMorph: lastFeature menuAction model: removeLastAction resetAction setHotspotAction: shownFeature strokeDistance:and: switchShowLastAction)('updating' update: updateContents)('model access' addToActionAskUser: addToDefaultAction addToXAction cancelAction createMorphForFeature objectToString:)('initialize-release' initializeModel: layout)('buttons' addToDefaultButton addToXButton basicButton cancelButton menuButton resetButton)('genie-processing' allowsGestureEscape allowsGesturePreprocessing gestureDictionary handlesGestureStart: processEvent:using:)('genie-dispatching' gesture:)!"Postscript:Reinitialize CRDictionary and CRDisplayProperties"CRDictionary initialize.CRDisplayProperties initialize.!