'From Squeak2.8alpha of 4 February 2000 [latest update: #2310] on 12 June 2000 at 12:59:49 pm'!"Change Set:		130ClickDragSelection-mirDate:			25 May 2000Authors:		Leandro Caniglia & Valeria Murgia, Michael Rueger[It seems to be saver to file-in this stuff using MVC --sma]This change set:1. Adds double-click and drag support as in:	aMorph		on: #doubleClick		send: <doubleClickSelector>		to: <recipient>.2. Moves the double-click support from PluggableListMorph to EventHandler.3. Changes the visual feedback to the selection of items in PluggableListMorphs. Now the selection is made with #mouseUp instead of #mouseDown, which seems to be more convenient when dragging or double-clicking."!Object subclass: #EventHandler	instanceVariableNames: 'mouseDownRecipient mouseDownSelector mouseStillDownRecipient mouseStillDownSelector mouseUpRecipient mouseUpSelector mouseEnterRecipient mouseEnterSelector mouseLeaveRecipient mouseLeaveSelector mouseEnterDraggingRecipient mouseEnterDraggingSelector mouseLeaveDraggingRecipient mouseLeaveDraggingSelector keyStrokeRecipient keyStrokeSelector valueParameter startDragSelector startDragRecipient doubleClickSelector doubleClickRecipient '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!ScrollPane subclass: #PluggableListMorph	instanceVariableNames: 'list selectedMorph selection getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect font lastKeystrokeTime lastKeystrokes lastClickTime doubleClickSelector potentialDropMorph '	classVariableNames: 'DoubleClickTime '	poolDictionaries: ''	category: 'Morphic-Windows'!!EventHandler methodsFor: 'initialization' stamp: 'LC 5/18/2000 09:37'!adaptToWorld: aWorld	"If any of my recipients refer to a world or a hand, make them now refer	to the corresponding items in the new world.  (instVarNamed: is slow, later	use perform of two selectors.)"	| value newValue |	#(mouseDownRecipient mouseStillDownRecipient mouseUpRecipient	mouseEnterRecipient mouseLeaveRecipient mouseEnterDraggingRecipient	mouseLeaveDraggingRecipient doubleClickRecipient startDragRecipient keyStrokeRecipient valueParameter) do:		[:aName |		(value _ self instVarNamed: aName asString) ifNotNil:			[newValue _ nil.			value isMorph				ifTrue:					[value isWorldMorph ifTrue: [newValue _ aWorld].					value isHandMorph ifTrue: [newValue _ aWorld primaryHand]]				ifFalse: [(value isKindOf: Presenter) ifTrue: [newValue _ aWorld presenter]].			(newValue notNil and: [newValue ~~ value])				ifTrue:					[self instVarNamed: aName asString put: newValue]]]! !!EventHandler methodsFor: 'initialization' stamp: 'LC 2/14/2000 08:13'!forgetDispatchesTo: aSelector	"aSelector is no longer implemented by my corresponding Player, so don't call it any more"	mouseDownSelector == aSelector		ifTrue: [mouseDownRecipient _ mouseDownSelector _ nil].	mouseStillDownSelector == aSelector		ifTrue: [mouseStillDownRecipient _ mouseStillDownSelector _ nil].	mouseUpSelector == aSelector		ifTrue: [mouseUpRecipient _ mouseUpSelector _ nil].	mouseEnterSelector == aSelector		ifTrue: [mouseEnterRecipient _ mouseEnterSelector _ nil].	mouseLeaveSelector == aSelector		ifTrue: [mouseLeaveRecipient _ mouseLeaveSelector _ nil].	mouseEnterDraggingSelector == aSelector		ifTrue: [mouseEnterDraggingRecipient _ mouseEnterDraggingSelector _ nil].	mouseLeaveDraggingSelector == aSelector		ifTrue: [mouseLeaveDraggingRecipient _ mouseLeaveDraggingSelector _ nil].	doubleClickSelector == aSelector		ifTrue: [doubleClickRecipient _ doubleClickSelector _ nil].	keyStrokeSelector == aSelector		ifTrue: [keyStrokeRecipient _ keyStrokeSelector _ nil].! !!EventHandler methodsFor: 'initialization' stamp: 'mir 5/25/2000 12:54'!on: eventName send: selector to: recipient	eventName = #mouseDown ifTrue:		[mouseDownRecipient _ recipient.  mouseDownSelector _ selector. ^ self].	eventName = #mouseStillDown ifTrue:		[mouseStillDownRecipient _ recipient.  mouseStillDownSelector _ selector. ^ self].	eventName = #mouseUp ifTrue:		[mouseUpRecipient _ recipient.  mouseUpSelector _ selector. ^ self].	eventName = #mouseEnter ifTrue:		[mouseEnterRecipient _ recipient.  mouseEnterSelector _ selector. ^ self].	eventName = #mouseLeave ifTrue:		[mouseLeaveRecipient _ recipient.  mouseLeaveSelector _ selector. ^ self].	eventName = #mouseEnterDragging ifTrue:		[mouseEnterDraggingRecipient _ recipient.  mouseEnterDraggingSelector _ selector. ^ self].	eventName = #mouseLeaveDragging ifTrue:		[mouseLeaveDraggingRecipient _ recipient.  mouseLeaveDraggingSelector _ selector. ^ self].	eventName = #doubleClick ifTrue:		[doubleClickRecipient _ recipient. doubleClickSelector _ selector. ^ self].	eventName = #startDrag ifTrue:		[startDragRecipient _ recipient. startDragSelector _ selector. ^ self].	eventName = #keyStroke ifTrue:		[keyStrokeRecipient _ recipient.  keyStrokeSelector _ selector. ^ self].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!EventHandler methodsFor: 'testing' stamp: 'LC 2/14/2000 08:50'!handlesDoubleClick: evt	^ doubleClickRecipient notNil! !!EventHandler methodsFor: 'testing' stamp: 'LC 2/14/2000 09:06'!handlesMouseDown: evt	mouseDownRecipient ifNotNil: [^ true].	mouseStillDownRecipient ifNotNil: [^ true].	mouseUpRecipient ifNotNil: [^ true].	doubleClickRecipient ifNotNil: [^ true].	^ false! !!EventHandler methodsFor: 'testing' stamp: 'mir 5/25/2000 12:52'!handlesStartDrag: evt	^ startDragRecipient notNil! !!EventHandler methodsFor: 'events' stamp: 'LC 2/14/2000 08:44'!click: event fromMorph: sourceMorph 	"This message is sent only when double clicks are handled."	^ self		send: mouseDownSelector		to: mouseDownRecipient		withEvent: event		fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'LC 2/14/2000 08:38'!doubleClick: event fromMorph: sourceMorph 	^ self		send: doubleClickSelector		to: doubleClickRecipient		withEvent: event		fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'mir 5/25/2000 13:02'!mouseDown: event fromMorph: sourceMorph 	"Take double-clicks into account."	((self handlesDoubleClick: event)		and: [event redButtonPressed])		ifTrue: 			[event hand waitForClicksOrDrag: sourceMorph event: event.			^ nil]		ifFalse: [^ self click: event fromMorph: sourceMorph]! !!EventHandler methodsFor: 'events' stamp: 'mir 5/23/2000 17:43'!startDrag: event fromMorph: sourceMorph 	^ self		send: startDragSelector		to: startDragRecipient		withEvent: event		fromMorph: sourceMorph! !!EventHandler methodsFor: 'access' stamp: 'LC 2/14/2000 08:56'!allRecipients	"Answer a list, without duplication, of all the objects serving as recipients to any of the events I handle.  Intended for debugging/documentation use only"	| aList |	aList _ OrderedCollection with: mouseDownRecipient with: mouseStillDownRecipient with: mouseUpRecipient with: mouseEnterRecipient with: mouseLeaveRecipient.	aList addAll: (OrderedCollection with:  mouseEnterDraggingRecipient with: mouseLeaveDraggingRecipient with: doubleClickRecipient with: keyStrokeRecipient).	^ (aList copyWithout: nil) asSet asArray! !!EventHandler methodsFor: 'access' stamp: 'LC 2/14/2000 08:57'!firstMouseSelector	"Answer the selector corresponding to the first mouse-handling selector fielded.  Created in support of providing balloon-help for halo handles, triggered by the selector handled"	mouseDownSelector ifNotNil: [^ mouseDownSelector].	mouseStillDownSelector ifNotNil: [^ mouseStillDownSelector].	mouseUpSelector ifNotNil: [^ mouseUpSelector].	mouseEnterSelector ifNotNil: [^ mouseEnterSelector].	mouseLeaveSelector ifNotNil: [^ mouseLeaveSelector].	mouseEnterDraggingSelector ifNotNil: [^ mouseEnterDraggingSelector].	mouseLeaveDraggingSelector ifNotNil: [^ mouseLeaveDraggingSelector].	doubleClickSelector ifNotNil: [^ doubleClickSelector].	^ nil! !!EventHandler methodsFor: 'access' stamp: 'LC 2/14/2000 08:58'!messageList	"Return a list of 'Class selector' for each message I can send.  tk9/13/97"	| list |	list _ SortedCollection new.	mouseDownRecipient ifNotNil:		[list add: (mouseDownRecipient class classThatUnderstands:					mouseDownSelector) name , ' ', mouseDownSelector].	mouseStillDownRecipient ifNotNil:		[list add: (mouseStillDownRecipient class classThatUnderstands:					mouseStillDownSelector) name , ' ', mouseStillDownSelector].	mouseUpRecipient ifNotNil:		[list add: (mouseUpRecipient class classThatUnderstands:					mouseUpSelector) name , ' ', mouseUpSelector].	mouseEnterRecipient ifNotNil:		[list add: (mouseEnterRecipient class classThatUnderstands:					mouseEnterSelector) name , ' ', mouseEnterSelector].	mouseLeaveRecipient ifNotNil:		[list add: (mouseLeaveRecipient class classThatUnderstands:					mouseLeaveSelector) name , ' ', mouseLeaveSelector].	mouseEnterDraggingRecipient ifNotNil:		[list add: (mouseEnterDraggingRecipient class classThatUnderstands:					mouseEnterDraggingSelector) name , ' ', mouseEnterDraggingSelector].	mouseLeaveDraggingRecipient ifNotNil:		[list add: (mouseLeaveDraggingRecipient class classThatUnderstands:					mouseLeaveDraggingSelector) name , ' ', mouseLeaveDraggingSelector].	doubleClickRecipient ifNotNil:		[list add: (doubleClickRecipient class classThatUnderstands:					doubleClickSelector) name , ' ', doubleClickSelector].	keyStrokeRecipient ifNotNil:		[list add: (keyStrokeRecipient class classThatUnderstands:					keyStrokeSelector) name , ' ', keyStrokeSelector].	^ list! !!EventHandler methodsFor: 'access' stamp: 'LC 2/14/2000 09:01'!printOn: aStream	| aVal recipients |	super printOn: aStream.	#('mouseDownSelector' 'mouseStillDownSelector' 'mouseUpSelector' 'mouseEnterSelector' 'mouseLeaveSelector' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingSelector' 'doubleClickSelector' 'keyStrokeSelector') do:		[:aName | (aVal _ self instVarNamed: aName) ~~ nil ifTrue:			[aStream nextPutAll: '; ', aName, '=', aVal]].	(recipients _ self allRecipients) size > 0 ifTrue:		[aStream nextPutAll: ' recipients: '.		recipients printOn: aStream]! !!Morph methodsFor: 'drawing' stamp: 'LC 5/18/2000 08:55'!drawMouseDownHiglightOn: aCanvas	self highlightedForMouseDown ifTrue: [		aCanvas frameRectangle: self fullBounds color: self color darker darker].! !!Morph methodsFor: 'drawing' stamp: 'LC 5/18/2000 08:40'!fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"	self visible ifFalse: [^ self].	(self hasProperty: #errorOnDraw) ifTrue:[^self drawErrorOn: aCanvas].	aCanvas drawMorph: self.	self drawSubmorphsOn:aCanvas.	self drawDropHighlightOn: aCanvas.	self drawMouseDownHiglightOn: aCanvas! !!Morph methodsFor: 'drawing' stamp: 'LC 5/18/2000 08:51'!highlightForMouseDown	self highlightForMouseDown: true! !!Morph methodsFor: 'drawing' stamp: 'LC 5/18/2000 08:51'!highlightForMouseDown: aBoolean	self setProperty: #highlightedForMouseDown toValue: aBoolean.	self changed! !!Morph methodsFor: 'drawing' stamp: 'LC 5/18/2000 08:48'!highlightedForMouseDown	^(self valueOfProperty: #highlightedForMouseDown) == true! !!Morph methodsFor: 'event handling' stamp: 'LC 5/18/2000 09:54'!click: evt	"Handle a single-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing.	LC 2/14/2000 08:32 - added: EventHandler notification"	self eventHandler ifNotNil:		[self eventHandler click: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'LC 5/18/2000 09:54'!doubleClick: evt	"Handle a double-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing.	LC 2/14/2000 08:32 - added: EventHandler notification"	self eventHandler ifNotNil:		[self eventHandler doubleClick: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'mir 5/23/2000 17:43'!startDrag: evt	"Handle a double-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing."	self eventHandler ifNotNil:		[self eventHandler startDrag: evt fromMorph: self].! !!HandMorph methodsFor: 'event handling' stamp: 'LC 5/18/2000 09:32'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: Sensor cursorPoint]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				clickState == #firstClickDown					ifTrue: [clickClient click: firstClickEvent]					ifFalse:					["ensure that at least one mouseMove: is reported for each mouse transaction:"					m mouseMove: (localEvt copy setType: #mouseMove).					(m handlesMouseOverDragging: localEvt) ifTrue:						["If m also handles dragOver, enter it in the list"						dragOverMorphs add: m.						mouseOverMorphs remove: m ifAbsent: []]]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab					ifNotNil:						[self grabMorph: rootForGrab]					ifNil:						[self newMouseFocus: m   "trigger automatic viewing, for example"]].		mouseOverTimes removeKey: m ifAbsent: []]! !!HandMorph methodsFor: 'double click support' stamp: 'mir 6/1/2000 14:21'!checkForDoubleClick: evt	"Process the given mouse event to detect a click, double-click, or drag."	| t tfmEvt nowPos dragClient dragStartEvent |	tfmEvt _ evt transformedBy: eventTransform.	t _ Time millisecondClockValue - firstClickTime.	clickState = #firstClickDown ifTrue: [		(((tfmEvt cursorPoint - firstClickEvent cursorPoint) r > 10)			and: [clickClient containsPoint: firstClickEvent cursorPoint]) ifTrue:			["consider it a drag if hand moves"			"NOTE: First drag point must be from first click point,			AND handPos must revert in case the target wants to be grabbed."			nowPos _ self position.			self position: firstClickEvent cursorPoint.			dragClient _ clickClient.			dragStartEvent _ firstClickEvent.			self resetClickState.			dragClient startDrag: dragStartEvent.			self position: nowPos.			^ self].		tfmEvt isMouseUp ifTrue:			[clickState _ #firstClickUp.			^ self]].	clickState = #firstClickUp ifTrue:		[tfmEvt isMouseDown ifTrue:			[clickClient doubleClick: firstClickEvent.			^ self resetClickState].		t > DoubleClickTime ifTrue:			["clickClient click: firstClickEvent."			^ self resetClickState]]! !!MenuMorph methodsFor: 'control' stamp: 'mir 5/25/2000 17:39'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem i yOffset sub delta |	hand resetClickState.	popUpOwner _ hand.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | each == lastSelection]				ifNone: [self items isEmpty						ifTrue: [^ self]						ifFalse: [self items first]].	"Note: items may not be laid out yet (I found them all to be at 0@0), 	so have to add up heights of items above the selected item."	i _ 0.	yOffset _ 0.	[(sub _ self submorphs at: (i _ i + 1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	self bounds right > hand worldBounds right		ifTrue: [self position: self position - (self bounds width - 4 @ 0)].	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self; startSteppingSubmorphsOf: self.	hand newMouseFocus: selectedItem.	self changed! !!PluggableListMorph methodsFor: 'events' stamp: 'LC 5/20/2000 19:41'!doubleClick: event onItem: aMorph	doubleClickSelector isNil ifTrue: [^ self].	selectedMorph ifNil: [self setSelectedMorph: aMorph].	^ self model perform: doubleClickSelector! !!PluggableListMorph methodsFor: 'events' stamp: 'LC 5/29/2000 22:12'!mouseDown: evt	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed]! !!PluggableListMorph methodsFor: 'events' stamp: 'LC 5/18/2000 09:55'!mouseDown: event onItem: aMorph	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	aMorph ifNotNil: [aMorph highlightForMouseDown]! !!PluggableListMorph methodsFor: 'events' stamp: 'LC 5/29/2000 22:26'!mouseUp: evt	"do nothing but fix the nobody land bug"! !!PluggableListMorph methodsFor: 'events' stamp: 'mir 6/2/2000 16:07'!mouseUp: event onItem: aMorph 	aMorph ifNotNil: [aMorph highlightForMouseDown: false].	model okToChange ifFalse: [		^ self].	"No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [aMorph == selectedMorph])		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].	Cursor normal show.! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'mir 5/25/2000 12:54'!installEventHandlerOn: morphList	| handler |	handler _ EventHandler new.	handler		on: #mouseDown send: #mouseDown:onItem: to: self;		on: #mouseUp send: #mouseUp:onItem: to: self;		on: #doubleClick send: #doubleClick:onItem: to: self.	self dragEnabled		ifTrue: [handler				on: #startDrag				send: #startDrag:onItem:				to: self].	self dropEnabled		ifTrue: 			[handler				on: #mouseEnterDragging				send: #mouseEnterDragging:onItem:				to: self.			handler				on: #mouseLeaveDragging				send: #mouseLeaveDragging:onItem:				to: self].	morphList do: [:m | m eventHandler: handler].! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'mir 6/2/2000 16:05'!startDrag: evt onItem: itemMorph 	| ddm |	evt hand hasSubmorphs		ifTrue: [^self].	itemMorph ifNotNil: [itemMorph highlightForMouseDown: false].	model okToChange ifFalse: [		Cursor normal show.		^ self].  "No change if model is locked"	itemMorph ~= self selection ifTrue: [self setSelectedMorph: itemMorph].	ddm _ TransferMorph withPassenger: (self model dragPassengerFor: itemMorph inMorph: self) from: self.	ddm dragTransferType: (self model dragTransferTypeForMorph: self).	Preferences dragNDropWithAnimation			ifTrue: [self model dragAnimationFor: itemMorph transferMorph: ddm].	evt hand grabMorph: ddm! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'mir 6/1/2000 14:32'!mouseDown: evt	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed]! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'mir 6/1/2000 14:32'!mouseUp: evt	"do nothing but fix the nobody land bug"! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'mir 5/25/2000 12:58'!startDrag: evt onItem: itemMorph 	| ddm |	evt hand hasSubmorphs		ifTrue: [^self].	itemMorph ~= self selectedMorph ifTrue: [self setSelectedMorph: itemMorph].	ddm _ TransferMorph withPassenger: (self model dragPassengerFor: itemMorph inMorph: self) from: self.	ddm dragTransferType: (self model dragTransferTypeForMorph: self).	Preferences dragNDropWithAnimation			ifTrue: [self model dragAnimationFor: itemMorph transferMorph: ddm].	evt hand grabMorph: ddm! !SimpleHierarchicalListMorph removeSelector: #drag:itemMorph:!SimpleHierarchicalListMorph removeSelector: #mouseStillDown:onItem:!PluggableListMorph class removeSelector: #initialize!PluggableListMorph removeSelector: #drag:itemMorph:!PluggableListMorph removeSelector: #mouseMove:!PluggableListMorph removeSelector: #mouseStillDown:onItem:!ScrollPane subclass: #PluggableListMorph	instanceVariableNames: 'list selectedMorph selection getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect font lastKeystrokeTime lastKeystrokes lastClickTime doubleClickSelector potentialDropMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!Morph removeSelector: #drag:!Object subclass: #EventHandler	instanceVariableNames: 'mouseDownRecipient mouseDownSelector mouseStillDownRecipient mouseStillDownSelector mouseUpRecipient mouseUpSelector mouseEnterRecipient mouseEnterSelector mouseLeaveRecipient mouseLeaveSelector mouseEnterDraggingRecipient mouseEnterDraggingSelector mouseLeaveDraggingRecipient mouseLeaveDraggingSelector keyStrokeRecipient keyStrokeSelector valueParameter startDragRecipient startDragSelector doubleClickSelector doubleClickRecipient '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!"Postscript:"PluggableListMorph allSubInstances do: [:each | each list: each getList]!