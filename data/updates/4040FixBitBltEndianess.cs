'From Squeak3.1alpha of 28 February 2001 [latest update: #4039] on 17 May 2001 at 3:36:05 pm'!"Change Set:		FixBitBltEndianessDate:			17 May 2001Author:			Andreas RaabThis change set fixes the determination of endianess from within BitBlt. Rather than assuming that all non-Bitmap bits are little endian pixels (which leads to problems when Form>>hackBits: is used to perform pixel hacking) we now check for NEGATIVE depth values of forms. This has a variety of advantages, such as giving *explicit* information about the format of the form, allowing for transparent pixel access through a Form (depending on the endianess the shifts are either left or right aligned so the sign of the depth tells us which way to go) and also allows extending various support primitives (such as #supportsDisplayDepth:) to deal with little endian formats more easily.Note that this CS deals *exclusively* with the BitBlt related side of the issue - support for the image side hasn't been written yet."!!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 5/17/2001 13:58'!loadBitBltDestForm	"Load the dest form for BitBlt. Return false if anything is wrong, true otherwise."	| destBitsSize |	self inline: true.	destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.	destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.	destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.	(destWidth >= 0 and: [destHeight >= 0])		ifFalse: [^ false].	destDepth _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.	destMSB _ destDepth > 0.	destDepth < 0 ifTrue:[destDepth _ 0 - destDepth].	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(interpreterProxy isIntegerObject: destBits) ifTrue:[		"Query for actual surface dimensions"		(self queryDestSurface: (interpreterProxy integerValueOf: destBits))			ifFalse:[^false].		destPPW _ 32 // destDepth.		destBits _ destPitch _ 0.	] ifFalse:[		destPPW _ 32 // destDepth.		destPitch _ destWidth + (destPPW-1) // destPPW * 4.		destBitsSize _ interpreterProxy byteSizeOf: destBits.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destPitch * destHeight)])			ifFalse: [^ false].		"Skip header since external bits don't have one"		destBits _ self cCoerce: (interpreterProxy firstIndexableField: destBits) to:'int'.	].	^true! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 5/17/2001 13:56'!loadBitBltSourceForm	"Load the source form for BitBlt. Return false if anything is wrong, true otherwise."	| sourceBitsSize |	self inline: true.	sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.	sourceWidth _ self fetchIntOrFloat: FormWidthIndex ofObject: sourceForm.	sourceHeight _ self fetchIntOrFloat: FormHeightIndex ofObject: sourceForm.	(sourceWidth >= 0 and: [sourceHeight >= 0])		ifFalse: [^ false].	sourceDepth _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.	sourceMSB _ sourceDepth > 0.	sourceDepth < 0 ifTrue:[sourceDepth _ 0 - sourceDepth].	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(interpreterProxy isIntegerObject: sourceBits) ifTrue:[		"Query for actual surface dimensions"		(self querySourceSurface: (interpreterProxy integerValueOf: sourceBits))			ifFalse:[^false].		sourcePPW _ 32 // sourceDepth.		sourceBits _ sourcePitch _ 0.	] ifFalse:[		sourcePPW _ 32 // sourceDepth.		sourcePitch _ sourceWidth + (sourcePPW-1) // sourcePPW * 4.		sourceBitsSize _ interpreterProxy byteSizeOf: sourceBits.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourcePitch * sourceHeight)])			ifFalse: [^ false].		"Skip header since external bits don't have one"		sourceBits _ self cCoerce: (interpreterProxy firstIndexableField: sourceBits) to:'int'.	].	^true! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 5/17/2001 15:15'!OLDtallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord |	(cmFlags bitAnd: (ColorMapPresent bitOr: ColorMapIndexedPart)) =		(ColorMapPresent bitOr: ColorMapIndexedPart)			ifFalse: [^ destinationWord "no op"].	destDepth < 16 ifTrue:		["loop through all packed pixels."		pixMask _ (maskTable at: destDepth) bitAnd: cmMask.		shiftWord _ destinationWord.		1 to: destPPW do:			[:i |			mapIndex _ shiftWord bitAnd: pixMask.			self tallyMapAt: mapIndex put: (self tallyMapAt: mapIndex) + 1.			shiftWord _ shiftWord >> destDepth].		^ destinationWord].	destDepth = 16 ifTrue:		["Two pixels  Tally the right half..."		mapIndex _ self rgbMap: (destinationWord bitAnd: 16rFFFF) from: 5 to: cmBitsPerColor.		self tallyMapAt: mapIndex put: (self tallyMapAt: mapIndex) + 1.		"... and then left half"		mapIndex _ self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.		self tallyMapAt: mapIndex put: (self tallyMapAt: mapIndex) + 1]	ifFalse:		["Just one pixel."		mapIndex _ self rgbMap: destinationWord from: 8 to: cmBitsPerColor.		self tallyMapAt: mapIndex put: (self tallyMapAt: mapIndex) + 1].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 5/17/2001 15:16'!tallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Those tallied are exactly those	in the destination rectangle.  Note that the source should be 	specified == destination, in order for the proper color map checks 	to be performed at setup."	| mapIndex pixMask destShifted maskShifted pixVal |	self inline: false.	(cmFlags bitAnd: (ColorMapPresent bitOr: ColorMapIndexedPart)) = 		(ColorMapPresent bitOr: ColorMapIndexedPart)			ifFalse: [^ destinationWord "no op"].	pixMask _ maskTable at: destDepth.	destShifted _ destinationWord.	maskShifted _ destMask.	1 to: destPPW do:		[:i |		(maskShifted bitAnd: pixMask) = 0 ifFalse:			["Only tally pixels within the destination rectangle"			pixVal _ destShifted bitAnd: pixMask.			destDepth < 16				ifTrue: [mapIndex _ pixVal]				ifFalse: [destDepth = 16					ifTrue: [mapIndex _ self rgbMap: pixVal from: 5 to: cmBitsPerColor]					ifFalse: [mapIndex _ self rgbMap: pixVal from: 8 to: cmBitsPerColor]].			self tallyMapAt: mapIndex put: (self tallyMapAt: mapIndex) + 1].		maskShifted _ maskShifted >> destDepth.		destShifted _ destShifted >> destDepth].	^ destinationWord  "For no effect on dest"! !