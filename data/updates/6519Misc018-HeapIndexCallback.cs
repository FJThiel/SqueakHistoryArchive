'From TeaSqueak3.2 of 19 September 2002 [latest update: #364] on 30 June 2003 at 12:47:27 am'!"Change Set:		Misc018-HeapIndexCallbackDate:			17 March 2003Author:			Joshua GargusThis changeset allows a block to be set that is evaluated whenever an object's position in the heap is changed.  The parameters to the block are the object and the new index.The motivation is to enable a Heap to be used as a dynamic priority queue (one where the priorities of the events may change even after they are added to the queue.  When a priority is changed, the heap must be updated.  To do this efficiently, it must be possible to quickly find the changed object in the heap.  Without maintaining an index into the heap, this process is O(n), which is not fast enough."!SequenceableCollection subclass: #Heap	instanceVariableNames: 'array tally sortBlock indexUpdateBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!!Heap commentStamp: '<historical>' prior: 0!Class Heap implements a special data structure commonly referred to as 'heap'. Heaps are more efficient than SortedCollections if:a) Elements are only removed at the beginningb) Elements are added with arbitrary sort order.The sort time for a heap is O(n log n) in all cases.Instance variables:	array		<Array>		The data repository	tally		<Integer>	The number of elements in the heap	sortBlock	<Block|nil>	A two-argument block defining the sort order,							or nil in which case the default sort order is								[:element1 :element2| element1 <= element2]	indexUpdateBlock 	<Block|nil> 							A two-argument block of the form [:data :index | ... ]							which allows an application object to keep track of its							index within the heap.  Useful for quick heap update							when object's sort value changes (for example, when an							object in a priority queue has its priority increased							by an external event, you don't want to have to search							through the whole heap to find the index before fixing							the heap).  No update occurs if nil.!TestCase subclass: #HeapTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Collections-Sequenceable'!!Heap methodsFor: 'accessing' stamp: 'jcg 3/8/2003 02:00'!indexUpdateBlock: aBlockOrNil	indexUpdateBlock _ aBlockOrNil.	indexUpdateBlock fixTemps.! !!Heap methodsFor: 'adding' stamp: 'jcg 3/8/2003 02:07'!add: anObject	"Include newObject as one of the receiver's elements. Answer newObject."	tally = array size ifTrue:[self grow].	array at: (tally _ tally + 1) put: anObject.	self updateObjectIndex: tally.	self upHeap: tally.	^anObject! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:11'!downHeap: anIndex	"Check the heap downwards for correctness starting at anIndex.	 Everything above (i.e. left of) anIndex is ok."	| value k n j |	anIndex = 0 ifTrue:[^self].	n _ tally bitShift: -1.	k _ anIndex.	value _ array at: anIndex.	[k <= n] whileTrue:[		j _ k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[ j _ j + 1].		"check if position k is ok"		(self sorts: value before: (array at: j)) 			ifTrue:[	"yes -> break loop"					n _ k - 1]			ifFalse:[	"no -> make room at j by moving j-th element to k-th position"					array at: k put: (array at: j).					self updateObjectIndex: k.					"and try again with j"					k _ j]].	array at: k put: value.	self updateObjectIndex: k.! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:11'!downHeapSingle: anIndex	"This version is optimized for the case when only one element in the receiver can be at a wrong position. It avoids one comparison at each node when travelling down the heap and checks the heap upwards after the element is at a bottom position. Since the probability for being at the bottom of the heap is much larger than for being somewhere in the middle this version should be faster."	| value k n j |	anIndex = 0 ifTrue:[^self].	n _ tally bitShift: -1.	k _ anIndex.	value _ array at: anIndex.	[k <= n] whileTrue:[		j _ k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[	j _ j + 1].		array at: k put: (array at: j).		self updateObjectIndex: k.		"and try again with j"		k _ j].	array at: k put: value.	self updateObjectIndex: k.	self upHeap: k! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:12'!upHeap: anIndex	"Check the heap upwards for correctness starting at anIndex.	 Everything below anIndex is ok."	| value k kDiv2 tmp |	anIndex = 0 ifTrue:[^self].	k _ anIndex.	value _ array at: anIndex.	[ (k > 1) and:[self sorts: value before: (tmp _ array at: (kDiv2 _ k bitShift: -1))] ] 		whileTrue:[			array at: k put: tmp.			self updateObjectIndex: k.			k _ kDiv2].	array at: k put: value.	self updateObjectIndex: k.! !!Heap methodsFor: 'private' stamp: 'jcg 3/8/2003 02:08'!updateObjectIndex: index	"If indexUpdateBlock is not nil, notify the object at index of its new position in the heap array."	indexUpdateBlock ifNotNil: [		indexUpdateBlock value: (array at: index) value: index]! !!HeapTest methodsFor: 'as yet unclassified' stamp: 'jcg 3/8/2003 03:10'!test1	| data h |	"The first element of each array is the sort value, and the second will be updated by the heap with the index of the element within the heap."	data _  (1 to: 8) collect: [:i | {i*2. 0}].	"Repeat with different data ordering."	5 timesRepeat: [		h _ Heap new sortBlock: [:e1 :e2 | e1 first < e2 first].		h indexUpdateBlock: [:array :index | array at: 2 put: index].		data shuffled do: [:d | h add: d].		data do: [:d | self should: (h at: d second) == d].	]! !