'From Squeak2.8alpha of 16 February 2000 [latest update: #2151] on 17 May 2000 at 12:19:27 am'!"Change Set:		BrowserWithDragAndDropDate:			15 May 2000Author:			Stephan Rudlof, Michael RuegerRelease:			0.7Drag&drop for standard browsers!!Precondition: Morphic, Squeak 2.7, dndCleanupPostcondition: You have to open new browsers to see some effect!! Old ones should work as before (the same should be valid for other tools using PluggableListMorph or subclasses).Usage:Just press the red button (after pressing shift key or not) and drag inside a browser window or from one browser window to another (you *don't* need two windows!!):- a method in another message category,- a class in another class category,- a method from a class to another class.There is- copy semantic, if shift key pressed,- move semantic, if shift key not pressed.The user has to confirm, if some method should be overwritten.DoIts:Browser openBrowser.Utilities dragNDropDomestos. 'for removal of drag&drop artifacts'Preferences:There are 'browsing' preferences- 'browseWithDragNDrop', default is 'on';- 'dragNDropWithAnimation', default is 'on'.Bugs: They surely exist: mail them to me or Squeak ML!!Implementation note:Merged with standard classes since v0.5 to avoid code bloat.Have fun!!History:0.7		rewritten based on dndCleanup0.6		copy/move semantic controlled by shift key:		-> copy visualized by cursor with '+',		-> move visualized by cursor without '+' and animation,			- successful move has another animation as unsuccessful one;		refactored and improved Browser code;		animation of #move operation (controlled by Preferences).		0.5		Drag&drop inside hierarchies: moving methods from sub/super to super/sub class			-> works in HierarchyBrowsers!!		Drag&drop between hierarchies: copying methods from class to class;		TransferMorph: better visualization (from Henrik Gedenryd)			-> the item will be dragged now;		Implementation integrated in standard classes now.0.4		Drag&drop inside browsers, better logic, better visualization.0.3		Drag&drop triggered by pressing red mouse button and just moving mouse;		PluggableListMorphWithDragAndDrop:			event handling improved			-> mouseUp deselects now (better for drag&drop).0.2.1	PluggableListMorphWithDragAndDrop: superfluous inst var removed0.2		Drag&drop triggered by pressing red mouse button longer than DoubleClickTime.0.1		Drag&drop triggered by pressing shift-key and then red mouse button."!!Browser methodsFor: 'initialize-release' stamp: 'mir 5/5/2000 15:26'!openAsMorphClassEditing: editString	"Create a pluggable version a Browser on just a single class."	| window switches codePane baseline aTextMorph dragNDropFlag |	window _ (SystemWindow labelled: 'later') model: self.	dragNDropFlag _ Preferences browseWithDragNDrop.	window addMorph: ((PluggableListMorph on: self list: #classListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #classListMenu: keystroke: #classListKey:from:) enableDragNDrop: dragNDropFlag)		frame: (0@0 extent: 0.5@0.06).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0.5@0 extent: 0.5@0.06).	switches borderWidth: 0.	window addMorph: ((PluggableMessageCategoryListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu: keystroke: #arrowKey:from:	 getRawListSelector: #rawMessageCategoryList)  enableDragNDrop: dragNDropFlag)		frame: (0@0.06 extent: 0.5@0.30).	window addMorph: ((PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:) enableDragNDrop: dragNDropFlag)		frame: (0.5@0.06 extent: 0.5@0.30).	Preferences useAnnotationPanes		ifFalse:			[baseline _ 0.36]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.36 corner: 1@0.41).			baseline _ 0.41].	Preferences optionalButtons		ifTrue:			[window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@baseline corner: 1@1).	window setUpdatablePanesFrom: #(messageCategoryList messageList).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'mir 5/5/2000 15:27'!openAsMorphEditing: editString	"Create a pluggable version of all the morphs for a Browser in Morphic"	| window switches codePane aListMorph baseline aTextMorph dragNDropFlag |	window _ (SystemWindow labelled: 'later') model: self.	dragNDropFlag _ Preferences browseWithDragNDrop.	window addMorph: ((PluggableListMorph on: self list: #systemCategoryList			selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:			menu: #systemCategoryMenu: keystroke: #systemCatListKey:from:) enableDragNDrop: dragNDropFlag)		frame: (0@0 extent: 0.25@0.4).	window addMorph: ((PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu: keystroke: #classListKey:from:) enableDragNDrop: dragNDropFlag)		frame: (0.25@0 extent: 0.25@0.3).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0.25@0.3 extent: 0.25@0.1).	switches borderWidth: 0.	window addMorph: ((PluggableMessageCategoryListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu: keystroke: #arrowKey:from: getRawListSelector: #rawMessageCategoryList) enableDragNDrop: dragNDropFlag)		frame: (0.5@0 extent: 0.25@0.4).	aListMorph _ PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph enableDragNDrop: dragNDropFlag.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0.75@0 extent: 0.25@0.4).	Preferences useAnnotationPanes		ifFalse:			[baseline _ 0.4]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.4 corner: 1@0.45).			baseline _ 0.45].	Preferences optionalButtons		ifTrue:			[window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0 @ baseline corner: 1 @ 1).	window setUpdatablePanesFrom: #(systemCategoryList classList messageCategoryList messageList).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'mir 5/5/2000 15:26'!openAsMorphMessageEditing: editString	"Create a pluggable version a Browser that shows just one message"	| window codePane baseline aTextMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: ((PluggableListMorph on: self list: #messageListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:) enableDragNDrop: Preferences browseWithDragNDrop)		frame: (0@0 extent: 1.0@0.06).	Preferences useAnnotationPanes		ifFalse:			[baseline _ 0.06]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.06 corner: 1@0.11).			baseline _ 0.11].	Preferences optionalButtons		ifTrue:			[window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@baseline corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'mir 5/5/2000 15:26'!openAsMorphMsgCatEditing: editString	"Create a pluggable version a Browser on just a messageCategory."	| window codePane baseline aTextMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: ((PluggableListMorph on: self list: #messageCatListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageCategoryMenu:) enableDragNDrop: Preferences browseWithDragNDrop)		frame: (0@0 extent: 1.0@0.06).	window addMorph: ((PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:) enableDragNDrop: Preferences browseWithDragAndDrop)		frame: (0@0.06 extent: 1.0@0.30).	Preferences useAnnotationPanes		ifFalse:			[baseline _ 0.30]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.30 corner: 1@0.35).			baseline _ 0.35].	Preferences optionalButtons		ifTrue:			[window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@baseline corner: 1@1).	window setUpdatablePanesFrom: #(messageCatListSingleton messageList).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'mir 5/5/2000 15:26'!openAsMorphSysCatEditing: editString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window switches codePane baseline aTextMorph dragNDropFlag |	window _ (SystemWindow labelled: 'later') model: self.	dragNDropFlag _ Preferences browseWithDragNDrop.	window addMorph: ((PluggableListMorph on: self list: #systemCategorySingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #systemCatSingletonMenu: keystroke: #systemCatSingletonKey:from:) enableDragNDrop: dragNDropFlag)		frame: (0@0 extent: 1.0@0.06).	window addMorph: ((PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu: keystroke: #classListKey:from:) enableDragNDrop: dragNDropFlag)		frame: (0@0.06 extent: 0.3333@0.24).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0@0.3 extent: 0.3333@0.06).	switches borderWidth: 0.	window addMorph: ((PluggableMessageCategoryListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu: keystroke: #arrowKey:from:	 getRawListSelector: #rawMessageCategoryList) enableDragNDrop: dragNDropFlag)		frame: (0.3333@0.06 extent: 0.3333@0.30).	window addMorph: ((PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:) enableDragNDrop: dragNDropFlag)		frame: (0.6666@0.06 extent: 0.3333@0.30).	Preferences useAnnotationPanes		ifFalse: 	[baseline _ 0.36]		ifTrue: [baseline _ 0.41.			aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.36 corner: 1@baseline)].	Preferences optionalButtons		ifTrue:			[window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@baseline corner: 1@1).	window setUpdatablePanesFrom: #( classList messageCategoryList messageList).	^ window! !!Browser methodsFor: 'message category functions' stamp: 'mir 5/5/2000 16:02'!addCategory	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"	| labels reject lines cats menuIndex oldIndex newName |	self okToChange ifFalse: [^ self].	classListIndex = 0 ifTrue: [^ self].	labels _ OrderedCollection with: 'new...'.	reject _ Set new.	reject		addAll: self selectedClassOrMetaClass organization categories;		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines _ OrderedCollection new.	self selectedClassOrMetaClass allSuperclasses do: [:cls |		cls = Object ifFalse: [			cats _ cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse: [				lines add: labels size.				labels addAll: cats asSortedCollection.				reject addAll: cats]]].	newName _ (labels size = 1 or: [		menuIndex _ (PopUpMenu labelArray: labels lines: lines)		startUpWithCaption: 'Add Category'.		menuIndex = 0 ifTrue: [^ self].		menuIndex = 1])			ifTrue: [				self request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: [				labels at: menuIndex].	oldIndex _ messageCategoryListIndex.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	self classOrMetaClassOrganizer		addCategory: newName		before: (messageCategoryListIndex = 0				ifTrue: [nil]				ifFalse: [self selectedMessageCategoryName]).	self changed: #messageCategoryList.	self messageCategoryListIndex:		(oldIndex = 0			ifTrue: [self classOrMetaClassOrganizer categories size + 1]			ifFalse: [oldIndex]).	self changed: #messageCategoryList.! !!Browser methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 18:41'!acceptDroppingMorph: transferMorph event: evt inMorph: dstListMorph 	"Here we are fetching informations from the dropped transferMorph and 	             performing the correct action for this drop."	| srcType success class newClassCategory |	success _ false.	srcType _ transferMorph dragTransferType.	srcType == #messageList ifTrue: [success _ self					acceptMethod: transferMorph passenger value					class: transferMorph passenger key					atListMorph: dstListMorph					otherModel: self					internal: self == transferMorph source model].	srcType == #classList		ifTrue: 			[class _ transferMorph passenger.			newClassCategory _ dstListMorph potentialDropMorph contents.			newClassCategory ~= (SystemOrganization categoryOfElement: class)				ifTrue: [					class category: newClassCategory.					self selectCategoryForClass: class.					self selectClass: class.					success _ true]].	^success! !!Browser methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 11:47'!acceptMethod: methodSelector class: class atListMorph: dstListMorph otherModel: otherModel internal: internal 	| myClass dstListSel newMessageCategory dropMorph success conflict hierarchyChange source higher dropClassSymbol myClassOrMeta |	success _ true.	dstListSel _ dstListMorph getListSelector.	myClass _ internal & (dstListSel == #classList)				ifTrue: 					[dropMorph _ dstListMorph potentialDropMorph.					dropMorph ifNil: [success _ false]						ifNotNil: [dropClassSymbol _ dropMorph contents withBlanksCondensed asSymbol].					success ifTrue: [Smalltalk at: dropClassSymbol]]				ifFalse: [self selectedClass].	myClassOrMeta _ self metaClassIndicated				ifTrue: [myClass class]				ifFalse: [myClass].	newMessageCategory _ internal & (dstListSel == #messageCategoryList)				ifTrue: 					[dropMorph _ dstListMorph potentialDropMorph.					dropMorph ifNil: [success _ false]						ifNotNil: [dropMorph contents asSymbol]]				ifFalse: [self selectedMessageCategoryName].	(success _ success & myClassOrMeta notNil)		ifTrue: [myClassOrMeta == class				ifTrue: 					[(success _ newMessageCategory ~~ nil & (newMessageCategory ~= '-- all --' asSymbol))						ifTrue: [(success _ newMessageCategory ~= otherModel selectedMessageCategoryName and: [class organization categories includes: newMessageCategory])								ifTrue: [class organization										classify: methodSelector										under: newMessageCategory										suppressIfDefault: false]]]				ifFalse: 					[internal ifTrue: [success _ success & (dropClassSymbol ~~ self selectedClassName)].					success						ifTrue: 							[conflict _ myClassOrMeta selectors includes: methodSelector.							hierarchyChange _ (higher _ class inheritsFrom: myClassOrMeta) | (myClassOrMeta inheritsFrom: class).							(success _ conflict not										or: [self												overwriteDialogHierarchyChange: hierarchyChange												higher: higher												sourceClassName: myClassOrMeta name												destinationClassName: class name												methodSelector: methodSelector])								ifTrue: 									[source _ class sourceCodeAt: methodSelector.									newMessageCategory ifNil: [newMessageCategory _ class whichCategoryIncludesSelector: methodSelector]										ifNotNil: [newMessageCategory asSymbol == '-- all --' asSymbol ifTrue: [newMessageCategory _ 'as yet unclassified' asSymbol]].									myClassOrMeta										compile: source										classified: newMessageCategory										notifying: nil.									hierarchyChange ifTrue: ["default: cut/paste"										class removeSelector: methodSelector]]]]].	success & internal not		ifTrue: 			[self selectMessageCategoryNamed: newMessageCategory.			self messageListIndex: (self messageList indexOf: methodSelector).			self changed: #messageList].	^ success! !!Browser methodsFor: 'drag and drop' stamp: 'mir 5/16/2000 11:35'!dragAnimationFor: item transferMorph: transferMorph 	TransferMorphLineAnimation on: transferMorph! !!Browser methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 16:46'!dragPassengerFor: item inMorph: dragSource 	| transferType |	(dragSource isKindOf: PluggableListMorph)		ifFalse: [^item].	transferType _ self dragTransferTypeForMorph: dragSource.	transferType == #messageList		ifTrue: [^self selectedClassOrMetaClass->item contents].	transferType == #classList		ifTrue: [^self selectedClassOrMetaClass].	^item contents! !!Browser methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 16:18'!dragTransferTypeForMorph: dragSource 	^(dragSource isKindOf: PluggableListMorph)		ifTrue: [dragSource getListSelector]! !!Browser methodsFor: 'drag and drop' stamp: 'sr 4/23/2000 07:59'!overwriteDialogHierarchyChange: hierarchyChange higher: higherFlag sourceClassName: srcClassName destinationClassName: dstClassName methodSelector: methodSelector 	| lastHand tmpHand lf success |	World removeHand: (lastHand _ World activeHand).	World addHand: (tmpHand _ lastHand copy).	lf _ Character cr asString.	success _ SelectionMenu				confirm: 'There is a conflict.' , ' Overwrite' , (hierarchyChange							ifTrue: [higherFlag									ifTrue: [' superclass']									ifFalse: [' subclass']]							ifFalse: ['']) , ' method' , lf , dstClassName , '>>' , methodSelector , lf , 'by ' , (hierarchyChange							ifTrue: ['moving']							ifFalse: ['copying']) , ' method' , lf , srcClassName name , '>>' , methodSelector , ' ?'				trueChoice: 'Yes, don''t care.'				falseChoice: 'No, I have changed my opinion.'.	World removeHand: tmpHand.	World addHand: lastHand.	^ success! !!Browser methodsFor: 'drag and drop' stamp: 'panda 4/28/2000 18:27'!wantsDroppedMorph: transferMorph event: anEvent inMorph: destinationLM 	"We are only interested in TransferMorphs as wrappers for             	informations. If their content is really interesting for us, will             	determined later in >>acceptDroppingMorph:event:."	| srcType dstType |	srcType _ transferMorph dragTransferType.	dstType _ destinationLM getListSelector.	(srcType == #messageList		and: [dstType == #messageCategoryList or: [dstType == #classList]])		ifTrue: [^true].	(srcType == #classList		and: [dstType == #systemCategoryList])		ifTrue: [^true]."			[			srcLS == #messageList ifTrue: [^ dstLS == #messageList | (dstLS == #messageCategoryList) | (dstLS == #classList)].			srcLS == #classList ifTrue: [^ dstLS == #classList | (dstLS == #systemCategoryList)]]."	^ false! !!Preferences class methodsFor: 'help' stamp: 'mir 5/16/2000 16:32'!helpMsgsAddition4sr	^ #((browseWithDragNDrop	'If true, drag&drop browsing is enabled, new Browser are opened with drag&drop functionality (only in Morphic).'))! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 5/5/2000 03:26'!browseWithDragNDrop	^ self valueOfFlag: #browseWithDragNDrop! !!Preferences class methodsFor: 'initial values' stamp: 'mir 5/16/2000 16:33'!initialValuesAddition4sr	^ #((browseWithDragNDrop true (browsing ) ) )! !"Postscript:"Preferences absorbAdditions!