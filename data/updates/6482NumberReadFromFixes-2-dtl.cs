'From Squeak3.7beta of ''1 April 2004'' [latest update: #5923] on 24 November 2004 at 9:20:31 pm'!"Change Set:		NumberReadFromFixes-2-dtlDate:			24 November 2004Author:			David T. LewisThese changes correct several problems with parsing of numbers from strings and streams. The problems are demonstrated by NumberParsingTest and ScaledDecimalTest (provided in separate change sets; the latter is already included in the Squeak 3.9 image).The original bug report was for the following problem, which is corrected by this change set:  '1.40s2' asNumber => 1.39s2This change set replaces NumberReadFromFixes-dtl, which introduced a serious bug that prevented recompilation of the system."!!Number class methodsFor: 'private' stamp: 'dtl 9/18/2004 18:20'!canParseAsScaledDecimal: integerPart fractionPart: fractionPart digits: fractionDigits base: base sign: sign from: aStream 	"Answer true if parsing a ScaleDecimal will succeed. Read from a copy  	of aStream to test the parsing."	^ aStream peek == $s		and: [(self				readScaledDecimal: integerPart				fractionPart: fractionPart				digits: fractionDigits				base: base				sign: sign				from: aStream copy) notNil]! !!Number class methodsFor: 'private' stamp: 'dtl 11/24/2004 21:15'!canParseExponentFor: baseValue base: base from: aStream 	"Answer true if parsing the expoenent for a number will succeed. Read from	a copy of aStream to test the parsing."	^ ('edq' includes: aStream peek)		and: [(self				readExponent: baseValue				base: base				from: aStream copy) notNil]! !!Number class methodsFor: 'private' stamp: 'dtl 11/24/2004 21:16'!canParseExponentOrScaledDecimal: value integerPart: integerPart fractionPart: fractionPart digits: fractionDigits base: base sign: sign from: aStream 	"Answer true if aStream contains parseable characters. The state of aStream is not changed."	^ (self			canParseExponentFor: value			base: base			from: aStream)		or: [self				canParseAsScaledDecimal: integerPart				fractionPart: fractionPart				digits: fractionDigits				base: base				sign: sign				from: aStream]! !!Number class methodsFor: 'private' stamp: 'dtl 11/24/2004 21:14'!readExponent: baseValue base: base from: aStream	"Complete creation of a number, reading exponent from aStream. Answer the	number, or nil if parsing fails.	<number>(e|d|q)<exponent>>"	| sign exp value |	aStream next. "skip e|d|q"	sign _ ((aStream peek) == $-)		ifTrue: [aStream next. -1]		ifFalse: [1].	(aStream peek digitValue between: 0 and: 9) ifFalse: [^ nil]. "Avoid throwing an error"	exp _ (Integer readFrom: aStream base: 10) * sign.	value := baseValue * (base raisedTo: exp).	^ value! !!Number class methodsFor: 'private' stamp: 'dtl 11/24/2004 21:18'!readRemainderOf: integerPart from: aStream base: base withSign: sign 	"Read optional fractional part and exponent or decimal scale, and return the final result"	"Changed 200/01/19 For ANSI Numeric Literals support."	"Number readFrom: '3r-22.2'"	| value fraction fractionDigits fracpos fractionPart scaledDecimal |	#Numeric.	value := integerPart.	fractionDigits := 0.	(aStream peekFor: $.)		ifTrue: ["<integer>.<fraction>"			(aStream atEnd not					and: [aStream peek digitValue between: 0 and: base - 1])				ifTrue: [fracpos := aStream position.					fractionPart := Integer readFrom: aStream base: base.					fraction := fractionPart asFloat								/ (base raisedTo: aStream position - fracpos).					fractionDigits := aStream position - fracpos.					value := value asFloat + fraction]				ifFalse: [(self							canParseExponentOrScaledDecimal: value							integerPart: integerPart							fractionPart: fractionPart							digits: fractionDigits							base: base							sign: sign							from: aStream)						ifFalse: ["oops - just <integer>."							aStream skip: -1.							"un-gobble the period"							^ value * sign]]].	(self canParseAsScaledDecimal: integerPart			fractionPart: fractionPart			digits: fractionDigits			base: base			sign: sign			from: aStream)		ifTrue: ["<number>s[<scale>]"			(scaledDecimal := self						readScaledDecimal: integerPart						fractionPart: fractionPart						digits: fractionDigits						base: base						sign: sign						from: aStream)				ifNotNil: [^ scaledDecimal]].	(self canParseExponentFor: value			base: base			from: aStream)		ifTrue: ["<number>(e|d|q)<exponent>>"			value := self						readExponent: value						base: base						from: aStream].	(value isFloat			and: [value = 0.0					and: [sign = -1]])		ifTrue: [^ Float negativeZero]		ifFalse: [^ value * sign]! !!Number class methodsFor: 'private' stamp: 'dtl 9/18/2004 19:07'!readScaledDecimal: integerPart fractionPart: fractionPart digits: fractionDigits base: base sign: sign from: aStream 	"Complete creation of a ScaledDecimal, reading scale from aStream. Answer	a ScaledDecimal, or nil if parsing fails.	<number>s[<scale>]"	| scale decimalMultiplier decimalFraction |	aStream atEnd ifTrue: [^ nil].	(aStream next == $s) ifFalse: [^ nil].	"<number>s<scale>"	(aStream peek digitValue between: 0 and: 10)		ifTrue: [scale := Integer readFrom: aStream]		ifFalse: [^ nil].	scale isNil		ifTrue: ["<number>s"			fractionDigits = 0				ifTrue: ["<integer>s"					scale := 0]				ifFalse: ["<integer>.<fraction>s"					scale := fractionDigits]].	fractionPart isNil		ifTrue: [^ ScaledDecimal newFromNumber: integerPart * sign scale: scale]		ifFalse: [decimalMultiplier := base raisedTo: fractionDigits.			decimalFraction := integerPart * decimalMultiplier + fractionPart * sign / decimalMultiplier.			^ ScaledDecimal newFromNumber: decimalFraction scale: scale]! !!Number class reorganize!('instance creation' readFrom: readFrom:base:)('private' canParseAsScaledDecimal:fractionPart:digits:base:sign:from: canParseExponentFor:base:from: canParseExponentOrScaledDecimal:integerPart:fractionPart:digits:base:sign:from: readExponent:base:from: readRemainderOf:from:base:withSign: readScaledDecimal:fractionPart:digits:base:sign:from:)!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."!