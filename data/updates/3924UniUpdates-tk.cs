'From Squeak3.1alpha [latest update: #''Squeak3.1alpha'' of 28 February 2001 update 3923] on 11 April 2001 at 1:24:36 pm'!"Change Set:		UniUpdates-tkDate:			11 April 2001Author:			Ted KaehlerMake both Disney internal updates and External updates come from the same folder in the same server.  When making an update external, we don't have to move the file.  It will keep its same number and name.  Two indexes, updates.list and <prefix>updates.list will be in that directory.	When the user chooses which 'server group' to fetch updates from, any with a * in its name will use the prefixed updates file.	When anupdate is broadcast, the user chooses which 'server group' to write to, and any with a * in its name will use the prefixed updates file."!!EToySystem class methodsFor: 'external release' stamp: 'tk 4/10/2001 13:08'!methodsToStripForExternalRelease	"Answer a list of triplets #(className, class/instance, methodName) of methods to be stripped in an external release."	^ #(		(EToySystem			class		prepareRelease)			(EToySystem			class		previewEToysOn:)		)! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 4/10/2001 16:34'!putUpdate: fileStrm 	"Put this file out as an Update on the servers of my group.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class readServerUpdatesThrough:saveLocally:updateImage:.	When two sets of updates need to use the same directory, one of them has a * in its serverUrls description.  When that is true, the first word of the description is put onthe front of 'updates.list', and that index file is used."	| myServers updateStrm sequence newName myName response local restOfText seq fileContents indexPrefix |"	(ScheduledControllers scheduledControllers detect: [:each |		each model == Transcript] ifNone: [nil]) ifNil: [			^ self inform: 'Please open a Transcript window, and then start putting out this update again.']."	local _ fileStrm localName.	fileStrm size = 0		ifTrue: [^ self inform: 'That file has zero bytes!!  May have a new name.'].	fileContents _ fileStrm contentsOfEntireFile.	(fileContents includes: Character linefeed)		ifTrue: [self notify: 'That file contains linefeeds.Proceed if you know that this is okay (e.g. the file contains raw binary data).'].	fileStrm reset.	(self checkNames: (Array with: local)) ifFalse: [^ nil].	"illegal characters"	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	(myServers _ self checkServers) size = 0 ifTrue: [self closeGroup.  ^ self].	indexPrefix _ (group key includes: $*) 		ifTrue: [(group key findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	updateStrm _ myServers first getFileNamed: indexPrefix, 'updates.list'.	sequence _ Utilities lastUpdateNum: updateStrm.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: SystemVersion current version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', SystemVersion current version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil].	"abort"		sequence _ Utilities olderVersNum: restOfText from: updateStrm default: sequence.		].	"get last number and add 1"	seq _ (sequence+1) printString.	seq size = 1 ifTrue: [seq _ '00', seq].	seq size = 2 ifTrue: [seq _ '0', seq].	newName _ seq, local.	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr; nextPutAll: restOfText.	myServers do:		[:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName retry: true.		updateStrm reset.		aServer putFileSavingOldVersion: updateStrm named: indexPrefix, 'updates.list'.		Transcript show: 'Update succeeded on server ', aServer moniker; cr].	self closeGroup.			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 4/10/2001 22:59'!putUpdateMulti: list fromDirectory: updateDirectory 	"Put these files out as an Update on the servers of my group.  List is an array of local file names without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm lastNum myName response restOfText newNames file numStr insertion indexPrefix |	(self checkNames: list) ifFalse: [^ nil].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	(myServers _ self checkServers) size = 0 ifTrue: [self closeGroup.  ^ self].	indexPrefix _ (group key includes: $*) 		ifTrue: [(group key findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	updateStrm _ myServers first getFileNamed: indexPrefix,'updates.list'.	lastNum _ Utilities lastUpdateNum: updateStrm.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: SystemVersion current version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', SystemVersion current version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil	"abort"].		numStr _ FillInTheBlank 			request: 'Please confirm or change the starting update number' 			initialAnswer: (lastNum+1) printString.		lastNum _ numStr asNumber - 1].	newNames _ list with: (lastNum+1 to: lastNum+list size) collect:		[:each :num | (num printString padded: #left to: 4 with: $0) , each].	insertion _ String streamContents:		[:s | newNames do: [:n | s nextPutAll: n; cr]].	"append name to updates"	(updateStrm skip: -1; next) = Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: insertion; nextPutAll: restOfText.	myServers do:		[:aServer |		list doWithIndex: [:local :ind |			file _ updateDirectory oldFileNamed: local.			aServer putFile: file named: (newNames at: ind) retry: true.			file close].		updateStrm reset.		aServer putFileSavingOldVersion: updateStrm named: indexPrefix,'updates.list'.		Transcript cr; show: 'Updates succeeded on server ', aServer moniker].	self closeGroup.		Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally"	list with: newNames do:		[:local :newName | updateDirectory rename: local toBe: newName].! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 4/10/2001 23:01'!updateInstallVersion: newVersion	"For each server group, ask whether we want to put the new version marker (#Squeak2.3) at the end of the file.  Current version of Squeak must be the old one when this is done.	ServerDirectory new updateInstallVersion: 'Squeak2.3'      "	| myServers updateStrm names choice indexPrefix |[names _ ServerDirectory groupNames asSortedArray.choice _ (SelectionMenu labelList: names selections: names) startUp.choice == nil] whileFalse: [	myServers _ (ServerDirectory groupNamed: choice) checkServers.	myServers size = 0 ifTrue: [self inform: 'checkServers failed on one of those'].	indexPrefix _ (myServers first group key includes: $*) 		ifTrue: [(myServers first group key findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	updateStrm _ myServers first getFileNamed: indexPrefix,'updates.list'.	Utilities position: updateStrm 	"checks for current OLD version"			atVersion: SystemVersion current version.			"append name to updates"	updateStrm setToEnd.	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: '#', newVersion; nextPut: Character cr.	myServers do:		[:aServer | updateStrm reset.		aServer putFileSavingOldVersion: updateStrm named: indexPrefix,'updates.list'.		Transcript cr; show: indexPrefix,'updates.list written on server ', aServer moniker].			]! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 4/10/2001 14:47'!newUpdatesOn: serverList special: indexPrefix throughNumber: aNumber	"Return a list of fully formed URLs of update files we do not yet have.  Go to the listed servers and look at the file 'updates.list' for the names of the last N update files.  We look backwards for the first one we have, and make the list from there.  tk 9/10/97	No updates numbered higher than aNumber (if it is not nil) are returned " 	| existing doc list out ff raw char maxNumber itsNumber |	maxNumber _ aNumber ifNil: [99999].	out _ OrderedCollection new.	existing _ SystemVersion current updates.	serverList do: [:server |		doc _ HTTPSocket httpGet: server,indexPrefix,'updates.list' accept: 'application/octet-stream'.		"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue:			[raw _ doc reset; contents.	"one file name per line"			list _ self extractThisVersion: raw.			list reverseDo: [:fileName |				ff _ (fileName findTokens: '/') last.	"allow subdirectories"				itsNumber _ ff initialIntegerOrNil. 				(existing includes: itsNumber)					ifFalse:						[						(itsNumber == nil or: [itsNumber <= maxNumber])							ifTrue:								[out addFirst: server, fileName]]					ifTrue: [^ out]].			((out size > 0) or: [char _ doc reset; skipSeparators; next.				(char == $*) | (char == $#)]) ifTrue:					[^ out "we have our list"]].	"else got error msg instead of file"		"Server was down, try next one"].	PopUpMenu notify: 'All code update servers seem to be unavailable'.	^ out! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 4/10/2001 14:50'!readServer: serverList special: indexPrefix updatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.""Utilities readServer: Utilities serverUrls updatesThrough: 828 saveLocally: true updateImage: true"	| urls failed loaded docQueue this nextDoc docQueueSema str updateName |	Cursor wait showWhile: [	urls _ self newUpdatesOn: (serverList collect: [:url | url, 'updates/']) 				special: indexPrefix				throughNumber: maxNumber.	loaded _ 0.	failed _ nil.	"send downloaded documents throuh this queue"	docQueue := SharedQueue new.	"this semaphore keeps too many documents from beeing queueed up at a time"	docQueueSema := Semaphore new.	5 timesRepeat: [ docQueueSema signal ].	"fork a process to download the updates"	self retrieveUrls: urls ontoQueue: docQueue withWaitSema: docQueueSema.	"process downloaded updates in the foreground"	[ this _ docQueue next.	  nextDoc _ docQueue next.  	  nextDoc = #failed ifTrue: [ failed _ this ].	  (failed isNil and: [ nextDoc ~= #finished ])	] whileTrue: [		failed ifNil: [			nextDoc reset; text.			nextDoc size = 0 ifTrue: [ failed _ this ]. ].		failed ifNil: [			nextDoc peek asciiValue = 4	"pure object file"				ifTrue: [failed _ this]].	"Must be fileIn, not pure object file"		failed ifNil: [			"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."				"HTML source code not supported here yet"			updateImage				ifTrue: [					updateName _ (this findTokens: '/') last.					ChangeSorter newChangesFromStream: nextDoc named: updateName.					SystemVersion current registerUpdate: updateName initialIntegerOrNil].			saveLocally ifTrue:				[self saveUpdate: nextDoc onFile: (this findTokens: '/') last].	"if wanted"			loaded _ loaded + 1].		docQueueSema signal].	].	failed ~~ nil & (urls size - loaded > 0) ifTrue: [		str _ loaded printString ,' new update file(s) processed.'.		str _ str, '\Could not load ' withCRs, 			(urls size - loaded) printString ,' update file(s).',			'\Starting with "' withCRs, failed, '".'.		self inform: str].	^ Array with: failed with: loaded! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 4/10/2001 16:31'!readServerUpdatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.A file on the server called updates.list has the names of the last N update files.  We look backwards for the first one we do not have, and start there""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""When two sets of updates need to use the same directory, one of them has a * in its serverUrls description.  When that is true, the first word of the description is put onthe front of 'updates.list', and that is the index file used.""Utilities readServerUpdatesThrough: 3922 saveLocally: true updateImage: true"	| failed loaded str res servers triple tryAgain indexPrefix |	Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"	servers _ Utilities serverUrls copy.	indexPrefix _ (Utilities updateUrlLists first first includes: $*) 		ifTrue: [(Utilities updateUrlLists first first findTokens: ' ') first]						"special for internal updates"		ifFalse: ['']. 	"normal"	[servers isEmpty] whileFalse: [		triple _ self readServer: servers special: indexPrefix 					updatesThrough: maxNumber 					saveLocally: saveLocally updateImage: updateImage.		"report to user"		failed _ triple first.		loaded _ triple second.		tryAgain _ false.		failed ifNil: ["is OK"			loaded = 0 ifTrue: ["found no updates"				servers size > 1 ifTrue: ["not the last server"					res _ PopUpMenu withCaption: 'No new updates on the server', servers first, 'Would you like to try the next server?(Normally, all servers are identical, but sometimes aserver won''t let us store new files, and gets out of date.)' 						chooseFrom: 'Stop looking\Try next server'.					res = 2 ifFalse: [^ self]						 ifTrue: [servers _ servers allButFirst.	"try the next server"							tryAgain _ true]]]].		tryAgain ifFalse: [			str _ loaded printString ,' new update file(s) processed.'.			^ self inform: str].	].! !Utilities class removeSelector: #newUpdatesOn:throughNumber:!Utilities class removeSelector: #readServer:updatesThrough:saveLocally:updateImage:!"Postscript:Change the name of Disney Internal Updates to have a * in it.  Change to the external servers."| lists have sv1 sv2 assoc |  have _ false.lists _ Utilities classPool at: #UpdateUrlLists.lists withIndexDo: [:ll :ind |	ll first = 'Disney Internal Updates' ifTrue: [		lists at: ind put: #('Disney Internal Updates*' #('squeak.cs.uiuc.edu/Squeak2.0/' 'www.squeaklet.com/updates/external/')).		have _ true]].have ifTrue: [sv1 _ (ServerDirectory serverNamed: 'UpdatesExtAtKitchen') clone.	sv2 _ (ServerDirectory serverNamed: 'UpdatesExtUIUC') clone.	assoc _ 'Disney Internal Updates*'->(Array with: sv1 with: sv2).	sv1 group: assoc.	sv2 group: assoc.	ServerDirectory addServer: sv1 named: 'UpdatesExtAtKitchen2'.	ServerDirectory addServer: sv2 named: 'UpdatesExtUIUC2'.	(ServerDirectory serverNamed: 'UpdatesAtSqueak.org') group key: 'Obsolete Disney Updates' ].have ifTrue: [self inform: 'Changing the server that Disney Internal Updates are stored on.Please fetch updates again to query the new server.']. !| existing |existing _ ChangeSorter allChangeSetNames.existing _ existing collect: [:cngSet | cngSet copyReplaceAll: '/' with: '_'].existing _ existing collect: [:each | each initialIntegerOrNil].(existing select: [:each | each notNil]) asSet do: [:each |	SystemVersion current registerUpdate: each].!