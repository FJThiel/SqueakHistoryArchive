'From Squeak2.7 of 5 January 2000 [latest update: #1775] on 13 January 2000 at 9:57:14 pm'!"Change Set:		ftpNewFile-tkMUDate:			13 January 2000Author:			Ted KaehlerAllows RemoteFileStreams to keep track of whether they have valid data in their local stream.  The lack of this knowledge caused ftp errors when closing a newly created remote file, and when writing a file of zero length."!RWBinaryOrTextStream subclass: #RemoteFileStream	instanceVariableNames: 'remoteFile localDataValid '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Kernel'!!RemoteFileStream commentStamp: 'tk 1/13/2000 21:41' prior: 0!An in-memory stream that can be used to fileIn code from the network.  Knows its ServerFile, and thus its name, path, etc.localDataValid -- false when have never read the file from the server.  Set to true after reading, when my contents has the true data.  When creating a remote file, set localDataValid to true so it will write to server.!!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 1/13/2000 21:47'!contentsOfEntireFile	"Fetch the data off the server and store it in me.  But not if I already have it."	readLimit _ readLimit max: position.	localDataValid ifTrue: [^ super contentsOfEntireFile].	collection size = 0 ifTrue: [self on: (String new: 2000)].	remoteFile getFileNamed: remoteFile fileName into: self.	"sets localDataValid _ true"	^ super contentsOfEntireFile! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 1/13/2000 21:45'!dataIsValid	localDataValid _ true.! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 1/13/2000 21:48'!openReadOnly	"If we have data, don't reread."	self readOnly.	readLimit _ readLimit max: position.	localDataValid ifFalse: [remoteFile getFileNamed: remoteFile fileName into: self].		"sets localDataValid _ true"! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 1/13/2000 21:39'!remoteFile: aServerFile	remoteFile _ aServerFile.	localDataValid _ false.	"need to read from the server"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 1/13/2000 21:47'!getFileNamed: fileNameOnServer into: dataStream	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	type == #file ifTrue: [		dataStream nextPutAll: 			(resp _ FileStream oldFileNamed: server,(self serverDelimiter asString), 				self bareDirectory, (self serverDelimiter asString),				fileNameOnServer) contentsOfEntireFile.		dataStream dataIsValid.		^ resp].	type == #http ifTrue: [		resp _ HTTPSocket httpGet: (self fullNameFor: fileNameOnServer) 				accept: 'application/octet-stream'.		resp class == String ifTrue: [^ dataStream].	"error, no data"		dataStream copyFrom: resp.		dataStream dataIsValid.		^ dataStream].	type ifNil: [type _ #ftp].	"type == #ftp"	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieving file ', fileNameOnServer; cr.	"Transcript show: 'retrieve from port ', dd portNum printString; cr."	resp _ dd getDataTo: dataStream whileWatching: so.		"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [socket _ nil.  ^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [		socket _ nil.  ^ rr].	"226 Transfer complete."	socket ifNil: [		so sendCommand: 'QUIT'.		(rr _ so responseOK) == true ifFalse: [^ rr].	"221"		so destroy].	"Always OK to destroy"	dd destroy.	dataStream dataIsValid.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 1/13/2000 21:51'!newFileNamed: fullName	"Create a RemoteFileStream.  If the file exists, and complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm selection |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file readWrite.	file type == #file ifTrue: [		^ FileStream newFileNamed: (file fileNameRelativeTo: self)].	file exists 		ifTrue: [			selection _ (PopUpMenu labels: 'overwrite that filechoose another namecancel')				startUpWithCaption: (file fullNameFor: file fileName) , 'already exists.']		ifFalse: [selection _ 1].	selection = 1 ifTrue:		[remoteStrm _ RemoteFileStream on: (String new: 2000).		remoteStrm remoteFile: file.		remoteStrm dataIsValid.	"empty stream is the real contents!!"		^ remoteStrm].	"no actual writing till close"	selection = 2 ifTrue: [		^ self newFileNamed:			(FillInTheBlank request: 'Enter a new file name'				initialAnswer: file fileName)].	^ nil	"cancel"! !