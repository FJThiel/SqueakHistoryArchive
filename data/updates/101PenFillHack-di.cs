'From Squeak 2.0 of May 22, 1998 on 14 June 1998 at 1:48:57 pm'!"Change Set:		PenFillHack-diDate:			14 June 1998Author:			Dan IngallsDefines Pen >> fill: fillBlock color: fillColorallowing a closed shape drawn by the fillBlock to be filled with the fillColor.  For example, try...	Display restoreAfter: [Pen new filberts: 4 side: 5]"!Pen subclass: #PenRegionTracer	instanceVariableNames: 'region boundingBox '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Form methodsFor: 'filling' stamp: 'di 6/11/1998 21:38'!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.		"bwForm _ self makeBWForm: interiorColor."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	((BitBlt destForm: self sourceForm: bwForm 		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits.	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!Pen methodsFor: 'operations' stamp: 'di 6/14/1998 13:40'!fill: drawBlock color: color	| region tileForm tilePen shape saveColor |	region _ (self as: PenRegionTracer) in: drawBlock; region.	tileForm _ Form extent: region extent+6.	tilePen _ Pen newOnForm: tileForm.	tilePen location: location-(region origin-3)		direction: direction		penDown: penDown.	drawBlock value: tilePen.  "Draw the shape in B/W"	saveColor _ halftoneForm.	drawBlock value: self.	halftoneForm _ saveColor.	shape _ (tileForm findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: tileForm to: 0@0 rule: Form erase.	destForm fillShape: shape fillColor: color at: region origin-3! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/11/1998 22:01'!dragon: n  "Display restoreAfter: [Display fillWhite. Pen new dragon: 10]."	"Display restoreAfter: [Display fillWhite. 1 to: 4 do:				[:i | Pen new color: i; turn: 90*i; dragon: 10]]"	"Draw a dragon curve of order n in the center of the screen."	n = 0		ifTrue: [self go: 5]		ifFalse: [n > 0				ifTrue: [self dragon: n - 1; turn: 90; dragon: 1 - n]				ifFalse: [self dragon: -1 - n; turn: -90; dragon: 1 + n]]! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/14/1998 13:42'!filberts: n side: s   "Display restoreAfter: [Pen new filberts: 4 side: 5]"	"Two Hilbert curve fragments form a Hilbert tile. Draw four interlocking 	tiles of order n and sides length s."	| n2 |	Display fillWhite.	n2 _ 1 bitShift: n - 1.	self up; go: 0 - n2 * s; down.	1 to: 4 do: 		[:i | 		self fill: [:p |				p hilbert: n side: s.				p go: s.				p hilbert: n side: s.				p go: s.				p up.				p go: n2 - 1 * s.				p turn: -90.				p go: n2 * s.				p turn: 180.				p down]			color: (Color perform: (#(yellow red green blue) at: i))]! !!Pen methodsFor: 'private' stamp: 'di 6/11/1998 16:09'!location: aPoint direction: aFloat penDown: aBoolean	location _ aPoint.	direction _ aFloat.	penDown _ aBoolean! !Smalltalk renameClassNamed: #RegionBuilder as: #PenRegionTracer!!PenRegionTracer commentStamp: 'di 6/14/1998 13:48' prior: 0!I am a pen intended to do no drawing, but to accumulate a bounding rectangular region for a given sequence of drawing requests.  The resulting region does not include any border expansion due to line width.!!PenRegionTracer reorganize!('all' drawFrom:to: region)!!PenRegionTracer methodsFor: 'all' stamp: 'di 6/11/1998 21:56'!drawFrom: p1 to: p2.	"Overridden to skip drawing but track bounds of the region traversed."	region == nil ifTrue: [region _ location rounded extent: 0@0].	region _ region encompass: p2 rounded! !!PenRegionTracer methodsFor: 'all' stamp: 'di 6/11/1998 15:33'!region	^ region! !Pen removeSelector: #fill:!Pen removeSelector: #penDown!Pen removeSelector: #fill:border:!