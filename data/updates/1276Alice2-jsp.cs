'From Squeak 2.4b of April 23, 1999 on 29 June 1999 at 12:03:26 am'!"Change Set:		Alice2Date:			29 June 1999Author:			Jeff PierceSome initial classes for Alice v2.0."!Object subclass: #AliceHierarchical	instanceVariableNames: 'myParent myChildren '	classVariableNames: ''	poolDictionaries: ''	category: 'Alice2.0-Cast'!AliceHierarchical subclass: #AliceActor	instanceVariableNames: 'myName myWorld myMesh myTexture myMaterial myColor compositeMatrix scaleMatrix isHidden isFirstClass '	classVariableNames: ''	poolDictionaries: 'AliceConstants '	category: 'Alice2.0-Cast'!AliceActor subclass: #AliceCamera	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Alice2.0-Cast'!AliceActor subclass: #AliceLight	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Alice2.0-Cast'!Object subclass: #AliceNamespace	instanceVariableNames: 'myDictionary myWorkspace '	classVariableNames: ''	poolDictionaries: 'AliceConstants '	category: 'Alice2.0-Misc'!AliceHierarchical subclass: #AliceScene	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Alice2.0-Cast'!Object subclass: #AliceScheduler	instanceVariableNames: 'currentTime elapsedTime lastSystemTime speed isRunning updateList '	classVariableNames: ''	poolDictionaries: ''	category: 'Alice2.0-Time'!Object subclass: #AliceScript	instanceVariableNames: 'scriptName myCommands activeAnimations pendingCommands scriptType isRunning myWorld '	classVariableNames: ''	poolDictionaries: 'AliceConstants '	category: 'Alice2.0-Scripts'!Object subclass: #AliceWorld	instanceVariableNames: 'myScheduler myNamespace myUndoStack sharedMeshDict sharedTextureDict cameraList lightList myScene actorClassList myTextOutputWindow '	classVariableNames: 'ActorPrototypeClasses '	poolDictionaries: 'AliceConstants '	category: 'Alice2.0-Worlds'!!AliceHierarchical methodsFor: 'initialization' stamp: 'jsp 6/8/1999 23:52'!initialize	"Initialize this instance"	myChildren _ OrderedCollection new.! !!AliceHierarchical methodsFor: 'parent-child' stamp: 'jsp 6/8/1999 23:57'!getAllChildren	"Return all of this instance's children"	| children |	children _ OrderedCollection new.	myChildren do: [:child | children addLast: child.						children _ children , (child getAllChildren).					].	^ children.! !!AliceHierarchical methodsFor: 'parent-child' stamp: 'jsp 6/8/1999 23:58'!getChildren	"Return the object's immediate children."	^ (myChildren copy).! !!AliceHierarchical methodsFor: 'parent-child' stamp: 'jsp 6/8/1999 23:59'!getParent	"Return the object's parent."	^ myParent.! !!AliceHierarchical methodsFor: 'parent-child' stamp: 'jsp 6/8/1999 23:59'!setParent: anObject	"Set this instance's parent"	myParent _ anObject.! !!AliceHierarchical methodsFor: 'private' stamp: 'jsp 6/8/1999 23:54'!addChild: aChild	"Add an object to this instance's list of children. Checks to make sure that aChild is not already a child of this object"	((myChildren identityIndexOf: aChild) = 0) ifTrue: [ myChildren addLast: aChild ].! !!AliceHierarchical methodsFor: 'private' stamp: 'jsp 6/8/1999 23:59'!appendChildrenNamesTo: prefix	"Return the object's children's names, each appended to the prefix."	| nameList |	nameList _ OrderedCollection new.	myChildren do: [:child | nameList addLast: (prefix , (child getName)).							nameList _ nameList , (child appendChildrenNamesTo: (prefix , '    '))].	^ nameList.! !!AliceHierarchical methodsFor: 'private' stamp: 'jsp 6/8/1999 23:58'!getChildrenNames	"Return the object's children."	^ myChildren collect: [: child | child asString ].! !!AliceHierarchical methodsFor: 'private' stamp: 'jsp 6/8/1999 23:57'!removeChild: aChild	"Remove an object from this instance's list of children"	myChildren remove: aChild ifAbsent: [].! !!AliceActor methodsFor: 'initialization' stamp: 'jsp 6/9/1999 00:11'!initializeFor: anAliceWorld	"Initialize the instance variables for the AliceActor"	super initialize.	myName _ 'Unnamed'.	myWorld _ myWorld.	myParent _ myWorld getScene.	myParent addChild: self.	"Initialize our material"	myMaterial _ B3DMaterial new.	myMaterial ambientPart: Color white.	myMaterial diffusePart: Color white.	myMaterial specularPart: Color white.	"Set up our default properties"	myColor _ B3DColor4 r: 1.0 g: 1.0 b: 1.0 a: 1.0.	compositeMatrix _ B3DMatrix4x4 identity.	scaleMatrix _ B3DMatrix4x4 identity.	isHidden _ false.	isFirstClass _ true.! !!AliceActor methodsFor: 'drawing' stamp: 'jsp 6/9/1999 00:16'!drawMesh: aRenderer	"Draw the mesh for this actor."	myMaterial ifNotNil: [			aRenderer pushMaterial.			aRenderer material: myMaterial.						].	myTexture ifNotNil: [			aRenderer pushTexture.			aRenderer texture: myTexture.						].	"Note from Andreas: Using myMesh>>renderOn: here prevents meshes		from being picked!!"	myMesh ifNotNil: [ myMesh renderOn: aRenderer ].	myTexture ifNotNil: [ aRenderer popTexture ].	myMaterial ifNotNil: [ aRenderer popMaterial ].! !!AliceActor methodsFor: 'drawing' stamp: 'jsp 6/9/1999 00:14'!renderOn: aRenderer	"Draw the actor."	"Save the old transformation matrix"	aRenderer pushMatrix.	"Modify the matrix using our composite matrix for position and orientation"	aRenderer transformBy: compositeMatrix.	"Save the new transformation matrix"	aRenderer pushMatrix.	"Modify the matrix using our scale matrix - we do this seperately to avoid scaling space"	aRenderer transformBy: scaleMatrix.	"Draw our mesh if the object is not hidden"	(isHidden) ifFalse: [ self drawMesh: aRenderer ].	"Remove the scaling matrix"	aRenderer popMatrix.	"Draw our children.	Note: For correct picking it is important to use B3DRenderEngine>>render: here."	myChildren do: [:child | aRenderer render: child].	"Restore the old transformation matrix"	aRenderer popMatrix.! !!AliceHierarchical class methodsFor: 'instance creation' stamp: 'jsp 6/8/1999 23:52'!new	"Create and initialize a new instance."	^ super new initialize.! !!AliceActor class reorganize!('instance creation' newFor:)('unique name creation' uniqueNameFrom:)!!AliceActor class methodsFor: 'instance creation' stamp: 'jsp 6/9/1999 00:10'!newFor: anAliceWorld	"Create a new instance for this World."	^ super new initializeFor: anAliceWorld.! !!AliceActor class methodsFor: 'unique name creation' stamp: 'jsp 6/9/1999 00:09'!uniqueNameFrom: aName	"If aName is not an instance variable of this class, returns aName.  Otherwise it returns a unique name based on aName that is not an instance var."	| index |	(self instVarNames includes: aName) ifFalse: [ ^ aName ].	index _ 2.	[ self instVarNames includes: (aName , (index asString)) ]		whileTrue: [ index _ index + 1 ].	^ aName , (index asString).	! !!AliceNamespace methodsFor: 'initialize' stamp: 'jsp 6/7/1999 21:49'!initialize	"Initialize the namespace"	myDictionary _ AliceConstants copy.	myWorkspace _ Workspace new.	myWorkspace setBindings: myDictionary.	myWorkspace embeddedInMorphicWindowLabeled: 'Namespace'.! !!AliceNamespace methodsFor: 'accessing' stamp: 'jsp 6/7/1999 21:43'!at: key	"Return the value in the namespace associated with the key"	^ myDictionary at: key.! !!AliceNamespace methodsFor: 'accessing' stamp: 'jsp 6/7/1999 21:43'!at: key put: value	"Store the value in the namespace under the key"	myDictionary at: key put: value.! !!AliceNamespace methodsFor: 'accessing' stamp: 'jsp 6/7/1999 21:42'!getDictionary	"Return the namespace dictionary"	^ myDictionary.! !!AliceNamespace methodsFor: 'accessing' stamp: 'jsp 6/7/1999 21:44'!getEvaluationContext	"Return a context containing the namespace for evaluating a statement "	^ (myWorkspace dependents last select model: myWorkspace).! !!AliceNamespace methodsFor: 'accessing' stamp: 'jsp 6/8/1999 21:55'!includesKey: aKey	"Return true if the namespace includes the key"	^ myDictionary includesKey: aKey.! !!AliceNamespace methodsFor: 'accessing' stamp: 'jsp 6/8/1999 22:57'!removeKey: theKey	"Remove the key from the namespace"	myDictionary removeKey: theKey ifAbsent: [].! !!AliceNamespace methodsFor: 'accessing' stamp: 'jsp 6/8/1999 22:57'!removeKey: theKey ifAbsent: failBlock	"Remove the key from the namespace. If the key isn't there, run the code in the fail block."	myDictionary removeKey: theKey ifAbsent: failBlock.! !!AliceNamespace class methodsFor: 'instance creation' stamp: 'jsp 6/7/1999 21:46'!new	"Create a new namespace for an Alice world"	^ super new initialize.! !!AliceScheduler reorganize!('initialize' initialize reset)('accessing' getElapsedTime getFPS getTime pause resume setSpeed:)('update list maintenance' addUpdateItem: removeUpdateItem:)('ticking' tick)!!AliceScheduler methodsFor: 'initialize' stamp: 'jsp 6/7/1999 16:06'!initialize	"Initialize the scheduler"	"The scheduler starts at time 0"	currentTime _ 0.	elapsedTime _ 0.	"The scheduler starts executing at 1:1 time"	speed _ 1.	"The scheduler starts running"	isRunning _ true.	"Determine the system time we're starting at"	lastSystemTime _ Time millisecondClockValue / 1000.0.	"Create the list of items to update"	updateList _ OrderedCollection new.! !!AliceScheduler methodsFor: 'initialize' stamp: 'jsp 6/7/1999 15:51'!reset	"Resets the Wonderland time to 0"	self initialize.! !!AliceScheduler methodsFor: 'accessing' stamp: 'jsp 6/7/1999 15:53'!getElapsedTime	"Returns the time that elapsed in the last Scheduler tick"	^ elapsedTime.! !!AliceScheduler methodsFor: 'accessing' stamp: 'jsp 6/7/1999 15:53'!getFPS	"Returns the instantaneous frames per second (1 / elapsedTime)"	^ (1.0 / elapsedTime).! !!AliceScheduler methodsFor: 'accessing' stamp: 'jsp 6/7/1999 15:53'!getTime	"Returns the current scheduler time"	^ currentTime.! !!AliceScheduler methodsFor: 'accessing' stamp: 'jsp 6/7/1999 15:55'!pause	"Pause the scheduler. Pauses all script executiong, but any active cameras continue to render."	isRunning _ false.! !!AliceScheduler methodsFor: 'accessing' stamp: 'jsp 6/7/1999 15:55'!resume	"If the scheduler was paused, resume it."	isRunning ifFalse: 	[ isRunning _ true.						  lastSystemTime _ (Time millisecondClockValue) / 1000.0.						].! !!AliceScheduler methodsFor: 'accessing' stamp: 'jsp 6/7/1999 15:55'!setSpeed: newSpeed	"This method sets the speed for the Scheduler. 1 is a 1:1 mapping with clock time, 2 is a 2:1 mapping, etc."	(speed > 0) ifTrue: [speed _ newSpeed] ifFalse: [self error: 'Scheduler speed must be greater than 0.'].! !!AliceScheduler methodsFor: 'update list maintenance' stamp: 'jsp 6/7/1999 16:05'!addUpdateItem: newItem	"Add a new item to the scheduler's update list (a running animation, active script, etc"	updateList addLast: newItem.! !!AliceScheduler methodsFor: 'update list maintenance' stamp: 'jsp 6/7/1999 16:06'!removeUpdateItem: anItem	"Add a new item to the scheduler's update list (a running animation, active script, etc)"	updateList remove: anItem ifAbsent: [].! !!AliceScheduler methodsFor: 'ticking' stamp: 'jsp 6/7/1999 16:02'!tick	"Figure out how much time has elapsed since the last Scheduler tick and update all the scripts"	isRunning ifTrue: [			elapsedTime _ ((Time millisecondClockValue / 1000.0) - lastSystemTime) * speed.			"if elapsedTime is negative the clock rolled over; deal with it"			(elapsedTime < 0) ifTrue: [lastSystemTime _ 0. elapsedTime _										(Time millisecondClockValue) / 1000.0].			currentTime _ currentTime + elapsedTime.			lastSystemTime _ lastSystemTime + elapsedTime.			"Process scripts here"				updateList do: [:item | item update: currentTime.								(item isDone) ifTrue: [self removeUpdateItem: item]				].						].! !!AliceScheduler class methodsFor: 'instance creation' stamp: 'jsp 6/7/1999 15:46'!new	"Create a new scheduler and initialize it"	^ super new initialize.! !Smalltalk renameClassNamed: #NamelessScript as: #AliceScript!!AliceScript reorganize!('initialize' initialize:)('accessing' getScriptName isDone setCommands: setScriptName: setScriptType:)('executing' start update: updateInOrder: updateTogether:)!!AliceScript methodsFor: 'initialize' stamp: 'jsp 6/8/1999 17:58'!initialize: anAliceWorld	"Initialize script by assigning the scheduler and putting default values in the instance variables"	"Set the script name"	scriptName _ 'Unnamed'.	"Set the scheduler for this script"	myWorld _ anAliceWorld.	"By default a script contains no commands"	myCommands _ OrderedCollection new.	"By default there are no active commands"	pendingCommands _ OrderedCollection new.	"By default there are no active animations"	activeAnimations _ OrderedCollection new.	"By default scripts run in order (one command after another)"	scriptType _ inOrder.	"By default the script isn't running"	isRunning _ false.! !!AliceScript methodsFor: 'accessing' stamp: 'jsp 6/7/1999 21:59'!getScriptName	"Returns the name of the script"	^ scriptName.! !!AliceScript methodsFor: 'accessing' stamp: 'jsp 6/7/1999 16:12'!isDone	"Returns true if the script is not currently running"	^ isRunning not.! !!AliceScript methodsFor: 'accessing' stamp: 'jsp 6/7/1999 15:15'!setCommands: commands	"Set the commands in the script"	myCommands _ commands.! !!AliceScript methodsFor: 'accessing' stamp: 'jsp 6/7/1999 21:59'!setScriptName: aName	"Sets the name of the script"	scriptName _ aName.! !!AliceScript methodsFor: 'accessing' stamp: 'jsp 6/7/1999 15:14'!setScriptType: type	"Set the script type (inOrder or Together)"	scriptType _ type.! !!AliceScript methodsFor: 'executing' stamp: 'jsp 6/8/1999 18:03'!start	"Start running this script"	| result |	(scriptType = inOrder)		ifTrue: [					pendingCommands _ OrderedCollection new.					1 to: (myCommands size) do: [:i | pendingCommands addLast: i ].				]		ifFalse: [					myCommands do: [:command | result _ command.						result _ Compiler new evaluate: command in: nil to: nil								notifying: (myWorld getNamespace											getEvaluationContext) ifFail: [].						myWorld addOutputText: (result printString).						(result isKindOf: Animation)							ifTrue: [ activeAnimations add: result ].									].				].	isRunning _ true.	"Need to add this script to the scheduler so it gets updated"	(myWorld getScheduler) addUpdateItem: self.	"Update the script once with the current time"	self update: (myWorld getScheduler getTime).! !!AliceScript methodsFor: 'executing' stamp: 'jsp 6/7/1999 21:38'!update: currentTime	"Determine how to update this script based on the type of script it is"	(scriptType = inOrder)		ifTrue: [ self updateInOrder: currentTime ]		ifFalse: [ self updateTogether: currentTime ].! !!AliceScript methodsFor: 'executing' stamp: 'jsp 6/8/1999 17:33'!updateInOrder: currentTime	"Update this script assuming that one command runs after the previous command finishes"	| nextCommand result |	"Update the previous command if it's still active"	activeAnimations do: [:anim | anim update: currentTime.								(anim isDone) ifTrue: [activeAnimations remove: anim ]].	"Check if all active animations are complete, if not keep pulling and executing script commands until we hit one that doesn't complete immediately"	(activeAnimations isEmpty)		ifTrue: [ [ (pendingCommands isEmpty) or: [activeAnimations isEmpty not] ]					whileFalse: [						nextCommand _ myCommands at: (pendingCommands removeFirst).						"evaluate the command in my namespace"						result _ Compiler new evaluate: nextCommand in: nil to: nil									notifying: (myWorld getNamespace												getEvaluationContext) ifFail: [].						myWorld addOutputText: (result printString).						(result isKindOf: Animation)							ifTrue: [ activeAnimations addLast: result ].								].								((activeAnimations isEmpty) and: [ pendingCommands isEmpty ])					ifTrue: [ isRunning _ false ].				].! !!AliceScript methodsFor: 'executing' stamp: 'jsp 6/7/1999 21:39'!updateTogether: currentTime	"Update this script assuming that all script commands begin simultaneously"	activeAnimations do: [:anim | anim update: currentTime.								(anim isDone) ifTrue: [activeAnimations remove: anim ]].	(activeAnimations isEmpty) ifTrue: [ isRunning _ false ].! !!AliceScript class methodsFor: 'instance creation' stamp: 'jsp 6/8/1999 13:36'!new: type withCommands: commands in: anAliceWorld	"Create a new nameless (lambda) script containing the specified commands"	| newScript |	newScript _ AliceScript new initialize: anAliceWorld.	newScript setScriptType: type.	newScript setCommands: commands.	^ newScript.! !!AliceWorld reorganize!('temporary' makeActorFrom: makeLight makeLight: renderWonderland:)('initialize-reset-release' initialize release reset)('accessing' getActorClassList getCameras getDefaultCamera getLights getNamespace getScene getScheduler getSharedMeshDict getSharedTextureDict getUndoStack)('creating scripts' doInOrder: doTogether:)('creating actors' fixNameFrom: uniqueNameFrom:)('user feedback' addOutputText: reportErrorToUser:)('undoing actions' undo)('drawing' renderWorld:)('private' getTextOutputWindow)!!AliceWorld methodsFor: 'temporary' stamp: 'jsp 6/8/1999 22:52'!makeActorFrom: filename	"Creates a new actor using the specification from the given file"	| aFile words line startSubstr index parent name texture meshFile matrix baseActor newActor protoClass actorClass fileVersion |	myUndoStack closeStack.	words _ (filename findTokens: #.).	((words last) = 'mdl') ifTrue: [			aFile _ (CrLfFileStream readOnlyFileNamed: filename) ascii.			"First see if we need to create a prototype class for this model"			(ActorPrototypeClasses includesKey: (aFile localName))					ifTrue: [ protoClass _ ActorPrototypeClasses at: (aFile localName) ]					ifFalse: [							"Make a new prototype class for this model"							protoClass _ (WonderlandActor newUniqueClassInstVars: ''															classInstVars: '').							ActorPrototypeClasses at: (aFile localName) put: protoClass.							].			"Check what version this mdl file is"			line _ aFile upTo: (Character cr).			line _ aFile upTo: (Character cr).			line _ aFile upTo: (Character cr).			((line truncateTo: 7) = 'version')					ifTrue: [ fileVersion _ 1 ]					ifFalse: [ fileVersion _ 0 ].			[ line _ aFile upTo: (Character cr).			  (aFile atEnd) ifTrue: [ true ]			  			ifFalse: [ words _ line findTokens: '='.								  false ]			] whileFalse: [					"See if we're creating a new object"					(((words size) > 1) and: [ ((words at: 2) beginsWith: ' _MakeObject')											or: [ (words at: 2) beginsWith: ' Alice.MakeObject' ] ])						ifTrue: [						(fileVersion = 0)							ifTrue: [								words _ line findTokens: #,.								parent _ (words at: 2) withBlanksTrimmed.								name _ (((words at: 3) withBlanksTrimmed)													findBetweenSubStrs: '"') at: 1.									]							ifFalse: [								name _ (words at: 1) truncateTo: (((words at: 1) size) - 1).								parent _ ((words at: 3) findTokens: #,) at: 1.									].						"Now pull in the texture to use"						startSubstr _ name , '.SetTexture'.						[(line _ aFile upTo: (Character cr)) beginsWith: startSubstr] whileFalse: [].						texture _ (line findBetweenSubStrs: '"') at: 2.						texture _ (aFile directory pathName), FileDirectory slash, texture.						"Read the composite matrix to use"						startSubstr _ name , '._SetLocalTransformation'.						[(line _ aFile upTo: (Character cr)) beginsWith: startSubstr] whileFalse: [].						matrix _ B3DMatrix4x4 new.						words _ line findBetweenSubStrs: ',()'.						words removeAllSuchThat: [:str | str = ' '].						index _ words size.						4 to: 1 by: -1 do: [:i | 							4 to: 1 by: -1 do: [:j | matrix at: i at: j put: 										((words at: index) withBlanksTrimmed) asNumber.										   		index _ index - 1. ]. ].						1 to: 4 do: [:i | index _ matrix at: i at: 4.									   matrix at: i at: 4 put: (matrix at: 4 at: i).									   matrix at: 4 at: i put: index. ].						matrix a14: (matrix a14 negated).						"Read the mesh file to use"						startSubstr _ 'LoadGeometry'.						[(line _ aFile upTo: (Character cr)) beginsWith: startSubstr] whileFalse: [].						meshFile _ (line findBetweenSubStrs: '"') at: 2.						meshFile _ (aFile directory pathName), FileDirectory slash, meshFile.						"Now build the actor name"						words _ name findTokens: '.'.						name _ words last.						name at: 1 put: ((name at: 1) asLowercase).						"Now build the parent name"						parent _ parent copyReplaceAll: '.' with: ' '.						"Now create the object"						(parent = 'None') ifTrue: [								actorClass _ protoClass newUniqueClassInstVars: '' classInstVars: ''.								baseActor _ actorClass createFor: self.								actorClassList addLast: actorClass.								baseActor setName: name.								baseActor setTexture: texture.								baseActor loadMeshFromFile: meshFile.								baseActor setComposite: matrix.												]  "end base actor creation"										ifFalse: [								actorClass _ WonderlandActor newUniqueClassInstVars: ''																classInstVars: ''.								newActor _ actorClass createFor: self.								actorClassList addLast: actorClass.								newActor setName: name.								parent _ (baseActor getChildNamed: parent).								newActor reparentTo: parent.								newActor becomePart.								newActor setTexture: texture.								newActor loadMeshFromFile: meshFile.								newActor setComposite: matrix.												]. "end new actor with parent"															]. "end MakeObject parsing"											]. "end file parsing"			aFile close.			myUndoStack openStack.			"Ensure that the new actor's name is unique"			name _ self uniqueNameFrom: (baseActor getName).			baseActor setName: name.			myNamespace at: name put: baseActor.			"Add an undo item to undo the creation of this object"			myUndoStack push: (UndoAction new: [ baseActor removeFromScene.													myNamespace removeKey: name ifAbsent: [].												  ] ).			^ baseActor.								]. " end mdl file parsing"! !!AliceWorld methodsFor: 'temporary' stamp: 'jsp 6/8/1999 23:06'!makeLight	"Create a light of the specified type and add it to the Wonderland"	| theLight lightType name |	lightType _ positional.	"Make sure the user gave us a type of light"	[ WonderlandVerifier VerifyLight: lightType ]		ifError: [ :msg :rcvr |			self reportErrorToUser:				'Squeak could not determine the type of light to create because ', msg.			^ nil ].	"The user gave us a valid type type, so proceed"	(lightType = ambient)		ifTrue: [ theLight _ WonderlandAmbientLight createFor: self. ]		ifFalse: [ (lightType = positional)			ifTrue: [ theLight _ WonderlandPositionalLight createFor: self. ]			ifFalse: [ (lightType = directional)				ifTrue: [ theLight _ WonderlandDirectionalLight createFor: self. ]				ifFalse: [ theLight _ WonderlandSpotLight createFor: self. ]					]				].	name _ self uniqueNameFrom: 'light'.	theLight setName: name.	myNamespace at: name put: theLight.	lightList addLast: theLight.	^ theLight.! !!AliceWorld methodsFor: 'temporary' stamp: 'jsp 6/8/1999 23:05'!makeLight: lightType	"Create a light of the specified type and add it to the Wonderland"	| theLight name |	"Make sure the user gave us a type of light"	[ WonderlandVerifier VerifyLight: lightType ]		ifError: [ :msg :rcvr |			self reportErrorToUser:				'Squeak could not determine the type of light to create because ', msg.			^ nil ].	"The user gave us a valid type type, so proceed"	(lightType = ambient)		ifTrue: [ theLight _ WonderlandAmbientLight createFor: self. ]		ifFalse: [ (lightType = positional)			ifTrue: [ theLight _ WonderlandPositionalLight createFor: self. ]			ifFalse: [ (lightType = directional)				ifTrue: [ theLight _ WonderlandDirectionalLight createFor: self. ]				ifFalse: [ theLight _ WonderlandSpotLight createFor: self. ]					]				].	name _ self uniqueNameFrom: 'light'.	theLight setName: name.	myNamespace at: name put: theLight.	lightList addLast: theLight.	^ theLight.! !!AliceWorld methodsFor: 'temporary' stamp: 'jsp 6/8/1999 22:51'!renderWonderland: aRenderer	"Temporary method"	self renderWorld: aRenderer.! !!AliceWorld methodsFor: 'initialize-reset-release' stamp: 'jsp 6/8/1999 23:00'!initialize	"Initialize the Alice world"	| defaultCamera |	"Initialize this Wonderland's shared namespace"	myNamespace _ AliceNamespace new.	myNamespace at: 'world' put: self.	"Create the Wonderland's scheduler"	myScheduler _ AliceScheduler new.	myNamespace at: 'scheduler' put: myScheduler.	"Initialize the list of actor UniClasses"	actorClassList _ OrderedCollection new.	"Initialize the shared mesh and texture directories"	sharedMeshDict _ Dictionary new.	sharedTextureDict _ Dictionary new.	"Create an output window for us to dump text to"	myTextOutputWindow _ AliceTextOutputWindow new.	myTextOutputWindow setText: 'Squeak Alice v2.0.'.	cameraList _ OrderedCollection new.	lightList _ OrderedCollection new.	"-------------------------------"	"Create the undo stack for this Wonderland."	myUndoStack _ WonderlandUndoStack new.	"The scene object is the root of the object tree - all objects in the Wonderland are children (directly or indirectly) of the scene. "	myScene _ WonderlandScene newFor: self.	myNamespace at: 'scene' put: myScene.	"Create the default camera"	defaultCamera _ WonderlandCamera createFor: self.	cameraList addLast: defaultCamera.	myNamespace at: 'camera' put: defaultCamera.	myNamespace at: 'cameraWindow' put: (defaultCamera getMorph).	defaultCamera setName: 'camera'.	myUndoStack reset.! !!AliceWorld methodsFor: 'initialize-reset-release' stamp: 'jsp 6/8/1999 22:46'!release	"This method cleans up the world."	"Clean up any uniclasses we created"	actorClassList do: [:aClass | aClass removeFromSystem ].	"Clean up the output window"	myTextOutputWindow delete.	"Get rid of our cameras"	cameraList do: [:camera | camera release].! !!AliceWorld methodsFor: 'initialize-reset-release' stamp: 'jsp 6/8/1999 17:19'!reset	"Reset this Wonderland"	"Initialize this Wonderland's shared namespace"	myNamespace _ AliceNamespace new.	"Reset the scheduler"	myScheduler reset.	"Reset the shared mesh and texture directories"	sharedMeshDict _ Dictionary new.	sharedTextureDict _ Dictionary new.	"Reset the list of actor uniclasses"	actorClassList do: [:aClass | aClass removeFromSystem ].	actorClassList _ OrderedCollection new.	"Rebuild the namespace"	myNamespace at: 'scheduler' put: myScheduler.	myNamespace at: 'world' put: self.	"Create a new text output window"	myTextOutputWindow setText: 'Reset'.! !!AliceWorld methodsFor: 'accessing' stamp: 'jsp 6/8/1999 22:55'!getActorClassList	"Return the list of actor classes"	^ actorClassList.! !!AliceWorld methodsFor: 'accessing' stamp: 'jsp 6/8/1999 22:39'!getCameras	"Return the list of cameras in the scene"	^ cameraList.! !!AliceWorld methodsFor: 'accessing' stamp: 'jsp 6/8/1999 21:36'!getDefaultCamera	"Return the default camera, which is the camera at the front of the camera list"	^ cameraList first.! !!AliceWorld methodsFor: 'accessing' stamp: 'jsp 6/8/1999 22:39'!getLights	"Return the list of lights in the scene"	^ lightList.! !!AliceWorld methodsFor: 'accessing' stamp: 'jsp 6/8/1999 17:38'!getNamespace	"Return this world's namespace"	^ myNamespace.! !!AliceWorld methodsFor: 'accessing' stamp: 'jsp 6/8/1999 21:37'!getScene	"Return the world's scene"	^ myScene.! !!AliceWorld methodsFor: 'accessing' stamp: 'jsp 6/8/1999 17:56'!getScheduler	"Return this world's scheduler"	^ myScheduler.! !!AliceWorld methodsFor: 'accessing' stamp: 'jsp 6/8/1999 21:47'!getSharedMeshDict	"Return the shared mesh dictionary"	^ sharedMeshDict.! !!AliceWorld methodsFor: 'accessing' stamp: 'jsp 6/8/1999 21:47'!getSharedTextureDict	"Return the shared texture dictionary"	^ sharedTextureDict.! !!AliceWorld methodsFor: 'accessing' stamp: 'jsp 6/8/1999 21:38'!getUndoStack	"Return the world's undo stack"	^ myUndoStack.! !!AliceWorld methodsFor: 'creating scripts' stamp: 'jsp 6/8/1999 13:37'!doInOrder: commands	"Create a nameless inOrder script with the specified commands"	^ AliceScript new: inOrder withCommands: commands in: self.! !!AliceWorld methodsFor: 'creating scripts' stamp: 'jsp 6/8/1999 13:37'!doTogether: commands	"Create a nameless together script with the specified commands"	^ AliceScript new: together withCommands: commands in: self.! !!AliceWorld methodsFor: 'creating actors' stamp: 'jsp 6/8/1999 23:12'!fixNameFrom: aString	"Fix the name to be a valid Smalltalk name (e.g., so that we can compile it as an inst var and accessor message)"	| aName |	aName _ aString select: [:c | c isAlphaNumeric].	"If the name is empty use 'unknown'"	aName isEmpty ifTrue:[aName _ 'unknown'].	"Make sure the first letter is lowercase"	aName first isUppercase		ifTrue: [aName _ (aName first asLowercase asString) ,								(aName copyFrom: 2 to: aName size) ].	"Make sure the first letter is a letter, otherwise use 'a' as the first letter"	aName first isLetter ifFalse: [aName _ 'a' , aName].	^ aName.! !!AliceWorld methodsFor: 'creating actors' stamp: 'jsp 6/8/1999 23:12'!uniqueNameFrom: aString	"If aName is unique to this world's namespace, returns that name. Otherwise creates a unique variant and returns that."	| index aName |	aName _ self fixNameFrom: aString.	(myNamespace includesKey: aName)			ifFalse: [ ^ aName ]			ifTrue: [						index _ 2.						[ myNamespace includesKey: (aName , (index asString)) ]							whileTrue: [ index _ index + 1 ].						^ aName , (index asString).					].! !!AliceWorld methodsFor: 'user feedback' stamp: 'jsp 6/8/1999 17:20'!addOutputText: thisText	"Appends the given text to the Alice output window"	myTextOutputWindow addTextOnNewLine: thisText.! !!AliceWorld methodsFor: 'user feedback' stamp: 'jsp 6/8/1999 21:52'!reportErrorToUser: errorString	"When any object in an Alice World discovers an error it creates an error report and then calls this method to display the error to the user."	| errWin tm |	errWin _ SystemWindowWithButton labelled: 'Ooops'.	errWin openInWorldExtent: 400@100.	errWin color: (Color white).	tm _ TextMorph new.	tm initialize.	errWin addMorph: tm.	tm color: (Color red).	tm contents: errorString wrappedTo: 380.	tm position: ((errWin position) + (10@20)).	tm lock.	errWin height: (tm height) + 30.	errorSound play.! !!AliceWorld methodsFor: 'undoing actions' stamp: 'jsp 6/8/1999 21:52'!undo	"Undo the last action the user performed in the Wonderland.  This pulls a block context off the animation stack and executes it."	myUndoStack popAndUndo.! !!AliceWorld methodsFor: 'drawing' stamp: 'jsp 6/8/1999 21:48'!renderWorld: aRenderer	"Tell all the objects in the World to render themselves."	myScene renderOn: aRenderer.! !!AliceWorld methodsFor: 'private' stamp: 'jsp 6/8/1999 22:42'!getTextOutputWindow	"Returns the current text output window"	^ myTextOutputWindow.! !!AliceWorld class methodsFor: 'instance creation' stamp: 'jsp 6/7/1999 22:27'!new   "AliceWorld new" 	"Create and initialize a new AliceWorld."	B3DPrimitiveEngine isAvailable ifFalse: [	(self confirm: 'WARNING: This Squeak does not have real 3D support.Opening a Wonderland will EXTREMELY time consuming.Are you sure you want to do this?(NO is probably the right answer :-)') ifFalse: [^ self]].	Display depth < 8 ifTrue:		[(self confirm: 'The display depth should be set to at least 8 bit.Shall I do this now for you?') ifTrue: [Display newDepth: 8]].	^ super new initialize.! !!AliceWorld class methodsFor: 'class initialization' stamp: 'jsp 6/7/1999 22:17'!initialize	"Initialize the AliceWorld class by creating the ActorPrototypeClasses collection"	ActorPrototypeClasses _ Dictionary new.! !!AliceWorld class methodsFor: 'actor prototype mgmt' stamp: 'jsp 6/7/1999 22:18'!removeActorPrototypesFromSystem	"Clean out all the actor prototypes - this involves removing those classes from the Smalltalk dictionary"	ActorPrototypeClasses do: [:aClass | aClass removeFromSystem ].	ActorPrototypeClasses _ Dictionary new.! !AliceScheduler removeSelector: #incrementTimeBy:!AliceScript removeSelector: #initialize!AliceScript removeSelector: #run!AliceScript removeSelector: #activate!AliceScript class removeSelector: #initialize!AliceScript class removeSelector: #new:withCommands:!AliceWorld initialize!Smalltalk removeClassNamed: #AliceTextOutputWindow!